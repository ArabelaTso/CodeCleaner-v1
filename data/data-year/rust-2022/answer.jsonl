{"hexsha": "ed945dd1c6e72f8d7d2818723f8771328de00955", "ext": "rs", "lang": "Rust", "content": "fn state_control() {\n    let store = MemoryBlockstore::new();\n    let v = VM::new(&store);\n    let addr1 = Address::new_id(1000);\n    let addr2 = Address::new_id(2222);\n\n    // set actor\n    let a1 = actor(*ACCOUNT_ACTOR_CODE_ID, make_builtin(b\"a1-head\"), 42, TokenAmount::from(10u8));\n    v.set_actor(addr1, a1.clone());\n    let out = v.get_actor(addr1).unwrap();\n    assert_eq!(out, a1);\n    let check = v.checkpoint();\n\n    let a2 = actor(*PAYCH_ACTOR_CODE_ID, make_builtin(b\"a2-head\"), 88, TokenAmount::from(1u8));\n    v.set_actor(addr2, a2.clone());\n    assert_eq!(v.get_actor(addr2).unwrap(), a2);\n    // rollback removes a2 but not a1\n    v.rollback(check);\n\n    // a2 is gone\n    assert_eq!(None, v.get_actor(addr2));\n    assert_eq!(v.get_actor(addr1).unwrap(), a1);\n}", "item_id": 0, "repo": "filecoin-project/builtin-actors", "file": "test_vm/tests/test_vm_test.rs", "last_update_at": "2022-03-24T03:31:10+00:00"}
{"hexsha": "7bf327281bbd0348593ce16bd9c8d59140cb577d", "ext": "rs", "lang": "Rust", "content": "fn set_and_retrieve_cached_onionskin() {\n    let anim = create_animation();\n\n    anim.perform_edits(vec![AnimationEdit::AddNewLayer(24)]);\n\n    let layer           = anim.get_layer_with_id(24).unwrap();\n    let cache           = layer.get_canvas_cache_at_time(Duration::from_millis(2000));\n\n    cache.store(CacheType::OnionSkinLayer, Arc::new(vec![Draw::Path(PathOp::NewPath), Draw::Fill]));\n\n    let cache           = layer.get_canvas_cache_at_time(Duration::from_millis(2000));\n    let cached_drawing  = cache.retrieve(CacheType::OnionSkinLayer);\n\n    assert!(cached_drawing == Some(Arc::new(vec![Draw::Path(PathOp::NewPath), Draw::Fill])));\n}", "item_id": 0, "repo": "Logicalshift/flowbetween", "file": "animation/src/storage/tests/caching.rs", "last_update_at": "2022-02-21T09:04:10+00:00"}
{"hexsha": "4f8443be259d19e55b468b280badc18a5eca7b9d", "ext": "rs", "lang": "Rust", "content": "fn test_matches_dft() {\n        let n = 4;\n\n        for len in 1..20 {\n            let dft_instance = Dft::new(len, FftDirection::Forward);\n            assert_eq!(\n                dft_instance.len(),\n                len,\n                \"Dft instance reported incorrect length\"\n            );\n\n            let input = random_signal(len * n);\n            let mut expected_output = input.clone();\n\n            // Compute the control data using our simplified Dft definition\n            for (input_chunk, output_chunk) in\n                input.chunks(len).zip(expected_output.chunks_mut(len))\n            {\n                dft(input_chunk, output_chunk);\n            }\n\n            // test process()\n            {\n                let mut inplace_buffer = input.clone();\n\n                dft_instance.process(&mut inplace_buffer);\n\n                assert!(\n                    compare_vectors(&expected_output, &inplace_buffer),\n                    \"process() failed, length = {}\",\n                    len\n                );\n            }\n\n            // test process_with_scratch()\n            {\n                let mut inplace_with_scratch_buffer = input.clone();\n                let mut inplace_scratch =\n                    vec![Zero::zero(); dft_instance.get_inplace_scratch_len()];\n\n                dft_instance\n                    .process_with_scratch(&mut inplace_with_scratch_buffer, &mut inplace_scratch);\n\n                assert!(\n                    compare_vectors(&expected_output, &inplace_with_scratch_buffer),\n                    \"process_inplace() failed, length = {}\",\n                    len\n                );\n\n                // one more thing: make sure that the Dft algorithm even works with dirty scratch space\n                for item in inplace_scratch.iter_mut() {\n                    *item = Complex::new(100.0, 100.0);\n                }\n                inplace_with_scratch_buffer.copy_from_slice(&input);\n\n                dft_instance\n                    .process_with_scratch(&mut inplace_with_scratch_buffer, &mut inplace_scratch);\n\n                assert!(\n                    compare_vectors(&expected_output, &inplace_with_scratch_buffer),\n                    \"process_with_scratch() failed the 'dirty scratch' test for len = {}\",\n                    len\n                );\n            }\n\n            // test process_outofplace_with_scratch\n            {\n                let mut outofplace_input = input.clone();\n                let mut outofplace_output = expected_output.clone();\n\n                dft_instance.process_outofplace_with_scratch(\n                    &mut outofplace_input,\n                    &mut outofplace_output,\n                    &mut [],\n                );\n\n                assert!(\n                    compare_vectors(&expected_output, &outofplace_output),\n                    \"process_outofplace_with_scratch() failed, length = {}\",\n                    len\n                );\n            }\n        }\n\n        //verify that it doesn't crash or infinite loop if we have a length of 0\n        let zero_dft = Dft::new(0, FftDirection::Forward);\n        let mut zero_input: Vec<Complex<f32>> = Vec::new();\n        let mut zero_output: Vec<Complex<f32>> = Vec::new();\n        let mut zero_scratch: Vec<Complex<f32>> = Vec::new();\n\n        zero_dft.process(&mut zero_input);\n        zero_dft.process_with_scratch(&mut zero_input, &mut zero_scratch);\n        zero_dft.process_outofplace_with_scratch(\n            &mut zero_input,\n            &mut zero_output,\n            &mut zero_scratch,\n        );\n    }", "item_id": 0, "repo": "songww/RustFFT", "file": "src/algorithm/dft.rs", "last_update_at": "2022-03-31T17:43:32+00:00"}
{"hexsha": "d4c044b4464d1846dd4a853c231d2edd55e48d41", "ext": "rs", "lang": "Rust", "content": "fn encode_bit_pattern_examples() {\n        assert_eq!(encode(0x0f0f).as_ref(), &[0x9E, 0x78]);\n        assert_eq!(\n            encode(0x0f0f_f0f0).as_ref(),\n            &[0xF0, 0x3C, 0xFC, 0xC3, 0x03]\n        );\n        assert_eq!(\n            encode(0x0f0f_f0f0_0f0f).as_ref(),\n            &[0xFC, 0x0F, 0x0F, 0xF0, 0xF0, 0x0F, 0x0F]\n        );\n        assert_eq!(\n            encode(0x0f0f_f0f0_0f0f_f0f0).as_ref(),\n            &[0xFF, 0xE0, 0xE1, 0x1F, 0x1E, 0xE0, 0xE1, 0x1F, 0x1E]\n        );\n        //\n        assert_eq!(encode(-0x0f0f).as_ref(), &[0x9D, 0x78]);\n        assert_eq!(\n            encode(-0x0f0f_f0f0).as_ref(),\n            &[0xF7, 0x3B, 0xFC, 0xC3, 0x03]\n        );\n        assert_eq!(\n            encode(-0x0f0f_f0f0_0f0f).as_ref(),\n            &[0xFD, 0x0E, 0x0F, 0xF0, 0xF0, 0x0F, 0x0F]\n        );\n        assert_eq!(\n            encode(-0x0f0f_f0f0_0f0f_f0f0).as_ref(),\n            &[0xFF, 0xDF, 0xE1, 0x1F, 0x1E, 0xE0, 0xE1, 0x1F, 0x1E]\n        );\n    }", "item_id": 0, "repo": "aki-akaguma/vu64", "file": "src/signed.rs", "last_update_at": "2022-02-02T10:25:49+00:00"}
{"hexsha": "dbd6eabc87f2d2be8b8b8bc7d2a69e80cc7ba8ad", "ext": "rs", "lang": "Rust", "content": "pub fn unpack_sect4_body<R: Read>(f: &mut R, body_size: usize) -> Result<SectionBody, ParseError> {\n    let mut buf = [0; 4]; // octet 6-9\n    f.read_exact(&mut buf[..])?;\n\n    let len_extra = body_size - buf.len();\n    let mut templated = vec![0; len_extra];\n    f.read_exact(&mut templated[..])?;\n\n    let prod_tmpl_num = read_as!(u16, buf, 2);\n\n    Ok(SectionBody::Section4(ProdDefinition {\n        num_coordinates: read_as!(u16, buf, 0),\n        prod_tmpl_num,\n        templated: templated.into_boxed_slice(),\n        template_supported: SUPPORTED_PROD_DEF_TEMPLATE_NUMBERS.contains(&prod_tmpl_num),\n    }))\n}", "item_id": 4, "repo": "Quba1/grib-rs", "file": "src/reader.rs", "last_update_at": "2022-03-17T20:32:52+00:00"}
{"hexsha": "5fb6127847771f22d3c822eae64d7f4a54547e02", "ext": "rs", "lang": "Rust", "content": "fn lore() -> String {\n    let mut ret = String::from(\"Barkeep:\");\n    ret = format!(\"{} Angry Karen says that the Rusty Dragon killed her children.\\nWe all know that's a lie...\", ret);\n    ret\n}", "item_id": 10, "repo": "MaulingMonkey/rust-mini-games", "file": "text-games/lord/src/main.rs", "last_update_at": "2022-03-17T06:21:31+00:00"}
{"hexsha": "81fe1b970d24becea38ddd9b06ae49db5bcded3e", "ext": "rs", "lang": "Rust", "content": "fn bench_disjoint_set_forest(b: &mut test::Bencher) {\n        let num_nodes = 500;\n        let num_edges = 20 * num_nodes;\n\n        let mut rng: StdRng = SeedableRng::seed_from_u64(1);\n        let uniform = Uniform::new(0, num_nodes);\n\n        let mut forest = DisjointSetForest::new(num_nodes);\n        b.iter(|| {\n            let mut count = 0;\n            while count < num_edges {\n                let u = uniform.sample(&mut rng);\n                let v = uniform.sample(&mut rng);\n                forest.union(u, v);\n                count += 1;\n            }\n            test::black_box(forest.num_trees());\n        });\n    }", "item_id": 2, "repo": "beltegeuse/imageproc", "file": "src/union_find.rs", "last_update_at": "2022-03-30T17:53:02+00:00"}
{"hexsha": "27f1158840e2f4f0bfff5cf11627ec83120e8c20", "ext": "rs", "lang": "Rust", "content": "fn test_vec_binary_tree_basic() {\n        let mut tree = VecBinaryTree::new();\n        let mut cursor = tree.cursor_mut();\n        cursor.insert_as_root(0);\n        cursor.insert_as_left(1);\n        cursor.insert_as_right(2);\n        cursor.move_right();\n        cursor.insert_as_left(3);\n        cursor.move_left();\n        cursor.insert_as_left(4);\n        cursor.insert_as_right(5);\n        assert_eq!(\n            tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),\n            [0, 1, 2, 3, 4, 5]\n        );\n        let mut cursor = tree.cursor_mut();\n        let right = cursor.take_right().unwrap();\n        assert_eq!(\n            tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),\n            [0, 1]\n        );\n        assert_eq!(\n            right.cursor().in_order_iter().copied().collect::<Vec<_>>(),\n            [2, 3, 4, 5]\n        );\n        let mut cursor = tree.cursor_mut();\n        cursor.move_left();\n        cursor.append_left(right);\n        assert_eq!(\n            tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),\n            [0, 1, 2, 3, 4, 5]\n        );\n        let mut cursor = tree.cursor_mut();\n        cursor.insert_as_right(6);\n        assert_eq!(\n            tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),\n            [0, 1, 6, 2, 3, 4, 5]\n        );\n        assert_eq!(\n            tree.cursor().pre_order_iter().copied().collect::<Vec<_>>(),\n            [0, 1, 2, 3, 4, 5, 6]\n        );\n        assert_eq!(\n            tree.cursor().mid_order_iter().copied().collect::<Vec<_>>(),\n            [4, 3, 5, 2, 1, 0, 6]\n        );\n        assert_eq!(\n            tree.cursor().post_order_iter().copied().collect::<Vec<_>>(),\n            [4, 5, 3, 2, 1, 6, 0]\n        );\n        let mut cursor = tree.cursor_mut();\n        cursor.move_right();\n        assert_eq!(\n            cursor\n                .cursor()\n                .post_order_iter()\n                .copied()\n                .collect::<Vec<_>>(),\n            [6]\n        );\n    }", "item_id": 0, "repo": "Nouzan/algo-rs", "file": "src/ch4/binary_tree/vec_binary_tree/mod.rs", "last_update_at": "2022-01-17T06:40:00+00:00"}
{"hexsha": "ed55cd606c815fe8b36c6528988c6e1f75011288", "ext": "rs", "lang": "Rust", "content": "fn clk_fro_hf_96mhz() {\n        let dp = unsafe { pac::Peripherals::steal() };\n        let syscon = dp.SYSCON.freeze(Config::frohf_96mhz());\n        assert_eq!(unwrap!(syscon.get_main_clock_freq()), 96_000_000.Hz());\n    }", "item_id": 2, "repo": "lpc-rs/lpc546xx-hal", "file": "self-tests/tests/clocking-api.rs", "last_update_at": "2022-01-21T12:10:20+00:00"}
{"hexsha": "8166c572bfaef0679b0b7305c6ec91d4344aeac1", "ext": "rs", "lang": "Rust", "content": "fn run_handler_no_request<Resp, F>(f: F) -> Result<Resp>\nwhere\n    F: FnOnce(Sandbox) -> Result<Resp>,\n{\n    let sandbox = Sandbox::new().context(SandboxCreation)?;\n    let resp = f(sandbox)?;\n    Ok(resp)\n}", "item_id": 2, "repo": "chazkiker2/rust-playground", "file": "ui/src/main.rs", "last_update_at": "2022-03-30T07:25:56+00:00"}
{"hexsha": "85260655dd0d5a7f12fcbff8f77b1a01315ba1f1", "ext": "rs", "lang": "Rust", "content": "fn insert() {\n    //normal\n    let t = vec![4, 1, 3, 2, 16, 9, 10, 14, 8, 7];\n    let mut heap = max_heap::BinaryHeap::new(t);\n    // data layout:\n    //   vec![16, 14, 10, 8, 7, 9, 3, 2, 4, 1];\n    heap.insert(100);\n    let data = heap.keys_slice();\n    assert_eq!(data, vec![100, 16, 10, 8, 14, 9, 3, 2, 4, 1, 7])\n}", "item_id": 4, "repo": "zg9uagfv/Algorithm", "file": "tests/test_common_heap.rs", "last_update_at": "2022-03-27T06:39:06+00:00"}
{"hexsha": "c30a04583fd48d49e401243784c51970de5a05bc", "ext": "rs", "lang": "Rust", "content": "fn unwatch_dir(path: &std::path::Path) {\n    let mut config = Config::load();\n    let path = path\n        .to_str()\n        .expect(\"The provided path is not valid unicode\")\n        .to_string();\n\n    config.set_unwatch(path);\n    config.save();\n}", "item_id": 2, "repo": "darti/dura", "file": "src/main.rs", "last_update_at": "2022-03-31T11:50:13+00:00"}
{"hexsha": "8145eeaa6e65368de7c0488d377cd4186ba4bedc", "ext": "rs", "lang": "Rust", "content": "pub fn get_property_values(\n        conn: &SqliteConnection,\n        root_values: Vec<MfgBatchPropertyValue>,\n    ) -> Result<Vec<PropertyValue>, MfgBatchStoreError> {\n        let mut definitions = Vec::new();\n\n        for root_value in root_values {\n            let children = mfg_batch_property_value::table\n                .select(mfg_batch_property_value::all_columns)\n                .filter(mfg_batch_property_value::parent_property.eq(&root_value.parent_property))\n                .load(conn)?;\n\n            if children.is_empty() {\n                definitions.push(PropertyValue::from(root_value));\n            } else {\n                definitions.push(PropertyValue::from((\n                    root_value,\n                    get_property_values(conn, children)?,\n                )));\n            }\n        }\n\n        Ok(definitions)\n    }", "item_id": 3, "repo": "kjf64c/grid", "file": "sdk/src/mfg_batch/store/diesel/operations/list_mfg_batches.rs", "last_update_at": "2022-02-17T21:18:34+00:00"}
{"hexsha": "bc25520c5512d3a8495993761bffa37382061d77", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout___darwin_mcontext64_full() {\n    assert_eq!(\n        ::std::mem::size_of::<__darwin_mcontext64_full>(),\n        744usize,\n        concat!(\"Size of: \", stringify!(__darwin_mcontext64_full))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<__darwin_mcontext64_full>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(__darwin_mcontext64_full))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__es as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext64_full),\n            \"::\",\n            stringify!(__es)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__ss as *const _ as usize },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext64_full),\n            \"::\",\n            stringify!(__ss)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__fs as *const _ as usize },\n        216usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext64_full),\n            \"::\",\n            stringify!(__fs)\n        )\n    );\n}", "item_id": 65, "repo": "Ewpratten/raylib-rs", "file": "raylib-sys/bindings_osx.rs", "last_update_at": "2022-03-27T23:14:25+00:00"}
{"hexsha": "75feeb57a15caec75223b753a9d57495a352e3ad", "ext": "rs", "lang": "Rust", "content": "fn get_ddn_status_not_found_works() {\n    let contract = make_contract();\n    let p2p_id = String::from(\"test_p2p_id\");\n\n    // Should return an error if not found\n    assert_eq!(contract.get_ddn_status(p2p_id), Err(Error::DDNNotFound));\n}", "item_id": 32, "repo": "Cerebellum-Network/ddc-smart-contract", "file": "src/ddc/tests.rs", "last_update_at": "2022-01-24T18:05:10+00:00"}
{"hexsha": "0cbf3fa7da9775e62d2210a96cfe1b2bfa3a5381", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_ThreadExceptionFrameA64 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < ThreadExceptionFrameA64 > ( ) , 120usize , concat ! ( \"Size of: \" , stringify ! ( ThreadExceptionFrameA64 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < ThreadExceptionFrameA64 > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( ThreadExceptionFrameA64 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . cpu_gprs as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( cpu_gprs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . lr as * const _ as usize } , 72usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( lr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . sp as * const _ as usize } , 80usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( sp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . elr_el1 as * const _ as usize } , 88usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( elr_el1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . pstate as * const _ as usize } , 96usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( pstate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . afsr0 as * const _ as usize } , 100usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( afsr0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . afsr1 as * const _ as usize } , 104usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( afsr1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . esr as * const _ as usize } , 108usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( esr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . far as * const _ as usize } , 112usize , concat ! ( \"Offset of field: \" , stringify ! ( ThreadExceptionFrameA64 ) , \"::\" , stringify ! ( far ) ) ) ; }", "item_id": 12, "repo": "XorTroll/libnx-Rust", "file": "bindgen/libnx.rs", "last_update_at": "2022-02-18T12:36:44+00:00"}
{"hexsha": "d298a20f78a7cd8b9fd933bc3d999cb4a2f685ba", "ext": "rs", "lang": "Rust", "content": "fn make_column(\n    py: Python,\n    children: &PyAny,\n    spacing: Option<u16>,\n    padding: Option<u16>,\n    width: Option<&WrappedLength>,\n    height: Option<&WrappedLength>,\n    max_width: Option<u32>,\n    max_height: Option<u32>,\n    align_items: Option<&WrappedAlign>,\n) -> PyResult<WrappedWidgetBuilder> {\n    let children = children\n        .iter()?\n        .filter_map(|child| match child {\n            Ok(child) => match child.is_none() {\n                false => match child.extract() {\n                    Ok(WrappedWidgetBuilder(widget)) => Some(widget),\n                    Err(err) => {\n                        err.print(py);\n                        None\n                    },\n                },\n                true => None,\n            },\n            Err(err) => {\n                err.print(py);\n                None\n            },\n        })\n        .collect();\n    let el = ColumnBuilder {\n        children,\n        spacing,\n        padding,\n        width: width.map(|o| o.0),\n        height: height.map(|o| o.0),\n        max_width,\n        max_height,\n        align_items: align_items.map(|o| o.0),\n    };\n    Ok(el.into())\n}", "item_id": 0, "repo": "Kijewski/pyiced", "file": "src/widgets/column.rs", "last_update_at": "2022-03-08T10:33:11+00:00"}
{"hexsha": "51ad805afa4fe2a89e9386dbe4e9973843109ec0", "ext": "rs", "lang": "Rust", "content": "fn gas_add_fixed_range() {\n        assert_eq!(\n            Gas::Range { min: 1, max: 3 },\n            Gas::Fixed(3) + Gas::Range { min: 1, max: 2 }\n        );\n\n        assert_eq!(\n            Gas::Range { min: 1, max: 5 },\n            Gas::Fixed(3) + Gas::Range { min: 1, max: 5 }\n        );\n\n        let mut gas = Gas::Fixed(3);\n        gas += Gas::Range { min: 1, max: 2 };\n        assert_eq!(Gas::Range { min: 1, max: 3 }, gas);\n\n        let mut gas = Gas::Fixed(3);\n        gas += Gas::Range { min: 1, max: 5 };\n        assert_eq!(Gas::Range { min: 1, max: 5 }, gas);\n    }", "item_id": 2, "repo": "kobby-pentangeli/svm", "file": "crates/gas/src/gas.rs", "last_update_at": "2022-01-31T14:56:48+00:00"}
{"hexsha": "3e809b385f9b56e557955c72322fdf9b13b17b3e", "ext": "rs", "lang": "Rust", "content": "fn lexer_text_unit_literal_accepted() {\n        let mut lexer = Lexer::from_memory(\"X\", Source::Unknown);\n        let mut lexer = WordLexer {\n            lexer: &mut lexer,\n            context: WordContext::Word,\n        };\n        let mut called = false;\n        let result = block_on(lexer.text_unit(\n            |c| {\n                called = true;\n                assert_eq!(c, 'X');\n                false\n            },\n            |c| panic!(\"unexpected call to is_escapable({:?})\", c),\n        ))\n        .unwrap()\n        .unwrap();\n        assert!(called);\n        if let Literal(c) = result {\n            assert_eq!(c, 'X');\n        } else {\n            panic!(\"unexpected result {:?}\", result);\n        }\n\n        assert_eq!(block_on(lexer.peek_char()), Ok(None));\n    }", "item_id": 0, "repo": "magicant/yash-rs", "file": "yash-syntax/src/parser/lex/text.rs", "last_update_at": "2022-03-24T10:45:57+00:00"}
{"hexsha": "618d60fa67d4afe25f183f31ec8cd5308ae7c79d", "ext": "rs", "lang": "Rust", "content": "fn build_context(program: &Bytes) -> Result<DebugContext, String> {\n    use addr2line::object::{Object, ObjectSection};\n\n    // Adapted from https://github.com/gimli-rs/addr2line/blob/fc2de9f47ae513f5a54448167b476ff50f07dca6/src/lib.rs#L87-L148\n    // for working with gimli::EndianArcSlice type\n    let file = addr2line::object::File::parse(program.as_ref())\n        .map_err(|e| format!(\"object parsing error: {}\", e))?;\n\n    let dwarf = gimli::Dwarf::load(|id| {\n        let data = file\n            .section_by_name(id.name())\n            .and_then(|section| section.uncompressed_data().ok())\n            .unwrap_or(Cow::Borrowed(&[]));\n        Ok(gimli::EndianArcSlice::new(\n            Arc::from(&*data),\n            gimli::RunTimeEndian::Little,\n        ))\n    })\n    .map_err(|e: gimli::Error| format!(\"dwarf load error: {}\", e))?;\n\n    let addr_context = Addr2LineContext::from_dwarf(dwarf)\n        .map_err(|e| format!(\"context creation error: {}\", e))?;\n\n    let debug_frame_section = file\n        .section_by_name(gimli::SectionId::DebugFrame.name())\n        .and_then(|s| s.uncompressed_data().ok())\n        .ok_or_else(|| \"Provided binary is missing .debug_frame section!\".to_string())?;\n    let debug_frame_reader = Addr2LineEndianReader::new(\n        Arc::from(&*debug_frame_section),\n        gimli::RunTimeEndian::Little,\n    );\n\n    Ok(DebugContext {\n        addr_context,\n        debug_frame: debug_frame_reader.into(),\n    })\n}", "item_id": 3, "repo": "xxuejie/ckb-vm-signal-profiler", "file": "src/lib.rs", "last_update_at": "2022-03-29T03:07:22+00:00"}
{"hexsha": "fc93fb4e66d6b5b349a44ebf4b801f4fa091f217", "ext": "rs", "lang": "Rust", "content": "fn unexpected_directive_invalid() {\n    let input = include_str!(\"relay_resolvers/fixtures/unexpected-directive.invalid.graphql\");\n    let expected = include_str!(\"relay_resolvers/fixtures/unexpected-directive.invalid.expected\");\n    test_fixture(transform_fixture, \"unexpected-directive.invalid.graphql\", \"relay_resolvers/fixtures/unexpected-directive.invalid.expected\", input, expected);\n}", "item_id": 7, "repo": "morrys/relay", "file": "compiler/crates/relay-transforms/tests/relay_resolvers_test.rs", "last_update_at": "2022-03-31T10:17:36+00:00"}
{"hexsha": "fcea69fb39f98bf184fecd0f9c6a3e9e2e891b0a", "ext": "rs", "lang": "Rust", "content": "pub fn get_replay_addresses(\n    dwarf: &Dwarf<EndianSlice<RunTimeEndian>>,\n) -> Result<ObjectLocationMap> {\n    let mut objects: ObjectLocationMap = HashMap::new();\n    // Iterate over the compilation units.\n    let mut iter = dwarf.units();\n    while let Some(header) = iter.next()? {\n        let unit = dwarf.unit(header)?;\n        let entries = parser::parse_variable_entries(&dwarf, &unit, &header)?;\n        for entry in entries {\n            objects.insert(entry.name, entry.address);\n        }\n    }\n    Ok(objects)\n}", "item_id": 1, "repo": "markhakansson/rauk", "file": "src/measure/dwarf/mod.rs", "last_update_at": "2022-03-18T08:46:46+00:00"}
{"hexsha": "436c8df3a12786557a9b473da80f4bf93dd92cdb", "ext": "rs", "lang": "Rust", "content": "pub fn init<Traits: TimerInstance>() {\n    let tcfg = &Traits::TICKLESS_CFG;\n\n    // Safety: No context switching during boot\n    let tstate = unsafe { &mut *Traits::tickless_state() };\n\n    tstate.reset(tcfg, Traits::time_lo() as u32);\n}", "item_id": 2, "repo": "r3-os/r3", "file": "src/r3_port_riscv/src/sbi_timer/imp.rs", "last_update_at": "2022-03-22T01:13:51+00:00"}
{"hexsha": "83fb55ac55ad311397f4a8d72e4bfbae1bff2476", "ext": "rs", "lang": "Rust", "content": "fn port_midi_can_get_max_event_size() {\n        // open clients and ports\n        let c = open_test_client(\"port_midi_cglc\");\n        let mut out_p = c.register_port(\"op\", MidiOut::default()).unwrap();\n\n        // set callback routine\n        let process_callback = move |_: &Client, ps: &ProcessScope| -> Control {\n            let out_p = out_p.writer(ps);\n            PMCGMES_MAX_EVENT_SIZE.fetch_add(out_p.max_event_size(), Ordering::Relaxed);\n            Control::Continue\n        };\n\n        // activate\n        let ac = c\n            .activate_async((), ClosureProcessHandler::new(process_callback))\n            .unwrap();\n\n        // check correctness\n        assert!(PMCGMES_MAX_EVENT_SIZE.load(Ordering::Relaxed) > 0);\n        ac.deactivate().unwrap();\n    }", "item_id": 1, "repo": "Be-ing/rust-jack", "file": "src/port/midi.rs", "last_update_at": "2022-03-25T10:01:34+00:00"}
{"hexsha": "9e7bd9389b966dbd7dee5731f391c7dbf7ed5188", "ext": "rs", "lang": "Rust", "content": "fn draw_border(settings: &Settings, cursor: &TerminalCursor) {\n    let room = &settings.room;\n    let chars = &settings.chars;\n\n    let draw_horizontal = |y: u16| {\n        let border_char = &chars.room.border_horizontal;\n        let printable = printable_maybe_repeat(\n            border_char,\n            Some(settings.room.width as usize),\n        );\n        cursor.goto(0, y).unwrap();\n        print!(\"{}\", printable);\n    };\n    let draw_vertical = |x: u16| {\n        let border_char = &chars.room.border_vertical;\n        let printable = printable_maybe_repeat(border_char, None);\n        for y in 0 .. room.height {\n            cursor.goto(x, y).unwrap();\n            print!(\"{}\", printable);\n        }\n    };\n\n    let right = room.width - 1;\n    let bottom = room.height - 1;\n    draw_horizontal(0);\n    draw_horizontal(bottom);\n    draw_vertical(0);\n    draw_vertical(right);\n    // Draw corners\n    let corner_printable =\n        printable_maybe_repeat(&chars.room.border_corner, None);\n    cursor.goto(0, 0).unwrap();\n    print!(\"{}\", corner_printable);\n    cursor.goto(right, 0).unwrap();\n    print!(\"{}\", corner_printable);\n    cursor.goto(0, bottom).unwrap();\n    print!(\"{}\", corner_printable);\n    cursor.goto(right, bottom).unwrap();\n    print!(\"{}\", corner_printable);\n}", "item_id": 2, "repo": "Noah2610/pong-cli", "file": "src/systems/draw_room.rs", "last_update_at": "2022-03-19T10:57:17+00:00"}
{"hexsha": "cbcf5eccfb6cbebf5ac428959796b460a16c2acd", "ext": "rs", "lang": "Rust", "content": "fn test_from_into_diff() {\n    let service: Service = service();\n\n    let diff: DiffService = service.clone().into_diff().unwrap();\n    let new: Service = Service::from_diff(diff.clone()).unwrap();\n    assert_eq!(new, service);\n\n    let ser: String = diff.to_json().unwrap();\n    let de: DiffService = DiffService::from_json(&ser).unwrap();\n    assert_eq!(diff, de);\n    let from: Service = Service::from_diff(de).unwrap();\n    assert_eq!(from, service);\n  }", "item_id": 7, "repo": "Dr-Electron/identity.rs", "file": "identity-did/src/diff/diff_service.rs", "last_update_at": "2022-02-02T16:32:22+00:00"}
{"hexsha": "ad6448553bad6a18e0be3c2fe80008aa9d54e53c", "ext": "rs", "lang": "Rust", "content": "async fn do_not_read_network_from_legacy_storage_and_delete_file() {\n        // Possible contents of a file generated from KnownEssStore, with networks foo and bar with\n        // passwords foobar and password respecitively. Network foo should not be read into new\n        // saved network manager because the password is too short for a valid network password.\n        let contents = b\"[{\\\"ssid\\\":[102,111,111],\\\"password\\\":[102,111,111,98,97,114]},\n            {\\\"ssid\\\":[98,97,114],\\\"password\\\":[112, 97, 115, 115, 119, 111, 114, 100]}]\";\n        let temp_dir = TempDir::new().expect(\"failed to create temporary directory\");\n        let path = temp_dir.path().join(\"networks.json\");\n        let mut file = fs::File::create(&path).expect(\"failed to open file for writing\");\n\n        assert_eq!(file.write(contents).expect(\"Failed to write to file\"), contents.len());\n        file.flush().expect(\"failed to flush contents of file\");\n\n        let stash_id = \"read_network_from_legacy_storage\";\n        let saved_networks = SavedNetworksManager::new_with_stash_or_paths(\n            stash_id,\n            &path,\n            create_mock_cobalt_sender(),\n        )\n        .await\n        .expect(\"failed to create saved networks store\");\n\n        // Network should not be read. The backing file should be deleted.\n        assert_eq!(0, saved_networks.known_network_count().await);\n        assert!(!path.exists());\n    }", "item_id": 24, "repo": "fabio-d/fuchsia-stardock", "file": "src/connectivity/wlan/wlancfg/src/config_management/config_manager.rs", "last_update_at": "2022-01-21T20:14:17+00:00"}
{"hexsha": "884bae434a424fe9c10f1165f1c91cef6c285d03", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn test_chunk_compression_rw(compression: compression::CompressionType) {\n    let array_meta = ArrayMetadata::new(\n        smallvec![10, 10, 10],\n        smallvec![5, 5, 5],\n        i32::ZARR_TYPE,\n        compression,\n    );\n    let chunk_data: Vec<i32> = (0..125_i32).collect();\n    let chunk_in = SliceDataChunk::new(smallvec![0, 0, 0], &chunk_data);\n\n    let mut inner: Vec<u8> = Vec::new();\n\n    <DefaultChunk as DefaultChunkWriter<i32, _, _>>::write_chunk(\n        &mut inner,\n        &array_meta,\n        &chunk_in,\n    )\n    .expect(\"write_chunk failed\");\n\n    let chunk_out = <DefaultChunk as DefaultChunkReader<i32, _>>::read_chunk(\n        &inner[..],\n        &array_meta,\n        smallvec![0, 0, 0],\n    )\n    .expect(\"read_chunk failed\");\n\n    assert_eq!(chunk_out.get_grid_position(), &[0, 0, 0]);\n    assert_eq!(chunk_out.get_data(), &chunk_data[..]);\n}", "item_id": 3, "repo": "sci-rs/zarr", "file": "src/tests.rs", "last_update_at": "2022-03-23T01:23:14+00:00"}
{"hexsha": "94f0e35732ff5de7f6c6a9dfcd1b6346522b80cd", "ext": "rs", "lang": "Rust", "content": "fn it_puts_the_query_params_on_the_uri() {\n        let ep = All::default()\n            .with_cursor(\"CURSOR\")\n            .with_limit(123)\n            .with_order(Direction::Desc);\n        let req = ep.into_request(\"https://www.google.com\").unwrap();\n        assert_eq!(req.uri().path(), \"/effects\");\n        assert_eq!(\n            req.uri().query(),\n            Some(\"order=desc&cursor=CURSOR&limit=123\")\n        );\n    }", "item_id": 1, "repo": "nebkor/stellar-sdk", "file": "client/src/endpoint/effect.rs", "last_update_at": "2022-03-21T11:54:02+00:00"}
{"hexsha": "145a76c705315bebea22d96a3d1a877ff5f4ba5b", "ext": "rs", "lang": "Rust", "content": "fn test_init() {\n        let dst = Path::new(\"dst_test_init_writer\");\n        std::fs::create_dir(dst).unwrap();\n        let _ = WriterDoc::new(dst, \"en\", Some(1_000_000));\n        std::fs::remove_dir_all(dst).unwrap();\n    }", "item_id": 0, "repo": "pjox/ungoliant", "file": "src/io/writer/writer_doc.rs", "last_update_at": "2022-03-29T18:15:26+00:00"}
{"hexsha": "07a534096d670567b68a8c0a91fabca805b06e05", "ext": "rs", "lang": "Rust", "content": "fn view_macroblock_history(model: &Model) -> Vec<Node<GMsg>> {\n    let is_visible = !model.frames.is_empty() && model.selected_macroblock.is_some();\n    let is_hint_visible = !model.frames.is_empty() && model.selected_macroblock.is_none();\n    let canvas_attrs = attrs! {\n        At::Width => 128,\n        At::Height => 128,\n    };\n    let macroblock_info = model\n        .selected_macroblock\n        .map(|i| &model.frames[model.selected_frame].stats.macroblock_info[i]);\n    let kind = macroblock_info.map(|x| &x.kind);\n    let previous_reference_text = match kind {\n        Some(MacroblockInfoKind::Intra) => \"intra\",\n        Some(MacroblockInfoKind::Moved { .. } | MacroblockInfoKind::Interpolated { .. }) => {\n            \"direction\"\n        }\n        _ => \"\",\n    };\n\n    nodes![\n        div![\n            C![\"macroblock-history\"],\n            C![IF!(!is_visible => \"-hidden\")],\n            h3![\"Macroblock history\"],\n            p![\n                \"Macroblock type: \",\n                kind.map(|x| strong![format_macroblock_kind(x).to_string()])\n            ],\n            div![\n                C![\"history-container\"],\n                IF!(matches!(kind, Some(MacroblockInfoKind::Skipped)) => C![\"-skipped\"]),\n                IF!(matches!(kind, Some(MacroblockInfoKind::Intra)) => C![\"-intra\"]),\n                IF!(matches!(kind, Some(MacroblockInfoKind::Moved { is_forward: true, ..  })) => C![\"-forward\"]),\n                IF!(matches!(kind, Some(MacroblockInfoKind::Moved { is_forward: false, ..  })) => C![\"-backward\"]),\n                IF!(matches!(kind, Some(MacroblockInfoKind::Interpolated { ..  })) => C![\"-interpolated\"]),\n                div![\n                    C![\"image previous-reference\"],\n                    canvas![\n                        &canvas_attrs,\n                        el_ref(&model.canvas_history_previous_reference)\n                    ],\n                    \"Previous reference\"\n                ],\n                div![\n                    C![\"arrow -right from-previous-reference\"],\n                    attrs! {At::from(\"data-text\") => previous_reference_text},\n                ],\n                div![\n                    C![\"image previous-before-diff\"],\n                    canvas![\n                        &canvas_attrs,\n                        el_ref(&model.canvas_history_previous_before_diff)\n                    ],\n                    \"Moved macroblock\"\n                ],\n                div![\n                    C![\"arrow -right from-previous-before-diff\"],\n                    attrs! {At::from(\"data-text\") => \"difference\"},\n                ],\n                div![\n                    C![\"vertical-container\"],\n                    div![\n                        C![\"image interpolated\"],\n                        canvas![&canvas_attrs, el_ref(&model.canvas_history_interpolated)],\n                        \"Interpolation result\"\n                    ],\n                    div![\n                        C![\"arrow -down from-interpolated\"],\n                        attrs! {At::from(\"data-text\") => \"difference\"},\n                    ],\n                    div![\n                        C![\"image result\"],\n                        canvas![&canvas_attrs, el_ref(&model.canvas_history_result)],\n                        \"Result\"\n                    ],\n                ],\n                div![\n                    C![\"arrow -left from-next-before-diff\"],\n                    attrs! {At::from(\"data-text\") => \"difference\"},\n                ],\n                div![\n                    C![\"image next-before-diff\"],\n                    canvas![\n                        &canvas_attrs,\n                        el_ref(&model.canvas_history_next_before_diff)\n                    ],\n                    \"Moved macroblock\"\n                ],\n                div![\n                    C![\"arrow -left from-next-reference\"],\n                    attrs! {At::from(\"data-text\") => \"direction\"},\n                ],\n                div![\n                    C![\"image next-reference\"],\n                    canvas![&canvas_attrs, el_ref(&model.canvas_history_next_reference)],\n                    \"Next reference\"\n                ],\n            ]\n        ]\n        div![\n            C![\"macroblock-selection-hint\"],\n            C![IF!(!is_hint_visible => \"-hidden\")],\n            strong![\"Hint: \"],\n            \"Click on the frame above to show information about corresponding macroblock\"\n        ]\n    ]\n}", "item_id": 1, "repo": "jpeg-mpeg-visualizer/jpeg-mpeg-visualizer", "file": "src/section/mpeg_visualization/view.rs", "last_update_at": "2022-01-11T12:06:29+00:00"}
{"hexsha": "908e270555dc1efde907e4e021368817b4d04fbc", "ext": "rs", "lang": "Rust", "content": "fn const_test(term: Term) {\n        init();\n        let mut cs = Computation::new(true);\n        cs.assert(term.clone());\n        cs.assert(leaf_term(Op::Const(Value::Bool(true))));\n        let ilp = to_ilp(cs);\n        let r = ilp.solve(default_solver);\n        if r.is_err() {\n            panic!(\"Error: {:?} on {}\", r, term)\n        }\n    }", "item_id": 3, "repo": "julesdesmit/circ", "file": "src/target/ilp/trans.rs", "last_update_at": "2022-03-31T21:36:45+00:00"}
{"hexsha": "c4a96cf9191285bd7e65aac700530f7a4ec11eca", "ext": "rs", "lang": "Rust", "content": "fn private_corpus() {\n    let _ = env_logger::init();\n\n    let options = glob::MatchOptions {\n        case_sensitive: true,\n        require_literal_separator: true,\n        require_literal_leading_dot: true,\n    };\n    for entry in glob::glob_with(\"../private/**/*.idx\", &options).unwrap() {\n        let entry = entry.unwrap();\n        process_file(&entry);\n    }\n}", "item_id": 0, "repo": "sykul/subtitles-rs", "file": "subtitle_ocr/tests/ocr_corpus.rs", "last_update_at": "2022-03-10T00:47:05+00:00"}
{"hexsha": "e4ce04d58e035599f2e904b41e1e7fe2e4e2ef23", "ext": "rs", "lang": "Rust", "content": "async fn submit_tx_when_service_is_frozen() {\n    let (mut testkit, api) = init_testkit();\n    let keys = testkit.us().service_keypair();\n\n    let tx = keys.freeze_service(SUPERVISOR_INSTANCE_ID, SERVICE_ID);\n    let block = testkit.create_block_with_transaction(tx);\n    block[0].status().expect(\"Cannot freeze service\");\n\n    let ping = PingQuery { value: 64 };\n    let err = api\n        .public(ApiKind::Service(\"api-service\"))\n        .query(&ping)\n        .post::<()>(\"submit-tx\")\n        .await\n        .expect_err(\"Request to the valid endpoint should fail\");\n    assert_eq!(err.http_code, api::HttpStatusCode::SERVICE_UNAVAILABLE);\n    assert_eq!(err.body.title, \"Service is not active\");\n\n    let block = testkit.create_block();\n    assert!(block.is_empty());\n}", "item_id": 8, "repo": "Kollego/exonum", "file": "test-suite/testkit/tests/api.rs", "last_update_at": "2022-03-17T07:37:15+00:00"}
{"hexsha": "33af33f042063cb938a7e5f8f2845e3f68908304", "ext": "rs", "lang": "Rust", "content": "fn run_benchmarks< F: FnOnce( &mut Bencher ) >( callback: F ) {\n    if !*IS_NODEJS {\n        let body = document().query_selector( \"body\" ).unwrap().unwrap();\n        let start = document().create_element( \"button\" ).unwrap();\n        start.set_text_content( \"Start\" );\n        body.append_child( &start );\n        let pre = document().create_element( \"pre\" ).unwrap();\n        pre.set_attribute( \"id\", \"console\" ).unwrap();\n        body.append_child( &pre );\n    }\n\n    if cfg!( nightly ) {\n        js! {\n            console.log( \"Compiled with the `nightly` feature!\" );\n        }\n    }\n\n    let mut bencher = Bencher::new();\n    callback( &mut bencher );\n\n    if !*IS_NODEJS {\n        let body = document().query_selector( \"body\" ).unwrap().unwrap();\n        body.add_event_listener( move |_: ClickEvent| {\n            bencher.run();\n        });\n    } else {\n        bencher.run();\n    }\n}", "item_id": 0, "repo": "notriddle/stdweb", "file": "benchmarks/src/main.rs", "last_update_at": "2022-03-31T18:14:19+00:00"}
{"hexsha": "14d51673a1e7dae1cbaac81bfd544f62dd8e1c53", "ext": "rs", "lang": "Rust", "content": "fn dec_by_inclusive_type_dependent_overflow() {\n  let mut r11 = (255u8..=248u8).dec_by::<50>();\n  assert_eq!(r11.next(), Some(255));\n  assert_eq!(r11.next(), None);\n  let mut r12 = (255u32..=248u32).dec_by::<{ usize::MAX }>();\n  assert_eq!(r12.next(), Some(255));\n  assert_eq!(r12.next(), None);\n  let mut r13 = (255i32..=248i32).dec_by::<{ u32::MAX as usize }>();\n  assert_eq!(r13.next(), Some(255));\n  assert_eq!(r13.next(), None);\n  let mut r14 = (i16::MAX..=i16::MAX).dec_by::<1>();\n  assert_eq!(r14.next(), Some(32767));\n  assert_eq!(r14.next(), None);\n}", "item_id": 30, "repo": "slightlyoutofphase/staticstep", "file": "tests/test_staticstep.rs", "last_update_at": "2022-01-30T19:12:35+00:00"}
{"hexsha": "74e251808f8357c43b87e9238e44b8960592c1d4", "ext": "rs", "lang": "Rust", "content": "fn test_from_string() {\n    assert_eq!(\"0\", FeelNumber::from_string(\"0\").to_string());\n    assert_eq!(\"-0\", FeelNumber::from_string(\"-0\").to_string());\n    assert_eq!(\"1\", FeelNumber::from_string(\"1\").to_string());\n    assert_eq!(\"-1\", FeelNumber::from_string(\"-1\").to_string());\n    assert_eq!(\"1.23456789\", FeelNumber::from_string(\"1.23456789\").to_string());\n    assert_eq!(\"-1.23456789\", FeelNumber::from_string(\"-1.23456789\").to_string());\n  }", "item_id": 9, "repo": "dmntk/dmntk.rs", "file": "feel-number/src/number.rs", "last_update_at": "2022-03-31T13:13:29+00:00"}
{"hexsha": "4f3d9f22f5d4f4f98d5b2b0083560fc60382ddd2", "ext": "rs", "lang": "Rust", "content": "fn test_maximal_independent_set_wikipedia() {\n    let g = graph_wikipedia();\n    assert_eq!(vec![0, 2, 5], maximal_independent_set(&g, &vec![0, 1, 2, 3, 4, 5]));\n    assert_eq!(vec![1, 3], maximal_independent_set(&g, &vec![1, 0, 2, 3, 4, 5]));\n    assert_eq!(vec![0, 2, 5], maximal_independent_set(&g, &vec![2, 0, 1, 3, 4, 5]));\n    assert_eq!(vec![0, 3], maximal_independent_set(&g, &vec![3, 0, 1, 2, 4, 5]));\n    assert_eq!(vec![2, 4, 5], maximal_independent_set(&g, &vec![4, 0, 1, 2, 3, 5]));\n    assert_eq!(vec![0, 2, 5], maximal_independent_set(&g, &vec![5, 0, 1, 2, 3, 4]));\n}", "item_id": 0, "repo": "peferron/algo", "file": "independent_set/rust/independent_set_test.rs", "last_update_at": "2022-03-23T18:06:46+00:00"}
{"hexsha": "82296e5ab9043c8c71ccf066decbd60f54d4e606", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn lower(cp: u32) -> bool {\n    // Derived Property: Lowercase\n    //  Generated from: Ll + Other_Lowercase\n    let cp = CodePoint::new(cp).unwrap();\n\n    cp.gc() == Gc::Ll || cp.olower()\n}", "item_id": 2, "repo": "hardboiled65/seshat-unicode", "file": "src/unicode/ucd/derived_props.rs", "last_update_at": "2022-03-05T17:23:19+00:00"}
{"hexsha": "ccf5cfcfbb628b2aace6b7ce9bba1d5b1502d0ce", "ext": "rs", "lang": "Rust", "content": "pub fn combination_save(\n    storage: &mut dyn Storage,\n    lottery_id: u64,\n    address: CanonicalAddr,\n    combination: Vec<String>,\n) -> StdResult<()> {\n    let mut exist = true;\n    // Save combination by senders\n    PREFIXED_USER_COMBINATION.update(\n        storage,\n        (&lottery_id.to_be_bytes(), address.as_slice()),\n        |exists| -> StdResult<Vec<String>> {\n            match exists {\n                Some(combinations) => {\n                    let mut modified = combinations;\n                    modified.extend(combination.clone());\n                    Ok(modified)\n                }\n                None => {\n                    exist = false;\n                    Ok(combination.clone())\n                }\n            }\n        },\n    )?;\n    if !exist {\n        ALL_USER_COMBINATION.update(\n            storage,\n            &lottery_id.to_be_bytes(),\n            |exist| -> StdResult<Vec<CanonicalAddr>> {\n                match exist {\n                    None => Ok(vec![address]),\n                    Some(players) => {\n                        let mut data = players;\n                        data.push(address);\n                        Ok(data)\n                    }\n                }\n            },\n        )?;\n        COUNT_PLAYERS\n            .update(\n                storage,\n                &lottery_id.to_be_bytes(),\n                |exists| -> StdResult<Uint128> {\n                    match exists {\n                        None => Ok(Uint128(1)),\n                        Some(p) => Ok(p.add(Uint128(1))),\n                    }\n                },\n            )\n            .map(|_| ())?\n    }\n    COUNT_TICKETS\n        .update(\n            storage,\n            &lottery_id.to_be_bytes(),\n            |exists| -> StdResult<Uint128> {\n                match exists {\n                    None => Ok(Uint128(combination.len() as u128)),\n                    Some(p) => Ok(p.add(Uint128(combination.len() as u128))),\n                }\n            },\n        )\n        .map(|_| ())\n}", "item_id": 0, "repo": "0xantman/LoTerra", "file": "src/state.rs", "last_update_at": "2022-01-18T05:00:45+00:00"}
{"hexsha": "638731c51c5f41e412237e6d63ffc746ec7369a1", "ext": "rs", "lang": "Rust", "content": "pub fn wlroots_dehandle(_args: TokenStream, input: TokenStream) -> TokenStream {\n    let input = parse_macro_input!(input as ItemFn);\n    let output = Args.fold_item_fn(input);\n    TokenStream::from(quote!(#output))\n}", "item_id": 0, "repo": "SethBarberee/wlroots-rs", "file": "wlroots-dehandle/src/lib.rs", "last_update_at": "2022-01-13T23:46:42+00:00"}
{"hexsha": "4a7c0b0d3d3bd17552f59a07db83ad636a06bd3e", "ext": "rs", "lang": "Rust", "content": "fn basics_with_schema_projection() -> Result<()> {\n    let (data, schema, columns) = case_basics_schema();\n\n    let mut reader = ReaderBuilder::new()\n        .with_schema(Arc::new(schema.clone()))\n        .build(Cursor::new(data))?;\n    let batch = reader.next()?.unwrap();\n\n    assert_eq!(&schema, batch.schema().as_ref());\n\n    columns\n        .iter()\n        .zip(batch.columns())\n        .for_each(|(expected, result)| assert_eq!(expected.as_ref(), result.as_ref()));\n    Ok(())\n}", "item_id": 1, "repo": "ives9638/arrow2", "file": "tests/it/io/json/read.rs", "last_update_at": "2022-02-20T00:10:06+00:00"}
{"hexsha": "ec997430e31b86f8a9c22418c5c30c6b4fd32db1", "ext": "rs", "lang": "Rust", "content": "pub fn set_sampling_mode<'a>(\n    mut ctx: partial!(Context<'a>, mut ProofP<'a>, mut SolverStateP, mut VariablesP),\n    global: Var,\n    mode: SamplingMode,\n) -> Option<Var> {\n    let variables = ctx.part_mut(VariablesP);\n\n    let var_data = &mut variables.var_data[global.index()];\n\n    assert!(!var_data.deleted);\n\n    if var_data.assumed {\n        panic!(\"cannot change sampling mode of assumption variable\")\n    }\n\n    let previous_mode = var_data.sampling_mode;\n\n    if previous_mode == mode {\n        return None;\n    }\n\n    var_data.sampling_mode = mode;\n\n    let mut result = None;\n\n    if mode != SamplingMode::Hide {\n        proof::add_step(\n            ctx.borrow(),\n            false,\n            &ProofStep::ChangeSamplingMode {\n                var: global,\n                sample: mode == SamplingMode::Sample,\n            },\n        );\n    }\n    let variables = ctx.part_mut(VariablesP);\n\n    if previous_mode == SamplingMode::Hide {\n        let user = variables.next_unmapped_user();\n        variables.user_from_global_mut().insert(user, global);\n        variables.user_freelist.remove(&user);\n\n        proof::add_step(\n            ctx.borrow(),\n            false,\n            &ProofStep::UserVarName {\n                global,\n                user: Some(user),\n            },\n        );\n\n        result = Some(user);\n    } else if mode == SamplingMode::Hide {\n        if let Some(user) = variables.user_from_global_mut().remove(global) {\n            variables.user_freelist.insert(user);\n        }\n\n        proof::add_step(\n            ctx.borrow(),\n            false,\n            &ProofStep::UserVarName { global, user: None },\n        );\n\n        delete_global_if_unused(ctx.borrow(), global);\n    }\n\n    result\n}", "item_id": 3, "repo": "cjsauer/varisat", "file": "varisat/src/variables.rs", "last_update_at": "2022-03-31T18:32:05+00:00"}
{"hexsha": "54c30d3a87d97116fad54f93ec46b12a13be9dde", "ext": "rs", "lang": "Rust", "content": "async fn integration_test_is_ready_ok_no_such_bucket() {\n        // test that is_ready returns Ok even if the bucket doesn't exist\n        let mut client = init_client().await;\n        client\n            .delete_bucket(&S3BucketsSettings::default().global_models)\n            .await\n            .unwrap();\n\n        let res = client.is_ready().await;\n        assert!(res.is_ok())\n    }", "item_id": 5, "repo": "Robert-Steiner/xaynet", "file": "rust/xaynet-server/src/storage/model_storage/s3.rs", "last_update_at": "2022-02-10T02:59:04+00:00"}
{"hexsha": "42999a743bbd29d266cf2f0faadc5ca8c4cb64c3", "ext": "rs", "lang": "Rust", "content": "async fn csv_query_array_agg() -> Result<()> {\n    let ctx = SessionContext::new();\n    register_aggregate_csv(&ctx).await?;\n    let sql =\n        \"SELECT array_agg(c13) FROM (SELECT * FROM aggregate_test_100 ORDER BY c13 LIMIT 2) test\";\n    let actual = execute_to_batches(&ctx, sql).await;\n    let expected = vec![\n        \"+------------------------------------------------------------------+\",\n        \"| ARRAYAGG(test.c13)                                               |\",\n        \"+------------------------------------------------------------------+\",\n        \"| [0VVIHzxWtNOFLtnhjHEKjXaJOSLJfm, 0keZ5G8BffGwgF2RwQD59TFzMStxCB] |\",\n        \"+------------------------------------------------------------------+\",\n    ];\n    assert_batches_eq!(expected, &actual);\n    Ok(())\n}", "item_id": 31, "repo": "capkurmagati/arrow-datafusion", "file": "datafusion/core/tests/sql/aggregates.rs", "last_update_at": "2022-03-29T13:34:55+00:00"}
{"hexsha": "bcf073018c381b64faf9337df7e306a087c8a090", "ext": "rs", "lang": "Rust", "content": "fn insert_8_char_string(b: &mut Bencher) {\n    let mut strings: Vec<_> = Vec::new();\n    for i in 1..1001 {\n        strings.push(format!(\"{:x}\", -i));\n    }\n\n    let mut m = new_map();\n    b.iter(|| {\n        for key in &strings {\n            m.insert(key, key);\n        }\n    })\n}", "item_id": 7, "repo": "zhangpf/fuchsia-rs", "file": "third_party/rust_crates/vendor/hashbrown/benches/bench.rs", "last_update_at": "2022-02-14T19:18:24+00:00"}
{"hexsha": "7bbe64ec6f80d16efee4802c6f5d0ca610eb8674", "ext": "rs", "lang": "Rust", "content": "fn helmholtz_energy() {\n        let disp = Dispersion {\n            parameters: propane_parameters(),\n        };\n        let t = 250.0;\n        let v = 1000.0;\n        let n = 1.0;\n        let s = StateHD::new(t, v, arr1(&[n]));\n        let a_rust = disp.helmholtz_energy(&s);\n        assert_relative_eq!(a_rust, -1.0622531100351962, epsilon = 1e-10);\n    }", "item_id": 0, "repo": "bbbursik/feos-pcsaft", "file": "src/eos/dispersion.rs", "last_update_at": "2022-03-02T16:39:08+00:00"}
{"hexsha": "7f4da6f279dddfd14822d3ff27b2543722279870", "ext": "rs", "lang": "Rust", "content": "async fn test_create_lookup_table() {\n    let mut context = setup_test_context().await;\n\n    let test_recent_slot = 123;\n    overwrite_slot_hashes_with_slots(&mut context, &[test_recent_slot]);\n\n    let client = &mut context.banks_client;\n    let payer = &context.payer;\n    let recent_blockhash = context.last_blockhash;\n    let authority_keypair = Keypair::new();\n    let authority_address = authority_keypair.pubkey();\n    let (create_lookup_table_ix, lookup_table_address) =\n        create_lookup_table(authority_address, payer.pubkey(), test_recent_slot);\n\n    // First create should succeed\n    {\n        let transaction = Transaction::new_signed_with_payer(\n            &[create_lookup_table_ix.clone()],\n            Some(&payer.pubkey()),\n            &[payer, &authority_keypair],\n            recent_blockhash,\n        );\n\n        assert_matches!(client.process_transaction(transaction).await, Ok(()));\n        let lookup_table_account = client\n            .get_account(lookup_table_address)\n            .await\n            .unwrap()\n            .unwrap();\n        assert_eq!(lookup_table_account.owner, crate::id());\n        assert_eq!(lookup_table_account.data.len(), LOOKUP_TABLE_META_SIZE);\n        assert_eq!(\n            lookup_table_account.lamports,\n            Rent::default().minimum_balance(LOOKUP_TABLE_META_SIZE)\n        );\n        let lookup_table = AddressLookupTable::deserialize(&lookup_table_account.data).unwrap();\n        assert_eq!(lookup_table.meta.derivation_slot, test_recent_slot);\n        assert_eq!(lookup_table.meta.authority, Some(authority_address));\n        assert_eq!(lookup_table.meta.last_extended_slot, 0);\n        assert_eq!(lookup_table.meta.last_extended_slot_start_index, 0);\n        assert_eq!(lookup_table.addresses.len(), 0);\n    }\n\n    // Second create should fail\n    {\n        context.last_blockhash = client\n            .get_new_latest_blockhash(&recent_blockhash)\n            .await\n            .unwrap();\n        assert_ix_error(\n            &mut context,\n            create_lookup_table_ix,\n            Some(&authority_keypair),\n            InstructionError::AccountAlreadyInitialized,\n        )\n        .await;\n    }\n}", "item_id": 0, "repo": "alexbosy/solana", "file": "programs/address-lookup-table-tests/tests/create_lookup_table_ix.rs", "last_update_at": "2022-03-31T19:25:12+00:00"}
{"hexsha": "35328c4632ef130aef9ae4b25454f12a1bb664ff", "ext": "rs", "lang": "Rust", "content": "async fn main() -> Result<()> {\n    tracing_subscriber::fmt().with_env_filter(\"debug\").init();\n\n    let opts = Opts::parse();\n\n    let id = Keypair::generate_ed25519();\n\n    let endpoint_addr = Endpoint::new(TokioTcpConfig::new(), id, Duration::from_secs(20), [])\n        .create(None)\n        .spawn_global();\n\n    let dialer_constructor = {\n        let connect_addr = opts.multiaddr.clone();\n        let endpoint_addr = endpoint_addr.clone();\n        move || dialer::Actor::new(endpoint_addr.clone(), connect_addr.clone())\n    };\n\n    let (supervisor, _dialer_actor) = supervisor::Actor::with_policy(\n        dialer_constructor,\n        |_: &dialer::Error| true, // always restart dialer actor\n    );\n    let _dialer_supervisor = supervisor.create(None).spawn_global();\n\n    sleep(Duration::from_secs(1)).await;\n\n    let stream = endpoint_addr\n        .send(OpenSubstream::single_protocol(\n            PeerId::try_from_multiaddr(&opts.multiaddr).unwrap(),\n            \"/hello-world/1.0.0\",\n        ))\n        .await\n        .unwrap()\n        .unwrap();\n\n    let message = hello_world_dialer(stream, opts.name).await.unwrap();\n\n    tracing::info!(\"{message}\");\n\n    Ok(())\n}", "item_id": 0, "repo": "itchysats/itchysats", "file": "xtra-libp2p/examples/hello_world_dialer.rs", "last_update_at": "2022-03-14T01:20:28+00:00"}
{"hexsha": "40a4099c379c46d3ff5f65c2b90445fe38fe5822", "ext": "rs", "lang": "Rust", "content": "fn subr(&mut self) -> Result<Ipv4Addr, Self::Error> {\n        let mut subr = Ipv4Addr::UNSPECIFIED;\n        self.read(reg::SUBR, COMMON_BLOCK_OFFSET, &mut subr.octets)?;\n        Ok(subr)\n    }", "item_id": 3, "repo": "newAM/w5500-ll-rs", "file": "src/lib.rs", "last_update_at": "2022-03-05T05:06:30+00:00"}
{"hexsha": "c7b6c06a91c2d640e2a5eafd6be8cec2a3cef26e", "ext": "rs", "lang": "Rust", "content": "fn test_get_text() {\n        let width = 3;\n        let key_config = KeyConfig::default();\n        let mut component = HelpComponent::new(key_config.clone());\n        component.set_cmds(vec![\n            CommandInfo::new(crate::components::command::scroll(&key_config)),\n            CommandInfo::new(crate::components::command::filter(&key_config)),\n        ]);\n        assert_eq!(\n            component.get_text(width),\n            vec![\n                Spans::from(Span::styled(\n                    \"-- General --\",\n                    Style::default().add_modifier(Modifier::REVERSED)\n                )),\n                Spans::from(Span::styled(\n                    \" Scroll up/down/left/right [k,j,h,l]  3\",\n                    Style::default().bg(Color::Rgb(0xea, 0x59, 0x0b))\n                )),\n                Spans::from(Span::styled(\" Filter [/]  3\", Style::default()))\n            ]\n        );\n    }", "item_id": 0, "repo": "andyslucky/gobang", "file": "src/components/help.rs", "last_update_at": "2022-02-07T22:46:16+00:00"}
{"hexsha": "2c4ed5a22570842ff78d205527b9c2dad01eecf6", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let mut input_a = String::new();\n    let mut input_b = String::new();\n\n    if let Err(_e) = io::stdin().read_line(&mut input_a){}\n    if let Err(_e) = io::stdin().read_line(&mut input_b){}\n\n    let a: f64 = input_a.trim().parse().unwrap();\n    let b: f64 = input_b.trim().parse().unwrap();\n\n    println!(\"MEDIA = {:.5}\", (a * 3.5 + b * 7.5) / 11.0);\n}", "item_id": 0, "repo": "deniscostadsc/playground", "file": "solutions/beecrowd/1005/1005.rs", "last_update_at": "2022-01-08T22:36:47+00:00"}
{"hexsha": "28c52a8cb860091ec0522e9d56f08e35df2004ec", "ext": "rs", "lang": "Rust", "content": "pub fn request(endpoint : &str) -> Result<bytes::Bytes, Error> {\n    \n    let resp = reqwest::blocking::get(format!(\"https://api.dhravya.me/{}\", endpoint)).unwrap();\n\n    let status : u16 = resp.status().as_u16();\n\n    if status == 200 {\n        let bytes : bytes::Bytes = resp.bytes().unwrap();\n        return Ok(bytes);\n    } else {\n        if status == 500 {\n            return Err(Error::HTTPException(\"Internal Server Error\".to_string()));\n        } else {\n            return Err(Error::HTTPException(\"Unknown Error\".to_string()));\n        }\n    }\n}", "item_id": 0, "repo": "kekda-py/Dhavya", "file": "src/lib.rs", "last_update_at": "2022-03-10T12:01:43+00:00"}
{"hexsha": "8fd6b208ec84f00e8121ce9174d335326a9c9d90", "ext": "rs", "lang": "Rust", "content": "fn read_records<R>(reader: R) -> csv::Result<()>\nwhere\n    R: Read,\n{\n    let mut rdr = csv::Reader::from_reader(reader);\n    println!(\"Comparing planets in the solar system with the earth\");\n    println!(\"where a value of '1' means 'equal to earth'\");\n    for result in rdr.records() {\n        println!(\"-------\");\n        let record = result?;\n        if let Some(name) = record.get(0) {\n            println!(\"Name: {}\", name);\n        }\n        if let Some(radius) = record.get(1) {\n            println!(\"Radius: {}\", radius);\n        }\n        if let Some(distance) = record.get(2) {\n            println!(\"Distance from sun: {}\", distance);\n        }\n        if let Some(gravity) = record.get(3) {\n            println!(\"Surface gravity: {}\", gravity);\n        }\n    }\n    Ok(())\n}", "item_id": 2, "repo": "PacktPublishing/Rust-Standard-Library-Cookbook", "file": "Chapter04/src/bin/csv.rs", "last_update_at": "2022-03-29T02:31:56+00:00"}
{"hexsha": "7e2cb0923ee66343bab7e18ac18838de40478cf7", "ext": "rs", "lang": "Rust", "content": "fn from_cursor_wrong() {\n        let a = &[0, 1, 78];\n        let mut wrong: Cursor<&[u8]> = Cursor::new(a);\n        let _ = StatusChangeType::from_cursor(&mut wrong).unwrap();\n    }", "item_id": 4, "repo": "devbasil/cdrs-tokio", "file": "cdrs-tokio/src/frame/events.rs", "last_update_at": "2022-03-30T17:06:01+00:00"}
{"hexsha": "0112ea4a8241ff775de3a099a311c1a0995367f0", "ext": "rs", "lang": "Rust", "content": "pub fn test() -> Html {\n    let (label, set_label) = use_state(|| \"Hello\".to_owned());\n\n    let on_click = {\n        let label = Rc::clone(&label);\n        Callback::from(move |_| set_label(format!(\"{} world\", label)))\n    };\n\n    let default_string = use_trans(\"default\");\n\n    let switch_on_click = Callback::from(move |_| ());\n\n    let slider_on_change = Callback::from(move |_| ());\n\n    let on_select = Callback::from(move |_| ());\n\n    let text_field_on_focus_lost = Callback::from(move |_| ());\n\n    let up_down_on_step = Callback::from(move |_| ());\n\n    html! {\n        <div class=\"px-4 py-3\">\n            <div class=\"flex flex-col space-y-2 items-start\">\n                <Button on_click=on_click.clone() button_type=ButtonType::None>\n                    {label.clone()}\n                </Button>\n                <Button on_click=on_click.clone() button_type=ButtonType::Primary>\n                    {label.clone()}\n                </Button>\n                <Button on_click=on_click.clone() button_type=ButtonType::Secondary>\n                    {label.clone()}\n                </Button>\n                <Button on_click=on_click button_type=ButtonType::Danger>\n                    {label}\n                </Button>\n            </div>\n            <Switch on_click=switch_on_click checked=true/>\n            <Slider value=\"0\" default=\"30\" min=\"-1\" max=\"40\" step=\"0.5\" on_change=slider_on_change/>\n            <ButtonGroup\n                options=vec![\"hello1\".into(), \"hello2\".into()]\n                selected=\"hello1\"\n                on_select=on_select.clone()\n            />\n            <Select\n                options=vec![\"hello1\".into(), \"hello2\".into()]\n                selected=\"hello1\"\n                on_select=on_select\n            />\n            <div class=\"space-y-2\">\n                <TextField\n                    value=default_string.clone()\n                    on_focus_lost=text_field_on_focus_lost.clone()\n                />\n                <TextField\n                    label=\"Hi there\"\n                    value=default_string\n                    on_focus_lost=text_field_on_focus_lost.clone()\n                />\n            </div>\n            <div class=\"py-2 space-y-2\">\n                <UpDown\n                    label=\"Bitrate\"\n                    value=\"123\"\n                    on_focus_lost=text_field_on_focus_lost.clone()\n                    on_step_down=up_down_on_step.clone()\n                    on_step_up=up_down_on_step.clone()\n                />\n                <UpDown\n                    value=\"123\"\n                    on_focus_lost=text_field_on_focus_lost\n                    on_step_down=up_down_on_step.clone()\n                    on_step_up=up_down_on_step\n                />\n            </div>\n        </div>\n    }\n}", "item_id": 2, "repo": "Nexite/ALVR", "file": "alvr/dashboard/src/dashboard.rs", "last_update_at": "2022-01-10T05:12:29+00:00"}
{"hexsha": "4693cf30bac359276617be3ce520aa50f3f6d85a", "ext": "rs", "lang": "Rust", "content": "fn exclusion_rule_must_have_different_families_for_conditions_and_exclusions() {\n        let blue = Item::from(\"shirts:blue\");\n        let red = Item::from(\"shirts:red\");\n\n        let jeans = Item::from(\"pants:jeans\");\n        let slacks = Item::from(\"pants:slacks\");\n\n        let shirts = Family::from(\"shirts\");\n        let pants = Family::from(\"pants\");\n\n        let error = build_catalog(CatalogAssembly {\n            families: btreemap! {\n                shirts.clone() => vec![red.clone(), blue.clone()],\n                pants.clone() => vec![jeans.clone(), slacks.clone()],\n            },\n            exclusions: vec![\n                CatalogExclusionRule { conditions: vec![jeans.clone()], exclusions: vec![slacks.clone()] },\n                CatalogExclusionRule { conditions: vec![slacks.clone()], exclusions: vec![jeans.clone()] },\n            ],\n            inclusions: vec![],\n        })\n            .expect_err(\"expected build to return Error\");\n\n        assert_eq!(\n            CatalogBuilderError::ExclusionFamilyConflict { family: pants, items: vec![jeans, slacks] },\n            error\n        );\n    }", "item_id": 10, "repo": "tchupp/ignition-app", "file": "packages/catalogs/crate/src/catalog_builder/mod.rs", "last_update_at": "2022-01-22T07:53:16+00:00"}
{"hexsha": "5687c712cbdb9e849da153118e5b5a914d7a5178", "ext": "rs", "lang": "Rust", "content": "pub fn spl_token_transfer(params: TokenTransferParams<'_, '_>) -> Result<()> {\n    let TokenTransferParams {\n        source,\n        destination,\n        authority,\n        token_program,\n        amount,\n        authority_signer_seeds,\n    } = params;\n\n    let val = &[authority_signer_seeds];\n\n    let result = invoke_signed(\n        &spl_token::instruction::transfer(\n            token_program.key,\n            source.key,\n            destination.key,\n            authority.key,\n            &[],\n            amount,\n        )?,\n        &[source, destination, authority, token_program],\n        if authority_signer_seeds.len() == 0 {\n            &[]\n        } else {\n            val\n        },\n    );\n\n    result.map_err(|_| error!(ErrorCode::TokenTransferFailed))\n}", "item_id": 0, "repo": "raindrops-protocol/raindrops", "file": "rust/staking/src/utils.rs", "last_update_at": "2022-03-31T23:27:38+00:00"}
{"hexsha": "f238826e4b4a7216f9dbdd3263e5275544b144b2", "ext": "rs", "lang": "Rust", "content": "async fn deduplicates_bsses_from_multiple_networks() {\n            let mut cache = RealBssCache::new();\n            let result = cache\n                .update(FakeScanResultIterator::new_single_step(vec![\n                    ScanResult {\n                        id: None,\n                        entries: Some(vec![WlanPolicyBss {\n                            bssid: Some([0, 1, 2, 3, 4, 5]),\n                            rssi: Some(-1),\n                            frequency: Some(2412),\n                            timestamp_nanos: Some(1),\n                            ..WlanPolicyBss::EMPTY\n                        }]),\n                        compatibility: None,\n                        ..ScanResult::EMPTY\n                    },\n                    ScanResult {\n                        id: None,\n                        entries: Some(vec![WlanPolicyBss {\n                            bssid: Some([0, 1, 2, 3, 4, 5]),\n                            rssi: Some(-2),\n                            frequency: Some(2432),\n                            timestamp_nanos: Some(2),\n                            ..WlanPolicyBss::EMPTY\n                        }]),\n                        compatibility: None,\n                        ..ScanResult::EMPTY\n                    },\n                ]))\n                .await;\n            assert_eq!(result, Ok(()));\n\n            let mut bsses = cache.iter();\n            assert_matches!(bsses.next(), Some((&[0, 1, 2, 3, 4, 5], _)));\n            assert_eq!(bsses.next(), None);\n        }", "item_id": 5, "repo": "wwjiang007/fuchsia-1", "file": "src/connectivity/location/emergency/src/bss_cache.rs", "last_update_at": "2022-03-28T07:59:06+00:00"}
{"hexsha": "9ba37a921a2a4ece1f5deed1b92d20efe3b78a04", "ext": "rs", "lang": "Rust", "content": "fn values_del() {\n        let mut values = Values::new();\n        values.set_value(\"key\", Some(\"value\".to_string()));\n        values.add_value(\"key\", None);\n        values.del_value(\"key\");\n        assert_eq!(values.len(), 0);\n\n        let mut values2 = Values::new();\n        values2.set_value(\"key\", Some(\"value\".to_string()));\n        values2.add_value(\"key\", None);\n        values2.set_value(\"key2\", Some(\"value\".to_string()));\n        values2.add_value(\"key2\", None);\n\n        values2.del_value(\"key\");\n        assert_eq!(values2.len(), 1);\n    }", "item_id": 2, "repo": "n-k/minio-rs", "file": "src/minio/net.rs", "last_update_at": "2022-03-18T07:52:30+00:00"}
{"hexsha": "d9f5a19e461c4da51c8d8a53a1ec9b27f300edb9", "ext": "rs", "lang": "Rust", "content": "fn suffix_comma() {\n        let (parts, surname_index, generation) = parse(\"Doe, John III\").unwrap();\n        assert_eq!(\"John\", parts[0].word);\n        assert_eq!(\"Doe\", parts[1].word);\n        assert_eq!(1, surname_index);\n        assert_eq!(Some(3), generation);\n    }", "item_id": 5, "repo": "juma121/human-name", "file": "src/parse.rs", "last_update_at": "2022-01-08T15:35:15+00:00"}
{"hexsha": "0f3e077d1de342c44a9cdb4f271ed7f73f727538", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    assert_eq!(\n        <() as Foo<u32>>::Out::default().to_string(),\n        \"0\");\n    assert_eq!(\n        <() as Foo<u64>>::Out::default().to_string(),\n        \"false\");\n\n    assert_eq!(\n        <LocalDefault as Foo<u32>>::Out::default().to_string(),\n        \"0\");\n    assert_eq!(\n        <LocalOverride as Foo<u64>>::Out::default().to_string(),\n        \"false\");\n}", "item_id": 0, "repo": "Eric-Arellano/rust", "file": "src/test/ui/cross-crate/xcrate-associated-type-defaults.rs", "last_update_at": "2022-03-31T23:26:40+00:00"}
{"hexsha": "4240c517c9a992c92f452da8f5ff4a533bb41164", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_operation_crate_operation_get_group_configuration(\n    input: &crate::input::GetGroupConfigurationInput,\n) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {\n    let mut out = String::new();\n    let mut object = aws_smithy_json::serialize::JsonObjectWriter::new(&mut out);\n    crate::json_ser::serialize_structure_crate_input_get_group_configuration_input(\n        &mut object,\n        input,\n    )?;\n    object.finish();\n    Ok(aws_smithy_http::body::SdkBody::from(out))\n}", "item_id": 3, "repo": "StevenBlack/aws-sdk-rust", "file": "sdk/resourcegroups/src/operation_ser.rs", "last_update_at": "2022-03-31T20:47:15+00:00"}
{"hexsha": "48d8b037e6638eba17cd8992e9e253afcb6f5160", "ext": "rs", "lang": "Rust", "content": "fn num_squares(n: i32) -> i32 {\n    let mut dp = vec![0; n as usize];\n\n    let mut queue = VecDeque::from(vec![(0, 0)]);\n\n    while !queue.is_empty() {\n        let (val, step) = queue.pop_front().unwrap();\n\n        for i in 1..100 {\n            let target = val + i * i;\n\n            match target.cmp(&n) {\n                Ordering::Less => {\n                    if dp[target as usize] == 0 {\n                        dp[target as usize] = step + 1;\n                        queue.push_back((target, step + 1));\n                    }\n                },\n                Ordering::Equal => {\n                    return step + 1;\n                },\n                Ordering::Greater => {\n                    break;\n                },\n            }\n        }\n    }\n\n    -1\n}", "item_id": 0, "repo": "kristof-mattei/leet-code", "file": "src/problem_0279/mod.rs", "last_update_at": "2022-03-19T07:21:10+00:00"}
{"hexsha": "16cd6e2a6a15bffe3842c885e8f90ad2f1fe9a96", "ext": "rs", "lang": "Rust", "content": "fn abort(\n    env: &Env,\n    message: AsmScriptStringPtr,\n    filename: AsmScriptStringPtr,\n    line: i32,\n    col: i32,\n) {\n    let memory = env.memory.get_ref().expect(\"initialized memory\");\n    let message = message.read(memory).unwrap();\n    let filename = filename.read(memory).unwrap();\n    eprintln!(\"Error: {} at {}:{} col: {}\", message, filename, line, col);\n}", "item_id": 1, "repo": "k10pr0f/wasmer-as", "file": "tests/strings.rs", "last_update_at": "2022-03-05T09:05:20+00:00"}
{"hexsha": "d9efe0ed2e393b8300ba82eb3f7e3f77313eef6c", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_UConverterFromUnicodeArgs () { assert_eq ! (:: std :: mem :: size_of :: < UConverterFromUnicodeArgs > () , 56usize , concat ! (\"Size of: \" , stringify ! (UConverterFromUnicodeArgs))) ; assert_eq ! (:: std :: mem :: align_of :: < UConverterFromUnicodeArgs > () , 8usize , concat ! (\"Alignment of \" , stringify ! (UConverterFromUnicodeArgs))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . size as * const _ as usize } , 0usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (size))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . flush as * const _ as usize } , 2usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (flush))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . converter as * const _ as usize } , 8usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (converter))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . source as * const _ as usize } , 16usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (source))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . sourceLimit as * const _ as usize } , 24usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (sourceLimit))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . target as * const _ as usize } , 32usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (target))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . targetLimit as * const _ as usize } , 40usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (targetLimit))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . offsets as * const _ as usize } , 48usize , concat ! (\"Offset of field: \" , stringify ! (UConverterFromUnicodeArgs) , \"::\" , stringify ! (offsets))) ; }", "item_id": 3, "repo": "allansrc/fuchsia", "file": "third_party/rust_crates/vendor/rust_icu_sys/bindgen/lib_67.rs", "last_update_at": "2022-01-21T20:14:17+00:00"}
{"hexsha": "34498ed0c9dd848a3ba9a31a646eb0ec5ab5028b", "ext": "rs", "lang": "Rust", "content": "fn return_popped_empty() {\n        const MAX_IN_FLY: usize = 3;\n        const COMMIT_MARK: u8 = 0;\n\n        let mut queue = TxQueueBuilder::new(MAX_IN_FLY).build();\n\n        queue\n            .return_popped(get_tx_data(\n                AggregatedActionType::CommitBlocks,\n                BlockNumber(1),\n                vec![COMMIT_MARK, 0],\n            ))\n            .unwrap();\n    }", "item_id": 1, "repo": "euevew/zksync", "file": "core/bin/zksync_eth_sender/src/tx_queue/mod.rs", "last_update_at": "2022-03-31T19:24:23+00:00"}
{"hexsha": "f431383ef3c859d44cba61f9d2a0540d7ffd18f4", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_structure_crate_model_license_specification(\n    object: &mut aws_smithy_json::serialize::JsonObjectWriter,\n    input: &crate::model::LicenseSpecification,\n) -> Result<(), aws_smithy_http::operation::SerializationError> {\n    if let Some(var_333) = &input.license_configuration_arn {\n        object.key(\"LicenseConfigurationArn\").string(var_333);\n    }\n    if let Some(var_334) = &input.ami_association_scope {\n        object.key(\"AmiAssociationScope\").string(var_334);\n    }\n    Ok(())\n}", "item_id": 48, "repo": "jdisanti/aws-sdk-rust", "file": "sdk/licensemanager/src/json_ser.rs", "last_update_at": "2022-03-31T20:47:15+00:00"}
{"hexsha": "318569367212c7ef19ef5847be4d26f72dbb01bf", "ext": "rs", "lang": "Rust", "content": "fn test_split() {\n        let token = \"#\".to_string();\n        let c: HoardCommand = command_struct(\"test # test\");\n        let expected = vec![\"test \".to_string(), \" test\".to_string()];\n        assert_eq!(expected, c.split(&token));\n    }", "item_id": 7, "repo": "qb60/hoard", "file": "src/command/hoard_command.rs", "last_update_at": "2022-03-28T07:09:24+00:00"}
{"hexsha": "2be71527eb96a5f6fbf86f71d4934e65fcb7e381", "ext": "rs", "lang": "Rust", "content": "fn test_Aac_Ab() {\n    let A1 = array(vec![a(), c()]);\n    let A2 = array(vec![b()]);\n    let r = PredictionContext::merge(&A1, &A2, root_is_wildcard(), &mut None);\n    let expecting = String::new()\n        + \"digraph G {\\n\"\n        + \"rankdir=LR;\\n\"\n        + \"  s0[shape=record, label=\\\"<p0>|<p1>|<p2>\\\"];\\n\"\n        + \"  s1[label=\\\"*\\\"];\\n\"\n        + \"  s0:p0->s1[label=\\\"1\\\"];\\n\"\n        + \"  s0:p1->s1[label=\\\"2\\\"];\\n\"\n        + \"  s0:p2->s1[label=\\\"3\\\"];\\n\"\n        + \"}\\n\";\n    assert_eq!(expecting, to_dot_string(r, root_is_wildcard()))\n}", "item_id": 26, "repo": "kjplatz/antlr4rust", "file": "src/prediction_context/test.rs", "last_update_at": "2022-03-10T09:39:19+00:00"}
{"hexsha": "a2d2f0976d20104c3aa34b53503e85381dd4aa5a", "ext": "rs", "lang": "Rust", "content": "fn linspace(min: f64, max: f64, n: usize) -> Vec<f64> {\n    if n == 1 {\n        return vec![min];\n    }\n\n    let d = max - min;\n    let l = n as f64 - 1.0;\n    (0..n).map(|i| min + (i as f64 * d) / l).collect()\n}", "item_id": 2, "repo": "EmbarkStudios/colorgrad-rs", "file": "src/lib.rs", "last_update_at": "2022-03-29T22:12:28+00:00"}
{"hexsha": "8e3c03372106afa1014015c54d342a22614f5c76", "ext": "rs", "lang": "Rust", "content": "fn special_whitespace() {\n    let strings = [\"\\n\", \"\\t\", \"foo\\tbar\", \"baz\\n\"];\n\n    for &s in &strings {\n        let input = format!(r#\"b\"{}\"\"#, s);\n        let input_raw = format!(r#\"br\"{}\"\"#, s);\n        for (input, num_hashes) in vec![(input, None), (input_raw, Some(0))] {\n            let expected = ByteStringLit {\n                raw: &*input,\n                value: None,\n                num_hashes,\n            };\n            assert_parse_ok_eq(\n                &input, ByteStringLit::parse(&*input), expected.clone(), \"ByteStringLit::parse\");\n            assert_parse_ok_eq(\n                &input, Literal::parse(&*input), Literal::ByteString(expected), \"Literal::parse\");\n            assert_eq!(ByteStringLit::parse(&*input).unwrap().value(), s.as_bytes());\n            assert_eq!(ByteStringLit::parse(&*input).unwrap().into_value(), s.as_bytes());\n        }\n    }\n\n    let res = ByteStringLit::parse(\"br\\\"\\r\\\"\").expect(\"failed to parse\");\n    assert_eq!(res.value(), b\"\\r\");\n}", "item_id": 1, "repo": "LukasKalbertodt/litrs", "file": "src/bytestr/tests.rs", "last_update_at": "2022-03-10T15:50:51+00:00"}
{"hexsha": "800be99bdf5cb24a7bfccb5526fb18e550299c3c", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<(), u32> {\n    // - initialize allocator -------------------------------------------------\n\n    allocator::init();\n\n\n    // - configure board ------------------------------------------------------\n\n    let board = unsafe { bsp::Board::steal() };\n    let cp = cortex_m::Peripherals::take().unwrap();\n    let dp = pac::Peripherals::take().unwrap();\n    let ccdr = boards::freeze_clocks_with_config(\n        dp.PWR.constrain(), dp.RCC.constrain(), &dp.SYSCFG,\n        |pwrcfg, rcc, syscfg| {\n            rcc.sys_ck(96.mhz())                // system clock @ 96 MHz\n            // pll1 drives system clock\n                .pll1_strategy(hal::rcc::PllConfigStrategy::Iterative)\n                .pll1_r_ck(96.mhz())             // TRACECLK\n                .pll1_q_ck(48.mhz())             // spi clock\n                .pll3_p_ck((48_000 * 256).hz())  // sai clock @ 12.288 MHz\n                .freeze(pwrcfg, syscfg)\n        }\n    );\n\n    println!(\"Hello ockam_transport_ble!\");\n\n    let pins = board.split_gpios(dp.GPIOA.split(ccdr.peripheral.GPIOA),\n                                 dp.GPIOB.split(ccdr.peripheral.GPIOB),\n                                 dp.GPIOC.split(ccdr.peripheral.GPIOC),\n                                 dp.GPIOD.split(ccdr.peripheral.GPIOD),\n                                 dp.GPIOE.split(ccdr.peripheral.GPIOE),\n                                 dp.GPIOF.split(ccdr.peripheral.GPIOF),\n                                 dp.GPIOG.split(ccdr.peripheral.GPIOG));\n\n    let mut user_leds = bsp::led::UserLeds::new(pins.user_leds);\n\n\n    // - configure spi --------------------------------------------------------\n\n    let mut timer = dp.TIM7.timer(1.hz(), ccdr.peripheral.TIM7, &ccdr.clocks);\n    let mut delay = Delay::new(cp.SYST, ccdr.clocks);\n\n    let spi3_irq  = pins.d43.into_pull_down_input();\n    let spi3_rst  = pins.d44.into_push_pull_output();\n    let spi3_sck  = pins.d45.into_alternate_af6().set_speed(hal::gpio::Speed::VeryHigh);\n    let spi3_miso = pins.d46.into_alternate_af6().set_speed(hal::gpio::Speed::VeryHigh);\n    let spi3_mosi = pins.d47.into_alternate_af6().set_speed(hal::gpio::Speed::VeryHigh);\n\n    use nucleo_h7xx::embedded_hal::digital::v2::OutputPin;\n    let mut spi3_nss  = pins.d20.into_push_pull_output();\n    spi3_nss.set_high().ok();\n\n    let config = hal::spi::Config::new(\n        spi::Mode {\n            polarity: spi::Polarity::IdleLow,\n            phase: spi::Phase::CaptureOnFirstTransition,\n        }\n    );\n\n    let mut spi3 = dp.SPI3.spi(\n        (spi3_sck, spi3_miso, spi3_mosi),\n        config,\n        3.mhz(),\n        ccdr.peripheral.SPI3,\n        &ccdr.clocks,\n    );\n\n\n    // - bluenrg --------------------------------------------------------------\n\n    use ockam_transport_ble::driver::CHARACTERISTIC_VALUE_LENGTH;\n    let ble_addr = ockam_transport_ble::parse_ble_addr(\"ockam_ble_1\").unwrap();\n\n    let mut rx_buffer: [u8; CHARACTERISTIC_VALUE_LENGTH] = [0; CHARACTERISTIC_VALUE_LENGTH];\n    let mut bluetooth = bluenrg::BlueNRG::new(\n        &mut rx_buffer,\n        spi3_nss,\n        spi3_irq,\n        spi3_rst\n    );\n\n    // hardware reset\n    println!(\"\\n\\treset bluenrg-ms device\");\n    bluetooth.reset(&mut timer, 2.hz()).ok();\n    match bluetooth.with_spi(&mut spi3, |controller| block!(controller.read())) {\n        Ok(packet) => {\n            let bluetooth_hci::host::uart::Packet::Event(event) = packet;\n            ble_uart::dispatch_event(&event);\n        }\n        Err(e) => println!(\"reset error: {:?}\", e),\n    }\n\n    // test device comms\n    ble::read_local_version_information(&mut spi3, &mut bluetooth)\n        .expect(\"ble::read_local_version_information failed\");\n\n\n    // - configure ble uart ---------------------------------------------------\n\n    ble_uart::setup(&mut spi3, &mut bluetooth)\n        .expect(\"ble_uart::setup failed\");\n    delay.delay_ms(500u16);\n    let mut context = ble_uart::initialize_gatt_and_gap(&mut spi3, &mut bluetooth, &ble_addr)\n        .expect(\"ble_uart::initialize_gatt_and_gap failed\");\n    delay.delay_ms(500u16);\n    ble_uart::initialize_uart(&mut spi3, &mut bluetooth, &mut context)\n        .expect(\"ble_uart::initialize_uart failed\");\n    delay.delay_ms(500u16);\n\n\n    // - main loop ------------------------------------------------------------\n\n    let mut counter: usize = 0;\n\n    println!(\"\\nentering main loop\");\n\n    #[derive(Debug, PartialEq)]\n    enum State {\n        Disconnected,\n        Advertising,\n        Connected,\n        Error,\n    }\n\n    use ockam_transport_ble::driver::bluetooth_hci::Event;\n\n    //use bluetooth_hci::event::command::ReturnParameters::Vendor as Vendor;\n    //use bluetooth_hci::Vendor;\n\n    use bluenrg::event::BlueNRGEvent;\n\n    let mut state = State::Disconnected;\n    loop {\n        match state {\n            State::Disconnected => {\n                ble_uart::start_advertising(&mut spi3, &mut bluetooth, &mut context, &ble_addr)\n                    .expect(\"ble_uart::make_connection failed\");\n                state = State::Advertising;\n                println!(\"\\nstate = {:?}\", state);\n            }\n            State::Advertising => {\n            }\n            State::Connected => {\n            }\n            State::Error => {\n            }\n        }\n\n        ble_uart::poll(&mut spi3, &mut bluetooth, |event| {\n            match event {\n                Event::LeConnectionComplete(event) => {\n                    println!(\"\\t=> LeConnectionComplete -> {:?}\", event);\n                    state = State::Connected;\n                    println!(\"\\nstate = {:?}\", state);\n                }\n                Event::Vendor(BlueNRGEvent::GattAttributeModified(event)) => {\n                    if event.attr_handle == context.uart_rx_attribute_handle\n                        .expect(\"rx attribute handle is not set\")\n                    {\n                        if let Ok(data) = core::str::from_utf8(event.data()) {\n                            println!(\"\\t=> Rx: -> {:?}\", data);\n                        } else {\n                            println!(\"\\t=> Rx: -> {:?}\", event.data());\n                        }\n                    } else {\n                        println!(\"\\t=> Rx unknown: -> {:?}\", event);\n                    }\n                }\n                Event::DisconnectionComplete(event) => {\n                    println!(\"\\t=> DisconnectionComplete -> {:?}\", event);\n                    state = State::Disconnected;\n                    println!(\"\\nstate = {:?}\", state);\n                }\n                _ => {\n                    println!(\"\\t=> unknown event: {:?}\", event);\n                }\n            }\n            Some(State::Error)\n        });\n\n        if counter % 1000_000 == 0 && state == State::Connected {\n            //led.toggle().ok();\n\n            // create message buffer\n            let mut tx_buffer = [0 as u8; CHARACTERISTIC_VALUE_LENGTH];\n            let mut tx_cursor = Cursor::new(&mut tx_buffer[..]);\n            match write!(&mut tx_cursor, \"server counter: {}\", counter / 100_000) {\n            //match write!(&mut tx_cursor, \"0123456789012345678 server: {}\", counter / 100_000) {\n                Ok(()) => (),\n                Err(e) => {\n                    println!(\"failed write: {:?}\", e);\n                    continue\n                }\n            }\n            let position: usize = tx_cursor.position() as usize;\n            let tx_buffer = &tx_cursor.into_inner()[0..position];\n\n            // send message buffer\n            block!(bluetooth.with_spi(&mut spi3, |controller| {\n                controller.update_characteristic_value(&bluenrg::gatt::UpdateCharacteristicValueParameters {\n                    service_handle: context.uart_service_handle.expect(\"uart service handle has not been set\"),\n                    characteristic_handle: context.uart_tx_handle.expect(\"uart tx handle has not been set\"),\n                    offset: 0x00,\n                    value: tx_buffer,\n                })\n            })).unwrap();\n            ble_uart::controller_read(&mut spi3, &mut bluetooth);\n        }\n\n        if counter >= 0xffff_fffe {\n            break;\n        } else {\n            counter += 1;\n        }\n    }\n\n    Ok(())\n}", "item_id": 0, "repo": "antoinevg/hello_ockam_embedded", "file": "examples/hello_transport.rs", "last_update_at": "2022-01-11T07:22:39+00:00"}
{"hexsha": "bfc489018883d968955a4b6a7de8c6ce38abbb90", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    // Tell cargo to tell rustc to link the system bzip2\n    // shared library.\n    println!(\"cargo:rustc-link-lib=static=honey_analyzer\");\n    println!(\"cargo:rustc-link-search=./Honeybee/build\");\n\n    Command::new(\"make\")\n        .args(&[\"-C\", \"./Honeybee/build\"])\n        .output()\n        .expect(\"could not run make\");\n\n    // Tell cargo to invalidate the built crate whenever the wrapper changes\n    println!(\"cargo:rerun-if-changed=wrapper.h\");\n    println!(\"cargo:rerun-if-changed=./Honeybee/build/libhoney_analyzer.a\");\n\n    // The bindgen::Builder is the main entry point\n    // to bindgen, and lets you build up options for\n    // the resulting bindings.\n    let bindings = bindgen::Builder::default()\n        // The input header we would like to generate\n        // bindings for.\n        .header(\"wrapper.h\")\n        // Tell cargo to invalidate the built crate whenever any of the\n        // included header files changed.\n        .parse_callbacks(Box::new(bindgen::CargoCallbacks))\n        // Finish the builder and generate the bindings.\n        .generate()\n        // Unwrap the Result and panic on failure.\n        .expect(\"Unable to generate bindings\");\n\n    // Write the bindings to the $OUT_DIR/bindings.rs file.\n    let out_path = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n    bindings\n        .write_to_file(out_path.join(\"bindings.rs\"))\n        .expect(\"Couldn't write bindings!\");\n}", "item_id": 0, "repo": "Lukas-Dresel/rust-honeybee-sys", "file": "build.rs", "last_update_at": "2022-03-22T09:39:24+00:00"}
{"hexsha": "2bb86ce178202df66c7ed4d9d7dd56bb2335408b", "ext": "rs", "lang": "Rust", "content": "pub fn parse_start_simulation_job_batch_error(\n    response: &http::Response<bytes::Bytes>,\n) -> std::result::Result<\n    crate::output::StartSimulationJobBatchOutput,\n    crate::error::StartSimulationJobBatchError,\n> {\n    let generic = crate::json_deser::parse_http_generic_error(response)\n        .map_err(crate::error::StartSimulationJobBatchError::unhandled)?;\n    let error_code = match generic.code() {\n        Some(code) => code,\n        None => {\n            return Err(crate::error::StartSimulationJobBatchError::unhandled(\n                generic,\n            ))\n        }\n    };\n\n    let _error_message = generic.message().map(|msg| msg.to_owned());\n    Err(match error_code {\n        \"IdempotentParameterMismatchException\" => crate::error::StartSimulationJobBatchError {\n            meta: generic,\n            kind:\n                crate::error::StartSimulationJobBatchErrorKind::IdempotentParameterMismatchException(\n                    {\n                        #[allow(unused_mut)]\n                        let mut tmp = {\n                            #[allow(unused_mut)]let mut output = crate::error::idempotent_parameter_mismatch_exception::Builder::default();\n                            let _ = response;\n                            output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;\n                            output.build()\n                        };\n                        if (&tmp.message).is_none() {\n                            tmp.message = _error_message;\n                        }\n                        tmp\n                    },\n                ),\n        },\n        \"InternalServerException\" => crate::error::StartSimulationJobBatchError {\n            meta: generic,\n            kind: crate::error::StartSimulationJobBatchErrorKind::InternalServerException({\n                #[allow(unused_mut)]\n                let mut tmp = {\n                    #[allow(unused_mut)]\n                    let mut output = crate::error::internal_server_exception::Builder::default();\n                    let _ = response;\n                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;\n                    output.build()\n                };\n                if (&tmp.message).is_none() {\n                    tmp.message = _error_message;\n                }\n                tmp\n            }),\n        },\n        \"InvalidParameterException\" => crate::error::StartSimulationJobBatchError {\n            meta: generic,\n            kind: crate::error::StartSimulationJobBatchErrorKind::InvalidParameterException({\n                #[allow(unused_mut)]\n                let mut tmp = {\n                    #[allow(unused_mut)]\n                    let mut output = crate::error::invalid_parameter_exception::Builder::default();\n                    let _ = response;\n                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;\n                    output.build()\n                };\n                if (&tmp.message).is_none() {\n                    tmp.message = _error_message;\n                }\n                tmp\n            }),\n        },\n        \"LimitExceededException\" => crate::error::StartSimulationJobBatchError {\n            meta: generic,\n            kind: crate::error::StartSimulationJobBatchErrorKind::LimitExceededException({\n                #[allow(unused_mut)]\n                let mut tmp = {\n                    #[allow(unused_mut)]\n                    let mut output = crate::error::limit_exceeded_exception::Builder::default();\n                    let _ = response;\n                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;\n                    output.build()\n                };\n                if (&tmp.message).is_none() {\n                    tmp.message = _error_message;\n                }\n                tmp\n            }),\n        },\n        \"ThrottlingException\" => crate::error::StartSimulationJobBatchError {\n            meta: generic,\n            kind: crate::error::StartSimulationJobBatchErrorKind::ThrottlingException({\n                #[allow(unused_mut)]\n                let mut tmp = {\n                    #[allow(unused_mut)]\n                    let mut output = crate::error::throttling_exception::Builder::default();\n                    let _ = response;\n                    output = crate::json_deser::deser_structure_crate_error_throttling_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;\n                    output.build()\n                };\n                if (&tmp.message).is_none() {\n                    tmp.message = _error_message;\n                }\n                tmp\n            }),\n        },\n        _ => crate::error::StartSimulationJobBatchError::generic(generic),\n    })\n}", "item_id": 50, "repo": "StevenBlack/aws-sdk-rust", "file": "sdk/robomaker/src/operation_deser.rs", "last_update_at": "2022-03-31T20:47:15+00:00"}
{"hexsha": "008e114c66c0517e2af7501e3ada08ad0af373c7", "ext": "rs", "lang": "Rust", "content": "fn try_main() -> Result<()> {\n    let args = env::args_os()\n        .skip(1)\n        .map(PathBuf::from)\n        .collect::<Vec<_>>();\n\n    let (crate_path, bin_path, target_path) = match args[..] {\n        [ref c, ref b, ref t] => (c, b, t),\n        _ => bail!(\"Incorrect usage\"),\n    };\n\n    Bundler::new_with_dir(bin_path, target_path.parent().unwrap(), crate_path)?\n        .bundle(Path::new(target_path.file_name().unwrap()))?;\n\n    Ok(())\n}", "item_id": 0, "repo": "Aetf/rust-script-bundler", "file": "src/bin/rust-script-bundle.rs", "last_update_at": "2022-01-22T03:43:40+00:00"}
{"hexsha": "7a35cd8f8ca91a6b6aaf419a68a0563c8d688a9a", "ext": "rs", "lang": "Rust", "content": "fn test_databases_books_annotated() {\n        let app = app_from_test_db(\"books-annotated\");\n\n        assert_eq!(app.stor().count_books(), 3);\n        assert_eq!(app.stor().count_annotations(), 10);\n    }", "item_id": 3, "repo": "tnahs/readstor", "file": "src/cli/app.rs", "last_update_at": "2022-02-20T14:48:56+00:00"}
{"hexsha": "f4c80467512e38daec9973a973da8fe1787ff711", "ext": "rs", "lang": "Rust", "content": "pub fn build_collection(\n    collection_path: &Path,\n    wal_config: &WalConfig,               // from config\n    collection_params: &CollectionParams, //  from user\n    optimizers_config: &OptimizersConfig,\n    hnsw_config: &HnswConfig,\n) -> CollectionResult<Collection> {\n    let wal_path = collection_path.join(\"wal\");\n\n    create_dir_all(&wal_path).map_err(|err| CollectionError::ServiceError {\n        error: format!(\"Can't create collection directory. Error: {}\", err),\n    })?;\n\n    let segments_path = collection_path.join(\"segments\");\n\n    create_dir_all(&segments_path).map_err(|err| CollectionError::ServiceError {\n        error: format!(\"Can't create collection directory. Error: {}\", err),\n    })?;\n\n    let mut segment_holder = SegmentHolder::default();\n\n    let schema_storage = Arc::new(SchemaStorage::new());\n\n    for _sid in 0..optimizers_config.default_segment_number {\n        let segment = build_simple_segment(\n            &segments_path,\n            collection_params.vector_size,\n            collection_params.distance,\n            schema_storage.clone(),\n        )?;\n        segment_holder.add(segment);\n    }\n\n    let wal: SerdeWal<CollectionUpdateOperations> =\n        SerdeWal::new(wal_path.to_str().unwrap(), &wal_config.into())?;\n\n    let collection_config = CollectionConfig {\n        params: collection_params.clone(),\n        hnsw_config: *hnsw_config,\n        optimizer_config: optimizers_config.clone(),\n        wal_config: wal_config.clone(),\n    };\n\n    collection_config.save(collection_path)?;\n\n    let optimizers = build_optimizers(\n        collection_path,\n        collection_params,\n        optimizers_config,\n        &collection_config.hnsw_config,\n        schema_storage.clone(),\n    );\n\n    let collection = construct_collection(\n        segment_holder,\n        collection_config,\n        wal,\n        optimizers,\n        collection_path,\n        schema_storage,\n    );\n\n    Ok(collection)\n}", "item_id": 1, "repo": "HaiCheViet/qdrant", "file": "lib/collection/src/collection_builder/collection_builder_base.rs", "last_update_at": "2022-03-29T14:28:30+00:00"}
{"hexsha": "288b05878c115cf8d8040303a66291955e35deae", "ext": "rs", "lang": "Rust", "content": "fn get_block(&self, position: usize) -> Self::Block {\n        assert!(position < self.block_len(),\n                format!(\"Bits::get_block: out of bounds ({}/{})\",\n                        position, self.block_len()));\n\n        let first_bit = Self::Block::mul_nbits(position);\n        let bit_count = Self::Block::block_bits(self.bit_len(), position);\n\n        let mut result = Self::Block::zero();\n        let mut mask = Self::Block::one();\n\n        for i in 0 .. bit_count as u64 {\n            if self.get_bit(first_bit + i) {\n                result = result | mask;\n            }\n            mask = mask << 1;\n        }\n\n        result\n    }", "item_id": 1, "repo": "tov/bv-rs", "file": "src/traits/bits.rs", "last_update_at": "2022-03-11T21:57:21+00:00"}
{"hexsha": "50e37a221451a6e4926acb115f4082c5afea99b0", "ext": "rs", "lang": "Rust", "content": "fn test_add_offset() {\n        let q1 = UnitQuaternion::from_quaternion(Quaternion::new(\n            4.329780281177467e-17,\n            0.7071067811865476,\n            4.329780281177466e-17,\n            0.7071067811865475,\n        ));\n        let t = Translation3::new(0.2, 1.4, 2.);\n        let mut position = Isometry3::from_parts(t, q1);\n        apply_grip_offset(&mut position);\n\n        let expected_rotation = Quaternion::new(\n            -0.5493369162990798,\n            -0.4188107240790279,\n            0.6209124327141259,\n            -0.3705324286596844,\n        );\n        let expected_translation = Translation3::new(0.2, 1.328827, 2.066082);\n\n        approx::assert_relative_eq!(position.rotation.quaternion(), &expected_rotation);\n        approx::assert_relative_eq!(position.translation, &expected_translation);\n    }", "item_id": 4, "repo": "leetvr/hotham", "file": "examples/beat-saber-clone/src/systems/sabers.rs", "last_update_at": "2022-03-30T11:15:40+00:00"}
{"hexsha": "378b0c384de771b6b3e18cc42ab0e276a648fb5b", "ext": "rs", "lang": "Rust", "content": "fn test_n_triples_parse_literal() {\n        let input = \"\\\"a\\\"\".as_bytes();\n\n        let mut lexer = NTriplesLexer::new(input);\n\n        assert_eq!(\n            lexer.get_next_token().unwrap(),\n            Token::Literal(\"a\".to_string())\n        );\n    }", "item_id": 1, "repo": "media-io/rdf-rs", "file": "src/reader/lexer/n_triples_lexer.rs", "last_update_at": "2022-02-20T23:01:21+00:00"}
{"hexsha": "c0ef355e1a4d368491e2928aecf91b843ab68c58", "ext": "rs", "lang": "Rust", "content": "pub fn get_test_data() -> Vec<u8> {\n    use std::env;\n    let path = env::var(\"TEST_FILE\").unwrap_or(\"tests/pg11.txt\".to_string());\n    get_test_file_data(&path)\n}", "item_id": 1, "repo": "allansrc/fuchsia", "file": "third_party/rust_crates/vendor/deflate/src/test_utils.rs", "last_update_at": "2022-03-28T07:59:06+00:00"}
{"hexsha": "3291454d9441767fcf4857710a9b2dd15cb5e40a", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let s1 = String::from(\"Hello world\");\n    let s2 = s1;\n    // s1 is not more valid\n\n    println!(\"{}, bye\", s2);\n    let s3 = s2.clone();\n    println!(\" {} ----- {}\", s2, s3);\n    take_ownership(s2);\n    let i = 0;\n    make_copy(i);\n\n    let s2 = give_ownership(s3);\n    let il = calculate_len(&s2);\n    println!(\" {} ----- {}\", s2, il);\n}", "item_id": 0, "repo": "dmike16/study-notes", "file": "rust/ownership/src/main.rs", "last_update_at": "2022-01-14T22:34:57+00:00"}
{"hexsha": "0f964ef47fe7df50a72fa11257c1413277cf8ab0", "ext": "rs", "lang": "Rust", "content": "fn stop_search_in_tab<TFileSystem: Clone + Debug + Default + FileSystem>(\n    tabs: Vec<TabState<TFileSystem>>,\n    tab: TabIdx,\n) -> Vec<TabState<TFileSystem>> {\n    let mut result = Vec::<TabState<TFileSystem>>::new();\n\n    for (idx, tab_state) in tabs.iter().enumerate() {\n        if idx == tab {\n            result.push(TabState {\n                search_mode: false,\n                phrase: String::from(\"\"),\n                ..tab_state.clone()\n            });\n        } else {\n            result.push(tab_state.clone());\n        }\n    }\n\n    result\n}", "item_id": 1, "repo": "mihaigalos/sfm", "file": "src/app/reducers/search_reducer.rs", "last_update_at": "2022-03-09T01:18:31+00:00"}
{"hexsha": "ead18f7810c59496ea57eb60be925abf8a067436", "ext": "rs", "lang": "Rust", "content": "fn test_bitvec_set_raw_copy() {\n    let v = vec![7];\n    let buf = v.as_ptr();\n    let mut bitvec = unsafe { BitVec::from_raw_copy(buf, 1, 64) };\n    let ptr = bitvec.storage.as_mut_ptr();\n    let buffer_len = bitvec.storage.len();\n    let mut bitvec2 = BitVec::zeros(1);\n    unsafe {\n        bitvec2.set_raw_copy(ptr, buffer_len, bitvec.nbits);\n    }\n    assert_eq!(v.len(), 1); // ensure v lives long enough\n    assert_eq!(bitvec2.get(0), Some(true));\n    assert_eq!(bitvec2.get(1), Some(true));\n    assert_eq!(bitvec2.get(2), Some(true));\n    assert_eq!(bitvec2.get(3), Some(false));\n    assert_eq!(bitvec2.get(63), Some(false));\n    assert_eq!(bitvec2.get(64), None);\n}", "item_id": 12, "repo": "GCCFeli/bitvec_simd", "file": "src/tests.rs", "last_update_at": "2022-03-18T03:45:50+00:00"}
{"hexsha": "87138225c889272ff48408c3c09661d09fda2894", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    #[derive(Form)]\n    #[form(newtype)]\n    struct A{}\n}", "item_id": 0, "repo": "swimos/swim-rust", "file": "api/swim_form/src/tests/derive/form/newtype_empty_struct.rs", "last_update_at": "2022-02-10T00:59:19+00:00"}
{"hexsha": "24068e3b222ff3ad03e1e0e3566ae2cdfae4aeaf", "ext": "rs", "lang": "Rust", "content": "fn copy(matches: getopts::Matches) {\n    let sources: Vec<String> = if matches.free.is_empty() {\n        show_error!(\"Missing SOURCE argument. Try --help.\");\n        panic!()\n    } else {\n        // All but the last argument:\n        matches.free[..matches.free.len() - 1].iter().cloned().collect()\n    };\n    let dest = if matches.free.len() < 2 {\n        show_error!(\"Missing DEST argument. Try --help.\");\n        panic!()\n    } else {\n        // Only the last argument:\n        Path::new(&matches.free[matches.free.len() - 1])\n    };\n\n    assert!(sources.len() >= 1);\n\n    if sources.len() == 1 {\n        let source = Path::new(&sources[0]);\n        let same_file = paths_refer_to_same_file(source, dest).unwrap_or_else(|err| {\n            match err.kind() {\n                ErrorKind::NotFound => false,\n                _ => {\n                    show_error!(\"{}\", err);\n                    panic!()\n                }\n            }\n        });\n\n        if same_file {\n            show_error!(\"\\\"{}\\\" and \\\"{}\\\" are the same file\",\n                source.display(),\n                dest.display());\n            panic!();\n        }\n\n        if let Err(err) = fs::copy(source, dest) {\n            show_error!(\"{}\", err);\n            panic!();\n        }\n    } else {\n        if !dest.is_dir() {\n            show_error!(\"TARGET must be a directory\");\n            panic!();\n        }\n\n        for src in &sources {\n            let source = Path::new(&src);\n\n            if !source.is_file() {\n                show_error!(\"\\\"{}\\\" is not a file\", source.display());\n                continue;\n            }\n\n            let mut full_dest = dest.to_path_buf();\n\n            full_dest.push(source.to_str().unwrap());\n\n            println!(\"{}\", full_dest.display());\n\n            let io_result = fs::copy(source, full_dest);\n\n            if let Err(err) = io_result {\n                show_error!(\"{}\", err);\n                panic!()\n            }\n        }\n    }\n}", "item_id": 1, "repo": "KokaKiwi/coreutils", "file": "src/cp/cp.rs", "last_update_at": "2022-02-08T08:44:00+00:00"}
{"hexsha": "db9dbc74b12bdbaa442c66982b7ad32de4420b40", "ext": "rs", "lang": "Rust", "content": "pub fn consume(channel: Channel, basic_consume: BasicConsume) -> MethodResponse {\n    let BasicConsume {\n        queue: queue_name,\n        consumer_tag,\n        no_local,\n        no_ack,\n        exclusive,\n        no_wait,\n        ..\n    } = basic_consume;\n\n    if no_local || exclusive || no_ack {\n        amqp_todo!();\n    }\n\n    let global_data = channel.global_data.clone();\n\n    let consumer_tag = if consumer_tag.is_empty() {\n        haesli_core::random_uuid().to_string()\n    } else {\n        consumer_tag\n    };\n\n    let mut global_data = global_data.lock();\n\n    let queue = global_data\n        .queues\n        .get_mut(queue_name.as_str())\n        .ok_or(ChannelException::NotFound)?;\n\n    let consumer = Consumer {\n        id: ConsumerId::random(),\n        tag: consumer_tag.clone(),\n        channel: Arc::clone(&channel),\n        queue: Arc::clone(queue),\n    };\n\n    queue.consumers.lock().insert(consumer.id, consumer.clone());\n\n    channel.connection.consuming.lock().push(consumer);\n\n    info!(%queue_name, %consumer_tag, \"Consumer started consuming\");\n\n    Ok(no_wait\n        .not()\n        .then(|| Method::BasicConsumeOk(BasicConsumeOk { consumer_tag })))\n}", "item_id": 0, "repo": "Nilstrieb/haesli", "file": "haesli_messaging/src/methods/consume.rs", "last_update_at": "2022-02-21T14:06:42+00:00"}
{"hexsha": "e0c0885fe3e34bd594657dc9b93874c7cb20d856", "ext": "rs", "lang": "Rust", "content": "fn to_diagram(src: &str) -> (String, Vec<(&'static str, String)>) {\n    let macro_rules = macro_railroad::parser::parse(&src).expect(src);\n    let mut tree = macro_railroad::lowering::MacroRules::from(macro_rules);\n    let name = tree.name.clone();\n    let mut v = Vec::new();\n\n    v.push((\n        \"vanilla\",\n        macro_railroad::diagram::into_diagram(tree.clone(), true).to_string(),\n    ));\n\n    let mut tree_ungrouped = tree.clone();\n    tree_ungrouped.ungroup();\n    v.push((\n        \"ungrouped\",\n        macro_railroad::diagram::into_diagram(tree_ungrouped, false).to_string(),\n    ));\n\n    tree.remove_internal();\n    tree.foldcommontails();\n    tree.normalize();\n    v.push((\n        \"optimized\",\n        macro_railroad::diagram::into_diagram(tree, true).to_string(),\n    ));\n\n    (name, v)\n}", "item_id": 0, "repo": "lukaslueg/macro_railroad", "file": "tests/verification.rs", "last_update_at": "2022-03-31T09:08:44+00:00"}
{"hexsha": "422c2630057f5e3b37c74adb2284892b77a510a1", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn media_unsuspend<T: RTSPMediaImpl>(\n    ptr: *mut ffi::GstRTSPMedia,\n) -> glib::ffi::gboolean {\n    let instance = &*(ptr as *mut T::Instance);\n    let imp = instance.impl_();\n    let wrap: Borrowed<RTSPMedia> = from_glib_borrow(ptr);\n\n    match imp.unsuspend(wrap.unsafe_cast_ref()) {\n        Ok(()) => glib::ffi::GTRUE,\n        Err(err) => {\n            err.log_with_object(&*wrap);\n            glib::ffi::GFALSE\n        }\n    }\n}", "item_id": 4, "repo": "pbor/gstreamer-rs", "file": "gstreamer-rtsp-server/src/subclass/rtsp_media.rs", "last_update_at": "2022-03-20T06:06:05+00:00"}
{"hexsha": "8a15579b1ca5073c0fed58e1bfa0cbaca93c9167", "ext": "rs", "lang": "Rust", "content": "fn panicIfProcessNotSuccessful(programName: &'static str, absoluteHomeFolderPath: &str, mut command: Command) -> String\n{\n\tlet output = command.output().unwrap_or_else(|error|\n\t{\n\t\tpanic!(\"Failed to execute '{}' in '{}' error was '{}'\", programName, absoluteHomeFolderPath, error);\n\t});\n\t\n\tlet code = output.status.code().unwrap_or_else(||\n\t{\n\t\tpanic!(\"Failed to retrieve exit status from command - was it killed by a signal?\");\n\t});\n\n\tlet standardOut = String::from_utf8_lossy(&output.stdout);\n\tif code == 0\n\t{\n\t\treturn standardOut.into_owned();\n\t}\n\t\n\tlet standardError = String::from_utf8_lossy(&output.stderr);\n\tpanic!(\"Command '{}' failed with exit code '{}' (standard out was '{}'; standard error was '{}')\", programName, code, standardOut.into_owned(), standardError.into_owned());\n}", "item_id": 1, "repo": "lemonrock/rdma-core", "file": "workspace/mxm-reference-sys/src/build.rs", "last_update_at": "2022-01-02T22:09:52+00:00"}
{"hexsha": "b81ef9dc4252d344f33a898fa7fb1991639ccc4e", "ext": "rs", "lang": "Rust", "content": "fn data_set() -> Vec<Vec<u8>> {\n\tuse rand::SeedableRng;\n\tuse rand::Rng;\n\n\tlet rnd: [u8; 32] = rand::rngs::StdRng::seed_from_u64(12).gen();\n\tlet mut rnd = rnd.iter().cycle();\n\tlet mut res = Vec::new();\n\tfor size in 1..=MAX_KEY_SIZE {\n\t\tfor _ in 0..1_000 {\n\t\t\tlet value = (0..size)\n\t\t\t\t.map(|_| rnd.next().unwrap().clone())\n\t\t\t\t.collect();\n\t\t\tres.push(value);\n\t\t}\n\t}\n\tres\n}", "item_id": 0, "repo": "wm5713/blogs", "file": "learn substrate/substrate-1.0/core/primitives/benches/benches.rs", "last_update_at": "2022-02-14T16:09:57+00:00"}
{"hexsha": "3e0ce1e812879c263dd5be267ffee55661505718", "ext": "rs", "lang": "Rust", "content": "pub fn send(socket: &std::net::UdpSocket, transmits: &[Transmit]) -> Result<usize> {\n        let mut sent = 0;\n        for transmit in transmits {\n            match socket.send_to(&transmit.contents, &transmit.destination) {\n                Ok(_) => {\n                    sent += 1;\n                }\n                Err(_) if sent != 0 => {\n                    // We need to report that some packets were sent in this case, so we rely on\n                    // errors being either harmlessly transient (in the case of WouldBlock) or\n                    // recurring on the next call.\n                    return Ok(sent);\n                }\n                Err(e) => {\n                    return Err(e);\n                }\n            }\n        }\n        Ok(sent)\n    }", "item_id": 0, "repo": "kpp/udp-socket", "file": "src/socket.rs", "last_update_at": "2022-02-12T11:23:43+00:00"}
{"hexsha": "7a907a172847881dbf26c6ede66f2c73522f7f89", "ext": "rs", "lang": "Rust", "content": "fn test_initialize() {\n    let (_, api) = create_testkit(InitParam {\n        v_bit_len: vec![16],\n        is_acc2: true,\n        intra_index: true,\n        skip_list_max_level: 2,\n    });\n    let param = api.get_param();\n    assert_eq!(param.v_bit_len, vec![16]);\n    assert_eq!(param.acc_type, acc::Type::ACC2);\n    assert_eq!(param.use_sk, false);\n    assert_eq!(param.intra_index, true);\n    assert_eq!(param.skip_list_max_level, 2);\n}", "item_id": 1, "repo": "hkbudb/vchain-demo", "file": "vchain-exonum/src/tests.rs", "last_update_at": "2022-02-25T05:43:33+00:00"}
{"hexsha": "fa66a4903760d0893eca7c35bd266573e901b2b5", "ext": "rs", "lang": "Rust", "content": "fn dropped_update_action() {\n    let mut state = (DownlinkState::Synced, SharedValue::new(Value::from(13)));\n\n    let machine = unvalidated(Value::from(0));\n    let (action, _) = make_update();\n\n    let result = machine.handle_action_request(&mut state, action);\n\n    let (dl_state, data_state) = state;\n\n    assert!(result.is_ok());\n    let response = result.unwrap();\n\n    assert!(\n        matches!(response, Response{ event: Some(ev), command: Some(Command::Action(cmd)) } if *ev == *data_state && *cmd == *data_state)\n    );\n\n    assert_eq!(dl_state, DownlinkState::Synced);\n    assert_eq!(*data_state, Value::from(26));\n}", "item_id": 14, "repo": "swimos/swim-rust", "file": "swim_client/src/downlink/state_machine/value/tests.rs", "last_update_at": "2022-02-10T00:59:19+00:00"}
{"hexsha": "2d258eff0d2cd59939147908da5d87f11534bc63", "ext": "rs", "lang": "Rust", "content": "fn reestablish_channel_test() {\n        let msg_hex = \"\\\n            00880100000000000000000000000000000000000000000000000000000000000000000000000000\\\n            000b0000000000000002000200000000000000000000000000000000000000000000000000000000\\\n            0000031de8e2207c6ad1d81f5458c40b9cb1b519448ad67b00983e411ef522cbb187b6\";\n        let msg_bytes = hex::decode(msg_hex).unwrap();\n\n        let msg_correct = ReestablishChannel {\n            channel_id: ChannelId::from_hex(\"0100000000000000000000000000000000000000000000000000000000000000\").unwrap(),\n            next_local_commitment_number: 11,\n            next_remote_revocation_number: 2,\n            last_remote_commit_secret: u8_32_from_hex(\"0002000000000000000000000000000000000000000000000000000000000000\").unwrap(),\n            local_unrevoked_commit_point: RawPublicKey::from_hex(\"031de8e2207c6ad1d81f5458c40b9cb1b519448ad67b00983e411ef522cbb187b6\").unwrap(),\n        };\n        let wrapped_msg_correct = Message::ReestablishChannel(msg_correct);\n\n        let mut cursor = Cursor::new(msg_bytes.clone());\n        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();\n        assert_eq!(&msg, &wrapped_msg_correct);\n\n        // Now check deserialization\n        let mut new_msg_bytes = vec![];\n        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();\n        assert_eq!(new_msg_bytes, msg_bytes);\n    }", "item_id": 3, "repo": "LightningPeach/lpd", "file": "wire/src/message/channel/open.rs", "last_update_at": "2022-01-02T11:14:21+00:00"}
{"hexsha": "513c01a10ce557423b902e4c7d2acbb446f4d2b2", "ext": "rs", "lang": "Rust", "content": "pub fn represent_into_bits(x: u64) -> Vec<u8> {\n        let mut result = Vec::with_capacity(64);\n        let mut x = x;\n        for _ in 0..64 {\n            let bit = x & 1;\n            let bit = bit as u8;\n            result.push(bit);\n            x >>= 1;\n        }\n        assert_eq!(result.len(), 64);\n        result\n    }", "item_id": 4, "repo": "Endle/rust-bundler-cp", "file": "tests/testdata/output/multiple_binaries.rs", "last_update_at": "2022-03-09T13:16:45+00:00"}
{"hexsha": "cc85375e5830f2356c9bb120240414a1336967f5", "ext": "rs", "lang": "Rust", "content": "pub fn decode(input: &str) -> String {\n    // convert encoded characters to indices from the b64 string\n    let mut indices = vec![];\n    for chara in input.chars() {\n        indices.push(get_b64_index(chara));\n    }\n\n    // convert the decimal indices to binary representation\n    let mut indices_bytes = vec![];\n    for index in indices {\n        indices_bytes.push(dec_to_bin(index as u8));\n    }\n\n    // pad the binary values if necessary\n    let mut bits_str = String::new();\n    for mut byte in indices_bytes {\n        if byte.len() < 6 {\n            let padding_amount = 6 - byte.len();\n            let mut padding = String::new();\n            for _i in 0..padding_amount {\n                padding += \"0\";\n            }\n            byte = format!(\"{}{}\", padding, byte);\n        }\n        bits_str += &byte;\n    }\n\n    // divide the binary string into bytes\n    let mut bytes = vec![];\n    while !bits_str.is_empty() {\n        if (bits_str.len()) >= 8 {\n            bytes.push(bits_str[0..8].to_string());\n            bits_str = (&bits_str[8..]).to_string();\n        } else {\n            bytes.push(bits_str.to_string());\n            String::clear(&mut bits_str);\n        }\n    }\n\n    // decode ascii bytes to characters in str\n    let mut decoded = String::new();\n    for byte in bytes {\n        decoded.push((binary_to_dec(&byte)) as char);\n    }\n\n    // return decoded String\n    decoded\n}", "item_id": 1, "repo": "gomihiko/b64rs", "file": "src/b64rs.rs", "last_update_at": "2022-02-21T22:18:29+00:00"}
{"hexsha": "86498bf9e5c8fae2b68cf194a1ad32d2c946040f", "ext": "rs", "lang": "Rust", "content": "pub fn i64_nullable_field(field_name: &str, data: &[Option<i64>], fields: &mut Vec<Field>, columns: &mut Vec<ArrayRef>) {\n    let mut builder = Int64Builder::new(data.len());\n    data.iter().for_each(|value| {\n        match value {\n            None => builder.append_null(),\n            Some(value) => builder.append_value(*value),\n        }\n            .expect(\"append data into builder failed\")\n    });\n    let array = builder.finish();\n    if array.null_count() < array.len() {\n        fields.push(Field::new(field_name, DataType::Int64, array.null_count() > 0));\n        columns.push(Arc::new(array));\n    }\n}", "item_id": 6, "repo": "lquerel/oltp-arrow", "file": "crates/trace/src/arrow/mod.rs", "last_update_at": "2022-02-01T22:51:42+00:00"}
{"hexsha": "1f1c81f7ac1a0489cb978eaa361e1509557cc9c8", "ext": "rs", "lang": "Rust", "content": "fn test_ec_aes_siv_test_vectors() {\n    tink_hybrid::init();\n    // These are the same test vectors used to test the c++ implementation in\n    // tink/cc/hybrid/ecies_aead_hkdf_hybrid_decrypt_test.cc.\n    struct TestCase {\n        name: &'static str,\n        key: &'static str,\n        ciphertext: &'static str,\n        context: &'static str,\n        plaintext: &'static str,\n    }\n    let test_vectors = vec![\n        TestCase {\n            name:       \"Empty plaintext\",\n            key:        \"32588172ed65830571bb83748f7fddd383323208a7825c80a71bef846333eb02\",\n            ciphertext: \"0401b11f8c9bafe30ae13f8bd15528714e752631a4328bf146009068e99489c8e9fae1ec39e3fe9994723711417fcab2af4b3c9b60117d47d33d35175c87b483b8935a73312940d1fbf8da3944a89b5e8b\",\n            context:    \"some context info\",\n            plaintext:  \"\",\n        },\n        TestCase{\n            name:       \"Small plaintext\",\n            key:        \"32588172ed65830571bb83748f7fddd383323208a7825c80a71bef846333eb02\",\n            ciphertext: \"040230023d1547b55af5a735a7f460722612126d7539d7cd0f677d308b29c6f52a964e66e7b0cb44cff1673df9e2c793f1477ca755807bfbeadcae1ab20b45ecb1501ca5e3f5b0626d3ca40aa5d010443d506e4df90b\",\n            context:    \"some context info\",\n            plaintext:  \"hello\",\n        },\n        TestCase{\n            name:       \"Large plaintext\",\n            key:        \"32588172ed65830571bb83748f7fddd383323208a7825c80a71bef846333eb02\",\n            ciphertext: \"0441ddd246cea0825bd68bddff05cec54a4ee678da35b2f5cfbbb32e5350bdd817214bfb7b5ed5528131bde56916062cfbd8b9952d9e0907a6e87e1de54db5df3aaccddd328efcf7771ce061e647488f66b8c11a9fca171dcff813e90b44b2739573f9f23b60202491870c7ff8aaf0ae46838e48f17f8dc1ad55b67809699dd31eb6ca50dfa9beeee32d30bdc00a1eb1d8b0cbcedbe50b1e24619cc5e79042f25f49e2c2d5a35c79e833c0d68e31a93da4173aacd0428b367594ed4636763d16c23e4f8c115d44bddc83bcefcaea13587238ce8b7a5d5fad53beeb59aaa1d7483eb4bac93ed50ed4d3e9fd5af760283fd38080b58744b73212a36039179ce6f96ef1ecaa05b5186967d81c06b9cd91140dfbd54084ddcfd941527719848a2eecb84278f6a0fe9357a3964f87222fcd16a12a353e1f64fd45dc227a4a2112da6f61269f22f16b41e68eadf0b6b3a48c67b9e7e3ec1c66eecce50dda8ecbce99d3778299aa28741b7247fbc46a1b8a908dc23943c2dd17210a270bb12b096c2c6a00400a95c62894a15b9fc44e709d27348f2f2644a786cd9e96caf42ea9b949f76e85e6f7365e15fa2902e851222c025f6c208269d799fcfc4c0b37aba8979ed9e6ccf543c217ee0b6ad05f0e3ffb92943d308c801b25efedab5bf93a733bdae611132d774d4b9ee4fb5e88ae63014315ae9571039a8c8c7020e2b3a1bbd4235b65af94771c8417c87fd6cab423b82a557f60a99ae7402dba205e05136dd34f0026fce87899d4b9819cc2b2ba686512d62c41a1e3a667a705ea45404aafa489cd7f53f42455fff3f9b22f960d12a2587efd6ed0fa3e00dd4645face1b2f1268e6019be70999eab00f0aeff3cb0e77b7c4a1ab1fdf15d00c4eedd7b75e8cf5c90119346894089ee0299d58f1d7ebac9b592da2325a5a738ea2baecc1468670f5aec880bce32efecfb2a7c5ad3ae4096b0a07aa9bfe6cbaf53da6757377bb692e55ec8caf5f0af28dafdc42e1d6e5893140945a853f56652c575b99d64399aad2d042948575134c8fe638fb0b80ac3a0f08a60f3aa817fe0a24c1fffee6933bd72ea460e0b241d3f5d98b2321ee25d8c0302353fcfd41bce964d73ff670422864506cc56f3470362c90144586ccbfc8e5e6fefbb70429b0a517e4b1badb449cd11092790aba6e19b914899872f4fb481c8dc47a33422fc05072ac99c958e40dae53d96ebd87cfbde67a0f050203a89e487da5e03364951830e43771d36abfbe8f5a7da8e7aa891f36a68dbe9a3b0e3dfbd1afd6327a3ced4a5cd8a5b256fef46d200df4af2e2da4dbb786ea0404bb968b6d961e4fc76f89e70ad7c9e11d6aee6526b75b399811f73c053a29582ba9295ea4d5a8fffb5a8ccbac008d291dd60e2041371acfc4c432a0ae0fcd8fa25c9551123c95da64caa134edaee5893e19c3c76075bef419c09681a67f4ede6f28d747b53afd61ddc937d7de96a22c7db10ad8700cade888de5d6f450c15d796978ddb5e6a52e5044e90247c988686d992105c85f6d198e2de859330f973ded4d7e5d90de57051dbaf0db0febd4cf9d44da155e55293b0930f89c1d21cc227eba9615ca47cce41d16eaddb5bf5dc9bc8477df5cf21f460b83241e7d0fa3707f9d2b322b9aaa42747d0653168b095ca0a83f38426688f6f10143cbd1b84c08583b09ed6192c7366ecc23af528fc2e8c585560f9bd0fcc255b82fc70723a92506bb475ebc1f5ae34a902bf2aa75997ed90a54762c8e83720833b2fd607eee1beb347a75d3bd0f174ed450a72cce79f1be426de9d6f1a6feff052674af141b3cea89f8e749118392e9533c62ddad870e60d509fd7abfa0bc33c2774b29a0170089b30d82047d6e130c49f6965f9871d1928b7f13e3e40ad8e3dc85195f4b312f9f6d8e4158aca23a611f6c6c798983555139942536f6ac59bbd6cc88b9933f22e81429e835bfd4fec27c67520d64a0ad8fd7feb6a3fbe52dc56cbbf59644b0fad0c462ed02ffbf7258e4b94bdedefb187fbdb729a0d56a36e876ac76de766eed416f39ab4e8b1982b8d0a87cd33182ae81ecf1d1d5202cc3e82c5762646d15db5f13cde3e81c83715195f9af9f27e01e1829ce529fa0f715db1f5d227bb201c7c127ea8d0e9c21739c7e9c6a0d8d5a1aaea5216c549f3715f889e583555ac1bfd77339f3eff1bee75ee2fc45457f5c3ffe9401b8b67f5bb3f305f3269fe6153ba34de3fa90016c76811cd54b4b49b17b244b1a4f6edfa2eaf46e2819aded26005b4ed712e8b700ae7b6123fa2c179640ee523f864360d116ee243f13c66d2cd61d422709648d905ab17edf0d0075d2fed443889e15344069b69b2d3d8273f197f8468baf167074bf6dfdeea5871f0c0652ab2801f394ef6fbf841e8072c8bf65026d85d441ca61e78785a2e7ca1e743640fecd6dfad8b77adcbb8bcb8ce8532ad0cd8b3e51269c26ad037545273f756c1a5511925408a5045af469ca947f9a3f5457bcc325d05291a192abe75b4da7c97a61adc2fa247984edb5a03285f1c3b99f13f6a22f007029faffdd38b62f7bf909ce602e4e06ab1ec4543013d354d0dd86d8933a53c17ead02faf0cc740d7191fe475be2f7940c234f8c73420774a7213fd2a477847527172c02a54928de5fde5f15616760e6f7ff3c03a233aec880a939d9f1ca68be7f474fd13184fe8f6deb0c4ea01617ea207d5d765d067fddba58b94f3b59d5996e9f5434f483e2f0079c48050f3ba941b589294c41a0f350451d566fe58a9c9688cc3a75da314ff4b3473eeac58664c5922ae4efae850fe0f7f11dcc089bc0b4df9a64547a35b2559f4a4a3e7d3782d850997baa589534921becde8dc3f76380ae36bd9730956aae9f59b121d8ae4dbbc586c6b45ad9d5c17cf6821b746177bc9fcb727db3f4aa190688c48826421de5ebcd429e0d9b479e66e676e8f9a3b4bd92621f47357a7b1b27942121f5a6e0087e4192a5f8cf4da942cc9d86eac5e\",\n            context:    \"some context info\",\n            plaintext:  \"08b8b2b733424243760fe426a4b54908632110a66c2f6591eabd3345e3e4eb98fa6e264bf09efe12ee50f8f54e9f77b1e355f6c50544e23fb1433ddf73be84d879de7c0046dc4996d9e773f4bc9efe5738829adb26c81b37c93a1b270b20329d658675fc6ea534e0810a4432826bf58c941efb65d57a338bbd2e26640f89ffbc1a858efcb8550ee3a5e1998bd177e93a7363c344fe6b199ee5d02e82d522c4feba15452f80288a821a579116ec6dad2b3b310da903401aa62100ab5d1a36553e06203b33890cc9b832f79ef80560ccb9a39ce767967ed628c6ad573cb116dbefefd75499da96bd68a8a97b928a8bbc103b6621fcde2beca1231d206be6cd9ec7aff6f6c94fcd7204ed3455c68c83f4a41da4af2b74ef5c53f1d8ac70bdcb7ed185ce81bd84359d44254d95629e9855a94a7c1958d1f8ada5d0532ed8a5aa3fb2d17ba70eb6248e594e1a2297acbbb39d502f1a8c6eb6f1ce22b3de1a1f40cc24554119a831a9aad6079cad88425de6bde1a9187ebb6092cf67bf2b13fd65f27088d78b7e883c8759d2c4f5c65adb7553878ad575f9fad878e80a0c9ba63bcbcc2732e69485bbc9c90bfbd62481d9089beccf80cfe2df16a2cf65bd92dd597b0707e0917af48bbb75fed413d238f5555a7a569d80c3414a8d0859dc65a46128bab27af87a71314f318c782b23ebfe808b82b0ce26401d2e22f04d83d1255dc51addd3b75a2b1ae0784504df543af8969be3ea7082ff7fc9888c144da2af58429ec96031dbcad3dad9af0dcbaaaf268cb8fcffead94f3c7ca495e056a9b47acdb751fb73e666c6c655ade8297297d07ad1ba5e43f1bca32301651339e22904cc8c42f58c30c04aafdb038dda0847dd988dcda6f3bfd15c4b4c4525004aa06eeff8ca61783aacec57fb3d1f92b0fe2fd1a85f6724517b65e614ad6808d6f6ee34dff7310fdc82aebfd904b01e1dc54b2927094b2db68d6f903b68401adebf5a7e08d78ff4ef5d63653a65040cf9bfd4aca7984a74d37145986780fc0b16ac451649de6188a7dbdf191f64b5fc5e2ab47b57f7f7276cd419c17a3ca8e1b939ae49e488acba6b965610b5480109c8b17b80e1b7b750dfc7598d5d5011fd2dcc5600a32ef5b52a1ecc820e308aa342721aac0943bf6686b64b2579376504ccc493d97e6aed3fb0f9cd71a43dd497f01f17c0e2cb3797aa2a2f256656168e6c496afc5fb93246f6b1116398a346f1a641f3b041e989f7914f90cc2c7fff357876e506b50d334ba77c225bc307ba537152f3f1610e4eafe595f6d9d90d11faa933a15ef1369546868a7f3a45a96768d40fd9d03412c091c6315cf4fde7cb68606937380db2eaaa707b4c4185c32eddcdd306705e4dc1ffc872eeee475a64dfac86aba41c0618983f8741c5ef68d3a101e8a3b8cac60c905c15fc910840b94c00a0b9d0\",\n        },\n    ];\n    for tv in test_vectors {\n        let key = hex::decode(&tv.key).unwrap();\n        let ct = hex::decode(&tv.ciphertext).unwrap();\n        let ctx = tv.context.as_bytes();\n        let pt = tv.plaintext.as_bytes();\n\n        let curve = EllipticCurveType::NistP256;\n        let pvt = tink_hybrid::subtle::EcPrivateKey::new(curve, &key).unwrap();\n        let salt = Vec::new();\n        let helper = tink_hybrid::EciesAeadHkdfDemHelper::new(&tink_daead::aes_siv_key_template())\n            .expect(\"error generating a DEM helper\");\n        let d = tink_hybrid::subtle::EciesAeadHkdfHybridDecrypt::new(\n            pvt,\n            &salt,\n            HashType::Sha256,\n            EcPointFormat::Uncompressed,\n            helper,\n        )\n        .expect(\"error generating an decryption construct\");\n        let dt = d.decrypt(&ct, ctx).expect(\"decryption error\");\n        assert_eq!(\n            dt, pt,\n            \"{}: Decryption did not match test vector's plaintext\",\n            tv.name\n        );\n    }\n}", "item_id": 4, "repo": "daviddrysdale/tink-rust", "file": "tests/tests/hybrid/ecies_aead_hkdf_hybrid_decrypt_test.rs", "last_update_at": "2022-03-14T01:04:34+00:00"}
{"hexsha": "cfb3a96a647bb99322d2148319a8c351b42fe18a", "ext": "rs", "lang": "Rust", "content": "fn block_invalidated() {\n    let data = vec![Node::new(\"Camper\")];\n    let mut fix_node_state = fix(data);\n    fix_node_state.transactions[0].event = Events::BlockInvalidated;\n    let (chain, _) = mine(fix_node_state).expect(\"result to be chain\");\n    assert_eq!(chain.get_last_block().unwrap().data[0].racks, 0);\n    assert_eq!(chain.get_last_block().unwrap().data[0].tokens, 19);\n    assert_eq!(chain.get_last_block().unwrap().data[0].reputation, 0);\n}", "item_id": 2, "repo": "ShaunSHamilton/proof-of-stake", "file": "blockchain/tests/handle_mine.rs", "last_update_at": "2022-03-10T14:58:42+00:00"}
{"hexsha": "04f0a8a0a6f6af3c07c0da8c6821d9c100eb1ad5", "ext": "rs", "lang": "Rust", "content": "fn parse_coordinate(input: &[u8]) -> IResult<&[u8], Coords> {\n    use nom::character::complete::char;\n    use nom::character::complete::u16;\n\n    separated_pair(u16, char(','), u16)(input)\n}", "item_id": 1, "repo": "bertptrs/adventofcode", "file": "2021/src/day13.rs", "last_update_at": "2022-01-27T22:31:11+00:00"}
{"hexsha": "c037d3f6c1a8155a53172de89fcd272070a3b257", "ext": "rs", "lang": "Rust", "content": "fn generate_mnt6_spec_params<FE: ElementRepr>(\n    modulus: BigUint, \n    a: BigUint,\n    b: BigUint,\n    main_subgroup_order: BigUint,\n    fp_non_residue: BigUint,\n    generator_g1_x: BigUint,\n    generator_g1_y: BigUint,\n    generator_g2_x_0: BigUint,\n    generator_g2_x_1: BigUint,\n    generator_g2_x_2: BigUint,\n    generator_g2_y_0: BigUint,\n    generator_g2_y_1: BigUint,\n    generator_g2_y_2: BigUint,\n    ate_loop_scalar: BigUint,\n    ate_loop_scalar_is_negative: bool,\n    final_exp_scalar: BigUint,\n    w0_exp_scalar: BigUint,\n    w0_exp_scalar_is_negative: bool,\n    w1_exp_scalar: BigUint,\n) {\n    let modulus_uint = MaxFieldUint::from_big_endian(&modulus.to_bytes_be());\n    let field = field_from_modulus::<FE>(&modulus_uint).unwrap();\n    let a_fp = Fp::from_be_bytes(&field, &a.to_bytes_be(), true).unwrap();\n    let b_fp = Fp::from_be_bytes(&field, &b.to_bytes_be(), true).unwrap();\n    let fp_non_residue = Fp::from_be_bytes(&field, &fp_non_residue.to_bytes_be(), true).unwrap();\n    let extension_3 = Extension3::new(fp_non_residue.clone());\n\n    let one = Fp::one(&field);\n\n    let mut twist = Fp3::zero(&extension_3);\n    twist.c1 = one.clone();\n\n    let mut twist_squared = twist.clone();\n    twist_squared.square();\n\n    let mut twist_cubed = twist_squared.clone();\n    twist_cubed.mul_assign(&twist);\n\n    let mut a_fp3 = twist_squared.clone();\n    a_fp3.mul_by_fp(&a_fp);\n\n    let mut b_fp3 = twist_cubed.clone();\n    b_fp3.mul_by_fp(&b_fp);\n\n\n    let g1_generator_x = Fp::from_be_bytes(&field, &generator_g1_x.to_bytes_be(), true).unwrap();\n    let g1_generator_y = Fp::from_be_bytes(&field, &generator_g1_y.to_bytes_be(), true).unwrap();\n\n    let g1_generator_x_c0 = Fp::from_be_bytes(&field, &generator_g2_x_0.to_bytes_be(), true).unwrap();\n    let g1_generator_x_c1 = Fp::from_be_bytes(&field, &generator_g2_x_1.to_bytes_be(), true).unwrap();\n    let g1_generator_x_c2 = Fp::from_be_bytes(&field, &generator_g2_x_2.to_bytes_be(), true).unwrap();\n    let g1_generator_y_c0 = Fp::from_be_bytes(&field, &generator_g2_y_0.to_bytes_be(), true).unwrap();\n    let g1_generator_y_c1 = Fp::from_be_bytes(&field, &generator_g2_y_1.to_bytes_be(), true).unwrap();\n    let g1_generator_y_c2 = Fp::from_be_bytes(&field, &generator_g2_y_2.to_bytes_be(), true).unwrap();\n    println!(\"Weierstrass curve parameters with k=6\");\n    println!(\"Base field modulus = {}\", field.modulus());\n    println!(\"A coefficient = {}\", a_fp);\n    println!(\"B coefficient = {}\", b_fp);\n    println!(\"Main subgroup order = 0x{}\", main_subgroup_order.to_str_radix(16));\n\n    println!(\"Extension tower:\");\n    println!(\"Fp3 construction:\");\n    println!(\"Fp cubic non-residue = {}\", fp_non_residue);\n\n    println!(\"A coefficient for twist c0 = {}\", a_fp3.c0);\n    println!(\"A coefficient for twist c1 = {}\", a_fp3.c1);\n    println!(\"A coefficient for twist c2 = {}\", a_fp3.c2);\n\n    println!(\"B coefficient for twist c0 = {}\", b_fp3.c0);\n    println!(\"B coefficient for twist c1 = {}\", b_fp3.c1);\n    println!(\"B coefficient for twist c2 = {}\", b_fp3.c2);\n\n    println!(\"Generators:\");\n    println!(\"G1:\");\n    println!(\"X = {}\", g1_generator_x);\n    println!(\"Y = {}\", g1_generator_y);\n\n    println!(\"G2:\");\n    println!(\"X c0 = {}\", g1_generator_x_c0);\n    println!(\"X c1 = {}\", g1_generator_x_c1);\n    println!(\"X c2 = {}\", g1_generator_x_c2);\n    println!(\"Y c0 = {}\", g1_generator_y_c0);\n    println!(\"Y c1 = {}\", g1_generator_y_c1);\n    println!(\"Y c2 = {}\", g1_generator_y_c2);\n\n    println!(\"Pairing parameters:\");\n    println!(\"|ate_loop_scalar| (miller loop scalar) = 0x{}\", ate_loop_scalar.to_str_radix(16));\n    println!(\"ate_loop_scalar is negative = {}\", ate_loop_scalar_is_negative);\n\n    println!(\"final_exp_scalar (final exponentiation power) = 0x{}\", final_exp_scalar.to_str_radix(16));\n\n    println!(\"Breaking final exponentiation hard part into the two parts (usually labeled w0 and w1)\");\n\n    println!(\"|w0| = 0x{}\", w0_exp_scalar.to_str_radix(16));\n    println!(\"w0 is negative = {}\", w0_exp_scalar_is_negative);\n\n    println!(\"|w1| = 0x{}\", w1_exp_scalar.to_str_radix(16));\n}", "item_id": 0, "repo": "litezk/eip1962", "file": "src/test/spec_generator/mnt6.rs", "last_update_at": "2022-03-09T07:01:38+00:00"}
{"hexsha": "fcfe694812796a9074cc0d41097fd1d0c3044cc7", "ext": "rs", "lang": "Rust", "content": "fn lp_3_mat_10_50(b: &mut Bencher) {\n    let a = Matrix::new(10, 50, vec![2.0;500]);\n    let lp = Lp::Integer(3);\n\n    b.iter(|| {\n    \tlet _ = black_box(MatrixNorm::norm(&lp, &a));\n    });\n}", "item_id": 4, "repo": "Frando/rulinalg", "file": "benches/linalg/norm.rs", "last_update_at": "2022-03-30T16:29:40+00:00"}
{"hexsha": "a97ff0572deb752b85f5b36725a641def5d4bf8b", "ext": "rs", "lang": "Rust", "content": "fn ouster_pcd_converter() -> Result<()> {\n    // Load config\n    let config = Config::from_path(\"test_files/ouster_example.json\")?;\n    let pcd_converter = PointCloudConverter::from_config(config);\n\n    // Load pcap file\n    let mut cap = Capture::from_file(\"test_files/ouster_example.pcap\")?;\n    cap.filter(\"udp\")?;\n\n    while let Ok(packet) = cap.next() {\n        let lidar_packet = OusterPacket::from_pcap(&packet)?;\n        let points = pcd_converter.convert(lidar_packet)?;\n        assert!(points.len() as u16 == pcd_converter.columns_per_revolution());\n    }\n\n    Ok(())\n}", "item_id": 1, "repo": "jerry73204/rust-lidar-utils", "file": "tests/ouster.rs", "last_update_at": "2022-01-16T14:52:16+00:00"}
{"hexsha": "3bced46876805d59d4c7b63e4e102e39ced5ad13", "ext": "rs", "lang": "Rust", "content": "fn bench_hadamard_larger(b: &mut Bencher) {\n        let n = 8;\n        let indices = (0..n).collect::<Vec<_>>();\n        let mut state = FeynmanState::<f64>::new(n);\n\n        let mult = (1.0 / 2.0f64).sqrt();\n        let mat = from_reals(&[mult, mult, mult, -mult]);\n\n        let ops: Vec<UnitaryOp> = (0..n).map(|i| Matrix(vec![i], mat.clone())).collect();\n        ops.iter().for_each(|op| state.apply_op(op));\n\n        b.iter(|| state.stochastic_measure(&indices, 0.0));\n    }", "item_id": 4, "repo": "oxarbitrage/RustQIP", "file": "benches/feynman_bench.rs", "last_update_at": "2022-03-30T13:48:29+00:00"}
{"hexsha": "7d0a4f66f48b8514bd9fb03b9e855d16dd4adb01", "ext": "rs", "lang": "Rust", "content": "pub fn to_signed_transaction(state: &MinerState, transaction: RPCTransaction, stateful: &MemoryStateful) -> Result<Transaction, Error> {\n    let address = match transaction.from {\n        Some(val) => val.0,\n        None => Address::default(),\n    };\n    let secret_key = {\n        let mut secret_key = None;\n        for key in state.accounts() {\n            if Address::from_secret_key(&key)? == address {\n                secret_key = Some(key);\n            }\n        }\n        match secret_key {\n            Some(val) => val,\n            None => return Err(Error::NotFound),\n        }\n    };\n    let block = state.get_block_by_number(state.block_height());\n    let trie = stateful.state_of(block.header.state_root);\n\n    let account: Option<Account> = trie.get(&address);\n\n    let unsigned = UnsignedTransaction {\n        nonce: match transaction.nonce {\n            Some(val) => val.0,\n            None => {\n                account.as_ref().map(|account| account.nonce).unwrap_or(U256::zero())\n            }\n        },\n        gas_price: match transaction.gas_price {\n            Some(val) => val.0,\n            None => Gas::zero(),\n        },\n        gas_limit: match transaction.gas {\n            Some(val) => val.0,\n            None => Gas::from(90000u64),\n        },\n        action: match transaction.to {\n            Some(val) => TransactionAction::Call(val.0),\n            None => TransactionAction::Create,\n        },\n        value: match transaction.value {\n            Some(val) => val.0,\n            None => U256::zero(),\n        },\n        input: match transaction.data {\n            Some(val) => val.0,\n            None => Vec::new(),\n        },\n    };\n    let transaction = unsigned.sign::<GlobalSignaturePatch>(&secret_key);\n\n    Ok(transaction)\n}", "item_id": 4, "repo": "ethereumproject/evm-dev", "file": "src/rpc/util.rs", "last_update_at": "2022-03-25T09:38:32+00:00"}
{"hexsha": "2bf2666112a7aad2638c77fc88a6df78693e3161", "ext": "rs", "lang": "Rust", "content": "fn test_stringifying_and_parsing_public_coefficients_should_produce_original(\n    public_coefficients: PublicCoefficientsBytes,\n) {\n    let string = String::from(public_coefficients.clone());\n    let parsed = PublicCoefficientsBytes::try_from(string.as_str());\n    assert_eq!(\n        Ok(public_coefficients),\n        parsed,\n        \"String form does not parse to original: '{}'\",\n        string\n    );\n}", "item_id": 7, "repo": "3cL1p5e7/ic", "file": "rs/crypto/internal/crypto_lib/threshold_sig/bls12_381/src/types/public_coefficients/conversions/tests.rs", "last_update_at": "2022-03-31T11:40:24+00:00"}
{"hexsha": "6fa48d308487319188cbc34cfdba4d8f1c8076c0", "ext": "rs", "lang": "Rust", "content": "fn test_backup_mode_long_with_args() {\n        let short_opt_present = false;\n        let long_opt_present = true;\n        let long_opt_value = Some(\"simple\");\n        let _dummy = TEST_MUTEX.lock().unwrap();\n\n        let result =\n            determine_backup_mode(short_opt_present, long_opt_present, long_opt_value).unwrap();\n\n        assert_eq!(result, BackupMode::SimpleBackup);\n    }", "item_id": 5, "repo": "aburn/coreutils", "file": "src/uucore/src/lib/mods/backup_control.rs", "last_update_at": "2022-01-28T23:17:30+00:00"}
{"hexsha": "14650697c31b96dbd3fd6946ab01a9d8b60a3c69", "ext": "rs", "lang": "Rust", "content": "async fn full_rewind() {\n        let underlying = [104, 101, 108, 108, 111];\n\n        let mock = tokio_test::io::Builder::new().read(&underlying).build();\n\n        let mut stream = Rewind::new(mock);\n\n        let mut buf = [0; 5];\n        stream.read_exact(&mut buf).await.expect(\"read1\");\n\n        // Rewind the stream so that it is as if we never read in the first place.\n        stream.rewind(Bytes::copy_from_slice(&buf[..]));\n\n        let mut buf = [0; 5];\n        stream.read_exact(&mut buf).await.expect(\"read1\");\n    }", "item_id": 1, "repo": "goffrie/hyper", "file": "src/common/io/rewind.rs", "last_update_at": "2022-03-28T07:59:06+00:00"}
{"hexsha": "1ca6459842c951bfd8ac8e495b26964a4ca66989", "ext": "rs", "lang": "Rust", "content": "fn find_instruction_starts(fct: &BytecodeFunction) -> Vec<usize> {\n    let code = fct.code();\n    let mut pos = 0;\n    let mut intruction_start_offsets = Vec::new();\n\n    while pos < fct.code().len() {\n        intruction_start_offsets.push(pos);\n        let (opcode, width) = read_opcode_and_width(code, pos);\n        pos += opcode.size(width) as usize;\n    }\n\n    intruction_start_offsets\n}", "item_id": 0, "repo": "dinfuehr/dora", "file": "dora/src/bytecode/reader.rs", "last_update_at": "2022-03-26T10:32:44+00:00"}
{"hexsha": "4d5ced4fc1cad419ec89bdb5f0d025f006e6f814", "ext": "rs", "lang": "Rust", "content": "pub fn build_program(instructions: Vec<String>) -> String {\n    let mut out = String::from(\nr###\".syntax unified\n\n.global main\n.type main, %function\nmain:\n\"###);\n\n    for line in instructions {\n        out.push_str(&line);\n        out.push('\\n');\n    }\n\n    out.push_str(\nr###\"ldr lr, =0x444F4E45 @ \"DONE\"\n.size main, . - main\n\n.section .isr_vector, \"a\", %progbits\ng_pfnVectors:\n.word _stack_end\n.word main\n\n\"###);\n\n    return out;\n}", "item_id": 0, "repo": "cpmpercussion/comp2300-discoserver", "file": "tests/common/online.rs", "last_update_at": "2022-03-09T07:43:26+00:00"}
{"hexsha": "d635e87385b4d008770525871764a7b0d3034375", "ext": "rs", "lang": "Rust", "content": "pub fn wait<F>(fd: RawFd, cond: F, timeout: Option<Duration>) -> bool\nwhere\n    F: Fn() -> bool,\n{\n    if cond() {\n        return true;\n    }\n\n    let start = Instant::now();\n\n    let mut t = timeout;\n\n    loop {\n        let wait_timeout = match t {\n            Some(duration) => duration.as_millis() as i32,\n            None => -1,\n        };\n        wait_file_changes(fd, wait_timeout);\n\n        if let Some(duration) = timeout {\n            let elapsed = start.elapsed();\n            if elapsed >= duration {\n                return false;\n            }\n            t = Some(duration - elapsed);\n        }\n\n        if cond() {\n            return true;\n        }\n    }\n}", "item_id": 0, "repo": "MassiminoilTrace/ev3dev-lang-rust", "file": "src/wait.rs", "last_update_at": "2022-01-23T18:19:51+00:00"}
{"hexsha": "83ebff57f44faa45ab77fe0782451ab5c4d3f2ca", "ext": "rs", "lang": "Rust", "content": "fn test_nested_refs_for_let_shadowing() {\n        let values = vec![1, 2, 3, 4];\n        let vs = &values;\n        check_match(vec![5, 5, 5, 5,\n                         6, 6, 6, 6,\n                         7, 7, 7, 7,\n                         8, 8, 8, 8].into_iter(),\n                    iterate![for x in vs.iter();\n                             let a = *x + 3;\n                             for y in vs.iter();\n                             let y = 1;\n                             yield y + a]);\n    }", "item_id": 6, "repo": "dstu/r4", "file": "src/lib.rs", "last_update_at": "2022-02-22T20:27:43+00:00"}
{"hexsha": "10889000a775094684cae75666e5e1555ae97dbb", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn connection_settings_get_username(\n    this: *const ConnectionSettings,\n) -> *const c_char {\n    if this.is_null() {\n        return ptr::null();\n    }\n    let settings: &ConnectionSettings = { &*this };\n\n    match CString::new(settings.username.as_bytes()) {\n        Err(_) => std::ptr::null(),\n        Ok(str_bytes) => str_bytes.into_raw(),\n    }\n}", "item_id": 8, "repo": "jonathanschroeter/datajoint-core", "file": "packages/datajoint-core-ffi-c/src/connection/settings.rs", "last_update_at": "2022-02-23T08:54:00+00:00"}
{"hexsha": "87ac99b3c92bccdcc8f6f96496d0a9f062e80842", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_operation_crate_operation_describe_resource_policies(\n    input: &crate::input::DescribeResourcePoliciesInput,\n) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {\n    let mut out = String::new();\n    let mut object = aws_smithy_json::serialize::JsonObjectWriter::new(&mut out);\n    crate::json_ser::serialize_structure_crate_input_describe_resource_policies_input(\n        &mut object,\n        input,\n    )?;\n    object.finish();\n    Ok(aws_smithy_http::body::SdkBody::from(out))\n}", "item_id": 20, "repo": "StevenBlack/aws-sdk-rust", "file": "sdk/cloudwatchlogs/src/operation_ser.rs", "last_update_at": "2022-03-31T20:47:15+00:00"}
{"hexsha": "30e511542e4aac60c54c4fe6514719129fa9ee2c", "ext": "rs", "lang": "Rust", "content": "fn test_utsname() {\n    init();\n\n    let mut st = get_st(\"utsname\");\n    let mut iterator = st.iter_as_syscall().skip_while(compare).skip(1);\n\n    let call = unwrap_syscall!(iterator, Uname);\n    let uts_name = nix::sys::utsname::uname();\n    assert_eq!(&call.utsname.sysname, uts_name.sysname());\n    assert_eq!(&call.utsname.nodename, uts_name.nodename());\n    assert_eq!(&call.utsname.release, uts_name.release());\n    assert_eq!(&call.utsname.version, uts_name.version());\n    assert_eq!(&call.utsname.machine, uts_name.machine());\n}", "item_id": 5, "repo": "palfrey/hstrace", "file": "tests/test_c_binary.rs", "last_update_at": "2022-03-07T11:10:40+00:00"}
{"hexsha": "65567f1625990beb275e3bfe29ed6bb0c8b1c9e2", "ext": "rs", "lang": "Rust", "content": "fn test_deserialize_serialize_signed_response() {\n        let response_xml = include_str!(concat!(\n            env!(\"CARGO_MANIFEST_DIR\"),\n            \"/test_vectors/response_signed.xml\",\n        ));\n        let expected_response: Response = response_xml\n            .parse()\n            .expect(\"failed to parse response_signed.xml\");\n        let serialized_response =\n            yaserde::ser::to_string(&expected_response).expect(\"failed to convert response to xml\");\n        std::fs::write(\"/tmp/foo.xml\", &serialized_response).unwrap();\n        let actual_response: Response = serialized_response\n            .parse()\n            .expect(\"failed to re-parse response\");\n\n        assert_eq!(expected_response, actual_response);\n    }", "item_id": 2, "repo": "samueltardieu/samael", "file": "src/schema/response.rs", "last_update_at": "2022-02-10T20:46:53+00:00"}
{"hexsha": "7b85deecc9f4c6c1d046ff64481e6b1cc2059653", "ext": "rs", "lang": "Rust", "content": "fn test_solve_dual64() {\r\n        let a = arr2(&[\r\n            [Dual64::new_scalar(4.0, 3.0), Dual64::new_scalar(3.0, 3.0)],\r\n            [Dual64::new_scalar(6.0, 1.0), Dual64::new_scalar(3.0, 2.0)],\r\n        ]);\r\n        let b = arr1(&[\r\n            Dual64::new_scalar(10.0, 20.0),\r\n            Dual64::new_scalar(12.0, 20.0),\r\n        ]);\r\n        let lu = LU::new(a).unwrap();\r\n        let det = lu.determinant();\r\n        assert_eq!((det.re, det.eps[0]), (-6.0, -4.0));\r\n        let x = lu.solve(&b);\r\n        assert_eq!(\r\n            (x[0].re, x[0].eps[0], x[1].re, x[1].eps[0]),\r\n            (1.0, 2.0, 2.0, 1.0)\r\n        );\r\n    }", "item_id": 2, "repo": "itt-ustutt/num-dual", "file": "src/linalg/mod.rs", "last_update_at": "2022-03-27T21:57:27+00:00"}
{"hexsha": "a25a42c6f86834a28e4f969ee28452aa8842621d", "ext": "rs", "lang": "Rust", "content": "fn spawn_random(player: &Character, distance: &location::Distance) -> (Class, i32) {\n    // the weights for each group of enemies are different depending on the distance\n    // the further from home, the bigger the chance to find difficult enemies\n    let (w_common, w_rare, w_legendary) = match distance {\n        location::Distance::Near(_) => (10, 2, 0),\n        location::Distance::Mid(_) => (8, 10, 1),\n        location::Distance::Far(_) => (0, 8, 2),\n    };\n\n    let mut rng = rand::thread_rng();\n\n    // assign weights to each group and select one\n    let weights = vec![\n        (Category::Common, w_common),\n        (Category::Rare, w_rare),\n        (Category::Legendary, w_legendary),\n    ];\n\n    let category = weights\n        .as_slice()\n        .choose_weighted(&mut rng, |(_c, weight)| *weight)\n        .unwrap()\n        .0\n        .clone();\n\n    let level = std::cmp::max(player.level / 10 + distance.len() - 1, 1);\n    (Class::random(category).clone(), level)\n}", "item_id": 1, "repo": "Kruemmelspalter/rpg-cli", "file": "src/character/enemy.rs", "last_update_at": "2022-03-24T03:32:34+00:00"}
{"hexsha": "2b978d2c632b3c1d0402d90c490b370ec45c7979", "ext": "rs", "lang": "Rust", "content": "fn successfully_forwards_an_image_from_rocketchat_to_matrix_when_the_user_is_not_registered_on_matrix() {\n    let test = Test::new();\n    let (message_forwarder, receiver) = MessageForwarder::new();\n    let uploaded_files = Arc::new(Mutex::new(Vec::new()));\n    let (create_content_forwarder, create_content_receiver) =\n        handlers::MatrixCreateContentHandler::with_forwarder(Arc::clone(&uploaded_files));\n    let mut matrix_router = test.default_matrix_routes();\n    matrix_router.put(SendMessageEventEndpoint::router_path(), message_forwarder, \"send_message_event\");\n    matrix_router.post(CreateContentEndpoint::router_path(), create_content_forwarder, \"create_content\");\n\n    let attachments = vec![Attachment {\n        description: \"Spec image\".to_string(),\n        image_size: Some(100),\n        image_type: Some(\"image/png\".to_string()),\n        image_url: Some(\"/file-upload/image.png\".to_string()),\n        mimetype: \"image/png\".to_string(),\n        title: \"Spec titel\".to_string(),\n        title_link: \"/file-upload/image.png\".to_string(),\n    }];\n    let rocketchat_message = Arc::new(Mutex::new(Some(Message {\n        id: \"spec_id\".to_string(),\n        rid: \"spec_rid\".to_string(),\n        msg: \"\".to_string(),\n        ts: \"2017-12-12 11:11\".to_string(),\n        attachments: Some(attachments),\n        file: Some(File { mimetype: \"image/png\".to_string() }),\n        u: UserInfo { id: \"spec_user_id\".to_string(), username: \"spec_sender\".to_string(), name: \"spec sender\".to_string() },\n        mentions: Vec::new(),\n        channels: Vec::new(),\n        updated_at: \"2017-12-12 11:11\".to_string(),\n    })));\n    let rocketchat_message_responder = handlers::RocketchatMessageResponder { message: rocketchat_message };\n    let mut rocketchat_router = test.default_rocketchat_routes();\n    rocketchat_router.get(CHAT_GET_MESSAGE_PATH, rocketchat_message_responder, \"get_chat_message\");\n    let mut files = HashMap::new();\n    files.insert(\"image.png\".to_string(), b\"image\".to_vec());\n    rocketchat_router.get(\"/file-upload/:filename\", handlers::RocketchatFileResponder { files: files }, \"get_file\");\n\n    let test = test\n        .with_matrix_routes(matrix_router)\n        .with_rocketchat_mock()\n        .with_custom_rocketchat_routes(rocketchat_router)\n        .with_connected_admin_room()\n        .with_logged_in_user()\n        .with_bridged_room((\"spec_channel\", vec![\"spec_user\"]))\n        .run();\n\n    // discard welcome message\n    receiver.recv_timeout(default_timeout()).unwrap();\n    // discard connect message\n    receiver.recv_timeout(default_timeout()).unwrap();\n    // discard login message\n    receiver.recv_timeout(default_timeout()).unwrap();\n    // discard room bridged message\n    receiver.recv_timeout(default_timeout()).unwrap();\n\n    let message = WebhookMessage {\n        message_id: \"spec_id\".to_string(),\n        token: Some(RS_TOKEN.to_string()),\n        channel_id: \"spec_channel_id\".to_string(),\n        channel_name: Some(\"spec_channel\".to_string()),\n        user_id: \"new_user_id\".to_string(),\n        user_name: \"new_spec_user\".to_string(),\n        text: \"Uploaded an image\".to_string(),\n    };\n    let payload = to_string(&message).unwrap();\n\n    helpers::simulate_message_from_rocketchat(&test.config.as_url, &payload);\n\n    let file = create_content_receiver.recv_timeout(default_timeout()).unwrap();\n    // this would contain the image data, but for the test this was just a string converted to bytes.\n    assert_eq!(file, \"image\");\n\n    let message = receiver.recv_timeout(default_timeout()).unwrap();\n    assert!(message.contains(\"Spec titel\"));\n    assert!(message.contains(\"m.image\"));\n    let files = uploaded_files.lock().unwrap();\n    let file_id = files.first().unwrap();\n    assert!(message.contains(&format!(\"mxc://localhost/{}\", file_id)));\n}", "item_id": 2, "repo": "exul/matrix-rocketchat", "file": "tests/forward_rocketchat_channel_to_matrix.rs", "last_update_at": "2022-02-15T16:26:29+00:00"}
{"hexsha": "5ba01e060b204adf10b9b18a3d1e4142b797623d", "ext": "rs", "lang": "Rust", "content": "pub fn test_mode(enabled: bool) {\n    use crate::pam::TEST_MODE;\n    let getal = if enabled { 1 } else { 0 };\n    TEST_MODE.store(getal, Ordering::SeqCst);\n}", "item_id": 0, "repo": "giganteous/webdav-server-rs", "file": "pam/src/lib.rs", "last_update_at": "2022-03-09T15:45:36+00:00"}
{"hexsha": "b6a707da54aee506c9801a816a90ebc2dbfa374b", "ext": "rs", "lang": "Rust", "content": "fn destroy_iface_failure() {\n        let mut exec = fasync::TestExecutor::new().expect(\"Failed to create an executor\");\n        let test_values = test_setup();\n        let mut phy_stream = fake_destroy_iface_env(&test_values.phys, &test_values.ifaces);\n\n        let destroy_fut = super::destroy_iface(&test_values.phys, &test_values.ifaces, 42);\n        pin_mut!(destroy_fut);\n        assert_eq!(Poll::Pending, exec.run_until_stalled(&mut destroy_fut));\n\n        let (req, responder) = assert_variant!(exec.run_until_stalled(&mut phy_stream.next()),\n            Poll::Ready(Some(Ok(fidl_dev::PhyRequest::DestroyIface { req, responder }))) => (req, responder)\n        );\n\n        // Verify the destroy iface request to the corresponding PHY is correct.\n        assert_eq!(0, req.id);\n\n        responder\n            .send(&mut fidl_dev::DestroyIfaceResponse { status: zx::sys::ZX_ERR_INTERNAL })\n            .expect(\"failed to send DestroyIfaceResponse\");\n        assert_eq!(\n            Poll::Ready(Err(zx::Status::INTERNAL)),\n            exec.run_until_stalled(&mut destroy_fut)\n        );\n\n        // Verify iface was not removed from available ifaces.\n        assert!(test_values.ifaces.get(&42u16).is_some(), \"iface expected to not be deleted\");\n    }", "item_id": 26, "repo": "gnoliyil/fuchsia", "file": "src/connectivity/wlan/wlandevicemonitor/src/service.rs", "last_update_at": "2022-01-08T17:06:28+00:00"}
{"hexsha": "7f05c250eb491a42bf847b1c2b9e52d9f45b49d7", "ext": "rs", "lang": "Rust", "content": "fn non_empty_array_set_slice_begin_non_empty_drain_0() {\n        let mut ary = SmallArray::from([1, 2, 3, 4, 5]);\n        let drained = ary.set_slice(0, 0, &[7, 8, 9]);\n        assert_eq!(drained, 0);\n        assert_eq!(ary, [7, 8, 9, 1, 2, 3, 4, 5]);\n    }", "item_id": 45, "repo": "b-n/artichoke", "file": "spinoso-array/src/array/smallvec/mod.rs", "last_update_at": "2022-02-28T08:45:47+00:00"}
{"hexsha": "964e7adc38a85ccc5250e28810827bb190b96dcb", "ext": "rs", "lang": "Rust", "content": "pub fn read(file: &Option<PathBuf>) -> Result<String, io::Error> {\n    // TODO: stream instead of reading everything into string\n    let mut contents = String::new();\n\n    if let Some(path) = file {\n        File::open(&path)?.read_to_string(&mut contents)?;\n    } else {\n        stdin().read_to_string(&mut contents)?;\n    };\n\n    Ok(contents)\n}", "item_id": 2, "repo": "comprakt/comprakt", "file": "runner-integration-tests/src/lookup.rs", "last_update_at": "2022-01-15T07:39:33+00:00"}
{"hexsha": "5252b70b49975622f4c6f984caaee8c728d24b2a", "ext": "rs", "lang": "Rust", "content": "fn test_user_data() {\n        let user_data = Box::new(10u8);\n        let mut inner: io_uring_sqe = unsafe { std::mem::zeroed() };\n        inner.user_data = Box::into_raw(user_data) as u64;\n\n        let sqe: Sqe = Sqe::new(inner);\n\n        assert_eq!(unsafe { sqe.user_data::<u8>() }, 10);\n    }", "item_id": 0, "repo": "cmarincia/firecracker", "file": "src/io_uring/src/operation/sqe.rs", "last_update_at": "2022-02-16T03:19:52+00:00"}
{"hexsha": "c42042139752649ce8a3fb1d87121eb546da2213", "ext": "rs", "lang": "Rust", "content": "fn test_seq_emitting() {\n    let vec = vec![vec![1u64, 2], vec![3, 4]];\n\n    let mut driver = SerializeDriver::new(&vec);\n    let mut events = Vec::new();\n    while let Some((event, _, _)) = driver.next().unwrap() {\n        events.push(event.to_static());\n    }\n\n    assert_eq!(\n        events,\n        vec![\n            Event::SeqStart,\n            Event::SeqStart,\n            1u64.into(),\n            2u64.into(),\n            Event::SeqEnd,\n            Event::SeqStart,\n            3u64.into(),\n            4u64.into(),\n            Event::SeqEnd,\n            Event::SeqEnd,\n        ],\n    );\n}", "item_id": 0, "repo": "mitsuhiko/deser", "file": "deser/src/ser/driver.rs", "last_update_at": "2022-03-16T17:06:33+00:00"}
{"hexsha": "61ba86b714a91e7ff1570d03834ee26b4b252164", "ext": "rs", "lang": "Rust", "content": "fn mandelbrot() -> Result<(), Box<dyn std::error::Error>> {\n    let mut cmd = Command::cargo_bin(\"rocklang\")?;\n\n    cmd.arg(\"examples/mandelbrot.rc\");\n    cmd.assert().success().stdout(\n        predicate::eq(\n            \"...............*..............\n...............*..............\n...............*..............\n..............***.............\n.............*****............\n.............*****............\n.............*****............\n..............***.............\n.............*****............\n...........*********..........\n.........*************........\n..........***********.........\n.........*************........\n.......*****************......\n.......*****************......\n.....*...*************...*....\n.........*************........\n..........***********.........\n..........*****.*****.........\n..............................\n..............................\n..............................\n..............................\n..............................\n..............................\n..............................\n..............................\n..............................\n..............................\n..............................\n\",\n        )\n        .normalize(),\n    );\n\n    Ok(())\n}", "item_id": 1, "repo": "oczekrb/rocklang", "file": "tests/integration_tests.rs", "last_update_at": "2022-03-25T13:45:38+00:00"}
{"hexsha": "a1fbd456fd2ee1579a62e2f316832dec00221fbc", "ext": "rs", "lang": "Rust", "content": "async fn glob_leading_double_star() {\n\tlet filterer = filt(&[\"**/possum\"], &[], &[]).await;\n\n\tfilterer.file_does_pass(\"possum\");\n\tfilterer.file_does_pass(\"foo/bar/possum\");\n\tfilterer.file_does_pass(\"/foo/bar/possum\");\n\tfilterer.dir_does_pass(\"possum\");\n\tfilterer.dir_does_pass(\"foo/bar/possum\");\n\tfilterer.dir_does_pass(\"/foo/bar/possum\");\n\tfilterer.file_doesnt_pass(\"rat\");\n\tfilterer.file_doesnt_pass(\"foo/bar/rat\");\n\tfilterer.file_doesnt_pass(\"/foo/bar/rat\");\n}", "item_id": 6, "repo": "abitrolly/watchexec", "file": "lib/tests/filter_globset.rs", "last_update_at": "2022-01-20T21:13:31+00:00"}
{"hexsha": "b3bffd2d765dbc06616b7219943d68de1663a301", "ext": "rs", "lang": "Rust", "content": "async fn document_symbol() {\n            let (service, _) = LspService::new(|_| Mock::default());\n            let mut service = Spawn::new(service);\n\n            super::helper::initialize(&mut service).await;\n\n            let params = lsp::DocumentSymbolParams {\n                text_document: lsp::TextDocumentIdentifier {\n                    uri: lsp::Url::parse(\"inmemory::///test\").unwrap(),\n                },\n                work_done_progress_params: Default::default(),\n                partial_result_params: Default::default(),\n            };\n            let request: Incoming = helper::request(\"textDocument/documentSymbol\", params).unwrap();\n            let response = Response::error(Some(Id::Number(1)), Error::method_not_found());\n            assert_eq!(service.poll_ready(), Poll::Ready(Ok(())));\n            assert_eq!(\n                service.call(request.clone()).await,\n                Ok(Some(Outgoing::Response(response)))\n            );\n        }", "item_id": 27, "repo": "attliaLin/lspower", "file": "src/lib.rs", "last_update_at": "2022-03-26T08:17:19+00:00"}
{"hexsha": "215c9a8a58f67f74eb17900120110f25c10d05a7", "ext": "rs", "lang": "Rust", "content": "pub fn trimesh_area_and_center_of_mass(\n    vertices: &[Point<Real>],\n    indices: &[[u32; 3]],\n) -> (Real, Point<Real>) {\n    let mut res = Point::origin();\n    let mut areasum = 0.0;\n\n    for idx in indices {\n        let triangle = Triangle::new(\n            vertices[idx[0] as usize],\n            vertices[idx[1] as usize],\n            vertices[idx[2] as usize],\n        );\n        let area = triangle.area();\n        let center = triangle.center();\n\n        res += center.coords * area;\n        areasum += area;\n    }\n\n    if areasum == 0.0 {\n        (areasum, res)\n    } else {\n        (areasum, res / areasum)\n    }\n}", "item_id": 0, "repo": "bellwether-softworks/parry", "file": "src/mass_properties/mass_properties_trimesh.rs", "last_update_at": "2022-03-26T06:25:32+00:00"}
{"hexsha": "606daf72d736c3733db174fdf1211797033d2d8d", "ext": "rs", "lang": "Rust", "content": "fn webpage(name: String, visitor: State<VisitorCounter>) -> Template {\n    let mut context = HashMap::new();\n    context.insert(\"name\", name);\n    let current = visitor.visitor_number.fetch_add(1, Ordering::SeqCst);\n    context.insert(\"visitor_number\", current.to_string());\n    Template::render(\"webpage\", &context)\n}", "item_id": 0, "repo": "d2r/Network-Programming-with-Rust", "file": "Chapter06/ch6/rocket-templates/src/main.rs", "last_update_at": "2022-03-13T16:13:46+00:00"}
{"hexsha": "a20411a6bb3d23bb6b558c1a248eb567801b08d1", "ext": "rs", "lang": "Rust", "content": "fn fetch_markets_raw() -> Vec<FtxMarket> {\n    let txt = http_get(\"https://ftx.com/api/markets\").unwrap();\n    let resp = serde_json::from_str::<Response>(&txt).unwrap();\n    assert!(resp.success);\n    resp.result\n}", "item_id": 0, "repo": "CPT-Jack-A-Castle/crypto-crawler-rs", "file": "crypto-pair/tests/ftx.rs", "last_update_at": "2022-03-23T03:36:51+00:00"}
{"hexsha": "d574411007b66f532420634a3d0cc4ba2b332053", "ext": "rs", "lang": "Rust", "content": "async fn handle_after_timeout<T: Node + Debug>(state: &mut RaftElectionState<T>) {\n    //don't start election there isn't enough nodes.\n    if state.peers.len() < state.min_node {\n        trace!(\"[node: {}] not enough node\", &state.self_id);\n        return;\n    }\n\n    if state.has_leader || (state.node_state == NodeState::Leader) {\n        // let's reset has_leader to false.\n        // some external process(or message) should set the flag to true on heartbeat message.\n        // has_leader after timeout means no heartbeat was received from the leader\n        // during timout\n        state.has_leader = false | (state.node_state == NodeState::Leader);\n        return;\n    }\n\n    //has no leader or initializing the raft system\n    //promote to Candidate\n    // if candidate, just restart the voting process.\n    if matches!(state.node_state, NodeState::Follower | NodeState::Candidate) {\n        debug!(\n            \"[node: {}] updating node state to NodeState::Candidate\",\n            &state.self_id\n        );\n        trace!(\n            \"[node: {}] updating term from {} to {}\",\n            &state.self_id,\n            &state.term,\n            state.term + 1\n        );\n        state.term += 1;\n        state.node_state = NodeState::Candidate;\n        //self vote\n        state.votes = 1;\n        //ask peers to vote\n        for peer in state.peers.iter() {\n            let msg = Message::RequestVote {\n                node_id: state.self_id.clone(),\n                term: state.term,\n            };\n            trace!(\n                \"[node: {}] sending vote request for term {} to: {:?}\",\n                &state.self_id,\n                &state.term,\n                peer\n            );\n            peer.send_message(msg).await;\n        }\n    }\n    if state.votes > (state.peers.len() + 1) / 2 {\n        state.node_state = NodeState::Leader;\n        // for peer in state.peers.iter() {\n        //     peer.send_message(Message::LeaderAnnouncement(state.self_id.clone()))\n        //         .await;\n        // }\n        let result = state\n            .tx\n            .send_timeout(\n                Message::ControlLeaderChanged(state.self_id.clone()),\n                Duration::from_millis(state.message_timeout),\n            )\n            .await;\n        log_error!(result);\n    }\n}", "item_id": 4, "repo": "eipi1/almost-raft", "file": "src/election/mod.rs", "last_update_at": "2022-03-27T18:46:36+00:00"}
{"hexsha": "7231263198f52eee4d269390002eab6c1ea91c43", "ext": "rs", "lang": "Rust", "content": "fn fetch_stream(stream: String) -> Vec<String> {\n        let query = format!(\"%7Btest_name%3D\\\"{}\\\"%7D\", stream);\n        let query = format!(\n            \"http://localhost:3100/loki/api/v1/query_range?query={}&direction=forward\",\n            query\n        );\n        let mut res = reqwest::get(&query).unwrap();\n\n        assert_eq!(res.status(), 200);\n\n        // The response type follows this api https://github.com/grafana/loki/blob/master/docs/api.md#get-lokiapiv1query_range\n        // where the result type is `streams`.\n        let data = res.json::<serde_json::Value>().unwrap();\n\n        // TODO: clean this up or explain it via docs\n        let results = data\n            .get(\"data\")\n            .unwrap()\n            .get(\"result\")\n            .unwrap()\n            .as_array()\n            .unwrap();\n\n        let values = results[0].get(\"values\").unwrap().as_array().unwrap();\n\n        values\n            .iter()\n            // Lets check the message field of the array where\n            // the array looks like: [ts, line].\n            .map(|v| v[1].as_str().unwrap().to_string())\n            .collect::<Vec<_>>()\n    }", "item_id": 5, "repo": "alathon/vector", "file": "src/sinks/loki.rs", "last_update_at": "2022-02-27T18:33:25+00:00"}
{"hexsha": "bad08a39a07f57fab14230c4b1270c20a16a6a3e", "ext": "rs", "lang": "Rust", "content": "pub async fn update(client: &Client, id: String, peer_urls: Vec<String>) -> EtcdMembersResult {\n    let peer_urls = PeerUrls { peer_urls };\n    let body = serde_json::to_string(&peer_urls).map_err(|e| vec![e.into()])?;\n\n    client\n        .first_ok(|client, endpoint| {\n            let url = build_url(endpoint, &format!(\"/{}\", id));\n            let body = body.clone();\n            async move {\n                let response = client.http_client().put(url).body(body).send().await?;\n                parse_empty_response(response).await\n            }\n        })\n        .await\n}", "item_id": 1, "repo": "discord/rust-etcd", "file": "src/members.rs", "last_update_at": "2022-03-23T13:57:00+00:00"}
{"hexsha": "f48cc0114fdd889f94a6dc5ec25f0093359096c9", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let firebase = Firebase::new(\"https://shining-torch-7752.firebaseio.com\").ok().unwrap();\n    let messages = firebase.at(\"/api/messages\").ok().unwrap();\n\n    let res = messages.push(serde_json::json!({\"name\":\"David\",\"message\":\"Hello from Rust\"})).ok().unwrap();\n\n    println!(\"Response body: {:?}\", res.body);\n    println!(\"Response code: {:?}\", res.code);\n    println!(\"Response success: {:?}\", res.is_success());\n}", "item_id": 0, "repo": "GT3CH1/rust-firebase", "file": "examples/push_data.rs", "last_update_at": "2022-03-19T12:26:29+00:00"}
{"hexsha": "8ee46090be0a408028a1b29311cd8a419a713217", "ext": "rs", "lang": "Rust", "content": "fn fake_pors_subset() -> [usize; PORS_K] {\n        let seed = hash::tests::HASH_ELEMENT;\n        let prng = prng::Prng::new(&seed);\n        let address = address::Address::new(0, 0);\n\n        let mut subset: [usize; PORS_K] = [0; PORS_K];\n        let mut count = 0;\n        let mut counter = 1;\n        let mut block = Default::default();\n\n        'outer: while count < PORS_K {\n            prng.genblock(&mut block, &address, counter);\n            'inner: for i in 0..8 {\n                let x = BigEndian::read_u32(array_ref![block.h, 4 * i, 4]) as usize;\n                let x = x % PORS_T;\n\n                for i in 0..count {\n                    if subset[i] == x {\n                        continue 'inner;\n                    }\n                }\n\n                subset[count] = x;\n                count += 1;\n                if count == PORS_K {\n                    break 'outer;\n                }\n            }\n            counter += 1;\n        }\n\n        subset.sort();\n        subset\n    }", "item_id": 9, "repo": "gendx/gravity-rs", "file": "src/octopus.rs", "last_update_at": "2022-01-02T03:46:10+00:00"}
{"hexsha": "a5697097b716f587bfe10a7d599e122f2aa6d0c6", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_structure_crate_model_transit_gateway_request_options(\n    mut writer: aws_smithy_query::QueryValueWriter,\n    input: &crate::model::TransitGatewayRequestOptions,\n) -> Result<(), aws_smithy_http::operation::SerializationError> {\n    #[allow(unused_mut)]\n    let mut scope_318 = writer.prefix(\"AmazonSideAsn\");\n    if let Some(var_319) = &input.amazon_side_asn {\n        scope_318.number(\n            #[allow(clippy::useless_conversion)]\n            aws_smithy_types::Number::NegInt((*var_319).into()),\n        );\n    }\n    #[allow(unused_mut)]\n    let mut scope_320 = writer.prefix(\"AutoAcceptSharedAttachments\");\n    if let Some(var_321) = &input.auto_accept_shared_attachments {\n        scope_320.string(var_321.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_322 = writer.prefix(\"DefaultRouteTableAssociation\");\n    if let Some(var_323) = &input.default_route_table_association {\n        scope_322.string(var_323.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_324 = writer.prefix(\"DefaultRouteTablePropagation\");\n    if let Some(var_325) = &input.default_route_table_propagation {\n        scope_324.string(var_325.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_326 = writer.prefix(\"VpnEcmpSupport\");\n    if let Some(var_327) = &input.vpn_ecmp_support {\n        scope_326.string(var_327.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_328 = writer.prefix(\"DnsSupport\");\n    if let Some(var_329) = &input.dns_support {\n        scope_328.string(var_329.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_330 = writer.prefix(\"MulticastSupport\");\n    if let Some(var_331) = &input.multicast_support {\n        scope_330.string(var_331.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_332 = writer.prefix(\"TransitGatewayCidrBlocks\");\n    if let Some(var_333) = &input.transit_gateway_cidr_blocks {\n        let mut list_335 = scope_332.start_list(true, Some(\"item\"));\n        for item_334 in var_333 {\n            #[allow(unused_mut)]\n            let mut entry_336 = list_335.entry();\n            entry_336.string(item_334);\n        }\n        list_335.finish();\n    }\n    Ok(())\n}", "item_id": 36, "repo": "jdisanti/aws-sdk-rust", "file": "sdk/ec2/src/query_ser.rs", "last_update_at": "2022-03-31T20:47:15+00:00"}
{"hexsha": "ae15adb105436aefdc02c8b355e0821f34c5cbdf", "ext": "rs", "lang": "Rust", "content": "pub fn routes(cfg: &config::Config) -> distringo::Result<BoxedFilter<(impl Reply,)>> {\n\tlet slash = warp::get()\n\t\t.and(path::end())\n\t\t.and(fs::file(\"./dist/index.html\"));\n\n\tlet static_files = warp::get().and(fs::dir(\"./dist/\")).and(path::end());\n\n\tlet file_routes = slash.or(static_files);\n\n\tlet api_routes = api::api(cfg)?;\n\n\tlet root = api_routes\n\t\t.or(file_routes)\n\t\t.with(warp::log(\"distringo\"))\n\t\t.recover(super::handle_rejection)\n\t\t.boxed();\n\n\tOk(root)\n}", "item_id": 0, "repo": "rye/distringo", "file": "server/src/server/routes.rs", "last_update_at": "2022-03-31T12:20:08+00:00"}
{"hexsha": "016b434a6124a83ecd1cad9fda874a0aa5689aa9", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<(), std::io::Error> {\n    vec! { 1, 2, 3 }.len();\n    write! { vec![], \"\" }?;\n    println!{\"\"}\n    [0]; // separate statement, not indexing into the result of println.\n    Ok(())\n}", "item_id": 0, "repo": "ohno418/rust", "file": "src/test/ui/parser/macro-braces-dot-question.rs", "last_update_at": "2022-03-31T23:26:40+00:00"}
{"hexsha": "a02fceded9209aad274883d3388c8126df7649ac", "ext": "rs", "lang": "Rust", "content": "pub fn indoc(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    let source = TokenStream::from(input);\n\n    let len = source.clone().into_iter().count();\n    if len != 1 {\n        panic!(\n            \"argument must be a single string literal, but got {} tokens\",\n            len\n        );\n    }\n\n    let lit = match syn::parse2::<Lit>(source) {\n        Ok(lit) => lit,\n        Err(_) => {\n            panic!(\"argument must be a single string literal\");\n        }\n    };\n\n    let lit = match lit {\n        Lit::Str(lit) => {\n            let v = unindent(&lit.value());\n            Lit::Str(LitStr::new(&v, lit.span()))\n        }\n        Lit::ByteStr(lit) => {\n            let v = unindent_bytes(&lit.value());\n            Lit::ByteStr(LitByteStr::new(&v, lit.span()))\n        }\n        _ => {\n            panic!(\"argument must be a single string literal\");\n        }\n    };\n\n    proc_macro::TokenStream::from(quote!(#lit))\n}", "item_id": 0, "repo": "wwjiang007/fuchsia-1", "file": "third_party/rust_crates/vendor/indoc-impl/src/lib.rs", "last_update_at": "2022-03-28T07:59:06+00:00"}
{"hexsha": "ac0a0d5709c4081b6449b6ab397e59c2f883da89", "ext": "rs", "lang": "Rust", "content": "async fn main() {\n    tracing_subscriber::fmt::init();\n\n    eprintln!(\"connecting to localhost:5001...\");\n\n    let client = IpfsClient::default();\n\n    match client.name_resolve(Some(IPFS_IPNS), true, false).await {\n        Ok(resolved) => eprintln!(\"{} resolves to: {}\", IPFS_IPNS, &resolved.path),\n        Err(e) => {\n            eprintln!(\"error resolving {}: {}\", IPFS_IPNS, e);\n            return;\n        }\n    }\n\n    let publish = match client.name_publish(IPFS_IPNS, true, None, None, None).await {\n        Ok(publish) => {\n            eprintln!(\"published {} to: /ipns/{}\", IPFS_IPNS, &publish.name);\n            publish\n        }\n        Err(e) => {\n            eprintln!(\"error publishing name: {}\", e);\n            return;\n        }\n    };\n\n    match client.name_resolve(Some(&publish.name), true, false).await {\n        Ok(resolved) => {\n            eprintln!(\"/ipns/{} resolves to: {}\", &publish.name, &resolved.path);\n        }\n        Err(e) => {\n            eprintln!(\"error resolving name: {}\", e);\n        }\n    }\n}", "item_id": 0, "repo": "hanabi1224/rust-ipfs-api", "file": "ipfs-api-examples/examples/resolve_name.rs", "last_update_at": "2022-03-26T02:37:44+00:00"}
{"hexsha": "7f4f4a85523e169edbd101e27da6c913897bbc70", "ext": "rs", "lang": "Rust", "content": "fn test_sub_self() {\n        let a;\n        let mut b;\n\n        let (ap, asz) = make_limbs!(const a, 0, 2);\n        let bp = make_limbs!(out b, 2);\n        let bsz = 2;\n        b[0] = Limb(2);\n        b[1] = Limb(1);\n\n        unsafe {\n            assert_eq!(sub(bp, ap, asz, bp.as_const(), bsz), 0);\n        }\n        assert_eq!(b, [!1, 0]);\n    }", "item_id": 8, "repo": "nathanwhit/ramp", "file": "src/ll/mod.rs", "last_update_at": "2022-03-13T04:48:43+00:00"}
{"hexsha": "39d5191dc6f2291cc6ce204de3f3872aac335526", "ext": "rs", "lang": "Rust", "content": "pub async fn redrive_webhook_result(configuration: &configuration::Configuration, params: RedriveWebhookResultParams) -> Result<crate::models::WebhookRedriveResult, Error<RedriveWebhookResultError>> {\n    // unbox the parameters\n    let webhook_result_id = params.webhook_result_id;\n\n\n    let local_var_client = &configuration.client;\n\n    let local_var_uri_str = format!(\"{}/webhooks/results/{webhookResultId}/redrive\", configuration.base_path, webhookResultId=webhook_result_id);\n    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());\n\n    if let Some(ref local_var_user_agent) = configuration.user_agent {\n        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());\n    }\n    if let Some(ref local_var_apikey) = configuration.api_key {\n        let local_var_key = local_var_apikey.key.clone();\n        let local_var_value = match local_var_apikey.prefix {\n            Some(ref local_var_prefix) => format!(\"{} {}\", local_var_prefix, local_var_key),\n            None => local_var_key,\n        };\n        local_var_req_builder = local_var_req_builder.header(\"x-api-key\", local_var_value);\n    };\n\n    let local_var_req = local_var_req_builder.build()?;\n    let local_var_resp = local_var_client.execute(local_var_req).await?;\n\n    let local_var_status = local_var_resp.status();\n    let local_var_content = local_var_resp.text().await?;\n\n    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {\n        serde_json::from_str(&local_var_content).map_err(Error::from)\n    } else {\n        let local_var_entity: Option<RedriveWebhookResultError> = serde_json::from_str(&local_var_content).ok();\n        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };\n        Err(Error::ResponseError(local_var_error))\n    }\n}", "item_id": 17, "repo": "mailslurp/mailslurp-client-rust", "file": "src/apis/webhook_controller_api.rs", "last_update_at": "2022-03-08T02:34:57+00:00"}
{"hexsha": "a64e26f13048d3dae7059431e5afa22048c83b5a", "ext": "rs", "lang": "Rust", "content": "fn it_works() {\n        asdf\n//      ^^^^ERR(<1.16.0,rust_syntax_checking_include_tests=True) unresolved name\n//      ^^^^ERR(<1.16.0,rust_syntax_checking_include_tests=True) unresolved name\n//      ^^^^ERR(>=1.23.0,rust_syntax_checking_include_tests=True) cannot find value\n//      ^^^^ERR(>=1.23.0,rust_syntax_checking_include_tests=True) not found in this scope\n    }", "item_id": 1, "repo": "steveklabnik/sublime-rust", "file": "tests/error-tests/src/lib.rs", "last_update_at": "2022-03-28T19:03:37+00:00"}
{"hexsha": "562159a5c0c10143023a752d9d16ca66d256582b", "ext": "rs", "lang": "Rust", "content": "async fn test_bad_raw_query_syntax() -> ReturnUnit {\n        let cat = create_test_catalog(\"test_index\");\n        let body = r#\"{ \"query\" : { \"raw\": \"asd*(@sq__\" } }\"#;\n        let err = doc_search(Arc::clone(&cat), Body::from(body), \"test_index\").await?;\n        let body: ErrorResponse = wait_json::<ErrorResponse>(err).await;\n        assert_eq!(body.message, \"Error in Index: \\'Syntax Error\\'\");\n        Ok(())\n    }", "item_id": 2, "repo": "toshi-search/Toshi", "file": "toshi-server/src/handlers/search.rs", "last_update_at": "2022-03-31T15:55:04+00:00"}
{"hexsha": "0cde25078991b22a0a3f923899068105690d4d21", "ext": "rs", "lang": "Rust", "content": "fn html_writer_basic_colors() -> anyhow::Result<()> {\n        let mut buffer = String::new();\n        let mut writer = HtmlWriter::new(&mut buffer, None);\n        write!(writer, \"Hello, \")?;\n        writer.set_color(\n            ColorSpec::new()\n                .set_bold(true)\n                .set_underline(true)\n                .set_fg(Some(Color::Green))\n                .set_bg(Some(Color::White)),\n        )?;\n        write!(writer, \"world\")?;\n        writer.reset()?;\n        write!(writer, \"!\")?;\n\n        assert_eq!(\n            buffer,\n            r#\"Hello, <span class=\"bold underline fg2 bg7\">world</span>!\"#\n        );\n\n        Ok(())\n    }", "item_id": 1, "repo": "slowli/term-transcript", "file": "src/html.rs", "last_update_at": "2022-02-24T17:38:56+00:00"}
{"hexsha": "2d21e3d23b05466323d410b8d353bafba83dd045", "ext": "rs", "lang": "Rust", "content": "fn set_limited_discoverable_bad_adv_type() {\n    let mut sink = RecordingSink::new();\n    {\n        let mut fixture = Fixture::new(&mut sink);\n        let err = fixture\n            .act(|controller| {\n                controller.set_limited_discoverable(&DiscoverableParameters {\n                    advertising_type: AdvertisingType::ConnectableDirectedHighDutyCycle,\n                    advertising_interval: Some((\n                        Duration::from_millis(1280),\n                        Duration::from_millis(2560),\n                    )),\n                    address_type: OwnAddressType::Public,\n                    filter_policy: AdvertisingFilterPolicy::AllowConnectionAndScan,\n                    local_name: Some(LocalName::Shortened(b\"testdev\")),\n                    advertising_data: &[0x01, 0x02, 0x03, 0x04],\n                    conn_interval: (Some(Duration::from_millis(5000)), None),\n                })\n            })\n            .err()\n            .unwrap();\n        assert_eq!(\n            err,\n            nb::Error::Other(Error::BadAdvertisingType(\n                AdvertisingType::ConnectableDirectedHighDutyCycle\n            ))\n        );\n    }\n\n    assert!(!sink.wrote_header());\n}", "item_id": 2, "repo": "antoinevg/bluenrg", "file": "tests/gap.rs", "last_update_at": "2022-03-05T04:52:30+00:00"}
{"hexsha": "c116c1124eddbe1d1b2a05542c894884a2d8ca99", "ext": "rs", "lang": "Rust", "content": "async fn handle_socks(mut stream: TcpStream, server: String,uuid: [u8; 16]) -> Result<()> {\n    let mut buf = [0; 1024];\n\n    let len = stream.read(&mut buf).await?;\n\n    // socks5: first handshake begin\n    if 1 + 1 + (buf[1] as usize) != len || buf[0] != b'\\x05' {\n        warn!(\"invalid header\");\n        return Ok(());\n    }\n    stream.write_all(b\"\\x05\\x00\").await?; // version 5, method 0\n\n    // socks5: first handshake begin\n    let len = stream.read(&mut buf).await?;\n    if len <= 4 {\n        warn!(\"invalid proto\");\n        return Ok(());\n    }\n\n    let ver = buf[0]; // version\n    let cmd = buf[1]; // command code 1-connect 2-bind 3-udp forward\n    let atyp = buf[3]; // type of the dist server 1-ipv4 3-domain 4-ipv6\n\n    if ver != b'\\x05' {\n        warn!(\"invalid proto\");\n        return Ok(());\n    }\n\n    if cmd != 1 {\n        warn!(\"Command not supported\");\n        stream\n            .write_all(b\"\\x05\\x07\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\")\n            .await?;\n        return Ok(());\n    }\n\n    let (addr, ipbuf, portbuf) = decode_atyp(atyp, len, &buf).unwrap();\n\n    vmess_proxy(stream, &server, (addr, ipbuf, portbuf),uuid).await?;\n\n    Ok(())\n}", "item_id": 1, "repo": "irumeria/tokio-vmess", "file": "src/socks.rs", "last_update_at": "2022-02-11T20:06:12+00:00"}
{"hexsha": "ff2f4883dac8a1c3022c30054dc47766f61f1f86", "ext": "rs", "lang": "Rust", "content": "fn disable_devices() {\n\twait_write();\n\tunsafe {\n\t\tio::outb(COMMAND_REGISTER, 0xad);\n\t}\n\n\twait_write();\n\tunsafe {\n\t\tio::outb(COMMAND_REGISTER, 0xa7);\n\t}\n}", "item_id": 1, "repo": "llenotre/maestro", "file": "src/device/ps2.rs", "last_update_at": "2022-03-04T15:29:05+00:00"}
{"hexsha": "ef451145d11aad10740dd6887f5fb5c1af4124dc", "ext": "rs", "lang": "Rust", "content": "fn set(args: &SetArguments) -> Result<()> {\n    let mut config = crate::config::Config::load()?;\n    config.set(&args.path, &args.value)?;\n    config.dump()?;\n    Ok(())\n}", "item_id": 0, "repo": "openfare/openfare", "file": "openfare/src/command/config.rs", "last_update_at": "2022-03-31T09:32:29+00:00"}
{"hexsha": "b3c4fe615e1f5f4606357e6bd3cec096a407e78d", "ext": "rs", "lang": "Rust", "content": "async fn test_mute_combinations() {\n    let (service_registry, fake_services) = create_services().await;\n    let (env, _) = create_environment(service_registry).await;\n    let input_proxy = env.connect_to_service::<InputMarker>().unwrap();\n\n    // Hardware muted, software unmuted.\n    switch_hardware_mic_mute(&fake_services, true).await;\n    set_mic_mute(&input_proxy, false).await;\n    get_and_check_mic_mute(&input_proxy, true).await;\n\n    // Hardware muted, software muted.\n    set_mic_mute(&input_proxy, true).await;\n    get_and_check_mic_mute(&input_proxy, true).await;\n\n    // Hardware unmuted, software muted.\n    switch_hardware_mic_mute(&fake_services, false).await;\n    get_and_check_mic_mute(&input_proxy, true).await;\n\n    // Hardware unmuted, software unmuted.\n    switch_hardware_mic_mute(&fake_services, false).await;\n    set_mic_mute(&input_proxy, false).await;\n    get_and_check_mic_mute(&input_proxy, false).await;\n}", "item_id": 7, "repo": "dahlia-os/fuchsia-pine64-pinephone", "file": "garnet/bin/setui/src/tests/input_tests.rs", "last_update_at": "2022-03-12T03:20:43+00:00"}
{"hexsha": "96505ebeaf5c96af46eb7c6ad159836fef5202f9", "ext": "rs", "lang": "Rust", "content": "fn draw_field(draw: &Draw, model: &Model, win: &Rect) {\n  let color = hsl(0.0, 0.0, 0.02);\n  let source = OpenSimplex::new();\n  let noisefn = Terrace::new(&source)\n    .add_control_point(model.control_point1)\n    .add_control_point(model.control_point2)\n    .add_control_point(model.control_point3)\n    .add_control_point(model.control_point4)\n    .add_control_point(model.control_point5);\n\n  for _i in 0..=model.n_lines {\n    // circular placement\n    // let init_angle = map_range(_i, 0, model.n_lines, 0.0, 2.0 * PI);\n    // let mut x = init_angle.cos() * win.left().hypot(win.bottom()) * model.radius;\n    // let mut y = init_angle.sin() * win.left().hypot(win.bottom()) * model.radius;\n\n    // random rectangular placement\n    let diag = win.left().hypot(win.bottom());\n    let mut x = random_range(diag * model.radius / 2.0, diag * -model.radius / 2.0);\n    let mut y = random_range(diag * model.radius / 2.0, diag * -model.radius / 2.0);\n\n    let _init_x = x;\n    let init_y = y;\n\n    // Generate points for the line that do not intersect other lines\n    let points = (0..model.n_steps)\n      .map(|_n| {\n        // let angle = field(model, x, y);\n        // hmm, not quite sure why this is necessary\n        let angle = noise_field(model.seed, model.noise_scale, x, y, &noisefn);\n        if init_y < 0.0 {\n          x -= angle.cos();\n          y -= angle.sin();\n        } else {\n          x += angle.cos();\n          y += angle.sin();\n        };\n\n        let point = pt2(x, y);\n        Some(point)\n      })\n      // Skip any initial Nones\n      // Take all the Somes until we hit a None.\n      .skip_while(|&o| o.is_none())\n      .take_while(|&o| o.is_some())\n      .filter_map(|o| o);\n\n    draw\n      .polyline()\n      .caps_round()\n      .weight(model.stroke_weight)\n      .color(color)\n      .points(points);\n  }\n}", "item_id": 6, "repo": "ericyd/generative-art", "file": "nannou/examples/watercolor3.rs", "last_update_at": "2022-03-12T21:02:12+00:00"}
{"hexsha": "489ad77a50a1f9d245b0af344d944074e4afeff2", "ext": "rs", "lang": "Rust", "content": "async fn atomic_update_reader() {\n        let inspector = Inspector::new();\n\n        // Spawn a read thread that holds a duplicate handle to the VMO that will be written.\n        let vmo = inspector.duplicate_vmo().expect(\"duplicate vmo handle\");\n        let (p1, p2) = zx::EventPair::create().unwrap();\n\n        macro_rules! notify_and_wait_reader {\n            () => {\n                p1.signal_peer(zx::Signals::NONE, zx::Signals::USER_0).unwrap();\n                p1.wait_handle(zx::Signals::USER_0, zx::Time::INFINITE).unwrap();\n                p1.signal_handle(zx::Signals::USER_0, zx::Signals::NONE).unwrap();\n            };\n        }\n\n        macro_rules! wait_and_notify_writer {\n            ($code:block) => {\n              p2.wait_handle(zx::Signals::USER_0, zx::Time::INFINITE).unwrap();\n              p2.signal_handle(zx::Signals::USER_0, zx::Signals::NONE).unwrap();\n              $code\n              p2.signal_peer(zx::Signals::NONE, zx::Signals::USER_0).unwrap();\n            }\n        }\n\n        let thread = std::thread::spawn(move || {\n            // Before running the atomic update.\n            wait_and_notify_writer! {{\n                let hierarchy: DiagnosticsHierarchy<String> =\n                    reader::PartialNodeHierarchy::try_from(&vmo).unwrap().into();\n                assert_eq!(hierarchy, DiagnosticsHierarchy::new_root());\n            }};\n            // After: create_child(\"child\"): Assert that the VMO is in use (locked) and we can't\n            // read.\n            wait_and_notify_writer! {{\n                assert!(reader::PartialNodeHierarchy::try_from(&vmo).is_err());\n            }};\n            // After: record_int(\"a\"): Assert that the VMO is in use (locked) and we can't\n            // read.\n            wait_and_notify_writer! {{\n                assert!(reader::PartialNodeHierarchy::try_from(&vmo).is_err());\n            }};\n            // After: record_int(\"b\"): Assert that the VMO is in use (locked) and we can't\n            // read.\n            wait_and_notify_writer! {{\n                assert!(reader::PartialNodeHierarchy::try_from(&vmo).is_err());\n            }};\n            // After atomic update\n            wait_and_notify_writer! {{\n                let hierarchy: DiagnosticsHierarchy<String> =\n                    reader::PartialNodeHierarchy::try_from(&vmo).unwrap().into();\n                assert_data_tree!(hierarchy, root: {\n                   value: 2i64,\n                   child: {\n                       a: 1i64,\n                       b: 2i64,\n                   }\n                });\n            }};\n        });\n\n        // Perform the atomic update\n        let mut child = Node::default();\n        notify_and_wait_reader!();\n        let int_val = inspector.root().create_int(\"value\", 1);\n        inspector\n            .root()\n            .atomic_update(|node| {\n                // Intentionally make this slow to assert an atomic update in the reader.\n                child = node.create_child(\"child\");\n                notify_and_wait_reader!();\n                child.record_int(\"a\", 1);\n                notify_and_wait_reader!();\n                child.record_int(\"b\", 2);\n                notify_and_wait_reader!();\n                int_val.add(1);\n                Ok::<(), Error>(())\n            })\n            .expect(\"successful atomic update\");\n        notify_and_wait_reader!();\n\n        // Wait for the reader thread to successfully finish.\n        let _ = thread.join();\n\n        // Ensure that the variable that we mutated internally can be used.\n        child.record_int(\"c\", 3);\n        assert_data_tree!(inspector, root: {\n            value: 2i64,\n            child: {\n                a: 1i64,\n                b: 2i64,\n                c: 3i64,\n            }\n        });\n    }", "item_id": 10, "repo": "Prajwal-Koirala/fuchsia", "file": "src/lib/diagnostics/inspect/rust/src/writer/types/node.rs", "last_update_at": "2022-01-04T15:37:09+00:00"}
{"hexsha": "c39f066f8958f23479aabe6f8d70e6bab13226e2", "ext": "rs", "lang": "Rust", "content": "fn test_etag() {\n    use headers::test_utils::{assert_conversion_correct, assert_interpretation_correct,\n                              assert_invalid};\n    assert_conversion_correct(\"\\\"\\\"\", strong_etag(\"\"));\n    assert_conversion_correct(\"\\\"fO0\\\"\", strong_etag(\"fO0\"));\n    assert_conversion_correct(\"\\\"fO0 bar\\\"\", strong_etag(\"fO0 bar\"));\n    assert_conversion_correct(\"\\\"fO0 \\\\\\\"bar\\\"\", strong_etag(\"fO0 \\\"bar\"));\n    assert_conversion_correct(\"\\\"fO0 \\\\\\\"bar\\\\\\\"\\\"\", strong_etag(\"fO0 \\\"bar\\\"\"));\n\n    assert_conversion_correct(\"W/\\\"\\\"\", weak_etag(\"\"));\n    assert_conversion_correct(\"W/\\\"fO0\\\"\", weak_etag(\"fO0\"));\n    assert_conversion_correct(\"W/\\\"fO0 bar\\\"\", weak_etag(\"fO0 bar\"));\n    assert_conversion_correct(\"W/\\\"fO0 \\\\\\\"bar\\\"\", weak_etag(\"fO0 \\\"bar\"));\n    assert_conversion_correct(\"W/\\\"fO0 \\\\\\\"bar\\\\\\\"\\\"\", weak_etag(\"fO0 \\\"bar\\\"\"));\n    assert_interpretation_correct(\"w/\\\"fO0\\\"\", weak_etag(\"fO0\"));\n\n    assert_invalid::<EntityTag>(\"\");\n    assert_invalid::<EntityTag>(\"fO0\");\n    assert_invalid::<EntityTag>(\"\\\"\\\\\\\"\");\n    assert_invalid::<EntityTag>(\"\\\"\\\"\\\"\\\"\");\n}", "item_id": 0, "repo": "jeff-davis/rust-http", "file": "src/http/headers/etag.rs", "last_update_at": "2022-02-11T06:51:31+00:00"}
{"hexsha": "badce57a5d5d436ceb4dd7413877bfcfdf4c6ae6", "ext": "rs", "lang": "Rust", "content": "fn check_vhost_file_access(host_file_location: &String) -> Result<()> {\n    let contents = fs::read_to_string(host_file_location)\n        .with_context(|| format!(\"Unable to open {}\",  host_file_location))?;\n    let mut file = OpenOptions::new().write(true).truncate(true).open(host_file_location)?;\n    file.write(contents.as_bytes())\n        .with_context(|| format!(\"Unable to write to file {}\", host_file_location))?;\n    file.sync_all()?;\n    Ok(())\n}", "item_id": 4, "repo": "itaylor/docker-vhoster", "file": "src/main.rs", "last_update_at": "2022-03-15T23:11:53+00:00"}
{"hexsha": "50fdc5ef6908110f35a85b94862f0e65496f4d9c", "ext": "rs", "lang": "Rust", "content": "fn pop_last_span() {\n        let mut stack = SpanStack::new();\n        let id = Id::from_u64(1);\n        stack.push(id.clone());\n\n        assert_eq!(Some(id.clone()), stack.pop(&id));\n    }", "item_id": 0, "repo": "wwjiang007/fuchsia-1", "file": "third_party/rust_crates/vendor/tracing-subscriber/src/registry/stack.rs", "last_update_at": "2022-03-28T07:59:06+00:00"}
{"hexsha": "0d52db0b3e25e49604bd1717bb5bcfcb64e5db30", "ext": "rs", "lang": "Rust", "content": "fn safe_integral_is_pos_policy_for_t<T>()\n    where\n        T: Integer + std::panic::RefUnwindSafe,\n    {\n        let val = SafeIntegral::<T>::magic_1();\n        assert_eq!(val.is_pos(), true);\n\n        let val = SafeIntegral::<T>::magic_1() + SafeIntegral::<T>::magic_1();\n        assert_eq!(val.checked().is_pos(), true);\n\n        let val = SafeIntegral::<T>::failure();\n        assert_panics!(val.is_pos());\n\n        let val = SafeIntegral::<T>::magic_1() + SafeIntegral::<T>::magic_1();\n        assert_panics!(val.is_pos());\n    }", "item_id": 51, "repo": "Bareflank/dynarray", "file": "include/bsl/safe_integral.rs", "last_update_at": "2022-03-31T18:04:47+00:00"}
{"hexsha": "dedc3653184eef876ff815ddb0d57675ad5cc4cd", "ext": "rs", "lang": "Rust", "content": "pub fn perform_highpass(\n    data: &mut [f64],\n    sampling_rate: usize,\n    cutoff: f64,\n    order: usize,\n    filter_type: FilterTypes,\n    ripple: f64,\n) -> Result<()> {\n    let res = unsafe {\n        data_handler::perform_highpass(\n            data.as_mut_ptr() as *mut c_double,\n            data.len() as c_int,\n            sampling_rate as c_int,\n            cutoff as c_double,\n            order as c_int,\n            filter_type as c_int,\n            ripple as c_double,\n        )\n    };\n    check_brainflow_exit_code(res)?;\n    Ok(())\n}", "item_id": 2, "repo": "xgdgsc/brainflow", "file": "rust-package/brainflow/src/data_filter.rs", "last_update_at": "2022-01-08T15:25:46+00:00"}
{"hexsha": "2bc74d77633e7b155169b3cdb7c93955b7531403", "ext": "rs", "lang": "Rust", "content": "pub fn start_watcher<TApi>(\n    config_path: PathBuf,\n    config_directory_path: PathBuf,\n    api: std::sync::Arc<futures_util::lock::Mutex<TApi>>,\n) where\n    TApi: UpdateConfig + Send + 'static,\n{\n    // DEVNOTE: The channel created for file watcher receiver needs to address up to two messages,\n    // since the message is resent to file change receiver using a blocking send.\n    // When the number of messages is set to 1, then main thread appears to block.\n    let (file_changed_tx, mut file_changed_rx) = tokio::sync::mpsc::channel(2);\n\n    let config_path_clone = config_path.clone();\n    let config_directory_path_clone = config_directory_path.clone();\n\n    // Start file change listener that asynchronously reads and updates service config.\n    tokio::spawn(async move {\n        while let Some(()) = file_changed_rx.recv().await {\n            let new_config =\n                match crate::read_config(&config_path_clone, Some(&config_directory_path_clone)) {\n                    Ok(config) => config,\n                    Err(err) => {\n                        log::warn!(\n                        \"Detected config file update, but new config failed to parse. Error: {}\",\n                        err\n                    );\n                        continue;\n                    }\n                };\n\n            let mut api = api.lock().await;\n\n            if let Err(err) = api.update_config(new_config).await {\n                log::warn!(\"Config update failed. Error: {}\", err);\n            }\n        }\n    });\n\n    // Start file watcher using blocking channel.\n    std::thread::spawn({\n        move || {\n            let (file_watcher_tx, file_watcher_rx) = std::sync::mpsc::channel();\n\n            // Create a watcher object, delivering debounced events.\n            let mut file_watcher =\n                notify::watcher(file_watcher_tx, std::time::Duration::from_secs(10)).unwrap();\n\n            // Add configuration paths to be watched.\n            if config_directory_path.exists() {\n                file_watcher\n                    .watch(config_directory_path, notify::RecursiveMode::NonRecursive)\n                    .expect(\"Watching config directory path should not fail.\");\n            }\n\n            if config_path.exists() {\n                file_watcher\n                    .watch(config_path, notify::RecursiveMode::NonRecursive)\n                    .expect(\"Watching config file should not fail.\");\n            }\n\n            loop {\n                let event = file_watcher_rx.recv();\n                log::debug!(\"Incoming file watcher event: {:?}\", &event);\n\n                if let Ok(event) = event {\n                    match event {\n                        notify::DebouncedEvent::NoticeWrite(_)\n                        | notify::DebouncedEvent::NoticeRemove(_)\n                        | notify::DebouncedEvent::Rescan\n                        | notify::DebouncedEvent::Error(_, _) => {}\n\n                        notify::DebouncedEvent::Create(_)\n                        | notify::DebouncedEvent::Write(_)\n                        | notify::DebouncedEvent::Chmod(_)\n                        | notify::DebouncedEvent::Remove(_)\n                        | notify::DebouncedEvent::Rename(_, _) => {\n                            let _ = file_changed_tx.blocking_send(());\n                        }\n                    };\n                }\n            }\n        }\n    });\n}", "item_id": 0, "repo": "vadim-kovalyov/iot-identity-service", "file": "config-common/src/watcher.rs", "last_update_at": "2022-01-11T23:37:34+00:00"}
{"hexsha": "36730aed9dfe5926038aaf7427051082fb9a2994", "ext": "rs", "lang": "Rust", "content": "fn get_expected_value_for_string_append_with_original_update_object(\n    original_update_object: &serde_json::value::Map<String, serde_json::Value>,\n    field: &'static Field<String>,\n    string: &str\n) -> Result<serde_json::value::Value, Box<dyn std::error::Error>> {\n    let original_bytes_option = original_update_object.get(&field.name);\n    let original_bytes = get_original_bytes(&original_bytes_option)?;\n\n    return Ok(\n        serde_json::json!(\n            original_bytes\n                .iter()\n                .chain(string.as_bytes())\n                .cloned()\n                .collect::<Vec<u8>>()\n        )\n    );\n}", "item_id": 1, "repo": "Sudograph/sudograph", "file": "sudograph-tests/canisters/test_utilities/src/arbitraries/queries/input_info_strategies/input_info_strategy_blob.rs", "last_update_at": "2022-03-30T21:02:23+00:00"}
{"hexsha": "cebf25bba760a73d8e3a6086e7f79edc52e1d037", "ext": "rs", "lang": "Rust", "content": "async fn test_pow() {\n        let pow_cfg = Config::load_test()\n            .and_then(|cfg| cfg.get::<PoWConfig>(\"pow\"))\n            .unwrap_or_default();\n        pow_cfg.install_as_global().ok();\n\n        let mut blk = Block::genesis_block();\n        blk.header.tx_list = std::iter::repeat_with(H256::zero).take(100).collect();\n\n        for _ in 0..30 {\n            let mut header = blk.header.clone();\n            header.height = header.height.next_height();\n            header.set_ts(Utc::now());\n            let new_blk = create_new_block(header, &blk).await.unwrap();\n            println!(\"diff = {}\", new_blk.diff);\n            println!(\"time = {}\", new_blk.time_stamp() - blk.time_stamp());\n            println!(\"nonce = {}\", new_blk.nonce);\n            println!(\"target = {}\", U256::MAX / U256::from(new_blk.diff));\n            println!(\"---------------------\");\n            blk = new_blk;\n        }\n    }", "item_id": 5, "repo": "hkbudb/slimchain", "file": "slimchain-chain/src/consensus/pow.rs", "last_update_at": "2022-02-13T13:51:45+00:00"}
{"hexsha": "4a10a39040b92a5447417c7ebb202e228a2ff783", "ext": "rs", "lang": "Rust", "content": "unsafe fn alloc(size: usize) -> (*mut u8, u64, usize) {\n        let (p, off, len, z) = Self::pre_alloc(size);\n        Self::drop_on_failure(off, len, z);\n        Self::perform(z);\n        (p, off, len)\n    }", "item_id": 6, "repo": "NVSL/Corundum", "file": "src/alloc/pool.rs", "last_update_at": "2022-02-18T22:36:33+00:00"}
{"hexsha": "9cf96a415ee61e2a06b10e1d6062498c19a98764", "ext": "rs", "lang": "Rust", "content": "fn buffer_length_is_correct_for_server_demand_active() {\n    let data = SERVER_DEMAND_ACTIVE.clone();\n    let expected_buffer_len = SERVER_DEMAND_ACTIVE_BUFFER.len();\n\n    let len = data.buffer_length();\n\n    assert_eq!(expected_buffer_len, len);\n}", "item_id": 3, "repo": "msabansal/IronRDP", "file": "ironrdp/src/rdp/capability_sets/test.rs", "last_update_at": "2022-03-28T01:31:18+00:00"}
{"hexsha": "2bd0b28762cbb562aef54469fa61edf0c4070892", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn prepare_effects(\n    mut commands: Commands,\n    sim_params: Res<SimParams>,\n    render_device: Res<RenderDevice>,\n    render_queue: Res<RenderQueue>,\n    //update_pipeline: Res<ParticlesUpdatePipeline>, // TODO move update_pipeline.pipeline to EffectsMeta\n    mut effects_meta: ResMut<EffectsMeta>,\n    mut extracted_effects: ResMut<ExtractedEffects>,\n) {\n    trace!(\"prepare_effects\");\n\n    // Allocate simulation uniform if needed\n    if effects_meta.sim_params_uniforms.is_empty() {\n        effects_meta\n            .sim_params_uniforms\n            .push(SimParamsUniform::default());\n    }\n\n    // Update simulation parameters\n    {\n        let sim_params_uni = effects_meta.sim_params_uniforms.get_mut(0);\n        let sim_params = *sim_params;\n        *sim_params_uni = sim_params.into();\n    }\n    trace!(\n        \"Simulation parameters: time={} dt={}\",\n        sim_params.time,\n        sim_params.dt\n    );\n    effects_meta\n        .sim_params_uniforms\n        .write_buffer(&render_device, &render_queue);\n\n    // Allocate spawner buffer if needed\n    //if effects_meta.spawner_buffer.is_empty() {\n    //    effects_meta.spawner_buffer.push(SpawnerParams::default());\n    //}\n\n    // Write vertices (TODO - lazily once only)\n    effects_meta\n        .vertices\n        .write_buffer(&render_device, &render_queue);\n\n    // Allocate GPU data for newly created effect instances. Do this first to ensure a group is not left\n    // unused and dropped due to the last effect being removed but a new compatible one added not being\n    // inserted yet. By inserting first, we ensure the group is not dropped in this case.\n    for added_effect in extracted_effects.added_effects.drain(..) {\n        let entity = added_effect.entity;\n        let id = effects_meta.effect_cache.insert(\n            added_effect.handle,\n            added_effect.capacity,\n            added_effect.item_size,\n            //update_pipeline.pipeline.clone(),\n            &render_queue,\n        );\n        let slice = effects_meta.effect_cache.get_slice(id);\n        effects_meta.entity_map.insert(entity, slice);\n    }\n\n    // Deallocate GPU data for destroyed effect instances. This will automatically drop any group where\n    // there is no more effect slice.\n    for _entity in extracted_effects.removed_effect_entities.iter() {\n        unimplemented!(\"Remove particle effect.\");\n        //effects_meta.remove(&*entity);\n    }\n\n    // // sort first by z and then by handle. this ensures that, when possible, batches span multiple z layers\n    // // batches won't span z-layers if there is another batch between them\n    // extracted_effects.effects.sort_by(|a, b| {\n    //     match FloatOrd(a.transform.w_axis[2]).cmp(&FloatOrd(b.transform.w_axis[2])) {\n    //         Ordering::Equal => a.handle.cmp(&b.handle),\n    //         other => other,\n    //     }\n    // });\n\n    // Get the effect-entity mapping\n    let mut effect_entity_list = extracted_effects\n        .effects\n        .iter()\n        .map(|(entity, extracted_effect)| {\n            let slice = effects_meta.entity_map.get(entity).unwrap().clone();\n            (slice, extracted_effect)\n        })\n        .collect::<Vec<_>>();\n    trace!(\"Collected {} extracted effects\", effect_entity_list.len());\n\n    // Sort first by effect buffer, then by slice range (see EffectSlice)\n    effect_entity_list.sort_by(|a, b| a.0.cmp(&b.0));\n\n    // Loop on all extracted effects in order\n    effects_meta.spawner_buffer.clear();\n    let mut spawner_base = 0;\n    let mut item_size = 0;\n    let mut current_buffer_index = u32::MAX;\n    let mut asset: Handle<EffectAsset> = Default::default();\n    let mut layout_flags = LayoutFlags::NONE;\n    let mut image_handle_id: HandleId = HandleId::default::<Image>();\n    let mut shader: Handle<Shader> = Default::default();\n    let mut start = 0;\n    let mut end = 0;\n    let mut num_emitted = 0;\n    let mut position_code = String::default();\n    let mut force_field_code = String::default();\n    let mut lifetime_code = String::default();\n\n    for (slice, extracted_effect) in effect_entity_list {\n        let buffer_index = slice.group_index;\n        let range = slice.slice;\n        layout_flags = if extracted_effect.has_image {\n            LayoutFlags::PARTICLE_TEXTURE\n        } else {\n            LayoutFlags::NONE\n        };\n        image_handle_id = extracted_effect.image_handle_id;\n        trace!(\"Effect: buffer #{} | range {:?}\", buffer_index, range);\n\n        // Check the buffer the effect is in\n        assert!(buffer_index >= current_buffer_index || current_buffer_index == u32::MAX);\n        if current_buffer_index != buffer_index {\n            trace!(\n                \"+ New buffer! ({} -> {})\",\n                current_buffer_index,\n                buffer_index\n            );\n            // Commit previous buffer if any\n            if current_buffer_index != u32::MAX {\n                // Record open batch if any\n                trace!(\"+ Prev: {} - {}\", start, end);\n                if end > start {\n                    assert_ne!(asset, Handle::<EffectAsset>::default());\n                    assert!(item_size > 0);\n                    trace!(\n                        \"Emit batch: buffer #{} | spawner_base {} | slice {:?} | item_size {} | shader {:?}\",\n                        current_buffer_index,\n                        spawner_base,\n                        start..end,\n                        item_size,\n                        shader\n                    );\n                    commands.spawn_bundle((EffectBatch {\n                        buffer_index: current_buffer_index,\n                        spawner_base: spawner_base as u32,\n                        slice: start..end,\n                        item_size,\n                        handle: asset.clone_weak(),\n                        layout_flags,\n                        image_handle_id,\n                        shader: shader.clone(),\n                        position_code: position_code.clone(),\n                        force_field_code: force_field_code.clone(),\n                        lifetime_code: lifetime_code.clone(),\n                        compute_pipeline: None,\n                    },));\n                    num_emitted += 1;\n                }\n            }\n\n            // Move to next buffer\n            current_buffer_index = buffer_index;\n            start = 0;\n            end = 0;\n            spawner_base = effects_meta.spawner_buffer.len();\n            trace!(\"+ New spawner_base = {}\", spawner_base);\n            // Each effect buffer contains effect instances with a compatible layout\n            // FIXME - Currently this means same effect asset, so things are easier...\n            asset = extracted_effect.handle.clone_weak();\n            item_size = slice.item_size;\n        }\n\n        assert_ne!(asset, Handle::<EffectAsset>::default());\n\n        shader = extracted_effect.shader.clone();\n        trace!(\"shader = {:?}\", shader);\n\n        trace!(\"item_size = {}B\", slice.item_size);\n\n        position_code = extracted_effect.position_code.clone();\n        trace!(\"position_code = {}\", position_code);\n\n        force_field_code = extracted_effect.force_field_code.clone();\n        trace!(\"force_field_code = {}\", force_field_code);\n\n        lifetime_code = extracted_effect.lifetime_code.clone();\n        trace!(\"lifetime_code = {}\", lifetime_code);\n\n        // extract the force field and turn it into a struct that is compliant with Std430,\n        // namely ForceFieldStd430\n        let mut extracted_force_field = [ForceFieldStd430::default(); FFNUM];\n        for (i, ff) in extracted_effect.force_field.iter().enumerate() {\n            extracted_force_field[i] = (*ff).into();\n        }\n\n        // Prepare the spawner block for the current slice\n        // FIXME - This is once per EFFECT/SLICE, not once per BATCH, so indeed this is spawner_BASE, and need an array of them in the compute shader!!!!!!!!!!!!!!\n        let spawner_params = SpawnerParams {\n            spawn: extracted_effect.spawn_count as i32,\n            count: 0,\n            origin: extracted_effect.transform.col(3).truncate(),\n            accel: extracted_effect.accel,\n            force_field: extracted_force_field, // extracted_effect.force_field,\n            seed: random::<u32>(),\n            ..Default::default()\n        };\n        trace!(\"spawner_params = {:?}\", spawner_params);\n        effects_meta.spawner_buffer.push(spawner_params);\n\n        trace!(\"slice = {}-{} | prev end = {}\", range.start, range.end, end);\n        if (range.start > end) || (item_size != slice.item_size) {\n            // Discontinuous slices; create a new batch\n            if end > start {\n                // Record the previous batch\n                assert_ne!(asset, Handle::<EffectAsset>::default());\n                assert!(item_size > 0);\n                trace!(\n                    \"Emit batch: buffer #{} | spawner_base {} | slice {:?} | item_size {} | shader {:?}\",\n                    buffer_index,\n                    spawner_base,\n                    start..end,\n                    item_size,\n                    shader\n                );\n                commands.spawn_bundle((EffectBatch {\n                    buffer_index,\n                    spawner_base: spawner_base as u32,\n                    slice: start..end,\n                    item_size,\n                    handle: asset.clone_weak(),\n                    layout_flags,\n                    image_handle_id,\n                    shader: shader.clone(),\n                    position_code: position_code.clone(),\n                    force_field_code: force_field_code.clone(),\n                    lifetime_code: lifetime_code.clone(),\n                    compute_pipeline: None,\n                },));\n                num_emitted += 1;\n            }\n            start = range.start;\n            item_size = slice.item_size;\n        }\n        end = range.end;\n    }\n\n    // Record last open batch if any\n    if end > start {\n        assert_ne!(asset, Handle::<EffectAsset>::default());\n        assert!(item_size > 0);\n        trace!(\n            \"Emit LAST batch: buffer #{} | spawner_base {} | slice {:?} | item_size {} | shader {:?}\",\n            current_buffer_index,\n            spawner_base,\n            start..end,\n            item_size,\n            shader\n        );\n        commands.spawn_bundle((EffectBatch {\n            buffer_index: current_buffer_index,\n            spawner_base: spawner_base as u32,\n            slice: start..end,\n            item_size,\n            handle: asset.clone_weak(),\n            layout_flags,\n            image_handle_id,\n            shader,\n            position_code,\n            force_field_code,\n            lifetime_code,\n            compute_pipeline: None,\n        },));\n        num_emitted += 1;\n    }\n    trace!(\n        \"Emitted {} buffers, spawner_buffer len = {}\",\n        num_emitted,\n        effects_meta.spawner_buffer.len()\n    );\n\n    // Write the entire spawner buffer for this frame, for all effects combined\n    effects_meta\n        .spawner_buffer\n        .write_buffer(&render_device, &render_queue);\n}", "item_id": 2, "repo": "djeedai/bevy_hanabi", "file": "src/render/mod.rs", "last_update_at": "2022-03-31T09:51:15+00:00"}
{"hexsha": "45d755071fd38bd417786aa87f53f00b64a9a613", "ext": "rs", "lang": "Rust", "content": "fn get_settings_interactively() -> Settings {\n    let mut input = String::new();\n\n    print!(\"Enter the C/C++ file to be converted to Rust : \");\n    io::stdout().flush().expect(\"FATAL : Buffer flush failed\");\n    io::stdin().read_line(&mut input).expect(\"Unable to read\");\n\n    let mut strict = String::new();\n\n    print!(\"Enter the translation mode [(S/s)trict/(L/l)oose] : \");\n    io::stdout().flush().expect(\"FATAL : Buffer flush failed\");\n    io::stdin().read_line(&mut strict).expect(\"Unable to read\");\n    let strict = strict.trim();\n    let strict = matches!(strict, \"S\" | \"Strict\" | \"s\");\n\n    let mut cargo = String::new();\n    print!(\"Do you want to create a cargo project :[Y/N]\");\n    io::stdout().flush().expect(\"FATAL : Buffer flush failed.\");\n    io::stdin()\n        .read_line(&mut cargo)\n        .expect(\"Unable to read input\");\n    let cargo = cargo.trim();\n    let cargo: bool = matches!(cargo, \"Y\" | \"y\");\n\n    let mut project_name = None;\n    if cargo {\n        let mut project = String::new();\n        print!(\"Enter cargo project name : \");\n        io::stdout().flush().expect(\"FATAL : Buffer flush failed\");\n        io::stdin()\n            .read_line(&mut project)\n            .expect(\"Unable to read input\");\n        project_name = Some(String::from(project.trim()));\n    }\n\n    Settings {\n        strict,\n        project_name,\n        files: vec![input.trim().to_owned()],\n    }\n}", "item_id": 1, "repo": "m-abrarhasan/crust", "file": "src/main.rs", "last_update_at": "2022-03-27T19:23:27+00:00"}
{"hexsha": "767350991ac08cc681344bf1063ed059726417c0", "ext": "rs", "lang": "Rust", "content": "fn test_loop_else_trim12() {\n    let t = LoopElseTrim12 { values: &[1] };\n    assert_eq!(t.render().unwrap(), \"a \\t1 b\");\n\n    let t = LoopElseTrim12 { values: &[] };\n    assert_eq!(t.render().unwrap(), \"a X\\n b\");\n}", "item_id": 13, "repo": "gpmake/askama", "file": "testing/tests/loop_else.rs", "last_update_at": "2022-01-19T19:15:54+00:00"}
{"hexsha": "0953cf2ae6dc86f53baca42a655a6165a3597861", "ext": "rs", "lang": "Rust", "content": "pub fn search<E: SearchEnv>(env: &mut E, name: &str) -> Option<Target> {\n    if name.contains('/') {\n        return if let Ok(path) = CString::new(name) {\n            Some(Target::External { path })\n        } else {\n            None\n        };\n    }\n\n    let builtin = env.builtins().get(name).copied();\n    if let Some(builtin) = builtin {\n        if builtin.r#type == Special {\n            return Some(builtin.into());\n        }\n    }\n\n    if let Some(function) = env.functions().get(name) {\n        return Some(function.0.clone().into());\n    }\n\n    if let Some(builtin) = builtin {\n        if builtin.r#type == Intrinsic {\n            return Some(builtin.into());\n        }\n    }\n\n    if let Some(path) = search_path(env, name) {\n        if let Some(builtin) = builtin {\n            assert_eq!(builtin.r#type, NonIntrinsic);\n            return Some(builtin.into());\n        }\n        return Some(Target::External { path });\n    }\n\n    None\n}", "item_id": 0, "repo": "magicant/yash-rs", "file": "yash-semantics/src/command_search.rs", "last_update_at": "2022-03-24T10:45:57+00:00"}
{"hexsha": "8abbbca823e7bcb5fde0e048d55209945d99b1a9", "ext": "rs", "lang": "Rust", "content": "fn _0032(b: &mut Bencher) {\n  let ctx = context(r#\"{}\"#);\n  let invocable_name = \"feel-date-function_ErrorCase_032_fc66cc2fec\";\n  assert_decision(&MODEL_EVALUATOR, invocable_name, &ctx, r#\"null([core::date] invalid date string '')\"#);\n  b.iter(|| MODEL_EVALUATOR.evaluate_invocable(invocable_name, &ctx));\n}", "item_id": 31, "repo": "dmntk/dmntk.rs", "file": "model-evaluator/benches/compliance/dmn_3_1115.rs", "last_update_at": "2022-03-31T13:13:29+00:00"}
{"hexsha": "6350c5fb113a1102b491ea5d2d9f622932f2b5a8", "ext": "rs", "lang": "Rust", "content": "fn list_with_text() {\n    // root (Document)\n    // \u2514\u2500\u2500 html\n    //     \u2514\u2500\u2500 head\n    //     \u2514\u2500\u2500 body\n    //         \u2514\u2500\u2500 ul\n    //             \u2514\u2500\u2500 li\n    //                 \u2514\u2500\u2500 list 1\n    //             \u2514\u2500\u2500 li\n    //                 \u2514\u2500\u2500 list 2\n    let root = create_base_dom_tree();\n    let mut body = root\n        .borrow_mut()\n        .first_child()\n        .unwrap()\n        .borrow_mut()\n        .first_child()\n        .unwrap()\n        .borrow_mut()\n        .next_sibling()\n        .unwrap();\n    add_child_ul_to(&mut body);\n\n    let mut li1 = body\n        .borrow_mut()\n        .first_child()\n        .unwrap()\n        .borrow_mut()\n        .first_child()\n        .unwrap();\n    add_text_node_to(&mut li1, \"list 1\");\n\n    let mut l12 = li1.borrow_mut().next_sibling().unwrap();\n    add_text_node_to(&mut l12, \"list 2\");\n\n    run_test!(\n        \"<html><head></head><body><ul><li>list 1</li><li>list 2</li></ul></body></html>\",\n        Some(root)\n    );\n}", "item_id": 10, "repo": "hikalium/liumos", "file": "app/browser-rs/tests/dom.rs", "last_update_at": "2022-03-24T19:02:52+00:00"}
{"hexsha": "46d192f462c52cc588e61632f92ee4effa4bbd01", "ext": "rs", "lang": "Rust", "content": "pub fn verify_fuchsia_pkg_cm_url(url: &str) -> Result<String> {\n    let url = match PkgUrl::parse(url) {\n        Ok(url) => url,\n        Err(e) => ffx_bail!(\"URL parsing error: {:?}\", e),\n    };\n\n    let resource = url.resource().ok_or(ffx_error!(\"URL does not contain a path to a manifest\"))?;\n    let manifest = resource\n        .split('/')\n        .last()\n        .ok_or(ffx_error!(\"Could not extract manifest filename from URL\"))?;\n\n    if let Some(name) = manifest.strip_suffix(\".cm\") {\n        Ok(name.to_string())\n    } else if manifest.ends_with(\".cmx\") {\n        ffx_bail!(\n            \"{} is a legacy component manifest. Run it using `ffx component run-legacy`\",\n            manifest\n        )\n    } else {\n        ffx_bail!(\n            \"{} is not a component manifest! Component manifests must end in the `cm` extension.\",\n            manifest\n        )\n    }\n}", "item_id": 1, "repo": "fabio-d/fuchsia-stardock", "file": "src/developer/ffx/plugins/component/common/src/lib.rs", "last_update_at": "2022-01-21T20:14:17+00:00"}
{"hexsha": "dbfb6f95a5a3c09d2aa1f8d7c6669ef2bd25601e", "ext": "rs", "lang": "Rust", "content": "fn read_document_nok_not_found() {\n\n    let (_server, client) = make_server_and_client();\n    client.create_database(\"/baseball\").run().unwrap();\n\n    match client.read_document(\"/baseball/babe_ruth\").run() {\n        Err(chill::Error::NotFound(..)) => (),\n        x @ _ => unexpected_result!(x),\n    }\n}", "item_id": 7, "repo": "baajur/chill", "file": "tests/actions.rs", "last_update_at": "2022-03-10T13:16:21+00:00"}
{"hexsha": "c16d223f5de9cba222b18b557bfe0e78720b7d75", "ext": "rs", "lang": "Rust", "content": "fn variables_invalid() {\n    let input = include_str!(\"inline_data_fragment/fixtures/variables.invalid.graphql\");\n    let expected = include_str!(\"inline_data_fragment/fixtures/variables.invalid.expected\");\n    test_fixture(transform_fixture, \"variables.invalid.graphql\", \"inline_data_fragment/fixtures/variables.invalid.expected\", input, expected);\n}", "item_id": 1, "repo": "erictaylor/relay", "file": "compiler/crates/relay-transforms/tests/inline_data_fragment_test.rs", "last_update_at": "2022-03-31T10:17:36+00:00"}
{"hexsha": "81d186e99e97da9364fdc65e09e7c264db315a8f", "ext": "rs", "lang": "Rust", "content": "fn build<'s>(nodes: BTreeMap<&'s str, MergeNode<'s>>, num_frames: i64) -> Vec<MergeScope<'s>> {\n    let mut scopes: Vec<_> = nodes\n        .into_values()\n        .map(|node| node.build(num_frames))\n        .collect();\n\n    // Earliest first:\n    scopes.sort_by_key(|scope| scope.relative_start_ns);\n\n    // Make sure sibling scopes do not overlap:\n    let mut relative_ns = 0;\n    for scope in &mut scopes {\n        scope.relative_start_ns = scope.relative_start_ns.max(relative_ns);\n        relative_ns = scope.relative_start_ns + scope.duration_per_frame_ns;\n    }\n\n    scopes\n}", "item_id": 0, "repo": "Nekrolm/puffin", "file": "puffin/src/merge.rs", "last_update_at": "2022-03-28T15:36:13+00:00"}
{"hexsha": "f43e6b4f3934ec1c6e5c25d3d52f0d34c0a345df", "ext": "rs", "lang": "Rust", "content": "fn parse_import_named_clause(p: &mut Parser) -> ParsedSyntax<CompletedMarker> {\n\tif !p.at(T!['{']) {\n\t\treturn Absent;\n\t}\n\n\tlet m = p.start();\n\n\tparse_default_import_specifier(p).or_missing(p);\n\tparse_named_import(p).or_missing_with_error(p, expected_named_import);\n\texpect_keyword(p, \"from\", T![from]);\n\tparse_module_source(p).or_missing_with_error(p, expected_module_source);\n\tparse_import_assertion(p).or_missing(p);\n\n\tPresent(m.complete(p, JS_IMPORT_NAMED_CLAUSE))\n}", "item_id": 3, "repo": "10088/tools", "file": "crates/rslint_parser/src/syntax/module.rs", "last_update_at": "2022-03-31T20:38:14+00:00"}
{"hexsha": "d63a3a3c21dfd4cedc1a7a2cab8c57ac018fb7b3", "ext": "rs", "lang": "Rust", "content": "async fn single_singleton() {\n    use crate::{DependencyContext, DependencyLifeCycle};\n    use std::sync::Arc;\n    use tokio::sync::RwLock;\n\n    let root_context = DependencyContext::new_root();\n    root_context.register_type::<RwLock<SingletonDependency>>(DependencyLifeCycle::Singleton).await.unwrap();\n\n    let dependency = root_context.resolve::<Arc<RwLock<SingletonDependency>>>().await.unwrap();\n\n    assert_eq!(dependency.read().await.str, \"test\".to_string());\n\n    dependency.write().await.str = \"test2\".to_string(); // \u0438\u0437\u043c\u0435\u043d\u044f\u0435\u043c \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 singletone \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438\n\n    let dependency2 = root_context.resolve::<Arc<RwLock<SingletonDependency>>>().await.unwrap();\n\n    assert_eq!(dependency2.read().await.str, \"test2\".to_string()); // \u0432\u0438\u0434\u0438\u043c \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u043d\u043e\u0435 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0432 \u043d\u043e\u0432\u043e\u043c \u043e\u0431\u044a\u0435\u043a\u0442\u0435\n}", "item_id": 0, "repo": "Vidrochka/anthill-di", "file": "src/tests/single_singleton.rs", "last_update_at": "2022-03-04T01:33:02+00:00"}
{"hexsha": "69cb13c991faa98f161e44d0088980ebb6f80b61", "ext": "rs", "lang": "Rust", "content": "fn do_something(data: &[u8], s: &mut StateTracker) {\n    //Do something. Like writing it to a file or to stdout...\n    std::io::stdout().write_all(data).unwrap();\n    s.bytes_used += data.len() as u64;\n}", "item_id": 1, "repo": "MinusKelvin/zstd-rs", "file": "src/bin/zstd.rs", "last_update_at": "2022-03-29T19:03:53+00:00"}
{"hexsha": "cbce4a9da80294ed41bcf44d246e24c09d0b59de", "ext": "rs", "lang": "Rust", "content": "pub async fn load_home(client: &Client) -> Result<(Vec<Video>, Vec<Video>), reqwest::Error> {\n    let trending_fut = invidious_videos(vec![], client, TRENDING_URL);\n    let popular_fut = invidious_videos(vec![], client, POPULAR_URL);\n    //let top_fut = home_videos(client, TOP_URL);\n\n    futures::try_join!(trending_fut, popular_fut)//, top_fut)\n}", "item_id": 0, "repo": "dfangx/invidious-tui", "file": "src/invidious.rs", "last_update_at": "2022-02-01T12:39:17+00:00"}
{"hexsha": "42d03f5a24edfe8dd99160f7ef0e293d55dcc02a", "ext": "rs", "lang": "Rust", "content": "pub async fn list<C>(client: &Client<C>) -> Result<Vec<Zone>, Error>\nwhere\n    C: Connect + Clone + Debug + Send + Sync + 'static,\n{\n    let path = format!(\"{}/v4/products/zones\", client.endpoint);\n\n    #[cfg(feature = \"logging\")]\n    if log_enabled!(Level::Debug) {\n        debug!(\"execute a request to list zones, path: '{}'\", &path);\n    }\n\n    client.get(&path).await.map_err(Error::List)\n}", "item_id": 0, "repo": "CleverCloud/clevercloud-sdk-rust", "file": "src/v4/products/zones.rs", "last_update_at": "2022-02-05T17:37:37+00:00"}
{"hexsha": "c6faf0bdd224fd7459877121d9036d9de4becc0b", "ext": "rs", "lang": "Rust", "content": "fn parse_function_native_method() -> anyhow::Result<()> {\n        let class = load_code(\"public native void log(int x);\")?;\n        assert_eq!(class.methods.len(), 1 /* <init> */ + 1);\n        assert_eq!(*class.methods[0].id.name, \"<init>\");\n\n        // Check method signature\n        let method = &class.methods[1];\n        assert_eq!(format!(\"{}\", method.id), \"Test.log(I)V\");\n        assert_eq!(format!(\"{}\", method.descriptor), \"(I)V\");\n        assert_eq!(\n            method.flags,\n            MethodAccessFlags::PUBLIC | MethodAccessFlags::NATIVE\n        );\n\n        // Check no Java implementation as native\n        assert_eq!(*method.code.lock().unwrap(), None);\n\n        Ok(())\n    }", "item_id": 10, "repo": "mrbbot/montera", "file": "src/class/parser.rs", "last_update_at": "2022-03-31T22:45:13+00:00"}
{"hexsha": "8d58f045f65e095a023d1fcdcb3ebdfbf4eea32d", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_structure_crate_model_webhook_definition(\n    object: &mut aws_smithy_json::serialize::JsonObjectWriter,\n    input: &crate::model::WebhookDefinition,\n) -> Result<(), aws_smithy_http::operation::SerializationError> {\n    if let Some(var_189) = &input.name {\n        object.key(\"name\").string(var_189);\n    }\n    if let Some(var_190) = &input.target_pipeline {\n        object.key(\"targetPipeline\").string(var_190);\n    }\n    if let Some(var_191) = &input.target_action {\n        object.key(\"targetAction\").string(var_191);\n    }\n    if let Some(var_192) = &input.filters {\n        let mut array_193 = object.key(\"filters\").start_array();\n        for item_194 in var_192 {\n            {\n                let mut object_195 = array_193.value().start_object();\n                crate::json_ser::serialize_structure_crate_model_webhook_filter_rule(\n                    &mut object_195,\n                    item_194,\n                )?;\n                object_195.finish();\n            }\n        }\n        array_193.finish();\n    }\n    if let Some(var_196) = &input.authentication {\n        object.key(\"authentication\").string(var_196.as_str());\n    }\n    if let Some(var_197) = &input.authentication_configuration {\n        let mut object_198 = object.key(\"authenticationConfiguration\").start_object();\n        crate::json_ser::serialize_structure_crate_model_webhook_auth_configuration(\n            &mut object_198,\n            var_197,\n        )?;\n        object_198.finish();\n    }\n    Ok(())\n}", "item_id": 42, "repo": "jdisanti/aws-sdk-rust", "file": "sdk/codepipeline/src/json_ser.rs", "last_update_at": "2022-03-31T20:47:15+00:00"}
{"hexsha": "b6b401423a70f0bbafd364b550f89737fbc86a43", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn open_impl(\n    start: &fs::File,\n    path: &Path,\n    options: &OpenOptions,\n) -> io::Result<fs::File> {\n    // Windows reserves several special device paths. Disallow opening any\n    // of them.\n    if let Some(stem) = path.file_stem() {\n        if let Some(stemstr) = stem.to_str() {\n            match stemstr.to_uppercase().as_str() {\n                \"CON\" | \"PRN\" | \"AUX\" | \"NUL\" | \"COM0\" | \"COM1\" | \"COM2\" | \"COM3\" | \"COM4\"\n                | \"COM5\" | \"COM6\" | \"COM7\" | \"COM8\" | \"COM9\" | \"LPT0\" | \"LPT1\" | \"LPT2\"\n                | \"LPT3\" | \"LPT4\" | \"LPT5\" | \"LPT6\" | \"LPT7\" | \"LPT8\" | \"LPT9\" => {\n                    return Err(io::Error::from_raw_os_error(ERROR_FILE_NOT_FOUND as i32));\n                }\n                _ => {}\n            }\n        }\n    }\n\n    manually::open(start, path, options)\n}", "item_id": 0, "repo": "sunshowers/cap-std", "file": "cap-primitives/src/windows/fs/open_impl.rs", "last_update_at": "2022-03-03T11:20:24+00:00"}
{"hexsha": "a41e7912c8c8749475376f5140e743c9fc01b9e8", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_FriendsGetFollowerCount_t() {\n\tassert_eq!(\n\t\t::std::mem::size_of::<FriendsGetFollowerCount_t>(),\n\t\t16usize,\n\t\tconcat!(\"Size of: \", stringify!(FriendsGetFollowerCount_t))\n\t);\n\tassert_eq!(\n\t\t::std::mem::align_of::<FriendsGetFollowerCount_t>(),\n\t\t4usize,\n\t\tconcat!(\"Alignment of \", stringify!(FriendsGetFollowerCount_t))\n\t);\n\tassert_eq!(\n\t\tunsafe {\n\t\t\t&(*(::std::ptr::null::<FriendsGetFollowerCount_t>())).m_eResult as *const _ as usize\n\t\t},\n\t\t0usize,\n\t\tconcat!(\n\t\t\t\"Offset of field: \",\n\t\t\tstringify!(FriendsGetFollowerCount_t),\n\t\t\t\"::\",\n\t\t\tstringify!(m_eResult)\n\t\t)\n\t);\n\tassert_eq!(\n\t\tunsafe {\n\t\t\t&(*(::std::ptr::null::<FriendsGetFollowerCount_t>())).m_steamID as *const _ as usize\n\t\t},\n\t\t4usize,\n\t\tconcat!(\n\t\t\t\"Offset of field: \",\n\t\t\tstringify!(FriendsGetFollowerCount_t),\n\t\t\t\"::\",\n\t\t\tstringify!(m_steamID)\n\t\t)\n\t);\n\tassert_eq!(\n\t\tunsafe {\n\t\t\t&(*(::std::ptr::null::<FriendsGetFollowerCount_t>())).m_nCount as *const _ as usize\n\t\t},\n\t\t12usize,\n\t\tconcat!(\n\t\t\t\"Offset of field: \",\n\t\t\tstringify!(FriendsGetFollowerCount_t),\n\t\t\t\"::\",\n\t\t\tstringify!(m_nCount)\n\t\t)\n\t);\n}", "item_id": 40, "repo": "JoshPiper/gmsv_workshop", "file": "steamworks-rs/steamworks-sys/src/bindings_win64.rs", "last_update_at": "2022-03-22T10:51:55+00:00"}
{"hexsha": "9cdfdc3dae4dc5096084630cd33cfe44e2e66635", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_operation_crate_operation_modify_replication_group(\n    input: &crate::input::ModifyReplicationGroupInput,\n) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {\n    let mut out = String::new();\n    #[allow(unused_mut)]\n    let mut writer =\n        aws_smithy_query::QueryWriter::new(&mut out, \"ModifyReplicationGroup\", \"2015-02-02\");\n    #[allow(unused_mut)]\n    let mut scope_667 = writer.prefix(\"ReplicationGroupId\");\n    if let Some(var_668) = &input.replication_group_id {\n        scope_667.string(var_668);\n    }\n    #[allow(unused_mut)]\n    let mut scope_669 = writer.prefix(\"ReplicationGroupDescription\");\n    if let Some(var_670) = &input.replication_group_description {\n        scope_669.string(var_670);\n    }\n    #[allow(unused_mut)]\n    let mut scope_671 = writer.prefix(\"PrimaryClusterId\");\n    if let Some(var_672) = &input.primary_cluster_id {\n        scope_671.string(var_672);\n    }\n    #[allow(unused_mut)]\n    let mut scope_673 = writer.prefix(\"SnapshottingClusterId\");\n    if let Some(var_674) = &input.snapshotting_cluster_id {\n        scope_673.string(var_674);\n    }\n    #[allow(unused_mut)]\n    let mut scope_675 = writer.prefix(\"AutomaticFailoverEnabled\");\n    if let Some(var_676) = &input.automatic_failover_enabled {\n        scope_675.boolean(*var_676);\n    }\n    #[allow(unused_mut)]\n    let mut scope_677 = writer.prefix(\"MultiAZEnabled\");\n    if let Some(var_678) = &input.multi_az_enabled {\n        scope_677.boolean(*var_678);\n    }\n    #[allow(unused_mut)]\n    let mut scope_679 = writer.prefix(\"NodeGroupId\");\n    if let Some(var_680) = &input.node_group_id {\n        scope_679.string(var_680);\n    }\n    #[allow(unused_mut)]\n    let mut scope_681 = writer.prefix(\"CacheSecurityGroupNames\");\n    if let Some(var_682) = &input.cache_security_group_names {\n        let mut list_684 = scope_681.start_list(false, Some(\"CacheSecurityGroupName\"));\n        for item_683 in var_682 {\n            #[allow(unused_mut)]\n            let mut entry_685 = list_684.entry();\n            entry_685.string(item_683);\n        }\n        list_684.finish();\n    }\n    #[allow(unused_mut)]\n    let mut scope_686 = writer.prefix(\"SecurityGroupIds\");\n    if let Some(var_687) = &input.security_group_ids {\n        let mut list_689 = scope_686.start_list(false, Some(\"SecurityGroupId\"));\n        for item_688 in var_687 {\n            #[allow(unused_mut)]\n            let mut entry_690 = list_689.entry();\n            entry_690.string(item_688);\n        }\n        list_689.finish();\n    }\n    #[allow(unused_mut)]\n    let mut scope_691 = writer.prefix(\"PreferredMaintenanceWindow\");\n    if let Some(var_692) = &input.preferred_maintenance_window {\n        scope_691.string(var_692);\n    }\n    #[allow(unused_mut)]\n    let mut scope_693 = writer.prefix(\"NotificationTopicArn\");\n    if let Some(var_694) = &input.notification_topic_arn {\n        scope_693.string(var_694);\n    }\n    #[allow(unused_mut)]\n    let mut scope_695 = writer.prefix(\"CacheParameterGroupName\");\n    if let Some(var_696) = &input.cache_parameter_group_name {\n        scope_695.string(var_696);\n    }\n    #[allow(unused_mut)]\n    let mut scope_697 = writer.prefix(\"NotificationTopicStatus\");\n    if let Some(var_698) = &input.notification_topic_status {\n        scope_697.string(var_698);\n    }\n    #[allow(unused_mut)]\n    let mut scope_699 = writer.prefix(\"ApplyImmediately\");\n    if input.apply_immediately {\n        scope_699.boolean(input.apply_immediately);\n    }\n    #[allow(unused_mut)]\n    let mut scope_700 = writer.prefix(\"EngineVersion\");\n    if let Some(var_701) = &input.engine_version {\n        scope_700.string(var_701);\n    }\n    #[allow(unused_mut)]\n    let mut scope_702 = writer.prefix(\"AutoMinorVersionUpgrade\");\n    if let Some(var_703) = &input.auto_minor_version_upgrade {\n        scope_702.boolean(*var_703);\n    }\n    #[allow(unused_mut)]\n    let mut scope_704 = writer.prefix(\"SnapshotRetentionLimit\");\n    if let Some(var_705) = &input.snapshot_retention_limit {\n        scope_704.number(\n            #[allow(clippy::useless_conversion)]\n            aws_smithy_types::Number::NegInt((*var_705).into()),\n        );\n    }\n    #[allow(unused_mut)]\n    let mut scope_706 = writer.prefix(\"SnapshotWindow\");\n    if let Some(var_707) = &input.snapshot_window {\n        scope_706.string(var_707);\n    }\n    #[allow(unused_mut)]\n    let mut scope_708 = writer.prefix(\"CacheNodeType\");\n    if let Some(var_709) = &input.cache_node_type {\n        scope_708.string(var_709);\n    }\n    #[allow(unused_mut)]\n    let mut scope_710 = writer.prefix(\"AuthToken\");\n    if let Some(var_711) = &input.auth_token {\n        scope_710.string(var_711);\n    }\n    #[allow(unused_mut)]\n    let mut scope_712 = writer.prefix(\"AuthTokenUpdateStrategy\");\n    if let Some(var_713) = &input.auth_token_update_strategy {\n        scope_712.string(var_713.as_str());\n    }\n    #[allow(unused_mut)]\n    let mut scope_714 = writer.prefix(\"UserGroupIdsToAdd\");\n    if let Some(var_715) = &input.user_group_ids_to_add {\n        let mut list_717 = scope_714.start_list(false, None);\n        for item_716 in var_715 {\n            #[allow(unused_mut)]\n            let mut entry_718 = list_717.entry();\n            entry_718.string(item_716);\n        }\n        list_717.finish();\n    }\n    #[allow(unused_mut)]\n    let mut scope_719 = writer.prefix(\"UserGroupIdsToRemove\");\n    if let Some(var_720) = &input.user_group_ids_to_remove {\n        let mut list_722 = scope_719.start_list(false, None);\n        for item_721 in var_720 {\n            #[allow(unused_mut)]\n            let mut entry_723 = list_722.entry();\n            entry_723.string(item_721);\n        }\n        list_722.finish();\n    }\n    #[allow(unused_mut)]\n    let mut scope_724 = writer.prefix(\"RemoveUserGroups\");\n    if let Some(var_725) = &input.remove_user_groups {\n        scope_724.boolean(*var_725);\n    }\n    #[allow(unused_mut)]\n    let mut scope_726 = writer.prefix(\"LogDeliveryConfigurations\");\n    if let Some(var_727) = &input.log_delivery_configurations {\n        let mut list_729 = scope_726.start_list(false, Some(\"LogDeliveryConfigurationRequest\"));\n        for item_728 in var_727 {\n            #[allow(unused_mut)]\n            let mut entry_730 = list_729.entry();\n            crate::query_ser::serialize_structure_crate_model_log_delivery_configuration_request(\n                entry_730, item_728,\n            )?;\n        }\n        list_729.finish();\n    }\n    writer.finish();\n    Ok(aws_smithy_http::body::SdkBody::from(out))\n}", "item_id": 53, "repo": "a-xp/aws-sdk-rust", "file": "sdk/elasticache/src/operation_ser.rs", "last_update_at": "2022-03-02T02:19:58+00:00"}
{"hexsha": "4142b600f42a69de56f5807db7b1b36af0bb13c2", "ext": "rs", "lang": "Rust", "content": "pub fn dominance_order<S>(a: &S, b: &S, objectives: &[Arc<dyn Objective<Solution = S> + Send + Sync>]) -> Ordering {\n    let mut less_cnt = 0;\n    let mut greater_cnt = 0;\n\n    for objective in objectives.iter() {\n        match objective.total_order(a, b) {\n            Ordering::Less => {\n                less_cnt += 1;\n            }\n            Ordering::Greater => {\n                greater_cnt += 1;\n            }\n            Ordering::Equal => {}\n        }\n    }\n\n    if less_cnt > 0 && greater_cnt == 0 {\n        Ordering::Less\n    } else if greater_cnt > 0 && less_cnt == 0 {\n        Ordering::Greater\n    } else {\n        debug_assert!((less_cnt > 0 && greater_cnt > 0) || (less_cnt == 0 && greater_cnt == 0));\n        Ordering::Equal\n    }\n}", "item_id": 2, "repo": "iedmrc/vrp", "file": "vrp-core/src/algorithms/nsga2/objective.rs", "last_update_at": "2022-03-22T17:43:15+00:00"}
{"hexsha": "bc201e4de741dfe810e53f5de7188f5170e41779", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout__opaque_pthread_t() {\n    assert_eq!(\n        ::std::mem::size_of::<_opaque_pthread_t>(),\n        8192usize,\n        concat!(\"Size of: \", stringify!(_opaque_pthread_t))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<_opaque_pthread_t>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(_opaque_pthread_t))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_opaque_pthread_t),\n            \"::\",\n            stringify!(__sig)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize\n        },\n        8usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_opaque_pthread_t),\n            \"::\",\n            stringify!(__cleanup_stack)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_opaque_pthread_t),\n            \"::\",\n            stringify!(__opaque)\n        )\n    );\n}", "item_id": 10, "repo": "chengyuhui/netstat2-rs", "file": "src/integrations/osx/ffi/libproc.rs", "last_update_at": "2022-01-05T12:09:25+00:00"}
{"hexsha": "9134b645ee85923bd63ade17cbdbd39ba6accc92", "ext": "rs", "lang": "Rust", "content": "fn test_gaussian_filter_2d() {\n    let a: Array1<f32> = (0..70).step_by(2).map(|v| v as f32).collect();\n    let mut a = a.into_shape((5, 7)).unwrap();\n    a[(0, 0)] = 17.0;\n    assert_relative_eq!(\n        gaussian_filter(&a, 1.0, 4.0),\n        arr2(&[\n            [13.815777, 11.339161, 10.62479, 12.028319, 13.970364, 15.842661, 17.12449],\n            [19.028267, 18.574514, 19.253122, 20.97248, 22.940516, 24.813597, 26.095427],\n            [29.490631, 30.42986, 32.06769, 34.004536, 35.990467, 37.864086, 39.14592],\n            [41.95432, 43.209373, 45.064693, 47.050846, 49.040836, 50.914577, 52.196407],\n            [50.876965, 52.158012, 54.031227, 56.02144, 58.01176, 59.885513, 61.167343],\n        ]),\n        epsilon = 1e-4\n    );\n    let a: Array1<f32> = (0..84).step_by(2).map(|v| v as f32).collect();\n    let mut a = a.into_shape((6, 7)).unwrap();\n    a[(0, 0)] = 8.5;\n    assert_relative_eq!(\n        gaussian_filter(&a, 1.0, 2.0),\n        arr2(&[\n            [10.078889, 9.458512, 10.006921, 11.707343, 13.707343, 15.598366, 16.892008],\n            [17.220367, 17.630152, 18.90118, 20.76284, 22.76284, 24.653864, 25.947506],\n            [29.114912, 30.247316, 32.025234, 34.000000, 36.000000, 37.89102, 39.184666],\n            [42.815334, 44.10898, 46.000000, 48.000000, 50.000000, 51.89102, 53.184666],\n            [56.052494, 57.346134, 59.23716, 61.23716, 63.23716, 65.12818, 66.42182],\n            [65.107994, 66.401634, 68.292656, 70.292656, 72.292656, 74.18368, 75.47732],\n        ]),\n        epsilon = 1e-4\n    );\n\n    let a: Array1<f32> = (0..112).step_by(2).map(|v| v as f32).collect();\n    let mut a = a.into_shape((8, 7)).unwrap();\n    a[(0, 0)] = 18.2;\n    assert_relative_eq!(\n        gaussian_filter(&a, 1.5, 3.5),\n        arr2(&[\n            [16.712738, 16.30507, 16.362633, 17.34964, 18.918924, 20.453388, 21.402458],\n            [22.053278, 22.092232, 22.654442, 23.931578, 25.60057, 27.156698, 28.1087],\n            [31.7295, 32.2731, 33.405533, 35.01049, 36.79215, 38.372753, 39.328068],\n            [44.08236, 44.91609, 46.376343, 48.169773, 50.0162, 51.61088, 52.5681],\n            [57.50711, 58.440548, 60.013466, 61.87167, 63.740356, 65.339874, 66.297745],\n            [70.68089, 71.636, 73.2334, 75.10567, 76.979195, 78.579765, 79.53778],\n            [81.8913, 82.849335, 84.45004, 86.32423, 88.1984, 89.79911, 90.75715],\n            [88.59754, 89.55557, 91.15629, 93.030464, 94.90464, 96.505356, 97.46339],\n        ]),\n        epsilon = 1e-4\n    );\n}", "item_id": 2, "repo": "imeka/ndarray-image", "file": "tests/filters.rs", "last_update_at": "2022-03-17T12:53:11+00:00"}
{"hexsha": "c6b197af804d779b6b66bba1817ff422da0f548b", "ext": "rs", "lang": "Rust", "content": "fn has_target_feature(\n    name: &str,\n    mut has_target_feature: bool,\n    version: &Version,\n    stabilized: Option<u32>,\n) -> bool {\n    // HACK: Currently, it seems that the only way that works on the stable is\n    // to parse the `-C target-feature` in RUSTFLAGS.\n    //\n    // - #[cfg(target_feature = \"unstable_target_feature\")] doesn't work on stable.\n    // - CARGO_CFG_TARGET_FEATURE excludes unstable features on stable.\n    //\n    // As mentioned in the [RFC2045], unstable target features are also passed to LLVM\n    // (e.g., https://godbolt.org/z/8Eh3z5Wzb), so this hack works properly on stable.\n    //\n    // [RFC2045]: https://rust-lang.github.io/rfcs/2045-target-feature.html#backend-compilation-options\n    if version.nightly || stabilized.map_or(false, |stabilized| version.minor >= stabilized) {\n        has_target_feature = env::var(\"CARGO_CFG_TARGET_FEATURE\")\n            .ok()\n            .map_or(false, |s| s.split(',').any(|s| s == name));\n    } else if let Some(rustflags) = env::var_os(\"CARGO_ENCODED_RUSTFLAGS\") {\n        for mut flag in rustflags.to_string_lossy().split('\\x1f') {\n            if flag.starts_with(\"-C\") {\n                flag = &flag[\"-C\".len()..];\n            }\n            if flag.starts_with(\"target-feature=\") {\n                flag = &flag[\"target-feature=\".len()..];\n                for s in flag.split(',').filter(|s| !s.is_empty()) {\n                    match (s.as_bytes()[0] as char, &s.as_bytes()[1..]) {\n                        ('+', f) if f == name.as_bytes() => has_target_feature = true,\n                        ('-', f) if f == name.as_bytes() => has_target_feature = false,\n                        _ => {}\n                    }\n                }\n            }\n        }\n    }\n    has_target_feature\n}", "item_id": 3, "repo": "taiki-e/portable-atomic", "file": "tests/no-std/build.rs", "last_update_at": "2022-03-25T18:27:06+00:00"}
{"hexsha": "a1137d3c18bd5e6e9b9df5ad207c11ddf07af8a8", "ext": "rs", "lang": "Rust", "content": "pub fn plugin_main<P: Plugin>(host_cb: HostCallbackProc, unique_id: &[u8; 4]) -> *mut AEffect {\n    let mut flags = effect_flags::CAN_REPLACING | effect_flags::PROGRAM_CHUNKS;\n\n    if WrappedPlugin::<P>::wants_midi_input() {\n        flags |= effect_flags::IS_SYNTH;\n    }\n\n    if VST2Adapter::<P>::has_ui() {\n        flags |= effect_flags::HAS_EDITOR;\n    }\n\n    let unique_id =\n          (unique_id[0] as u32) << 24\n        | (unique_id[1] as u32) << 16\n        | (unique_id[2] as u32) << 8\n        | (unique_id[3] as u32);\n    \n    let effect = AEffect {\n        magic: MAGIC,\n\n        dispatcher: dispatch::<P>,\n        process: process_deprecated,\n        set_parameter: set_parameter::<P>,\n        get_parameter: get_parameter::<P>,\n\n        num_programs: 0,\n        num_params: <P::Model as Model<P>>::Smooth::PARAMS.len() as i32,\n        num_inputs: P::INPUT_CHANNELS as i32,\n        num_outputs: P::OUTPUT_CHANNELS as i32,\n\n        flags,\n\n        ptr_1: ptr::null_mut(),\n        ptr_2: ptr::null_mut(),\n\n        initial_delay: 0,\n\n        empty_2: [0; 8],\n        unknown_float: 0.0,\n\n        object: ptr::null_mut(),\n        user: ptr::null_mut(),\n\n        unique_id: unique_id as i32,\n        version: 0,\n\n        process_replacing: process_replacing::<P>,\n        process_double_replacing: process_replacing_f64,\n    };\n    \n    let host_callback = VST2HostCallback {\n        effect: std::ptr::null_mut() as *mut AEffect,\n        host_cb,\n    };\n\n    let mut adapter = Box::new(VST2Adapter::<P> {\n        effect,\n\n        host_callback,\n\n        editor_rect: Rect {\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0,\n        },\n\n        wrapped: WrappedPlugin::new(),\n        state: None,\n\n        output_events_buffer: OutgoingEvents::new()\n    });\n\n    // Make sure we have the correct pointer to the effect.\n    let host_callback = VST2HostCallback {\n        effect: &mut adapter.effect as *mut AEffect,\n        host_cb,\n    };\n    adapter.host_callback = host_callback;\n\n    unsafe {\n        &mut ((*Box::into_raw(adapter)).effect)\n    }\n}", "item_id": 0, "repo": "DGriffin91/baseplug", "file": "src/api/vst2/abi.rs", "last_update_at": "2022-02-27T03:41:13+00:00"}
{"hexsha": "823d01796f1ad4950edc5cc8e24cb927b4afcbd8", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_operation_crate_operation_copy_image(\n    input: &crate::input::CopyImageInput,\n) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {\n    let mut out = String::new();\n    #[allow(unused_mut)]\n    let mut writer = aws_smithy_query::QueryWriter::new(&mut out, \"CopyImage\", \"2016-11-15\");\n    #[allow(unused_mut)]\n    let mut scope_407 = writer.prefix(\"ClientToken\");\n    if let Some(var_408) = &input.client_token {\n        scope_407.string(var_408);\n    }\n    #[allow(unused_mut)]\n    let mut scope_409 = writer.prefix(\"Description\");\n    if let Some(var_410) = &input.description {\n        scope_409.string(var_410);\n    }\n    #[allow(unused_mut)]\n    let mut scope_411 = writer.prefix(\"Encrypted\");\n    if let Some(var_412) = &input.encrypted {\n        scope_411.boolean(*var_412);\n    }\n    #[allow(unused_mut)]\n    let mut scope_413 = writer.prefix(\"KmsKeyId\");\n    if let Some(var_414) = &input.kms_key_id {\n        scope_413.string(var_414);\n    }\n    #[allow(unused_mut)]\n    let mut scope_415 = writer.prefix(\"Name\");\n    if let Some(var_416) = &input.name {\n        scope_415.string(var_416);\n    }\n    #[allow(unused_mut)]\n    let mut scope_417 = writer.prefix(\"SourceImageId\");\n    if let Some(var_418) = &input.source_image_id {\n        scope_417.string(var_418);\n    }\n    #[allow(unused_mut)]\n    let mut scope_419 = writer.prefix(\"SourceRegion\");\n    if let Some(var_420) = &input.source_region {\n        scope_419.string(var_420);\n    }\n    #[allow(unused_mut)]\n    let mut scope_421 = writer.prefix(\"DestinationOutpostArn\");\n    if let Some(var_422) = &input.destination_outpost_arn {\n        scope_421.string(var_422);\n    }\n    #[allow(unused_mut)]\n    let mut scope_423 = writer.prefix(\"DryRun\");\n    if let Some(var_424) = &input.dry_run {\n        scope_423.boolean(*var_424);\n    }\n    writer.finish();\n    Ok(aws_smithy_http::body::SdkBody::from(out))\n}", "item_id": 44, "repo": "a-xp/aws-sdk-rust", "file": "sdk/ec2/src/operation_ser.rs", "last_update_at": "2022-03-02T02:19:58+00:00"}
{"hexsha": "e670de2d08f3b83fd72dff6f44c4be4280c285b4", "ext": "rs", "lang": "Rust", "content": "async fn get_contracts() -> (\n    AuthContract,\n    ContractId,\n    AuthCallerContract,\n    ContractId,\n    Wallet,\n) {\n    let salt = Salt::from([0u8; 32]);\n    let (provider, wallet) = setup_test_provider_and_wallet().await;\n    let compiled_1 = Contract::load_sway_contract(\n        \"test_artifacts/auth_testing_contract/out/debug/auth_testing_contract.bin\",\n        salt,\n    )\n    .unwrap();\n    let compiled_2 = Contract::load_sway_contract(\n        \"test_artifacts/auth_caller_contract/out/debug/auth_caller_contract.bin\",\n        salt,\n    )\n    .unwrap();\n\n    let id_1 = Contract::deploy(&compiled_1, &provider, &wallet, TxParameters::default())\n        .await\n        .unwrap();\n    let id_2 = Contract::deploy(&compiled_2, &provider, &wallet, TxParameters::default())\n        .await\n        .unwrap();\n\n    let instance_1 = AuthContract::new(id_1.to_string(), provider.clone(), wallet.clone());\n    let instance_2 = AuthCallerContract::new(id_2.to_string(), provider.clone(), wallet.clone());\n\n    (instance_1, id_1, instance_2, id_2, wallet)\n}", "item_id": 3, "repo": "FuelLabs/sway-lib-std", "file": "tests/test_projects/auth/mod.rs", "last_update_at": "2022-02-26T03:45:41+00:00"}
{"hexsha": "511a11219c3a9bfee342d25c620cc7c91c43683c", "ext": "rs", "lang": "Rust", "content": "fn build_closure_expression(\n    mut symbols: &mut Vec<Symbol>,\n    mut syntax_tree: &mut SyntaxTree,\n    symbol: Symbol,\n) -> Result<ExpressionNode, Error> {\n    match symbol {\n        Symbol::ClosureParamsOpen => {}\n        symbol => todo!(\"Unexpected symbol: {:?}\\n\\n{:?}\", symbol, syntax_tree),\n    }\n\n    let symbol = symbols.pop().expect(\"Unfinished closure!\");\n\n    let mut params = match symbol {\n        Symbol::FunctionParamsParamName(_) => vec![build_closure_param_node(\n            &mut symbols,\n            &mut syntax_tree,\n            symbol,\n        )?],\n        Symbol::ClosureParamsClose => vec![],\n        symbol => todo!(\"Unexpected symbol: {:?}\\n\\n{:?}\", symbol, syntax_tree),\n    };\n\n    if params.len() > 0 {\n        loop {\n            let symbol = symbols.pop().expect(\"Unfinished closure!\");\n\n            match symbol {\n                Symbol::ClosureParamsComma => {\n                    let symbol = symbols.pop().expect(\"Unfinished closure!\");\n\n                    params.push(build_closure_param_node(\n                        &mut symbols,\n                        &mut syntax_tree,\n                        symbol,\n                    )?);\n                }\n                Symbol::ClosureParamsClose => {\n                    break;\n                }\n                symbol => todo!(\"Unexpected symbol: {:?}\\n\\n{:?}\", symbol, syntax_tree),\n            }\n        }\n    }\n\n    let return_type = match symbols.last().expect(\"Unfinished closure!\") {\n        Symbol::FunctionReturnTypeColon => {\n            symbols.pop();\n\n            let symbol = symbols.pop().expect(\"Unfinished closure!\");\n\n            Some(build_type_node(&mut symbols, &mut syntax_tree, symbol)?)\n        }\n        _ => None,\n    };\n\n    let signature = ClosureSignatureNode {\n        params,\n        return_type,\n    };\n\n    match symbols.pop().expect(\"Unfinished closure!\") {\n        Symbol::ClosureArrow => {}\n        symbol => todo!(\"Unexpected symbol: {:?}\\n\\n{:?}\", symbol, syntax_tree),\n    }\n\n    let mut statements = match symbols.last().expect(\"Unfinished closure!\") {\n        Symbol::FunctionExpressionsOpenBrace => {\n            symbols.pop();\n            vec![]\n        }\n        _ => {\n            let symbol = symbols.pop().expect(\"Unfinished closure!\");\n            vec![StatementNode::Expression(build_expression_node(\n                &mut symbols,\n                &mut syntax_tree,\n                symbol,\n            )?)]\n        }\n    };\n\n    if statements.len() == 0 {\n        loop {\n            let symbol = symbols.pop().expect(\"Unfinished function!\");\n\n            match symbol {\n                Symbol::FunctionExpressionsCloseBrace => {\n                    break;\n                }\n                symbol => statements.push(build_statement_node(\n                    &mut symbols,\n                    &mut syntax_tree,\n                    symbol,\n                )?),\n            }\n        }\n    }\n\n    let body = FunctionBodyNode { statements };\n\n    return Ok(ExpressionNode::Closure(ClosureExpressionNode {\n        signature,\n        body,\n    }));\n}", "item_id": 5, "repo": "ferrum-lang/ferrum", "file": "src/compiler/parser/mod.rs", "last_update_at": "2022-02-17T20:00:39+00:00"}
{"hexsha": "2add226a65dc233e101f8feeabc98631aa02828b", "ext": "rs", "lang": "Rust", "content": "fn test_bert_tokenizer_no_lower_casing() {\n        //        Given\n        let vocab = generate_test_vocab();\n        let bert_tokenizer: BertTokenizer = BertTokenizer::from_existing_vocab(vocab, false, false);\n        let test_tuples = [\n            (\"Hello [MASK] world!\", vec![\"[UNK]\", \"[MASK]\", \"world\", \"!\"]),\n            (\n                \"Hello, unaffable world!\",\n                vec![\"[UNK]\", \"[UNK]\", \"una\", \"##ffa\", \"##ble\", \"world\", \"!\"],\n            ),\n            (\n                \"[UNK]\u4e2d\u534e\u4eba\u6c11\u5171\u548c\u56fd [PAD] asdf\",\n                vec![\n                    \"[UNK]\", \"\u4e2d\", \"\u534e\", \"\u4eba\", \"[UNK]\", \"[UNK]\", \"[UNK]\", \"[UNK]\", \"[PAD]\", \"[UNK]\",\n                ],\n            ),\n        ];\n        let source_texts: Vec<&str> = test_tuples.iter().map(|v| v.0).collect();\n        let expected_results: Vec<Vec<&str>> = test_tuples.iter().map(|v| v.1.clone()).collect();\n\n        //        When & Then\n        for (source_text, expected_result) in test_tuples.iter() {\n            assert_eq!(bert_tokenizer.tokenize(*source_text), *expected_result);\n        }\n\n        assert_eq!(\n            Tokenizer::tokenize_list(&bert_tokenizer, &source_texts),\n            expected_results\n        );\n        assert_eq!(\n            MultiThreadedTokenizer::tokenize_list(&bert_tokenizer, &source_texts),\n            expected_results\n        );\n    }", "item_id": 2, "repo": "eonm-abes/rust-tokenizers", "file": "main/src/tokenizer/bert_tokenizer.rs", "last_update_at": "2022-03-02T08:41:12+00:00"}
{"hexsha": "fda6fb51772f6ea99e2e49db4275566c2d580a25", "ext": "rs", "lang": "Rust", "content": "fn test_calculate_amounts_from_balances_virtual_balancing_transaction() {\n        let mut transactions = parse_transactions(\n            r#\"\n2018-10-01 Marek Ogarek\n  TEST:ABC     $1.20\n  TEST:DEF\n\n2018-10-01 Marek Ogarek\n  [TEST:ABC]         = $1.20\n\"#,\n        );\n        let expected_transactions = parse_transactions(\n            r#\"\n2018-10-01 Marek Ogarek\n  TEST:ABC     $1.20\n  TEST:DEF    $-1.20\n\n2018-10-01 Marek Ogarek\n  [TEST:ABC]   $0.00\n\"#,\n        );\n        assert_eq!(\n            calculate_amounts_from_balances(&mut transactions, &mut Vec::new()),\n            Ok(())\n        );\n        assert_eq!(transactions, expected_transactions);\n    }", "item_id": 23, "repo": "marek-g/rust-ledger-utils", "file": "src/calculate_amounts.rs", "last_update_at": "2022-02-19T18:15:14+00:00"}
{"hexsha": "4c84db8b6b41fc6cd5d6f54ad130d3363987b677", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_structure_crate_model_auto_ml_security_config(\n    object: &mut aws_smithy_json::serialize::JsonObjectWriter,\n    input: &crate::model::AutoMlSecurityConfig,\n) -> Result<(), aws_smithy_http::operation::SerializationError> {\n    if let Some(var_2009) = &input.volume_kms_key_id {\n        object.key(\"VolumeKmsKeyId\").string(var_2009);\n    }\n    if input.enable_inter_container_traffic_encryption {\n        object\n            .key(\"EnableInterContainerTrafficEncryption\")\n            .boolean(input.enable_inter_container_traffic_encryption);\n    }\n    if let Some(var_2010) = &input.vpc_config {\n        let mut object_2011 = object.key(\"VpcConfig\").start_object();\n        crate::json_ser::serialize_structure_crate_model_vpc_config(&mut object_2011, var_2010)?;\n        object_2011.finish();\n    }\n    Ok(())\n}", "item_id": 251, "repo": "a-xp/aws-sdk-rust", "file": "sdk/sagemaker/src/json_ser.rs", "last_update_at": "2022-03-02T02:19:58+00:00"}
{"hexsha": "d2aab05ce06d795f75cb1111540483ce28b0f166", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_bdfprops() {\n    assert_eq!(\n        ::std::mem::size_of::<bdfprops>(),\n        24usize,\n        concat!(\"Size of: \", stringify!(bdfprops))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<bdfprops>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(bdfprops))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<bdfprops>())).name as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(bdfprops),\n            \"::\",\n            stringify!(name)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<bdfprops>())).type_ as *const _ as usize },\n        8usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(bdfprops),\n            \"::\",\n            stringify!(type_)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<bdfprops>())).u as *const _ as usize },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(bdfprops),\n            \"::\",\n            stringify!(u)\n        )\n    );\n}", "item_id": 122, "repo": "mfeq/Qstroke", "file": "fontforge-sys/src/lib.rs", "last_update_at": "2022-02-09T06:16:05+00:00"}
{"hexsha": "a1d42519f4c63b218250cf7687a8c47f28ca2ec4", "ext": "rs", "lang": "Rust", "content": "unsafe fn find_unused_key_code(\n    display: *mut ffi::Display,\n    min_keycode: ffi::KeyCode,\n    max_keycode: ffi::KeyCode,\n) -> Result<ffi::KeyCode, Error> {\n\n    // Get the full mapping from keycodes to keysyms. There may be\n    // multiple keysyms for each keycode depending on which modifiers\n    // are pressed. We need this for finding an unused keycode, that is\n    // a keycode without any associated keysyms.\n    let keycode_count = (max_keycode - min_keycode) + 1;\n    let mut keysyms_per_keycode = 0;\n    let keysyms = ffi::XGetKeyboardMapping(\n        display,\n        min_keycode,\n        keycode_count as std::os::raw::c_int,\n        &mut keysyms_per_keycode,\n    );\n    if keysyms.is_null() {\n        return Err(Error::Platform(PlatformError::XGetKeyboardMapping));\n    }\n    let keysyms_per_keycode = keysyms_per_keycode as usize;\n\n    // Find a keycode that has no keysyms associated with it. This keycode will\n    // be used for remapping for the purpose of producing characters that aren't\n    // on the default keyboard layout.\n    for code_idx in 0..keycode_count {\n        let sym_idx = code_idx as usize * keysyms_per_keycode;\n        let slice = std::slice::from_raw_parts(\n            keysyms.add(sym_idx), keysyms_per_keycode\n        );\n        if slice.iter().all(|keysym| *keysym == ffi::NoSymbol) {\n            ffi::XFree(keysyms);\n            return Ok(code_idx + min_keycode);\n        }\n    }\n\n    ffi::XFree(keysyms);\n    Err(Error::Platform(PlatformError::NoUnusedKeyCode))\n}", "item_id": 1, "repo": "Byron/The-Fat-Controller", "file": "src/linux_x11/mod.rs", "last_update_at": "2022-03-25T10:40:47+00:00"}
{"hexsha": "b632d76ef380755c4eeba82137bfa4cdca87282c", "ext": "rs", "lang": "Rust", "content": "fn connect_initiation_uses_biased_codec_negotiation_by_peer() {\n        let (mut exec, mut peers, _stream, sbc_codec, _aac_codec) = setup_negotiation_test();\n        let id = PeerId(1);\n        let (remote, channel) = Channel::create();\n\n        // System biases towards the Source direction (called when the AudioMode FIDL changes).\n        peers.set_preferred_direction(avdtp::EndpointType::Source);\n\n        // New fake peer discovered with some descriptor - the peer's SDP entry shows Sink.\n        let remote = avdtp::Peer::new(remote);\n        let desc = ProfileDescriptor {\n            profile_id: ServiceClassProfileIdentifier::AdvancedAudioDistribution,\n            major_version: 1,\n            minor_version: 2,\n        };\n        let preferred_direction = vec![avdtp::EndpointType::Sink];\n        let delay = zx::Duration::from_seconds(1);\n        peers.found(id, desc, HashSet::from_iter(preferred_direction.into_iter()));\n\n        let _ = peers.connected(id, channel, Some(delay)).expect(\"connect control channel is ok\");\n        // run the start task until it's stalled.\n        let _ = exec.run_until_stalled(&mut futures::future::pending::<()>());\n\n        let mut remote_requests = remote.take_request_stream();\n\n        // Should wait for the specified amount of time.\n        assert!(exec.run_until_stalled(&mut remote_requests.next()).is_pending());\n\n        exec.set_fake_time(fasync::Time::after(delay + zx::Duration::from_micros(1)));\n        let _ = exec.wake_expired_timers();\n\n        let _ = exec.run_until_stalled(&mut futures::future::pending::<()>());\n        // Even though the peer supports both SBC Sink and Source, we expect to negotiate and start\n        // on the Sink endpoint since that is the peer's preferred one.\n        let (peer_sbc_source_seid, peer_sbc_source_endpoint) = sbc_source_endpoint();\n        let (peer_sbc_sink_seid, peer_sbc_sink_endpoint) = sbc_sink_endpoint();\n        expect_peer_discovery(\n            &mut exec,\n            &mut remote_requests,\n            vec![peer_sbc_source_endpoint, peer_sbc_sink_endpoint],\n        );\n        for _twice in 1..=2 {\n            match exec.run_until_stalled(&mut remote_requests.next()) {\n                Poll::Ready(Some(Ok(avdtp::Request::GetCapabilities { stream_id, responder }))) => {\n                    let codec = match stream_id {\n                        id if id == peer_sbc_source_seid => sbc_codec.clone(),\n                        id if id == peer_sbc_sink_seid => sbc_codec.clone(),\n                        x => panic!(\"Got unexpected get_capabilities seid {:?}\", x),\n                    };\n                    responder\n                        .send(&vec![avdtp::ServiceCapability::MediaTransport, codec])\n                        .expect(\"respond succeeds\");\n                }\n                x => panic!(\"Expected a ready get capabilities request, got {:?}\", x),\n            };\n        }\n\n        match exec.run_until_stalled(&mut remote_requests.next()) {\n            Poll::Ready(Some(Ok(avdtp::Request::SetConfiguration {\n                local_stream_id,\n                remote_stream_id,\n                capabilities: _,\n                responder,\n            }))) => {\n                // We expect the set configuration to apply to the remote peer's Sink SEID and the\n                // local Source SEID.\n                assert_eq!(peer_sbc_sink_seid, local_stream_id);\n                let local_sbc_source_seid: avdtp::StreamEndpointId =\n                    SBC_SOURCE_SEID.try_into().unwrap();\n                assert_eq!(local_sbc_source_seid, remote_stream_id);\n                responder.send().expect(\"response sends\");\n            }\n            x => panic!(\"Expected a ready set configuration request, got {:?}\", x),\n        };\n    }", "item_id": 13, "repo": "allansrc/fuchsia", "file": "src/connectivity/bluetooth/lib/bt-a2dp/src/connected_peers.rs", "last_update_at": "2022-01-21T20:14:17+00:00"}
{"hexsha": "58855566eae511b01b128211127672883dd1eba8", "ext": "rs", "lang": "Rust", "content": "fn huffman_decode<R: Read>(\r\n    reader: &mut BitReader<R, BigEndian>,\r\n    huffman_table: &HuffmanTable,\r\n    state: &mut HuffmanState,\r\n) -> Result<usize, Error> {\r\n    let mut point = 0;\r\n    let mut bits_left = 32;\r\n    let mut bits_read = 0;\r\n    if !huffman_table.data.is_empty() {\r\n        loop {\r\n            if huffman_table.data[point] & 0xff00 == 0 {\r\n                state.x = ((huffman_table.data[point] >> 4) & 0xf).into();\r\n                state.y = (huffman_table.data[point] & 0xf).into();\r\n                break;\r\n            }\r\n\r\n            bits_read += 1;\r\n            if reader.read_bit()? {\r\n                while (huffman_table.data[point] & 0xff) >= 250 {\r\n                    point += (huffman_table.data[point] & 0xff) as usize;\r\n                }\r\n                point += (huffman_table.data[point] & 0xff) as usize;\r\n            } else {\r\n                while (huffman_table.data[point] >> 8) >= 250 {\r\n                    point += (huffman_table.data[point] >> 8) as usize;\r\n                }\r\n                point += (huffman_table.data[point] >> 8) as usize;\r\n            }\r\n\r\n            bits_left -= 1;\r\n            if bits_left <= 0 || point >= huffman_table.data.len() {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if huffman_table.quads {\r\n            state.v = (state.y >> 3) & 1;\r\n            state.w = (state.y >> 2) & 1;\r\n            state.x = (state.y >> 1) & 1;\r\n            state.y &= 1;\r\n\r\n            if state.v > 0 {\r\n                bits_read += 1;\r\n                if reader.read_bit()? {\r\n                    state.v = -state.v;\r\n                }\r\n            }\r\n            if state.w > 0 {\r\n                bits_read += 1;\r\n                if reader.read_bit()? {\r\n                    state.w = -state.w;\r\n                }\r\n            }\r\n            if state.x > 0 {\r\n                bits_read += 1;\r\n                if reader.read_bit()? {\r\n                    state.x = -state.x;\r\n                }\r\n            }\r\n            if state.y > 0 {\r\n                bits_read += 1;\r\n                if reader.read_bit()? {\r\n                    state.y = -state.y;\r\n                }\r\n            }\r\n        } else {\r\n            if huffman_table.linbits > 0 && state.x == 15 {\r\n                bits_read += huffman_table.linbits;\r\n                // TODO(Herschel): u32?\r\n                state.x += reader.read::<u32>(huffman_table.linbits as u32)? as i32;\r\n            }\r\n\r\n            if state.x > 0 {\r\n                bits_read += 1;\r\n                if reader.read_bit()? {\r\n                    state.x = -state.x;\r\n                }\r\n            }\r\n\r\n            if huffman_table.linbits > 0 && state.y == 15 {\r\n                bits_read += huffman_table.linbits;\r\n                state.y += reader.read::<u32>(huffman_table.linbits as u32)? as i32;\r\n            }\r\n\r\n            if state.y > 0 {\r\n                bits_read += 1;\r\n                if reader.read_bit()? {\r\n                    state.y = -state.y;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        *state = Default::default();\r\n    }\r\n    Ok(bits_read)\r\n}", "item_id": 1, "repo": "gentoid/puremp3", "file": "src/huffman.rs", "last_update_at": "2022-03-13T19:34:00+00:00"}
{"hexsha": "11ce203089b093a0fe111d1b15cd09e8bfe5ad3e", "ext": "rs", "lang": "Rust", "content": "pub fn init(header: &'static mut VirtIOHeader) {\n    let event_buf = Box::leak(Box::new([0u64; 32]));\n    let input = VirtIOInput::new(header, event_buf).expect(\"failed to create input driver\");\n\n    let driver = Arc::new(VirtIOInputDriver(Mutex::new(input)));\n    IRQ_MANAGER.write().register_all(driver.clone());\n    DRIVERS.write().push(driver);\n}", "item_id": 0, "repo": "WenhaoKong2001/rCore", "file": "kernel/src/drivers/input/virtio_input.rs", "last_update_at": "2022-03-31T15:56:40+00:00"}
{"hexsha": "919fffee936f4bc984f9df49b0eb53e0d2b00a7e", "ext": "rs", "lang": "Rust", "content": "fn size_hint() {\n\t\tlet mut coord = Coordinates::new(Region::from(0, 0, 2, 2));\n\n\t\tassert_eq!(4, coord.size_hint().0);\n\t\tcoord.next().unwrap();\n\t\tassert_eq!(3, coord.size_hint().0);\n\t\tcoord.next().unwrap();\n\t\tassert_eq!(2, coord.size_hint().0);\n\t\tcoord.next().unwrap();\n\t\tassert_eq!(1, coord.size_hint().0);\n\t\tcoord.next().unwrap();\n\t\tassert_eq!(0, coord.size_hint().0);\n\t}", "item_id": 0, "repo": "meh/rust-picto", "file": "src/iter/coordinates.rs", "last_update_at": "2022-02-24T13:10:48+00:00"}
{"hexsha": "276674de8f0bf6670a1a8b1aa87c6f32589ca474", "ext": "rs", "lang": "Rust", "content": "unsafe fn column_butterfly4(rows: [Self; 4], rotation: Rotation90<Self>) -> [Self; 4] {\n        // Algorithm: 2x2 mixed radix\n\n        // Perform the first set of size-2 FFTs.\n        let [mid0, mid2] = Self::column_butterfly2([rows[0], rows[2]]);\n        let [mid1, mid3] = Self::column_butterfly2([rows[1], rows[3]]);\n\n        // Apply twiddle factors (in this case just a rotation)\n        let mid3_rotated = mid3.rotate90(rotation);\n\n        // Transpose the data and do size-2 FFTs down the columns\n        let [output0, output1] = Self::column_butterfly2([mid0, mid1]);\n        let [output2, output3] = Self::column_butterfly2([mid2, mid3_rotated]);\n\n        // Swap outputs 1 and 2 in the output to do a square transpose\n        [output0, output2, output1, output3]\n    }", "item_id": 3, "repo": "ejmahler/RustFFT", "file": "src/avx/avx_vector.rs", "last_update_at": "2022-03-31T17:43:32+00:00"}
{"hexsha": "d10d475b1655a45a2b954d59652a0646e298eae7", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_structure_crate_model_rule_definition(\n    object: &mut aws_smithy_json::serialize::JsonObjectWriter,\n    input: &crate::model::RuleDefinition,\n) -> Result<(), aws_smithy_http::operation::SerializationError> {\n    if let Some(var_244) = &input.match_attributes {\n        let mut object_245 = object.key(\"MatchAttributes\").start_object();\n        crate::json_ser::serialize_structure_crate_model_match_attributes(\n            &mut object_245,\n            var_244,\n        )?;\n        object_245.finish();\n    }\n    if let Some(var_246) = &input.actions {\n        let mut array_247 = object.key(\"Actions\").start_array();\n        for item_248 in var_246 {\n            {\n                array_247.value().string(item_248);\n            }\n        }\n        array_247.finish();\n    }\n    Ok(())\n}", "item_id": 43, "repo": "ymwjbxxq/aws-sdk-rust", "file": "sdk/networkfirewall/src/json_ser.rs", "last_update_at": "2022-03-31T20:47:15+00:00"}
{"hexsha": "c9b11a0633a5a45923854be3614c69ebbf16afb9", "ext": "rs", "lang": "Rust", "content": "pub async fn get_entries(client: &Client, id: Uuid) -> Result<Vec<Entry>, Error> {\n    let mut url = Url::parse(\"https://splits.io/api/v4/races\").unwrap();\n    url.path_segments_mut().unwrap().extend(&[\n        id.to_hyphenated().encode_lower(&mut Uuid::encode_buffer()),\n        \"entries\",\n    ]);\n\n    let ContainsEntries { entries } = get_json(\n        client,\n        Request::get(url.as_str()).body(Body::empty()).unwrap(),\n    )\n    .await?;\n\n    Ok(entries)\n}", "item_id": 2, "repo": "LiveSplit/splits-io-api", "file": "src/race.rs", "last_update_at": "2022-03-30T22:29:51+00:00"}
{"hexsha": "8ad7974280f098044fedb63f95afe1b6be71ef86", "ext": "rs", "lang": "Rust", "content": "async fn prune_date64() {\n    // work around for not being able to cast Date32 to Date64 automatically\n    let date = \"2020-01-02\"\n        .parse::<chrono::NaiveDate>()\n        .unwrap()\n        .and_time(chrono::NaiveTime::from_hms(0, 0, 0));\n    let date = ScalarValue::Date64(Some(date.timestamp_millis()));\n\n    let output = ContextWithParquet::new(Scenario::Dates)\n        .await\n        .query_with_expr(col(\"date64\").lt(lit(date)))\n        // .query(\n        //     \"SELECT * FROM t where date64 < caste('2020-01-02' as date)\",\n        // query results in Plan(\"'Date64 < Date32' can't be evaluated because there isn't a common type to coerce the types to\")\n        // )\n        .await;\n\n    println!(\"{}\", output.description());\n    // This should prune out groups  without error\n    assert_eq!(output.predicate_evaluation_errors(), Some(0));\n    assert_eq!(output.row_groups_pruned(), Some(3));\n    assert_eq!(output.result_rows, 1, \"{}\", output.description());\n}", "item_id": 5, "repo": "McPatate/tensorbase", "file": "crates/datafusion/tests/parquet_pruning.rs", "last_update_at": "2022-03-31T14:54:44+00:00"}
{"hexsha": "b427f5acc2095b74427d52bdb7f6e9c423048f00", "ext": "rs", "lang": "Rust", "content": "pub fn derive_elm_json(input: TokenStream) -> TokenStream {\n    let derive_input = parse_macro_input!(input as DeriveInput);\n    let intermediate = match super::derive_input_to_intermediate(derive_input) {\n        Ok(intermediate) => intermediate,\n        Err(err) => return err.to_compile_error().into(),\n    };\n    let token_stream = match intermediate_to_token_stream(intermediate) {\n        Ok(token_stream) => token_stream,\n        Err(err) => return err.to_compile_error().into(),\n    };\n    TokenStream::from(token_stream)\n}", "item_id": 0, "repo": "Heliozoa/jalava", "file": "jalava-derive/src/json.rs", "last_update_at": "2022-01-23T04:19:45+00:00"}
{"hexsha": "f8edc3625e0ab079ee306a10a74bde260643695c", "ext": "rs", "lang": "Rust", "content": "fn number_of_digits_decimal_left_shift(d: &Decimal, mut shift: usize) -> usize {\n    #[rustfmt::skip]\n    const TABLE: [u16; 65] = [\n        0x0000, 0x0800, 0x0801, 0x0803, 0x1006, 0x1009, 0x100D, 0x1812, 0x1817, 0x181D, 0x2024,\n        0x202B, 0x2033, 0x203C, 0x2846, 0x2850, 0x285B, 0x3067, 0x3073, 0x3080, 0x388E, 0x389C,\n        0x38AB, 0x38BB, 0x40CC, 0x40DD, 0x40EF, 0x4902, 0x4915, 0x4929, 0x513E, 0x5153, 0x5169,\n        0x5180, 0x5998, 0x59B0, 0x59C9, 0x61E3, 0x61FD, 0x6218, 0x6A34, 0x6A50, 0x6A6D, 0x6A8B,\n        0x72AA, 0x72C9, 0x72E9, 0x7B0A, 0x7B2B, 0x7B4D, 0x8370, 0x8393, 0x83B7, 0x83DC, 0x8C02,\n        0x8C28, 0x8C4F, 0x9477, 0x949F, 0x94C8, 0x9CF2, 0x051C, 0x051C, 0x051C, 0x051C,\n    ];\n    #[rustfmt::skip]\n    const TABLE_POW5: [u8; 0x051C] = [\n        5, 2, 5, 1, 2, 5, 6, 2, 5, 3, 1, 2, 5, 1, 5, 6, 2, 5, 7, 8, 1, 2, 5, 3, 9, 0, 6, 2, 5, 1,\n        9, 5, 3, 1, 2, 5, 9, 7, 6, 5, 6, 2, 5, 4, 8, 8, 2, 8, 1, 2, 5, 2, 4, 4, 1, 4, 0, 6, 2, 5,\n        1, 2, 2, 0, 7, 0, 3, 1, 2, 5, 6, 1, 0, 3, 5, 1, 5, 6, 2, 5, 3, 0, 5, 1, 7, 5, 7, 8, 1, 2,\n        5, 1, 5, 2, 5, 8, 7, 8, 9, 0, 6, 2, 5, 7, 6, 2, 9, 3, 9, 4, 5, 3, 1, 2, 5, 3, 8, 1, 4, 6,\n        9, 7, 2, 6, 5, 6, 2, 5, 1, 9, 0, 7, 3, 4, 8, 6, 3, 2, 8, 1, 2, 5, 9, 5, 3, 6, 7, 4, 3, 1,\n        6, 4, 0, 6, 2, 5, 4, 7, 6, 8, 3, 7, 1, 5, 8, 2, 0, 3, 1, 2, 5, 2, 3, 8, 4, 1, 8, 5, 7, 9,\n        1, 0, 1, 5, 6, 2, 5, 1, 1, 9, 2, 0, 9, 2, 8, 9, 5, 5, 0, 7, 8, 1, 2, 5, 5, 9, 6, 0, 4, 6,\n        4, 4, 7, 7, 5, 3, 9, 0, 6, 2, 5, 2, 9, 8, 0, 2, 3, 2, 2, 3, 8, 7, 6, 9, 5, 3, 1, 2, 5, 1,\n        4, 9, 0, 1, 1, 6, 1, 1, 9, 3, 8, 4, 7, 6, 5, 6, 2, 5, 7, 4, 5, 0, 5, 8, 0, 5, 9, 6, 9, 2,\n        3, 8, 2, 8, 1, 2, 5, 3, 7, 2, 5, 2, 9, 0, 2, 9, 8, 4, 6, 1, 9, 1, 4, 0, 6, 2, 5, 1, 8, 6,\n        2, 6, 4, 5, 1, 4, 9, 2, 3, 0, 9, 5, 7, 0, 3, 1, 2, 5, 9, 3, 1, 3, 2, 2, 5, 7, 4, 6, 1, 5,\n        4, 7, 8, 5, 1, 5, 6, 2, 5, 4, 6, 5, 6, 6, 1, 2, 8, 7, 3, 0, 7, 7, 3, 9, 2, 5, 7, 8, 1, 2,\n        5, 2, 3, 2, 8, 3, 0, 6, 4, 3, 6, 5, 3, 8, 6, 9, 6, 2, 8, 9, 0, 6, 2, 5, 1, 1, 6, 4, 1, 5,\n        3, 2, 1, 8, 2, 6, 9, 3, 4, 8, 1, 4, 4, 5, 3, 1, 2, 5, 5, 8, 2, 0, 7, 6, 6, 0, 9, 1, 3, 4,\n        6, 7, 4, 0, 7, 2, 2, 6, 5, 6, 2, 5, 2, 9, 1, 0, 3, 8, 3, 0, 4, 5, 6, 7, 3, 3, 7, 0, 3, 6,\n        1, 3, 2, 8, 1, 2, 5, 1, 4, 5, 5, 1, 9, 1, 5, 2, 2, 8, 3, 6, 6, 8, 5, 1, 8, 0, 6, 6, 4, 0,\n        6, 2, 5, 7, 2, 7, 5, 9, 5, 7, 6, 1, 4, 1, 8, 3, 4, 2, 5, 9, 0, 3, 3, 2, 0, 3, 1, 2, 5, 3,\n        6, 3, 7, 9, 7, 8, 8, 0, 7, 0, 9, 1, 7, 1, 2, 9, 5, 1, 6, 6, 0, 1, 5, 6, 2, 5, 1, 8, 1, 8,\n        9, 8, 9, 4, 0, 3, 5, 4, 5, 8, 5, 6, 4, 7, 5, 8, 3, 0, 0, 7, 8, 1, 2, 5, 9, 0, 9, 4, 9, 4,\n        7, 0, 1, 7, 7, 2, 9, 2, 8, 2, 3, 7, 9, 1, 5, 0, 3, 9, 0, 6, 2, 5, 4, 5, 4, 7, 4, 7, 3, 5,\n        0, 8, 8, 6, 4, 6, 4, 1, 1, 8, 9, 5, 7, 5, 1, 9, 5, 3, 1, 2, 5, 2, 2, 7, 3, 7, 3, 6, 7, 5,\n        4, 4, 3, 2, 3, 2, 0, 5, 9, 4, 7, 8, 7, 5, 9, 7, 6, 5, 6, 2, 5, 1, 1, 3, 6, 8, 6, 8, 3, 7,\n        7, 2, 1, 6, 1, 6, 0, 2, 9, 7, 3, 9, 3, 7, 9, 8, 8, 2, 8, 1, 2, 5, 5, 6, 8, 4, 3, 4, 1, 8,\n        8, 6, 0, 8, 0, 8, 0, 1, 4, 8, 6, 9, 6, 8, 9, 9, 4, 1, 4, 0, 6, 2, 5, 2, 8, 4, 2, 1, 7, 0,\n        9, 4, 3, 0, 4, 0, 4, 0, 0, 7, 4, 3, 4, 8, 4, 4, 9, 7, 0, 7, 0, 3, 1, 2, 5, 1, 4, 2, 1, 0,\n        8, 5, 4, 7, 1, 5, 2, 0, 2, 0, 0, 3, 7, 1, 7, 4, 2, 2, 4, 8, 5, 3, 5, 1, 5, 6, 2, 5, 7, 1,\n        0, 5, 4, 2, 7, 3, 5, 7, 6, 0, 1, 0, 0, 1, 8, 5, 8, 7, 1, 1, 2, 4, 2, 6, 7, 5, 7, 8, 1, 2,\n        5, 3, 5, 5, 2, 7, 1, 3, 6, 7, 8, 8, 0, 0, 5, 0, 0, 9, 2, 9, 3, 5, 5, 6, 2, 1, 3, 3, 7, 8,\n        9, 0, 6, 2, 5, 1, 7, 7, 6, 3, 5, 6, 8, 3, 9, 4, 0, 0, 2, 5, 0, 4, 6, 4, 6, 7, 7, 8, 1, 0,\n        6, 6, 8, 9, 4, 5, 3, 1, 2, 5, 8, 8, 8, 1, 7, 8, 4, 1, 9, 7, 0, 0, 1, 2, 5, 2, 3, 2, 3, 3,\n        8, 9, 0, 5, 3, 3, 4, 4, 7, 2, 6, 5, 6, 2, 5, 4, 4, 4, 0, 8, 9, 2, 0, 9, 8, 5, 0, 0, 6, 2,\n        6, 1, 6, 1, 6, 9, 4, 5, 2, 6, 6, 7, 2, 3, 6, 3, 2, 8, 1, 2, 5, 2, 2, 2, 0, 4, 4, 6, 0, 4,\n        9, 2, 5, 0, 3, 1, 3, 0, 8, 0, 8, 4, 7, 2, 6, 3, 3, 3, 6, 1, 8, 1, 6, 4, 0, 6, 2, 5, 1, 1,\n        1, 0, 2, 2, 3, 0, 2, 4, 6, 2, 5, 1, 5, 6, 5, 4, 0, 4, 2, 3, 6, 3, 1, 6, 6, 8, 0, 9, 0, 8,\n        2, 0, 3, 1, 2, 5, 5, 5, 5, 1, 1, 1, 5, 1, 2, 3, 1, 2, 5, 7, 8, 2, 7, 0, 2, 1, 1, 8, 1, 5,\n        8, 3, 4, 0, 4, 5, 4, 1, 0, 1, 5, 6, 2, 5, 2, 7, 7, 5, 5, 5, 7, 5, 6, 1, 5, 6, 2, 8, 9, 1,\n        3, 5, 1, 0, 5, 9, 0, 7, 9, 1, 7, 0, 2, 2, 7, 0, 5, 0, 7, 8, 1, 2, 5, 1, 3, 8, 7, 7, 7, 8,\n        7, 8, 0, 7, 8, 1, 4, 4, 5, 6, 7, 5, 5, 2, 9, 5, 3, 9, 5, 8, 5, 1, 1, 3, 5, 2, 5, 3, 9, 0,\n        6, 2, 5, 6, 9, 3, 8, 8, 9, 3, 9, 0, 3, 9, 0, 7, 2, 2, 8, 3, 7, 7, 6, 4, 7, 6, 9, 7, 9, 2,\n        5, 5, 6, 7, 6, 2, 6, 9, 5, 3, 1, 2, 5, 3, 4, 6, 9, 4, 4, 6, 9, 5, 1, 9, 5, 3, 6, 1, 4, 1,\n        8, 8, 8, 2, 3, 8, 4, 8, 9, 6, 2, 7, 8, 3, 8, 1, 3, 4, 7, 6, 5, 6, 2, 5, 1, 7, 3, 4, 7, 2,\n        3, 4, 7, 5, 9, 7, 6, 8, 0, 7, 0, 9, 4, 4, 1, 1, 9, 2, 4, 4, 8, 1, 3, 9, 1, 9, 0, 6, 7, 3,\n        8, 2, 8, 1, 2, 5, 8, 6, 7, 3, 6, 1, 7, 3, 7, 9, 8, 8, 4, 0, 3, 5, 4, 7, 2, 0, 5, 9, 6, 2,\n        2, 4, 0, 6, 9, 5, 9, 5, 3, 3, 6, 9, 1, 4, 0, 6, 2, 5,\n    ];\n\n    shift &= 63;\n    let x_a = TABLE[shift];\n    let x_b = TABLE[shift + 1];\n    let num_new_digits = (x_a >> 11) as _;\n    let pow5_a = (0x7FF & x_a) as usize;\n    let pow5_b = (0x7FF & x_b) as usize;\n    let pow5 = &TABLE_POW5[pow5_a..];\n    for (i, &p5) in pow5.iter().enumerate().take(pow5_b - pow5_a) {\n        if i >= d.num_digits {\n            return num_new_digits - 1;\n        } else if d.digits[i] == p5 {\n            continue;\n        } else if d.digits[i] < p5 {\n            return num_new_digits - 1;\n        } else {\n            return num_new_digits;\n        }\n    }\n    num_new_digits\n}", "item_id": 1, "repo": "mbc-git/rust", "file": "library/core/src/num/dec2flt/decimal.rs", "last_update_at": "2022-03-31T23:26:40+00:00"}
{"hexsha": "17f72486ca10ac010214ad07b7dbe96fa067c1f9", "ext": "rs", "lang": "Rust", "content": "fn hit_vector(c: &mut Criterion) {\n    let mut s = Sphere {\n        center: V3D {\n            x: 0.,\n            y: 0.,\n            z: 10.,\n        },\n        radius: 1.,\n    };\n    let mut r = RayxN {\n        origin: V3DxN {\n            x: f32xN::splat(0.),\n            y: f32xN::splat(0.),\n            z: f32xN::splat(0.),\n        },\n        dir: V3DxN {\n            x: f32xN::splat(0.),\n            y: f32xN::splat(0.),\n            z: f32xN::splat(1.),\n        },\n    };\n\n    c.bench(\n        \"vector\",\n        Benchmark::new(\"isec_sphere_hit\", move |b| {\n            b.iter(|| {\n                let mut isect = IsectxN::default();\n                let isect = black_box(&mut isect);\n                let s = black_box(&mut s);\n                let r = black_box(&mut r);\n                let mut v = r.intersect(s, *isect);\n                black_box(&mut v);\n                assert_eq!(v.hit.all(), true);\n            })\n        })\n        .throughput(Throughput::Elements(f32xN::lanes() as u64)),\n    );\n}", "item_id": 2, "repo": "eclipseo/packed_simd", "file": "examples/aobench/benches/isec_sphere.rs", "last_update_at": "2022-03-08T03:12:55+00:00"}
{"hexsha": "af3157c216065e2b895e47c3b7579a5743310777", "ext": "rs", "lang": "Rust", "content": "pub fn get_engine() -> Handlebars<'static> {\n    let mut h = Handlebars::new();\n    let _ = h.register_partial(\"compiled_from\", PART_COMPILED_FROM);\n    let _ = h.register_partial(\"sys_info\", PART_SYS_INFO);\n    let _ = h.register_partial(\"fields\", PART_FIELDS);\n    let _ = h.register_partial(\"methods\", PART_METHODS);\n    let _ = h.register_partial(\"constant_pool\", PART_CP);\n    // let _ = h.register_partial(\"stack_map_table\", PART_STACK_MAP_TABLE);\n    h.register_escape_fn(handlebars::no_escape);\n\n    h\n}", "item_id": 0, "repo": "fujinjun/jvm", "file": "tools/javap/src/template.rs", "last_update_at": "2022-03-30T05:33:33+00:00"}
{"hexsha": "756f72b7d8b65f496211cb0e6494d633662db033", "ext": "rs", "lang": "Rust", "content": "fn tokenize_test(input: &str, expected: &str) {\n    let (tokens, mut diagnostics) = tokenize(input);\n    diagnostics.retain(|d| d != &Diagnostic::Valid);\n    assert_eq!(diagnostics.as_slice(), []);\n\n    let got = format!(\"{:#?}\", tokens);\n    assert_eq!(got.as_str(), expected);\n}", "item_id": 0, "repo": "adam-mcdaniel/dune", "file": "src/tests/mod.rs", "last_update_at": "2022-03-30T16:33:46+00:00"}
{"hexsha": "c24144e0b86940dbe3c939b11504b3223ce1d429", "ext": "rs", "lang": "Rust", "content": "pub fn setup(hull_opts: &Config) -> Result<(), io::Error> {\n    let dir = &hull_opts.posts.output;\n    let path = Path::new(dir);\n\n    if path.exists() {\n        fs::remove_dir_all(path).expect(\"Hull: failed to remove posts output\");\n        println!(\"Hull: removed {:#?}\", path);\n    }\n\n    fs::create_dir(path).expect(\"Hull: failed to create posts output\");\n    println!(\"Hull: created {:#?}\", path);\n\n    Ok(())\n}", "item_id": 1, "repo": "rpearce/ramda.guide", "file": "src/hull/post.rs", "last_update_at": "2022-03-23T16:02:52+00:00"}
{"hexsha": "95bc49a8b217eb1c78014d3e8bd43e9a68bd51a4", "ext": "rs", "lang": "Rust", "content": "pub fn search(\n\tpid: &Pid,\n\tregion: &(usize, usize),\n\tpattern: &Pattern,\n) -> Result<(usize, Vec<u8>), MemError> {\n\tlet end = region.1;\n\tlet find = pattern.len();\n\tlet mut chunk_size = CHUNK_SIZE;\n\tlet mut pointer = region.0;\n\tlet mut criteria = pattern.iter();\n\tlet mut found = vec![];\n\tlet mut at = 0;\n\n\tloop {\n\t\t// Avoid overreach\n\t\tif pointer + chunk_size > end {\n\t\t\tchunk_size = end - pointer;\n\t\t}\n\n\t\t// Read memory region one chunk at a time\n\t\tlet chunk = read(pid, pointer, chunk_size)?;\n\n\t\t// Try to find pattern\n\t\tfor (idx, mbyte) in chunk.iter().enumerate() {\n\t\t\tif let Some(byte) = criteria.next().unwrap() {\n\t\t\t\t// Found one\n\t\t\t\tif byte == mbyte {\n\t\t\t\t\tfound.push(*mbyte);\n\n\t\t\t\t\t// Set \"at\" on first discovery\n\t\t\t\t\tif found.len() == 1 {\n\t\t\t\t\t\tat = pointer + idx;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Doesn't match, reset\n\t\t\t\t\tfound.clear();\n\t\t\t\t\tcriteria = pattern.iter();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Skip (None) is still considered found\n\t\t\t\tfound.push(*mbyte);\n\t\t\t}\n\n\t\t\t// Found what there is to find\n\t\t\tif found.len() == find {\n\t\t\t\treturn Ok((at, found));\n\t\t\t}\n\t\t}\n\n\t\t// Set next chunk\n\t\tpointer += chunk.len();\n\n\t\t// End of region, never found it sadly\n\t\tif pointer == end {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tErr(MemError::Read(\"Could not find pattern '{pattern}'\".into()))?\n}", "item_id": 0, "repo": "leaty/tuxtrain", "file": "src/mem.rs", "last_update_at": "2022-03-31T02:36:21+00:00"}
{"hexsha": "cca810b0a2c1dd3ee2d3aa3a33344cfbf67bbbb8", "ext": "rs", "lang": "Rust", "content": "fn _cmp_bytes_16(a_ptr: *const u8, b_ptr: *const u8) -> Ordering {\n    let aa_ptr = a_ptr as *const u128;\n    let bb_ptr = b_ptr as *const u128;\n    let aac = unsafe { *aa_ptr };\n    let bbc = unsafe { *bb_ptr };\n    let bits = aac ^ bbc;\n    if bits != 0 {\n        let pos = (bits.trailing_zeros() / 8) as usize;\n        let aa_ptr = unsafe { a_ptr.add(pos) };\n        let bb_ptr = unsafe { b_ptr.add(pos) };\n        let aac = unsafe { *aa_ptr };\n        let bbc = unsafe { *bb_ptr };\n        aac.cmp(&bbc)\n    } else {\n        Ordering::Equal\n    }\n}", "item_id": 1, "repo": "aki-akaguma/memx", "file": "src/arch/x86/x86_cmp.rs", "last_update_at": "2022-02-01T16:08:04+00:00"}
{"hexsha": "63077605e2c62999dd0f25e69279265cbec3a23c", "ext": "rs", "lang": "Rust", "content": "fn secure_passphrase_identity() {\n        let dir = TempDir::new(\"identity\").unwrap();\n        let keychain = keychain::CreateOptions::new()\n            .password(\"password\")\n            .create(dir.path().join(\"identity.keychain\"))\n            .unwrap();\n\n        let data = include_bytes!(\"../../../test/server.p12\");\n        let mut items = SecItems::default();\n        ImportOptions::new()\n            .filename(\"server.p12\")\n            .secure_passphrase(true)\n            .alert_title(\"alert title\")\n            .alert_prompt(\"alert prompt\")\n            .items(&mut items)\n            .keychain(&keychain)\n            .import(data)\n            .unwrap();\n        assert_eq!(1, items.identities.len());\n        assert_eq!(0, items.certificates.len());\n        assert_eq!(0, items.keys.len());\n    }", "item_id": 3, "repo": "allansrc/fuchsia", "file": "third_party/rust_crates/forks/security-framework/src/os/macos/import_export.rs", "last_update_at": "2022-03-28T07:59:06+00:00"}
{"hexsha": "53f29da9eca021b6f01792987ac8a7ae218489dd", "ext": "rs", "lang": "Rust", "content": "async fn test_ttl_index() {\n    test_setup();\n    let collection_name = \"test_collection\";\n    let index_name = \"idx_ttl_test\";\n    let conn = connection().await;\n\n    let database = conn.db(\"test_db\").await.unwrap();\n\n    let index = Index::builder()\n        .name(index_name)\n        .fields(vec![\"password\".to_string()])\n        .settings(IndexSettings::Ttl { expire_after: 500 })\n        .build();\n\n    let index = database\n        .create_index(collection_name, &index)\n        .await\n        .unwrap();\n\n    let delete_result = database.delete_index(&index.id).await.unwrap();\n\n    assert!(index.id.len() > 0);\n    assert_eq!(index.name, index_name.to_string());\n    assert_eq!(delete_result.id, index.id);\n\n    if let IndexSettings::Ttl { expire_after } = index.settings {\n        assert_eq!(expire_after, 500);\n    }\n}", "item_id": 4, "repo": "r3bu1ld3r/arangors", "file": "tests/index.rs", "last_update_at": "2022-03-10T13:16:03+00:00"}
{"hexsha": "ab688fcf5573e69668dcb8598743abbfef680a36", "ext": "rs", "lang": "Rust", "content": "fn allows_ints() {\n            let mut node = ExpressionNode::from(RangeNode {\n                l: Box::new(Some(ExpressionNode::Var(VarNode::new(\"foo\")))),\n                r: Box::new(Some(ExpressionNode::from(456))),\n                span: None,\n            });\n\n            let mut scopes = ScopeTree::default();\n            scopes.push_new();\n            let sym = Symbol::new(\"foo\", LpcType::Int(false));\n            scopes.current_mut().unwrap().insert(sym);\n            let context = CompilationContext {\n                scopes,\n                ..CompilationContext::default()\n            };\n\n            let mut walker = SemanticCheckWalker::new(context);\n            let _ = node.visit(&mut walker);\n\n            assert!(walker.context.errors.is_empty());\n        }", "item_id": 48, "repo": "xxx/lpc-rs", "file": "src/codegen/semantic_check_walker.rs", "last_update_at": "2022-02-01T19:12:36+00:00"}
{"hexsha": "6909681d7022d2c0050eef2a8fd33f1497608030", "ext": "rs", "lang": "Rust", "content": "pub fn expand_groups(path: &str) -> Vec<String> {\n    lazy_static! {\n        static ref GROUPS_MATCHER: Regex = Regex::new(r\"\\{[^\\{]+?\\}\").unwrap();\n    }\n\n    let mut offset = 0;\n    let mut chunks: Vec<Vec<&str>> = vec![];\n\n    for m in GROUPS_MATCHER.find_iter(path) {\n        chunks.push(vec![&path[offset..m.start()]]);\n        chunks.push(path[m.start() + 1..m.end() - 1].split(',').collect());\n        offset = m.end();\n    }\n    chunks.push(vec![&path[offset..]]);\n\n    join_chunks(chunks)\n}", "item_id": 0, "repo": "panhania/rrg", "file": "src/action/finder/groups.rs", "last_update_at": "2022-03-10T06:42:44+00:00"}
{"hexsha": "c9b4e7f9f9ec1954c6b89b4e71ac9099f3b5a134", "ext": "rs", "lang": "Rust", "content": "fn create_builder_struct_code(parameters: &FunctionParamsCode, in_group: bool) -> Result<TokenStream, Error> {\n    let mut params: Vec<TokenStream> = Vec::new();\n    if in_group {\n        params.push(quote! { pub(crate) client: super::super::Client });\n    } else {\n        params.push(quote! { pub(crate) client: super::Client });\n    }\n    for param in parameters.required_params() {\n        let FunctionParam {\n            variable_name, type_name, ..\n        } = param;\n        params.push(quote! { pub(crate) #variable_name: #type_name });\n    }\n    for param in parameters.optional_params() {\n        let FunctionParam {\n            variable_name, type_name, ..\n        } = param;\n        let mut type_name = type_name.clone();\n        if type_name.is_vec() {\n            type_name = type_name.optional(false);\n        }\n        params.push(quote! { pub(crate) #variable_name: #type_name });\n    }\n    Ok(quote! {\n        #[derive(Clone)]\n        pub struct Builder {\n            #(#params),*\n        }\n    })\n}", "item_id": 6, "repo": "rickrain/azure-sdk-for-rust", "file": "services/autorust/codegen/src/codegen_operations.rs", "last_update_at": "2022-02-16T18:36:01+00:00"}
{"hexsha": "d862c6a9a02786c55e48e2a6a6f45f9c1c80b65d", "ext": "rs", "lang": "Rust", "content": "pub fn inline_metas(mut tcs: TCS, val: ValInfo) -> ValTCM {\n    use Neutral::*;\n    let info = val.loc;\n    let val = val.ast.try_map_neutral(&mut |neut| match neut {\n        Meta(mi) => tcs\n            .meta_context\n            .take_meta(mi)\n            .ok_or_else(|| TCE::MetaUnsolved(mi)),\n        e => Ok(Val::Neut(e)),\n    })?;\n    Ok((val.into_info(info), tcs))\n}", "item_id": 1, "repo": "ice1000/voile-rs", "file": "src/check/decl.rs", "last_update_at": "2022-03-28T10:48:27+00:00"}
{"hexsha": "a3889528db5bb779621f9bea8c6f6249ccc93496", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn eval(p: &[u8], x: u8) -> u8 {\n    let mut result = 0;\n\n    for i in (0..p.len()).rev() {\n        result = add(mul(result, x), p[i])\n    }\n    result\n}", "item_id": 1, "repo": "rustyhorde/sss", "file": "src/gf256/mod.rs", "last_update_at": "2022-01-19T14:26:27+00:00"}
{"hexsha": "a8db0b5b31478f6f8c1bc9ced0437c56ea77da0e", "ext": "rs", "lang": "Rust", "content": "pub fn create_theme(opt: &Opt) -> Theme {\n    let locations = locations();\n    let mut theme = Theme::default();\n    if let Some(th) = &opt.theme {\n        locations.iter().find(|d| {\n            let path = d.join(&format!(\"{}.toml\", th));\n            if !path.exists() {\n                return false;\n            }\n\n            match get_theme(&path) {\n                Ok(t) => {\n                    theme = t;\n                    theme.set_randomization();\n                    true\n                }\n                Err(e) => {\n                    error::print_errors(e);\n                    false\n                }\n            }\n        });\n    }\n\n    theme\n}", "item_id": 1, "repo": "uttarayan21/macchina", "file": "src/theme/base.rs", "last_update_at": "2022-03-31T18:42:08+00:00"}
{"hexsha": "d95402363cd8ad4150d80467195470ad710b702c", "ext": "rs", "lang": "Rust", "content": "fn simple_message() {\n    let test_name = random_name(\"simple_message\");\n    libsystemd::logging::journal_send(\n        Priority::Info,\n        \"Hello World\",\n        vec![\n            (\"TEST_NAME\", test_name.as_str()),\n            (\"FOO\", \"another piece of data\"),\n        ]\n        .into_iter(),\n    )\n    .unwrap();\n\n    let messages = read_from_journal(&test_name);\n    assert_eq!(messages.len(), 1);\n\n    let message = &messages[0];\n    assert_eq!(message[\"MESSAGE\"], \"Hello World\");\n    assert_eq!(message[\"TEST_NAME\"], test_name);\n    assert_eq!(message[\"PRIORITY\"], \"6\");\n    assert_eq!(message[\"FOO\"], \"another piece of data\");\n}", "item_id": 0, "repo": "vilgotf/libsystemd-rs", "file": "tests/journal.rs", "last_update_at": "2022-03-05T11:42:31+00:00"}
{"hexsha": "dedc9bc7459e74b5a527e66e0bbc160bd46ad9a6", "ext": "rs", "lang": "Rust", "content": "fn slow_on_write() {\n        // this test is pretty similar to the above, except that it lags the on_write call instead.\n        let exec = fasync::Executor::new().expect(\"Executor creation failed\");\n\n        let write_counter = Arc::new(AtomicUsize::new(0));\n        let client_counter = Arc::new(AtomicUsize::new(0));\n        let client_count = client_counter.clone();\n        let (finish_future_sender, finish_future_receiver) = oneshot::channel::<()>();\n        let finish_future_receiver = finish_future_receiver.shared();\n\n        run_server_client_with_executor(\n            OPEN_RIGHT_WRITABLE,\n            exec,\n            write_only(100, |content| {\n                let write_counter = write_counter.clone();\n                let finish_future_receiver = finish_future_receiver.clone();\n                async move {\n                    assert_eq!(*&content, b\"content\");\n                    write_counter.fetch_add(1, Ordering::Relaxed);\n                    await!(finish_future_receiver)\n                        .expect(\"finish_future_sender was not called before been dropped.\");\n                    write_counter.fetch_add(1, Ordering::Relaxed);\n                    Ok(())\n                }\n            }),\n            async move |proxy| {\n                client_count.fetch_add(1, Ordering::Relaxed);\n\n                assert_write!(proxy, \"content\");\n                assert_close!(proxy);\n\n                client_count.fetch_add(1, Ordering::Relaxed);\n            },\n            |run_until_stalled_assert| {\n                let check_write_client_counts = |expected_write, expected_client| {\n                    assert_eq!(write_counter.load(Ordering::Relaxed), expected_write);\n                    assert_eq!(client_counter.load(Ordering::Relaxed), expected_client);\n                };\n\n                run_until_stalled_assert(false);\n\n                // The server and the client are waiting.\n                check_write_client_counts(1, 1);\n\n                finish_future_sender.send(()).unwrap();\n                run_until_stalled_assert(true);\n\n                // The server and the client are done.\n                check_write_client_counts(2, 2);\n            },\n        );\n    }", "item_id": 6, "repo": "zhangpf/fuchsia-rs", "file": "garnet/public/rust/fuchsia-vfs/pseudo-fs/src/file/asynchronous.rs", "last_update_at": "2022-03-02T04:44:22+00:00"}
{"hexsha": "3e2f6607d27280bcb38a973c0c7be105d5707329", "ext": "rs", "lang": "Rust", "content": "fn get_local_contract(path: &Path) -> Result<String> {\n    let path = if path.is_relative() {\n        let absolute_path = path.canonicalize().with_context(|| {\n            format!(\n                \"unable to canonicalize file from working dir {} with path {}\",\n                env::current_dir()\n                    .map(|cwd| cwd.display().to_string())\n                    .unwrap_or_else(|err| format!(\"??? ({})\", err)),\n                path.display(),\n            )\n        })?;\n        Cow::Owned(absolute_path)\n    } else {\n        Cow::Borrowed(path)\n    };\n\n    let json = fs::read_to_string(&path).context(format!(\n        \"failed to read artifact JSON file with path {}\",\n        &path.display()\n    ))?;\n    Ok(json)\n}", "item_id": 0, "repo": "luizstacio/fuels-rs", "file": "packages/fuels-core/src/source.rs", "last_update_at": "2022-03-29T22:45:20+00:00"}
{"hexsha": "2a7f1ec01831b9ec8306a324ede6d31050ecea54", "ext": "rs", "lang": "Rust", "content": "fn test_from_config_date() {\n        let mut c = Config::with_none();\n        c.date = Some(\"date\".into());\n\n        assert_eq!(Some(DateFlag::Date), DateFlag::from_config(&c));\n    }", "item_id": 7, "repo": "NyleCohen/lsd", "file": "src/flags/date.rs", "last_update_at": "2022-03-31T19:22:11+00:00"}
{"hexsha": "d8edfa906c932a5dfccb45fe938d24ebd281099e", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout___darwin_mcontext_avx64_full() {\n    assert_eq!(\n        ::std::mem::size_of::<__darwin_mcontext_avx64_full>(),\n        1064usize,\n        concat!(\"Size of: \", stringify!(__darwin_mcontext_avx64_full))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<__darwin_mcontext_avx64_full>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(__darwin_mcontext_avx64_full))\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__es as *const _ as usize\n        },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext_avx64_full),\n            \"::\",\n            stringify!(__es)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__ss as *const _ as usize\n        },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext_avx64_full),\n            \"::\",\n            stringify!(__ss)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__fs as *const _ as usize\n        },\n        216usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext_avx64_full),\n            \"::\",\n            stringify!(__fs)\n        )\n    );\n}", "item_id": 162, "repo": "ueno/rust-tss-esapi", "file": "tss-esapi-sys/src/bindings/x86_64-unknown-darwin.rs", "last_update_at": "2022-03-22T07:54:57+00:00"}
{"hexsha": "d76cdd6a4fcc687a5ef8aeade4fa2f9699dc40ff", "ext": "rs", "lang": "Rust", "content": "fn compare_to_reference() {\n        let reference_input = to_f32(include_bytes!(\"../test_data/testing.raw\"));\n        let reference_output = to_i16(include_bytes!(\"../test_data/reference_output.raw\"));\n        let mut output = Vec::new();\n        let mut out_buf = [0.0; FRAME_SIZE];\n        let mut state = DenoiseState::new();\n        let mut first = true;\n        for chunk in reference_input.chunks_exact(FRAME_SIZE) {\n            state.process_frame(&mut out_buf[..], chunk);\n            if !first {\n                output.extend_from_slice(&out_buf[..]);\n            }\n            first = false;\n        }\n\n        assert_eq!(output.len(), reference_output.len());\n        let output = output.into_iter().map(|x| x as i16).collect::<Vec<_>>();\n        let xx: f64 = output.iter().map(|&x| (x as f64).powi(2)).sum();\n        let diff: f64 = reference_output\n            .into_iter()\n            .zip(output)\n            .map(|(x, y)| (x as f64 - y as f64).powi(2))\n            .sum();\n        assert!(diff / xx < 1e-4);\n    }", "item_id": 3, "repo": "Rikorose/nnnoiseless", "file": "src/lib.rs", "last_update_at": "2022-03-31T17:47:15+00:00"}
{"hexsha": "5b624133894ec5a9d8631b19de5deaabd8a65bbf", "ext": "rs", "lang": "Rust", "content": "async fn install_wallet(canister_id: &Principal, wasm_module: Vec<u8>) -> Result<(), String> {\n        // Install Wasm\n        #[derive(CandidType, Deserialize)]\n        enum InstallMode {\n            #[serde(rename = \"install\")]\n            Install,\n            #[serde(rename = \"reinstall\")]\n            Reinstall,\n            #[serde(rename = \"upgrade\")]\n            Upgrade,\n        }\n\n        #[derive(CandidType, Deserialize)]\n        struct CanisterInstall {\n            mode: InstallMode,\n            canister_id: Principal,\n            #[serde(with = \"serde_bytes\")]\n            wasm_module: Vec<u8>,\n            arg: Vec<u8>,\n        }\n\n        let install_config = CanisterInstall {\n            mode: InstallMode::Install,\n            canister_id: *canister_id,\n            wasm_module: wasm_module.clone(),\n            arg: b\" \".to_vec(),\n        };\n\n        match api::call::call(\n            Principal::management_canister(),\n            \"install_code\",\n            (install_config,),\n        )\n        .await\n        {\n            Ok(x) => x,\n            Err((code, msg)) => {\n                return Err(format!(\n                    \"An error happened during the call: {}: {}\",\n                    code as u8, msg\n                ))\n            }\n        };\n\n        events::record(events::EventKind::WalletDeployed {\n            canister: *canister_id,\n        });\n\n        // Store wallet wasm\n        let store_args = WalletStoreWASMArgs { wasm_module };\n        match api::call::call(*canister_id, \"wallet_store_wallet_wasm\", (store_args,)).await {\n            Ok(x) => x,\n            Err((code, msg)) => {\n                return Err(format!(\n                    \"An error happened during the call: {}: {}\",\n                    code as u8, msg\n                ))\n            }\n        };\n        Ok(())\n    }", "item_id": 10, "repo": "wackyleo459/cycles-wallet", "file": "wallet/src/lib.rs", "last_update_at": "2022-03-15T14:28:46+00:00"}
{"hexsha": "7664dfc683b5b5061964a63f04c08ed6b07d34d9", "ext": "rs", "lang": "Rust", "content": "fn serialize_currency() {\n    use stripe::Currency;\n    assert_eq!(serde_json::to_string(&Currency::AED).unwrap(), \"\\\"aed\\\"\");\n    assert_eq!(serde_json::to_string(&Currency::USD).unwrap(), \"\\\"usd\\\"\");\n    assert_eq!(serde_json::to_string(&Currency::ZMW).unwrap(), \"\\\"zmw\\\"\");\n}", "item_id": 2, "repo": "chrislearn/async-stripe", "file": "tests/encoding.rs", "last_update_at": "2022-03-31T15:00:05+00:00"}
{"hexsha": "848a493f75eb7f91fc8451bf7c2a53f425c531a8", "ext": "rs", "lang": "Rust", "content": "pub fn line_spacing() -> Result<(), DocxError> {\n    let path = std::path::Path::new(\"./tests/output/line_spacing.docx\");\n    let file = std::fs::File::create(&path).unwrap();\n    Docx::new()\n        .add_paragraph(\n            Paragraph::new()\n                .add_run(Run::new().add_text(DUMMY))\n                .line_spacing(Some(300), None, Some(300), Some(LineSpacingType::Auto)),\n        )\n        .add_paragraph(\n            Paragraph::new()\n                .add_run(Run::new().add_text(DUMMY))\n                .line_spacing(None, None, Some(300), Some(LineSpacingType::AtLeast)),\n        )\n        .add_paragraph(\n            Paragraph::new()\n                .add_run(Run::new().add_text(DUMMY).character_spacing(100))\n                .line_spacing(None, Some(300), Some(300), Some(LineSpacingType::Exact)),\n        )\n        .build()\n        .pack(file)?;\n    Ok(())\n}", "item_id": 19, "repo": "lkadalski/docx-rs", "file": "docx-core/tests/lib.rs", "last_update_at": "2022-03-31T11:06:05+00:00"}
{"hexsha": "8af80106c8e9c874ac74ce54ebabea9db1974f58", "ext": "rs", "lang": "Rust", "content": "fn test_nested_prefixed_expressions() {\n    assert_eq!(\n        parse(\"++42\"),\n        Ok(Expression(UnaryPrefixOperation(\n            PlusSign,\n            Box::new(UnaryPrefixOperation(PlusSign, Box::new(Number(42f64))),),\n        )))\n    );\n    assert_eq!(\n        parse(\"+-42\"),\n        Ok(Expression(UnaryPrefixOperation(\n            PlusSign,\n            Box::new(UnaryPrefixOperation(MinusSign, Box::new(Number(42f64))),),\n        )))\n    );\n\n    assert_eq!(\n        parse(\"-+-42\"),\n        Ok(Expression(UnaryPrefixOperation(\n            MinusSign,\n            Box::new(UnaryPrefixOperation(\n                PlusSign,\n                Box::new(UnaryPrefixOperation(MinusSign, Box::new(Number(42f64))),),\n            )),\n        )))\n    );\n}", "item_id": 2, "repo": "MoritzKn/ralculator", "file": "src/parser/test.rs", "last_update_at": "2022-01-04T22:30:21+00:00"}
{"hexsha": "e112cbf8f2863098273dd72f928af9f8a27fff8d", "ext": "rs", "lang": "Rust", "content": "fn if_else() {\n        /*\n        if abc == 1 {\n            xyz == 1;\n        } else if abc == 2{\n            xyz == 2;\n        } else {\n            xyz == 3;\n        }\n        */\n\n        let condition1 = Condition {\n            span: Span::new(),\n            lhs: make_identifier!(\"abc\"),\n            op: ConditionOp::Equals,\n            rhs: Value::NumericLiteral(1),\n        };\n        let condition2 = Condition {\n            span: Span::new(),\n            lhs: make_identifier!(\"abc\"),\n            op: ConditionOp::Equals,\n            rhs: Value::NumericLiteral(2),\n        };\n        let statement1 = Statement::ConditionStatement {\n            span: Span::new(),\n            condition: Condition {\n                span: Span::new(),\n                lhs: make_identifier!(\"xyz\"),\n                op: ConditionOp::Equals,\n                rhs: Value::NumericLiteral(1),\n            },\n        };\n        let statement2 = Statement::ConditionStatement {\n            span: Span::new(),\n            condition: Condition {\n                span: Span::new(),\n                lhs: make_identifier!(\"xyz\"),\n                op: ConditionOp::Equals,\n                rhs: Value::NumericLiteral(2),\n            },\n        };\n        let statement3 = Statement::ConditionStatement {\n            span: Span::new(),\n            condition: Condition {\n                span: Span::new(),\n                lhs: make_identifier!(\"xyz\"),\n                op: ConditionOp::Equals,\n                rhs: Value::NumericLiteral(3),\n            },\n        };\n\n        let statements = vec![Statement::If {\n            span: Span::new(),\n            blocks: vec![\n                (condition1.clone(), vec![statement1.clone()]),\n                (condition2.clone(), vec![statement2.clone()]),\n            ],\n            else_block: vec![statement3.clone()],\n        }];\n        let mut symbol_table = HashMap::new();\n        symbol_table.insert(\n            make_identifier!(\"abc\"),\n            Symbol::Key(\"abc\".to_string(), bind_library::ValueType::Number),\n        );\n        symbol_table.insert(\n            make_identifier!(\"xyz\"),\n            Symbol::Key(\"xyz\".to_string(), bind_library::ValueType::Number),\n        );\n\n        let instructions = compiler::compile_statements(statements, &symbol_table, false).unwrap();\n\n        // Binds when the if clause is satisfied.\n        let properties = vec![\n            Property { key: make_identifier!(\"abc\"), value: Value::NumericLiteral(1) },\n            Property { key: make_identifier!(\"xyz\"), value: Value::NumericLiteral(1) },\n        ];\n        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();\n        assert!(debugger.evaluate_bind_rules().unwrap());\n        assert_eq!(\n            debugger.output,\n            vec![\n                DebuggerOutput::IfCondition { condition: &condition1, success: true },\n                DebuggerOutput::ConditionStatement { statement: &statement1, success: true }\n            ]\n        );\n\n        // Binds when the if else clause is satisfied.\n        let properties = vec![\n            Property { key: make_identifier!(\"abc\"), value: Value::NumericLiteral(2) },\n            Property { key: make_identifier!(\"xyz\"), value: Value::NumericLiteral(2) },\n        ];\n        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();\n        assert!(debugger.evaluate_bind_rules().unwrap());\n        assert_eq!(\n            debugger.output,\n            vec![\n                DebuggerOutput::IfCondition { condition: &condition1, success: false },\n                DebuggerOutput::IfCondition { condition: &condition2, success: true },\n                DebuggerOutput::ConditionStatement { statement: &statement2, success: true }\n            ]\n        );\n\n        // Binds when the else clause is satisfied.\n        let properties =\n            vec![Property { key: make_identifier!(\"xyz\"), value: Value::NumericLiteral(3) }];\n        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();\n        assert!(debugger.evaluate_bind_rules().unwrap());\n        assert_eq!(\n            debugger.output,\n            vec![\n                DebuggerOutput::IfCondition { condition: &condition1, success: false },\n                DebuggerOutput::IfCondition { condition: &condition2, success: false },\n                DebuggerOutput::ConditionStatement { statement: &statement3, success: true }\n            ]\n        );\n\n        // Doesn't bind when the device has incorrect values for the properties.\n        let properties = vec![\n            Property { key: make_identifier!(\"abc\"), value: Value::NumericLiteral(42) },\n            Property { key: make_identifier!(\"xyz\"), value: Value::NumericLiteral(42) },\n        ];\n        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();\n        assert!(!debugger.evaluate_bind_rules().unwrap());\n        assert_eq!(\n            debugger.output,\n            vec![\n                DebuggerOutput::IfCondition { condition: &condition1, success: false },\n                DebuggerOutput::IfCondition { condition: &condition2, success: false },\n                DebuggerOutput::ConditionStatement { statement: &statement3, success: false }\n            ]\n        );\n\n        // Doesn't bind when the properties are missing in the device.\n        let properties = Vec::new();\n        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();\n        assert!(!debugger.evaluate_bind_rules().unwrap());\n        assert_eq!(\n            debugger.output,\n            vec![\n                DebuggerOutput::IfCondition { condition: &condition1, success: false },\n                DebuggerOutput::IfCondition { condition: &condition2, success: false },\n                DebuggerOutput::ConditionStatement { statement: &statement3, success: false }\n            ]\n        );\n    }", "item_id": 5, "repo": "allansrc/fuchsia", "file": "src/devices/lib/bind/src/debugger/offline_debugger.rs", "last_update_at": "2022-03-28T07:59:06+00:00"}
{"hexsha": "d3bb7c75edf3e7c8839c415f4ea783450b47429b", "ext": "rs", "lang": "Rust", "content": "fn rpc_parity_set_min_gas_price() {\n\tlet miner = miner_service();\n\tlet client = client_service();\n\tlet network = network_service();\n\tlet updater = updater_service();\n\n\tlet mut io = IoHandler::new();\n\tio.extend_with(parity_set_client(&client, &miner, &updater, &network).to_delegate());\n\n\tlet request = r#\"{\"jsonrpc\": \"2.0\", \"method\": \"parity_setMinGasPrice\", \"params\":[\"0xcd1722f3947def4cf144679da39c4c32bdc35681\"], \"id\": 1}\"#;\n\tlet response = r#\"{\"jsonrpc\":\"2.0\",\"result\":true,\"id\":1}\"#;\n\n\tassert_eq!(io.handle_request_sync(request), Some(response.to_owned()));\n}", "item_id": 2, "repo": "snuspl/fluffy", "file": "openethereum/rpc/src/v1/tests/mocked/parity_set.rs", "last_update_at": "2022-02-16T09:30:15+00:00"}
{"hexsha": "35566c0b1d436852b987c6efff410545cd18a5fd", "ext": "rs", "lang": "Rust", "content": "pub fn get_padded_node_len<'a>(reader: &Reader<'a>, node_name: &str) -> usize {\n    let root = reader.struct_items();\n    let (node, _) = root.path_struct_items(node_name).next().unwrap();\n\n    let node_len = TOKEN_SIZE + node.node_name().unwrap().len();\n    let padded_node_len = node_len + (node_len % 4);\n    padded_node_len\n}", "item_id": 5, "repo": "imrank03/rustBoot", "file": "rustBoot/src/dt/patch.rs", "last_update_at": "2022-03-13T11:58:36+00:00"}
{"hexsha": "4f539f11575a3a4c50764185f950a5b2b7aeb8b0", "ext": "rs", "lang": "Rust", "content": "fn flush_changes(&mut self) -> Result<bool> {\n        let mut changes = self.take_changes();\n        // Sort the changes by the order in which the columns are\n        changes.sort_by_key(|a| a.get_column_index());\n\n        let column_metas = self.static_meta().get_column_meta();\n\n        let mut buffer_actions = Vec::with_capacity(self.dynamic_meta().buffers.len());\n        let mut node_changes = vec![];\n\n        let mut this_buffer_index = 0;\n        let mut this_buffer_offset = 0;\n\n        // Go over all of the pending changes, calculate target locations for those buffers\n        // and neighbouring buffers if they need to be moved.\n        changes.iter().for_each(|array_data| {\n            let column_index = array_data.get_column_index();\n            // `meta` contains the information about where to look in `self.dynamic_meta` for\n            // current offset/node information\n            let meta = &column_metas[column_index];\n\n            let buffer_start = meta.buffer_start;\n            // Depth-first is required, because this is the order in which\n            // nodes are written into memory, see `write_static_array_data` in ./arrow/ipc.rs\n            let array_datas = gather_array_datas_depth_first(array_data.get_data());\n\n            // Iterate over buffers that are not modified, but might have to be moved,\n            // because of preceding buffers which may have been moved/resized\n            if this_buffer_index != buffer_start {\n                this_buffer_offset = push_non_modify_actions(\n                    &mut buffer_actions,\n                    this_buffer_index,\n                    buffer_start - 1,\n                    this_buffer_offset,\n                    self.dynamic_meta(),\n                );\n                this_buffer_index = buffer_start;\n            }\n\n            // A column can consist of more than one node. For example a field that is\n            // List<u8> corresponds to a column with 2 nodes\n            array_datas.iter().enumerate().for_each(|(i, array_data)| {\n                let node_index = meta.node_start + i;\n                // Update Node information\n                node_changes.push((node_index, Node {\n                    null_count: array_data._null_count(),\n                    length: array_data._len(),\n                }));\n\n                // Null buffer calculation.\n                // The null buffer is always the first buffer in a column,\n                // it is found under `array_data.null_buffer()` and\n                // NOT under `array_data.buffers()[0]`\n                {\n                    let num_bytes = arrow_bit_util::ceil(array_data._len(), 8);\n                    let next_buffer_offset = self\n                        .dynamic_meta()\n                        .buffers\n                        .get(this_buffer_index + 1)\n                        .map_or_else(|| self.dynamic_meta().data_length, |v| v.offset);\n                    let new_padding = padding::maybe_new_dynamic_pad(\n                        this_buffer_offset,\n                        num_bytes,\n                        next_buffer_offset,\n                    );\n                    // Safety: A null buffer is always followed by another buffer\n                    if let Some(b) = array_data._null_buffer() {\n                        buffer_actions.push(BufferAction::Ref {\n                            index: this_buffer_index,\n                            offset: this_buffer_offset,\n                            padding: new_padding,\n                            buffer: b,\n                        });\n                    } else {\n                        // We know all values must be valid.\n                        // Hence we have to make a homogeneous\n                        // null buffer corresponding to valid values\n                        let buffer = vec![255_u8; num_bytes];\n\n                        buffer_actions.push(BufferAction::Owned {\n                            index: this_buffer_index,\n                            offset: this_buffer_offset,\n                            padding: new_padding,\n                            buffer,\n                        });\n                    }\n\n                    this_buffer_index += 1;\n                    let total_buffer_length = num_bytes + new_padding;\n                    this_buffer_offset += total_buffer_length;\n                }\n\n                // Go over offset/data buffers (these are not null buffers)\n                // Have to do `meta.buffer_counts[i] - 1` because the null buffer is separate\n                debug_assert_eq!(\n                    meta.buffer_counts[i] - 1,\n                    array_data._get_non_null_buffer_count()\n                );\n                // todo: when adding datatypes with no null buffer (the null datatype), then this\n                //   convention does not work\n                (0..meta.buffer_counts[i] - 1).for_each(|j| {\n                    let buffer = array_data._get_buffer(j);\n                    let new_len = buffer.len();\n                    let next_buffer_offset = self\n                        .dynamic_meta()\n                        .buffers\n                        .get(this_buffer_index + 1)\n                        .map_or_else(|| self.dynamic_meta().data_length, |v| v.offset);\n                    let new_padding = padding::maybe_new_dynamic_pad(\n                        this_buffer_offset,\n                        new_len,\n                        next_buffer_offset,\n                    );\n                    buffer_actions.push(BufferAction::Ref {\n                        index: this_buffer_index,\n                        offset: this_buffer_offset,\n                        padding: new_padding,\n                        buffer,\n                    });\n                    this_buffer_offset += new_len + new_padding;\n                    this_buffer_index += 1;\n                });\n            });\n        });\n\n        // There can be buffers at the end which have not been\n        // attended to yet. Create actions for them too and use\n        // the chance to update final data length\n        let last_buffer_index = self.static_meta().get_padding_meta().len() - 1;\n        self.mut_dynamic_meta().data_length = push_non_modify_actions(\n            &mut buffer_actions,\n            this_buffer_index,\n            last_buffer_index,\n            this_buffer_offset,\n            self.dynamic_meta(),\n        );\n        let data_length = self.dynamic_meta().data_length;\n        // Resize memory if needed\n        let change = self.mut_memory().set_data_length(data_length)?;\n\n        debug_assert!(self.dynamic_meta().data_length == self.memory().get_data_buffer()?.len());\n\n        // Iterate backwards over every buffer action and perform them\n        // Also update offset information in `self.dynamic_meta`\n        buffer_actions\n            .into_iter()\n            .rev()\n            .try_for_each(|action| match action {\n                BufferAction::Move {\n                    old_offset,\n                    old_total_length,\n                    new_offset,\n                    first_index,\n                    last_index,\n                } => {\n                    // We shouldn't be left-shifting buffers\n                    debug_assert!(old_offset <= new_offset);\n                    (first_index..=last_index).for_each(|j| {\n                        // To avoid the modular nature of unsigned int subtraction:\n                        self.mut_dynamic_meta().buffers[j].offset += new_offset;\n                        self.mut_dynamic_meta().buffers[j].offset -= old_offset;\n                    });\n\n                    self.mut_memory().copy_in_data_buffer_unchecked(\n                        old_offset,\n                        new_offset,\n                        old_total_length,\n                    )\n                }\n                BufferAction::Owned {\n                    index,\n                    offset,\n                    padding,\n                    buffer,\n                } => {\n                    let dynamic_meta = self.mut_dynamic_meta();\n                    dynamic_meta.buffers[index].offset = offset;\n                    dynamic_meta.buffers[index].padding = padding;\n                    dynamic_meta.buffers[index].length = buffer.len();\n                    self.mut_memory()\n                        .overwrite_in_data_buffer_unchecked_nonoverlapping(offset, &buffer)\n                }\n                BufferAction::Ref {\n                    index,\n                    offset,\n                    padding,\n                    buffer,\n                } => {\n                    let dynamic_meta = self.mut_dynamic_meta();\n                    dynamic_meta.buffers[index].offset = offset;\n                    dynamic_meta.buffers[index].padding = padding;\n                    dynamic_meta.buffers[index].length = buffer.len();\n                    self.mut_memory()\n                        .overwrite_in_data_buffer_unchecked_nonoverlapping(offset, buffer)\n                }\n            })?;\n\n        // Update `FieldNode` data with null_count/element count values\n        node_changes.into_iter().for_each(|(i, n)| {\n            self.mut_dynamic_meta().nodes[i] = n;\n        });\n\n        // Write `self.dynamic_meta` in Arrow format into the `meta_buffer` in `self.memory`\n        let dynamic_meta = self.dynamic_meta();\n        let new_data_length =\n            dynamic_meta.buffers[dynamic_meta.buffers.len() - 1].get_next_offset();\n        debug_assert!(self.static_meta().validate_lengths(self.dynamic_meta()));\n        self.mut_memory().set_data_length(new_data_length)?;\n        let meta_buffer = get_dynamic_meta_flatbuffers(self.dynamic_meta())?;\n        self.mut_memory().set_metadata(&meta_buffer)?;\n        debug_assert!(self.memory().validate_markers());\n        Ok(change.resized())\n    }", "item_id": 0, "repo": "mschrader15/hash", "file": "packages/engine/src/datastore/batch/flush.rs", "last_update_at": "2022-03-31T04:39:07+00:00"}
{"hexsha": "ad6fd265ade99544a2062b47ed15f1479d7e21b3", "ext": "rs", "lang": "Rust", "content": "fn test_lex_multi_char() {\n        let code = \"<<=<>>>=::=\".as_bytes();\n        let mut lexer = Lexer::new(code).unwrap();\n        assert_eq!(Lt, lexer.next_token().unwrap().kind);\n        assert_eq!(Le, lexer.next_token().unwrap().kind);\n        assert_eq!(Ne, lexer.next_token().unwrap().kind);\n        assert_eq!(Gt, lexer.next_token().unwrap().kind);\n        assert_eq!(Ge, lexer.next_token().unwrap().kind);\n        assert_eq!(Colon, lexer.next_token().unwrap().kind);\n        assert_eq!(ColonEq, lexer.next_token().unwrap().kind);\n        assert_eq!(Eof, lexer.next_token().unwrap().kind);\n    }", "item_id": 1, "repo": "Y-Nak/tiger-cranelift", "file": "tigerc/src/lexer.rs", "last_update_at": "2022-02-11T15:18:19+00:00"}
{"hexsha": "7b46989e8a44f46047cfa334ef8813c929d3a6e8", "ext": "rs", "lang": "Rust", "content": "fn call_fetch_sidechain_blocks_from_peer(\n\t\tlast_known_block_hash: H256,\n\t\tshard_identifier: H256,\n\t\tbuffer: &mut Vec<u8>,\n\t\tsidechain_bridge: Arc<dyn SidechainBridge>,\n\t) -> sgx_status_t {\n\t\tlet last_known_block_hash_encoded = last_known_block_hash.encode();\n\t\tlet shard_identifier_encoded = shard_identifier.encode();\n\n\t\tfetch_sidechain_blocks_from_peer(\n\t\t\tlast_known_block_hash_encoded.as_ptr(),\n\t\t\tlast_known_block_hash_encoded.len() as u32,\n\t\t\tshard_identifier_encoded.as_ptr(),\n\t\t\tshard_identifier_encoded.len() as u32,\n\t\t\tbuffer.as_mut_ptr(),\n\t\t\tbuffer.len() as u32,\n\t\t\tsidechain_bridge,\n\t\t)\n\t}", "item_id": 3, "repo": "ajuna-network/worker", "file": "service/src/ocall_bridge/ffi/fetch_sidechain_blocks_from_peer.rs", "last_update_at": "2022-03-14T04:23:40+00:00"}
{"hexsha": "3a8f81119edd616c79cd978d6b2c44f01b72ce61", "ext": "rs", "lang": "Rust", "content": "pub fn gen(options: Options) {\n    fs::create_dir_all(options.out_dir.join(\"src/peripherals\")).unwrap();\n    fs::create_dir_all(options.out_dir.join(\"src/chips\")).unwrap();\n\n    let mut all_peripheral_versions: HashSet<(String, String)> = HashSet::new();\n    let mut chip_core_names: Vec<String> = Vec::new();\n\n    for chip_name in &options.chips {\n        println!(\"Generating {}...\", chip_name);\n\n        let chip = load_chip(&options, chip_name);\n        for (core_index, core) in chip.cores.iter().enumerate() {\n            let chip_core_name = match chip.cores.len() {\n                1 => chip_name.clone(),\n                _ => format!(\"{}-{}\", chip_name, core.name),\n            };\n\n            chip_core_names.push(chip_core_name.clone());\n            gen_chip(\n                &options,\n                &chip_core_name,\n                &chip,\n                core,\n                core_index,\n                &mut all_peripheral_versions,\n            )\n        }\n    }\n\n    for (module, version) in all_peripheral_versions {\n        println!(\"loading {} {}\", module, version);\n\n        let regs_path = Path::new(&options.data_dir)\n            .join(\"registers\")\n            .join(&format!(\"{}_{}.yaml\", module, version));\n\n        let mut ir: ir::IR = serde_yaml::from_reader(File::open(regs_path).unwrap()).unwrap();\n\n        transform::expand_extends::ExpandExtends {}\n            .run(&mut ir)\n            .unwrap();\n\n        transform::map_names(&mut ir, |k, s| match k {\n            transform::NameKind::Block => *s = format!(\"{}\", s),\n            transform::NameKind::Fieldset => *s = format!(\"regs::{}\", s),\n            transform::NameKind::Enum => *s = format!(\"vals::{}\", s),\n            _ => {}\n        });\n\n        transform::sort::Sort {}.run(&mut ir).unwrap();\n        transform::Sanitize {}.run(&mut ir).unwrap();\n\n        let items = generate::render(&ir, &gen_opts()).unwrap();\n        let mut file = File::create(\n            options\n                .out_dir\n                .join(\"src/peripherals\")\n                .join(format!(\"{}_{}.rs\", module, version)),\n        )\n        .unwrap();\n        let data = items.to_string().replace(\"] \", \"]\\n\");\n\n        // Remove inner attributes like #![no_std]\n        let re = Regex::new(\"# *! *\\\\[.*\\\\]\").unwrap();\n        let data = re.replace_all(&data, \"\");\n        file.write_all(data.as_bytes()).unwrap();\n    }\n\n    // Generate src/lib_inner.rs\n    const PATHS_MARKER: &[u8] = b\"// GEN PATHS HERE\";\n    let librs = include_bytes!(\"assets/lib_inner.rs\");\n    let i = bytes_find(librs, PATHS_MARKER).unwrap();\n    let mut paths = String::new();\n\n    for name in chip_core_names {\n        let x = name.to_ascii_lowercase();\n        write!(\n            &mut paths,\n            \"#[cfg_attr(feature=\\\"{}\\\", path = \\\"chips/{}/mod.rs\\\")]\",\n            x, x\n        )\n        .unwrap();\n    }\n    let mut contents: Vec<u8> = Vec::new();\n    contents.extend(&librs[..i]);\n    contents.extend(paths.as_bytes());\n    contents.extend(&librs[i + PATHS_MARKER.len()..]);\n    fs::write(options.out_dir.join(\"src\").join(\"lib_inner.rs\"), &contents).unwrap();\n\n    // Generate src/lib.rs\n    const CUT_MARKER: &[u8] = b\"// GEN CUT HERE\";\n    let librs = include_bytes!(\"../../stm32-metapac/src/lib.rs\");\n    let i = bytes_find(librs, CUT_MARKER).unwrap();\n    let mut contents: Vec<u8> = Vec::new();\n    contents.extend(&librs[..i]);\n    contents.extend(b\"include!(\\\"lib_inner.rs\\\");\\n\");\n    fs::write(options.out_dir.join(\"src\").join(\"lib.rs\"), contents).unwrap();\n\n    // Generate src/common.rs\n    fs::write(\n        options.out_dir.join(\"src\").join(\"common.rs\"),\n        generate::COMMON_MODULE,\n    )\n    .unwrap();\n\n    // Generate Cargo.toml\n    const BUILDDEP_BEGIN: &[u8] = b\"# BEGIN BUILD DEPENDENCIES\";\n    const BUILDDEP_END: &[u8] = b\"# END BUILD DEPENDENCIES\";\n\n    let mut contents = include_bytes!(\"../../stm32-metapac/Cargo.toml\").to_vec();\n    let begin = bytes_find(&contents, BUILDDEP_BEGIN).unwrap();\n    let end = bytes_find(&contents, BUILDDEP_END).unwrap() + BUILDDEP_END.len();\n    contents.drain(begin..end);\n    fs::write(options.out_dir.join(\"Cargo.toml\"), contents).unwrap();\n\n    // Generate build.rs\n    fs::write(\n        options.out_dir.join(\"build.rs\"),\n        include_bytes!(\"assets/build.rs\"),\n    )\n    .unwrap();\n}", "item_id": 5, "repo": "Liamolucko/embassy", "file": "stm32-metapac-gen/src/lib.rs", "last_update_at": "2022-03-30T17:57:24+00:00"}
{"hexsha": "04323b01537ade9c60e944be1605964e78b88da0", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn is_running(process_name: &str, print_pid: bool) -> bool {\n    let mut cmdline: Command = Command::new(String::from(\"pidof\"));\n\n    // return one PID only\n    cmdline.arg(\"--single-shot\");\n    if !print_pid {\n        // quiet mode, only set the exit code\n        cmdline.arg(\"-q\");\n    }\n\n    cmdline\n        .arg(process_name)\n        .status()\n        .expect(\"Could not execute `pidof` command.\")\n        .success()\n}", "item_id": 0, "repo": "thingsiplay/enjoy", "file": "src/settings/retroarch.rs", "last_update_at": "2022-03-14T03:52:10+00:00"}
{"hexsha": "d91ed3814ba30744bf9d2196311636223d81b5d7", "ext": "rs", "lang": "Rust", "content": "pub extern \"C\" fn all_generated_locations_for(\n    mappings: *mut Mappings<Observer>,\n    source: u32,\n    original_line: u32,\n    has_original_column: bool,\n    original_column: u32,\n) {\n    let this_scope = ();\n    let mappings = unsafe { mappings_mut(&this_scope, mappings) };\n\n    let original_column = if has_original_column {\n        Some(original_column)\n    } else {\n        None\n    };\n\n    for m in mappings.all_generated_locations_for(source, original_line, original_column) {\n        unsafe {\n            invoke_mapping_callback(m);\n        }\n    }\n}", "item_id": 8, "repo": "fitzgen/source-map-mappings", "file": "source-map-mappings-wasm-api/src/lib.rs", "last_update_at": "2022-03-26T06:43:13+00:00"}
{"hexsha": "56b1907de8e056b7b6eab055838b71af6c927f97", "ext": "rs", "lang": "Rust", "content": "fn test_get_preferred_horizontal_position4() {\n        // Case 4: X is moved to left and width is truncated\n        let area = gdk::Rectangle {\n            x: 0,\n            y: 0,\n            height: 0,\n            width: 20,\n        };\n\n        let pos = gdk::Rectangle {\n            x: 15,\n            y: 0,\n            width: 0,\n            height: 0,\n        };\n\n        let width = 150;\n        let (x, w) = get_preferred_horizontal_position(&area, &pos, width);\n        assert_eq!(x, 0);\n        assert_eq!(w, 20);\n    }", "item_id": 10, "repo": "vhakulinen/gnvim", "file": "src/ui/common.rs", "last_update_at": "2022-03-31T18:56:37+00:00"}
{"hexsha": "4502905b1b7a3f7cbe3f42818ecf4e134856bbe4", "ext": "rs", "lang": "Rust", "content": "fn bench_circuit1(b: &mut Bencher){\n    let qiskit = QiskitPython::new().unwrap();\n    let circuit = qiskit.get_qasm_circuit(\"example\", \"example/example.qasm\").unwrap();\n    let backend_circuit = qiskit.get_backend_circuit(circuit).unwrap();\n    let mut us = UnitarySimulator::new(backend_circuit.to_string()).unwrap();\n    b.iter(|| us.run());\n}", "item_id": 0, "repo": "atilag/unitary-quantum-simulator-rust", "file": "benches/unitary-simulator.rs", "last_update_at": "2022-03-28T20:51:01+00:00"}
{"hexsha": "7d188a17adbe857399b198225f6e002b1072dbd4", "ext": "rs", "lang": "Rust", "content": "fn audio(synth: &mut Synth, buffer: &mut Buffer) {\n    let midi_messages: Vec<Vec<u8>> = synth.midi_receiver.try_iter().collect();\n    for message in midi_messages {\n        if message.len() == 3 {\n            let step = message[1] as f32;\n            if message[0] == 144 {\n                synth\n                    .midi\n                    .midi_pitch\n                    .set_step(&mut synth.controls, step.into());\n                synth.karplus.on(&mut synth.controls, &mut synth.state);\n            } else if message[0] == 128 {\n                synth.karplus.off(&mut synth.controls);\n            }\n        }\n    }\n\n    let sample_rate = buffer.sample_rate() as f32;\n    for frame in buffer.frames_mut() {\n        let amp = synth.rack.mono(\n            &synth.controls,\n            &mut synth.state,\n            &mut synth.outputs,\n            &mut synth.buffers,\n            sample_rate,\n        );\n\n        for channel in frame {\n            *channel = amp;\n        }\n        synth.sender.send(amp).unwrap();\n    }\n}", "item_id": 2, "repo": "reedrosenbluth/oscen", "file": "nannou-apps/src/bin/pluck.rs", "last_update_at": "2022-03-28T11:14:42+00:00"}
{"hexsha": "f92b6391027f0df4b8d36a70e78db5fd285ad730", "ext": "rs", "lang": "Rust", "content": "async fn query_outside_projection_area_of_use_produces_empty_tiles() {\n        let mut exe_ctx = MockExecutionContext::default();\n        let query_ctx = MockQueryContext::default();\n\n        let m = GdalMetaDataStatic {\n            time: Some(TimeInterval::default()),\n            params: GdalDatasetParameters {\n                file_path: PathBuf::new(),\n                rasterband_channel: 1,\n                geo_transform: GdalDatasetGeoTransform {\n                    origin_coordinate: (166_021.44, 9_329_005.188).into(),\n                    x_pixel_size: (534_994.66 - 166_021.444) / 100.,\n                    y_pixel_size: -9_329_005.18 / 100.,\n                },\n                width: 100,\n                height: 100,\n                file_not_found_handling: FileNotFoundHandling::NoData,\n                no_data_value: Some(0.),\n                properties_mapping: None,\n                gdal_open_options: None,\n                gdal_config_options: None,\n            },\n            result_descriptor: RasterResultDescriptor {\n                data_type: RasterDataType::U8,\n                spatial_reference: SpatialReference::new(SpatialReferenceAuthority::Epsg, 32636)\n                    .into(),\n                measurement: Measurement::Unitless,\n                no_data_value: Some(0.),\n            },\n        };\n\n        let id: DatasetId = InternalDatasetId::new().into();\n        exe_ctx.add_meta_data(id.clone(), Box::new(m));\n\n        exe_ctx.tiling_specification =\n            TilingSpecification::new((0.0, 0.0).into(), [600, 600].into());\n\n        let output_shape: GridShape2D = [1000, 1000].into();\n        let output_bounds =\n            SpatialPartition2D::new_unchecked((-180., 0.).into(), (180., -90.).into());\n        let time_interval = TimeInterval::new_instant(1_388_534_400_000).unwrap(); // 2014-01-01\n\n        let gdal_op = GdalSource {\n            params: GdalSourceParameters {\n                dataset: id.clone(),\n            },\n        }\n        .boxed();\n\n        let initialized_operator = RasterOperator::boxed(Reprojection {\n            params: ReprojectionParams {\n                target_spatial_reference: SpatialReference::epsg_4326(),\n            },\n            sources: SingleRasterOrVectorSource {\n                source: gdal_op.into(),\n            },\n        })\n        .initialize(&exe_ctx)\n        .await\n        .unwrap();\n\n        let x_query_resolution = output_bounds.size_x() / output_shape.axis_size_x() as f64;\n        let y_query_resolution = output_bounds.size_y() / (output_shape.axis_size_y()) as f64;\n        let spatial_resolution =\n            SpatialResolution::new_unchecked(x_query_resolution, y_query_resolution);\n\n        let qp = initialized_operator\n            .query_processor()\n            .unwrap()\n            .get_u8()\n            .unwrap();\n\n        let result = qp\n            .raster_query(\n                QueryRectangle {\n                    spatial_bounds: output_bounds,\n                    time_interval,\n                    spatial_resolution,\n                },\n                &query_ctx,\n            )\n            .await\n            .unwrap()\n            .map(Result::unwrap)\n            .collect::<Vec<_>>()\n            .await;\n\n        assert_eq!(result.len(), 4);\n\n        for r in result {\n            assert!(r.is_empty());\n        }\n    }", "item_id": 10, "repo": "2younis/geoengine", "file": "operators/src/processing/reprojection.rs", "last_update_at": "2022-03-24T14:33:00+00:00"}
{"hexsha": "51adc990642f5fe3d7380e0c350b6e8335eb5923", "ext": "rs", "lang": "Rust", "content": "fn range() {\n        let reader = DataReaderBuilder::default()\n            .range(-1.0..1.0)\n            .build()\n            .unwrap();\n        let mut file = NamedTempFile::new().unwrap();\n        writeln!(file, \"1.3\").unwrap();\n        writeln!(file, \"2\").unwrap();\n        writeln!(file, \"-0.5\").unwrap();\n        writeln!(file, \"0.5\").unwrap();\n        let vec = reader.read(file.path().to_str().unwrap());\n        assert_eq!(vec, [-0.5, 0.5]);\n    }", "item_id": 4, "repo": "juan-leon/lowcharts", "file": "src/read/buckets.rs", "last_update_at": "2022-03-01T01:53:24+00:00"}
{"hexsha": "ba9177c4c780a99dd976f4d5e53230ffc5e40b89", "ext": "rs", "lang": "Rust", "content": "fn match_invalid_id() {\n        let doc = document();\n        let parent = create_element(doc.clone().downgrade(), \"h1\");\n        let child = create_element(doc.clone().downgrade(), \"button\");\n        Node::append_child(parent.clone(), child.clone());\n\n        let css = \"h1#name > button { color: red; }\";\n\n        let tokenizer = Tokenizer::new(css.chars());\n        let tokens = tokenizer.run();\n        let mut parser = Parser::<Token>::new(tokens);\n        let stylesheet = parser.parse_a_css_stylesheet();\n\n        let rule = stylesheet.first().unwrap();\n\n        match rule {\n            CSSRule::Style(style) => {\n                let selectors = &style.selectors;\n                assert!(!is_match_selectors(&child, selectors));\n            }\n        }\n    }", "item_id": 8, "repo": "ZeroX-DG/moon", "file": "components/style/src/selector_matching.rs", "last_update_at": "2022-03-29T02:27:14+00:00"}
{"hexsha": "b4aa6fd294238560ec0b536139b18353cf0107ac", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let ron_path = format!(\"{}/examples/config.{}\", env!(\"CARGO_MANIFEST_DIR\"), \"ron\");\n    match ExampleConfig::load(&ron_path) {\n        Ok(cfg) => {\n            println!(\"RON Config Result:\\n{:#?}\", cfg);\n\n            if let Err(e) = cfg.write_format(ConfigFormat::Ron, &ron_path) {\n                println!(\"Error:\\n{}\", e);\n            }\n        }\n        Err(e) => println!(\"{:?}\", e),\n    }\n\n    #[cfg(feature = \"json\")]\n    {\n        let json_path = format!(\"{}/examples/config.{}\", env!(\"CARGO_MANIFEST_DIR\"), \"json\");\n        match ExampleConfig::load(&json_path) {\n            Ok(cfg) => {\n                println!(\"JSON Config Result:\\n{:#?}\", cfg);\n\n                if let Err(e) = cfg.write_format(ConfigFormat::Json, &json_path) {\n                    println!(\"Error:\\n{}\", e);\n                }\n            }\n            Err(e) => println!(\"{:?}\", e),\n        }\n    }\n\n    #[cfg(feature = \"binary\")]\n    {\n        let binary_path = format!(\"{}/examples/config.{}\", env!(\"CARGO_MANIFEST_DIR\"), \"bin\");\n        match ExampleConfig::load(&binary_path) {\n            Ok(cfg) => {\n                println!(\"Binary Config Result:\\n{:#?}\", cfg);\n\n                if let Err(e) = cfg.write_format(ConfigFormat::Binary, &binary_path) {\n                    println!(\"Error:\\n{}\", e);\n                }\n            }\n            Err(e) => println!(\"{:?}\", e),\n        }\n    }\n}", "item_id": 0, "repo": "rdelfin/amethyst", "file": "amethyst_config/examples/main.rs", "last_update_at": "2022-03-31T09:08:50+00:00"}
{"hexsha": "89eedd9db8eec7a8c9a9770825d0b041b0616466", "ext": "rs", "lang": "Rust", "content": "fn derive_field(seed_hex: &[u8; 64], suffix: &[u8]) -> Field {\n    let mut hasher = Sha256::new();\n    hasher.update(seed_hex);\n    hasher.update(suffix);\n    Field::from_be_bytes_mod_order(hasher.finalize().as_ref())\n}", "item_id": 0, "repo": "oskarth/semaphore-rs", "file": "src/identity.rs", "last_update_at": "2022-03-21T22:35:05+00:00"}
{"hexsha": "1311f5f7ac6f38b5de162388caa8ef01656946cd", "ext": "rs", "lang": "Rust", "content": "fn init(env: NapiEnv, mut exports: JsObject) -> NapiResult<()> {\n    let obj = env.object()?;\n\n    obj.define_properties(&[DescriptorValueBuilder::new()\n        .with_utf8name(\"myvalue\")\n        .with_value(env.string(\"myvalue\")?)\n        .build()?])?;\n\n    obj.define_properties(&[DescriptorMethodBuilder::new()\n        .with_utf8name(\"mymethod\")\n        .with_method(move |this, ()| this.env().double(200.))\n        .build()?])?;\n\n    let value = Arc::new(Mutex::new(0.));\n    let value2 = value.clone();\n\n    obj.define_properties(&[DescriptorAccessorBuilder::new()\n        .with_utf8name(\"myaccessor\")\n        .with_getter(move |this| this.env().double(*value.lock().unwrap()))\n        .with_setter(move |_this: JsObject, n: JsNumber| {\n            let mut value = value2.lock().unwrap();\n            *value = n.get_value_double()?;\n            Ok(())\n        })\n        .build()?])?;\n\n    exports.set(\"obj\", obj)?;\n\n    Ok(())\n}", "item_id": 0, "repo": "uuhan/nodex", "file": "examples/descriptor/src/lib.rs", "last_update_at": "2022-03-04T04:37:59+00:00"}
{"hexsha": "77126f80e354ba337c44351fb14bf3807ae902a2", "ext": "rs", "lang": "Rust", "content": "fn reading_hashmap_set_from_lua_works() {\n        let mut lua = Lua::new();\n\n        lua.execute::<()>(r#\"v = { [1] = 2, [2] = 3, [3] = 4 }\"#).unwrap();\n\n        let read: HashMap<_, _> = lua.get(\"v\").unwrap();\n        assert_eq!(\n            read,\n            [2., 3., 4.].iter().enumerate()\n                .map(|(k, v)| (AnyHashableLuaValue::LuaNumber((k + 1) as i32), AnyLuaValue::LuaNumber(*v))).collect::<HashMap<_, _>>());\n    }", "item_id": 18, "repo": "Fuwn/hlua", "file": "hlua/src/rust_tables.rs", "last_update_at": "2022-03-03T12:26:24+00:00"}
{"hexsha": "ac096c0c3ed3e5b617cbc97791f86f7d40c63540", "ext": "rs", "lang": "Rust", "content": "fn commit_should_work() {\n\t\tlet mut ext = TestExternalities::<Blake2Hasher>::default();\n\t\text.set_storage(b\"doe\".to_vec(), b\"reindeer\".to_vec());\n\t\text.set_storage(b\"dog\".to_vec(), b\"puppy\".to_vec());\n\t\text.set_storage(b\"dogglesworth\".to_vec(), b\"cat\".to_vec());\n\t\tconst ROOT: [u8; 32] = hex!(\"0b33ed94e74e0f8e92a55923bece1ed02d16cf424e124613ddebc53ac3eeeabe\");\n\t\tassert_eq!(ext.storage_root(), H256::from(ROOT));\n\t}", "item_id": 0, "repo": "wm5713/blogs", "file": "learn substrate/substrate-1.0/core/state-machine/src/testing.rs", "last_update_at": "2022-02-14T16:09:57+00:00"}
{"hexsha": "2cecf69f696d8608c50dbf9dd4a7e2c2d038c650", "ext": "rs", "lang": "Rust", "content": "fn test_basic_expansion() {\n        let case = MacroCase {\n            args: vec![\n                MacroPattern::Syntax(\"test\".to_string()),\n                MacroPattern::Single(\"a\".to_string()),\n                MacroPattern::Single(\"b\".to_string()),\n                MacroPattern::Single(\"c\".to_string()),\n            ],\n            body: List::new(vec![\n                atom_identifier(\"fun-call\"),\n                atom_identifier(\"inserted-variable\"),\n                atom_identifier(\"a\"),\n                atom_identifier(\"b\"),\n                atom_identifier(\"c\"),\n            ])\n            .into(),\n        };\n\n        let input = List::new(vec![\n            atom_identifier(\"test\"),\n            atom_int(1),\n            atom_identifier(\"apple\"),\n            atom_int(2),\n        ]);\n\n        let expected: ExprKind = List::new(vec![\n            atom_identifier(\"fun-call\"),\n            atom_identifier(\"inserted-variable\"),\n            atom_int(1),\n            atom_identifier(\"apple\"),\n            atom_int(2),\n        ])\n        .into();\n\n        let output = case.expand(input, Span::new(0, 0)).unwrap();\n\n        assert_eq!(output, expected);\n    }", "item_id": 12, "repo": "mattwparas/Rucket", "file": "steel/src/parser/expander.rs", "last_update_at": "2022-03-27T22:44:14+00:00"}
{"hexsha": "d0b5b7c8dd58bbba9369419690d50cafc247e18c", "ext": "rs", "lang": "Rust", "content": "fn open_file_with(path: &str, opts: Vec<OpenOptions>) -> IO<GluonFile> {\n    let mut open_with = fs::OpenOptions::new();\n\n    for opt in opts {\n        match opt {\n            OpenOptions::Read => open_with.read(true),\n            OpenOptions::Write => open_with.write(true),\n            OpenOptions::Append => open_with.append(true),\n            OpenOptions::Truncate => open_with.truncate(true),\n            OpenOptions::Create => open_with.create(true),\n            OpenOptions::CreateNew => open_with.create_new(true),\n        };\n    }\n\n    open_with\n        .open(path)\n        .map(|file| GluonFile(Mutex::new(Some(file))))\n        .into()\n}", "item_id": 0, "repo": "sandkoan/gluon", "file": "src/std_lib/io.rs", "last_update_at": "2022-03-31T18:35:43+00:00"}
{"hexsha": "e880f876f91a94a74444433184a987b176ed7ce9", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    copy_after_move();\n    move_after_move();\n    borrow_after_move();\n\n    move_after_borrow();\n\n    copy_after_mut_borrow();\n    move_after_mut_borrow();\n    borrow_after_mut_borrow();\n    mut_borrow_after_borrow();\n\n    copy_after_move_nested();\n    move_after_move_nested();\n    borrow_after_move_nested();\n\n    move_after_borrow_nested();\n\n    copy_after_mut_borrow_nested();\n    move_after_mut_borrow_nested();\n    borrow_after_mut_borrow_nested();\n    mut_borrow_after_borrow_nested();\n}", "item_id": 16, "repo": "ohno418/rust", "file": "src/test/ui/borrowck/borrowck-box-sensitivity.rs", "last_update_at": "2022-03-31T23:26:40+00:00"}
{"hexsha": "37c4cb5bbcfed34b2a7de92da82bea807a2e2fe4", "ext": "rs", "lang": "Rust", "content": "fn can_generate_simple_enum() {\n    let mut lang = swift::Swift::new();\n    let mut g = Generator::new(\n        &mut lang,\n        Params {\n            use_marker: false,\n            swift_prefix: \"TypeShare\".to_string(),\n            java_package: \"\".to_string(),\n        },\n    );\n\n    let source = r##\"\n/// This is a comment.\npub enum Colors {\n\tRed = 0,\n\tBlue = 1,\n\tGreen = 2,\n}\n   \n\"##;\n\n    let mut out: Vec<u8> = Vec::new();\n    assert!(g.process_source(source.to_string(), &mut out).is_ok(), \"must be able to process the source\");\n    let result = String::from_utf8(out).unwrap();\n\n    let expected = format!(\n        \"/*\n Generated by typeshare {}\n*/\n\nimport Foundation\n\n/// This is a comment.\npublic enum TypeShareColors: Int, Codable {{\n\tcase Red = 0\n\tcase Blue = 1\n\tcase Green = 2\n}}\n\n\",\n        env!(\"CARGO_PKG_VERSION\")\n    );\n\n    if expected != result {\n        text_diff::print_diff(&expected, &result, \" \");\n    }\n    assert_eq!(expected, result);\n}", "item_id": 3, "repo": "1Password/typeshare", "file": "tests/swift_tests.rs", "last_update_at": "2022-02-20T01:39:55+00:00"}
{"hexsha": "0147b962adede16e0c5ac55fd62e2ebaf3ba4f6b", "ext": "rs", "lang": "Rust", "content": "pub async fn download_json(\n    client: &reqwest::Client,\n    urls: Vec<String>,\n) -> Result<Vec<serde_json::Value>, Box<dyn Error>> {\n    let vers: Vec<Result<serde_json::Value, Box<dyn Error>>> =\n        future::join_all(urls.into_iter().map(|url| async move {\n            let json = client\n                .get(url)\n                .send()\n                .await?\n                .error_for_status()?\n                .json()\n                .await?;\n            Ok(json)\n        }))\n        .await;\n\n    let mut vers2: Vec<serde_json::Value> = vec![];\n\n    for v in vers {\n        match v {\n            Ok(v) => vers2.push(v),\n            Err(e) => bail!(\"Cannot download JSON: {}\", e.to_string()),\n        };\n    }\n\n    Ok(vers2)\n}", "item_id": 4, "repo": "gaborcsardi/rim", "file": "src/download.rs", "last_update_at": "2022-03-26T04:25:34+00:00"}
{"hexsha": "8fd191f26a659e3244490ff32be4dc8e5ee85260", "ext": "rs", "lang": "Rust", "content": "fn test_extract_col(){\n        let m :  MatrixI64 = from_range_rw_i64(20, 20, -100, 400);\n        let v1   = m.view(2, 2, 6, 6);\n        println!(\"v1 : {}\", v1);\n        let c1 = v1.col(0);\n        let v2 = m.view(2,2, 6, 1);\n        assert_eq!(v2.to_matrix(), c1);\n    }", "item_id": 1, "repo": "TitanNotSoGreat/scirust", "file": "srmatrix/src/extract/view_extract.rs", "last_update_at": "2022-03-14T06:56:30+00:00"}
{"hexsha": "2f38966370425f82e5df53f513685abc4f2a8e89", "ext": "rs", "lang": "Rust", "content": "pub fn perform_transition_protection_in() {\n    // Hack: In an actual implementation, this if condition is bad. You would want to do this unconditionally or with cmovs\n    // But that's just engineering work\n    if get_should_lfence_in() {\n        unsafe {\n            invoke_lfence();\n        }\n    }\n\n    if get_should_flush_in() {\n        unsafe {\n            btb_flush();\n        }\n    }\n\n    if get_should_switch_mpk_in() {\n        // yes, this is mpk_allow_ALL_mem not \"mpk_allow_SBX_mem\"\n        // sbx is restricted to access only sbx memory through software sandboxing\n        // mpk is only to make sure the app doesn't get tricked to accessing sbx memory at an incorrect time\n        mpk_allow_all_mem();\n    }\n}", "item_id": 3, "repo": "PLSysSec/wasmtime-spectre", "file": "cranelift-spectre/src/runtime.rs", "last_update_at": "2022-01-24T08:46:42+00:00"}
{"hexsha": "ee27432789a626ce41445807e2d273279f356e2a", "ext": "rs", "lang": "Rust", "content": "async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n    let configuration = read_config(\"config.toml\");\n    let logging = configuration.bot.logging.enabled;\n\n    if logging {\n        LogTracer::init()?;\n\n        let base_level = configuration.bot.logging.level.as_str();\n\n        let level = match base_level {\n            \"error\" => Level::ERROR,\n            \"warn\" => Level::WARN,\n            \"info\" => Level::INFO,\n            \"debug\" => Level::DEBUG,\n            \"trace\" => Level::TRACE,\n            _ => Level::TRACE\n        };\n\n        let subscriber = FmtSubscriber::builder()\n            .with_target(false)\n            .with_max_level(level)\n            .with_env_filter(EnvFilter::from_default_env())\n            .finish();\n\n        tracing::subscriber::set_global_default(subscriber)?;\n\n        info!(\"Tracing initialized with logging level set to {}.\", level);\n    }\n\n    let appid = configuration.bot.discord.appid;\n    let token = configuration.bot.discord.token;\n    let prefix = configuration.bot.general.prefix.as_str();\n\n    let http = Http::new_with_token(&token);\n    let (owners, bot_id) = match http.get_current_application_info().await {\n        Ok(info) => {\n            let mut owners = HashSet::new();\n            owners.insert(info.owner.id);\n            (owners, info.id)\n        }\n        Err(why) => {\n            error!(\"Unable to retrieve application info: {:?}\", why);\n            return Ok(());\n        }\n    };\n\n    let framework = StandardFramework::new()\n        .configure(|configuration| {\n            configuration\n                .on_mention(Some(bot_id))\n                .prefix(prefix)\n                .ignore_webhooks(false)\n                .ignore_bots(true)\n                .no_dm_prefix(true)\n                .with_whitespace(true)\n                .owners(owners)\n                .case_insensitivity(true)\n        })\n        .after(after)\n        .prefix_only(prefix_only)\n        .on_dispatch_error(dispatch_error)\n        .group(&EXTRA_GROUP)\n        .group(&FUN_GROUP)\n        .group(&INFO_GROUP)\n        .group(&MODERATION_GROUP)\n        .group(&MUSIC_GROUP)\n        .group(&OWNER_GROUP)\n        .group(&SEARCH_GROUP)\n        .group(&SOCIAL_GROUP)\n        .group(&UTILITIES_GROUP)\n        .help(&HELP);\n\n    let mut client = ClientBuilder::new(&token)\n        .event_handler(Handler)\n        .application_id(appid)\n        .intents(GatewayIntents::all())\n        .framework(framework)\n        .await?;\n\n    {\n        let mut data = client.data.write().await;\n\n        let url = configuration.bot.database.url;\n        let pool = PgPoolOptions::new().max_connections(20).connect(&url).await?;\n        let http_client = Client::builder().user_agent(REQWEST_USER_AGENT).redirect(Policy::none()).build()?;\n\n        data.insert::<ConfigContainer>(read_config(\"config.toml\"));\n        data.insert::<DatabasePool>(pool);\n        data.insert::<ShardManagerContainer>(Arc::clone(&client.shard_manager));\n        data.insert::<ReqwestContainer>(http_client);\n\n        {\n            let id = configuration.api.music.spotify.client_id;\n            let secret = configuration.api.music.spotify.client_secret;\n            let credentials = aspotify::ClientCredentials { id, secret };\n            let spotify_client = aspotify::Client::new(credentials);\n            data.insert::<SpotifyContainer>(spotify_client);\n        }\n    }\n\n    if let Err(why) = client.start_autosharded().await {\n        eprintln!(\"An error occurred while running the client: {:?}\", why);\n    }\n\n    Ok(())\n}", "item_id": 0, "repo": "KamranMackey/Ellie", "file": "src/main.rs", "last_update_at": "2022-01-07T00:30:42+00:00"}
{"hexsha": "3c67406a5d63db2d4a8143cc65e8de185ef05aa1", "ext": "rs", "lang": "Rust", "content": "pub fn load_cell_textures(world: &mut World) -> CellTextures {\n    let loader = world.read_resource::<Loader>();\n    let mut counts = vec![];\n    for i in 0..=8 {\n        counts.push(loader.load(\n            format!(\"cell-{}.png\", i),\n            ImageFormat::default(),\n            (),\n            &world.read_resource::<AssetStorage<Texture>>(),\n        ));\n    }\n    CellTextures {\n        counts,\n        normal: loader.load(\n            \"cell.png\",\n            ImageFormat::default(),\n            (),\n            &world.read_resource::<AssetStorage<Texture>>(),\n        ),\n        blood: loader.load(\n            \"cell-blood.png\",\n            ImageFormat::default(),\n            (),\n            &world.read_resource::<AssetStorage<Texture>>(),\n        ),\n        error: loader.load(\n            \"cell-error.png\",\n            ImageFormat::default(),\n            (),\n            &world.read_resource::<AssetStorage<Texture>>(),\n        ),\n        mine: loader.load(\n            \"cell-mine.png\",\n            ImageFormat::default(),\n            (),\n            &world.read_resource::<AssetStorage<Texture>>(),\n        ),\n        flag: loader.load(\n            \"cell-flag.png\",\n            ImageFormat::default(),\n            (),\n            &world.read_resource::<AssetStorage<Texture>>(),\n        ),\n    }\n}", "item_id": 0, "repo": "asurance/mine-tutorial", "file": "tutorial_03/src/textures/cell.rs", "last_update_at": "2022-01-14T09:35:03+00:00"}
{"hexsha": "c314c25f00a350d2358a769a61cb28fe5d3be57f", "ext": "rs", "lang": "Rust", "content": "async fn should_get_service_graph() {\n    let client = XRayClient::new(Region::UsEast1);\n\n    let time = (OffsetDateTime::now_utc().unix_timestamp() - 30) as f64; // 30 seconds in the past\n    println!(\"{:?}\", time);\n\n    let request = GetServiceGraphRequest {\n        start_time: time - 600.0,\n        end_time: time,\n        ..Default::default()\n    };\n\n    let result = client.get_service_graph(request).await;\n    println!(\"{:#?}\", result);\n    result.unwrap();\n}", "item_id": 0, "repo": "grafbase/rusoto", "file": "integration_tests/tests/xray.rs", "last_update_at": "2022-03-30T16:11:18+00:00"}
{"hexsha": "4a9b1cafa156bde7c7ec9cf6f72803c89a3744b4", "ext": "rs", "lang": "Rust", "content": "fn main() {\n\n\t// variable of circle datatype\n\tlet mut circle1 = Circle {\n\t\tr : 10.0\n\t};\n\tprintln!(\"Area of circle {}\", circle1.area() );\n\t\n\t// variable of rectangle datatype\n\tlet mut rect = Rectangle {\n\t\th:10.0,b : 10.0\n\t};\n\tprintln!(\"Area of rectangle {}\", rect.area() );\n}", "item_id": 0, "repo": "Ngugisenior/studyGroupLessons", "file": "Rust-intro/code_samples/trait.rs", "last_update_at": "2022-01-28T06:37:43+00:00"}
{"hexsha": "250b75194e84bf3cafbc90f683d3599c9949052b", "ext": "rs", "lang": "Rust", "content": "fn test_new_with_default_error_rate() {\n        let mut b = BloomFilter::new_with_default_error_rate(20000, true);\n        assert_eq!(b.add(\"Test\".as_bytes()).unwrap(), true);\n        assert!(b.contains(\"Test\".as_bytes()));\n    }", "item_id": 7, "repo": "srinivasreddy/rust-bloomfilter", "file": "src/lib.rs", "last_update_at": "2022-01-31T08:47:48+00:00"}
{"hexsha": "c2238439db5c8b40ea7325b23ef33ef0136d69ce", "ext": "rs", "lang": "Rust", "content": "fn query() {\n        let rs = RangedStates::from_slice(&[(1..4, 1u8), (5..7, 2)]);\n        assert_eq!(rs.query(&(0..1), |v| *v), None);\n        assert_eq!(rs.query(&(1..3), |v| *v), Some(Ok(1)));\n        assert_eq!(rs.query(&(1..6), |v| *v), Some(Err(())));\n    }", "item_id": 1, "repo": "ghishadow/wgpu", "file": "wgpu-core/src/track/range.rs", "last_update_at": "2022-03-31T18:49:23+00:00"}
{"hexsha": "29a7f2b67b9000316d825f8935d2f7aa510c0392", "ext": "rs", "lang": "Rust", "content": "async fn get_proxies_gets_proxies_with_toxics() {\n        let _lock = MOCK_LOCK.lock().await;\n        let (stop, _stopper) = Stop::new();\n        let store = Store::new(stop, None);\n        let init_ctx = MockNoopRunner::initialize_proxy_context();\n        let run_ctx = MockNoopRunner::run_proxy_context();\n        init_ctx.expect().returning(|config, _initial_toxics| {\n            let listener = MockNoopListener::default();\n            let proxy_info = SharedProxyInfo {\n                state: Arc::new(ProxyState::new(Toxics {\n                    upstream: vec![Toxic {\n                        kind: ToxicKind::Latency {\n                            latency: 500,\n                            jitter: 42,\n                        },\n                        name: format!(\"{}tox1\", config.name),\n                        toxicity: 0.67,\n                        direction: StreamDirection::Upstream,\n                    }],\n                    downstream: Vec::new(),\n                })),\n                config: Arc::new(config),\n            };\n            Ok((listener, proxy_info))\n        });\n\n        run_ctx.expect().returning(\n            move |_listener: MockNoopListener, _info, _event_receiver, _stop, _closer| Ok(()),\n        );\n\n        populate_store(&store).await;\n\n        let result = store.get_proxies().await.unwrap();\n        assert_eq!(3, result.len());\n        let p1 = result.iter().find(|el| el.proxy.name == \"foo\").unwrap();\n        let p2 = result.iter().find(|el| el.proxy.name == \"bar\").unwrap();\n        let p3 = result.iter().find(|el| el.proxy.name == \"baz\").unwrap();\n        assert_eq!(1, p1.toxics.len());\n        assert_eq!(\"footox1\", p1.toxics[0].get_name());\n        assert_eq!(\"bartox1\", p2.toxics[0].get_name());\n        assert_eq!(\"baztox1\", p3.toxics[0].get_name());\n    }", "item_id": 4, "repo": "oguzbilgener/noxious", "file": "server/src/store.rs", "last_update_at": "2022-03-22T09:14:34+00:00"}
{"hexsha": "cafe015af5e186644b3fbfbd475077a46394c335", "ext": "rs", "lang": "Rust", "content": "fn test_public_xor() {\n    let seq1 = PublicByteSeq::from_hex(\"3544de28f9d7d48ee7b318f6c541ff35\");\n    let seq2 = PublicByteSeq::from_hex(\"a4b13aa347b72f6c22870170fcb0cda3\");\n\n    let xor_output = seq1 ^ seq2; // output of XOR to be checked for correctness\n    let expected = PublicByteSeq::from_hex(\"91f5e48bbe60fbe2c534198639f13296\");\n\n    assert_eq!(expected, xor_output);\n}", "item_id": 5, "repo": "tanmay2004/hacspec", "file": "lib/tests/test_public_seq.rs", "last_update_at": "2022-03-24T22:05:37+00:00"}
{"hexsha": "5b32d1e6c1940d90f8cbee20a89569b9377e63cb", "ext": "rs", "lang": "Rust", "content": "fn get_node(ctx: &Context, args: Vec<String>) -> RedisResult {\n    ctx.auto_memory();\n\n    let mut parsed = GET_NODE_CMD.with(|cmd| cmd.parse_args(args))?;\n\n    let index_suffix = parsed.remove(\"index\").unwrap().as_string()?;\n    let node_suffix = parsed.remove(\"node\").unwrap().as_string()?;\n\n    let node_name = format!(\"{}.{}.{}\", PREFIX, index_suffix, node_suffix);\n\n    ctx.log_debug(format!(\"get key: {}\", node_name).as_str());\n\n    let key = ctx.open_key(&node_name);\n\n    let value = key\n        .get_value::<NodeRedis>(&HNSW_NODE_REDIS_TYPE)?\n        .ok_or_else(|| format!(\"Node: {} does not exist\", &node_name))?;\n\n    Ok(value.into())\n}", "item_id": 9, "repo": "zhao-lang/redis_hnsw", "file": "src/lib.rs", "last_update_at": "2022-03-29T15:25:19+00:00"}
{"hexsha": "0b0affba01c6539766f8537df100100d0621917c", "ext": "rs", "lang": "Rust", "content": "fn test_gt_insensitive() {\n        let test = r#\"gT 5\"#;\n        let want = Token::Gt;\n        match scan(test).get(0) {\n            Some(t) => assert_eq!(*t, want),\n            _ => panic!(\"no token\"),\n        }\n    }", "item_id": 23, "repo": "gracig/bda", "file": "bdaindex/src/bql/scanner.rs", "last_update_at": "2022-02-04T13:44:40+00:00"}
{"hexsha": "baf3f78ce9b4811ed2e529fe17ad489708b108bb", "ext": "rs", "lang": "Rust", "content": "fn test_regex_lit() {\n        assert_json_snapshot!(parse_literal(\"/abc/g\".into()).unwrap().1);\n        assert_json_snapshot!(parse_literal(r#\"/abc\\\\/g\"#.into()).unwrap().1);\n        assert_json_snapshot!(parse_literal(r#\"/\\\\\\//g\"#.into()).unwrap().1);\n        assert_json_snapshot!(parse_literal(r#\"/[^/]*$/\"#.into()).unwrap().1);\n    }", "item_id": 0, "repo": "lukechu10/almond", "file": "src/parser/regex.rs", "last_update_at": "2022-02-22T21:19:31+00:00"}
{"hexsha": "9fd8aaaaeba21fd589ff27e97e9560be85a6b6ff", "ext": "rs", "lang": "Rust", "content": "fn test_is_empty() {\n        let mut stack: Stack = Stack::new();\n        assert!(stack.is_empty());\n\n        stack.push(Value::new(\"Hello!\".to_string()));\n        stack.push(Value::new(42));\n        assert!(!stack.is_empty());\n\n        stack.pop().ok();\n        assert!(!stack.is_empty());\n\n        stack.initialize();\n        assert!(stack.is_empty());\n    }", "item_id": 3, "repo": "Pagliacii/sicp-reg-machine", "file": "src/machine/stack.rs", "last_update_at": "2022-03-05T02:48:07+00:00"}
{"hexsha": "20b41bbe0060e4b74d291a9329ed6b1180dbb5ce", "ext": "rs", "lang": "Rust", "content": "pub async fn test_ibc_transfer(\n    contact: &Contact,                     // Src chain's deep_space client\n    dst_bank_qc: BankQueryClient<Channel>, // Dst chain's GRPC x/bank query client\n    dst_ibc_transfer_qc: IbcTransferQueryClient<Channel>, // Dst chain's GRPC ibc-transfer query client\n    sender: CosmosPrivateKey,                             // The Src chain's funds sender\n    receiver: CosmosAddress,                              // The Dst chain's funds receiver\n    channel_id: String,       // The Src chain's ibc channel connecting to Dst\n    packet_timeout: Duration, // Used to create ibc-transfer timeout-timestamp\n) {\n    let sender_address = sender.to_address(&*ADDRESS_PREFIX).unwrap().to_string();\n    let pre_bal = get_ibc_balance(\n        receiver,\n        (*STAKING_TOKEN).to_string(),\n        None,\n        dst_bank_qc.clone(),\n        dst_ibc_transfer_qc.clone(),\n        None,\n    )\n    .await;\n\n    let timeout_timestamp = SystemTime::now()\n        .add(packet_timeout)\n        .duration_since(SystemTime::UNIX_EPOCH)\n        .unwrap()\n        .as_nanos() as u64;\n    info!(\"Calculated 150 minutes from now: {:?}\", timeout_timestamp);\n    let amount: Uint256 = one_atom();\n    let msg_transfer = MsgTransfer {\n        source_port: \"transfer\".to_string(),\n        source_channel: channel_id,\n        token: Some(Coin {\n            amount: amount.clone().to_string(),\n            denom: STAKING_TOKEN.as_str().to_string(),\n        }),\n        sender: sender_address,\n        receiver: receiver.to_string(),\n        timeout_height: None,\n        timeout_timestamp, // 150 minutes from now\n    };\n    info!(\"Submitting MsgTransfer {:?}\", msg_transfer);\n    let msg_transfer = Msg::new(MSG_TRANSFER_TYPE_URL, msg_transfer);\n    let send_res = contact\n        .send_message(\n            &[msg_transfer],\n            Some(\"Test Relaying\".to_string()),\n            &[DSCoin {\n                amount: 100u16.into(),\n                denom: (*STAKING_TOKEN).to_string(),\n            }],\n            Some(OPERATION_TIMEOUT),\n            sender,\n        )\n        .await;\n    info!(\"Sent MsgTransfer with response {:?}\", send_res);\n\n    // Give the ibc-relayer a bit of time to work in the event of multiple runs\n    delay_for(Duration::from_secs(10)).await;\n\n    let start_bal = Some(match pre_bal.clone() {\n        Some(coin) => Uint256::from_str(&coin.amount).unwrap(),\n        None => 0u8.into(),\n    });\n\n    let post_bal = get_ibc_balance(\n        receiver,\n        (*STAKING_TOKEN).to_string(),\n        start_bal,\n        dst_bank_qc,\n        dst_ibc_transfer_qc,\n        None,\n    )\n    .await;\n    match (pre_bal, post_bal) {\n        (None, None) => {\n            panic!(\"Failed to transfer stake to ibc-test-1 user {}!\", receiver,);\n        }\n        (None, Some(post)) => {\n            if Uint256::from_str(&post.amount).unwrap() != amount {\n                panic!(\n                    \"Incorrect ibc stake balance for user {}: actual {} != expected {}\",\n                    receiver, post.amount, amount,\n                );\n            }\n            info!(\n                \"Successfully transfered {} stake (aka {}) to ibc-test-1!\",\n                amount, post.denom\n            );\n        }\n        (Some(pre), Some(post)) => {\n            let pre_amt = Uint256::from_str(&pre.amount).unwrap();\n            let post_amt = Uint256::from_str(&post.amount).unwrap();\n            if post_amt < pre_amt || post_amt - pre_amt.clone() != amount.clone() {\n                panic!(\n                    \"Incorrect ibc stake balance for user {}: actual {} != expected {}\",\n                    receiver,\n                    post.amount,\n                    (pre_amt + amount),\n                );\n            }\n            info!(\n                \"Successfully transfered {} stake (aka {}) to ibc-test-1!\",\n                amount, post.denom\n            );\n        }\n        (Some(_), None) => {\n            panic!(\n                \"User wound up with no balance after ibc transfer? {}\",\n                receiver,\n            );\n        }\n    }\n}", "item_id": 1, "repo": "umee-network/Gravity-Bridge", "file": "orchestrator/test_runner/src/ibc_auto_forward.rs", "last_update_at": "2022-03-28T11:12:20+00:00"}
{"hexsha": "b57933639403c3b508e1442d15180d63b4b76bcf", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_TPM20_ClockRateAdjust_Out() {\n    assert_eq!(::std::mem::size_of::<TPM20_ClockRateAdjust_Out>() , 16usize ,\n               concat ! (\n               \"Size of: \" , stringify ! ( TPM20_ClockRateAdjust_Out ) ));\n    assert_eq! (::std::mem::align_of::<TPM20_ClockRateAdjust_Out>() , 4usize ,\n                concat ! (\n                \"Alignment of \" , stringify ! ( TPM20_ClockRateAdjust_Out )\n                ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) . tag as *\n                const _ as usize } , 0usize , concat ! (\n                \"Alignment of field: \" , stringify ! (\n                TPM20_ClockRateAdjust_Out ) , \"::\" , stringify ! ( tag ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) .\n                responseSize as * const _ as usize } , 4usize , concat ! (\n                \"Alignment of field: \" , stringify ! (\n                TPM20_ClockRateAdjust_Out ) , \"::\" , stringify ! (\n                responseSize ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) .\n                responseCode as * const _ as usize } , 8usize , concat ! (\n                \"Alignment of field: \" , stringify ! (\n                TPM20_ClockRateAdjust_Out ) , \"::\" , stringify ! (\n                responseCode ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) . otherData\n                as * const _ as usize } , 12usize , concat ! (\n                \"Alignment of field: \" , stringify ! (\n                TPM20_ClockRateAdjust_Out ) , \"::\" , stringify ! ( otherData )\n                ));\n}", "item_id": 223, "repo": "genofire/tss-sapi", "file": "src/bindings.rs", "last_update_at": "2022-02-20T19:41:53+00:00"}
{"hexsha": "04c8c1f635c10d014cfbe889550fb77665f38a00", "ext": "rs", "lang": "Rust", "content": "fn delete_run(m: &ArgMatches<'_>) -> Result<(), Error> {\n    // The unwrap is ok, because NAME is a required argument.\n    let name = m.value_of(\"NAME\").unwrap();\n    let mut repo = crate::open_repo()?;\n    repo.delete_branch(name)?;\n    repo.write()?;\n    eprintln!(\"Deleted branch \\\"{}\\\"\", name);\n    Ok(())\n}", "item_id": 1, "repo": "jneem/jp", "file": "ojo/src/branch.rs", "last_update_at": "2022-03-27T21:34:27+00:00"}
{"hexsha": "cfbe46cb9076cdae947716442ead1ecc815a6423", "ext": "rs", "lang": "Rust", "content": "fn b42_ammonia_clean(b: &mut Bencher) {\n    let mut frag = String::new();\n    sample_file(\"github-dekellum-frag.html\")\n        .expect(\"sample_file\")\n        .read_to_string(&mut frag)\n        .expect(\"read_to_string\");\n    let frag = frag.trim();\n    let amm = ammonia::Builder::default();\n    b.iter(|| {\n        let doc = amm.clean(&frag);\n        let out = doc.to_string();\n        assert_eq!(out.len(), 52062, /*\"[[[{}]]]\", out*/);\n    });\n}", "item_id": 2, "repo": "joshstoik1/marked", "file": "ammonia-compare/src/lib.rs", "last_update_at": "2022-03-24T08:41:26+00:00"}
{"hexsha": "ab6e81d1ccbbe7f48bca5ffaf070d494000bd8ac", "ext": "rs", "lang": "Rust", "content": "fn compare_num_attrs_layout() {\n    let schema = StandardSchema::NumAttrs(3);\n\n    let greater_schemas = vec![StandardSchema::Layout {\n        items: vec![],\n        exhaustive: false,\n    }];\n    let not_related_schemas = vec![\n        StandardSchema::Layout {\n            items: vec![],\n            exhaustive: true,\n        },\n        StandardSchema::Layout {\n            items: vec![(\n                ItemSchema::Field(SlotSchema::new(\n                    StandardSchema::OfKind(ValueKind::Text),\n                    StandardSchema::OfKind(ValueKind::Text),\n                )),\n                false,\n            )],\n            exhaustive: false,\n        },\n        StandardSchema::Layout {\n            items: vec![\n                (\n                    ItemSchema::Field(SlotSchema::new(\n                        StandardSchema::OfKind(ValueKind::Text),\n                        StandardSchema::OfKind(ValueKind::Text),\n                    )),\n                    true,\n                ),\n                (\n                    ItemSchema::Field(SlotSchema::new(\n                        StandardSchema::OfKind(ValueKind::Text),\n                        StandardSchema::OfKind(ValueKind::Text),\n                    )),\n                    true,\n                ),\n            ],\n            exhaustive: false,\n        },\n    ];\n\n    assert_less_than(schema.clone(), greater_schemas);\n    assert_not_related(schema, not_related_schemas);\n}", "item_id": 146, "repo": "swimos/swim-rust", "file": "api/swim_schema/src/schema/tests/mod.rs", "last_update_at": "2022-02-10T00:59:19+00:00"}
{"hexsha": "8b41703798c5f45d2dc4ef7b63d343671e6f8dd8", "ext": "rs", "lang": "Rust", "content": "pub fn test_033_clobs() -> HdbResult<()> {\n    let mut log_handle = test_utils::init_logger();\n    let start = std::time::Instant::now();\n    let mut connection = test_utils::get_authenticated_connection()?;\n\n    if !prepare_test(&mut connection)? {\n        info!(\"TEST ABANDONED since database does not support CLOB columns\");\n        return Ok(());\n    }\n\n    let (blabla, fingerprint) = get_blabla();\n    test_clobs(&mut log_handle, &mut connection, &blabla, &fingerprint)?;\n    test_streaming(&mut log_handle, &mut connection, blabla, &fingerprint)?;\n    test_zero_length(&mut log_handle, &mut connection)?;\n\n    test_utils::closing_info(connection, start)\n}", "item_id": 0, "repo": "emabee/rust-hdbconnect", "file": "tests/test_033_clobs.rs", "last_update_at": "2022-03-21T20:21:28+00:00"}
{"hexsha": "5128af75d30e943fd2c2d2ec6394af47bbbbfdbb", "ext": "rs", "lang": "Rust", "content": "fn spawn_clone_with_ref_local()\n{\n\tlet (tx, mut rx) = mpsc::channel( 1 );\n\tlet exec         = Bindgen::default();\n\n\tincrement_clone_local( 4, &exec, tx );\n\n\tlet fut = async move\n\t{\n\t\tlet result = rx.next().await.expect( \"Some\" );\n\n\t\tassert_eq!( 5u8, result );\n\t};\n\n\texec.spawn_local( fut ).expect( \"spawn future\" );\n}", "item_id": 11, "repo": "najamelan/async_executors", "file": "tests/bindgen.rs", "last_update_at": "2022-03-16T09:52:02+00:00"}
{"hexsha": "74b1f304d6518fee8db1a5be89de4a5213f4cba9", "ext": "rs", "lang": "Rust", "content": "pub fn chmod(path: impl AsRef<Path>, mode: u32) -> Result<()> {\n    let path = CString::new(path.as_ref().to_string_lossy().to_string())?;\n    let res = unsafe { nix::libc::chmod(path.as_ptr(), mode) };\n    nix::errno::Errno::result(res).map(drop)?;\n\n    Ok(())\n}", "item_id": 0, "repo": "tiqwab/tftpff", "file": "src/privilege.rs", "last_update_at": "2022-01-22T02:11:26+00:00"}
{"hexsha": "1751a92244b9b42fd82dc86705f209fa7f258188", "ext": "rs", "lang": "Rust", "content": "fn test_is_container() {\n        let docker_cgroup = r#\"\n12:cpu,cpuacct:/docker/c6fa62a9938149f6098fd0cdaffc9cdf0f526f25d97b5f6e2a4cc1fccc7f7ce1\n11:perf_event:/docker/c6fa62a9938149f6098fd0cdaffc9cdf0f526f25d97b5f6e2a4cc1fccc7f7ce1\n10:rdma:/\"#;\n        assert!(is_container(docker_cgroup));\n        let init_cgroup = r#\"\n12:cpu,cpuacct:/\n11:perf_event:/\n0::/init.scope\"#;\n        assert!(!is_container(init_cgroup));\n        let k8s_cgroup = r#\"\n12:hugetlb:/kubepods/besteffort/poda00e29fd-7bbd-11e9-8679-fa163ea7e3b8/c4b1403f3d9c7ce261be851df71d9a9773c53419075ccda39ae8fe6a39fd2eb1\n11:cpuset:/kubepods/besteffort/poda00e29fd-7bbd-11e9-8679-fa163ea7e3b8/c4b1403f3d9c7ce261be851df71d9a9773c53419075ccda39ae8fe6a39fd2eb1\"#;\n        assert!(is_container(k8s_cgroup));\n    }", "item_id": 2, "repo": "nui/nmk", "file": "nmk/src/nmk/container.rs", "last_update_at": "2022-01-25T15:23:06+00:00"}
{"hexsha": "b0be92bd7e809e3d31232bf0af30c108e80f5a91", "ext": "rs", "lang": "Rust", "content": "fn to_bytes(fs: &[Fraction]) -> Vec<u8> {\n        let mut res = Vec::new();\n        for f in fs {\n            res.extend_from_slice(&f.0);\n        }\n        res\n    }", "item_id": 1, "repo": "cloudpeers/tlfs", "file": "crdt/src/fraction.rs", "last_update_at": "2022-03-22T10:08:47+00:00"}
{"hexsha": "1eb3faad36d9c99107eeb632258a82f0135079a6", "ext": "rs", "lang": "Rust", "content": "fn test_volume_changes() -> Result<(), Error> {\n        let mut exec = fasync::Executor::new().expect(\"executor needed\");\n        let (mut settings_requests, avrcp_requests, _stop_sender, relay_fut) =\n            setup_volume_relay()?;\n\n        pin_mut!(relay_fut);\n\n        let res = exec.run_until_stalled(&mut relay_fut);\n        assert!(res.is_pending());\n\n        let (volume_client, watch_responder) =\n            finish_relay_setup(&mut relay_fut, &mut exec, avrcp_requests, &mut settings_requests);\n\n        let volume_get_fut = volume_client.get_current_volume();\n        pin_mut!(volume_get_fut);\n\n        let res = exec.run_until_stalled(&mut relay_fut);\n        assert!(res.is_pending());\n\n        // Volume get should return immediately with the initial volume (0.8 -> 100)\n        match exec.run_until_stalled(&mut volume_get_fut) {\n            Poll::Ready(Ok(vol)) => {\n                assert_eq!(INITIAL_AVRCP_VOLUME, vol);\n            }\n            x => panic!(\"Expected get_current_volume to be finished, but got {:?}\", x),\n        };\n\n        let volume_hanging_fut = volume_client.on_volume_changed();\n        pin_mut!(volume_hanging_fut);\n\n        let res = exec.run_until_stalled(&mut relay_fut);\n        assert!(res.is_pending());\n\n        // The OnVolumeChanged request should return immediately the first time.\n        match exec.run_until_stalled(&mut volume_hanging_fut) {\n            Poll::Ready(Ok(vol)) => {\n                assert_eq!(INITIAL_AVRCP_VOLUME, vol);\n            }\n            x => {\n                panic!(\"Expected on_volume_changed to be finished the first time, but got {:?}\", x)\n            }\n        };\n\n        let volume_hanging_fut = volume_client.on_volume_changed();\n        pin_mut!(volume_hanging_fut);\n\n        let res = exec.run_until_stalled(&mut relay_fut);\n        assert!(res.is_pending());\n\n        // The next OnVolumeChanged request shouldn't resolve because the volume hasn't changed.\n        match exec.run_until_stalled(&mut volume_hanging_fut) {\n            Poll::Pending => {}\n            x => {\n                panic!(\"Expected on_volume_changed to be hanging the second time, but got {:?}\", x)\n            }\n        };\n\n        let res = exec.run_until_stalled(&mut relay_fut);\n        assert!(res.is_pending());\n\n        // When a new volume happens as a result, it's returned.\n        respond_to_audio_watch(watch_responder, NEW_MEDIA_VOLUME);\n\n        let res = exec.run_until_stalled(&mut relay_fut);\n        assert!(res.is_pending());\n\n        match exec.run_until_stalled(&mut volume_hanging_fut) {\n            Poll::Ready(Ok(vol)) => assert_eq!(vol, NEW_AVRCP_VOLUME),\n            x => panic!(\n                \"Expected on_volume_changed to be responded to after change but got: {:?}\",\n                x\n            ),\n        };\n\n        let _watch_responder = expect_audio_watch(&mut exec, &mut settings_requests);\n\n        Ok(())\n    }", "item_id": 6, "repo": "gobftald/fuchsia-rpi", "file": "src/connectivity/bluetooth/profiles/bt-a2dp-sink/src/volume_relay.rs", "last_update_at": "2022-01-20T15:42:41+00:00"}
{"hexsha": "d9b012ea4f09039f57924ced0af1f028e5bed835", "ext": "rs", "lang": "Rust", "content": "fn test_seq0255_bool() {\n            let s: Seq0255<bool> = Seq0255::new(vec![true, false, true]).unwrap();\n\n            let expected = Test { a: s };\n\n            #[cfg(not(feature = \"with_serde\"))]\n            let mut bytes = to_bytes(expected.clone()).unwrap();\n            #[cfg(feature = \"with_serde\")]\n            let mut bytes = to_bytes(&expected.clone()).unwrap();\n\n            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n\n            assert_eq!(deserialized, expected);\n        }", "item_id": 10, "repo": "stratum-mining/bitcoin", "file": "src/rusty/binary-sv2/binary-sv2/src/lib.rs", "last_update_at": "2022-03-29T14:42:33+00:00"}
{"hexsha": "a0351f349b997fec95b9cb84de06206dddeada89", "ext": "rs", "lang": "Rust", "content": "pub fn fix_syntax_and_write(out_path: &Path, contents: String) {\n    // move(x) ~> move x\n    let contents = replace!(contents, r\"move\\((\\w+)\\)\", \"move $1\");\n    // copy(x) ~> copy x\n    let contents = replace!(contents, r\"copy\\((\\w+)\\)\", \"copy $1\");\n    // resource StructName ~> resource struct StructName\n    let contents = replace!(contents, r\"resource\\s+(\\w)\", \"resource struct $1\");\n    // copyable ~> copyable\n    let contents = replace!(contents, r\":\\s*copyable\", NoExpand(\": copyable\"));\n    // import ~> use\n    let contents = replace!(contents, r\"import\", NoExpand(\"use\"));\n    // Self. is unnecessary\n    let contents = replace!(contents, r\"Self\\.\", NoExpand(\"\"));\n    // Module|Address. ~> Module|Address::\n    let contents = replace!(contents, r\"(([A-Z]\\w*)|(\\}\\})|(0x\\d+))\\.\", \"$1::\");\n    // add fun keyword to functions\n    let contents = replace!(\n        contents,\n        r\"(((public|native| )*))(\\w+\\(.*\\).*\\{)\",\n        |cap: &Captures| format!(\"{}fun {}\", &cap[1], &cap[4])\n    );\n    fs::write(out_path, contents.as_bytes()).unwrap();\n}", "item_id": 0, "repo": "BlockSuite/libra", "file": "language/move-lang/src/ir_translation.rs", "last_update_at": "2022-03-31T23:25:13+00:00"}
{"hexsha": "f9acdd1be3b820ad6f684d935997e95cb5640a75", "ext": "rs", "lang": "Rust", "content": "fn read_req(p: &mut ServerProtocol, src: &[u8], read_size: usize) -> TestRequest {\n        const READ_SIZE_MAX: usize = 1024;\n        const LOOPS_MAX: u32 = 20;\n\n        assert!(read_size <= READ_SIZE_MAX);\n\n        assert_eq!(p.state(), ServerState::ReceivingRequest);\n\n        let mut rbuf = io::Cursor::new(src);\n\n        let mut result = TestRequest::new();\n\n        assert_eq!(p.state(), ServerState::ReceivingRequest);\n\n        let mut headers = [httparse::EMPTY_HEADER; HEADERS_MAX];\n\n        let req = p.recv_request(&mut rbuf, &mut headers).unwrap().unwrap();\n\n        result.method = String::from(req.method);\n        result.uri = String::from(req.uri);\n\n        for h in req.headers {\n            let name = String::from(h.name);\n            let value = Vec::from(h.value);\n            result.headers.push((name, value));\n        }\n\n        for _ in 0..LOOPS_MAX {\n            if p.state() != ServerState::ReceivingBody {\n                break;\n            }\n\n            let mut buf = [0; READ_SIZE_MAX];\n\n            let (size, trailing_headers) = p\n                .recv_body(&mut rbuf, &mut buf[..read_size], &mut headers)\n                .unwrap();\n\n            result.body.extend_from_slice(&buf[..size]);\n\n            if let Some(trailing_headers) = trailing_headers {\n                for h in trailing_headers {\n                    let name = String::from(h.name);\n                    let value = Vec::from(h.value);\n                    result.trailing_headers.push((name, value));\n                }\n            }\n        }\n\n        result.persistent = p.is_persistent();\n\n        assert_eq!(p.state(), ServerState::AwaitingResponse);\n\n        return result;\n    }", "item_id": 5, "repo": "fanout/condure", "file": "src/http1.rs", "last_update_at": "2022-02-03T13:54:57+00:00"}
{"hexsha": "2e3d354c774b7741c3776cd8d01c88f2eb41bb6b", "ext": "rs", "lang": "Rust", "content": "fn update_consensus_evidence_params() {\n        let mut deps = mock_deps_tgrade();\n        let env = mock_env();\n        proposals()\n            .save(\n                &mut deps.storage,\n                1,\n                &Proposal {\n                    title: \"UnpinCodes\".to_owned(),\n                    description: \"UnpinCodes testing proposal\".to_owned(),\n                    created_by: \"mock_person\".to_owned(),\n                    start_height: env.block.height,\n                    expires: Expiration::at_timestamp(env.block.time.plus_seconds(66666)),\n                    proposal: ValidatorProposal::UpdateConsensusEvidenceParams {\n                        max_age_num_blocks: Some(10),\n                        max_age_duration: Some(100),\n                        max_bytes: Some(256),\n                    },\n                    status: Status::Passed,\n                    rules: VotingRules {\n                        voting_period: 1,\n                        quorum: Decimal::percent(50),\n                        threshold: Decimal::percent(40),\n                        allow_end_early: true,\n                    },\n                    total_points: 20,\n                    votes: Votes {\n                        yes: 20,\n                        no: 0,\n                        abstain: 0,\n                        veto: 0,\n                    },\n                },\n            )\n            .unwrap();\n\n        let res = execute_execute(deps.as_mut(), env, mock_info(\"sender\", &[]), 1).unwrap();\n        assert_eq!(\n            res.messages,\n            vec![SubMsg::new(CosmosMsg::Custom(TgradeMsg::ConsensusParams(\n                ConsensusParams {\n                    block: None,\n                    evidence: Some(EvidenceParams {\n                        max_age_num_blocks: Some(10),\n                        max_age_duration: Some(100),\n                        max_bytes: Some(256),\n                    }),\n                }\n            )))]\n        );\n    }", "item_id": 8, "repo": "confio/poe-contracts", "file": "contracts/tgrade-validator-voting/src/contract.rs", "last_update_at": "2022-03-31T16:43:24+00:00"}
{"hexsha": "8dcf8e6347f1b9f6a3759594c30ed42aaafaabb2", "ext": "rs", "lang": "Rust", "content": "fn test_decimal_round_result_zero() {\n        let x = Decimal::new_raw(12345, 2);\n        let y = x.round(-3);\n        assert_eq!(y.coefficient(), 0);\n        assert_eq!(y.n_frac_digits(), 0);\n        let y = x.round(-37);\n        assert_eq!(y.coefficient(), 0);\n        assert_eq!(y.n_frac_digits(), 0);\n        let y = x.checked_round(-9).unwrap();\n        assert_eq!(y.coefficient(), 0);\n        assert_eq!(y.n_frac_digits(), 0);\n        let y = x.checked_round(-42).unwrap();\n        assert_eq!(y.coefficient(), 0);\n        assert_eq!(y.n_frac_digits(), 0);\n    }", "item_id": 1, "repo": "mamrhein/fpdec.rs", "file": "src/round.rs", "last_update_at": "2022-03-08T03:40:31+00:00"}
{"hexsha": "d4c044b4464d1846dd4a853c231d2edd55e48d41", "ext": "rs", "lang": "Rust", "content": "fn enc_dec_max_i8() {\n        let val = core::i8::MAX.into();\n        assert_eq!(encoded_len(val), 2);\n        assert_eq!(encode(val).as_ref(), &[0xBE, 0x03]);\n        assert_eq!(decode(encode(val).as_ref()).unwrap(), val);\n    }", "item_id": 9, "repo": "aki-akaguma/vu64", "file": "src/signed.rs", "last_update_at": "2022-02-02T10:25:49+00:00"}
{"hexsha": "c7e9af65cf4203d61fc9d741d9f84684268734c5", "ext": "rs", "lang": "Rust", "content": "fn test_includes() {\n        assert_eq!(document(json!({})).includes(), Vec::<String>::new());\n        assert_eq!(document(json!({ \"include\": []})).includes(), Vec::<String>::new());\n        assert_eq!(\n            document(json!({ \"include\": [ \"foo.cml\", \"bar.cml\" ]})).includes(),\n            vec![\"foo.cml\", \"bar.cml\"]\n        );\n    }", "item_id": 5, "repo": "fabio-d/fuchsia-stardock", "file": "tools/lib/cml/src/lib.rs", "last_update_at": "2022-01-21T20:14:17+00:00"}
{"hexsha": "3fce34367ae5040132e5bad3ed34924faf7178ad", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let mut vec = vec![1, 2, 3, 4];\n    let vec2 = vec![1, 2, 3, 4];\n    for i in 0..vec.len() {\n        println!(\"{}\", vec[i]);\n    }\n\n    for i in 0..vec.len() {\n        let i = 42; // make a different `i`\n        println!(\"{}\", vec[i]); // ok, not the `i` of the for-loop\n    }\n\n    for i in 0..vec.len() {\n        let _ = vec[i];\n    }\n\n    // ICE #746\n    for j in 0..4 {\n        println!(\"{:?}\", STATIC[j]);\n    }\n\n    for j in 0..4 {\n        println!(\"{:?}\", CONST[j]);\n    }\n\n    for i in 0..vec.len() {\n        println!(\"{} {}\", vec[i], i);\n    }\n    for i in 0..vec.len() {\n        // not an error, indexing more than one variable\n        println!(\"{} {}\", vec[i], vec2[i]);\n    }\n\n    for i in 0..vec.len() {\n        println!(\"{}\", vec2[i]);\n    }\n\n    for i in 5..vec.len() {\n        println!(\"{}\", vec[i]);\n    }\n\n    for i in 0..MAX_LEN {\n        println!(\"{}\", vec[i]);\n    }\n\n    for i in 0..=MAX_LEN {\n        println!(\"{}\", vec[i]);\n    }\n\n    for i in 5..10 {\n        println!(\"{}\", vec[i]);\n    }\n\n    for i in 5..=10 {\n        println!(\"{}\", vec[i]);\n    }\n\n    for i in 5..vec.len() {\n        println!(\"{} {}\", vec[i], i);\n    }\n\n    for i in 5..10 {\n        println!(\"{} {}\", vec[i], i);\n    }\n\n    // #2542\n    for i in 0..vec.len() {\n        vec[i] = Some(1).unwrap_or_else(|| panic!(\"error on {}\", i));\n    }\n\n    // #3788\n    let test = Test {\n        inner: vec![1, 2, 3, 4],\n    };\n    for i in 0..2 {\n        println!(\"{}\", test[i]);\n    }\n}", "item_id": 0, "repo": "Eric-Arellano/rust", "file": "src/tools/clippy/tests/ui/needless_range_loop.rs", "last_update_at": "2022-03-31T23:26:40+00:00"}
{"hexsha": "78af2ad1e00582d2a1c0a2534ddc830b95eec458", "ext": "rs", "lang": "Rust", "content": "fn from_date() {\n    let date: Date<Utc> = Date::from_utc(NaiveDate::from_ymd(2018, 6, 19), Utc);\n\n    let solar_date = SolarDate::from_date(date).unwrap();\n\n    assert_eq!(SolarYear::from_u16(2018), solar_date.get_solar_year());\n    assert_eq!(SolarMonth::from_u8(6).unwrap(), solar_date.get_solar_month());\n    assert_eq!(SolarDay::from_u8(19).unwrap(), solar_date.get_solar_day());\n}", "item_id": 1, "repo": "ChaosStudyGroup/chinese-lunisolar-calendar", "file": "tests/solar_date.rs", "last_update_at": "2022-03-05T17:06:57+00:00"}
{"hexsha": "f419036840fdab102b9b8647ef28cba23a71a5c8", "ext": "rs", "lang": "Rust", "content": "fn decode_message_valid_header_size() {\n        let data = vec![0; SIGNED_MESSAGE_MIN_SIZE + 1];\n\n        match get_decoded_message(&data) {\n            Ok(Some(ref message)) if *message == &data[..] => {}\n            _ => panic!(\"Wrong input\"),\n        };\n    }", "item_id": 2, "repo": "mobilipia/milestone-core", "file": "exonum-node/src/events/codec.rs", "last_update_at": "2022-03-26T04:27:03+00:00"}
{"hexsha": "ceaf60f189248fa5fd48952aede09a7a325d9f39", "ext": "rs", "lang": "Rust", "content": "pub fn deser_operation_crate_operation_create_load_balancer(\n    inp: &[u8],\n    mut builder: crate::output::create_load_balancer_output::Builder,\n) -> Result<crate::output::create_load_balancer_output::Builder, aws_smithy_xml::decode::XmlError> {\n    use std::convert::TryFrom;\n    let mut doc = aws_smithy_xml::decode::Document::try_from(inp)?;\n\n    #[allow(unused_mut)]\n    let mut decoder = doc.root_element()?;\n    let start_el = decoder.start_el();\n    if !(start_el.matches(\"CreateLoadBalancerResponse\")) {\n        return Err(aws_smithy_xml::decode::XmlError::custom(format!(\n            \"invalid root, expected CreateLoadBalancerResponse got {:?}\",\n            start_el\n        )));\n    }\n    if let Some(mut result_tag) = decoder.next_tag() {\n        let start_el = result_tag.start_el();\n        if !(start_el.matches(\"CreateLoadBalancerResult\")) {\n            return Err(aws_smithy_xml::decode::XmlError::custom(format!(\n                \"invalid result, expected CreateLoadBalancerResult got {:?}\",\n                start_el\n            )));\n        }\n        while let Some(mut tag) = result_tag.next_tag() {\n            match tag.start_el() {\n            s if s.matches(\"LoadBalancers\") /* LoadBalancers com.amazonaws.elasticloadbalancingv2.synthetic#CreateLoadBalancerOutput$LoadBalancers */ =>  {\n                let var_34 =\n                    Some(\n                        crate::xml_deser::deser_list_com_amazonaws_elasticloadbalancingv2_load_balancers(&mut tag)\n                        ?\n                    )\n                ;\n                builder = builder.set_load_balancers(var_34);\n            }\n            ,\n            _ => {}\n        }\n        }\n    } else {\n        return Err(aws_smithy_xml::decode::XmlError::custom(\n            \"expected CreateLoadBalancerResult tag\",\n        ));\n    };\n    Ok(builder)\n}", "item_id": 33, "repo": "StevenBlack/aws-sdk-rust", "file": "sdk/elasticloadbalancingv2/src/xml_deser.rs", "last_update_at": "2022-03-31T20:47:15+00:00"}
{"hexsha": "84c23658828a7fca46ef7a8340541724fc5d3044", "ext": "rs", "lang": "Rust", "content": "fn exec(attempts: i32, command: &mut Command) -> String {\n    let command_line = format!(\"{:?}\", command);\n\n    for _attempt in 0..attempts {\n        match command.output() {\n            Ok(output) => return String::from_utf8(output.stdout).expect(\"parse UTF8 string\"),\n            Err(err) => {\n                eprintln!(\n                    \"Godot command failed:\\n  command: {}\\n  error: {}\",\n                    command_line, err\n                )\n            }\n        }\n    }\n\n    panic!(\"Could not execute Godot command (see above).\")\n}", "item_id": 1, "repo": "orion78fr/godot-rust", "file": "bindings_generator/src/godot_api_json.rs", "last_update_at": "2022-03-28T20:34:55+00:00"}
{"hexsha": "81dd805358ffce9d8cee14099785d2615d8df9bd", "ext": "rs", "lang": "Rust", "content": "pub fn DCONST_1(code_reader: CodeReader, thread: Thread) -> (ExecuteResult, CodeReader) {\n    println!(\"DCONST_1\");\n    let (frame, thread) = thread.pop_frame();\n\n    let Frame {\n        operand_stack,\n        local_vars,\n        method,\n        class,\n    } = frame;\n    let operand_stack = operand_stack.push_double(1f64);\n    let local_vars = local_vars;\n    let frame = Frame {\n        class,\n        operand_stack,\n        local_vars,\n        method,\n    };\n    let thread = thread.push_frame(frame);\n    let execute_result = ExecuteResult { thread, offset: 0 };\n    (execute_result, code_reader)\n}", "item_id": 1, "repo": "standbyme/jvm-rs", "file": "src/instruction/constant/xconst.rs", "last_update_at": "2022-03-15T11:40:26+00:00"}
{"hexsha": "818f200fd90b770a503fb40d7dc82f16b8c56849", "ext": "rs", "lang": "Rust", "content": "async fn set_and_reset_distinct_attribute_with_dedicated_route() {\n    let server = Server::new().await;\n    let index = server.index(\"test\");\n\n    let (_response, _code) = index.update_distinct_attribute(json!(\"test\")).await;\n    index.wait_update_id(0).await;\n\n    let (response, _) = index.get_distinct_attribute().await;\n\n    assert_eq!(response, \"test\");\n\n    index.update_distinct_attribute(json!(null)).await;\n\n    index.wait_update_id(1).await;\n\n    let (response, _) = index.get_distinct_attribute().await;\n\n    assert_eq!(response, json!(null));\n}", "item_id": 1, "repo": "palfrey/MeiliSearch", "file": "meilisearch-http/tests/settings/distinct.rs", "last_update_at": "2022-01-26T12:15:39+00:00"}
{"hexsha": "e7730aba85b226b2b7c71c4cc2d0dad0be71c85e", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let matches = App::new(\"rlox\")\n        .version(\"0.1.0\")\n        .about(\"lox language interpreter\")\n        .author(\"Thomas Peters\")\n        .arg(\n            Arg::with_name(INPUT_STR)\n                .help(\"sets input file to use\")\n                .required(false)\n                .index(1),\n        )\n        .arg(\n            Arg::with_name(SHOW_TOKENS_STR)\n                .long(\"--show-tokens\")\n                .takes_value(false)\n                .help(\"show the token stream\"),\n        )\n        .arg(\n            Arg::with_name(SHOW_AST_STR)\n                .long(\"--show-ast\")\n                .takes_value(false)\n                .help(\"show the AST\"),\n        )\n        .arg(\n            Arg::with_name(DISASSEMBLE_STR)\n                .long(\"--disassemble\")\n                .takes_value(false)\n                .help(\"show the bytecode\"),\n        )\n        .arg(\n            Arg::with_name(DEBUG_STR)\n                .long(\"--debug\")\n                .takes_value(false)\n                .help(\"run in the debugger\"),\n        )\n        .arg(\n            Arg::with_name(TREEWALK_STR)\n                .long(\"--treewalk\")\n                .takes_value(false)\n                .help(\"run the tree-walk interpreter instead of the bytecode interpreter\"),\n        )\n        .arg(\n            Arg::with_name(LITERAL_INPUT)\n                .long(\"-c\")\n                .takes_value(true)\n                .help(\"provide a literal string of Lox code\"),\n        )\n        .arg(\n            Arg::with_name(EXTENSION_LISTS)\n                .long(&format![\"--{}\", EXTENSION_LISTS])\n                .takes_value(false)\n                .help(\"use the lists extension\"),\n        )\n        .arg(\n            Arg::with_name(EXTENSION_LAMBDAS)\n                .long(&format![\"--{}\", EXTENSION_LAMBDAS])\n                .takes_value(false)\n                .help(\"use the lambdas extension\"),\n        )\n        .get_matches();\n\n    let extensions = extensions::Extensions {\n        lists: matches.is_present(EXTENSION_LISTS),\n        lambdas: matches.is_present(EXTENSION_LAMBDAS),\n    };\n\n    if let Some(input) = get_input(&matches) {\n        if matches.is_present(SHOW_TOKENS_STR)\n            || matches.is_present(SHOW_AST_STR)\n            || matches.is_present(TREEWALK_STR)\n        {\n            match scanner::scan_tokens(input.content.clone()) {\n                Ok(tokens) => {\n                    if matches.is_present(SHOW_TOKENS_STR) {\n                        println!(\"{:#?}\", tokens);\n                        std::process::exit(0);\n                    }\n\n                    let stmts_maybe = parser::parse(extensions, tokens);\n\n                    match stmts_maybe {\n                        Ok(stmts) => {\n                            if matches.is_present(SHOW_AST_STR) {\n                                println!(\"{:#?}\", stmts);\n                                std::process::exit(0);\n                            }\n\n                            let mut interpreter: treewalk_interpreter::Interpreter =\n                                Default::default();\n                            let interpret_result = interpreter.interpret(&stmts);\n\n                            match interpret_result {\n                                Ok(_) => {\n                                    std::process::exit(0);\n                                }\n                                Err(err) => {\n                                    println!(\n                                        \"Runtime Error: {}\\n\\n{}\",\n                                        err,\n                                        interpreter.format_backtrace()\n                                    );\n                                    std::process::exit(-1);\n                                }\n                            }\n                        }\n                        Err(err) => {\n                            error_formatting::format_parse_error(&err, &input);\n                            std::process::exit(-1)\n                        }\n                    }\n                }\n                Err(err) => {\n                    error_formatting::format_lexical_error(&err, &input);\n                    std::process::exit(-1);\n                }\n            }\n        }\n\n        let func_or_err = compiler::Compiler::compile(input.content.clone(), extensions);\n\n        match func_or_err {\n            Ok(func) => {\n                if matches.is_present(DISASSEMBLE_STR) {\n                    println!(\n                        \"{}\",\n                        bytecode_interpreter::disassemble_chunk(&func.chunk, \"\")\n                    );\n                    std::process::exit(0);\n                }\n                if matches.is_present(DEBUG_STR) {\n                    debugger::Debugger::new(func, input.content).debug();\n                    std::process::exit(0);\n                }\n                let mut interpreter = bytecode_interpreter::Interpreter::default();\n                let res = interpreter.interpret(func);\n                match res {\n                    Ok(()) => {\n                        std::process::exit(0);\n                    }\n                    Err(bytecode_interpreter::InterpreterError::Runtime(err)) => {\n                        println!(\n                            \"Runtime error: {}\\n\\n{}\",\n                            err,\n                            interpreter.format_backtrace()\n                        );\n\n                        std::process::exit(1);\n                    }\n                }\n            }\n            Err(err) => {\n                error_formatting::format_compiler_error(&err, &input);\n                std::process::exit(1);\n            }\n        }\n    } else {\n        repl::run(extensions);\n    }\n}", "item_id": 1, "repo": "pedrogao/crafting-interpreters-rs", "file": "src/main.rs", "last_update_at": "2022-03-05T08:26:00+00:00"}
{"hexsha": "3d2f9b7c606e02ad5e3851c7dc9d48cc8915be9e", "ext": "rs", "lang": "Rust", "content": "fn print_usage(to: PrintDestination) {\n    let prog_name = PathBuf::from(env::args_os().next().unwrap())\n        .file_name()\n        .unwrap()\n        .to_string_lossy()\n        .to_string();\n    let usage = format!(\n        \"{N} [-{h}|{V}] [-{x}] [-{P} PUBLIC_KEY]\\n\\\n         {w:width$} [-{E} SIG_PATH] [-{e} SHA256]\\n\\\n         {w:width$} [-{S} SIG_PATH] [-{s} SHA256]\\n\\\n         {w:width$} <EXECUTABLE_PATH> [<SCRIPT_PATH>] [..ARGS]\\n\\n\\\n         [-{h}] * Print help and exit\\n\\\n         [-{V}] * Print version and exit\\n\\\n         [-{x}] * Use execve()\\n\\\n         [-{P}] * Minisign base64 public key\\n\\\n         [-{E}] * Executable signature path\\n\\\n         [-{e}] * Executable hash\\n\\\n         [-{S}] * Script signature path\\n\\\n         [-{s}] * Script hash\",\n        N = prog_name,\n        h = flag::HELP,\n        V = flag::VERSION,\n        x = flag::EXEC,\n        P = flag::PUBLIC_KEY,\n        E = flag::EXECUTABLE_SIG_PATH,\n        e = flag::EXECUTABLE_HASH,\n        S = flag::SCRIPT_SIG_PATH,\n        s = flag::SCRIPT_HASH,\n        w = \"\",\n        width = prog_name.chars().count(),\n    );\n    match to {\n        PrintDestination::Stdout => println!(\"{}\", usage),\n        PrintDestination::Stderr => eprintln!(\"{}\", usage),\n    }\n}", "item_id": 0, "repo": "x13a/exec-guard", "file": "src/main.rs", "last_update_at": "2022-01-23T15:06:43+00:00"}
{"hexsha": "366b24c4937caaf5198dfb7c4b26bbe44abf2ba0", "ext": "rs", "lang": "Rust", "content": "fn leading_dot() {\n    const LEADING_DOT: &str = \".111\";\n\n    lexer_test(LEADING_DOT, Single(Err(LexerError::LeadingDot(0, 0))));\n\n    const LEADING_DOT_AFTER_SIGN: &str = \"+.1111\";\n\n    lexer_test(\n        LEADING_DOT_AFTER_SIGN,\n        Single(Err(LexerError::LeadingDot(1, 1))),\n    );\n}", "item_id": 6, "repo": "fluencelabs/aquavm", "file": "crates/air-lib/air-parser/src/parser/lexer/tests.rs", "last_update_at": "2022-03-19T07:49:13+00:00"}
{"hexsha": "d9996dac95a8685c5b10471c5e631791509a6bd3", "ext": "rs", "lang": "Rust", "content": "pub fn delete(conn: DatabaseConnection, user: User, id: i32) -> Result<JsonValue> {\n\tlet log_type_model = LogType::new(&conn, id)?.as_model();\n\n\tif log_type_model.user_id != user.get_id() {\n\t\treturn Err(ErrorKind::AccessDenied.into());\n\t}\n\n\tdiesel::delete(log_type_dsl::log_type)\n\t\t.filter(log_type_dsl::id.eq(id))\n\t\t.execute(&*conn)?;\n\n\tOk(json!({\n\t\t\"status\": true\n\t}))\n}", "item_id": 2, "repo": "zeljic/rpi-stats-service", "file": "service/collector/src/routes/log_type.rs", "last_update_at": "2022-02-26T10:05:30+00:00"}
{"hexsha": "8bde40cec4cf22d7a4be6d75793d9f2ca1eef708", "ext": "rs", "lang": "Rust", "content": "pub fn crawl_directory_for_repos(directory: &Path) -> IoResult<Vec<Repository>> {\n\t// Contains paths to explore\n\tlet paths = SegQueue::new();\n\tpaths.push(directory.to_path_buf());\n\n\t// Contains found repositories\n\tlet repositories = SegQueue::new();\n\n\t// Set the number of threads to use for crawling\n\tlet thread_count = max(8, num_cpus::get() * 2);\n\n\tthread::scope(|scope| {\n\t\tfor _ in 0..thread_count {\n\t\t\tscope.spawn(|_| {\n\t\t\t\twhile let Some(path) = paths.pop() {\n\t\t\t\t\tcrawl(path, &paths, &repositories).unwrap();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t})\n\t.unwrap_or_else(|_| error!(\"Could not spawn threads\"));\n\n\t// Return the repositories in a `Vec`\n\tOk(repositories.into_iter().collect::<Vec<_>>())\n}", "item_id": 0, "repo": "MrNossiom/git-leave", "file": "src/crawl.rs", "last_update_at": "2022-03-22T17:26:45+00:00"}
{"hexsha": "376d280fed48ebbede1b0b917d74cf57c426dee0", "ext": "rs", "lang": "Rust", "content": "pub fn daa(cpu: &mut crate::cpu::Cpu) {\n    if cpu.registers.a & 0xf > 0x09 || cpu.registers.f.h {\n        cpu.registers.a = cpu.registers.a.wrapping_add(0x06);\n    }\n\n    if cpu.registers.a & 0xf0 > 0x90 || cpu.registers.f.c {\n        cpu.registers.a = cpu.registers.a.wrapping_add(0x60);\n        cpu.registers.f.c = true;\n    } else {\n        cpu.registers.f.c = false;\n    }\n\n    cpu.registers.f.z = cpu.registers.a == 0;\n    cpu.registers.f.h = false;\n}", "item_id": 3, "repo": "martinkauppinen/gibberish", "file": "src/cpu/opcodes/logic.rs", "last_update_at": "2022-02-11T18:30:21+00:00"}
{"hexsha": "812215e67b0cf0df02f68a8b186ce073b0925908", "ext": "rs", "lang": "Rust", "content": "fn test_commutator_scalar_e2() {\n        let scalar = EuclideanMultivector2::from_scalar(6_f64);\n        let e2 = EuclideanMultivector2::unit_e2();\n        let expected = EuclideanMultivector2::zero();\n        let result = scalar.commutator(&e2);\n\n        assert_eq!(result, expected);\n    }", "item_id": 122, "repo": "lambdaxymox/cggeomalg", "file": "tests/test_e2ga.rs", "last_update_at": "2022-03-17T02:23:11+00:00"}
{"hexsha": "b70fa1910b06cdcf267c9c777989a969c5ab8cb2", "ext": "rs", "lang": "Rust", "content": "fn main() -> io::Result<()> {\n    let mut buffer = String::new();\n    io::stdin().read_to_string(&mut buffer)?;\n\n    let ans: usize = buffer\n        .trim()\n        .split('\\n')\n        .map(|line| {\n\n            let (_, raw_digits) = line.split_once(\" | \").unwrap();\n            let digits: Vec<_> = raw_digits.trim().split_whitespace().collect();\n\n            return digits\n                .iter()\n                .filter(|digit| digit.len() == 2 || digit.len() == 3 || digit.len() == 4 || digit.len() == 7)\n                .count();\n        })\n        .sum();\n\n    println!(\"{}\", ans);\n\n    return Ok(());\n}", "item_id": 0, "repo": "garciparedes/advent-of-code", "file": "2021/08_seven_segment_search_part_1.rs", "last_update_at": "2022-01-08T03:14:57+00:00"}
{"hexsha": "977214e75800d0332ff5afeaa8695c47d93db661", "ext": "rs", "lang": "Rust", "content": "fn get_server_response<D: DelayUs>(\n    spi_drv: &mut SpiDrv,\n    uart: &mut EnabledUart,\n    delay: &mut D,\n    socket: u8,\n) -> Result<httparse::Status<usize>, String<STR_LEN>> {\n    let response_length: u16 = 0;\n    let mut avail_length: usize = 0;\n    let n = 0;\n    let response_buf: [u8; RESPONSE_BUF_LEN] = [0; RESPONSE_BUF_LEN];\n    let mut timeout: u16 = 1000;\n\n    while timeout > 0 {\n        delay.delay_ms(50).ok().unwrap();\n        avail_length = avail_data(spi_drv, uart, socket)?;\n        if avail_length > 0 {\n            break;\n        }\n\n        timeout -= 1;\n    }\n\n    write!(\n        uart,\n        \"\\tresponse_length: {:?} avail_length {:?}\\r\\n\",\n        response_length, avail_length\n    )\n    .ok()\n    .unwrap();\n\n    let response_buf = get_data_buf(spi_drv, uart, socket, avail_length as u16)?;\n    let response_str = core::str::from_utf8(&response_buf).unwrap();\n\n    writeln!(\n        uart,\n        \"\\tHTTP server response string: {:?}\\r\\n\",\n        response_str\n    )\n    .ok()\n    .unwrap();\n\n    let mut headers = [httparse::EMPTY_HEADER; 64];\n    let mut response = httparse::Response::new(&mut headers);\n    match response.parse(&response_buf) {\n        Ok(parsed) => {\n            write!(\n                uart,\n                \"HTTP response version: {:?}\\r\\n\",\n                response.version.unwrap()\n            )\n            .ok()\n            .unwrap();\n            write!(uart, \"HTTP response code: {:?}\\r\\n\", response.code.unwrap())\n                .ok()\n                .unwrap();\n            writeln!(\n                uart,\n                \"HTTP response reason: {:?}\\r\\n\",\n                response.reason.unwrap()\n            )\n            .ok()\n            .unwrap();\n\n            if response.code.unwrap() == 200 {\n                write!(uart, \"Got successful response from HTTP server.\\r\\n\")\n                    .ok()\n                    .unwrap();\n            } else if response.code.unwrap() == 400 {\n                write!(uart, \"** Got error response from HTTP server.\\r\\n\")\n                    .ok()\n                    .unwrap();\n            }\n            return Ok(parsed);\n        }\n\n        Err(e) => {\n            write!(uart, \"Failed to parse HTTP server response: {:?}\\r\\n\", e)\n                .ok()\n                .unwrap();\n            return Err(String::from(\"Failed to parse HTTP server response\"));\n        }\n    }\n}", "item_id": 13, "repo": "Jim-Hodapp-Coaching/esp32-pico-wifi", "file": "src/main.rs", "last_update_at": "2022-03-19T08:43:47+00:00"}
{"hexsha": "0a8fc331e7e14b48c185d68d0b0f4a8a317aa9f6", "ext": "rs", "lang": "Rust", "content": "fn test_file_writer_empty_file() {\n        let file = tempfile::tempfile().unwrap();\n\n        let schema = Arc::new(\n            types::Type::group_type_builder(\"schema\")\n                .with_fields(&mut vec![Arc::new(\n                    types::Type::primitive_type_builder(\"col1\", Type::INT32)\n                        .build()\n                        .unwrap(),\n                )])\n                .build()\n                .unwrap(),\n        );\n        let props = Arc::new(WriterProperties::builder().build());\n        let writer =\n            SerializedFileWriter::new(file.try_clone().unwrap(), schema, props).unwrap();\n        writer.close().unwrap();\n\n        let reader = SerializedFileReader::new(file).unwrap();\n        assert_eq!(reader.get_row_iter(None).unwrap().count(), 0);\n    }", "item_id": 2, "repo": "HaoYang670/arrow-rs", "file": "parquet/src/file/writer.rs", "last_update_at": "2022-03-29T02:31:02+00:00"}
{"hexsha": "03310e63246987c9fa32df9e5103e22c2c55f425", "ext": "rs", "lang": "Rust", "content": "pub fn fetch(args: InputArgs, filter_list: Vec<Regex>) {\n    let matches = args.get_matches();\n    let filter_hidden = matches.is_present(\"traverse-hidden\");\n\n    let dir_tree_with_options = DirectoryTreeOptions {\n        filter_list: filter_list,\n        filter_hidden: filter_hidden,\n    };\n\n    let root_path = args.get_root_path(\"PATH\");\n    let root = root_path\n        .to_str()\n        .expect(format!(\"{}\", \"Error in converting directory to string\".red()).as_str());\n\n    let multi_bars = ProgressTracker::new(matches.value_of(\"jobs\").and_then(|e| e.parse().ok()));\n    dir_tree_with_options\n        .process_directories(root)\n        .flat_map(|dir| {\n            dir.ok().and_then(|d| {\n                if d.file_name().eq(\".git\") {\n                    d.path().parent().map(|e| e.to_path_buf())\n                } else {\n                    None\n                }\n            })\n        })\n        .map(|dir| GitFetch {\n            dir,\n            remote: \"origin\".to_string(),\n        })\n        .for_each(|clone| multi_bars.start_task(clone));\n\n    multi_bars.join().unwrap();\n}", "item_id": 0, "repo": "thecasualcoder/gg", "file": "src/fetch.rs", "last_update_at": "2022-01-19T08:53:20+00:00"}
{"hexsha": "5f2264d1e7609ce7a37d36c3bc1a5e67065895e5", "ext": "rs", "lang": "Rust", "content": "pub fn rdtsc() -> u64 {\n    let val_lo: u32;\n    let val_hi: u32;\n\n    unsafe {\n        llvm_asm!(\"rdtsc\" : \"={edx}\"(val_hi), \"={eax}\"(val_lo) ::\n             \"memory\" : \"volatile\", \"intel\");\n    }\n\n    ((val_hi as u64) << 32) | val_lo as u64\n}", "item_id": 3, "repo": "ZiyanWu93/chocolate_milk", "file": "shared/cpu/src/lib.rs", "last_update_at": "2022-03-27T16:21:40+00:00"}
{"hexsha": "e6707d103a019faf494dc745d0c33600adf1b0d3", "ext": "rs", "lang": "Rust", "content": "fn write_dummy_executable(executable_data_len: usize) -> Vec<u8> {\n        let mut written_data = Vec::new();\n        let executable_data = vec![0u8; executable_data_len];\n        write_executable(\n            &mut written_data,\n            SegmentOffsetPtr::new(0, 0),\n            &[],\n            &executable_data,\n        )\n        .unwrap();\n        written_data\n    }", "item_id": 1, "repo": "mthiesen/parsec_exe_unpacker", "file": "src/dos_exe.rs", "last_update_at": "2022-02-18T04:15:44+00:00"}
{"hexsha": "390d2b21871e5247833a2f064d36859858c84b89", "ext": "rs", "lang": "Rust", "content": "fn handles_empty_paths() {\n        let actual = main(\n            &model::Configuration {\n                paths: String::new(),\n                ..model::stubs::configuration()\n            },\n            path::Path::new(\".\"),\n        );\n\n        let actual = actual.unwrap();\n        assert!(actual.is_empty());\n    }", "item_id": 1, "repo": "evolutics/files-embedded-as-modules", "file": "src/list_files/get_raw_paths.rs", "last_update_at": "2022-03-01T07:18:58+00:00"}
{"hexsha": "c18cae37cdc78ab843bee1bf7527e5e78439239c", "ext": "rs", "lang": "Rust", "content": "fn test_parser() {\n        assert_eq!(MediaType::Audio, \"AUDIO\".parse().unwrap());\n        assert_eq!(MediaType::Video, \"VIDEO\".parse().unwrap());\n        assert_eq!(MediaType::Subtitles, \"SUBTITLES\".parse().unwrap());\n        assert_eq!(\n            MediaType::ClosedCaptions,\n            \"CLOSED-CAPTIONS\".parse().unwrap()\n        );\n    }", "item_id": 0, "repo": "Sequal32/hls_m3u8", "file": "src/types/media_type.rs", "last_update_at": "2022-02-15T16:52:40+00:00"}
{"hexsha": "228cdc96b428d6bd27e009d21edbf646dc913494", "ext": "rs", "lang": "Rust", "content": "fn comment_with_single_quotes_one_pass() {\n        let mut scanner = Scanner::new();\n        let bytes = r#\"<!-- goodbye a='val-->'-->Content\"#.as_bytes();\n        assert_eq!(scanner.scan(bytes), Some(State::ScannedComment(22)));\n        assert_eq!(scanner.state, InternalState::Reset);\n    }", "item_id": 62, "repo": "bluk/maybe_xml", "file": "src/scanner.rs", "last_update_at": "2022-03-12T03:55:27+00:00"}
{"hexsha": "3ec8df72db047df9c7e3e30aeb87c436f2170203", "ext": "rs", "lang": "Rust", "content": "fn alloc_and_free() {\n        let mut vm = VM::default();\n        let mut system = helper::generate_system();\n\n        let program = helper::program_builder()\n            .instructions(vec![\n                Instruction::Alloc(10),\n                Instruction::Alloc(30),\n                Instruction::Free,\n                Instruction::Free,\n                Instruction::Alloc(20),\n                Instruction::Free,\n            ])\n            .gen();\n\n        vm.exec(&program, &mut system).unwrap();\n\n        assert_eq!(vm.bp, 0);\n    }", "item_id": 33, "repo": "bakervm/melon", "file": "src/vm.rs", "last_update_at": "2022-03-04T03:22:23+00:00"}
{"hexsha": "1aefff91b0ee55dee2c7d76bb55022029d6a197f", "ext": "rs", "lang": "Rust", "content": "pub fn main(username: String) {\n    let icon_bytes = include_bytes!(\"../assets/icon.ico\");\n    let icon = Icon::from_buffer(icon_bytes, None, None).unwrap();\n    let (s, r) = std::sync::mpsc::channel::<Events>();\n\n    let _tray_icon = TrayIconBuilder::new()\n        .icon(icon)\n        .sender(s)\n        .tooltip(\"Bitwarden Autotype\")\n        .menu(\n            MenuBuilder::new()\n                .with(info_item(\"Bitwarden Autotype is running\"))\n                .separator()\n                .with(info_item(&format!(\"Logged in as {}\", username)))\n                .with(info_item(\"Hotkey: Ctrl-Alt-A\"))\n                .separator()\n                .item(\"Sync Vault\", Events::SyncNow)\n                .separator()\n                .item(\"Exit\", Events::Exit),\n        )\n        .build()\n        .unwrap();\n\n    std::thread::spawn(move || {\n        r.iter().for_each(|m| match m {\n            Events::Exit => {\n                info!(\"Shutting down\");\n                exit(0);\n            }\n            Events::SyncNow => {\n                info!(\"Sync requested\");\n                crate::bw_cli::sync()\n            }\n            e => {\n                println!(\"{:?}\", e);\n            }\n        })\n    });\n\n    loop {\n        unsafe {\n            let mut msg = MaybeUninit::uninit();\n            let bret = winuser::GetMessageW(msg.as_mut_ptr(), 0 as _, 0, 0);\n            if bret > 0 {\n                winuser::TranslateMessage(msg.as_ptr());\n                winuser::DispatchMessageW(msg.as_ptr());\n            } else {\n                warn!(\"Failed to receive message\");\n            }\n        }\n    }\n}", "item_id": 0, "repo": "MCOfficer/bitwarden-autotype", "file": "src/tray.rs", "last_update_at": "2022-02-27T18:59:30+00:00"}
{"hexsha": "adc5d0a11384fb7c9040d8515a8a0a66e2136d47", "ext": "rs", "lang": "Rust", "content": "fn bench_allocator(c: &mut Criterion<ProcessTime>) {\n    let page = &[1u8; PAGE_SIZE];\n    let mut group = c.benchmark_group(\"Allocate\");\n    for n in [1usize, 10, 100, 1_000].iter().cloned() {\n        let pages: Vec<(PageIndex, &PageBytes)> = (0..n)\n            .into_iter()\n            .map(|i| (PageIndex::new(i as u64), page))\n            .collect();\n        let mut thread_pool = Cell::new(scoped_threadpool::Pool::new(NUM_THREADS));\n        group.bench_function(BenchmarkId::new(\"HeapBasedPageAllocator\", n), |b| {\n            b.iter(|| {\n                thread_pool.get_mut().scoped(|scope| {\n                    for _ in 0..NUM_THREADS {\n                        scope.execute(|| {\n                            let allocator = Arc::new(HeapBasedPageAllocator::default());\n                            for _ in 0..NUM_ALLOCATIONS {\n                                let pages =\n                                    HeapBasedPageAllocator::allocate(&allocator, &pages[..]);\n                                black_box(pages);\n                            }\n                        });\n                    }\n                });\n            })\n        });\n        // We don't use mmap-based allocator directly because it is only available on\n        // Linux for now. To avoid platform specific code here, we compare the\n        // heap-based allocator with the default allocator, which can be either\n        // the mmap-based allocator or the heap-based allocator.\n        group.bench_function(BenchmarkId::new(\"DefaultPageAllocatorImpl\", n), |b| {\n            b.iter(|| {\n                thread_pool.get_mut().scoped(|scope| {\n                    for _ in 0..NUM_THREADS {\n                        scope.execute(|| {\n                            let allocator = Arc::new(DefaultPageAllocatorImpl::default());\n                            // Allocate multiple times to simulate multiple rounds per checkpoint.\n                            for _ in 0..NUM_ALLOCATIONS {\n                                let pages =\n                                    DefaultPageAllocatorImpl::allocate(&allocator, &pages[..]);\n                                black_box(pages);\n                            }\n                        });\n                    }\n                });\n            })\n        });\n    }\n    group.finish();\n}", "item_id": 0, "repo": "3cL1p5e7/ic", "file": "rs/replicated_state/benches/bench_allocator.rs", "last_update_at": "2022-03-31T11:40:24+00:00"}
{"hexsha": "8c7adf3814a9f170972790ce9c0b24cf68116e4c", "ext": "rs", "lang": "Rust", "content": "fn correct_coordinates_origin() {\n        let cell = HexagonCell2d {\n            coords: IVec3::new(0, 0, 0),\n        };\n        let neighbors = cell.neighbor_coordinates();\n        assert_eq!(\n            neighbors,\n            vec![\n                IVec3::new(0, 1, -1),\n                IVec3::new(1, 0, -1),\n                IVec3::new(1, -1, 0),\n                IVec3::new(0, -1, 1),\n                IVec3::new(-1, 0, 1),\n                IVec3::new(-1, 1, 0),\n            ]\n        );\n    }", "item_id": 2, "repo": "ManevilleF/bevy_life", "file": "src/components/cell/hexagon_2d_cell.rs", "last_update_at": "2022-03-28T12:07:51+00:00"}
{"hexsha": "147ae9c3d24b2452deeee3ae7cfb094b5179fbd3", "ext": "rs", "lang": "Rust", "content": "fn test_bit_field() {\n        let mut gene = Gene::new(false, 16, false, 25, 1);\n        assert_eq!(gene.get_source_type(), false);\n        assert_eq!(gene.get_source_num(), 16);\n        assert_eq!(gene.get_sink_type(), false);\n        assert_eq!(gene.get_sink_num(), 25);\n\n        gene.set_sink_num(99);\n        gene.set_source_num(35);\n        gene.set_sink_type(false);\n        gene.set_source_type(true);\n        assert_eq!(gene.get_source_type(), true);\n        assert_eq!(gene.get_source_num(), 35);\n        assert_eq!(gene.get_sink_type(), false);\n        assert_eq!(gene.get_sink_num(), 99);\n    }", "item_id": 0, "repo": "Destrings2/biosim-rust", "file": "src/population/genome/gene.rs", "last_update_at": "2022-01-16T09:19:00+00:00"}
{"hexsha": "2d9442a0eeb0611cd72b50be9fa941550e358003", "ext": "rs", "lang": "Rust", "content": "fn test_next_in_subdir() {\n        let d = dir();\n        let p = LogPath::new(&d, 123).next().unwrap();\n        assert_eq!(p.seq_num(), 124);\n        assert_eq!(p.path(), dir().join(\"000000124.devlog\"));\n    }", "item_id": 4, "repo": "wedaly/devlog", "file": "src/path.rs", "last_update_at": "2022-02-02T02:59:13+00:00"}
{"hexsha": "64943b3932802d1853e022c982a43a407ff22fd4", "ext": "rs", "lang": "Rust", "content": "pub fn verify_authorization(pub_key: String, sign: String, message: String) -> bool {\n    let public_key = hex::decode(pub_key);\n    if public_key.is_err() {\n        error!(\"err -> Err: public_key_decode\");\n        return false;\n    }\n    let hex_signature = hex::decode(sign);\n    if hex_signature.is_err() {\n        error!(\"err -> Err: hex_signature\");\n        return false;\n    }\n    let public_key = PublicKey::from_bytes(&public_key.unwrap().clone());\n    if public_key.is_err() {\n        error!(\"err -> Err: public_key\");\n        return false;\n    }\n    let signature = ed25519_dalek::Signature::from_bytes(&hex_signature.unwrap());\n    if signature.is_err() {\n        // eprintln!(\"err -> Err: signature\");\n        return false;\n    }\n    let ok = public_key\n        .unwrap()\n        .verify(message.as_bytes(), &signature.unwrap());\n    if ok.is_err() {\n        return false;\n    }\n    return true;\n}", "item_id": 0, "repo": "RabbitHouseCorp/http-interaction", "file": "src/sign_mod.rs", "last_update_at": "2022-03-13T16:19:24+00:00"}
{"hexsha": "ec8d4129821e19102a63373cd475b7cb03b04021", "ext": "rs", "lang": "Rust", "content": "fn funding_created_test() {\n        let msg_hex = \"002202000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000200050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n        let msg_bytes = hex::decode(msg_hex).unwrap();\n\n        let msg_correct = FundingCreated {\n            temporary_channel_id: ChannelId::from_hex(\"0200000000000000000000000000000000000000000000000000000000000000\").unwrap(),\n            funding_txid: FundingTxid::from_hex(\"0000000000000000000000000000000000000000000000000000000005000000\").unwrap(),\n            output_index: OutputIndex::from_u16(2),\n            signature: RawSignature::from_hex(\"3024021f05000000000000000000000000000000000000000000000000000000000000020100\").unwrap(),\n        };\n        let wrapped_msg_correct = Message::FundingCreated(msg_correct);\n\n        let mut cursor = Cursor::new(msg_bytes.clone());\n        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();\n        assert_eq!(&msg, &wrapped_msg_correct);\n\n\n        // Now check serialization\n        let mut new_msg_bytes = vec![];\n        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();\n        assert_eq!(new_msg_bytes, msg_bytes);\n\n    }", "item_id": 7, "repo": "LightningPeach/lpd", "file": "wire/tests/comp_check.rs", "last_update_at": "2022-01-02T11:14:21+00:00"}
{"hexsha": "222008ce52047888e82d647ed7477ef3b14a48e7", "ext": "rs", "lang": "Rust", "content": "fn normalize(val: f64, max: f64) -> f64 {\n  if val < ALL_MIN {\n    return ALL_MIN;\n  }\n  if val > max {\n    return max;\n  }\n  val\n}", "item_id": 0, "repo": "emgyrz/colorsys.rs", "file": "src/normalize.rs", "last_update_at": "2022-03-12T04:51:46+00:00"}
{"hexsha": "67280002b1c8875187ee19e0a8fd68d549cdb015", "ext": "rs", "lang": "Rust", "content": "fn encrypt_cli(encrypt_args: &ArgMatches, verbose: bool) {\n    let mut file_supplied = false;\n    let mut string_to_encrypt = match encrypt_args.value_of(\"string\") {\n        Some(words) => words,\n        None => \"Hello World!\",\n    };\n    let public_key_path = match encrypt_args.value_of(\"public-key-path\") {\n        Some(words) => words,\n        None => \"keys/public_key.pkcs7.pem\",\n    };\n\n    let file_to_encrypt: String = match encrypt_args.value_of(\"file\") {\n        Some(file) => {\n            file_supplied = true;\n            match read_to_string(&file) {\n                Ok(file_contents) => file_contents.to_owned(),\n                Err(_) => String::from(\"Hello world!\"),\n            }\n        }\n        None => String::from(\"Hello World!\"),\n    };\n    if file_supplied {\n        string_to_encrypt = file_to_encrypt.as_ref();\n    }\n    let ciphertext_pkcs7 = encrypt_str(public_key_path, &string_to_encrypt.as_bytes(), &verbose);\n    if verbose.clone() {\n        print! {\"New ciphertext: \"}\n    }\n    println!(\n        \"{:#}\",\n        from_utf8(&ciphertext_pkcs7.as_ref().to_pem().unwrap()).unwrap()\n    );\n    let mut output_file: String = \"\".into();\n    // todo: verify this in-place doesn't need a different method\n    if encrypt_args.is_present(\"in-place\") {\n        // this has to check the file that was fed in\n        if verbose.clone() {\n            println!(\"Going to try and use input file as the output file (encrypt in place)\")\n        }\n        output_file = encrypt_args.value_of(\"file\").unwrap().into();\n    } else {\n        match encrypt_args.value_of(\"output-file\") {\n            Some(ofile) => {\n                if verbose.clone() {\n                    println!(\"Using output-file argas output file\")\n                }\n                output_file = ofile.into()\n            }\n            None => {}\n        };\n    }\n    if output_file != \"\" {\n        if verbose.clone() {\n            println!(\"Going to write ciphertext to {}\", &output_file)\n        }\n        match write_file(&output_file, &ciphertext_pkcs7.as_ref().to_pem().unwrap()) {\n            Ok(_) => {}\n            Err(_) => println!(\"There was an error writing the ciphertext to file!\"),\n        }\n    } else {\n        if verbose.clone() {\n            println!(\"output_file variable was never assigned to anything\");\n        }\n    }\n}", "item_id": 21, "repo": "evan-chaney/eyaml-rs", "file": "src/main.rs", "last_update_at": "2022-01-27T11:04:13+00:00"}
{"hexsha": "a0c355822fec8705456df948932560c923e6f7df", "ext": "rs", "lang": "Rust", "content": "fn test_format_unification() {\n    use Format::*;\n\n    let mut x = Format::unknown();\n    assert!(x.unify(U8).is_ok());\n    x.reduce();\n    assert_eq!(x, U8);\n    assert_eq!(\n        x.unify(U16).unwrap_err(),\n        Error::Incompatible(\"U8\".into(), \"U16\".into())\n    );\n\n    let mut x = Tuple(vec![Format::unknown(), U32]);\n    x.unify(Tuple(vec![U16, Format::unknown()])).unwrap();\n    x.reduce();\n    assert_eq!(x, Tuple(vec![U16, U32]));\n\n    for x in vec![\n        Unit,\n        Bool,\n        I8,\n        I16,\n        I32,\n        I64,\n        I128,\n        U8,\n        U16,\n        U32,\n        U64,\n        U128,\n        F32,\n        F64,\n        Char,\n        Str,\n        Bytes,\n        TypeName(\"foo\".into()),\n        Option(Box::new(Unit)),\n        Seq(Box::new(Unit)),\n        Map {\n            key: Box::new(Unit),\n            value: Box::new(Unit),\n        },\n        Tuple(vec![Format::unknown()]),\n    ]\n    .iter_mut()\n    {\n        assert!(x.unify(TypeName(\"bar\".into())).is_err());\n        assert!(x.unify(Option(Box::new(U32))).is_err());\n        assert!(x.unify(Seq(Box::new(U32))).is_err());\n        assert!(x.unify(Tuple(vec![])).is_err());\n    }\n}", "item_id": 3, "repo": "texas16/serde-reflection", "file": "serde-reflection/tests/format.rs", "last_update_at": "2022-03-30T15:04:15+00:00"}
{"hexsha": "cd801b2196455ebd88e17bde021a3420c7750ef0", "ext": "rs", "lang": "Rust", "content": "fn random_single_units_to_times() {\n    assert_eq!(time!(16:51:49) - (-13).minutes(), time!(17:4:49));\n    assert_eq!(time!(13:20:48) - (-4).minutes(), time!(13:24:48));\n    assert_eq!(time!(6:51:52) - 44.minutes(), time!(6:7:52));\n    assert_eq!(time!(20:19:13) - 41.minutes(), time!(19:38:13));\n    assert_eq!(time!(1:4:31) - 0.hours(), time!(1:4:31));\n    assert_eq!(time!(19:11:31) - 32.seconds(), time!(19:10:59));\n    assert_eq!(time!(7:31:3) + 2.hours(), time!(9:31:3));\n    assert_eq!(time!(7:5:30) - (-20).hours(), time!(3:5:30));\n    assert_eq!(time!(11:56:1) - (-18).minutes(), time!(12:14:1));\n    assert_eq!(time!(18:51:17) - (-51).seconds(), time!(18:52:8));\n    assert_eq!(time!(21:13:48) - 36.seconds(), time!(21:13:12));\n    assert_eq!(time!(19:42:49) - 99.minutes(), time!(18:3:49));\n    assert_eq!(time!(0:54:29) + (-70).seconds(), time!(0:53:19));\n    assert_eq!(time!(14:20:2) - (-49).minutes(), time!(15:9:2));\n    assert_eq!(time!(8:51:55) - 58.seconds(), time!(8:50:57));\n    assert_eq!(time!(9:21:3) + 87.seconds(), time!(9:22:30));\n    assert_eq!(time!(2:40:56) + (-2).seconds(), time!(2:40:54));\n    assert_eq!(time!(15:24:1) + 47.hours(), time!(14:24:1));\n    assert_eq!(time!(7:38:1) + (-21).hours(), time!(10:38:1));\n    assert_eq!(time!(11:26:23) - 65.minutes(), time!(10:21:23));\n}", "item_id": 8, "repo": "Rapptz/eos", "file": "tests/interval.rs", "last_update_at": "2022-03-30T09:54:02+00:00"}
{"hexsha": "cf918a5c6c2be86db742e35664b0332b37fbfcda", "ext": "rs", "lang": "Rust", "content": "fn sync_symlink< P >( path: P ) -> std::io::Result< () >\nwhere\n    P: AsRef< std::path::Path >,\n{\n    log::trace!( \"Begin `sync_symlink`.\" );\n\n    let path = path.as_ref();\n\n    let metadata = path.symlink_metadata()?;\n    if !metadata.file_type().is_symlink() {\n        let error_msg = format!(\n            \"Invalid file type: not a symlink: \\\n                path: {:?}, \\\n                type: {:?}\",\n            path,\n            metadata.file_type(),\n        );\n\n        log::error!( \"{}\", error_msg );\n\n        let error = std::io::Error::new(\n                std::io::ErrorKind::InvalidInput, error_msg );\n\n        return Err( error );\n    }\n\n    let mut abs_path = std::env::current_dir()?;\n    abs_path.push( path );\n    let parent_path = abs_path.parent().unwrap();\n\n    log::debug!( \"Syncing symlink parent: {:?}\", parent_path );\n\n    std::fs::File::open( parent_path )?.sync_all()?;\n\n    log::trace!( \"End `sync_symlink`.\" );\n\n    return Ok( () );\n}", "item_id": 10, "repo": "selendym/cpdd", "file": "src/lib.rs", "last_update_at": "2022-01-06T22:02:25+00:00"}
{"hexsha": "3863099a09f96fdd1c286caad2c5672a87791b1b", "ext": "rs", "lang": "Rust", "content": "fn insert_header_with_configuration_change(\n\t\tbackend: &Backend<Block>,\n\t\tnumber: u64,\n\t\tparent_hash: H256,\n\t\tchanges: Option<Vec<(Vec<u8>, Vec<u8>)>>,\n\t\tnew_configuration: Option<ChangesTrieConfiguration>,\n\t) -> H256 {\n\t\tlet mut digest = Digest::default();\n\t\tlet mut changes_trie_update = Default::default();\n\t\tif let Some(changes) = changes {\n\t\t\tlet (root, update) = prepare_changes(changes);\n\t\t\tdigest.push(DigestItem::ChangesTrieRoot(root));\n\t\t\tchanges_trie_update = update;\n\t\t}\n\t\tdigest.push(DigestItem::ChangesTrieSignal(ChangesTrieSignal::NewConfiguration(new_configuration)));\n\n\t\tlet header = Header {\n\t\t\tnumber,\n\t\t\tparent_hash,\n\t\t\tstate_root: BlakeTwo256::trie_root(Vec::new()),\n\t\t\tdigest,\n\t\t\textrinsics_root: Default::default(),\n\t\t};\n\t\tlet header_hash = header.hash();\n\n\t\tlet block_id = if number == 0 {\n\t\t\tBlockId::Hash(Default::default())\n\t\t} else {\n\t\t\tBlockId::Number(number - 1)\n\t\t};\n\t\tlet mut op = backend.begin_operation().unwrap();\n\t\tbackend.begin_state_operation(&mut op, block_id).unwrap();\n\t\top.set_block_data(header, None, None, None, NewBlockState::Best).unwrap();\n\t\top.update_changes_trie((changes_trie_update, ChangesTrieCacheAction::Clear)).unwrap();\n\t\tbackend.commit_operation(op).unwrap();\n\n\t\theader_hash\n\t}", "item_id": 0, "repo": "cruz101-hub/substrate", "file": "client/db/src/changes_tries_storage.rs", "last_update_at": "2022-03-30T16:49:33+00:00"}
{"hexsha": "9858de99ea2d9db0765d2e755fc1a81a5935c68e", "ext": "rs", "lang": "Rust", "content": "fn get_containers(pod: &KubernetesPod) -> Vec<Container> {\n  let mut ret = Vec::new();\n\n  let pod_name = pod.metadata.name.clone();\n  let siblings = pod.spec.containers.len();\n  for container in &pod.spec.containers {\n    ret.push(Container::new(\n      pod_name.clone(), container.name.clone(),\n      siblings\n    ));\n  }\n\n  ret\n}", "item_id": 0, "repo": "HewlettPackard/woodchipper", "file": "src/reader/kubernetes.rs", "last_update_at": "2022-02-20T08:11:13+00:00"}
{"hexsha": "f14aa880f7ac22f7552d8600fbe09ad19f07f6f1", "ext": "rs", "lang": "Rust", "content": "fn quartic_bspline() {\n        let expect: Vec<(f32, f32)> = vec![(0.0, 0.0), (0.4, 0.0010666668), (1.0, 0.041666668),\n                          (1.5, 0.19791667), (2.0, 0.4583333), (2.5, 0.5989583),\n                          (3.0, 0.4583333), (3.2, 0.35206667), (4.1, 0.02733751),\n                          (4.5, 0.002604167), (5.0, 0.0)];\n        let points: Vec<f32> = vec![0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0];\n        let knots: Vec<f32> = vec![0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 5.0, 5.0, 5.0, 5.0];\n        let degree = 4;\n        let spline = BSpline::new(degree, points, knots);\n        assert!(check_bspline(&spline, &expect));\n    }", "item_id": 4, "repo": "Twinklebear/bspline", "file": "src/lib.rs", "last_update_at": "2022-03-05T05:25:21+00:00"}
{"hexsha": "c42b742997a8fbeb7cdfa9bc997e9747509a91df", "ext": "rs", "lang": "Rust", "content": "async fn main() -> Result<(), Error> {\n    let address = \"localhost:27015\";\n    let mut conn = Connection::builder()\n        .connect(address, \"test\").await?;\n\n    demo(&mut conn, \"status\").await?;\n    demo(&mut conn, \"users\").await?;\n    demo(&mut conn, \"echo \\\"Rust lang rocks! ;P\\\"\").await?;\n    println!(\"commands finished\");\n\n    Ok(())\n}", "item_id": 0, "repo": "anatawa12/rust-rcon", "file": "examples/source-engine.rs", "last_update_at": "2022-01-03T03:26:09+00:00"}
{"hexsha": "3971c9bbf521ff07b6bea659a9f3b5c159a09aae", "ext": "rs", "lang": "Rust", "content": "fn sort_fskey() {\n    let a = FSKey::compose(0, 0, 0);\n    let b = FSKey::compose(0, 1, 0);\n    let c = FSKey::compose(1, 0, 0);\n    let d = FSKey::compose(0, 1, 1);\n    let e = FSKey::compose(0, 2, 0);\n    let f = FSKey::compose(0, 2, 1);\n    let g = FSKey::compose(0, 2, 2);\n    assert!(a < b && b < c);\n    assert!(b < d && d < e);\n    assert!(e < f && f < g);\n}", "item_id": 7, "repo": "bfffs/bfffs", "file": "bfffs-core/src/fs_tree.rs", "last_update_at": "2022-02-08T03:27:46+00:00"}
{"hexsha": "3c06427b84abab716aeb10bdc7f00708bba08807", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    // Bug from https://github.com/bluss/indexing/issues/12\n    let array = [0, 1, 2, 3, 4, 5];\n    let ix = scope(&array[..], |arr| {\n        let left = arr.vet_range(0..2).unwrap();\n        let left = left.nonempty().unwrap();\n        let (_, right) = arr.range().frontiers();\n\n        let joined = right.join_cover(left);\n        let ix = joined.first();\n        arr[ix]; //~ ERROR: cannot be indexed by\n        ix.integer()\n    });\n    dbg!(array[ix]);\n}", "item_id": 0, "repo": "bluss/indexing", "file": "tests/compile-fail/join_cover.rs", "last_update_at": "2022-03-18T12:56:42+00:00"}
{"hexsha": "94eeb0179269e48b811d7d886afceb3c9ad4c445", "ext": "rs", "lang": "Rust", "content": "fn do_inserts(s: Arc<Storage>, tid: u32, n_records: u32) -> Result<()> {\n    let tid_bytes = tid.to_be_bytes();\n    for id in 0..n_records {\n        let mut key: Vec<u8> = Vec::new();\n        key.extend_from_slice(&id.to_be_bytes());\n        key.extend_from_slice(&tid_bytes);\n        s.put(key, tid_bytes.to_vec())?;\n    }\n    Ok(())\n}", "item_id": 5, "repo": "knizhnik/yakv", "file": "tests/storage_spec.rs", "last_update_at": "2022-03-05T12:50:08+00:00"}
{"hexsha": "e442c968e23f01371625ee2c451f1818ce9837d7", "ext": "rs", "lang": "Rust", "content": "fn add_article(conn_pg: ConnPg, conn_dsl: ConnDsl, user: UserOr, user_id: UserId, data_article: Form<DataArticle>)  -> Template {\n    let data = data_article.get();\n    let uid = user_id.0;\n    let category = &data.category;\n    let title = &data.title;\n    let raw = &data.raw;\n    add_article_by_uid(&conn_dsl, uid, &category, &title, &raw);\n    let datas = article_list(&conn_pg);\n    let context = TemplateArticle {\n        datas: datas,\n        username: user.0,\n        user_id: user_id.0,\n    };\n    Template::render(\"index\", &context)\n}", "item_id": 3, "repo": "alluLinger/kylyp", "file": "src/controller/article.rs", "last_update_at": "2022-03-03T14:38:00+00:00"}
{"hexsha": "a47954f1c09485973a72f04c9a710db160c3d28d", "ext": "rs", "lang": "Rust", "content": "fn get_data(status: (u8, u16, u8), payload: Vec<u8>) -> Vec<u8> {\n    let statindex = if status.0 == CTAPHID_MSG { 0 } else { 1 };\n\n    // data size\n    let datasize = if status.0 == CTAPHID_MSG {\n        // remove SW1 , SW2\n        status.1 - 2\n    } else {\n        status.1\n    };\n\n    // get CBOR\n    let mut data: Vec<u8> = vec![];\n    for n in statindex..datasize {\n        let index: usize = n.into();\n        let dat = payload[index];\n        data.push(dat);\n    }\n    data\n}", "item_id": 2, "repo": "gebogebogebo/ctap-hid-fido2", "file": "src/ctaphid.rs", "last_update_at": "2022-03-27T08:58:38+00:00"}
{"hexsha": "10c37d13c9d7737d94a2336977e75af31c3fabea", "ext": "rs", "lang": "Rust", "content": "fn _0002() {\n  let scope = scope!();\n  scope.set_entry(&\"  \\n  \\n  \\t  thing \\n \\t \\t \".into(), value_null!());\n  accept(\n    &scope,\n    StartTextualExpression,\n    \"thing\",\n    r#\"\n       Name\n       \u2514\u2500 `thing`\n    \"#,\n    false,\n  );\n}", "item_id": 1, "repo": "dmntk/dmntk.rs", "file": "feel-parser/src/tests/name.rs", "last_update_at": "2022-03-31T13:13:29+00:00"}
{"hexsha": "7e6af774643419db92e3ce46aea86f0dc494f050", "ext": "rs", "lang": "Rust", "content": "fn test_small_bit_vec_tests() {\n    let v = BitVec::from_slice(&[0]);\n    assert!(!v.all());\n    assert!(!v.any());\n    assert!(v.none());\n\n    let v = BitVec::from_slice(&[0b00010100]);\n    assert!(!v.all());\n    assert!(v.any());\n    assert!(!v.none());\n\n    let v = BitVec::from_slice(&[0xFF]);\n    assert!(v.all());\n    assert!(v.any());\n    assert!(!v.none());\n}", "item_id": 17, "repo": "huonw/primal", "file": "primal-bit/tests/from_rust.rs", "last_update_at": "2022-03-21T17:42:29+00:00"}
{"hexsha": "705b144edcd33a7acc3d6c5ba52f74b29b11babf", "ext": "rs", "lang": "Rust", "content": "fn save_follower_relation<S: Storage>(\n    storage: &mut S,\n    owner: &CanonicalAddr,\n    followed_addr: &CanonicalAddr,\n) -> StdResult<()> {\n    // save follower relation\n    let mut vec_storage = PrefixedStorage::multilevel(\n        &[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_VEC],\n        storage,\n    );\n    let vec_storage = AppendStoreMut::<Follower, _>::attach_or_create(&mut vec_storage)?;\n    let vec_storage_len = vec_storage.len();\n\n    let link_storage = ReadonlyPrefixedStorage::multilevel(\n        &[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_LINK],\n        storage,\n    );\n\n    let idx: u32 =\n        get_bin_data(&link_storage, owner.as_slice()).unwrap_or_else(|_| vec_storage_len);\n    let follower = Follower {\n        who: owner.clone(),\n        active: true,\n    };\n\n    let mut vec_storage = PrefixedStorage::multilevel(\n        &[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_VEC],\n        storage,\n    );\n    let mut vec_storage = AppendStoreMut::<Follower, _>::attach_or_create(&mut vec_storage)?;\n    if idx == vec_storage_len {\n        vec_storage.push(&follower)?;\n    } else {\n        vec_storage.set_at(idx, &follower)?;\n    }\n\n    let mut link_storage = PrefixedStorage::multilevel(\n        &[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_LINK],\n        storage,\n    );\n    if idx == vec_storage_len {\n        set_bin_data(&mut link_storage, owner.as_slice(), &idx)?;\n    }\n\n    Ok(())\n}", "item_id": 3, "repo": "darwinzer0/fardels", "file": "contract/src/social_state.rs", "last_update_at": "2022-02-21T07:56:50+00:00"}
{"hexsha": "06656cd35a4c28ccebc2eb1592d6fcfa2194d46c", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_MonoReflectionMethodAux() {\n    assert_eq!(\n        ::std::mem::size_of::<MonoReflectionMethodAux>(),\n        56usize,\n        concat!(\"Size of: \", stringify!(MonoReflectionMethodAux))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<MonoReflectionMethodAux>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(MonoReflectionMethodAux))\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_names as *const _ as usize\n        },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(param_names)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_marshall as *const _ as usize\n        },\n        8usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(param_marshall)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_cattr as *const _ as usize\n        },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(param_cattr)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_defaults as *const _ as usize\n        },\n        24usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(param_defaults)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_default_types as *const _\n                as usize\n        },\n        32usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(param_default_types)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).dllentry as *const _ as usize\n        },\n        40usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(dllentry)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<MonoReflectionMethodAux>())).dll as *const _ as usize },\n        48usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(MonoReflectionMethodAux),\n            \"::\",\n            stringify!(dll)\n        )\n    );\n}", "item_id": 49, "repo": "Hezuikn/mono-rs", "file": "src/bindings.rs", "last_update_at": "2022-01-02T08:48:47+00:00"}
{"hexsha": "ab995d2c452535936ef07503967df939967f3aaa", "ext": "rs", "lang": "Rust", "content": "async fn it_test_prometheus_metrics() {\n        let mut mock_service = MockRouterService::new();\n        mock_service\n            .expect_call()\n            .times(1)\n            .returning(move |req: RouterRequest| {\n                Ok(RouterResponse::fake_builder()\n                    .context(req.context)\n                    .build()\n                    .unwrap()\n                    .boxed())\n            });\n\n        let mut dyn_plugin: Box<dyn DynPlugin> = crate::plugin::plugins()\n            .get(\"apollo.telemetry\")\n            .expect(\"Plugin not found\")\n            .create_instance(\n                &Value::from_str(\n                    r#\"{\n                \"apollo\": {\n                    \"client_name_header\": \"name_header\",\n                    \"client_version_header\": \"version_header\",\n                    \"schema_id\": \"schema_sha\"\n                },\n                \"metrics\": {\n                    \"common\": {\n                        \"attributes\": {\n                            \"from_headers\": [\n                                {\n                                    \"named\": \"test\",\n                                    \"default\": \"default_value\",\n                                    \"rename\": \"renamed_value\"\n                                },\n                                {\n                                    \"named\": \"another_test\",\n                                    \"default\": \"my_default_value\"\n                                }\n                            ],\n                            \"static\": [\n                                {\n                                    \"name\": \"myname\",\n                                    \"value\": \"label_value\"\n                                }\n                            ]\n                        }\n                    },\n                    \"prometheus\": {\n                        \"enabled\": true\n                    }\n                }\n            }\"#,\n                )\n                .unwrap(),\n            )\n            .await\n            .unwrap();\n        let mut router_service = dyn_plugin.router_service(BoxService::new(mock_service.build()));\n        let router_req = RouterRequest::fake_builder().header(\"test\", \"my_value_set\");\n\n        let _router_response = router_service\n            .ready()\n            .await\n            .unwrap()\n            .call(router_req.build().unwrap())\n            .await\n            .unwrap()\n            .next_response()\n            .await\n            .unwrap();\n\n        let handler = dyn_plugin.custom_endpoint().unwrap();\n        let http_req_prom = http_compat::Request::fake_builder()\n            .uri(Uri::from_static(\n                \"http://localhost:4000/BADPATH/apollo.telemetry/prometheus\",\n            ))\n            .method(Method::GET)\n            .body(Bytes::new())\n            .build()\n            .unwrap();\n        let resp = handler.clone().oneshot(http_req_prom).await.unwrap();\n        assert_eq!(resp.status(), StatusCode::NOT_FOUND);\n\n        let http_req_prom = http_compat::Request::fake_builder()\n            .uri(Uri::from_static(\n                \"http://localhost:4000/plugins/apollo.telemetry/prometheus\",\n            ))\n            .method(Method::GET)\n            .body(Bytes::new())\n            .build()\n            .unwrap();\n        let resp = handler.oneshot(http_req_prom).await.unwrap();\n        assert_eq!(resp.status(), StatusCode::OK);\n        match resp.body() {\n            crate::ResponseBody::Text(prom_metrics) => {\n                assert!(prom_metrics.contains(r#\"http_requests_total{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\"} 1\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_count{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.001\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.005\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.015\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.05\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.3\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.4\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"0.5\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"1\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"5\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"10\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_bucket{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\",le=\"+Inf\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_count{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\"}\"#));\n                assert!(prom_metrics.contains(r#\"http_request_duration_seconds_sum{another_test=\"my_default_value\",myname=\"label_value\",renamed_value=\"my_value_set\",status=\"200\"}\"#));\n            }\n            _ => panic!(\"body does not have the right format\"),\n        }\n    }", "item_id": 0, "repo": "apollographql/router", "file": "apollo-router/src/plugins/telemetry/mod.rs", "last_update_at": "2022-03-30T22:31:53+00:00"}
{"hexsha": "12616c0908739002fe6187322e988e46314ee927", "ext": "rs", "lang": "Rust", "content": "fn test_P3_Cmp_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}", "item_id": 1406, "repo": "krichard410/moloch-dao-substrate", "file": "target/release/build/typenum-dad1e3c5e3f02b9b/out/tests.rs", "last_update_at": "2022-03-04T01:44:49+00:00"}
{"hexsha": "46625b08d80d6af6416b86a3ba8d1ac961426211", "ext": "rs", "lang": "Rust", "content": "fn transition_callback() {\n        let mut sm = TransitionSm::new();\n        let transits = Arc::new(Mutex::new(Vec::new()));\n        let transits_cb = transits.clone();\n        sm.event_monitor_mut()\n            .add_transition_callback(Callback::new(\n                \"test\",\n                move |t: &Transition<TransitionSm>| {\n                    transits_cb.lock().unwrap().push(t.to_string());\n                },\n            ));\n        sm.transit();\n        assert_eq!(*transits.lock().unwrap(), vec![\"S0->S1\"]);\n        transits.lock().unwrap().clear();\n        sm.transit();\n        assert_eq!(*transits.lock().unwrap(), vec![\"S1->S2\", \"S2->S3\"]);\n    }", "item_id": 5, "repo": "gitter-badger/frame_transpiler", "file": "framec_tests/src/transition.rs", "last_update_at": "2022-02-27T16:36:14+00:00"}
{"hexsha": "36215d036542a38140c6b47e5e448ef5f5fce98a", "ext": "rs", "lang": "Rust", "content": "pub fn register_all_ops(reg: &mut OnnxOpRegister) {\n    reg.insert(\"GRU\", gru::gru);\n    reg.insert(\"LSTM\", lstm::lstm);\n    reg.insert(\"RNN\", rnn::rnn);\n    reg.insert(\"Scan\", scan::scan);\n}", "item_id": 0, "repo": "mithril-security/tract-sgx-xargo", "file": "onnx/src/ops/rec.rs", "last_update_at": "2022-03-31T08:14:32+00:00"}
{"hexsha": "1abc65f64eec87163d57f09aaf6b5b24fae16bb6", "ext": "rs", "lang": "Rust", "content": "fn parse2() {\n    use crate::Pane;\n    use crate::PANE_ALL;\n\n    let origin = Pane {\n        #[cfg(feature = \"tmux_1_6\")]\n        active: Some(true),\n        #[cfg(feature = \"tmux_2_6\")]\n        at_bottom: Some(true),\n        #[cfg(feature = \"tmux_2_6\")]\n        at_left: Some(true),\n        #[cfg(feature = \"tmux_2_6\")]\n        at_right: Some(true),\n        #[cfg(feature = \"tmux_2_6\")]\n        at_top: Some(true),\n        #[cfg(feature = \"tmux_2_0\")]\n        bottom: Some(63),\n        #[cfg(feature = \"tmux_1_8\")]\n        current_command: Some(\"bash\".to_string()),\n        #[cfg(feature = \"tmux_1_7\")]\n        current_path: Some(\"/home/user\".to_string()),\n        #[cfg(feature = \"tmux_1_6\")]\n        dead: Some(false),\n        #[cfg(feature = \"tmux_2_0\")]\n        dead_status: None,\n        #[cfg(feature = \"tmux_2_6\")]\n        format: Some(true),\n        #[cfg(feature = \"tmux_1_6\")]\n        height: Some(64),\n        #[cfg(feature = \"tmux_1_6\")]\n        id: Some(0),\n        #[cfg(feature = \"tmux_1_8\")]\n        in_mode: Some(false),\n        #[cfg(feature = \"tmux_1_7\")]\n        index: Some(0),\n        #[cfg(feature = \"tmux_2_0\")]\n        input_off: Some(false),\n        #[cfg(feature = \"tmux_2_0\")]\n        left: Some(0),\n        #[cfg(feature = \"tmux_3_0\")]\n        marked: Some(false),\n        #[cfg(feature = \"tmux_3_0\")]\n        marked_set: Some(false),\n        #[cfg(feature = \"tmux_2_5\")]\n        mode: None,\n        #[cfg(feature = \"tmux_3_1\")]\n        path: None,\n        #[cfg(feature = \"tmux_1_6\")]\n        pid: Some(1945),\n        #[cfg(feature = \"tmux_2_6\")]\n        pipe: Some(false),\n        #[cfg(feature = \"tmux_2_0\")]\n        right: Some(176),\n        #[cfg(feature = \"tmux_2_5\")]\n        search_string: None,\n        #[cfg(feature = \"tmux_1_6\")]\n        start_command: None,\n        #[cfg(all(feature = \"tmux_1_6\", not(feature = \"tmux_2_0\")))]\n        start_path: None,\n        #[cfg(feature = \"tmux_1_9\")]\n        synchronized: Some(false),\n        #[cfg(feature = \"tmux_1_8\")]\n        tabs: None,\n        #[cfg(feature = \"tmux_1_6\")]\n        title: Some(\"title\".to_string()),\n        #[cfg(feature = \"tmux_2_0\")]\n        top: Some(0),\n        #[cfg(feature = \"tmux_1_6\")]\n        tty: Some(\"/dev/pts/2\".to_string()),\n        #[cfg(feature = \"tmux_1_6\")]\n        width: Some(177),\n    };\n\n    let pane_vec = vec![\n        // pane_active\n        #[cfg(feature = \"tmux_1_6\")]\n        \"1\",\n        // pane_at_bottom\n        #[cfg(feature = \"tmux_2_6\")]\n        \"1\",\n        // pane_at_left\n        #[cfg(feature = \"tmux_2_6\")]\n        \"1\",\n        // pane_at_right\n        #[cfg(feature = \"tmux_2_6\")]\n        \"1\",\n        // pane_at_top\n        #[cfg(feature = \"tmux_2_6\")]\n        \"1\",\n        // pane_bottom\n        #[cfg(feature = \"tmux_2_0\")]\n        \"63\",\n        // pane_current_command\n        #[cfg(feature = \"tmux_1_8\")]\n        \"bash\",\n        // pane_current_path\n        #[cfg(feature = \"tmux_1_7\")]\n        \"/home/user\",\n        // pane_dead\n        #[cfg(feature = \"tmux_1_6\")]\n        \"0\",\n        // pane_dead_status\n        #[cfg(feature = \"tmux_2_0\")]\n        \"\",\n        // pane_format\n        #[cfg(feature = \"tmux_2_6\")]\n        \"1\",\n        // pane_height\n        #[cfg(feature = \"tmux_1_6\")]\n        \"64\",\n        // pane_id\n        #[cfg(feature = \"tmux_1_6\")]\n        \"%0\",\n        // pane_in_mode\n        #[cfg(feature = \"tmux_1_8\")]\n        \"0\",\n        // pane_index\n        #[cfg(feature = \"tmux_1_7\")]\n        \"0\",\n        // pane_input_off\n        #[cfg(feature = \"tmux_2_0\")]\n        \"0\",\n        // pane_left\n        #[cfg(feature = \"tmux_2_0\")]\n        \"0\",\n        // pane_marked\n        #[cfg(feature = \"tmux_3_0\")]\n        \"0\",\n        // pane_marked_set\n        #[cfg(feature = \"tmux_3_0\")]\n        \"0\",\n        // pane_mode\n        #[cfg(feature = \"tmux_2_5\")]\n        \"\",\n        // pane_path\n        #[cfg(feature = \"tmux_3_1\")]\n        \"\",\n        // pane_pid\n        #[cfg(feature = \"tmux_1_6\")]\n        \"1945\",\n        // pane_pipe\n        #[cfg(feature = \"tmux_2_6\")]\n        \"0\",\n        // pane_right\n        #[cfg(feature = \"tmux_2_0\")]\n        \"176\",\n        // pane_search_string\n        #[cfg(feature = \"tmux_2_5\")]\n        \"\",\n        // pane_start_command\n        #[cfg(feature = \"tmux_1_6\")]\n        \"\",\n        // pane_start_path\n        #[cfg(all(feature = \"tmux_1_6\", not(feature = \"tmux_2_0\")))]\n        \"\",\n        // pane_synchronized\n        #[cfg(feature = \"tmux_1_9\")]\n        \"0\",\n        // pane_tabs\n        #[cfg(feature = \"tmux_1_8\")]\n        \"\",\n        // pane_title\n        #[cfg(feature = \"tmux_1_6\")]\n        \"title\",\n        // pane_top\n        #[cfg(feature = \"tmux_2_0\")]\n        \"0\",\n        // pane_tty\n        #[cfg(feature = \"tmux_1_6\")]\n        \"/dev/pts/2\",\n        // pane_width\n        #[cfg(feature = \"tmux_1_6\")]\n        \"177\",\n    ];\n    //let pane_str = \"1'1'1'1'1'63'bash'/home/user'0''1'64'%0'0'0'0'0'0'0''1945'0'176'''0''asus'0'/dev/pts/2'177\";\n    //let pane_str = \"1'1'1'1'1'63'bash'/home/user'0''1'64'%0'0'0'0'0'0'0''1945'0'176'''0'8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128,136,144,152,160,168,176'asus'0'/dev/pts/2'177\";\n    let pane_str = pane_vec.join(\"'\");\n    let pane = Pane::from_str(&pane_str, PANE_ALL).unwrap();\n    //assert_eq!(pane.current_path, Some(\"/home/user\".to_string()));\n    //assert_eq!(pane.tty, Some(\"/dev/pts/2\".to_string()));\n    assert_eq!(origin, pane);\n}", "item_id": 5, "repo": "AntonGepting/tmux-interface", "file": "src/variables/pane/pane_tests.rs", "last_update_at": "2022-03-23T14:10:45+00:00"}
{"hexsha": "6fe4c5300e59e2d27e2db3e5eaf76d4b37a8332d", "ext": "rs", "lang": "Rust", "content": "fn built_in_fn_to_string() {\n    let ast = src_to_ast(vec![\n        r#\"\u09a6\u09c7\u0996\u09be\u0993 _\u09b8\u09cd\u099f\u09cd\u09b0\u09bf\u0982(\u09e7) == \"\u09e7\";\"#,\n        r#\"\u09a6\u09c7\u0996\u09be\u0993 _\u09b8\u09cd\u099f\u09cd\u09b0\u09bf\u0982(\u09e7.\u09e6) == \"\u09e7\";\"#,\n        r#\"\u09a6\u09c7\u0996\u09be\u0993 _\u09b8\u09cd\u099f\u09cd\u09b0\u09bf\u0982(-\u09e7.\u09e6) == \"-\u09e7\";\"#,\n        r#\"\u09a6\u09c7\u0996\u09be\u0993 _\u09b8\u09cd\u099f\u09cd\u09b0\u09bf\u0982(\u09e7\u09e9.\u09e9\u09e8) == \"\u09e7\u09e9.\u09e9\u09e8\";\"#,\n        r#\"\u09a6\u09c7\u0996\u09be\u0993 _\u09b8\u09cd\u099f\u09cd\u09b0\u09bf\u0982(-\u09ea\u09e9.\u09ea\u09e9) == \"-\u09ea\u09e9.\u09ea\u09e9\";\"#,\n        r#\"\u09a6\u09c7\u0996\u09be\u0993 _\u09b8\u09cd\u099f\u09cd\u09b0\u09bf\u0982(-\u09e6.\u09ea\u09e9) == \"-\u09e6.\u09ea\u09e9\";\"#,\n    ]);\n    let mut mock_io: MockIO = MockIO::new();\n    mock_io.expect_println(\"\u09b8\u09a4\u09cd\u09af\");\n    mock_io.expect_println(\"\u09b8\u09a4\u09cd\u09af\");\n    mock_io.expect_println(\"\u09b8\u09a4\u09cd\u09af\");\n    mock_io.expect_println(\"\u09b8\u09a4\u09cd\u09af\");\n    mock_io.expect_println(\"\u09b8\u09a4\u09cd\u09af\");\n    mock_io.expect_println(\"\u09b8\u09a4\u09cd\u09af\");\n    if let Err(err) = run_assert_all_true(ast, mock_io) {\n        panic!(\"{:?}\", err);\n    }\n}", "item_id": 33, "repo": "Shafin098/pakhi-bhasha", "file": "tests/interpreter.rs", "last_update_at": "2022-02-28T12:36:20+00:00"}
{"hexsha": "e1cf57a1a62cadc5d181bfdf945465ab99f18ee1", "ext": "rs", "lang": "Rust", "content": "fn bench_cidentity_giant(b: &mut Bencher) {\n        let n = 16;\n\n        let mat = from_reals(&[1.0, 0.0, 0.0, 1.0]);\n        let c_indices = (0..n - 1).collect();\n        let op = make_matrix_op(vec![n - 1], mat).unwrap();\n        let op = make_control_op(c_indices, op).unwrap();\n\n        let base_vector: Vec<f64> = (0..1 << n).map(|_| 0.0).collect();\n        let input = from_reals(&base_vector);\n        let mut output = from_reals(&base_vector);\n\n        b.iter(|| apply_op(n, &op, &input, &mut output, 0, 0));\n    }", "item_id": 6, "repo": "oxarbitrage/RustQIP", "file": "benches/state_bench.rs", "last_update_at": "2022-03-30T13:48:29+00:00"}
{"hexsha": "c95d9a131896a303b21d2e61f964bf127f8db7b1", "ext": "rs", "lang": "Rust", "content": "fn split<'a>(r: &'a Regex, text: &'a str) -> Vec<&'a str> {\n    let mut result = Vec::new();\n    let mut last = 0;\n    for (index, matched) in text.match_indices(r) {\n        if last != index {\n            result.push(&text[last..index]);\n        }\n        result.push(matched);\n\n        last = index + matched.len();\n    }\n    if last < text.len() {\n        result.push(&text[last..]);\n    }\n    result\n}", "item_id": 0, "repo": "marc2332/ham", "file": "ham_core/src/lib.rs", "last_update_at": "2022-03-07T16:03:57+00:00"}
{"hexsha": "7396a47a37791c0e23bfdc96eb93b85c0b853f6f", "ext": "rs", "lang": "Rust", "content": "pub extern \"C\" fn ipassignment_free(ip_assignment: *mut IpAssignment<u32>) {\n        assert!(!ip_assignment.is_null());\n        unsafe { Box::from_raw(ip_assignment) };\n    }", "item_id": 5, "repo": "mjptree/shadow", "file": "src/main/routing/network_graph.rs", "last_update_at": "2022-03-30T09:04:18+00:00"}
{"hexsha": "6c7cf2611001c13b04b5b9ee7237f07c08d40a20", "ext": "rs", "lang": "Rust", "content": "fn empty_git_commit<'r>(\n    git_repo: &'r git2::Repository,\n    ref_name: &str,\n    parents: &[&git2::Commit],\n) -> git2::Commit<'r> {\n    let signature = git2::Signature::now(\"Someone\", \"someone@example.com\").unwrap();\n    let empty_tree_id = Oid::from_str(\"4b825dc642cb6eb9a060e54bf8d69288fbee4904\").unwrap();\n    let empty_tree = git_repo.find_tree(empty_tree_id).unwrap();\n    let oid = git_repo\n        .commit(\n            Some(ref_name),\n            &signature,\n            &signature,\n            &format!(\"random commit {}\", rand::random::<u32>()),\n            &empty_tree,\n            parents,\n        )\n        .unwrap();\n    git_repo.find_commit(oid).unwrap()\n}", "item_id": 0, "repo": "clayne/jj", "file": "lib/tests/test_git.rs", "last_update_at": "2022-03-30T23:59:48+00:00"}
{"hexsha": "976070c649d0db7bbc274371fdedab5a49d4603e", "ext": "rs", "lang": "Rust", "content": "fn nontrivial_identity_syntactic() {\n    // dnf (!a * !b * !c) + (!a * !b * c) + (!a * b * c) + (a * !b * c) + (a * b * !c)\n    //                                    <=>\n    // cnf            !(!a * b * !c) * !(a * !b * !c) * !(a * b * c)\n    let variables = mk_5_variable_set();\n    let a = variables.mk_var(v1());\n    let b = variables.mk_var(v2());\n    let c = variables.mk_var(v3());\n\n    let d1 = bdd!(((!a) & (!b)) & (!c));\n    let d2 = bdd!(((!a) & (!b)) & c);\n    let d3 = bdd!(((!a) & b) & c);\n    let d4 = bdd!((a & (!b)) & c);\n    let d5 = bdd!((a & b) & (!c));\n\n    let c1 = bdd!((a | (!b)) | c);\n    let c2 = bdd!(((!a) | b) | c);\n    let c3 = bdd!(((!a) | (!b)) | (!c));\n\n    let cnf = bdd!(((c1 & c2) & c3));\n    let dnf = bdd!(((((d1 | d2) | d3) | d4) | d5));\n\n    assert_eq!(cnf, dnf);\n    assert!(bdd!((cnf <=> dnf)).is_true());\n    assert_eq!(20.0, cnf.cardinality());\n}", "item_id": 12, "repo": "lengyijun/biodivine-lib-bdd", "file": "src/_test_bdd/_test_bdd_logic_basic.rs", "last_update_at": "2022-03-10T09:57:36+00:00"}
{"hexsha": "54505e5beaa6a4e62e0c01348f1e97462aeb6b2a", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn opj_dwt_init_sparse_array(\n  mut tilec: *mut opj_tcd_tilecomp_t,\n  mut numres: OPJ_UINT32,\n) -> *mut opj_sparse_array_int32_t {\n  let mut tr_max: *mut opj_tcd_resolution_t = &mut *(*tilec)\n    .resolutions\n    .offset(numres.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize)\n    as *mut opj_tcd_resolution_t;\n  let mut w = ((*tr_max).x1 - (*tr_max).x0) as OPJ_UINT32;\n  let mut h = ((*tr_max).y1 - (*tr_max).y0) as OPJ_UINT32;\n  let mut resno: OPJ_UINT32 = 0;\n  let mut bandno: OPJ_UINT32 = 0;\n  let mut precno: OPJ_UINT32 = 0;\n  let mut cblkno: OPJ_UINT32 = 0;\n  let mut sa = opj_sparse_array_int32_create(\n    w,\n    h,\n    opj_uint_min(w, 64 as libc::c_int as OPJ_UINT32),\n    opj_uint_min(h, 64 as libc::c_int as OPJ_UINT32),\n  );\n  if sa.is_null() {\n    return 0 as *mut opj_sparse_array_int32_t;\n  }\n  resno = 0 as libc::c_int as OPJ_UINT32;\n  while resno < numres {\n    let mut res: *mut opj_tcd_resolution_t =\n      &mut *(*tilec).resolutions.offset(resno as isize) as *mut opj_tcd_resolution_t;\n    bandno = 0 as libc::c_int as OPJ_UINT32;\n    while bandno < (*res).numbands {\n      let mut band: *mut opj_tcd_band_t =\n        &mut *(*res).bands.as_mut_ptr().offset(bandno as isize) as *mut opj_tcd_band_t;\n      precno = 0 as libc::c_int as OPJ_UINT32;\n      while precno < (*res).pw.wrapping_mul((*res).ph) {\n        let mut precinct: *mut opj_tcd_precinct_t =\n          &mut *(*band).precincts.offset(precno as isize) as *mut opj_tcd_precinct_t;\n        cblkno = 0 as libc::c_int as OPJ_UINT32;\n        while cblkno < (*precinct).cw.wrapping_mul((*precinct).ch) {\n          let mut cblk: *mut opj_tcd_cblk_dec_t =\n            &mut *(*precinct).cblks.dec.offset(cblkno as isize) as *mut opj_tcd_cblk_dec_t;\n          if !(*cblk).decoded_data.is_null() {\n            let mut x = ((*cblk).x0 - (*band).x0) as OPJ_UINT32;\n            let mut y = ((*cblk).y0 - (*band).y0) as OPJ_UINT32;\n            let mut cblk_w = ((*cblk).x1 - (*cblk).x0) as OPJ_UINT32;\n            let mut cblk_h = ((*cblk).y1 - (*cblk).y0) as OPJ_UINT32;\n            if (*band).bandno & 1 as libc::c_int as libc::c_uint != 0 {\n              let mut pres: *mut opj_tcd_resolution_t = &mut *(*tilec)\n                .resolutions\n                .offset(resno.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize)\n                as *mut opj_tcd_resolution_t;\n              x = (x as libc::c_uint).wrapping_add(((*pres).x1 - (*pres).x0) as OPJ_UINT32)\n                as OPJ_UINT32 as OPJ_UINT32\n            }\n            if (*band).bandno & 2 as libc::c_int as libc::c_uint != 0 {\n              let mut pres_0: *mut opj_tcd_resolution_t = &mut *(*tilec)\n                .resolutions\n                .offset(resno.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize)\n                as *mut opj_tcd_resolution_t;\n              y = (y as libc::c_uint).wrapping_add(((*pres_0).y1 - (*pres_0).y0) as OPJ_UINT32)\n                as OPJ_UINT32 as OPJ_UINT32\n            }\n            if opj_sparse_array_int32_write(\n              sa,\n              x,\n              y,\n              x.wrapping_add(cblk_w),\n              y.wrapping_add(cblk_h),\n              (*cblk).decoded_data,\n              1 as libc::c_int as OPJ_UINT32,\n              cblk_w,\n              1 as libc::c_int,\n            ) == 0\n            {\n              opj_sparse_array_int32_free(sa);\n              return 0 as *mut opj_sparse_array_int32_t;\n            }\n          }\n          cblkno = cblkno.wrapping_add(1)\n        }\n        precno = precno.wrapping_add(1)\n      }\n      bandno = bandno.wrapping_add(1)\n    }\n    resno = resno.wrapping_add(1)\n  }\n  return sa;\n}", "item_id": 34, "repo": "Neopallium/openjpeg", "file": "openjp2-rs/src/dwt.rs", "last_update_at": "2022-02-02T19:47:58+00:00"}
{"hexsha": "005643a0c40d69864a931e4b81517ee53d84e2cd", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn compact<TI1, TI2, O1, O2, E1, E2>(\n    old: &ModelImpl<TI1, O1>,\n) -> TractResult<ModelImpl<TI2, O2>>\nwhere\n    TractError: From<E1> + From<E2>,\n    TI1: Fact + Clone + 'static,\n    TI2: Fact + TryFrom<TI1, Error = E1> + Clone + 'static,\n    O1: Display + Debug + Clone + AsRef<dyn Op> + AsMut<dyn Op> + Clone + 'static,\n    O2: Display + TryFrom<O1, Error = E2> + Debug + AsRef<dyn Op> + AsMut<dyn Op> + Clone + 'static,\n{\n    let mut model = ModelImpl::default();\n    let mut map = HashMap::new();\n    for old_id in old.eval_order()? {\n        let old_node = &old.nodes()[old_id];\n        let facts = old_node\n            .outputs\n            .iter()\n            .map(|of| Ok(TI2::try_from(of.fact.clone())?))\n            .collect::<TractResult<TVec<_>>>()\n            .map_err(|e| format!(\"While translating {}: {:?}\", old_node, e))?;\n        let new_op = O2::try_from(old_node.op.clone())?;\n        let new_id = model.add_node(old_node.name.clone(), new_op, facts)?;\n        map.insert(old_id, new_id);\n        for ix in 0..old_node.outputs.len() {\n            if let Some(label) = old.outlet_label(OutletId::new(old_id, ix)) {\n                model.set_outlet_label(OutletId::new(new_id, ix), label.to_string());\n            }\n        }\n        if old.input_outlets()?.contains(&OutletId::new(old_node.id, 0)) {\n            continue;\n        }\n        for (ix, input) in old_node.inputs.iter().enumerate() {\n            model\n                .add_edge(OutletId::new(map[&input.node], input.slot), InletId::new(new_id, ix))?;\n        }\n        for input in old_node.control_inputs.iter() {\n            model.node_mut(new_id).control_inputs.push(map[input]);\n        }\n    }\n    for i in old.input_outlets()? {\n        if !map.contains_key(&i.node) {\n            let node = old.node(i.node);\n            debug!(\"Translate useless source {}\", node);\n            let new_id = model.add_node(\n                &*node.name,\n                O2::try_from(node.op.clone())?,\n                tvec!(TI2::try_from(node.outputs[0].fact.clone())?),\n            )?;\n            map.insert(i.node, new_id);\n        }\n    }\n    // maintaining order of i/o interface\n    model.inputs = old.input_outlets()?.iter().map(|i| OutletId::new(map[&i.node], 0)).collect();\n    model.outputs =\n        old.output_outlets()?.iter().map(|o| OutletId::new(map[&o.node], o.slot)).collect();\n    Ok(model)\n}", "item_id": 1, "repo": "pruthvikar/tract", "file": "core/src/model/compact.rs", "last_update_at": "2022-02-08T08:47:07+00:00"}
{"hexsha": "0ec2a7973349ca2a2a756953a02067d05d6bcb1c", "ext": "rs", "lang": "Rust", "content": "pub fn decode_typedef_or_ref_token<T: Into<Token>>(token: T) -> DecodedToken {\n    let Token(raw_token) = token.into();\n    let tag = raw_token & 0b11;\n    let idx = raw_token >> 2;\n    DecodedToken(\n        match tag {\n            0 => TableKind::TypeDef.into(),\n            1 => TableKind::TypeRef.into(),\n            2 => TableKind::TypeSpec.into(),\n            _ => unreachable!(),\n        },\n        idx,\n    )\n}", "item_id": 1, "repo": "snikeguo/yacht", "file": "src/metadata/token.rs", "last_update_at": "2022-02-10T22:20:07+00:00"}
{"hexsha": "bbc5f888886d49b631e2442b748df5b774b59179", "ext": "rs", "lang": "Rust", "content": "async fn run_server(addr: SocketAddr, rx: watch::Receiver<Vec<u8>>) {\n    println!(\"Listening on http://{}\", addr);\n    // Bind the Hyper HTTP server to addr and start serving requests.\n    let serve_future = Server::bind(&addr)\n        .serve(make_service_fn(|_| {\n            // This function is invoked on every request.\n            // We need to clone rx to avoid moving it to this request.\n            let my_rx = rx.clone();\n            async {\n                // We need to clone my_rx because of the async block.\n                Ok::<_, hyper::Error>(service_fn(move |_req| serve_req(_req, my_rx.clone() )))\n            }\n        }));\n\n    if let Err(e) = serve_future.await {\n        eprintln!(\"Server error: {}\", e);\n    }\n}", "item_id": 1, "repo": "benbusby/raztot", "file": "src/main.rs", "last_update_at": "2022-03-10T19:48:33+00:00"}
{"hexsha": "476d6c1b2aa538eb3a9eb43d026985481306dedf", "ext": "rs", "lang": "Rust", "content": "pub fn parse(source_file: impl Into<SourceFile>) -> Result<Block, ParseError> {\n    let source_file = source_file.into();\n\n    let mut ctx = ParsingContext {\n        source_file: source_file.clone(),\n        regex_parser: regex_syntax::Parser::new(),\n    };\n\n    let mut pair = match grammar::parse(source_file.source_text(), Rule::program) {\n        Ok(pair) => pair,\n        Err(e) => {\n            let span = match e.location {\n                pest::error::InputLocation::Pos(offset) => source_file.slice(offset, offset).unwrap(),\n                pest::error::InputLocation::Span((start, end)) => source_file.slice(start, end).unwrap(),\n            };\n\n            return Err(ParseError::from_pest(span, e));\n        }\n    };\n\n    from_pair(pair.next().unwrap(), &mut ctx)\n}", "item_id": 0, "repo": "sagebind/riptide", "file": "syntax/src/parser.rs", "last_update_at": "2022-02-11T12:01:46+00:00"}
{"hexsha": "300db69bf5f13042adb173fa2905733b51d4a5f0", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn input_value_definition(p: &mut Parser, is_input: bool) {\n    if let Some(TokenKind::Name | TokenKind::StringValue) = p.peek() {\n        let guard = p.start_node(SyntaxKind::INPUT_VALUE_DEFINITION);\n\n        if let Some(TokenKind::StringValue) = p.peek() {\n            description::description(p);\n        }\n\n        name::name(p);\n\n        if let Some(T![:]) = p.peek() {\n            p.bump(S![:]);\n            match p.peek() {\n                Some(TokenKind::Name) | Some(T!['[']) => {\n                    ty::ty(p);\n                    if let Some(T![=]) = p.peek() {\n                        value::default_value(p);\n                    }\n\n                    if let Some(T![@]) = p.peek() {\n                        directive::directives(p);\n                    }\n\n                    if p.peek().is_some() {\n                        guard.finish_node();\n                        return input_value_definition(p, true);\n                    }\n                }\n                _ => p.err(\"expected a Type\"),\n            }\n        } else {\n            p.err(\"expected a Name\");\n        }\n    }\n    // TODO @lrlna: this can be simplified a little bit, and follow the pattern of FieldDefinition\n    if !is_input {\n        p.err(\"expected an Input Value Definition\");\n    }\n}", "item_id": 3, "repo": "MidasLamb/apollo-rs", "file": "crates/apollo-parser/src/parser/grammar/input.rs", "last_update_at": "2022-03-30T17:25:13+00:00"}
{"hexsha": "586d2ffbdf7dfe3e1a0cfcee430bc0202124cbf5", "ext": "rs", "lang": "Rust", "content": "pub fn parse_block_size(s: &str) -> Result<usize> {\n    let block_size_regex = Regex::new(r\"^(?i)(\\d+) *(([km])b?)?$\").unwrap();\n    let captures = block_size_regex.captures(s);\n\n    match captures {\n        Some(groups) => {\n            let units = groups[1].parse::<usize>().context(\"Not a number.\")?;\n            let unit_size = match groups.get(3).map(|m| m.as_str().to_uppercase()) {\n                Some(ref u) if u == \"K\" => 1024,\n                Some(ref u) if u == \"M\" => 1024 * 1024,\n                _ => 1,\n            };\n\n            let bytes_length = (units * unit_size) as usize;\n            if bytes_length & (bytes_length - 1) == 0 {\n                Ok((units * unit_size) as usize)\n            } else {\n                Err(anyhow!(\"Should be a power of two.\"))\n            }\n        }\n        _ => Err(anyhow!(\n            \"Use a number of bytes with optional scale (e.g. 4096, 128k or 2M).\"\n        )),\n    }\n}", "item_id": 0, "repo": "Kostassoid/lethe", "file": "src/ui/args.rs", "last_update_at": "2022-03-30T16:14:14+00:00"}
{"hexsha": "d38394ef5faeccf27b5e0fdae94536904b045835", "ext": "rs", "lang": "Rust", "content": "pub fn center(txt: &str, space: usize) -> Option<String> {\n    // Determine the width of the characters when displayed\n    let len = txt.width();\n    // Return None if there is not enough space to fit the string\n    if len > space {\n        return None;\n    }\n    // Work out total space needed on each side\n    let left_over = space - len;\n    let each = left_over / 2;\n    // Pad the left hand side\n    let left_pad = \" \".repeat(each);\n    // Pad the right hand side\n    let right_pad = \" \".repeat(left_over - each);\n    // Format and return\n    Some(format!(\"{}{}{}\", left_pad, txt, right_pad))\n}", "item_id": 0, "repo": "curlpipe/alinio", "file": "src/align.rs", "last_update_at": "2022-02-21T08:21:52+00:00"}
{"hexsha": "2c041ebea8f5dc28e70bc26be459e8a058631baf", "ext": "rs", "lang": "Rust", "content": "fn new_user(cred:Form<Credentials>\n            ,sess:State<Session>\n            ,mut cookies:Cookies\n            )->Html<String>{\n    let cred = cred.into_inner();\n    let sess = sess.inner();\n    match sess.ub.add_user(&cred.username, &cred.password) {\n        Ok(_)=>{\n            let n = sess.add_session(cred.username.clone());\n            cookies.add(Cookie::new(\"session\",n.to_string()));\n            pages::home_page(&cred.username,0)\n        },\n        Err(e)=>pages::err_page(e,\"/\"),\n    }\n}", "item_id": 0, "repo": "PacktPublishing/-Learn-Rust-in-7-Days", "file": "day7/web_bank/src/main.rs", "last_update_at": "2022-02-14T17:00:17+00:00"}
{"hexsha": "c70c78342b41a82ac5b009713c3ea05562899db1", "ext": "rs", "lang": "Rust", "content": "fn dfs(\n    graph: &Graph<Edge>,\n    u: usize,\n    l: &mut [usize],\n    r: &mut [usize],\n    p: &mut [usize],\n    time: &mut usize,\n) {\n    *time += 1;\n    l[u] = *time;\n\n    for AdjTo{v, ..} in graph.adj_list(u) {\n        if l[v] == 0 {\n            p[v] = l[u];\n            dfs(graph, v, l, r, p, time);\n        }\n    }\n\n    r[u] = *time;\n}", "item_id": 0, "repo": "kena0ki/rustrithm", "file": "tests/codeforces343d.rs", "last_update_at": "2022-03-13T09:43:52+00:00"}
{"hexsha": "856aebc5a75a496a9188c61e4f7a7d5a3c49b82e", "ext": "rs", "lang": "Rust", "content": "pub fn from(path: &Path) -> Result<StorageSet<(Vec<PackStore<MmapPackReader>>, LooseStore)>, std::io::Error> {\n    let packfiles = packfiles_from_path(path)?;\n    let loose = loose_from_path(path)?;\n\n    Ok(StorageSet::new((\n        packfiles,\n        loose\n    )))\n}", "item_id": 0, "repo": "chrisdickinson/git-rs", "file": "src/stores/fs.rs", "last_update_at": "2022-03-10T17:41:14+00:00"}
{"hexsha": "8ed9f34a8638853e7c2b0b1a1b19ce381ebf7f15", "ext": "rs", "lang": "Rust", "content": "pub fn write_initializer(tmd: &mut TableMetaData) {\n    write_default_initializer(tmd.line_writer, &tmd.swift_properties.iter().collect());\n    write_row_initializer_with_starting_index(tmd);\n    write_row_initializer_protocol(tmd);\n}", "item_id": 0, "repo": "Jasperav/GRDB-ORM", "file": "Parser/src/swift_struct/initializer.rs", "last_update_at": "2022-01-07T01:30:53+00:00"}
{"hexsha": "2d49d06763f3ae287a674af43441b543bcbfa1e2", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_lysp_node_choice__bindgen_ty_1() {\n    assert_eq!(\n        ::std::mem::size_of::<lysp_node_choice__bindgen_ty_1>(),\n        64usize,\n        concat!(\"Size of: \", stringify!(lysp_node_choice__bindgen_ty_1))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<lysp_node_choice__bindgen_ty_1>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(lysp_node_choice__bindgen_ty_1))\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<lysp_node_choice__bindgen_ty_1>())).node\n                as *const _ as usize\n        },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(lysp_node_choice__bindgen_ty_1),\n            \"::\",\n            stringify!(node)\n        )\n    );\n}", "item_id": 77, "repo": "ishidawataru/yang2-rs", "file": "libyang2-sys/pre-generated-bindings/libyang2-0aa1f7090ca814f6df6131a6a7ab77db83f0bc57.rs", "last_update_at": "2022-03-06T01:38:29+00:00"}
{"hexsha": "31562cb189e7b55343443e0c48d47187ea7d4bf2", "ext": "rs", "lang": "Rust", "content": "fn get_thread_with_perms() -> impl thorn::AnyQuery {\n    use schema::*;\n    use thorn::*;\n\n    tables! {\n        struct AggPerm {\n            Perms: AggRoomPerms::Perms,\n        }\n    }\n\n    const READ_MESSAGES: i64 = Permission::PACKED_READ_MESSAGE_HISTORY as i64;\n\n    let user_id_var = Var::at(Users::Id, 1);\n    let room_id_var = Var::at(Rooms::Id, 2);\n    let thread_id_var = Var::at(Threads::Id, 3);\n\n    let permissions = AggPerm::as_query(\n        Query::select()\n            .expr(AggRoomPerms::Perms.alias_to(AggPerm::Perms))\n            .from_table::<AggRoomPerms>()\n            .and_where(AggRoomPerms::UserId.equals(user_id_var.clone()))\n            .and_where(AggRoomPerms::RoomId.equals(room_id_var.clone())),\n    );\n\n    Query::with()\n        .with(permissions)\n        .select()\n        .from(Threads::inner_join_table::<AggMessages>().on(AggMessages::MsgId.equals(Threads::ParentId)))\n        .and_where(Threads::Id.equals(thread_id_var))\n        .and_where(\n            AggPerm::Perms\n                .bit_and(READ_MESSAGES.lit())\n                .equals(READ_MESSAGES.lit()),\n        )\n        .cols(Columns::default())\n        .cols(ThreadColumns::default())\n}", "item_id": 2, "repo": "Lantern-chat/server", "file": "crates/server/src/ctrl/room/threads/get.rs", "last_update_at": "2022-01-29T10:11:21+00:00"}
{"hexsha": "772e287872dbb47fac16dfc09bdd21146efdf8e3", "ext": "rs", "lang": "Rust", "content": "pub fn parse_chart(g: &Grammar, input: &[&str]) -> Chart {\n  let mut chart = Chart::new(input.len() + 1);\n\n  for rule in g.rules.get(&g.start).expect(\"grammar missing start rules\") {\n    chart.add(0, State::new(LR0::new(&rule), 0));\n  }\n\n  for k in 0..chart.len() {\n    // need to use while loop because the number of states at k can expand during the loop\n    let mut idx = 0;\n    while idx < chart.len_at(k) {\n      let state = chart.get_state(k, idx);\n      idx += 1;\n\n      if let Some(production) = state.lr0.next_production() {\n        if production.is_nonterminal() {\n          predictor(g, &mut chart, k, &state);\n        } else {\n          scanner(&mut chart, k, &state, input);\n        }\n      } else {\n        completer(&mut chart, k, &state);\n      }\n    }\n  }\n\n  chart\n}", "item_id": 0, "repo": "vgel/treebender", "file": "src/earley.rs", "last_update_at": "2022-02-25T01:33:06+00:00"}
{"hexsha": "39f80b5501609cc74772384959a1c94bee60e925", "ext": "rs", "lang": "Rust", "content": "pub fn lower_cfg(\n    bump: &Bump,\n    b: &mut FunctionBuilder,\n    pat: &PatternContainer,\n    provider: &ErlangPatternProvider,\n    cfg: &PatternCfg<ErlangPatternProvider>,\n    clauses: &[PatternClause],\n    destinations: &DecisionTreeDestinations,\n) -> Block {\n    assert!(destinations.guards.len() == destinations.bodies.len());\n\n    let entry_kind = &cfg.graph[cfg.entry];\n    assert!(*entry_kind == CfgNodeKind::Root);\n\n    let mut ctx = LowerCtx {\n        provider,\n        mapping: BFnvHashMap::with_hasher_in(Default::default(), &bump),\n        destinations,\n    };\n\n    let entry_block = b.block_insert();\n    let entry_arg = b.block_arg_insert(entry_block);\n\n    let mut block = entry_block;\n\n    // First node is a dummy root node\n    let value_list_node = {\n        let mut edges = cfg.graph.edges(cfg.entry);\n        let edge = edges.next().unwrap();\n        assert!(edges.next().is_none());\n\n        let edge_weight = edge.weight();\n        assert!(edge_weight.kind == Some(NodeKind::Wildcard));\n        assert!(edge_weight.variable_binds.len() == 1);\n\n        ctx.bind(edge_weight.variable_binds[0], entry_arg);\n\n        edge.target()\n    };\n\n    let outgoing: Vec<_> = cfg.graph.edges(value_list_node).collect();\n    if outgoing.len() == 2 {\n        // This will always be a ValueList and a Wildcard\n        let val_list_target = outgoing\n            .iter()\n            .find(|o| o.weight().kind == Some(NodeKind::ValueList))\n            .unwrap();\n        assert!(outgoing\n            .iter()\n            .find(|o| o.weight().kind == Some(NodeKind::Wildcard))\n            .is_some());\n\n        if let CfgNodeKind::Match(var) = cfg.graph[value_list_node] {\n            let var_list_len = val_list_target.weight().variable_binds.len();\n            block = b.op_unpack_value_list(block, ctx.get_var_value(var), var_list_len);\n        } else {\n            unreachable!()\n        }\n\n        // Insert variable binds for all value list elements\n        for (idx, var) in val_list_target.weight().variable_binds.iter().enumerate() {\n            let val = b.fun().block_args(block)[idx];\n            ctx.bind(*var, val);\n        }\n\n        lower_cfg_rec(\n            bump,\n            b,\n            pat,\n            &mut ctx,\n            cfg,\n            clauses,\n            block,\n            val_list_target.target(),\n        );\n    } else if outgoing.len() == 0 {\n        // Fail immediately\n        b.op_call_flow(block, destinations.fail, &[]);\n    } else {\n        unreachable!();\n    }\n\n    entry_block\n}", "item_id": 0, "repo": "eirproject/eir", "file": "libeir_passes/src/compile_pattern/lower_cfg.rs", "last_update_at": "2022-03-28T19:08:38+00:00"}
{"hexsha": "9da3e13f17677b46f040f1db0b526ffa66f7b31b", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_structure_crate_model_port_range_from_to(\n    object: &mut aws_smithy_json::serialize::JsonObjectWriter,\n    input: &crate::model::PortRangeFromTo,\n) -> Result<(), aws_smithy_http::operation::SerializationError> {\n    if input.from != 0 {\n        object.key(\"From\").number(\n            #[allow(clippy::useless_conversion)]\n            aws_smithy_types::Number::NegInt((input.from).into()),\n        );\n    }\n    if input.to != 0 {\n        object.key(\"To\").number(\n            #[allow(clippy::useless_conversion)]\n            aws_smithy_types::Number::NegInt((input.to).into()),\n        );\n    }\n    Ok(())\n}", "item_id": 254, "repo": "jdisanti/aws-sdk-rust", "file": "sdk/securityhub/src/json_ser.rs", "last_update_at": "2022-03-02T02:19:58+00:00"}
{"hexsha": "0a5d50245436f77e3cb10a335d220ec877d28b1b", "ext": "rs", "lang": "Rust", "content": "fn should_fail_if_insufficient_receivers() {\n    let max_corrupt_receivers = NumberOfNodes::new(1);\n    let receivers = set_of(&[node_id(NODE_1), node_id(NODE_2)]);\n    let threshold = 2;\n    let config_data = NiDkgConfigData {\n        max_corrupt_receivers,\n        receivers,\n        threshold: NumberOfNodes::new(threshold),\n        ..valid_dkg_config_data()\n    };\n\n    let result = NiDkgConfig::new(config_data);\n\n    assert_eq!(\n        result.unwrap_err(),\n        NiDkgConfigValidationError::InsufficientReceivers {\n            receiver_count: NumberOfNodes::new(2),\n            max_corrupt_receivers,\n            threshold: dkg_threshold(threshold),\n        }\n    );\n}", "item_id": 3, "repo": "3cL1p5e7/ic", "file": "rs/types/types/src/crypto/threshold_sig/ni_dkg/config/tests.rs", "last_update_at": "2022-03-31T11:40:24+00:00"}
{"hexsha": "3039187fc8301af3e6678fad9c3dedec7f2aa613", "ext": "rs", "lang": "Rust", "content": "pub fn deser_operation_crate_operation_update_ip_set(\n    value: &[u8],\n    mut builder: crate::output::update_ip_set_output::Builder,\n) -> Result<crate::output::update_ip_set_output::Builder, aws_smithy_json::deserialize::Error> {\n    let mut tokens_owned =\n        aws_smithy_json::deserialize::json_token_iter(crate::json_deser::or_empty_doc(value))\n            .peekable();\n    let tokens = &mut tokens_owned;\n    aws_smithy_json::deserialize::token::expect_start_object(tokens.next())?;\n    loop {\n        match tokens.next().transpose()? {\n            Some(aws_smithy_json::deserialize::Token::EndObject { .. }) => break,\n            Some(aws_smithy_json::deserialize::Token::ObjectKey { key, .. }) => {\n                match key.to_unescaped()?.as_ref() {\n                    \"ChangeToken\" => {\n                        builder = builder.set_change_token(\n                            aws_smithy_json::deserialize::token::expect_string_or_null(\n                                tokens.next(),\n                            )?\n                            .map(|s| s.to_unescaped().map(|u| u.into_owned()))\n                            .transpose()?,\n                        );\n                    }\n                    _ => aws_smithy_json::deserialize::token::skip_value(tokens)?,\n                }\n            }\n            other => {\n                return Err(aws_smithy_json::deserialize::Error::custom(format!(\n                    \"expected object key or end object, found: {:?}\",\n                    other\n                )))\n            }\n        }\n    }\n    if tokens.next().is_some() {\n        return Err(aws_smithy_json::deserialize::Error::custom(\n            \"found more JSON tokens after completing parsing\",\n        ));\n    }\n    Ok(builder)\n}", "item_id": 82, "repo": "StevenBlack/aws-sdk-rust", "file": "sdk/wafregional/src/json_deser.rs", "last_update_at": "2022-03-31T20:47:15+00:00"}
{"hexsha": "5b24f4e259b056a71984f4199a617730ab78616c", "ext": "rs", "lang": "Rust", "content": "fn key_inception_test() {\n    let mut wallet = UnlockedWallet::new(\"test\");\n    incept_keys(&mut wallet).unwrap();\n    // check next\n    let next = wallet.get_content_by_controller(NEXT);\n    assert!(next.is_some());\n    match next.unwrap() {\n        Content::KeyPair(_) => (),\n        _ => panic!(\"next is not a KeyPair!\")\n    }\n\n    // check current\n    let current = wallet.get_content_by_controller(CURRENT);\n    assert!(current.is_some());\n    match current.unwrap() {\n        Content::KeyPair(_) => (),\n        _ => panic!(\"current is not a KeyPair!\")\n    }\n\n    // check crypto\n    let crypto = wallet.get_content_by_controller(CRYPTO);\n    assert!(crypto.is_some());\n    match crypto.unwrap() {\n        Content::KeyPair(_) => (),\n        _ => panic!(\"crypto is not a KeyPair!\")\n    }\n}", "item_id": 1, "repo": "decentralized-identity/keriox", "file": "src/signer/wallet.rs", "last_update_at": "2022-02-20T17:32:46+00:00"}
{"hexsha": "fbfe62e6f8359fdafe557525d184a4fd33db6145", "ext": "rs", "lang": "Rust", "content": "fn list_should_disable_register() {\n        let a = app(&[]);\n        assert!(!a.output.list);\n        assert!(a.register);\n\n        let a = app(&[\"--list\"]);\n        assert!(a.output.list);\n        assert!(!a.register);\n\n        let a = app(&[\"--list\", \"--register\"]);\n        assert!(a.output.list);\n        assert!(a.register);\n    }", "item_id": 1, "repo": "flyingcircusio/userscan", "file": "src/main.rs", "last_update_at": "2022-03-08T15:03:11+00:00"}
{"hexsha": "f7a484fab27a88addb8effa8e14cecb648ba5243", "ext": "rs", "lang": "Rust", "content": "fn todo_show_should_return_json() {\n        let client = Client::tracked(quake_rocket()).expect(\"valid rocket instance\");\n        let mut response = client.get(\"/action/query?input=todo.show\").dispatch();\n\n        let mut res = \"\".to_string();\n        let _ = response.read_to_string(&mut res);\n\n        assert_eq!(response.status(), Status::Ok);\n        assert_eq!(\n            \"{\\\"entry\\\":\\\"todo\\\",\\\"action\\\":\\\"show\\\",\\\"text\\\":\\\"\\\",\\\"parameters\\\":[]}\",\n            res\n        );\n    }", "item_id": 2, "repo": "zoroqi/quake", "file": "src/server/action_api.rs", "last_update_at": "2022-03-27T01:13:18+00:00"}
{"hexsha": "3d1bc20cca49ecd0870bab4346977e0260b370b0", "ext": "rs", "lang": "Rust", "content": "fn test_hash() {\n      let mut x = Flags::empty();\n      let mut y = Flags::empty();\n      assert!(hash::hash(&x) == hash::hash(&y));\n      x = Flags::all();\n      y = FlagABC;\n      assert!(hash::hash(&x) == hash::hash(&y));\n    }", "item_id": 15, "repo": "TeXitoi/rust", "file": "src/libstd/bitflags.rs", "last_update_at": "2022-03-19T22:44:50+00:00"}
{"hexsha": "a2fc683c9d42063130f072835cbea917bad8fc4d", "ext": "rs", "lang": "Rust", "content": "fn adc_can_add_basic_numbers() {\n            let code = vec![0xA9, 0x05, 0x69, 0x03];\n            let mut cpu = Cpu::new();\n            cpu.load(&code[..], None);\n            cpu.reset();\n\n            cpu.step_n(2);\n\n            assert_eq!(8, cpu.registers.A);\n        }", "item_id": 8, "repo": "kabergstrom/rs6502", "file": "tests/cpu.rs", "last_update_at": "2022-02-06T06:38:52+00:00"}
{"hexsha": "fea1e0d67b1baa2e1d8b4dc79ce2236954ca0498", "ext": "rs", "lang": "Rust", "content": "pub async fn into_struct_from_slice<T>(resp: Response<Body>) -> Result<T>\nwhere\n    T: de::DeserializeOwned,\n{\n    // asynchronously concatenate the buffer from a body into bytes\n    let bytes = hyper::body::to_bytes(resp).await?;\n\n    // try to parse as json with serde_json\n    Ok(serde_json::from_slice(&bytes)?)\n}", "item_id": 1, "repo": "rnag/smartsheet-rs", "file": "src/utils.rs", "last_update_at": "2022-03-01T20:22:55+00:00"}
{"hexsha": "7b2ec5c14c6162741e31364c08f77bad4b609af4", "ext": "rs", "lang": "Rust", "content": "fn is_possible_for_an_already_delegated_node() {\n            let mut deps = helpers::init_contract();\n            let gateway_owner = \"bob\";\n            let identity = add_gateway(gateway_owner, good_gateway_bond(), &mut deps);\n            let delegation_owner = Addr::unchecked(\"sender\");\n\n            let delegation1 = coin(100, DENOM);\n            let delegation2 = coin(50, DENOM);\n\n            try_delegate_to_gateway(\n                deps.as_mut(),\n                mock_env(),\n                mock_info(delegation_owner.as_str(), &vec![delegation1.clone()]),\n                identity.clone(),\n            )\n            .unwrap();\n\n            try_delegate_to_gateway(\n                deps.as_mut(),\n                mock_env(),\n                mock_info(delegation_owner.as_str(), &vec![delegation2.clone()]),\n                identity.clone(),\n            )\n            .unwrap();\n\n            assert_eq!(\n                RawDelegationData::new(\n                    delegation1.amount + delegation2.amount,\n                    mock_env().block.height\n                ),\n                gateway_delegations_read(&deps.storage, &identity)\n                    .load(delegation_owner.as_bytes())\n                    .unwrap()\n            );\n            assert!(\n                reverse_gateway_delegations_read(&deps.storage, &delegation_owner)\n                    .load(identity.as_bytes())\n                    .is_ok()\n            );\n\n            // node's \"total_delegation\" is sum of both\n            assert_eq!(\n                delegation1.amount + delegation2.amount,\n                gateways_read(&deps.storage)\n                    .load(identity.as_bytes())\n                    .unwrap()\n                    .total_delegation\n                    .amount\n            )\n        }", "item_id": 53, "repo": "nymtech/nym", "file": "contracts/mixnet/src/transactions.rs", "last_update_at": "2022-03-31T08:28:41+00:00"}
{"hexsha": "7fafcb91c0aebb5ae266fe08ef07059384fcfa34", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<(), Error> {\n    syslog::init_with_tags(&[\"setui-service\"]).expect(\"Can't init logger\");\n    fx_log_info!(\"Starting setui-service...\");\n\n    let mut executor = fasync::Executor::new()?;\n\n    let (action_tx, action_rx) = futures::channel::mpsc::unbounded::<SettingAction>();\n\n    // Creates switchboard, handed to interface implementations to send messages\n    // to handlers.\n    let (_switchboard_handle, event_tx) = SwitchboardImpl::create(action_tx);\n\n    // Creates registry, used to register handlers for setting types.\n    let _registry_handle = RegistryImpl::create(event_tx, action_rx);\n\n    let mut fs = ServiceFs::new();\n    let handler = Arc::new(SetUIHandler::new());\n    let system_handler = Arc::new(SystemStreamHandler::new(handler.clone()));\n\n    // TODO(SU-210): Remove once other adapters are ready.\n    handler.register_adapter(Box::new(SettingAdapter::new(\n        SettingType::Unknown,\n        Box::new(DefaultStore::new(\"/data/unknown.dat\".to_string(), Box::new(JsonCodec::new()))),\n        MutationHandler { process: &process_string_mutation, check_sync: None },\n        None,\n    )));\n\n    handler.register_adapter(Box::new(SettingAdapter::new(\n        SettingType::Account,\n        Box::new(DefaultStore::new(\"/data/account.dat\".to_string(), Box::new(JsonCodec::new()))),\n        MutationHandler {\n            process: &process_account_mutation,\n            check_sync: Some(&should_sync_account_mutation),\n        },\n        Some(SettingData::Account(AccountSettings { mode: None })),\n    )));\n\n    let handler_clone = handler.clone();\n    fs.dir(\"svc\").add_fidl_service(move |stream: SetUiServiceRequestStream| {\n        let handler_clone = handler_clone.clone();\n\n        fx_log_info!(\"Connecting to setui_service\");\n        fasync::spawn(async move {\n            await!(handler_clone.handle_stream(stream))\n                .unwrap_or_else(|e| error!(\"Failed to spawn {:?}\", e))\n        });\n    });\n\n    // Register for the new settings APIs as well.\n    fs.dir(\"svc\").add_fidl_service(move |stream: SystemRequestStream| {\n        let system_handler_clone = system_handler.clone();\n        fx_log_info!(\"Connecting to System\");\n        fasync::spawn(async move {\n            await!(system_handler_clone.handle_system_stream(stream))\n                .unwrap_or_else(|e| error!(\"Failed to spawn {:?}\", e))\n        });\n    });\n\n    fs.take_and_serve_directory_handle()?;\n    let () = executor.run_singlethreaded(fs.collect());\n    Ok(())\n}", "item_id": 0, "repo": "zhangpf/fuchsia-rs", "file": "garnet/bin/setui/src/main.rs", "last_update_at": "2022-03-02T04:44:22+00:00"}
{"hexsha": "bcc092c580a9eb1ce5fc7439659eb198af30bef5", "ext": "rs", "lang": "Rust", "content": "fn single_many_guard() {\n    assert_eq!(SingleManyGuard::check::<()>(&[]), Ok(()));\n    assert_eq!(SingleManyGuard::check::<()>(&[0]), Ok(()));\n    assert_eq!(SingleManyGuard::check::<()>(&[0, 1]), Ok(()));\n    assert_eq!(SingleManyGuard::check::<()>(&[0, 1, 2]), Ok(()));\n    assert_eq!(SingleManyGuard::check::<()>(&[0, 1, 2, 3]), Ok(()));\n}", "item_id": 3, "repo": "Traverse-Research/safe-transmute-rs", "file": "tests/guard/zero_sized.rs", "last_update_at": "2022-03-29T01:15:49+00:00"}
{"hexsha": "bc286fbae6a23f99a4466d8d65f2c7f38acc5939", "ext": "rs", "lang": "Rust", "content": "async fn test_munmap_not_mapped() {\n        let (_kernel, current_task) = create_kernel_and_task();\n\n        let mapped_address = map_memory(&current_task, UserAddress::default(), *PAGE_SIZE);\n        assert_eq!(sys_munmap(&current_task, mapped_address, *PAGE_SIZE as usize), Ok(SUCCESS));\n        assert_eq!(sys_munmap(&current_task, mapped_address, *PAGE_SIZE as usize), Ok(SUCCESS));\n    }", "item_id": 9, "repo": "Prajwal-Koirala/fuchsia", "file": "src/proc/bin/starnix/mm/syscalls.rs", "last_update_at": "2022-01-04T15:37:09+00:00"}
{"hexsha": "ce843a93a2fa4531761d1f94925bb14a23d9f72a", "ext": "rs", "lang": "Rust", "content": "pub fn open_database(config: &DatabaseSettings, col_meta: Option<u32>, db_type: &str) -> client::error::Result<Arc<KeyValueDB>> {\n\tlet mut db_config = DatabaseConfig::with_columns(Some(NUM_COLUMNS));\n\tdb_config.memory_budget = config.cache_size;\n\tlet path = config.path.to_str().ok_or_else(|| client::error::ErrorKind::Backend(\"Invalid database path\".into()))?;\n\tlet db = Database::open(&db_config, &path).map_err(db_err)?;\n\n\t// check database type\n\tmatch db.get(col_meta, meta_keys::TYPE).map_err(db_err)? {\n\t\tSome(stored_type) => {\n\t\t\tif db_type.as_bytes() != &*stored_type {\n\t\t\t\treturn Err(client::error::ErrorKind::Backend(\n\t\t\t\t\tformat!(\"Unexpected database type. Expected: {}\", db_type)).into());\n\t\t\t}\n\t\t},\n\t\tNone => {\n\t\t\tlet mut transaction = DBTransaction::new();\n\t\t\ttransaction.put(col_meta, meta_keys::TYPE, db_type.as_bytes());\n\t\t\tdb.write(transaction).map_err(db_err)?;\n\t\t},\n\t}\n\n\tOk(Arc::new(db))\n}", "item_id": 2, "repo": "wm5713/blogs", "file": "learn substrate/substrate-1.0/core/client/db/src/utils.rs", "last_update_at": "2022-02-14T16:09:57+00:00"}
{"hexsha": "021e43bdd08646fffd7fd93c4ef845129e3d9d32", "ext": "rs", "lang": "Rust", "content": "fn take_boolean() -> Result<()> {\n        use super::take_boolean;\n        let mut bytes: &[u8] = &[0x01, 0xaf];\n        assert_eq!(take_boolean(&mut bytes)?, true);\n        assert_eq!(bytes, &[0xaf]);\n        Ok(())\n    }", "item_id": 10, "repo": "Night-Shift-Job/toydb", "file": "src/storage/kv/encoding.rs", "last_update_at": "2022-03-30T22:46:54+00:00"}
{"hexsha": "07f4ae5c0e290177615b3c9cbe0ac358020bc5bb", "ext": "rs", "lang": "Rust", "content": "fn make_request_with_document_id() {\n\n        let doc_content = serde_json::builder::ObjectBuilder::new()\n            .insert(\"field\", 42)\n            .build();\n\n        let transport = MockTransport::new();\n\n        let expected = transport\n            .put(vec![\"foo\", \"bar\"])\n            .with_accept_json()\n            .with_json_content(&doc_content)\n            .unwrap();\n\n        let got = {\n            let mut action = CreateDocument::new(&transport, \"/foo\", &doc_content).with_document_id(\"bar\");\n            action.make_request().unwrap()\n        };\n\n        assert_eq!(expected, got);\n    }", "item_id": 1, "repo": "baajur/chill", "file": "src/action/create_document.rs", "last_update_at": "2022-03-10T13:16:21+00:00"}
{"hexsha": "86375a58b94c0bd087ab91e8ffed242f68308f74", "ext": "rs", "lang": "Rust", "content": "pub fn deser_operation_crate_operation_get_device_methods(\n    value: &[u8],\n    mut builder: crate::output::get_device_methods_output::Builder,\n) -> Result<crate::output::get_device_methods_output::Builder, aws_smithy_json::deserialize::Error>\n{\n    let mut tokens_owned =\n        aws_smithy_json::deserialize::json_token_iter(crate::json_deser::or_empty_doc(value))\n            .peekable();\n    let tokens = &mut tokens_owned;\n    aws_smithy_json::deserialize::token::expect_start_object(tokens.next())?;\n    loop {\n        match tokens.next().transpose()? {\n            Some(aws_smithy_json::deserialize::Token::EndObject { .. }) => break,\n            Some(aws_smithy_json::deserialize::Token::ObjectKey { key, .. }) => {\n                match key.to_unescaped()?.as_ref() {\n                    \"deviceMethods\" => {\n                        builder = builder.set_device_methods(\n                            crate::json_deser::deser_list_com_amazonaws_iot1clickdevicesservice___list_of_device_method(tokens)?\n                        );\n                    }\n                    _ => aws_smithy_json::deserialize::token::skip_value(tokens)?,\n                }\n            }\n            other => {\n                return Err(aws_smithy_json::deserialize::Error::custom(format!(\n                    \"expected object key or end object, found: {:?}\",\n                    other\n                )))\n            }\n        }\n    }\n    if tokens.next().is_some() {\n        return Err(aws_smithy_json::deserialize::Error::custom(\n            \"found more JSON tokens after completing parsing\",\n        ));\n    }\n    Ok(builder)\n}", "item_id": 9, "repo": "StevenBlack/aws-sdk-rust", "file": "sdk/iot1clickdevices/src/json_deser.rs", "last_update_at": "2022-03-31T20:47:15+00:00"}
{"hexsha": "ecbcc2862e0cba21d7359b869d7ebc01c05bf2a1", "ext": "rs", "lang": "Rust", "content": "pub fn hello3() {\n    env_setup();\n\n    let mut contract: Contract = Contract::default();\n\n    contract.hello3();\n\n    assert_eq!(\n        contract.get_phrase(),\n        \"Hello from yet_another_module\",\n    );\n}", "item_id": 4, "repo": "On0n0k1/Tutorial_NEAR_Rust", "file": "EN/lesson_4_modules/tests/contract.rs", "last_update_at": "2022-03-13T21:25:37+00:00"}
{"hexsha": "79dd1c39a87551e854f1ed5a8f74f505095d4a98", "ext": "rs", "lang": "Rust", "content": "pub fn adjacent_find(it: Vec<(i64, Array2R)>) -> Vec<usize> {\n    let mut v = Vec::new();\n    for (idx, i) in it.iter().enumerate() {\n        if (idx + 1) >= it.len() {\n            break;\n        }\n        if i.1 == it[idx + 1].1 {\n            v.push(idx);\n        }\n    }\n    v\n}", "item_id": 2, "repo": "npapapietro/liesym", "file": "rootsystem/src/common.rs", "last_update_at": "2022-01-22T01:15:47+00:00"}
