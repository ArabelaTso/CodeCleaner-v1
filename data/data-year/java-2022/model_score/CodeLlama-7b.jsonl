{"hexsha": "7f3b0708d23d5e1ee48dbe7838e969a42e3dc380", "ext": "java", "lang": "Java", "content": "@RunWith(MockitoJUnitRunner.class)\npublic class AndSpecificationTest {\n\n  @Test\n  public void should_satisfied_all() throws Exception {\n    AlwaysSatisfiedSpecification a = new AlwaysSatisfiedSpecification();\n    AlwaysSatisfiedSpecification b = new AlwaysSatisfiedSpecification();\n\n    AndSpecification<String> specification = new AndSpecification(a, b);\n    assertTrue(specification.isSatisfiedBy(\"test\"));\n  }\n\n  @Test\n  public void should_fail_if_any_fail_all() throws Exception {\n    AlwaysSatisfiedSpecification a = new AlwaysSatisfiedSpecification();\n    AlwaysSatisfiedSpecification b = new AlwaysSatisfiedSpecification();\n\n    AndSpecification<String> specification = new AndSpecification(a, b.not());\n    assertFalse(specification.isSatisfiedBy(\"test\"));\n  }\n\n  @Test\n  public void should_print() throws Exception {\n    AlwaysSatisfiedSpecification a = new AlwaysSatisfiedSpecification();\n    AlwaysSatisfiedSpecification b = new AlwaysSatisfiedSpecification();\n\n    AndSpecification<String> specification = new AndSpecification(a, b.not());\n    Pattern pattern = Pattern.compile(\"AND\\\\(.*\\\\)\");\n    assertTrue(pattern.matcher(specification.toString()).matches());\n  }\n}", "item_id": 0, "repo": "PlImbert/blossom", "file": "blossom-core/blossom-core-common/src/test/java/com/blossomproject/core/common/utils/specification/AndSpecificationTest.java", "last_update_at": "2022-01-02T19:52:07+00:00", "question_id": "7f3b0708d23d5e1ee48dbe7838e969a42e3dc380_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(MockitoJUnitRunner.class)\npublic class AndSpecificationTest {\n  @Test\n  public void should_satisfied_all() throws Exception {\n    AlwaysSatisfiedSpecification a = new AlwaysSatisfiedSpecification();\n    AlwaysSatisfiedSpecification b = new AlwaysSatisfiedSpecification();\n    AndSpecification<String> specification = new AndSpecification(a, b);\n    assertTrue(specification.isSatisfiedBy(\"test\"));\n  }\n  @Test\n  public void should_fail_if_any_fail_all() throws Exception {\n    AlwaysSatisfiedSpecification a = new AlwaysSatisfiedSpecification();\n    AlwaysSatisfiedSpecification b = new AlwaysSatisfiedSpecification();\n    AndSpecification<String> specification = new AndSpecification(a, b.not());\n    assertFalse(specification.isSatisfiedBy(\"test\"));\n  }\n  @Test\n  public void should_print() throws Exception {\n    AlwaysSatisfiedSpecification a = new AlwaysSatisfiedSpecification();\n    AlwaysSatisfiedSpecification b = new AlwaysSatisfiedSpecification();\n    AndSpecification<String> specification = new AndSpecification(a, b.not());\n    Pattern pattern = Pattern.compile(\"AND\\\\(.*\\\\)\");\n    assertTrue(pattern.matcher(specification.toString()).matches());\n  }\n"]], "pred": {"ppl": 1.6269551515579224, "ppl_lower": 2.0136704444885254, "ppl/lowercase_ppl": -1.4381433928151222, "ppl/zlib": 0.001649865297430484, "Min_5.0% Prob": 6.055288851261139, "Min_10.0% Prob": 4.166134245693684, "Min_20.0% Prob": 2.3837062026445683, "Min_30.0% Prob": 1.6114351330515073, "Min_40.0% Prob": 1.2210090233514515, "Min_50.0% Prob": 0.9756127839702313, "Min_60.0% Prob": 0.8118201923136105}}
{"hexsha": "5c50e368b7b1ec2a3efb1ffbd26ee59359f6033f", "ext": "java", "lang": "Java", "content": "public class W3CMappingGenerator extends MappingGenerator {\n\t\n\tpublic W3CMappingGenerator(ConnectedDB database) {\n\t\tsuper(database);\n\t\tsetGenerateLabelBridges(false);\n\t\tsetHandleLinkTables(false);\n\t\tsetGenerateDefinitionLabels(false);\n\t\tsetServeVocabulary(false);\n\t\tsetSkipForeignKeyTargetColumns(false);\n\t}\n\n\t@Override\n\tprotected void writeEntityIdentifier(RelationName tableName, List<Attribute> identifierColumns) {\n\t\tString uriPattern = this.instanceNamespaceURI + encodeTableName(tableName);\n\t\tIterator<Attribute> it = identifierColumns.iterator();\n\t\tint i = 0;\n\t\twhile (it.hasNext()) {\n\t\t\turiPattern += i == 0 ? \"/\" : \";\";\n\t\t\ti++;\n\t\t\t\n\t\t\tAttribute column = it.next();\n\t\t\turiPattern += encodeColumnName(column) + \"=@@\" + column.qualifiedName();\n\t\t\tif (!database.columnType(column).isIRISafe()) {\n\t\t\t\turiPattern += \"|encode\";\n\t\t\t}\n\t\t\turiPattern += \"@@\";\n\t\t}\n\t\tthis.out.println(\"\\td2rq:uriPattern \\\"\" + uriPattern + \"\\\";\");\n\t}\n\t\n\t@Override\n\tprotected void writePseudoEntityIdentifier(RelationName tableName) {\n\t\tList<Attribute> usedColumns = filter(schema.listColumns(tableName), true, \"pseudo identifier column\");\n\t\tout.print(\"\\td2rq:bNodeIdColumns \\\"\");\n\t\tIterator<Attribute> it = usedColumns.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tAttribute column = it.next();\n\t\t\tout.print(column.qualifiedName());\n\t\t\tif (it.hasNext()) {\n\t\t\t\tout.print(\",\");\n\t\t\t}\n\t\t}\n\t\tout.println(\"\\\";\");\n\t}\n\t\n\t@Override\n\tprotected String vocabularyIRITurtle(RelationName table) {\n\t\treturn \"<\" + encodeTableName(table) + \">\";\n\t}\n\t\n\t@Override\n\tprotected String vocabularyIRITurtle(Attribute attribute) {\n\t\treturn \"<\" + encodeTableName(attribute.relationName()) + \"#\"\n\t\t+ encodeColumnName(attribute) + \">\";\n\t}\n\t\n\t@Override\n\tprotected String vocabularyIRITurtle(List<Attribute> attributes) {\n\t\tStringBuffer result = new StringBuffer();\n\t\tresult.append(\"<\");\n\t\tresult.append(encodeTableName(attributes.get(0).relationName()));\n\t\tint i = 1;\n\t\tfor (Attribute column: attributes) {\n\t\t\tString attributeName = encodeColumnName(column);\n\t\t\tif (i == 1) {\n\t\t\t\tresult.append(\"#ref-\");\n\t\t\t\tresult.append(attributeName);\n\t\t\t} else {\n\t\t\t\tresult.append(\";\" + attributeName);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tresult.append(\">\");\n\t\treturn result.toString();\n\t}\n\n\tprivate String encodeTableName(RelationName tableName) {\n\t\treturn (tableName.schemaName() == null ? \"\" : IRIEncoder.encode(tableName.schemaName()) + '/')\n\t\t\t+ IRIEncoder.encode(tableName.tableName());\n\t}\n\n\tprivate String encodeColumnName(Attribute column) {\n\t\treturn IRIEncoder.encode(column.attributeName());\n\t}\n}", "item_id": 0, "repo": "arvados/d2rq", "file": "src/de/fuberlin/wiwiss/d2rq/mapgen/W3CMappingGenerator.java", "last_update_at": "2022-03-23T08:30:02+00:00", "question_id": "5c50e368b7b1ec2a3efb1ffbd26ee59359f6033f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class W3CMappingGenerator extends MappingGenerator {\n\t\n\tpublic W3CMappingGenerator(ConnectedDB database) {\n\t\tsuper(database);\n\t\tsetGenerateLabelBridges(false);\n\t\tsetHandleLinkTables(false);\n\t\tsetGenerateDefinitionLabels(false);\n\t\tsetServeVocabulary(false);\n\t\tsetSkipForeignKeyTargetColumns(false);\n\t}\n\t@Override\n\tprotected void writeEntityIdentifier(RelationName tableName, List<Attribute> identifierColumns) {\n\t\tString uriPattern = this.instanceNamespaceURI + encodeTableName(tableName);\n\t\tIterator<Attribute> it = identifierColumns.iterator();\n\t\tint i = 0;\n\t\twhile (it.hasNext()) {\n\t\t\turiPattern += i == 0 ? \"/\" : \";\";\n\t\t\ti++;\n\t\t\t\n\t\t\tAttribute column = it.next();\n\t\t\turiPattern += encodeColumnName(column) + \"=@@\" + column.qualifiedName();\n\t\t\tif (!database.columnType(column).isIRISafe()) {\n\t\t\t\turiPattern += \"|encode\";\n\t\t\t}\n\t\t\turiPattern += \"@@\";\n\t\t}\n\t\tthis.out.println(\"\\td2rq:uriPattern \\\"\" + uriPattern + \"\\\";\");\n\t}\n\t\n\t@Override\n\tprotected void writePseudoEntityIdentifier(RelationName tableName) {\n\t\tList<Attribute> usedColumns = filter(schema.listColumns(tableName), true, \"pseudo identifier column\");\n\t\tout.print(\"\\td2rq:bNodeIdColumns \\\"\");\n\t\tIterator<Attribute> it = usedColumns.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tAttribute column = it.next();\n\t\t\tout.print(column.qualifiedName());\n\t\t\tif (it.hasNext()) {\n\t\t\t\tout.print(\",\");\n\t\t\t}\n\t\t}\n\t\tout.println(\"\\\";\");\n\t}\n\t\n\t@Override\n\tprotected String vocabularyIRITurtle(RelationName table) {\n\t\treturn \"<\" + encodeTableName(table) + \">\";\n\t}\n\t\n\t@Override\n\tprotected String vocabularyIRITurtle(Attribute attribute) {\n\t\treturn \"<\" + encodeTableName(attribute.relationName()) + \"#\"\n\t\t+ encodeColumnName(attribute) + \">\";\n\t}\n\t\n\t@Override\n\tprotected String vocabularyIRITurtle(List<Attribute> attributes) {\n\t\tStringBuffer result = new StringBuffer();\n\t\tresult.append(\"<\");\n\t\tresult.append(encodeTableName(attributes.get(0).relationName()));\n\t\tint i = 1;\n\t\tfor (Attribute column: attributes) {\n\t\t\tString attributeName = encodeColumnName(column);\n\t\t\tif (i == 1) {\n\t\t\t\tresult.append(\"#ref-\");\n\t\t\t\tresult.append(attributeName);\n\t\t\t} else {\n\t\t\t\tresult.append(\";\" + attributeName);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tresult.append(\">\");\n\t\treturn result.toString();\n\t}\n\tprivate String encodeTableName(RelationName tableName) {\n\t\treturn (tableName.schemaName() == null ? \"\" : IRIEncoder.encode(tableName.schemaName()) + '/')\n\t\t\t+ IRIEncoder.encode(tableName.tableName());\n\t}\n\tprivate String encodeColumnName(Attribute column) {\n\t\treturn IRIEncoder.encode(column.attributeName());\n\t}\n"]], "pred": {"ppl": 2.286454916000366, "ppl_lower": 2.4949581623077393, "ppl/lowercase_ppl": -1.1055249640690783, "ppl/zlib": 0.000982188297446107, "Min_5.0% Prob": 7.469698851758784, "Min_10.0% Prob": 5.798675986853513, "Min_20.0% Prob": 3.7764854807068002, "Min_30.0% Prob": 2.6911070600829343, "Min_40.0% Prob": 2.0520494973271157, "Min_50.0% Prob": 1.6512094363021135, "Min_60.0% Prob": 1.3788874943957212}}
{"hexsha": "c2506325303b329653e79d68dec8842d4e6e02a9", "ext": "java", "lang": "Java", "content": "public class ValidatorFactoryImpl implements ValidatorFactory {\n\n    private static final boolean jackson2Present = ClassUtils.isPresent(\"com.fasterxml.jackson.databind.ObjectMapper\", ValidatorFactoryImpl.class.getClassLoader()) &&\n            ClassUtils.isPresent(\"com.fasterxml.jackson.core.JsonGenerator\", ValidatorFactoryImpl.class.getClassLoader());\n\n    private static final boolean jackson2XmlPresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.xml.XmlMapper\", ValidatorFactoryImpl.class.getClassLoader());\n\n    private static final boolean fastjsonPresent = ClassUtils.isPresent(\"com.alibaba.fastjson.JSON\", ValidatorFactoryImpl.class.getClassLoader());\n    \n    private static final boolean commonsFileUploadPresent = ClassUtils.isPresent(\"org.apache.commons.fileupload.servlet.ServletFileUpload\", ValidatorFactoryImpl.class.getClassLoader());\n    \n    private MessageInterpolator messageInterpolator;\n    private List<HttpMessageReader<?>> messageReaders;\n    private ValidationFactory validationFactory;\n    private ValidatorConfig validatorConfig;\n    private boolean initialized;\n    \n    public ValidatorFactoryImpl() {\n    }\n\n    public ValidatorFactoryImpl(ValidatorConfig validatorConfig) {\n        setValidatorConfig(validatorConfig);\n    }\n\n    @Override\n    public MessageInterpolator getMessageInterpolator() {\n        return this.messageInterpolator;\n    }\n    \n    @Override\n    public List<HttpMessageReader<?>> getMessageReaders() {\n        return this.messageReaders;\n    }\n    \n    @Override\n    public ValidationFactory getValidationFactory() {\n        return this.validationFactory;\n    }\n    \n    @Override\n    public ValidatorConfig getValidatorConfig() {\n        return this.validatorConfig;\n    }\n    \n    public void setMessageInterpolator(MessageInterpolator messageInterpolator) {\n        this.messageInterpolator = messageInterpolator;\n    }\n    \n    public void setMessageReaders(List<HttpMessageReader<?>> messageReaders) {\n        this.messageReaders = messageReaders;\n    }\n    \n    public void setValidationFactory(ValidationFactory validationFactory) {\n        this.validationFactory = validationFactory;\n    }\n    \n    public void setValidatorConfig(ValidatorConfig validatorConfig) {\n        Assert.notNull(validatorConfig, \"validator config must not be null.\");\n        this.validatorConfig = validatorConfig;\n    }\n    \n    public void init() {\n        if (this.initialized) {\n            return;\n        }\n        this.initialized = true;\n        if (this.validatorConfig == null) {\n            throw new IllegalArgumentException(\"validator config must not be null.\");\n        }\n        if (this.messageInterpolator == null) {\n            this.messageInterpolator = new ResourceBundleMessageInterpolator();\n        }\n        if (this.messageReaders == null) {\n            this.messageReaders = new ArrayList<>();\n            this.messageReaders.add(new FormHttpMessageReader());\n            if (commonsFileUploadPresent) {\n                this.messageReaders.add(new MultipartFormHttpMessageReader());\n            }\n            if (jackson2Present) {\n                this.messageReaders.add(new MappingJackson2HttpMessageReader());\n            } else if (fastjsonPresent) {\n                this.messageReaders.add(new FastJsonHttpMessageReader());\n            }\n            if (jackson2XmlPresent) {\n                this.messageReaders.add(new MappingJackson2XmlHttpMessageReader());\n            }\n        }\n        if (this.validationFactory == null) {\n            this.validationFactory = new DefaultValidationFactory();\n        }\n        if (this.validatorConfig.getInvalidHandler() == null) {\n            this.validatorConfig.setInvalidHandler(new DefaultInvalidHandler());\n        }\n        if (this.validatorConfig.getValidatorDelegate() == null) {\n            this.validatorConfig.setValidatorDelegate(new DefaultValidatorDelegate());\n        }\n    }\n\n    @Override\n    public Validator buildValidator() {\n        init();\n        return new ValidatorImpl(this);\n    }\n}", "item_id": 0, "repo": "devefx/validator-web", "file": "validator-web/src/main/java/org/devefx/validator/internal/engine/ValidatorFactoryImpl.java", "last_update_at": "2022-03-20T18:10:53+00:00", "question_id": "c2506325303b329653e79d68dec8842d4e6e02a9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ValidatorFactoryImpl implements ValidatorFactory {\n    private static final boolean jackson2Present = ClassUtils.isPresent(\"com.fasterxml.jackson.databind.ObjectMapper\", ValidatorFactoryImpl.class.getClassLoader()) &&\n            ClassUtils.isPresent(\"com.fasterxml.jackson.core.JsonGenerator\", ValidatorFactoryImpl.class.getClassLoader());\n    private static final boolean jackson2XmlPresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.xml.XmlMapper\", ValidatorFactoryImpl.class.getClassLoader());\n    private static final boolean fastjsonPresent = ClassUtils.isPresent(\"com.alibaba.fastjson.JSON\", ValidatorFactoryImpl.class.getClassLoader());\n    private static final boolean commonsFileUploadPresent = ClassUtils.isPresent(\"org.apache.commons.fileupload.servlet.ServletFileUpload\", ValidatorFactoryImpl.class.getClassLoader());\n    private MessageInterpolator messageInterpolator;\n    private List<HttpMessageReader<?>> messageReaders;\n    private ValidationFactory validationFactory;\n    private ValidatorConfig validatorConfig;\n    private boolean initialized;\n    public ValidatorFactoryImpl() {\n    }\n    public ValidatorFactoryImpl(ValidatorConfig validatorConfig) {\n        setValidatorConfig(validatorConfig);\n    }\n    @Override\n    public MessageInterpolator getMessageInterpolator() {\n        return this.messageInterpolator;\n    }\n    @Override\n    public List<HttpMessageReader<?>> getMessageReaders() {\n        return this.messageReaders;\n    }\n    @Override\n    public ValidationFactory getValidationFactory() {\n        return this.validationFactory;\n    }\n    @Override\n    public ValidatorConfig getValidatorConfig() {\n        return this.validatorConfig;\n    }\n    public void setMessageInterpolator(MessageInterpolator messageInterpolator) {\n        this.messageInterpolator = messageInterpolator;\n    }\n    public void setMessageReaders(List<HttpMessageReader<?>> messageReaders) {\n        this.messageReaders = messageReaders;\n    }\n    public void setValidationFactory(ValidationFactory validationFactory) {\n        this.validationFactory = validationFactory;\n    }\n    public void setValidatorConfig(ValidatorConfig validatorConfig) {\n        Assert.notNull(validatorConfig, \"validator config must not be null.\");\n        this.validatorConfig = validatorConfig;\n    }\n    public void init() {\n        if (this.initialized) {\n            return;\n        }\n        this.initialized = true;\n        if (this.validatorConfig == null) {\n            throw new IllegalArgumentException(\"validator config must not be null.\");\n        }\n        if (this.messageInterpolator == null) {\n            this.messageInterpolator = new ResourceBundleMessageInterpolator();\n        }\n        if (this.messageReaders == null) {\n            this.messageReaders = new ArrayList<>();\n            this.messageReaders.add(new FormHttpMessageReader());\n            if (commonsFileUploadPresent) {\n                this.messageReaders.add(new MultipartFormHttpMessageReader());\n            }\n            if (jackson2Present) {\n                this.messageReaders.add(new MappingJackson2HttpMessageReader());\n            } else if (fastjsonPresent) {\n                this.messageReaders.add(new FastJsonHttpMessageReader());\n            }\n            if (jackson2XmlPresent) {\n                this.messageReaders.add(new MappingJackson2XmlHttpMessageReader());\n            }\n        }\n        if (this.validationFactory == null) {\n            this.validationFactory = new DefaultValidationFactory();\n        }\n        if (this.validatorConfig.getInvalidHandler() == null) {\n            this.validatorConfig.setInvalidHandler(new DefaultInvalidHandler());\n        }\n        if (this.validatorConfig.getValidatorDelegate() == null) {\n            this.validatorConfig.setValidatorDelegate(new DefaultValidatorDelegate());\n        }\n    }\n    @Override\n    public Validator buildValidator() {\n        init();\n        return new ValidatorImpl(this);\n    }\n"]], "pred": {"ppl": 1.3933931589126587, "ppl_lower": 1.5006545782089233, "ppl/lowercase_ppl": -1.2235457920024233, "ppl/zlib": 0.00039074428028909586, "Min_5.0% Prob": 4.728193621635437, "Min_10.0% Prob": 2.925236112410479, "Min_20.0% Prob": 1.6155485057184849, "Min_30.0% Prob": 1.0980805849137365, "Min_40.0% Prob": 0.8290227235574734, "Min_50.0% Prob": 0.6635901118944011, "Min_60.0% Prob": 0.5529372437463951}}
{"hexsha": "63b28142dc308b467da56ec4046d9159414ac09e", "ext": "java", "lang": "Java", "content": "public class AmazonTest {\n\n    @BeforeSuite\n    public void setup() {\n        WebDriverManager.chromedriver().setup();\n    }\n\n    public WebDriver getDriver() {\n        SeleniumWaitOptions options = SeleniumWaitOptions.builder()\n                .parseAnnotations(true)\n                .defaultWaitTime(Duration.ofSeconds(30))\n                .packageToBeParsed(\"io.github.sudharsan_selvaraj\")\n                .build();\n        SeleniumWaitPlugin<ChromeDriver> seleniumWaitPlugin = new SeleniumWaitPlugin<ChromeDriver>(new ChromeDriver(), options);\n        return seleniumWaitPlugin.getDriver();\n    }\n\n    @Test\n    public void runTestWthAutoWait() {\n        WebDriver driver = getDriver();\n        driver.get(\"https://www.amazon.in\");\n        driver.findElement(By.id(\"twotabsearchtextbox\")).sendKeys(\"oneplus 7\");\n        driver.findElement(By.id(\"twotabsearchtextbox\")).sendKeys(Keys.ENTER);\n        driver.findElement(By.partialLinkText(\"OnePlus 7 Pro\")).click();\n        driver.switchTo().window(driver.getWindowHandles().toArray(new String[]{})[1]);\n        driver.findElement(By.cssSelector(\"#add-to-cart-button\")).click();\n        driver.findElement(By.cssSelector(\"#attach-view-cart-button-form\")).click();\n    }\n\n    @Test\n    @IgnoreWait\n    public void runTestIgnoreWait() {\n        WebDriver driver = getDriver();\n        driver.get(\"https://www.amazon.in\");\n\n        new WebDriverWait(driver, 10).until(ExpectedConditions.presenceOfElementLocated(By.id(\"twotabsearchtextbox\")));\n\n        driver.findElement(By.id(\"twotabsearchtextbox\")).sendKeys(\"oneplus 7\", Keys.ENTER);\n\n        new WebDriverWait(driver, 10)\n                .until(ExpectedConditions.presenceOfElementLocated(By.partialLinkText(\"OnePlus 7 Pro\")));\n\n        driver.findElement(By.partialLinkText(\"OnePlus 7 Pro\")).click();\n        driver.switchTo().window(driver.getWindowHandles().toArray(new String[]{})[1]);\n\n        new WebDriverWait(driver, 10)\n                .until(ExpectedConditions.presenceOfElementLocated(By.cssSelector(\"#add-to-cart-button\")));\n\n        driver.findElement(By.cssSelector(\"#add-to-cart-button\")).click();\n\n        new WebDriverWait(driver, 10)\n                .until(ExpectedConditions.elementToBeClickable(By.cssSelector(\"#attach-view-cart-button-form\")));\n\n        driver.findElement(By.cssSelector(\"#attach-view-cart-button-form\")).click();\n    }\n}", "item_id": 0, "repo": "sudharsan-selvaraj/selenium-auto-wait", "file": "src/test/java/io/github/sudharsan_selvaraj/amazon/AmazonTest.java", "last_update_at": "2022-01-10T23:57:22+00:00", "question_id": "63b28142dc308b467da56ec4046d9159414ac09e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AmazonTest {\n    @BeforeSuite\n    public void setup() {\n        WebDriverManager.chromedriver().setup();\n    }\n    public WebDriver getDriver() {\n        SeleniumWaitOptions options = SeleniumWaitOptions.builder()\n                .parseAnnotations(true)\n                .defaultWaitTime(Duration.ofSeconds(30))\n                .packageToBeParsed(\"io.github.sudharsan_selvaraj\")\n                .build();\n        SeleniumWaitPlugin<ChromeDriver> seleniumWaitPlugin = new SeleniumWaitPlugin<ChromeDriver>(new ChromeDriver(), options);\n        return seleniumWaitPlugin.getDriver();\n    }\n    @Test\n    public void runTestWthAutoWait() {\n        WebDriver driver = getDriver();\n        driver.get(\"https://www.amazon.in\");\n        driver.findElement(By.id(\"twotabsearchtextbox\")).sendKeys(\"oneplus 7\");\n        driver.findElement(By.id(\"twotabsearchtextbox\")).sendKeys(Keys.ENTER);\n        driver.findElement(By.partialLinkText(\"OnePlus 7 Pro\")).click();\n        driver.switchTo().window(driver.getWindowHandles().toArray(new String[]{})[1]);\n        driver.findElement(By.cssSelector(\"#add-to-cart-button\")).click();\n        driver.findElement(By.cssSelector(\"#attach-view-cart-button-form\")).click();\n    }\n    @Test\n    @IgnoreWait\n    public void runTestIgnoreWait() {\n        WebDriver driver = getDriver();\n        driver.get(\"https://www.amazon.in\");\n        new WebDriverWait(driver, 10).until(ExpectedConditions.presenceOfElementLocated(By.id(\"twotabsearchtextbox\")));\n        driver.findElement(By.id(\"twotabsearchtextbox\")).sendKeys(\"oneplus 7\", Keys.ENTER);\n        new WebDriverWait(driver, 10)\n                .until(ExpectedConditions.presenceOfElementLocated(By.partialLinkText(\"OnePlus 7 Pro\")));\n        driver.findElement(By.partialLinkText(\"OnePlus 7 Pro\")).click();\n        driver.switchTo().window(driver.getWindowHandles().toArray(new String[]{})[1]);\n        new WebDriverWait(driver, 10)\n                .until(ExpectedConditions.presenceOfElementLocated(By.cssSelector(\"#add-to-cart-button\")));\n        driver.findElement(By.cssSelector(\"#add-to-cart-button\")).click();\n        new WebDriverWait(driver, 10)\n                .until(ExpectedConditions.elementToBeClickable(By.cssSelector(\"#attach-view-cart-button-form\")));\n        driver.findElement(By.cssSelector(\"#attach-view-cart-button-form\")).click();\n    }\n"]], "pred": {"ppl": 1.6484768390655518, "ppl_lower": 1.847328782081604, "ppl/lowercase_ppl": -1.2278454843084332, "ppl/zlib": 0.0007810183339508208, "Min_5.0% Prob": 6.5649262700762065, "Min_10.0% Prob": 4.235786718981607, "Min_20.0% Prob": 2.4001115351281266, "Min_30.0% Prob": 1.654583120727426, "Min_40.0% Prob": 1.247405957423996, "Min_50.0% Prob": 0.998657766075293, "Min_60.0% Prob": 0.8339747336905573}}
{"hexsha": "52d3af15d7157eba95b9c9fecb2018428ae5839c", "ext": "java", "lang": "Java", "content": "public class InstanceNotificationPublisher {\n    private static final Log log = LogFactory.getLog(InstanceNotificationPublisher.class);\n\n    public static InstanceNotificationPublisher getInstance() {\n        return InstanceHolder.INSTANCE;\n    }\n\n    private static void publish(Event event) {\n        String topic = MessagingUtil.getMessageTopicName(event);\n\n        EventPublisher instanceNotifyingEvent = EventPublisherPool.\n                getPublisher(topic);\n        instanceNotifyingEvent.publish(event);\n    }\n\n    public synchronized void sendInstanceCleanupEventForCluster(String clusterId, String instanceId) {\n        log.info(String.format(\"Publishing Instance Cleanup Event: [cluster] %s \" +\n                \"[cluster-instance] %s\", clusterId, instanceId));\n        publish(new InstanceCleanupClusterEvent(clusterId, instanceId));\n    }\n\n    /**\n     * Publishing the instance termination notification to the instances\n     *\n     * @param memberId\n     */\n    public synchronized void sendInstanceCleanupEventForMember(String memberId) {\n        log.info(String.format(\"Publishing Instance Cleanup Event: [member] %s\", memberId));\n        publish(new InstanceCleanupMemberEvent(memberId));\n    }\n\n    /* An instance of InstanceNotificationPublisher is created when the class is loaded.\n     * Since the class is loaded only once, it is guaranteed that an object of\n     * InstanceNotificationPublisher is created only once. Hence it is singleton.\n     */\n    private static class InstanceHolder {\n        private static final InstanceNotificationPublisher INSTANCE = new InstanceNotificationPublisher();\n    }\n}", "item_id": 0, "repo": "TanJay/stratos", "file": "components/org.apache.stratos.autoscaler/src/main/java/org/apache/stratos/autoscaler/event/publisher/InstanceNotificationPublisher.java", "last_update_at": "2022-01-19T03:16:20+00:00", "question_id": "52d3af15d7157eba95b9c9fecb2018428ae5839c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class InstanceNotificationPublisher {\n    private static final Log log = LogFactory.getLog(InstanceNotificationPublisher.class);\n    public static InstanceNotificationPublisher getInstance() {\n        return InstanceHolder.INSTANCE;\n    }\n    private static void publish(Event event) {\n        String topic = MessagingUtil.getMessageTopicName(event);\n        EventPublisher instanceNotifyingEvent = EventPublisherPool.\n                getPublisher(topic);\n        instanceNotifyingEvent.publish(event);\n    }\n    public synchronized void sendInstanceCleanupEventForCluster(String clusterId, String instanceId) {\n        log.info(String.format(\"Publishing Instance Cleanup Event: [cluster] %s \" +\n                \"[cluster-instance] %s\", clusterId, instanceId));\n        publish(new InstanceCleanupClusterEvent(clusterId, instanceId));\n    }\n    /**\n     * Publishing the instance termination notification to the instances\n     *\n     * @param memberId\n     */\n    public synchronized void sendInstanceCleanupEventForMember(String memberId) {\n        log.info(String.format(\"Publishing Instance Cleanup Event: [member] %s\", memberId));\n        publish(new InstanceCleanupMemberEvent(memberId));\n    }\n    /* An instance of InstanceNotificationPublisher is created when the class is loaded.\n     * Since the class is loaded only once, it is guaranteed that an object of\n     * InstanceNotificationPublisher is created only once. Hence it is singleton.\n     */\n    private static class InstanceHolder {\n        private static final InstanceNotificationPublisher INSTANCE = new InstanceNotificationPublisher();\n    }\n"]], "pred": {"ppl": 2.098165512084961, "ppl_lower": 2.504128932952881, "ppl/lowercase_ppl": -1.238680720278323, "ppl/zlib": 0.0013449426447816684, "Min_5.0% Prob": 6.06768479347229, "Min_10.0% Prob": 4.7069919400098845, "Min_20.0% Prob": 3.1575053973370286, "Min_30.0% Prob": 2.3384282110679533, "Min_40.0% Prob": 1.8172838760607213, "Min_50.0% Prob": 1.4773187267859489, "Min_60.0% Prob": 1.2332834342202867}}
{"hexsha": "3c6494ce77675634578c1e0e20e539c4048f7e78", "ext": "java", "lang": "Java", "content": "public class Fp6_3Over2 extends AbstractFieldElement<Fp6_3Over2> implements Serializable {\n    protected final Fp2 c0;\n    protected final Fp2 c1;\n    protected final Fp2 c2;\n    private final AbstractFp6_3Over2_Parameters Fp6Parameters;\n\n    public Fp6_3Over2(\n            final Fp2 c0,\n            final Fp2 c1,\n            final Fp2 c2,\n            final AbstractFp6_3Over2_Parameters Fp6Parameters) {\n        this.c0 = c0;\n        this.c1 = c1;\n        this.c2 = c2;\n        this.Fp6Parameters = Fp6Parameters;\n    }\n\n    public Fp6_3Over2 self() {\n        return this;\n    }\n\n    public Fp6_3Over2 add(final Fp6_3Over2 that) {\n        return new Fp6_3Over2(c0.add(that.c0), c1.add(that.c1), c2.add(that.c2), Fp6Parameters);\n    }\n\n    public Fp6_3Over2 sub(final Fp6_3Over2 that) {\n        return new Fp6_3Over2(c0.sub(that.c0), c1.sub(that.c1), c2.sub(that.c2), Fp6Parameters);\n    }\n\n    public Fp6_3Over2 mul(final Fp that) {\n        return new Fp6_3Over2(c0.mul(that), c1.mul(that), c2.mul(that), Fp6Parameters);\n    }\n\n    public Fp6_3Over2 mul(final Fp2 that) {\n        return new Fp6_3Over2(c0.mul(that), c1.mul(that), c2.mul(that), Fp6Parameters);\n    }\n\n    public Fp2 mulByNonResidue(final Fp2 that) {\n        return Fp6Parameters.nonresidue().mul(that);\n    }\n\n    public Fp6_3Over2 mul(final Fp6_3Over2 that) {\n    /* Devegili OhEig Scott Dahab --- Multiplication and Squaring on AbstractPairing-Friendly\n     Fields.pdf; Section 4 (Karatsuba) */\n        final Fp2 c0C0 = c0.mul(that.c0);\n        final Fp2 c1C1 = c1.mul(that.c1);\n        final Fp2 c2C2 = c2.mul(that.c2);\n        final Fp2 c0Factor = c1.add(c2).mul(that.c1.add(that.c2)).sub(c1C1).sub(c2C2);\n        final Fp2 c1Factor = c0.add(c1).mul(that.c0.add(that.c1)).sub(c0C0).sub(c1C1);\n        final Fp2 c2Factor = c0.add(c2).mul(that.c0.add(that.c2)).sub(c0C0).add(c1C1).sub(c2C2);\n\n        return new Fp6_3Over2(\n                c0C0.add(mulByNonResidue(c0Factor)),\n                c1Factor.add(mulByNonResidue(c2C2)),\n                c2Factor,\n                Fp6Parameters);\n    }\n\n    public Fp6_3Over2 zero() {\n        return Fp6Parameters.ZERO();\n    }\n\n    public boolean isZero() {\n        return c0.isZero() && c1.isZero() && c2.isZero();\n    }\n\n    public Fp6_3Over2 one() {\n        return Fp6Parameters.ONE();\n    }\n\n    public boolean isOne() {\n        return c0.isOne() && c1.isZero() && c2.isZero();\n    }\n\n    public Fp6_3Over2 random(final Long seed, final byte[] secureSeed) {\n        return new Fp6_3Over2(\n                c0.random(seed, secureSeed),\n                c1.random(seed, secureSeed),\n                c2.random(seed, secureSeed),\n                Fp6Parameters);\n    }\n\n    public Fp6_3Over2 negate() {\n        return new Fp6_3Over2(c0.negate(), c1.negate(), c2.negate(), Fp6Parameters);\n    }\n\n    public Fp6_3Over2 square() {\n    /* Devegili OhEig Scott Dahab --- Multiplication and Squaring on AbstractPairing-Friendly\n     Fields.pdf; Section 4 (CH-SQR2) */\n        final Fp2 s0 = c0.square();\n        final Fp2 c0c1 = c0.mul(c1);\n        final Fp2 s1 = c0c1.add(c0c1);\n        final Fp2 s2 = c0.sub(c1).add(c2).square();\n        final Fp2 c1c2 = c1.mul(c2);\n        final Fp2 s3 = c1c2.add(c1c2);\n        final Fp2 s4 = c2.square();\n\n        return new Fp6_3Over2(\n                s0.add(mulByNonResidue(s3)),\n                s1.add(mulByNonResidue(s4)),\n                s1.add(s2).add(s3).sub(s0).sub(s4),\n                Fp6Parameters);\n    }\n\n    public Fp6_3Over2 inverse() {\n    /* From \"High-Speed Software Implementation of the Optimal Ate AbstractPairing over\n    Barreto-Naehrig Curves\"; Algorithm 17 */\n        final Fp2 t0 = c0.square();\n        final Fp2 t1 = c1.square();\n        final Fp2 t2 = c2.square();\n        final Fp2 t3 = c0.mul(c1);\n        final Fp2 t4 = c0.mul(c2);\n        final Fp2 t5 = c1.mul(c2);\n        final Fp2 s0 = t0.sub(mulByNonResidue(t5));\n        final Fp2 s1 = mulByNonResidue(t2).sub(t3);\n        final Fp2 s2 = t1\n                .sub(t4); // typo in paper referenced above. should be \"-\" as per Scott, but is \"*\"\n        final Fp2 t6 = c0.mul(s0).add(mulByNonResidue(c2.mul(s1).add(c1.mul(s2)))).inverse();\n\n        return new Fp6_3Over2(t6.mul(s0), t6.mul(s1), t6.mul(s2), Fp6Parameters);\n    }\n\n    public Fp6_3Over2 FrobeniusMap(long power) {\n        return new Fp6_3Over2(c0.FrobeniusMap(power),\n                Fp6Parameters.FrobeniusMapCoefficientsC1()[(int) (power % 6)].mul(c1.FrobeniusMap(power)),\n                Fp6Parameters.FrobeniusMapCoefficientsC2()[(int) (power % 6)].mul(c2.FrobeniusMap(power)),\n                Fp6Parameters);\n    }\n\n    public int bitSize() {\n        return Math.max(c0.bitSize(), Math.max(c1.bitSize(), c2.bitSize()));\n    }\n\n    public Fp6_3Over2 construct(final Fp2 c0, final Fp2 c1, final Fp2 c2) {\n        return new Fp6_3Over2(c0, c1, c2, Fp6Parameters);\n    }\n\n    public String toString() {\n        return c0.toString() + \" / \" + c1.toString() + \" / \" + c2.toString();\n    }\n\n    public boolean equals(final Fp6_3Over2 that) {\n        if (that == null) {\n            return false;\n        }\n\n        return c0.equals(that.c0) && c1.equals(that.c1) && c2.equals(that.c2);\n    }\n}", "item_id": 0, "repo": "sidckchau/dizk", "file": "src/main/java/algebra/fields/Fp6_3Over2.java", "last_update_at": "2022-03-28T14:52:59+00:00", "question_id": "3c6494ce77675634578c1e0e20e539c4048f7e78_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Fp6_3Over2 extends AbstractFieldElement<Fp6_3Over2> implements Serializable {\n    protected final Fp2 c0;\n    protected final Fp2 c1;\n    protected final Fp2 c2;\n    private final AbstractFp6_3Over2_Parameters Fp6Parameters;\n    public Fp6_3Over2(\n            final Fp2 c0,\n            final Fp2 c1,\n            final Fp2 c2,\n            final AbstractFp6_3Over2_Parameters Fp6Parameters) {\n        this.c0 = c0;\n        this.c1 = c1;\n        this.c2 = c2;\n        this.Fp6Parameters = Fp6Parameters;\n    }\n    public Fp6_3Over2 self() {\n        return this;\n    }\n    public Fp6_3Over2 add(final Fp6_3Over2 that) {\n        return new Fp6_3Over2(c0.add(that.c0), c1.add(that.c1), c2.add(that.c2), Fp6Parameters);\n    }\n    public Fp6_3Over2 sub(final Fp6_3Over2 that) {\n        return new Fp6_3Over2(c0.sub(that.c0), c1.sub(that.c1), c2.sub(that.c2), Fp6Parameters);\n    }\n    public Fp6_3Over2 mul(final Fp that) {\n        return new Fp6_3Over2(c0.mul(that), c1.mul(that), c2.mul(that), Fp6Parameters);\n    }\n    public Fp6_3Over2 mul(final Fp2 that) {\n        return new Fp6_3Over2(c0.mul(that), c1.mul(that), c2.mul(that), Fp6Parameters);\n    }\n    public Fp2 mulByNonResidue(final Fp2 that) {\n        return Fp6Parameters.nonresidue().mul(that);\n    }\n    public Fp6_3Over2 mul(final Fp6_3Over2 that) {\n    /* Devegili OhEig Scott Dahab --- Multiplication and Squaring on AbstractPairing-Friendly\n     Fields.pdf; Section 4 (Karatsuba) */\n        final Fp2 c0C0 = c0.mul(that.c0);\n        final Fp2 c1C1 = c1.mul(that.c1);\n        final Fp2 c2C2 = c2.mul(that.c2);\n        final Fp2 c0Factor = c1.add(c2).mul(that.c1.add(that.c2)).sub(c1C1).sub(c2C2);\n        final Fp2 c1Factor = c0.add(c1).mul(that.c0.add(that.c1)).sub(c0C0).sub(c1C1);\n        final Fp2 c2Factor = c0.add(c2).mul(that.c0.add(that.c2)).sub(c0C0).add(c1C1).sub(c2C2);\n        return new Fp6_3Over2(\n                c0C0.add(mulByNonResidue(c0Factor)),\n                c1Factor.add(mulByNonResidue(c2C2)),\n                c2Factor,\n                Fp6Parameters);\n    }\n    public Fp6_3Over2 zero() {\n        return Fp6Parameters.ZERO();\n    }\n    public boolean isZero() {\n        return c0.isZero() && c1.isZero() && c2.isZero();\n    }\n    public Fp6_3Over2 one() {\n        return Fp6Parameters.ONE();\n    }\n    public boolean isOne() {\n        return c0.isOne() && c1.isZero() && c2.isZero();\n    }\n    public Fp6_3Over2 random(final Long seed, final byte[] secureSeed) {\n        return new Fp6_3Over2(\n                c0.random(seed, secureSeed),\n                c1.random(seed, secureSeed),\n                c2.random(seed, secureSeed),\n                Fp6Parameters);\n    }\n    public Fp6_3Over2 negate() {\n        return new Fp6_3Over2(c0.negate(), c1.negate(), c2.negate(), Fp6Parameters);\n    }\n    public Fp6_3Over2 square() {\n    /* Devegili OhEig Scott Dahab --- Multiplication and Squaring on AbstractPairing-Friendly\n     Fields.pdf; Section 4 (CH-SQR2) */\n        final Fp2 s0 = c0.square();\n        final Fp2 c0c1 = c0.mul(c1);\n        final Fp2 s1 = c0c1.add(c0c1);\n        final Fp2 s2 = c0.sub(c1).add(c2).square();\n        final Fp2 c1c2 = c1.mul(c2);\n        final Fp2 s3 = c1c2.add(c1c2);\n        final Fp2 s4 = c2.square();\n        return new Fp6_3Over2(\n                s0.add(mulByNonResidue(s3)),\n                s1.add(mulByNonResidue(s4)),\n                s1.add(s2).add(s3).sub(s0).sub(s4),\n                Fp6Parameters);\n    }\n    public Fp6_3Over2 inverse() {\n    /* From \"High-Speed Software Implementation of the Optimal Ate AbstractPairing over\n    Barreto-Naehrig Curves\"; Algorithm 17 */\n        final Fp2 t0 = c0.square();\n        final Fp2 t1 = c1.square();\n        final Fp2 t2 = c2.square();\n        final Fp2 t3 = c0.mul(c1);\n        final Fp2 t4 = c0.mul(c2);\n        final Fp2 t5 = c1.mul(c2);\n        final Fp2 s0 = t0.sub(mulByNonResidue(t5));\n        final Fp2 s1 = mulByNonResidue(t2).sub(t3);\n        final Fp2 s2 = t1\n                .sub(t4); // typo in paper referenced above. should be \"-\" as per Scott, but is \"*\"\n        final Fp2 t6 = c0.mul(s0).add(mulByNonResidue(c2.mul(s1).add(c1.mul(s2)))).inverse();\n        return new Fp6_3Over2(t6.mul(s0), t6.mul(s1), t6.mul(s2), Fp6Parameters);\n    }\n    public Fp6_3Over2 FrobeniusMap(long power) {\n        return new Fp6_3Over2(c0.FrobeniusMap(power),\n                Fp6Parameters.FrobeniusMapCoefficientsC1()[(int) (power % 6)].mul(c1.FrobeniusMap(power)),\n                Fp6Parameters.FrobeniusMapCoefficientsC2()[(int) (power % 6)].mul(c2.FrobeniusMap(power)),\n                Fp6Parameters);\n    }\n    public int bitSize() {\n        return Math.max(c0.bitSize(), Math.max(c1.bitSize(), c2.bitSize()));\n    }\n    public Fp6_3Over2 construct(final Fp2 c0, final Fp2 c1, final Fp2 c2) {\n        return new Fp6_3Over2(c0, c1, c2, Fp6Parameters);\n    }\n    public String toString() {\n        return c0.toString() + \" / \" + c1.toString() + \" / \" + c2.toString();\n    }\n    public boolean equals(final Fp6_3Over2 that) {\n        if (that == null) {\n            return false;\n        }\n        return c0.equals(that.c0) && c1.equals(that.c1) && c2.equals(that.c2);\n    }\n"]], "pred": {"ppl": 1.3005244731903076, "ppl_lower": 1.628915786743164, "ppl/lowercase_ppl": -1.8568293327917076, "ppl/zlib": 0.0002150307888892865, "Min_5.0% Prob": 3.961432216214199, "Min_10.0% Prob": 2.393826320475223, "Min_20.0% Prob": 1.2891022532667016, "Min_30.0% Prob": 0.8724139841772567, "Min_40.0% Prob": 0.6556404362954108, "Min_50.0% Prob": 0.5255754950926539, "Min_60.0% Prob": 0.4383716619316964}}
{"hexsha": "d57c055c82af9c037ae79288a8be0e21d673952d", "ext": "java", "lang": "Java", "content": "@SpringBootTest(classes = EnvKeeperApp.class)\n@AutoConfigureMockMvc\n@WithMockUser(roles={\"USER\", \"WRITER\"})\npublic class EnvironmentResourceIT {\n\n    private static final String DEFAULT_SHORT_NAME = \"AAAAAAAAAA\";\n    private static final String UPDATED_SHORT_NAME = \"BBBBBBBBBB\";\n\n    private static final String DEFAULT_FULL_NAME = \"AAAAAAAAAA\";\n    private static final String UPDATED_FULL_NAME = \"BBBBBBBBBB\";\n\n    private static final String DEFAULT_DESCRIPTION = \"AAAAAAAAAA\";\n    private static final String UPDATED_DESCRIPTION = \"BBBBBBBBBB\";\n\n    private static final Integer DEFAULT_SORT_ORDER = 1;\n    private static final Integer UPDATED_SORT_ORDER = 2;\n    private static final Integer SMALLER_SORT_ORDER = 1 - 1;\n\n    @Autowired\n    private EnvironmentRepository environmentRepository;\n\n    @Autowired\n    private EnvironmentMapper environmentMapper;\n\n    @Autowired\n    private EnvironmentService environmentService;\n\n    @Autowired\n    private EnvironmentQueryService environmentQueryService;\n\n    @Autowired\n    private EntityManager em;\n\n    @Autowired\n    private MockMvc restEnvironmentMockMvc;\n\n    private Environment environment;\n\n    /**\n     * Create an entity for this test.\n     *\n     * This is a static method, as tests for other entities might also need it,\n     * if they test an entity which requires the current entity.\n     */\n    public static Environment createEntity(EntityManager em) {\n        Environment environment = new Environment()\n            .shortName(DEFAULT_SHORT_NAME)\n            .fullName(DEFAULT_FULL_NAME)\n            .description(DEFAULT_DESCRIPTION)\n            .sortOrder(DEFAULT_SORT_ORDER);\n        // Add required entity\n        EnvironmentGroup environmentGroup;\n        if (TestUtil.findAll(em, EnvironmentGroup.class).isEmpty()) {\n            environmentGroup = EnvironmentGroupResourceIT.createEntity(em);\n            em.persist(environmentGroup);\n            em.flush();\n        } else {\n            environmentGroup = TestUtil.findAll(em, EnvironmentGroup.class).get(0);\n        }\n        environment.setEnvironmentGroup(environmentGroup);\n        return environment;\n    }\n    /**\n     * Create an updated entity for this test.\n     *\n     * This is a static method, as tests for other entities might also need it,\n     * if they test an entity which requires the current entity.\n     */\n    public static Environment createUpdatedEntity(EntityManager em) {\n        Environment environment = new Environment()\n            .shortName(UPDATED_SHORT_NAME)\n            .fullName(UPDATED_FULL_NAME)\n            .description(UPDATED_DESCRIPTION)\n            .sortOrder(UPDATED_SORT_ORDER);\n        // Add required entity\n        EnvironmentGroup environmentGroup;\n        if (TestUtil.findAll(em, EnvironmentGroup.class).isEmpty()) {\n            environmentGroup = EnvironmentGroupResourceIT.createUpdatedEntity(em);\n            em.persist(environmentGroup);\n            em.flush();\n        } else {\n            environmentGroup = TestUtil.findAll(em, EnvironmentGroup.class).get(0);\n        }\n        environment.setEnvironmentGroup(environmentGroup);\n        return environment;\n    }\n\n    @BeforeEach\n    public void initTest() {\n        environment = createEntity(em);\n    }\n\n    @Test\n    @Transactional\n    public void createEnvironment() throws Exception {\n        int databaseSizeBeforeCreate = environmentRepository.findAll().size();\n        // Create the Environment\n        EnvironmentDTO environmentDTO = environmentMapper.toDto(environment);\n        restEnvironmentMockMvc.perform(post(\"/api/environments\")\n            .contentType(MediaType.APPLICATION_JSON)\n            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))\n            .andExpect(status().isCreated());\n\n        // Validate the Environment in the database\n        List<Environment> environmentList = environmentRepository.findAll();\n        assertThat(environmentList).hasSize(databaseSizeBeforeCreate + 1);\n        Environment testEnvironment = environmentList.get(environmentList.size() - 1);\n        assertThat(testEnvironment.getShortName()).isEqualTo(DEFAULT_SHORT_NAME);\n        assertThat(testEnvironment.getFullName()).isEqualTo(DEFAULT_FULL_NAME);\n        assertThat(testEnvironment.getDescription()).isEqualTo(DEFAULT_DESCRIPTION);\n        assertThat(testEnvironment.getSortOrder()).isEqualTo(DEFAULT_SORT_ORDER);\n    }\n\n    @Test\n    @Transactional\n    public void createEnvironmentWithExistingId() throws Exception {\n        int databaseSizeBeforeCreate = environmentRepository.findAll().size();\n\n        // Create the Environment with an existing ID\n        environment.setId(1L);\n        EnvironmentDTO environmentDTO = environmentMapper.toDto(environment);\n\n        // An entity with an existing ID cannot be created, so this API call must fail\n        restEnvironmentMockMvc.perform(post(\"/api/environments\")\n            .contentType(MediaType.APPLICATION_JSON)\n            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))\n            .andExpect(status().isBadRequest());\n\n        // Validate the Environment in the database\n        List<Environment> environmentList = environmentRepository.findAll();\n        assertThat(environmentList).hasSize(databaseSizeBeforeCreate);\n    }\n\n\n    @Test\n    @Transactional\n    public void checkShortNameIsRequired() throws Exception {\n        int databaseSizeBeforeTest = environmentRepository.findAll().size();\n        // set the field null\n        environment.setShortName(null);\n\n        // Create the Environment, which fails.\n        EnvironmentDTO environmentDTO = environmentMapper.toDto(environment);\n\n\n        restEnvironmentMockMvc.perform(post(\"/api/environments\")\n            .contentType(MediaType.APPLICATION_JSON)\n            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))\n            .andExpect(status().isBadRequest());\n\n        List<Environment> environmentList = environmentRepository.findAll();\n        assertThat(environmentList).hasSize(databaseSizeBeforeTest);\n    }\n\n    @Test\n    @Transactional\n    public void checkFullNameIsRequired() throws Exception {\n        int databaseSizeBeforeTest = environmentRepository.findAll().size();\n        // set the field null\n        environment.setFullName(null);\n\n        // Create the Environment, which fails.\n        EnvironmentDTO environmentDTO = environmentMapper.toDto(environment);\n\n\n        restEnvironmentMockMvc.perform(post(\"/api/environments\")\n            .contentType(MediaType.APPLICATION_JSON)\n            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))\n            .andExpect(status().isBadRequest());\n\n        List<Environment> environmentList = environmentRepository.findAll();\n        assertThat(environmentList).hasSize(databaseSizeBeforeTest);\n    }\n\n    @Test\n    @Transactional\n    public void checkDescriptionIsRequired() throws Exception {\n        int databaseSizeBeforeTest = environmentRepository.findAll().size();\n        // set the field null\n        environment.setDescription(null);\n\n        // Create the Environment, which fails.\n        EnvironmentDTO environmentDTO = environmentMapper.toDto(environment);\n\n\n        restEnvironmentMockMvc.perform(post(\"/api/environments\")\n            .contentType(MediaType.APPLICATION_JSON)\n            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))\n            .andExpect(status().isBadRequest());\n\n        List<Environment> environmentList = environmentRepository.findAll();\n        assertThat(environmentList).hasSize(databaseSizeBeforeTest);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironments() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList\n        restEnvironmentMockMvc.perform(get(\"/api/environments?sort=id,desc\"))\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_VALUE))\n            .andExpect(jsonPath(\"$.[*].id\").value(hasItem(environment.getId().intValue())))\n            .andExpect(jsonPath(\"$.[*].shortName\").value(hasItem(DEFAULT_SHORT_NAME)))\n            .andExpect(jsonPath(\"$.[*].fullName\").value(hasItem(DEFAULT_FULL_NAME)))\n            .andExpect(jsonPath(\"$.[*].description\").value(hasItem(DEFAULT_DESCRIPTION)))\n            .andExpect(jsonPath(\"$.[*].sortOrder\").value(hasItem(DEFAULT_SORT_ORDER)));\n    }\n\n    @Test\n    @Transactional\n    public void getEnvironment() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get the environment\n        restEnvironmentMockMvc.perform(get(\"/api/environments/{id}\", environment.getId()))\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_VALUE))\n            .andExpect(jsonPath(\"$.id\").value(environment.getId().intValue()))\n            .andExpect(jsonPath(\"$.shortName\").value(DEFAULT_SHORT_NAME))\n            .andExpect(jsonPath(\"$.fullName\").value(DEFAULT_FULL_NAME))\n            .andExpect(jsonPath(\"$.description\").value(DEFAULT_DESCRIPTION))\n            .andExpect(jsonPath(\"$.sortOrder\").value(DEFAULT_SORT_ORDER));\n    }\n\n\n    @Test\n    @Transactional\n    public void getEnvironmentsByIdFiltering() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        Long id = environment.getId();\n\n        defaultEnvironmentShouldBeFound(\"id.equals=\" + id);\n        defaultEnvironmentShouldNotBeFound(\"id.notEquals=\" + id);\n\n        defaultEnvironmentShouldBeFound(\"id.greaterThanOrEqual=\" + id);\n        defaultEnvironmentShouldNotBeFound(\"id.greaterThan=\" + id);\n\n        defaultEnvironmentShouldBeFound(\"id.lessThanOrEqual=\" + id);\n        defaultEnvironmentShouldNotBeFound(\"id.lessThan=\" + id);\n    }\n\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByShortNameIsEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where shortName equals to DEFAULT_SHORT_NAME\n        defaultEnvironmentShouldBeFound(\"shortName.equals=\" + DEFAULT_SHORT_NAME);\n\n        // Get all the environmentList where shortName equals to UPDATED_SHORT_NAME\n        defaultEnvironmentShouldNotBeFound(\"shortName.equals=\" + UPDATED_SHORT_NAME);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByShortNameIsNotEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where shortName not equals to DEFAULT_SHORT_NAME\n        defaultEnvironmentShouldNotBeFound(\"shortName.notEquals=\" + DEFAULT_SHORT_NAME);\n\n        // Get all the environmentList where shortName not equals to UPDATED_SHORT_NAME\n        defaultEnvironmentShouldBeFound(\"shortName.notEquals=\" + UPDATED_SHORT_NAME);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByShortNameIsInShouldWork() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where shortName in DEFAULT_SHORT_NAME or UPDATED_SHORT_NAME\n        defaultEnvironmentShouldBeFound(\"shortName.in=\" + DEFAULT_SHORT_NAME + \",\" + UPDATED_SHORT_NAME);\n\n        // Get all the environmentList where shortName equals to UPDATED_SHORT_NAME\n        defaultEnvironmentShouldNotBeFound(\"shortName.in=\" + UPDATED_SHORT_NAME);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByShortNameIsNullOrNotNull() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where shortName is not null\n        defaultEnvironmentShouldBeFound(\"shortName.specified=true\");\n\n        // Get all the environmentList where shortName is null\n        defaultEnvironmentShouldNotBeFound(\"shortName.specified=false\");\n    }\n                @Test\n    @Transactional\n    public void getAllEnvironmentsByShortNameContainsSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where shortName contains DEFAULT_SHORT_NAME\n        defaultEnvironmentShouldBeFound(\"shortName.contains=\" + DEFAULT_SHORT_NAME);\n\n        // Get all the environmentList where shortName contains UPDATED_SHORT_NAME\n        defaultEnvironmentShouldNotBeFound(\"shortName.contains=\" + UPDATED_SHORT_NAME);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByShortNameNotContainsSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where shortName does not contain DEFAULT_SHORT_NAME\n        defaultEnvironmentShouldNotBeFound(\"shortName.doesNotContain=\" + DEFAULT_SHORT_NAME);\n\n        // Get all the environmentList where shortName does not contain UPDATED_SHORT_NAME\n        defaultEnvironmentShouldBeFound(\"shortName.doesNotContain=\" + UPDATED_SHORT_NAME);\n    }\n\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByFullNameIsEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where fullName equals to DEFAULT_FULL_NAME\n        defaultEnvironmentShouldBeFound(\"fullName.equals=\" + DEFAULT_FULL_NAME);\n\n        // Get all the environmentList where fullName equals to UPDATED_FULL_NAME\n        defaultEnvironmentShouldNotBeFound(\"fullName.equals=\" + UPDATED_FULL_NAME);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByFullNameIsNotEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where fullName not equals to DEFAULT_FULL_NAME\n        defaultEnvironmentShouldNotBeFound(\"fullName.notEquals=\" + DEFAULT_FULL_NAME);\n\n        // Get all the environmentList where fullName not equals to UPDATED_FULL_NAME\n        defaultEnvironmentShouldBeFound(\"fullName.notEquals=\" + UPDATED_FULL_NAME);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByFullNameIsInShouldWork() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where fullName in DEFAULT_FULL_NAME or UPDATED_FULL_NAME\n        defaultEnvironmentShouldBeFound(\"fullName.in=\" + DEFAULT_FULL_NAME + \",\" + UPDATED_FULL_NAME);\n\n        // Get all the environmentList where fullName equals to UPDATED_FULL_NAME\n        defaultEnvironmentShouldNotBeFound(\"fullName.in=\" + UPDATED_FULL_NAME);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByFullNameIsNullOrNotNull() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where fullName is not null\n        defaultEnvironmentShouldBeFound(\"fullName.specified=true\");\n\n        // Get all the environmentList where fullName is null\n        defaultEnvironmentShouldNotBeFound(\"fullName.specified=false\");\n    }\n                @Test\n    @Transactional\n    public void getAllEnvironmentsByFullNameContainsSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where fullName contains DEFAULT_FULL_NAME\n        defaultEnvironmentShouldBeFound(\"fullName.contains=\" + DEFAULT_FULL_NAME);\n\n        // Get all the environmentList where fullName contains UPDATED_FULL_NAME\n        defaultEnvironmentShouldNotBeFound(\"fullName.contains=\" + UPDATED_FULL_NAME);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByFullNameNotContainsSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where fullName does not contain DEFAULT_FULL_NAME\n        defaultEnvironmentShouldNotBeFound(\"fullName.doesNotContain=\" + DEFAULT_FULL_NAME);\n\n        // Get all the environmentList where fullName does not contain UPDATED_FULL_NAME\n        defaultEnvironmentShouldBeFound(\"fullName.doesNotContain=\" + UPDATED_FULL_NAME);\n    }\n\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByDescriptionIsEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where description equals to DEFAULT_DESCRIPTION\n        defaultEnvironmentShouldBeFound(\"description.equals=\" + DEFAULT_DESCRIPTION);\n\n        // Get all the environmentList where description equals to UPDATED_DESCRIPTION\n        defaultEnvironmentShouldNotBeFound(\"description.equals=\" + UPDATED_DESCRIPTION);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByDescriptionIsNotEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where description not equals to DEFAULT_DESCRIPTION\n        defaultEnvironmentShouldNotBeFound(\"description.notEquals=\" + DEFAULT_DESCRIPTION);\n\n        // Get all the environmentList where description not equals to UPDATED_DESCRIPTION\n        defaultEnvironmentShouldBeFound(\"description.notEquals=\" + UPDATED_DESCRIPTION);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByDescriptionIsInShouldWork() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where description in DEFAULT_DESCRIPTION or UPDATED_DESCRIPTION\n        defaultEnvironmentShouldBeFound(\"description.in=\" + DEFAULT_DESCRIPTION + \",\" + UPDATED_DESCRIPTION);\n\n        // Get all the environmentList where description equals to UPDATED_DESCRIPTION\n        defaultEnvironmentShouldNotBeFound(\"description.in=\" + UPDATED_DESCRIPTION);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByDescriptionIsNullOrNotNull() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where description is not null\n        defaultEnvironmentShouldBeFound(\"description.specified=true\");\n\n        // Get all the environmentList where description is null\n        defaultEnvironmentShouldNotBeFound(\"description.specified=false\");\n    }\n                @Test\n    @Transactional\n    public void getAllEnvironmentsByDescriptionContainsSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where description contains DEFAULT_DESCRIPTION\n        defaultEnvironmentShouldBeFound(\"description.contains=\" + DEFAULT_DESCRIPTION);\n\n        // Get all the environmentList where description contains UPDATED_DESCRIPTION\n        defaultEnvironmentShouldNotBeFound(\"description.contains=\" + UPDATED_DESCRIPTION);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByDescriptionNotContainsSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where description does not contain DEFAULT_DESCRIPTION\n        defaultEnvironmentShouldNotBeFound(\"description.doesNotContain=\" + DEFAULT_DESCRIPTION);\n\n        // Get all the environmentList where description does not contain UPDATED_DESCRIPTION\n        defaultEnvironmentShouldBeFound(\"description.doesNotContain=\" + UPDATED_DESCRIPTION);\n    }\n\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsBySortOrderIsEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where sortOrder equals to DEFAULT_SORT_ORDER\n        defaultEnvironmentShouldBeFound(\"sortOrder.equals=\" + DEFAULT_SORT_ORDER);\n\n        // Get all the environmentList where sortOrder equals to UPDATED_SORT_ORDER\n        defaultEnvironmentShouldNotBeFound(\"sortOrder.equals=\" + UPDATED_SORT_ORDER);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsBySortOrderIsNotEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where sortOrder not equals to DEFAULT_SORT_ORDER\n        defaultEnvironmentShouldNotBeFound(\"sortOrder.notEquals=\" + DEFAULT_SORT_ORDER);\n\n        // Get all the environmentList where sortOrder not equals to UPDATED_SORT_ORDER\n        defaultEnvironmentShouldBeFound(\"sortOrder.notEquals=\" + UPDATED_SORT_ORDER);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsBySortOrderIsInShouldWork() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where sortOrder in DEFAULT_SORT_ORDER or UPDATED_SORT_ORDER\n        defaultEnvironmentShouldBeFound(\"sortOrder.in=\" + DEFAULT_SORT_ORDER + \",\" + UPDATED_SORT_ORDER);\n\n        // Get all the environmentList where sortOrder equals to UPDATED_SORT_ORDER\n        defaultEnvironmentShouldNotBeFound(\"sortOrder.in=\" + UPDATED_SORT_ORDER);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsBySortOrderIsNullOrNotNull() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where sortOrder is not null\n        defaultEnvironmentShouldBeFound(\"sortOrder.specified=true\");\n\n        // Get all the environmentList where sortOrder is null\n        defaultEnvironmentShouldNotBeFound(\"sortOrder.specified=false\");\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsBySortOrderIsGreaterThanOrEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where sortOrder is greater than or equal to DEFAULT_SORT_ORDER\n        defaultEnvironmentShouldBeFound(\"sortOrder.greaterThanOrEqual=\" + DEFAULT_SORT_ORDER);\n\n        // Get all the environmentList where sortOrder is greater than or equal to UPDATED_SORT_ORDER\n        defaultEnvironmentShouldNotBeFound(\"sortOrder.greaterThanOrEqual=\" + UPDATED_SORT_ORDER);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsBySortOrderIsLessThanOrEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where sortOrder is less than or equal to DEFAULT_SORT_ORDER\n        defaultEnvironmentShouldBeFound(\"sortOrder.lessThanOrEqual=\" + DEFAULT_SORT_ORDER);\n\n        // Get all the environmentList where sortOrder is less than or equal to SMALLER_SORT_ORDER\n        defaultEnvironmentShouldNotBeFound(\"sortOrder.lessThanOrEqual=\" + SMALLER_SORT_ORDER);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsBySortOrderIsLessThanSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where sortOrder is less than DEFAULT_SORT_ORDER\n        defaultEnvironmentShouldNotBeFound(\"sortOrder.lessThan=\" + DEFAULT_SORT_ORDER);\n\n        // Get all the environmentList where sortOrder is less than UPDATED_SORT_ORDER\n        defaultEnvironmentShouldBeFound(\"sortOrder.lessThan=\" + UPDATED_SORT_ORDER);\n    }\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsBySortOrderIsGreaterThanSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        // Get all the environmentList where sortOrder is greater than DEFAULT_SORT_ORDER\n        defaultEnvironmentShouldNotBeFound(\"sortOrder.greaterThan=\" + DEFAULT_SORT_ORDER);\n\n        // Get all the environmentList where sortOrder is greater than SMALLER_SORT_ORDER\n        defaultEnvironmentShouldBeFound(\"sortOrder.greaterThan=\" + SMALLER_SORT_ORDER);\n    }\n\n\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByEnvironmentGroupIsEqualToSomething() throws Exception {\n        // Get already existing entity\n        EnvironmentGroup environmentGroup = environment.getEnvironmentGroup();\n        environmentRepository.saveAndFlush(environment);\n        Long environmentGroupId = environmentGroup.getId();\n\n        // Get all the environmentList where environmentGroup equals to environmentGroupId\n        defaultEnvironmentShouldBeFound(\"environmentGroupId.equals=\" + environmentGroupId);\n\n        // Get all the environmentList where environmentGroup equals to environmentGroupId + 1\n        defaultEnvironmentShouldNotBeFound(\"environmentGroupId.equals=\" + (environmentGroupId + 1));\n    }\n\n    /**\n     * Executes the search, and checks that the default entity is returned.\n     */\n    private void defaultEnvironmentShouldBeFound(String filter) throws Exception {\n        restEnvironmentMockMvc.perform(get(\"/api/environments?sort=id,desc&\" + filter))\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_VALUE))\n            .andExpect(jsonPath(\"$.[*].id\").value(hasItem(environment.getId().intValue())))\n            .andExpect(jsonPath(\"$.[*].shortName\").value(hasItem(DEFAULT_SHORT_NAME)))\n            .andExpect(jsonPath(\"$.[*].fullName\").value(hasItem(DEFAULT_FULL_NAME)))\n            .andExpect(jsonPath(\"$.[*].description\").value(hasItem(DEFAULT_DESCRIPTION)))\n            .andExpect(jsonPath(\"$.[*].sortOrder\").value(hasItem(DEFAULT_SORT_ORDER)));\n\n        // Check, that the count call also returns 1\n        restEnvironmentMockMvc.perform(get(\"/api/environments/count?sort=id,desc&\" + filter))\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_VALUE))\n            .andExpect(content().string(\"1\"));\n    }\n\n    /**\n     * Executes the search, and checks that the default entity is not returned.\n     */\n    private void defaultEnvironmentShouldNotBeFound(String filter) throws Exception {\n        restEnvironmentMockMvc.perform(get(\"/api/environments?sort=id,desc&\" + filter))\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_VALUE))\n            .andExpect(jsonPath(\"$\").isArray())\n            .andExpect(jsonPath(\"$\").isEmpty());\n\n        // Check, that the count call also returns 0\n        restEnvironmentMockMvc.perform(get(\"/api/environments/count?sort=id,desc&\" + filter))\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_VALUE))\n            .andExpect(content().string(\"0\"));\n    }\n\n    @Test\n    @Transactional\n    public void getNonExistingEnvironment() throws Exception {\n        // Get the environment\n        restEnvironmentMockMvc.perform(get(\"/api/environments/{id}\", Long.MAX_VALUE))\n            .andExpect(status().isNotFound());\n    }\n\n    @Test\n    @Transactional\n    public void updateEnvironment() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        int databaseSizeBeforeUpdate = environmentRepository.findAll().size();\n\n        // Update the environment\n        Environment updatedEnvironment = environmentRepository.findById(environment.getId()).get();\n        // Disconnect from session so that the updates on updatedEnvironment are not directly saved in db\n        em.detach(updatedEnvironment);\n        updatedEnvironment\n            .shortName(UPDATED_SHORT_NAME)\n            .fullName(UPDATED_FULL_NAME)\n            .description(UPDATED_DESCRIPTION)\n            .sortOrder(UPDATED_SORT_ORDER);\n        EnvironmentDTO environmentDTO = environmentMapper.toDto(updatedEnvironment);\n\n        restEnvironmentMockMvc.perform(put(\"/api/environments\")\n            .contentType(MediaType.APPLICATION_JSON)\n            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))\n            .andExpect(status().isOk());\n\n        // Validate the Environment in the database\n        List<Environment> environmentList = environmentRepository.findAll();\n        assertThat(environmentList).hasSize(databaseSizeBeforeUpdate);\n        Environment testEnvironment = environmentList.get(environmentList.size() - 1);\n        assertThat(testEnvironment.getShortName()).isEqualTo(UPDATED_SHORT_NAME);\n        assertThat(testEnvironment.getFullName()).isEqualTo(UPDATED_FULL_NAME);\n        assertThat(testEnvironment.getDescription()).isEqualTo(UPDATED_DESCRIPTION);\n        assertThat(testEnvironment.getSortOrder()).isEqualTo(UPDATED_SORT_ORDER);\n    }\n\n    @Test\n    @Transactional\n    public void updateNonExistingEnvironment() throws Exception {\n        int databaseSizeBeforeUpdate = environmentRepository.findAll().size();\n\n        // Create the Environment\n        EnvironmentDTO environmentDTO = environmentMapper.toDto(environment);\n\n        // If the entity doesn't have an ID, it will throw BadRequestAlertException\n        restEnvironmentMockMvc.perform(put(\"/api/environments\")\n            .contentType(MediaType.APPLICATION_JSON)\n            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))\n            .andExpect(status().isBadRequest());\n\n        // Validate the Environment in the database\n        List<Environment> environmentList = environmentRepository.findAll();\n        assertThat(environmentList).hasSize(databaseSizeBeforeUpdate);\n    }\n\n    @Test\n    @Transactional\n    public void deleteEnvironment() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n\n        int databaseSizeBeforeDelete = environmentRepository.findAll().size();\n\n        // Delete the environment\n        restEnvironmentMockMvc.perform(delete(\"/api/environments/{id}\", environment.getId())\n            .accept(MediaType.APPLICATION_JSON))\n            .andExpect(status().isNoContent());\n\n        // Validate the database contains one less item\n        List<Environment> environmentList = environmentRepository.findAll();\n        assertThat(environmentList).hasSize(databaseSizeBeforeDelete - 1);\n    }\n}", "item_id": 0, "repo": "ethiebaut/EnvKeeper", "file": "src/test/java/cc/envkeeper/app/web/rest/EnvironmentResourceIT.java", "last_update_at": "2022-01-14T23:18:41+00:00", "question_id": "d57c055c82af9c037ae79288a8be0e21d673952d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SpringBootTest(classes = EnvKeeperApp.class)\n@AutoConfigureMockMvc\n@WithMockUser(roles={\"USER\", \"WRITER\"})\npublic class EnvironmentResourceIT {\n    private static final String DEFAULT_SHORT_NAME = \"AAAAAAAAAA\";\n    private static final String UPDATED_SHORT_NAME = \"BBBBBBBBBB\";\n    private static final String DEFAULT_FULL_NAME = \"AAAAAAAAAA\";\n    private static final String UPDATED_FULL_NAME = \"BBBBBBBBBB\";\n    private static final String DEFAULT_DESCRIPTION = \"AAAAAAAAAA\";\n    private static final String UPDATED_DESCRIPTION = \"BBBBBBBBBB\";\n    private static final Integer DEFAULT_SORT_ORDER = 1;\n    private static final Integer UPDATED_SORT_ORDER = 2;\n    private static final Integer SMALLER_SORT_ORDER = 1 - 1;\n    @Autowired\n    private EnvironmentRepository environmentRepository;\n    @Autowired\n    private EnvironmentMapper environmentMapper;\n    @Autowired\n    private EnvironmentService environmentService;\n    @Autowired\n    private EnvironmentQueryService environmentQueryService;\n    @Autowired\n    private EntityManager em;\n    @Autowired\n    private MockMvc restEnvironmentMockMvc;\n    private Environment environment;\n    /**\n     * Create an entity for this test.\n     *\n     * This is a static method, as tests for other entities might also need it,\n     * if they test an entity which requires the current entity.\n     */\n    public static Environment createEntity(EntityManager em) {\n        Environment environment = new Environment()\n            .shortName(DEFAULT_SHORT_NAME)\n            .fullName(DEFAULT_FULL_NAME)\n            .description(DEFAULT_DESCRIPTION)\n            .sortOrder(DEFAULT_SORT_ORDER);\n        // Add required entity\n        EnvironmentGroup environmentGroup;\n        if (TestUtil.findAll(em, EnvironmentGroup.class).isEmpty()) {\n            environmentGroup = EnvironmentGroupResourceIT.createEntity(em);\n            em.persist(environmentGroup);\n            em.flush();\n        } else {\n            environmentGroup = TestUtil.findAll(em, EnvironmentGroup.class).get(0);\n        }\n        environment.setEnvironmentGroup(environmentGroup);\n        return environment;\n    }\n    /**\n     * Create an updated entity for this test.\n     *\n     * This is a static method, as tests for other entities might also need it,\n     * if they test an entity which requires the current entity.\n     */\n    public static Environment createUpdatedEntity(EntityManager em) {\n        Environment environment = new Environment()\n            .shortName(UPDATED_SHORT_NAME)\n            .fullName(UPDATED_FULL_NAME)\n            .description(UPDATED_DESCRIPTION)\n            .sortOrder(UPDATED_SORT_ORDER);\n        // Add required entity\n        EnvironmentGroup environmentGroup;\n        if (TestUtil.findAll(em, EnvironmentGroup.class).isEmpty()) {\n            environmentGroup = EnvironmentGroupResourceIT.createUpdatedEntity(em);\n            em.persist(environmentGroup);\n            em.flush();\n        } else {\n            environmentGroup = TestUtil.findAll(em, EnvironmentGroup.class).get(0);\n        }\n        environment.setEnvironmentGroup(environmentGroup);\n        return environment;\n    }\n    @BeforeEach\n    public void initTest() {\n        environment = createEntity(em);\n    }\n    @Test\n    @Transactional\n    public void createEnvironment() throws Exception {\n        int databaseSizeBeforeCreate = environmentRepository.findAll().size();\n        // Create the Environment\n        EnvironmentDTO environmentDTO = environmentMapper.toDto(environment);\n        restEnvironmentMockMvc.perform(post(\"/api/environments\")\n            .contentType(MediaType.APPLICATION_JSON)\n            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))\n            .andExpect(status().isCreated());\n        // Validate the Environment in the database\n        List<Environment> environmentList = environmentRepository.findAll();\n        assertThat(environmentList).hasSize(databaseSizeBeforeCreate + 1);\n        Environment testEnvironment = environmentList.get(environmentList.size() - 1);\n        assertThat(testEnvironment.getShortName()).isEqualTo(DEFAULT_SHORT_NAME);\n        assertThat(testEnvironment.getFullName()).isEqualTo(DEFAULT_FULL_NAME);\n        assertThat(testEnvironment.getDescription()).isEqualTo(DEFAULT_DESCRIPTION);\n        assertThat(testEnvironment.getSortOrder()).isEqualTo(DEFAULT_SORT_ORDER);\n    }\n    @Test\n    @Transactional\n    public void createEnvironmentWithExistingId() throws Exception {\n        int databaseSizeBeforeCreate = environmentRepository.findAll().size();\n        // Create the Environment with an existing ID\n        environment.setId(1L);\n        EnvironmentDTO environmentDTO = environmentMapper.toDto(environment);\n        // An entity with an existing ID cannot be created, so this API call must fail\n        restEnvironmentMockMvc.perform(post(\"/api/environments\")\n            .contentType(MediaType.APPLICATION_JSON)\n            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))\n            .andExpect(status().isBadRequest());\n        // Validate the Environment in the database\n        List<Environment> environmentList = environmentRepository.findAll();\n        assertThat(environmentList).hasSize(databaseSizeBeforeCreate);\n    }\n    @Test\n    @Transactional\n    public void checkShortNameIsRequired() throws Exception {\n        int databaseSizeBeforeTest = environmentRepository.findAll().size();\n        // set the field null\n        environment.setShortName(null);\n        // Create the Environment, which fails.\n        EnvironmentDTO environmentDTO = environmentMapper.toDto(environment);\n        restEnvironmentMockMvc.perform(post(\"/api/environments\")\n            .contentType(MediaType.APPLICATION_JSON)\n            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))\n            .andExpect(status().isBadRequest());\n        List<Environment> environmentList = environmentRepository.findAll();\n        assertThat(environmentList).hasSize(databaseSizeBeforeTest);\n    }\n    @Test\n    @Transactional\n    public void checkFullNameIsRequired() throws Exception {\n        int databaseSizeBeforeTest = environmentRepository.findAll().size();\n        // set the field null\n        environment.setFullName(null);\n        // Create the Environment, which fails.\n        EnvironmentDTO environmentDTO = environmentMapper.toDto(environment);\n        restEnvironmentMockMvc.perform(post(\"/api/environments\")\n            .contentType(MediaType.APPLICATION_JSON)\n            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))\n            .andExpect(status().isBadRequest());\n        List<Environment> environmentList = environmentRepository.findAll();\n        assertThat(environmentList).hasSize(databaseSizeBeforeTest);\n    }\n    @Test\n    @Transactional\n    public void checkDescriptionIsRequired() throws Exception {\n        int databaseSizeBeforeTest = environmentRepository.findAll().size();\n        // set the field null\n        environment.setDescription(null);\n        // Create the Environment, which fails.\n        EnvironmentDTO environmentDTO = environmentMapper.toDto(environment);\n        restEnvironmentMockMvc.perform(post(\"/api/environments\")\n            .contentType(MediaType.APPLICATION_JSON)\n            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))\n            .andExpect(status().isBadRequest());\n        List<Environment> environmentList = environmentRepository.findAll();\n        assertThat(environmentList).hasSize(databaseSizeBeforeTest);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironments() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList\n        restEnvironmentMockMvc.perform(get(\"/api/environments?sort=id,desc\"))\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_VALUE))\n            .andExpect(jsonPath(\"$.[*].id\").value(hasItem(environment.getId().intValue())))\n            .andExpect(jsonPath(\"$.[*].shortName\").value(hasItem(DEFAULT_SHORT_NAME)))\n            .andExpect(jsonPath(\"$.[*].fullName\").value(hasItem(DEFAULT_FULL_NAME)))\n            .andExpect(jsonPath(\"$.[*].description\").value(hasItem(DEFAULT_DESCRIPTION)))\n            .andExpect(jsonPath(\"$.[*].sortOrder\").value(hasItem(DEFAULT_SORT_ORDER)));\n    }\n    @Test\n    @Transactional\n    public void getEnvironment() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get the environment\n        restEnvironmentMockMvc.perform(get(\"/api/environments/{id}\", environment.getId()))\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_VALUE))\n            .andExpect(jsonPath(\"$.id\").value(environment.getId().intValue()))\n            .andExpect(jsonPath(\"$.shortName\").value(DEFAULT_SHORT_NAME))\n            .andExpect(jsonPath(\"$.fullName\").value(DEFAULT_FULL_NAME))\n            .andExpect(jsonPath(\"$.description\").value(DEFAULT_DESCRIPTION))\n            .andExpect(jsonPath(\"$.sortOrder\").value(DEFAULT_SORT_ORDER));\n    }\n    @Test\n    @Transactional\n    public void getEnvironmentsByIdFiltering() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        Long id = environment.getId();\n        defaultEnvironmentShouldBeFound(\"id.equals=\" + id);\n        defaultEnvironmentShouldNotBeFound(\"id.notEquals=\" + id);\n        defaultEnvironmentShouldBeFound(\"id.greaterThanOrEqual=\" + id);\n        defaultEnvironmentShouldNotBeFound(\"id.greaterThan=\" + id);\n        defaultEnvironmentShouldBeFound(\"id.lessThanOrEqual=\" + id);\n        defaultEnvironmentShouldNotBeFound(\"id.lessThan=\" + id);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByShortNameIsEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where shortName equals to DEFAULT_SHORT_NAME\n        defaultEnvironmentShouldBeFound(\"shortName.equals=\" + DEFAULT_SHORT_NAME);\n        // Get all the environmentList where shortName equals to UPDATED_SHORT_NAME\n        defaultEnvironmentShouldNotBeFound(\"shortName.equals=\" + UPDATED_SHORT_NAME);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByShortNameIsNotEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where shortName not equals to DEFAULT_SHORT_NAME\n        defaultEnvironmentShouldNotBeFound(\"shortName.notEquals=\" + DEFAULT_SHORT_NAME);\n        // Get all the environmentList where shortName not equals to UPDATED_SHORT_NAME\n        defaultEnvironmentShouldBeFound(\"shortName.notEquals=\" + UPDATED_SHORT_NAME);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByShortNameIsInShouldWork() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where shortName in DEFAULT_SHORT_NAME or UPDATED_SHORT_NAME\n        defaultEnvironmentShouldBeFound(\"shortName.in=\" + DEFAULT_SHORT_NAME + \",\" + UPDATED_SHORT_NAME);\n        // Get all the environmentList where shortName equals to UPDATED_SHORT_NAME\n        defaultEnvironmentShouldNotBeFound(\"shortName.in=\" + UPDATED_SHORT_NAME);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByShortNameIsNullOrNotNull() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where shortName is not null\n        defaultEnvironmentShouldBeFound(\"shortName.specified=true\");\n        // Get all the environmentList where shortName is null\n        defaultEnvironmentShouldNotBeFound(\"shortName.specified=false\");\n    }\n                @Test\n    @Transactional\n    public void getAllEnvironmentsByShortNameContainsSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where shortName contains DEFAULT_SHORT_NAME\n        defaultEnvironmentShouldBeFound(\"shortName.contains=\" + DEFAULT_SHORT_NAME);\n        // Get all the environmentList where shortName contains UPDATED_SHORT_NAME\n        defaultEnvironmentShouldNotBeFound(\"shortName.contains=\" + UPDATED_SHORT_NAME);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByShortNameNotContainsSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where shortName does not contain DEFAULT_SHORT_NAME\n        defaultEnvironmentShouldNotBeFound(\"shortName.doesNotContain=\" + DEFAULT_SHORT_NAME);\n        // Get all the environmentList where shortName does not contain UPDATED_SHORT_NAME\n        defaultEnvironmentShouldBeFound(\"shortName.doesNotContain=\" + UPDATED_SHORT_NAME);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByFullNameIsEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where fullName equals to DEFAULT_FULL_NAME\n        defaultEnvironmentShouldBeFound(\"fullName.equals=\" + DEFAULT_FULL_NAME);\n        // Get all the environmentList where fullName equals to UPDATED_FULL_NAME\n        defaultEnvironmentShouldNotBeFound(\"fullName.equals=\" + UPDATED_FULL_NAME);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByFullNameIsNotEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where fullName not equals to DEFAULT_FULL_NAME\n        defaultEnvironmentShouldNotBeFound(\"fullName.notEquals=\" + DEFAULT_FULL_NAME);\n        // Get all the environmentList where fullName not equals to UPDATED_FULL_NAME\n        defaultEnvironmentShouldBeFound(\"fullName.notEquals=\" + UPDATED_FULL_NAME);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByFullNameIsInShouldWork() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where fullName in DEFAULT_FULL_NAME or UPDATED_FULL_NAME\n        defaultEnvironmentShouldBeFound(\"fullName.in=\" + DEFAULT_FULL_NAME + \",\" + UPDATED_FULL_NAME);\n        // Get all the environmentList where fullName equals to UPDATED_FULL_NAME\n        defaultEnvironmentShouldNotBeFound(\"fullName.in=\" + UPDATED_FULL_NAME);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByFullNameIsNullOrNotNull() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where fullName is not null\n        defaultEnvironmentShouldBeFound(\"fullName.specified=true\");\n        // Get all the environmentList where fullName is null\n        defaultEnvironmentShouldNotBeFound(\"fullName.specified=false\");\n    }\n                @Test\n    @Transactional\n    public void getAllEnvironmentsByFullNameContainsSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where fullName contains DEFAULT_FULL_NAME\n        defaultEnvironmentShouldBeFound(\"fullName.contains=\" + DEFAULT_FULL_NAME);\n        // Get all the environmentList where fullName contains UPDATED_FULL_NAME\n        defaultEnvironmentShouldNotBeFound(\"fullName.contains=\" + UPDATED_FULL_NAME);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByFullNameNotContainsSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where fullName does not contain DEFAULT_FULL_NAME\n        defaultEnvironmentShouldNotBeFound(\"fullName.doesNotContain=\" + DEFAULT_FULL_NAME);\n        // Get all the environmentList where fullName does not contain UPDATED_FULL_NAME\n        defaultEnvironmentShouldBeFound(\"fullName.doesNotContain=\" + UPDATED_FULL_NAME);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByDescriptionIsEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where description equals to DEFAULT_DESCRIPTION\n        defaultEnvironmentShouldBeFound(\"description.equals=\" + DEFAULT_DESCRIPTION);\n        // Get all the environmentList where description equals to UPDATED_DESCRIPTION\n        defaultEnvironmentShouldNotBeFound(\"description.equals=\" + UPDATED_DESCRIPTION);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByDescriptionIsNotEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where description not equals to DEFAULT_DESCRIPTION\n        defaultEnvironmentShouldNotBeFound(\"description.notEquals=\" + DEFAULT_DESCRIPTION);\n        // Get all the environmentList where description not equals to UPDATED_DESCRIPTION\n        defaultEnvironmentShouldBeFound(\"description.notEquals=\" + UPDATED_DESCRIPTION);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByDescriptionIsInShouldWork() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where description in DEFAULT_DESCRIPTION or UPDATED_DESCRIPTION\n        defaultEnvironmentShouldBeFound(\"description.in=\" + DEFAULT_DESCRIPTION + \",\" + UPDATED_DESCRIPTION);\n        // Get all the environmentList where description equals to UPDATED_DESCRIPTION\n        defaultEnvironmentShouldNotBeFound(\"description.in=\" + UPDATED_DESCRIPTION);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByDescriptionIsNullOrNotNull() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where description is not null\n        defaultEnvironmentShouldBeFound(\"description.specified=true\");\n        // Get all the environmentList where description is null\n        defaultEnvironmentShouldNotBeFound(\"description.specified=false\");\n    }\n                @Test\n    @Transactional\n    public void getAllEnvironmentsByDescriptionContainsSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where description contains DEFAULT_DESCRIPTION\n        defaultEnvironmentShouldBeFound(\"description.contains=\" + DEFAULT_DESCRIPTION);\n        // Get all the environmentList where description contains UPDATED_DESCRIPTION\n        defaultEnvironmentShouldNotBeFound(\"description.contains=\" + UPDATED_DESCRIPTION);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByDescriptionNotContainsSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where description does not contain DEFAULT_DESCRIPTION\n        defaultEnvironmentShouldNotBeFound(\"description.doesNotContain=\" + DEFAULT_DESCRIPTION);\n        // Get all the environmentList where description does not contain UPDATED_DESCRIPTION\n        defaultEnvironmentShouldBeFound(\"description.doesNotContain=\" + UPDATED_DESCRIPTION);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsBySortOrderIsEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where sortOrder equals to DEFAULT_SORT_ORDER\n        defaultEnvironmentShouldBeFound(\"sortOrder.equals=\" + DEFAULT_SORT_ORDER);\n        // Get all the environmentList where sortOrder equals to UPDATED_SORT_ORDER\n        defaultEnvironmentShouldNotBeFound(\"sortOrder.equals=\" + UPDATED_SORT_ORDER);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsBySortOrderIsNotEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where sortOrder not equals to DEFAULT_SORT_ORDER\n        defaultEnvironmentShouldNotBeFound(\"sortOrder.notEquals=\" + DEFAULT_SORT_ORDER);\n        // Get all the environmentList where sortOrder not equals to UPDATED_SORT_ORDER\n        defaultEnvironmentShouldBeFound(\"sortOrder.notEquals=\" + UPDATED_SORT_ORDER);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsBySortOrderIsInShouldWork() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where sortOrder in DEFAULT_SORT_ORDER or UPDATED_SORT_ORDER\n        defaultEnvironmentShouldBeFound(\"sortOrder.in=\" + DEFAULT_SORT_ORDER + \",\" + UPDATED_SORT_ORDER);\n        // Get all the environmentList where sortOrder equals to UPDATED_SORT_ORDER\n        defaultEnvironmentShouldNotBeFound(\"sortOrder.in=\" + UPDATED_SORT_ORDER);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsBySortOrderIsNullOrNotNull() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where sortOrder is not null\n        defaultEnvironmentShouldBeFound(\"sortOrder.specified=true\");\n        // Get all the environmentList where sortOrder is null\n        defaultEnvironmentShouldNotBeFound(\"sortOrder.specified=false\");\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsBySortOrderIsGreaterThanOrEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where sortOrder is greater than or equal to DEFAULT_SORT_ORDER\n        defaultEnvironmentShouldBeFound(\"sortOrder.greaterThanOrEqual=\" + DEFAULT_SORT_ORDER);\n        // Get all the environmentList where sortOrder is greater than or equal to UPDATED_SORT_ORDER\n        defaultEnvironmentShouldNotBeFound(\"sortOrder.greaterThanOrEqual=\" + UPDATED_SORT_ORDER);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsBySortOrderIsLessThanOrEqualToSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where sortOrder is less than or equal to DEFAULT_SORT_ORDER\n        defaultEnvironmentShouldBeFound(\"sortOrder.lessThanOrEqual=\" + DEFAULT_SORT_ORDER);\n        // Get all the environmentList where sortOrder is less than or equal to SMALLER_SORT_ORDER\n        defaultEnvironmentShouldNotBeFound(\"sortOrder.lessThanOrEqual=\" + SMALLER_SORT_ORDER);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsBySortOrderIsLessThanSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where sortOrder is less than DEFAULT_SORT_ORDER\n        defaultEnvironmentShouldNotBeFound(\"sortOrder.lessThan=\" + DEFAULT_SORT_ORDER);\n        // Get all the environmentList where sortOrder is less than UPDATED_SORT_ORDER\n        defaultEnvironmentShouldBeFound(\"sortOrder.lessThan=\" + UPDATED_SORT_ORDER);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsBySortOrderIsGreaterThanSomething() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        // Get all the environmentList where sortOrder is greater than DEFAULT_SORT_ORDER\n        defaultEnvironmentShouldNotBeFound(\"sortOrder.greaterThan=\" + DEFAULT_SORT_ORDER);\n        // Get all the environmentList where sortOrder is greater than SMALLER_SORT_ORDER\n        defaultEnvironmentShouldBeFound(\"sortOrder.greaterThan=\" + SMALLER_SORT_ORDER);\n    }\n    @Test\n    @Transactional\n    public void getAllEnvironmentsByEnvironmentGroupIsEqualToSomething() throws Exception {\n        // Get already existing entity\n        EnvironmentGroup environmentGroup = environment.getEnvironmentGroup();\n        environmentRepository.saveAndFlush(environment);\n        Long environmentGroupId = environmentGroup.getId();\n        // Get all the environmentList where environmentGroup equals to environmentGroupId\n        defaultEnvironmentShouldBeFound(\"environmentGroupId.equals=\" + environmentGroupId);\n        // Get all the environmentList where environmentGroup equals to environmentGroupId + 1\n        defaultEnvironmentShouldNotBeFound(\"environmentGroupId.equals=\" + (environmentGroupId + 1));\n    }\n    /**\n     * Executes the search, and checks that the default entity is returned.\n     */\n    private void defaultEnvironmentShouldBeFound(String filter) throws Exception {\n        restEnvironmentMockMvc.perform(get(\"/api/environments?sort=id,desc&\" + filter))\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_VALUE))\n            .andExpect(jsonPath(\"$.[*].id\").value(hasItem(environment.getId().intValue())))\n            .andExpect(jsonPath(\"$.[*].shortName\").value(hasItem(DEFAULT_SHORT_NAME)))\n            .andExpect(jsonPath(\"$.[*].fullName\").value(hasItem(DEFAULT_FULL_NAME)))\n            .andExpect(jsonPath(\"$.[*].description\").value(hasItem(DEFAULT_DESCRIPTION)))\n            .andExpect(jsonPath(\"$.[*].sortOrder\").value(hasItem(DEFAULT_SORT_ORDER)));\n        // Check, that the count call also returns 1\n        restEnvironmentMockMvc.perform(get(\"/api/environments/count?sort=id,desc&\" + filter))\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_VALUE))\n            .andExpect(content().string(\"1\"));\n    }\n    /**\n     * Executes the search, and checks that the default entity is not returned.\n     */\n    private void defaultEnvironmentShouldNotBeFound(String filter) throws Exception {\n        restEnvironmentMockMvc.perform(get(\"/api/environments?sort=id,desc&\" + filter))\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_VALUE))\n            .andExpect(jsonPath(\"$\").isArray())\n            .andExpect(jsonPath(\"$\").isEmpty());\n        // Check, that the count call also returns 0\n        restEnvironmentMockMvc.perform(get(\"/api/environments/count?sort=id,desc&\" + filter))\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_VALUE))\n            .andExpect(content().string(\"0\"));\n    }\n    @Test\n    @Transactional\n    public void getNonExistingEnvironment() throws Exception {\n        // Get the environment\n        restEnvironmentMockMvc.perform(get(\"/api/environments/{id}\", Long.MAX_VALUE))\n            .andExpect(status().isNotFound());\n    }\n    @Test\n    @Transactional\n    public void updateEnvironment() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        int databaseSizeBeforeUpdate = environmentRepository.findAll().size();\n        // Update the environment\n        Environment updatedEnvironment = environmentRepository.findById(environment.getId()).get();\n        // Disconnect from session so that the updates on updatedEnvironment are not directly saved in db\n        em.detach(updatedEnvironment);\n        updatedEnvironment\n            .shortName(UPDATED_SHORT_NAME)\n            .fullName(UPDATED_FULL_NAME)\n            .description(UPDATED_DESCRIPTION)\n            .sortOrder(UPDATED_SORT_ORDER);\n        EnvironmentDTO environmentDTO = environmentMapper.toDto(updatedEnvironment);\n        restEnvironmentMockMvc.perform(put(\"/api/environments\")\n            .contentType(MediaType.APPLICATION_JSON)\n            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))\n            .andExpect(status().isOk());\n        // Validate the Environment in the database\n        List<Environment> environmentList = environmentRepository.findAll();\n        assertThat(environmentList).hasSize(databaseSizeBeforeUpdate);\n        Environment testEnvironment = environmentList.get(environmentList.size() - 1);\n        assertThat(testEnvironment.getShortName()).isEqualTo(UPDATED_SHORT_NAME);\n        assertThat(testEnvironment.getFullName()).isEqualTo(UPDATED_FULL_NAME);\n        assertThat(testEnvironment.getDescription()).isEqualTo(UPDATED_DESCRIPTION);\n        assertThat(testEnvironment.getSortOrder()).isEqualTo(UPDATED_SORT_ORDER);\n    }\n    @Test\n    @Transactional\n    public void updateNonExistingEnvironment() throws Exception {\n        int databaseSizeBeforeUpdate = environmentRepository.findAll().size();\n        // Create the Environment\n        EnvironmentDTO environmentDTO = environmentMapper.toDto(environment);\n        // If the entity doesn't have an ID, it will throw BadRequestAlertException\n        restEnvironmentMockMvc.perform(put(\"/api/environments\")\n            .contentType(MediaType.APPLICATION_JSON)\n            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))\n            .andExpect(status().isBadRequest());\n        // Validate the Environment in the database\n        List<Environment> environmentList = environmentRepository.findAll();\n        assertThat(environmentList).hasSize(databaseSizeBeforeUpdate);\n    }\n    @Test\n    @Transactional\n    public void deleteEnvironment() throws Exception {\n        // Initialize the database\n        environmentRepository.saveAndFlush(environment);\n        int databaseSizeBeforeDelete = environmentRepository.findAll().size();\n        // Delete the environment\n        restEnvironmentMockMvc.perform(delete(\"/api/environments/{id}\", environment.getId())\n            .accept(MediaType.APPLICATION_JSON))\n            .andExpect(status().isNoContent());\n        // Validate the database contains one less item\n        List<Environment> environmentList = environmentRepository.findAll();\n        assertThat(environmentList).hasSize(databaseSizeBeforeDelete - 1);\n    }\n"]], "pred": {"ppl": 1.147802710533142, "ppl_lower": 1.5999011993408203, "ppl/lowercase_ppl": -3.4090955841428845, "ppl/zlib": 4.518172015481339e-05, "Min_5.0% Prob": 2.571386481032652, "Min_10.0% Prob": 1.3671769069909465, "Min_20.0% Prob": 0.6898549971873781, "Min_30.0% Prob": 0.4606123273093497, "Min_40.0% Prob": 0.34473536987986086, "Min_50.0% Prob": 0.27595128532108193, "Min_60.0% Prob": 0.23004364796014007}}
{"hexsha": "5c3e5ea23f017e18e35e8f905b98d3180d7cbdbd", "ext": "java", "lang": "Java", "content": "public class BlockEnhancedInterface extends AEBaseTileBlock {\n\n    public static final int MAX_TIER = 3;\n    private static final PropertyBool OMNIDIRECTIONAL = PropertyBool.create(\"omnidirectional\");\n    private static final PropertyDirection FACING = PropertyDirection.create(\"facing\");\n    private final int tier;\n\n    public BlockEnhancedInterface(int tier) {\n        super(Material.IRON);\n        if (tier == 1) {\n            setTileEntity(TileEnhancedInterfaceTier1.class);\n        } else if (tier == 2) {\n            setTileEntity(TileEnhancedInterfaceTier2.class);\n        } else if (tier == 3) {\n            setTileEntity(TileEnhancedInterfaceTier3.class);\n        }\n\n        this.tier = tier;\n    }\n\n\n    @Override\n    protected IProperty<?>[] getAEStates() {\n        return new IProperty[]{OMNIDIRECTIONAL};\n    }\n\n    @Override\n    protected BlockStateContainer createBlockState() {\n        return new BlockStateContainer(this, OMNIDIRECTIONAL, FACING);\n    }\n\n    @Nonnull\n    @Override\n    public IBlockState getActualState(@Nonnull IBlockState state, @Nonnull IBlockAccess world, @Nonnull BlockPos pos) {\n        TileEnhancedInterfaceBase te = this.getTileEntity(world, pos);\n        return te == null ? state\n                : state.withProperty(OMNIDIRECTIONAL, te.isOmniDirectional()).withProperty(FACING, te.getForward());\n    }\n\n    @Override\n    public boolean onActivated(final World world, final BlockPos pos, final EntityPlayer player, final EnumHand hand, final @Nullable ItemStack heldItem, final EnumFacing side, final float hitX, final float hitY, final float hitZ) {\n        if (player.isSneaking()) {\n            return false;\n        }\n\n        TileEntity tile = world.getTileEntity(pos);\n        if (tile instanceof TileEnhancedInterfaceBase) {\n\n            if (!world.isRemote) {\n                Ae2uGuiHandler.openGui(player, this.tier, tile, AEPartLocation.fromFacing(side));\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    @Nullable\n    @Override\n    public TileEntity createTileEntity(@Nonnull World world, @Nonnull IBlockState state) {\n        switch (this.tier) {\n            case 2:\n                return new TileEnhancedInterfaceTier2();\n            case 3:\n                return new TileEnhancedInterfaceTier3();\n            case 1:\n            default:\n                return new TileEnhancedInterfaceTier1();\n        }\n\n    }\n\n    @Override\n    protected boolean hasCustomRotation() {\n        return true;\n    }\n\n    @Override\n    protected void customRotateBlock(final IOrientable rotatable, final EnumFacing axis) {\n        if (rotatable instanceof TileEnhancedInterfaceBase) {\n            ((TileEnhancedInterfaceBase) rotatable).setSide(axis);\n        }\n    }\n\n}", "item_id": 0, "repo": "vfyjxf/AE2-Utilities", "file": "src/main/java/com/github/vfyjxf/ae2utilities/block/BlockEnhancedInterface.java", "last_update_at": "2022-02-13T17:39:49+00:00", "question_id": "5c3e5ea23f017e18e35e8f905b98d3180d7cbdbd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BlockEnhancedInterface extends AEBaseTileBlock {\n    public static final int MAX_TIER = 3;\n    private static final PropertyBool OMNIDIRECTIONAL = PropertyBool.create(\"omnidirectional\");\n    private static final PropertyDirection FACING = PropertyDirection.create(\"facing\");\n    private final int tier;\n    public BlockEnhancedInterface(int tier) {\n        super(Material.IRON);\n        if (tier == 1) {\n            setTileEntity(TileEnhancedInterfaceTier1.class);\n        } else if (tier == 2) {\n            setTileEntity(TileEnhancedInterfaceTier2.class);\n        } else if (tier == 3) {\n            setTileEntity(TileEnhancedInterfaceTier3.class);\n        }\n        this.tier = tier;\n    }\n    @Override\n    protected IProperty<?>[] getAEStates() {\n        return new IProperty[]{OMNIDIRECTIONAL};\n    }\n    @Override\n    protected BlockStateContainer createBlockState() {\n        return new BlockStateContainer(this, OMNIDIRECTIONAL, FACING);\n    }\n    @Nonnull\n    @Override\n    public IBlockState getActualState(@Nonnull IBlockState state, @Nonnull IBlockAccess world, @Nonnull BlockPos pos) {\n        TileEnhancedInterfaceBase te = this.getTileEntity(world, pos);\n        return te == null ? state\n                : state.withProperty(OMNIDIRECTIONAL, te.isOmniDirectional()).withProperty(FACING, te.getForward());\n    }\n    @Override\n    public boolean onActivated(final World world, final BlockPos pos, final EntityPlayer player, final EnumHand hand, final @Nullable ItemStack heldItem, final EnumFacing side, final float hitX, final float hitY, final float hitZ) {\n        if (player.isSneaking()) {\n            return false;\n        }\n        TileEntity tile = world.getTileEntity(pos);\n        if (tile instanceof TileEnhancedInterfaceBase) {\n            if (!world.isRemote) {\n                Ae2uGuiHandler.openGui(player, this.tier, tile, AEPartLocation.fromFacing(side));\n            }\n            return true;\n        }\n        return false;\n    }\n    @Nullable\n    @Override\n    public TileEntity createTileEntity(@Nonnull World world, @Nonnull IBlockState state) {\n        switch (this.tier) {\n            case 2:\n                return new TileEnhancedInterfaceTier2();\n            case 3:\n                return new TileEnhancedInterfaceTier3();\n            case 1:\n            default:\n                return new TileEnhancedInterfaceTier1();\n        }\n    }\n    @Override\n    protected boolean hasCustomRotation() {\n        return true;\n    }\n    @Override\n    protected void customRotateBlock(final IOrientable rotatable, final EnumFacing axis) {\n        if (rotatable instanceof TileEnhancedInterfaceBase) {\n            ((TileEnhancedInterfaceBase) rotatable).setSide(axis);\n        }\n    }\n"]], "pred": {"ppl": 1.6559114456176758, "ppl_lower": 2.0919673442840576, "ppl/lowercase_ppl": -1.4634730335626467, "ppl/zlib": 0.000579714459384693, "Min_5.0% Prob": 5.624727878815088, "Min_10.0% Prob": 3.9364134073257446, "Min_20.0% Prob": 2.3830895761273942, "Min_30.0% Prob": 1.6505570872433515, "Min_40.0% Prob": 1.255553372741493, "Min_50.0% Prob": 1.0083426615774147, "Min_60.0% Prob": 0.8409178290654183}}
{"hexsha": "7fe3491d2af98d470efecc752e1649b862a69976", "ext": "java", "lang": "Java", "content": "public class V1LimitRangeItemFluentImpl<A extends io.kubernetes.client.openapi.models.V1LimitRangeItemFluent<A>> extends io.kubernetes.client.fluent.BaseFluent<A> implements io.kubernetes.client.openapi.models.V1LimitRangeItemFluent<A>{\n  public V1LimitRangeItemFluentImpl() {\n  }\n  public V1LimitRangeItemFluentImpl(io.kubernetes.client.openapi.models.V1LimitRangeItem instance) {\n    this.withDefault(instance.getDefault());\n\n    this.withDefaultRequest(instance.getDefaultRequest());\n\n    this.withMax(instance.getMax());\n\n    this.withMaxLimitRequestRatio(instance.getMaxLimitRequestRatio());\n\n    this.withMin(instance.getMin());\n\n    this.withType(instance.getType());\n\n  }\n  private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> _default;\n  private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> defaultRequest;\n  private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> max;\n  private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> maxLimitRequestRatio;\n  private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> min;\n  private io.kubernetes.client.openapi.models.V1LimitRangeItem.TypeEnum type;\n  public A addToDefault(java.lang.String key,io.kubernetes.client.custom.Quantity value) {\n    if(this._default == null && key != null && value != null) { this._default = new java.util.LinkedHashMap(); }\n    if(key != null && value != null) {this._default.put(key, value);} return (A)this;\n  }\n  public A addToDefault(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this._default == null && map != null) { this._default = new java.util.LinkedHashMap(); }\n    if(map != null) { this._default.putAll(map);} return (A)this;\n  }\n  public A removeFromDefault(java.lang.String key) {\n    if(this._default == null) { return (A) this; }\n    if(key != null && this._default != null) {this._default.remove(key);} return (A)this;\n  }\n  public A removeFromDefault(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this._default == null) { return (A) this; }\n    if(map != null) { for(Object key : map.keySet()) {if (this._default != null){this._default.remove(key);}}} return (A)this;\n  }\n  public java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> getDefault() {\n    return this._default;\n  }\n  public <K,V>A withDefault(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> _default) {\n    if (_default == null) { this._default =  null;} else {this._default = new java.util.LinkedHashMap(_default);} return (A) this;\n  }\n  public java.lang.Boolean hasDefault() {\n    return this._default != null;\n  }\n  public A addToDefaultRequest(java.lang.String key,io.kubernetes.client.custom.Quantity value) {\n    if(this.defaultRequest == null && key != null && value != null) { this.defaultRequest = new java.util.LinkedHashMap(); }\n    if(key != null && value != null) {this.defaultRequest.put(key, value);} return (A)this;\n  }\n  public A addToDefaultRequest(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this.defaultRequest == null && map != null) { this.defaultRequest = new java.util.LinkedHashMap(); }\n    if(map != null) { this.defaultRequest.putAll(map);} return (A)this;\n  }\n  public A removeFromDefaultRequest(java.lang.String key) {\n    if(this.defaultRequest == null) { return (A) this; }\n    if(key != null && this.defaultRequest != null) {this.defaultRequest.remove(key);} return (A)this;\n  }\n  public A removeFromDefaultRequest(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this.defaultRequest == null) { return (A) this; }\n    if(map != null) { for(Object key : map.keySet()) {if (this.defaultRequest != null){this.defaultRequest.remove(key);}}} return (A)this;\n  }\n  public java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> getDefaultRequest() {\n    return this.defaultRequest;\n  }\n  public <K,V>A withDefaultRequest(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> defaultRequest) {\n    if (defaultRequest == null) { this.defaultRequest =  null;} else {this.defaultRequest = new java.util.LinkedHashMap(defaultRequest);} return (A) this;\n  }\n  public java.lang.Boolean hasDefaultRequest() {\n    return this.defaultRequest != null;\n  }\n  public A addToMax(java.lang.String key,io.kubernetes.client.custom.Quantity value) {\n    if(this.max == null && key != null && value != null) { this.max = new java.util.LinkedHashMap(); }\n    if(key != null && value != null) {this.max.put(key, value);} return (A)this;\n  }\n  public A addToMax(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this.max == null && map != null) { this.max = new java.util.LinkedHashMap(); }\n    if(map != null) { this.max.putAll(map);} return (A)this;\n  }\n  public A removeFromMax(java.lang.String key) {\n    if(this.max == null) { return (A) this; }\n    if(key != null && this.max != null) {this.max.remove(key);} return (A)this;\n  }\n  public A removeFromMax(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this.max == null) { return (A) this; }\n    if(map != null) { for(Object key : map.keySet()) {if (this.max != null){this.max.remove(key);}}} return (A)this;\n  }\n  public java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> getMax() {\n    return this.max;\n  }\n  public <K,V>A withMax(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> max) {\n    if (max == null) { this.max =  null;} else {this.max = new java.util.LinkedHashMap(max);} return (A) this;\n  }\n  public java.lang.Boolean hasMax() {\n    return this.max != null;\n  }\n  public A addToMaxLimitRequestRatio(java.lang.String key,io.kubernetes.client.custom.Quantity value) {\n    if(this.maxLimitRequestRatio == null && key != null && value != null) { this.maxLimitRequestRatio = new java.util.LinkedHashMap(); }\n    if(key != null && value != null) {this.maxLimitRequestRatio.put(key, value);} return (A)this;\n  }\n  public A addToMaxLimitRequestRatio(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this.maxLimitRequestRatio == null && map != null) { this.maxLimitRequestRatio = new java.util.LinkedHashMap(); }\n    if(map != null) { this.maxLimitRequestRatio.putAll(map);} return (A)this;\n  }\n  public A removeFromMaxLimitRequestRatio(java.lang.String key) {\n    if(this.maxLimitRequestRatio == null) { return (A) this; }\n    if(key != null && this.maxLimitRequestRatio != null) {this.maxLimitRequestRatio.remove(key);} return (A)this;\n  }\n  public A removeFromMaxLimitRequestRatio(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this.maxLimitRequestRatio == null) { return (A) this; }\n    if(map != null) { for(Object key : map.keySet()) {if (this.maxLimitRequestRatio != null){this.maxLimitRequestRatio.remove(key);}}} return (A)this;\n  }\n  public java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> getMaxLimitRequestRatio() {\n    return this.maxLimitRequestRatio;\n  }\n  public <K,V>A withMaxLimitRequestRatio(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> maxLimitRequestRatio) {\n    if (maxLimitRequestRatio == null) { this.maxLimitRequestRatio =  null;} else {this.maxLimitRequestRatio = new java.util.LinkedHashMap(maxLimitRequestRatio);} return (A) this;\n  }\n  public java.lang.Boolean hasMaxLimitRequestRatio() {\n    return this.maxLimitRequestRatio != null;\n  }\n  public A addToMin(java.lang.String key,io.kubernetes.client.custom.Quantity value) {\n    if(this.min == null && key != null && value != null) { this.min = new java.util.LinkedHashMap(); }\n    if(key != null && value != null) {this.min.put(key, value);} return (A)this;\n  }\n  public A addToMin(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this.min == null && map != null) { this.min = new java.util.LinkedHashMap(); }\n    if(map != null) { this.min.putAll(map);} return (A)this;\n  }\n  public A removeFromMin(java.lang.String key) {\n    if(this.min == null) { return (A) this; }\n    if(key != null && this.min != null) {this.min.remove(key);} return (A)this;\n  }\n  public A removeFromMin(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this.min == null) { return (A) this; }\n    if(map != null) { for(Object key : map.keySet()) {if (this.min != null){this.min.remove(key);}}} return (A)this;\n  }\n  public java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> getMin() {\n    return this.min;\n  }\n  public <K,V>A withMin(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> min) {\n    if (min == null) { this.min =  null;} else {this.min = new java.util.LinkedHashMap(min);} return (A) this;\n  }\n  public java.lang.Boolean hasMin() {\n    return this.min != null;\n  }\n  public io.kubernetes.client.openapi.models.V1LimitRangeItem.TypeEnum getType() {\n    return this.type;\n  }\n  public A withType(io.kubernetes.client.openapi.models.V1LimitRangeItem.TypeEnum type) {\n    this.type=type; return (A) this;\n  }\n  public java.lang.Boolean hasType() {\n    return this.type != null;\n  }\n  public boolean equals(java.lang.Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    V1LimitRangeItemFluentImpl that = (V1LimitRangeItemFluentImpl) o;\n    if (_default != null ? !_default.equals(that._default) :that._default != null) return false;\n    if (defaultRequest != null ? !defaultRequest.equals(that.defaultRequest) :that.defaultRequest != null) return false;\n    if (max != null ? !max.equals(that.max) :that.max != null) return false;\n    if (maxLimitRequestRatio != null ? !maxLimitRequestRatio.equals(that.maxLimitRequestRatio) :that.maxLimitRequestRatio != null) return false;\n    if (min != null ? !min.equals(that.min) :that.min != null) return false;\n    if (type != null ? !type.equals(that.type) :that.type != null) return false;\n    return true;\n  }\n  public int hashCode() {\n    return java.util.Objects.hash(_default,  defaultRequest,  max,  maxLimitRequestRatio,  min,  type,  super.hashCode());\n  }\n  \n}", "item_id": 0, "repo": "Ankit01Mishra/java", "file": "fluent/src/main/java/io/kubernetes/client/openapi/models/V1LimitRangeItemFluentImpl.java", "last_update_at": "2022-03-31T07:06:17+00:00", "question_id": "7fe3491d2af98d470efecc752e1649b862a69976_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class V1LimitRangeItemFluentImpl<A extends io.kubernetes.client.openapi.models.V1LimitRangeItemFluent<A>> extends io.kubernetes.client.fluent.BaseFluent<A> implements io.kubernetes.client.openapi.models.V1LimitRangeItemFluent<A>{\n  public V1LimitRangeItemFluentImpl() {\n  }\n  public V1LimitRangeItemFluentImpl(io.kubernetes.client.openapi.models.V1LimitRangeItem instance) {\n    this.withDefault(instance.getDefault());\n    this.withDefaultRequest(instance.getDefaultRequest());\n    this.withMax(instance.getMax());\n    this.withMaxLimitRequestRatio(instance.getMaxLimitRequestRatio());\n    this.withMin(instance.getMin());\n    this.withType(instance.getType());\n  }\n  private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> _default;\n  private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> defaultRequest;\n  private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> max;\n  private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> maxLimitRequestRatio;\n  private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> min;\n  private io.kubernetes.client.openapi.models.V1LimitRangeItem.TypeEnum type;\n  public A addToDefault(java.lang.String key,io.kubernetes.client.custom.Quantity value) {\n    if(this._default == null && key != null && value != null) { this._default = new java.util.LinkedHashMap(); }\n    if(key != null && value != null) {this._default.put(key, value);} return (A)this;\n  }\n  public A addToDefault(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this._default == null && map != null) { this._default = new java.util.LinkedHashMap(); }\n    if(map != null) { this._default.putAll(map);} return (A)this;\n  }\n  public A removeFromDefault(java.lang.String key) {\n    if(this._default == null) { return (A) this; }\n    if(key != null && this._default != null) {this._default.remove(key);} return (A)this;\n  }\n  public A removeFromDefault(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this._default == null) { return (A) this; }\n    if(map != null) { for(Object key : map.keySet()) {if (this._default != null){this._default.remove(key);}}} return (A)this;\n  }\n  public java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> getDefault() {\n    return this._default;\n  }\n  public <K,V>A withDefault(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> _default) {\n    if (_default == null) { this._default =  null;} else {this._default = new java.util.LinkedHashMap(_default);} return (A) this;\n  }\n  public java.lang.Boolean hasDefault() {\n    return this._default != null;\n  }\n  public A addToDefaultRequest(java.lang.String key,io.kubernetes.client.custom.Quantity value) {\n    if(this.defaultRequest == null && key != null && value != null) { this.defaultRequest = new java.util.LinkedHashMap(); }\n    if(key != null && value != null) {this.defaultRequest.put(key, value);} return (A)this;\n  }\n  public A addToDefaultRequest(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this.defaultRequest == null && map != null) { this.defaultRequest = new java.util.LinkedHashMap(); }\n    if(map != null) { this.defaultRequest.putAll(map);} return (A)this;\n  }\n  public A removeFromDefaultRequest(java.lang.String key) {\n    if(this.defaultRequest == null) { return (A) this; }\n    if(key != null && this.defaultRequest != null) {this.defaultRequest.remove(key);} return (A)this;\n  }\n  public A removeFromDefaultRequest(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this.defaultRequest == null) { return (A) this; }\n    if(map != null) { for(Object key : map.keySet()) {if (this.defaultRequest != null){this.defaultRequest.remove(key);}}} return (A)this;\n  }\n  public java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> getDefaultRequest() {\n    return this.defaultRequest;\n  }\n  public <K,V>A withDefaultRequest(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> defaultRequest) {\n    if (defaultRequest == null) { this.defaultRequest =  null;} else {this.defaultRequest = new java.util.LinkedHashMap(defaultRequest);} return (A) this;\n  }\n  public java.lang.Boolean hasDefaultRequest() {\n    return this.defaultRequest != null;\n  }\n  public A addToMax(java.lang.String key,io.kubernetes.client.custom.Quantity value) {\n    if(this.max == null && key != null && value != null) { this.max = new java.util.LinkedHashMap(); }\n    if(key != null && value != null) {this.max.put(key, value);} return (A)this;\n  }\n  public A addToMax(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this.max == null && map != null) { this.max = new java.util.LinkedHashMap(); }\n    if(map != null) { this.max.putAll(map);} return (A)this;\n  }\n  public A removeFromMax(java.lang.String key) {\n    if(this.max == null) { return (A) this; }\n    if(key != null && this.max != null) {this.max.remove(key);} return (A)this;\n  }\n  public A removeFromMax(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this.max == null) { return (A) this; }\n    if(map != null) { for(Object key : map.keySet()) {if (this.max != null){this.max.remove(key);}}} return (A)this;\n  }\n  public java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> getMax() {\n    return this.max;\n  }\n  public <K,V>A withMax(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> max) {\n    if (max == null) { this.max =  null;} else {this.max = new java.util.LinkedHashMap(max);} return (A) this;\n  }\n  public java.lang.Boolean hasMax() {\n    return this.max != null;\n  }\n  public A addToMaxLimitRequestRatio(java.lang.String key,io.kubernetes.client.custom.Quantity value) {\n    if(this.maxLimitRequestRatio == null && key != null && value != null) { this.maxLimitRequestRatio = new java.util.LinkedHashMap(); }\n    if(key != null && value != null) {this.maxLimitRequestRatio.put(key, value);} return (A)this;\n  }\n  public A addToMaxLimitRequestRatio(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this.maxLimitRequestRatio == null && map != null) { this.maxLimitRequestRatio = new java.util.LinkedHashMap(); }\n    if(map != null) { this.maxLimitRequestRatio.putAll(map);} return (A)this;\n  }\n  public A removeFromMaxLimitRequestRatio(java.lang.String key) {\n    if(this.maxLimitRequestRatio == null) { return (A) this; }\n    if(key != null && this.maxLimitRequestRatio != null) {this.maxLimitRequestRatio.remove(key);} return (A)this;\n  }\n  public A removeFromMaxLimitRequestRatio(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this.maxLimitRequestRatio == null) { return (A) this; }\n    if(map != null) { for(Object key : map.keySet()) {if (this.maxLimitRequestRatio != null){this.maxLimitRequestRatio.remove(key);}}} return (A)this;\n  }\n  public java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> getMaxLimitRequestRatio() {\n    return this.maxLimitRequestRatio;\n  }\n  public <K,V>A withMaxLimitRequestRatio(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> maxLimitRequestRatio) {\n    if (maxLimitRequestRatio == null) { this.maxLimitRequestRatio =  null;} else {this.maxLimitRequestRatio = new java.util.LinkedHashMap(maxLimitRequestRatio);} return (A) this;\n  }\n  public java.lang.Boolean hasMaxLimitRequestRatio() {\n    return this.maxLimitRequestRatio != null;\n  }\n  public A addToMin(java.lang.String key,io.kubernetes.client.custom.Quantity value) {\n    if(this.min == null && key != null && value != null) { this.min = new java.util.LinkedHashMap(); }\n    if(key != null && value != null) {this.min.put(key, value);} return (A)this;\n  }\n  public A addToMin(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this.min == null && map != null) { this.min = new java.util.LinkedHashMap(); }\n    if(map != null) { this.min.putAll(map);} return (A)this;\n  }\n  public A removeFromMin(java.lang.String key) {\n    if(this.min == null) { return (A) this; }\n    if(key != null && this.min != null) {this.min.remove(key);} return (A)this;\n  }\n  public A removeFromMin(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {\n    if(this.min == null) { return (A) this; }\n    if(map != null) { for(Object key : map.keySet()) {if (this.min != null){this.min.remove(key);}}} return (A)this;\n  }\n  public java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> getMin() {\n    return this.min;\n  }\n  public <K,V>A withMin(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> min) {\n    if (min == null) { this.min =  null;} else {this.min = new java.util.LinkedHashMap(min);} return (A) this;\n  }\n  public java.lang.Boolean hasMin() {\n    return this.min != null;\n  }\n  public io.kubernetes.client.openapi.models.V1LimitRangeItem.TypeEnum getType() {\n    return this.type;\n  }\n  public A withType(io.kubernetes.client.openapi.models.V1LimitRangeItem.TypeEnum type) {\n    this.type=type; return (A) this;\n  }\n  public java.lang.Boolean hasType() {\n    return this.type != null;\n  }\n  public boolean equals(java.lang.Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    V1LimitRangeItemFluentImpl that = (V1LimitRangeItemFluentImpl) o;\n    if (_default != null ? !_default.equals(that._default) :that._default != null) return false;\n    if (defaultRequest != null ? !defaultRequest.equals(that.defaultRequest) :that.defaultRequest != null) return false;\n    if (max != null ? !max.equals(that.max) :that.max != null) return false;\n    if (maxLimitRequestRatio != null ? !maxLimitRequestRatio.equals(that.maxLimitRequestRatio) :that.maxLimitRequestRatio != null) return false;\n    if (min != null ? !min.equals(that.min) :that.min != null) return false;\n    if (type != null ? !type.equals(that.type) :that.type != null) return false;\n    return true;\n  }\n  public int hashCode() {\n    return java.util.Objects.hash(_default,  defaultRequest,  max,  maxLimitRequestRatio,  min,  type,  super.hashCode());\n  }\n"]], "pred": {"ppl": 1.0718554258346558, "ppl_lower": 1.5246214866638184, "ppl/lowercase_ppl": -6.0778057885438725, "ppl/zlib": 5.5646503282629875e-05, "Min_5.0% Prob": 1.366459603330084, "Min_10.0% Prob": 0.6944872447262135, "Min_20.0% Prob": 0.347901985631895, "Min_30.0% Prob": 0.2319731911322105, "Min_40.0% Prob": 0.17356002092952724, "Min_50.0% Prob": 0.13891734064862216, "Min_60.0% Prob": 0.1158026763732726}}
{"hexsha": "3833871066190b0d3f0ec786374528b7ee356e10", "ext": "java", "lang": "Java", "content": "@Data\npublic class PresentationManager {\n\n    private final Presentations presentations;\n    private final String presentationId;\n    private final String slideId;\n\n    public void addImages(List<PositionedImage> images, int parentWidth, int parentHeight) {\n        HostingClient hosting = new HostingClient();\n        List<HostedImage> hostedImages = new ArrayList<>();\n        for (PositionedImage image : images) {\n            String url = hosting.hostFile(\"image/png\", ImageUtils.toBytes(image.image));\n            hostedImages.add(new HostedImage(image, url));\n        }\n        try {\n            Size slideSize = presentations.get(presentationId).execute().getPageSize();\n            double slideWidth = toPts(slideSize.getWidth());\n            double slideHeight = toPts(slideSize.getHeight());\n            double scale = Math.min(slideWidth / parentWidth, slideHeight / parentHeight);\n            presentations\n                .batchUpdate(presentationId, new BatchUpdatePresentationRequest()\n                    .setRequests(hostedImages.stream()\n                        .map(image -> new Request()\n                            .setCreateImage(new CreateImageRequest()\n                                .setElementProperties(new PageElementProperties()\n                                    .setPageObjectId(slideId)\n                                    .setTransform(new AffineTransform()\n                                        .setTranslateX(image.getImage().x * scale)\n                                        .setTranslateY(image.getImage().y * scale)\n                                        .setScaleX(scale)\n                                        .setScaleY(scale)\n                                        .setUnit(\"PT\")))\n                                .setUrl(image.url)))\n                        .collect(Collectors.toList())))\n                .execute();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static double toPts(Dimension dimension) {\n        switch (dimension.getUnit()) {\n            case \"EMU\":\n                return dimension.getMagnitude() / 12700;\n            case \"PT\":\n                return dimension.getMagnitude();\n            default:\n                throw new RuntimeException(\"Invalid dimension unit: \" + dimension.getUnit());\n        }\n    }\n\n    @Data\n    public static class PositionedImage {\n\n        private final BufferedImage image;\n        private final int x;\n        private final int y;\n    }\n\n    @Data\n    private static class HostedImage {\n\n        private final PositionedImage image;\n        private final String url;\n    }\n}", "item_id": 0, "repo": "kevinychen/snap2", "file": "snap-server/src/main/java/com/kyc/snap/google/PresentationManager.java", "last_update_at": "2022-01-16T06:22:28+00:00", "question_id": "3833871066190b0d3f0ec786374528b7ee356e10_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Data\npublic class PresentationManager {\n    private final Presentations presentations;\n    private final String presentationId;\n    private final String slideId;\n    public void addImages(List<PositionedImage> images, int parentWidth, int parentHeight) {\n        HostingClient hosting = new HostingClient();\n        List<HostedImage> hostedImages = new ArrayList<>();\n        for (PositionedImage image : images) {\n            String url = hosting.hostFile(\"image/png\", ImageUtils.toBytes(image.image));\n            hostedImages.add(new HostedImage(image, url));\n        }\n        try {\n            Size slideSize = presentations.get(presentationId).execute().getPageSize();\n            double slideWidth = toPts(slideSize.getWidth());\n            double slideHeight = toPts(slideSize.getHeight());\n            double scale = Math.min(slideWidth / parentWidth, slideHeight / parentHeight);\n            presentations\n                .batchUpdate(presentationId, new BatchUpdatePresentationRequest()\n                    .setRequests(hostedImages.stream()\n                        .map(image -> new Request()\n                            .setCreateImage(new CreateImageRequest()\n                                .setElementProperties(new PageElementProperties()\n                                    .setPageObjectId(slideId)\n                                    .setTransform(new AffineTransform()\n                                        .setTranslateX(image.getImage().x * scale)\n                                        .setTranslateY(image.getImage().y * scale)\n                                        .setScaleX(scale)\n                                        .setScaleY(scale)\n                                        .setUnit(\"PT\")))\n                                .setUrl(image.url)))\n                        .collect(Collectors.toList())))\n                .execute();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    private static double toPts(Dimension dimension) {\n        switch (dimension.getUnit()) {\n            case \"EMU\":\n                return dimension.getMagnitude() / 12700;\n            case \"PT\":\n                return dimension.getMagnitude();\n            default:\n                throw new RuntimeException(\"Invalid dimension unit: \" + dimension.getUnit());\n        }\n    }\n    @Data\n    public static class PositionedImage {\n        private final BufferedImage image;\n        private final int x;\n        private final int y;\n    }\n    @Data\n    private static class HostedImage {\n        private final PositionedImage image;\n        private final String url;\n    }\n"]], "pred": {"ppl": 1.75804603099823, "ppl_lower": 2.1619536876678467, "ppl/lowercase_ppl": -1.3665512619324691, "ppl/zlib": 0.0007159936328054614, "Min_5.0% Prob": 6.032068212827046, "Min_10.0% Prob": 4.198560802662959, "Min_20.0% Prob": 2.6361348394487725, "Min_30.0% Prob": 1.8465688441131936, "Min_40.0% Prob": 1.4055035282842447, "Min_50.0% Prob": 1.1262129307085393, "Min_60.0% Prob": 0.9402741623169435}}
{"hexsha": "dea97423645a8ac4ca94f6bc34c067a7e48224d6", "ext": "java", "lang": "Java", "content": "public class CompressingFileAppender<E> extends UnsynchronizedAppenderBase<E> {\n\n  protected Encoder<E> encoder;\n\n  private FileAppender<E> fileAppender;\n\n  protected boolean append = true;\n\n  protected String fileName = null;\n\n  private boolean prudent = false;\n\n  private int bufferSize = 1024000;\n\n  private String compressAlgo = CompressorStreamFactory.getGzip();\n\n  public Encoder<E> getEncoder() {\n    return encoder;\n  }\n\n  public void setEncoder(Encoder<E> encoder) {\n    this.encoder = encoder;\n  }\n\n  public boolean isPrudent() {\n    return prudent;\n  }\n\n  public void setPrudent(boolean prudent) {\n    this.prudent = prudent;\n  }\n\n  public void setAppend(boolean append) {\n    this.append = append;\n  }\n\n  public void setFile(String file) {\n    fileName = file;\n  }\n\n  public boolean isAppend() {\n    return append;\n  }\n\n  public String getFile() {\n    return fileName;\n  }\n\n  public int getBufferSize() {\n    return bufferSize;\n  }\n\n  public void setBufferSize(int bufferSize) {\n    this.bufferSize = bufferSize;\n  }\n\n  public String getCompressAlgo() {\n    return compressAlgo;\n  }\n\n  public void setCompressAlgo(String compressAlgo) {\n    this.compressAlgo = compressAlgo;\n  }\n\n  @Override\n  public void start() {\n    fileAppender = new FileAppender<>();\n    fileAppender.setContext(getContext());\n    fileAppender.setFile(getFile());\n    fileAppender.setImmediateFlush(false);\n    fileAppender.setPrudent(isPrudent());\n    fileAppender.setAppend(isAppend());\n    fileAppender.setName(name + \"-embedded-file\");\n\n    CompressingEncoder<E> compressedEncoder = createCompressingEncoder(getEncoder());\n    fileAppender.setEncoder(compressedEncoder);\n    fileAppender.start();\n\n    super.start();\n  }\n\n  public void stop() {\n    fileAppender.stop();\n    super.stop();\n  }\n\n  @Override\n  protected void append(E eventObject) {\n    fileAppender.doAppend(eventObject);\n  }\n\n  protected CompressingEncoder<E> createCompressingEncoder(Encoder<E> e) {\n    int bufferSize = getBufferSize();\n    String compressAlgo = getCompressAlgo();\n\n    CompressorStreamFactory factory = CompressorStreamFactory.getSingleton();\n    Set<String> names = factory.getOutputStreamCompressorNames();\n    if (names.contains(getCompressAlgo())) {\n      try {\n        return new CompressingEncoder<>(e, compressAlgo, factory, bufferSize);\n      } catch (CompressorException ex) {\n        throw new RuntimeException(\"Cannot create CompressingEncoder\", ex);\n      }\n    } else {\n      throw new RuntimeException(\"No such compression algorithm: \" + compressAlgo);\n    }\n  }\n}", "item_id": 0, "repo": "tersesystems/terse-logback", "file": "logback-compress-encoder/src/main/java/com.tersesystems.logback.compress/CompressingFileAppender.java", "last_update_at": "2022-03-22T12:54:14+00:00", "question_id": "dea97423645a8ac4ca94f6bc34c067a7e48224d6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CompressingFileAppender<E> extends UnsynchronizedAppenderBase<E> {\n  protected Encoder<E> encoder;\n  private FileAppender<E> fileAppender;\n  protected boolean append = true;\n  protected String fileName = null;\n  private boolean prudent = false;\n  private int bufferSize = 1024000;\n  private String compressAlgo = CompressorStreamFactory.getGzip();\n  public Encoder<E> getEncoder() {\n    return encoder;\n  }\n  public void setEncoder(Encoder<E> encoder) {\n    this.encoder = encoder;\n  }\n  public boolean isPrudent() {\n    return prudent;\n  }\n  public void setPrudent(boolean prudent) {\n    this.prudent = prudent;\n  }\n  public void setAppend(boolean append) {\n    this.append = append;\n  }\n  public void setFile(String file) {\n    fileName = file;\n  }\n  public boolean isAppend() {\n    return append;\n  }\n  public String getFile() {\n    return fileName;\n  }\n  public int getBufferSize() {\n    return bufferSize;\n  }\n  public void setBufferSize(int bufferSize) {\n    this.bufferSize = bufferSize;\n  }\n  public String getCompressAlgo() {\n    return compressAlgo;\n  }\n  public void setCompressAlgo(String compressAlgo) {\n    this.compressAlgo = compressAlgo;\n  }\n  @Override\n  public void start() {\n    fileAppender = new FileAppender<>();\n    fileAppender.setContext(getContext());\n    fileAppender.setFile(getFile());\n    fileAppender.setImmediateFlush(false);\n    fileAppender.setPrudent(isPrudent());\n    fileAppender.setAppend(isAppend());\n    fileAppender.setName(name + \"-embedded-file\");\n    CompressingEncoder<E> compressedEncoder = createCompressingEncoder(getEncoder());\n    fileAppender.setEncoder(compressedEncoder);\n    fileAppender.start();\n    super.start();\n  }\n  public void stop() {\n    fileAppender.stop();\n    super.stop();\n  }\n  @Override\n  protected void append(E eventObject) {\n    fileAppender.doAppend(eventObject);\n  }\n  protected CompressingEncoder<E> createCompressingEncoder(Encoder<E> e) {\n    int bufferSize = getBufferSize();\n    String compressAlgo = getCompressAlgo();\n    CompressorStreamFactory factory = CompressorStreamFactory.getSingleton();\n    Set<String> names = factory.getOutputStreamCompressorNames();\n    if (names.contains(getCompressAlgo())) {\n      try {\n        return new CompressingEncoder<>(e, compressAlgo, factory, bufferSize);\n      } catch (CompressorException ex) {\n        throw new RuntimeException(\"Cannot create CompressingEncoder\", ex);\n      }\n    } else {\n      throw new RuntimeException(\"No such compression algorithm: \" + compressAlgo);\n    }\n  }\n"]], "pred": {"ppl": 1.5098514556884766, "ppl_lower": 1.7080012559890747, "ppl/lowercase_ppl": -1.2992941376852558, "ppl/zlib": 0.0005515545813541913, "Min_5.0% Prob": 4.4387660920619965, "Min_10.0% Prob": 3.2435997769236566, "Min_20.0% Prob": 1.9842500109225512, "Min_30.0% Prob": 1.3634765651387473, "Min_40.0% Prob": 1.0271740916222798, "Min_50.0% Prob": 0.8241384280764236, "Min_60.0% Prob": 0.6875522424122744}}
{"hexsha": "5448b36f1896fae88ad9b02d8f921742d72bfc10", "ext": "java", "lang": "Java", "content": "public class S1656DesignOrderedStream {\n    class OrderedStream {\n        String[] data;\n        int current;\n\n        public OrderedStream(int n) {\n            data = new String[n+1];\n            current = 1;\n        }\n\n        public List<String> insert(int idKey, String value) {\n            data[idKey] = value;\n            List<String> res = new ArrayList<>();\n            int i = current;\n            while (i < data.length && data[i] != null) {\n                res.add(data[i]);\n                i++;\n            }\n            current = i;\n            return res;\n        }\n    }\n}", "item_id": 0, "repo": "camelcc/leetcode", "file": "src/S1656DesignOrderedStream.java", "last_update_at": "2022-01-04T04:01:32+00:00", "question_id": "5448b36f1896fae88ad9b02d8f921742d72bfc10_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class S1656DesignOrderedStream {\n    class OrderedStream {\n        String[] data;\n        int current;\n        public OrderedStream(int n) {\n            data = new String[n+1];\n            current = 1;\n        }\n        public List<String> insert(int idKey, String value) {\n            data[idKey] = value;\n            List<String> res = new ArrayList<>();\n            int i = current;\n            while (i < data.length && data[i] != null) {\n                res.add(data[i]);\n                i++;\n            }\n            current = i;\n            return res;\n        }\n    }\n"]], "pred": {"ppl": 1.5867663621902466, "ppl_lower": 2.442322015762329, "ppl/lowercase_ppl": -1.9340539154633425, "ppl/zlib": 0.001824894114286441, "Min_5.0% Prob": 5.657243460416794, "Min_10.0% Prob": 4.039869852364063, "Min_20.0% Prob": 2.270381369628012, "Min_30.0% Prob": 1.5251059076007532, "Min_40.0% Prob": 1.1602055994077372, "Min_50.0% Prob": 0.922181007037757, "Min_60.0% Prob": 0.7723019849057594}}
{"hexsha": "c797673248382e6feec94ccd27c96be56563c613", "ext": "java", "lang": "Java", "content": "public class CreateNetworkCmdExec extends AbstrSyncDockerCmdExec<CreateNetworkCmd, CreateNetworkResponse> implements\n        CreateNetworkCmd.Exec {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(CreateNetworkCmdExec.class);\n\n    public CreateNetworkCmdExec(WebTarget baseResource, DockerClientConfig dockerClientConfig) {\n        super(baseResource, dockerClientConfig);\n    }\n\n    @Override\n    protected CreateNetworkResponse execute(CreateNetworkCmd command) {\n        WebTarget webResource = getBaseResource().path(\"/networks/create\");\n\n        LOGGER.trace(\"POST: {}\", webResource);\n        return webResource.request().accept(MediaType.APPLICATION_JSON)\n                .post(command, new TypeReference<CreateNetworkResponse>() {\n                });\n    }\n}", "item_id": 0, "repo": "elliotsayes/docker-java", "file": "docker-java-core/src/main/java/com/github/dockerjava/core/exec/CreateNetworkCmdExec.java", "last_update_at": "2022-03-31T07:11:55+00:00", "question_id": "c797673248382e6feec94ccd27c96be56563c613_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CreateNetworkCmdExec extends AbstrSyncDockerCmdExec<CreateNetworkCmd, CreateNetworkResponse> implements\n        CreateNetworkCmd.Exec {\n    private static final Logger LOGGER = LoggerFactory.getLogger(CreateNetworkCmdExec.class);\n    public CreateNetworkCmdExec(WebTarget baseResource, DockerClientConfig dockerClientConfig) {\n        super(baseResource, dockerClientConfig);\n    }\n    @Override\n    protected CreateNetworkResponse execute(CreateNetworkCmd command) {\n        WebTarget webResource = getBaseResource().path(\"/networks/create\");\n        LOGGER.trace(\"POST: {}\", webResource);\n        return webResource.request().accept(MediaType.APPLICATION_JSON)\n                .post(command, new TypeReference<CreateNetworkResponse>() {\n                });\n    }\n"]], "pred": {"ppl": 1.520288109779358, "ppl_lower": 2.8751652240753174, "ppl/lowercase_ppl": -2.521151796928372, "ppl/zlib": 0.0011291101423291144, "Min_5.0% Prob": 6.145344522264269, "Min_10.0% Prob": 3.88667388425933, "Min_20.0% Prob": 2.0585041307919734, "Min_30.0% Prob": 1.404508790238337, "Min_40.0% Prob": 1.0498487332684767, "Min_50.0% Prob": 0.8369414651095467, "Min_60.0% Prob": 0.7017047497326391}}
{"hexsha": "76e47fbafb289f9dda735661d55a50bea337f183", "ext": "java", "lang": "Java", "content": "public class StudyHavingStudySiteQuery extends AbstractQuery {\r\n\r\n    private static String queryString = \"select distinct s from Study s\";\r\n\r\n    private static String ORGANIZATION_NAME = \"organizationName\";\r\n    \r\n    private static String NCI_INSTITUTE_CODE = \"nciInstituteCode\";\r\n    \r\n    private static String RETIRED_INDICATOR = \"retiredIndicator\";\r\n\r\n    private static String STIUDY_SHORT_TITLE = \"shortTitle\";\r\n\r\n    private static String STUDY_IDENTIFIER_VALUE = \"identifier\";\r\n    \r\n    private static final String DATA_ENTRY_STATUS = \"qcStatus\";\r\n\r\n    public StudyHavingStudySiteQuery() {\r\n\r\n        super(queryString);\r\n        //join(\"s.studyOrganizations ss\");\r\n        //andWhere(\"ss.class = 'SST'\");\r\n    }\r\n    public void joinIdentifier() {\r\n        join(\"s.identifiers as identifier\");\r\n    }\r\n\r\n    public void joinStudyOrganization() {\r\n        join(\"s.studyOrganizations as ss\");\r\n    }\r\n\r\n    \r\n    public void filterByStudySiteName(final String organizationName) {\r\n        String searchString = \"%\" + organizationName.toLowerCase() + \"%\";\r\n        andWhere(\"lower(ss.organization.name) LIKE :\" + ORGANIZATION_NAME);\r\n        setParameter(ORGANIZATION_NAME, searchString);\r\n    }\r\n\r\n    public void filterByStudySiteNciInstituteCode(final String nciInstituteCode) {\r\n        String searchString = \"%\" + nciInstituteCode.toLowerCase() + \"%\";\r\n        andWhere(\"lower(ss.organization.nciInstituteCode) LIKE :\" + NCI_INSTITUTE_CODE);\r\n        andWhere(\"ss.retiredIndicator = :\" + RETIRED_INDICATOR);\r\n        setParameter(NCI_INSTITUTE_CODE, searchString);\r\n        setParameter(RETIRED_INDICATOR, new Boolean(false));\r\n    }\r\n\r\n    public void filterByStudyShortTile(final String shortTitle) {\r\n        String searchString = \"%\" + shortTitle.toLowerCase() + \"%\";\r\n        andWhere(\"lower(s.shortTitle) LIKE :\" + STIUDY_SHORT_TITLE);\r\n        setParameter(STIUDY_SHORT_TITLE, searchString);\r\n    }\r\n\r\n    public void filterByShortTitleOrIdentifiers(String text) {\r\n        leftOuterJoin(STUDY_ALIAS + \".identifiers as identifier\");\r\n        andWhere(\"(lower(s.shortTitle) LIKE :TITLE or lower(identifier.value) LIKE :IDENTIFIER)\");\r\n        setParameter(\"TITLE\", \"%\" + text.toLowerCase() + \"%\");\r\n        setParameter(\"IDENTIFIER\", \"%\" + text.toLowerCase() + \"%\");\r\n    }\r\n\r\n//  identifier\r\n    public void filterByIdentifierValue(final String Identifiervalue) {\r\n    \tjoinIdentifier();\r\n        String searchString = \"%\" + Identifiervalue.toLowerCase() + \"%\";\r\n        andWhere(\"lower(identifier.value) LIKE :\" + STUDY_IDENTIFIER_VALUE);\r\n        setParameter(STUDY_IDENTIFIER_VALUE, searchString);\r\n    }\r\n    \r\n    \r\n    public void filterBySST() {\r\n        andWhere(\"ss.class = 'SST'\");\r\n    }\r\n\r\n    public void filterByIdentifierValueExactMatch(final String Identifiervalue) {\r\n        String searchString = Identifiervalue.toLowerCase();\r\n        andWhere(\"lower(s.identifiers.value) LIKE :\" + STUDY_IDENTIFIER_VALUE);\r\n        setParameter(STUDY_IDENTIFIER_VALUE, searchString);\r\n    }\r\n    \r\n    /**\r\n     * If true, will return only DATA ENTRY completed studies.\r\n     * @param ignoreNonQCedStudy\r\n     */\r\n    public void filterByDataEntryStatus(boolean ignoreNonQCedStudy) {\r\n        if (ignoreNonQCedStudy) {\r\n            andWhere(\"s.dataEntryStatus = :\" + DATA_ENTRY_STATUS);\r\n            setParameter(DATA_ENTRY_STATUS, true);\r\n        }\r\n    }\r\n\r\n}", "item_id": 0, "repo": "colorshifter/caaers", "file": "caAERS/software/core/src/main/java/gov/nih/nci/cabig/caaers/dao/query/StudyHavingStudySiteQuery.java", "last_update_at": "2022-02-01T01:03:15+00:00", "question_id": "76e47fbafb289f9dda735661d55a50bea337f183_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StudyHavingStudySiteQuery extends AbstractQuery {\r\n\r\n    private static String queryString = \"select distinct s from Study s\";\r\n\r\n    private static String ORGANIZATION_NAME = \"organizationName\";\r\n    \r\n    private static String NCI_INSTITUTE_CODE = \"nciInstituteCode\";\r\n    \r\n    private static String RETIRED_INDICATOR = \"retiredIndicator\";\r\n\r\n    private static String STIUDY_SHORT_TITLE = \"shortTitle\";\r\n\r\n    private static String STUDY_IDENTIFIER_VALUE = \"identifier\";\r\n    \r\n    private static final String DATA_ENTRY_STATUS = \"qcStatus\";\r\n\r\n    public StudyHavingStudySiteQuery() {\r\n\r\n        super(queryString);\r\n        //join(\"s.studyOrganizations ss\");\r\n        //andWhere(\"ss.class = 'SST'\");\r\n    }\r\n    public void joinIdentifier() {\r\n        join(\"s.identifiers as identifier\");\r\n    }\r\n\r\n    public void joinStudyOrganization() {\r\n        join(\"s.studyOrganizations as ss\");\r\n    }\r\n\r\n    \r\n    public void filterByStudySiteName(final String organizationName) {\r\n        String searchString = \"%\" + organizationName.toLowerCase() + \"%\";\r\n        andWhere(\"lower(ss.organization.name) LIKE :\" + ORGANIZATION_NAME);\r\n        setParameter(ORGANIZATION_NAME, searchString);\r\n    }\r\n\r\n    public void filterByStudySiteNciInstituteCode(final String nciInstituteCode) {\r\n        String searchString = \"%\" + nciInstituteCode.toLowerCase() + \"%\";\r\n        andWhere(\"lower(ss.organization.nciInstituteCode) LIKE :\" + NCI_INSTITUTE_CODE);\r\n        andWhere(\"ss.retiredIndicator = :\" + RETIRED_INDICATOR);\r\n        setParameter(NCI_INSTITUTE_CODE, searchString);\r\n        setParameter(RETIRED_INDICATOR, new Boolean(false));\r\n    }\r\n\r\n    public void filterByStudyShortTile(final String shortTitle) {\r\n        String searchString = \"%\" + shortTitle.toLowerCase() + \"%\";\r\n        andWhere(\"lower(s.shortTitle) LIKE :\" + STIUDY_SHORT_TITLE);\r\n        setParameter(STIUDY_SHORT_TITLE, searchString);\r\n    }\r\n\r\n    public void filterByShortTitleOrIdentifiers(String text) {\r\n        leftOuterJoin(STUDY_ALIAS + \".identifiers as identifier\");\r\n        andWhere(\"(lower(s.shortTitle) LIKE :TITLE or lower(identifier.value) LIKE :IDENTIFIER)\");\r\n        setParameter(\"TITLE\", \"%\" + text.toLowerCase() + \"%\");\r\n        setParameter(\"IDENTIFIER\", \"%\" + text.toLowerCase() + \"%\");\r\n    }\r\n\r\n//  identifier\r\n    public void filterByIdentifierValue(final String Identifiervalue) {\r\n    \tjoinIdentifier();\r\n        String searchString = \"%\" + Identifiervalue.toLowerCase() + \"%\";\r\n        andWhere(\"lower(identifier.value) LIKE :\" + STUDY_IDENTIFIER_VALUE);\r\n        setParameter(STUDY_IDENTIFIER_VALUE, searchString);\r\n    }\r\n    \r\n    \r\n    public void filterBySST() {\r\n        andWhere(\"ss.class = 'SST'\");\r\n    }\r\n\r\n    public void filterByIdentifierValueExactMatch(final String Identifiervalue) {\r\n        String searchString = Identifiervalue.toLowerCase();\r\n        andWhere(\"lower(s.identifiers.value) LIKE :\" + STUDY_IDENTIFIER_VALUE);\r\n        setParameter(STUDY_IDENTIFIER_VALUE, searchString);\r\n    }\r\n    \r\n    /**\r\n     * If true, will return only DATA ENTRY completed studies.\r\n     * @param ignoreNonQCedStudy\r\n     */\r\n    public void filterByDataEntryStatus(boolean ignoreNonQCedStudy) {\r\n        if (ignoreNonQCedStudy) {\r\n            andWhere(\"s.dataEntryStatus = :\" + DATA_ENTRY_STATUS);\r\n            setParameter(DATA_ENTRY_STATUS, true);\r\n        }\r\n    }\r\n\r\n"]], "pred": {"ppl": 1.7950745820999146, "ppl_lower": 2.0959420204162598, "ppl/lowercase_ppl": -1.26486187724247, "ppl/zlib": 0.0006701564387095707, "Min_5.0% Prob": 6.285418790929458, "Min_10.0% Prob": 4.514186316845464, "Min_20.0% Prob": 2.739433690175122, "Min_30.0% Prob": 1.9124452159100889, "Min_40.0% Prob": 1.4518870804868729, "Min_50.0% Prob": 1.1682670359443255, "Min_60.0% Prob": 0.9756407692160938}}
{"hexsha": "c96b7bbfeb5d17e3b13aedab9e977d813c3fc9c3", "ext": "java", "lang": "Java", "content": "public class GlueCommandFactory extends JSONInputCommandFactory{\n\n\tprivate enum Arguments {\n\t\tworksheetId, hTableId, hNodeId, \n\t\tnewColumnName, defaultValue, selectionName, \n\t\tvalues, ImplMethod\n\t}\n\t\n\t@Override\n\tpublic Command createCommand(JSONArray inputJson, String model, Workspace workspace)\n\t\t\tthrows JSONException, KarmaException {\n\t\tString hNodeId = CommandInputJSONUtil.getStringValue(Arguments.hNodeId.name(), inputJson);\n\t\tString worksheetId = CommandInputJSONUtil.getStringValue(Arguments.worksheetId.name(), inputJson);\n\t\tString hNodeIdList = CommandInputJSONUtil.getStringValue(Arguments.values.name(), inputJson);\n\t\tString implMethod = CommandInputJSONUtil.getStringValue(Arguments.ImplMethod.name(), inputJson);\n\t\tthis.normalizeSelectionId(worksheetId, inputJson, workspace);\n\t\tString selectionName = CommandInputJSONUtil.getStringValue(Arguments.selectionName.name(), inputJson);\n\t\tGlueCommand glueCmd = new GlueCommand(getNewId(workspace), model, worksheetId,\n\t\t\t\thNodeId, selectionName, hNodeIdList, implMethod);\n\t\tglueCmd.setInputParameterJson(inputJson.toString());\n\t\treturn glueCmd;\n\t}\n\n\t@Override\n\tpublic Command createCommand(HttpServletRequest request, Workspace workspace) {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Class<? extends Command> getCorrespondingCommand() {\n\t\treturn GlueCommand.class;\n\t}\n\n}", "item_id": 0, "repo": "rpatil524/Web-Karma", "file": "karma-commands/commands-worksheet/src/main/java/edu/isi/karma/controller/command/worksheet/GlueCommandFactory.java", "last_update_at": "2022-03-15T07:55:38+00:00", "question_id": "c96b7bbfeb5d17e3b13aedab9e977d813c3fc9c3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GlueCommandFactory extends JSONInputCommandFactory{\n\tprivate enum Arguments {\n\t\tworksheetId, hTableId, hNodeId, \n\t\tnewColumnName, defaultValue, selectionName, \n\t\tvalues, ImplMethod\n\t}\n\t\n\t@Override\n\tpublic Command createCommand(JSONArray inputJson, String model, Workspace workspace)\n\t\t\tthrows JSONException, KarmaException {\n\t\tString hNodeId = CommandInputJSONUtil.getStringValue(Arguments.hNodeId.name(), inputJson);\n\t\tString worksheetId = CommandInputJSONUtil.getStringValue(Arguments.worksheetId.name(), inputJson);\n\t\tString hNodeIdList = CommandInputJSONUtil.getStringValue(Arguments.values.name(), inputJson);\n\t\tString implMethod = CommandInputJSONUtil.getStringValue(Arguments.ImplMethod.name(), inputJson);\n\t\tthis.normalizeSelectionId(worksheetId, inputJson, workspace);\n\t\tString selectionName = CommandInputJSONUtil.getStringValue(Arguments.selectionName.name(), inputJson);\n\t\tGlueCommand glueCmd = new GlueCommand(getNewId(workspace), model, worksheetId,\n\t\t\t\thNodeId, selectionName, hNodeIdList, implMethod);\n\t\tglueCmd.setInputParameterJson(inputJson.toString());\n\t\treturn glueCmd;\n\t}\n\t@Override\n\tpublic Command createCommand(HttpServletRequest request, Workspace workspace) {\n\t\treturn null;\n\t}\n\t@Override\n\tpublic Class<? extends Command> getCorrespondingCommand() {\n\t\treturn GlueCommand.class;\n\t}\n"]], "pred": {"ppl": 2.306792974472046, "ppl_lower": 2.867457628250122, "ppl/lowercase_ppl": -1.260292411446448, "ppl/zlib": 0.001723419045734875, "Min_5.0% Prob": 7.780782850165116, "Min_10.0% Prob": 5.970706682938796, "Min_20.0% Prob": 3.8274292893047575, "Min_30.0% Prob": 2.7239278163445197, "Min_40.0% Prob": 2.073219214247752, "Min_50.0% Prob": 1.6710530423894903, "Min_60.0% Prob": 1.3916677844235164}}
{"hexsha": "6230d08f0425e98cd38cf222b765976d97ca58ae", "ext": "java", "lang": "Java", "content": "public class OptionsUtil {\r\n\r\n\tprivate static final Logger logger      = Logger.getLogger(OptionsUtil.class);\r\n\tprivate HashMap<String, String> options       = new HashMap<String, String>();\r\n\tprivate static OptionsUtil INSTANCE     = null;\r\n\t\r\n\tprivate OptionsUtil() {\r\n\t\treadParameters();\r\n\t}\r\n\t\r\n\tpublic static OptionsUtil getInstance() {\r\n\t\tif (INSTANCE == null) {\r\n\t\t\tINSTANCE = new OptionsUtil();\r\n\t\t}\r\n\t\t\r\n\t\treturn INSTANCE;\r\n\t}\r\n\r\n\tpublic void readParameters() {\r\n\t\tString[] args = Platform.getCommandLineArgs();\r\n\t\t\r\n\t\tint i = 0;\r\n\t\ttry {\r\n\t\t\twhile (i < args.length) {\r\n\t\t\t\tString key = args[i];\r\n\t\t\t    String value;\r\n\t\t\t    if (key.startsWith(\"-\")) {\r\n\t\t\t    \ttry {\r\n\t\t\t    \t\tString test = args[i+1];\r\n\t\t\t    \t    if (test.startsWith(\"-\")) {\r\n\t\t\t    \t    \tvalue = test;\r\n\t\t\t    \t    } else {\r\n\t\t\t    \t    \tvalue = key;\r\n\t\t\t    \t    }\r\n\t\t\t    \t} catch (Throwable t) {\r\n\t\t\t    \t\tvalue = key;\r\n\t\t\t    \t}\r\n\t\t\t    \t\r\n\t\t\t\t    options.put(key, value);\r\n\t\t\t    }\r\n\t\t\t    \r\n\t\t\t    i++;\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.error(\"An error occured when trying to read input parameters.\");\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(\"here.\");\r\n\t}\r\n\t\r\n\tpublic static String getOption(String optionName) throws Exception {\r\n\t\t try {\r\n\t\t\t return getInstance().options.get(optionName);\r\n\t\t } catch (Exception e) {\r\n\t\t\t //log and throw it\r\n\t\t\t logger.error(\"An error occured when trying to read input parameters.\");\r\n\t\t\t throw e;\r\n\t\t }\r\n\t}\r\n\r\n}", "item_id": 0, "repo": "InnovativeDigitalSolution/NASA_astrobee_gds", "file": "gov.nasa.util/src/gov/nasa/util/OptionsUtil.java", "last_update_at": "2022-02-24T10:45:55+00:00", "question_id": "6230d08f0425e98cd38cf222b765976d97ca58ae_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OptionsUtil {\r\n\r\n\tprivate static final Logger logger      = Logger.getLogger(OptionsUtil.class);\r\n\tprivate HashMap<String, String> options       = new HashMap<String, String>();\r\n\tprivate static OptionsUtil INSTANCE     = null;\r\n\t\r\n\tprivate OptionsUtil() {\r\n\t\treadParameters();\r\n\t}\r\n\t\r\n\tpublic static OptionsUtil getInstance() {\r\n\t\tif (INSTANCE == null) {\r\n\t\t\tINSTANCE = new OptionsUtil();\r\n\t\t}\r\n\t\t\r\n\t\treturn INSTANCE;\r\n\t}\r\n\r\n\tpublic void readParameters() {\r\n\t\tString[] args = Platform.getCommandLineArgs();\r\n\t\t\r\n\t\tint i = 0;\r\n\t\ttry {\r\n\t\t\twhile (i < args.length) {\r\n\t\t\t\tString key = args[i];\r\n\t\t\t    String value;\r\n\t\t\t    if (key.startsWith(\"-\")) {\r\n\t\t\t    \ttry {\r\n\t\t\t    \t\tString test = args[i+1];\r\n\t\t\t    \t    if (test.startsWith(\"-\")) {\r\n\t\t\t    \t    \tvalue = test;\r\n\t\t\t    \t    } else {\r\n\t\t\t    \t    \tvalue = key;\r\n\t\t\t    \t    }\r\n\t\t\t    \t} catch (Throwable t) {\r\n\t\t\t    \t\tvalue = key;\r\n\t\t\t    \t}\r\n\t\t\t    \t\r\n\t\t\t\t    options.put(key, value);\r\n\t\t\t    }\r\n\t\t\t    \r\n\t\t\t    i++;\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.error(\"An error occured when trying to read input parameters.\");\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(\"here.\");\r\n\t}\r\n\t\r\n\tpublic static String getOption(String optionName) throws Exception {\r\n\t\t try {\r\n\t\t\t return getInstance().options.get(optionName);\r\n\t\t } catch (Exception e) {\r\n\t\t\t //log and throw it\r\n\t\t\t logger.error(\"An error occured when trying to read input parameters.\");\r\n\t\t\t throw e;\r\n\t\t }\r\n\t}\r\n\r\n"]], "pred": {"ppl": 1.7729765176773071, "ppl_lower": 1.9026376008987427, "ppl/lowercase_ppl": -1.1232518050652358, "ppl/zlib": 0.0010430961431758124, "Min_5.0% Prob": 6.1468997826943035, "Min_10.0% Prob": 4.338652178926288, "Min_20.0% Prob": 2.6307499937291414, "Min_30.0% Prob": 1.848950321599841, "Min_40.0% Prob": 1.4171994356832034, "Min_50.0% Prob": 1.1396855169537474, "Min_60.0% Prob": 0.9539482413296355}}
{"hexsha": "e62593df411efd0f1684fdccd2d77dbe46a1d13e", "ext": "java", "lang": "Java", "content": "@Controller\n@RequestMapping(\"/datashare\")\npublic class DataShareController {\n    private final ShareService shareService;\n    @Value(\"${datashareHost}\")\n    private String datashareHost;\n\n    public DataShareController(ShareService shareService) {\n        this.shareService = shareService;\n    }\n\n    @GetMapping(\"/index\")\n    public String index(Map<String, Object> map, HttpServletRequest request,String path) throws IOException {\n\n        net.gvsun.session.dto.User user = shareService.getCurrentUserFromUnifySession(request);\n\n        request.getSession().setAttribute(\"user\", user);\n\n        GvsunDataSourceDto currDbSource = shareService.getCurrDbSource();\n        map.put(\"currDbSource\", currDbSource);\n        map.put(\"path\", path);\n        return \"/datashare/dataShareCenter\";\n    }\n\n    @GetMapping(\"/schoolCampusList\")\n    public String schoolCampusList() {\n        return \"/datashare/share/schoolCampusList\";\n    }\n\n    @GetMapping(\"/userCardList\")\n    public String userCardList() {\n        return \"/datashare/share/userCardList\";\n    }\n\n    @GetMapping(\"/schoolAcademyList\")\n    public String schoolAcademyList() {\n        return \"/datashare/share/schoolAcademyList\";\n    }\n\n    @GetMapping(\"/userList\")\n    public String userList() {\n        return \"/datashare/share/userList\";\n    }\n\n    @GetMapping(\"/schoolTermList\")\n    public String schoolTermList() {\n        return \"/datashare/share/schoolTermList\";\n    }\n\n    @GetMapping(\"/schoolTimeList\")\n    public String schoolTimeList() {\n        return \"/datashare/share/schoolTimeList\";\n    }\n\n    @GetMapping(\"/schoolBuildList\")\n    public String schoolBuildList() {\n        return \"/datashare/share/schoolBuildList\";\n    }\n\n    @GetMapping(\"/schoolSubjectList\")\n    public String schoolSubjectList() {\n        return \"/datashare/share/schoolSubjectList\";\n    }\n\n    @GetMapping(\"/schoolMajorList\")\n    public String schoolMajorList() {\n        return \"/datashare/share/schoolMajorList\";\n    }\n\n    @GetMapping(\"/schoolDepartmentList\")\n    public String schoolDepartmentList() {\n        return \"/datashare/share/schoolDepartmentList\";\n    }\n\n    @GetMapping(\"/schoolClassList\")\n    public String schoolClassList() {\n        return \"/datashare/share/schoolClassList\";\n    }\n\n    @GetMapping(\"/schoolRoomList\")\n    public String schoolRoomList() {\n        return \"/datashare/share/schoolRoomList\";\n    }\n\n    @GetMapping(\"/schoolDeviceList\")\n    public String schoolDeviceList() {\n        return \"/datashare/share/schoolDeviceList\";\n    }\n\n    @GetMapping(\"/dictionary\")\n    public String dictionary() {\n        return \"/datashare/share/dictionary\";\n    }\n\n    @GetMapping(\"/dictionaryType\")\n    public String dictionaryType() {\n        return \"/datashare/share/dictionaryType\";\n    }\n\n    @GetMapping(\"/schoolCourseList\")\n    public String schoolCourseList() {\n        return \"/datashare/share/schoolCourseList\";\n    }\n\n    @GetMapping(\"/schoolCourseInfoList\")\n    public String schoolCourseInfoList() {\n        return \"/datashare/share/schoolCourseInfoList\";\n    }\n\n    @GetMapping(\"/schoolCourseDetailList\")\n    public String schoolCourseDetailList() {\n        return \"/datashare/share/schoolCourseDetailList\";\n    }\n\n    @GetMapping(\"/schoolCourseClassList\")\n    public String schoolCourseClassList() {\n        return \"/datashare/share/schoolCourseClassList\";\n    }\n\n    @GetMapping(\"/schoolCourseStudentList\")\n    public String schoolCourseStudentList() {\n        return \"/datashare/share/schoolCourseStudentList\";\n    }\n\n    @GetMapping(\"/viewDetail\")\n    public String viewDetail(Map<String, Object> map,String courseNo) {\n        map.put(\"courseNo\",courseNo);\n        return \"/datashare/share/viewDetail\";\n    }\n\n    @GetMapping(\"/viewCourseStudent\")\n    public String viewCourseStudent(Map<String, Object> map,String courseNo) {\n        map.put(\"courseNo\",courseNo);\n        return \"/datashare/share/viewCourseStudent\";\n    }\n\n    @GetMapping(\"/newSchoolTerm\")\n    public String newSchoolTerm() {\n        return \"/datashare/share/newSchoolTerm\";\n    }\n\n    @GetMapping(\"/newSchoolCourse\")\n    public String newSchoolCourse() {\n        return \"/datashare/share/newSchoolCourse\";\n    }\n\n    @GetMapping(\"/newSchoolCourseInfo\")\n    public String newSchoolCourseInfo() {\n        return \"/datashare/share/newSchoolCourseInfo\";\n    }\n\n    @GetMapping(\"/newDictionaryType\")\n    public String newDictionaryType() {\n        return \"/datashare/share/newDictionaryType\";\n    }\n\n}", "item_id": 0, "repo": "osgvsun/lubanlou", "file": "usercenter-front/src/main/java/net/gvsun/teacherinformationcenter/controller/datashare/DataShareController.java", "last_update_at": "2022-01-20T04:42:37+00:00", "question_id": "e62593df411efd0f1684fdccd2d77dbe46a1d13e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Controller\n@RequestMapping(\"/datashare\")\npublic class DataShareController {\n    private final ShareService shareService;\n    @Value(\"${datashareHost}\")\n    private String datashareHost;\n    public DataShareController(ShareService shareService) {\n        this.shareService = shareService;\n    }\n    @GetMapping(\"/index\")\n    public String index(Map<String, Object> map, HttpServletRequest request,String path) throws IOException {\n        net.gvsun.session.dto.User user = shareService.getCurrentUserFromUnifySession(request);\n        request.getSession().setAttribute(\"user\", user);\n        GvsunDataSourceDto currDbSource = shareService.getCurrDbSource();\n        map.put(\"currDbSource\", currDbSource);\n        map.put(\"path\", path);\n        return \"/datashare/dataShareCenter\";\n    }\n    @GetMapping(\"/schoolCampusList\")\n    public String schoolCampusList() {\n        return \"/datashare/share/schoolCampusList\";\n    }\n    @GetMapping(\"/userCardList\")\n    public String userCardList() {\n        return \"/datashare/share/userCardList\";\n    }\n    @GetMapping(\"/schoolAcademyList\")\n    public String schoolAcademyList() {\n        return \"/datashare/share/schoolAcademyList\";\n    }\n    @GetMapping(\"/userList\")\n    public String userList() {\n        return \"/datashare/share/userList\";\n    }\n    @GetMapping(\"/schoolTermList\")\n    public String schoolTermList() {\n        return \"/datashare/share/schoolTermList\";\n    }\n    @GetMapping(\"/schoolTimeList\")\n    public String schoolTimeList() {\n        return \"/datashare/share/schoolTimeList\";\n    }\n    @GetMapping(\"/schoolBuildList\")\n    public String schoolBuildList() {\n        return \"/datashare/share/schoolBuildList\";\n    }\n    @GetMapping(\"/schoolSubjectList\")\n    public String schoolSubjectList() {\n        return \"/datashare/share/schoolSubjectList\";\n    }\n    @GetMapping(\"/schoolMajorList\")\n    public String schoolMajorList() {\n        return \"/datashare/share/schoolMajorList\";\n    }\n    @GetMapping(\"/schoolDepartmentList\")\n    public String schoolDepartmentList() {\n        return \"/datashare/share/schoolDepartmentList\";\n    }\n    @GetMapping(\"/schoolClassList\")\n    public String schoolClassList() {\n        return \"/datashare/share/schoolClassList\";\n    }\n    @GetMapping(\"/schoolRoomList\")\n    public String schoolRoomList() {\n        return \"/datashare/share/schoolRoomList\";\n    }\n    @GetMapping(\"/schoolDeviceList\")\n    public String schoolDeviceList() {\n        return \"/datashare/share/schoolDeviceList\";\n    }\n    @GetMapping(\"/dictionary\")\n    public String dictionary() {\n        return \"/datashare/share/dictionary\";\n    }\n    @GetMapping(\"/dictionaryType\")\n    public String dictionaryType() {\n        return \"/datashare/share/dictionaryType\";\n    }\n    @GetMapping(\"/schoolCourseList\")\n    public String schoolCourseList() {\n        return \"/datashare/share/schoolCourseList\";\n    }\n    @GetMapping(\"/schoolCourseInfoList\")\n    public String schoolCourseInfoList() {\n        return \"/datashare/share/schoolCourseInfoList\";\n    }\n    @GetMapping(\"/schoolCourseDetailList\")\n    public String schoolCourseDetailList() {\n        return \"/datashare/share/schoolCourseDetailList\";\n    }\n    @GetMapping(\"/schoolCourseClassList\")\n    public String schoolCourseClassList() {\n        return \"/datashare/share/schoolCourseClassList\";\n    }\n    @GetMapping(\"/schoolCourseStudentList\")\n    public String schoolCourseStudentList() {\n        return \"/datashare/share/schoolCourseStudentList\";\n    }\n    @GetMapping(\"/viewDetail\")\n    public String viewDetail(Map<String, Object> map,String courseNo) {\n        map.put(\"courseNo\",courseNo);\n        return \"/datashare/share/viewDetail\";\n    }\n    @GetMapping(\"/viewCourseStudent\")\n    public String viewCourseStudent(Map<String, Object> map,String courseNo) {\n        map.put(\"courseNo\",courseNo);\n        return \"/datashare/share/viewCourseStudent\";\n    }\n    @GetMapping(\"/newSchoolTerm\")\n    public String newSchoolTerm() {\n        return \"/datashare/share/newSchoolTerm\";\n    }\n    @GetMapping(\"/newSchoolCourse\")\n    public String newSchoolCourse() {\n        return \"/datashare/share/newSchoolCourse\";\n    }\n    @GetMapping(\"/newSchoolCourseInfo\")\n    public String newSchoolCourseInfo() {\n        return \"/datashare/share/newSchoolCourseInfo\";\n    }\n    @GetMapping(\"/newDictionaryType\")\n    public String newDictionaryType() {\n        return \"/datashare/share/newDictionaryType\";\n    }\n"]], "pred": {"ppl": 1.4322465658187866, "ppl_lower": 1.5694128274917603, "ppl/lowercase_ppl": -1.254582560614993, "ppl/zlib": 0.0004683757973286039, "Min_5.0% Prob": 5.155796051025391, "Min_10.0% Prob": 3.3135392256811556, "Min_20.0% Prob": 1.7774019146922464, "Min_30.0% Prob": 1.1959969912065205, "Min_40.0% Prob": 0.8972330207624507, "Min_50.0% Prob": 0.7187848559582111, "Min_60.0% Prob": 0.5993853359074685}}
{"hexsha": "166edaf948f37cbd4f574618f7512af0d99665b1", "ext": "java", "lang": "Java", "content": "@WithTags({@WithTag(\"testType:Integration\")})\n@SuppressWarnings(\"unchecked\")\nclass RetrieveRegionDetailsIntegrationTest extends LrdAuthorizationEnabledIntegrationTest {\n\n    public static final String HTTP_STATUS = \"http_status\";\n\n    List<LrdRegionResponse> expectedListAll = List.of(\n        new LrdRegionResponse(new Region(\"1\", \"National\", null)),\n        new LrdRegionResponse(new Region(\"2\", \"London\", null)),\n        new LrdRegionResponse(new Region(\"3\", \"Midlands\", null)),\n        new LrdRegionResponse(new Region(\"4\", \"North East\", null)),\n        new LrdRegionResponse(new Region(\"5\", \"North West\", null)),\n        new LrdRegionResponse(new Region(\"6\", \"South East\", null)),\n        new LrdRegionResponse(new Region(\"7\", \"South West\", null)),\n        new LrdRegionResponse(new Region(\"8\", \"Wales\", null)),\n        new LrdRegionResponse(new Region(\"9\", \"Scotland\", null))\n    );\n\n    @Test\n    void returnsRegionDetailsByDescriptionWithStatusCode_200() throws JsonProcessingException {\n\n        List<LrdRegionResponse> response = (List<LrdRegionResponse>)\n            lrdApiClient.findRegionDetailsByDescription(\"London\", LrdRegionResponse[].class);\n\n        assertNotNull(response);\n        responseVerification(response, 1);\n    }\n\n    @Test\n    void returnsRegionDetailsByDescriptionsWithStatusCode_200() throws JsonProcessingException {\n\n        List<LrdRegionResponse> response = (List<LrdRegionResponse>)\n            lrdApiClient.findRegionDetailsByDescription(\"London, Midlands\", LrdRegionResponse[].class);\n\n        assertNotNull(response);\n        responseVerification(response, 2);\n    }\n\n    @Test\n    void returnsRegionDetailsByDescriptionCaseInsensitiveWithStatusCode_200() throws JsonProcessingException {\n\n        List<LrdRegionResponse> response = (List<LrdRegionResponse>)\n            lrdApiClient.findRegionDetailsByDescription(\"LoNdOn\", LrdRegionResponse[].class);\n\n        assertNotNull(response);\n        responseVerification(response, 1);\n    }\n\n    @Test\n    void returnsRegionDetailsByIdWithStatusCode_200() throws JsonProcessingException {\n\n        List<LrdRegionResponse> response = (List<LrdRegionResponse>)\n            lrdApiClient.findRegionDetailsById(\"2\", LrdRegionResponse[].class);\n\n        assertNotNull(response);\n        responseVerification(response, 1);\n    }\n\n    @Test\n    void returnsRegionDetailsByIdsWithStatusCode_200() throws JsonProcessingException {\n\n        List<LrdRegionResponse> response = (List<LrdRegionResponse>)\n            lrdApiClient.findRegionDetailsById(\"2, 3\", LrdRegionResponse[].class);\n\n        assertNotNull(response);\n        responseVerification(response, 2);\n    }\n\n    @Test\n    void returnsRegionDetailsByIdAllWithStatusCode_200() throws JsonProcessingException {\n\n        List<LrdRegionResponse> response = (List<LrdRegionResponse>)\n            lrdApiClient.findRegionDetailsById(\"ALL\", LrdRegionResponse[].class);\n\n        assertNotNull(response);\n        responseVerificationForAll(response, expectedListAll);\n    }\n\n    @Test\n    void returnsRegionDetailsById1AndAllWithStatusCode_200() throws JsonProcessingException {\n\n        List<LrdRegionResponse> response = (List<LrdRegionResponse>)\n            lrdApiClient.findRegionDetailsById(\"1, ALL\", LrdRegionResponse[].class);\n\n        assertNotNull(response);\n        assertEquals(9, response.size());\n        assertEquals(\"1\", response.get(0).getRegionId());\n        assertEquals(\"National\", response.get(0).getDescription());\n        assertNull(response.get(0).getWelshDescription());\n    }\n\n    @Test\n    void returnsRegionDetailsNoParamWithStatusCode_200() throws JsonProcessingException {\n\n        List<LrdRegionResponse> response = (List<LrdRegionResponse>)\n            lrdApiClient.findRegionDetailsById(\"\", LrdRegionResponse[].class);\n\n        assertNotNull(response);\n        assertEquals(8, response.size());\n    }\n\n    @Test\n    void doesNotReturnRegionDetailsByInvalidDescriptionWithStatusCode_404() throws JsonProcessingException {\n\n        Map<String, Object> errorResponseMap = (Map<String, Object>)\n            lrdApiClient.findRegionDetailsByDescription(\"Invalid Description\", ErrorResponse.class);\n\n\n        assertThat(errorResponseMap).containsEntry(HTTP_STATUS, HttpStatus.NOT_FOUND);\n    }\n\n    @Test\n    void doesNotReturnRegionByInvalidDescriptionSpecialCharWithStatusCode_400() throws JsonProcessingException {\n\n        Map<String, Object> errorResponseMap = (Map<String, Object>)\n            lrdApiClient.findRegionDetailsByDescription(\"Lo\u00a3nd*on\", ErrorResponse.class);\n\n\n        assertThat(errorResponseMap).containsEntry(HTTP_STATUS, HttpStatus.BAD_REQUEST);\n    }\n\n    @Test\n    void doesNotReturnRegionByInvalidIdnSpecialCharWithStatusCode_400() throws JsonProcessingException {\n\n        Map<String, Object> errorResponseMap = (Map<String, Object>)\n            lrdApiClient.findRegionDetailsByDescription(\"1*\", ErrorResponse.class);\n\n\n        assertThat(errorResponseMap).containsEntry(HTTP_STATUS, HttpStatus.BAD_REQUEST);\n    }\n\n    private void responseVerification(List<LrdRegionResponse> response, int expectedRegions) {\n        assertThat(response.size()).isEqualTo(expectedRegions);\n        assertThat(response.get(0).getRegionId()).isEqualTo(\"2\");\n        assertThat(response.get(0).getDescription()).isEqualTo(\"London\");\n        assertThat(response.get(0).getWelshDescription()).isNull();\n        if (expectedRegions == 2) {\n            assertThat(response.get(1).getRegionId()).isEqualTo(\"3\");\n            assertThat(response.get(1).getDescription()).isEqualTo(\"Midlands\");\n            assertThat(response.get(1).getWelshDescription()).isNull();\n        }\n    }\n\n    private void responseVerificationForAll(List<LrdRegionResponse> actual, List<LrdRegionResponse> expected) {\n        assertThat(actual).hasSize(expected.size()).usingRecursiveComparison().isEqualTo(expected);\n    }\n\n}", "item_id": 0, "repo": "hmcts/rd-location-ref-api", "file": "src/integrationTest/java/uk/gov/hmcts/reform/lrdapi/RetrieveRegionDetailsIntegrationTest.java", "last_update_at": "2022-03-25T17:28:53+00:00", "question_id": "166edaf948f37cbd4f574618f7512af0d99665b1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@WithTags({@WithTag(\"testType:Integration\")})\n@SuppressWarnings(\"unchecked\")\nclass RetrieveRegionDetailsIntegrationTest extends LrdAuthorizationEnabledIntegrationTest {\n    public static final String HTTP_STATUS = \"http_status\";\n    List<LrdRegionResponse> expectedListAll = List.of(\n        new LrdRegionResponse(new Region(\"1\", \"National\", null)),\n        new LrdRegionResponse(new Region(\"2\", \"London\", null)),\n        new LrdRegionResponse(new Region(\"3\", \"Midlands\", null)),\n        new LrdRegionResponse(new Region(\"4\", \"North East\", null)),\n        new LrdRegionResponse(new Region(\"5\", \"North West\", null)),\n        new LrdRegionResponse(new Region(\"6\", \"South East\", null)),\n        new LrdRegionResponse(new Region(\"7\", \"South West\", null)),\n        new LrdRegionResponse(new Region(\"8\", \"Wales\", null)),\n        new LrdRegionResponse(new Region(\"9\", \"Scotland\", null))\n    );\n    @Test\n    void returnsRegionDetailsByDescriptionWithStatusCode_200() throws JsonProcessingException {\n        List<LrdRegionResponse> response = (List<LrdRegionResponse>)\n            lrdApiClient.findRegionDetailsByDescription(\"London\", LrdRegionResponse[].class);\n        assertNotNull(response);\n        responseVerification(response, 1);\n    }\n    @Test\n    void returnsRegionDetailsByDescriptionsWithStatusCode_200() throws JsonProcessingException {\n        List<LrdRegionResponse> response = (List<LrdRegionResponse>)\n            lrdApiClient.findRegionDetailsByDescription(\"London, Midlands\", LrdRegionResponse[].class);\n        assertNotNull(response);\n        responseVerification(response, 2);\n    }\n    @Test\n    void returnsRegionDetailsByDescriptionCaseInsensitiveWithStatusCode_200() throws JsonProcessingException {\n        List<LrdRegionResponse> response = (List<LrdRegionResponse>)\n            lrdApiClient.findRegionDetailsByDescription(\"LoNdOn\", LrdRegionResponse[].class);\n        assertNotNull(response);\n        responseVerification(response, 1);\n    }\n    @Test\n    void returnsRegionDetailsByIdWithStatusCode_200() throws JsonProcessingException {\n        List<LrdRegionResponse> response = (List<LrdRegionResponse>)\n            lrdApiClient.findRegionDetailsById(\"2\", LrdRegionResponse[].class);\n        assertNotNull(response);\n        responseVerification(response, 1);\n    }\n    @Test\n    void returnsRegionDetailsByIdsWithStatusCode_200() throws JsonProcessingException {\n        List<LrdRegionResponse> response = (List<LrdRegionResponse>)\n            lrdApiClient.findRegionDetailsById(\"2, 3\", LrdRegionResponse[].class);\n        assertNotNull(response);\n        responseVerification(response, 2);\n    }\n    @Test\n    void returnsRegionDetailsByIdAllWithStatusCode_200() throws JsonProcessingException {\n        List<LrdRegionResponse> response = (List<LrdRegionResponse>)\n            lrdApiClient.findRegionDetailsById(\"ALL\", LrdRegionResponse[].class);\n        assertNotNull(response);\n        responseVerificationForAll(response, expectedListAll);\n    }\n    @Test\n    void returnsRegionDetailsById1AndAllWithStatusCode_200() throws JsonProcessingException {\n        List<LrdRegionResponse> response = (List<LrdRegionResponse>)\n            lrdApiClient.findRegionDetailsById(\"1, ALL\", LrdRegionResponse[].class);\n        assertNotNull(response);\n        assertEquals(9, response.size());\n        assertEquals(\"1\", response.get(0).getRegionId());\n        assertEquals(\"National\", response.get(0).getDescription());\n        assertNull(response.get(0).getWelshDescription());\n    }\n    @Test\n    void returnsRegionDetailsNoParamWithStatusCode_200() throws JsonProcessingException {\n        List<LrdRegionResponse> response = (List<LrdRegionResponse>)\n            lrdApiClient.findRegionDetailsById(\"\", LrdRegionResponse[].class);\n        assertNotNull(response);\n        assertEquals(8, response.size());\n    }\n    @Test\n    void doesNotReturnRegionDetailsByInvalidDescriptionWithStatusCode_404() throws JsonProcessingException {\n        Map<String, Object> errorResponseMap = (Map<String, Object>)\n            lrdApiClient.findRegionDetailsByDescription(\"Invalid Description\", ErrorResponse.class);\n        assertThat(errorResponseMap).containsEntry(HTTP_STATUS, HttpStatus.NOT_FOUND);\n    }\n    @Test\n    void doesNotReturnRegionByInvalidDescriptionSpecialCharWithStatusCode_400() throws JsonProcessingException {\n        Map<String, Object> errorResponseMap = (Map<String, Object>)\n            lrdApiClient.findRegionDetailsByDescription(\"Lo\u00a3nd*on\", ErrorResponse.class);\n        assertThat(errorResponseMap).containsEntry(HTTP_STATUS, HttpStatus.BAD_REQUEST);\n    }\n    @Test\n    void doesNotReturnRegionByInvalidIdnSpecialCharWithStatusCode_400() throws JsonProcessingException {\n        Map<String, Object> errorResponseMap = (Map<String, Object>)\n            lrdApiClient.findRegionDetailsByDescription(\"1*\", ErrorResponse.class);\n        assertThat(errorResponseMap).containsEntry(HTTP_STATUS, HttpStatus.BAD_REQUEST);\n    }\n    private void responseVerification(List<LrdRegionResponse> response, int expectedRegions) {\n        assertThat(response.size()).isEqualTo(expectedRegions);\n        assertThat(response.get(0).getRegionId()).isEqualTo(\"2\");\n        assertThat(response.get(0).getDescription()).isEqualTo(\"London\");\n        assertThat(response.get(0).getWelshDescription()).isNull();\n        if (expectedRegions == 2) {\n            assertThat(response.get(1).getRegionId()).isEqualTo(\"3\");\n            assertThat(response.get(1).getDescription()).isEqualTo(\"Midlands\");\n            assertThat(response.get(1).getWelshDescription()).isNull();\n        }\n    }\n    private void responseVerificationForAll(List<LrdRegionResponse> actual, List<LrdRegionResponse> expected) {\n        assertThat(actual).hasSize(expected.size()).usingRecursiveComparison().isEqualTo(expected);\n    }\n"]], "pred": {"ppl": 1.474831223487854, "ppl_lower": 1.677237868309021, "ppl/lowercase_ppl": -1.3309918619136754, "ppl/zlib": 0.0004043117153910242, "Min_5.0% Prob": 5.228248282974842, "Min_10.0% Prob": 3.448677557356217, "Min_20.0% Prob": 1.9149364714017685, "Min_30.0% Prob": 1.2933787745149696, "Min_40.0% Prob": 0.9704351592512942, "Min_50.0% Prob": 0.7774889924647305, "Min_60.0% Prob": 0.6483296144590941}}
{"hexsha": "38954e4fa4dcbe6542ae92d969290e8dd9efd554", "ext": "java", "lang": "Java", "content": "public class SmsIntentService extends IntentService {\n    public static final int NOTIFICATION_ID = 1;\n    private NotificationManager mNotificationManager;\n\n    public SmsIntentService() {\n        super(\"GcmIntentService\");\n    }\n    public static final String TAG = \"SMS Gateway\";\n\n    @Override\n    protected void onHandleIntent(Intent intent)\n    {\n        Bundle extras = intent.getExtras();\n        GoogleCloudMessaging gcm = GoogleCloudMessaging.getInstance(this);\n        String messageType = gcm.getMessageType(intent);\n\n        if (!extras.isEmpty())\n        {\n            if (GoogleCloudMessaging.MESSAGE_TYPE_MESSAGE.equals(messageType))\n            {\n                String number = extras.getString(\"number\");\n                String message = extras.getString(\"message\");\n                if (!TextUtils.isEmpty(number) && !TextUtils.isEmpty(message))\n                {\n                    try\n                    {\n                        if (!number.startsWith(\"+\"))\n                        {\n                            number = \"+\" + number;\n                        }\n                        SmsManager smsManager = SmsManager.getDefault();\n                        ArrayList<String> parts = smsManager.divideMessage(message);\n                        if (parts.size() > 1)\n                        {\n                            smsManager.sendMultipartTextMessage(number, null, parts, null, null);\n                        }\n                        else\n                        {\n                            smsManager.sendTextMessage(number, null, message, null, null);\n                        }\n\n                        String result = number + \": \" + message;\n                        Log.i(TAG, result);\n\n                        sendNotification(result);\n\n                        ContentValues values = new ContentValues();\n                        values.put(\"address\", number);\n                        values.put(\"body\", message);\n                        getApplicationContext().getContentResolver()\n                                               .insert(Uri.parse(\"content://sms/sent\"), values);\n                    }\n                    catch (Exception ex)\n                    {\n                        Log.e(TAG, ex.toString());\n                    }\n                }\n            }\n        }\n        SmsBroadcastReceiver.completeWakefulIntent(intent);\n    }\n\n    private void sendNotification(String msg) {\n        mNotificationManager = (NotificationManager) this.getSystemService(Context.NOTIFICATION_SERVICE);\n\n        PendingIntent contentIntent = PendingIntent.getActivity(this, 0, new Intent(this, MainActivity.class), 0);\n\n        NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this)\n        .setSmallIcon(R.drawable.ic_stat_gcm)\n        .setContentTitle(getText(R.string.app_name))\n        .setStyle(new NotificationCompat.BigTextStyle()\n        .bigText(msg))\n        .setContentText(msg).setAutoCancel(true);\n\n        mBuilder.setContentIntent(contentIntent);\n        mNotificationManager.notify(NOTIFICATION_ID, mBuilder.build());\n    }\n}", "item_id": 0, "repo": "gymka/android-sms-gateway", "file": "src/main/java/com/anjlab/android/smsgateway/gcm/SmsIntentService.java", "last_update_at": "2022-03-28T19:13:09+00:00", "question_id": "38954e4fa4dcbe6542ae92d969290e8dd9efd554_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SmsIntentService extends IntentService {\n    public static final int NOTIFICATION_ID = 1;\n    private NotificationManager mNotificationManager;\n    public SmsIntentService() {\n        super(\"GcmIntentService\");\n    }\n    public static final String TAG = \"SMS Gateway\";\n    @Override\n    protected void onHandleIntent(Intent intent)\n    {\n        Bundle extras = intent.getExtras();\n        GoogleCloudMessaging gcm = GoogleCloudMessaging.getInstance(this);\n        String messageType = gcm.getMessageType(intent);\n        if (!extras.isEmpty())\n        {\n            if (GoogleCloudMessaging.MESSAGE_TYPE_MESSAGE.equals(messageType))\n            {\n                String number = extras.getString(\"number\");\n                String message = extras.getString(\"message\");\n                if (!TextUtils.isEmpty(number) && !TextUtils.isEmpty(message))\n                {\n                    try\n                    {\n                        if (!number.startsWith(\"+\"))\n                        {\n                            number = \"+\" + number;\n                        }\n                        SmsManager smsManager = SmsManager.getDefault();\n                        ArrayList<String> parts = smsManager.divideMessage(message);\n                        if (parts.size() > 1)\n                        {\n                            smsManager.sendMultipartTextMessage(number, null, parts, null, null);\n                        }\n                        else\n                        {\n                            smsManager.sendTextMessage(number, null, message, null, null);\n                        }\n                        String result = number + \": \" + message;\n                        Log.i(TAG, result);\n                        sendNotification(result);\n                        ContentValues values = new ContentValues();\n                        values.put(\"address\", number);\n                        values.put(\"body\", message);\n                        getApplicationContext().getContentResolver()\n                                               .insert(Uri.parse(\"content://sms/sent\"), values);\n                    }\n                    catch (Exception ex)\n                    {\n                        Log.e(TAG, ex.toString());\n                    }\n                }\n            }\n        }\n        SmsBroadcastReceiver.completeWakefulIntent(intent);\n    }\n    private void sendNotification(String msg) {\n        mNotificationManager = (NotificationManager) this.getSystemService(Context.NOTIFICATION_SERVICE);\n        PendingIntent contentIntent = PendingIntent.getActivity(this, 0, new Intent(this, MainActivity.class), 0);\n        NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this)\n        .setSmallIcon(R.drawable.ic_stat_gcm)\n        .setContentTitle(getText(R.string.app_name))\n        .setStyle(new NotificationCompat.BigTextStyle()\n        .bigText(msg))\n        .setContentText(msg).setAutoCancel(true);\n        mBuilder.setContentIntent(contentIntent);\n        mNotificationManager.notify(NOTIFICATION_ID, mBuilder.build());\n    }\n"]], "pred": {"ppl": 1.349134087562561, "ppl_lower": 1.7169376611709595, "ppl/lowercase_ppl": -1.8050387811323414, "ppl/zlib": 0.00029886523955525675, "Min_5.0% Prob": 3.8897492488225303, "Min_10.0% Prob": 2.545814786871819, "Min_20.0% Prob": 1.43982244436055, "Min_30.0% Prob": 0.9873463845212166, "Min_40.0% Prob": 0.7461773842598681, "Min_50.0% Prob": 0.5985757284338445, "Min_60.0% Prob": 0.4993731330258381}}
{"hexsha": "fb5fb0cbd38cd76fbbd8c2b73a773da087dc0977", "ext": "java", "lang": "Java", "content": "public class ProjectDescriptor {\n\tprivate final String projectName;\n\tprivate final File projectSaveFile;\n\tprivate final Workspace workspace;\n\n\tpublic ProjectDescriptor(@NotNull String projectName, @NotNull File projectSaveFile, @NotNull Workspace workspace) {\n\t\tthis.projectName = projectName;\n\t\tthis.projectSaveFile = projectSaveFile;\n\t\tthis.workspace = workspace;\n\t}\n\n\t@NotNull\n\tpublic Workspace getWorkspace() {\n\t\treturn workspace;\n\t}\n\n\t@NotNull\n\tpublic File getProjectSaveFile() {\n\t\treturn projectSaveFile;\n\t}\n\n\t@NotNull\n\tpublic String getProjectName() {\n\t\treturn projectName;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o == null || getClass() != o.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tProjectDescriptor that = (ProjectDescriptor) o;\n\n\t\tif (!projectName.equals(that.projectName)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn projectSaveFile.equals(that.projectSaveFile);\n\t}\n\n}", "item_id": 0, "repo": "kayler-renslow/arma-dialog-creator", "file": "ADC Modules/ADC Application/src/com/armadialogcreator/application/ProjectDescriptor.java", "last_update_at": "2022-03-23T22:22:49+00:00", "question_id": "fb5fb0cbd38cd76fbbd8c2b73a773da087dc0977_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProjectDescriptor {\n\tprivate final String projectName;\n\tprivate final File projectSaveFile;\n\tprivate final Workspace workspace;\n\tpublic ProjectDescriptor(@NotNull String projectName, @NotNull File projectSaveFile, @NotNull Workspace workspace) {\n\t\tthis.projectName = projectName;\n\t\tthis.projectSaveFile = projectSaveFile;\n\t\tthis.workspace = workspace;\n\t}\n\t@NotNull\n\tpublic Workspace getWorkspace() {\n\t\treturn workspace;\n\t}\n\t@NotNull\n\tpublic File getProjectSaveFile() {\n\t\treturn projectSaveFile;\n\t}\n\t@NotNull\n\tpublic String getProjectName() {\n\t\treturn projectName;\n\t}\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o == null || getClass() != o.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tProjectDescriptor that = (ProjectDescriptor) o;\n\t\tif (!projectName.equals(that.projectName)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn projectSaveFile.equals(that.projectSaveFile);\n\t}\n"]], "pred": {"ppl": 1.3392211198806763, "ppl_lower": 1.5000032186508179, "ppl/lowercase_ppl": -1.3881672253785924, "ppl/zlib": 0.0009185163243677318, "Min_5.0% Prob": 4.611424922943115, "Min_10.0% Prob": 2.7580461422602336, "Min_20.0% Prob": 1.4536086241485642, "Min_30.0% Prob": 0.973558647699816, "Min_40.0% Prob": 0.7304003595949976, "Min_50.0% Prob": 0.5839453177230264, "Min_60.0% Prob": 0.48885765411282395}}
{"hexsha": "a4d51c464101b86c3b0cf599d73b78ed99752f62", "ext": "java", "lang": "Java", "content": "public class MessageUtil {\n\n    private MessageUtil() {\n        throw new IllegalAccessError(\"Utility class\");\n    }\n\n    public static boolean hasFields(Message message) {\n        return !message.getFields().isEmpty();\n    }\n\n    /**\n     * Returns a list of bit fields used for field presence checks.\n     */\n    public static List<String> bitFieldNames(Message message) {\n        int fieldCount = message.getFieldCount();\n        if (fieldCount == 0) {\n            return Collections.emptyList();\n        }\n        List<String> result = new ArrayList<>();\n        int n = (fieldCount - 1) / 32 + 1;\n        for (int i = 0; i < n; i++) {\n            result.add(\"__bitField\" + i);\n        }\n        return result;\n    }\n\n    public static String getOneofEnumClassName(Oneof oneof) {\n        String name = oneof.getName();\n        return Formatter.toPascalCase(name) + \"Case\";\n    }\n\n    /**\n     * Returns a \"not set\" name for one-of enum constant.\n     */\n    public static String getOneofNotSetConstantName(Oneof oneof) {\n        String name = oneof.getName();\n        String underscored = Formatter.toUnderscoreCase(name);\n        return Formatter.toUpperCase(underscored) + \"_NOT_SET\";\n    }\n\n    public static String getOneofCaseGetterName(Oneof oneof) {\n        String name = oneof.getName();\n        return \"get\" + Formatter.toPascalCase(name) + \"Case\";\n    }\n\n    public static String getOneofCaseCleanerName(Oneof oneof) {\n        String name = oneof.getName();\n        return \"clear\" + Formatter.toPascalCase(name);\n    }\n\n    public static String getOneofFieldName(Oneof oneof) {\n        String name = oneof.getName();\n        return Formatter.toCamelCase(name) + \"__\";\n    }\n\n    public static String getOneofCaseFieldName(Oneof oneof) {\n        String name = oneof.getName();\n        return Formatter.toCamelCase(name) + \"Case__\";\n    }\n}", "item_id": 0, "repo": "gagranov/protostuff-compiler", "file": "protostuff-generator/src/main/java/io/protostuff/generator/java/MessageUtil.java", "last_update_at": "2022-03-02T00:56:59+00:00", "question_id": "a4d51c464101b86c3b0cf599d73b78ed99752f62_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MessageUtil {\n    private MessageUtil() {\n        throw new IllegalAccessError(\"Utility class\");\n    }\n    public static boolean hasFields(Message message) {\n        return !message.getFields().isEmpty();\n    }\n    /**\n     * Returns a list of bit fields used for field presence checks.\n     */\n    public static List<String> bitFieldNames(Message message) {\n        int fieldCount = message.getFieldCount();\n        if (fieldCount == 0) {\n            return Collections.emptyList();\n        }\n        List<String> result = new ArrayList<>();\n        int n = (fieldCount - 1) / 32 + 1;\n        for (int i = 0; i < n; i++) {\n            result.add(\"__bitField\" + i);\n        }\n        return result;\n    }\n    public static String getOneofEnumClassName(Oneof oneof) {\n        String name = oneof.getName();\n        return Formatter.toPascalCase(name) + \"Case\";\n    }\n    /**\n     * Returns a \"not set\" name for one-of enum constant.\n     */\n    public static String getOneofNotSetConstantName(Oneof oneof) {\n        String name = oneof.getName();\n        String underscored = Formatter.toUnderscoreCase(name);\n        return Formatter.toUpperCase(underscored) + \"_NOT_SET\";\n    }\n    public static String getOneofCaseGetterName(Oneof oneof) {\n        String name = oneof.getName();\n        return \"get\" + Formatter.toPascalCase(name) + \"Case\";\n    }\n    public static String getOneofCaseCleanerName(Oneof oneof) {\n        String name = oneof.getName();\n        return \"clear\" + Formatter.toPascalCase(name);\n    }\n    public static String getOneofFieldName(Oneof oneof) {\n        String name = oneof.getName();\n        return Formatter.toCamelCase(name) + \"__\";\n    }\n    public static String getOneofCaseFieldName(Oneof oneof) {\n        String name = oneof.getName();\n        return Formatter.toCamelCase(name) + \"Case__\";\n    }\n"]], "pred": {"ppl": 1.7407416105270386, "ppl_lower": 2.124804735183716, "ppl/lowercase_ppl": -1.3596691907675469, "ppl/zlib": 0.0010208310043647766, "Min_5.0% Prob": 5.726856911623919, "Min_10.0% Prob": 4.077726827968251, "Min_20.0% Prob": 2.581831230358644, "Min_30.0% Prob": 1.813510606595964, "Min_40.0% Prob": 1.3759643978932325, "Min_50.0% Prob": 1.1079888435526062, "Min_60.0% Prob": 0.9254453011979757}}
{"hexsha": "60b1865ce445a0de08c8744d25e13aa6488addb3", "ext": "java", "lang": "Java", "content": "@Service\npublic class ProgettoFormativoFormatter {\n\tprivate static Log logger = LogFactory.getLog(ProgettoFormativoFormatter.class);\n\t\t\t\n\t@Autowired\n\tprivate AttivitaAlternanzaRepository attivitaAlternanzaRepository;\n\t\n\t@Autowired\n\tprivate EsperienzaSvoltaRepository esperienzaSvoltaRepository;\n\t\n\t@Autowired\n\tprivate StudenteRepository studenteRepository;\n\t\n\t@Autowired\n\tprivate AziendaRepository aziendaRepository;\n\t\n\t@Autowired\n\tprivate IstituzioneRepository istituzioneRepository;\n\t\n\t@Autowired\n\tprivate ResourceLoader resourceLoader;\n\t\n\t@Autowired\n\tprivate CompetenzaManager competenzaManager;\n\t\n\tDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n\t\n\tpublic OdtFile getOtdFile(String istitutoId, Long esperienzaSvoltaId) throws Exception {\n\t\tEsperienzaSvolta es = esperienzaSvoltaRepository.findById(esperienzaSvoltaId).orElse(null);\n\t\tif(es == null) {\n\t\t\tthrow new BadRequestException(\"esperienza non trovato\");\n\t\t}\n\t\tif(!es.getIstitutoId().equals(istitutoId)) {\n\t\t\tthrow new BadRequestException(\"istituto non corrispondente\");\n\t\t}\n\t\tIstituzione istituzione = istituzioneRepository.findById(istitutoId).orElse(null);\n\t\tif(istituzione == null) {\n\t\t\tthrow new BadRequestException(\"istituto non trovato\");\n\t\t}\n\t\tStudente studente = studenteRepository.findById(es.getStudenteId()).orElse(null);\n\t\tif(studente == null) {\n\t\t\tthrow new BadRequestException(\"studente non trovato\");\n\t\t}\n\t\tAttivitaAlternanza aa = attivitaAlternanzaRepository.findById(es.getAttivitaAlternanzaId()).orElse(null);\n\t\tif(aa == null) {\n\t\t\tthrow new BadRequestException(\"attivit\u00e0 non trovata\");\n\t\t}\n\t\tif(aa.getTipologia() != 7) {\n\t\t\tthrow new BadRequestException(\"tipologia non conforme\");\n\t\t}\n\t\tAzienda azienda = aziendaRepository.findById(aa.getEnteId()).orElse(null);\n\t\tif(azienda == null) {\n\t\t\tthrow new BadRequestException(\"anzienda/ente non trovata\");\n\t\t}\n\t\tList<Competenza> competenze = competenzaManager.getRisorsaCompetenze(aa.getUuid());\n\t\t\n\t\tProgettoFormativoOdt pf = new ProgettoFormativoOdt();\n\t\tpf.setCognome(studente.getSurname());\n\t\tpf.setNome(studente.getName());\n\t\tpf.setDataNascita(studente.getBirthdate());\n\t\tpf.setEmail(getNotEmpty(studente.getEmail()));\n\t\tpf.setClasse(es.getClasseStudente());\n\t\tpf.setEnte(azienda.getNome());\n\t\tpf.setPartitaIva(azienda.getPartita_iva());\n\t\tpf.setIndirizzo(getIndirizzo(aa, azienda));\n\t\tpf.setTipologia(getTipologiaAzienda(azienda));\n\t\tpf.setContattoTel(getNotEmpty(azienda.getPhone()));\n\t\tpf.setDateFrom(aa.getDataInizio().format(formatter));\n\t\tpf.setDateTo(aa.getDataFine().format(formatter));\n\t\tpf.setOre(String.valueOf(aa.getOre()));\n\t\tpf.setIntNominativo(getNotEmpty(aa.getReferenteScuola()));\n\t\tpf.setIntEmail(getNotEmpty(aa.getReferenteScuolaEmail()));\n\t\tpf.setEstNominativo(getNotEmpty(aa.getReferenteEsterno()));\n\t\tpf.setEstEmail(getNotEmpty(aa.getReferenteEsternoEmail()));\n\t\tpf.setDescrizione(getNotEmpty(aa.getDescrizione()));\n\t\tpf.setPolizzaInail(getNotEmpty(istituzione.getPolizzaInail()));\n\t\tpf.setRctPat(getNotEmpty(istituzione.getRctPat()));\n\t\tpf.setInfortuniPat(getNotEmpty(istituzione.getInfortuniPat()));\n\t\t\n\t\t// Load ODT file and set Velocity template engine and cache it to the registry\n\t\tResource resource = resourceLoader.getResource(\"classpath:templates/progetto_formativo_it.odt\");\n\t\tInputStream isTemplate = resource.getInputStream();\n\t\tIXDocReport report = XDocReportRegistry.getRegistry().loadReport(isTemplate, TemplateEngineKind.Velocity);\n\t\t\n\t\t// Create Java model context\n\t\tIContext context = report.createContext();\n\t\tcontext.put(\"pf\", pf);\n\t\tcontext.put(\"competenze\", competenze);\n\t\t\n\t\t// Generate report by merging Java model with the ODT\n\t\tPath tempFile = Files.createTempFile(\"edit-pf-\", \".odt\");\n\t\ttempFile.toFile().deleteOnExit();\n\t\tFile outputFileODT = tempFile.toFile();\n\t\tOutputStream osODT = new FileOutputStream(outputFileODT);\n\t\treport.process(context, osODT);\n\t\tosODT.flush();\n\t\tosODT.close();\n\t\t\n\t\tif(logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"getOtdFile:\" + outputFileODT.getAbsolutePath());\n\t\t}\n\t\tString filename = \"Progetto formativo \" + es.getNominativoStudente() + \" \" + es.getClasseStudente() + \" \" + aa.getTitolo() + \".odt\";\n\t\tfilename = filename.replace(\" \", \"_\");\n    OdtFile odtFile = new OdtFile();\n    odtFile.setFile(outputFileODT);\n    odtFile.setFilename(filename);\n\t\treturn odtFile;\n\t}\n\t\n\tprivate String getNotEmpty(String value) {\n\t\tif(value == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn value;\n\t}\n\t\n\tprivate String getIndirizzo(AttivitaAlternanza aa, Azienda azienda) {\n\t\tif(Utils.isNotEmpty(aa.getLuogoSvolgimento())) {\n\t\t\treturn aa.getLuogoSvolgimento();\n\t\t}\n\t\tif(Utils.isNotEmpty(azienda.getAddress())) {\n\t\t\treturn azienda.getAddress();\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\tprivate String getTipologiaAzienda(Azienda azienda) {\n\t\tswitch(azienda.getIdTipoAzienda()) {\n\t\t\tcase 1: return \"Associazione\";\n\t\t\tcase 5: return \"Cooperativa\";\n\t\t\tcase 10: return \"Impresa\";\n\t\t\tcase 15: return \"Libero professionista\";\n\t\t\tcase 20: return \"Pubblica amministrazione\";\n\t\t\tcase 25: return \"Ente privato/Fondazione\";\n\t\t}\n\t\treturn \"\";\n\t}\n\n\n}", "item_id": 0, "repo": "smartcommunitylab/cartella-asl-v2", "file": "back-end/src/main/java/it/smartcommunitylab/cartella/asl/services/ProgettoFormativoFormatter.java", "last_update_at": "2022-03-02T08:04:27+00:00", "question_id": "60b1865ce445a0de08c8744d25e13aa6488addb3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class ProgettoFormativoFormatter {\n\tprivate static Log logger = LogFactory.getLog(ProgettoFormativoFormatter.class);\n\t\t\t\n\t@Autowired\n\tprivate AttivitaAlternanzaRepository attivitaAlternanzaRepository;\n\t\n\t@Autowired\n\tprivate EsperienzaSvoltaRepository esperienzaSvoltaRepository;\n\t\n\t@Autowired\n\tprivate StudenteRepository studenteRepository;\n\t\n\t@Autowired\n\tprivate AziendaRepository aziendaRepository;\n\t\n\t@Autowired\n\tprivate IstituzioneRepository istituzioneRepository;\n\t\n\t@Autowired\n\tprivate ResourceLoader resourceLoader;\n\t\n\t@Autowired\n\tprivate CompetenzaManager competenzaManager;\n\t\n\tDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n\t\n\tpublic OdtFile getOtdFile(String istitutoId, Long esperienzaSvoltaId) throws Exception {\n\t\tEsperienzaSvolta es = esperienzaSvoltaRepository.findById(esperienzaSvoltaId).orElse(null);\n\t\tif(es == null) {\n\t\t\tthrow new BadRequestException(\"esperienza non trovato\");\n\t\t}\n\t\tif(!es.getIstitutoId().equals(istitutoId)) {\n\t\t\tthrow new BadRequestException(\"istituto non corrispondente\");\n\t\t}\n\t\tIstituzione istituzione = istituzioneRepository.findById(istitutoId).orElse(null);\n\t\tif(istituzione == null) {\n\t\t\tthrow new BadRequestException(\"istituto non trovato\");\n\t\t}\n\t\tStudente studente = studenteRepository.findById(es.getStudenteId()).orElse(null);\n\t\tif(studente == null) {\n\t\t\tthrow new BadRequestException(\"studente non trovato\");\n\t\t}\n\t\tAttivitaAlternanza aa = attivitaAlternanzaRepository.findById(es.getAttivitaAlternanzaId()).orElse(null);\n\t\tif(aa == null) {\n\t\t\tthrow new BadRequestException(\"attivit\u00e0 non trovata\");\n\t\t}\n\t\tif(aa.getTipologia() != 7) {\n\t\t\tthrow new BadRequestException(\"tipologia non conforme\");\n\t\t}\n\t\tAzienda azienda = aziendaRepository.findById(aa.getEnteId()).orElse(null);\n\t\tif(azienda == null) {\n\t\t\tthrow new BadRequestException(\"anzienda/ente non trovata\");\n\t\t}\n\t\tList<Competenza> competenze = competenzaManager.getRisorsaCompetenze(aa.getUuid());\n\t\t\n\t\tProgettoFormativoOdt pf = new ProgettoFormativoOdt();\n\t\tpf.setCognome(studente.getSurname());\n\t\tpf.setNome(studente.getName());\n\t\tpf.setDataNascita(studente.getBirthdate());\n\t\tpf.setEmail(getNotEmpty(studente.getEmail()));\n\t\tpf.setClasse(es.getClasseStudente());\n\t\tpf.setEnte(azienda.getNome());\n\t\tpf.setPartitaIva(azienda.getPartita_iva());\n\t\tpf.setIndirizzo(getIndirizzo(aa, azienda));\n\t\tpf.setTipologia(getTipologiaAzienda(azienda));\n\t\tpf.setContattoTel(getNotEmpty(azienda.getPhone()));\n\t\tpf.setDateFrom(aa.getDataInizio().format(formatter));\n\t\tpf.setDateTo(aa.getDataFine().format(formatter));\n\t\tpf.setOre(String.valueOf(aa.getOre()));\n\t\tpf.setIntNominativo(getNotEmpty(aa.getReferenteScuola()));\n\t\tpf.setIntEmail(getNotEmpty(aa.getReferenteScuolaEmail()));\n\t\tpf.setEstNominativo(getNotEmpty(aa.getReferenteEsterno()));\n\t\tpf.setEstEmail(getNotEmpty(aa.getReferenteEsternoEmail()));\n\t\tpf.setDescrizione(getNotEmpty(aa.getDescrizione()));\n\t\tpf.setPolizzaInail(getNotEmpty(istituzione.getPolizzaInail()));\n\t\tpf.setRctPat(getNotEmpty(istituzione.getRctPat()));\n\t\tpf.setInfortuniPat(getNotEmpty(istituzione.getInfortuniPat()));\n\t\t\n\t\t// Load ODT file and set Velocity template engine and cache it to the registry\n\t\tResource resource = resourceLoader.getResource(\"classpath:templates/progetto_formativo_it.odt\");\n\t\tInputStream isTemplate = resource.getInputStream();\n\t\tIXDocReport report = XDocReportRegistry.getRegistry().loadReport(isTemplate, TemplateEngineKind.Velocity);\n\t\t\n\t\t// Create Java model context\n\t\tIContext context = report.createContext();\n\t\tcontext.put(\"pf\", pf);\n\t\tcontext.put(\"competenze\", competenze);\n\t\t\n\t\t// Generate report by merging Java model with the ODT\n\t\tPath tempFile = Files.createTempFile(\"edit-pf-\", \".odt\");\n\t\ttempFile.toFile().deleteOnExit();\n\t\tFile outputFileODT = tempFile.toFile();\n\t\tOutputStream osODT = new FileOutputStream(outputFileODT);\n\t\treport.process(context, osODT);\n\t\tosODT.flush();\n\t\tosODT.close();\n\t\t\n\t\tif(logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"getOtdFile:\" + outputFileODT.getAbsolutePath());\n\t\t}\n\t\tString filename = \"Progetto formativo \" + es.getNominativoStudente() + \" \" + es.getClasseStudente() + \" \" + aa.getTitolo() + \".odt\";\n\t\tfilename = filename.replace(\" \", \"_\");\n    OdtFile odtFile = new OdtFile();\n    odtFile.setFile(outputFileODT);\n    odtFile.setFilename(filename);\n\t\treturn odtFile;\n\t}\n\t\n\tprivate String getNotEmpty(String value) {\n\t\tif(value == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn value;\n\t}\n\t\n\tprivate String getIndirizzo(AttivitaAlternanza aa, Azienda azienda) {\n\t\tif(Utils.isNotEmpty(aa.getLuogoSvolgimento())) {\n\t\t\treturn aa.getLuogoSvolgimento();\n\t\t}\n\t\tif(Utils.isNotEmpty(azienda.getAddress())) {\n\t\t\treturn azienda.getAddress();\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\tprivate String getTipologiaAzienda(Azienda azienda) {\n\t\tswitch(azienda.getIdTipoAzienda()) {\n\t\t\tcase 1: return \"Associazione\";\n\t\t\tcase 5: return \"Cooperativa\";\n\t\t\tcase 10: return \"Impresa\";\n\t\t\tcase 15: return \"Libero professionista\";\n\t\t\tcase 20: return \"Pubblica amministrazione\";\n\t\t\tcase 25: return \"Ente privato/Fondazione\";\n\t\t}\n\t\treturn \"\";\n\t}\n"]], "pred": {"ppl": 1.7042839527130127, "ppl_lower": 2.064190626144409, "ppl/lowercase_ppl": -1.3593640160512432, "ppl/zlib": 0.00033363269927439885, "Min_5.0% Prob": 6.398751254175224, "Min_10.0% Prob": 4.458695556603226, "Min_20.0% Prob": 2.5804396661765434, "Min_30.0% Prob": 1.7639785151368652, "Min_40.0% Prob": 1.3286974795873123, "Min_50.0% Prob": 1.0658653872233401, "Min_60.0% Prob": 0.8893339801621494}}
{"hexsha": "f47a90b6e364133e5f5879fad5b6b48cab9927c0", "ext": "java", "lang": "Java", "content": "public class StormEnvironment {\n\n\tpublic static final String BEGIN_DATABASE = \":DB_START\";\n\tpublic static final String END_DATABASE = \":DB_END\";\n\tpublic static final String BEGIN_CONVERTERS = \":CONV_START\";\n\tpublic static final String END_CONVERTERS = \":CONV_END\";\n\tprivate static final String ENV_FILE = \"stormEnv\";\n\tprivate ProcessorLogger logger;\n\tprivate Map<String,DatabaseModel> dbModels = new TreeMap<String,DatabaseModel>();\n\tprivate List<ConverterModel> converters = new ArrayList<ConverterModel>();\n\tprivate Map<String, ConverterModel> typeMap = new HashMap<String, ConverterModel>();\n\n\tStormEnvironment(ProcessorLogger logger) {\n\t\tthis.logger = logger;\n\t\taddBuiltInConverters();\n\t}\n\n\tprivate void addBuiltInConverters() {\n\t\tthis.addConverter(new ConverterModel(new BlobConverter()));\n\t\tthis.addConverter(new ConverterModel(new BooleanConverter()));\n\t\tthis.addConverter(new ConverterModel(new ByteConverter()));\n\t\tthis.addConverter(new ConverterModel(new CharConverter()));\n\t\tthis.addConverter(new ConverterModel(new DateConverter()));\n\t\tthis.addConverter(new ConverterModel(new DoubleConverter()));\n\t\tthis.addConverter(new ConverterModel(new EnumConverter()));\n\t\tthis.addConverter(new ConverterModel(new FloatConverter()));\n\t\tthis.addConverter(new ConverterModel(new IntegerConverter()));\n\t\tthis.addConverter(new ConverterModel(new LongConverter()));\n\t\tthis.addConverter(new ConverterModel(new ShortConverter()));\n\t\tthis.addConverter(new ConverterModel(new StringConverter()));\n\t}\n\n\tpublic ProcessorLogger getLogger() {\n\t\treturn this.logger;\n\t}\n\n\tvoid addDatabase(DatabaseModel dbModel) {\n\t\tdbModels.put(dbModel.getQualifiedClassName(), dbModel);\n\t}\n\n\tCollection<DatabaseModel> getDbModels() {\n\t\treturn dbModels.values();\n\t}\n\n\tpublic DatabaseModel getDbByName(String helperClass) {\n\t\treturn dbModels.get(helperClass);\n\t}\n\n\tpublic DatabaseModel getDefaultDb() {\n\t\tif (dbModels.size() > 0) {\n\t\t\treturn dbModels.values().iterator().next();\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Read the current model state from a file in support of incremental\n\t * compilation. This is necessary because the annotation processor has\n\t * access to only classes which have been annotated (and any resulting\n\t * generated classes on subsequent rounds), but DatabaseHelper classes\n\t * aren't available when doing incremental compilation on a new @Entity.\n\t *\n\t * @see http\n\t *      ://stackoverflow.com/questions/10585665/how-can-i-examine-the-whole\n\t *      -source-tree-with-an-annotation-processor\n\t *      https://github.com/sentinelt/evo-classindex\n\t *\n\t * @param Filer\n\t *            used by the annotation processor\n\t */\n\tvoid readIndex(Filer filer) {\n\t\tStandardLocation location = StandardLocation.SOURCE_OUTPUT;\n\t\tFileObject indexFile;\n\t\ttry {\n\t\t\tindexFile = filer.getResource(location, \"com.turbomanage.storm\",\n\t\t\t\t\tENV_FILE);\n\t\t\tlogger.info(\"Reading index \" + indexFile.toUri());\n\t\t\t// indexFile.openReader() not implemented on all platforms\n\t\t\tReader fileReader = new InputStreamReader(indexFile.openInputStream());\n\t\t\tBufferedReader reader = new BufferedReader(fileReader);\n\t\t\tString line = reader.readLine(); // BEGIN_CONVERTERS\n\t\t\tline = reader.readLine();\n\t\t\twhile (line != null && !line.startsWith(END_CONVERTERS)) {\n\t\t\t\tConverterModel converter = ConverterModel.readFromIndex(line, logger);\n\t\t\t\tthis.addConverter(converter);\n\t\t\t\tline = reader.readLine();\n\t\t\t}\n\t\t\tline = reader.readLine();\n\t\t\twhile (line != null && line.startsWith(BEGIN_DATABASE)) {\n\t\t\t\tDatabaseModel dbModel = DatabaseModel.readFromIndex(reader, logger);\n\t\t\t\tthis.addDatabase(dbModel);\n\t\t\t\tline = reader.readLine();\n\t\t\t}\n\t\t\treader.close();\n\t\t} catch (IOException e) {\n\t\t\t// gulp--only way to catch not yet existing file on first run\n\t\t}\n\t}\n\n\t/**\n\t * Write the current model state to a file in support of incremental\n\t * compilation.\n\t *\n\t * @see StormEnvironment#readIndex(Filer)\n\t *\n\t * @param Filer\n\t *            used by the annotation processor\n\t */\n\tvoid writeIndex(Filer filer) {\n\t\tStandardLocation location = StandardLocation.SOURCE_OUTPUT;\n\t\tFileObject indexFile;\n\t\ttry {\n\t\t\tindexFile = filer.createResource(location, \"com.turbomanage.storm\",\n\t\t\t\t\tENV_FILE);\n\t\t\tOutputStream fos = indexFile.openOutputStream();\n\t\t\tPrintWriter out = new PrintWriter(fos);\n\t\t\t// Dump converters\n\t\t\tout.println(BEGIN_CONVERTERS);\n\t\t\tfor (ConverterModel converter : converters) {\n\t\t\t\tconverter.writeToIndex(out);\n\t\t\t}\n\t\t\tout.println(END_CONVERTERS);\n\t\t\t// Dump databases\n\t\t\tfor (DatabaseModel dbModel : dbModels.values()) {\n\t\t\t\tdbModel.writeToIndex(out);\n\t\t\t}\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Register a custom {@link TypeConverter} for a given data (field) type.\n\t * This method is called at compile time by the annotation processor. In\n\t * order for the TypeConverter to be visible, it must be in a jar on the\n\t * client project's annotation factory classpath.\n\t *\n\t * @param converter\n\t * @return true if successful, false if converter was already registered for\n\t *         type\n\t */\n\tpublic boolean addConverter(ConverterModel converter) {\n\t\tif (converters.contains(converter))\n\t\t\treturn true;\n\t\tfor (String type : converter.getConvertibleTypes()) {\n\t\t\t// TODO what if already put the 1st type?\n\t\t\tif (typeMap.containsKey(type)\n\t\t\t\t\t&& !typeMap.get(type).equals(converter))\n\t\t\t\treturn false;\n\t\t\ttypeMap.put(type, converter);\n\t\t}\n\t\tconverters.add(converter);\n\t\tlogger.info(\"Added \" + converter.getQualifiedClassName());\n\t\treturn true;\n\t}\n\n\tpublic ConverterModel getConverterForType(String javaType) {\n\t\tConverterModel converter = typeMap.get(javaType);\n\t\tif (converter != null)\n\t\t\treturn converter;\n\t\tthrow new TypeNotSupportedException(\n\t\t\t\t\"Could not find converter for type \" + javaType);\n\t}\n\n\tpublic List<ConverterModel> getConverters() {\n\t\treturn converters;\n\t}\n\n}", "item_id": 0, "repo": "coachnow/storm-gen", "file": "storm-apt/impl/src/main/java/com/turbomanage/storm/apt/StormEnvironment.java", "last_update_at": "2022-02-26T01:06:44+00:00", "question_id": "f47a90b6e364133e5f5879fad5b6b48cab9927c0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StormEnvironment {\n\tpublic static final String BEGIN_DATABASE = \":DB_START\";\n\tpublic static final String END_DATABASE = \":DB_END\";\n\tpublic static final String BEGIN_CONVERTERS = \":CONV_START\";\n\tpublic static final String END_CONVERTERS = \":CONV_END\";\n\tprivate static final String ENV_FILE = \"stormEnv\";\n\tprivate ProcessorLogger logger;\n\tprivate Map<String,DatabaseModel> dbModels = new TreeMap<String,DatabaseModel>();\n\tprivate List<ConverterModel> converters = new ArrayList<ConverterModel>();\n\tprivate Map<String, ConverterModel> typeMap = new HashMap<String, ConverterModel>();\n\tStormEnvironment(ProcessorLogger logger) {\n\t\tthis.logger = logger;\n\t\taddBuiltInConverters();\n\t}\n\tprivate void addBuiltInConverters() {\n\t\tthis.addConverter(new ConverterModel(new BlobConverter()));\n\t\tthis.addConverter(new ConverterModel(new BooleanConverter()));\n\t\tthis.addConverter(new ConverterModel(new ByteConverter()));\n\t\tthis.addConverter(new ConverterModel(new CharConverter()));\n\t\tthis.addConverter(new ConverterModel(new DateConverter()));\n\t\tthis.addConverter(new ConverterModel(new DoubleConverter()));\n\t\tthis.addConverter(new ConverterModel(new EnumConverter()));\n\t\tthis.addConverter(new ConverterModel(new FloatConverter()));\n\t\tthis.addConverter(new ConverterModel(new IntegerConverter()));\n\t\tthis.addConverter(new ConverterModel(new LongConverter()));\n\t\tthis.addConverter(new ConverterModel(new ShortConverter()));\n\t\tthis.addConverter(new ConverterModel(new StringConverter()));\n\t}\n\tpublic ProcessorLogger getLogger() {\n\t\treturn this.logger;\n\t}\n\tvoid addDatabase(DatabaseModel dbModel) {\n\t\tdbModels.put(dbModel.getQualifiedClassName(), dbModel);\n\t}\n\tCollection<DatabaseModel> getDbModels() {\n\t\treturn dbModels.values();\n\t}\n\tpublic DatabaseModel getDbByName(String helperClass) {\n\t\treturn dbModels.get(helperClass);\n\t}\n\tpublic DatabaseModel getDefaultDb() {\n\t\tif (dbModels.size() > 0) {\n\t\t\treturn dbModels.values().iterator().next();\n\t\t}\n\t\treturn null;\n\t}\n\t/**\n\t * Read the current model state from a file in support of incremental\n\t * compilation. This is necessary because the annotation processor has\n\t * access to only classes which have been annotated (and any resulting\n\t * generated classes on subsequent rounds), but DatabaseHelper classes\n\t * aren't available when doing incremental compilation on a new @Entity.\n\t *\n\t * @see http\n\t *      ://stackoverflow.com/questions/10585665/how-can-i-examine-the-whole\n\t *      -source-tree-with-an-annotation-processor\n\t *      https://github.com/sentinelt/evo-classindex\n\t *\n\t * @param Filer\n\t *            used by the annotation processor\n\t */\n\tvoid readIndex(Filer filer) {\n\t\tStandardLocation location = StandardLocation.SOURCE_OUTPUT;\n\t\tFileObject indexFile;\n\t\ttry {\n\t\t\tindexFile = filer.getResource(location, \"com.turbomanage.storm\",\n\t\t\t\t\tENV_FILE);\n\t\t\tlogger.info(\"Reading index \" + indexFile.toUri());\n\t\t\t// indexFile.openReader() not implemented on all platforms\n\t\t\tReader fileReader = new InputStreamReader(indexFile.openInputStream());\n\t\t\tBufferedReader reader = new BufferedReader(fileReader);\n\t\t\tString line = reader.readLine(); // BEGIN_CONVERTERS\n\t\t\tline = reader.readLine();\n\t\t\twhile (line != null && !line.startsWith(END_CONVERTERS)) {\n\t\t\t\tConverterModel converter = ConverterModel.readFromIndex(line, logger);\n\t\t\t\tthis.addConverter(converter);\n\t\t\t\tline = reader.readLine();\n\t\t\t}\n\t\t\tline = reader.readLine();\n\t\t\twhile (line != null && line.startsWith(BEGIN_DATABASE)) {\n\t\t\t\tDatabaseModel dbModel = DatabaseModel.readFromIndex(reader, logger);\n\t\t\t\tthis.addDatabase(dbModel);\n\t\t\t\tline = reader.readLine();\n\t\t\t}\n\t\t\treader.close();\n\t\t} catch (IOException e) {\n\t\t\t// gulp--only way to catch not yet existing file on first run\n\t\t}\n\t}\n\t/**\n\t * Write the current model state to a file in support of incremental\n\t * compilation.\n\t *\n\t * @see StormEnvironment#readIndex(Filer)\n\t *\n\t * @param Filer\n\t *            used by the annotation processor\n\t */\n\tvoid writeIndex(Filer filer) {\n\t\tStandardLocation location = StandardLocation.SOURCE_OUTPUT;\n\t\tFileObject indexFile;\n\t\ttry {\n\t\t\tindexFile = filer.createResource(location, \"com.turbomanage.storm\",\n\t\t\t\t\tENV_FILE);\n\t\t\tOutputStream fos = indexFile.openOutputStream();\n\t\t\tPrintWriter out = new PrintWriter(fos);\n\t\t\t// Dump converters\n\t\t\tout.println(BEGIN_CONVERTERS);\n\t\t\tfor (ConverterModel converter : converters) {\n\t\t\t\tconverter.writeToIndex(out);\n\t\t\t}\n\t\t\tout.println(END_CONVERTERS);\n\t\t\t// Dump databases\n\t\t\tfor (DatabaseModel dbModel : dbModels.values()) {\n\t\t\t\tdbModel.writeToIndex(out);\n\t\t\t}\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\t/**\n\t * Register a custom {@link TypeConverter} for a given data (field) type.\n\t * This method is called at compile time by the annotation processor. In\n\t * order for the TypeConverter to be visible, it must be in a jar on the\n\t * client project's annotation factory classpath.\n\t *\n\t * @param converter\n\t * @return true if successful, false if converter was already registered for\n\t *         type\n\t */\n\tpublic boolean addConverter(ConverterModel converter) {\n\t\tif (converters.contains(converter))\n\t\t\treturn true;\n\t\tfor (String type : converter.getConvertibleTypes()) {\n\t\t\t// TODO what if already put the 1st type?\n\t\t\tif (typeMap.containsKey(type)\n\t\t\t\t\t&& !typeMap.get(type).equals(converter))\n\t\t\t\treturn false;\n\t\t\ttypeMap.put(type, converter);\n\t\t}\n\t\tconverters.add(converter);\n\t\tlogger.info(\"Added \" + converter.getQualifiedClassName());\n\t\treturn true;\n\t}\n\tpublic ConverterModel getConverterForType(String javaType) {\n\t\tConverterModel converter = typeMap.get(javaType);\n\t\tif (converter != null)\n\t\t\treturn converter;\n\t\tthrow new TypeNotSupportedException(\n\t\t\t\t\"Could not find converter for type \" + javaType);\n\t}\n\tpublic List<ConverterModel> getConverters() {\n\t\treturn converters;\n\t}\n"]], "pred": {"ppl": 2.1661760807037354, "ppl_lower": 2.408930540084839, "ppl/lowercase_ppl": -1.137418467863421, "ppl/zlib": 0.00041759234916534214, "Min_5.0% Prob": 6.879610239290724, "Min_10.0% Prob": 5.264516762658661, "Min_20.0% Prob": 3.491107412997414, "Min_30.0% Prob": 2.521356790186533, "Min_40.0% Prob": 1.923475509659731, "Min_50.0% Prob": 1.5453210028449762, "Min_60.0% Prob": 1.2894232905200922}}
{"hexsha": "c7c6f62e711082863ff9a09915a14edffd8ae5ef", "ext": "java", "lang": "Java", "content": "public class DataTable {\n\tprivate final String datatablePath, datatableName;\n\tprivate String dataReferenceIdentifier = \"#\";\n\n\tprivate String currentTestcase;\n\tprivate int currentIteration = 0;\n\n\t/**\n\t * Constructor to initialize the {@link DataTable} object\n\t * \n\t * @param datatablePath The path where the datatable is stored\n\t * @param datatableName The name of the datatable file\n\t */\n\tpublic DataTable(String datatablePath, String datatableName) {\n\t\tthis.datatablePath = datatablePath;\n\t\tthis.datatableName = datatableName;\n\t}\n\n\t/**\n\t * Function to set the data reference identifier character\n\t * \n\t * @param dataReferenceIdentifier The data reference identifier character\n\t */\n\tpublic void setDataReferenceIdentifier(String dataReferenceIdentifier) {\n\t\tif (dataReferenceIdentifier.length() != 1) {\n\t\t\tthrow new FrameworkException(\"The data reference identifier must be a single character!\");\n\t\t}\n\n\t\tthis.dataReferenceIdentifier = dataReferenceIdentifier;\n\t}\n\n\t/**\n\t * Function to set the variables required to uniquely identify the exact row of\n\t * data under consideration\n\t * \n\t * @param currentTestcase  The ID of the current test case\n\t * @param currentIteration The Iteration being executed currently\n\t */\n\tpublic void setCurrentRow(String currentTestcase, int currentIteration) {\n\t\tthis.currentTestcase = currentTestcase;\n\t\tthis.currentIteration = currentIteration;\n\t}\n\n\tprivate void checkPreRequisites() {\n\t\tif (currentTestcase == null) {\n\t\t\tthrow new FrameworkException(\"DataTable.currentTestCase is not set!\");\n\t\t}\n\t\tif (currentIteration == 0) {\n\t\t\tthrow new FrameworkException(\"DataTable.currentIteration is not set!\");\n\t\t}\n\t}\n\n\t/**\n\t * Function to return the test data value corresponding to the sheet name and\n\t * field name passed\n\t * \n\t * @param datasheetName The name of the sheet in which the data is present\n\t * @param fieldName     The name of the field whose value is required\n\t * @return The test data present in the field name specified\n\t * @see #putData(String, String, String)\n\t * @see #getExpectedResult(String)\n\t */\n\tpublic String getData(String datasheetName, String fieldName) {\n\t\tcheckPreRequisites();\n\n\t\tExcelDataAccess testDataAccess = new ExcelDataAccess(datatablePath, datatableName);\n\t\ttestDataAccess.setDatasheetName(datasheetName);\n\n\t\tint rowNum = testDataAccess.getRowNum(currentTestcase, 0, 1); // Start\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// at\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// skipping\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// header\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\tif (rowNum == -1) {\n\t\t\tthrow new FrameworkException(\"The test case \\\"\" + currentTestcase + \"\\\"\"\n\t\t\t\t\t+ \"is not found in the test data sheet \\\"\" + datasheetName + \"\\\"!\");\n\t\t}\n\t\trowNum = testDataAccess.getRowNum(Integer.toString(currentIteration), 1, rowNum);\n\t\tif (rowNum == -1) {\n\t\t\tthrow new FrameworkException(\"The iteration number \\\"\" + currentIteration + \"\\\"\" + \"of the test case \\\"\"\n\t\t\t\t\t+ currentTestcase + \"\\\"\" + \"is not found in the test data sheet \\\"\" + datasheetName + \"\\\"!\");\n\t\t}\n\n\t\tString dataValue = testDataAccess.getValue(rowNum, fieldName);\n\n\t\tif (dataValue.startsWith(dataReferenceIdentifier)) {\n\t\t\tdataValue = getCommonData(fieldName, dataValue);\n\t\t}\n\n\t\treturn dataValue;\n\t}\n\n\tprivate String getCommonData(String fieldName, String dataValue) {\n\t\tExcelDataAccess commonDataAccess = new ExcelDataAccess(datatablePath, \"Common Testdata\");\n\t\tcommonDataAccess.setDatasheetName(\"Common_Testdata\");\n\n\t\tString dataReferenceId = dataValue.split(dataReferenceIdentifier)[1];\n\n\t\tint rowNum = commonDataAccess.getRowNum(dataReferenceId, 0, 1); // Start\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// at\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// skipping\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// header\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\tif (rowNum == -1) {\n\t\t\tthrow new FrameworkException(\"The common test data row identified by \\\"\" + dataReferenceId + \"\\\"\"\n\t\t\t\t\t+ \"is not found in the common test data sheet!\");\n\t\t}\n\n\t\treturn commonDataAccess.getValue(rowNum, fieldName);\n\t}\n\n\t/**\n\t * Function to output intermediate data (output values) into the specified sheet\n\t * \n\t * @param datasheetName The name of the sheet into which the data is to be\n\t *                      written\n\t * @param fieldName     The name of the field into which the data is to be\n\t *                      written\n\t * @param dataValue     The value to be written into the field specified\n\t * @see #getData(String, String)\n\t */\n\tpublic void putData(String datasheetName, String fieldName, String dataValue) {\n\t\tcheckPreRequisites();\n\n\t\tExcelDataAccess testDataAccess = new ExcelDataAccess(datatablePath, datatableName);\n\t\ttestDataAccess.setDatasheetName(datasheetName);\n\n\t\tint rowNum = testDataAccess.getRowNum(currentTestcase, 0, 1); // Start\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// at\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// skipping\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// header\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\tif (rowNum == -1) {\n\t\t\tthrow new FrameworkException(\"The test case \\\"\" + currentTestcase + \"\\\"\"\n\t\t\t\t\t+ \"is not found in the test data sheet \\\"\" + datasheetName + \"\\\"!\");\n\t\t}\n\t\trowNum = testDataAccess.getRowNum(Integer.toString(currentIteration), 1, rowNum);\n\t\tif (rowNum == -1) {\n\t\t\tthrow new FrameworkException(\"The iteration number \\\"\" + currentIteration + \"\\\"\" + \"of the test case \\\"\"\n\t\t\t\t\t+ currentTestcase + \"\\\"\" + \"is not found in the test data sheet \\\"\" + datasheetName + \"\\\"!\");\n\t\t}\n\n\t\tsynchronized (DataTable.class) {\n\t\t\ttestDataAccess.setValue(rowNum, fieldName, dataValue);\n\t\t}\n\t}\n\n\t/**\n\t * Function to get the expected result corresponding to the field name passed\n\t * \n\t * @param fieldName The name of the field which contains the expected results\n\t * @return The expected result present in the field name specified\n\t * @see #getData(String, String)\n\t */\n\tpublic String getExpectedResult(String fieldName) {\n\t\tcheckPreRequisites();\n\n\t\tExcelDataAccess expectedResultsAccess = new ExcelDataAccess(datatablePath, datatableName);\n\t\texpectedResultsAccess.setDatasheetName(\"Parametrized_Checkpoints\");\n\n\t\tint rowNum = expectedResultsAccess.getRowNum(currentTestcase, 0, 1); // Start\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// at\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// skipping\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// header\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\tif (rowNum == -1) {\n\t\t\tthrow new FrameworkException(\"The test case \\\"\" + currentTestcase + \"\\\"\"\n\t\t\t\t\t+ \"is not found in the parametrized checkpoints sheet!\");\n\t\t}\n\t\trowNum = expectedResultsAccess.getRowNum(Integer.toString(currentIteration), 1, rowNum);\n\t\tif (rowNum == -1) {\n\t\t\tthrow new FrameworkException(\"The iteration number \\\"\" + currentIteration + \"\\\"\" + \"of the test case \\\"\"\n\t\t\t\t\t+ currentTestcase + \"\\\"\" + \"is not found in the parametrized checkpoints sheet!\");\n\t\t}\n\n\t\treturn expectedResultsAccess.getValue(rowNum, fieldName);\n\t}\n\n\t/**\n\t * Function to return the test data value corresponding to the sheet name and\n\t * field name passed\n\t * \n\t * @param datasheetName The name of the sheet in which the data is present\n\t * @param keys          The name of the fields whose values are required\n\t * @return The Map of Column Names with values\n\t */\n\tpublic Map<String, String> getData(String datasheetName, String[] keys) {\n\t\tcheckPreRequisites();\n\n\t\tExcelDataAccess testDataAccess = new ExcelDataAccess(datatablePath, datatableName);\n\t\ttestDataAccess.setDatasheetName(datasheetName);\n\n\t\tint rowNum = testDataAccess.getRowNum(currentTestcase, 0, 1); // Start\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// at\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// skipping\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// header\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\tif (rowNum == -1) {\n\t\t\tthrow new FrameworkException(\"The test case \\\"\" + currentTestcase + \"\\\"\"\n\t\t\t\t\t+ \"is not found in the test data sheet \\\"\" + datasheetName + \"\\\"!\");\n\t\t}\n\t\trowNum = testDataAccess.getRowNum(Integer.toString(currentIteration), 1, rowNum);\n\t\tif (rowNum == -1) {\n\t\t\tthrow new FrameworkException(\"The iteration number \\\"\" + currentIteration + \"\\\"\" + \"of the test case \\\"\"\n\t\t\t\t\t+ currentTestcase + \"\\\"\" + \"is not found in the test data sheet \\\"\" + datasheetName + \"\\\"!\");\n\t\t}\n\n\t\tMap<String, String> values = testDataAccess.getValuesForSpecificRow(keys, rowNum);\n\n\t\treturn values;\n\t}\n\n}", "item_id": 0, "repo": "ayosuva/Cognizant-Reusable-Automation-Framework-for-Testing", "file": "modularDriven-maven-testng-framework/src/test/java/com/cognizant/framework/DataTable.java", "last_update_at": "2022-02-17T14:29:29+00:00", "question_id": "c7c6f62e711082863ff9a09915a14edffd8ae5ef_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DataTable {\n\tprivate final String datatablePath, datatableName;\n\tprivate String dataReferenceIdentifier = \"#\";\n\tprivate String currentTestcase;\n\tprivate int currentIteration = 0;\n\t/**\n\t * Constructor to initialize the {@link DataTable} object\n\t * \n\t * @param datatablePath The path where the datatable is stored\n\t * @param datatableName The name of the datatable file\n\t */\n\tpublic DataTable(String datatablePath, String datatableName) {\n\t\tthis.datatablePath = datatablePath;\n\t\tthis.datatableName = datatableName;\n\t}\n\t/**\n\t * Function to set the data reference identifier character\n\t * \n\t * @param dataReferenceIdentifier The data reference identifier character\n\t */\n\tpublic void setDataReferenceIdentifier(String dataReferenceIdentifier) {\n\t\tif (dataReferenceIdentifier.length() != 1) {\n\t\t\tthrow new FrameworkException(\"The data reference identifier must be a single character!\");\n\t\t}\n\t\tthis.dataReferenceIdentifier = dataReferenceIdentifier;\n\t}\n\t/**\n\t * Function to set the variables required to uniquely identify the exact row of\n\t * data under consideration\n\t * \n\t * @param currentTestcase  The ID of the current test case\n\t * @param currentIteration The Iteration being executed currently\n\t */\n\tpublic void setCurrentRow(String currentTestcase, int currentIteration) {\n\t\tthis.currentTestcase = currentTestcase;\n\t\tthis.currentIteration = currentIteration;\n\t}\n\tprivate void checkPreRequisites() {\n\t\tif (currentTestcase == null) {\n\t\t\tthrow new FrameworkException(\"DataTable.currentTestCase is not set!\");\n\t\t}\n\t\tif (currentIteration == 0) {\n\t\t\tthrow new FrameworkException(\"DataTable.currentIteration is not set!\");\n\t\t}\n\t}\n\t/**\n\t * Function to return the test data value corresponding to the sheet name and\n\t * field name passed\n\t * \n\t * @param datasheetName The name of the sheet in which the data is present\n\t * @param fieldName     The name of the field whose value is required\n\t * @return The test data present in the field name specified\n\t * @see #putData(String, String, String)\n\t * @see #getExpectedResult(String)\n\t */\n\tpublic String getData(String datasheetName, String fieldName) {\n\t\tcheckPreRequisites();\n\t\tExcelDataAccess testDataAccess = new ExcelDataAccess(datatablePath, datatableName);\n\t\ttestDataAccess.setDatasheetName(datasheetName);\n\t\tint rowNum = testDataAccess.getRowNum(currentTestcase, 0, 1); // Start\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// at\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// skipping\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// header\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\tif (rowNum == -1) {\n\t\t\tthrow new FrameworkException(\"The test case \\\"\" + currentTestcase + \"\\\"\"\n\t\t\t\t\t+ \"is not found in the test data sheet \\\"\" + datasheetName + \"\\\"!\");\n\t\t}\n\t\trowNum = testDataAccess.getRowNum(Integer.toString(currentIteration), 1, rowNum);\n\t\tif (rowNum == -1) {\n\t\t\tthrow new FrameworkException(\"The iteration number \\\"\" + currentIteration + \"\\\"\" + \"of the test case \\\"\"\n\t\t\t\t\t+ currentTestcase + \"\\\"\" + \"is not found in the test data sheet \\\"\" + datasheetName + \"\\\"!\");\n\t\t}\n\t\tString dataValue = testDataAccess.getValue(rowNum, fieldName);\n\t\tif (dataValue.startsWith(dataReferenceIdentifier)) {\n\t\t\tdataValue = getCommonData(fieldName, dataValue);\n\t\t}\n\t\treturn dataValue;\n\t}\n\tprivate String getCommonData(String fieldName, String dataValue) {\n\t\tExcelDataAccess commonDataAccess = new ExcelDataAccess(datatablePath, \"Common Testdata\");\n\t\tcommonDataAccess.setDatasheetName(\"Common_Testdata\");\n\t\tString dataReferenceId = dataValue.split(dataReferenceIdentifier)[1];\n\t\tint rowNum = commonDataAccess.getRowNum(dataReferenceId, 0, 1); // Start\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// at\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// skipping\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// header\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\tif (rowNum == -1) {\n\t\t\tthrow new FrameworkException(\"The common test data row identified by \\\"\" + dataReferenceId + \"\\\"\"\n\t\t\t\t\t+ \"is not found in the common test data sheet!\");\n\t\t}\n\t\treturn commonDataAccess.getValue(rowNum, fieldName);\n\t}\n\t/**\n\t * Function to output intermediate data (output values) into the specified sheet\n\t * \n\t * @param datasheetName The name of the sheet into which the data is to be\n\t *                      written\n\t * @param fieldName     The name of the field into which the data is to be\n\t *                      written\n\t * @param dataValue     The value to be written into the field specified\n\t * @see #getData(String, String)\n\t */\n\tpublic void putData(String datasheetName, String fieldName, String dataValue) {\n\t\tcheckPreRequisites();\n\t\tExcelDataAccess testDataAccess = new ExcelDataAccess(datatablePath, datatableName);\n\t\ttestDataAccess.setDatasheetName(datasheetName);\n\t\tint rowNum = testDataAccess.getRowNum(currentTestcase, 0, 1); // Start\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// at\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// skipping\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// header\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\tif (rowNum == -1) {\n\t\t\tthrow new FrameworkException(\"The test case \\\"\" + currentTestcase + \"\\\"\"\n\t\t\t\t\t+ \"is not found in the test data sheet \\\"\" + datasheetName + \"\\\"!\");\n\t\t}\n\t\trowNum = testDataAccess.getRowNum(Integer.toString(currentIteration), 1, rowNum);\n\t\tif (rowNum == -1) {\n\t\t\tthrow new FrameworkException(\"The iteration number \\\"\" + currentIteration + \"\\\"\" + \"of the test case \\\"\"\n\t\t\t\t\t+ currentTestcase + \"\\\"\" + \"is not found in the test data sheet \\\"\" + datasheetName + \"\\\"!\");\n\t\t}\n\t\tsynchronized (DataTable.class) {\n\t\t\ttestDataAccess.setValue(rowNum, fieldName, dataValue);\n\t\t}\n\t}\n\t/**\n\t * Function to get the expected result corresponding to the field name passed\n\t * \n\t * @param fieldName The name of the field which contains the expected results\n\t * @return The expected result present in the field name specified\n\t * @see #getData(String, String)\n\t */\n\tpublic String getExpectedResult(String fieldName) {\n\t\tcheckPreRequisites();\n\t\tExcelDataAccess expectedResultsAccess = new ExcelDataAccess(datatablePath, datatableName);\n\t\texpectedResultsAccess.setDatasheetName(\"Parametrized_Checkpoints\");\n\t\tint rowNum = expectedResultsAccess.getRowNum(currentTestcase, 0, 1); // Start\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// at\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// skipping\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// header\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\tif (rowNum == -1) {\n\t\t\tthrow new FrameworkException(\"The test case \\\"\" + currentTestcase + \"\\\"\"\n\t\t\t\t\t+ \"is not found in the parametrized checkpoints sheet!\");\n\t\t}\n\t\trowNum = expectedResultsAccess.getRowNum(Integer.toString(currentIteration), 1, rowNum);\n\t\tif (rowNum == -1) {\n\t\t\tthrow new FrameworkException(\"The iteration number \\\"\" + currentIteration + \"\\\"\" + \"of the test case \\\"\"\n\t\t\t\t\t+ currentTestcase + \"\\\"\" + \"is not found in the parametrized checkpoints sheet!\");\n\t\t}\n\t\treturn expectedResultsAccess.getValue(rowNum, fieldName);\n\t}\n\t/**\n\t * Function to return the test data value corresponding to the sheet name and\n\t * field name passed\n\t * \n\t * @param datasheetName The name of the sheet in which the data is present\n\t * @param keys          The name of the fields whose values are required\n\t * @return The Map of Column Names with values\n\t */\n\tpublic Map<String, String> getData(String datasheetName, String[] keys) {\n\t\tcheckPreRequisites();\n\t\tExcelDataAccess testDataAccess = new ExcelDataAccess(datatablePath, datatableName);\n\t\ttestDataAccess.setDatasheetName(datasheetName);\n\t\tint rowNum = testDataAccess.getRowNum(currentTestcase, 0, 1); // Start\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// at\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// skipping\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// header\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// row\n\t\tif (rowNum == -1) {\n\t\t\tthrow new FrameworkException(\"The test case \\\"\" + currentTestcase + \"\\\"\"\n\t\t\t\t\t+ \"is not found in the test data sheet \\\"\" + datasheetName + \"\\\"!\");\n\t\t}\n\t\trowNum = testDataAccess.getRowNum(Integer.toString(currentIteration), 1, rowNum);\n\t\tif (rowNum == -1) {\n\t\t\tthrow new FrameworkException(\"The iteration number \\\"\" + currentIteration + \"\\\"\" + \"of the test case \\\"\"\n\t\t\t\t\t+ currentTestcase + \"\\\"\" + \"is not found in the test data sheet \\\"\" + datasheetName + \"\\\"!\");\n\t\t}\n\t\tMap<String, String> values = testDataAccess.getValuesForSpecificRow(keys, rowNum);\n\t\treturn values;\n\t}\n"]], "pred": {"ppl": 1.7373034954071045, "ppl_lower": 1.7856873273849487, "ppl/lowercase_ppl": -1.049732938475398, "ppl/zlib": 0.00037935040926674677, "Min_5.0% Prob": 5.560626955593333, "Min_10.0% Prob": 4.026996273620456, "Min_20.0% Prob": 2.5661195127987395, "Min_30.0% Prob": 1.8125609276828423, "Min_40.0% Prob": 1.3750896585927617, "Min_50.0% Prob": 1.1044959866254063, "Min_60.0% Prob": 0.9215573570026361}}
{"hexsha": "a5f95092cb09f26d3e2eb488bd93eba068b2f130", "ext": "java", "lang": "Java", "content": "public class KEPRuleItem implements TextRulerRuleItem {\n\n  private boolean isStarWildCard = false;\n\n  private boolean isReluctant = false;\n\n  private Type type;\n\n  private TextRulerAnnotation annotation;\n\n  private int min = 1;\n\n  private int max = 1;\n\n  private List<List<KEPRuleItemCondition>> conditions = new ArrayList<List<KEPRuleItemCondition>>();\n\n  public KEPRuleItem(KEPRuleItem copyFrom) {\n    super();\n    this.annotation = copyFrom.annotation;\n    this.isStarWildCard = copyFrom.isStarWildCard;\n    this.type = copyFrom.type;\n    this.conditions = new ArrayList<List<KEPRuleItemCondition>>();\n    for (List<KEPRuleItemCondition> cList : copyFrom.conditions) {\n      this.conditions.add(new ArrayList<KEPRuleItemCondition>(cList));\n    }\n    this.isReluctant = copyFrom.isReluctant;\n    this.min = copyFrom.min;\n    this.max = copyFrom.max;\n  }\n\n  public KEPRuleItem(Type type) {\n    super();\n    this.type = type;\n  }\n\n  public KEPRuleItem(TextRulerAnnotation a) {\n    super();\n    this.type = a.getType();\n    this.annotation = a;\n  }\n\n  public KEPRuleItem(AnnotationFS afs) {\n    super();\n    this.annotation = new TextRulerAnnotation(afs);\n    this.type = this.annotation.getType();\n  }\n\n  public KEPRuleItem(Type type, String regExpString) {\n    super();\n    this.type = type;\n    List<KEPRuleItemCondition> list = new ArrayList<KEPRuleItemCondition>();\n    list.add(new KEPRuleItemCondition(regExpString));\n    this.conditions.add(list);\n  }\n\n  public KEPRuleItem() {\n    this.type = null;\n  }\n\n  public KEPRuleItem copy() {\n    return new KEPRuleItem(this);\n  }\n\n  public String getStringForRuleString(TextRulerRule rule, MLRuleItemType type,\n          int numberInPattern, int patternSize, int numberInRule, int ruleSize, int slotIndex) {\n\n    String mark = \"\";\n    KEPRule kepRule = (KEPRule) rule;\n    boolean isMarkingItem = type == MLRuleItemType.FILLER && numberInPattern == 0;\n    String cStr = \"\";\n\n    String anchor = (this.type == null ? \"ANY\" : this.type.getShortName())\n            + (isStarWildCard ? \"*\" : \"\")\n            + ((min == 1 && max == 1) ? \"\" : (\"[\" + min + \",\" + max + \"]\"))\n            + (isReluctant ? \"?\" : \"\") + ((isMarkingItem || !this.conditions.isEmpty()) ? \"{\" : \"\");\n\n    if (!this.conditions.isEmpty() && !this.conditions.get(0).isEmpty()) {\n      for (List<KEPRuleItemCondition> cList : this.conditions) {\n        if (cList.size() == 1) {\n          cStr += cList.get(0) + \", \";\n        } else {\n          cStr += \"OR(\";\n          for (KEPRuleItemCondition condition : cList) {\n            cStr += condition + \", \";\n          }\n          cStr = cStr.substring(0, cStr.lastIndexOf(\",\"));\n          cStr += \"), \";\n        }\n      }\n      cStr = cStr.substring(0, cStr.lastIndexOf(\",\"));\n    }\n\n    if (isMarkingItem) {\n      if (kepRule.isCorrectionRule())\n        mark += \"->UNMARK(\" + kepRule.getMarkName(slotIndex);\n      else\n        mark += \"->MARKONCE(\" + kepRule.getMarkName(slotIndex);\n      if (patternSize > 1)\n        mark += \", \" + (numberInRule + 1) + \", \" + (numberInRule + patternSize);\n      mark += \")\";\n    }\n    return anchor + cStr + mark + ((isMarkingItem || !this.conditions.isEmpty()) ? \"}\" : \"\");\n  }\n\n  @Override\n  public String toString() {\n    return getStringForRuleString(null, null, 0, 0, 0, 0, 0);\n  }\n\n  public boolean isStarWildCard() {\n    return isStarWildCard;\n  }\n\n  public KEPRuleItem setStarWildCard(boolean isStarWildCard) {\n    this.isStarWildCard = isStarWildCard;\n    if (isStarWildCard) {\n      this.min = 1;\n      this.max = 1;\n    }\n    return this;\n  }\n\n  public Type getType() {\n    return type;\n  }\n\n  public void setType(Type type) {\n    this.type = type;\n  }\n\n  public boolean equals(TextRulerRuleItem o) {\n    return o.toString().equals(this.toString());\n  }\n\n  public int getBegin() {\n    return this.annotation.getBegin();\n  }\n\n  public int getEnd() {\n    return this.annotation.getEnd();\n  }\n\n  public int getMin() {\n    return min;\n  }\n\n  public KEPRuleItem setMin(int min) {\n    this.min = min;\n    if (min > this.max)\n      this.max = min;\n    isStarWildCard = false;\n    return this;\n  }\n\n  public int getMax() {\n    return max;\n  }\n\n  public KEPRuleItem setMax(int max) {\n    this.max = max;\n    if (max < this.min)\n      this.min = max;\n    isStarWildCard = false;\n    return this;\n  }\n\n  public boolean isReluctant() {\n    return isReluctant;\n  }\n\n  public KEPRuleItem setReluctant(boolean isReluctant) {\n    this.isReluctant = isReluctant;\n    return this;\n  }\n\n  public KEPRuleItem addAndCondition(KEPRuleItemCondition condition) {\n    List<KEPRuleItemCondition> list = new ArrayList<KEPRuleItemCondition>();\n    list.add(condition);\n    this.conditions.add(list);\n    return this;\n  }\n\n  public List<List<KEPRuleItemCondition>> getConditions() {\n    return this.conditions;\n  }\n\n  public void setAnnotation(AnnotationFS afs) {\n    this.annotation = new TextRulerAnnotation(afs);\n    this.type = this.annotation.getType();\n  }\n\n  public KEPRuleItem setConditions(List<List<KEPRuleItemCondition>> conditions) {\n    this.conditions = conditions;\n    return this;\n  }\n\n  public KEPRuleItem addConditions(List<KEPRuleItemCondition> toMerge) {\n    this.conditions.add(toMerge);\n    return this;\n  }\n\n  public boolean containsAndCondition(Type type2) {\n    for (List<KEPRuleItemCondition> list : this.conditions) {\n      if (list.size() == 1)\n        for (KEPRuleItemCondition c : list) {\n          if (c.equals(type2))\n            return true;\n        }\n    }\n    return false;\n  }\n}", "item_id": 0, "repo": "apache/uima-ruta", "file": "ruta-ep-textruler/src/main/java/org/apache/uima/ruta/textruler/learner/kep/KEPRuleItem.java", "last_update_at": "2022-02-09T06:46:05+00:00", "question_id": "a5f95092cb09f26d3e2eb488bd93eba068b2f130_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class KEPRuleItem implements TextRulerRuleItem {\n  private boolean isStarWildCard = false;\n  private boolean isReluctant = false;\n  private Type type;\n  private TextRulerAnnotation annotation;\n  private int min = 1;\n  private int max = 1;\n  private List<List<KEPRuleItemCondition>> conditions = new ArrayList<List<KEPRuleItemCondition>>();\n  public KEPRuleItem(KEPRuleItem copyFrom) {\n    super();\n    this.annotation = copyFrom.annotation;\n    this.isStarWildCard = copyFrom.isStarWildCard;\n    this.type = copyFrom.type;\n    this.conditions = new ArrayList<List<KEPRuleItemCondition>>();\n    for (List<KEPRuleItemCondition> cList : copyFrom.conditions) {\n      this.conditions.add(new ArrayList<KEPRuleItemCondition>(cList));\n    }\n    this.isReluctant = copyFrom.isReluctant;\n    this.min = copyFrom.min;\n    this.max = copyFrom.max;\n  }\n  public KEPRuleItem(Type type) {\n    super();\n    this.type = type;\n  }\n  public KEPRuleItem(TextRulerAnnotation a) {\n    super();\n    this.type = a.getType();\n    this.annotation = a;\n  }\n  public KEPRuleItem(AnnotationFS afs) {\n    super();\n    this.annotation = new TextRulerAnnotation(afs);\n    this.type = this.annotation.getType();\n  }\n  public KEPRuleItem(Type type, String regExpString) {\n    super();\n    this.type = type;\n    List<KEPRuleItemCondition> list = new ArrayList<KEPRuleItemCondition>();\n    list.add(new KEPRuleItemCondition(regExpString));\n    this.conditions.add(list);\n  }\n  public KEPRuleItem() {\n    this.type = null;\n  }\n  public KEPRuleItem copy() {\n    return new KEPRuleItem(this);\n  }\n  public String getStringForRuleString(TextRulerRule rule, MLRuleItemType type,\n          int numberInPattern, int patternSize, int numberInRule, int ruleSize, int slotIndex) {\n    String mark = \"\";\n    KEPRule kepRule = (KEPRule) rule;\n    boolean isMarkingItem = type == MLRuleItemType.FILLER && numberInPattern == 0;\n    String cStr = \"\";\n    String anchor = (this.type == null ? \"ANY\" : this.type.getShortName())\n            + (isStarWildCard ? \"*\" : \"\")\n            + ((min == 1 && max == 1) ? \"\" : (\"[\" + min + \",\" + max + \"]\"))\n            + (isReluctant ? \"?\" : \"\") + ((isMarkingItem || !this.conditions.isEmpty()) ? \"{\" : \"\");\n    if (!this.conditions.isEmpty() && !this.conditions.get(0).isEmpty()) {\n      for (List<KEPRuleItemCondition> cList : this.conditions) {\n        if (cList.size() == 1) {\n          cStr += cList.get(0) + \", \";\n        } else {\n          cStr += \"OR(\";\n          for (KEPRuleItemCondition condition : cList) {\n            cStr += condition + \", \";\n          }\n          cStr = cStr.substring(0, cStr.lastIndexOf(\",\"));\n          cStr += \"), \";\n        }\n      }\n      cStr = cStr.substring(0, cStr.lastIndexOf(\",\"));\n    }\n    if (isMarkingItem) {\n      if (kepRule.isCorrectionRule())\n        mark += \"->UNMARK(\" + kepRule.getMarkName(slotIndex);\n      else\n        mark += \"->MARKONCE(\" + kepRule.getMarkName(slotIndex);\n      if (patternSize > 1)\n        mark += \", \" + (numberInRule + 1) + \", \" + (numberInRule + patternSize);\n      mark += \")\";\n    }\n    return anchor + cStr + mark + ((isMarkingItem || !this.conditions.isEmpty()) ? \"}\" : \"\");\n  }\n  @Override\n  public String toString() {\n    return getStringForRuleString(null, null, 0, 0, 0, 0, 0);\n  }\n  public boolean isStarWildCard() {\n    return isStarWildCard;\n  }\n  public KEPRuleItem setStarWildCard(boolean isStarWildCard) {\n    this.isStarWildCard = isStarWildCard;\n    if (isStarWildCard) {\n      this.min = 1;\n      this.max = 1;\n    }\n    return this;\n  }\n  public Type getType() {\n    return type;\n  }\n  public void setType(Type type) {\n    this.type = type;\n  }\n  public boolean equals(TextRulerRuleItem o) {\n    return o.toString().equals(this.toString());\n  }\n  public int getBegin() {\n    return this.annotation.getBegin();\n  }\n  public int getEnd() {\n    return this.annotation.getEnd();\n  }\n  public int getMin() {\n    return min;\n  }\n  public KEPRuleItem setMin(int min) {\n    this.min = min;\n    if (min > this.max)\n      this.max = min;\n    isStarWildCard = false;\n    return this;\n  }\n  public int getMax() {\n    return max;\n  }\n  public KEPRuleItem setMax(int max) {\n    this.max = max;\n    if (max < this.min)\n      this.min = max;\n    isStarWildCard = false;\n    return this;\n  }\n  public boolean isReluctant() {\n    return isReluctant;\n  }\n  public KEPRuleItem setReluctant(boolean isReluctant) {\n    this.isReluctant = isReluctant;\n    return this;\n  }\n  public KEPRuleItem addAndCondition(KEPRuleItemCondition condition) {\n    List<KEPRuleItemCondition> list = new ArrayList<KEPRuleItemCondition>();\n    list.add(condition);\n    this.conditions.add(list);\n    return this;\n  }\n  public List<List<KEPRuleItemCondition>> getConditions() {\n    return this.conditions;\n  }\n  public void setAnnotation(AnnotationFS afs) {\n    this.annotation = new TextRulerAnnotation(afs);\n    this.type = this.annotation.getType();\n  }\n  public KEPRuleItem setConditions(List<List<KEPRuleItemCondition>> conditions) {\n    this.conditions = conditions;\n    return this;\n  }\n  public KEPRuleItem addConditions(List<KEPRuleItemCondition> toMerge) {\n    this.conditions.add(toMerge);\n    return this;\n  }\n  public boolean containsAndCondition(Type type2) {\n    for (List<KEPRuleItemCondition> list : this.conditions) {\n      if (list.size() == 1)\n        for (KEPRuleItemCondition c : list) {\n          if (c.equals(type2))\n            return true;\n        }\n    }\n    return false;\n  }\n"]], "pred": {"ppl": 1.8590261936187744, "ppl_lower": 2.0193684101104736, "ppl/lowercase_ppl": -1.1334273397575407, "ppl/zlib": 0.0004751362442958916, "Min_5.0% Prob": 5.648750216353173, "Min_10.0% Prob": 4.197502082469416, "Min_20.0% Prob": 2.78208357387898, "Min_30.0% Prob": 2.005078310816506, "Min_40.0% Prob": 1.5365977416265857, "Min_50.0% Prob": 1.2384828559456507, "Min_60.0% Prob": 1.03411322381867}}
{"hexsha": "2fe24cd32a37fb3e0c0dde69995c5bd1bcd20401", "ext": "java", "lang": "Java", "content": "public class MarkDown14_40 {\n  public static org.hl7.fhir.r4.model.MarkdownType convertMarkdown(org.hl7.fhir.dstu2016may.model.MarkdownType src) throws FHIRException {\n    org.hl7.fhir.r4.model.MarkdownType tgt = new org.hl7.fhir.r4.model.MarkdownType();\n    if (src.hasValue()) tgt.setValue(src.getValue());\n    ConversionContext14_40.INSTANCE.getVersionConvertor_14_40().copyElement(src, tgt);\n    return tgt;\n  }\n\n  public static org.hl7.fhir.dstu2016may.model.MarkdownType convertMarkdown(org.hl7.fhir.r4.model.MarkdownType src) throws FHIRException {\n    org.hl7.fhir.dstu2016may.model.MarkdownType tgt = new org.hl7.fhir.dstu2016may.model.MarkdownType();\n    if (src.hasValue()) tgt.setValue(src.getValue());\n    ConversionContext14_40.INSTANCE.getVersionConvertor_14_40().copyElement(src, tgt);\n    return tgt;\n  }\n}", "item_id": 0, "repo": "LouisRolland78/org.hl7.fhir.core", "file": "org.hl7.fhir.convertors/src/main/java/org/hl7/fhir/convertors/conv14_40/datatypes14_40/primitivetypes14_40/MarkDown14_40.java", "last_update_at": "2022-03-23T15:52:06+00:00", "question_id": "2fe24cd32a37fb3e0c0dde69995c5bd1bcd20401_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MarkDown14_40 {\n  public static org.hl7.fhir.r4.model.MarkdownType convertMarkdown(org.hl7.fhir.dstu2016may.model.MarkdownType src) throws FHIRException {\n    org.hl7.fhir.r4.model.MarkdownType tgt = new org.hl7.fhir.r4.model.MarkdownType();\n    if (src.hasValue()) tgt.setValue(src.getValue());\n    ConversionContext14_40.INSTANCE.getVersionConvertor_14_40().copyElement(src, tgt);\n    return tgt;\n  }\n  public static org.hl7.fhir.dstu2016may.model.MarkdownType convertMarkdown(org.hl7.fhir.r4.model.MarkdownType src) throws FHIRException {\n    org.hl7.fhir.dstu2016may.model.MarkdownType tgt = new org.hl7.fhir.dstu2016may.model.MarkdownType();\n    if (src.hasValue()) tgt.setValue(src.getValue());\n    ConversionContext14_40.INSTANCE.getVersionConvertor_14_40().copyElement(src, tgt);\n    return tgt;\n  }\n"]], "pred": {"ppl": 1.2244524955749512, "ppl_lower": 1.53364098072052, "ppl/lowercase_ppl": -2.111889997179362, "ppl/zlib": 0.0007699384095071343, "Min_5.0% Prob": 4.058931536972523, "Min_10.0% Prob": 2.063283816092845, "Min_20.0% Prob": 1.0182599088528068, "Min_30.0% Prob": 0.675591657982043, "Min_40.0% Prob": 0.5092406429635116, "Min_50.0% Prob": 0.40618866280536686, "Min_60.0% Prob": 0.33782284289541975}}
{"hexsha": "09d5b3e0819fc3fb245e2e3ec06662e5e99fb02a", "ext": "java", "lang": "Java", "content": "public class AudioPlayer02 extends JFrame {\n   private static final long serialVersionUID = 1L;\n   \n   AudioFormat audioFormat;\n   AudioInputStream audioInputStream;\n   SourceDataLine sourceDataLine;\n   boolean stopPlayback = false;\n   boolean terminatePlayback = false;\n   final JButton stopBtn = new JButton (\"Stop\");\n   final JButton resumeBtn = new JButton (\"Resume\");\n   final JButton playBtn = new JButton (\"Play\");\n   final JTextField textField = new JTextField (\"A.wav\");\n\n   public static void main (String args[]) {\n      new AudioPlayer02();\n   }// end main\n\n   // -------------------------------------------//\n\n   public AudioPlayer02() {// constructor\n\n      stopBtn.setEnabled (false);\n      resumeBtn.setEnabled (false);\n      playBtn.setEnabled (true);\n\n      // Instantiate and register action listeners\n      // on the Play and Stop buttons.\n      playBtn.addActionListener (new ActionListener() {\n         public void actionPerformed (ActionEvent e) {\n            stopBtn.setEnabled (true);\n            resumeBtn.setEnabled (false);\n            playBtn.setEnabled (false);\n            playAudio();// Play the file\n         }// end actionPerformed\n      }// end ActionListener\n         );// end addActionListener()\n\n      stopBtn.addActionListener (new ActionListener() {\n         public void actionPerformed (ActionEvent e) {\n            // Terminate playback before EOF\n            stopPlayback = true;\n            resumeBtn.setEnabled (true);\n         }// end actionPerformed\n      }// end ActionListener\n         );// end addActionListener()\n\n      resumeBtn.addActionListener (new ActionListener() {\n         public void actionPerformed (ActionEvent e) {\n            stopPlayback = false;\n            resumeBtn.setEnabled (false);\n         }// end actionPerformed\n      }// end ActionListener\n         );// end addActionListener()\n\n      getContentPane().add (playBtn, \"West\");\n      getContentPane().add (stopBtn, \"East\");\n      getContentPane().add (resumeBtn);\n      getContentPane().add (textField, \"North\");\n\n      setDefaultCloseOperation (EXIT_ON_CLOSE);\n      setSize (250, 70);\n      setVisible (true);\n   }// end constructor\n\n   // -------------------------------------------//\n\n   // This method plays back audio data from an\n   // audio file whose name is specified in the\n   // text field.\n   private void playAudio() {\n      try {\n         File soundFile = new File (textField.getText());\n         audioInputStream = AudioSystem.getAudioInputStream (soundFile);\n         audioFormat = audioInputStream.getFormat();\n         System.out.println (audioFormat);\n\n         DataLine.Info dataLineInfo =\n            new DataLine.Info (SourceDataLine.class, audioFormat);\n\n         sourceDataLine = (SourceDataLine)AudioSystem.getLine (dataLineInfo);\n\n         // Create a thread to play back the data and\n         // start it running. It will run until the\n         // end of file, or the Stop button is\n         // clicked, whichever occurs first.\n         // Because of the data buffers involved,\n         // there will normally be a delay between\n         // the click on the Stop button and the\n         // actual termination of playback.\n         new PlayThread().start();\n      }\n      catch (Exception e) {\n         e.printStackTrace();\n         System.exit (0);\n      }// end catch\n   }// end playAudio\n\n   // =============================================//\n   // Inner class to play back the data from the\n   // audio file.\n   class PlayThread extends Thread {\n      int bufferSize = 1024;\n      byte tempBuffer[] = new byte[bufferSize];\n\n      public void run() {\n         // int ii = 0;\n         setPriority (MAX_PRIORITY);\n         try {\n            sourceDataLine.open (audioFormat, bufferSize);\n            sourceDataLine.start();\n\n            int cnt;\n            // Keep looping until the input read method\n            // returns -1 for empty stream or the\n            // user clicks the Stop button causing\n            // stopPlayback to switch from false to\n            // true.\n            while ((cnt =\n               audioInputStream.read (tempBuffer, 0, tempBuffer.length)) != -1\n            && terminatePlayback == false) {\n               if (cnt > 0) {\n                  // Write data to the internal buffer of\n                  // the data line where it will be\n                  // delivered to the speaker.\n                  while (stopPlayback) {\n                     try {\n                        sleep (10);\n                        // System.out.println(ii++);\n                     }\n                     catch (Exception eee) {\n                     }\n                  }\n                  sourceDataLine.write (tempBuffer, 0, cnt);\n               }// end if\n            }// end while\n            // Block and wait for internal buffer of the\n            // data line to empty.\n            sourceDataLine.drain();\n            sourceDataLine.close();\n\n            // Prepare to playback another file\n            stopBtn.setEnabled (false);\n            playBtn.setEnabled (true);\n            stopPlayback = false;\n         }\n         catch (Exception e) {\n            e.printStackTrace();\n            System.exit (0);\n         }// end catch\n      }// end run\n   }// end inner class PlayThread\n   // ===================================//\n\n}", "item_id": 0, "repo": "dannyhx/artisynth_core", "file": "src/artisynth/core/util/AudioPlayer02.java", "last_update_at": "2022-02-08T15:02:38+00:00", "question_id": "09d5b3e0819fc3fb245e2e3ec06662e5e99fb02a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AudioPlayer02 extends JFrame {\n   private static final long serialVersionUID = 1L;\n   AudioFormat audioFormat;\n   AudioInputStream audioInputStream;\n   SourceDataLine sourceDataLine;\n   boolean stopPlayback = false;\n   boolean terminatePlayback = false;\n   final JButton stopBtn = new JButton (\"Stop\");\n   final JButton resumeBtn = new JButton (\"Resume\");\n   final JButton playBtn = new JButton (\"Play\");\n   final JTextField textField = new JTextField (\"A.wav\");\n   public static void main (String args[]) {\n      new AudioPlayer02();\n   }// end main\n   // -------------------------------------------//\n   public AudioPlayer02() {// constructor\n      stopBtn.setEnabled (false);\n      resumeBtn.setEnabled (false);\n      playBtn.setEnabled (true);\n      // Instantiate and register action listeners\n      // on the Play and Stop buttons.\n      playBtn.addActionListener (new ActionListener() {\n         public void actionPerformed (ActionEvent e) {\n            stopBtn.setEnabled (true);\n            resumeBtn.setEnabled (false);\n            playBtn.setEnabled (false);\n            playAudio();// Play the file\n         }// end actionPerformed\n      }// end ActionListener\n         );// end addActionListener()\n      stopBtn.addActionListener (new ActionListener() {\n         public void actionPerformed (ActionEvent e) {\n            // Terminate playback before EOF\n            stopPlayback = true;\n            resumeBtn.setEnabled (true);\n         }// end actionPerformed\n      }// end ActionListener\n         );// end addActionListener()\n      resumeBtn.addActionListener (new ActionListener() {\n         public void actionPerformed (ActionEvent e) {\n            stopPlayback = false;\n            resumeBtn.setEnabled (false);\n         }// end actionPerformed\n      }// end ActionListener\n         );// end addActionListener()\n      getContentPane().add (playBtn, \"West\");\n      getContentPane().add (stopBtn, \"East\");\n      getContentPane().add (resumeBtn);\n      getContentPane().add (textField, \"North\");\n      setDefaultCloseOperation (EXIT_ON_CLOSE);\n      setSize (250, 70);\n      setVisible (true);\n   }// end constructor\n   // -------------------------------------------//\n   // This method plays back audio data from an\n   // audio file whose name is specified in the\n   // text field.\n   private void playAudio() {\n      try {\n         File soundFile = new File (textField.getText());\n         audioInputStream = AudioSystem.getAudioInputStream (soundFile);\n         audioFormat = audioInputStream.getFormat();\n         System.out.println (audioFormat);\n         DataLine.Info dataLineInfo =\n            new DataLine.Info (SourceDataLine.class, audioFormat);\n         sourceDataLine = (SourceDataLine)AudioSystem.getLine (dataLineInfo);\n         // Create a thread to play back the data and\n         // start it running. It will run until the\n         // end of file, or the Stop button is\n         // clicked, whichever occurs first.\n         // Because of the data buffers involved,\n         // there will normally be a delay between\n         // the click on the Stop button and the\n         // actual termination of playback.\n         new PlayThread().start();\n      }\n      catch (Exception e) {\n         e.printStackTrace();\n         System.exit (0);\n      }// end catch\n   }// end playAudio\n   // =============================================//\n   // Inner class to play back the data from the\n   // audio file.\n   class PlayThread extends Thread {\n      int bufferSize = 1024;\n      byte tempBuffer[] = new byte[bufferSize];\n      public void run() {\n         // int ii = 0;\n         setPriority (MAX_PRIORITY);\n         try {\n            sourceDataLine.open (audioFormat, bufferSize);\n            sourceDataLine.start();\n            int cnt;\n            // Keep looping until the input read method\n            // returns -1 for empty stream or the\n            // user clicks the Stop button causing\n            // stopPlayback to switch from false to\n            // true.\n            while ((cnt =\n               audioInputStream.read (tempBuffer, 0, tempBuffer.length)) != -1\n            && terminatePlayback == false) {\n               if (cnt > 0) {\n                  // Write data to the internal buffer of\n                  // the data line where it will be\n                  // delivered to the speaker.\n                  while (stopPlayback) {\n                     try {\n                        sleep (10);\n                        // System.out.println(ii++);\n                     }\n                     catch (Exception eee) {\n                     }\n                  }\n                  sourceDataLine.write (tempBuffer, 0, cnt);\n               }// end if\n            }// end while\n            // Block and wait for internal buffer of the\n            // data line to empty.\n            sourceDataLine.drain();\n            sourceDataLine.close();\n            // Prepare to playback another file\n            stopBtn.setEnabled (false);\n            playBtn.setEnabled (true);\n            stopPlayback = false;\n         }\n         catch (Exception e) {\n            e.printStackTrace();\n            System.exit (0);\n         }// end catch\n      }// end run\n   }// end inner class PlayThread\n   // ===================================//\n"]], "pred": {"ppl": 1.9950833320617676, "ppl_lower": 2.0121943950653076, "ppl/lowercase_ppl": -1.0123645878098495, "ppl/zlib": 0.00044445676957946713, "Min_5.0% Prob": 5.856876242394541, "Min_10.0% Prob": 4.470738971934599, "Min_20.0% Prob": 3.034240371748513, "Min_30.0% Prob": 2.2020004637101116, "Min_40.0% Prob": 1.698522886356981, "Min_50.0% Prob": 1.3750291783399078, "Min_60.0% Prob": 1.1504772030801602}}
{"hexsha": "c84ca92eed0925a17cc582d53b4cea88c352b903", "ext": "java", "lang": "Java", "content": "public class StatusFilterViewHolder extends CheckboxFilterViewHolder<Integer, StatusGeocacheFilter> {\n\n    private static final int OWN_FOUND = 1;\n    private static final int DISABLED = 2;\n    private static final int ARCHIVED = 3;\n\n    public StatusFilterViewHolder() {\n        super(new ValueGroupFilterAccessor<Integer, StatusGeocacheFilter>()\n            .setSelectableValues(new Integer[]{OWN_FOUND, DISABLED, ARCHIVED})\n            .setValueGetter(StatusFilterViewHolder::getFilterValues)\n            .setValueSetter(StatusFilterViewHolder::setFilterValues)\n            .setValueDisplayTextGetter(s -> LocalizationUtils.getString(s == ARCHIVED ? R.string.map_showc_archived : (s == OWN_FOUND ? R.string.map_showc_ownfound : R.string.map_showc_disabled)))\n            .setValueDrawableGetter(s -> s == ARCHIVED ? R.drawable.ic_menu_archived : (s == OWN_FOUND ? R.drawable.ic_menu_myplaces : R.drawable.ic_menu_disabled))\n            .setGeocacheValueGetter((f, c) -> getGeocacheValues(c)));\n    }\n\n    @NotNull\n    private static Set<Integer> getGeocacheValues(final Geocache c) {\n        final Set<Integer> set = new HashSet<>();\n        if (c.isArchived()) {\n            set.add(ARCHIVED);\n        }\n        if (c.isDisabled()) {\n            set.add(DISABLED);\n        }\n        if (c.isFound() || c.getOwnerUserId().equals(Settings.getUserName())) {\n            set.add(OWN_FOUND);\n        }\n        return set;\n    }\n\n    private static void setFilterValues(final StatusGeocacheFilter f, final Collection<Integer> s) {\n        f.setShowOwnFound(s.contains(OWN_FOUND));\n        f.setShowDisabled(s.contains(DISABLED));\n        f.setShowArchived(s.contains(ARCHIVED));\n    }\n\n    @NotNull\n    private static Collection<Integer> getFilterValues(final StatusGeocacheFilter f) {\n\n            final Set<Integer> set = new HashSet<>();\n            if (f.isShowArchived()) {\n                set.add(ARCHIVED);\n            }\n            if (f.isShowOwnFound()) {\n                set.add(OWN_FOUND);\n            }\n            if (f.isShowDisabled()) {\n                set.add(DISABLED);\n            }\n            return set;\n    }\n\n}", "item_id": 0, "repo": "matej116/cgeo", "file": "main/src/cgeo/geocaching/filters/gui/StatusFilterViewHolder.java", "last_update_at": "2022-03-22T05:11:07+00:00", "question_id": "c84ca92eed0925a17cc582d53b4cea88c352b903_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StatusFilterViewHolder extends CheckboxFilterViewHolder<Integer, StatusGeocacheFilter> {\n    private static final int OWN_FOUND = 1;\n    private static final int DISABLED = 2;\n    private static final int ARCHIVED = 3;\n    public StatusFilterViewHolder() {\n        super(new ValueGroupFilterAccessor<Integer, StatusGeocacheFilter>()\n            .setSelectableValues(new Integer[]{OWN_FOUND, DISABLED, ARCHIVED})\n            .setValueGetter(StatusFilterViewHolder::getFilterValues)\n            .setValueSetter(StatusFilterViewHolder::setFilterValues)\n            .setValueDisplayTextGetter(s -> LocalizationUtils.getString(s == ARCHIVED ? R.string.map_showc_archived : (s == OWN_FOUND ? R.string.map_showc_ownfound : R.string.map_showc_disabled)))\n            .setValueDrawableGetter(s -> s == ARCHIVED ? R.drawable.ic_menu_archived : (s == OWN_FOUND ? R.drawable.ic_menu_myplaces : R.drawable.ic_menu_disabled))\n            .setGeocacheValueGetter((f, c) -> getGeocacheValues(c)));\n    }\n    @NotNull\n    private static Set<Integer> getGeocacheValues(final Geocache c) {\n        final Set<Integer> set = new HashSet<>();\n        if (c.isArchived()) {\n            set.add(ARCHIVED);\n        }\n        if (c.isDisabled()) {\n            set.add(DISABLED);\n        }\n        if (c.isFound() || c.getOwnerUserId().equals(Settings.getUserName())) {\n            set.add(OWN_FOUND);\n        }\n        return set;\n    }\n    private static void setFilterValues(final StatusGeocacheFilter f, final Collection<Integer> s) {\n        f.setShowOwnFound(s.contains(OWN_FOUND));\n        f.setShowDisabled(s.contains(DISABLED));\n        f.setShowArchived(s.contains(ARCHIVED));\n    }\n    @NotNull\n    private static Collection<Integer> getFilterValues(final StatusGeocacheFilter f) {\n            final Set<Integer> set = new HashSet<>();\n            if (f.isShowArchived()) {\n                set.add(ARCHIVED);\n            }\n            if (f.isShowOwnFound()) {\n                set.add(OWN_FOUND);\n            }\n            if (f.isShowDisabled()) {\n                set.add(DISABLED);\n            }\n            return set;\n    }\n"]], "pred": {"ppl": 1.80070161819458, "ppl_lower": 2.0379176139831543, "ppl/lowercase_ppl": -1.2103996982556442, "ppl/zlib": 0.0009133173553422884, "Min_5.0% Prob": 6.319094777107239, "Min_10.0% Prob": 4.561699691185584, "Min_20.0% Prob": 2.8012585858352312, "Min_30.0% Prob": 1.943582202669005, "Min_40.0% Prob": 1.4661778569406339, "Min_50.0% Prob": 1.1772102697535962, "Min_60.0% Prob": 0.9800713327819951}}
{"hexsha": "8019c8eb68ca0d419de99e52cf2cb25dcaeaa318", "ext": "java", "lang": "Java", "content": "public class ArrayHelper {\n\n    /**\n     * Merges two arrays\n     * @param <TItemType> Type of the items\n     * @param first First array\n     * @param second Second array\n     * @return\n     */\n    @CheckForNull\n    public static <TItemType> TItemType[] merge(@CheckForNull TItemType[] first, @CheckForNull TItemType[] second) {\n        // Handle nulls\n        if (first == null) {\n            return second;\n        }\n        if (second == null) {\n            return first;\n        }\n\n        // Handle two arrays\n        TItemType[] result = Arrays.copyOf(first, first.length + second.length);\n        System.arraycopy(second, 0, result, first.length, second.length);\n        return result;\n    }\n}", "item_id": 0, "repo": "dariver/custom-tools-plugin", "file": "src/main/java/com/synopsys/arc/jenkinsci/plugins/customtools/ArrayHelper.java", "last_update_at": "2022-03-17T03:19:30+00:00", "question_id": "8019c8eb68ca0d419de99e52cf2cb25dcaeaa318_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ArrayHelper {\n    /**\n     * Merges two arrays\n     * @param <TItemType> Type of the items\n     * @param first First array\n     * @param second Second array\n     * @return\n     */\n    @CheckForNull\n    public static <TItemType> TItemType[] merge(@CheckForNull TItemType[] first, @CheckForNull TItemType[] second) {\n        // Handle nulls\n        if (first == null) {\n            return second;\n        }\n        if (second == null) {\n            return first;\n        }\n        // Handle two arrays\n        TItemType[] result = Arrays.copyOf(first, first.length + second.length);\n        System.arraycopy(second, 0, result, first.length, second.length);\n        return result;\n    }\n"]], "pred": {"ppl": 1.7311948537826538, "ppl_lower": 2.270507335662842, "ppl/lowercase_ppl": -1.4941428866367346, "ppl/zlib": 0.0018990028963163995, "Min_5.0% Prob": 6.427267657385932, "Min_10.0% Prob": 4.406665268697236, "Min_20.0% Prob": 2.628938023860638, "Min_30.0% Prob": 1.8179763810614409, "Min_40.0% Prob": 1.3699420370350155, "Min_50.0% Prob": 1.0959694169536986, "Min_60.0% Prob": 0.9203915456507229}}
{"hexsha": "738e81bfd607906228abcf1d32e9b47406c97dd1", "ext": "java", "lang": "Java", "content": "@Configuration\n@ExtendWith(SpringExtension.class)\n@ContextConfiguration(classes = {ExpressionConfig.class, AnalyzerTestBase.class})\nclass NamedExpressionAnalyzerTest extends AnalyzerTestBase {\n  @Test\n  void visit_named_select_item() {\n    Alias alias = AstDSL.alias(\"integer_value\", AstDSL.qualifiedName(\"integer_value\"));\n\n    NamedExpressionAnalyzer analyzer =\n        new NamedExpressionAnalyzer(expressionAnalyzer);\n\n    NamedExpression analyze = analyzer.analyze(alias, analysisContext);\n    assertEquals(\"integer_value\", analyze.getNameOrAlias());\n  }\n}", "item_id": 0, "repo": "ylwu-amzn/sql-1", "file": "core/src/test/java/org/opensearch/sql/analysis/NamedExpressionAnalyzerTest.java", "last_update_at": "2022-03-22T21:13:33+00:00", "question_id": "738e81bfd607906228abcf1d32e9b47406c97dd1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Configuration\n@ExtendWith(SpringExtension.class)\n@ContextConfiguration(classes = {ExpressionConfig.class, AnalyzerTestBase.class})\nclass NamedExpressionAnalyzerTest extends AnalyzerTestBase {\n  @Test\n  void visit_named_select_item() {\n    Alias alias = AstDSL.alias(\"integer_value\", AstDSL.qualifiedName(\"integer_value\"));\n    NamedExpressionAnalyzer analyzer =\n        new NamedExpressionAnalyzer(expressionAnalyzer);\n    NamedExpression analyze = analyzer.analyze(alias, analysisContext);\n    assertEquals(\"integer_value\", analyze.getNameOrAlias());\n  }\n"]], "pred": {"ppl": 3.1736843585968018, "ppl_lower": 7.027468204498291, "ppl/lowercase_ppl": -1.6883176279279226, "ppl/zlib": 0.004277382115638544, "Min_5.0% Prob": 8.57884019613266, "Min_10.0% Prob": 7.003943741321564, "Min_20.0% Prob": 4.6869190111756325, "Min_30.0% Prob": 3.55178651958704, "Min_40.0% Prob": 2.827119997702539, "Min_50.0% Prob": 2.3055921046063306, "Min_60.0% Prob": 1.9327180380156885}}
{"hexsha": "f05c7799656bcdb964afbd4ccff8c8d66b5b9ec0", "ext": "java", "lang": "Java", "content": "@Day(1) @Problem(1) @Year(2018)\n@AutoService(DailyEvent.class)\npublic class ProblemOne implements DailyInputEvent, AnnotatedDailyEvent {\n    private final BiFunction<String, Long, Long> applier;\n\n    public ProblemOne(final BiFunction<String, Long, Long> applier) {\n        this.applier = applier;\n    }\n\n    public ProblemOne() {\n        this(new LineToFrequencyFunction());\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"Adding all frequencies together, starting with 0!\");\n        long frequency = 0;\n        for (String line : readLines()) {\n            frequency = applier.apply(line, frequency);\n        }\n        System.out.println(frequency);\n    }\n}", "item_id": 0, "repo": "philcali/aoc", "file": "aoc-day1/src/main/java/me/philcali/aoc/day1/year2018/ProblemOne.java", "last_update_at": "2022-01-04T16:36:17+00:00", "question_id": "f05c7799656bcdb964afbd4ccff8c8d66b5b9ec0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Day(1) @Problem(1) @Year(2018)\n@AutoService(DailyEvent.class)\npublic class ProblemOne implements DailyInputEvent, AnnotatedDailyEvent {\n    private final BiFunction<String, Long, Long> applier;\n    public ProblemOne(final BiFunction<String, Long, Long> applier) {\n        this.applier = applier;\n    }\n    public ProblemOne() {\n        this(new LineToFrequencyFunction());\n    }\n    @Override\n    public void run() {\n        System.out.println(\"Adding all frequencies together, starting with 0!\");\n        long frequency = 0;\n        for (String line : readLines()) {\n            frequency = applier.apply(line, frequency);\n        }\n        System.out.println(frequency);\n    }\n"]], "pred": {"ppl": 2.5815484523773193, "ppl_lower": 4.020257472991943, "ppl/lowercase_ppl": -1.4670619020389761, "ppl/zlib": 0.0028652247560132433, "Min_5.0% Prob": 7.619456815719604, "Min_10.0% Prob": 5.934898471832275, "Min_20.0% Prob": 4.070993170142174, "Min_30.0% Prob": 3.003039801120758, "Min_40.0% Prob": 2.3359687700867653, "Min_50.0% Prob": 1.8887976540625095, "Min_60.0% Prob": 1.578815299505368}}
{"hexsha": "817f15d3b59e5820fc10f0d483d0655a72ab1876", "ext": "java", "lang": "Java", "content": "class ConvexTriangleCallback extends TriangleCallback {\n\n\t//protected final BulletStack stack = BulletStack.get();\n\t\n\tprivate CollisionObject convexBody;\n\tprivate CollisionObject triBody;\n\n\tprivate final Vector3f aabbMin = new Vector3f();\n\tprivate final Vector3f aabbMax = new Vector3f();\n\n\tprivate ManifoldResult resultOut;\n\n\tprivate Dispatcher dispatcher;\n\tprivate DispatcherInfo dispatchInfoPtr;\n\tprivate float collisionMarginTriangle;\n\t\n\tpublic int triangleCount;\n\tpublic PersistentManifold manifoldPtr;\n\t\n\tpublic ConvexTriangleCallback(Dispatcher dispatcher, CollisionObject body0, CollisionObject body1, boolean isSwapped) {\n\t\tthis.dispatcher = dispatcher;\n\t\tthis.dispatchInfoPtr = null;\n\n\t\tconvexBody = isSwapped ? body1 : body0;\n\t\ttriBody = isSwapped ? body0 : body1;\n\n\t\t//\n\t\t// create the manifold from the dispatcher 'manifold pool'\n\t\t//\n\t\tmanifoldPtr = dispatcher.getNewManifold(convexBody, triBody);\n\n\t\tclearCache();\n\t}\n\t\n\tpublic void destroy() {\n\t\tclearCache();\n\t\tdispatcher.releaseManifold(manifoldPtr);\n\t}\n\n\tpublic void setTimeStepAndCounters(float collisionMarginTriangle, DispatcherInfo dispatchInfo, ManifoldResult resultOut) {\n\t\tthis.dispatchInfoPtr = dispatchInfo;\n\t\tthis.collisionMarginTriangle = collisionMarginTriangle;\n\t\tthis.resultOut = resultOut;\n\n\t\tStack stack = Stack.enter();\n\t\t// recalc aabbs\n\t\tTransform convexInTriangleSpace = stack.allocTransform();\n\n\t\ttriBody.getWorldTransform(convexInTriangleSpace);\n\t\tconvexInTriangleSpace.inverse();\n\t\tconvexInTriangleSpace.mul(convexBody.getWorldTransform(stack.allocTransform()));\n\n\t\tCollisionShape convexShape = (CollisionShape)convexBody.getCollisionShape();\n\t\t//CollisionShape* triangleShape = static_cast<btCollisionShape*>(triBody->m_collisionShape);\n\t\tconvexShape.getAabb(convexInTriangleSpace, aabbMin, aabbMax);\n\t\tfloat extraMargin = collisionMarginTriangle;\n\t\tVector3f extra = stack.allocVector3f();\n\t\textra.set(extraMargin, extraMargin, extraMargin);\n\n\t\taabbMax.add(extra);\n\t\taabbMin.sub(extra);\n\t\tstack.leave();\n\t}\n\n\tprivate CollisionAlgorithmConstructionInfo ci = new CollisionAlgorithmConstructionInfo();\n\tprivate TriangleShape tm = new TriangleShape();\n\t\n\tpublic void processTriangle(Vector3f[] triangle, int partId, int triangleIndex) {\n\t\t// just for debugging purposes\n\t\t//printf(\"triangle %d\",m_triangleCount++);\n\n\t\t// aabb filter is already applied!\t\n\n\t\tci.dispatcher1 = dispatcher;\n\n\t\tCollisionObject ob = (CollisionObject) triBody;\n\n\t\t// debug drawing of the overlapping triangles\n\t\tif (dispatchInfoPtr != null && dispatchInfoPtr.debugDraw != null && dispatchInfoPtr.debugDraw.getDebugMode() > 0) {\n\t\t    Stack stack = Stack.enter();\n\t\t\tVector3f color = stack.allocVector3f();\n\t\t\tcolor.set(255, 255, 0);\n\t\t\tTransform tr = ob.getWorldTransform(stack.allocTransform());\n\n\t\t\tVector3f tmp1 = stack.allocVector3f();\n\t\t\tVector3f tmp2 = stack.allocVector3f();\n\n\t\t\ttmp1.set(triangle[0]); tr.transform(tmp1);\n\t\t\ttmp2.set(triangle[1]); tr.transform(tmp2);\n\t\t\tdispatchInfoPtr.debugDraw.drawLine(tmp1, tmp2, color);\n\n\t\t\ttmp1.set(triangle[1]); tr.transform(tmp1);\n\t\t\ttmp2.set(triangle[2]); tr.transform(tmp2);\n\t\t\tdispatchInfoPtr.debugDraw.drawLine(tmp1, tmp2, color);\n\n\t\t\ttmp1.set(triangle[2]); tr.transform(tmp1);\n\t\t\ttmp2.set(triangle[0]); tr.transform(tmp2);\n\t\t\tdispatchInfoPtr.debugDraw.drawLine(tmp1, tmp2, color);\n\n\t\t\t//btVector3 center = triangle[0] + triangle[1]+triangle[2];\n\t\t\t//center *= btScalar(0.333333);\n\t\t\t//m_dispatchInfoPtr->m_debugDraw->drawLine(tr(triangle[0]),tr(center),color);\n\t\t\t//m_dispatchInfoPtr->m_debugDraw->drawLine(tr(triangle[1]),tr(center),color);\n\t\t\t//m_dispatchInfoPtr->m_debugDraw->drawLine(tr(triangle[2]),tr(center),color);\n\t\t\tstack.leave();\n\t\t}\n\n\t\t//btCollisionObject* colObj = static_cast<btCollisionObject*>(m_convexProxy->m_clientObject);\n\n\t\tif (convexBody.getCollisionShape().isConvex()) {\n\t\t\ttm.init(triangle[0], triangle[1], triangle[2]);\n\t\t\ttm.setMargin(collisionMarginTriangle);\n\n\t\t\tCollisionShape tmpShape = ob.getCollisionShape();\n\t\t\tob.internalSetTemporaryCollisionShape(tm);\n\n\t\t\tCollisionAlgorithm colAlgo = ci.dispatcher1.findAlgorithm(convexBody, triBody, manifoldPtr);\n\t\t\t// this should use the btDispatcher, so the actual registered algorithm is used\n\t\t\t//\t\tbtConvexConvexAlgorithm cvxcvxalgo(m_manifoldPtr,ci,m_convexBody,m_triBody);\n\n\t\t\tresultOut.setShapeIdentifiers(-1, -1, partId, triangleIndex);\n\t\t\t//cvxcvxalgo.setShapeIdentifiers(-1,-1,partId,triangleIndex);\n\t\t\t//cvxcvxalgo.processCollision(m_convexBody,m_triBody,*m_dispatchInfoPtr,m_resultOut);\n\t\t\tcolAlgo.processCollision(convexBody, triBody, dispatchInfoPtr, resultOut);\n\t\t\t//colAlgo.destroy();\n\t\t\tci.dispatcher1.freeCollisionAlgorithm(colAlgo);\n\t\t\tob.internalSetTemporaryCollisionShape(tmpShape);\n\t\t}\n\t}\n\n\tpublic void clearCache() {\n\t\tdispatcher.clearManifold(manifoldPtr);\n\t}\n\n\tpublic Vector3f getAabbMin(Vector3f out) {\n\t\tout.set(aabbMin);\n\t\treturn out;\n\t}\n\n\tpublic Vector3f getAabbMax(Vector3f out) {\n\t\tout.set(aabbMax);\n\t\treturn out;\n\t}\n\t\n}", "item_id": 0, "repo": "SolarLune/bdx", "file": "extern/gbullet/src/com/bulletphysics/collision/dispatch/ConvexTriangleCallback.java", "last_update_at": "2022-03-21T09:44:58+00:00", "question_id": "817f15d3b59e5820fc10f0d483d0655a72ab1876_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class ConvexTriangleCallback extends TriangleCallback {\n\t//protected final BulletStack stack = BulletStack.get();\n\t\n\tprivate CollisionObject convexBody;\n\tprivate CollisionObject triBody;\n\tprivate final Vector3f aabbMin = new Vector3f();\n\tprivate final Vector3f aabbMax = new Vector3f();\n\tprivate ManifoldResult resultOut;\n\tprivate Dispatcher dispatcher;\n\tprivate DispatcherInfo dispatchInfoPtr;\n\tprivate float collisionMarginTriangle;\n\t\n\tpublic int triangleCount;\n\tpublic PersistentManifold manifoldPtr;\n\t\n\tpublic ConvexTriangleCallback(Dispatcher dispatcher, CollisionObject body0, CollisionObject body1, boolean isSwapped) {\n\t\tthis.dispatcher = dispatcher;\n\t\tthis.dispatchInfoPtr = null;\n\t\tconvexBody = isSwapped ? body1 : body0;\n\t\ttriBody = isSwapped ? body0 : body1;\n\t\t//\n\t\t// create the manifold from the dispatcher 'manifold pool'\n\t\t//\n\t\tmanifoldPtr = dispatcher.getNewManifold(convexBody, triBody);\n\t\tclearCache();\n\t}\n\t\n\tpublic void destroy() {\n\t\tclearCache();\n\t\tdispatcher.releaseManifold(manifoldPtr);\n\t}\n\tpublic void setTimeStepAndCounters(float collisionMarginTriangle, DispatcherInfo dispatchInfo, ManifoldResult resultOut) {\n\t\tthis.dispatchInfoPtr = dispatchInfo;\n\t\tthis.collisionMarginTriangle = collisionMarginTriangle;\n\t\tthis.resultOut = resultOut;\n\t\tStack stack = Stack.enter();\n\t\t// recalc aabbs\n\t\tTransform convexInTriangleSpace = stack.allocTransform();\n\t\ttriBody.getWorldTransform(convexInTriangleSpace);\n\t\tconvexInTriangleSpace.inverse();\n\t\tconvexInTriangleSpace.mul(convexBody.getWorldTransform(stack.allocTransform()));\n\t\tCollisionShape convexShape = (CollisionShape)convexBody.getCollisionShape();\n\t\t//CollisionShape* triangleShape = static_cast<btCollisionShape*>(triBody->m_collisionShape);\n\t\tconvexShape.getAabb(convexInTriangleSpace, aabbMin, aabbMax);\n\t\tfloat extraMargin = collisionMarginTriangle;\n\t\tVector3f extra = stack.allocVector3f();\n\t\textra.set(extraMargin, extraMargin, extraMargin);\n\t\taabbMax.add(extra);\n\t\taabbMin.sub(extra);\n\t\tstack.leave();\n\t}\n\tprivate CollisionAlgorithmConstructionInfo ci = new CollisionAlgorithmConstructionInfo();\n\tprivate TriangleShape tm = new TriangleShape();\n\t\n\tpublic void processTriangle(Vector3f[] triangle, int partId, int triangleIndex) {\n\t\t// just for debugging purposes\n\t\t//printf(\"triangle %d\",m_triangleCount++);\n\t\t// aabb filter is already applied!\t\n\t\tci.dispatcher1 = dispatcher;\n\t\tCollisionObject ob = (CollisionObject) triBody;\n\t\t// debug drawing of the overlapping triangles\n\t\tif (dispatchInfoPtr != null && dispatchInfoPtr.debugDraw != null && dispatchInfoPtr.debugDraw.getDebugMode() > 0) {\n\t\t    Stack stack = Stack.enter();\n\t\t\tVector3f color = stack.allocVector3f();\n\t\t\tcolor.set(255, 255, 0);\n\t\t\tTransform tr = ob.getWorldTransform(stack.allocTransform());\n\t\t\tVector3f tmp1 = stack.allocVector3f();\n\t\t\tVector3f tmp2 = stack.allocVector3f();\n\t\t\ttmp1.set(triangle[0]); tr.transform(tmp1);\n\t\t\ttmp2.set(triangle[1]); tr.transform(tmp2);\n\t\t\tdispatchInfoPtr.debugDraw.drawLine(tmp1, tmp2, color);\n\t\t\ttmp1.set(triangle[1]); tr.transform(tmp1);\n\t\t\ttmp2.set(triangle[2]); tr.transform(tmp2);\n\t\t\tdispatchInfoPtr.debugDraw.drawLine(tmp1, tmp2, color);\n\t\t\ttmp1.set(triangle[2]); tr.transform(tmp1);\n\t\t\ttmp2.set(triangle[0]); tr.transform(tmp2);\n\t\t\tdispatchInfoPtr.debugDraw.drawLine(tmp1, tmp2, color);\n\t\t\t//btVector3 center = triangle[0] + triangle[1]+triangle[2];\n\t\t\t//center *= btScalar(0.333333);\n\t\t\t//m_dispatchInfoPtr->m_debugDraw->drawLine(tr(triangle[0]),tr(center),color);\n\t\t\t//m_dispatchInfoPtr->m_debugDraw->drawLine(tr(triangle[1]),tr(center),color);\n\t\t\t//m_dispatchInfoPtr->m_debugDraw->drawLine(tr(triangle[2]),tr(center),color);\n\t\t\tstack.leave();\n\t\t}\n\t\t//btCollisionObject* colObj = static_cast<btCollisionObject*>(m_convexProxy->m_clientObject);\n\t\tif (convexBody.getCollisionShape().isConvex()) {\n\t\t\ttm.init(triangle[0], triangle[1], triangle[2]);\n\t\t\ttm.setMargin(collisionMarginTriangle);\n\t\t\tCollisionShape tmpShape = ob.getCollisionShape();\n\t\t\tob.internalSetTemporaryCollisionShape(tm);\n\t\t\tCollisionAlgorithm colAlgo = ci.dispatcher1.findAlgorithm(convexBody, triBody, manifoldPtr);\n\t\t\t// this should use the btDispatcher, so the actual registered algorithm is used\n\t\t\t//\t\tbtConvexConvexAlgorithm cvxcvxalgo(m_manifoldPtr,ci,m_convexBody,m_triBody);\n\t\t\tresultOut.setShapeIdentifiers(-1, -1, partId, triangleIndex);\n\t\t\t//cvxcvxalgo.setShapeIdentifiers(-1,-1,partId,triangleIndex);\n\t\t\t//cvxcvxalgo.processCollision(m_convexBody,m_triBody,*m_dispatchInfoPtr,m_resultOut);\n\t\t\tcolAlgo.processCollision(convexBody, triBody, dispatchInfoPtr, resultOut);\n\t\t\t//colAlgo.destroy();\n\t\t\tci.dispatcher1.freeCollisionAlgorithm(colAlgo);\n\t\t\tob.internalSetTemporaryCollisionShape(tmpShape);\n\t\t}\n\t}\n\tpublic void clearCache() {\n\t\tdispatcher.clearManifold(manifoldPtr);\n\t}\n\tpublic Vector3f getAabbMin(Vector3f out) {\n\t\tout.set(aabbMin);\n\t\treturn out;\n\t}\n\tpublic Vector3f getAabbMax(Vector3f out) {\n\t\tout.set(aabbMax);\n\t\treturn out;\n\t}\n\t\n"]], "pred": {"ppl": 1.9222722053527832, "ppl_lower": 2.432589530944824, "ppl/lowercase_ppl": -1.3602839450628361, "ppl/zlib": 0.00045131762887716314, "Min_5.0% Prob": 6.430241407132616, "Min_10.0% Prob": 4.721670573832942, "Min_20.0% Prob": 3.0187568223359538, "Min_30.0% Prob": 2.1404095108018204, "Min_40.0% Prob": 1.623679717688441, "Min_50.0% Prob": 1.304978521981818, "Min_60.0% Prob": 1.0896764519923712}}
{"hexsha": "bc930ab27697be84632cebdde642c18e3bb706f3", "ext": "java", "lang": "Java", "content": "@RestController\n@RequestMapping(\"/sysMenu\")\n@Api(tags = \"\u83dc\u5355\")\n@Slf4j\n@AllArgsConstructor\npublic class SysMenuController extends BaseController {\n\n    private final SysMenuService sysMenuService;\n\n    /**\n     * \u83dc\u5355 \u65b0\u589e\n     * @param sysMenu sysMenu\n     * @return Result\n     */\n    @PostMapping(\"/add\")\n    @ApiOperation(value = \"\u65b0\u589e\", notes = \"\u65b0\u589e\")\n    public Result add(@RequestBody SysMenu sysMenu) {\n        Result result = new Result();\n        try {\n            sysMenuService.insertSysMenu(sysMenu);\n        } catch (Exception e) {\n            log.error(e.getMessage());\n            result.setCode(Result.ERROR_BUSINESS);\n            result.setMessage(e.getMessage());\n        }\n        return result;\n    }\n\n    /**\n     * \u83dc\u5355 \u5220\u9664\n     * @param id id\n     * @return Result\n     */\n    @PostMapping(\"/delete\")\n    @ApiOperation(value = \"\u5220\u9664\", notes = \"\u5220\u9664\")\n    public Result delete(@RequestParam(\"id\") Integer id) {\n        Result result = new Result();\n        try {\n            sysMenuService.deleteSysMenu(id);\n        } catch (Exception e) {\n            log.error(e.getMessage());\n            result.setCode(Result.ERROR_BUSINESS);\n            result.setMessage(e.getMessage());\n        }\n        return result;\n    }\n\n    /**\n     * \u83dc\u5355 \u67e5\u770b\u8be6\u60c5\n     * @param id id\n     * @return Result\n     */\n    @GetMapping(\"/detail\")\n    @ApiOperation(value = \"\u67e5\u770b\u8be6\u60c5\", notes = \"\u67e5\u770b\u8be6\u60c5\")\n    public Result detail(@RequestParam(\"id\") Integer id) {\n        Result result = new Result();\n        try {\n            result.setData(sysMenuService.findSysMenuById(id));\n        } catch (Exception e) {\n            log.error(e.getMessage());\n            result.setCode(Result.ERROR_BUSINESS);\n            result.setMessage(e.getMessage());\n        }\n        return result;\n    }\n\n    /**\n     * \u83dc\u5355 \u66f4\u65b0\n     * @param sysMenu sysMenu\n     * @return Result\n     */\n    @PostMapping(\"/update\")\n    @ApiOperation(value = \"\u66f4\u65b0\", notes = \"\u66f4\u65b0\")\n    public Result update(@RequestBody SysMenu sysMenu) {\n        Result result = new Result();\n        try {\n            sysMenuService.updateSysMenu(sysMenu);\n        } catch (Exception e) {\n            log.error(e.getMessage());\n            result.setCode(Result.ERROR_BUSINESS);\n            result.setMessage(e.getMessage());\n        }\n        return result;\n    }\n\n    /**\n     * \u83dc\u5355 \u5206\u9875\u67e5\u8be2\n     * @param page page\n     * @param sysMenuRequest sysMenuRequest\n     * @return Result\n     */\n    @PostMapping(\"/findPage\")\n    @ApiOperation(value = \"\u5206\u9875\u67e5\u8be2\", notes = \"\u5206\u9875\u67e5\u8be2\")\n    public Result findPage(Page page, SysMenuRequest sysMenuRequest) {\n        Result result = new Result();\n        try {\n            result.setData(sysMenuService.findSysMenuPage(page, sysMenuRequest));\n        } catch (Exception e) {\n            log.error(e.getMessage());\n            result.setCode(Result.ERROR_BUSINESS);\n            result.setMessage(e.getMessage());\n        }\n        return result;\n    }\n}", "item_id": 0, "repo": "JcLoveCode/JavaTutorial", "file": "springboot-demo/src/main/java/cn/fjc/system/controller/SysMenuController.java", "last_update_at": "2022-01-20T01:59:59+00:00", "question_id": "bc930ab27697be84632cebdde642c18e3bb706f3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RestController\n@RequestMapping(\"/sysMenu\")\n@Api(tags = \"\u83dc\u5355\")\n@Slf4j\n@AllArgsConstructor\npublic class SysMenuController extends BaseController {\n    private final SysMenuService sysMenuService;\n    /**\n     * \u83dc\u5355 \u65b0\u589e\n     * @param sysMenu sysMenu\n     * @return Result\n     */\n    @PostMapping(\"/add\")\n    @ApiOperation(value = \"\u65b0\u589e\", notes = \"\u65b0\u589e\")\n    public Result add(@RequestBody SysMenu sysMenu) {\n        Result result = new Result();\n        try {\n            sysMenuService.insertSysMenu(sysMenu);\n        } catch (Exception e) {\n            log.error(e.getMessage());\n            result.setCode(Result.ERROR_BUSINESS);\n            result.setMessage(e.getMessage());\n        }\n        return result;\n    }\n    /**\n     * \u83dc\u5355 \u5220\u9664\n     * @param id id\n     * @return Result\n     */\n    @PostMapping(\"/delete\")\n    @ApiOperation(value = \"\u5220\u9664\", notes = \"\u5220\u9664\")\n    public Result delete(@RequestParam(\"id\") Integer id) {\n        Result result = new Result();\n        try {\n            sysMenuService.deleteSysMenu(id);\n        } catch (Exception e) {\n            log.error(e.getMessage());\n            result.setCode(Result.ERROR_BUSINESS);\n            result.setMessage(e.getMessage());\n        }\n        return result;\n    }\n    /**\n     * \u83dc\u5355 \u67e5\u770b\u8be6\u60c5\n     * @param id id\n     * @return Result\n     */\n    @GetMapping(\"/detail\")\n    @ApiOperation(value = \"\u67e5\u770b\u8be6\u60c5\", notes = \"\u67e5\u770b\u8be6\u60c5\")\n    public Result detail(@RequestParam(\"id\") Integer id) {\n        Result result = new Result();\n        try {\n            result.setData(sysMenuService.findSysMenuById(id));\n        } catch (Exception e) {\n            log.error(e.getMessage());\n            result.setCode(Result.ERROR_BUSINESS);\n            result.setMessage(e.getMessage());\n        }\n        return result;\n    }\n    /**\n     * \u83dc\u5355 \u66f4\u65b0\n     * @param sysMenu sysMenu\n     * @return Result\n     */\n    @PostMapping(\"/update\")\n    @ApiOperation(value = \"\u66f4\u65b0\", notes = \"\u66f4\u65b0\")\n    public Result update(@RequestBody SysMenu sysMenu) {\n        Result result = new Result();\n        try {\n            sysMenuService.updateSysMenu(sysMenu);\n        } catch (Exception e) {\n            log.error(e.getMessage());\n            result.setCode(Result.ERROR_BUSINESS);\n            result.setMessage(e.getMessage());\n        }\n        return result;\n    }\n    /**\n     * \u83dc\u5355 \u5206\u9875\u67e5\u8be2\n     * @param page page\n     * @param sysMenuRequest sysMenuRequest\n     * @return Result\n     */\n    @PostMapping(\"/findPage\")\n    @ApiOperation(value = \"\u5206\u9875\u67e5\u8be2\", notes = \"\u5206\u9875\u67e5\u8be2\")\n    public Result findPage(Page page, SysMenuRequest sysMenuRequest) {\n        Result result = new Result();\n        try {\n            result.setData(sysMenuService.findSysMenuPage(page, sysMenuRequest));\n        } catch (Exception e) {\n            log.error(e.getMessage());\n            result.setCode(Result.ERROR_BUSINESS);\n            result.setMessage(e.getMessage());\n        }\n        return result;\n    }\n"]], "pred": {"ppl": 1.1878445148468018, "ppl_lower": 1.3107874393463135, "ppl/lowercase_ppl": -1.5721362405308388, "ppl/zlib": 0.00027899567684986357, "Min_5.0% Prob": 2.638911102305759, "Min_10.0% Prob": 1.6051867370578377, "Min_20.0% Prob": 0.8515330788463691, "Min_30.0% Prob": 0.573680660711988, "Min_40.0% Prob": 0.4303664148059716, "Min_50.0% Prob": 0.3441347675852616, "Min_60.0% Prob": 0.2871775744271749}}
{"hexsha": "f28a0bdf00a2235f6383e6c55f882b5312213edd", "ext": "java", "lang": "Java", "content": "public abstract class AbstractApiClient implements ApiClient {\n\n    private final String url;\n\n    protected AbstractApiClient() {\n        url = Environment.TEST.getUrl();\n    }\n\n    protected AbstractApiClient(String url) {\n        this.url = url;\n    }\n\n    protected AbstractApiClient(Environment environment) {\n        url = environment.getUrl();\n    }\n\n    protected byte[] marshalXML(@NotNull Object o) throws JAXBException {\n\n        val jc = JAXBContext.newInstance(o.getClass());\n        val jaxbMarshaller = jc.createMarshaller();\n\n        jaxbMarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n        val stream = new ByteArrayOutputStream();\n        jaxbMarshaller.marshal(o, stream);\n\n        return stream.toByteArray();\n    }\n\n    @NotNull\n    protected String createUrl(@NotNull String endpoint) {\n\n        val sb = new StringBuilder();\n        sb.append(url);\n        if (!endpoint.startsWith(\"/\")) sb.append(\"/\");\n        sb.append(endpoint);\n\n        return sb.toString();\n    }\n\n    @Getter\n    @RequiredArgsConstructor\n    public enum Environment {\n\n        DEMO(\"https://ksef-demo.mf.gov.pl/api\"),\n        PROD(\"https://ksef.mf.gov.pl/api\"),\n        TEST(\"https://ksef-test.mf.gov.pl/api\");\n\n        private final String url;\n    }\n}", "item_id": 0, "repo": "alapierre/ksef-java-rest-client", "file": "ksef-client-spec/src/main/java/io/alapierre/ksef/client/AbstractApiClient.java", "last_update_at": "2022-03-28T17:15:19+00:00", "question_id": "f28a0bdf00a2235f6383e6c55f882b5312213edd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class AbstractApiClient implements ApiClient {\n    private final String url;\n    protected AbstractApiClient() {\n        url = Environment.TEST.getUrl();\n    }\n    protected AbstractApiClient(String url) {\n        this.url = url;\n    }\n    protected AbstractApiClient(Environment environment) {\n        url = environment.getUrl();\n    }\n    protected byte[] marshalXML(@NotNull Object o) throws JAXBException {\n        val jc = JAXBContext.newInstance(o.getClass());\n        val jaxbMarshaller = jc.createMarshaller();\n        jaxbMarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n        val stream = new ByteArrayOutputStream();\n        jaxbMarshaller.marshal(o, stream);\n        return stream.toByteArray();\n    }\n    @NotNull\n    protected String createUrl(@NotNull String endpoint) {\n        val sb = new StringBuilder();\n        sb.append(url);\n        if (!endpoint.startsWith(\"/\")) sb.append(\"/\");\n        sb.append(endpoint);\n        return sb.toString();\n    }\n    @Getter\n    @RequiredArgsConstructor\n    public enum Environment {\n        DEMO(\"https://ksef-demo.mf.gov.pl/api\"),\n        PROD(\"https://ksef.mf.gov.pl/api\"),\n        TEST(\"https://ksef-test.mf.gov.pl/api\");\n        private final String url;\n    }\n"]], "pred": {"ppl": 1.7819851636886597, "ppl_lower": 2.1946351528167725, "ppl/lowercase_ppl": -1.360529194952471, "ppl/zlib": 0.0010880000063319267, "Min_5.0% Prob": 6.0571345655541675, "Min_10.0% Prob": 4.243210406679856, "Min_20.0% Prob": 2.6645643734618236, "Min_30.0% Prob": 1.89062476824773, "Min_40.0% Prob": 1.4407138468844718, "Min_50.0% Prob": 1.1564296099749443, "Min_60.0% Prob": 0.9649284877957318}}
{"hexsha": "8d30ebd09be518da76c8ceb500e1e51506245dfd", "ext": "java", "lang": "Java", "content": "public class ActPerformanceTest extends ActivityInstrumentationTestCase2<Main> {\n    private static final String TAG = \"M3dMark\";\n\n    public ActPerformanceTest() {\n        super(\"com.mediatek.media3d\", Main.class);\n    }\n\n    private static final long APP_LAUNCH_TIME_WO_CACHE_CRITERIA = 3000;\n\n    public void test01_AppLaunchTimeWOCache() {\n        long t1 = SystemClock.uptimeMillis();\n        Log.v(TAG, \"starting activity without shader cache\");\n        final Main activity = getActivity();\n        assertNotNull(activity);\n        getInstrumentation().waitForIdleSync();\n        long t2 = SystemClock.uptimeMillis() - t1;\n        Log.v(TAG, \"getActivity costs: \" + t2);\n\n        writePerformanceData(activity, \"app.launch-time-wo-cache.txt\", t2);\n        assertThat(t2, is(lessThanOrEqualTo(APP_LAUNCH_TIME_WO_CACHE_CRITERIA)));\n    }\n\n    private void writePerformanceData(Activity activity, String name, Object data) {\n        File dataFile = new File(activity.getDir(\"perf\", Context.MODE_PRIVATE), name);\n        dataFile.delete();\n        try {\n            FileWriter writer = new FileWriter(dataFile);\n            writer.write(\"YVALUE=\" + data);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}", "item_id": 0, "repo": "touxiong88/92_mediatek", "file": "packages/apps/Media3D/tests/src/com/mediatek/media3d/ActPerformanceTest.java", "last_update_at": "2022-01-07T01:53:19+00:00", "question_id": "8d30ebd09be518da76c8ceb500e1e51506245dfd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ActPerformanceTest extends ActivityInstrumentationTestCase2<Main> {\n    private static final String TAG = \"M3dMark\";\n    public ActPerformanceTest() {\n        super(\"com.mediatek.media3d\", Main.class);\n    }\n    private static final long APP_LAUNCH_TIME_WO_CACHE_CRITERIA = 3000;\n    public void test01_AppLaunchTimeWOCache() {\n        long t1 = SystemClock.uptimeMillis();\n        Log.v(TAG, \"starting activity without shader cache\");\n        final Main activity = getActivity();\n        assertNotNull(activity);\n        getInstrumentation().waitForIdleSync();\n        long t2 = SystemClock.uptimeMillis() - t1;\n        Log.v(TAG, \"getActivity costs: \" + t2);\n        writePerformanceData(activity, \"app.launch-time-wo-cache.txt\", t2);\n        assertThat(t2, is(lessThanOrEqualTo(APP_LAUNCH_TIME_WO_CACHE_CRITERIA)));\n    }\n    private void writePerformanceData(Activity activity, String name, Object data) {\n        File dataFile = new File(activity.getDir(\"perf\", Context.MODE_PRIVATE), name);\n        dataFile.delete();\n        try {\n            FileWriter writer = new FileWriter(dataFile);\n            writer.write(\"YVALUE=\" + data);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n"]], "pred": {"ppl": 2.4247381687164307, "ppl_lower": 3.082446336746216, "ppl/lowercase_ppl": -1.2709649086842876, "ppl/zlib": 0.001471301572918205, "Min_5.0% Prob": 7.776317420758699, "Min_10.0% Prob": 5.7195359621292505, "Min_20.0% Prob": 3.854349059936328, "Min_30.0% Prob": 2.827674594954548, "Min_40.0% Prob": 2.1850093682415976, "Min_50.0% Prob": 1.7673838195892482, "Min_60.0% Prob": 1.4784976332806623}}
{"hexsha": "ac4b82f57514b08de7830bcaad91c5eac0044c1f", "ext": "java", "lang": "Java", "content": "public final class CommentsWidget extends Composite implements ClickHandler {\r\n\r\n\tprivate static CommentsWidget inst;\r\n\r\n\tpublic static CommentsWidget get() {\r\n\t\tif (inst == null) {\r\n\t\t\tinst = new CommentsWidget();\r\n\t\t}\r\n\t\treturn inst;\r\n\t}\r\n\r\n\tprivate final class CommentEntry extends Composite implements MouseOutHandler, MouseOverHandler,\r\n\t    ClickHandler, LoginListener, CommentEditCallback {\r\n\r\n\t\tprivate VerticalPanel mainPanel;\r\n\t\tprivate Grid header;\r\n\t\tprivate HTML content;\r\n\t\tprivate HTML userName;\r\n\t\tprivate Label lastModified;\r\n\t\tprivate Image editButton;\r\n\t\tprivate Image deleteButton;\r\n\t\tprivate CommentListEntry cle;\r\n\t\tprivate boolean isToDelete;\r\n\t\tprivate String possibleText;\r\n\r\n\t\tpublic CommentEntry(CommentListEntry cle) {\r\n\t\t\tthis.cle = cle;\r\n\t\t\tisToDelete = false;\r\n\t\t\tmainPanel = new VerticalPanel();\r\n\t\t\tmainPanel.setStyleName(\"relW\");\r\n\t\t\tmainPanel.setWidth(\"100%\");\r\n\r\n\t\t\theader = new Grid(1, 5);\r\n\t\t\tCellFormatter cf = header.getCellFormatter();\r\n\t\t\theader.setStyleName(\"relW-header\");\r\n\r\n\r\n\t\t\tuserName = new HTML(\"<B>\"+cle.getAuthor()+\"</B>\");\r\n\t\t\theader.setWidget(0, 0, userName);\r\n\t\t\tcf.setWidth(0, 0, \"20\");\r\n\t\t\tcf.setAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT,\r\n\t\t\t\t\tHasVerticalAlignment.ALIGN_MIDDLE);\r\n\r\n\t\t\teditButton = new Image(\"img/edit-name.png\", 0, 0, 15, 15);\r\n\t\t\teditButton.addClickHandler(this);\r\n\t\t\teditButton.addMouseOutHandler(this);\r\n\t\t\teditButton.addMouseOverHandler(this);\r\n\t\t\teditButton.setTitle(\"Edit the comment.\");\r\n\t\t\tCommon.setCursorPointer(editButton);\r\n\t\t\theader.setWidget(0, 1, editButton);\r\n\t\t\tcf.setWidth(0, 1, \"20px\");\r\n\t\t\tcf.setAlignment(0, 1, HasHorizontalAlignment.ALIGN_LEFT,\r\n\t\t\t\t\tHasVerticalAlignment.ALIGN_MIDDLE);\r\n\r\n\t\t\tdeleteButton = new Image(\"img/bin.png\", 0, 0, 15, 15);\r\n\t\t\tdeleteButton.addClickHandler(this);\r\n\t\t\tdeleteButton.addMouseOutHandler(this);\r\n\t\t\tdeleteButton.setTitle(\"Delete the comment.\");\r\n\t\t\tCommon.setCursorPointer(deleteButton);\r\n\t\t\theader.setWidget(0, 2, deleteButton);\r\n\t\t\tcf.setWidth(0, 2, \"20px\");\r\n\t\t\tcf.setAlignment(0, 2, HasHorizontalAlignment.ALIGN_LEFT,\r\n\t\t\t\t\tHasVerticalAlignment.ALIGN_MIDDLE);\r\n\r\n\t\t\tlastModified = new Label(cle.getLastModified());\r\n\t\t\theader.setWidget(0, 4, lastModified);\r\n\t\t\tcf.setAlignment(0, 4, HasHorizontalAlignment.ALIGN_RIGHT,\r\n\t\t\t\t\tHasVerticalAlignment.ALIGN_MIDDLE);\r\n\r\n\t\t\tmainPanel.add(header);\r\n\r\n\t\t\tcontent = new HTML(cle.getCommentString());\r\n\t\t\tmainPanel.add(content);\r\n\r\n\t\t\tthis.initWidget(mainPanel);\r\n\t\t\tsetWidth(\"100%\");\r\n\t\t\tLogin.get().addListener(this);\r\n\r\n\t\t\teditButton.setVisible(false);\r\n\t\t\tdeleteButton.setVisible(false);\r\n\r\n\t\t\t//display edit and delete buttons only if the user is logged in\r\n\t\t\tif (UserData.get().isLoggedIn()) {\r\n\t\t\t\tString id = UserData.get().getId();\r\n\t\t\t\tboolean isAdmin = UserData.get().isAdmin();\r\n\t\t\t\tif (isAdmin || id.equals(cle.getAuthorID())) {\r\n\t\t\t\t\teditButton.setVisible(true);\r\n\t\t\t\t\tdeleteButton.setVisible(true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void onMouseOut(MouseOutEvent event) {\r\n\t\t\tObject sender = event.getSource();\r\n\t\t\tif (sender == deleteButton) {\r\n\t\t\t\tdeleteButton.setVisibleRect(0, 0, 15, 15);\r\n\t\t\t} else if (sender == editButton) {\r\n\t\t\t\teditButton.setVisibleRect(0, 0, 15, 15);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void onMouseOver(MouseOverEvent event) {\r\n\t\t\tObject sender = event.getSource();\r\n\t\t\tif (sender == deleteButton) {\r\n\t\t\t\tdeleteButton.setVisibleRect(15, 0, 15, 15);\r\n\t\t\t} else if (sender == editButton) {\r\n\t\t\t\teditButton.setVisibleRect(15, 0, 15, 15);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void onClick(ClickEvent event) {\r\n\t\t\tObject sender = event.getSource();\r\n\t\t\tif (sender == deleteButton) {\r\n\t\t\t\tif(Window.confirm(\"Are you sure you wan to delete the comment?\")) {\r\n\t\t\t\t\tCommentEdit ce = CommentEdit.get();\r\n\t\t\t\t\tisToDelete = true;\r\n\t\t\t\t\tce.send(this, cle.getId(), \"\", true);\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if (sender == editButton) {\r\n\t\t\t\tCommentEditDialog ced = CommentEditDialog.get(cle, this);\r\n\t\t\t\tced.center();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic void onLoginSuccess() {\r\n\t\t\tString id = UserData.get().getId();\r\n\t\t\tboolean isAdmin = UserData.get().isAdmin();\r\n\t\t\tif (isAdmin || id.equals(cle.getAuthorID())) {\r\n\t\t\t\teditButton.setVisible(true);\r\n\t\t\t\tdeleteButton.setVisible(true);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tpublic void onSessionKilled() {\r\n\t\t\teditButton.setVisible(false);\r\n\t\t\tdeleteButton.setVisible(false);\r\n\t\t}\r\n\r\n\r\n\t\tpublic void onReseive(boolean isOK) {\r\n\t\t\tif(isOK) {\r\n\t\t\t\tif (isToDelete) {\r\n\t\t\t\t\tremoveFromParent();\r\n\t\t\t\t\t//Login.get().removeListener(this);\r\n\t\t\t\t} else if (possibleText != null) {\r\n\t\t\t\t\tcontent.setHTML(Common.escapeHTMLCharacters(possibleText));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (isToDelete) {\r\n\t\t\t\t\tWindow.alert(\"The comment could not be deleted.\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tWindow.alert(\"The comment could not be edited.\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tpossibleText = null;\r\n\t\t\tisToDelete = false;\r\n\t\t}\r\n\r\n\t\tpublic void setPossibleCommentText(String str) {\r\n\t\t\tthis.possibleText = str;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate VerticalPanel mainPanel;\r\n\tprivate List<CommentEntry> entries;\r\n\tprivate Button addCommentBut;\r\n\r\n\tprivate CommentsWidget() {\r\n\t\tmainPanel = new VerticalPanel();\r\n\t\tHorizontalPanel hp = new HorizontalPanel();\r\n\t\thp.setVerticalAlignment(HasVerticalAlignment.ALIGN_MIDDLE);\r\n\t\taddCommentBut = new Button(\"Add new Comment\");\r\n\t\taddCommentBut.setStyleName(\"min-cov-but\");\r\n\t\taddCommentBut.addClickHandler(this);\r\n\t\thp.add(addCommentBut);\r\n\t\thp.add(new InfoButton(\"comment\"));\r\n\t\tmainPanel.add(hp);\r\n\t\tentries = new ArrayList<>();\r\n\t\tinitWidget(mainPanel);\r\n\t\tmainPanel.setSpacing(6);\r\n\t\tsetWidth(\"100%\");\r\n\t}\r\n\r\n\tpublic void clearData() {\r\n\t\tfor (CommentEntry cm : entries) {\r\n\t\t\tcm.removeFromParent();\r\n\t\t}\r\n\t\tentries.clear();\r\n\t}\r\n\r\n\tpublic void addComments(List<CommentListEntry> comments) {\r\n\t\tfor (CommentListEntry cle : comments) {\r\n\t\t\tCommentEntry c =  new CommentEntry(cle);\r\n\t\t\tmainPanel.add(c);\r\n\t\t\tentries.add(c);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void onClick(ClickEvent event) {\r\n\t\tObject sender = event.getSource();\r\n\t\tif (sender == addCommentBut) {\r\n\t\t\tif (!UserData.get().isLoggedIn()) {\r\n\t\t\t\tWindow.alert(\"You have to login first.\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n//\t\t\tif(!SolveAssignmentWidget.get().isAssignmentLoadedFromDB()) {\r\n//\t\t\t\tWindow.alert(\"This is a static assignment,\\n\" +\r\n//\t\t\t\t\t\t\"thus it is not loaded from the database\\n\" +\r\n//\t\t\t\t\t\t\"and comments cannot be submited.\");\r\n//\t\t\t\treturn;\r\n//\t\t\t}\r\n\t\t\tCommentAddDialog.get().center();\r\n\t\t}\r\n\t}\r\n}", "item_id": 0, "repo": "devng/ldbn", "file": "src/main/java/se/umu/cs/ldbn/client/ui/sa/CommentsWidget.java", "last_update_at": "2022-01-05T09:45:01+00:00", "question_id": "ac4b82f57514b08de7830bcaad91c5eac0044c1f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class CommentsWidget extends Composite implements ClickHandler {\r\n\r\n\tprivate static CommentsWidget inst;\r\n\r\n\tpublic static CommentsWidget get() {\r\n\t\tif (inst == null) {\r\n\t\t\tinst = new CommentsWidget();\r\n\t\t}\r\n\t\treturn inst;\r\n\t}\r\n\r\n\tprivate final class CommentEntry extends Composite implements MouseOutHandler, MouseOverHandler,\r\n\t    ClickHandler, LoginListener, CommentEditCallback {\r\n\r\n\t\tprivate VerticalPanel mainPanel;\r\n\t\tprivate Grid header;\r\n\t\tprivate HTML content;\r\n\t\tprivate HTML userName;\r\n\t\tprivate Label lastModified;\r\n\t\tprivate Image editButton;\r\n\t\tprivate Image deleteButton;\r\n\t\tprivate CommentListEntry cle;\r\n\t\tprivate boolean isToDelete;\r\n\t\tprivate String possibleText;\r\n\r\n\t\tpublic CommentEntry(CommentListEntry cle) {\r\n\t\t\tthis.cle = cle;\r\n\t\t\tisToDelete = false;\r\n\t\t\tmainPanel = new VerticalPanel();\r\n\t\t\tmainPanel.setStyleName(\"relW\");\r\n\t\t\tmainPanel.setWidth(\"100%\");\r\n\r\n\t\t\theader = new Grid(1, 5);\r\n\t\t\tCellFormatter cf = header.getCellFormatter();\r\n\t\t\theader.setStyleName(\"relW-header\");\r\n\r\n\r\n\t\t\tuserName = new HTML(\"<B>\"+cle.getAuthor()+\"</B>\");\r\n\t\t\theader.setWidget(0, 0, userName);\r\n\t\t\tcf.setWidth(0, 0, \"20\");\r\n\t\t\tcf.setAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT,\r\n\t\t\t\t\tHasVerticalAlignment.ALIGN_MIDDLE);\r\n\r\n\t\t\teditButton = new Image(\"img/edit-name.png\", 0, 0, 15, 15);\r\n\t\t\teditButton.addClickHandler(this);\r\n\t\t\teditButton.addMouseOutHandler(this);\r\n\t\t\teditButton.addMouseOverHandler(this);\r\n\t\t\teditButton.setTitle(\"Edit the comment.\");\r\n\t\t\tCommon.setCursorPointer(editButton);\r\n\t\t\theader.setWidget(0, 1, editButton);\r\n\t\t\tcf.setWidth(0, 1, \"20px\");\r\n\t\t\tcf.setAlignment(0, 1, HasHorizontalAlignment.ALIGN_LEFT,\r\n\t\t\t\t\tHasVerticalAlignment.ALIGN_MIDDLE);\r\n\r\n\t\t\tdeleteButton = new Image(\"img/bin.png\", 0, 0, 15, 15);\r\n\t\t\tdeleteButton.addClickHandler(this);\r\n\t\t\tdeleteButton.addMouseOutHandler(this);\r\n\t\t\tdeleteButton.setTitle(\"Delete the comment.\");\r\n\t\t\tCommon.setCursorPointer(deleteButton);\r\n\t\t\theader.setWidget(0, 2, deleteButton);\r\n\t\t\tcf.setWidth(0, 2, \"20px\");\r\n\t\t\tcf.setAlignment(0, 2, HasHorizontalAlignment.ALIGN_LEFT,\r\n\t\t\t\t\tHasVerticalAlignment.ALIGN_MIDDLE);\r\n\r\n\t\t\tlastModified = new Label(cle.getLastModified());\r\n\t\t\theader.setWidget(0, 4, lastModified);\r\n\t\t\tcf.setAlignment(0, 4, HasHorizontalAlignment.ALIGN_RIGHT,\r\n\t\t\t\t\tHasVerticalAlignment.ALIGN_MIDDLE);\r\n\r\n\t\t\tmainPanel.add(header);\r\n\r\n\t\t\tcontent = new HTML(cle.getCommentString());\r\n\t\t\tmainPanel.add(content);\r\n\r\n\t\t\tthis.initWidget(mainPanel);\r\n\t\t\tsetWidth(\"100%\");\r\n\t\t\tLogin.get().addListener(this);\r\n\r\n\t\t\teditButton.setVisible(false);\r\n\t\t\tdeleteButton.setVisible(false);\r\n\r\n\t\t\t//display edit and delete buttons only if the user is logged in\r\n\t\t\tif (UserData.get().isLoggedIn()) {\r\n\t\t\t\tString id = UserData.get().getId();\r\n\t\t\t\tboolean isAdmin = UserData.get().isAdmin();\r\n\t\t\t\tif (isAdmin || id.equals(cle.getAuthorID())) {\r\n\t\t\t\t\teditButton.setVisible(true);\r\n\t\t\t\t\tdeleteButton.setVisible(true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void onMouseOut(MouseOutEvent event) {\r\n\t\t\tObject sender = event.getSource();\r\n\t\t\tif (sender == deleteButton) {\r\n\t\t\t\tdeleteButton.setVisibleRect(0, 0, 15, 15);\r\n\t\t\t} else if (sender == editButton) {\r\n\t\t\t\teditButton.setVisibleRect(0, 0, 15, 15);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void onMouseOver(MouseOverEvent event) {\r\n\t\t\tObject sender = event.getSource();\r\n\t\t\tif (sender == deleteButton) {\r\n\t\t\t\tdeleteButton.setVisibleRect(15, 0, 15, 15);\r\n\t\t\t} else if (sender == editButton) {\r\n\t\t\t\teditButton.setVisibleRect(15, 0, 15, 15);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void onClick(ClickEvent event) {\r\n\t\t\tObject sender = event.getSource();\r\n\t\t\tif (sender == deleteButton) {\r\n\t\t\t\tif(Window.confirm(\"Are you sure you wan to delete the comment?\")) {\r\n\t\t\t\t\tCommentEdit ce = CommentEdit.get();\r\n\t\t\t\t\tisToDelete = true;\r\n\t\t\t\t\tce.send(this, cle.getId(), \"\", true);\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if (sender == editButton) {\r\n\t\t\t\tCommentEditDialog ced = CommentEditDialog.get(cle, this);\r\n\t\t\t\tced.center();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic void onLoginSuccess() {\r\n\t\t\tString id = UserData.get().getId();\r\n\t\t\tboolean isAdmin = UserData.get().isAdmin();\r\n\t\t\tif (isAdmin || id.equals(cle.getAuthorID())) {\r\n\t\t\t\teditButton.setVisible(true);\r\n\t\t\t\tdeleteButton.setVisible(true);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tpublic void onSessionKilled() {\r\n\t\t\teditButton.setVisible(false);\r\n\t\t\tdeleteButton.setVisible(false);\r\n\t\t}\r\n\r\n\r\n\t\tpublic void onReseive(boolean isOK) {\r\n\t\t\tif(isOK) {\r\n\t\t\t\tif (isToDelete) {\r\n\t\t\t\t\tremoveFromParent();\r\n\t\t\t\t\t//Login.get().removeListener(this);\r\n\t\t\t\t} else if (possibleText != null) {\r\n\t\t\t\t\tcontent.setHTML(Common.escapeHTMLCharacters(possibleText));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (isToDelete) {\r\n\t\t\t\t\tWindow.alert(\"The comment could not be deleted.\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tWindow.alert(\"The comment could not be edited.\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tpossibleText = null;\r\n\t\t\tisToDelete = false;\r\n\t\t}\r\n\r\n\t\tpublic void setPossibleCommentText(String str) {\r\n\t\t\tthis.possibleText = str;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate VerticalPanel mainPanel;\r\n\tprivate List<CommentEntry> entries;\r\n\tprivate Button addCommentBut;\r\n\r\n\tprivate CommentsWidget() {\r\n\t\tmainPanel = new VerticalPanel();\r\n\t\tHorizontalPanel hp = new HorizontalPanel();\r\n\t\thp.setVerticalAlignment(HasVerticalAlignment.ALIGN_MIDDLE);\r\n\t\taddCommentBut = new Button(\"Add new Comment\");\r\n\t\taddCommentBut.setStyleName(\"min-cov-but\");\r\n\t\taddCommentBut.addClickHandler(this);\r\n\t\thp.add(addCommentBut);\r\n\t\thp.add(new InfoButton(\"comment\"));\r\n\t\tmainPanel.add(hp);\r\n\t\tentries = new ArrayList<>();\r\n\t\tinitWidget(mainPanel);\r\n\t\tmainPanel.setSpacing(6);\r\n\t\tsetWidth(\"100%\");\r\n\t}\r\n\r\n\tpublic void clearData() {\r\n\t\tfor (CommentEntry cm : entries) {\r\n\t\t\tcm.removeFromParent();\r\n\t\t}\r\n\t\tentries.clear();\r\n\t}\r\n\r\n\tpublic void addComments(List<CommentListEntry> comments) {\r\n\t\tfor (CommentListEntry cle : comments) {\r\n\t\t\tCommentEntry c =  new CommentEntry(cle);\r\n\t\t\tmainPanel.add(c);\r\n\t\t\tentries.add(c);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void onClick(ClickEvent event) {\r\n\t\tObject sender = event.getSource();\r\n\t\tif (sender == addCommentBut) {\r\n\t\t\tif (!UserData.get().isLoggedIn()) {\r\n\t\t\t\tWindow.alert(\"You have to login first.\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n//\t\t\tif(!SolveAssignmentWidget.get().isAssignmentLoadedFromDB()) {\r\n//\t\t\t\tWindow.alert(\"This is a static assignment,\\n\" +\r\n//\t\t\t\t\t\t\"thus it is not loaded from the database\\n\" +\r\n//\t\t\t\t\t\t\"and comments cannot be submited.\");\r\n//\t\t\t\treturn;\r\n//\t\t\t}\r\n\t\t\tCommentAddDialog.get().center();\r\n\t\t}\r\n\t}\r\n"]], "pred": {"ppl": 1.6966205835342407, "ppl_lower": 1.867659568786621, "ppl/lowercase_ppl": -1.1816888491250954, "ppl/zlib": 0.00030173423547013244, "Min_5.0% Prob": 6.046011377783382, "Min_10.0% Prob": 4.186746825190151, "Min_20.0% Prob": 2.5258888714745935, "Min_30.0% Prob": 1.7486850942418077, "Min_40.0% Prob": 1.3190219344976553, "Min_50.0% Prob": 1.0576576374711764, "Min_60.0% Prob": 0.8820564651846214}}
{"hexsha": "a9cd3209edfafa6f8a0562f2f093883ddee7ae96", "ext": "java", "lang": "Java", "content": "class LinkedList{\n    Node head;\n    public void swapNodes(int x,int y){\n        if(x == y) return;\n        //look for x\n        Node prevX = null,currentX = head;\n        while(currentX != null && currentX.data != x){\n            prevX = currentX;\n            currentX = currentX.next;\n        }\n        //look for y\n        Node prevY = null,currentY = head;\n        while(currentY != null && currentY.data != y){\n            prevY = currentY;\n            currentY = currentY.next;\n        }\n        if(currentX == null || currentY == null) return;\n        // if x is not head,then make y the new head.\n        if(prevX != null)\n            prevX.next = currentY;\n        else\n            head = currentY;\n        // if y is not head,then make x the new head.\n        if(prevY != null)\n            prevY.next = currentX;\n        else\n            head = currentX;\n        // swap next pointers.\n        Node temp = currentX.next;\n        currentX.next = currentY.next;\n        currentY.next = temp;\n    }\n\n    public void insertNode(int item){\n        Node node = new Node(item);\n        node.next = head;\n        head = node; // move the head to point the next node\n    }\n\n    public void print(){\n        Node node = head;\n        while(node != null){\n            System.out.print(node.data + \" \");\n            node = node.next;\n        }\n        System.out.println();\n    }\n\n    public static void main(String args[]){\n        LinkedList llist = new LinkedList();\n        llist.insertNode(14);\n        llist.insertNode(20);\n        llist.insertNode(13);\n        llist.insertNode(12);\n        llist.insertNode(15);\n        llist.insertNode(10);\n        System.out.println(\"Before swap - \");\n        llist.print();\n        llist.swapNodes(12,20);\n        System.out.println(\"After swap - \");\n        llist.print();\n    }\n}", "item_id": 0, "repo": "Abhishekiyer97/code-playground", "file": "java/LinkedLists/SwapNodesWithoutSwappingData.java", "last_update_at": "2022-01-08T02:41:50+00:00", "question_id": "a9cd3209edfafa6f8a0562f2f093883ddee7ae96_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class LinkedList{\n    Node head;\n    public void swapNodes(int x,int y){\n        if(x == y) return;\n        //look for x\n        Node prevX = null,currentX = head;\n        while(currentX != null && currentX.data != x){\n            prevX = currentX;\n            currentX = currentX.next;\n        }\n        //look for y\n        Node prevY = null,currentY = head;\n        while(currentY != null && currentY.data != y){\n            prevY = currentY;\n            currentY = currentY.next;\n        }\n        if(currentX == null || currentY == null) return;\n        // if x is not head,then make y the new head.\n        if(prevX != null)\n            prevX.next = currentY;\n        else\n            head = currentY;\n        // if y is not head,then make x the new head.\n        if(prevY != null)\n            prevY.next = currentX;\n        else\n            head = currentX;\n        // swap next pointers.\n        Node temp = currentX.next;\n        currentX.next = currentY.next;\n        currentY.next = temp;\n    }\n    public void insertNode(int item){\n        Node node = new Node(item);\n        node.next = head;\n        head = node; // move the head to point the next node\n    }\n    public void print(){\n        Node node = head;\n        while(node != null){\n            System.out.print(node.data + \" \");\n            node = node.next;\n        }\n        System.out.println();\n    }\n    public static void main(String args[]){\n        LinkedList llist = new LinkedList();\n        llist.insertNode(14);\n        llist.insertNode(20);\n        llist.insertNode(13);\n        llist.insertNode(12);\n        llist.insertNode(15);\n        llist.insertNode(10);\n        System.out.println(\"Before swap - \");\n        llist.print();\n        llist.swapNodes(12,20);\n        System.out.println(\"After swap - \");\n        llist.print();\n    }\n"]], "pred": {"ppl": 1.547312617301941, "ppl_lower": 1.6458120346069336, "ppl/lowercase_ppl": -1.141377993638582, "ppl/zlib": 0.0008346455657351452, "Min_5.0% Prob": 4.722352239820692, "Min_10.0% Prob": 3.3156967714980796, "Min_20.0% Prob": 2.061897915822488, "Min_30.0% Prob": 1.429934064961142, "Min_40.0% Prob": 1.0861517573637818, "Min_50.0% Prob": 0.8696818532580269, "Min_60.0% Prob": 0.7266656252713157}}
{"hexsha": "da92e01aa58179a72fb9cac6c9d5d236561eb669", "ext": "java", "lang": "Java", "content": "public class AdR2ElementParserTest extends MarshallingTestCase {\r\n\r\n\t@Test\r\n\tpublic void testParseNullNode() throws Exception {\r\n\t\tNode node = createNode(\"<something nullFlavor=\\\"NI\\\" />\");\r\n\t\tAD ad = (AD) (new AdR2ElementParser()).parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertTrue(this.xmlResult.isValid());\r\n\t\tassertEquals(\"null returned\", null, ad.getValue());\r\n\t}\r\n\r\n\tprivate ParseContext createContext(String type, VersionNumber version) {\r\n\t\treturn ParseContextImpl.create(type, PostalAddress.class, version, null, null, ConformanceLevel.POPULATED, null, null, false);\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testParseEmptyNode() throws Exception {\r\n\t\tNode node = createNode(\"<something/>\");\r\n        AD ad = (AD) new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertTrue(this.xmlResult.isValid());\r\n        assertNotNull(\"empty node\", ad.getValue());\r\n        assertTrue(\"empty node value\", ad.getValue().getParts().isEmpty());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testParseTextNode() throws Exception {\r\n\t\tNode node = createNode(\"<something>text value</something>\");\r\n        AD ad = (AD) new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertTrue(this.xmlResult.isValid());\r\n\t\tassertEquals(\"correct number of parts\", 1, ad.getValue().getParts().size());\r\n        assertPostalAddressPartAsExpected(\"text node\", ad.getValue().getParts().get(0), null, \"text value\");\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void testParseTextNodeWithAttributes() throws Exception {\r\n\t\tNode node = createNode(\"<something representation=\\\"TXT\\\" mediaType=\\\"text/plain\\\">text value</something>\");\r\n        AD ad = (AD) new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertTrue(this.xmlResult.isValid());\r\n\t\tassertEquals(\"correct number of parts\", 1, ad.getValue().getParts().size());\r\n\t\tassertNull(ad.getValue().getIsNotOrdered());\r\n        assertPostalAddressPartAsExpected(\"text node with attributes\", ad.getValue().getParts().get(0), null, \"text value\");\r\n\t}\r\n\r\n\t@Test\r\n    public void testParseAll() throws Exception {\r\n\t\tDate useable1 = DateUtil.getDate(2008, 5, 25, 0, 0, 0, 0);\r\n\t\tDate useable2 = DateUtil.getDate(2012, 8, 3, 0, 0, 0, 0);\r\n\r\n        Node node = createNode(\r\n                  \"<something isNotOrdered=\\\"true\\\"> \" +\r\n\t                  \"<city>city name</city>\" +\r\n\t                  \"freeform\" +\r\n\t                  \"<delimiter>,</delimiter>\" +\r\n\t                  \"\\n\" +\r\n\t                  \"<state>Ontario</state>\" +\r\n\t                  \"<useablePeriod operator=\\\"P\\\" value=\\\"20080625\\\" />\" +\r\n\t                  \"<useablePeriod value=\\\"20120903\\\" />\" +\r\n                  \"</something>\");\r\n        \r\n        AD ad = (AD) new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertTrue(this.xmlResult.isValid());\r\n        \r\n        PostalAddress postalAddress = ad.getValue();\r\n        \r\n        assertEquals(\"number of name uses\", 0, postalAddress.getUses().size());\r\n        assertEquals(\"number of name parts\", 4, postalAddress.getParts().size());\r\n        assertEquals(\"number of useablePeriods\", 2, postalAddress.getUseablePeriods().size());\r\n        \r\n        assertTrue((boolean)ad.getValue().getIsNotOrdered()); //cast for .NET translation\r\n        \r\n        assertPostalAddressPartAsExpected(\"city\", postalAddress.getParts().get(0), PostalAddressPartType.CITY, \"city name\");\r\n        assertPostalAddressPartAsExpected(\"free\", postalAddress.getParts().get(1), null, \"freeform\");\r\n        assertPostalAddressPartAsExpected(\"delimiter comma\", postalAddress.getParts().get(2), PostalAddressPartType.DELIMITER, \",\");\r\n        assertPostalAddressPartAsExpected(\"state\", postalAddress.getParts().get(3), PostalAddressPartType.STATE, \"Ontario\");\r\n        \r\n        assertTrue(postalAddress.getUseablePeriods().containsKey(useable1));\r\n        assertEquals(SetOperator.PERIODIC_HULL, postalAddress.getUseablePeriods().get(useable1));\r\n        \r\n        assertTrue(postalAddress.getUseablePeriods().containsKey(useable2));\r\n        assertEquals(SetOperator.INCLUDE, postalAddress.getUseablePeriods().get(useable2));\r\n    }\r\n\r\n\t@Test\r\n    public void testParseUseablePeriodOutOfOrder() throws Exception {\r\n\t\tDate useable1 = DateUtil.getDate(2008, 5, 25, 0, 0, 0, 0);\r\n\t\tDate useable2 = DateUtil.getDate(2012, 8, 3, 0, 0, 0, 0);\r\n\r\n        Node node = createNode(\r\n                  \"<something isNotOrdered=\\\"true\\\"> \" +\r\n\t                  \"<city>city name</city>\" +\r\n\t                  \"freeform\" +\r\n\t                  \"<useablePeriod operator=\\\"P\\\" value=\\\"20080625\\\" />\" +\r\n\t                  \"<delimiter>,</delimiter>\" +\r\n\t                  \"\\n\" +\r\n\t                  \"<state>Ontario</state>\" +\r\n\t                  \"<useablePeriod value=\\\"20120903\\\" />\" +\r\n                  \"</something>\");\r\n        \r\n        AD ad = (AD) new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertFalse(this.xmlResult.isValid());\r\n\t\tassertEquals(1, this.xmlResult.getHl7Errors().size());\r\n        \r\n        PostalAddress postalAddress = ad.getValue();\r\n        \r\n        assertEquals(\"number of name uses\", 0, postalAddress.getUses().size());\r\n        assertEquals(\"number of name parts\", 4, postalAddress.getParts().size());\r\n        assertEquals(\"number of useablePeriods\", 2, postalAddress.getUseablePeriods().size());\r\n        \r\n        assertTrue((boolean)ad.getValue().getIsNotOrdered());//cast for .NET translation\r\n        \r\n        assertPostalAddressPartAsExpected(\"city\", postalAddress.getParts().get(0), PostalAddressPartType.CITY, \"city name\");\r\n        assertPostalAddressPartAsExpected(\"free\", postalAddress.getParts().get(1), null, \"freeform\");\r\n        assertPostalAddressPartAsExpected(\"delimiter comma\", postalAddress.getParts().get(2), PostalAddressPartType.DELIMITER, \",\");\r\n        assertPostalAddressPartAsExpected(\"state\", postalAddress.getParts().get(3), PostalAddressPartType.STATE, \"Ontario\");\r\n        \r\n        assertTrue(postalAddress.getUseablePeriods().containsKey(useable1));\r\n        assertEquals(SetOperator.PERIODIC_HULL, postalAddress.getUseablePeriods().get(useable1));\r\n        \r\n        assertTrue(postalAddress.getUseablePeriods().containsKey(useable2));\r\n        assertEquals(SetOperator.INCLUDE, postalAddress.getUseablePeriods().get(useable2));\r\n    }\r\n\t\r\n\t@Test\r\n    public void testParseFailure() throws Exception {\r\n        Node node = createNode(\"<something><monkey>prefix 1</monkey>Organization name<delimiter>,</delimiter><suffix>Inc</suffix></something>\");\r\n        \r\n        new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n        assertFalse(this.xmlResult.isValid());\r\n        assertEquals(\"message\", \"Address part type not valid: monkey (<monkey>)\", this.xmlResult.getHl7Errors().get(0).getMessage());\r\n    }\r\n    \r\n    private void assertPostalAddressPartAsExpected(String message, PostalAddressPart postalAddressPart, PostalAddressPartType expectedType, String expectedValue) {\r\n        assertEquals(message + \" type\", expectedType, postalAddressPart.getType());\r\n        assertEquals(message + \" value\", expectedValue, postalAddressPart.getValue());\r\n    }\r\n    \r\n\t@Test\r\n    public void testUsesNoUse() throws Exception {\r\n        Node node = createNode(\"<something/>\");\r\n        AD ad = (AD) new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertTrue(this.xmlResult.isValid());\r\n        assertEquals(\"zero uses\", 0, ad.getValue().getUses().size());\r\n    }\r\n    \r\n\t@Test\r\n    public void testUsesOneUse() throws Exception {\r\n        Node node = createNode(\"<something use=\\\"H\\\"/>\");\r\n        AD ad = (AD) new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertTrue(this.xmlResult.isValid());\r\n        assertEquals(\"one use\", 1, ad.getValue().getUses().size());\r\n        Iterator<ca.infoway.messagebuilder.domainvalue.PostalAddressUse> iterator = ad.getValue().getUses().iterator();\r\n        if (iterator.hasNext()) { //.NET\r\n        \tassertTrue(\"contains HOME use\", iterator.next().getCodeValue().equals(PostalAddressUse.HOME.getCodeValue()));\r\n        }\r\n    }\r\n    \r\n\t@Test\r\n    public void testUsesMultipleUses() throws Exception {\r\n        Node node = createNode(\"<something use=\\\"H PHYS PST\\\"/>\");\r\n        AD ad = (AD) new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertTrue(this.xmlResult.isValid());\r\n        \r\n\t\tSet<String> uses = new HashSet<String>();\r\n        PostalAddress postalAddress = ad.getValue();\r\n\t\tfor (ca.infoway.messagebuilder.domainvalue.PostalAddressUse postalAddressUse : postalAddress.getUses()) {\r\n\t\t\tuses.add(postalAddressUse.getCodeValue());\r\n\t\t}\r\n\t\t\r\n\t\tassertEquals(\"three uses\", 3, postalAddress.getUses().size());\r\n        assertTrue(\"contains HOME use\", uses.contains(X_BasicPostalAddressUse.HOME.getCodeValue()));\r\n        assertTrue(\"contains PHYS use\", uses.contains(X_BasicPostalAddressUse.PHYSICAL.getCodeValue()));\r\n        assertTrue(\"contains POSTAL use\", uses.contains(X_BasicPostalAddressUse.POSTAL.getCodeValue()));\r\n    }\r\n    \r\n\t@Test\r\n    public void testUsesUnknownUse() throws Exception {\r\n        Node node = createNode(\"<something use=\\\"XXX\\\"/>\");\r\n        AD ad = (AD) new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertFalse(this.xmlResult.isValid());\r\n\t\tassertEquals(1, this.xmlResult.getHl7Errors().size());\r\n\t\tassertEquals(\"no uses\", 0, ad.getValue().getUses().size());\r\n    }\r\n}", "item_id": 0, "repo": "CanadaHealthInfoway/message-builder", "file": "message-builder-core/src/test/java/ca/infoway/messagebuilder/marshalling/hl7/parser/r2/AdR2ElementParserTest.java", "last_update_at": "2022-03-09T12:17:41+00:00", "question_id": "da92e01aa58179a72fb9cac6c9d5d236561eb669_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AdR2ElementParserTest extends MarshallingTestCase {\r\n\r\n\t@Test\r\n\tpublic void testParseNullNode() throws Exception {\r\n\t\tNode node = createNode(\"<something nullFlavor=\\\"NI\\\" />\");\r\n\t\tAD ad = (AD) (new AdR2ElementParser()).parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertTrue(this.xmlResult.isValid());\r\n\t\tassertEquals(\"null returned\", null, ad.getValue());\r\n\t}\r\n\r\n\tprivate ParseContext createContext(String type, VersionNumber version) {\r\n\t\treturn ParseContextImpl.create(type, PostalAddress.class, version, null, null, ConformanceLevel.POPULATED, null, null, false);\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testParseEmptyNode() throws Exception {\r\n\t\tNode node = createNode(\"<something/>\");\r\n        AD ad = (AD) new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertTrue(this.xmlResult.isValid());\r\n        assertNotNull(\"empty node\", ad.getValue());\r\n        assertTrue(\"empty node value\", ad.getValue().getParts().isEmpty());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testParseTextNode() throws Exception {\r\n\t\tNode node = createNode(\"<something>text value</something>\");\r\n        AD ad = (AD) new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertTrue(this.xmlResult.isValid());\r\n\t\tassertEquals(\"correct number of parts\", 1, ad.getValue().getParts().size());\r\n        assertPostalAddressPartAsExpected(\"text node\", ad.getValue().getParts().get(0), null, \"text value\");\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void testParseTextNodeWithAttributes() throws Exception {\r\n\t\tNode node = createNode(\"<something representation=\\\"TXT\\\" mediaType=\\\"text/plain\\\">text value</something>\");\r\n        AD ad = (AD) new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertTrue(this.xmlResult.isValid());\r\n\t\tassertEquals(\"correct number of parts\", 1, ad.getValue().getParts().size());\r\n\t\tassertNull(ad.getValue().getIsNotOrdered());\r\n        assertPostalAddressPartAsExpected(\"text node with attributes\", ad.getValue().getParts().get(0), null, \"text value\");\r\n\t}\r\n\r\n\t@Test\r\n    public void testParseAll() throws Exception {\r\n\t\tDate useable1 = DateUtil.getDate(2008, 5, 25, 0, 0, 0, 0);\r\n\t\tDate useable2 = DateUtil.getDate(2012, 8, 3, 0, 0, 0, 0);\r\n\r\n        Node node = createNode(\r\n                  \"<something isNotOrdered=\\\"true\\\"> \" +\r\n\t                  \"<city>city name</city>\" +\r\n\t                  \"freeform\" +\r\n\t                  \"<delimiter>,</delimiter>\" +\r\n\t                  \"\\n\" +\r\n\t                  \"<state>Ontario</state>\" +\r\n\t                  \"<useablePeriod operator=\\\"P\\\" value=\\\"20080625\\\" />\" +\r\n\t                  \"<useablePeriod value=\\\"20120903\\\" />\" +\r\n                  \"</something>\");\r\n        \r\n        AD ad = (AD) new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertTrue(this.xmlResult.isValid());\r\n        \r\n        PostalAddress postalAddress = ad.getValue();\r\n        \r\n        assertEquals(\"number of name uses\", 0, postalAddress.getUses().size());\r\n        assertEquals(\"number of name parts\", 4, postalAddress.getParts().size());\r\n        assertEquals(\"number of useablePeriods\", 2, postalAddress.getUseablePeriods().size());\r\n        \r\n        assertTrue((boolean)ad.getValue().getIsNotOrdered()); //cast for .NET translation\r\n        \r\n        assertPostalAddressPartAsExpected(\"city\", postalAddress.getParts().get(0), PostalAddressPartType.CITY, \"city name\");\r\n        assertPostalAddressPartAsExpected(\"free\", postalAddress.getParts().get(1), null, \"freeform\");\r\n        assertPostalAddressPartAsExpected(\"delimiter comma\", postalAddress.getParts().get(2), PostalAddressPartType.DELIMITER, \",\");\r\n        assertPostalAddressPartAsExpected(\"state\", postalAddress.getParts().get(3), PostalAddressPartType.STATE, \"Ontario\");\r\n        \r\n        assertTrue(postalAddress.getUseablePeriods().containsKey(useable1));\r\n        assertEquals(SetOperator.PERIODIC_HULL, postalAddress.getUseablePeriods().get(useable1));\r\n        \r\n        assertTrue(postalAddress.getUseablePeriods().containsKey(useable2));\r\n        assertEquals(SetOperator.INCLUDE, postalAddress.getUseablePeriods().get(useable2));\r\n    }\r\n\r\n\t@Test\r\n    public void testParseUseablePeriodOutOfOrder() throws Exception {\r\n\t\tDate useable1 = DateUtil.getDate(2008, 5, 25, 0, 0, 0, 0);\r\n\t\tDate useable2 = DateUtil.getDate(2012, 8, 3, 0, 0, 0, 0);\r\n\r\n        Node node = createNode(\r\n                  \"<something isNotOrdered=\\\"true\\\"> \" +\r\n\t                  \"<city>city name</city>\" +\r\n\t                  \"freeform\" +\r\n\t                  \"<useablePeriod operator=\\\"P\\\" value=\\\"20080625\\\" />\" +\r\n\t                  \"<delimiter>,</delimiter>\" +\r\n\t                  \"\\n\" +\r\n\t                  \"<state>Ontario</state>\" +\r\n\t                  \"<useablePeriod value=\\\"20120903\\\" />\" +\r\n                  \"</something>\");\r\n        \r\n        AD ad = (AD) new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertFalse(this.xmlResult.isValid());\r\n\t\tassertEquals(1, this.xmlResult.getHl7Errors().size());\r\n        \r\n        PostalAddress postalAddress = ad.getValue();\r\n        \r\n        assertEquals(\"number of name uses\", 0, postalAddress.getUses().size());\r\n        assertEquals(\"number of name parts\", 4, postalAddress.getParts().size());\r\n        assertEquals(\"number of useablePeriods\", 2, postalAddress.getUseablePeriods().size());\r\n        \r\n        assertTrue((boolean)ad.getValue().getIsNotOrdered());//cast for .NET translation\r\n        \r\n        assertPostalAddressPartAsExpected(\"city\", postalAddress.getParts().get(0), PostalAddressPartType.CITY, \"city name\");\r\n        assertPostalAddressPartAsExpected(\"free\", postalAddress.getParts().get(1), null, \"freeform\");\r\n        assertPostalAddressPartAsExpected(\"delimiter comma\", postalAddress.getParts().get(2), PostalAddressPartType.DELIMITER, \",\");\r\n        assertPostalAddressPartAsExpected(\"state\", postalAddress.getParts().get(3), PostalAddressPartType.STATE, \"Ontario\");\r\n        \r\n        assertTrue(postalAddress.getUseablePeriods().containsKey(useable1));\r\n        assertEquals(SetOperator.PERIODIC_HULL, postalAddress.getUseablePeriods().get(useable1));\r\n        \r\n        assertTrue(postalAddress.getUseablePeriods().containsKey(useable2));\r\n        assertEquals(SetOperator.INCLUDE, postalAddress.getUseablePeriods().get(useable2));\r\n    }\r\n\t\r\n\t@Test\r\n    public void testParseFailure() throws Exception {\r\n        Node node = createNode(\"<something><monkey>prefix 1</monkey>Organization name<delimiter>,</delimiter><suffix>Inc</suffix></something>\");\r\n        \r\n        new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n        assertFalse(this.xmlResult.isValid());\r\n        assertEquals(\"message\", \"Address part type not valid: monkey (<monkey>)\", this.xmlResult.getHl7Errors().get(0).getMessage());\r\n    }\r\n    \r\n    private void assertPostalAddressPartAsExpected(String message, PostalAddressPart postalAddressPart, PostalAddressPartType expectedType, String expectedValue) {\r\n        assertEquals(message + \" type\", expectedType, postalAddressPart.getType());\r\n        assertEquals(message + \" value\", expectedValue, postalAddressPart.getValue());\r\n    }\r\n    \r\n\t@Test\r\n    public void testUsesNoUse() throws Exception {\r\n        Node node = createNode(\"<something/>\");\r\n        AD ad = (AD) new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertTrue(this.xmlResult.isValid());\r\n        assertEquals(\"zero uses\", 0, ad.getValue().getUses().size());\r\n    }\r\n    \r\n\t@Test\r\n    public void testUsesOneUse() throws Exception {\r\n        Node node = createNode(\"<something use=\\\"H\\\"/>\");\r\n        AD ad = (AD) new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertTrue(this.xmlResult.isValid());\r\n        assertEquals(\"one use\", 1, ad.getValue().getUses().size());\r\n        Iterator<ca.infoway.messagebuilder.domainvalue.PostalAddressUse> iterator = ad.getValue().getUses().iterator();\r\n        if (iterator.hasNext()) { //.NET\r\n        \tassertTrue(\"contains HOME use\", iterator.next().getCodeValue().equals(PostalAddressUse.HOME.getCodeValue()));\r\n        }\r\n    }\r\n    \r\n\t@Test\r\n    public void testUsesMultipleUses() throws Exception {\r\n        Node node = createNode(\"<something use=\\\"H PHYS PST\\\"/>\");\r\n        AD ad = (AD) new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertTrue(this.xmlResult.isValid());\r\n        \r\n\t\tSet<String> uses = new HashSet<String>();\r\n        PostalAddress postalAddress = ad.getValue();\r\n\t\tfor (ca.infoway.messagebuilder.domainvalue.PostalAddressUse postalAddressUse : postalAddress.getUses()) {\r\n\t\t\tuses.add(postalAddressUse.getCodeValue());\r\n\t\t}\r\n\t\t\r\n\t\tassertEquals(\"three uses\", 3, postalAddress.getUses().size());\r\n        assertTrue(\"contains HOME use\", uses.contains(X_BasicPostalAddressUse.HOME.getCodeValue()));\r\n        assertTrue(\"contains PHYS use\", uses.contains(X_BasicPostalAddressUse.PHYSICAL.getCodeValue()));\r\n        assertTrue(\"contains POSTAL use\", uses.contains(X_BasicPostalAddressUse.POSTAL.getCodeValue()));\r\n    }\r\n    \r\n\t@Test\r\n    public void testUsesUnknownUse() throws Exception {\r\n        Node node = createNode(\"<something use=\\\"XXX\\\"/>\");\r\n        AD ad = (AD) new AdR2ElementParser().parse(createContext(\"AD\", V02R02), node, this.xmlResult);\r\n\t\tassertFalse(this.xmlResult.isValid());\r\n\t\tassertEquals(1, this.xmlResult.getHl7Errors().size());\r\n\t\tassertEquals(\"no uses\", 0, ad.getValue().getUses().size());\r\n    }\r\n"]], "pred": {"ppl": 1.6816143989562988, "ppl_lower": 2.084460496902466, "ppl/lowercase_ppl": -1.413187135229473, "ppl/zlib": 0.0003210341468538011, "Min_5.0% Prob": 5.802039487689149, "Min_10.0% Prob": 4.156921247641246, "Min_20.0% Prob": 2.48230447152666, "Min_30.0% Prob": 1.7117128725973219, "Min_40.0% Prob": 1.2934889014864974, "Min_50.0% Prob": 1.0387453620856055, "Min_60.0% Prob": 0.8669601403591549}}
{"hexsha": "8d736cfbdb7f0b903c51d0664b74557bb2115a86", "ext": "java", "lang": "Java", "content": "class FXOMRefresher {\n\n    public void refresh(FXOMDocument document) {\n        String fxmlText = null;\n        try {\n            fxmlText = document.getFxmlText(false);\n            final FXOMDocument newDocument\n                    = new FXOMDocument(fxmlText,\n                    document.getLocation(),\n                    document.getClassLoader(),\n                    document.getResources(),\n                    false /* normalized */);\n            final TransientStateBackup backup = new TransientStateBackup(document);\n            // if the refresh should not take place (e.g. due to an error), remove a property from intrinsic\n            if (newDocument.getSceneGraphRoot() == null && newDocument.getFxomRoot() == null) {\n                removeIntrinsicProperty(document);\n            } else {\n                refreshDocument(document, newDocument);\n            }\n            backup.restore();\n            synchronizeDividerPositions(document);\n        } catch (RuntimeException | IOException x) {\n            final StringBuilder sb = new StringBuilder();\n            sb.append(\"Bug in \");\n            sb.append(getClass().getSimpleName());\n            if (fxmlText != null) {\n                try {\n                    final File fxmlFile = File.createTempFile(\"DTL-5996-\", \".fxml\");\n                    try (PrintWriter pw = new PrintWriter(fxmlFile, \"UTF-8\")) {\n                        pw.write(fxmlText);\n                        sb.append(\": FXML dumped in \");\n                        sb.append(fxmlFile.getPath());\n                    }\n                } catch (IOException xx) {\n                    sb.append(\": no FXML dumped\");\n                }\n            } else {\n                sb.append(\": no FXML dumped\");\n            }\n            throw new IllegalStateException(sb.toString(), x);\n        }\n    }\n\n    private void removeIntrinsicProperty(FXOMDocument document) {\n        FXOMInstance fxomRoot = (FXOMInstance) document.getFxomRoot();\n        if (fxomRoot != null) {\n            FXOMPropertyC propertyC = (FXOMPropertyC) fxomRoot.getProperties().get(new PropertyName(\"children\"));\n            if (propertyC.getValues().get(0) instanceof FXOMIntrinsic) {\n                FXOMIntrinsic fxomIntrinsic = (FXOMIntrinsic) propertyC.getValues().get(0);\n                fxomIntrinsic.removeCharsetProperty();\n            }\n        }\n    }\n\n    /*\n     * Private (stylesheet)\n     */\n\n    private void refreshDocument(FXOMDocument currentDocument, FXOMDocument newDocument) {\n        // Transfers scene graph object from newDocument to currentDocument\n        currentDocument.setSceneGraphRoot(newDocument.getSceneGraphRoot());\n        // Transfers display node from newDocument to currentDocument\n        currentDocument.setDisplayNode(newDocument.getDisplayNode());\n        // Transfers display stylesheets from newDocument to currentDocument\n        currentDocument.setDisplayStylesheets(newDocument.getDisplayStylesheets());\n        // Simulates Scene's behavior : automatically adds \"root\" styleclass if\n        // if the scene graph root is a Parent instance or wraps a Parent instance\n        if (currentDocument.getSceneGraphRoot() instanceof Parent) {\n            final Parent rootParent = (Parent) currentDocument.getSceneGraphRoot();\n            rootParent.getStyleClass().add(0, \"root\");\n        } else if (currentDocument.getSceneGraphRoot() instanceof Scene\n                || currentDocument.getSceneGraphRoot() instanceof Window) {\n            Node displayNode = currentDocument.getDisplayNode();\n            if (displayNode != null && displayNode instanceof Parent) {\n                displayNode.getStyleClass().add(0, \"root\");\n            }\n        }\n        // Recurses\n        if (currentDocument.getFxomRoot() != null) {\n            refreshFxomObject(currentDocument.getFxomRoot(), newDocument.getFxomRoot());\n        }\n    }\n\n\n    private void refreshFxomObject(FXOMObject currentObject, FXOMObject newObject) {\n        assert currentObject != null;\n        assert newObject != null;\n        assert currentObject.getClass() == newObject.getClass();\n        currentObject.setSceneGraphObject(newObject.getSceneGraphObject());\n        if (currentObject instanceof FXOMInstance) {\n            refreshFxomInstance((FXOMInstance) currentObject, (FXOMInstance) newObject);\n        } else if (currentObject instanceof FXOMCollection) {\n            refreshFxomCollection((FXOMCollection) currentObject, (FXOMCollection) newObject);\n        } else if (currentObject instanceof FXOMIntrinsic) {\n            refreshFxomIntrinsic((FXOMIntrinsic) currentObject, (FXOMIntrinsic) newObject);\n        } else {\n            assert false : \"Unexpected fxom object \" + currentObject;\n        }\n\n//        assert currentObject.equals(newObject) : \"currentValue=\" + currentObject +\n//                                               \"  newValue=\" + newObject;\n    }\n\n\n    private void refreshFxomInstance(FXOMInstance currentInstance, FXOMInstance newInstance) {\n        assert currentInstance != null;\n        assert newInstance != null;\n        assert currentInstance.getClass() == newInstance.getClass();\n        currentInstance.setDeclaredClass(newInstance.getDeclaredClass());\n        final Set<PropertyName> currentNames = currentInstance.getProperties().keySet();\n        final Set<PropertyName> newNames = newInstance.getProperties().keySet();\n        assert currentNames.equals(newNames);\n        for (PropertyName name : currentNames) {\n            final FXOMProperty currentProperty = currentInstance.getProperties().get(name);\n            final FXOMProperty newProperty = newInstance.getProperties().get(name);\n            refreshFxomProperty(currentProperty, newProperty);\n        }\n    }\n\n    private void refreshFxomCollection(FXOMCollection currentCollection, FXOMCollection newCollection) {\n        assert currentCollection != null;\n        assert newCollection != null;\n        currentCollection.setDeclaredClass(newCollection.getDeclaredClass());\n        refreshFxomObjects(currentCollection.getItems(), newCollection.getItems());\n    }\n\n    private void refreshFxomIntrinsic(FXOMIntrinsic currentIntrinsic, FXOMIntrinsic newIntrinsic) {\n        assert currentIntrinsic != null;\n        assert newIntrinsic != null;\n        currentIntrinsic.setSourceSceneGraphObject(newIntrinsic.getSourceSceneGraphObject());\n        currentIntrinsic.getProperties().clear();\n        currentIntrinsic.fillProperties(newIntrinsic.getProperties());\n    }\n\n    private void refreshFxomProperty(FXOMProperty currentProperty, FXOMProperty newProperty) {\n        assert currentProperty != null;\n        assert newProperty != null;\n        assert currentProperty.getName().equals(newProperty.getName());\n        if (currentProperty instanceof FXOMPropertyT) {\n            assert newProperty instanceof FXOMPropertyT;\n            assert ((FXOMPropertyT) currentProperty).getValue().equals(((FXOMPropertyT) newProperty).getValue());\n        } else {\n            assert currentProperty instanceof FXOMPropertyC;\n            assert newProperty instanceof FXOMPropertyC;\n            final FXOMPropertyC currentPC = (FXOMPropertyC) currentProperty;\n            final FXOMPropertyC newPC = (FXOMPropertyC) newProperty;\n            refreshFxomObjects(currentPC.getValues(), newPC.getValues());\n        }\n    }\n\n\n    private void refreshFxomObjects(List<FXOMObject> currentObjects, List<FXOMObject> newObjects) {\n        assert currentObjects != null;\n        assert newObjects != null;\n        assert currentObjects.size() == newObjects.size();\n        for (int i = 0, count = currentObjects.size(); i < count; i++) {\n            final FXOMObject currentObject = currentObjects.get(i);\n            final FXOMObject newObject = newObjects.get(i);\n            if (currentObject instanceof FXOMIntrinsic || newObject instanceof FXOMIntrinsic) {\n                handleRefreshIntrinsic(currentObject, newObject);\n            } else {\n                refreshFxomObject(currentObject, newObject);\n            }\n        }\n    }\n\n    private void handleRefreshIntrinsic(FXOMObject currentObject, FXOMObject newObject) {\n        if (currentObject instanceof FXOMIntrinsic && newObject instanceof FXOMIntrinsic) {\n            refreshFxomObject(currentObject, newObject);\n        } else if (newObject instanceof FXOMIntrinsic) {\n            FXOMInstance fxomInstance = getFxomInstance((FXOMIntrinsic) newObject);\n            refreshFxomObject(currentObject, fxomInstance);\n        } else if (currentObject instanceof FXOMIntrinsic) {\n            FXOMInstance fxomInstance = getFxomInstance((FXOMIntrinsic) currentObject);\n            refreshFxomObject(fxomInstance, newObject);\n        }\n    }\n\n    private FXOMInstance getFxomInstance(FXOMIntrinsic intrinsic) {\n        FXOMInstance fxomInstance = new FXOMInstance(intrinsic.getFxomDocument(), intrinsic.getGlueElement());\n        fxomInstance.setSceneGraphObject(intrinsic.getSourceSceneGraphObject());\n        fxomInstance.setDeclaredClass(intrinsic.getClass());\n        if (!intrinsic.getProperties().isEmpty()) {\n            fxomInstance.fillProperties(intrinsic.getProperties());\n        }\n        return fxomInstance;\n    }\n    \n    /*\n     * The case of SplitPane.dividerPositions property\n     * -----------------------------------------------\n     * \n     * When user adds a child to a SplitPane, this adds a new entry in\n     * SplitPane.children property but also adds a new value to \n     * SplitPane.dividerPositions by side-effect.\n     * \n     * The change in SplitPane.dividerPositions is performed at scene graph\n     * level by FX. Thus it is unseen by FXOM. \n     * \n     * So in that case we perform a special operation which copies value of \n     * SplitPane.dividerPositions into FXOMProperty representing \n     * dividerPositions in FXOM.\n     */\n\n    private void synchronizeDividerPositions(FXOMDocument document) {\n        final FXOMObject fxomRoot = document.getFxomRoot();\n        if (fxomRoot != null) {\n            final Metadata metadata\n                    = Metadata.getMetadata();\n            final PropertyName dividerPositionsName\n                    = new PropertyName(\"dividerPositions\");\n            final List<FXOMObject> candidates\n                    = fxomRoot.collectObjectWithSceneGraphObjectClass(SplitPane.class);\n\n            for (FXOMObject fxomObject : candidates) {\n                if (fxomObject instanceof FXOMInstance) {\n                    final FXOMInstance fxomInstance = (FXOMInstance) fxomObject;\n                    assert fxomInstance.getSceneGraphObject() instanceof SplitPane;\n                    final SplitPane splitPane\n                            = (SplitPane) fxomInstance.getSceneGraphObject();\n                    splitPane.layout();\n                    final ValuePropertyMetadata vpm\n                            = metadata.queryValueProperty(fxomInstance, dividerPositionsName);\n                    assert vpm instanceof ListValuePropertyMetadata\n                            : \"vpm.getClass()=\" + vpm.getClass().getSimpleName();\n                    final DoubleArrayPropertyMetadata davpm\n                            = (DoubleArrayPropertyMetadata) vpm;\n                    davpm.synchronizeWithSceneGraphObject(fxomInstance);\n                }\n            }\n        }\n    }\n\n\n//    \n//    \n//    private void reloadStylesheets(final Parent p) {\n//        assert p != null;\n//        assert p.getScene() != null;\n//        \n//        if (p.getStylesheets().isEmpty() == false) {\n//            final List<String> stylesheets = new ArrayList<>();\n//            stylesheets.addAll(p.getStylesheets());\n////            p.getStylesheets().clear();\n////            p.impl_processCSS(true);\n//            p.getStylesheets().setAll(stylesheets);\n////            p.impl_processCSS(true);\n//        }\n//        for (Node child : p.getChildrenUnmodifiable()) {\n//            if (child instanceof Parent) {\n//                reloadStylesheets((Parent)child);\n//            }\n//        }\n//        \n//    }\n}", "item_id": 0, "repo": "ballgle/scenebuilder", "file": "kit/src/main/java/com/oracle/javafx/scenebuilder/kit/fxom/FXOMRefresher.java", "last_update_at": "2022-03-30T16:17:24+00:00", "question_id": "8d736cfbdb7f0b903c51d0664b74557bb2115a86_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class FXOMRefresher {\n    public void refresh(FXOMDocument document) {\n        String fxmlText = null;\n        try {\n            fxmlText = document.getFxmlText(false);\n            final FXOMDocument newDocument\n                    = new FXOMDocument(fxmlText,\n                    document.getLocation(),\n                    document.getClassLoader(),\n                    document.getResources(),\n                    false /* normalized */);\n            final TransientStateBackup backup = new TransientStateBackup(document);\n            // if the refresh should not take place (e.g. due to an error), remove a property from intrinsic\n            if (newDocument.getSceneGraphRoot() == null && newDocument.getFxomRoot() == null) {\n                removeIntrinsicProperty(document);\n            } else {\n                refreshDocument(document, newDocument);\n            }\n            backup.restore();\n            synchronizeDividerPositions(document);\n        } catch (RuntimeException | IOException x) {\n            final StringBuilder sb = new StringBuilder();\n            sb.append(\"Bug in \");\n            sb.append(getClass().getSimpleName());\n            if (fxmlText != null) {\n                try {\n                    final File fxmlFile = File.createTempFile(\"DTL-5996-\", \".fxml\");\n                    try (PrintWriter pw = new PrintWriter(fxmlFile, \"UTF-8\")) {\n                        pw.write(fxmlText);\n                        sb.append(\": FXML dumped in \");\n                        sb.append(fxmlFile.getPath());\n                    }\n                } catch (IOException xx) {\n                    sb.append(\": no FXML dumped\");\n                }\n            } else {\n                sb.append(\": no FXML dumped\");\n            }\n            throw new IllegalStateException(sb.toString(), x);\n        }\n    }\n    private void removeIntrinsicProperty(FXOMDocument document) {\n        FXOMInstance fxomRoot = (FXOMInstance) document.getFxomRoot();\n        if (fxomRoot != null) {\n            FXOMPropertyC propertyC = (FXOMPropertyC) fxomRoot.getProperties().get(new PropertyName(\"children\"));\n            if (propertyC.getValues().get(0) instanceof FXOMIntrinsic) {\n                FXOMIntrinsic fxomIntrinsic = (FXOMIntrinsic) propertyC.getValues().get(0);\n                fxomIntrinsic.removeCharsetProperty();\n            }\n        }\n    }\n    /*\n     * Private (stylesheet)\n     */\n    private void refreshDocument(FXOMDocument currentDocument, FXOMDocument newDocument) {\n        // Transfers scene graph object from newDocument to currentDocument\n        currentDocument.setSceneGraphRoot(newDocument.getSceneGraphRoot());\n        // Transfers display node from newDocument to currentDocument\n        currentDocument.setDisplayNode(newDocument.getDisplayNode());\n        // Transfers display stylesheets from newDocument to currentDocument\n        currentDocument.setDisplayStylesheets(newDocument.getDisplayStylesheets());\n        // Simulates Scene's behavior : automatically adds \"root\" styleclass if\n        // if the scene graph root is a Parent instance or wraps a Parent instance\n        if (currentDocument.getSceneGraphRoot() instanceof Parent) {\n            final Parent rootParent = (Parent) currentDocument.getSceneGraphRoot();\n            rootParent.getStyleClass().add(0, \"root\");\n        } else if (currentDocument.getSceneGraphRoot() instanceof Scene\n                || currentDocument.getSceneGraphRoot() instanceof Window) {\n            Node displayNode = currentDocument.getDisplayNode();\n            if (displayNode != null && displayNode instanceof Parent) {\n                displayNode.getStyleClass().add(0, \"root\");\n            }\n        }\n        // Recurses\n        if (currentDocument.getFxomRoot() != null) {\n            refreshFxomObject(currentDocument.getFxomRoot(), newDocument.getFxomRoot());\n        }\n    }\n    private void refreshFxomObject(FXOMObject currentObject, FXOMObject newObject) {\n        assert currentObject != null;\n        assert newObject != null;\n        assert currentObject.getClass() == newObject.getClass();\n        currentObject.setSceneGraphObject(newObject.getSceneGraphObject());\n        if (currentObject instanceof FXOMInstance) {\n            refreshFxomInstance((FXOMInstance) currentObject, (FXOMInstance) newObject);\n        } else if (currentObject instanceof FXOMCollection) {\n            refreshFxomCollection((FXOMCollection) currentObject, (FXOMCollection) newObject);\n        } else if (currentObject instanceof FXOMIntrinsic) {\n            refreshFxomIntrinsic((FXOMIntrinsic) currentObject, (FXOMIntrinsic) newObject);\n        } else {\n            assert false : \"Unexpected fxom object \" + currentObject;\n        }\n//        assert currentObject.equals(newObject) : \"currentValue=\" + currentObject +\n//                                               \"  newValue=\" + newObject;\n    }\n    private void refreshFxomInstance(FXOMInstance currentInstance, FXOMInstance newInstance) {\n        assert currentInstance != null;\n        assert newInstance != null;\n        assert currentInstance.getClass() == newInstance.getClass();\n        currentInstance.setDeclaredClass(newInstance.getDeclaredClass());\n        final Set<PropertyName> currentNames = currentInstance.getProperties().keySet();\n        final Set<PropertyName> newNames = newInstance.getProperties().keySet();\n        assert currentNames.equals(newNames);\n        for (PropertyName name : currentNames) {\n            final FXOMProperty currentProperty = currentInstance.getProperties().get(name);\n            final FXOMProperty newProperty = newInstance.getProperties().get(name);\n            refreshFxomProperty(currentProperty, newProperty);\n        }\n    }\n    private void refreshFxomCollection(FXOMCollection currentCollection, FXOMCollection newCollection) {\n        assert currentCollection != null;\n        assert newCollection != null;\n        currentCollection.setDeclaredClass(newCollection.getDeclaredClass());\n        refreshFxomObjects(currentCollection.getItems(), newCollection.getItems());\n    }\n    private void refreshFxomIntrinsic(FXOMIntrinsic currentIntrinsic, FXOMIntrinsic newIntrinsic) {\n        assert currentIntrinsic != null;\n        assert newIntrinsic != null;\n        currentIntrinsic.setSourceSceneGraphObject(newIntrinsic.getSourceSceneGraphObject());\n        currentIntrinsic.getProperties().clear();\n        currentIntrinsic.fillProperties(newIntrinsic.getProperties());\n    }\n    private void refreshFxomProperty(FXOMProperty currentProperty, FXOMProperty newProperty) {\n        assert currentProperty != null;\n        assert newProperty != null;\n        assert currentProperty.getName().equals(newProperty.getName());\n        if (currentProperty instanceof FXOMPropertyT) {\n            assert newProperty instanceof FXOMPropertyT;\n            assert ((FXOMPropertyT) currentProperty).getValue().equals(((FXOMPropertyT) newProperty).getValue());\n        } else {\n            assert currentProperty instanceof FXOMPropertyC;\n            assert newProperty instanceof FXOMPropertyC;\n            final FXOMPropertyC currentPC = (FXOMPropertyC) currentProperty;\n            final FXOMPropertyC newPC = (FXOMPropertyC) newProperty;\n            refreshFxomObjects(currentPC.getValues(), newPC.getValues());\n        }\n    }\n    private void refreshFxomObjects(List<FXOMObject> currentObjects, List<FXOMObject> newObjects) {\n        assert currentObjects != null;\n        assert newObjects != null;\n        assert currentObjects.size() == newObjects.size();\n        for (int i = 0, count = currentObjects.size(); i < count; i++) {\n            final FXOMObject currentObject = currentObjects.get(i);\n            final FXOMObject newObject = newObjects.get(i);\n            if (currentObject instanceof FXOMIntrinsic || newObject instanceof FXOMIntrinsic) {\n                handleRefreshIntrinsic(currentObject, newObject);\n            } else {\n                refreshFxomObject(currentObject, newObject);\n            }\n        }\n    }\n    private void handleRefreshIntrinsic(FXOMObject currentObject, FXOMObject newObject) {\n        if (currentObject instanceof FXOMIntrinsic && newObject instanceof FXOMIntrinsic) {\n            refreshFxomObject(currentObject, newObject);\n        } else if (newObject instanceof FXOMIntrinsic) {\n            FXOMInstance fxomInstance = getFxomInstance((FXOMIntrinsic) newObject);\n            refreshFxomObject(currentObject, fxomInstance);\n        } else if (currentObject instanceof FXOMIntrinsic) {\n            FXOMInstance fxomInstance = getFxomInstance((FXOMIntrinsic) currentObject);\n            refreshFxomObject(fxomInstance, newObject);\n        }\n    }\n    private FXOMInstance getFxomInstance(FXOMIntrinsic intrinsic) {\n        FXOMInstance fxomInstance = new FXOMInstance(intrinsic.getFxomDocument(), intrinsic.getGlueElement());\n        fxomInstance.setSceneGraphObject(intrinsic.getSourceSceneGraphObject());\n        fxomInstance.setDeclaredClass(intrinsic.getClass());\n        if (!intrinsic.getProperties().isEmpty()) {\n            fxomInstance.fillProperties(intrinsic.getProperties());\n        }\n        return fxomInstance;\n    }\n    /*\n     * The case of SplitPane.dividerPositions property\n     * -----------------------------------------------\n     * \n     * When user adds a child to a SplitPane, this adds a new entry in\n     * SplitPane.children property but also adds a new value to \n     * SplitPane.dividerPositions by side-effect.\n     * \n     * The change in SplitPane.dividerPositions is performed at scene graph\n     * level by FX. Thus it is unseen by FXOM. \n     * \n     * So in that case we perform a special operation which copies value of \n     * SplitPane.dividerPositions into FXOMProperty representing \n     * dividerPositions in FXOM.\n     */\n    private void synchronizeDividerPositions(FXOMDocument document) {\n        final FXOMObject fxomRoot = document.getFxomRoot();\n        if (fxomRoot != null) {\n            final Metadata metadata\n                    = Metadata.getMetadata();\n            final PropertyName dividerPositionsName\n                    = new PropertyName(\"dividerPositions\");\n            final List<FXOMObject> candidates\n                    = fxomRoot.collectObjectWithSceneGraphObjectClass(SplitPane.class);\n            for (FXOMObject fxomObject : candidates) {\n                if (fxomObject instanceof FXOMInstance) {\n                    final FXOMInstance fxomInstance = (FXOMInstance) fxomObject;\n                    assert fxomInstance.getSceneGraphObject() instanceof SplitPane;\n                    final SplitPane splitPane\n                            = (SplitPane) fxomInstance.getSceneGraphObject();\n                    splitPane.layout();\n                    final ValuePropertyMetadata vpm\n                            = metadata.queryValueProperty(fxomInstance, dividerPositionsName);\n                    assert vpm instanceof ListValuePropertyMetadata\n                            : \"vpm.getClass()=\" + vpm.getClass().getSimpleName();\n                    final DoubleArrayPropertyMetadata davpm\n                            = (DoubleArrayPropertyMetadata) vpm;\n                    davpm.synchronizeWithSceneGraphObject(fxomInstance);\n                }\n            }\n        }\n    }\n//    \n//    \n//    private void reloadStylesheets(final Parent p) {\n//        assert p != null;\n//        assert p.getScene() != null;\n//        \n//        if (p.getStylesheets().isEmpty() == false) {\n//            final List<String> stylesheets = new ArrayList<>();\n//            stylesheets.addAll(p.getStylesheets());\n////            p.getStylesheets().clear();\n////            p.impl_processCSS(true);\n//            p.getStylesheets().setAll(stylesheets);\n////            p.impl_processCSS(true);\n//        }\n//        for (Node child : p.getChildrenUnmodifiable()) {\n//            if (child instanceof Parent) {\n//                reloadStylesheets((Parent)child);\n//            }\n//        }\n//        \n//    }\n"]], "pred": {"ppl": 2.1986196041107178, "ppl_lower": 2.5708651542663574, "ppl/lowercase_ppl": -1.1985362639504618, "ppl/zlib": 0.0002998971110607202, "Min_5.0% Prob": 7.225750801610012, "Min_10.0% Prob": 5.413132812462601, "Min_20.0% Prob": 3.5592331471396426, "Min_30.0% Prob": 2.5463878535756876, "Min_40.0% Prob": 1.9514585118239842, "Min_50.0% Prob": 1.5725251940022535, "Min_60.0% Prob": 1.313609101595342}}
{"hexsha": "6943932b8652d103488dc8b0172c60413f4e1ea4", "ext": "java", "lang": "Java", "content": "public class AbstractPersisterTest {\n\t\n\t@SuppressWarnings(\"unchecked\")\n\t@Test\n\tpublic void testAlternateStateFields() {\n\t\t\n\t\tList<State<MockEntity>> states = new ArrayList<State<MockEntity>>();\n\t\tState<MockEntity> startState = mock(State.class);\n\t\tstates.add(startState);\n\t\t\n\t\tMockPersister<MockEntity> mockPersister = new MockPersister<MockEntity>(\n\t\t\t\tstates, \n\t\t\t\t\"stateField1\", \n\t\t\t\tstartState, \n\t\t\t\tMockEntity.class);\n\t\tField field = mockPersister.getStateField();\n\t\t\n\t\tassertNotNull(field);\n\t\tassertEquals(\"stateField1\", field.getName());\n\n\t\tmockPersister = new MockPersister<MockEntity>(\n\t\t\t\tstates, \n\t\t\t\t\"\", \n\t\t\t\tstartState, \n\t\t\t\tMockEntity.class);\n\t\tfield = mockPersister.getStateField();\n\t\t\n\t\tassertNotNull(field);\n\t\tassertEquals(\"stateField2\", field.getName());\n\t}\n\n}", "item_id": 0, "repo": "alonsoir/statefulj", "file": "statefulj-persistence/statefulj-persistence-common/src/test/java/org/statefulj/persistence/common/AbstractPersisterTest.java", "last_update_at": "2022-02-10T11:07:23+00:00", "question_id": "6943932b8652d103488dc8b0172c60413f4e1ea4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AbstractPersisterTest {\n\t\n\t@SuppressWarnings(\"unchecked\")\n\t@Test\n\tpublic void testAlternateStateFields() {\n\t\t\n\t\tList<State<MockEntity>> states = new ArrayList<State<MockEntity>>();\n\t\tState<MockEntity> startState = mock(State.class);\n\t\tstates.add(startState);\n\t\t\n\t\tMockPersister<MockEntity> mockPersister = new MockPersister<MockEntity>(\n\t\t\t\tstates, \n\t\t\t\t\"stateField1\", \n\t\t\t\tstartState, \n\t\t\t\tMockEntity.class);\n\t\tField field = mockPersister.getStateField();\n\t\t\n\t\tassertNotNull(field);\n\t\tassertEquals(\"stateField1\", field.getName());\n\t\tmockPersister = new MockPersister<MockEntity>(\n\t\t\t\tstates, \n\t\t\t\t\"\", \n\t\t\t\tstartState, \n\t\t\t\tMockEntity.class);\n\t\tfield = mockPersister.getStateField();\n\t\t\n\t\tassertNotNull(field);\n\t\tassertEquals(\"stateField2\", field.getName());\n\t}\n"]], "pred": {"ppl": 1.8191767930984497, "ppl_lower": 2.140289783477783, "ppl/lowercase_ppl": -1.271660207684426, "ppl/zlib": 0.002063393404416001, "Min_5.0% Prob": 5.746575628008161, "Min_10.0% Prob": 4.213840390954699, "Min_20.0% Prob": 2.7617952875923693, "Min_30.0% Prob": 1.9520597398974175, "Min_40.0% Prob": 1.4961252147168445, "Min_50.0% Prob": 1.198174104739267, "Min_60.0% Prob": 0.9976709180072946}}
{"hexsha": "c0ea2bd1af0d1c3b7917b1d3117b05ee528d67e9", "ext": "java", "lang": "Java", "content": "public abstract class PrefixTreeBase<T> implements PrefixTree<T> {\n    public static final String DEFAULT_PATH_SEPARATOR = \"/\";\n\n    public static final String PROTOCOL_PREFIX = \"://\";\n\n    private final PrefixTreeNode<T> _RootNode;\n\n    private final String _PathSeparator;\n\n    public PrefixTreeBase() {\n\n        this(DEFAULT_PATH_SEPARATOR);\n    }\n\n    public PrefixTreeBase(final String pathSeparator) {\n\n        _PathSeparator = pathSeparator;\n        _RootNode = new PrefixTreeNode<>();\n    }\n\n\n    public String getPathSeparator() {\n\n        return _PathSeparator;\n    }\n\n    public PrefixTreeNode<T> getRoot() {\n\n        return _RootNode;\n    }\n\n    @Override\n    public void setPathValue(final String path, final T value) {\n\n        PrefixTreeNode node = getRoot();\n        final List<String> segments = segmentPath(path);\n\n        for (final String segment : segments) {\n            if (node.hasChild(segment)) {\n                node = node.getChild(segment);\n            }\n            else {\n                node = node.addChild(segment, null);\n            }\n        }\n\n        node.setValue(value);\n    }\n\n    public String toString() {\n\n        final String pathSeparator = getPathSeparator();\n        final Set<String> paths = getRoot().deepPrint(pathSeparator);\n        final StringBuilder sb = new StringBuilder();\n        for (final String p : paths) {\n            sb.append(p).append('\\n');\n        }\n        return sb.toString();\n    }\n\n    protected List<String> segmentPath(final String path) {\n\n        final String pathSeparator = getPathSeparator();\n\n        String trimmedPath = path.trim();\n\n        final int protocolPrefixIndex = trimmedPath.indexOf(PROTOCOL_PREFIX);\n        if (protocolPrefixIndex >= 0) {\n            trimmedPath = trimmedPath.substring(protocolPrefixIndex + PROTOCOL_PREFIX.length());\n        }\n\n        if (trimmedPath.endsWith(pathSeparator)) {\n            trimmedPath = trimmedPath.substring(0, trimmedPath.length() - 1);\n        }\n\n        if (trimmedPath.startsWith(pathSeparator)) {\n            trimmedPath = trimmedPath.substring(1);\n        }\n\n        String[] segmentArray = trimmedPath.split(pathSeparator);\n        if (segmentArray.length == 0) {\n            return Collections.EMPTY_LIST;\n        }\n\n        final List<String> segments = new LinkedList<>(Arrays.asList(segmentArray));\n        return segments;\n    }\n}", "item_id": 0, "repo": "wrml/wrml", "file": "core/src/main/java/org/wrml/util/PrefixTreeBase.java", "last_update_at": "2022-02-18T10:44:03+00:00", "question_id": "c0ea2bd1af0d1c3b7917b1d3117b05ee528d67e9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class PrefixTreeBase<T> implements PrefixTree<T> {\n    public static final String DEFAULT_PATH_SEPARATOR = \"/\";\n    public static final String PROTOCOL_PREFIX = \"://\";\n    private final PrefixTreeNode<T> _RootNode;\n    private final String _PathSeparator;\n    public PrefixTreeBase() {\n        this(DEFAULT_PATH_SEPARATOR);\n    }\n    public PrefixTreeBase(final String pathSeparator) {\n        _PathSeparator = pathSeparator;\n        _RootNode = new PrefixTreeNode<>();\n    }\n    public String getPathSeparator() {\n        return _PathSeparator;\n    }\n    public PrefixTreeNode<T> getRoot() {\n        return _RootNode;\n    }\n    @Override\n    public void setPathValue(final String path, final T value) {\n        PrefixTreeNode node = getRoot();\n        final List<String> segments = segmentPath(path);\n        for (final String segment : segments) {\n            if (node.hasChild(segment)) {\n                node = node.getChild(segment);\n            }\n            else {\n                node = node.addChild(segment, null);\n            }\n        }\n        node.setValue(value);\n    }\n    public String toString() {\n        final String pathSeparator = getPathSeparator();\n        final Set<String> paths = getRoot().deepPrint(pathSeparator);\n        final StringBuilder sb = new StringBuilder();\n        for (final String p : paths) {\n            sb.append(p).append('\\n');\n        }\n        return sb.toString();\n    }\n    protected List<String> segmentPath(final String path) {\n        final String pathSeparator = getPathSeparator();\n        String trimmedPath = path.trim();\n        final int protocolPrefixIndex = trimmedPath.indexOf(PROTOCOL_PREFIX);\n        if (protocolPrefixIndex >= 0) {\n            trimmedPath = trimmedPath.substring(protocolPrefixIndex + PROTOCOL_PREFIX.length());\n        }\n        if (trimmedPath.endsWith(pathSeparator)) {\n            trimmedPath = trimmedPath.substring(0, trimmedPath.length() - 1);\n        }\n        if (trimmedPath.startsWith(pathSeparator)) {\n            trimmedPath = trimmedPath.substring(1);\n        }\n        String[] segmentArray = trimmedPath.split(pathSeparator);\n        if (segmentArray.length == 0) {\n            return Collections.EMPTY_LIST;\n        }\n        final List<String> segments = new LinkedList<>(Arrays.asList(segmentArray));\n        return segments;\n    }\n"]], "pred": {"ppl": 1.5565059185028076, "ppl_lower": 1.7925949096679688, "ppl/lowercase_ppl": -1.3191836306982743, "ppl/zlib": 0.0006302614150077994, "Min_5.0% Prob": 4.41597056388855, "Min_10.0% Prob": 3.2126844712157747, "Min_20.0% Prob": 2.0265396853436286, "Min_30.0% Prob": 1.4348159904651974, "Min_40.0% Prob": 1.0955170535329561, "Min_50.0% Prob": 0.8817357819138179, "Min_60.0% Prob": 0.7365450848586653}}
{"hexsha": "d2d4d994e88adb0d92194d9e58a8abdb41fd6618", "ext": "java", "lang": "Java", "content": "public class HydrateFunction extends LevenbergMarquardtFunction {\n\n    private static final long serialVersionUID = 1000;\n    static Logger logger = LogManager.getLogger(HydrateFunction.class);\n\n    /** Creates new Test */\n    public HydrateFunction() {\n        // params = new double[3];\n    }\n\n    @Override\n\tpublic double calcValue(double[] dependentValues) {\n        try {\n            thermoOps.hydrateFormationTemperature(1);\n            // System.out.println(\"temperature \" + system.getTemperature());\n        } catch (Exception e) {\n            logger.error(e.toString());\n        }\n        return system.getTemperature();\n    }\n\n    @Override\n\tpublic double calcTrueValue(double val) {\n        return val;\n    }\n\n    @Override\n\tpublic void setFittingParams(int i, double value) {\n        int structure = 1;\n        params[i] = value;\n//        if(i==0) ((ComponentHydrate) system.getPhase(4).getComponent(\"water\")).setDGfHydrate(value, structure);\n//        if(i==1) ((ComponentHydrate) system.getPhase(4).getComponent(\"water\")).setDHfHydrate(value, structure);\n        // int k=0;\n\n//        if(i==0) ((ComponentHydrate) system.getPhase(4).getComponent(\"water\")).setEmptyHydrateVapourPressureConstant(0,0, value);\n//        if(i==1) ((ComponentHydrate) system.getPhase(4).getComponent(\"water\")).setEmptyHydrateVapourPressureConstant(0,1, value);\n\n        // for(int k=0;k<system.getNumberOfPhases();k++){\n        // if(i==0)\n        // system.getPhase(k).getComponent(0).setLennardJonesEnergyParameter(value);\n        // if(i==1)\n        // system.getPhase(k).getComponent(0).setLennardJonesMolecularDiameter(value);\n        // if(i==2) system.getPhase(k).getComponent(0).setSphericalCoreRadius(value);\n        // }\n\n        if (i == 0) {\n            ((ComponentHydrate) system.getPhase(4).getComponent(0)).setLennardJonesEnergyParameterHydrate(value);\n        }\n        if (i == 1) {\n            ((ComponentHydrate) system.getPhase(4).getComponent(0)).setLennardJonesMolecularDiameterHydrate(value);\n        }\n        if (i == 2) {\n            ((ComponentHydrate) system.getPhase(4).getComponent(0)).setSphericalCoreRadiusHydrate(value);\n        }\n//\n\n    }\n}", "item_id": 0, "repo": "akisTas/neqsim", "file": "src/main/java/neqsim/thermo/util/parameterFitting/pureComponentParameterFitting/hydrate/HydrateFunction.java", "last_update_at": "2022-02-24T08:39:18+00:00", "question_id": "d2d4d994e88adb0d92194d9e58a8abdb41fd6618_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HydrateFunction extends LevenbergMarquardtFunction {\n    private static final long serialVersionUID = 1000;\n    static Logger logger = LogManager.getLogger(HydrateFunction.class);\n    /** Creates new Test */\n    public HydrateFunction() {\n        // params = new double[3];\n    }\n    @Override\n\tpublic double calcValue(double[] dependentValues) {\n        try {\n            thermoOps.hydrateFormationTemperature(1);\n            // System.out.println(\"temperature \" + system.getTemperature());\n        } catch (Exception e) {\n            logger.error(e.toString());\n        }\n        return system.getTemperature();\n    }\n    @Override\n\tpublic double calcTrueValue(double val) {\n        return val;\n    }\n    @Override\n\tpublic void setFittingParams(int i, double value) {\n        int structure = 1;\n        params[i] = value;\n//        if(i==0) ((ComponentHydrate) system.getPhase(4).getComponent(\"water\")).setDGfHydrate(value, structure);\n//        if(i==1) ((ComponentHydrate) system.getPhase(4).getComponent(\"water\")).setDHfHydrate(value, structure);\n        // int k=0;\n//        if(i==0) ((ComponentHydrate) system.getPhase(4).getComponent(\"water\")).setEmptyHydrateVapourPressureConstant(0,0, value);\n//        if(i==1) ((ComponentHydrate) system.getPhase(4).getComponent(\"water\")).setEmptyHydrateVapourPressureConstant(0,1, value);\n        // for(int k=0;k<system.getNumberOfPhases();k++){\n        // if(i==0)\n        // system.getPhase(k).getComponent(0).setLennardJonesEnergyParameter(value);\n        // if(i==1)\n        // system.getPhase(k).getComponent(0).setLennardJonesMolecularDiameter(value);\n        // if(i==2) system.getPhase(k).getComponent(0).setSphericalCoreRadius(value);\n        // }\n        if (i == 0) {\n            ((ComponentHydrate) system.getPhase(4).getComponent(0)).setLennardJonesEnergyParameterHydrate(value);\n        }\n        if (i == 1) {\n            ((ComponentHydrate) system.getPhase(4).getComponent(0)).setLennardJonesMolecularDiameterHydrate(value);\n        }\n        if (i == 2) {\n            ((ComponentHydrate) system.getPhase(4).getComponent(0)).setSphericalCoreRadiusHydrate(value);\n        }\n//\n    }\n"]], "pred": {"ppl": 1.8301697969436646, "ppl_lower": 2.338474988937378, "ppl/lowercase_ppl": -1.405504149178505, "ppl/zlib": 0.0009061600416254348, "Min_5.0% Prob": 6.182722727457683, "Min_10.0% Prob": 4.427502473195394, "Min_20.0% Prob": 2.8021461913983026, "Min_30.0% Prob": 1.969820239132753, "Min_40.0% Prob": 1.4993201869721007, "Min_50.0% Prob": 1.2064203918652816, "Min_60.0% Prob": 1.0075350237796858}}
{"hexsha": "6dec400abe03bae7a96e7c2bbadd5fd60e737d2f", "ext": "java", "lang": "Java", "content": "public class NodeInfoViewController {\r\n\r\n    @FXML\r\n    private AnchorPane nodeInfoPane;\r\n\r\n    @FXML\r\n    private SplitPane nodeInfoSplitPane;\r\n\r\n    @FXML\r\n    private AnchorPane nodeDataPane;\r\n\r\n    @FXML\r\n    private TextField cZxidField;\r\n\r\n    @FXML\r\n    private TextField pZxidField;\r\n\r\n    @FXML\r\n    private TextField mtimeField;\r\n\r\n    @FXML\r\n    private TextField ephemeralOwnerField;\r\n\r\n    @FXML\r\n    private TextField ctimeField;\r\n\r\n    @FXML\r\n    private TextField mZxidField;\r\n\r\n    @FXML\r\n    private TextField dataLengthField;\r\n\r\n    @FXML\r\n    private TextField numChildrenField;\r\n\r\n    @FXML\r\n    private TextField dataVersionField;\r\n\r\n    @FXML\r\n    private TextField aclVersionField;\r\n\r\n    @FXML\r\n    private TextField cVersionField;\r\n\r\n    @FXML\r\n    private TextField pathField;\r\n\r\n    @FXML\r\n    private Button nodeUpdateButton;\r\n\r\n    @FXML\r\n    private Label mtimeLabel;\r\n\r\n    @FXML\r\n    private Label ctimeLabel;\r\n\r\n    @FXML\r\n    private Button jsonFormatButton;\r\n\r\n    @FXML\r\n    private Button rawFormatButton;\r\n\r\n    @FXML\r\n    private Button xmlFormatButton;\r\n\r\n    @FXML\r\n    private HBox dataMenuBar;\r\n\r\n    @FXML\r\n    private ChoiceBox<String> charsetChoice;\r\n\r\n    private NodeDataArea dataCodeArea = new NodeDataArea();\r\n\r\n    @FXML\r\n    private PrettyZooFacade prettyZooFacade = new PrettyZooFacade();\r\n\r\n    private List<Button> formatButtons = List.of();\r\n\r\n    @FXML\r\n    private void initialize() {\r\n        nodeUpdateButton.setOnMouseClicked(e -> onNodeUpdate());\r\n        initCodeArea();\r\n        final Tooltip timeLabelTooltip = new Tooltip(\"Click to change format\");\r\n        mtimeLabel.setTooltip(timeLabelTooltip);\r\n        ctimeLabel.setTooltip(timeLabelTooltip);\r\n        mtimeLabel.setOnMouseClicked(e -> changeTimeFormat());\r\n        ctimeLabel.setOnMouseClicked(e -> changeTimeFormat());\r\n        jsonFormatButton.setOnAction(e -> dataJsonFormat());\r\n        rawFormatButton.setOnAction(e -> dataRawFormat());\r\n        xmlFormatButton.setOnAction(e -> dataXmlFormat());\r\n        formatButtons = List.of(jsonFormatButton, xmlFormatButton, rawFormatButton);\r\n        charsetChoice.getItems().addAll(\"UTF-8\", \"GBK\", \"GB2312\", \"ISO-8859-1\", \"UTF-16\");\r\n        charsetChoice.getSelectionModel().select(\"UTF-8\");\r\n        charsetChoice.getSelectionModel().selectedItemProperty().addListener((event, ov, nv) -> {\r\n            if (nv == null) {\r\n                return;\r\n            }\r\n            byte[] rawBytes = (byte[]) dataCodeArea.getProperties().get(\"rawBytes\");\r\n            if (rawBytes == null) {\r\n                return;\r\n            }\r\n            try {\r\n                setCodeAreaData(new String(rawBytes, nv));\r\n            } catch (UnsupportedEncodingException unsupportedEncodingException) {\r\n                VToast.error(\"Not supported Charset:\" + nv);\r\n            }\r\n        });\r\n\r\n        Tooltip tooltip = new Tooltip(\"Double click\");\r\n        Tooltip.install(dataMenuBar, tooltip);\r\n        dataMenuBar.setOnMouseClicked(e -> {\r\n            if (e.getClickCount() == 2 && e.getButton() == MouseButton.PRIMARY) {\r\n                StackPane parent = (StackPane) nodeInfoPane.getParent();\r\n                if (!parent.getChildren().contains(nodeDataPane)) {\r\n                    nodeInfoSplitPane.getItems().remove(nodeDataPane);\r\n                    parent.getChildren().add(nodeDataPane);\r\n                    Transitions.zoomIn(nodeDataPane).play();\r\n                } else {\r\n                    parent.getChildren().remove(nodeDataPane);\r\n                    nodeInfoSplitPane.getItems().add(nodeDataPane);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    public void show(StackPane parent) {\r\n        show(parent, null);\r\n    }\r\n\r\n    public void show(StackPane parent, ZkNode zkNode) {\r\n        if (!parent.getChildren().contains(nodeInfoPane)) {\r\n            parent.getChildren().add(nodeInfoPane);\r\n        }\r\n\r\n        if (zkNode == null) {\r\n            resetTextField();\r\n        } else {\r\n            initTextField(zkNode);\r\n        }\r\n        switchFormatButton(rawFormatButton);\r\n    }\r\n\r\n    private void initCodeArea() {\r\n        var pane = new VirtualizedScrollPane<>(dataCodeArea);\r\n        AnchorPane.setTopAnchor(pane, 40d);\r\n        AnchorPane.setLeftAnchor(pane, 0d);\r\n        AnchorPane.setRightAnchor(pane, 0d);\r\n        AnchorPane.setBottomAnchor(pane, 5d);\r\n        nodeDataPane.getChildren().add(pane);\r\n    }\r\n\r\n    private void setCodeAreaData(String data) {\r\n        dataCodeArea.setText(data);\r\n    }\r\n\r\n    private void onNodeUpdate() {\r\n        final String path = pathField.getText();\r\n        if (!ActiveServerContext.exists()) {\r\n            VToast.error(\"Error: connect zookeeper first\");\r\n            return;\r\n        }\r\n        if (!prettyZooFacade.nodeExists(path)) {\r\n            VToast.error(\"Node not exists\");\r\n            return;\r\n        }\r\n        final String data = dataCodeArea.getText();\r\n        TreeItem<ZkNode> currentData = TreeItemCache.getInstance().get(ActiveServerContext.get(), path);\r\n\r\n        Runnable action = () -> {\r\n            Transitions.rotate(nodeUpdateButton, () -> {\r\n                Stat stat = prettyZooFacade.updateData(ActiveServerContext.get(), path, data, ex -> VToast.error(ex.getMessage()));\r\n                dataCodeArea.getProperties().put(\"raw\", data);\r\n                dataCodeArea.getProperties().put(\"rawBytes\", data.getBytes());\r\n                updateField(stat);\r\n                VToast.info(\"update success\");\r\n            });\r\n        };\r\n\r\n        ResourceBundle bundle = ResourceBundleUtils.get(prettyZooFacade.getLocale());\r\n        String title = bundle.getString(\"nodeData.refresh.conflict.title\");\r\n        String content = bundle.getString(\"nodeData.refresh.conflict.content\");\r\n        if (!Objects.equals(currentData.getValue().getData(), data)) {\r\n            Dialog.confirm(title, String.format(content, currentData.getValue().getData()), action);\r\n        } else {\r\n            action.run();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * TODO use data bind to instead of manual bind\r\n     */\r\n    private void updateField(Stat node) {\r\n        ephemeralOwnerField.setText(String.valueOf(node.getEphemeralOwner()));\r\n        cZxidField.setText(String.valueOf(node.getCzxid()));\r\n        pZxidField.setText(String.valueOf(node.getPzxid()));\r\n        mZxidField.setText(String.valueOf(node.getMzxid()));\r\n        dataLengthField.setText(String.valueOf(node.getDataLength()));\r\n        numChildrenField.setText(String.valueOf(node.getNumChildren()));\r\n        dataVersionField.setText(String.valueOf(node.getVersion()));\r\n        aclVersionField.setText(String.valueOf(node.getAversion()));\r\n        cVersionField.setText(String.valueOf(node.getCversion()));\r\n        mtimeField.getProperties().put(\"timestamp\", node.getMtime());\r\n        mtimeField.getProperties().put(\"dateTime\", format(node.getMtime()));\r\n        ctimeField.getProperties().put(\"timestamp\", node.getCtime());\r\n        ctimeField.getProperties().put(\"dateTime\", format(node.getCtime()));\r\n        showDateTime();\r\n    }\r\n\r\n    private void initTextField(ZkNode node) {\r\n        setCodeAreaData(transformData(node));\r\n        dataCodeArea.getProperties().put(\"raw\", transformData(node));\r\n        dataCodeArea.getProperties().put(\"rawBytes\", node.getDataBytes());\r\n\r\n        ephemeralOwnerField.setText(String.valueOf(node.getEphemeralOwner()));\r\n        cZxidField.setText(String.valueOf(node.getCzxid()));\r\n        pZxidField.setText(String.valueOf(node.getPzxid()));\r\n        mZxidField.setText(String.valueOf(node.getMzxid()));\r\n        dataLengthField.setText(String.valueOf(node.getDataLength()));\r\n        numChildrenField.setText(String.valueOf(node.getNumChildren()));\r\n        dataVersionField.setText(String.valueOf(node.getVersion()));\r\n        aclVersionField.setText(String.valueOf(node.getAversion()));\r\n        cVersionField.setText(String.valueOf(node.getCversion()));\r\n        pathField.setText(node.getPath());\r\n\r\n        mtimeField.getProperties().put(\"timestamp\", node.getMtime());\r\n        mtimeField.getProperties().put(\"dateTime\", format(node.getMtime()));\r\n        ctimeField.getProperties().put(\"timestamp\", node.getCtime());\r\n        ctimeField.getProperties().put(\"dateTime\", format(node.getCtime()));\r\n        showDateTime();\r\n    }\r\n\r\n    private String transformData(ZkNode node) {\r\n        final String charset = charsetChoice.getSelectionModel().getSelectedItem();\r\n        try {\r\n            return new String(node.getDataBytes(), charset);\r\n        } catch (UnsupportedEncodingException e) {\r\n            return node.getData();\r\n        }\r\n    }\r\n\r\n    private void changeTimeFormat() {\r\n        if (\"timestamp\".equals(mtimeLabel.getProperties().get(\"format\"))) {\r\n            showDateTime();\r\n        } else {\r\n            showTimestamp();\r\n        }\r\n    }\r\n\r\n    private void showDateTime() {\r\n        final Object ctime = ctimeField.getProperties().getOrDefault(\"dateTime\", \"\");\r\n        ctimeField.setText(ctime.toString());\r\n        final Object mtime = mtimeField.getProperties().getOrDefault(\"dateTime\", \"\");\r\n        mtimeField.setText(mtime.toString());\r\n        ctimeLabel.getProperties().put(\"format\", \"dateTime\");\r\n        mtimeLabel.getProperties().put(\"format\", \"dateTime\");\r\n    }\r\n\r\n    private void showTimestamp() {\r\n        final Object ctime = ctimeField.getProperties().getOrDefault(\"timestamp\", \"\");\r\n        ctimeField.setText(ctime.toString());\r\n        final Object mtime = mtimeField.getProperties().getOrDefault(\"timestamp\", \"\");\r\n        mtimeField.setText(mtime.toString());\r\n        ctimeLabel.getProperties().put(\"format\", \"timestamp\");\r\n        mtimeLabel.getProperties().put(\"format\", \"timestamp\");\r\n    }\r\n\r\n    private String format(long timestamp) {\r\n        if (timestamp == 0) {\r\n            return \"-\";\r\n        } else {\r\n            return OffsetDateTime.ofInstant(Instant.ofEpochMilli(timestamp), ZoneId.systemDefault())\r\n                    .format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"));\r\n        }\r\n    }\r\n\r\n    private void resetTextField() {\r\n        dataCodeArea.clear();\r\n        ephemeralOwnerField.clear();\r\n        cZxidField.clear();\r\n        mtimeField.clear();\r\n        pZxidField.clear();\r\n        ctimeField.clear();\r\n        mZxidField.clear();\r\n        dataLengthField.clear();\r\n        numChildrenField.clear();\r\n        dataVersionField.clear();\r\n        aclVersionField.clear();\r\n        cVersionField.clear();\r\n        pathField.clear();\r\n    }\r\n\r\n    private void dataJsonFormat() {\r\n        final Object data = dataCodeArea.getProperties().get(\"raw\");\r\n        if (data == null) {\r\n            return;\r\n        }\r\n        final String prettyJson;\r\n        try {\r\n            prettyJson = Formatters.prettyJson(data.toString());\r\n            setCodeAreaData(prettyJson);\r\n            switchFormatButton(jsonFormatButton);\r\n        } catch (JsonProcessingException e) {\r\n            VToast.error(\"JSON format failed\");\r\n        }\r\n    }\r\n\r\n    private void dataXmlFormat() {\r\n        final Object data = dataCodeArea.getProperties().get(\"raw\");\r\n        if (data == null) {\r\n            return;\r\n        }\r\n        final String prettyXML;\r\n        try {\r\n            prettyXML = Formatters.prettyXml(data.toString());\r\n            setCodeAreaData(prettyXML);\r\n            switchFormatButton(xmlFormatButton);\r\n        } catch (Exception e) {\r\n            VToast.error(\"XML format failed\");\r\n        }\r\n    }\r\n\r\n    private void dataRawFormat() {\r\n        final Object data = dataCodeArea.getProperties().get(\"raw\");\r\n        if (data == null) {\r\n            return;\r\n        }\r\n        setCodeAreaData(data.toString());\r\n        switchFormatButton(rawFormatButton);\r\n    }\r\n\r\n    private void switchFormatButton(Button button) {\r\n        button.setTextFill(Color.valueOf(\"#3F51B5\"));\r\n        formatButtons.stream().filter(b -> b != button).forEach(b -> b.setTextFill(Color.valueOf(\"#000\")));\r\n    }\r\n}", "item_id": 0, "repo": "lsw1991abc/PrettyZoo", "file": "app/src/main/java/cc/cc1234/app/controller/NodeInfoViewController.java", "last_update_at": "2022-03-31T05:39:45+00:00", "question_id": "6dec400abe03bae7a96e7c2bbadd5fd60e737d2f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NodeInfoViewController {\r\n\r\n    @FXML\r\n    private AnchorPane nodeInfoPane;\r\n\r\n    @FXML\r\n    private SplitPane nodeInfoSplitPane;\r\n\r\n    @FXML\r\n    private AnchorPane nodeDataPane;\r\n\r\n    @FXML\r\n    private TextField cZxidField;\r\n\r\n    @FXML\r\n    private TextField pZxidField;\r\n\r\n    @FXML\r\n    private TextField mtimeField;\r\n\r\n    @FXML\r\n    private TextField ephemeralOwnerField;\r\n\r\n    @FXML\r\n    private TextField ctimeField;\r\n\r\n    @FXML\r\n    private TextField mZxidField;\r\n\r\n    @FXML\r\n    private TextField dataLengthField;\r\n\r\n    @FXML\r\n    private TextField numChildrenField;\r\n\r\n    @FXML\r\n    private TextField dataVersionField;\r\n\r\n    @FXML\r\n    private TextField aclVersionField;\r\n\r\n    @FXML\r\n    private TextField cVersionField;\r\n\r\n    @FXML\r\n    private TextField pathField;\r\n\r\n    @FXML\r\n    private Button nodeUpdateButton;\r\n\r\n    @FXML\r\n    private Label mtimeLabel;\r\n\r\n    @FXML\r\n    private Label ctimeLabel;\r\n\r\n    @FXML\r\n    private Button jsonFormatButton;\r\n\r\n    @FXML\r\n    private Button rawFormatButton;\r\n\r\n    @FXML\r\n    private Button xmlFormatButton;\r\n\r\n    @FXML\r\n    private HBox dataMenuBar;\r\n\r\n    @FXML\r\n    private ChoiceBox<String> charsetChoice;\r\n\r\n    private NodeDataArea dataCodeArea = new NodeDataArea();\r\n\r\n    @FXML\r\n    private PrettyZooFacade prettyZooFacade = new PrettyZooFacade();\r\n\r\n    private List<Button> formatButtons = List.of();\r\n\r\n    @FXML\r\n    private void initialize() {\r\n        nodeUpdateButton.setOnMouseClicked(e -> onNodeUpdate());\r\n        initCodeArea();\r\n        final Tooltip timeLabelTooltip = new Tooltip(\"Click to change format\");\r\n        mtimeLabel.setTooltip(timeLabelTooltip);\r\n        ctimeLabel.setTooltip(timeLabelTooltip);\r\n        mtimeLabel.setOnMouseClicked(e -> changeTimeFormat());\r\n        ctimeLabel.setOnMouseClicked(e -> changeTimeFormat());\r\n        jsonFormatButton.setOnAction(e -> dataJsonFormat());\r\n        rawFormatButton.setOnAction(e -> dataRawFormat());\r\n        xmlFormatButton.setOnAction(e -> dataXmlFormat());\r\n        formatButtons = List.of(jsonFormatButton, xmlFormatButton, rawFormatButton);\r\n        charsetChoice.getItems().addAll(\"UTF-8\", \"GBK\", \"GB2312\", \"ISO-8859-1\", \"UTF-16\");\r\n        charsetChoice.getSelectionModel().select(\"UTF-8\");\r\n        charsetChoice.getSelectionModel().selectedItemProperty().addListener((event, ov, nv) -> {\r\n            if (nv == null) {\r\n                return;\r\n            }\r\n            byte[] rawBytes = (byte[]) dataCodeArea.getProperties().get(\"rawBytes\");\r\n            if (rawBytes == null) {\r\n                return;\r\n            }\r\n            try {\r\n                setCodeAreaData(new String(rawBytes, nv));\r\n            } catch (UnsupportedEncodingException unsupportedEncodingException) {\r\n                VToast.error(\"Not supported Charset:\" + nv);\r\n            }\r\n        });\r\n\r\n        Tooltip tooltip = new Tooltip(\"Double click\");\r\n        Tooltip.install(dataMenuBar, tooltip);\r\n        dataMenuBar.setOnMouseClicked(e -> {\r\n            if (e.getClickCount() == 2 && e.getButton() == MouseButton.PRIMARY) {\r\n                StackPane parent = (StackPane) nodeInfoPane.getParent();\r\n                if (!parent.getChildren().contains(nodeDataPane)) {\r\n                    nodeInfoSplitPane.getItems().remove(nodeDataPane);\r\n                    parent.getChildren().add(nodeDataPane);\r\n                    Transitions.zoomIn(nodeDataPane).play();\r\n                } else {\r\n                    parent.getChildren().remove(nodeDataPane);\r\n                    nodeInfoSplitPane.getItems().add(nodeDataPane);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    public void show(StackPane parent) {\r\n        show(parent, null);\r\n    }\r\n\r\n    public void show(StackPane parent, ZkNode zkNode) {\r\n        if (!parent.getChildren().contains(nodeInfoPane)) {\r\n            parent.getChildren().add(nodeInfoPane);\r\n        }\r\n\r\n        if (zkNode == null) {\r\n            resetTextField();\r\n        } else {\r\n            initTextField(zkNode);\r\n        }\r\n        switchFormatButton(rawFormatButton);\r\n    }\r\n\r\n    private void initCodeArea() {\r\n        var pane = new VirtualizedScrollPane<>(dataCodeArea);\r\n        AnchorPane.setTopAnchor(pane, 40d);\r\n        AnchorPane.setLeftAnchor(pane, 0d);\r\n        AnchorPane.setRightAnchor(pane, 0d);\r\n        AnchorPane.setBottomAnchor(pane, 5d);\r\n        nodeDataPane.getChildren().add(pane);\r\n    }\r\n\r\n    private void setCodeAreaData(String data) {\r\n        dataCodeArea.setText(data);\r\n    }\r\n\r\n    private void onNodeUpdate() {\r\n        final String path = pathField.getText();\r\n        if (!ActiveServerContext.exists()) {\r\n            VToast.error(\"Error: connect zookeeper first\");\r\n            return;\r\n        }\r\n        if (!prettyZooFacade.nodeExists(path)) {\r\n            VToast.error(\"Node not exists\");\r\n            return;\r\n        }\r\n        final String data = dataCodeArea.getText();\r\n        TreeItem<ZkNode> currentData = TreeItemCache.getInstance().get(ActiveServerContext.get(), path);\r\n\r\n        Runnable action = () -> {\r\n            Transitions.rotate(nodeUpdateButton, () -> {\r\n                Stat stat = prettyZooFacade.updateData(ActiveServerContext.get(), path, data, ex -> VToast.error(ex.getMessage()));\r\n                dataCodeArea.getProperties().put(\"raw\", data);\r\n                dataCodeArea.getProperties().put(\"rawBytes\", data.getBytes());\r\n                updateField(stat);\r\n                VToast.info(\"update success\");\r\n            });\r\n        };\r\n\r\n        ResourceBundle bundle = ResourceBundleUtils.get(prettyZooFacade.getLocale());\r\n        String title = bundle.getString(\"nodeData.refresh.conflict.title\");\r\n        String content = bundle.getString(\"nodeData.refresh.conflict.content\");\r\n        if (!Objects.equals(currentData.getValue().getData(), data)) {\r\n            Dialog.confirm(title, String.format(content, currentData.getValue().getData()), action);\r\n        } else {\r\n            action.run();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * TODO use data bind to instead of manual bind\r\n     */\r\n    private void updateField(Stat node) {\r\n        ephemeralOwnerField.setText(String.valueOf(node.getEphemeralOwner()));\r\n        cZxidField.setText(String.valueOf(node.getCzxid()));\r\n        pZxidField.setText(String.valueOf(node.getPzxid()));\r\n        mZxidField.setText(String.valueOf(node.getMzxid()));\r\n        dataLengthField.setText(String.valueOf(node.getDataLength()));\r\n        numChildrenField.setText(String.valueOf(node.getNumChildren()));\r\n        dataVersionField.setText(String.valueOf(node.getVersion()));\r\n        aclVersionField.setText(String.valueOf(node.getAversion()));\r\n        cVersionField.setText(String.valueOf(node.getCversion()));\r\n        mtimeField.getProperties().put(\"timestamp\", node.getMtime());\r\n        mtimeField.getProperties().put(\"dateTime\", format(node.getMtime()));\r\n        ctimeField.getProperties().put(\"timestamp\", node.getCtime());\r\n        ctimeField.getProperties().put(\"dateTime\", format(node.getCtime()));\r\n        showDateTime();\r\n    }\r\n\r\n    private void initTextField(ZkNode node) {\r\n        setCodeAreaData(transformData(node));\r\n        dataCodeArea.getProperties().put(\"raw\", transformData(node));\r\n        dataCodeArea.getProperties().put(\"rawBytes\", node.getDataBytes());\r\n\r\n        ephemeralOwnerField.setText(String.valueOf(node.getEphemeralOwner()));\r\n        cZxidField.setText(String.valueOf(node.getCzxid()));\r\n        pZxidField.setText(String.valueOf(node.getPzxid()));\r\n        mZxidField.setText(String.valueOf(node.getMzxid()));\r\n        dataLengthField.setText(String.valueOf(node.getDataLength()));\r\n        numChildrenField.setText(String.valueOf(node.getNumChildren()));\r\n        dataVersionField.setText(String.valueOf(node.getVersion()));\r\n        aclVersionField.setText(String.valueOf(node.getAversion()));\r\n        cVersionField.setText(String.valueOf(node.getCversion()));\r\n        pathField.setText(node.getPath());\r\n\r\n        mtimeField.getProperties().put(\"timestamp\", node.getMtime());\r\n        mtimeField.getProperties().put(\"dateTime\", format(node.getMtime()));\r\n        ctimeField.getProperties().put(\"timestamp\", node.getCtime());\r\n        ctimeField.getProperties().put(\"dateTime\", format(node.getCtime()));\r\n        showDateTime();\r\n    }\r\n\r\n    private String transformData(ZkNode node) {\r\n        final String charset = charsetChoice.getSelectionModel().getSelectedItem();\r\n        try {\r\n            return new String(node.getDataBytes(), charset);\r\n        } catch (UnsupportedEncodingException e) {\r\n            return node.getData();\r\n        }\r\n    }\r\n\r\n    private void changeTimeFormat() {\r\n        if (\"timestamp\".equals(mtimeLabel.getProperties().get(\"format\"))) {\r\n            showDateTime();\r\n        } else {\r\n            showTimestamp();\r\n        }\r\n    }\r\n\r\n    private void showDateTime() {\r\n        final Object ctime = ctimeField.getProperties().getOrDefault(\"dateTime\", \"\");\r\n        ctimeField.setText(ctime.toString());\r\n        final Object mtime = mtimeField.getProperties().getOrDefault(\"dateTime\", \"\");\r\n        mtimeField.setText(mtime.toString());\r\n        ctimeLabel.getProperties().put(\"format\", \"dateTime\");\r\n        mtimeLabel.getProperties().put(\"format\", \"dateTime\");\r\n    }\r\n\r\n    private void showTimestamp() {\r\n        final Object ctime = ctimeField.getProperties().getOrDefault(\"timestamp\", \"\");\r\n        ctimeField.setText(ctime.toString());\r\n        final Object mtime = mtimeField.getProperties().getOrDefault(\"timestamp\", \"\");\r\n        mtimeField.setText(mtime.toString());\r\n        ctimeLabel.getProperties().put(\"format\", \"timestamp\");\r\n        mtimeLabel.getProperties().put(\"format\", \"timestamp\");\r\n    }\r\n\r\n    private String format(long timestamp) {\r\n        if (timestamp == 0) {\r\n            return \"-\";\r\n        } else {\r\n            return OffsetDateTime.ofInstant(Instant.ofEpochMilli(timestamp), ZoneId.systemDefault())\r\n                    .format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"));\r\n        }\r\n    }\r\n\r\n    private void resetTextField() {\r\n        dataCodeArea.clear();\r\n        ephemeralOwnerField.clear();\r\n        cZxidField.clear();\r\n        mtimeField.clear();\r\n        pZxidField.clear();\r\n        ctimeField.clear();\r\n        mZxidField.clear();\r\n        dataLengthField.clear();\r\n        numChildrenField.clear();\r\n        dataVersionField.clear();\r\n        aclVersionField.clear();\r\n        cVersionField.clear();\r\n        pathField.clear();\r\n    }\r\n\r\n    private void dataJsonFormat() {\r\n        final Object data = dataCodeArea.getProperties().get(\"raw\");\r\n        if (data == null) {\r\n            return;\r\n        }\r\n        final String prettyJson;\r\n        try {\r\n            prettyJson = Formatters.prettyJson(data.toString());\r\n            setCodeAreaData(prettyJson);\r\n            switchFormatButton(jsonFormatButton);\r\n        } catch (JsonProcessingException e) {\r\n            VToast.error(\"JSON format failed\");\r\n        }\r\n    }\r\n\r\n    private void dataXmlFormat() {\r\n        final Object data = dataCodeArea.getProperties().get(\"raw\");\r\n        if (data == null) {\r\n            return;\r\n        }\r\n        final String prettyXML;\r\n        try {\r\n            prettyXML = Formatters.prettyXml(data.toString());\r\n            setCodeAreaData(prettyXML);\r\n            switchFormatButton(xmlFormatButton);\r\n        } catch (Exception e) {\r\n            VToast.error(\"XML format failed\");\r\n        }\r\n    }\r\n\r\n    private void dataRawFormat() {\r\n        final Object data = dataCodeArea.getProperties().get(\"raw\");\r\n        if (data == null) {\r\n            return;\r\n        }\r\n        setCodeAreaData(data.toString());\r\n        switchFormatButton(rawFormatButton);\r\n    }\r\n\r\n    private void switchFormatButton(Button button) {\r\n        button.setTextFill(Color.valueOf(\"#3F51B5\"));\r\n        formatButtons.stream().filter(b -> b != button).forEach(b -> b.setTextFill(Color.valueOf(\"#000\")));\r\n    }\r\n"]], "pred": {"ppl": 1.7709869146347046, "ppl_lower": 1.8922350406646729, "ppl/lowercase_ppl": -1.1158660331264982, "ppl/zlib": 0.00023617230168845077, "Min_5.0% Prob": 6.3363294694937915, "Min_10.0% Prob": 4.547409203707003, "Min_20.0% Prob": 2.737762674689293, "Min_30.0% Prob": 1.8897565495149762, "Min_40.0% Prob": 1.4257549336703819, "Min_50.0% Prob": 1.143379601935169, "Min_60.0% Prob": 0.9536266567610542}}
{"hexsha": "769b59f14a20333ab57acbfea3828c25b222d52d", "ext": "java", "lang": "Java", "content": "public final class InsertColumnsTokenGenerator implements OptionalSQLTokenGenerator<BaseRule> {\n    \n    @Override\n    public Optional<InsertColumnsToken> generateSQLToken(final SQLStatement sqlStatement, final List<Object> parameters, final BaseRule rule) {\n        Optional<InsertColumnsSegment> insertColumnsSegment = sqlStatement.findSQLSegment(InsertColumnsSegment.class);\n        if (!(sqlStatement instanceof InsertStatement && insertColumnsSegment.isPresent())) {\n            return Optional.absent();\n        }\n        return createInsertColumnsToken((InsertStatement) sqlStatement, rule, insertColumnsSegment.get());\n    }\n    \n    private Optional<InsertColumnsToken> createInsertColumnsToken(final InsertStatement insertStatement, final BaseRule rule, final InsertColumnsSegment segment) {\n        if (!segment.getColumns().isEmpty()) {\n            return Optional.absent();\n        }\n        InsertColumnsToken result = new InsertColumnsToken(segment.getStopIndex(), new LinkedList<>(insertStatement.getColumnNames()), !isNeededToAppendColumns(insertStatement, rule));\n        return Optional.of(result);\n    }\n    \n    private boolean isNeededToAppendColumns(final InsertStatement insertStatement, final BaseRule rule) {\n        if (rule instanceof ShardingRule) {\n            return isNeededToAppendColumns(insertStatement, (ShardingRule) rule);\n        }\n        if (rule instanceof EncryptRule) {\n            return isNeededToAppendColumns(insertStatement.getTables().getSingleTableName(), (EncryptRule) rule);\n        }\n        return false;\n    }\n    \n    private boolean isNeededToAppendColumns(final InsertStatement insertStatement, final ShardingRule shardingRule) {\n        String tableName = insertStatement.getTables().getSingleTableName();\n        return isNeededToAppendGeneratedKey(tableName, insertStatement.getColumnNames(), shardingRule) || isNeededToAppendColumns(tableName, shardingRule.getEncryptRule());\n    }\n    \n    private boolean isNeededToAppendGeneratedKey(final String tableName, final Collection<String> columnNames, final ShardingRule shardingRule) {\n        Optional<String> generateKeyColumnName = shardingRule.findGenerateKeyColumnName(tableName);\n        return generateKeyColumnName.isPresent() && !columnNames.contains(generateKeyColumnName.get());\n    }\n    \n    private boolean isNeededToAppendColumns(final String tableName, final EncryptRule encryptRule) {\n        return !encryptRule.getEncryptorEngine().getAssistedQueryColumns(tableName).isEmpty();\n    }\n}", "item_id": 0, "repo": "zhaosoft1982/sharding-sphere", "file": "sharding-core/sharding-core-rewrite/src/main/java/org/apache/shardingsphere/core/rewrite/token/generator/InsertColumnsTokenGenerator.java", "last_update_at": "2022-01-19T02:49:36+00:00", "question_id": "769b59f14a20333ab57acbfea3828c25b222d52d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class InsertColumnsTokenGenerator implements OptionalSQLTokenGenerator<BaseRule> {\n    @Override\n    public Optional<InsertColumnsToken> generateSQLToken(final SQLStatement sqlStatement, final List<Object> parameters, final BaseRule rule) {\n        Optional<InsertColumnsSegment> insertColumnsSegment = sqlStatement.findSQLSegment(InsertColumnsSegment.class);\n        if (!(sqlStatement instanceof InsertStatement && insertColumnsSegment.isPresent())) {\n            return Optional.absent();\n        }\n        return createInsertColumnsToken((InsertStatement) sqlStatement, rule, insertColumnsSegment.get());\n    }\n    private Optional<InsertColumnsToken> createInsertColumnsToken(final InsertStatement insertStatement, final BaseRule rule, final InsertColumnsSegment segment) {\n        if (!segment.getColumns().isEmpty()) {\n            return Optional.absent();\n        }\n        InsertColumnsToken result = new InsertColumnsToken(segment.getStopIndex(), new LinkedList<>(insertStatement.getColumnNames()), !isNeededToAppendColumns(insertStatement, rule));\n        return Optional.of(result);\n    }\n    private boolean isNeededToAppendColumns(final InsertStatement insertStatement, final BaseRule rule) {\n        if (rule instanceof ShardingRule) {\n            return isNeededToAppendColumns(insertStatement, (ShardingRule) rule);\n        }\n        if (rule instanceof EncryptRule) {\n            return isNeededToAppendColumns(insertStatement.getTables().getSingleTableName(), (EncryptRule) rule);\n        }\n        return false;\n    }\n    private boolean isNeededToAppendColumns(final InsertStatement insertStatement, final ShardingRule shardingRule) {\n        String tableName = insertStatement.getTables().getSingleTableName();\n        return isNeededToAppendGeneratedKey(tableName, insertStatement.getColumnNames(), shardingRule) || isNeededToAppendColumns(tableName, shardingRule.getEncryptRule());\n    }\n    private boolean isNeededToAppendGeneratedKey(final String tableName, final Collection<String> columnNames, final ShardingRule shardingRule) {\n        Optional<String> generateKeyColumnName = shardingRule.findGenerateKeyColumnName(tableName);\n        return generateKeyColumnName.isPresent() && !columnNames.contains(generateKeyColumnName.get());\n    }\n    private boolean isNeededToAppendColumns(final String tableName, final EncryptRule encryptRule) {\n        return !encryptRule.getEncryptorEngine().getAssistedQueryColumns(tableName).isEmpty();\n    }\n"]], "pred": {"ppl": 1.6167019605636597, "ppl_lower": 2.0762195587158203, "ppl/lowercase_ppl": -1.5207464467505483, "ppl/zlib": 0.0007379235749915112, "Min_5.0% Prob": 5.6158432801564535, "Min_10.0% Prob": 3.844391238689423, "Min_20.0% Prob": 2.306590278695027, "Min_30.0% Prob": 1.5923888203584486, "Min_40.0% Prob": 1.198913221738274, "Min_50.0% Prob": 0.961687809735091, "Min_60.0% Prob": 0.802254485741317}}
{"hexsha": "300f73cad482defce27b88d7ca89f6802695f210", "ext": "java", "lang": "Java", "content": "@JSON(strict = true)\npublic class SubscriptionModelImpl\n\textends BaseModelImpl<Subscription> implements SubscriptionModel {\n\n\t/*\n\t * NOTE FOR DEVELOPERS:\n\t *\n\t * Never modify or reference this class directly. All methods that expect a subscription model instance should use the <code>Subscription</code> interface instead.\n\t */\n\tpublic static final String TABLE_NAME = \"IoTCatalogue_Subscription\";\n\n\tpublic static final Object[][] TABLE_COLUMNS = {\n\t\t{\"uuid_\", Types.VARCHAR}, {\"subscriptionId\", Types.BIGINT},\n\t\t{\"groupId\", Types.BIGINT}, {\"companyId\", Types.BIGINT},\n\t\t{\"userId\", Types.BIGINT}, {\"userName\", Types.VARCHAR},\n\t\t{\"createDate\", Types.TIMESTAMP}, {\"modifiedDate\", Types.TIMESTAMP},\n\t\t{\"status\", Types.INTEGER}, {\"statusByUserId\", Types.BIGINT},\n\t\t{\"statusByUserName\", Types.VARCHAR}, {\"statusDate\", Types.TIMESTAMP},\n\t\t{\"connectionId\", Types.VARCHAR}, {\"connectionState\", Types.VARCHAR},\n\t\t{\"token\", Types.VARCHAR}, {\"host\", Types.VARCHAR},\n\t\t{\"componentPagePath\", Types.VARCHAR},\n\t\t{\"validationPagePath\", Types.VARCHAR}, {\"port\", Types.INTEGER},\n\t\t{\"useSSL\", Types.BOOLEAN}\n\t};\n\n\tpublic static final Map<String, Integer> TABLE_COLUMNS_MAP =\n\t\tnew HashMap<String, Integer>();\n\n\tstatic {\n\t\tTABLE_COLUMNS_MAP.put(\"uuid_\", Types.VARCHAR);\n\t\tTABLE_COLUMNS_MAP.put(\"subscriptionId\", Types.BIGINT);\n\t\tTABLE_COLUMNS_MAP.put(\"groupId\", Types.BIGINT);\n\t\tTABLE_COLUMNS_MAP.put(\"companyId\", Types.BIGINT);\n\t\tTABLE_COLUMNS_MAP.put(\"userId\", Types.BIGINT);\n\t\tTABLE_COLUMNS_MAP.put(\"userName\", Types.VARCHAR);\n\t\tTABLE_COLUMNS_MAP.put(\"createDate\", Types.TIMESTAMP);\n\t\tTABLE_COLUMNS_MAP.put(\"modifiedDate\", Types.TIMESTAMP);\n\t\tTABLE_COLUMNS_MAP.put(\"status\", Types.INTEGER);\n\t\tTABLE_COLUMNS_MAP.put(\"statusByUserId\", Types.BIGINT);\n\t\tTABLE_COLUMNS_MAP.put(\"statusByUserName\", Types.VARCHAR);\n\t\tTABLE_COLUMNS_MAP.put(\"statusDate\", Types.TIMESTAMP);\n\t\tTABLE_COLUMNS_MAP.put(\"connectionId\", Types.VARCHAR);\n\t\tTABLE_COLUMNS_MAP.put(\"connectionState\", Types.VARCHAR);\n\t\tTABLE_COLUMNS_MAP.put(\"token\", Types.VARCHAR);\n\t\tTABLE_COLUMNS_MAP.put(\"host\", Types.VARCHAR);\n\t\tTABLE_COLUMNS_MAP.put(\"componentPagePath\", Types.VARCHAR);\n\t\tTABLE_COLUMNS_MAP.put(\"validationPagePath\", Types.VARCHAR);\n\t\tTABLE_COLUMNS_MAP.put(\"port\", Types.INTEGER);\n\t\tTABLE_COLUMNS_MAP.put(\"useSSL\", Types.BOOLEAN);\n\t}\n\n\tpublic static final String TABLE_SQL_CREATE =\n\t\t\"create table IoTCatalogue_Subscription (uuid_ VARCHAR(75) null,subscriptionId LONG not null primary key,groupId LONG,companyId LONG,userId LONG,userName VARCHAR(75) null,createDate DATE null,modifiedDate DATE null,status INTEGER,statusByUserId LONG,statusByUserName VARCHAR(75) null,statusDate DATE null,connectionId VARCHAR(75) null,connectionState VARCHAR(75) null,token VARCHAR(75) null,host VARCHAR(75) null,componentPagePath VARCHAR(75) null,validationPagePath VARCHAR(75) null,port INTEGER,useSSL BOOLEAN)\";\n\n\tpublic static final String TABLE_SQL_DROP =\n\t\t\"drop table IoTCatalogue_Subscription\";\n\n\tpublic static final String ORDER_BY_JPQL =\n\t\t\" ORDER BY subscription.subscriptionId ASC\";\n\n\tpublic static final String ORDER_BY_SQL =\n\t\t\" ORDER BY IoTCatalogue_Subscription.subscriptionId ASC\";\n\n\tpublic static final String DATA_SOURCE = \"liferayDataSource\";\n\n\tpublic static final String SESSION_FACTORY = \"liferaySessionFactory\";\n\n\tpublic static final String TX_MANAGER = \"liferayTransactionManager\";\n\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), replaced by {@link #getColumnBitmask(String)}\n\t */\n\t@Deprecated\n\tpublic static final long COMPANYID_COLUMN_BITMASK = 1L;\n\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), replaced by {@link #getColumnBitmask(String)}\n\t */\n\t@Deprecated\n\tpublic static final long GROUPID_COLUMN_BITMASK = 2L;\n\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), replaced by {@link #getColumnBitmask(String)}\n\t */\n\t@Deprecated\n\tpublic static final long SUBSCRIPTIONID_COLUMN_BITMASK = 4L;\n\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), replaced by {@link #getColumnBitmask(String)}\n\t */\n\t@Deprecated\n\tpublic static final long UUID_COLUMN_BITMASK = 8L;\n\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), with no direct replacement\n\t */\n\t@Deprecated\n\tpublic static void setEntityCacheEnabled(boolean entityCacheEnabled) {\n\t}\n\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), with no direct replacement\n\t */\n\t@Deprecated\n\tpublic static void setFinderCacheEnabled(boolean finderCacheEnabled) {\n\t}\n\n\t/**\n\t * Converts the soap model instance into a normal model instance.\n\t *\n\t * @param soapModel the soap model instance to convert\n\t * @return the normal model instance\n\t * @deprecated As of Athanasius (7.3.x), with no direct replacement\n\t */\n\t@Deprecated\n\tpublic static Subscription toModel(SubscriptionSoap soapModel) {\n\t\tif (soapModel == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tSubscription model = new SubscriptionImpl();\n\n\t\tmodel.setUuid(soapModel.getUuid());\n\t\tmodel.setSubscriptionId(soapModel.getSubscriptionId());\n\t\tmodel.setGroupId(soapModel.getGroupId());\n\t\tmodel.setCompanyId(soapModel.getCompanyId());\n\t\tmodel.setUserId(soapModel.getUserId());\n\t\tmodel.setUserName(soapModel.getUserName());\n\t\tmodel.setCreateDate(soapModel.getCreateDate());\n\t\tmodel.setModifiedDate(soapModel.getModifiedDate());\n\t\tmodel.setStatus(soapModel.getStatus());\n\t\tmodel.setStatusByUserId(soapModel.getStatusByUserId());\n\t\tmodel.setStatusByUserName(soapModel.getStatusByUserName());\n\t\tmodel.setStatusDate(soapModel.getStatusDate());\n\t\tmodel.setConnectionId(soapModel.getConnectionId());\n\t\tmodel.setConnectionState(soapModel.getConnectionState());\n\t\tmodel.setToken(soapModel.getToken());\n\t\tmodel.setHost(soapModel.getHost());\n\t\tmodel.setComponentPagePath(soapModel.getComponentPagePath());\n\t\tmodel.setValidationPagePath(soapModel.getValidationPagePath());\n\t\tmodel.setPort(soapModel.getPort());\n\t\tmodel.setUseSSL(soapModel.isUseSSL());\n\n\t\treturn model;\n\t}\n\n\t/**\n\t * Converts the soap model instances into normal model instances.\n\t *\n\t * @param soapModels the soap model instances to convert\n\t * @return the normal model instances\n\t * @deprecated As of Athanasius (7.3.x), with no direct replacement\n\t */\n\t@Deprecated\n\tpublic static List<Subscription> toModels(SubscriptionSoap[] soapModels) {\n\t\tif (soapModels == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Subscription> models = new ArrayList<Subscription>(\n\t\t\tsoapModels.length);\n\n\t\tfor (SubscriptionSoap soapModel : soapModels) {\n\t\t\tmodels.add(toModel(soapModel));\n\t\t}\n\n\t\treturn models;\n\t}\n\n\tpublic SubscriptionModelImpl() {\n\t}\n\n\t@Override\n\tpublic long getPrimaryKey() {\n\t\treturn _subscriptionId;\n\t}\n\n\t@Override\n\tpublic void setPrimaryKey(long primaryKey) {\n\t\tsetSubscriptionId(primaryKey);\n\t}\n\n\t@Override\n\tpublic Serializable getPrimaryKeyObj() {\n\t\treturn _subscriptionId;\n\t}\n\n\t@Override\n\tpublic void setPrimaryKeyObj(Serializable primaryKeyObj) {\n\t\tsetPrimaryKey(((Long)primaryKeyObj).longValue());\n\t}\n\n\t@Override\n\tpublic Class<?> getModelClass() {\n\t\treturn Subscription.class;\n\t}\n\n\t@Override\n\tpublic String getModelClassName() {\n\t\treturn Subscription.class.getName();\n\t}\n\n\t@Override\n\tpublic Map<String, Object> getModelAttributes() {\n\t\tMap<String, Object> attributes = new HashMap<String, Object>();\n\n\t\tMap<String, Function<Subscription, Object>> attributeGetterFunctions =\n\t\t\tgetAttributeGetterFunctions();\n\n\t\tfor (Map.Entry<String, Function<Subscription, Object>> entry :\n\t\t\t\tattributeGetterFunctions.entrySet()) {\n\n\t\t\tString attributeName = entry.getKey();\n\t\t\tFunction<Subscription, Object> attributeGetterFunction =\n\t\t\t\tentry.getValue();\n\n\t\t\tattributes.put(\n\t\t\t\tattributeName,\n\t\t\t\tattributeGetterFunction.apply((Subscription)this));\n\t\t}\n\n\t\treturn attributes;\n\t}\n\n\t@Override\n\tpublic void setModelAttributes(Map<String, Object> attributes) {\n\t\tMap<String, BiConsumer<Subscription, Object>>\n\t\t\tattributeSetterBiConsumers = getAttributeSetterBiConsumers();\n\n\t\tfor (Map.Entry<String, Object> entry : attributes.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\n\t\t\tBiConsumer<Subscription, Object> attributeSetterBiConsumer =\n\t\t\t\tattributeSetterBiConsumers.get(attributeName);\n\n\t\t\tif (attributeSetterBiConsumer != null) {\n\t\t\t\tattributeSetterBiConsumer.accept(\n\t\t\t\t\t(Subscription)this, entry.getValue());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic Map<String, Function<Subscription, Object>>\n\t\tgetAttributeGetterFunctions() {\n\n\t\treturn _attributeGetterFunctions;\n\t}\n\n\tpublic Map<String, BiConsumer<Subscription, Object>>\n\t\tgetAttributeSetterBiConsumers() {\n\n\t\treturn _attributeSetterBiConsumers;\n\t}\n\n\tprivate static Function<InvocationHandler, Subscription>\n\t\t_getProxyProviderFunction() {\n\n\t\tClass<?> proxyClass = ProxyUtil.getProxyClass(\n\t\t\tSubscription.class.getClassLoader(), Subscription.class,\n\t\t\tModelWrapper.class);\n\n\t\ttry {\n\t\t\tConstructor<Subscription> constructor =\n\t\t\t\t(Constructor<Subscription>)proxyClass.getConstructor(\n\t\t\t\t\tInvocationHandler.class);\n\n\t\t\treturn invocationHandler -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn constructor.newInstance(invocationHandler);\n\t\t\t\t}\n\t\t\t\tcatch (ReflectiveOperationException\n\t\t\t\t\t\t\treflectiveOperationException) {\n\n\t\t\t\t\tthrow new InternalError(reflectiveOperationException);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tcatch (NoSuchMethodException noSuchMethodException) {\n\t\t\tthrow new InternalError(noSuchMethodException);\n\t\t}\n\t}\n\n\tprivate static final Map<String, Function<Subscription, Object>>\n\t\t_attributeGetterFunctions;\n\tprivate static final Map<String, BiConsumer<Subscription, Object>>\n\t\t_attributeSetterBiConsumers;\n\n\tstatic {\n\t\tMap<String, Function<Subscription, Object>> attributeGetterFunctions =\n\t\t\tnew LinkedHashMap<String, Function<Subscription, Object>>();\n\t\tMap<String, BiConsumer<Subscription, ?>> attributeSetterBiConsumers =\n\t\t\tnew LinkedHashMap<String, BiConsumer<Subscription, ?>>();\n\n\t\tattributeGetterFunctions.put(\"uuid\", Subscription::getUuid);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"uuid\", (BiConsumer<Subscription, String>)Subscription::setUuid);\n\t\tattributeGetterFunctions.put(\n\t\t\t\"subscriptionId\", Subscription::getSubscriptionId);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"subscriptionId\",\n\t\t\t(BiConsumer<Subscription, Long>)Subscription::setSubscriptionId);\n\t\tattributeGetterFunctions.put(\"groupId\", Subscription::getGroupId);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"groupId\",\n\t\t\t(BiConsumer<Subscription, Long>)Subscription::setGroupId);\n\t\tattributeGetterFunctions.put(\"companyId\", Subscription::getCompanyId);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"companyId\",\n\t\t\t(BiConsumer<Subscription, Long>)Subscription::setCompanyId);\n\t\tattributeGetterFunctions.put(\"userId\", Subscription::getUserId);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"userId\", (BiConsumer<Subscription, Long>)Subscription::setUserId);\n\t\tattributeGetterFunctions.put(\"userName\", Subscription::getUserName);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"userName\",\n\t\t\t(BiConsumer<Subscription, String>)Subscription::setUserName);\n\t\tattributeGetterFunctions.put(\"createDate\", Subscription::getCreateDate);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"createDate\",\n\t\t\t(BiConsumer<Subscription, Date>)Subscription::setCreateDate);\n\t\tattributeGetterFunctions.put(\n\t\t\t\"modifiedDate\", Subscription::getModifiedDate);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"modifiedDate\",\n\t\t\t(BiConsumer<Subscription, Date>)Subscription::setModifiedDate);\n\t\tattributeGetterFunctions.put(\"status\", Subscription::getStatus);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"status\",\n\t\t\t(BiConsumer<Subscription, Integer>)Subscription::setStatus);\n\t\tattributeGetterFunctions.put(\n\t\t\t\"statusByUserId\", Subscription::getStatusByUserId);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"statusByUserId\",\n\t\t\t(BiConsumer<Subscription, Long>)Subscription::setStatusByUserId);\n\t\tattributeGetterFunctions.put(\n\t\t\t\"statusByUserName\", Subscription::getStatusByUserName);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"statusByUserName\",\n\t\t\t(BiConsumer<Subscription, String>)\n\t\t\t\tSubscription::setStatusByUserName);\n\t\tattributeGetterFunctions.put(\"statusDate\", Subscription::getStatusDate);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"statusDate\",\n\t\t\t(BiConsumer<Subscription, Date>)Subscription::setStatusDate);\n\t\tattributeGetterFunctions.put(\n\t\t\t\"connectionId\", Subscription::getConnectionId);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"connectionId\",\n\t\t\t(BiConsumer<Subscription, String>)Subscription::setConnectionId);\n\t\tattributeGetterFunctions.put(\n\t\t\t\"connectionState\", Subscription::getConnectionState);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"connectionState\",\n\t\t\t(BiConsumer<Subscription, String>)Subscription::setConnectionState);\n\t\tattributeGetterFunctions.put(\"token\", Subscription::getToken);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"token\", (BiConsumer<Subscription, String>)Subscription::setToken);\n\t\tattributeGetterFunctions.put(\"host\", Subscription::getHost);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"host\", (BiConsumer<Subscription, String>)Subscription::setHost);\n\t\tattributeGetterFunctions.put(\n\t\t\t\"componentPagePath\", Subscription::getComponentPagePath);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"componentPagePath\",\n\t\t\t(BiConsumer<Subscription, String>)\n\t\t\t\tSubscription::setComponentPagePath);\n\t\tattributeGetterFunctions.put(\n\t\t\t\"validationPagePath\", Subscription::getValidationPagePath);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"validationPagePath\",\n\t\t\t(BiConsumer<Subscription, String>)\n\t\t\t\tSubscription::setValidationPagePath);\n\t\tattributeGetterFunctions.put(\"port\", Subscription::getPort);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"port\", (BiConsumer<Subscription, Integer>)Subscription::setPort);\n\t\tattributeGetterFunctions.put(\"useSSL\", Subscription::getUseSSL);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"useSSL\",\n\t\t\t(BiConsumer<Subscription, Boolean>)Subscription::setUseSSL);\n\n\t\t_attributeGetterFunctions = Collections.unmodifiableMap(\n\t\t\tattributeGetterFunctions);\n\t\t_attributeSetterBiConsumers = Collections.unmodifiableMap(\n\t\t\t(Map)attributeSetterBiConsumers);\n\t}\n\n\t@JSON\n\t@Override\n\tpublic String getUuid() {\n\t\tif (_uuid == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn _uuid;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setUuid(String uuid) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_uuid = uuid;\n\t}\n\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), replaced by {@link\n\t *             #getColumnOriginalValue(String)}\n\t */\n\t@Deprecated\n\tpublic String getOriginalUuid() {\n\t\treturn getColumnOriginalValue(\"uuid_\");\n\t}\n\n\t@JSON\n\t@Override\n\tpublic long getSubscriptionId() {\n\t\treturn _subscriptionId;\n\t}\n\n\t@Override\n\tpublic void setSubscriptionId(long subscriptionId) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_subscriptionId = subscriptionId;\n\t}\n\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), replaced by {@link\n\t *             #getColumnOriginalValue(String)}\n\t */\n\t@Deprecated\n\tpublic long getOriginalSubscriptionId() {\n\t\treturn GetterUtil.getLong(\n\t\t\tthis.<Long>getColumnOriginalValue(\"subscriptionId\"));\n\t}\n\n\t@JSON\n\t@Override\n\tpublic long getGroupId() {\n\t\treturn _groupId;\n\t}\n\n\t@Override\n\tpublic void setGroupId(long groupId) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_groupId = groupId;\n\t}\n\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), replaced by {@link\n\t *             #getColumnOriginalValue(String)}\n\t */\n\t@Deprecated\n\tpublic long getOriginalGroupId() {\n\t\treturn GetterUtil.getLong(this.<Long>getColumnOriginalValue(\"groupId\"));\n\t}\n\n\t@JSON\n\t@Override\n\tpublic long getCompanyId() {\n\t\treturn _companyId;\n\t}\n\n\t@Override\n\tpublic void setCompanyId(long companyId) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_companyId = companyId;\n\t}\n\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), replaced by {@link\n\t *             #getColumnOriginalValue(String)}\n\t */\n\t@Deprecated\n\tpublic long getOriginalCompanyId() {\n\t\treturn GetterUtil.getLong(\n\t\t\tthis.<Long>getColumnOriginalValue(\"companyId\"));\n\t}\n\n\t@JSON\n\t@Override\n\tpublic long getUserId() {\n\t\treturn _userId;\n\t}\n\n\t@Override\n\tpublic void setUserId(long userId) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_userId = userId;\n\t}\n\n\t@Override\n\tpublic String getUserUuid() {\n\t\ttry {\n\t\t\tUser user = UserLocalServiceUtil.getUserById(getUserId());\n\n\t\t\treturn user.getUuid();\n\t\t}\n\t\tcatch (PortalException portalException) {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setUserUuid(String userUuid) {\n\t}\n\n\t@JSON\n\t@Override\n\tpublic String getUserName() {\n\t\tif (_userName == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn _userName;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setUserName(String userName) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_userName = userName;\n\t}\n\n\t@JSON\n\t@Override\n\tpublic Date getCreateDate() {\n\t\treturn _createDate;\n\t}\n\n\t@Override\n\tpublic void setCreateDate(Date createDate) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_createDate = createDate;\n\t}\n\n\t@JSON\n\t@Override\n\tpublic Date getModifiedDate() {\n\t\treturn _modifiedDate;\n\t}\n\n\tpublic boolean hasSetModifiedDate() {\n\t\treturn _setModifiedDate;\n\t}\n\n\t@Override\n\tpublic void setModifiedDate(Date modifiedDate) {\n\t\t_setModifiedDate = true;\n\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_modifiedDate = modifiedDate;\n\t}\n\n\t@JSON\n\t@Override\n\tpublic int getStatus() {\n\t\treturn _status;\n\t}\n\n\t@Override\n\tpublic void setStatus(int status) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_status = status;\n\t}\n\n\t@JSON\n\t@Override\n\tpublic long getStatusByUserId() {\n\t\treturn _statusByUserId;\n\t}\n\n\t@Override\n\tpublic void setStatusByUserId(long statusByUserId) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_statusByUserId = statusByUserId;\n\t}\n\n\t@Override\n\tpublic String getStatusByUserUuid() {\n\t\ttry {\n\t\t\tUser user = UserLocalServiceUtil.getUserById(getStatusByUserId());\n\n\t\t\treturn user.getUuid();\n\t\t}\n\t\tcatch (PortalException portalException) {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setStatusByUserUuid(String statusByUserUuid) {\n\t}\n\n\t@JSON\n\t@Override\n\tpublic String getStatusByUserName() {\n\t\tif (_statusByUserName == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn _statusByUserName;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setStatusByUserName(String statusByUserName) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_statusByUserName = statusByUserName;\n\t}\n\n\t@JSON\n\t@Override\n\tpublic Date getStatusDate() {\n\t\treturn _statusDate;\n\t}\n\n\t@Override\n\tpublic void setStatusDate(Date statusDate) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_statusDate = statusDate;\n\t}\n\n\t@JSON\n\t@Override\n\tpublic String getConnectionId() {\n\t\tif (_connectionId == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn _connectionId;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setConnectionId(String connectionId) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_connectionId = connectionId;\n\t}\n\n\t@JSON\n\t@Override\n\tpublic String getConnectionState() {\n\t\tif (_connectionState == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn _connectionState;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setConnectionState(String connectionState) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_connectionState = connectionState;\n\t}\n\n\t@JSON\n\t@Override\n\tpublic String getToken() {\n\t\tif (_token == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn _token;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setToken(String token) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_token = token;\n\t}\n\n\t@JSON\n\t@Override\n\tpublic String getHost() {\n\t\tif (_host == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn _host;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setHost(String host) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_host = host;\n\t}\n\n\t@JSON\n\t@Override\n\tpublic String getComponentPagePath() {\n\t\tif (_componentPagePath == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn _componentPagePath;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setComponentPagePath(String componentPagePath) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_componentPagePath = componentPagePath;\n\t}\n\n\t@JSON\n\t@Override\n\tpublic String getValidationPagePath() {\n\t\tif (_validationPagePath == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn _validationPagePath;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setValidationPagePath(String validationPagePath) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_validationPagePath = validationPagePath;\n\t}\n\n\t@JSON\n\t@Override\n\tpublic Integer getPort() {\n\t\treturn _port;\n\t}\n\n\t@Override\n\tpublic void setPort(Integer port) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_port = port;\n\t}\n\n\t@JSON\n\t@Override\n\tpublic boolean getUseSSL() {\n\t\treturn _useSSL;\n\t}\n\n\t@JSON\n\t@Override\n\tpublic boolean isUseSSL() {\n\t\treturn _useSSL;\n\t}\n\n\t@Override\n\tpublic void setUseSSL(boolean useSSL) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\t_useSSL = useSSL;\n\t}\n\n\t@Override\n\tpublic StagedModelType getStagedModelType() {\n\t\treturn new StagedModelType(\n\t\t\tPortalUtil.getClassNameId(Subscription.class.getName()));\n\t}\n\n\t@Override\n\tpublic boolean isApproved() {\n\t\tif (getStatus() == WorkflowConstants.STATUS_APPROVED) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isDenied() {\n\t\tif (getStatus() == WorkflowConstants.STATUS_DENIED) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isDraft() {\n\t\tif (getStatus() == WorkflowConstants.STATUS_DRAFT) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isExpired() {\n\t\tif (getStatus() == WorkflowConstants.STATUS_EXPIRED) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isInactive() {\n\t\tif (getStatus() == WorkflowConstants.STATUS_INACTIVE) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isIncomplete() {\n\t\tif (getStatus() == WorkflowConstants.STATUS_INCOMPLETE) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isPending() {\n\t\tif (getStatus() == WorkflowConstants.STATUS_PENDING) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isScheduled() {\n\t\tif (getStatus() == WorkflowConstants.STATUS_SCHEDULED) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic long getColumnBitmask() {\n\t\tif (_columnBitmask > 0) {\n\t\t\treturn _columnBitmask;\n\t\t}\n\n\t\tif ((_columnOriginalValues == null) ||\n\t\t\t(_columnOriginalValues == Collections.EMPTY_MAP)) {\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (Map.Entry<String, Object> entry :\n\t\t\t\t_columnOriginalValues.entrySet()) {\n\n\t\t\tif (entry.getValue() != getColumnValue(entry.getKey())) {\n\t\t\t\t_columnBitmask |= _columnBitmasks.get(entry.getKey());\n\t\t\t}\n\t\t}\n\n\t\treturn _columnBitmask;\n\t}\n\n\t@Override\n\tpublic ExpandoBridge getExpandoBridge() {\n\t\treturn ExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\tgetCompanyId(), Subscription.class.getName(), getPrimaryKey());\n\t}\n\n\t@Override\n\tpublic void setExpandoBridgeAttributes(ServiceContext serviceContext) {\n\t\tExpandoBridge expandoBridge = getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\t}\n\n\t@Override\n\tpublic Subscription toEscapedModel() {\n\t\tif (_escapedModel == null) {\n\t\t\tFunction<InvocationHandler, Subscription>\n\t\t\t\tescapedModelProxyProviderFunction =\n\t\t\t\t\tEscapedModelProxyProviderFunctionHolder.\n\t\t\t\t\t\t_escapedModelProxyProviderFunction;\n\n\t\t\t_escapedModel = escapedModelProxyProviderFunction.apply(\n\t\t\t\tnew AutoEscapeBeanHandler(this));\n\t\t}\n\n\t\treturn _escapedModel;\n\t}\n\n\t@Override\n\tpublic Object clone() {\n\t\tSubscriptionImpl subscriptionImpl = new SubscriptionImpl();\n\n\t\tsubscriptionImpl.setUuid(getUuid());\n\t\tsubscriptionImpl.setSubscriptionId(getSubscriptionId());\n\t\tsubscriptionImpl.setGroupId(getGroupId());\n\t\tsubscriptionImpl.setCompanyId(getCompanyId());\n\t\tsubscriptionImpl.setUserId(getUserId());\n\t\tsubscriptionImpl.setUserName(getUserName());\n\t\tsubscriptionImpl.setCreateDate(getCreateDate());\n\t\tsubscriptionImpl.setModifiedDate(getModifiedDate());\n\t\tsubscriptionImpl.setStatus(getStatus());\n\t\tsubscriptionImpl.setStatusByUserId(getStatusByUserId());\n\t\tsubscriptionImpl.setStatusByUserName(getStatusByUserName());\n\t\tsubscriptionImpl.setStatusDate(getStatusDate());\n\t\tsubscriptionImpl.setConnectionId(getConnectionId());\n\t\tsubscriptionImpl.setConnectionState(getConnectionState());\n\t\tsubscriptionImpl.setToken(getToken());\n\t\tsubscriptionImpl.setHost(getHost());\n\t\tsubscriptionImpl.setComponentPagePath(getComponentPagePath());\n\t\tsubscriptionImpl.setValidationPagePath(getValidationPagePath());\n\t\tsubscriptionImpl.setPort(getPort());\n\t\tsubscriptionImpl.setUseSSL(isUseSSL());\n\n\t\tsubscriptionImpl.resetOriginalValues();\n\n\t\treturn subscriptionImpl;\n\t}\n\n\t@Override\n\tpublic int compareTo(Subscription subscription) {\n\t\tlong primaryKey = subscription.getPrimaryKey();\n\n\t\tif (getPrimaryKey() < primaryKey) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if (getPrimaryKey() > primaryKey) {\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean equals(Object object) {\n\t\tif (this == object) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!(object instanceof Subscription)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tSubscription subscription = (Subscription)object;\n\n\t\tlong primaryKey = subscription.getPrimaryKey();\n\n\t\tif (getPrimaryKey() == primaryKey) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (int)getPrimaryKey();\n\t}\n\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), with no direct replacement\n\t */\n\t@Deprecated\n\t@Override\n\tpublic boolean isEntityCacheEnabled() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), with no direct replacement\n\t */\n\t@Deprecated\n\t@Override\n\tpublic boolean isFinderCacheEnabled() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void resetOriginalValues() {\n\t\t_columnOriginalValues = Collections.emptyMap();\n\n\t\t_setModifiedDate = false;\n\n\t\t_columnBitmask = 0;\n\t}\n\n\t@Override\n\tpublic CacheModel<Subscription> toCacheModel() {\n\t\tSubscriptionCacheModel subscriptionCacheModel =\n\t\t\tnew SubscriptionCacheModel();\n\n\t\tsubscriptionCacheModel.uuid = getUuid();\n\n\t\tString uuid = subscriptionCacheModel.uuid;\n\n\t\tif ((uuid != null) && (uuid.length() == 0)) {\n\t\t\tsubscriptionCacheModel.uuid = null;\n\t\t}\n\n\t\tsubscriptionCacheModel.subscriptionId = getSubscriptionId();\n\n\t\tsubscriptionCacheModel.groupId = getGroupId();\n\n\t\tsubscriptionCacheModel.companyId = getCompanyId();\n\n\t\tsubscriptionCacheModel.userId = getUserId();\n\n\t\tsubscriptionCacheModel.userName = getUserName();\n\n\t\tString userName = subscriptionCacheModel.userName;\n\n\t\tif ((userName != null) && (userName.length() == 0)) {\n\t\t\tsubscriptionCacheModel.userName = null;\n\t\t}\n\n\t\tDate createDate = getCreateDate();\n\n\t\tif (createDate != null) {\n\t\t\tsubscriptionCacheModel.createDate = createDate.getTime();\n\t\t}\n\t\telse {\n\t\t\tsubscriptionCacheModel.createDate = Long.MIN_VALUE;\n\t\t}\n\n\t\tDate modifiedDate = getModifiedDate();\n\n\t\tif (modifiedDate != null) {\n\t\t\tsubscriptionCacheModel.modifiedDate = modifiedDate.getTime();\n\t\t}\n\t\telse {\n\t\t\tsubscriptionCacheModel.modifiedDate = Long.MIN_VALUE;\n\t\t}\n\n\t\tsubscriptionCacheModel.status = getStatus();\n\n\t\tsubscriptionCacheModel.statusByUserId = getStatusByUserId();\n\n\t\tsubscriptionCacheModel.statusByUserName = getStatusByUserName();\n\n\t\tString statusByUserName = subscriptionCacheModel.statusByUserName;\n\n\t\tif ((statusByUserName != null) && (statusByUserName.length() == 0)) {\n\t\t\tsubscriptionCacheModel.statusByUserName = null;\n\t\t}\n\n\t\tDate statusDate = getStatusDate();\n\n\t\tif (statusDate != null) {\n\t\t\tsubscriptionCacheModel.statusDate = statusDate.getTime();\n\t\t}\n\t\telse {\n\t\t\tsubscriptionCacheModel.statusDate = Long.MIN_VALUE;\n\t\t}\n\n\t\tsubscriptionCacheModel.connectionId = getConnectionId();\n\n\t\tString connectionId = subscriptionCacheModel.connectionId;\n\n\t\tif ((connectionId != null) && (connectionId.length() == 0)) {\n\t\t\tsubscriptionCacheModel.connectionId = null;\n\t\t}\n\n\t\tsubscriptionCacheModel.connectionState = getConnectionState();\n\n\t\tString connectionState = subscriptionCacheModel.connectionState;\n\n\t\tif ((connectionState != null) && (connectionState.length() == 0)) {\n\t\t\tsubscriptionCacheModel.connectionState = null;\n\t\t}\n\n\t\tsubscriptionCacheModel.token = getToken();\n\n\t\tString token = subscriptionCacheModel.token;\n\n\t\tif ((token != null) && (token.length() == 0)) {\n\t\t\tsubscriptionCacheModel.token = null;\n\t\t}\n\n\t\tsubscriptionCacheModel.host = getHost();\n\n\t\tString host = subscriptionCacheModel.host;\n\n\t\tif ((host != null) && (host.length() == 0)) {\n\t\t\tsubscriptionCacheModel.host = null;\n\t\t}\n\n\t\tsubscriptionCacheModel.componentPagePath = getComponentPagePath();\n\n\t\tString componentPagePath = subscriptionCacheModel.componentPagePath;\n\n\t\tif ((componentPagePath != null) && (componentPagePath.length() == 0)) {\n\t\t\tsubscriptionCacheModel.componentPagePath = null;\n\t\t}\n\n\t\tsubscriptionCacheModel.validationPagePath = getValidationPagePath();\n\n\t\tString validationPagePath = subscriptionCacheModel.validationPagePath;\n\n\t\tif ((validationPagePath != null) &&\n\t\t\t(validationPagePath.length() == 0)) {\n\n\t\t\tsubscriptionCacheModel.validationPagePath = null;\n\t\t}\n\n\t\tInteger port = getPort();\n\n\t\tif (port != null) {\n\t\t\tsubscriptionCacheModel.port = port;\n\t\t}\n\n\t\tsubscriptionCacheModel.useSSL = isUseSSL();\n\n\t\treturn subscriptionCacheModel;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tMap<String, Function<Subscription, Object>> attributeGetterFunctions =\n\t\t\tgetAttributeGetterFunctions();\n\n\t\tStringBundler sb = new StringBundler(\n\t\t\t(4 * attributeGetterFunctions.size()) + 2);\n\n\t\tsb.append(\"{\");\n\n\t\tfor (Map.Entry<String, Function<Subscription, Object>> entry :\n\t\t\t\tattributeGetterFunctions.entrySet()) {\n\n\t\t\tString attributeName = entry.getKey();\n\t\t\tFunction<Subscription, Object> attributeGetterFunction =\n\t\t\t\tentry.getValue();\n\n\t\t\tsb.append(attributeName);\n\t\t\tsb.append(\"=\");\n\t\t\tsb.append(attributeGetterFunction.apply((Subscription)this));\n\t\t\tsb.append(\", \");\n\t\t}\n\n\t\tif (sb.index() > 1) {\n\t\t\tsb.setIndex(sb.index() - 1);\n\t\t}\n\n\t\tsb.append(\"}\");\n\n\t\treturn sb.toString();\n\t}\n\n\t@Override\n\tpublic String toXmlString() {\n\t\tMap<String, Function<Subscription, Object>> attributeGetterFunctions =\n\t\t\tgetAttributeGetterFunctions();\n\n\t\tStringBundler sb = new StringBundler(\n\t\t\t(5 * attributeGetterFunctions.size()) + 4);\n\n\t\tsb.append(\"<model><model-name>\");\n\t\tsb.append(getModelClassName());\n\t\tsb.append(\"</model-name>\");\n\n\t\tfor (Map.Entry<String, Function<Subscription, Object>> entry :\n\t\t\t\tattributeGetterFunctions.entrySet()) {\n\n\t\t\tString attributeName = entry.getKey();\n\t\t\tFunction<Subscription, Object> attributeGetterFunction =\n\t\t\t\tentry.getValue();\n\n\t\t\tsb.append(\"<column><column-name>\");\n\t\t\tsb.append(attributeName);\n\t\t\tsb.append(\"</column-name><column-value><![CDATA[\");\n\t\t\tsb.append(attributeGetterFunction.apply((Subscription)this));\n\t\t\tsb.append(\"]]></column-value></column>\");\n\t\t}\n\n\t\tsb.append(\"</model>\");\n\n\t\treturn sb.toString();\n\t}\n\n\tprivate static class EscapedModelProxyProviderFunctionHolder {\n\n\t\tprivate static final Function<InvocationHandler, Subscription>\n\t\t\t_escapedModelProxyProviderFunction = _getProxyProviderFunction();\n\n\t}\n\n\tprivate String _uuid;\n\tprivate long _subscriptionId;\n\tprivate long _groupId;\n\tprivate long _companyId;\n\tprivate long _userId;\n\tprivate String _userName;\n\tprivate Date _createDate;\n\tprivate Date _modifiedDate;\n\tprivate boolean _setModifiedDate;\n\tprivate int _status;\n\tprivate long _statusByUserId;\n\tprivate String _statusByUserName;\n\tprivate Date _statusDate;\n\tprivate String _connectionId;\n\tprivate String _connectionState;\n\tprivate String _token;\n\tprivate String _host;\n\tprivate String _componentPagePath;\n\tprivate String _validationPagePath;\n\tprivate Integer _port;\n\tprivate boolean _useSSL;\n\n\tpublic <T> T getColumnValue(String columnName) {\n\t\tcolumnName = _attributeNames.getOrDefault(columnName, columnName);\n\n\t\tFunction<Subscription, Object> function = _attributeGetterFunctions.get(\n\t\t\tcolumnName);\n\n\t\tif (function == null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"No attribute getter function found for \" + columnName);\n\t\t}\n\n\t\treturn (T)function.apply((Subscription)this);\n\t}\n\n\tpublic <T> T getColumnOriginalValue(String columnName) {\n\t\tif (_columnOriginalValues == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\n\t\treturn (T)_columnOriginalValues.get(columnName);\n\t}\n\n\tprivate void _setColumnOriginalValues() {\n\t\t_columnOriginalValues = new HashMap<String, Object>();\n\n\t\t_columnOriginalValues.put(\"uuid_\", _uuid);\n\t\t_columnOriginalValues.put(\"subscriptionId\", _subscriptionId);\n\t\t_columnOriginalValues.put(\"groupId\", _groupId);\n\t\t_columnOriginalValues.put(\"companyId\", _companyId);\n\t\t_columnOriginalValues.put(\"userId\", _userId);\n\t\t_columnOriginalValues.put(\"userName\", _userName);\n\t\t_columnOriginalValues.put(\"createDate\", _createDate);\n\t\t_columnOriginalValues.put(\"modifiedDate\", _modifiedDate);\n\t\t_columnOriginalValues.put(\"status\", _status);\n\t\t_columnOriginalValues.put(\"statusByUserId\", _statusByUserId);\n\t\t_columnOriginalValues.put(\"statusByUserName\", _statusByUserName);\n\t\t_columnOriginalValues.put(\"statusDate\", _statusDate);\n\t\t_columnOriginalValues.put(\"connectionId\", _connectionId);\n\t\t_columnOriginalValues.put(\"connectionState\", _connectionState);\n\t\t_columnOriginalValues.put(\"token\", _token);\n\t\t_columnOriginalValues.put(\"host\", _host);\n\t\t_columnOriginalValues.put(\"componentPagePath\", _componentPagePath);\n\t\t_columnOriginalValues.put(\"validationPagePath\", _validationPagePath);\n\t\t_columnOriginalValues.put(\"port\", _port);\n\t\t_columnOriginalValues.put(\"useSSL\", _useSSL);\n\t}\n\n\tprivate static final Map<String, String> _attributeNames;\n\n\tstatic {\n\t\tMap<String, String> attributeNames = new HashMap<>();\n\n\t\tattributeNames.put(\"uuid_\", \"uuid\");\n\n\t\t_attributeNames = Collections.unmodifiableMap(attributeNames);\n\t}\n\n\tprivate transient Map<String, Object> _columnOriginalValues;\n\n\tpublic static long getColumnBitmask(String columnName) {\n\t\treturn _columnBitmasks.get(columnName);\n\t}\n\n\tprivate static final Map<String, Long> _columnBitmasks;\n\n\tstatic {\n\t\tMap<String, Long> columnBitmasks = new HashMap<>();\n\n\t\tcolumnBitmasks.put(\"uuid_\", 1L);\n\n\t\tcolumnBitmasks.put(\"subscriptionId\", 2L);\n\n\t\tcolumnBitmasks.put(\"groupId\", 4L);\n\n\t\tcolumnBitmasks.put(\"companyId\", 8L);\n\n\t\tcolumnBitmasks.put(\"userId\", 16L);\n\n\t\tcolumnBitmasks.put(\"userName\", 32L);\n\n\t\tcolumnBitmasks.put(\"createDate\", 64L);\n\n\t\tcolumnBitmasks.put(\"modifiedDate\", 128L);\n\n\t\tcolumnBitmasks.put(\"status\", 256L);\n\n\t\tcolumnBitmasks.put(\"statusByUserId\", 512L);\n\n\t\tcolumnBitmasks.put(\"statusByUserName\", 1024L);\n\n\t\tcolumnBitmasks.put(\"statusDate\", 2048L);\n\n\t\tcolumnBitmasks.put(\"connectionId\", 4096L);\n\n\t\tcolumnBitmasks.put(\"connectionState\", 8192L);\n\n\t\tcolumnBitmasks.put(\"token\", 16384L);\n\n\t\tcolumnBitmasks.put(\"host\", 32768L);\n\n\t\tcolumnBitmasks.put(\"componentPagePath\", 65536L);\n\n\t\tcolumnBitmasks.put(\"validationPagePath\", 131072L);\n\n\t\tcolumnBitmasks.put(\"port\", 262144L);\n\n\t\tcolumnBitmasks.put(\"useSSL\", 524288L);\n\n\t\t_columnBitmasks = Collections.unmodifiableMap(columnBitmasks);\n\t}\n\n\tprivate long _columnBitmask;\n\tprivate Subscription _escapedModel;\n\n}", "item_id": 0, "repo": "unparallel-innovation/iot-catalogue-plugin-liferay", "file": "modules/iot-catalogue-elements/iot-catalogue-elements-service/src/main/java/com/iot_catalogue/model/impl/SubscriptionModelImpl.java", "last_update_at": "2022-03-15T11:11:42+00:00", "question_id": "300f73cad482defce27b88d7ca89f6802695f210_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@JSON(strict = true)\npublic class SubscriptionModelImpl\n\textends BaseModelImpl<Subscription> implements SubscriptionModel {\n\t/*\n\t * NOTE FOR DEVELOPERS:\n\t *\n\t * Never modify or reference this class directly. All methods that expect a subscription model instance should use the <code>Subscription</code> interface instead.\n\t */\n\tpublic static final String TABLE_NAME = \"IoTCatalogue_Subscription\";\n\tpublic static final Object[][] TABLE_COLUMNS = {\n\t\t{\"uuid_\", Types.VARCHAR}, {\"subscriptionId\", Types.BIGINT},\n\t\t{\"groupId\", Types.BIGINT}, {\"companyId\", Types.BIGINT},\n\t\t{\"userId\", Types.BIGINT}, {\"userName\", Types.VARCHAR},\n\t\t{\"createDate\", Types.TIMESTAMP}, {\"modifiedDate\", Types.TIMESTAMP},\n\t\t{\"status\", Types.INTEGER}, {\"statusByUserId\", Types.BIGINT},\n\t\t{\"statusByUserName\", Types.VARCHAR}, {\"statusDate\", Types.TIMESTAMP},\n\t\t{\"connectionId\", Types.VARCHAR}, {\"connectionState\", Types.VARCHAR},\n\t\t{\"token\", Types.VARCHAR}, {\"host\", Types.VARCHAR},\n\t\t{\"componentPagePath\", Types.VARCHAR},\n\t\t{\"validationPagePath\", Types.VARCHAR}, {\"port\", Types.INTEGER},\n\t\t{\"useSSL\", Types.BOOLEAN}\n\t};\n\tpublic static final Map<String, Integer> TABLE_COLUMNS_MAP =\n\t\tnew HashMap<String, Integer>();\n\tstatic {\n\t\tTABLE_COLUMNS_MAP.put(\"uuid_\", Types.VARCHAR);\n\t\tTABLE_COLUMNS_MAP.put(\"subscriptionId\", Types.BIGINT);\n\t\tTABLE_COLUMNS_MAP.put(\"groupId\", Types.BIGINT);\n\t\tTABLE_COLUMNS_MAP.put(\"companyId\", Types.BIGINT);\n\t\tTABLE_COLUMNS_MAP.put(\"userId\", Types.BIGINT);\n\t\tTABLE_COLUMNS_MAP.put(\"userName\", Types.VARCHAR);\n\t\tTABLE_COLUMNS_MAP.put(\"createDate\", Types.TIMESTAMP);\n\t\tTABLE_COLUMNS_MAP.put(\"modifiedDate\", Types.TIMESTAMP);\n\t\tTABLE_COLUMNS_MAP.put(\"status\", Types.INTEGER);\n\t\tTABLE_COLUMNS_MAP.put(\"statusByUserId\", Types.BIGINT);\n\t\tTABLE_COLUMNS_MAP.put(\"statusByUserName\", Types.VARCHAR);\n\t\tTABLE_COLUMNS_MAP.put(\"statusDate\", Types.TIMESTAMP);\n\t\tTABLE_COLUMNS_MAP.put(\"connectionId\", Types.VARCHAR);\n\t\tTABLE_COLUMNS_MAP.put(\"connectionState\", Types.VARCHAR);\n\t\tTABLE_COLUMNS_MAP.put(\"token\", Types.VARCHAR);\n\t\tTABLE_COLUMNS_MAP.put(\"host\", Types.VARCHAR);\n\t\tTABLE_COLUMNS_MAP.put(\"componentPagePath\", Types.VARCHAR);\n\t\tTABLE_COLUMNS_MAP.put(\"validationPagePath\", Types.VARCHAR);\n\t\tTABLE_COLUMNS_MAP.put(\"port\", Types.INTEGER);\n\t\tTABLE_COLUMNS_MAP.put(\"useSSL\", Types.BOOLEAN);\n\t}\n\tpublic static final String TABLE_SQL_CREATE =\n\t\t\"create table IoTCatalogue_Subscription (uuid_ VARCHAR(75) null,subscriptionId LONG not null primary key,groupId LONG,companyId LONG,userId LONG,userName VARCHAR(75) null,createDate DATE null,modifiedDate DATE null,status INTEGER,statusByUserId LONG,statusByUserName VARCHAR(75) null,statusDate DATE null,connectionId VARCHAR(75) null,connectionState VARCHAR(75) null,token VARCHAR(75) null,host VARCHAR(75) null,componentPagePath VARCHAR(75) null,validationPagePath VARCHAR(75) null,port INTEGER,useSSL BOOLEAN)\";\n\tpublic static final String TABLE_SQL_DROP =\n\t\t\"drop table IoTCatalogue_Subscription\";\n\tpublic static final String ORDER_BY_JPQL =\n\t\t\" ORDER BY subscription.subscriptionId ASC\";\n\tpublic static final String ORDER_BY_SQL =\n\t\t\" ORDER BY IoTCatalogue_Subscription.subscriptionId ASC\";\n\tpublic static final String DATA_SOURCE = \"liferayDataSource\";\n\tpublic static final String SESSION_FACTORY = \"liferaySessionFactory\";\n\tpublic static final String TX_MANAGER = \"liferayTransactionManager\";\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), replaced by {@link #getColumnBitmask(String)}\n\t */\n\t@Deprecated\n\tpublic static final long COMPANYID_COLUMN_BITMASK = 1L;\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), replaced by {@link #getColumnBitmask(String)}\n\t */\n\t@Deprecated\n\tpublic static final long GROUPID_COLUMN_BITMASK = 2L;\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), replaced by {@link #getColumnBitmask(String)}\n\t */\n\t@Deprecated\n\tpublic static final long SUBSCRIPTIONID_COLUMN_BITMASK = 4L;\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), replaced by {@link #getColumnBitmask(String)}\n\t */\n\t@Deprecated\n\tpublic static final long UUID_COLUMN_BITMASK = 8L;\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), with no direct replacement\n\t */\n\t@Deprecated\n\tpublic static void setEntityCacheEnabled(boolean entityCacheEnabled) {\n\t}\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), with no direct replacement\n\t */\n\t@Deprecated\n\tpublic static void setFinderCacheEnabled(boolean finderCacheEnabled) {\n\t}\n\t/**\n\t * Converts the soap model instance into a normal model instance.\n\t *\n\t * @param soapModel the soap model instance to convert\n\t * @return the normal model instance\n\t * @deprecated As of Athanasius (7.3.x), with no direct replacement\n\t */\n\t@Deprecated\n\tpublic static Subscription toModel(SubscriptionSoap soapModel) {\n\t\tif (soapModel == null) {\n\t\t\treturn null;\n\t\t}\n\t\tSubscription model = new SubscriptionImpl();\n\t\tmodel.setUuid(soapModel.getUuid());\n\t\tmodel.setSubscriptionId(soapModel.getSubscriptionId());\n\t\tmodel.setGroupId(soapModel.getGroupId());\n\t\tmodel.setCompanyId(soapModel.getCompanyId());\n\t\tmodel.setUserId(soapModel.getUserId());\n\t\tmodel.setUserName(soapModel.getUserName());\n\t\tmodel.setCreateDate(soapModel.getCreateDate());\n\t\tmodel.setModifiedDate(soapModel.getModifiedDate());\n\t\tmodel.setStatus(soapModel.getStatus());\n\t\tmodel.setStatusByUserId(soapModel.getStatusByUserId());\n\t\tmodel.setStatusByUserName(soapModel.getStatusByUserName());\n\t\tmodel.setStatusDate(soapModel.getStatusDate());\n\t\tmodel.setConnectionId(soapModel.getConnectionId());\n\t\tmodel.setConnectionState(soapModel.getConnectionState());\n\t\tmodel.setToken(soapModel.getToken());\n\t\tmodel.setHost(soapModel.getHost());\n\t\tmodel.setComponentPagePath(soapModel.getComponentPagePath());\n\t\tmodel.setValidationPagePath(soapModel.getValidationPagePath());\n\t\tmodel.setPort(soapModel.getPort());\n\t\tmodel.setUseSSL(soapModel.isUseSSL());\n\t\treturn model;\n\t}\n\t/**\n\t * Converts the soap model instances into normal model instances.\n\t *\n\t * @param soapModels the soap model instances to convert\n\t * @return the normal model instances\n\t * @deprecated As of Athanasius (7.3.x), with no direct replacement\n\t */\n\t@Deprecated\n\tpublic static List<Subscription> toModels(SubscriptionSoap[] soapModels) {\n\t\tif (soapModels == null) {\n\t\t\treturn null;\n\t\t}\n\t\tList<Subscription> models = new ArrayList<Subscription>(\n\t\t\tsoapModels.length);\n\t\tfor (SubscriptionSoap soapModel : soapModels) {\n\t\t\tmodels.add(toModel(soapModel));\n\t\t}\n\t\treturn models;\n\t}\n\tpublic SubscriptionModelImpl() {\n\t}\n\t@Override\n\tpublic long getPrimaryKey() {\n\t\treturn _subscriptionId;\n\t}\n\t@Override\n\tpublic void setPrimaryKey(long primaryKey) {\n\t\tsetSubscriptionId(primaryKey);\n\t}\n\t@Override\n\tpublic Serializable getPrimaryKeyObj() {\n\t\treturn _subscriptionId;\n\t}\n\t@Override\n\tpublic void setPrimaryKeyObj(Serializable primaryKeyObj) {\n\t\tsetPrimaryKey(((Long)primaryKeyObj).longValue());\n\t}\n\t@Override\n\tpublic Class<?> getModelClass() {\n\t\treturn Subscription.class;\n\t}\n\t@Override\n\tpublic String getModelClassName() {\n\t\treturn Subscription.class.getName();\n\t}\n\t@Override\n\tpublic Map<String, Object> getModelAttributes() {\n\t\tMap<String, Object> attributes = new HashMap<String, Object>();\n\t\tMap<String, Function<Subscription, Object>> attributeGetterFunctions =\n\t\t\tgetAttributeGetterFunctions();\n\t\tfor (Map.Entry<String, Function<Subscription, Object>> entry :\n\t\t\t\tattributeGetterFunctions.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tFunction<Subscription, Object> attributeGetterFunction =\n\t\t\t\tentry.getValue();\n\t\t\tattributes.put(\n\t\t\t\tattributeName,\n\t\t\t\tattributeGetterFunction.apply((Subscription)this));\n\t\t}\n\t\treturn attributes;\n\t}\n\t@Override\n\tpublic void setModelAttributes(Map<String, Object> attributes) {\n\t\tMap<String, BiConsumer<Subscription, Object>>\n\t\t\tattributeSetterBiConsumers = getAttributeSetterBiConsumers();\n\t\tfor (Map.Entry<String, Object> entry : attributes.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tBiConsumer<Subscription, Object> attributeSetterBiConsumer =\n\t\t\t\tattributeSetterBiConsumers.get(attributeName);\n\t\t\tif (attributeSetterBiConsumer != null) {\n\t\t\t\tattributeSetterBiConsumer.accept(\n\t\t\t\t\t(Subscription)this, entry.getValue());\n\t\t\t}\n\t\t}\n\t}\n\tpublic Map<String, Function<Subscription, Object>>\n\t\tgetAttributeGetterFunctions() {\n\t\treturn _attributeGetterFunctions;\n\t}\n\tpublic Map<String, BiConsumer<Subscription, Object>>\n\t\tgetAttributeSetterBiConsumers() {\n\t\treturn _attributeSetterBiConsumers;\n\t}\n\tprivate static Function<InvocationHandler, Subscription>\n\t\t_getProxyProviderFunction() {\n\t\tClass<?> proxyClass = ProxyUtil.getProxyClass(\n\t\t\tSubscription.class.getClassLoader(), Subscription.class,\n\t\t\tModelWrapper.class);\n\t\ttry {\n\t\t\tConstructor<Subscription> constructor =\n\t\t\t\t(Constructor<Subscription>)proxyClass.getConstructor(\n\t\t\t\t\tInvocationHandler.class);\n\t\t\treturn invocationHandler -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn constructor.newInstance(invocationHandler);\n\t\t\t\t}\n\t\t\t\tcatch (ReflectiveOperationException\n\t\t\t\t\t\t\treflectiveOperationException) {\n\t\t\t\t\tthrow new InternalError(reflectiveOperationException);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tcatch (NoSuchMethodException noSuchMethodException) {\n\t\t\tthrow new InternalError(noSuchMethodException);\n\t\t}\n\t}\n\tprivate static final Map<String, Function<Subscription, Object>>\n\t\t_attributeGetterFunctions;\n\tprivate static final Map<String, BiConsumer<Subscription, Object>>\n\t\t_attributeSetterBiConsumers;\n\tstatic {\n\t\tMap<String, Function<Subscription, Object>> attributeGetterFunctions =\n\t\t\tnew LinkedHashMap<String, Function<Subscription, Object>>();\n\t\tMap<String, BiConsumer<Subscription, ?>> attributeSetterBiConsumers =\n\t\t\tnew LinkedHashMap<String, BiConsumer<Subscription, ?>>();\n\t\tattributeGetterFunctions.put(\"uuid\", Subscription::getUuid);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"uuid\", (BiConsumer<Subscription, String>)Subscription::setUuid);\n\t\tattributeGetterFunctions.put(\n\t\t\t\"subscriptionId\", Subscription::getSubscriptionId);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"subscriptionId\",\n\t\t\t(BiConsumer<Subscription, Long>)Subscription::setSubscriptionId);\n\t\tattributeGetterFunctions.put(\"groupId\", Subscription::getGroupId);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"groupId\",\n\t\t\t(BiConsumer<Subscription, Long>)Subscription::setGroupId);\n\t\tattributeGetterFunctions.put(\"companyId\", Subscription::getCompanyId);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"companyId\",\n\t\t\t(BiConsumer<Subscription, Long>)Subscription::setCompanyId);\n\t\tattributeGetterFunctions.put(\"userId\", Subscription::getUserId);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"userId\", (BiConsumer<Subscription, Long>)Subscription::setUserId);\n\t\tattributeGetterFunctions.put(\"userName\", Subscription::getUserName);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"userName\",\n\t\t\t(BiConsumer<Subscription, String>)Subscription::setUserName);\n\t\tattributeGetterFunctions.put(\"createDate\", Subscription::getCreateDate);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"createDate\",\n\t\t\t(BiConsumer<Subscription, Date>)Subscription::setCreateDate);\n\t\tattributeGetterFunctions.put(\n\t\t\t\"modifiedDate\", Subscription::getModifiedDate);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"modifiedDate\",\n\t\t\t(BiConsumer<Subscription, Date>)Subscription::setModifiedDate);\n\t\tattributeGetterFunctions.put(\"status\", Subscription::getStatus);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"status\",\n\t\t\t(BiConsumer<Subscription, Integer>)Subscription::setStatus);\n\t\tattributeGetterFunctions.put(\n\t\t\t\"statusByUserId\", Subscription::getStatusByUserId);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"statusByUserId\",\n\t\t\t(BiConsumer<Subscription, Long>)Subscription::setStatusByUserId);\n\t\tattributeGetterFunctions.put(\n\t\t\t\"statusByUserName\", Subscription::getStatusByUserName);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"statusByUserName\",\n\t\t\t(BiConsumer<Subscription, String>)\n\t\t\t\tSubscription::setStatusByUserName);\n\t\tattributeGetterFunctions.put(\"statusDate\", Subscription::getStatusDate);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"statusDate\",\n\t\t\t(BiConsumer<Subscription, Date>)Subscription::setStatusDate);\n\t\tattributeGetterFunctions.put(\n\t\t\t\"connectionId\", Subscription::getConnectionId);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"connectionId\",\n\t\t\t(BiConsumer<Subscription, String>)Subscription::setConnectionId);\n\t\tattributeGetterFunctions.put(\n\t\t\t\"connectionState\", Subscription::getConnectionState);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"connectionState\",\n\t\t\t(BiConsumer<Subscription, String>)Subscription::setConnectionState);\n\t\tattributeGetterFunctions.put(\"token\", Subscription::getToken);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"token\", (BiConsumer<Subscription, String>)Subscription::setToken);\n\t\tattributeGetterFunctions.put(\"host\", Subscription::getHost);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"host\", (BiConsumer<Subscription, String>)Subscription::setHost);\n\t\tattributeGetterFunctions.put(\n\t\t\t\"componentPagePath\", Subscription::getComponentPagePath);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"componentPagePath\",\n\t\t\t(BiConsumer<Subscription, String>)\n\t\t\t\tSubscription::setComponentPagePath);\n\t\tattributeGetterFunctions.put(\n\t\t\t\"validationPagePath\", Subscription::getValidationPagePath);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"validationPagePath\",\n\t\t\t(BiConsumer<Subscription, String>)\n\t\t\t\tSubscription::setValidationPagePath);\n\t\tattributeGetterFunctions.put(\"port\", Subscription::getPort);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"port\", (BiConsumer<Subscription, Integer>)Subscription::setPort);\n\t\tattributeGetterFunctions.put(\"useSSL\", Subscription::getUseSSL);\n\t\tattributeSetterBiConsumers.put(\n\t\t\t\"useSSL\",\n\t\t\t(BiConsumer<Subscription, Boolean>)Subscription::setUseSSL);\n\t\t_attributeGetterFunctions = Collections.unmodifiableMap(\n\t\t\tattributeGetterFunctions);\n\t\t_attributeSetterBiConsumers = Collections.unmodifiableMap(\n\t\t\t(Map)attributeSetterBiConsumers);\n\t}\n\t@JSON\n\t@Override\n\tpublic String getUuid() {\n\t\tif (_uuid == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn _uuid;\n\t\t}\n\t}\n\t@Override\n\tpublic void setUuid(String uuid) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_uuid = uuid;\n\t}\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), replaced by {@link\n\t *             #getColumnOriginalValue(String)}\n\t */\n\t@Deprecated\n\tpublic String getOriginalUuid() {\n\t\treturn getColumnOriginalValue(\"uuid_\");\n\t}\n\t@JSON\n\t@Override\n\tpublic long getSubscriptionId() {\n\t\treturn _subscriptionId;\n\t}\n\t@Override\n\tpublic void setSubscriptionId(long subscriptionId) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_subscriptionId = subscriptionId;\n\t}\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), replaced by {@link\n\t *             #getColumnOriginalValue(String)}\n\t */\n\t@Deprecated\n\tpublic long getOriginalSubscriptionId() {\n\t\treturn GetterUtil.getLong(\n\t\t\tthis.<Long>getColumnOriginalValue(\"subscriptionId\"));\n\t}\n\t@JSON\n\t@Override\n\tpublic long getGroupId() {\n\t\treturn _groupId;\n\t}\n\t@Override\n\tpublic void setGroupId(long groupId) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_groupId = groupId;\n\t}\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), replaced by {@link\n\t *             #getColumnOriginalValue(String)}\n\t */\n\t@Deprecated\n\tpublic long getOriginalGroupId() {\n\t\treturn GetterUtil.getLong(this.<Long>getColumnOriginalValue(\"groupId\"));\n\t}\n\t@JSON\n\t@Override\n\tpublic long getCompanyId() {\n\t\treturn _companyId;\n\t}\n\t@Override\n\tpublic void setCompanyId(long companyId) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_companyId = companyId;\n\t}\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), replaced by {@link\n\t *             #getColumnOriginalValue(String)}\n\t */\n\t@Deprecated\n\tpublic long getOriginalCompanyId() {\n\t\treturn GetterUtil.getLong(\n\t\t\tthis.<Long>getColumnOriginalValue(\"companyId\"));\n\t}\n\t@JSON\n\t@Override\n\tpublic long getUserId() {\n\t\treturn _userId;\n\t}\n\t@Override\n\tpublic void setUserId(long userId) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_userId = userId;\n\t}\n\t@Override\n\tpublic String getUserUuid() {\n\t\ttry {\n\t\t\tUser user = UserLocalServiceUtil.getUserById(getUserId());\n\t\t\treturn user.getUuid();\n\t\t}\n\t\tcatch (PortalException portalException) {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\t@Override\n\tpublic void setUserUuid(String userUuid) {\n\t}\n\t@JSON\n\t@Override\n\tpublic String getUserName() {\n\t\tif (_userName == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn _userName;\n\t\t}\n\t}\n\t@Override\n\tpublic void setUserName(String userName) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_userName = userName;\n\t}\n\t@JSON\n\t@Override\n\tpublic Date getCreateDate() {\n\t\treturn _createDate;\n\t}\n\t@Override\n\tpublic void setCreateDate(Date createDate) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_createDate = createDate;\n\t}\n\t@JSON\n\t@Override\n\tpublic Date getModifiedDate() {\n\t\treturn _modifiedDate;\n\t}\n\tpublic boolean hasSetModifiedDate() {\n\t\treturn _setModifiedDate;\n\t}\n\t@Override\n\tpublic void setModifiedDate(Date modifiedDate) {\n\t\t_setModifiedDate = true;\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_modifiedDate = modifiedDate;\n\t}\n\t@JSON\n\t@Override\n\tpublic int getStatus() {\n\t\treturn _status;\n\t}\n\t@Override\n\tpublic void setStatus(int status) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_status = status;\n\t}\n\t@JSON\n\t@Override\n\tpublic long getStatusByUserId() {\n\t\treturn _statusByUserId;\n\t}\n\t@Override\n\tpublic void setStatusByUserId(long statusByUserId) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_statusByUserId = statusByUserId;\n\t}\n\t@Override\n\tpublic String getStatusByUserUuid() {\n\t\ttry {\n\t\t\tUser user = UserLocalServiceUtil.getUserById(getStatusByUserId());\n\t\t\treturn user.getUuid();\n\t\t}\n\t\tcatch (PortalException portalException) {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\t@Override\n\tpublic void setStatusByUserUuid(String statusByUserUuid) {\n\t}\n\t@JSON\n\t@Override\n\tpublic String getStatusByUserName() {\n\t\tif (_statusByUserName == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn _statusByUserName;\n\t\t}\n\t}\n\t@Override\n\tpublic void setStatusByUserName(String statusByUserName) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_statusByUserName = statusByUserName;\n\t}\n\t@JSON\n\t@Override\n\tpublic Date getStatusDate() {\n\t\treturn _statusDate;\n\t}\n\t@Override\n\tpublic void setStatusDate(Date statusDate) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_statusDate = statusDate;\n\t}\n\t@JSON\n\t@Override\n\tpublic String getConnectionId() {\n\t\tif (_connectionId == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn _connectionId;\n\t\t}\n\t}\n\t@Override\n\tpublic void setConnectionId(String connectionId) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_connectionId = connectionId;\n\t}\n\t@JSON\n\t@Override\n\tpublic String getConnectionState() {\n\t\tif (_connectionState == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn _connectionState;\n\t\t}\n\t}\n\t@Override\n\tpublic void setConnectionState(String connectionState) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_connectionState = connectionState;\n\t}\n\t@JSON\n\t@Override\n\tpublic String getToken() {\n\t\tif (_token == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn _token;\n\t\t}\n\t}\n\t@Override\n\tpublic void setToken(String token) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_token = token;\n\t}\n\t@JSON\n\t@Override\n\tpublic String getHost() {\n\t\tif (_host == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn _host;\n\t\t}\n\t}\n\t@Override\n\tpublic void setHost(String host) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_host = host;\n\t}\n\t@JSON\n\t@Override\n\tpublic String getComponentPagePath() {\n\t\tif (_componentPagePath == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn _componentPagePath;\n\t\t}\n\t}\n\t@Override\n\tpublic void setComponentPagePath(String componentPagePath) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_componentPagePath = componentPagePath;\n\t}\n\t@JSON\n\t@Override\n\tpublic String getValidationPagePath() {\n\t\tif (_validationPagePath == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn _validationPagePath;\n\t\t}\n\t}\n\t@Override\n\tpublic void setValidationPagePath(String validationPagePath) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_validationPagePath = validationPagePath;\n\t}\n\t@JSON\n\t@Override\n\tpublic Integer getPort() {\n\t\treturn _port;\n\t}\n\t@Override\n\tpublic void setPort(Integer port) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_port = port;\n\t}\n\t@JSON\n\t@Override\n\tpublic boolean getUseSSL() {\n\t\treturn _useSSL;\n\t}\n\t@JSON\n\t@Override\n\tpublic boolean isUseSSL() {\n\t\treturn _useSSL;\n\t}\n\t@Override\n\tpublic void setUseSSL(boolean useSSL) {\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\t_useSSL = useSSL;\n\t}\n\t@Override\n\tpublic StagedModelType getStagedModelType() {\n\t\treturn new StagedModelType(\n\t\t\tPortalUtil.getClassNameId(Subscription.class.getName()));\n\t}\n\t@Override\n\tpublic boolean isApproved() {\n\t\tif (getStatus() == WorkflowConstants.STATUS_APPROVED) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\t@Override\n\tpublic boolean isDenied() {\n\t\tif (getStatus() == WorkflowConstants.STATUS_DENIED) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\t@Override\n\tpublic boolean isDraft() {\n\t\tif (getStatus() == WorkflowConstants.STATUS_DRAFT) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\t@Override\n\tpublic boolean isExpired() {\n\t\tif (getStatus() == WorkflowConstants.STATUS_EXPIRED) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\t@Override\n\tpublic boolean isInactive() {\n\t\tif (getStatus() == WorkflowConstants.STATUS_INACTIVE) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\t@Override\n\tpublic boolean isIncomplete() {\n\t\tif (getStatus() == WorkflowConstants.STATUS_INCOMPLETE) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\t@Override\n\tpublic boolean isPending() {\n\t\tif (getStatus() == WorkflowConstants.STATUS_PENDING) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\t@Override\n\tpublic boolean isScheduled() {\n\t\tif (getStatus() == WorkflowConstants.STATUS_SCHEDULED) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\tpublic long getColumnBitmask() {\n\t\tif (_columnBitmask > 0) {\n\t\t\treturn _columnBitmask;\n\t\t}\n\t\tif ((_columnOriginalValues == null) ||\n\t\t\t(_columnOriginalValues == Collections.EMPTY_MAP)) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (Map.Entry<String, Object> entry :\n\t\t\t\t_columnOriginalValues.entrySet()) {\n\t\t\tif (entry.getValue() != getColumnValue(entry.getKey())) {\n\t\t\t\t_columnBitmask |= _columnBitmasks.get(entry.getKey());\n\t\t\t}\n\t\t}\n\t\treturn _columnBitmask;\n\t}\n\t@Override\n\tpublic ExpandoBridge getExpandoBridge() {\n\t\treturn ExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\tgetCompanyId(), Subscription.class.getName(), getPrimaryKey());\n\t}\n\t@Override\n\tpublic void setExpandoBridgeAttributes(ServiceContext serviceContext) {\n\t\tExpandoBridge expandoBridge = getExpandoBridge();\n\t\texpandoBridge.setAttributes(serviceContext);\n\t}\n\t@Override\n\tpublic Subscription toEscapedModel() {\n\t\tif (_escapedModel == null) {\n\t\t\tFunction<InvocationHandler, Subscription>\n\t\t\t\tescapedModelProxyProviderFunction =\n\t\t\t\t\tEscapedModelProxyProviderFunctionHolder.\n\t\t\t\t\t\t_escapedModelProxyProviderFunction;\n\t\t\t_escapedModel = escapedModelProxyProviderFunction.apply(\n\t\t\t\tnew AutoEscapeBeanHandler(this));\n\t\t}\n\t\treturn _escapedModel;\n\t}\n\t@Override\n\tpublic Object clone() {\n\t\tSubscriptionImpl subscriptionImpl = new SubscriptionImpl();\n\t\tsubscriptionImpl.setUuid(getUuid());\n\t\tsubscriptionImpl.setSubscriptionId(getSubscriptionId());\n\t\tsubscriptionImpl.setGroupId(getGroupId());\n\t\tsubscriptionImpl.setCompanyId(getCompanyId());\n\t\tsubscriptionImpl.setUserId(getUserId());\n\t\tsubscriptionImpl.setUserName(getUserName());\n\t\tsubscriptionImpl.setCreateDate(getCreateDate());\n\t\tsubscriptionImpl.setModifiedDate(getModifiedDate());\n\t\tsubscriptionImpl.setStatus(getStatus());\n\t\tsubscriptionImpl.setStatusByUserId(getStatusByUserId());\n\t\tsubscriptionImpl.setStatusByUserName(getStatusByUserName());\n\t\tsubscriptionImpl.setStatusDate(getStatusDate());\n\t\tsubscriptionImpl.setConnectionId(getConnectionId());\n\t\tsubscriptionImpl.setConnectionState(getConnectionState());\n\t\tsubscriptionImpl.setToken(getToken());\n\t\tsubscriptionImpl.setHost(getHost());\n\t\tsubscriptionImpl.setComponentPagePath(getComponentPagePath());\n\t\tsubscriptionImpl.setValidationPagePath(getValidationPagePath());\n\t\tsubscriptionImpl.setPort(getPort());\n\t\tsubscriptionImpl.setUseSSL(isUseSSL());\n\t\tsubscriptionImpl.resetOriginalValues();\n\t\treturn subscriptionImpl;\n\t}\n\t@Override\n\tpublic int compareTo(Subscription subscription) {\n\t\tlong primaryKey = subscription.getPrimaryKey();\n\t\tif (getPrimaryKey() < primaryKey) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if (getPrimaryKey() > primaryKey) {\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\treturn 0;\n\t\t}\n\t}\n\t@Override\n\tpublic boolean equals(Object object) {\n\t\tif (this == object) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(object instanceof Subscription)) {\n\t\t\treturn false;\n\t\t}\n\t\tSubscription subscription = (Subscription)object;\n\t\tlong primaryKey = subscription.getPrimaryKey();\n\t\tif (getPrimaryKey() == primaryKey) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (int)getPrimaryKey();\n\t}\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), with no direct replacement\n\t */\n\t@Deprecated\n\t@Override\n\tpublic boolean isEntityCacheEnabled() {\n\t\treturn true;\n\t}\n\t/**\n\t * @deprecated As of Athanasius (7.3.x), with no direct replacement\n\t */\n\t@Deprecated\n\t@Override\n\tpublic boolean isFinderCacheEnabled() {\n\t\treturn true;\n\t}\n\t@Override\n\tpublic void resetOriginalValues() {\n\t\t_columnOriginalValues = Collections.emptyMap();\n\t\t_setModifiedDate = false;\n\t\t_columnBitmask = 0;\n\t}\n\t@Override\n\tpublic CacheModel<Subscription> toCacheModel() {\n\t\tSubscriptionCacheModel subscriptionCacheModel =\n\t\t\tnew SubscriptionCacheModel();\n\t\tsubscriptionCacheModel.uuid = getUuid();\n\t\tString uuid = subscriptionCacheModel.uuid;\n\t\tif ((uuid != null) && (uuid.length() == 0)) {\n\t\t\tsubscriptionCacheModel.uuid = null;\n\t\t}\n\t\tsubscriptionCacheModel.subscriptionId = getSubscriptionId();\n\t\tsubscriptionCacheModel.groupId = getGroupId();\n\t\tsubscriptionCacheModel.companyId = getCompanyId();\n\t\tsubscriptionCacheModel.userId = getUserId();\n\t\tsubscriptionCacheModel.userName = getUserName();\n\t\tString userName = subscriptionCacheModel.userName;\n\t\tif ((userName != null) && (userName.length() == 0)) {\n\t\t\tsubscriptionCacheModel.userName = null;\n\t\t}\n\t\tDate createDate = getCreateDate();\n\t\tif (createDate != null) {\n\t\t\tsubscriptionCacheModel.createDate = createDate.getTime();\n\t\t}\n\t\telse {\n\t\t\tsubscriptionCacheModel.createDate = Long.MIN_VALUE;\n\t\t}\n\t\tDate modifiedDate = getModifiedDate();\n\t\tif (modifiedDate != null) {\n\t\t\tsubscriptionCacheModel.modifiedDate = modifiedDate.getTime();\n\t\t}\n\t\telse {\n\t\t\tsubscriptionCacheModel.modifiedDate = Long.MIN_VALUE;\n\t\t}\n\t\tsubscriptionCacheModel.status = getStatus();\n\t\tsubscriptionCacheModel.statusByUserId = getStatusByUserId();\n\t\tsubscriptionCacheModel.statusByUserName = getStatusByUserName();\n\t\tString statusByUserName = subscriptionCacheModel.statusByUserName;\n\t\tif ((statusByUserName != null) && (statusByUserName.length() == 0)) {\n\t\t\tsubscriptionCacheModel.statusByUserName = null;\n\t\t}\n\t\tDate statusDate = getStatusDate();\n\t\tif (statusDate != null) {\n\t\t\tsubscriptionCacheModel.statusDate = statusDate.getTime();\n\t\t}\n\t\telse {\n\t\t\tsubscriptionCacheModel.statusDate = Long.MIN_VALUE;\n\t\t}\n\t\tsubscriptionCacheModel.connectionId = getConnectionId();\n\t\tString connectionId = subscriptionCacheModel.connectionId;\n\t\tif ((connectionId != null) && (connectionId.length() == 0)) {\n\t\t\tsubscriptionCacheModel.connectionId = null;\n\t\t}\n\t\tsubscriptionCacheModel.connectionState = getConnectionState();\n\t\tString connectionState = subscriptionCacheModel.connectionState;\n\t\tif ((connectionState != null) && (connectionState.length() == 0)) {\n\t\t\tsubscriptionCacheModel.connectionState = null;\n\t\t}\n\t\tsubscriptionCacheModel.token = getToken();\n\t\tString token = subscriptionCacheModel.token;\n\t\tif ((token != null) && (token.length() == 0)) {\n\t\t\tsubscriptionCacheModel.token = null;\n\t\t}\n\t\tsubscriptionCacheModel.host = getHost();\n\t\tString host = subscriptionCacheModel.host;\n\t\tif ((host != null) && (host.length() == 0)) {\n\t\t\tsubscriptionCacheModel.host = null;\n\t\t}\n\t\tsubscriptionCacheModel.componentPagePath = getComponentPagePath();\n\t\tString componentPagePath = subscriptionCacheModel.componentPagePath;\n\t\tif ((componentPagePath != null) && (componentPagePath.length() == 0)) {\n\t\t\tsubscriptionCacheModel.componentPagePath = null;\n\t\t}\n\t\tsubscriptionCacheModel.validationPagePath = getValidationPagePath();\n\t\tString validationPagePath = subscriptionCacheModel.validationPagePath;\n\t\tif ((validationPagePath != null) &&\n\t\t\t(validationPagePath.length() == 0)) {\n\t\t\tsubscriptionCacheModel.validationPagePath = null;\n\t\t}\n\t\tInteger port = getPort();\n\t\tif (port != null) {\n\t\t\tsubscriptionCacheModel.port = port;\n\t\t}\n\t\tsubscriptionCacheModel.useSSL = isUseSSL();\n\t\treturn subscriptionCacheModel;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\tMap<String, Function<Subscription, Object>> attributeGetterFunctions =\n\t\t\tgetAttributeGetterFunctions();\n\t\tStringBundler sb = new StringBundler(\n\t\t\t(4 * attributeGetterFunctions.size()) + 2);\n\t\tsb.append(\"{\");\n\t\tfor (Map.Entry<String, Function<Subscription, Object>> entry :\n\t\t\t\tattributeGetterFunctions.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tFunction<Subscription, Object> attributeGetterFunction =\n\t\t\t\tentry.getValue();\n\t\t\tsb.append(attributeName);\n\t\t\tsb.append(\"=\");\n\t\t\tsb.append(attributeGetterFunction.apply((Subscription)this));\n\t\t\tsb.append(\", \");\n\t\t}\n\t\tif (sb.index() > 1) {\n\t\t\tsb.setIndex(sb.index() - 1);\n\t\t}\n\t\tsb.append(\"}\");\n\t\treturn sb.toString();\n\t}\n\t@Override\n\tpublic String toXmlString() {\n\t\tMap<String, Function<Subscription, Object>> attributeGetterFunctions =\n\t\t\tgetAttributeGetterFunctions();\n\t\tStringBundler sb = new StringBundler(\n\t\t\t(5 * attributeGetterFunctions.size()) + 4);\n\t\tsb.append(\"<model><model-name>\");\n\t\tsb.append(getModelClassName());\n\t\tsb.append(\"</model-name>\");\n\t\tfor (Map.Entry<String, Function<Subscription, Object>> entry :\n\t\t\t\tattributeGetterFunctions.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tFunction<Subscription, Object> attributeGetterFunction =\n\t\t\t\tentry.getValue();\n\t\t\tsb.append(\"<column><column-name>\");\n\t\t\tsb.append(attributeName);\n\t\t\tsb.append(\"</column-name><column-value><![CDATA[\");\n\t\t\tsb.append(attributeGetterFunction.apply((Subscription)this));\n\t\t\tsb.append(\"]]></column-value></column>\");\n\t\t}\n\t\tsb.append(\"</model>\");\n\t\treturn sb.toString();\n\t}\n\tprivate static class EscapedModelProxyProviderFunctionHolder {\n\t\tprivate static final Function<InvocationHandler, Subscription>\n\t\t\t_escapedModelProxyProviderFunction = _getProxyProviderFunction();\n\t}\n\tprivate String _uuid;\n\tprivate long _subscriptionId;\n\tprivate long _groupId;\n\tprivate long _companyId;\n\tprivate long _userId;\n\tprivate String _userName;\n\tprivate Date _createDate;\n\tprivate Date _modifiedDate;\n\tprivate boolean _setModifiedDate;\n\tprivate int _status;\n\tprivate long _statusByUserId;\n\tprivate String _statusByUserName;\n\tprivate Date _statusDate;\n\tprivate String _connectionId;\n\tprivate String _connectionState;\n\tprivate String _token;\n\tprivate String _host;\n\tprivate String _componentPagePath;\n\tprivate String _validationPagePath;\n\tprivate Integer _port;\n\tprivate boolean _useSSL;\n\tpublic <T> T getColumnValue(String columnName) {\n\t\tcolumnName = _attributeNames.getOrDefault(columnName, columnName);\n\t\tFunction<Subscription, Object> function = _attributeGetterFunctions.get(\n\t\t\tcolumnName);\n\t\tif (function == null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"No attribute getter function found for \" + columnName);\n\t\t}\n\t\treturn (T)function.apply((Subscription)this);\n\t}\n\tpublic <T> T getColumnOriginalValue(String columnName) {\n\t\tif (_columnOriginalValues == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (_columnOriginalValues == Collections.EMPTY_MAP) {\n\t\t\t_setColumnOriginalValues();\n\t\t}\n\t\treturn (T)_columnOriginalValues.get(columnName);\n\t}\n\tprivate void _setColumnOriginalValues() {\n\t\t_columnOriginalValues = new HashMap<String, Object>();\n\t\t_columnOriginalValues.put(\"uuid_\", _uuid);\n\t\t_columnOriginalValues.put(\"subscriptionId\", _subscriptionId);\n\t\t_columnOriginalValues.put(\"groupId\", _groupId);\n\t\t_columnOriginalValues.put(\"companyId\", _companyId);\n\t\t_columnOriginalValues.put(\"userId\", _userId);\n\t\t_columnOriginalValues.put(\"userName\", _userName);\n\t\t_columnOriginalValues.put(\"createDate\", _createDate);\n\t\t_columnOriginalValues.put(\"modifiedDate\", _modifiedDate);\n\t\t_columnOriginalValues.put(\"status\", _status);\n\t\t_columnOriginalValues.put(\"statusByUserId\", _statusByUserId);\n\t\t_columnOriginalValues.put(\"statusByUserName\", _statusByUserName);\n\t\t_columnOriginalValues.put(\"statusDate\", _statusDate);\n\t\t_columnOriginalValues.put(\"connectionId\", _connectionId);\n\t\t_columnOriginalValues.put(\"connectionState\", _connectionState);\n\t\t_columnOriginalValues.put(\"token\", _token);\n\t\t_columnOriginalValues.put(\"host\", _host);\n\t\t_columnOriginalValues.put(\"componentPagePath\", _componentPagePath);\n\t\t_columnOriginalValues.put(\"validationPagePath\", _validationPagePath);\n\t\t_columnOriginalValues.put(\"port\", _port);\n\t\t_columnOriginalValues.put(\"useSSL\", _useSSL);\n\t}\n\tprivate static final Map<String, String> _attributeNames;\n\tstatic {\n\t\tMap<String, String> attributeNames = new HashMap<>();\n\t\tattributeNames.put(\"uuid_\", \"uuid\");\n\t\t_attributeNames = Collections.unmodifiableMap(attributeNames);\n\t}\n\tprivate transient Map<String, Object> _columnOriginalValues;\n\tpublic static long getColumnBitmask(String columnName) {\n\t\treturn _columnBitmasks.get(columnName);\n\t}\n\tprivate static final Map<String, Long> _columnBitmasks;\n\tstatic {\n\t\tMap<String, Long> columnBitmasks = new HashMap<>();\n\t\tcolumnBitmasks.put(\"uuid_\", 1L);\n\t\tcolumnBitmasks.put(\"subscriptionId\", 2L);\n\t\tcolumnBitmasks.put(\"groupId\", 4L);\n\t\tcolumnBitmasks.put(\"companyId\", 8L);\n\t\tcolumnBitmasks.put(\"userId\", 16L);\n\t\tcolumnBitmasks.put(\"userName\", 32L);\n\t\tcolumnBitmasks.put(\"createDate\", 64L);\n\t\tcolumnBitmasks.put(\"modifiedDate\", 128L);\n\t\tcolumnBitmasks.put(\"status\", 256L);\n\t\tcolumnBitmasks.put(\"statusByUserId\", 512L);\n\t\tcolumnBitmasks.put(\"statusByUserName\", 1024L);\n\t\tcolumnBitmasks.put(\"statusDate\", 2048L);\n\t\tcolumnBitmasks.put(\"connectionId\", 4096L);\n\t\tcolumnBitmasks.put(\"connectionState\", 8192L);\n\t\tcolumnBitmasks.put(\"token\", 16384L);\n\t\tcolumnBitmasks.put(\"host\", 32768L);\n\t\tcolumnBitmasks.put(\"componentPagePath\", 65536L);\n\t\tcolumnBitmasks.put(\"validationPagePath\", 131072L);\n\t\tcolumnBitmasks.put(\"port\", 262144L);\n\t\tcolumnBitmasks.put(\"useSSL\", 524288L);\n\t\t_columnBitmasks = Collections.unmodifiableMap(columnBitmasks);\n\t}\n\tprivate long _columnBitmask;\n\tprivate Subscription _escapedModel;\n"]], "pred": {"ppl": 1.6062281131744385, "ppl_lower": 1.84256911277771, "ppl/lowercase_ppl": -1.2896718734454986, "ppl/zlib": 8.238676000161639e-05, "Min_5.0% Prob": 6.07885565477259, "Min_10.0% Prob": 4.147710401637881, "Min_20.0% Prob": 2.3459210882292076, "Min_30.0% Prob": 1.58136845015452, "Min_40.0% Prob": 1.1848570053052376, "Min_50.0% Prob": 0.9486273368132536, "Min_60.0% Prob": 0.790828632913078}}
{"hexsha": "b19d5961510e696107f051ce26a9fcf080a996e9", "ext": "java", "lang": "Java", "content": "public class DbFillCommand extends AbstractCommandLauncher {\n\n    private static final String OPTION_SCHEMA = \"schema\";\n\n    private static final String OPTION_CATALOG = \"catalog\";\n\n    private static final String OPTION_COUNT = \"count\";\n\n    private static final String OPTION_CASCADE = \"cascade\";\n    \n    private static final String OPTION_CASCADE_SELECT = \"select\";\n\n    private static final String OPTION_IGNORE_TABLES = \"ignore\";\n    \n    private static final String OPTION_PREFIXED_TABLES = \"prefixed\";\n    \n    private static final String OPTION_INTERVAL = \"interval\";\n    \n    private static final String OPTION_WEIGHTS = \"weights\";\n    \n    private static final String OPTION_CONTINUE = \"continue\";\n    \n    private static final String OPTION_PRINT = \"print\";\n    \n    private static final String OPTION_RAND = \"rand\";\n    \n    private static final String OPTION_REPEAT = \"repeat\";\n    \n    private static final String OPTION_COMMIT = \"commit\";\n    \n    private static final String OPTION_COMMIT_DELAY = \"commit-delay\";\n    \n    private static final String OPTION_ROLLBACK = \"rollback\";\n    \n    private static final String OPTION_TRUNCATE = \"truncate\";\n\n    public DbFillCommand() {\n        super(\"dbfill\", \"[tablename...]\", \"DbFill.Option.\");\n    }\n\n    public static void main(String[] args) {\n        new DbFillCommand().execute(args);\n    }\n\n    @Override\n    protected boolean printHelpIfNoOptionsAreProvided() {\n        return false;\n    }\n\n    @Override\n    protected boolean requiresPropertiesFile(CommandLine line) {\n        return true;\n    }\n\n    @Override\n    protected void printHelp(CommandLine cmd, Options options) {\n        System.out.println(app + \" version \" + Version.version());\n        System.out.println(\"Fill database tables with random generated data.\\n\");\n        super.printHelp(cmd, options);\n    }\n\n    @Override\n    protected void buildOptions(Options options) {\n        super.buildOptions(options);\n        addOption(options, null, OPTION_SCHEMA, true);\n        addOption(options, null, OPTION_CATALOG, true);\n        addOption(options, null, OPTION_COUNT, true);\n        addOption(options, null, OPTION_CASCADE, false);\n        addOption(options, null, OPTION_CASCADE_SELECT, false);\n        addOption(options, null, OPTION_IGNORE_TABLES, true);\n        addOption(options, null, OPTION_PREFIXED_TABLES, true);\n        addOption(options, null, OPTION_INTERVAL, true);\n        addOption(options, null, OPTION_WEIGHTS, true);\n        addOption(options, null, OPTION_CONTINUE, false);\n        addOption(options, null, OPTION_PRINT, false);\n        addOption(options, null, OPTION_RAND, false);\n        addOption(options, null, OPTION_REPEAT, true);\n        addOption(options, null, OPTION_COMMIT, true);\n        addOption(options, null, OPTION_COMMIT_DELAY, true);\n        addOption(options, null, OPTION_ROLLBACK, true);\n        addOption(options, null, OPTION_TRUNCATE, false);\n    }\n\n    @Override\n    protected boolean executeWithOptions(CommandLine line) throws Exception {\n        DbFill dbFill = new DbFill(getDatabasePlatform(false));\n\n        if (line.hasOption(OPTION_SCHEMA)) {\n            dbFill.setSchema(line.getOptionValue(OPTION_SCHEMA));\n        }\n        if (line.hasOption(OPTION_CATALOG)) {\n            dbFill.setCatalog(line.getOptionValue(OPTION_CATALOG));\n        }\n        if (line.hasOption(OPTION_COUNT)) {\n            dbFill.setRecordCount(Integer.parseInt(line.getOptionValue(OPTION_COUNT)));\n        }\n        if (line.hasOption(OPTION_CASCADE)) {\n            dbFill.setCascading(true);\n        }\n        if (line.hasOption(OPTION_CASCADE_SELECT)) {\n            dbFill.setCascadingSelect(true);\n        }\n        if (line.hasOption(OPTION_INTERVAL)) {\n            dbFill.setInterval(Integer.parseInt(line.getOptionValue(OPTION_INTERVAL)));\n        }\n        if (line.hasOption(OPTION_WEIGHTS)) {\n            int[] dmlWeight = {0,0,0};\n            String[] strWeight = line.getOptionValue(OPTION_WEIGHTS).split(\",\");\n            if (strWeight != null && strWeight.length == 3) {\n                for (int i=0; i<3; i++) {\n                    dmlWeight[i] = new Integer(strWeight[i]);\n                }\n                dbFill.setDmlWeight(dmlWeight);\n            }\n        }\n        if (line.hasOption(OPTION_DEBUG)) {\n            dbFill.setDebug(true);\n        }\n        if (line.hasOption(OPTION_VERBOSE_CONSOLE)) {\n            dbFill.setVerbose(true);\n        }\n        \n        String ignore[] = null;\n        if (line.hasOption(OPTION_IGNORE_TABLES)) {\n            ignore = line.getOptionValue(OPTION_IGNORE_TABLES).split(\",\");\n        }\n        String prefixed[] = null;\n        if (line.hasOption(OPTION_PREFIXED_TABLES)) {\n            prefixed = line.getOptionValue(OPTION_PREFIXED_TABLES).split(\",\");\n        }\n        if (line.hasOption(OPTION_CONTINUE)) {\n            dbFill.setContinueOnError(true);\n        }\n        if (line.hasOption(OPTION_PRINT)) {\n        \tdbFill.setPrint(true);\n        }\n        if (line.hasOption(OPTION_RAND)) {\n            dbFill.setUseRandomCount(true);\n        }\n        if (line.hasOption(OPTION_REPEAT)) {\n            dbFill.setRepeat(Integer.parseInt(line.getOptionValue(OPTION_REPEAT)));\n        }\n        if (line.hasOption(OPTION_COMMIT)) {\n            dbFill.setMaxRowsCommit(Integer.parseInt(line.getOptionValue(OPTION_COMMIT)));\n        }\n        if (line.hasOption(OPTION_COMMIT_DELAY)) {\n            dbFill.setCommitDelay(Integer.parseInt(line.getOptionValue(OPTION_COMMIT_DELAY)));\n        }        \n        if (line.hasOption(OPTION_ROLLBACK)) {\n            dbFill.setPercentRollback(Integer.parseInt(line.getOptionValue(OPTION_ROLLBACK)));\n        }\n        if (line.hasOption(OPTION_TRUNCATE)) {\n            dbFill.setTruncate(true);\n        }\n\n        // Ignore the Symmetric config tables.\n        getSymmetricEngine();\n        IParameterService parameterService = engine.getParameterService();\n        String cfgPrefix = parameterService.getString(ParameterConstants.RUNTIME_CONFIG_TABLE_PREFIX);\n        dbFill.setIgnore((String[])ArrayUtils.add(ignore, cfgPrefix));\n        dbFill.setPrefixed(prefixed);\n        \n        Map<String,int[]> tableProperties = parseTableProperties();\n        \n        // If tables are provided in the property file, ignore the tables provided at the command line.\n        String[] tableNames = null;\n        if (tableProperties.size() != 0) {\n            tableNames = tableProperties.keySet().toArray(new String[0]);\n        } else {\n            tableNames = line.getArgs();\n        }\n        \n        if (!dbFill.getPrint()) {\n        \tdbFill.fillTables(tableNames, tableProperties);\n        } else {\n        \tfor (String tableName : tableNames) {\n                Table table = platform.readTableFromDatabase(dbFill.getCatalogToUse(), dbFill.getSchemaToUse(),\n                        tableName);\n                if (table != null) {\n                \tfor (int i = 0; i < dbFill.getRecordCount(); i++) {\n                \t\tfor (int j = 0; j < dbFill.getInsertWeight(); j++) {\n                            String sql = dbFill.createDynamicRandomInsertSql(table);\n                            System.out.println(sql);\n                        }\n                        for (int j = 0; j < dbFill.getUpdateWeight(); j++) {\n                            String sql = dbFill.createDynamicRandomUpdateSql(table);\n                            System.out.println(sql);\n                        }\n                        for (int j = 0; j < dbFill.getDeleteWeight(); j++) {\n                            String sql = dbFill.createDynamicRandomDeleteSql(table);\n                            System.out.println(sql);\n                        }        \n                \t}\n                }\n        \t}\n        }\n\n        return true;\n    }\n    \n    private Map<String,int[]> parseTableProperties() {\n        Map<String,int[]> tableProperties = new HashMap<String,int[]>();\n        Properties properties = engine.getProperties();\n        Enumeration<Object> keys = properties.keys();\n        while (keys.hasMoreElements()) {\n            String key = (String) keys.nextElement();\n            String value = (String) properties.get(key);\n            if (key.startsWith(\"fill.\")) {\n                String tableName = null;\n                tableName = key.substring(key.lastIndexOf(\".\") + 1);\n                int[] iudVal = new int[3];\n                int i = 0;\n                for (String str : value.split(\",\")) {\n                    iudVal[i++] = Integer.valueOf(str).intValue();\n                }\n                tableProperties.put(tableName, iudVal);\n            }\n        }\n        return tableProperties;\n    }\n\n}", "item_id": 0, "repo": "hawkwang/BeyondMDM", "file": "SymmetricDS/symmetric-client/src/main/java/org/jumpmind/symmetric/DbFillCommand.java", "last_update_at": "2022-02-26T14:11:13+00:00", "question_id": "b19d5961510e696107f051ce26a9fcf080a996e9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DbFillCommand extends AbstractCommandLauncher {\n    private static final String OPTION_SCHEMA = \"schema\";\n    private static final String OPTION_CATALOG = \"catalog\";\n    private static final String OPTION_COUNT = \"count\";\n    private static final String OPTION_CASCADE = \"cascade\";\n    private static final String OPTION_CASCADE_SELECT = \"select\";\n    private static final String OPTION_IGNORE_TABLES = \"ignore\";\n    private static final String OPTION_PREFIXED_TABLES = \"prefixed\";\n    private static final String OPTION_INTERVAL = \"interval\";\n    private static final String OPTION_WEIGHTS = \"weights\";\n    private static final String OPTION_CONTINUE = \"continue\";\n    private static final String OPTION_PRINT = \"print\";\n    private static final String OPTION_RAND = \"rand\";\n    private static final String OPTION_REPEAT = \"repeat\";\n    private static final String OPTION_COMMIT = \"commit\";\n    private static final String OPTION_COMMIT_DELAY = \"commit-delay\";\n    private static final String OPTION_ROLLBACK = \"rollback\";\n    private static final String OPTION_TRUNCATE = \"truncate\";\n    public DbFillCommand() {\n        super(\"dbfill\", \"[tablename...]\", \"DbFill.Option.\");\n    }\n    public static void main(String[] args) {\n        new DbFillCommand().execute(args);\n    }\n    @Override\n    protected boolean printHelpIfNoOptionsAreProvided() {\n        return false;\n    }\n    @Override\n    protected boolean requiresPropertiesFile(CommandLine line) {\n        return true;\n    }\n    @Override\n    protected void printHelp(CommandLine cmd, Options options) {\n        System.out.println(app + \" version \" + Version.version());\n        System.out.println(\"Fill database tables with random generated data.\\n\");\n        super.printHelp(cmd, options);\n    }\n    @Override\n    protected void buildOptions(Options options) {\n        super.buildOptions(options);\n        addOption(options, null, OPTION_SCHEMA, true);\n        addOption(options, null, OPTION_CATALOG, true);\n        addOption(options, null, OPTION_COUNT, true);\n        addOption(options, null, OPTION_CASCADE, false);\n        addOption(options, null, OPTION_CASCADE_SELECT, false);\n        addOption(options, null, OPTION_IGNORE_TABLES, true);\n        addOption(options, null, OPTION_PREFIXED_TABLES, true);\n        addOption(options, null, OPTION_INTERVAL, true);\n        addOption(options, null, OPTION_WEIGHTS, true);\n        addOption(options, null, OPTION_CONTINUE, false);\n        addOption(options, null, OPTION_PRINT, false);\n        addOption(options, null, OPTION_RAND, false);\n        addOption(options, null, OPTION_REPEAT, true);\n        addOption(options, null, OPTION_COMMIT, true);\n        addOption(options, null, OPTION_COMMIT_DELAY, true);\n        addOption(options, null, OPTION_ROLLBACK, true);\n        addOption(options, null, OPTION_TRUNCATE, false);\n    }\n    @Override\n    protected boolean executeWithOptions(CommandLine line) throws Exception {\n        DbFill dbFill = new DbFill(getDatabasePlatform(false));\n        if (line.hasOption(OPTION_SCHEMA)) {\n            dbFill.setSchema(line.getOptionValue(OPTION_SCHEMA));\n        }\n        if (line.hasOption(OPTION_CATALOG)) {\n            dbFill.setCatalog(line.getOptionValue(OPTION_CATALOG));\n        }\n        if (line.hasOption(OPTION_COUNT)) {\n            dbFill.setRecordCount(Integer.parseInt(line.getOptionValue(OPTION_COUNT)));\n        }\n        if (line.hasOption(OPTION_CASCADE)) {\n            dbFill.setCascading(true);\n        }\n        if (line.hasOption(OPTION_CASCADE_SELECT)) {\n            dbFill.setCascadingSelect(true);\n        }\n        if (line.hasOption(OPTION_INTERVAL)) {\n            dbFill.setInterval(Integer.parseInt(line.getOptionValue(OPTION_INTERVAL)));\n        }\n        if (line.hasOption(OPTION_WEIGHTS)) {\n            int[] dmlWeight = {0,0,0};\n            String[] strWeight = line.getOptionValue(OPTION_WEIGHTS).split(\",\");\n            if (strWeight != null && strWeight.length == 3) {\n                for (int i=0; i<3; i++) {\n                    dmlWeight[i] = new Integer(strWeight[i]);\n                }\n                dbFill.setDmlWeight(dmlWeight);\n            }\n        }\n        if (line.hasOption(OPTION_DEBUG)) {\n            dbFill.setDebug(true);\n        }\n        if (line.hasOption(OPTION_VERBOSE_CONSOLE)) {\n            dbFill.setVerbose(true);\n        }\n        String ignore[] = null;\n        if (line.hasOption(OPTION_IGNORE_TABLES)) {\n            ignore = line.getOptionValue(OPTION_IGNORE_TABLES).split(\",\");\n        }\n        String prefixed[] = null;\n        if (line.hasOption(OPTION_PREFIXED_TABLES)) {\n            prefixed = line.getOptionValue(OPTION_PREFIXED_TABLES).split(\",\");\n        }\n        if (line.hasOption(OPTION_CONTINUE)) {\n            dbFill.setContinueOnError(true);\n        }\n        if (line.hasOption(OPTION_PRINT)) {\n        \tdbFill.setPrint(true);\n        }\n        if (line.hasOption(OPTION_RAND)) {\n            dbFill.setUseRandomCount(true);\n        }\n        if (line.hasOption(OPTION_REPEAT)) {\n            dbFill.setRepeat(Integer.parseInt(line.getOptionValue(OPTION_REPEAT)));\n        }\n        if (line.hasOption(OPTION_COMMIT)) {\n            dbFill.setMaxRowsCommit(Integer.parseInt(line.getOptionValue(OPTION_COMMIT)));\n        }\n        if (line.hasOption(OPTION_COMMIT_DELAY)) {\n            dbFill.setCommitDelay(Integer.parseInt(line.getOptionValue(OPTION_COMMIT_DELAY)));\n        }        \n        if (line.hasOption(OPTION_ROLLBACK)) {\n            dbFill.setPercentRollback(Integer.parseInt(line.getOptionValue(OPTION_ROLLBACK)));\n        }\n        if (line.hasOption(OPTION_TRUNCATE)) {\n            dbFill.setTruncate(true);\n        }\n        // Ignore the Symmetric config tables.\n        getSymmetricEngine();\n        IParameterService parameterService = engine.getParameterService();\n        String cfgPrefix = parameterService.getString(ParameterConstants.RUNTIME_CONFIG_TABLE_PREFIX);\n        dbFill.setIgnore((String[])ArrayUtils.add(ignore, cfgPrefix));\n        dbFill.setPrefixed(prefixed);\n        Map<String,int[]> tableProperties = parseTableProperties();\n        // If tables are provided in the property file, ignore the tables provided at the command line.\n        String[] tableNames = null;\n        if (tableProperties.size() != 0) {\n            tableNames = tableProperties.keySet().toArray(new String[0]);\n        } else {\n            tableNames = line.getArgs();\n        }\n        if (!dbFill.getPrint()) {\n        \tdbFill.fillTables(tableNames, tableProperties);\n        } else {\n        \tfor (String tableName : tableNames) {\n                Table table = platform.readTableFromDatabase(dbFill.getCatalogToUse(), dbFill.getSchemaToUse(),\n                        tableName);\n                if (table != null) {\n                \tfor (int i = 0; i < dbFill.getRecordCount(); i++) {\n                \t\tfor (int j = 0; j < dbFill.getInsertWeight(); j++) {\n                            String sql = dbFill.createDynamicRandomInsertSql(table);\n                            System.out.println(sql);\n                        }\n                        for (int j = 0; j < dbFill.getUpdateWeight(); j++) {\n                            String sql = dbFill.createDynamicRandomUpdateSql(table);\n                            System.out.println(sql);\n                        }\n                        for (int j = 0; j < dbFill.getDeleteWeight(); j++) {\n                            String sql = dbFill.createDynamicRandomDeleteSql(table);\n                            System.out.println(sql);\n                        }        \n                \t}\n                }\n        \t}\n        }\n        return true;\n    }\n    private Map<String,int[]> parseTableProperties() {\n        Map<String,int[]> tableProperties = new HashMap<String,int[]>();\n        Properties properties = engine.getProperties();\n        Enumeration<Object> keys = properties.keys();\n        while (keys.hasMoreElements()) {\n            String key = (String) keys.nextElement();\n            String value = (String) properties.get(key);\n            if (key.startsWith(\"fill.\")) {\n                String tableName = null;\n                tableName = key.substring(key.lastIndexOf(\".\") + 1);\n                int[] iudVal = new int[3];\n                int i = 0;\n                for (String str : value.split(\",\")) {\n                    iudVal[i++] = Integer.valueOf(str).intValue();\n                }\n                tableProperties.put(tableName, iudVal);\n            }\n        }\n        return tableProperties;\n    }\n"]], "pred": {"ppl": 1.5343571901321411, "ppl_lower": 1.7591818571090698, "ppl/lowercase_ppl": -1.319396499472787, "ppl/zlib": 0.00021523958003395106, "Min_5.0% Prob": 5.210513091554828, "Min_10.0% Prob": 3.5591000108157886, "Min_20.0% Prob": 2.0663518091919375, "Min_30.0% Prob": 1.415178658026788, "Min_40.0% Prob": 1.067322411189598, "Min_50.0% Prob": 0.8561735828726055, "Min_60.0% Prob": 0.714223061299307}}
{"hexsha": "9e30f407c877c4796ee2d53cec7425a3b27cacc5", "ext": "java", "lang": "Java", "content": "public class TurnToAngleNoPIDCommand extends CommandBase {\n  /**\n   * Creates a new DriveForwardDistance.\n   */\n  DriveTrainSubsystem driveTrain;\n  private Gyro gyro;\n  private double targetAngle;\n  private boolean resetGyro = true;\n  private double inputSpeed = 0.8; //don't turn too fast\n\n  public TurnToAngleNoPIDCommand(DriveTrainSubsystem inpuDriveTrain, double targetAngle) {\n    // Use addRequirements() here to declare subsystem dependencies.\n    driveTrain = inpuDriveTrain;\n\n    this.targetAngle = targetAngle;\n\n    // gyroPIDSubsystem = new GyroPIDSubsystem();\n    gyro = Gyro.getInstance();\n    addRequirements(driveTrain);\n  }\n\n  // Called when the command is initially scheduled.\n  @Override\n  public void initialize() {\n    if (resetGyro) {\n      gyro.reset();\n    }\n\n    this.targetAngle += gyro.getYaw(); //if not set to zero, adjust to whatever the initial value is\n\n    driveTrain.resetEncoders();\n  }\n\n  // Called every time the scheduler runs while the command is scheduled.\n  @Override\n  public void execute() {\n    double turnSpeed = inputSpeed * Math.signum(targetAngle); \n    System.out.println(\"executing turn to angle\");\n    System.out.println(\"yaw:\" + gyro.getYaw());\n    SmartDashboard.putNumber(\"yaw\", gyro.getYaw());\n    // SmartDashboard.putNumber(\"yaw\",gyroPIDSubsystem.getGyroSubsystem().getYaw());\n    // SmartDashboard.putNumber(\"gyroPIDSubsystem.getMeasurement()\", gyroPIDSubsystem.getMeasurement());\n\n    SmartDashboard.putNumber(\"turnSpeed\", turnSpeed);\n    SmartDashboard.putNumber(\"leftSpeed\", driveTrain.getLeftDriveEncoderVelocity());\n    SmartDashboard.putNumber(\"rightSpeed\", driveTrain.getRightDriveEncoderVelocity());\n\n    driveTrain.arcadeDrive(0, turnSpeed);\n    // driveTrain.driveDistance(distance);\n  }\n\n  // Called once the command ends or is interrupted.\n  @Override\n  public void end(boolean interrupted) {\n    if (interrupted) {\n      System.out.println(\"turn to angle interrupted\");\n    }\n\n    driveTrain.arcadeDrive(0,0);\n  }\n\n  // Returns true when the command should end.\n  @Override\n  public boolean isFinished() {\n    // return false;\n\n    // return gyroPIDSubsystem.getController().atSetpoint();\n    if (targetAngle < 0)\n      return gyro.getYaw() <= targetAngle;\n    else\n      return gyro.getYaw() >= targetAngle;\n  }\n}", "item_id": 0, "repo": "Adambots-245/Adambots2022", "file": "src/main/java/frc/robot/commands/autonCommands/TurnToAngleNoPIDCommand.java", "last_update_at": "2022-01-20T20:08:35+00:00", "question_id": "9e30f407c877c4796ee2d53cec7425a3b27cacc5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TurnToAngleNoPIDCommand extends CommandBase {\n  /**\n   * Creates a new DriveForwardDistance.\n   */\n  DriveTrainSubsystem driveTrain;\n  private Gyro gyro;\n  private double targetAngle;\n  private boolean resetGyro = true;\n  private double inputSpeed = 0.8; //don't turn too fast\n  public TurnToAngleNoPIDCommand(DriveTrainSubsystem inpuDriveTrain, double targetAngle) {\n    // Use addRequirements() here to declare subsystem dependencies.\n    driveTrain = inpuDriveTrain;\n    this.targetAngle = targetAngle;\n    // gyroPIDSubsystem = new GyroPIDSubsystem();\n    gyro = Gyro.getInstance();\n    addRequirements(driveTrain);\n  }\n  // Called when the command is initially scheduled.\n  @Override\n  public void initialize() {\n    if (resetGyro) {\n      gyro.reset();\n    }\n    this.targetAngle += gyro.getYaw(); //if not set to zero, adjust to whatever the initial value is\n    driveTrain.resetEncoders();\n  }\n  // Called every time the scheduler runs while the command is scheduled.\n  @Override\n  public void execute() {\n    double turnSpeed = inputSpeed * Math.signum(targetAngle); \n    System.out.println(\"executing turn to angle\");\n    System.out.println(\"yaw:\" + gyro.getYaw());\n    SmartDashboard.putNumber(\"yaw\", gyro.getYaw());\n    // SmartDashboard.putNumber(\"yaw\",gyroPIDSubsystem.getGyroSubsystem().getYaw());\n    // SmartDashboard.putNumber(\"gyroPIDSubsystem.getMeasurement()\", gyroPIDSubsystem.getMeasurement());\n    SmartDashboard.putNumber(\"turnSpeed\", turnSpeed);\n    SmartDashboard.putNumber(\"leftSpeed\", driveTrain.getLeftDriveEncoderVelocity());\n    SmartDashboard.putNumber(\"rightSpeed\", driveTrain.getRightDriveEncoderVelocity());\n    driveTrain.arcadeDrive(0, turnSpeed);\n    // driveTrain.driveDistance(distance);\n  }\n  // Called once the command ends or is interrupted.\n  @Override\n  public void end(boolean interrupted) {\n    if (interrupted) {\n      System.out.println(\"turn to angle interrupted\");\n    }\n    driveTrain.arcadeDrive(0,0);\n  }\n  // Returns true when the command should end.\n  @Override\n  public boolean isFinished() {\n    // return false;\n    // return gyroPIDSubsystem.getController().atSetpoint();\n    if (targetAngle < 0)\n      return gyro.getYaw() <= targetAngle;\n    else\n      return gyro.getYaw() >= targetAngle;\n  }\n"]], "pred": {"ppl": 1.8451377153396606, "ppl_lower": 2.31028413772583, "ppl/lowercase_ppl": -1.3670152077161333, "ppl/zlib": 0.0007676114250218062, "Min_5.0% Prob": 5.489629540178511, "Min_10.0% Prob": 4.18016227304119, "Min_20.0% Prob": 2.7609401014569688, "Min_30.0% Prob": 1.983755021811076, "Min_40.0% Prob": 1.5224251855573017, "Min_50.0% Prob": 1.2224486314442233, "Min_60.0% Prob": 1.0208939609132657}}
{"hexsha": "d145e6fa0afcbf8e2f0105387cfbf41db1ea9f21", "ext": "java", "lang": "Java", "content": "public class Leetcode2Test {\n    Leetcode2 leetcode = new Leetcode2();\n\n    @Test\n    public void addTwoNumbers() {\n        ListNode result = leetcode.addTwoNumbers(getNodeList(\"2,4,3\"), getNodeList(\"5,6,4\"));\n        ListNode expect = getNodeList(\"7,0,8\");\n        while (expect != null) {\n            assertEquals(expect,result);\n            result = result.next;\n            expect = expect.next;\n        }\n    }\n\n    @Test\n    public void addTwoNumbersCase2() {\n        ListNode result = leetcode.addTwoNumbers(getNodeList(\"5\"), getNodeList(\"5\"));\n        ListNode expect = getNodeList(\"0,1\");\n        while (expect != null) {\n            assertEquals(expect,result);\n            result = result.next;\n            expect = expect.next;\n        }\n    }\n\n    @Test\n    public void addTwoNumbersCase3() {\n        ListNode result = leetcode.addTwoNumbers(getNodeList(\"1\"), getNodeList(\"9,9\"));\n        ListNode expect = getNodeList(\"0,0,1\");\n        while (expect != null) {\n            assertEquals(expect,result);\n            result = result.next;\n            expect = expect.next;\n        }\n    }\n\n    public static ListNode getNodeList(String str) {\n        ListNode fake = new ListNode(0);\n        ListNode t = fake;\n        String[] nodes = str.split(\",\");\n        for (String s : nodes) {\n            int val = Integer.parseInt(s);\n            ListNode node = new ListNode(val);\n            t.next = node;\n            t = t.next;\n        }\n        return fake.next;\n    }\n}", "item_id": 0, "repo": "songjiang951130/leetcode", "file": "src/test/java/com/github/songjiang951130/leetcode/water/Leetcode2Test.java", "last_update_at": "2022-03-14T01:23:32+00:00", "question_id": "d145e6fa0afcbf8e2f0105387cfbf41db1ea9f21_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Leetcode2Test {\n    Leetcode2 leetcode = new Leetcode2();\n    @Test\n    public void addTwoNumbers() {\n        ListNode result = leetcode.addTwoNumbers(getNodeList(\"2,4,3\"), getNodeList(\"5,6,4\"));\n        ListNode expect = getNodeList(\"7,0,8\");\n        while (expect != null) {\n            assertEquals(expect,result);\n            result = result.next;\n            expect = expect.next;\n        }\n    }\n    @Test\n    public void addTwoNumbersCase2() {\n        ListNode result = leetcode.addTwoNumbers(getNodeList(\"5\"), getNodeList(\"5\"));\n        ListNode expect = getNodeList(\"0,1\");\n        while (expect != null) {\n            assertEquals(expect,result);\n            result = result.next;\n            expect = expect.next;\n        }\n    }\n    @Test\n    public void addTwoNumbersCase3() {\n        ListNode result = leetcode.addTwoNumbers(getNodeList(\"1\"), getNodeList(\"9,9\"));\n        ListNode expect = getNodeList(\"0,0,1\");\n        while (expect != null) {\n            assertEquals(expect,result);\n            result = result.next;\n            expect = expect.next;\n        }\n    }\n    public static ListNode getNodeList(String str) {\n        ListNode fake = new ListNode(0);\n        ListNode t = fake;\n        String[] nodes = str.split(\",\");\n        for (String s : nodes) {\n            int val = Integer.parseInt(s);\n            ListNode node = new ListNode(val);\n            t.next = node;\n            t = t.next;\n        }\n        return fake.next;\n    }\n"]], "pred": {"ppl": 1.4114335775375366, "ppl_lower": 1.5626513957977295, "ppl/lowercase_ppl": -1.295346303972252, "ppl/zlib": 0.00092387643307375, "Min_5.0% Prob": 4.610193048204694, "Min_10.0% Prob": 3.084783681603365, "Min_20.0% Prob": 1.701086432608061, "Min_30.0% Prob": 1.1416054642114501, "Min_40.0% Prob": 0.8617868917762717, "Min_50.0% Prob": 0.6883553806563607, "Min_60.0% Prob": 0.5749546501812381}}
{"hexsha": "96e9c7841997d0854c2b2f57244a45114f6d2b58", "ext": "java", "lang": "Java", "content": "class MyClassLoader extends ClassLoader {\n\n  @Override\n  public Class<?> loadClass(String name) throws ClassNotFoundException {\n    if (name.contains(\"Evil\")) {\n      return findClass(name);\n    }\n    return super.loadClass(name);\n  }\n\n  @Override\n  protected Class<?> findClass(String name) throws ClassNotFoundException {\n    File file = new File(\n        this.getResource(\".\").getPath() + \"/\" + name.replace(\".\", \"/\") + \".class\");\n    if (file.exists()) {\n      try {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        BufferedInputStream bufferedInputStream = new BufferedInputStream(\n            new FileInputStream(file));\n        byte[] bytes = new byte[1024];\n        int size;\n        while ((size = bufferedInputStream.read(bytes)) != -1) {\n          byteArrayOutputStream.write(bytes, 0, size);\n        }\n        PermissionCollection pc = new Permissions();\n        pc.add(new AllPermission());\n        ProtectionDomain protectionDomain = new ProtectionDomain(new CodeSource(null,\n            (Certificate[]) null), pc, this, null);\n        Class<?> clazz = this.defineClass(name, byteArrayOutputStream.toByteArray(), 0,\n            byteArrayOutputStream.size(), protectionDomain);\n        return clazz;\n      } catch (Exception e) {\n        e.printStackTrace();\n      }\n    }\n    return super.findClass(name);\n  }\n}", "item_id": 1, "repo": "fengjixuchui/learnjavabug", "file": "security-manager/src/main/java/com/threedr3am/bug/security/manager/AttackTest.java", "last_update_at": "2022-03-31T07:10:19+00:00", "question_id": "96e9c7841997d0854c2b2f57244a45114f6d2b58_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class MyClassLoader extends ClassLoader {\n  @Override\n  public Class<?> loadClass(String name) throws ClassNotFoundException {\n    if (name.contains(\"Evil\")) {\n      return findClass(name);\n    }\n    return super.loadClass(name);\n  }\n  @Override\n  protected Class<?> findClass(String name) throws ClassNotFoundException {\n    File file = new File(\n        this.getResource(\".\").getPath() + \"/\" + name.replace(\".\", \"/\") + \".class\");\n    if (file.exists()) {\n      try {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        BufferedInputStream bufferedInputStream = new BufferedInputStream(\n            new FileInputStream(file));\n        byte[] bytes = new byte[1024];\n        int size;\n        while ((size = bufferedInputStream.read(bytes)) != -1) {\n          byteArrayOutputStream.write(bytes, 0, size);\n        }\n        PermissionCollection pc = new Permissions();\n        pc.add(new AllPermission());\n        ProtectionDomain protectionDomain = new ProtectionDomain(new CodeSource(null,\n            (Certificate[]) null), pc, this, null);\n        Class<?> clazz = this.defineClass(name, byteArrayOutputStream.toByteArray(), 0,\n            byteArrayOutputStream.size(), protectionDomain);\n        return clazz;\n      } catch (Exception e) {\n        e.printStackTrace();\n      }\n    }\n    return super.findClass(name);\n  }\n"]], "pred": {"ppl": 1.5242480039596558, "ppl_lower": 1.9513440132141113, "ppl/lowercase_ppl": -1.5860415351699848, "ppl/zlib": 0.0007649749115825573, "Min_5.0% Prob": 5.3873589740079995, "Min_10.0% Prob": 3.561383935383388, "Min_20.0% Prob": 2.0085980220579764, "Min_30.0% Prob": 1.385343344481749, "Min_40.0% Prob": 1.048062072650015, "Min_50.0% Prob": 0.8407702277513356, "Min_60.0% Prob": 0.7044422393947596}}
{"hexsha": "8c165c1dbb6ddc63cf19943b671c28ef4aba71d0", "ext": "java", "lang": "Java", "content": "public class CreateMeshOperation {\n\n    private macroutils.checker.MainChecker _chk = null;\n    private macroutils.misc.MainDisabler _dis = null;\n    private macroutils.getter.MainGetter _get = null;\n    private macroutils.io.MainIO _io = null;\n    private MacroUtils _mu = null;\n    private macroutils.setter.MainSetter _set = null;\n    private Simulation _sim = null;\n    private macroutils.UserDeclarations _ud = null;\n\n    /**\n     * Main constructor for this class.\n     *\n     * @param m given MacroUtils object.\n     */\n    public CreateMeshOperation(MacroUtils m) {\n        _mu = m;\n        _sim = m.getSimulation();\n    }\n\n    /**\n     * Creates an Automated Mesh Mesh Operation for the given Geometry Parts.\n     *\n     * @param ag given ArrayList of Geometry Parts.\n     * @param am given ArrayList of Meshers. <u>Hint</u>: use with\n     *           {@link macroutils.getter.GetStrings#meshers}.\n     * @return The AutoMeshOperation.\n     */\n    public AutoMeshOperation automatedMesh(ArrayList<GeometryPart> ag, ArrayList<String> am) {\n        MeshOperationManager mom = _sim.get(MeshOperationManager.class);\n        AutoMeshOperation amo = mom.createAutoMeshOperation(am, ag);\n        _setAutomatedMesh(amo, ag, \"\");\n        return amo;\n    }\n\n    /**\n     * Creates an Automated Mesh Mesh Operation for the given Geometry Parts.\n     *\n     * @param ag      given ArrayList of Geometry Parts.\n     * @param meshers given meshers, separated by comma. See {@link macroutils.StaticDeclarations}\n     *                for options.\n     * @return The AutoMeshOperation.\n     */\n    public AutoMeshOperation automatedMesh(ArrayList<GeometryPart> ag,\n            StaticDeclarations.Meshers... meshers) {\n        return automatedMesh(ag, _get.strings.meshers(meshers));\n    }\n\n    /**\n     * Creates a Badge for 2D Mesh Operation on a set of Geometry Parts.\n     *\n     * @param agp given ArrayList of Geometry Parts.\n     * @return The PrepareFor2dOperation.\n     */\n    public PrepareFor2dOperation badgeFor2D(ArrayList<GeometryPart> agp) {\n        _io.say.action(\"Creating a Badge for 2D Mesh Operation\", true);\n        _io.say.objects(agp, \"Geometry Parts\", true);\n        MeshOperationManager mom = _sim.get(MeshOperationManager.class);\n        PrepareFor2dOperation p2d = (PrepareFor2dOperation) mom.createPrepareFor2dOperation(agp);\n        p2d.execute();\n        _io.say.created(p2d, true);\n        return p2d;\n    }\n\n    /**\n     * Creates a Bounded Shape Block with individual offsets.\n     *\n     * @param agp            given ArrayList of Geometry Parts.\n     * @param negOffset      given negative 3-components offset array using\n     *                       {@link UserDeclarations#defUnitLength} units.\n     * @param posOffset      given positive 3-components offset array using\n     *                       {@link UserDeclarations#defUnitLength} units.\n     * @param centroidOffset given 3-components offset array for the centroid of supplied Geometry\n     *                       Parts.\n     * @return The MeshOperationPart.\n     */\n    public MeshOperationPart boundedShape_Block(ArrayList<GeometryPart> agp, double[] negOffset,\n            double[] posOffset, double[] centroidOffset) {\n        Units u = _ud.defUnitLength;\n        _io.say.action(\"Creating a Block Bounded Shape Mesh Operation\", true);\n        _io.say.objects(agp, \"Geometry Parts\", true);\n        BoundedShapeCreatingOperation bsmo = _createBoundedShapeMeshOp(agp,\n                BoundedShapeCreatingOperation.OutputPartType.BLOCK);\n        BoxShapeInflationControl bsic = bsmo.getBoundedShapeValuesManager()\n                .get(BoxShapeInflationControl.class);\n        bsic.setInflationMode(BoxShapeInflationControl.InflationMode.INDIVIDUAL_OFFSETS);\n        BoxShapeIndividualOffsetsInflation bsioi = bsic.getIndividualInflationOffsets();\n        _set.object.physicalQuantity(bsioi.getNXOffset(), negOffset[0], u, \"-X Offset\", true);\n        _set.object.physicalQuantity(bsioi.getNYOffset(), negOffset[1], u, \"-Y Offset\", true);\n        _set.object.physicalQuantity(bsioi.getNZOffset(), negOffset[2], u, \"-Z Offset\", true);\n        _set.object.physicalQuantity(bsioi.getPXOffset(), posOffset[0], u, \"+X Offset\", true);\n        _set.object.physicalQuantity(bsioi.getPYOffset(), posOffset[1], u, \"+Y Offset\", true);\n        _set.object.physicalQuantity(bsioi.getPZOffset(), posOffset[2], u, \"+Z Offset\", true);\n        _setCentroidOffset(bsmo, centroidOffset);\n        bsmo.execute();\n        String opName = _get.strings.withinTheBrackets(bsmo.getOutputPartNames());\n        _io.say.created(bsmo, true);\n        return (MeshOperationPart) _sim.get(SimulationPartManager.class).getPart(opName);\n    }\n\n    /**\n     * Creates a Bounded Shape Sphere with individual offsets.\n     *\n     * @param agp            given ArrayList of Geometry Parts.\n     * @param factor         given inflation factor w.r.t. centroid supplied as Parts.\n     * @param centroidOffset given 3-components offset array for the centroid of supplied Geometry\n     *                       Parts.\n     * @return The MeshOperationPart.\n     */\n    public MeshOperationPart boundedShape_Sphere(ArrayList<GeometryPart> agp, double factor,\n            double[] centroidOffset) {\n        Units u = _ud.defUnitLength;\n        _io.say.action(\"Creating a Block Bounded Shape Mesh Operation\", true);\n        _io.say.objects(agp, \"Geometry Parts\", true);\n        BoundedShapeCreatingOperation bsmo = _createBoundedShapeMeshOp(agp,\n                BoundedShapeCreatingOperation.OutputPartType.SPHERE);\n        BoundedShapeControlsManager bscm = bsmo.getBoundedShapeValuesManager();\n        bscm.get(BoundedShapeConstantFactorInflation.class).setInflationFactor(factor);\n        _io.say.value(\"Inflation Factor\", factor, true);\n        _setCentroidOffset(bsmo, centroidOffset);\n        bsmo.execute();\n        String opName = _get.strings.withinTheBrackets(bsmo.getOutputPartNames());\n        _io.say.created(bsmo, true);\n        return (MeshOperationPart) _sim.get(SimulationPartManager.class).getPart(opName);\n    }\n\n    /**\n     * Creates a One Group Contact Prevention with the supplied Geometry Objects.\n     *\n     * @param mo  given Mesh Operation.\n     * @param ago given ArrayList of Geometry Objects.\n     * @param val given search floor value.\n     * @param u   given units for the search floor.\n     * @return The PartsOneGroupContactPreventionSet.\n     */\n    public PartsOneGroupContactPreventionSet contactPrevention(MeshOperation mo,\n            ArrayList<GeometryObject> ago, double val, Units u) {\n        _io.say.action(\"Creating a Contact Prevention between Object Parts\", true);\n        _io.say.object(mo, true);\n        _io.say.objects(ago, \"Geometry Objects\", true);\n        if (!_chk.is.surfaceWrapperOperation(mo)) {\n            _io.say.msg(true, \"This is not a Surface Wrapper Mesh Operation. Skipping...\");\n            return null;\n        }\n        SurfaceWrapperAutoMeshOperation swamo = (SurfaceWrapperAutoMeshOperation) mo;\n        PartsContactPreventionSetManager pcpsm = swamo.getContactPreventionSet();\n        PartsOneGroupContactPreventionSet cp = pcpsm.createPartsOneGroupContactPreventionSet();\n        cp.getPartSurfaceGroup().setObjects(ago);\n        _set.object.physicalQuantity(cp.getFloor(), val, u, \"Search Floor\", true);\n        _io.say.ok(true);\n        return cp;\n    }\n\n    /**\n     * Creates a Directed Mesh Operation using an Automated 2D Mesh.\n     *\n     * @param src     given Source Part Surface.\n     * @param tgt     given Target Part Surface.\n     * @param meshers given meshers, separated by comma. See {@link macroutils.StaticDeclarations}\n     *                for options.\n     * @param nVol    given number of layers in volume distribution.\n     * @return The DirectedMeshOperation.\n     */\n    public DirectedMeshOperation directedMeshing_AutoMesh(PartSurface src, PartSurface tgt,\n            int nVol, StaticDeclarations.Meshers... meshers) {\n        _io.say.action(\"Creating a Directed Mesh Operation with an Automated 2D Mesh\", true);\n        _io.say.object(src, true);\n        _io.say.object(tgt, true);\n        _io.say.msg(true, \"Number of Layers: %d.\", nVol);\n        DirectedMeshOperation dmo = _createDirectedMeshOperation(src, tgt);\n        //--\n        String pn = src.getPart().getPresentationName();\n        DirectedMeshPartCollectionManager dmpcm = dmo.getGuidedMeshPartCollectionManager();\n        DirectedMeshPartCollection dmpc = ((DirectedMeshPartCollection) dmpcm.getObject(pn));\n        DirectedSurfaceMeshBaseManager dsmbm = dmo.getGuidedSurfaceMeshBaseManager();\n        dsmbm.createAutoSourceMesh(_get.strings.meshers(meshers), _get.objects.arrayList(dmpc));\n        DirectedAutoSourceMesh dasm = (DirectedAutoSourceMesh) dsmbm.getObjects().iterator().next();\n        _setMeshDefaults(dasm.getDefaultValues());\n        _setWorkAroundAutoSourceMesh(dasm, src.getPart());\n        DirectedMeshDistributionManager dmdm = dmo.getDirectedMeshDistributionManager();\n        DirectedMeshDistribution dmd = dmdm\n                .createDirectedMeshDistribution(new Vector<>(_get.objects.arrayList(dmpc)),\n                        \"Constant\");\n        dmd.getDefaultValues().get(DirectedMeshNumLayers.class).setNumLayers(nVol);\n        dmo.execute();\n        _io.say.created(dmo, true);\n        return dmo;\n    }\n\n    /**\n     * Creates a Directed Mesh Operation in a squared Channel.\n     *\n     * @param src given Source Part Surface.\n     * @param tgt given Target Part Surface.\n     * @param nX  given number of points in X-direction.\n     * @param nY  given number of points in Y-direction.\n     * @param nZ  given number of points in Z-direction.\n     * @return The DirectedMeshOperation.\n     */\n    public DirectedMeshOperation directedMeshing_Channel(PartSurface src, PartSurface tgt,\n            int nX, int nY, int nZ) {\n        _io.say.action(\"Creating a Directed Mesh Operation in a Channel\", true);\n        _io.say.msg(\"Number of Elements:\");\n        _io.say.msg(true, \"  - X Direction: %d;\", nX);\n        _io.say.msg(true, \"  - Y Direction: %d;\", nY);\n        _io.say.msg(true, \"  - Z Direction: %d.\", nZ);\n        DirectedMeshOperation dmo = _createDirectedMeshOperation(src, tgt);\n        int isX = 0, isY = 0, isZ = 0;\n        int nP1 = 2, nP2 = 2, nVol = 2;\n        PatchCurve pcX = null, pcY = null, pcZ = null, pc1 = null, pc2 = null;\n        //--\n        String pn = src.getPart().getPresentationName();\n        DirectedMeshPartCollectionManager dmpcm = dmo.getGuidedMeshPartCollectionManager();\n        DirectedMeshPartCollection dmpc = ((DirectedMeshPartCollection) dmpcm.getObject(pn));\n        Vector<PartSurface> vpsSrc = new Vector<>(_get.objects.arrayList(src));\n        Vector<PartSurface> vpsTgt = new Vector<>(_get.objects.arrayList(tgt));\n        dmo.getGuidedSurfaceMeshBaseManager().validateConfigurationForPatchMeshCreation(dmpc,\n                vpsSrc, vpsTgt);\n        //--\n        DirectedPatchSourceMesh patchMsh = dmo.getGuidedSurfaceMeshBaseManager()\n                .createPatchSourceMesh(vpsSrc, dmpc);\n        NeoProperty np = patchMsh.autopopulateFeatureEdges();\n        ArrayList<PatchCurve> pcs = _getPatchCurves(patchMsh);\n        //--\n        double err = 0.05;\n        for (PatchCurve p : pcs) {\n            DoubleVector pts = p.getPoints();\n            if (_get.info.relativeError(pts.get(0), pts.get(3), true) <= err) {\n                isX += 1;\n                pcX = p;\n                _io.say.msg(p.getPresentationName() + \" is on X plane.\");\n            }\n            if (_get.info.relativeError(pts.get(1), pts.get(4), true) <= err) {\n                isY += 1;\n                pcY = p;\n                _io.say.msg(p.getPresentationName() + \" is on Y plane.\");\n            }\n            if (_get.info.relativeError(pts.get(2), pts.get(5), true) <= err) {\n                isZ += 1;\n                pcZ = p;\n                _io.say.msg(p.getPresentationName() + \" is on Z plane.\");\n            }\n        }\n        //_io.say.msg(\"X = %d; Y = %d; Z = %d.\", isX, isY, isZ);\n        //--\n        if (isX == 4) {\n            nVol = nX;\n            pc1 = pcY;\n            nP2 = nY;\n            pc2 = pcZ;\n            nP1 = nZ;\n        } else if (isY == 4) {\n            nVol = nY;\n            pc1 = pcX;\n            nP2 = nX;\n            pc2 = pcZ;\n            nP1 = nZ;\n        } else if (isZ == 4) {\n            nVol = nZ;\n            pc1 = pcX;\n            nP2 = nX;\n            pc2 = pcY;\n            nP1 = nY;\n        }\n        //--\n        patchMsh.defineMeshPatchCurve(pc1, pc1.getStretchingFunction(), 0., 0., nP1, false, false);\n        patchMsh.defineMeshPatchCurve(pc2, pc2.getStretchingFunction(), 0., 0., nP2, false, false);\n        //--\n        DirectedMeshDistributionManager dmdm = dmo.getDirectedMeshDistributionManager();\n        DirectedMeshDistribution dmd = dmdm\n                .createDirectedMeshDistribution(new Vector<>(_get.objects.arrayList(dmpc)),\n                        \"Constant\");\n        dmd.getDefaultValues().get(DirectedMeshNumLayers.class).setNumLayers(nVol);\n        dmo.execute();\n        _io.say.created(dmo, true);\n        return dmo;\n    }\n\n    /**\n     * Creates a Directed Mesh Operation in a Pipe, using an O-Grid structure.\n     *\n     * @param src  given Source Part Surface.\n     * @param tgt  given Target Part Surface.\n     * @param nT   given number of points in the circumference, i.e., Theta direction.\n     * @param nR   given number of points radially.\n     * @param nVol given number of points for the volume distribution.\n     * @param rR   given r/R distance for the O-Grid. E.x.: 0.5;\n     * @param c    given Cylindrical Coordinate System.\n     * @return The DirectedMeshOperation.\n     */\n    public DirectedMeshOperation directedMeshing_Pipe(PartSurface src, PartSurface tgt,\n            int nT, int nR, int nVol, double rR, CoordinateSystem c) {\n        _io.say.action(\"Creating a Directed Mesh Operation in a Pipe\", true);\n        if (!_chk.is.cylindricalCSYS(c)) {\n            _io.say.value(\"Warning! Not a Cylindrical Coordinate System\", c.getPresentationName(),\n                    true, true);\n            _io.say.msg(\"Directed Mesh not created.\");\n            return null;\n        }\n        _io.say.msg(\"Number of Elements:\");\n        _io.say.msg(true, \"  - Tangent Direction (theta): %d;\", nT);\n        _io.say.msg(true, \"  - Radial Direction (r): %d;\", nR);\n        _io.say.msg(true, \"  - Along Pipe (axially): %d.\", nVol);\n        DirectedMeshOperation dmo = _createDirectedMeshOperation(src, tgt);\n        CylindricalCoordinateSystem ccs = (CylindricalCoordinateSystem) c;\n        //--\n        String s = src.getPart().getPresentationName();\n        DirectedMeshPartCollection dmpc = dmo.getGuidedMeshPartCollectionManager().getObject(s);\n        Vector<PartSurface> vpsSrc = new Vector<>(_get.objects.arrayList(src));\n        Vector<PartSurface> vpsTgt = new Vector<>(_get.objects.arrayList(tgt));\n        dmo.getGuidedSurfaceMeshBaseManager().validateConfigurationForPatchMeshCreation(dmpc,\n                vpsSrc, vpsTgt);\n        //--\n        DirectedPatchSourceMesh patchMsh = dmo.getGuidedSurfaceMeshBaseManager()\n                .createPatchSourceMesh(vpsSrc, dmpc);\n        NeoProperty np = patchMsh.autopopulateFeatureEdges();\n        //_io.say.msg(\"NeoProperty np = patchMsh.autopopulateFeatureEdges();\");\n        //_io.say.msg(np.getHashtable().toString());\n        //--\n\n        //-- Trying the simple approach, i.e., split existing patch curves\n        ArrayList<PatchCurve> pcExts = new ArrayList<>();\n        ArrayList<PatchCurve> pcInts = new ArrayList<>();\n        ArrayList<PatchCurve> stockCurves = _getPatchCurves(patchMsh);\n        _sayPatchVerticesNames(_getPatchVertices(patchMsh));\n\n        if (stockCurves.size() == 2) {\n\n            // External curves creation\n            stockCurves.forEach(patchCurve -> {\n                _io.say.msg(\"Splitting external Patch Curve: \" + patchCurve.getPresentationName());\n                patchMsh.splitPatchCurve(patchCurve, 1);\n                _sayPatchVerticesNames(_getPatchVertices(patchMsh));\n            });\n            List<PatchCurve> externalCurves = _getPatchCurves(patchMsh);\n            List<PatchVertex> sortedVertices = _getPatchVerticesSortedByAngle(patchMsh, ccs);\n\n            // Internal Patch curves creation\n            _io.say.msg(\"Building internal Patch Curves...\");\n            _io.say.msg(\" \");\n            List<PatchCurve> internalCurves = new ArrayList<>();\n            List<PatchVertex> internalVertices = new ArrayList<>();\n\n            sortedVertices.forEach(externalVertex -> {\n\n                // In cylindrical coordinates\n                Vector3 cartCoordsExt = new Vector3(externalVertex.getCoordinate().toDoubleArray());\n                Vector3 cylCoordsExt = _getVector3(externalVertex, ccs);\n                double extR = cylCoordsExt.x;\n                double theta = cylCoordsExt.y;\n                Vector3 cylCoordsInt = new Vector3(extR * rR, theta, 0.0);\n\n                // Back to cartesian\n                Vector3 cartCoordsInt = ccs.transformCoordinate(cylCoordsInt);\n\n                _io.say.msg(\"  - External Coordinate [Cyl]: \" + cylCoordsExt.toString());\n                _io.say.msg(\"  - Internal Coordinate [Cyl]: \" + cylCoordsInt.toString());\n                _io.say.msg(\"  - External Coordinate [Cart]: \" + cartCoordsExt.toString());\n                _io.say.msg(\"  - Internal Coordinate [Cart]: \" + cartCoordsInt.toString());\n\n                // Create new internal Patch curve\n                patchMsh.createPatchCurve(externalVertex, null,\n                        new DoubleVector(cartCoordsInt.toArray()),\n                        new StringVector(new String[] {\"ON_SURFACE\"}));\n\n                // Find out which new vertex was created\n                List<PatchVertex> currentVertices = _getPatchVertices(patchMsh);\n                currentVertices.removeAll(sortedVertices);\n                currentVertices.removeAll(internalVertices);\n\n                PatchVertex createdVertex = currentVertices.get(0);\n                internalVertices.add(createdVertex);\n\n                List<PatchCurve> currentCurves = _getPatchCurves(patchMsh);\n                currentCurves.removeAll(externalCurves);\n                currentCurves.removeAll(internalCurves);\n\n                PatchCurve createdCurve = currentCurves.get(0);\n                internalCurves.add(createdCurve);\n\n                _io.say.msg(\"  - Created Patch Curve: \" + createdCurve.getPresentationName());\n                _io.say.msg(\"  - Created Patch Vertex: \" + createdVertex.getPresentationName());\n                _io.say.msg(\" \");\n\n            });\n\n            // Finally connect all the internal created vertices to close the O-Grid loop\n            internalVertices.add(internalVertices.get(0));\n            _io.say.msg(\"Connecting internal Patch Vertices...\");\n            _io.say.msg(\" \");\n            _sayPatchVerticesNames(internalVertices);\n\n            for (int i = 1; i < internalVertices.size(); i++) {\n\n                PatchVertex fromVertex = internalVertices.get(i-1);\n                PatchVertex toVertex = internalVertices.get(i);\n                _io.say.msg(\"  - From Patch Vertex: \" + fromVertex.getPresentationName());\n                _io.say.msg(\"  - To Patch Vertex: \" + toVertex.getPresentationName());\n                _io.say.msg(\" \");\n\n                patchMsh.createPatchCurve(fromVertex, toVertex, new DoubleVector(new double[] {}),\n                        new StringVector(new String[] {}));\n\n            }\n\n            // Mesh distribution in theta\n            pcExts.addAll(externalCurves);\n\n            // Radial mesh distribution -- only one is needed\n            pcInts.add(internalCurves.get(0));\n\n\n        } else {\n\n            // Reevaluate when happening\n            return null;\n\n        }\n\n        //--\n        //--\n        patchMsh.defineMeshMultiplePatchCurves(new Vector<>(pcExts), nT, false);\n        patchMsh.defineMeshMultiplePatchCurves(new Vector<>(pcInts), nR, false);\n        if (_ud.dmSmooths > 0) {\n            patchMsh.smoothPatchPolygonMesh(_ud.dmSmooths, 0.25, false);\n        }\n        //--\n        DirectedMeshDistributionManager dmdm = dmo.getDirectedMeshDistributionManager();\n        DirectedMeshDistribution dmd = dmdm\n                .createDirectedMeshDistribution(new Vector<>(_get.objects.arrayList(dmpc)),\n                        \"Constant\");\n        dmd.getDefaultValues().get(DirectedMeshNumLayers.class).setNumLayers(nVol);\n        dmo.execute();\n        _io.say.created(dmo, true);\n        return dmo;\n    }\n\n    /**\n     * Creates a Extract Volume Mesh Operation on the supplied geometries.\n     *\n     * @param agp given ArrayList of Geometry Parts.\n     * @return The ExtractVolumeOperation.\n     */\n    public ExtractVolumeOperation extractVolume(ArrayList<GeometryPart> agp) {\n        _io.say.action(\"Creating a Extract Volume Operation\", true);\n        MeshOperationManager mom = _sim.get(MeshOperationManager.class);\n        MeshOperation mo = mom.createExtractVolumeOperation(agp);\n        _io.say.objects(agp, \"Geometry Parts\", true);\n        mo.execute();\n        _io.say.ok(true);\n        return (ExtractVolumeOperation) mo;\n    }\n\n    /**\n     * Creates a Fill Holes Mesh Operation on the supplied geometry objects.\n     *\n     * @param agp given ArrayList of Geometry Parts.\n     * @param aps given ArrayList of Part Surfaces.\n     * @param apc given ArrayList of Part Curves. null is ignored.\n     * @return The FillHolesOperation.\n     */\n    public FillHolesOperation fillHoles(ArrayList<GeometryPart> agp, ArrayList<PartSurface> aps,\n            ArrayList<PartCurve> apc) {\n        _io.say.action(\"Creating a Fill Holes Operation\", true);\n        MeshOperationManager mom = _sim.get(MeshOperationManager.class);\n        FillHolesOperation fho = (FillHolesOperation) mom.createFillHolesOperation(agp);\n        _io.say.objects(agp, \"Geometry Parts\", true);\n        _io.say.objects(aps, \"Part Surfaces\", true);\n        fho.getEndSurfaces().setObjects(aps);\n        if (apc != null) {\n            _io.say.objects(aps, \"Part Curves\", true);\n            fho.getEndCurves().setObjects(apc);\n        }\n        fho.execute();\n        _io.say.ok(true);\n        return fho;\n    }\n\n    /**\n     * Creates an Imprint Mesh Operation with the given Parts.\n     *\n     * @param agp given ArrayList of Geometry Parts.\n     * @param tol given tolerance in {@link UserDeclarations#defUnitLength} unit.\n     * @param it  given Imprint Method.\n     * @param mt  given Resulting Mesh Type\n     * @return The ImprintPartsOperation.\n     */\n    public ImprintPartsOperation imprint(ArrayList<GeometryPart> agp, double tol,\n            ImprintMergeImprintMethodOption.Type it, ImprintResultingMeshTypeOption.Type mt) {\n        _io.say.action(\"Creating an Imprint Mesh Operation\", true);\n        _io.say.objects(agp, \"Geometry Parts\", true);\n        MeshOperationManager mom = _sim.get(MeshOperationManager.class);\n        MeshOperation mo = mom.createImprintPartsOperation(agp);\n        ImprintPartsOperation ipo = (ImprintPartsOperation) mo;\n        ipo.getMergeImprintMethod().setSelected(it);\n        ipo.getResultingMeshType().setSelected(mt);\n        _io.say.value(\"Imprint Method\",\n                ipo.getMergeImprintMethod().getSelectedElement().getPresentationName(), true, true);\n        _io.say.value(\"Resulting Mesh\",\n                ipo.getResultingMeshType().getSelectedElement().getPresentationName(), true, true);\n        _set.object.physicalQuantity(ipo.getTolerance(), tol, _ud.defUnitLength, \"Tolerance\", true);\n        if (it == ImprintMergeImprintMethodOption.Type.CAD_IMPRINT) {\n            ipo.getImprintValuesManager().get(CadTessellationOption.class)\n                    .getTessellationDensityOption().setSelected(_ud.defTessOpt.getType());\n        }\n        if (mt == ImprintResultingMeshTypeOption.Type.CONFORMAL) {\n            ipo.getImprintValuesManager().get(ImprintPartSurfaces.class)\n                    .getPartSurfacesOption().setSelected(ImprintPartSurfacesOption.Type.USE_INPUT);\n        }\n        _io.say.created(ipo, true);\n        return ipo;\n    }\n\n    /**\n     * Creates a Subtraction Mesh Operation between a set of Geometry Parts.\n     *\n     * @param agp given ArrayList of Geometry Parts.\n     * @param tgt given target Geometry Part.\n     * @return The MeshOperationPart.\n     */\n    public MeshOperationPart subtract(ArrayList<GeometryPart> agp, GeometryPart tgt) {\n        return _createBoolean(StaticDeclarations.Operation.SUBTRACT, agp, tgt);\n    }\n\n    /**\n     * Creates an empty Custom Surface Control.\n     *\n     * @param mo given Mesh Operation.\n     * @return The SurfaceCustomMeshControl.\n     */\n    public SurfaceCustomMeshControl surfaceControl(MeshOperation mo) {\n        return _createSurfaceCustomMeshControl(mo, true);\n    }\n\n    /**\n     * Copies a Custom Surface Control from another another Mesh Operation.\n     *\n     * @param scmc given Surface Control to copy.\n     * @param mo   given Mesh Operation where will be copied too.\n     * @return The SurfaceCustomMeshControl.\n     */\n    public SurfaceCustomMeshControl surfaceControl(SurfaceCustomMeshControl scmc,\n            MeshOperation mo) {\n        _io.say.action(\"Creating a Custom Surface Mesh Control\", true);\n        _io.say.object(scmc, true);\n        _io.say.object(mo, true);\n        SurfaceCustomMeshControl scmc2 = _createSurfaceCustomMeshControl(mo, false);\n        scmc2.setPresentationName(scmc.getPresentationName());\n        scmc2.copyProperties(scmc);\n        _io.say.msg(\"Properties copied succesfully.\");\n        _io.say.created(scmc2, true);\n        return scmc2;\n    }\n\n    /**\n     * Creates a Custom Surface Control to change Surface Sizes in a Mesh Operation.\n     *\n     * @param mo  given Mesh Operation.\n     * @param ago given ArrayList of Geometry Objects.\n     * @param min minimum relative size (%). If 0, this parameter will not be customized.\n     * @param tgt target relative size (%). If 0, this parameter will not be customized.\n     * @return The Custom Surface Control.\n     */\n    public SurfaceCustomMeshControl surfaceControl(MeshOperation mo, ArrayList<GeometryObject> ago,\n            double min, double tgt) {\n        _io.say.action(\"Creating a Custom Surface Mesh Control\", true);\n        _io.say.object(mo, true);\n        _io.say.objects(ago, \"Geometry Objects\", true);\n        SurfaceCustomMeshControl scmc = _createSurfaceCustomMeshControl(mo, false);\n        scmc.getGeometryObjects().setObjects(ago);\n        _set.mesh.surfaceSizes(scmc, min, tgt, true);\n        _io.say.created(scmc, true);\n        return scmc;\n    }\n\n    /**\n     * Creates a Custom Surface Control to change Prism Layers in a Mesh Operation.\n     *\n     * <b>Important:</b> If all three arguments are 0, Prisms will be disabled.\n     *\n     * @param amo       given Auto Mesh Operation.\n     * @param ago       given ArrayList of Geometry Objects.\n     * @param numLayers given number of prisms. If 0, this parameter will not be customized.\n     * @param stretch   given prism stretch relation. If 0, this parameter will not be customized.\n     * @param relSize   given relative size in (%). If 0, this parameter will not be customized.\n     * @return The Custom Surface Control.\n     */\n    public SurfaceCustomMeshControl surfaceControl(AutoMeshOperation amo,\n            ArrayList<GeometryObject> ago, int numLayers, double stretch, double relSize) {\n        _io.say.action(\"Creating a Custom Surface Mesh Control\", true);\n        _io.say.object(amo, true);\n        _io.say.objects(ago, \"Geometry Objects\", true);\n        SurfaceCustomMeshControl scmc = amo.getCustomMeshControls().createSurfaceControl();\n        scmc.getGeometryObjects().setObjects(ago);\n        PartsCustomizePrismMesh pcpm = scmc.getCustomConditions()\n                .get(PartsCustomizePrismMesh.class);\n        if (numLayers + stretch + relSize == 0.0) {\n            _dis.prismsLayers(scmc, false);\n            _io.say.msg(\"Prism Layers DISABLED.\");\n        } else {\n            pcpm.getCustomPrismOptions().setSelected(PartsCustomPrismsOption.Type.CUSTOMIZE);\n            CustomPrismValuesManager cpvm = scmc.getCustomValues()\n                    .get(CustomPrismValuesManager.class);\n            if (numLayers > 0) {\n                pcpm.getCustomPrismControls().setCustomizeNumLayers(true);\n                cpvm.get(NumPrismLayers.class).setNumLayers(numLayers);\n            } else {\n                pcpm.getCustomPrismControls().setCustomizeNumLayers(false);\n            }\n            if (stretch > 0) {\n                pcpm.getCustomPrismControls().setCustomizeStretching(true);\n                cpvm.get(PrismLayerStretching.class).setStretching(stretch);\n            } else {\n                pcpm.getCustomPrismControls().setCustomizeStretching(false);\n            }\n            if (relSize > 0) {\n                pcpm.getCustomPrismControls().setCustomizeTotalThickness(true);\n                cpvm.get(PrismThickness.class).setRelativeSize(relSize);\n            } else {\n                pcpm.getCustomPrismControls().setCustomizeTotalThickness(false);\n            }\n        }\n        _io.say.created(scmc, true);\n        return scmc;\n    }\n\n    /**\n     * Creates a Surface Wrap Mesh Operation in a set of Geometry Parts.\n     *\n     * @param agp  given ArrayList of Geometry Parts.\n     * @param name given name for the Operation. The Part generated will share the same name.\n     * @return The SurfaceWrapperAutoMeshOperation.\n     */\n    public SurfaceWrapperAutoMeshOperation surfaceWrapper(ArrayList<GeometryPart> agp,\n            String name) {\n        _io.say.action(\"Creating a Surface Wrapper Mesh Operation\", true);\n        _io.say.objects(agp, \"Geometry Parts\", true);\n        MeshOperationManager mom = _sim.get(MeshOperationManager.class);\n        AutoMeshOperation amo = mom.createSurfaceWrapperAutoMeshOperation(agp, name);\n        SurfaceWrapperAutoMeshOperation swamo = (SurfaceWrapperAutoMeshOperation) amo;\n        AutoMeshDefaultValuesManager amdvm = swamo.getDefaultValues();\n        _set.mesh.baseSize(swamo, _ud.mshBaseSize, _ud.defUnitLength, false);\n        _set.mesh.surfaceSizes(swamo, _ud.mshSrfSizeMin, _ud.mshSrfSizeTgt, false);\n        _set.mesh.surfaceCurvature(amdvm.get(SurfaceCurvature.class), _ud.mshSrfCurvNumPoints,\n                false);\n        GlobalVolumeOfInterestOption gvio = amdvm.get(GlobalVolumeOfInterest.class)\n                .getVolumeOfInterestOption();\n        GeometricFeatureAngle gfa = amdvm.get(GeometricFeatureAngle.class);\n        gvio.setSelected(GlobalVolumeOfInterestOption.Type.LARGEST_INTERNAL);\n        gfa.setGeometricFeatureAngle(_ud.mshWrapperFeatureAngle);\n        _io.say.value(\"Volume of Interest\", gvio.getSelectedElement().getPresentationName(), true,\n                true);\n        _io.say.value(\"Geometric Feature Angle\", gfa.getGeometricFeatureAngle(), true);\n        _io.say.created(swamo, true);\n        return swamo;\n    }\n\n    /**\n     * Creates an Unite Mesh Operation between a set of Geometry Parts.\n     *\n     * @param agp given ArrayList of Geometry Parts.\n     * @return The MeshOperationPart.\n     */\n    public MeshOperationPart unite(ArrayList<GeometryPart> agp) {\n        return _createBoolean(StaticDeclarations.Operation.UNITE, agp, null);\n    }\n\n    /**\n     * This method is called automatically by {@link MacroUtils}.\n     */\n    public void updateInstances() {\n        _chk = _mu.check;\n        _dis = _mu.disable;\n        _get = _mu.get;\n        _io = _mu.io;\n        _set = _mu.set;\n        _ud = _mu.userDeclarations;\n    }\n\n    /**\n     * Creates a Custom Volumetric Control with isotropic values in a Mesh Operation.\n     *\n     * @param mo      given Mesh Operation.\n     * @param agp     given ArrayList of Geometry Parts.\n     * @param relSize relative size in (<b>%</b>). Zero is ignored.\n     * @return The VolumeCustomMeshControl.\n     */\n    public VolumeCustomMeshControl volumetricControl(MeshOperation mo, ArrayList<GeometryPart> agp,\n            double relSize) {\n        return volumetricControl(mo, agp, relSize, StaticDeclarations.COORD0);\n    }\n\n    /**\n     * Creates a Custom Volumetric Control in a Mesh Operation where the control can be Isotropic or\n     * Anisotropic (Trimmer only).\n     *\n     * @param mo       given Mesh Operation.\n     * @param agp      given ArrayList of Geometry Parts.\n     * @param relSize  relative size in (<b>%</b>). Zero is ignored.\n     * @param relSizes given 3-component relative sizes in (<b>%</b>). E.g.: {0, 50, 0}. Zeros will\n     *                 be ignored.\n     * @return The VolumeCustomMeshControl.\n     */\n    public VolumeCustomMeshControl volumetricControl(MeshOperation mo, ArrayList<GeometryPart> agp,\n            double relSize, double[] relSizes) {\n        _io.say.action(\"Creating a Custom Volume Mesh Control\", true);\n        _io.say.object(mo, true);\n        _io.say.objects(agp, \"Geometry Parts\", true);\n        if (!_isCustomControllable(mo)) {\n            return null;\n        }\n        AutoMeshOperation amo = (AutoMeshOperation) mo;\n        VolumeCustomMeshControl vcmc = amo.getCustomMeshControls().createVolumeControl();\n        vcmc.getGeometryObjects().setObjects(agp);\n        if (relSize > 0) {\n            _setIsotropicSize(vcmc, relSize);\n        }\n        if (_chk.has.trimmerMesher(amo) && relSizes.length == 3 && _get.info.sum(relSizes) > 0) {\n            _setAnisotropicSizes(vcmc, relSizes);\n        }\n        _io.say.created(vcmc, true);\n        return vcmc;\n    }\n\n    private MeshOperationPart _createBoolean(StaticDeclarations.Operation op,\n            ArrayList<GeometryPart> ag, GeometryPart tgtGP) {\n        _io.say.action(String.format(\"Creating a %s Mesh Operation\", op.toString()), true);\n        _io.say.objects(ag, \"Parts\", true);\n        MeshOperation mo = _createBooleanMeshOperation(op, tgtGP);\n        mo.getInputGeometryObjects().setObjects(ag);\n        mo.execute();\n        String opName = _get.strings.withinTheBrackets(mo.getOutputPartNames());\n        return (MeshOperationPart) _sim.get(SimulationPartManager.class).getPart(opName);\n    }\n\n    private MeshOperation _createBooleanMeshOperation(StaticDeclarations.Operation op,\n            GeometryPart tgtGP) {\n        MeshOperationManager mom = _sim.get(MeshOperationManager.class);\n        switch (op) {\n            case SUBTRACT:\n                SubtractPartsOperation spo = (SubtractPartsOperation) mom\n                        .createSubtractPartsOperation();\n                spo.setTargetPart((MeshPart) tgtGP);\n                return spo;\n            case UNITE:\n                UnitePartsOperation upo = (UnitePartsOperation) mom.createUnitePartsOperation();\n                return upo;\n        }\n        return null;\n    }\n\n    private BoundedShapeCreatingOperation _createBoundedShapeMeshOp(ArrayList<GeometryPart> agp,\n            BoundedShapeCreatingOperation.OutputPartType type) {\n        MeshOperation mo = _sim.get(MeshOperationManager.class).createBoundedShapeOperation(agp);\n        BoundedShapeCreatingOperation bsco = (BoundedShapeCreatingOperation) mo;\n        bsco.setOutputPartType(type);\n        return bsco;\n    }\n\n    private DirectedMeshOperation _createDirectedMeshOperation(PartSurface src, PartSurface tgt) {\n        _io.say.object(src.getPart(), true);\n        if (!_chk.is.directedMeshable(src, tgt)) {\n            return null;\n        }\n        MeshOperationManager mom = _sim.get(MeshOperationManager.class);\n        MeshOperation mo = mom.createDirectedMeshOperation(\n                new ArrayList<>(_get.objects.arrayList(src.getPart())));\n        DirectedMeshOperation dmo = (DirectedMeshOperation) mo;\n        dmo.getSourceSurfaceGroup().add(src);\n        dmo.getTargetSurfaceGroup().add(tgt);\n        return dmo;\n    }\n\n    private SurfaceCustomMeshControl _createSurfaceCustomMeshControl(MeshOperation mo, boolean vo) {\n        _io.say.action(\"Creating a Custom Surface Mesh Control\", vo);\n        _io.say.object(mo, vo);\n        if (!_isCustomControllable(mo)) {\n            return null;\n        }\n        AutoMeshOperation amo = (AutoMeshOperation) mo;\n        SurfaceCustomMeshControl scmc = amo.getCustomMeshControls().createSurfaceControl();\n        _io.say.created(scmc, vo);\n        return scmc;\n    }\n\n    private ArrayList<PatchCurve> _getPatchCurves(DirectedPatchSourceMesh patchMsh) {\n        return new ArrayList<>(patchMsh.getPatchCurveManager().getObjects());\n    }\n\n    private ArrayList<PatchVertex> _getPatchVertices(DirectedPatchSourceMesh patchMsh) {\n        return new ArrayList<>(patchMsh.getPatchVertexManager().getObjects());\n    }\n\n    private List<PatchVertex> _getPatchVerticesSortedByAngle(DirectedPatchSourceMesh patchMsh,\n            CylindricalCoordinateSystem ccs) {\n\n        List<PatchVertex> vertices = _getPatchVertices(patchMsh);\n\n        List<Double> angles = vertices.stream()\n                .map(pv -> _getVector3(pv, ccs))\n                .map(cylindricalVector -> cylindricalVector.y)\n                .collect(Collectors.toList());\n\n        List<Double> sortedAngles = angles.stream()\n                .sorted(Comparator.naturalOrder())\n                .collect(Collectors.toList());\n\n        return sortedAngles.stream()\n                .map(angle -> angles.indexOf(angle))\n                .map(i -> vertices.get(i))\n                .collect(Collectors.toList());\n\n    }\n\n    private Vector3 _getVector3(PatchVertex pv, CylindricalCoordinateSystem c) {\n        return c.transformLabCoordinate(new Vector3(pv.getCoordinate().toDoubleArray()));\n    }\n\n    private boolean _isCustomControllable(MeshOperation mo) {\n        if (_chk.is.autoMeshOperation(mo) || _chk.is.surfaceWrapperOperation(mo)) {\n            return true;\n        }\n        _io.say.msg(true, \"This Mesh Operation can not have Custom Controls. Skipping...\");\n        return false;\n    }\n\n    private void _sayPatchVerticesNames(List<PatchVertex> vertices) {\n\n\n        List<String> names = vertices.stream()\n                .map(pv -> pv.getPresentationName())\n                .collect(Collectors.toList());\n\n        _io.say.msg(\"Vertices: \" + names.toString());\n\n    }\n\n    private void _setAnisotropicSizes(VolumeCustomMeshControl vcmc, double[] relSizes) {\n        CustomMeshControlConditionManager vccc = vcmc.getCustomConditions();\n        VolumeControlTrimmerSizeOption vctso = vccc.get(VolumeControlTrimmerSizeOption.class);\n        vctso.setTrimmerAnisotropicSizeOption(true);\n        TrimmerAnisotropicSize tas = vcmc.getCustomValues().get(TrimmerAnisotropicSize.class);\n        if (relSizes[0] > 0) {\n            tas.setXSize(true);\n            _set.object.relativeSize(tas.getRelativeXSize(), \"Relative Size X\", relSizes[0]);\n        }\n        if (relSizes[1] > 0) {\n            tas.setYSize(true);\n            _set.object.relativeSize(tas.getRelativeYSize(), \"Relative Size Y\", relSizes[1]);\n        }\n        if (relSizes[2] > 0) {\n            tas.setZSize(true);\n            _set.object.relativeSize(tas.getRelativeZSize(), \"Relative Size Z\", relSizes[2]);\n        }\n    }\n\n    private void _setAutomatedMesh(AutoMeshOperation amo, ArrayList<GeometryPart> ag, String txt) {\n        _io.say.action(\"Creating an Automated Mesh Operation \" + txt, true);\n        _io.say.objects(ag, \"Geometry Parts\", true);\n        _io.say.msg(\"Meshers: \" + _get.strings\n                .withinTheBrackets(amo.getMeshersCollection().toString()));\n        _setMeshDefaults(amo.getDefaultValues());\n        _set.mesh.prisms(amo, _ud.prismsLayers, _ud.prismsStretching, _ud.prismsRelSizeHeight,\n                false);\n        _set.mesh.thinMesher(amo, _ud.thinMeshLayers, _ud.thinMeshMaxThickness, false);\n        _set.mesh.coreMeshOptimizer(amo, _ud.mshOptCycles, _ud.mshQualityThreshold, false);\n        _io.say.created(amo, true);\n    }\n\n    private void _setCentroidOffset(BoundedShapeCreatingOperation bsmo, double[] offset) {\n        Units u = _ud.defUnitLength;\n        BoundedShapeControlsManager bscm = bsmo.getBoundedShapeValuesManager();\n        BoundedShapeCentroidOffset bsco = bscm.get(BoundedShapeCentroidOffset.class);\n        _set.object.physicalQuantity(bsco.getXOffset(), offset[0], u, \"X Centroid Offset\", true);\n        _set.object.physicalQuantity(bsco.getYOffset(), offset[1], u, \"Y Centroid Offset\", true);\n        _set.object.physicalQuantity(bsco.getZOffset(), offset[2], u, \"Z Centroid Offset\", true);\n    }\n\n    private void _setIsotropicSize(VolumeCustomMeshControl vcmc, double relSize) {\n        AutoMeshOperation amo = (AutoMeshOperation) vcmc.getManager().getMeshOperation();\n        CustomMeshControlValueManager cmcvm = vcmc.getCustomValues();\n        CustomMeshControlConditionManager vccc = vcmc.getCustomConditions();\n        if (_chk.has.polyMesher(amo)) {\n            vccc.get(VolumeControlDualMesherSizeOption.class).setVolumeControlBaseSizeOption(true);\n        } else if (_chk.has.trimmerMesher(amo)) {\n            vccc.get(VolumeControlTrimmerSizeOption.class).setVolumeControlBaseSizeOption(true);\n        } else {\n            _io.say.msg(\"WARNING! Impossible to set Relative size.\");\n            return;\n        }\n        _set.object.relativeSize(cmcvm.get(VolumeControlSize.class), \"Relative Size\", relSize);\n    }\n\n    private void _setMeshDefaults(AutoMeshDefaultValuesManager amdvm) {\n\n        boolean isTrimmer = false;\n\n        if (amdvm.getParent() instanceof AutoMeshOperation) {\n            AutoMeshOperation amo = amdvm.getParent();\n            isTrimmer = _chk.has.trimmerMesher(amo);\n        }\n\n        _set.object.physicalQuantity(amdvm.get(BaseSize.class), _ud.mshBaseSize, _ud.defUnitLength,\n                \"Base Size\", true);\n        _set.object.relativeSize(amdvm.get(PartsTargetSurfaceSize.class), \"Target Surface Size\",\n                _ud.mshSrfSizeTgt);\n        if (amdvm.has(\"Minimum Surface Size\")) {\n            _set.object.relativeSize(amdvm.get(PartsMinimumSurfaceSize.class),\n                    \"Minimum Surface Size\", _ud.mshSrfSizeMin);\n        }\n        if (amdvm.has(\"Surface Curvature\")) {\n            _set.mesh.surfaceCurvature(amdvm.get(SurfaceCurvature.class),\n                    _ud.mshSrfCurvNumPoints, false);\n        }\n        if (amdvm.has(\"Surface Proximity\")) {\n            _set.mesh.surfaceProximity(amdvm.get(SurfaceProximity.class),\n                    _ud.mshProximityPointsInGap, _ud.mshProximitySearchFloor, false);\n        }\n        if (amdvm.has(\"Volume Growth Rate\") && isTrimmer) {\n            star.trimmer.PartsGrowthRateOption.Type t = _ud.mshTrimmerGrowthRate.getType();\n            amdvm.get(PartsSimpleTemplateGrowthRate.class).getGrowthRateOption().setSelected(t);\n            _io.say.value(\"Growth Rate Type\", t.getPresentationName(), true, true);\n        }\n        if (amdvm.has(\"Maximum Cell Size\")) {\n            _set.object.relativeSize(amdvm.get(MaximumCellSize.class), \"Maximum Cell Size\",\n                    _ud.mshTrimmerMaxCellSize);\n        }\n    }\n\n    private void _setWorkAroundAutoSourceMesh(DirectedAutoSourceMesh dasm, GeometryPart gp) {\n        //-- Check later.\n        // Workaround for legacy limitation of Target size not being respected in 2D meshes.\n        SurfaceCustomMeshControl scmc = dasm.getCustomMeshControls().createSurfaceControl();\n        scmc.getGeometryObjects().setObjects(gp);\n        CustomMeshControlConditionManager cmccm = scmc.getCustomConditions();\n        cmccm.get(PartsTargetSurfaceSizeOption.class)\n                .setSelected(PartsTargetSurfaceSizeOption.Type.CUSTOM);\n        _set.object.relativeSize(scmc.getCustomValues().get(PartsTargetSurfaceSize.class),\n                \"Relative Size\", _ud.mshSrfSizeTgt);\n        scmc.setPresentationName(\"Work-Around AutoSource Mesh\");\n    }\n\n}", "item_id": 0, "repo": "frkasper/MacroUtils", "file": "macroutils/src/macroutils/creator/CreateMeshOperation.java", "last_update_at": "2022-03-29T10:02:24+00:00", "question_id": "8c165c1dbb6ddc63cf19943b671c28ef4aba71d0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CreateMeshOperation {\n    private macroutils.checker.MainChecker _chk = null;\n    private macroutils.misc.MainDisabler _dis = null;\n    private macroutils.getter.MainGetter _get = null;\n    private macroutils.io.MainIO _io = null;\n    private MacroUtils _mu = null;\n    private macroutils.setter.MainSetter _set = null;\n    private Simulation _sim = null;\n    private macroutils.UserDeclarations _ud = null;\n    /**\n     * Main constructor for this class.\n     *\n     * @param m given MacroUtils object.\n     */\n    public CreateMeshOperation(MacroUtils m) {\n        _mu = m;\n        _sim = m.getSimulation();\n    }\n    /**\n     * Creates an Automated Mesh Mesh Operation for the given Geometry Parts.\n     *\n     * @param ag given ArrayList of Geometry Parts.\n     * @param am given ArrayList of Meshers. <u>Hint</u>: use with\n     *           {@link macroutils.getter.GetStrings#meshers}.\n     * @return The AutoMeshOperation.\n     */\n    public AutoMeshOperation automatedMesh(ArrayList<GeometryPart> ag, ArrayList<String> am) {\n        MeshOperationManager mom = _sim.get(MeshOperationManager.class);\n        AutoMeshOperation amo = mom.createAutoMeshOperation(am, ag);\n        _setAutomatedMesh(amo, ag, \"\");\n        return amo;\n    }\n    /**\n     * Creates an Automated Mesh Mesh Operation for the given Geometry Parts.\n     *\n     * @param ag      given ArrayList of Geometry Parts.\n     * @param meshers given meshers, separated by comma. See {@link macroutils.StaticDeclarations}\n     *                for options.\n     * @return The AutoMeshOperation.\n     */\n    public AutoMeshOperation automatedMesh(ArrayList<GeometryPart> ag,\n            StaticDeclarations.Meshers... meshers) {\n        return automatedMesh(ag, _get.strings.meshers(meshers));\n    }\n    /**\n     * Creates a Badge for 2D Mesh Operation on a set of Geometry Parts.\n     *\n     * @param agp given ArrayList of Geometry Parts.\n     * @return The PrepareFor2dOperation.\n     */\n    public PrepareFor2dOperation badgeFor2D(ArrayList<GeometryPart> agp) {\n        _io.say.action(\"Creating a Badge for 2D Mesh Operation\", true);\n        _io.say.objects(agp, \"Geometry Parts\", true);\n        MeshOperationManager mom = _sim.get(MeshOperationManager.class);\n        PrepareFor2dOperation p2d = (PrepareFor2dOperation) mom.createPrepareFor2dOperation(agp);\n        p2d.execute();\n        _io.say.created(p2d, true);\n        return p2d;\n    }\n    /**\n     * Creates a Bounded Shape Block with individual offsets.\n     *\n     * @param agp            given ArrayList of Geometry Parts.\n     * @param negOffset      given negative 3-components offset array using\n     *                       {@link UserDeclarations#defUnitLength} units.\n     * @param posOffset      given positive 3-components offset array using\n     *                       {@link UserDeclarations#defUnitLength} units.\n     * @param centroidOffset given 3-components offset array for the centroid of supplied Geometry\n     *                       Parts.\n     * @return The MeshOperationPart.\n     */\n    public MeshOperationPart boundedShape_Block(ArrayList<GeometryPart> agp, double[] negOffset,\n            double[] posOffset, double[] centroidOffset) {\n        Units u = _ud.defUnitLength;\n        _io.say.action(\"Creating a Block Bounded Shape Mesh Operation\", true);\n        _io.say.objects(agp, \"Geometry Parts\", true);\n        BoundedShapeCreatingOperation bsmo = _createBoundedShapeMeshOp(agp,\n                BoundedShapeCreatingOperation.OutputPartType.BLOCK);\n        BoxShapeInflationControl bsic = bsmo.getBoundedShapeValuesManager()\n                .get(BoxShapeInflationControl.class);\n        bsic.setInflationMode(BoxShapeInflationControl.InflationMode.INDIVIDUAL_OFFSETS);\n        BoxShapeIndividualOffsetsInflation bsioi = bsic.getIndividualInflationOffsets();\n        _set.object.physicalQuantity(bsioi.getNXOffset(), negOffset[0], u, \"-X Offset\", true);\n        _set.object.physicalQuantity(bsioi.getNYOffset(), negOffset[1], u, \"-Y Offset\", true);\n        _set.object.physicalQuantity(bsioi.getNZOffset(), negOffset[2], u, \"-Z Offset\", true);\n        _set.object.physicalQuantity(bsioi.getPXOffset(), posOffset[0], u, \"+X Offset\", true);\n        _set.object.physicalQuantity(bsioi.getPYOffset(), posOffset[1], u, \"+Y Offset\", true);\n        _set.object.physicalQuantity(bsioi.getPZOffset(), posOffset[2], u, \"+Z Offset\", true);\n        _setCentroidOffset(bsmo, centroidOffset);\n        bsmo.execute();\n        String opName = _get.strings.withinTheBrackets(bsmo.getOutputPartNames());\n        _io.say.created(bsmo, true);\n        return (MeshOperationPart) _sim.get(SimulationPartManager.class).getPart(opName);\n    }\n    /**\n     * Creates a Bounded Shape Sphere with individual offsets.\n     *\n     * @param agp            given ArrayList of Geometry Parts.\n     * @param factor         given inflation factor w.r.t. centroid supplied as Parts.\n     * @param centroidOffset given 3-components offset array for the centroid of supplied Geometry\n     *                       Parts.\n     * @return The MeshOperationPart.\n     */\n    public MeshOperationPart boundedShape_Sphere(ArrayList<GeometryPart> agp, double factor,\n            double[] centroidOffset) {\n        Units u = _ud.defUnitLength;\n        _io.say.action(\"Creating a Block Bounded Shape Mesh Operation\", true);\n        _io.say.objects(agp, \"Geometry Parts\", true);\n        BoundedShapeCreatingOperation bsmo = _createBoundedShapeMeshOp(agp,\n                BoundedShapeCreatingOperation.OutputPartType.SPHERE);\n        BoundedShapeControlsManager bscm = bsmo.getBoundedShapeValuesManager();\n        bscm.get(BoundedShapeConstantFactorInflation.class).setInflationFactor(factor);\n        _io.say.value(\"Inflation Factor\", factor, true);\n        _setCentroidOffset(bsmo, centroidOffset);\n        bsmo.execute();\n        String opName = _get.strings.withinTheBrackets(bsmo.getOutputPartNames());\n        _io.say.created(bsmo, true);\n        return (MeshOperationPart) _sim.get(SimulationPartManager.class).getPart(opName);\n    }\n    /**\n     * Creates a One Group Contact Prevention with the supplied Geometry Objects.\n     *\n     * @param mo  given Mesh Operation.\n     * @param ago given ArrayList of Geometry Objects.\n     * @param val given search floor value.\n     * @param u   given units for the search floor.\n     * @return The PartsOneGroupContactPreventionSet.\n     */\n    public PartsOneGroupContactPreventionSet contactPrevention(MeshOperation mo,\n            ArrayList<GeometryObject> ago, double val, Units u) {\n        _io.say.action(\"Creating a Contact Prevention between Object Parts\", true);\n        _io.say.object(mo, true);\n        _io.say.objects(ago, \"Geometry Objects\", true);\n        if (!_chk.is.surfaceWrapperOperation(mo)) {\n            _io.say.msg(true, \"This is not a Surface Wrapper Mesh Operation. Skipping...\");\n            return null;\n        }\n        SurfaceWrapperAutoMeshOperation swamo = (SurfaceWrapperAutoMeshOperation) mo;\n        PartsContactPreventionSetManager pcpsm = swamo.getContactPreventionSet();\n        PartsOneGroupContactPreventionSet cp = pcpsm.createPartsOneGroupContactPreventionSet();\n        cp.getPartSurfaceGroup().setObjects(ago);\n        _set.object.physicalQuantity(cp.getFloor(), val, u, \"Search Floor\", true);\n        _io.say.ok(true);\n        return cp;\n    }\n    /**\n     * Creates a Directed Mesh Operation using an Automated 2D Mesh.\n     *\n     * @param src     given Source Part Surface.\n     * @param tgt     given Target Part Surface.\n     * @param meshers given meshers, separated by comma. See {@link macroutils.StaticDeclarations}\n     *                for options.\n     * @param nVol    given number of layers in volume distribution.\n     * @return The DirectedMeshOperation.\n     */\n    public DirectedMeshOperation directedMeshing_AutoMesh(PartSurface src, PartSurface tgt,\n            int nVol, StaticDeclarations.Meshers... meshers) {\n        _io.say.action(\"Creating a Directed Mesh Operation with an Automated 2D Mesh\", true);\n        _io.say.object(src, true);\n        _io.say.object(tgt, true);\n        _io.say.msg(true, \"Number of Layers: %d.\", nVol);\n        DirectedMeshOperation dmo = _createDirectedMeshOperation(src, tgt);\n        //--\n        String pn = src.getPart().getPresentationName();\n        DirectedMeshPartCollectionManager dmpcm = dmo.getGuidedMeshPartCollectionManager();\n        DirectedMeshPartCollection dmpc = ((DirectedMeshPartCollection) dmpcm.getObject(pn));\n        DirectedSurfaceMeshBaseManager dsmbm = dmo.getGuidedSurfaceMeshBaseManager();\n        dsmbm.createAutoSourceMesh(_get.strings.meshers(meshers), _get.objects.arrayList(dmpc));\n        DirectedAutoSourceMesh dasm = (DirectedAutoSourceMesh) dsmbm.getObjects().iterator().next();\n        _setMeshDefaults(dasm.getDefaultValues());\n        _setWorkAroundAutoSourceMesh(dasm, src.getPart());\n        DirectedMeshDistributionManager dmdm = dmo.getDirectedMeshDistributionManager();\n        DirectedMeshDistribution dmd = dmdm\n                .createDirectedMeshDistribution(new Vector<>(_get.objects.arrayList(dmpc)),\n                        \"Constant\");\n        dmd.getDefaultValues().get(DirectedMeshNumLayers.class).setNumLayers(nVol);\n        dmo.execute();\n        _io.say.created(dmo, true);\n        return dmo;\n    }\n    /**\n     * Creates a Directed Mesh Operation in a squared Channel.\n     *\n     * @param src given Source Part Surface.\n     * @param tgt given Target Part Surface.\n     * @param nX  given number of points in X-direction.\n     * @param nY  given number of points in Y-direction.\n     * @param nZ  given number of points in Z-direction.\n     * @return The DirectedMeshOperation.\n     */\n    public DirectedMeshOperation directedMeshing_Channel(PartSurface src, PartSurface tgt,\n            int nX, int nY, int nZ) {\n        _io.say.action(\"Creating a Directed Mesh Operation in a Channel\", true);\n        _io.say.msg(\"Number of Elements:\");\n        _io.say.msg(true, \"  - X Direction: %d;\", nX);\n        _io.say.msg(true, \"  - Y Direction: %d;\", nY);\n        _io.say.msg(true, \"  - Z Direction: %d.\", nZ);\n        DirectedMeshOperation dmo = _createDirectedMeshOperation(src, tgt);\n        int isX = 0, isY = 0, isZ = 0;\n        int nP1 = 2, nP2 = 2, nVol = 2;\n        PatchCurve pcX = null, pcY = null, pcZ = null, pc1 = null, pc2 = null;\n        //--\n        String pn = src.getPart().getPresentationName();\n        DirectedMeshPartCollectionManager dmpcm = dmo.getGuidedMeshPartCollectionManager();\n        DirectedMeshPartCollection dmpc = ((DirectedMeshPartCollection) dmpcm.getObject(pn));\n        Vector<PartSurface> vpsSrc = new Vector<>(_get.objects.arrayList(src));\n        Vector<PartSurface> vpsTgt = new Vector<>(_get.objects.arrayList(tgt));\n        dmo.getGuidedSurfaceMeshBaseManager().validateConfigurationForPatchMeshCreation(dmpc,\n                vpsSrc, vpsTgt);\n        //--\n        DirectedPatchSourceMesh patchMsh = dmo.getGuidedSurfaceMeshBaseManager()\n                .createPatchSourceMesh(vpsSrc, dmpc);\n        NeoProperty np = patchMsh.autopopulateFeatureEdges();\n        ArrayList<PatchCurve> pcs = _getPatchCurves(patchMsh);\n        //--\n        double err = 0.05;\n        for (PatchCurve p : pcs) {\n            DoubleVector pts = p.getPoints();\n            if (_get.info.relativeError(pts.get(0), pts.get(3), true) <= err) {\n                isX += 1;\n                pcX = p;\n                _io.say.msg(p.getPresentationName() + \" is on X plane.\");\n            }\n            if (_get.info.relativeError(pts.get(1), pts.get(4), true) <= err) {\n                isY += 1;\n                pcY = p;\n                _io.say.msg(p.getPresentationName() + \" is on Y plane.\");\n            }\n            if (_get.info.relativeError(pts.get(2), pts.get(5), true) <= err) {\n                isZ += 1;\n                pcZ = p;\n                _io.say.msg(p.getPresentationName() + \" is on Z plane.\");\n            }\n        }\n        //_io.say.msg(\"X = %d; Y = %d; Z = %d.\", isX, isY, isZ);\n        //--\n        if (isX == 4) {\n            nVol = nX;\n            pc1 = pcY;\n            nP2 = nY;\n            pc2 = pcZ;\n            nP1 = nZ;\n        } else if (isY == 4) {\n            nVol = nY;\n            pc1 = pcX;\n            nP2 = nX;\n            pc2 = pcZ;\n            nP1 = nZ;\n        } else if (isZ == 4) {\n            nVol = nZ;\n            pc1 = pcX;\n            nP2 = nX;\n            pc2 = pcY;\n            nP1 = nY;\n        }\n        //--\n        patchMsh.defineMeshPatchCurve(pc1, pc1.getStretchingFunction(), 0., 0., nP1, false, false);\n        patchMsh.defineMeshPatchCurve(pc2, pc2.getStretchingFunction(), 0., 0., nP2, false, false);\n        //--\n        DirectedMeshDistributionManager dmdm = dmo.getDirectedMeshDistributionManager();\n        DirectedMeshDistribution dmd = dmdm\n                .createDirectedMeshDistribution(new Vector<>(_get.objects.arrayList(dmpc)),\n                        \"Constant\");\n        dmd.getDefaultValues().get(DirectedMeshNumLayers.class).setNumLayers(nVol);\n        dmo.execute();\n        _io.say.created(dmo, true);\n        return dmo;\n    }\n    /**\n     * Creates a Directed Mesh Operation in a Pipe, using an O-Grid structure.\n     *\n     * @param src  given Source Part Surface.\n     * @param tgt  given Target Part Surface.\n     * @param nT   given number of points in the circumference, i.e., Theta direction.\n     * @param nR   given number of points radially.\n     * @param nVol given number of points for the volume distribution.\n     * @param rR   given r/R distance for the O-Grid. E.x.: 0.5;\n     * @param c    given Cylindrical Coordinate System.\n     * @return The DirectedMeshOperation.\n     */\n    public DirectedMeshOperation directedMeshing_Pipe(PartSurface src, PartSurface tgt,\n            int nT, int nR, int nVol, double rR, CoordinateSystem c) {\n        _io.say.action(\"Creating a Directed Mesh Operation in a Pipe\", true);\n        if (!_chk.is.cylindricalCSYS(c)) {\n            _io.say.value(\"Warning! Not a Cylindrical Coordinate System\", c.getPresentationName(),\n                    true, true);\n            _io.say.msg(\"Directed Mesh not created.\");\n            return null;\n        }\n        _io.say.msg(\"Number of Elements:\");\n        _io.say.msg(true, \"  - Tangent Direction (theta): %d;\", nT);\n        _io.say.msg(true, \"  - Radial Direction (r): %d;\", nR);\n        _io.say.msg(true, \"  - Along Pipe (axially): %d.\", nVol);\n        DirectedMeshOperation dmo = _createDirectedMeshOperation(src, tgt);\n        CylindricalCoordinateSystem ccs = (CylindricalCoordinateSystem) c;\n        //--\n        String s = src.getPart().getPresentationName();\n        DirectedMeshPartCollection dmpc = dmo.getGuidedMeshPartCollectionManager().getObject(s);\n        Vector<PartSurface> vpsSrc = new Vector<>(_get.objects.arrayList(src));\n        Vector<PartSurface> vpsTgt = new Vector<>(_get.objects.arrayList(tgt));\n        dmo.getGuidedSurfaceMeshBaseManager().validateConfigurationForPatchMeshCreation(dmpc,\n                vpsSrc, vpsTgt);\n        //--\n        DirectedPatchSourceMesh patchMsh = dmo.getGuidedSurfaceMeshBaseManager()\n                .createPatchSourceMesh(vpsSrc, dmpc);\n        NeoProperty np = patchMsh.autopopulateFeatureEdges();\n        //_io.say.msg(\"NeoProperty np = patchMsh.autopopulateFeatureEdges();\");\n        //_io.say.msg(np.getHashtable().toString());\n        //--\n        //-- Trying the simple approach, i.e., split existing patch curves\n        ArrayList<PatchCurve> pcExts = new ArrayList<>();\n        ArrayList<PatchCurve> pcInts = new ArrayList<>();\n        ArrayList<PatchCurve> stockCurves = _getPatchCurves(patchMsh);\n        _sayPatchVerticesNames(_getPatchVertices(patchMsh));\n        if (stockCurves.size() == 2) {\n            // External curves creation\n            stockCurves.forEach(patchCurve -> {\n                _io.say.msg(\"Splitting external Patch Curve: \" + patchCurve.getPresentationName());\n                patchMsh.splitPatchCurve(patchCurve, 1);\n                _sayPatchVerticesNames(_getPatchVertices(patchMsh));\n            });\n            List<PatchCurve> externalCurves = _getPatchCurves(patchMsh);\n            List<PatchVertex> sortedVertices = _getPatchVerticesSortedByAngle(patchMsh, ccs);\n            // Internal Patch curves creation\n            _io.say.msg(\"Building internal Patch Curves...\");\n            _io.say.msg(\" \");\n            List<PatchCurve> internalCurves = new ArrayList<>();\n            List<PatchVertex> internalVertices = new ArrayList<>();\n            sortedVertices.forEach(externalVertex -> {\n                // In cylindrical coordinates\n                Vector3 cartCoordsExt = new Vector3(externalVertex.getCoordinate().toDoubleArray());\n                Vector3 cylCoordsExt = _getVector3(externalVertex, ccs);\n                double extR = cylCoordsExt.x;\n                double theta = cylCoordsExt.y;\n                Vector3 cylCoordsInt = new Vector3(extR * rR, theta, 0.0);\n                // Back to cartesian\n                Vector3 cartCoordsInt = ccs.transformCoordinate(cylCoordsInt);\n                _io.say.msg(\"  - External Coordinate [Cyl]: \" + cylCoordsExt.toString());\n                _io.say.msg(\"  - Internal Coordinate [Cyl]: \" + cylCoordsInt.toString());\n                _io.say.msg(\"  - External Coordinate [Cart]: \" + cartCoordsExt.toString());\n                _io.say.msg(\"  - Internal Coordinate [Cart]: \" + cartCoordsInt.toString());\n                // Create new internal Patch curve\n                patchMsh.createPatchCurve(externalVertex, null,\n                        new DoubleVector(cartCoordsInt.toArray()),\n                        new StringVector(new String[] {\"ON_SURFACE\"}));\n                // Find out which new vertex was created\n                List<PatchVertex> currentVertices = _getPatchVertices(patchMsh);\n                currentVertices.removeAll(sortedVertices);\n                currentVertices.removeAll(internalVertices);\n                PatchVertex createdVertex = currentVertices.get(0);\n                internalVertices.add(createdVertex);\n                List<PatchCurve> currentCurves = _getPatchCurves(patchMsh);\n                currentCurves.removeAll(externalCurves);\n                currentCurves.removeAll(internalCurves);\n                PatchCurve createdCurve = currentCurves.get(0);\n                internalCurves.add(createdCurve);\n                _io.say.msg(\"  - Created Patch Curve: \" + createdCurve.getPresentationName());\n                _io.say.msg(\"  - Created Patch Vertex: \" + createdVertex.getPresentationName());\n                _io.say.msg(\" \");\n            });\n            // Finally connect all the internal created vertices to close the O-Grid loop\n            internalVertices.add(internalVertices.get(0));\n            _io.say.msg(\"Connecting internal Patch Vertices...\");\n            _io.say.msg(\" \");\n            _sayPatchVerticesNames(internalVertices);\n            for (int i = 1; i < internalVertices.size(); i++) {\n                PatchVertex fromVertex = internalVertices.get(i-1);\n                PatchVertex toVertex = internalVertices.get(i);\n                _io.say.msg(\"  - From Patch Vertex: \" + fromVertex.getPresentationName());\n                _io.say.msg(\"  - To Patch Vertex: \" + toVertex.getPresentationName());\n                _io.say.msg(\" \");\n                patchMsh.createPatchCurve(fromVertex, toVertex, new DoubleVector(new double[] {}),\n                        new StringVector(new String[] {}));\n            }\n            // Mesh distribution in theta\n            pcExts.addAll(externalCurves);\n            // Radial mesh distribution -- only one is needed\n            pcInts.add(internalCurves.get(0));\n        } else {\n            // Reevaluate when happening\n            return null;\n        }\n        //--\n        //--\n        patchMsh.defineMeshMultiplePatchCurves(new Vector<>(pcExts), nT, false);\n        patchMsh.defineMeshMultiplePatchCurves(new Vector<>(pcInts), nR, false);\n        if (_ud.dmSmooths > 0) {\n            patchMsh.smoothPatchPolygonMesh(_ud.dmSmooths, 0.25, false);\n        }\n        //--\n        DirectedMeshDistributionManager dmdm = dmo.getDirectedMeshDistributionManager();\n        DirectedMeshDistribution dmd = dmdm\n                .createDirectedMeshDistribution(new Vector<>(_get.objects.arrayList(dmpc)),\n                        \"Constant\");\n        dmd.getDefaultValues().get(DirectedMeshNumLayers.class).setNumLayers(nVol);\n        dmo.execute();\n        _io.say.created(dmo, true);\n        return dmo;\n    }\n    /**\n     * Creates a Extract Volume Mesh Operation on the supplied geometries.\n     *\n     * @param agp given ArrayList of Geometry Parts.\n     * @return The ExtractVolumeOperation.\n     */\n    public ExtractVolumeOperation extractVolume(ArrayList<GeometryPart> agp) {\n        _io.say.action(\"Creating a Extract Volume Operation\", true);\n        MeshOperationManager mom = _sim.get(MeshOperationManager.class);\n        MeshOperation mo = mom.createExtractVolumeOperation(agp);\n        _io.say.objects(agp, \"Geometry Parts\", true);\n        mo.execute();\n        _io.say.ok(true);\n        return (ExtractVolumeOperation) mo;\n    }\n    /**\n     * Creates a Fill Holes Mesh Operation on the supplied geometry objects.\n     *\n     * @param agp given ArrayList of Geometry Parts.\n     * @param aps given ArrayList of Part Surfaces.\n     * @param apc given ArrayList of Part Curves. null is ignored.\n     * @return The FillHolesOperation.\n     */\n    public FillHolesOperation fillHoles(ArrayList<GeometryPart> agp, ArrayList<PartSurface> aps,\n            ArrayList<PartCurve> apc) {\n        _io.say.action(\"Creating a Fill Holes Operation\", true);\n        MeshOperationManager mom = _sim.get(MeshOperationManager.class);\n        FillHolesOperation fho = (FillHolesOperation) mom.createFillHolesOperation(agp);\n        _io.say.objects(agp, \"Geometry Parts\", true);\n        _io.say.objects(aps, \"Part Surfaces\", true);\n        fho.getEndSurfaces().setObjects(aps);\n        if (apc != null) {\n            _io.say.objects(aps, \"Part Curves\", true);\n            fho.getEndCurves().setObjects(apc);\n        }\n        fho.execute();\n        _io.say.ok(true);\n        return fho;\n    }\n    /**\n     * Creates an Imprint Mesh Operation with the given Parts.\n     *\n     * @param agp given ArrayList of Geometry Parts.\n     * @param tol given tolerance in {@link UserDeclarations#defUnitLength} unit.\n     * @param it  given Imprint Method.\n     * @param mt  given Resulting Mesh Type\n     * @return The ImprintPartsOperation.\n     */\n    public ImprintPartsOperation imprint(ArrayList<GeometryPart> agp, double tol,\n            ImprintMergeImprintMethodOption.Type it, ImprintResultingMeshTypeOption.Type mt) {\n        _io.say.action(\"Creating an Imprint Mesh Operation\", true);\n        _io.say.objects(agp, \"Geometry Parts\", true);\n        MeshOperationManager mom = _sim.get(MeshOperationManager.class);\n        MeshOperation mo = mom.createImprintPartsOperation(agp);\n        ImprintPartsOperation ipo = (ImprintPartsOperation) mo;\n        ipo.getMergeImprintMethod().setSelected(it);\n        ipo.getResultingMeshType().setSelected(mt);\n        _io.say.value(\"Imprint Method\",\n                ipo.getMergeImprintMethod().getSelectedElement().getPresentationName(), true, true);\n        _io.say.value(\"Resulting Mesh\",\n                ipo.getResultingMeshType().getSelectedElement().getPresentationName(), true, true);\n        _set.object.physicalQuantity(ipo.getTolerance(), tol, _ud.defUnitLength, \"Tolerance\", true);\n        if (it == ImprintMergeImprintMethodOption.Type.CAD_IMPRINT) {\n            ipo.getImprintValuesManager().get(CadTessellationOption.class)\n                    .getTessellationDensityOption().setSelected(_ud.defTessOpt.getType());\n        }\n        if (mt == ImprintResultingMeshTypeOption.Type.CONFORMAL) {\n            ipo.getImprintValuesManager().get(ImprintPartSurfaces.class)\n                    .getPartSurfacesOption().setSelected(ImprintPartSurfacesOption.Type.USE_INPUT);\n        }\n        _io.say.created(ipo, true);\n        return ipo;\n    }\n    /**\n     * Creates a Subtraction Mesh Operation between a set of Geometry Parts.\n     *\n     * @param agp given ArrayList of Geometry Parts.\n     * @param tgt given target Geometry Part.\n     * @return The MeshOperationPart.\n     */\n    public MeshOperationPart subtract(ArrayList<GeometryPart> agp, GeometryPart tgt) {\n        return _createBoolean(StaticDeclarations.Operation.SUBTRACT, agp, tgt);\n    }\n    /**\n     * Creates an empty Custom Surface Control.\n     *\n     * @param mo given Mesh Operation.\n     * @return The SurfaceCustomMeshControl.\n     */\n    public SurfaceCustomMeshControl surfaceControl(MeshOperation mo) {\n        return _createSurfaceCustomMeshControl(mo, true);\n    }\n    /**\n     * Copies a Custom Surface Control from another another Mesh Operation.\n     *\n     * @param scmc given Surface Control to copy.\n     * @param mo   given Mesh Operation where will be copied too.\n     * @return The SurfaceCustomMeshControl.\n     */\n    public SurfaceCustomMeshControl surfaceControl(SurfaceCustomMeshControl scmc,\n            MeshOperation mo) {\n        _io.say.action(\"Creating a Custom Surface Mesh Control\", true);\n        _io.say.object(scmc, true);\n        _io.say.object(mo, true);\n        SurfaceCustomMeshControl scmc2 = _createSurfaceCustomMeshControl(mo, false);\n        scmc2.setPresentationName(scmc.getPresentationName());\n        scmc2.copyProperties(scmc);\n        _io.say.msg(\"Properties copied succesfully.\");\n        _io.say.created(scmc2, true);\n        return scmc2;\n    }\n    /**\n     * Creates a Custom Surface Control to change Surface Sizes in a Mesh Operation.\n     *\n     * @param mo  given Mesh Operation.\n     * @param ago given ArrayList of Geometry Objects.\n     * @param min minimum relative size (%). If 0, this parameter will not be customized.\n     * @param tgt target relative size (%). If 0, this parameter will not be customized.\n     * @return The Custom Surface Control.\n     */\n    public SurfaceCustomMeshControl surfaceControl(MeshOperation mo, ArrayList<GeometryObject> ago,\n            double min, double tgt) {\n        _io.say.action(\"Creating a Custom Surface Mesh Control\", true);\n        _io.say.object(mo, true);\n        _io.say.objects(ago, \"Geometry Objects\", true);\n        SurfaceCustomMeshControl scmc = _createSurfaceCustomMeshControl(mo, false);\n        scmc.getGeometryObjects().setObjects(ago);\n        _set.mesh.surfaceSizes(scmc, min, tgt, true);\n        _io.say.created(scmc, true);\n        return scmc;\n    }\n    /**\n     * Creates a Custom Surface Control to change Prism Layers in a Mesh Operation.\n     *\n     * <b>Important:</b> If all three arguments are 0, Prisms will be disabled.\n     *\n     * @param amo       given Auto Mesh Operation.\n     * @param ago       given ArrayList of Geometry Objects.\n     * @param numLayers given number of prisms. If 0, this parameter will not be customized.\n     * @param stretch   given prism stretch relation. If 0, this parameter will not be customized.\n     * @param relSize   given relative size in (%). If 0, this parameter will not be customized.\n     * @return The Custom Surface Control.\n     */\n    public SurfaceCustomMeshControl surfaceControl(AutoMeshOperation amo,\n            ArrayList<GeometryObject> ago, int numLayers, double stretch, double relSize) {\n        _io.say.action(\"Creating a Custom Surface Mesh Control\", true);\n        _io.say.object(amo, true);\n        _io.say.objects(ago, \"Geometry Objects\", true);\n        SurfaceCustomMeshControl scmc = amo.getCustomMeshControls().createSurfaceControl();\n        scmc.getGeometryObjects().setObjects(ago);\n        PartsCustomizePrismMesh pcpm = scmc.getCustomConditions()\n                .get(PartsCustomizePrismMesh.class);\n        if (numLayers + stretch + relSize == 0.0) {\n            _dis.prismsLayers(scmc, false);\n            _io.say.msg(\"Prism Layers DISABLED.\");\n        } else {\n            pcpm.getCustomPrismOptions().setSelected(PartsCustomPrismsOption.Type.CUSTOMIZE);\n            CustomPrismValuesManager cpvm = scmc.getCustomValues()\n                    .get(CustomPrismValuesManager.class);\n            if (numLayers > 0) {\n                pcpm.getCustomPrismControls().setCustomizeNumLayers(true);\n                cpvm.get(NumPrismLayers.class).setNumLayers(numLayers);\n            } else {\n                pcpm.getCustomPrismControls().setCustomizeNumLayers(false);\n            }\n            if (stretch > 0) {\n                pcpm.getCustomPrismControls().setCustomizeStretching(true);\n                cpvm.get(PrismLayerStretching.class).setStretching(stretch);\n            } else {\n                pcpm.getCustomPrismControls().setCustomizeStretching(false);\n            }\n            if (relSize > 0) {\n                pcpm.getCustomPrismControls().setCustomizeTotalThickness(true);\n                cpvm.get(PrismThickness.class).setRelativeSize(relSize);\n            } else {\n                pcpm.getCustomPrismControls().setCustomizeTotalThickness(false);\n            }\n        }\n        _io.say.created(scmc, true);\n        return scmc;\n    }\n    /**\n     * Creates a Surface Wrap Mesh Operation in a set of Geometry Parts.\n     *\n     * @param agp  given ArrayList of Geometry Parts.\n     * @param name given name for the Operation. The Part generated will share the same name.\n     * @return The SurfaceWrapperAutoMeshOperation.\n     */\n    public SurfaceWrapperAutoMeshOperation surfaceWrapper(ArrayList<GeometryPart> agp,\n            String name) {\n        _io.say.action(\"Creating a Surface Wrapper Mesh Operation\", true);\n        _io.say.objects(agp, \"Geometry Parts\", true);\n        MeshOperationManager mom = _sim.get(MeshOperationManager.class);\n        AutoMeshOperation amo = mom.createSurfaceWrapperAutoMeshOperation(agp, name);\n        SurfaceWrapperAutoMeshOperation swamo = (SurfaceWrapperAutoMeshOperation) amo;\n        AutoMeshDefaultValuesManager amdvm = swamo.getDefaultValues();\n        _set.mesh.baseSize(swamo, _ud.mshBaseSize, _ud.defUnitLength, false);\n        _set.mesh.surfaceSizes(swamo, _ud.mshSrfSizeMin, _ud.mshSrfSizeTgt, false);\n        _set.mesh.surfaceCurvature(amdvm.get(SurfaceCurvature.class), _ud.mshSrfCurvNumPoints,\n                false);\n        GlobalVolumeOfInterestOption gvio = amdvm.get(GlobalVolumeOfInterest.class)\n                .getVolumeOfInterestOption();\n        GeometricFeatureAngle gfa = amdvm.get(GeometricFeatureAngle.class);\n        gvio.setSelected(GlobalVolumeOfInterestOption.Type.LARGEST_INTERNAL);\n        gfa.setGeometricFeatureAngle(_ud.mshWrapperFeatureAngle);\n        _io.say.value(\"Volume of Interest\", gvio.getSelectedElement().getPresentationName(), true,\n                true);\n        _io.say.value(\"Geometric Feature Angle\", gfa.getGeometricFeatureAngle(), true);\n        _io.say.created(swamo, true);\n        return swamo;\n    }\n    /**\n     * Creates an Unite Mesh Operation between a set of Geometry Parts.\n     *\n     * @param agp given ArrayList of Geometry Parts.\n     * @return The MeshOperationPart.\n     */\n    public MeshOperationPart unite(ArrayList<GeometryPart> agp) {\n        return _createBoolean(StaticDeclarations.Operation.UNITE, agp, null);\n    }\n    /**\n     * This method is called automatically by {@link MacroUtils}.\n     */\n    public void updateInstances() {\n        _chk = _mu.check;\n        _dis = _mu.disable;\n        _get = _mu.get;\n        _io = _mu.io;\n        _set = _mu.set;\n        _ud = _mu.userDeclarations;\n    }\n    /**\n     * Creates a Custom Volumetric Control with isotropic values in a Mesh Operation.\n     *\n     * @param mo      given Mesh Operation.\n     * @param agp     given ArrayList of Geometry Parts.\n     * @param relSize relative size in (<b>%</b>). Zero is ignored.\n     * @return The VolumeCustomMeshControl.\n     */\n    public VolumeCustomMeshControl volumetricControl(MeshOperation mo, ArrayList<GeometryPart> agp,\n            double relSize) {\n        return volumetricControl(mo, agp, relSize, StaticDeclarations.COORD0);\n    }\n    /**\n     * Creates a Custom Volumetric Control in a Mesh Operation where the control can be Isotropic or\n     * Anisotropic (Trimmer only).\n     *\n     * @param mo       given Mesh Operation.\n     * @param agp      given ArrayList of Geometry Parts.\n     * @param relSize  relative size in (<b>%</b>). Zero is ignored.\n     * @param relSizes given 3-component relative sizes in (<b>%</b>). E.g.: {0, 50, 0}. Zeros will\n     *                 be ignored.\n     * @return The VolumeCustomMeshControl.\n     */\n    public VolumeCustomMeshControl volumetricControl(MeshOperation mo, ArrayList<GeometryPart> agp,\n            double relSize, double[] relSizes) {\n        _io.say.action(\"Creating a Custom Volume Mesh Control\", true);\n        _io.say.object(mo, true);\n        _io.say.objects(agp, \"Geometry Parts\", true);\n        if (!_isCustomControllable(mo)) {\n            return null;\n        }\n        AutoMeshOperation amo = (AutoMeshOperation) mo;\n        VolumeCustomMeshControl vcmc = amo.getCustomMeshControls().createVolumeControl();\n        vcmc.getGeometryObjects().setObjects(agp);\n        if (relSize > 0) {\n            _setIsotropicSize(vcmc, relSize);\n        }\n        if (_chk.has.trimmerMesher(amo) && relSizes.length == 3 && _get.info.sum(relSizes) > 0) {\n            _setAnisotropicSizes(vcmc, relSizes);\n        }\n        _io.say.created(vcmc, true);\n        return vcmc;\n    }\n    private MeshOperationPart _createBoolean(StaticDeclarations.Operation op,\n            ArrayList<GeometryPart> ag, GeometryPart tgtGP) {\n        _io.say.action(String.format(\"Creating a %s Mesh Operation\", op.toString()), true);\n        _io.say.objects(ag, \"Parts\", true);\n        MeshOperation mo = _createBooleanMeshOperation(op, tgtGP);\n        mo.getInputGeometryObjects().setObjects(ag);\n        mo.execute();\n        String opName = _get.strings.withinTheBrackets(mo.getOutputPartNames());\n        return (MeshOperationPart) _sim.get(SimulationPartManager.class).getPart(opName);\n    }\n    private MeshOperation _createBooleanMeshOperation(StaticDeclarations.Operation op,\n            GeometryPart tgtGP) {\n        MeshOperationManager mom = _sim.get(MeshOperationManager.class);\n        switch (op) {\n            case SUBTRACT:\n                SubtractPartsOperation spo = (SubtractPartsOperation) mom\n                        .createSubtractPartsOperation();\n                spo.setTargetPart((MeshPart) tgtGP);\n                return spo;\n            case UNITE:\n                UnitePartsOperation upo = (UnitePartsOperation) mom.createUnitePartsOperation();\n                return upo;\n        }\n        return null;\n    }\n    private BoundedShapeCreatingOperation _createBoundedShapeMeshOp(ArrayList<GeometryPart> agp,\n            BoundedShapeCreatingOperation.OutputPartType type) {\n        MeshOperation mo = _sim.get(MeshOperationManager.class).createBoundedShapeOperation(agp);\n        BoundedShapeCreatingOperation bsco = (BoundedShapeCreatingOperation) mo;\n        bsco.setOutputPartType(type);\n        return bsco;\n    }\n    private DirectedMeshOperation _createDirectedMeshOperation(PartSurface src, PartSurface tgt) {\n        _io.say.object(src.getPart(), true);\n        if (!_chk.is.directedMeshable(src, tgt)) {\n            return null;\n        }\n        MeshOperationManager mom = _sim.get(MeshOperationManager.class);\n        MeshOperation mo = mom.createDirectedMeshOperation(\n                new ArrayList<>(_get.objects.arrayList(src.getPart())));\n        DirectedMeshOperation dmo = (DirectedMeshOperation) mo;\n        dmo.getSourceSurfaceGroup().add(src);\n        dmo.getTargetSurfaceGroup().add(tgt);\n        return dmo;\n    }\n    private SurfaceCustomMeshControl _createSurfaceCustomMeshControl(MeshOperation mo, boolean vo) {\n        _io.say.action(\"Creating a Custom Surface Mesh Control\", vo);\n        _io.say.object(mo, vo);\n        if (!_isCustomControllable(mo)) {\n            return null;\n        }\n        AutoMeshOperation amo = (AutoMeshOperation) mo;\n        SurfaceCustomMeshControl scmc = amo.getCustomMeshControls().createSurfaceControl();\n        _io.say.created(scmc, vo);\n        return scmc;\n    }\n    private ArrayList<PatchCurve> _getPatchCurves(DirectedPatchSourceMesh patchMsh) {\n        return new ArrayList<>(patchMsh.getPatchCurveManager().getObjects());\n    }\n    private ArrayList<PatchVertex> _getPatchVertices(DirectedPatchSourceMesh patchMsh) {\n        return new ArrayList<>(patchMsh.getPatchVertexManager().getObjects());\n    }\n    private List<PatchVertex> _getPatchVerticesSortedByAngle(DirectedPatchSourceMesh patchMsh,\n            CylindricalCoordinateSystem ccs) {\n        List<PatchVertex> vertices = _getPatchVertices(patchMsh);\n        List<Double> angles = vertices.stream()\n                .map(pv -> _getVector3(pv, ccs))\n                .map(cylindricalVector -> cylindricalVector.y)\n                .collect(Collectors.toList());\n        List<Double> sortedAngles = angles.stream()\n                .sorted(Comparator.naturalOrder())\n                .collect(Collectors.toList());\n        return sortedAngles.stream()\n                .map(angle -> angles.indexOf(angle))\n                .map(i -> vertices.get(i))\n                .collect(Collectors.toList());\n    }\n    private Vector3 _getVector3(PatchVertex pv, CylindricalCoordinateSystem c) {\n        return c.transformLabCoordinate(new Vector3(pv.getCoordinate().toDoubleArray()));\n    }\n    private boolean _isCustomControllable(MeshOperation mo) {\n        if (_chk.is.autoMeshOperation(mo) || _chk.is.surfaceWrapperOperation(mo)) {\n            return true;\n        }\n        _io.say.msg(true, \"This Mesh Operation can not have Custom Controls. Skipping...\");\n        return false;\n    }\n    private void _sayPatchVerticesNames(List<PatchVertex> vertices) {\n        List<String> names = vertices.stream()\n                .map(pv -> pv.getPresentationName())\n                .collect(Collectors.toList());\n        _io.say.msg(\"Vertices: \" + names.toString());\n    }\n    private void _setAnisotropicSizes(VolumeCustomMeshControl vcmc, double[] relSizes) {\n        CustomMeshControlConditionManager vccc = vcmc.getCustomConditions();\n        VolumeControlTrimmerSizeOption vctso = vccc.get(VolumeControlTrimmerSizeOption.class);\n        vctso.setTrimmerAnisotropicSizeOption(true);\n        TrimmerAnisotropicSize tas = vcmc.getCustomValues().get(TrimmerAnisotropicSize.class);\n        if (relSizes[0] > 0) {\n            tas.setXSize(true);\n            _set.object.relativeSize(tas.getRelativeXSize(), \"Relative Size X\", relSizes[0]);\n        }\n        if (relSizes[1] > 0) {\n            tas.setYSize(true);\n            _set.object.relativeSize(tas.getRelativeYSize(), \"Relative Size Y\", relSizes[1]);\n        }\n        if (relSizes[2] > 0) {\n            tas.setZSize(true);\n            _set.object.relativeSize(tas.getRelativeZSize(), \"Relative Size Z\", relSizes[2]);\n        }\n    }\n    private void _setAutomatedMesh(AutoMeshOperation amo, ArrayList<GeometryPart> ag, String txt) {\n        _io.say.action(\"Creating an Automated Mesh Operation \" + txt, true);\n        _io.say.objects(ag, \"Geometry Parts\", true);\n        _io.say.msg(\"Meshers: \" + _get.strings\n                .withinTheBrackets(amo.getMeshersCollection().toString()));\n        _setMeshDefaults(amo.getDefaultValues());\n        _set.mesh.prisms(amo, _ud.prismsLayers, _ud.prismsStretching, _ud.prismsRelSizeHeight,\n                false);\n        _set.mesh.thinMesher(amo, _ud.thinMeshLayers, _ud.thinMeshMaxThickness, false);\n        _set.mesh.coreMeshOptimizer(amo, _ud.mshOptCycles, _ud.mshQualityThreshold, false);\n        _io.say.created(amo, true);\n    }\n    private void _setCentroidOffset(BoundedShapeCreatingOperation bsmo, double[] offset) {\n        Units u = _ud.defUnitLength;\n        BoundedShapeControlsManager bscm = bsmo.getBoundedShapeValuesManager();\n        BoundedShapeCentroidOffset bsco = bscm.get(BoundedShapeCentroidOffset.class);\n        _set.object.physicalQuantity(bsco.getXOffset(), offset[0], u, \"X Centroid Offset\", true);\n        _set.object.physicalQuantity(bsco.getYOffset(), offset[1], u, \"Y Centroid Offset\", true);\n        _set.object.physicalQuantity(bsco.getZOffset(), offset[2], u, \"Z Centroid Offset\", true);\n    }\n    private void _setIsotropicSize(VolumeCustomMeshControl vcmc, double relSize) {\n        AutoMeshOperation amo = (AutoMeshOperation) vcmc.getManager().getMeshOperation();\n        CustomMeshControlValueManager cmcvm = vcmc.getCustomValues();\n        CustomMeshControlConditionManager vccc = vcmc.getCustomConditions();\n        if (_chk.has.polyMesher(amo)) {\n            vccc.get(VolumeControlDualMesherSizeOption.class).setVolumeControlBaseSizeOption(true);\n        } else if (_chk.has.trimmerMesher(amo)) {\n            vccc.get(VolumeControlTrimmerSizeOption.class).setVolumeControlBaseSizeOption(true);\n        } else {\n            _io.say.msg(\"WARNING! Impossible to set Relative size.\");\n            return;\n        }\n        _set.object.relativeSize(cmcvm.get(VolumeControlSize.class), \"Relative Size\", relSize);\n    }\n    private void _setMeshDefaults(AutoMeshDefaultValuesManager amdvm) {\n        boolean isTrimmer = false;\n        if (amdvm.getParent() instanceof AutoMeshOperation) {\n            AutoMeshOperation amo = amdvm.getParent();\n            isTrimmer = _chk.has.trimmerMesher(amo);\n        }\n        _set.object.physicalQuantity(amdvm.get(BaseSize.class), _ud.mshBaseSize, _ud.defUnitLength,\n                \"Base Size\", true);\n        _set.object.relativeSize(amdvm.get(PartsTargetSurfaceSize.class), \"Target Surface Size\",\n                _ud.mshSrfSizeTgt);\n        if (amdvm.has(\"Minimum Surface Size\")) {\n            _set.object.relativeSize(amdvm.get(PartsMinimumSurfaceSize.class),\n                    \"Minimum Surface Size\", _ud.mshSrfSizeMin);\n        }\n        if (amdvm.has(\"Surface Curvature\")) {\n            _set.mesh.surfaceCurvature(amdvm.get(SurfaceCurvature.class),\n                    _ud.mshSrfCurvNumPoints, false);\n        }\n        if (amdvm.has(\"Surface Proximity\")) {\n            _set.mesh.surfaceProximity(amdvm.get(SurfaceProximity.class),\n                    _ud.mshProximityPointsInGap, _ud.mshProximitySearchFloor, false);\n        }\n        if (amdvm.has(\"Volume Growth Rate\") && isTrimmer) {\n            star.trimmer.PartsGrowthRateOption.Type t = _ud.mshTrimmerGrowthRate.getType();\n            amdvm.get(PartsSimpleTemplateGrowthRate.class).getGrowthRateOption().setSelected(t);\n            _io.say.value(\"Growth Rate Type\", t.getPresentationName(), true, true);\n        }\n        if (amdvm.has(\"Maximum Cell Size\")) {\n            _set.object.relativeSize(amdvm.get(MaximumCellSize.class), \"Maximum Cell Size\",\n                    _ud.mshTrimmerMaxCellSize);\n        }\n    }\n    private void _setWorkAroundAutoSourceMesh(DirectedAutoSourceMesh dasm, GeometryPart gp) {\n        //-- Check later.\n        // Workaround for legacy limitation of Target size not being respected in 2D meshes.\n        SurfaceCustomMeshControl scmc = dasm.getCustomMeshControls().createSurfaceControl();\n        scmc.getGeometryObjects().setObjects(gp);\n        CustomMeshControlConditionManager cmccm = scmc.getCustomConditions();\n        cmccm.get(PartsTargetSurfaceSizeOption.class)\n                .setSelected(PartsTargetSurfaceSizeOption.Type.CUSTOM);\n        _set.object.relativeSize(scmc.getCustomValues().get(PartsTargetSurfaceSize.class),\n                \"Relative Size\", _ud.mshSrfSizeTgt);\n        scmc.setPresentationName(\"Work-Around AutoSource Mesh\");\n    }\n"]], "pred": {"ppl": 2.0578300952911377, "ppl_lower": 2.685922622680664, "ppl/lowercase_ppl": -1.3691144571321512, "ppl/zlib": 8.884058547780046e-05, "Min_5.0% Prob": 7.389689043456433, "Min_10.0% Prob": 5.517720905004763, "Min_20.0% Prob": 3.419647789761132, "Min_30.0% Prob": 2.3791117884364783, "Min_40.0% Prob": 1.7990230237177065, "Min_50.0% Prob": 1.443417128673053, "Min_60.0% Prob": 1.204015200789395}}
{"hexsha": "18d95165dd89de4af5d4038d82f2b9dcec616e6c", "ext": "java", "lang": "Java", "content": "public class DeclutterableText implements Declutterable\n{\n    protected GeographicText text;\n    protected Vec4 point;\n    protected double eyeDistance;\n    protected DeclutteringTextRenderer textRenderer;\n    protected boolean enableDecluttering = true;\n    protected Rectangle2D textBounds; // cached text bounds\n    protected Font boundsFont; // font used by cached text bounds\n\n    /**\n     * Construct an object for specified text and position.\n     *\n     * @param text         the text to display.\n     * @param point        the Cartesian location of the text.\n     * @param eyeDistance  the distance to consider the text from the eye.\n     * @param textRenderer the text renderer to use to draw the text.\n     */\n    DeclutterableText(GeographicText text, Vec4 point, double eyeDistance, DeclutteringTextRenderer textRenderer)\n    {\n        this.text = text;\n        this.point = point;\n        this.eyeDistance = eyeDistance;\n        this.textRenderer = textRenderer;\n    }\n\n    /**\n     * Indicates whether this text should participate in decluttering.\n     *\n     * @return true (the default) if it should participate, otherwise false.\n     */\n    public boolean isEnableDecluttering()\n    {\n        return this.enableDecluttering;\n    }\n\n    public double getDistanceFromEye()\n    {\n        return this.eyeDistance;\n    }\n\n    public GeographicText getText()\n    {\n        return text;\n    }\n\n    public Vec4 getPoint()\n    {\n        return point;\n    }\n\n    public Rectangle2D getBounds(DrawContext dc)\n    {\n        Font font = this.getText().getFont();\n        if (font == null)\n            font = this.textRenderer.getDefaultFont();\n\n        if (this.textBounds != null && this.boundsFont == font)\n            return this.textBounds;\n\n        try\n        {\n            this.textBounds = this.textRenderer.computeTextBounds(dc, this);\n            this.boundsFont = font;\n        }\n        catch (Exception e)\n        {\n            Logging.logger().log(java.util.logging.Level.SEVERE, \"generic.ExceptionWhileRenderingText\", e);\n        }\n\n        return this.textBounds;\n    }\n\n    /** {@inheritDoc} */\n    public void render(DrawContext dc)\n    {\n        try\n        {\n            if (this.getBounds(dc) == null)\n                return;\n\n            this.textRenderer.drawText(dc, this, 1, 1);\n        }\n        catch (Exception e)\n        {\n            Logging.logger().log(java.util.logging.Level.SEVERE, \"generic.ExceptionWhileRenderingText\", e);\n        }\n    }\n\n    public void pick(DrawContext dc, java.awt.Point pickPoint)\n    {\n        // TODO\n    }\n}", "item_id": 0, "repo": "WorldWindEarth/WorldWindJava", "file": "src/gov/nasa/worldwind/render/DeclutterableText.java", "last_update_at": "2022-03-31T12:30:58+00:00", "question_id": "18d95165dd89de4af5d4038d82f2b9dcec616e6c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DeclutterableText implements Declutterable\n{\n    protected GeographicText text;\n    protected Vec4 point;\n    protected double eyeDistance;\n    protected DeclutteringTextRenderer textRenderer;\n    protected boolean enableDecluttering = true;\n    protected Rectangle2D textBounds; // cached text bounds\n    protected Font boundsFont; // font used by cached text bounds\n    /**\n     * Construct an object for specified text and position.\n     *\n     * @param text         the text to display.\n     * @param point        the Cartesian location of the text.\n     * @param eyeDistance  the distance to consider the text from the eye.\n     * @param textRenderer the text renderer to use to draw the text.\n     */\n    DeclutterableText(GeographicText text, Vec4 point, double eyeDistance, DeclutteringTextRenderer textRenderer)\n    {\n        this.text = text;\n        this.point = point;\n        this.eyeDistance = eyeDistance;\n        this.textRenderer = textRenderer;\n    }\n    /**\n     * Indicates whether this text should participate in decluttering.\n     *\n     * @return true (the default) if it should participate, otherwise false.\n     */\n    public boolean isEnableDecluttering()\n    {\n        return this.enableDecluttering;\n    }\n    public double getDistanceFromEye()\n    {\n        return this.eyeDistance;\n    }\n    public GeographicText getText()\n    {\n        return text;\n    }\n    public Vec4 getPoint()\n    {\n        return point;\n    }\n    public Rectangle2D getBounds(DrawContext dc)\n    {\n        Font font = this.getText().getFont();\n        if (font == null)\n            font = this.textRenderer.getDefaultFont();\n        if (this.textBounds != null && this.boundsFont == font)\n            return this.textBounds;\n        try\n        {\n            this.textBounds = this.textRenderer.computeTextBounds(dc, this);\n            this.boundsFont = font;\n        }\n        catch (Exception e)\n        {\n            Logging.logger().log(java.util.logging.Level.SEVERE, \"generic.ExceptionWhileRenderingText\", e);\n        }\n        return this.textBounds;\n    }\n    /** {@inheritDoc} */\n    public void render(DrawContext dc)\n    {\n        try\n        {\n            if (this.getBounds(dc) == null)\n                return;\n            this.textRenderer.drawText(dc, this, 1, 1);\n        }\n        catch (Exception e)\n        {\n            Logging.logger().log(java.util.logging.Level.SEVERE, \"generic.ExceptionWhileRenderingText\", e);\n        }\n    }\n    public void pick(DrawContext dc, java.awt.Point pickPoint)\n    {\n        // TODO\n    }\n"]], "pred": {"ppl": 1.6647034883499146, "ppl_lower": 2.0806162357330322, "ppl/lowercase_ppl": -1.4375912831250357, "ppl/zlib": 0.0006315328655492576, "Min_5.0% Prob": 5.264503349576677, "Min_10.0% Prob": 3.7559415521756025, "Min_20.0% Prob": 2.3452889646266724, "Min_30.0% Prob": 1.6649967448037362, "Min_40.0% Prob": 1.2665496578348892, "Min_50.0% Prob": 1.0190425252134936, "Min_60.0% Prob": 0.8490717311938986}}
{"hexsha": "a2f16597aa6277fc1e791fc750eb9adcb249e15f", "ext": "java", "lang": "Java", "content": "public class RequestStartPledgeWar extends GameClientPacket\n{\n\tprivate String _pledgeName;\n\t\n\t@Override\n\tprotected void readImpl()\n\t{\n\t\t_pledgeName = readS();\n\t}\n\t\n\t@Override\n\tprotected void runImpl()\n\t{\n\t\tfinal PlayerInstance player = getClient().getPlayer();\n\t\tif (player == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal Clan playerClan = player.getClan();\n\t\tif (playerClan == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif ((playerClan.getLevel() < 3) || (playerClan.getMembersCount() < Config.ALT_CLAN_MEMBERS_FOR_WAR))\n\t\t{\n\t\t\tplayer.sendPacket(new SystemMessage(SystemMessageId.A_CLAN_WAR_CAN_BE_DECLARED_ONLY_IF_THE_CLAN_IS_LEVEL_THREE_OR_ABOVE_AND_THE_NUMBER_OF_CLAN_MEMBERS_IS_FIFTEEN_OR_GREATER));\n\t\t\tplayer.sendPacket(ActionFailed.STATIC_PACKET);\n\t\t\treturn;\n\t\t}\n\t\telse if (!player.isClanLeader())\n\t\t{\n\t\t\tplayer.sendMessage(\"You can't declare war. You are not clan leader.\");\n\t\t\tplayer.sendPacket(ActionFailed.STATIC_PACKET);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal Clan clan = ClanTable.getInstance().getClanByName(_pledgeName);\n\t\tif (clan == null)\n\t\t{\n\t\t\tplayer.sendPacket(new SystemMessage(SystemMessageId.A_CLAN_WAR_CANNOT_BE_DECLARED_AGAINST_A_CLAN_THAT_DOES_NOT_EXIST));\n\t\t\tplayer.sendPacket(ActionFailed.STATIC_PACKET);\n\t\t\treturn;\n\t\t}\n\t\telse if ((playerClan.getAllyId() == clan.getAllyId()) && (playerClan.getAllyId() != 0))\n\t\t{\n\t\t\tplayer.sendPacket(new SystemMessage(SystemMessageId.A_DECLARATION_OF_CLAN_WAR_AGAINST_AN_ALLIED_CLAN_CAN_T_BE_MADE));\n\t\t\tplayer.sendPacket(ActionFailed.STATIC_PACKET);\n\t\t\treturn;\n\t\t}\n\t\telse if ((clan.getLevel() < 3) || (clan.getMembersCount() < Config.ALT_CLAN_MEMBERS_FOR_WAR))\n\t\t{\n\t\t\tplayer.sendPacket(new SystemMessage(SystemMessageId.A_CLAN_WAR_CAN_BE_DECLARED_ONLY_IF_THE_CLAN_IS_LEVEL_THREE_OR_ABOVE_AND_THE_NUMBER_OF_CLAN_MEMBERS_IS_FIFTEEN_OR_GREATER));\n\t\t\tplayer.sendPacket(ActionFailed.STATIC_PACKET);\n\t\t\treturn;\n\t\t}\n\t\telse if (playerClan.isAtWarWith(clan.getClanId()))\n\t\t{\n\t\t\tfinal SystemMessage sm = new SystemMessage(SystemMessageId.YOU_HAVE_ALREADY_BEEN_AT_WAR_WITH_THE_S1_CLAN_5_DAYS_MUST_PASS_BEFORE_YOU_CAN_DECLARE_WAR_AGAIN); // msg id 628\n\t\t\tsm.addString(clan.getName());\n\t\t\tplayer.sendPacket(sm);\n\t\t\tplayer.sendPacket(ActionFailed.STATIC_PACKET);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// LOGGER.warning(\"RequestStartPledgeWar, leader: \" + clan.getLeaderName() + \" clan: \"+ _clan.getName());\n\t\t\n\t\t// PlayerInstance leader = World.getInstance().getPlayer(clan.getLeaderName());\n\t\t\n\t\t// if(leader == null)\n\t\t// return;\n\t\t\n\t\t// if(leader != null && leader.isOnline() == 0)\n\t\t// {\n\t\t// player.sendMessage(\"Clan leader isn't online.\");\n\t\t// player.sendPacket(ActionFailed.STATIC_PACKET);\n\t\t// return;\n\t\t// }\n\t\t\n\t\t// if (leader.isProcessingRequest())\n\t\t// {\n\t\t// SystemMessage sm = new SystemMessage(SystemMessage.S1_IS_BUSY_TRY_LATER);\n\t\t// sm.addString(leader.getName());\n\t\t// player.sendPacket(sm);\n\t\t// return;\n\t\t// }\n\t\t\n\t\t// if (leader.isTransactionInProgress())\n\t\t// {\n\t\t// SystemMessage sm = new SystemMessage(SystemMessage.S1_IS_BUSY_TRY_LATER);\n\t\t// sm.addString(leader.getName());\n\t\t// player.sendPacket(sm);\n\t\t// return;\n\t\t// }\n\t\t\n\t\t// leader.setTransactionRequester(player);\n\t\t// player.setTransactionRequester(leader);\n\t\t// leader.sendPacket(new StartPledgeWar(_clan.getName(),player.getName()));\n\t\tClanTable.getInstance().storeClanWars(player.getClanId(), clan.getClanId());\n\t\tfor (PlayerInstance cha : World.getInstance().getAllPlayers())\n\t\t{\n\t\t\tif ((cha.getClan() == player.getClan()) || (cha.getClan() == clan))\n\t\t\t{\n\t\t\t\tcha.broadcastUserInfo();\n\t\t\t}\n\t\t}\n\t}\n}", "item_id": 0, "repo": "juninhorosa/L2JServer_C6_Interlude", "file": "java/org/l2jserver/gameserver/network/clientpackets/RequestStartPledgeWar.java", "last_update_at": "2022-02-24T01:37:23+00:00", "question_id": "a2f16597aa6277fc1e791fc750eb9adcb249e15f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RequestStartPledgeWar extends GameClientPacket\n{\n\tprivate String _pledgeName;\n\t\n\t@Override\n\tprotected void readImpl()\n\t{\n\t\t_pledgeName = readS();\n\t}\n\t\n\t@Override\n\tprotected void runImpl()\n\t{\n\t\tfinal PlayerInstance player = getClient().getPlayer();\n\t\tif (player == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal Clan playerClan = player.getClan();\n\t\tif (playerClan == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif ((playerClan.getLevel() < 3) || (playerClan.getMembersCount() < Config.ALT_CLAN_MEMBERS_FOR_WAR))\n\t\t{\n\t\t\tplayer.sendPacket(new SystemMessage(SystemMessageId.A_CLAN_WAR_CAN_BE_DECLARED_ONLY_IF_THE_CLAN_IS_LEVEL_THREE_OR_ABOVE_AND_THE_NUMBER_OF_CLAN_MEMBERS_IS_FIFTEEN_OR_GREATER));\n\t\t\tplayer.sendPacket(ActionFailed.STATIC_PACKET);\n\t\t\treturn;\n\t\t}\n\t\telse if (!player.isClanLeader())\n\t\t{\n\t\t\tplayer.sendMessage(\"You can't declare war. You are not clan leader.\");\n\t\t\tplayer.sendPacket(ActionFailed.STATIC_PACKET);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal Clan clan = ClanTable.getInstance().getClanByName(_pledgeName);\n\t\tif (clan == null)\n\t\t{\n\t\t\tplayer.sendPacket(new SystemMessage(SystemMessageId.A_CLAN_WAR_CANNOT_BE_DECLARED_AGAINST_A_CLAN_THAT_DOES_NOT_EXIST));\n\t\t\tplayer.sendPacket(ActionFailed.STATIC_PACKET);\n\t\t\treturn;\n\t\t}\n\t\telse if ((playerClan.getAllyId() == clan.getAllyId()) && (playerClan.getAllyId() != 0))\n\t\t{\n\t\t\tplayer.sendPacket(new SystemMessage(SystemMessageId.A_DECLARATION_OF_CLAN_WAR_AGAINST_AN_ALLIED_CLAN_CAN_T_BE_MADE));\n\t\t\tplayer.sendPacket(ActionFailed.STATIC_PACKET);\n\t\t\treturn;\n\t\t}\n\t\telse if ((clan.getLevel() < 3) || (clan.getMembersCount() < Config.ALT_CLAN_MEMBERS_FOR_WAR))\n\t\t{\n\t\t\tplayer.sendPacket(new SystemMessage(SystemMessageId.A_CLAN_WAR_CAN_BE_DECLARED_ONLY_IF_THE_CLAN_IS_LEVEL_THREE_OR_ABOVE_AND_THE_NUMBER_OF_CLAN_MEMBERS_IS_FIFTEEN_OR_GREATER));\n\t\t\tplayer.sendPacket(ActionFailed.STATIC_PACKET);\n\t\t\treturn;\n\t\t}\n\t\telse if (playerClan.isAtWarWith(clan.getClanId()))\n\t\t{\n\t\t\tfinal SystemMessage sm = new SystemMessage(SystemMessageId.YOU_HAVE_ALREADY_BEEN_AT_WAR_WITH_THE_S1_CLAN_5_DAYS_MUST_PASS_BEFORE_YOU_CAN_DECLARE_WAR_AGAIN); // msg id 628\n\t\t\tsm.addString(clan.getName());\n\t\t\tplayer.sendPacket(sm);\n\t\t\tplayer.sendPacket(ActionFailed.STATIC_PACKET);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// LOGGER.warning(\"RequestStartPledgeWar, leader: \" + clan.getLeaderName() + \" clan: \"+ _clan.getName());\n\t\t\n\t\t// PlayerInstance leader = World.getInstance().getPlayer(clan.getLeaderName());\n\t\t\n\t\t// if(leader == null)\n\t\t// return;\n\t\t\n\t\t// if(leader != null && leader.isOnline() == 0)\n\t\t// {\n\t\t// player.sendMessage(\"Clan leader isn't online.\");\n\t\t// player.sendPacket(ActionFailed.STATIC_PACKET);\n\t\t// return;\n\t\t// }\n\t\t\n\t\t// if (leader.isProcessingRequest())\n\t\t// {\n\t\t// SystemMessage sm = new SystemMessage(SystemMessage.S1_IS_BUSY_TRY_LATER);\n\t\t// sm.addString(leader.getName());\n\t\t// player.sendPacket(sm);\n\t\t// return;\n\t\t// }\n\t\t\n\t\t// if (leader.isTransactionInProgress())\n\t\t// {\n\t\t// SystemMessage sm = new SystemMessage(SystemMessage.S1_IS_BUSY_TRY_LATER);\n\t\t// sm.addString(leader.getName());\n\t\t// player.sendPacket(sm);\n\t\t// return;\n\t\t// }\n\t\t\n\t\t// leader.setTransactionRequester(player);\n\t\t// player.setTransactionRequester(leader);\n\t\t// leader.sendPacket(new StartPledgeWar(_clan.getName(),player.getName()));\n\t\tClanTable.getInstance().storeClanWars(player.getClanId(), clan.getClanId());\n\t\tfor (PlayerInstance cha : World.getInstance().getAllPlayers())\n\t\t{\n\t\t\tif ((cha.getClan() == player.getClan()) || (cha.getClan() == clan))\n\t\t\t{\n\t\t\t\tcha.broadcastUserInfo();\n\t\t\t}\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.4112118482589722, "ppl_lower": 1.7759660482406616, "ppl/lowercase_ppl": -1.6674307586117691, "ppl/zlib": 0.0003289864394558421, "Min_5.0% Prob": 4.4663641265794345, "Min_10.0% Prob": 2.967707271669425, "Min_20.0% Prob": 1.686417977380402, "Min_30.0% Prob": 1.1465730170713238, "Min_40.0% Prob": 0.8606857608054244, "Min_50.0% Prob": 0.6893611547884344, "Min_60.0% Prob": 0.5747782132518725}}
{"hexsha": "682b1b2e97e87628ab52e2898214c99e8e8409c2", "ext": "java", "lang": "Java", "content": "public class InMemoryStorageTest {\n  private InMemoryStorage<Integer> storage;\n\n  @BeforeEach\n  public void setup() {\n    storage = InMemoryStorage.<Integer>builder().maxItems(2).build();\n  }\n\n  @Test\n  public void itCanSave() {\n    storage.save(123);\n\n    assertThat(storage.peek().getValue()).isEqualTo(123);\n  }\n\n  @Test\n  public void itCanSaveAndRemoveIfExceedTheMaxItemsSize() {\n    storage.save(123);\n    storage.save(456);\n    storage.save(789);\n\n    assertThat(storage.peek().getValue()).isEqualTo(456);\n  }\n\n  @Test\n  public void itCanGetItemsForALimitLessThanCurrentItems() {\n    storage.save(123);\n    storage.save(456);\n\n    List<StorageItem<Integer>> items = storage.get(1);\n    assertThat(items.stream().map(StorageItem::getValue).collect(Collectors.toList()))\n        .isEqualTo(List.of(123));\n  }\n\n  @Test\n  public void itCanGetItemsForALimitEqualToCurrentItems() {\n    storage.save(123);\n    storage.save(456);\n\n    List<StorageItem<Integer>> items = storage.get(2);\n    assertThat(items.stream().map(StorageItem::getValue).collect(Collectors.toList()))\n        .isEqualTo(List.of(123, 456));\n  }\n\n  @Test\n  public void itCanGetItemsForALimitMoreThanCurrentItems() {\n    storage.save(123);\n    storage.save(456);\n\n    List<StorageItem<Integer>> items = storage.get(3);\n    assertThat(items.stream().map(StorageItem::getValue).collect(Collectors.toList()))\n        .isEqualTo(List.of(123, 456));\n  }\n\n  @Test\n  public void itCanRemoveByTimestamp() {\n    storage.save(123);\n    StorageItem<Integer> item = storage.peek();\n    storage.remove(item.getTimestamp());\n\n    assertThat(storage.peek()).isNull();\n  }\n}", "item_id": 0, "repo": "exceptionless/Exceptionless.Java", "file": "src/test/java/com/exceptionless/exceptionlessclient/storage/InMemoryStorageTest.java", "last_update_at": "2022-02-11T05:23:08+00:00", "question_id": "682b1b2e97e87628ab52e2898214c99e8e8409c2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class InMemoryStorageTest {\n  private InMemoryStorage<Integer> storage;\n  @BeforeEach\n  public void setup() {\n    storage = InMemoryStorage.<Integer>builder().maxItems(2).build();\n  }\n  @Test\n  public void itCanSave() {\n    storage.save(123);\n    assertThat(storage.peek().getValue()).isEqualTo(123);\n  }\n  @Test\n  public void itCanSaveAndRemoveIfExceedTheMaxItemsSize() {\n    storage.save(123);\n    storage.save(456);\n    storage.save(789);\n    assertThat(storage.peek().getValue()).isEqualTo(456);\n  }\n  @Test\n  public void itCanGetItemsForALimitLessThanCurrentItems() {\n    storage.save(123);\n    storage.save(456);\n    List<StorageItem<Integer>> items = storage.get(1);\n    assertThat(items.stream().map(StorageItem::getValue).collect(Collectors.toList()))\n        .isEqualTo(List.of(123));\n  }\n  @Test\n  public void itCanGetItemsForALimitEqualToCurrentItems() {\n    storage.save(123);\n    storage.save(456);\n    List<StorageItem<Integer>> items = storage.get(2);\n    assertThat(items.stream().map(StorageItem::getValue).collect(Collectors.toList()))\n        .isEqualTo(List.of(123, 456));\n  }\n  @Test\n  public void itCanGetItemsForALimitMoreThanCurrentItems() {\n    storage.save(123);\n    storage.save(456);\n    List<StorageItem<Integer>> items = storage.get(3);\n    assertThat(items.stream().map(StorageItem::getValue).collect(Collectors.toList()))\n        .isEqualTo(List.of(123, 456));\n  }\n  @Test\n  public void itCanRemoveByTimestamp() {\n    storage.save(123);\n    StorageItem<Integer> item = storage.peek();\n    storage.remove(item.getTimestamp());\n    assertThat(storage.peek()).isNull();\n  }\n"]], "pred": {"ppl": 1.4537172317504883, "ppl_lower": 1.638756275177002, "ppl/lowercase_ppl": -1.3202514095697355, "ppl/zlib": 0.0009036808794645457, "Min_5.0% Prob": 4.537487702710288, "Min_10.0% Prob": 3.2041038743087222, "Min_20.0% Prob": 1.813489477718826, "Min_30.0% Prob": 1.2374442379921675, "Min_40.0% Prob": 0.9363683383475033, "Min_50.0% Prob": 0.7489301104998618, "Min_60.0% Prob": 0.623749592216165}}
{"hexsha": "c70dbee9c06604d822b612fb40b23f4b8dc69ca2", "ext": "java", "lang": "Java", "content": "public class Ledger extends AbstractAccountingConcept {\n\n  private static final String FACTORY_CLASS_NAME = \"com.yanimetaxas.bookkeeping.BankFactoryImpl\";\n\n  private String name;\n  private ChartOfAccounts chartOfAccounts;\n\n  private Ledger(LedgerBuilder builder) throws InfrastructureException {\n    super(FACTORY_CLASS_NAME, builder.options);\n    this.chartOfAccounts = builder.chartOfAccounts;\n    this.name = builder.name;\n  }\n\n  public Ledger init() {\n    chartOfAccounts.get().forEach(account -> {\n      if (!account.getBalance().isNullMoney()) {\n        getAccountService().createAccount(account.getAccountRef(), account.getBalance());\n      }\n    });\n    return this;\n  }\n\n  public void commit(TransferRequest transferRequest) {\n    validateAccountRefs(\n        transferRequest.getLegs()\n            .stream()\n            .map(TransactionLeg::getAccountRef)\n            .toArray(String[]::new)\n    );\n    getTransferService().transferFunds(transferRequest);\n  }\n\n  private void validateAccountRefs(String... accountRefs) {\n    List<String> chartOfAccountsRefs = this.chartOfAccounts.get()\n        .stream()\n        .map(Account::getAccountRef)\n        .collect(Collectors.toList());\n\n    for (String ref : accountRefs) {\n      if (!chartOfAccountsRefs.contains(ref)) {\n        throw new LedgerAccountException(ref);\n      }\n    }\n  }\n\n  public ReferenceStep createTransferRequest() {\n    return TransferRequest.builder();\n  }\n\n  public List<Transaction> findTransactions(String accountRef) {\n    validateAccountRefs(accountRef);\n    return getTransferService().findTransactionsByAccountRef(accountRef);\n  }\n\n  public Transaction getTransactionByRef(String transactionRef) {\n    return getTransferService().getTransactionByRef(transactionRef);\n  }\n\n  public Money getAccountBalance(String accountRef) {\n    validateAccountRefs(accountRef);\n    return getAccountService().getAccountBalance(accountRef);\n  }\n\n  public void printHistoryLog() {\n    System.out.println(toString());\n  }\n\n  private String formatAccounts() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"Ledger: \" + name + \"\\n\\n\");\n    sb.append(String\n        .format(\"%20s %20s %10s %15s %10s %10s\", \"Account\", \"|\", \"Amount\", \"|\", \"Currency\", \"|\"));\n    sb.append(String.format(\"%s\",\n        \"\\n------------------------------------------------------------------------------------------\"));\n\n    chartOfAccounts.get().forEach(account -> {\n      Money money = getAccountService().getAccountBalance(account.getAccountRef());\n      sb.append(\"\\n\" + String\n          .format(\"%20s %20s %10.2f %15s %10s %10s\", account.getAccountRef(), \"|\",\n              money.getAmount(), \"|\",\n              money.getCurrency(), \"|\"));\n    });\n\n    return sb.toString();\n  }\n\n  private String formatTransactionLog() {\n    StringBuilder sb = new StringBuilder();\n\n    sb.append(String\n        .format(\"%20s %20s %15s %10s %10s %10s %10s\", \"Account\", \"|\", \"Transaction\", \"|\", \"Type\",\n            \"|\", \"Date\"));\n    sb.append(String.format(\"%s\",\n        \"\\n-------------------------------------------------------------------------------------------------------------------------\"));\n\n    chartOfAccounts.get().forEach(account -> {\n      List<Transaction> transactions = getTransferService()\n          .findTransactionsByAccountRef(account.getAccountRef());\n      if (!transactions.isEmpty()) {\n        transactions.forEach(transaction -> sb.append(\"\\n\" + String\n            .format(\"%20s %20s %10s %15s %10s %10s %10s %1s\", account.getAccountRef(), \"|\",\n                transaction.getTransactionRef(), \"|\", transaction.getTransactionType(), \"|\",\n                transaction.getTransactionDate(), \"|\")));\n      } else {\n        sb.append(\"\\n\" + String\n            .format(\"%20s %20s %10s %15s %10s %10s %10s %1s\", account.getAccountRef(), \"|\",\n                \"N/A\", \"|\", \"N/A\", \"|\",\n                \"N/A\", \"|\"));\n      }\n    });\n    chartOfAccounts.get().forEach(account -> {\n      List<Transaction> transactions = getTransferService()\n          .findTransactionsByAccountRef(account.getAccountRef());\n      if (!transactions.isEmpty()) {\n        sb.append(\n            \"\\n\\n\" + String.format(\"%20s %20s %15s %4s %10s %10s %15s %5s\", \"Account\", \"|\",\n                \"Transaction Leg Ref\", \"|\", \"Amount\", \"|\", \"Currency\", \"|\"));\n        sb.append(String.format(\"%s\",\n            \"\\n-------------------------------------------------------------------------------------------------------------------------\"));\n        transactions.forEach(transaction ->\n            transaction.getLegs().forEach(leg -> sb.append(\"\\n\" + String\n                .format(\"%20s %20s %10s %10s %10s %10s %10s %10s\", account.getAccountRef(), \"|\",\n                    leg.getAccountRef(), \"|\", leg.getAmount().getAmount(), \"|\",\n                    leg.getAmount().getCurrency(), \"|\"))));\n      }\n    });\n\n    return sb.toString();\n  }\n\n  @Override\n  public String toString() {\n    return formatAccounts() + \"\\n\\n\" + formatTransactionLog() + \"\\n\\n\";\n  }\n\n  public static class LedgerBuilder {\n\n    private String name = \"General Ledger\";\n    private ChartOfAccounts chartOfAccounts;\n    private ConnectionOptions options = ConnectionOptions.EMBEDDED_H2_CONNECTION;\n\n    public LedgerBuilder(ChartOfAccounts chartOfAccounts) {\n      this.chartOfAccounts = chartOfAccounts;\n    }\n\n    public LedgerBuilder name(String name) {\n      this.name = name;\n      return this;\n    }\n\n    public LedgerBuilder options(ConnectionOptions options) {\n      this.options = options;\n      return this;\n    }\n\n    public Ledger build() {\n      return new Ledger(this);\n    }\n  }\n}", "item_id": 0, "repo": "imetaxas/double-entry-bookkeeping-api", "file": "src/main/java/com/yanimetaxas/bookkeeping/Ledger.java", "last_update_at": "2022-03-13T10:33:09+00:00", "question_id": "c70dbee9c06604d822b612fb40b23f4b8dc69ca2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Ledger extends AbstractAccountingConcept {\n  private static final String FACTORY_CLASS_NAME = \"com.yanimetaxas.bookkeeping.BankFactoryImpl\";\n  private String name;\n  private ChartOfAccounts chartOfAccounts;\n  private Ledger(LedgerBuilder builder) throws InfrastructureException {\n    super(FACTORY_CLASS_NAME, builder.options);\n    this.chartOfAccounts = builder.chartOfAccounts;\n    this.name = builder.name;\n  }\n  public Ledger init() {\n    chartOfAccounts.get().forEach(account -> {\n      if (!account.getBalance().isNullMoney()) {\n        getAccountService().createAccount(account.getAccountRef(), account.getBalance());\n      }\n    });\n    return this;\n  }\n  public void commit(TransferRequest transferRequest) {\n    validateAccountRefs(\n        transferRequest.getLegs()\n            .stream()\n            .map(TransactionLeg::getAccountRef)\n            .toArray(String[]::new)\n    );\n    getTransferService().transferFunds(transferRequest);\n  }\n  private void validateAccountRefs(String... accountRefs) {\n    List<String> chartOfAccountsRefs = this.chartOfAccounts.get()\n        .stream()\n        .map(Account::getAccountRef)\n        .collect(Collectors.toList());\n    for (String ref : accountRefs) {\n      if (!chartOfAccountsRefs.contains(ref)) {\n        throw new LedgerAccountException(ref);\n      }\n    }\n  }\n  public ReferenceStep createTransferRequest() {\n    return TransferRequest.builder();\n  }\n  public List<Transaction> findTransactions(String accountRef) {\n    validateAccountRefs(accountRef);\n    return getTransferService().findTransactionsByAccountRef(accountRef);\n  }\n  public Transaction getTransactionByRef(String transactionRef) {\n    return getTransferService().getTransactionByRef(transactionRef);\n  }\n  public Money getAccountBalance(String accountRef) {\n    validateAccountRefs(accountRef);\n    return getAccountService().getAccountBalance(accountRef);\n  }\n  public void printHistoryLog() {\n    System.out.println(toString());\n  }\n  private String formatAccounts() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"Ledger: \" + name + \"\\n\\n\");\n    sb.append(String\n        .format(\"%20s %20s %10s %15s %10s %10s\", \"Account\", \"|\", \"Amount\", \"|\", \"Currency\", \"|\"));\n    sb.append(String.format(\"%s\",\n        \"\\n------------------------------------------------------------------------------------------\"));\n    chartOfAccounts.get().forEach(account -> {\n      Money money = getAccountService().getAccountBalance(account.getAccountRef());\n      sb.append(\"\\n\" + String\n          .format(\"%20s %20s %10.2f %15s %10s %10s\", account.getAccountRef(), \"|\",\n              money.getAmount(), \"|\",\n              money.getCurrency(), \"|\"));\n    });\n    return sb.toString();\n  }\n  private String formatTransactionLog() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(String\n        .format(\"%20s %20s %15s %10s %10s %10s %10s\", \"Account\", \"|\", \"Transaction\", \"|\", \"Type\",\n            \"|\", \"Date\"));\n    sb.append(String.format(\"%s\",\n        \"\\n-------------------------------------------------------------------------------------------------------------------------\"));\n    chartOfAccounts.get().forEach(account -> {\n      List<Transaction> transactions = getTransferService()\n          .findTransactionsByAccountRef(account.getAccountRef());\n      if (!transactions.isEmpty()) {\n        transactions.forEach(transaction -> sb.append(\"\\n\" + String\n            .format(\"%20s %20s %10s %15s %10s %10s %10s %1s\", account.getAccountRef(), \"|\",\n                transaction.getTransactionRef(), \"|\", transaction.getTransactionType(), \"|\",\n                transaction.getTransactionDate(), \"|\")));\n      } else {\n        sb.append(\"\\n\" + String\n            .format(\"%20s %20s %10s %15s %10s %10s %10s %1s\", account.getAccountRef(), \"|\",\n                \"N/A\", \"|\", \"N/A\", \"|\",\n                \"N/A\", \"|\"));\n      }\n    });\n    chartOfAccounts.get().forEach(account -> {\n      List<Transaction> transactions = getTransferService()\n          .findTransactionsByAccountRef(account.getAccountRef());\n      if (!transactions.isEmpty()) {\n        sb.append(\n            \"\\n\\n\" + String.format(\"%20s %20s %15s %4s %10s %10s %15s %5s\", \"Account\", \"|\",\n                \"Transaction Leg Ref\", \"|\", \"Amount\", \"|\", \"Currency\", \"|\"));\n        sb.append(String.format(\"%s\",\n            \"\\n-------------------------------------------------------------------------------------------------------------------------\"));\n        transactions.forEach(transaction ->\n            transaction.getLegs().forEach(leg -> sb.append(\"\\n\" + String\n                .format(\"%20s %20s %10s %10s %10s %10s %10s %10s\", account.getAccountRef(), \"|\",\n                    leg.getAccountRef(), \"|\", leg.getAmount().getAmount(), \"|\",\n                    leg.getAmount().getCurrency(), \"|\"))));\n      }\n    });\n    return sb.toString();\n  }\n  @Override\n  public String toString() {\n    return formatAccounts() + \"\\n\\n\" + formatTransactionLog() + \"\\n\\n\";\n  }\n  public static class LedgerBuilder {\n    private String name = \"General Ledger\";\n    private ChartOfAccounts chartOfAccounts;\n    private ConnectionOptions options = ConnectionOptions.EMBEDDED_H2_CONNECTION;\n    public LedgerBuilder(ChartOfAccounts chartOfAccounts) {\n      this.chartOfAccounts = chartOfAccounts;\n    }\n    public LedgerBuilder name(String name) {\n      this.name = name;\n      return this;\n    }\n    public LedgerBuilder options(ConnectionOptions options) {\n      this.options = options;\n      return this;\n    }\n    public Ledger build() {\n      return new Ledger(this);\n    }\n  }\n"]], "pred": {"ppl": 1.8696295022964478, "ppl_lower": 2.1432793140411377, "ppl/lowercase_ppl": -1.21829625677778, "ppl/zlib": 0.000488859596970724, "Min_5.0% Prob": 5.792530064489327, "Min_10.0% Prob": 4.293829162915547, "Min_20.0% Prob": 2.8191343405667473, "Min_30.0% Prob": 2.0259923279480216, "Min_40.0% Prob": 1.5480228702202985, "Min_50.0% Prob": 1.2481128601667175, "Min_60.0% Prob": 1.0429455858760104}}
{"hexsha": "9d1095695216a557f92d497f712fcd2f87af14d0", "ext": "java", "lang": "Java", "content": "class TextUtils {\n\t/**\n\t * Combines an array of string with the separator\n\t * @param a array of Strings to combine\n\t * @param sep separator to place in between each String\n\t * @return combined string\n\t */\n\tpublic static String join(String[] a, String sep) {\n\t\tStringBuilder s = new StringBuilder();\n\t\tfor (String str : a) {\n\t\t\ts.append(str + sep);\n\t\t}\n\t\treturn s.substring(0, s.length() - sep.length());\n\t}\n}", "item_id": 2, "repo": "Nithanaroy/minibase", "file": "src/optimizer/Scheduler.java", "last_update_at": "2022-02-10T01:35:01+00:00", "question_id": "9d1095695216a557f92d497f712fcd2f87af14d0_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class TextUtils {\n\t/**\n\t * Combines an array of string with the separator\n\t * @param a array of Strings to combine\n\t * @param sep separator to place in between each String\n\t * @return combined string\n\t */\n\tpublic static String join(String[] a, String sep) {\n\t\tStringBuilder s = new StringBuilder();\n\t\tfor (String str : a) {\n\t\t\ts.append(str + sep);\n\t\t}\n\t\treturn s.substring(0, s.length() - sep.length());\n\t}\n"]], "pred": {"ppl": 2.2165262699127197, "ppl_lower": 2.572134017944336, "ppl/lowercase_ppl": -1.1869417983984036, "ppl/zlib": 0.003316421779634618, "Min_5.0% Prob": 6.29761536916097, "Min_10.0% Prob": 4.574941818530743, "Min_20.0% Prob": 3.2600204807061415, "Min_30.0% Prob": 2.530487907238496, "Min_40.0% Prob": 1.9658318588939996, "Min_50.0% Prob": 1.5891021468891546, "Min_60.0% Prob": 1.3322326423457036}}
{"hexsha": "17aab48110d4c8199b5eccf69aa83aeaad5dada4", "ext": "java", "lang": "Java", "content": "public class YAxisBuilder {\n    private Boolean show;\n    private Boolean showAlways;\n    private String seriesName;\n    private Boolean opposite;\n    private Boolean logarithmic;\n    private Double tickAmount;\n    private Boolean forceNiceScale;\n    private Object min;\n    private Object max;\n    private Boolean floating;\n    private Double decimalsInFloat;\n    private Labels labels;\n    private AxisBorder axisBorder;\n    private AxisTicks axisTicks;\n    private Title title;\n    private Crosshairs crosshairs;\n    private com.github.appreciated.apexcharts.config.Tooltip tooltip;\n\n    private YAxisBuilder() {\n    }\n\n    public static YAxisBuilder get() {\n        return new YAxisBuilder();\n    }\n\n    public YAxisBuilder withShow(Boolean show) {\n        this.show = show;\n        return this;\n    }\n\n    public YAxisBuilder withShowAlways(Boolean showAlways) {\n        this.showAlways = showAlways;\n        return this;\n    }\n\n    public YAxisBuilder withSeriesName(String seriesName) {\n        this.seriesName = seriesName;\n        return this;\n    }\n\n    public YAxisBuilder withOpposite(Boolean opposite) {\n        this.opposite = opposite;\n        return this;\n    }\n\n    public YAxisBuilder withLogarithmic(Boolean logarithmic) {\n        this.logarithmic = logarithmic;\n        return this;\n    }\n\n    public YAxisBuilder withTickAmount(Double tickAmount) {\n        this.tickAmount = tickAmount;\n        return this;\n    }\n\n    public YAxisBuilder withForceNiceScale(Boolean forceNiceScale) {\n        this.forceNiceScale = forceNiceScale;\n        return this;\n    }\n\n    public YAxisBuilder withMin(Double min) {\n        this.min = min;\n        return this;\n    }\n\n    public YAxisBuilder withMax(Double max) {\n        this.max = max;\n        return this;\n    }\n\n    public YAxisBuilder withMin(Object min) {\n        this.min = min;\n        return this;\n    }\n\n    public YAxisBuilder withMax(Object max) {\n        this.max = max;\n        return this;\n    }\n\n    public YAxisBuilder withMin(LocalDate min) {\n        ZoneId zoneId = ZoneId.systemDefault();\n        this.min = min.atStartOfDay(zoneId).toInstant().toEpochMilli();\n        return this;\n    }\n\n    public YAxisBuilder withMax(LocalDate max) {\n        ZoneId zoneId = ZoneId.systemDefault();\n        this.max = max.atStartOfDay(zoneId).toInstant().toEpochMilli();\n        return this;\n    }\n\n    public YAxisBuilder withFloating(Boolean floating) {\n        this.floating = floating;\n        return this;\n    }\n\n    public YAxisBuilder withDecimalsInFloat(Double decimalsInFloat) {\n        this.decimalsInFloat = decimalsInFloat;\n        return this;\n    }\n\n    public YAxisBuilder withLabels(Labels labels) {\n        this.labels = labels;\n        return this;\n    }\n\n    public YAxisBuilder withAxisBorder(AxisBorder axisBorder) {\n        this.axisBorder = axisBorder;\n        return this;\n    }\n\n    public YAxisBuilder withAxisTicks(AxisTicks axisTicks) {\n        this.axisTicks = axisTicks;\n        return this;\n    }\n\n    public YAxisBuilder withTitle(Title title) {\n        this.title = title;\n        return this;\n    }\n\n    public YAxisBuilder withCrosshairs(Crosshairs crosshairs) {\n        this.crosshairs = crosshairs;\n        return this;\n    }\n\n    public YAxisBuilder withTooltip(Tooltip tooltip) {\n        this.tooltip = tooltip;\n        return this;\n    }\n\n    public YAxis build() {\n        YAxis yAxis = new YAxis();\n        yAxis.setShow(show);\n        yAxis.setShowAlways(showAlways);\n        yAxis.setSeriesName(seriesName);\n        yAxis.setOpposite(opposite);\n        yAxis.setLogarithmic(logarithmic);\n        yAxis.setTickAmount(tickAmount);\n        yAxis.setForceNiceScale(forceNiceScale);\n        yAxis.setMin(min);\n        yAxis.setMax(max);\n        yAxis.setFloating(floating);\n        yAxis.setDecimalsInFloat(decimalsInFloat);\n        yAxis.setLabels(labels);\n        yAxis.setAxisBorder(axisBorder);\n        yAxis.setAxisTicks(axisTicks);\n        yAxis.setTitle(title);\n        yAxis.setCrosshairs(crosshairs);\n        yAxis.setTooltip(tooltip);\n        return yAxis;\n    }\n}", "item_id": 0, "repo": "yurili8/apexcharts-flow", "file": "src/main/java/com/github/appreciated/apexcharts/config/builder/YAxisBuilder.java", "last_update_at": "2022-03-20T11:26:04+00:00", "question_id": "17aab48110d4c8199b5eccf69aa83aeaad5dada4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class YAxisBuilder {\n    private Boolean show;\n    private Boolean showAlways;\n    private String seriesName;\n    private Boolean opposite;\n    private Boolean logarithmic;\n    private Double tickAmount;\n    private Boolean forceNiceScale;\n    private Object min;\n    private Object max;\n    private Boolean floating;\n    private Double decimalsInFloat;\n    private Labels labels;\n    private AxisBorder axisBorder;\n    private AxisTicks axisTicks;\n    private Title title;\n    private Crosshairs crosshairs;\n    private com.github.appreciated.apexcharts.config.Tooltip tooltip;\n    private YAxisBuilder() {\n    }\n    public static YAxisBuilder get() {\n        return new YAxisBuilder();\n    }\n    public YAxisBuilder withShow(Boolean show) {\n        this.show = show;\n        return this;\n    }\n    public YAxisBuilder withShowAlways(Boolean showAlways) {\n        this.showAlways = showAlways;\n        return this;\n    }\n    public YAxisBuilder withSeriesName(String seriesName) {\n        this.seriesName = seriesName;\n        return this;\n    }\n    public YAxisBuilder withOpposite(Boolean opposite) {\n        this.opposite = opposite;\n        return this;\n    }\n    public YAxisBuilder withLogarithmic(Boolean logarithmic) {\n        this.logarithmic = logarithmic;\n        return this;\n    }\n    public YAxisBuilder withTickAmount(Double tickAmount) {\n        this.tickAmount = tickAmount;\n        return this;\n    }\n    public YAxisBuilder withForceNiceScale(Boolean forceNiceScale) {\n        this.forceNiceScale = forceNiceScale;\n        return this;\n    }\n    public YAxisBuilder withMin(Double min) {\n        this.min = min;\n        return this;\n    }\n    public YAxisBuilder withMax(Double max) {\n        this.max = max;\n        return this;\n    }\n    public YAxisBuilder withMin(Object min) {\n        this.min = min;\n        return this;\n    }\n    public YAxisBuilder withMax(Object max) {\n        this.max = max;\n        return this;\n    }\n    public YAxisBuilder withMin(LocalDate min) {\n        ZoneId zoneId = ZoneId.systemDefault();\n        this.min = min.atStartOfDay(zoneId).toInstant().toEpochMilli();\n        return this;\n    }\n    public YAxisBuilder withMax(LocalDate max) {\n        ZoneId zoneId = ZoneId.systemDefault();\n        this.max = max.atStartOfDay(zoneId).toInstant().toEpochMilli();\n        return this;\n    }\n    public YAxisBuilder withFloating(Boolean floating) {\n        this.floating = floating;\n        return this;\n    }\n    public YAxisBuilder withDecimalsInFloat(Double decimalsInFloat) {\n        this.decimalsInFloat = decimalsInFloat;\n        return this;\n    }\n    public YAxisBuilder withLabels(Labels labels) {\n        this.labels = labels;\n        return this;\n    }\n    public YAxisBuilder withAxisBorder(AxisBorder axisBorder) {\n        this.axisBorder = axisBorder;\n        return this;\n    }\n    public YAxisBuilder withAxisTicks(AxisTicks axisTicks) {\n        this.axisTicks = axisTicks;\n        return this;\n    }\n    public YAxisBuilder withTitle(Title title) {\n        this.title = title;\n        return this;\n    }\n    public YAxisBuilder withCrosshairs(Crosshairs crosshairs) {\n        this.crosshairs = crosshairs;\n        return this;\n    }\n    public YAxisBuilder withTooltip(Tooltip tooltip) {\n        this.tooltip = tooltip;\n        return this;\n    }\n    public YAxis build() {\n        YAxis yAxis = new YAxis();\n        yAxis.setShow(show);\n        yAxis.setShowAlways(showAlways);\n        yAxis.setSeriesName(seriesName);\n        yAxis.setOpposite(opposite);\n        yAxis.setLogarithmic(logarithmic);\n        yAxis.setTickAmount(tickAmount);\n        yAxis.setForceNiceScale(forceNiceScale);\n        yAxis.setMin(min);\n        yAxis.setMax(max);\n        yAxis.setFloating(floating);\n        yAxis.setDecimalsInFloat(decimalsInFloat);\n        yAxis.setLabels(labels);\n        yAxis.setAxisBorder(axisBorder);\n        yAxis.setAxisTicks(axisTicks);\n        yAxis.setTitle(title);\n        yAxis.setCrosshairs(crosshairs);\n        yAxis.setTooltip(tooltip);\n        return yAxis;\n    }\n"]], "pred": {"ppl": 1.1960893869400024, "ppl_lower": 1.3160158395767212, "ppl/lowercase_ppl": -1.533636045295417, "ppl/zlib": 0.00022133175646455594, "Min_5.0% Prob": 3.3541282660820904, "Min_10.0% Prob": 1.777957486134826, "Min_20.0% Prob": 0.8961764549249874, "Min_30.0% Prob": 0.5982044558040798, "Min_40.0% Prob": 0.44776104865689625, "Min_50.0% Prob": 0.3584360334128991, "Min_60.0% Prob": 0.2988094719278737}}
{"hexsha": "7311e333513f8c6ace3fdd627d1fe78c7302ae3c", "ext": "java", "lang": "Java", "content": "@ApiModel(description = \"Set of fields along with symbol is mandatory to update the date.\")\n@JsonPropertyOrder({\n  InlineObject3.JSON_PROPERTY_DATA\n})\n@javax.annotation.Generated(value = \"org.openapitools.codegen.languages.JavaClientCodegen\")\npublic class InlineObject3 implements Serializable {\n  private static final long serialVersionUID = 1L;\n\n  public static final String JSON_PROPERTY_DATA = \"data\";\n  private java.util.List<Object> data = null;\n\n  public InlineObject3() { \n  }\n\n  public InlineObject3 data(java.util.List<Object> data) {\n    this.data = data;\n    return this;\n  }\n\n  public InlineObject3 addDataItem(Object dataItem) {\n    if (this.data == null) {\n      this.data = new java.util.ArrayList<>();\n    }\n    this.data.add(dataItem);\n    return this;\n  }\n\n   /**\n   * date has to be provide in case 3d OFDB with date and atleast one iterative field\n   * @return data\n  **/\n  @javax.annotation.Nullable\n  @ApiModelProperty(example = \"[{\\\"symbol\\\":\\\"FACTSET\\\",\\\"field1\\\":\\\"VALUE\\\"}]\", value = \"date has to be provide in case 3d OFDB with date and atleast one iterative field\")\n  @JsonProperty(JSON_PROPERTY_DATA)\n  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n\n  public java.util.List<Object> getData() {\n    return data;\n  }\n\n\n  @JsonProperty(JSON_PROPERTY_DATA)\n  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n  public void setData(java.util.List<Object> data) {\n    this.data = data;\n  }\n\n\n  /**\n   * Return true if this inline_object_3 object is equal to o.\n   */\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    InlineObject3 inlineObject3 = (InlineObject3) o;\n    return Objects.equals(this.data, inlineObject3.data);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(data);\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class InlineObject3 {\\n\");\n    sb.append(\"    data: \").append(toIndentedString(data)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n\n}", "item_id": 0, "repo": "factset/enterprise-sdk", "file": "code/java/OFDB/v1/src/main/java/com/factset/sdk/OFDB/models/InlineObject3.java", "last_update_at": "2022-03-30T08:04:57+00:00", "question_id": "7311e333513f8c6ace3fdd627d1fe78c7302ae3c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ApiModel(description = \"Set of fields along with symbol is mandatory to update the date.\")\n@JsonPropertyOrder({\n  InlineObject3.JSON_PROPERTY_DATA\n})\n@javax.annotation.Generated(value = \"org.openapitools.codegen.languages.JavaClientCodegen\")\npublic class InlineObject3 implements Serializable {\n  private static final long serialVersionUID = 1L;\n  public static final String JSON_PROPERTY_DATA = \"data\";\n  private java.util.List<Object> data = null;\n  public InlineObject3() { \n  }\n  public InlineObject3 data(java.util.List<Object> data) {\n    this.data = data;\n    return this;\n  }\n  public InlineObject3 addDataItem(Object dataItem) {\n    if (this.data == null) {\n      this.data = new java.util.ArrayList<>();\n    }\n    this.data.add(dataItem);\n    return this;\n  }\n   /**\n   * date has to be provide in case 3d OFDB with date and atleast one iterative field\n   * @return data\n  **/\n  @javax.annotation.Nullable\n  @ApiModelProperty(example = \"[{\\\"symbol\\\":\\\"FACTSET\\\",\\\"field1\\\":\\\"VALUE\\\"}]\", value = \"date has to be provide in case 3d OFDB with date and atleast one iterative field\")\n  @JsonProperty(JSON_PROPERTY_DATA)\n  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n  public java.util.List<Object> getData() {\n    return data;\n  }\n  @JsonProperty(JSON_PROPERTY_DATA)\n  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n  public void setData(java.util.List<Object> data) {\n    this.data = data;\n  }\n  /**\n   * Return true if this inline_object_3 object is equal to o.\n   */\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    InlineObject3 inlineObject3 = (InlineObject3) o;\n    return Objects.equals(this.data, inlineObject3.data);\n  }\n  @Override\n  public int hashCode() {\n    return Objects.hash(data);\n  }\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class InlineObject3 {\\n\");\n    sb.append(\"    data: \").append(toIndentedString(data)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n"]], "pred": {"ppl": 1.6337577104568481, "ppl_lower": 2.226290464401245, "ppl/lowercase_ppl": -1.6304031953895841, "ppl/zlib": 0.0005324107434154817, "Min_5.0% Prob": 6.875619147953234, "Min_10.0% Prob": 4.6390547133111335, "Min_20.0% Prob": 2.4493580934982147, "Min_30.0% Prob": 1.6408270838879178, "Min_40.0% Prob": 1.2285650072885947, "Min_50.0% Prob": 0.9817066312441722, "Min_60.0% Prob": 0.8191760811734736}}
{"hexsha": "71d9f830499cea150fad9ac7fee313a95fbc5d27", "ext": "java", "lang": "Java", "content": "@Command(name = \"uploadTelemetry\", description = \"Upload Telemetry from an air-gapped deployment.\")\npublic class UploadTelemetry implements Runnable {\n\n  @Option(\n      name = {\"-f\", \"--file\"},\n      description = \"Path to stats.json to be uploaded.\",\n      required = true\n  )\n  public String filePath;\n\n  @Override\n  public void run() {\n    File file = new File(filePath);\n\n    System.out.println(String.format(\"Uploading telemetry from %s\", file.getAbsolutePath()));\n    if (!file.exists() || !file.isFile()) {\n      throw new RuntimeException(String.format(\"ERROR: file %s must be a valid stats.json\", file.getAbsolutePath()));\n    }\n\n    ObjectGraph dagger = ObjectGraph.create(RuntimeModule.class);\n    DCStatsCollectorTask statsTask = new DCStatsCollectorTask(\n        dagger.get(BuildInfo.class),\n        dagger.get(RuntimeInfo.class),\n        dagger.get(Configuration.class),\n        null,\n        null,\n        null\n    );\n\n    try {\n      statsTask.reportStats(FileUtils.readFileToString(file, StandardCharsets.UTF_8));\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n  }\n}", "item_id": 0, "repo": "designmind/datacollector", "file": "container/src/main/java/com/streamsets/datacollector/usagestats/cli/UploadTelemetry.java", "last_update_at": "2022-01-18T11:46:01+00:00", "question_id": "71d9f830499cea150fad9ac7fee313a95fbc5d27_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Command(name = \"uploadTelemetry\", description = \"Upload Telemetry from an air-gapped deployment.\")\npublic class UploadTelemetry implements Runnable {\n  @Option(\n      name = {\"-f\", \"--file\"},\n      description = \"Path to stats.json to be uploaded.\",\n      required = true\n  )\n  public String filePath;\n  @Override\n  public void run() {\n    File file = new File(filePath);\n    System.out.println(String.format(\"Uploading telemetry from %s\", file.getAbsolutePath()));\n    if (!file.exists() || !file.isFile()) {\n      throw new RuntimeException(String.format(\"ERROR: file %s must be a valid stats.json\", file.getAbsolutePath()));\n    }\n    ObjectGraph dagger = ObjectGraph.create(RuntimeModule.class);\n    DCStatsCollectorTask statsTask = new DCStatsCollectorTask(\n        dagger.get(BuildInfo.class),\n        dagger.get(RuntimeInfo.class),\n        dagger.get(Configuration.class),\n        null,\n        null,\n        null\n    );\n    try {\n      statsTask.reportStats(FileUtils.readFileToString(file, StandardCharsets.UTF_8));\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n"]], "pred": {"ppl": 2.4786736965179443, "ppl_lower": 3.2066447734832764, "ppl/lowercase_ppl": -1.2836783425536724, "ppl/zlib": 0.0017257102991051795, "Min_5.0% Prob": 7.881461322307587, "Min_10.0% Prob": 5.909180887043476, "Min_20.0% Prob": 3.9186156327907855, "Min_30.0% Prob": 2.8729673256071244, "Min_40.0% Prob": 2.2320612206031347, "Min_50.0% Prob": 1.806705004217603, "Min_60.0% Prob": 1.5170474629041415}}
{"hexsha": "b0f0dcb234f6fe524140afbf4a0dddc50e1ccaba", "ext": "java", "lang": "Java", "content": "public class ValidityDialogDefaultValue {\n\n\t@Rule\n\tpublic Logger log = Logger.getLogger(this);\n\t\n\t@Before\n\tpublic void setUp() throws Exception {\n\t\tapp.start(true);\n\t\tAppTool.newSpreadsheet();\n\t\tapp.dispatch(\".uno:Validation\");\n\t}\n\n\t@After\n\tpublic void tearDown() throws Exception {\n\t\tapp.stop();\n\t}\n\n\t/**\n\t * test Data -> Validity - UI(Criteria: Cell range).\n\t */\n\t@Test\n\tpublic void testValidityUICellRange() {\n\n\t\tscValidityCriteriaTabpage.select();\n\t\tscValidityCriteriaAllowList.select(5); \n\n\t\tassertEquals(\"Wrong default value of AllowBlankCells in Validity\",true, scValidityAllowBlankCells.isChecked());\n\t\tassertEquals(\"Wrong default value of ShowSelectionList in Validity\",true, scValidityShowSelectionList.isChecked());\n\t\tassertEquals(\"Wrong default value of Sort Entries Ascending in Validity\",false, scValiditySortEntriesAscending.isChecked());\n\t\tassertEquals(\"Wrong default value of AllowBlankCells in Validity\",true, scValidityAllowBlankCells.isEnabled());\n\t\tassertEquals(\"Wrong default value of Sort Entries Ascending in Validity\",true, scValiditySortEntriesAscending.isEnabled());\n\t\tassertEquals(\"Wrong default value of SourcePicker in Validity\",true, scValiditySourcePicker.isEnabled());\n\t}\n\n\t/**\n\t * test Data -> Validity - UI(Error Alert: Default status)\n\t */\n\t@Test\n\tpublic void testValidityUIErrorAlert() {\n\n\t\tscValidityErrorAlertTabPage.select();\n\t\tassertEquals(\"Error Alert Action list is disable\",true, scValidityErrorAlertActionList.isEnabled());\n\t\t// assertEquals(\"Stop\",SC_ValidityErrorAlertActionList.getSelText()); \n\t\t// Do not test this. Do it in GVT.\n\t\tassertEquals(\"Error Message Title is disable\",true, scValidityErrorMessageTitle.isEnabled());\n\t\tassertEquals(\"Have default error message title\",\"\", scValidityErrorMessageTitle.getText());\n\t\tassertEquals(\"Error message is disable\",true, scValidityErrorMessage.isEnabled());\n\t\tassertEquals(\"Have default error message\",\"\", scValidityErrorMessage.getText());\n\t\tscValidityErrorAlertActionList.select(3); // \"Macro\"\n\t\tassertEquals(\"error browse button is disable\",true, scValidityErrorBrowseButton.isEnabled());\n\t}\n\n}", "item_id": 0, "repo": "Grosskopf/openoffice", "file": "test/testgui/source/fvt/gui/sc/validity/ValidityDialogDefaultValue.java", "last_update_at": "2022-03-30T01:06:03+00:00", "question_id": "b0f0dcb234f6fe524140afbf4a0dddc50e1ccaba_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ValidityDialogDefaultValue {\n\t@Rule\n\tpublic Logger log = Logger.getLogger(this);\n\t\n\t@Before\n\tpublic void setUp() throws Exception {\n\t\tapp.start(true);\n\t\tAppTool.newSpreadsheet();\n\t\tapp.dispatch(\".uno:Validation\");\n\t}\n\t@After\n\tpublic void tearDown() throws Exception {\n\t\tapp.stop();\n\t}\n\t/**\n\t * test Data -> Validity - UI(Criteria: Cell range).\n\t */\n\t@Test\n\tpublic void testValidityUICellRange() {\n\t\tscValidityCriteriaTabpage.select();\n\t\tscValidityCriteriaAllowList.select(5); \n\t\tassertEquals(\"Wrong default value of AllowBlankCells in Validity\",true, scValidityAllowBlankCells.isChecked());\n\t\tassertEquals(\"Wrong default value of ShowSelectionList in Validity\",true, scValidityShowSelectionList.isChecked());\n\t\tassertEquals(\"Wrong default value of Sort Entries Ascending in Validity\",false, scValiditySortEntriesAscending.isChecked());\n\t\tassertEquals(\"Wrong default value of AllowBlankCells in Validity\",true, scValidityAllowBlankCells.isEnabled());\n\t\tassertEquals(\"Wrong default value of Sort Entries Ascending in Validity\",true, scValiditySortEntriesAscending.isEnabled());\n\t\tassertEquals(\"Wrong default value of SourcePicker in Validity\",true, scValiditySourcePicker.isEnabled());\n\t}\n\t/**\n\t * test Data -> Validity - UI(Error Alert: Default status)\n\t */\n\t@Test\n\tpublic void testValidityUIErrorAlert() {\n\t\tscValidityErrorAlertTabPage.select();\n\t\tassertEquals(\"Error Alert Action list is disable\",true, scValidityErrorAlertActionList.isEnabled());\n\t\t// assertEquals(\"Stop\",SC_ValidityErrorAlertActionList.getSelText()); \n\t\t// Do not test this. Do it in GVT.\n\t\tassertEquals(\"Error Message Title is disable\",true, scValidityErrorMessageTitle.isEnabled());\n\t\tassertEquals(\"Have default error message title\",\"\", scValidityErrorMessageTitle.getText());\n\t\tassertEquals(\"Error message is disable\",true, scValidityErrorMessage.isEnabled());\n\t\tassertEquals(\"Have default error message\",\"\", scValidityErrorMessage.getText());\n\t\tscValidityErrorAlertActionList.select(3); // \"Macro\"\n\t\tassertEquals(\"error browse button is disable\",true, scValidityErrorBrowseButton.isEnabled());\n\t}\n"]], "pred": {"ppl": 2.9191734790802, "ppl_lower": 3.0283362865448, "ppl/lowercase_ppl": -1.0342694384507516, "ppl/zlib": 0.0016897484559984406, "Min_5.0% Prob": 8.403762909673876, "Min_10.0% Prob": 6.8225498880658835, "Min_20.0% Prob": 4.731208011271462, "Min_30.0% Prob": 3.429863798397559, "Min_40.0% Prob": 2.641297522754896, "Min_50.0% Prob": 2.132898551142878, "Min_60.0% Prob": 1.783822374176924}}
{"hexsha": "2a158f42b049471ac1076dc9686672c883c98458", "ext": "java", "lang": "Java", "content": "public abstract class AbstractWorkflowAction<E extends BullhornEntity, T extends Traverser> implements WorkflowAction<E, T> {\n\n    private final Logger log = Logger.getLogger(getClass());\n\n    private final Map<? extends BullhornRelatedEntity, Set<String>> relatedEntityFields;\n\n    private EmailTemplateService emailTemplateService;\n    private ApplicationSettings appSettings;\n    private MessageSource messageSource;\n    private Emailer emailer;\n\n    public AbstractWorkflowAction(Map<? extends BullhornRelatedEntity, Set<String>> relatedEntityFields) {\n        this.relatedEntityFields = relatedEntityFields;\n    }\n\n    protected Map<StandardRelatedEntity, Set<String>> getStandardEntityFields() {\n        return Maps.newLinkedHashMap();\n    }\n\n    protected String getMessageUsingKey(String key) throws NoSuchMessageException {\n        return getMessageUsingKey(key, new Object[] {});\n    }\n\n    protected String getMessageUsingKey(String key, Object[] args) throws NoSuchMessageException {\n        return getMessageSource().getMessage(key, args, Locale.US);\n    }\n\n    protected MessageSource getMessageSource() {\n        if(this.messageSource == null) {\n            this.messageSource = AppContext.getApplicationContext().getBean(\"messageSource\", MessageSource.class);\n        }\n\n        return messageSource;\n    }\n\n    protected EmailTemplateService getEmailTemplateService() {\n        if(this.emailTemplateService == null) {\n            this.emailTemplateService = AppContext.getApplicationContext().getBean(EmailTemplateService.class);\n        }\n\n        return this.emailTemplateService;\n    }\n\n    protected ApplicationSettings getAppSettings() {\n        if(this.appSettings == null) {\n            this.appSettings = AppContext.getApplicationContext().getBean(ApplicationSettings.class);\n        }\n\n        return this.appSettings;\n    }\n\n    protected Emailer getEmailer() {\n        if(this.emailer == null) {\n            this.emailer = AppContext.getApplicationContext().getBean(Emailer.class);\n        }\n\n        return emailer;\n    }\n\n    @Override\n    public Map<? extends BullhornRelatedEntity, Set<String>> getRelatedEntityFields() {\n        Map<BullhornRelatedEntity, Set<String>> allFields = Maps.newLinkedHashMap();\n\n        allFields.putAll(getStandardEntityFields());\n        allFields.putAll(this.relatedEntityFields);\n\n        return allFields;\n    }\n\n    protected Logger getLog() {\n        return log;\n    }\n\n}", "item_id": 0, "repo": "mkesmetzis/starter-kit-spring-maven", "file": "src/main/java/com/client/core/base/workflow/node/AbstractWorkflowAction.java", "last_update_at": "2022-02-14T02:19:56+00:00", "question_id": "2a158f42b049471ac1076dc9686672c883c98458_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class AbstractWorkflowAction<E extends BullhornEntity, T extends Traverser> implements WorkflowAction<E, T> {\n    private final Logger log = Logger.getLogger(getClass());\n    private final Map<? extends BullhornRelatedEntity, Set<String>> relatedEntityFields;\n    private EmailTemplateService emailTemplateService;\n    private ApplicationSettings appSettings;\n    private MessageSource messageSource;\n    private Emailer emailer;\n    public AbstractWorkflowAction(Map<? extends BullhornRelatedEntity, Set<String>> relatedEntityFields) {\n        this.relatedEntityFields = relatedEntityFields;\n    }\n    protected Map<StandardRelatedEntity, Set<String>> getStandardEntityFields() {\n        return Maps.newLinkedHashMap();\n    }\n    protected String getMessageUsingKey(String key) throws NoSuchMessageException {\n        return getMessageUsingKey(key, new Object[] {});\n    }\n    protected String getMessageUsingKey(String key, Object[] args) throws NoSuchMessageException {\n        return getMessageSource().getMessage(key, args, Locale.US);\n    }\n    protected MessageSource getMessageSource() {\n        if(this.messageSource == null) {\n            this.messageSource = AppContext.getApplicationContext().getBean(\"messageSource\", MessageSource.class);\n        }\n        return messageSource;\n    }\n    protected EmailTemplateService getEmailTemplateService() {\n        if(this.emailTemplateService == null) {\n            this.emailTemplateService = AppContext.getApplicationContext().getBean(EmailTemplateService.class);\n        }\n        return this.emailTemplateService;\n    }\n    protected ApplicationSettings getAppSettings() {\n        if(this.appSettings == null) {\n            this.appSettings = AppContext.getApplicationContext().getBean(ApplicationSettings.class);\n        }\n        return this.appSettings;\n    }\n    protected Emailer getEmailer() {\n        if(this.emailer == null) {\n            this.emailer = AppContext.getApplicationContext().getBean(Emailer.class);\n        }\n        return emailer;\n    }\n    @Override\n    public Map<? extends BullhornRelatedEntity, Set<String>> getRelatedEntityFields() {\n        Map<BullhornRelatedEntity, Set<String>> allFields = Maps.newLinkedHashMap();\n        allFields.putAll(getStandardEntityFields());\n        allFields.putAll(this.relatedEntityFields);\n        return allFields;\n    }\n    protected Logger getLog() {\n        return log;\n    }\n"]], "pred": {"ppl": 1.6465418338775635, "ppl_lower": 1.8885505199432373, "ppl/lowercase_ppl": -1.2749922707033656, "ppl/zlib": 0.0007940720227260345, "Min_5.0% Prob": 5.6859969139099125, "Min_10.0% Prob": 3.9878633530413516, "Min_20.0% Prob": 2.404676262198425, "Min_30.0% Prob": 1.6498498950858373, "Min_40.0% Prob": 1.2440326347012027, "Min_50.0% Prob": 0.996309130535458, "Min_60.0% Prob": 0.8325898311182706}}
{"hexsha": "01e167677eb8cc00d3380457990ffa9f367952f0", "ext": "java", "lang": "Java", "content": "class AnnotatedMixinElementHandlerInjector extends AnnotatedMixinElementHandler {\n  static class AnnotatedElementInjector extends AnnotatedMixinElementHandler.AnnotatedElement<ExecutableElement> {\n    private final InjectorRemap state;\n    \n    public AnnotatedElementInjector(ExecutableElement element, AnnotationHandle annotation, InjectorRemap shouldRemap) {\n      super(element, annotation);\n      this.state = shouldRemap;\n    }\n    \n    public boolean shouldRemap() {\n      return this.state.shouldRemap();\n    }\n    \n    public boolean hasCoerceArgument() {\n      if (!this.annotation.toString().equals(\"@Inject\"))\n        return false; \n      Iterator<? extends VariableElement> iterator = this.element.getParameters().iterator();\n      if (iterator.hasNext()) {\n        VariableElement param = iterator.next();\n        return AnnotationHandle.of(param, Coerce.class).exists();\n      } \n      return false;\n    }\n    \n    public void addMessage(Diagnostic.Kind kind, CharSequence msg, Element element, AnnotationHandle annotation) {\n      this.state.addMessage(kind, msg, element, annotation);\n    }\n    \n    public String toString() {\n      return getAnnotation().toString();\n    }\n  }\n  \n  static class AnnotatedElementInjectionPoint extends AnnotatedMixinElementHandler.AnnotatedElement<ExecutableElement> {\n    private final AnnotationHandle at;\n    \n    private Map<String, String> args;\n    \n    private final InjectorRemap state;\n    \n    public AnnotatedElementInjectionPoint(ExecutableElement element, AnnotationHandle inject, AnnotationHandle at, InjectorRemap state) {\n      super(element, inject);\n      this.at = at;\n      this.state = state;\n    }\n    \n    public boolean shouldRemap() {\n      return this.at.getBoolean(\"remap\", this.state.shouldRemap());\n    }\n    \n    public AnnotationHandle getAt() {\n      return this.at;\n    }\n    \n    public String getAtArg(String key) {\n      if (this.args == null) {\n        this.args = new HashMap<String, String>();\n        for (String arg : this.at.getList(\"args\")) {\n          if (arg == null)\n            continue; \n          int eqPos = arg.indexOf('=');\n          if (eqPos > -1) {\n            this.args.put(arg.substring(0, eqPos), arg.substring(eqPos + 1));\n            continue;\n          } \n          this.args.put(arg, \"\");\n        } \n      } \n      return this.args.get(key);\n    }\n    \n    public void notifyRemapped() {\n      this.state.notifyRemapped();\n    }\n  }\n  \n  AnnotatedMixinElementHandlerInjector(IMixinAnnotationProcessor ap, AnnotatedMixin mixin) {\n    super(ap, mixin);\n  }\n  \n  public void registerInjector(AnnotatedElementInjector elem) {\n    if (this.mixin.isInterface())\n      this.ap.printMessage(Diagnostic.Kind.ERROR, \"Injector in interface is unsupported\", elem.getElement()); \n    for (String reference : elem.getAnnotation().getList(\"method\")) {\n      MemberInfo targetMember = MemberInfo.parse(reference);\n      if (targetMember.name == null)\n        continue; \n      try {\n        targetMember.validate();\n      } catch (InvalidMemberDescriptorException ex) {\n        elem.printMessage((Messager)this.ap, Diagnostic.Kind.ERROR, ex.getMessage());\n      } \n      if (targetMember.desc != null)\n        validateReferencedTarget(elem.getElement(), elem.getAnnotation(), targetMember, elem.toString()); \n      if (!elem.shouldRemap())\n        continue; \n      for (TypeHandle target : this.mixin.getTargets()) {\n        if (!registerInjector(elem, reference, targetMember, target))\n          break; \n      } \n    } \n  }\n  \n  private boolean registerInjector(AnnotatedElementInjector elem, String reference, MemberInfo targetMember, TypeHandle target) {\n    String desc = target.findDescriptor(targetMember);\n    if (desc == null) {\n      Diagnostic.Kind error = this.mixin.isMultiTarget() ? Diagnostic.Kind.ERROR : Diagnostic.Kind.WARNING;\n      if (target.isSimulated()) {\n        elem.printMessage((Messager)this.ap, Diagnostic.Kind.NOTE, elem + \" target '\" + reference + \"' in @Pseudo mixin will not be obfuscated\");\n      } else if (target.isImaginary()) {\n        elem.printMessage((Messager)this.ap, error, elem + \" target requires method signature because enclosing type information for \" + target + \" is unavailable\");\n      } else if (!targetMember.isInitialiser()) {\n        elem.printMessage((Messager)this.ap, error, \"Unable to determine signature for \" + elem + \" target method\");\n      } \n      return true;\n    } \n    String targetName = elem + \" target \" + targetMember.name;\n    MappingMethod targetMethod = target.getMappingMethod(targetMember.name, desc);\n    ObfuscationData<MappingMethod> obfData = this.obf.getDataProvider().getObfMethod(targetMethod);\n    if (obfData.isEmpty())\n      if (target.isSimulated()) {\n        obfData = this.obf.getDataProvider().getRemappedMethod(targetMethod);\n      } else {\n        if (targetMember.isClassInitialiser())\n          return true; \n        Diagnostic.Kind error = targetMember.isConstructor() ? Diagnostic.Kind.WARNING : Diagnostic.Kind.ERROR;\n        elem.addMessage(error, \"No obfuscation mapping for \" + targetName, elem.getElement(), elem.getAnnotation());\n        return false;\n      }  \n    IReferenceManager refMap = this.obf.getReferenceManager();\n    try {\n      if ((targetMember.owner == null && this.mixin.isMultiTarget()) || target.isSimulated())\n        obfData = AnnotatedMixinElementHandler.stripOwnerData(obfData); \n      refMap.addMethodMapping(this.classRef, reference, obfData);\n    } catch (ReferenceConflictException ex) {\n      String conflictType = this.mixin.isMultiTarget() ? \"Multi-target\" : \"Target\";\n      if (elem.hasCoerceArgument() && targetMember.owner == null && targetMember.desc == null) {\n        MemberInfo oldMember = MemberInfo.parse(ex.getOld());\n        MemberInfo newMember = MemberInfo.parse(ex.getNew());\n        if (oldMember.name.equals(newMember.name)) {\n          obfData = AnnotatedMixinElementHandler.stripDescriptors(obfData);\n          refMap.setAllowConflicts(true);\n          refMap.addMethodMapping(this.classRef, reference, obfData);\n          refMap.setAllowConflicts(false);\n          elem.printMessage((Messager)this.ap, Diagnostic.Kind.WARNING, \"Coerced \" + conflictType + \" reference has conflicting descriptors for \" + targetName + \": Storing bare references \" + obfData\n              .values() + \" in refMap\");\n          return true;\n        } \n      } \n      elem.printMessage((Messager)this.ap, Diagnostic.Kind.ERROR, conflictType + \" reference conflict for \" + targetName + \": \" + reference + \" -> \" + ex\n          .getNew() + \" previously defined as \" + ex.getOld());\n    } \n    return true;\n  }\n  \n  public void registerInjectionPoint(AnnotatedElementInjectionPoint elem, String format) {\n    if (this.mixin.isInterface())\n      this.ap.printMessage(Diagnostic.Kind.ERROR, \"Injector in interface is unsupported\", elem.getElement()); \n    if (!elem.shouldRemap())\n      return; \n    String type = InjectionPointData.parseType((String)elem.getAt().getValue(\"value\"));\n    String target = (String)elem.getAt().getValue(\"target\");\n    if (\"NEW\".equals(type)) {\n      remapNewTarget(String.format(format, new Object[] { type + \".<target>\" }), target, elem);\n      remapNewTarget(String.format(format, new Object[] { type + \".args[class]\" }), elem.getAtArg(\"class\"), elem);\n    } else {\n      remapReference(String.format(format, new Object[] { type + \".<target>\" }), target, elem);\n    } \n  }\n  \n  protected final void remapNewTarget(String subject, String reference, AnnotatedElementInjectionPoint elem) {\n    if (reference == null)\n      return; \n    MemberInfo member = MemberInfo.parse(reference);\n    String target = member.toCtorType();\n    if (target != null) {\n      String desc = member.toCtorDesc();\n      MappingMethod m = new MappingMethod(target, \".\", (desc != null) ? desc : \"()V\");\n      ObfuscationData<MappingMethod> remapped = this.obf.getDataProvider().getRemappedMethod(m);\n      if (remapped.isEmpty()) {\n        this.ap.printMessage(Diagnostic.Kind.WARNING, \"Cannot find class mapping for \" + subject + \" '\" + target + \"'\", elem.getElement(), elem\n            .getAnnotation().asMirror());\n        return;\n      } \n      ObfuscationData<String> mappings = new ObfuscationData<String>();\n      for (ObfuscationType type : remapped) {\n        MappingMethod mapping = remapped.get(type);\n        if (desc == null) {\n          mappings.put(type, mapping.getOwner());\n          continue;\n        } \n        mappings.put(type, mapping.getDesc().replace(\")V\", \")L\" + mapping.getOwner() + \";\"));\n      } \n      this.obf.getReferenceManager().addClassMapping(this.classRef, reference, mappings);\n    } \n    elem.notifyRemapped();\n  }\n  \n  protected final void remapReference(String subject, String reference, AnnotatedElementInjectionPoint elem) {\n    if (reference == null)\n      return; \n    AnnotationMirror errorsOn = ((this.ap.getCompilerEnvironment() == IMixinAnnotationProcessor.CompilerEnvironment.JDT) ? elem.getAt() : elem.getAnnotation()).asMirror();\n    MemberInfo targetMember = MemberInfo.parse(reference);\n    if (!targetMember.isFullyQualified()) {\n      String missing = (targetMember.owner == null) ? ((targetMember.desc == null) ? \"owner and signature\" : \"owner\") : \"signature\";\n      this.ap.printMessage(Diagnostic.Kind.ERROR, subject + \" is not fully qualified, missing \" + missing, elem.getElement(), errorsOn);\n      return;\n    } \n    try {\n      targetMember.validate();\n    } catch (InvalidMemberDescriptorException ex) {\n      this.ap.printMessage(Diagnostic.Kind.ERROR, ex.getMessage(), elem.getElement(), errorsOn);\n    } \n    try {\n      if (targetMember.isField()) {\n        ObfuscationData<MappingField> obfFieldData = this.obf.getDataProvider().getObfFieldRecursive(targetMember);\n        if (obfFieldData.isEmpty()) {\n          this.ap.printMessage(Diagnostic.Kind.WARNING, \"Cannot find field mapping for \" + subject + \" '\" + reference + \"'\", elem.getElement(), errorsOn);\n          return;\n        } \n        this.obf.getReferenceManager().addFieldMapping(this.classRef, reference, targetMember, obfFieldData);\n      } else {\n        ObfuscationData<MappingMethod> obfMethodData = this.obf.getDataProvider().getObfMethodRecursive(targetMember);\n        if (obfMethodData.isEmpty() && (\n          targetMember.owner == null || !targetMember.owner.startsWith(\"java/lang/\"))) {\n          this.ap.printMessage(Diagnostic.Kind.WARNING, \"Cannot find method mapping for \" + subject + \" '\" + reference + \"'\", elem.getElement(), errorsOn);\n          return;\n        } \n        this.obf.getReferenceManager().addMethodMapping(this.classRef, reference, targetMember, obfMethodData);\n      } \n    } catch (ReferenceConflictException ex) {\n      this.ap.printMessage(Diagnostic.Kind.ERROR, \"Unexpected reference conflict for \" + subject + \": \" + reference + \" -> \" + ex\n          .getNew() + \" previously defined as \" + ex.getOld(), elem.getElement(), errorsOn);\n      return;\n    } \n    elem.notifyRemapped();\n  }\n}", "item_id": 0, "repo": "14ms/Minecraft-Disclosed-Source-Modifications", "file": "Catware/org/spongepowered/tools/obfuscation/AnnotatedMixinElementHandlerInjector.java", "last_update_at": "2022-03-06T21:55:16+00:00", "question_id": "01e167677eb8cc00d3380457990ffa9f367952f0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class AnnotatedMixinElementHandlerInjector extends AnnotatedMixinElementHandler {\n  static class AnnotatedElementInjector extends AnnotatedMixinElementHandler.AnnotatedElement<ExecutableElement> {\n    private final InjectorRemap state;\n    public AnnotatedElementInjector(ExecutableElement element, AnnotationHandle annotation, InjectorRemap shouldRemap) {\n      super(element, annotation);\n      this.state = shouldRemap;\n    }\n    public boolean shouldRemap() {\n      return this.state.shouldRemap();\n    }\n    public boolean hasCoerceArgument() {\n      if (!this.annotation.toString().equals(\"@Inject\"))\n        return false; \n      Iterator<? extends VariableElement> iterator = this.element.getParameters().iterator();\n      if (iterator.hasNext()) {\n        VariableElement param = iterator.next();\n        return AnnotationHandle.of(param, Coerce.class).exists();\n      } \n      return false;\n    }\n    public void addMessage(Diagnostic.Kind kind, CharSequence msg, Element element, AnnotationHandle annotation) {\n      this.state.addMessage(kind, msg, element, annotation);\n    }\n    public String toString() {\n      return getAnnotation().toString();\n    }\n  }\n  static class AnnotatedElementInjectionPoint extends AnnotatedMixinElementHandler.AnnotatedElement<ExecutableElement> {\n    private final AnnotationHandle at;\n    private Map<String, String> args;\n    private final InjectorRemap state;\n    public AnnotatedElementInjectionPoint(ExecutableElement element, AnnotationHandle inject, AnnotationHandle at, InjectorRemap state) {\n      super(element, inject);\n      this.at = at;\n      this.state = state;\n    }\n    public boolean shouldRemap() {\n      return this.at.getBoolean(\"remap\", this.state.shouldRemap());\n    }\n    public AnnotationHandle getAt() {\n      return this.at;\n    }\n    public String getAtArg(String key) {\n      if (this.args == null) {\n        this.args = new HashMap<String, String>();\n        for (String arg : this.at.getList(\"args\")) {\n          if (arg == null)\n            continue; \n          int eqPos = arg.indexOf('=');\n          if (eqPos > -1) {\n            this.args.put(arg.substring(0, eqPos), arg.substring(eqPos + 1));\n            continue;\n          } \n          this.args.put(arg, \"\");\n        } \n      } \n      return this.args.get(key);\n    }\n    public void notifyRemapped() {\n      this.state.notifyRemapped();\n    }\n  }\n  AnnotatedMixinElementHandlerInjector(IMixinAnnotationProcessor ap, AnnotatedMixin mixin) {\n    super(ap, mixin);\n  }\n  public void registerInjector(AnnotatedElementInjector elem) {\n    if (this.mixin.isInterface())\n      this.ap.printMessage(Diagnostic.Kind.ERROR, \"Injector in interface is unsupported\", elem.getElement()); \n    for (String reference : elem.getAnnotation().getList(\"method\")) {\n      MemberInfo targetMember = MemberInfo.parse(reference);\n      if (targetMember.name == null)\n        continue; \n      try {\n        targetMember.validate();\n      } catch (InvalidMemberDescriptorException ex) {\n        elem.printMessage((Messager)this.ap, Diagnostic.Kind.ERROR, ex.getMessage());\n      } \n      if (targetMember.desc != null)\n        validateReferencedTarget(elem.getElement(), elem.getAnnotation(), targetMember, elem.toString()); \n      if (!elem.shouldRemap())\n        continue; \n      for (TypeHandle target : this.mixin.getTargets()) {\n        if (!registerInjector(elem, reference, targetMember, target))\n          break; \n      } \n    } \n  }\n  private boolean registerInjector(AnnotatedElementInjector elem, String reference, MemberInfo targetMember, TypeHandle target) {\n    String desc = target.findDescriptor(targetMember);\n    if (desc == null) {\n      Diagnostic.Kind error = this.mixin.isMultiTarget() ? Diagnostic.Kind.ERROR : Diagnostic.Kind.WARNING;\n      if (target.isSimulated()) {\n        elem.printMessage((Messager)this.ap, Diagnostic.Kind.NOTE, elem + \" target '\" + reference + \"' in @Pseudo mixin will not be obfuscated\");\n      } else if (target.isImaginary()) {\n        elem.printMessage((Messager)this.ap, error, elem + \" target requires method signature because enclosing type information for \" + target + \" is unavailable\");\n      } else if (!targetMember.isInitialiser()) {\n        elem.printMessage((Messager)this.ap, error, \"Unable to determine signature for \" + elem + \" target method\");\n      } \n      return true;\n    } \n    String targetName = elem + \" target \" + targetMember.name;\n    MappingMethod targetMethod = target.getMappingMethod(targetMember.name, desc);\n    ObfuscationData<MappingMethod> obfData = this.obf.getDataProvider().getObfMethod(targetMethod);\n    if (obfData.isEmpty())\n      if (target.isSimulated()) {\n        obfData = this.obf.getDataProvider().getRemappedMethod(targetMethod);\n      } else {\n        if (targetMember.isClassInitialiser())\n          return true; \n        Diagnostic.Kind error = targetMember.isConstructor() ? Diagnostic.Kind.WARNING : Diagnostic.Kind.ERROR;\n        elem.addMessage(error, \"No obfuscation mapping for \" + targetName, elem.getElement(), elem.getAnnotation());\n        return false;\n      }  \n    IReferenceManager refMap = this.obf.getReferenceManager();\n    try {\n      if ((targetMember.owner == null && this.mixin.isMultiTarget()) || target.isSimulated())\n        obfData = AnnotatedMixinElementHandler.stripOwnerData(obfData); \n      refMap.addMethodMapping(this.classRef, reference, obfData);\n    } catch (ReferenceConflictException ex) {\n      String conflictType = this.mixin.isMultiTarget() ? \"Multi-target\" : \"Target\";\n      if (elem.hasCoerceArgument() && targetMember.owner == null && targetMember.desc == null) {\n        MemberInfo oldMember = MemberInfo.parse(ex.getOld());\n        MemberInfo newMember = MemberInfo.parse(ex.getNew());\n        if (oldMember.name.equals(newMember.name)) {\n          obfData = AnnotatedMixinElementHandler.stripDescriptors(obfData);\n          refMap.setAllowConflicts(true);\n          refMap.addMethodMapping(this.classRef, reference, obfData);\n          refMap.setAllowConflicts(false);\n          elem.printMessage((Messager)this.ap, Diagnostic.Kind.WARNING, \"Coerced \" + conflictType + \" reference has conflicting descriptors for \" + targetName + \": Storing bare references \" + obfData\n              .values() + \" in refMap\");\n          return true;\n        } \n      } \n      elem.printMessage((Messager)this.ap, Diagnostic.Kind.ERROR, conflictType + \" reference conflict for \" + targetName + \": \" + reference + \" -> \" + ex\n          .getNew() + \" previously defined as \" + ex.getOld());\n    } \n    return true;\n  }\n  public void registerInjectionPoint(AnnotatedElementInjectionPoint elem, String format) {\n    if (this.mixin.isInterface())\n      this.ap.printMessage(Diagnostic.Kind.ERROR, \"Injector in interface is unsupported\", elem.getElement()); \n    if (!elem.shouldRemap())\n      return; \n    String type = InjectionPointData.parseType((String)elem.getAt().getValue(\"value\"));\n    String target = (String)elem.getAt().getValue(\"target\");\n    if (\"NEW\".equals(type)) {\n      remapNewTarget(String.format(format, new Object[] { type + \".<target>\" }), target, elem);\n      remapNewTarget(String.format(format, new Object[] { type + \".args[class]\" }), elem.getAtArg(\"class\"), elem);\n    } else {\n      remapReference(String.format(format, new Object[] { type + \".<target>\" }), target, elem);\n    } \n  }\n  protected final void remapNewTarget(String subject, String reference, AnnotatedElementInjectionPoint elem) {\n    if (reference == null)\n      return; \n    MemberInfo member = MemberInfo.parse(reference);\n    String target = member.toCtorType();\n    if (target != null) {\n      String desc = member.toCtorDesc();\n      MappingMethod m = new MappingMethod(target, \".\", (desc != null) ? desc : \"()V\");\n      ObfuscationData<MappingMethod> remapped = this.obf.getDataProvider().getRemappedMethod(m);\n      if (remapped.isEmpty()) {\n        this.ap.printMessage(Diagnostic.Kind.WARNING, \"Cannot find class mapping for \" + subject + \" '\" + target + \"'\", elem.getElement(), elem\n            .getAnnotation().asMirror());\n        return;\n      } \n      ObfuscationData<String> mappings = new ObfuscationData<String>();\n      for (ObfuscationType type : remapped) {\n        MappingMethod mapping = remapped.get(type);\n        if (desc == null) {\n          mappings.put(type, mapping.getOwner());\n          continue;\n        } \n        mappings.put(type, mapping.getDesc().replace(\")V\", \")L\" + mapping.getOwner() + \";\"));\n      } \n      this.obf.getReferenceManager().addClassMapping(this.classRef, reference, mappings);\n    } \n    elem.notifyRemapped();\n  }\n  protected final void remapReference(String subject, String reference, AnnotatedElementInjectionPoint elem) {\n    if (reference == null)\n      return; \n    AnnotationMirror errorsOn = ((this.ap.getCompilerEnvironment() == IMixinAnnotationProcessor.CompilerEnvironment.JDT) ? elem.getAt() : elem.getAnnotation()).asMirror();\n    MemberInfo targetMember = MemberInfo.parse(reference);\n    if (!targetMember.isFullyQualified()) {\n      String missing = (targetMember.owner == null) ? ((targetMember.desc == null) ? \"owner and signature\" : \"owner\") : \"signature\";\n      this.ap.printMessage(Diagnostic.Kind.ERROR, subject + \" is not fully qualified, missing \" + missing, elem.getElement(), errorsOn);\n      return;\n    } \n    try {\n      targetMember.validate();\n    } catch (InvalidMemberDescriptorException ex) {\n      this.ap.printMessage(Diagnostic.Kind.ERROR, ex.getMessage(), elem.getElement(), errorsOn);\n    } \n    try {\n      if (targetMember.isField()) {\n        ObfuscationData<MappingField> obfFieldData = this.obf.getDataProvider().getObfFieldRecursive(targetMember);\n        if (obfFieldData.isEmpty()) {\n          this.ap.printMessage(Diagnostic.Kind.WARNING, \"Cannot find field mapping for \" + subject + \" '\" + reference + \"'\", elem.getElement(), errorsOn);\n          return;\n        } \n        this.obf.getReferenceManager().addFieldMapping(this.classRef, reference, targetMember, obfFieldData);\n      } else {\n        ObfuscationData<MappingMethod> obfMethodData = this.obf.getDataProvider().getObfMethodRecursive(targetMember);\n        if (obfMethodData.isEmpty() && (\n          targetMember.owner == null || !targetMember.owner.startsWith(\"java/lang/\"))) {\n          this.ap.printMessage(Diagnostic.Kind.WARNING, \"Cannot find method mapping for \" + subject + \" '\" + reference + \"'\", elem.getElement(), errorsOn);\n          return;\n        } \n        this.obf.getReferenceManager().addMethodMapping(this.classRef, reference, targetMember, obfMethodData);\n      } \n    } catch (ReferenceConflictException ex) {\n      this.ap.printMessage(Diagnostic.Kind.ERROR, \"Unexpected reference conflict for \" + subject + \": \" + reference + \" -> \" + ex\n          .getNew() + \" previously defined as \" + ex.getOld(), elem.getElement(), errorsOn);\n      return;\n    } \n    elem.notifyRemapped();\n  }\n"]], "pred": {"ppl": 1.8189454078674316, "ppl_lower": 2.1762139797210693, "ppl/lowercase_ppl": -1.2997537971246622, "ppl/zlib": 0.00023179267218836644, "Min_5.0% Prob": 5.923142218122296, "Min_10.0% Prob": 4.2740861352752235, "Min_20.0% Prob": 2.7289501802594054, "Min_30.0% Prob": 1.9452393730871038, "Min_40.0% Prob": 1.4853898654247846, "Min_50.0% Prob": 1.1958095515019274, "Min_60.0% Prob": 0.9980955337247163}}
{"hexsha": "cb08cf762e00fa4456bca75444154d2d5fb05213", "ext": "java", "lang": "Java", "content": "@Execution(ExecutionMode.SAME_THREAD)\nclass JsonTemplateLayoutAdditionalFieldTest {\n\n    @Test\n    @LoggerContextSource(\"additionalFieldEnrichedJsonTemplateLayoutLogging.json\")\n    void test_JSON_config_additional_fields(\n            final LoggerContext loggerContext,\n            final @Named(value = \"List\") ListAppender appender) {\n        assertAdditionalFields(loggerContext, appender);\n    }\n\n    @Test\n    @LoggerContextSource(\"additionalFieldEnrichedJsonTemplateLayoutLogging.properties\")\n    void test_Properties_config_additional_fields(\n            final LoggerContext loggerContext,\n            final @Named(value = \"List\") ListAppender appender) {\n        assertAdditionalFields(loggerContext, appender);\n    }\n\n    @Test\n    @LoggerContextSource(\"additionalFieldEnrichedJsonTemplateLayoutLogging.xml\")\n    void test_XML_config_additional_fields(\n            final LoggerContext loggerContext,\n            final @Named(value = \"List\") ListAppender appender) {\n        assertAdditionalFields(loggerContext, appender);\n    }\n\n    @Test\n    @LoggerContextSource(\"additionalFieldEnrichedJsonTemplateLayoutLogging.yaml\")\n    void test_YAML_config_additional_fields(\n            final LoggerContext loggerContext,\n            final @Named(value = \"List\") ListAppender appender) {\n        assertAdditionalFields(loggerContext, appender);\n    }\n\n    private static void assertAdditionalFields(\n            final LoggerContext loggerContext,\n            final ListAppender appender) {\n\n        // Log an event.\n        final Logger logger =\n                loggerContext.getLogger(JsonTemplateLayoutAdditionalFieldTest.class);\n        logger.info(\"trigger\");\n\n        // Verify that the appender has logged the event.\n        final List<byte[]> serializedEvents = appender.getData();\n        Assertions.assertThat(serializedEvents).hasSize(1);\n\n        // Deserialize the serialized event.\n        final byte[] serializedEvent = serializedEvents.get(0);\n        final String serializedEventJson =\n                new String(\n                        serializedEvent,\n                        JsonTemplateLayoutDefaults.getCharset());\n        final Object serializedEventObject = JsonReader.read(serializedEventJson);\n        Assertions.assertThat(serializedEventObject).isInstanceOf(Map.class);\n        @SuppressWarnings(\"unchecked\") final Map<String, Object> serializedEventMap =\n                (Map<String, Object>) serializedEventObject;\n\n        // Verify the serialized additional fields.\n        Assertions\n                .assertThat(serializedEventMap)\n                .containsEntry(\"stringField\", \"string\")\n                .containsEntry(\"numberField\", 1)\n                .containsEntry(\"objectField\", Collections.singletonMap(\"numberField\", 1))\n                .containsEntry(\"listField\", Arrays.asList(1, \"two\"));\n\n    }\n\n}", "item_id": 0, "repo": "grgrzybek/logging-log4j2", "file": "log4j-layout-template-json/src/test/java/org/apache/logging/log4j/layout/template/json/JsonTemplateLayoutAdditionalFieldTest.java", "last_update_at": "2022-03-24T06:26:58+00:00", "question_id": "cb08cf762e00fa4456bca75444154d2d5fb05213_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Execution(ExecutionMode.SAME_THREAD)\nclass JsonTemplateLayoutAdditionalFieldTest {\n    @Test\n    @LoggerContextSource(\"additionalFieldEnrichedJsonTemplateLayoutLogging.json\")\n    void test_JSON_config_additional_fields(\n            final LoggerContext loggerContext,\n            final @Named(value = \"List\") ListAppender appender) {\n        assertAdditionalFields(loggerContext, appender);\n    }\n    @Test\n    @LoggerContextSource(\"additionalFieldEnrichedJsonTemplateLayoutLogging.properties\")\n    void test_Properties_config_additional_fields(\n            final LoggerContext loggerContext,\n            final @Named(value = \"List\") ListAppender appender) {\n        assertAdditionalFields(loggerContext, appender);\n    }\n    @Test\n    @LoggerContextSource(\"additionalFieldEnrichedJsonTemplateLayoutLogging.xml\")\n    void test_XML_config_additional_fields(\n            final LoggerContext loggerContext,\n            final @Named(value = \"List\") ListAppender appender) {\n        assertAdditionalFields(loggerContext, appender);\n    }\n    @Test\n    @LoggerContextSource(\"additionalFieldEnrichedJsonTemplateLayoutLogging.yaml\")\n    void test_YAML_config_additional_fields(\n            final LoggerContext loggerContext,\n            final @Named(value = \"List\") ListAppender appender) {\n        assertAdditionalFields(loggerContext, appender);\n    }\n    private static void assertAdditionalFields(\n            final LoggerContext loggerContext,\n            final ListAppender appender) {\n        // Log an event.\n        final Logger logger =\n                loggerContext.getLogger(JsonTemplateLayoutAdditionalFieldTest.class);\n        logger.info(\"trigger\");\n        // Verify that the appender has logged the event.\n        final List<byte[]> serializedEvents = appender.getData();\n        Assertions.assertThat(serializedEvents).hasSize(1);\n        // Deserialize the serialized event.\n        final byte[] serializedEvent = serializedEvents.get(0);\n        final String serializedEventJson =\n                new String(\n                        serializedEvent,\n                        JsonTemplateLayoutDefaults.getCharset());\n        final Object serializedEventObject = JsonReader.read(serializedEventJson);\n        Assertions.assertThat(serializedEventObject).isInstanceOf(Map.class);\n        @SuppressWarnings(\"unchecked\") final Map<String, Object> serializedEventMap =\n                (Map<String, Object>) serializedEventObject;\n        // Verify the serialized additional fields.\n        Assertions\n                .assertThat(serializedEventMap)\n                .containsEntry(\"stringField\", \"string\")\n                .containsEntry(\"numberField\", 1)\n                .containsEntry(\"objectField\", Collections.singletonMap(\"numberField\", 1))\n                .containsEntry(\"listField\", Arrays.asList(1, \"two\"));\n    }\n"]], "pred": {"ppl": 1.7030649185180664, "ppl_lower": 2.070913553237915, "ppl/lowercase_ppl": -1.3672980389125011, "ppl/zlib": 0.000779545418809393, "Min_5.0% Prob": 5.641050931385585, "Min_10.0% Prob": 4.043509636126774, "Min_20.0% Prob": 2.500098551662875, "Min_30.0% Prob": 1.7496898494695834, "Min_40.0% Prob": 1.3261822357996773, "Min_50.0% Prob": 1.0637531738990629, "Min_60.0% Prob": 0.8871104694575513}}
{"hexsha": "bce37b2816d68aa631aa52752c26dea498b575a6", "ext": "java", "lang": "Java", "content": "public abstract class JOGLGLWindow extends J2SEWindow\n        implements GLEventListener, MouseListener, MouseMotionListener, java.awt.event.MouseListener,\n        com.jogamp.newt.event.WindowListener,\n        KeyListener, WindowListener {\n\n    private boolean alwaysOnTop = false;\n    private boolean mouseVisible = true;\n    private boolean mouseConfined = false;\n    private boolean autoSwapBuffer = false;\n    protected volatile boolean contextCreated = false;\n    protected GLCanvas canvas;\n    protected Frame frame;\n    protected GLWindow glWindow;\n    Animator animator;\n    private Hashtable<Integer, Integer> AWTKeycodes;\n\n    /**\n     * Creates a new JOGL window with the specified {@link CoreAppStarter} and swapinterval\n     * \n     * @throws IllegalArgumentException If coreAppStarter is null\n     */\n    public JOGLGLWindow(BackendFactory factory, CoreAppStarter coreAppStarter, PropertySettings appSettings) {\n        super(factory, coreAppStarter, appSettings);\n    }\n\n    @Override\n    public VideoMode init(PropertySettings appSettings) {\n        version = appSettings.version;\n        if (coreAppStarter == null) {\n            throw new IllegalArgumentException(\"CoreAppStarter is null\");\n        }\n        switch (appSettings.windowType) {\n            case NEWT:\n                createNEWTWindow(appSettings);\n                break;\n            case JAWT:\n                createAWTWindow(appSettings);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid windowtype for JOGL: \" + appSettings.windowType);\n        }\n\n        /**\n         * Fetch jogamp.newt fields that start with VK_ and store keycodes in array to convert to AWT values.\n         */\n        AWTKeycodes = getAWTFields();\n        return new VideoMode(appSettings.width, appSettings.height, appSettings.fullscreen, appSettings.swapInterval);\n    }\n\n    private Hashtable<Integer, Integer> getAWTFields() {\n        Hashtable<Integer, Integer> awtFields = new Hashtable<>();\n        for (Field newtField : com.jogamp.newt.event.KeyEvent.class.getDeclaredFields()) {\n            if (java.lang.reflect.Modifier.isStatic(newtField.getModifiers())) {\n                String fieldName = newtField.getName();\n                if (fieldName.startsWith(\"VK_\")) {\n                    try {\n                        Field awtField = java.awt.event.KeyEvent.class.getField(fieldName);\n                        int newtKeyCode = newtField.getShort(null) & 0xffff;\n                        int awtKeyCode = awtField.getInt(null);\n                        awtFields.put(newtKeyCode, awtKeyCode);\n                    } catch (NoSuchFieldException | IllegalAccessException e) {\n                        SimpleLogger.d(getClass(), e.toString());\n                    }\n                }\n            }\n        }\n        return awtFields;\n    }\n\n    protected GLProfile getProfile(Renderers version) {\n        SimpleLogger.d(getClass(), \"os.and.arch: \" + Platform.os_and_arch);\n        GLProfile defaultProfile = null;\n        try {\n            defaultProfile = GLProfile.getDefault();\n            if (defaultProfile != null) {\n                SimpleLogger.d(getClass(), \"Default profile implName: \" + defaultProfile.getImplName() + \", name: \"\n                        + defaultProfile.getName());\n            } else {\n                SimpleLogger.d(getClass(), \"Default profile is NULL\");\n            }\n        } catch (Throwable t) {\n            // Not much to do\n            SimpleLogger.d(getClass(), \"Internal error when fetching default profile\");\n        }\n        GLProfile profile = null;\n        switch (version) {\n            case GLES20:\n                if (defaultProfile != null && (defaultProfile.isGLES2() || defaultProfile.isGL2ES2())) {\n                    profile = defaultProfile;\n                } else {\n                    profile = GLProfile.get(GLProfile.GL2ES2);\n                }\n                break;\n            case GLES30:\n            case GLES31:\n            case GLES32:\n                if (defaultProfile != null && (defaultProfile.isGLES3() || defaultProfile.isGL4ES3())) {\n                    profile = defaultProfile;\n                } else {\n                    profile = GLProfile.get(GLProfile.GL4ES3);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid version \" + version);\n        }\n        return profile;\n    }\n\n    /**\n     * Creates the JOGL display and OpenGLES\n     * \n     * @param width\n     * @param height\n     * @param profile\n     * @version\n     */\n    private void createNEWTWindow(PropertySettings appSettings) {\n        GLProfile profile = getProfile(appSettings.version);\n        SurfaceConfiguration config = appSettings.getConfiguration();\n        GLProfile.initSingleton();\n        GLCapabilities glCapabilities = new GLCapabilities(profile);\n        glCapabilities.setSampleBuffers(config.getSamples() > 0);\n        glCapabilities.setNumSamples(config.getSamples());\n        glCapabilities.setBackgroundOpaque(true);\n        glCapabilities.setAlphaBits(0);\n        glWindow = GLWindow.create(glCapabilities);\n        glWindow.setUndecorated(appSettings.windowUndecorated);\n        InsetsImmutable insets = glWindow.getInsets();\n        glWindow.setSize(\n                appSettings.windowUndecorated ? appSettings.width\n                        : appSettings.width + insets.getTotalWidth(),\n                appSettings.windowUndecorated ? appSettings.height\n                        : appSettings.height + insets.getTotalHeight());\n        glWindow.setAlwaysOnTop(alwaysOnTop);\n        glWindow.setPointerVisible(mouseVisible);\n        glWindow.confinePointer(mouseConfined);\n        glWindow.addMouseListener(this);\n        glWindow.addWindowListener(this);\n        glWindow.addKeyListener(this);\n        glWindow.addWindowListener(this);\n        glWindow.addGLEventListener(this);\n        glWindow.setFullscreen(appSettings.fullscreen);\n        animator = new Animator();\n        animator.add(glWindow);\n        animator.start();\n        glWindow.setAutoSwapBufferMode(autoSwapBuffer);\n\n    }\n\n    private void createAWTWindow(PropertySettings appSettings) {\n        GLProfile profile = getProfile(appSettings.version);\n        GLProfile.initSingleton();\n        GLCapabilities caps = new GLCapabilities(profile);\n        caps.setBackgroundOpaque(true);\n        caps.setAlphaBits(0);\n        // glWindow = GLWindow.create(caps);\n        frame = new java.awt.Frame(\"Nucleus\");\n        frame.setSize(appSettings.width, appSettings.height);\n        frame.setLayout(new java.awt.BorderLayout());\n        canvas = new GLCanvas(caps);\n        canvas.addGLEventListener(this);\n        frame.add(canvas, java.awt.BorderLayout.CENTER);\n        frame.validate();\n        frame.addWindowListener(this);\n        animator = new Animator();\n        animator.add(canvas);\n        animator.start();\n        canvas.setAutoSwapBufferMode(autoSwapBuffer);\n        canvas.addMouseListener(this);\n        canvas.addMouseMotionListener(this);\n    }\n\n    @Override\n    public void setWindowTitle(String title) {\n        if (frame != null) {\n            frame.setTitle(title);\n        }\n        if (glWindow != null) {\n            glWindow.setTitle(title);\n        }\n    }\n\n    public void setGLEVentListener() {\n        if (glWindow != null) {\n            glWindow.addGLEventListener(this);\n        }\n        if (canvas != null) {\n            canvas.addGLEventListener(this);\n        }\n    }\n\n    @Override\n    public void setVisible(boolean visible) {\n        if (glWindow != null) {\n            glWindow.setVisible(visible);\n        }\n        if (frame != null) {\n            frame.setVisible(visible);\n        }\n\n    }\n\n    @Override\n    public void init(GLAutoDrawable drawable) {\n        internalCreateCoreApp(drawable.getSurfaceWidth(), drawable.getSurfaceHeight());\n        drawable.swapBuffers();\n        drawable.getGL().setSwapInterval(videoMode.getSwapInterval());\n        internalContextCreated(drawable.getSurfaceWidth(), drawable.getSurfaceHeight());\n    }\n\n    @Override\n    public void reshape(GLAutoDrawable drawable, int x, int y, int width, int height) {\n        SimpleLogger.d(getClass(), \"reshape: x,y= \" + x + \", \" + y + \" width,height= \" + width + \", \" + height);\n    }\n\n    @Override\n    public void display(GLAutoDrawable drawable) {\n        if (!autoSwapBuffer) {\n            coreApp.renderFrame();\n            if (glWindow != null) {\n                glWindow.swapBuffers();\n            } else if (canvas != null) {\n                canvas.swapBuffers();\n            }\n        }\n    }\n\n    protected void handleMouseEvent(MouseEvent e, PointerAction action) {\n        int[] xpos = e.getAllX();\n        int[] ypos = e.getAllY();\n        int count = e.getPointerCount();\n        Type type = Type.STYLUS;\n        for (int i = 0; i < count; i++) {\n            switch (e.getButton()) {\n                case MouseEvent.BUTTON1:\n                    type = Type.MOUSE;\n                    break;\n                case MouseEvent.BUTTON2:\n                    type = Type.MOUSE;\n                    break;\n                case MouseEvent.BUTTON3:\n                    type = Type.MOUSE;\n                    break;\n                case MouseEvent.BUTTON4:\n                    type = Type.MOUSE;\n                    break;\n                case MouseEvent.BUTTON5:\n                    type = Type.MOUSE;\n                    break;\n                case MouseEvent.BUTTON6:\n                    type = Type.MOUSE;\n                    break;\n            }\n            handleMouseEvent(action, type, xpos[i], ypos[i], e.getPointerId(i), e.getWhen());\n        }\n    }\n\n    protected void handleKeyEvent(KeyEvent event) {\n        /**\n         * com.jogamp.newt.event.KeyEvent keycodes are the same as the AWT KeyEvent keycodes.\n         */\n        SimpleLogger.d(getClass(), \"KeyEvent \" + event.getEventType() + \" : \" + event.getKeyCode());\n        switch (event.getEventType()) {\n            case KeyEvent.EVENT_KEY_PRESSED:\n                super.handleKeyEvent(new com.nucleus.mmi.Key(Action.PRESSED,\n                        AWTKeycodes.get((int) event.getKeyCode())));\n                switch (event.getKeyCode()) {\n                    case KeyEvent.VK_ESCAPE:\n                        onBackPressed();\n                }\n                break;\n            case KeyEvent.EVENT_KEY_RELEASED:\n                super.handleKeyEvent(new com.nucleus.mmi.Key(Action.RELEASED,\n                        AWTKeycodes.get((int) event.getKeyCode())));\n                break;\n            default:\n                // Do nothing\n        }\n    }\n\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        // TODO Auto-generated method stub\n\n    }\n\n    @Override\n    public void mouseEntered(MouseEvent e) {\n        // TODO Auto-generated method stub\n\n    }\n\n    @Override\n    public void mouseExited(MouseEvent e) {\n        // TODO Auto-generated method stub\n\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e) {\n        handleMouseEvent(e, PointerAction.DOWN);\n    }\n\n    @Override\n    public void mouseReleased(MouseEvent e) {\n        handleMouseEvent(e, PointerAction.UP);\n    }\n\n    @Override\n    public void mouseMoved(MouseEvent e) {\n    }\n\n    @Override\n    public void mouseDragged(MouseEvent e) {\n        handleMouseEvent(e, PointerAction.MOVE);\n    }\n\n    @Override\n    public void mouseWheelMoved(MouseEvent e) {\n        mouseWheelMoved(e.getRotation()[1], e.getWhen());\n    }\n\n    @Override\n    public void mouseDragged(java.awt.event.MouseEvent e) {\n        handleMouseEvent(PointerAction.MOVE, Type.MOUSE, e.getX(), e.getX(), Pointer.POINTER_1, e.getWhen());\n    }\n\n    @Override\n    public void mouseMoved(java.awt.event.MouseEvent e) {\n        // TODO Auto-generated method stub\n    }\n\n    @Override\n    public void mouseClicked(java.awt.event.MouseEvent e) {\n\n    }\n\n    @Override\n    public void mousePressed(java.awt.event.MouseEvent e) {\n        handleMouseEvent(PointerAction.DOWN, Type.MOUSE, e.getX(), e.getX(), Pointer.POINTER_1, e.getWhen());\n    }\n\n    @Override\n    public void mouseReleased(java.awt.event.MouseEvent e) {\n        handleMouseEvent(PointerAction.UP, Type.MOUSE, e.getX(), e.getX(), Pointer.POINTER_1, e.getWhen());\n    }\n\n    @Override\n    public void mouseEntered(java.awt.event.MouseEvent e) {\n\n    }\n\n    @Override\n    public void mouseExited(java.awt.event.MouseEvent e) {\n    }\n\n    @Override\n    public void windowResized(WindowEvent e) {\n    }\n\n    @Override\n    public void windowMoved(WindowEvent e) {\n    }\n\n    @Override\n    public void windowDestroyNotify(WindowEvent e) {\n        windowClosed();\n    }\n\n    @Override\n    public void windowDestroyed(WindowEvent e) {\n        windowClosed();\n    }\n\n    @Override\n    public void windowGainedFocus(WindowEvent e) {\n    }\n\n    @Override\n    public void windowLostFocus(WindowEvent e) {\n    }\n\n    @Override\n    public void windowRepaint(WindowUpdateEvent e) {\n    }\n\n    @Override\n    public void windowOpened(java.awt.event.WindowEvent e) {\n        // TODO Auto-generated method stub\n\n    }\n\n    @Override\n    public void windowClosing(java.awt.event.WindowEvent e) {\n        SimpleLogger.d(getClass(), \"Window closing\");\n        windowClosed();\n    }\n\n    @Override\n    public void windowClosed(java.awt.event.WindowEvent e) {\n        SimpleLogger.d(getClass(), \"Window closed\");\n    }\n\n    @Override\n    public void windowIconified(java.awt.event.WindowEvent e) {\n        // TODO Auto-generated method stub\n\n    }\n\n    @Override\n    public void windowDeiconified(java.awt.event.WindowEvent e) {\n        // TODO Auto-generated method stub\n\n    }\n\n    @Override\n    public void windowActivated(java.awt.event.WindowEvent e) {\n        // TODO Auto-generated method stub\n\n    }\n\n    @Override\n    public void windowDeactivated(java.awt.event.WindowEvent e) {\n        // TODO Auto-generated method stub\n\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        if ((e.getModifiers() & InputEvent.AUTOREPEAT_MASK) == 0) {\n            handleKeyEvent(e);\n        }\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        if ((e.getModifiers() & InputEvent.AUTOREPEAT_MASK) == 0) {\n            handleKeyEvent(e);\n        }\n    }\n\n    @Override\n    public VideoMode setVideoMode(VideoMode videoMode, int monitorIndex) {\n        switch (windowType) {\n            case JAWT:\n                break;\n            case NEWT:\n                glWindow.setFullscreen(videoMode.isFullScreen());\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid windowtype: \" + windowType);\n        }\n        return videoMode;\n    }\n\n    @Override\n    public void destroy() {\n        if (animator != null) {\n            animator.stop();\n        }\n    }\n\n}", "item_id": 0, "repo": "rsahlin/graphics-by-opengl", "file": "graphics-by-opengl-jogl/src/main/java/com/nucleus/jogl/JOGLGLWindow.java", "last_update_at": "2022-03-30T14:05:54+00:00", "question_id": "bce37b2816d68aa631aa52752c26dea498b575a6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class JOGLGLWindow extends J2SEWindow\n        implements GLEventListener, MouseListener, MouseMotionListener, java.awt.event.MouseListener,\n        com.jogamp.newt.event.WindowListener,\n        KeyListener, WindowListener {\n    private boolean alwaysOnTop = false;\n    private boolean mouseVisible = true;\n    private boolean mouseConfined = false;\n    private boolean autoSwapBuffer = false;\n    protected volatile boolean contextCreated = false;\n    protected GLCanvas canvas;\n    protected Frame frame;\n    protected GLWindow glWindow;\n    Animator animator;\n    private Hashtable<Integer, Integer> AWTKeycodes;\n    /**\n     * Creates a new JOGL window with the specified {@link CoreAppStarter} and swapinterval\n     * \n     * @throws IllegalArgumentException If coreAppStarter is null\n     */\n    public JOGLGLWindow(BackendFactory factory, CoreAppStarter coreAppStarter, PropertySettings appSettings) {\n        super(factory, coreAppStarter, appSettings);\n    }\n    @Override\n    public VideoMode init(PropertySettings appSettings) {\n        version = appSettings.version;\n        if (coreAppStarter == null) {\n            throw new IllegalArgumentException(\"CoreAppStarter is null\");\n        }\n        switch (appSettings.windowType) {\n            case NEWT:\n                createNEWTWindow(appSettings);\n                break;\n            case JAWT:\n                createAWTWindow(appSettings);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid windowtype for JOGL: \" + appSettings.windowType);\n        }\n        /**\n         * Fetch jogamp.newt fields that start with VK_ and store keycodes in array to convert to AWT values.\n         */\n        AWTKeycodes = getAWTFields();\n        return new VideoMode(appSettings.width, appSettings.height, appSettings.fullscreen, appSettings.swapInterval);\n    }\n    private Hashtable<Integer, Integer> getAWTFields() {\n        Hashtable<Integer, Integer> awtFields = new Hashtable<>();\n        for (Field newtField : com.jogamp.newt.event.KeyEvent.class.getDeclaredFields()) {\n            if (java.lang.reflect.Modifier.isStatic(newtField.getModifiers())) {\n                String fieldName = newtField.getName();\n                if (fieldName.startsWith(\"VK_\")) {\n                    try {\n                        Field awtField = java.awt.event.KeyEvent.class.getField(fieldName);\n                        int newtKeyCode = newtField.getShort(null) & 0xffff;\n                        int awtKeyCode = awtField.getInt(null);\n                        awtFields.put(newtKeyCode, awtKeyCode);\n                    } catch (NoSuchFieldException | IllegalAccessException e) {\n                        SimpleLogger.d(getClass(), e.toString());\n                    }\n                }\n            }\n        }\n        return awtFields;\n    }\n    protected GLProfile getProfile(Renderers version) {\n        SimpleLogger.d(getClass(), \"os.and.arch: \" + Platform.os_and_arch);\n        GLProfile defaultProfile = null;\n        try {\n            defaultProfile = GLProfile.getDefault();\n            if (defaultProfile != null) {\n                SimpleLogger.d(getClass(), \"Default profile implName: \" + defaultProfile.getImplName() + \", name: \"\n                        + defaultProfile.getName());\n            } else {\n                SimpleLogger.d(getClass(), \"Default profile is NULL\");\n            }\n        } catch (Throwable t) {\n            // Not much to do\n            SimpleLogger.d(getClass(), \"Internal error when fetching default profile\");\n        }\n        GLProfile profile = null;\n        switch (version) {\n            case GLES20:\n                if (defaultProfile != null && (defaultProfile.isGLES2() || defaultProfile.isGL2ES2())) {\n                    profile = defaultProfile;\n                } else {\n                    profile = GLProfile.get(GLProfile.GL2ES2);\n                }\n                break;\n            case GLES30:\n            case GLES31:\n            case GLES32:\n                if (defaultProfile != null && (defaultProfile.isGLES3() || defaultProfile.isGL4ES3())) {\n                    profile = defaultProfile;\n                } else {\n                    profile = GLProfile.get(GLProfile.GL4ES3);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid version \" + version);\n        }\n        return profile;\n    }\n    /**\n     * Creates the JOGL display and OpenGLES\n     * \n     * @param width\n     * @param height\n     * @param profile\n     * @version\n     */\n    private void createNEWTWindow(PropertySettings appSettings) {\n        GLProfile profile = getProfile(appSettings.version);\n        SurfaceConfiguration config = appSettings.getConfiguration();\n        GLProfile.initSingleton();\n        GLCapabilities glCapabilities = new GLCapabilities(profile);\n        glCapabilities.setSampleBuffers(config.getSamples() > 0);\n        glCapabilities.setNumSamples(config.getSamples());\n        glCapabilities.setBackgroundOpaque(true);\n        glCapabilities.setAlphaBits(0);\n        glWindow = GLWindow.create(glCapabilities);\n        glWindow.setUndecorated(appSettings.windowUndecorated);\n        InsetsImmutable insets = glWindow.getInsets();\n        glWindow.setSize(\n                appSettings.windowUndecorated ? appSettings.width\n                        : appSettings.width + insets.getTotalWidth(),\n                appSettings.windowUndecorated ? appSettings.height\n                        : appSettings.height + insets.getTotalHeight());\n        glWindow.setAlwaysOnTop(alwaysOnTop);\n        glWindow.setPointerVisible(mouseVisible);\n        glWindow.confinePointer(mouseConfined);\n        glWindow.addMouseListener(this);\n        glWindow.addWindowListener(this);\n        glWindow.addKeyListener(this);\n        glWindow.addWindowListener(this);\n        glWindow.addGLEventListener(this);\n        glWindow.setFullscreen(appSettings.fullscreen);\n        animator = new Animator();\n        animator.add(glWindow);\n        animator.start();\n        glWindow.setAutoSwapBufferMode(autoSwapBuffer);\n    }\n    private void createAWTWindow(PropertySettings appSettings) {\n        GLProfile profile = getProfile(appSettings.version);\n        GLProfile.initSingleton();\n        GLCapabilities caps = new GLCapabilities(profile);\n        caps.setBackgroundOpaque(true);\n        caps.setAlphaBits(0);\n        // glWindow = GLWindow.create(caps);\n        frame = new java.awt.Frame(\"Nucleus\");\n        frame.setSize(appSettings.width, appSettings.height);\n        frame.setLayout(new java.awt.BorderLayout());\n        canvas = new GLCanvas(caps);\n        canvas.addGLEventListener(this);\n        frame.add(canvas, java.awt.BorderLayout.CENTER);\n        frame.validate();\n        frame.addWindowListener(this);\n        animator = new Animator();\n        animator.add(canvas);\n        animator.start();\n        canvas.setAutoSwapBufferMode(autoSwapBuffer);\n        canvas.addMouseListener(this);\n        canvas.addMouseMotionListener(this);\n    }\n    @Override\n    public void setWindowTitle(String title) {\n        if (frame != null) {\n            frame.setTitle(title);\n        }\n        if (glWindow != null) {\n            glWindow.setTitle(title);\n        }\n    }\n    public void setGLEVentListener() {\n        if (glWindow != null) {\n            glWindow.addGLEventListener(this);\n        }\n        if (canvas != null) {\n            canvas.addGLEventListener(this);\n        }\n    }\n    @Override\n    public void setVisible(boolean visible) {\n        if (glWindow != null) {\n            glWindow.setVisible(visible);\n        }\n        if (frame != null) {\n            frame.setVisible(visible);\n        }\n    }\n    @Override\n    public void init(GLAutoDrawable drawable) {\n        internalCreateCoreApp(drawable.getSurfaceWidth(), drawable.getSurfaceHeight());\n        drawable.swapBuffers();\n        drawable.getGL().setSwapInterval(videoMode.getSwapInterval());\n        internalContextCreated(drawable.getSurfaceWidth(), drawable.getSurfaceHeight());\n    }\n    @Override\n    public void reshape(GLAutoDrawable drawable, int x, int y, int width, int height) {\n        SimpleLogger.d(getClass(), \"reshape: x,y= \" + x + \", \" + y + \" width,height= \" + width + \", \" + height);\n    }\n    @Override\n    public void display(GLAutoDrawable drawable) {\n        if (!autoSwapBuffer) {\n            coreApp.renderFrame();\n            if (glWindow != null) {\n                glWindow.swapBuffers();\n            } else if (canvas != null) {\n                canvas.swapBuffers();\n            }\n        }\n    }\n    protected void handleMouseEvent(MouseEvent e, PointerAction action) {\n        int[] xpos = e.getAllX();\n        int[] ypos = e.getAllY();\n        int count = e.getPointerCount();\n        Type type = Type.STYLUS;\n        for (int i = 0; i < count; i++) {\n            switch (e.getButton()) {\n                case MouseEvent.BUTTON1:\n                    type = Type.MOUSE;\n                    break;\n                case MouseEvent.BUTTON2:\n                    type = Type.MOUSE;\n                    break;\n                case MouseEvent.BUTTON3:\n                    type = Type.MOUSE;\n                    break;\n                case MouseEvent.BUTTON4:\n                    type = Type.MOUSE;\n                    break;\n                case MouseEvent.BUTTON5:\n                    type = Type.MOUSE;\n                    break;\n                case MouseEvent.BUTTON6:\n                    type = Type.MOUSE;\n                    break;\n            }\n            handleMouseEvent(action, type, xpos[i], ypos[i], e.getPointerId(i), e.getWhen());\n        }\n    }\n    protected void handleKeyEvent(KeyEvent event) {\n        /**\n         * com.jogamp.newt.event.KeyEvent keycodes are the same as the AWT KeyEvent keycodes.\n         */\n        SimpleLogger.d(getClass(), \"KeyEvent \" + event.getEventType() + \" : \" + event.getKeyCode());\n        switch (event.getEventType()) {\n            case KeyEvent.EVENT_KEY_PRESSED:\n                super.handleKeyEvent(new com.nucleus.mmi.Key(Action.PRESSED,\n                        AWTKeycodes.get((int) event.getKeyCode())));\n                switch (event.getKeyCode()) {\n                    case KeyEvent.VK_ESCAPE:\n                        onBackPressed();\n                }\n                break;\n            case KeyEvent.EVENT_KEY_RELEASED:\n                super.handleKeyEvent(new com.nucleus.mmi.Key(Action.RELEASED,\n                        AWTKeycodes.get((int) event.getKeyCode())));\n                break;\n            default:\n                // Do nothing\n        }\n    }\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        // TODO Auto-generated method stub\n    }\n    @Override\n    public void mouseEntered(MouseEvent e) {\n        // TODO Auto-generated method stub\n    }\n    @Override\n    public void mouseExited(MouseEvent e) {\n        // TODO Auto-generated method stub\n    }\n    @Override\n    public void mousePressed(MouseEvent e) {\n        handleMouseEvent(e, PointerAction.DOWN);\n    }\n    @Override\n    public void mouseReleased(MouseEvent e) {\n        handleMouseEvent(e, PointerAction.UP);\n    }\n    @Override\n    public void mouseMoved(MouseEvent e) {\n    }\n    @Override\n    public void mouseDragged(MouseEvent e) {\n        handleMouseEvent(e, PointerAction.MOVE);\n    }\n    @Override\n    public void mouseWheelMoved(MouseEvent e) {\n        mouseWheelMoved(e.getRotation()[1], e.getWhen());\n    }\n    @Override\n    public void mouseDragged(java.awt.event.MouseEvent e) {\n        handleMouseEvent(PointerAction.MOVE, Type.MOUSE, e.getX(), e.getX(), Pointer.POINTER_1, e.getWhen());\n    }\n    @Override\n    public void mouseMoved(java.awt.event.MouseEvent e) {\n        // TODO Auto-generated method stub\n    }\n    @Override\n    public void mouseClicked(java.awt.event.MouseEvent e) {\n    }\n    @Override\n    public void mousePressed(java.awt.event.MouseEvent e) {\n        handleMouseEvent(PointerAction.DOWN, Type.MOUSE, e.getX(), e.getX(), Pointer.POINTER_1, e.getWhen());\n    }\n    @Override\n    public void mouseReleased(java.awt.event.MouseEvent e) {\n        handleMouseEvent(PointerAction.UP, Type.MOUSE, e.getX(), e.getX(), Pointer.POINTER_1, e.getWhen());\n    }\n    @Override\n    public void mouseEntered(java.awt.event.MouseEvent e) {\n    }\n    @Override\n    public void mouseExited(java.awt.event.MouseEvent e) {\n    }\n    @Override\n    public void windowResized(WindowEvent e) {\n    }\n    @Override\n    public void windowMoved(WindowEvent e) {\n    }\n    @Override\n    public void windowDestroyNotify(WindowEvent e) {\n        windowClosed();\n    }\n    @Override\n    public void windowDestroyed(WindowEvent e) {\n        windowClosed();\n    }\n    @Override\n    public void windowGainedFocus(WindowEvent e) {\n    }\n    @Override\n    public void windowLostFocus(WindowEvent e) {\n    }\n    @Override\n    public void windowRepaint(WindowUpdateEvent e) {\n    }\n    @Override\n    public void windowOpened(java.awt.event.WindowEvent e) {\n        // TODO Auto-generated method stub\n    }\n    @Override\n    public void windowClosing(java.awt.event.WindowEvent e) {\n        SimpleLogger.d(getClass(), \"Window closing\");\n        windowClosed();\n    }\n    @Override\n    public void windowClosed(java.awt.event.WindowEvent e) {\n        SimpleLogger.d(getClass(), \"Window closed\");\n    }\n    @Override\n    public void windowIconified(java.awt.event.WindowEvent e) {\n        // TODO Auto-generated method stub\n    }\n    @Override\n    public void windowDeiconified(java.awt.event.WindowEvent e) {\n        // TODO Auto-generated method stub\n    }\n    @Override\n    public void windowActivated(java.awt.event.WindowEvent e) {\n        // TODO Auto-generated method stub\n    }\n    @Override\n    public void windowDeactivated(java.awt.event.WindowEvent e) {\n        // TODO Auto-generated method stub\n    }\n    @Override\n    public void keyPressed(KeyEvent e) {\n        if ((e.getModifiers() & InputEvent.AUTOREPEAT_MASK) == 0) {\n            handleKeyEvent(e);\n        }\n    }\n    @Override\n    public void keyReleased(KeyEvent e) {\n        if ((e.getModifiers() & InputEvent.AUTOREPEAT_MASK) == 0) {\n            handleKeyEvent(e);\n        }\n    }\n    @Override\n    public VideoMode setVideoMode(VideoMode videoMode, int monitorIndex) {\n        switch (windowType) {\n            case JAWT:\n                break;\n            case NEWT:\n                glWindow.setFullscreen(videoMode.isFullScreen());\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid windowtype: \" + windowType);\n        }\n        return videoMode;\n    }\n    @Override\n    public void destroy() {\n        if (animator != null) {\n            animator.stop();\n        }\n    }\n"]], "pred": {"ppl": 2.360879898071289, "ppl_lower": 2.625492572784424, "ppl/lowercase_ppl": -1.1236669206934906, "ppl/zlib": 0.000280546828124246, "Min_5.0% Prob": 7.966345132565966, "Min_10.0% Prob": 5.915433981839349, "Min_20.0% Prob": 3.809999946870056, "Min_30.0% Prob": 2.7651283381616367, "Min_40.0% Prob": 2.1246515505361967, "Min_50.0% Prob": 1.714560296262547, "Min_60.0% Prob": 1.4323023673979531}}
{"hexsha": "2c991f3981ee40868f85178cd22aa2a64a123490", "ext": "java", "lang": "Java", "content": "class SampleRB_de extends ListResourceBundle {\n\t@Override\n\tprotected Object[][] getContents() {\n\t\tObject[][] resources = new Object[3][2];\n\t\tresources[0][0] = \"title\";\n\t\tresources[0][1] = \"Mein Programm\";\n\t\tresources[1][0] = \"StopText\";\n\t\tresources[1][1] = \"Anschlag\";\n\t\tresources[2][0] = \"StartText\";\n\t\tresources[2][1] = \"Anfang\";\n\t\treturn resources;\n\t}\n}", "item_id": 2, "repo": "sumon-dey/JavaConcepts", "file": "src/main/java/com/javaconcepts/utilities/ResourceBundleDemo.java", "last_update_at": "2022-03-20T19:54:05+00:00", "question_id": "2c991f3981ee40868f85178cd22aa2a64a123490_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class SampleRB_de extends ListResourceBundle {\n\t@Override\n\tprotected Object[][] getContents() {\n\t\tObject[][] resources = new Object[3][2];\n\t\tresources[0][0] = \"title\";\n\t\tresources[0][1] = \"Mein Programm\";\n\t\tresources[1][0] = \"StopText\";\n\t\tresources[1][1] = \"Anschlag\";\n\t\tresources[2][0] = \"StartText\";\n\t\tresources[2][1] = \"Anfang\";\n\t\treturn resources;\n\t}\n"]], "pred": {"ppl": 2.5170950889587402, "ppl_lower": 3.7580618858337402, "ppl/lowercase_ppl": -1.4341842585002436, "ppl/zlib": 0.004685814691005061, "Min_5.0% Prob": 8.058220624923706, "Min_10.0% Prob": 6.492323141831618, "Min_20.0% Prob": 4.463781177997589, "Min_30.0% Prob": 3.0578373450695016, "Min_40.0% Prob": 2.334742348537677, "Min_50.0% Prob": 1.8576291664503515, "Min_60.0% Prob": 1.5415186482913248}}
{"hexsha": "5eb74c5442d6f7c2288f7b9fd8dbc5af726a9536", "ext": "java", "lang": "Java", "content": "public class KubernetesConfigMapProviderIT {\n    private static final String RESOURCE_NAME = \"my-test-config-map\";\n\n    private static String namespace;\n    private static KubernetesClient client;\n    private static KubernetesConfigMapConfigProvider provider;\n\n    @BeforeAll\n    public static void beforeAll()   {\n        provider = new KubernetesConfigMapConfigProvider();\n        provider.configure(emptyMap());\n\n        client = new DefaultKubernetesClient();\n        namespace = client.getNamespace();\n\n        ConfigMap cm = new ConfigMapBuilder()\n                .withNewMetadata()\n                    .withName(RESOURCE_NAME)\n                    .withNamespace(namespace)\n                .endMetadata()\n                .addToData(\"test-key-1\", \"test-value-1\")\n                .addToData(\"test-key-2\", \"test-value-2\")\n                .addToData(\"test-key-3\", \"test-value-3\")\n                .build();\n\n        client.configMaps().create(cm);\n    }\n\n    @AfterAll\n    public static void afterAll() throws IOException {\n        client.configMaps().inNamespace(namespace).withName(RESOURCE_NAME).delete();\n        provider.close();\n    }\n\n    @Test\n    public void testAllValues() {\n        ConfigData config = provider.get(namespace + \"/\" + RESOURCE_NAME);\n        Map<String, String> data = config.data();\n\n        assertThat(data.size(), is(3));\n        assertThat(data.get(\"test-key-1\"), is(\"test-value-1\"));\n        assertThat(data.get(\"test-key-2\"), is(\"test-value-2\"));\n        assertThat(data.get(\"test-key-3\"), is(\"test-value-3\"));\n    }\n\n    @Test\n    public void testSomeValues() {\n        ConfigData config = provider.get(namespace + \"/\" + RESOURCE_NAME, new HashSet<>(Arrays.asList(\"test-key-1\", \"test-key-3\")));\n        Map<String, String> data = config.data();\n\n        assertThat(data.size(), is(2));\n        assertThat(data.get(\"test-key-1\"), is(\"test-value-1\"));\n        assertThat(data.get(\"test-key-3\"), is(\"test-value-3\"));\n    }\n\n    @Test\n    public void testOneValue() {\n        ConfigData config = provider.get(namespace + \"/\" + RESOURCE_NAME, Collections.singleton(\"test-key-2\"));\n        Map<String, String> data = config.data();\n\n        assertThat(data.size(), is(1));\n        assertThat(data.get(\"test-key-2\"), is(\"test-value-2\"));\n    }\n\n    @Test\n    public void testNonExistentConfigMap() {\n        assertThrows(ConfigException.class, () -> provider.get(namespace + \"/i-do-not-exist\"));\n        assertThrows(ConfigException.class, () -> provider.get(\"i-do-not-exist/i-do-not-exist-either\"));\n        assertThrows(ConfigException.class, () -> provider.get(\"i-do-not-exist\"));\n    }\n}", "item_id": 0, "repo": "scholzj/kafka-kubernetes-config-provider", "file": "src/test/java/io/strimzi/kafka/KubernetesConfigMapProviderIT.java", "last_update_at": "2022-03-02T21:02:53+00:00", "question_id": "5eb74c5442d6f7c2288f7b9fd8dbc5af726a9536_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class KubernetesConfigMapProviderIT {\n    private static final String RESOURCE_NAME = \"my-test-config-map\";\n    private static String namespace;\n    private static KubernetesClient client;\n    private static KubernetesConfigMapConfigProvider provider;\n    @BeforeAll\n    public static void beforeAll()   {\n        provider = new KubernetesConfigMapConfigProvider();\n        provider.configure(emptyMap());\n        client = new DefaultKubernetesClient();\n        namespace = client.getNamespace();\n        ConfigMap cm = new ConfigMapBuilder()\n                .withNewMetadata()\n                    .withName(RESOURCE_NAME)\n                    .withNamespace(namespace)\n                .endMetadata()\n                .addToData(\"test-key-1\", \"test-value-1\")\n                .addToData(\"test-key-2\", \"test-value-2\")\n                .addToData(\"test-key-3\", \"test-value-3\")\n                .build();\n        client.configMaps().create(cm);\n    }\n    @AfterAll\n    public static void afterAll() throws IOException {\n        client.configMaps().inNamespace(namespace).withName(RESOURCE_NAME).delete();\n        provider.close();\n    }\n    @Test\n    public void testAllValues() {\n        ConfigData config = provider.get(namespace + \"/\" + RESOURCE_NAME);\n        Map<String, String> data = config.data();\n        assertThat(data.size(), is(3));\n        assertThat(data.get(\"test-key-1\"), is(\"test-value-1\"));\n        assertThat(data.get(\"test-key-2\"), is(\"test-value-2\"));\n        assertThat(data.get(\"test-key-3\"), is(\"test-value-3\"));\n    }\n    @Test\n    public void testSomeValues() {\n        ConfigData config = provider.get(namespace + \"/\" + RESOURCE_NAME, new HashSet<>(Arrays.asList(\"test-key-1\", \"test-key-3\")));\n        Map<String, String> data = config.data();\n        assertThat(data.size(), is(2));\n        assertThat(data.get(\"test-key-1\"), is(\"test-value-1\"));\n        assertThat(data.get(\"test-key-3\"), is(\"test-value-3\"));\n    }\n    @Test\n    public void testOneValue() {\n        ConfigData config = provider.get(namespace + \"/\" + RESOURCE_NAME, Collections.singleton(\"test-key-2\"));\n        Map<String, String> data = config.data();\n        assertThat(data.size(), is(1));\n        assertThat(data.get(\"test-key-2\"), is(\"test-value-2\"));\n    }\n    @Test\n    public void testNonExistentConfigMap() {\n        assertThrows(ConfigException.class, () -> provider.get(namespace + \"/i-do-not-exist\"));\n        assertThrows(ConfigException.class, () -> provider.get(\"i-do-not-exist/i-do-not-exist-either\"));\n        assertThrows(ConfigException.class, () -> provider.get(\"i-do-not-exist\"));\n    }\n"]], "pred": {"ppl": 1.371429681777954, "ppl_lower": 1.602363109588623, "ppl/lowercase_ppl": -1.4927144908818384, "ppl/zlib": 0.0004785663015877389, "Min_5.0% Prob": 4.0958421902778825, "Min_10.0% Prob": 2.707672145886299, "Min_20.0% Prob": 1.539358210296203, "Min_30.0% Prob": 1.0480878877445545, "Min_40.0% Prob": 0.7896739924326539, "Min_50.0% Prob": 0.6311596847619252, "Min_60.0% Prob": 0.5264924200356448}}
{"hexsha": "88992b81223bff8aff8aefc4402b628c603b4e04", "ext": "java", "lang": "Java", "content": "public class devOnePopup extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.dev_one_popup);\n        ArrayList<String> urls= new ArrayList<>();\n\n        ImageView devOneGh = findViewById(R.id.devOneGh);\n        devOneGh.setOnClickListener(view -> {\n            vibrateDevice();\n            Intent intent = new Intent();\n            intent.setAction(Intent.ACTION_VIEW);\n            intent.addCategory(Intent.CATEGORY_BROWSABLE);\n            intent.setData(Uri.parse(\"https://github.com/the-rebooted-coder\"));\n            startActivity(intent);\n        });\n        ImageView devOneIn = findViewById(R.id.devOneLinkedin);\n        devOneIn.setOnClickListener(view -> {\n            vibrateDevice();\n            Intent intent = new Intent();\n            intent.setAction(Intent.ACTION_VIEW);\n            intent.addCategory(Intent.CATEGORY_BROWSABLE);\n            intent.setData(Uri.parse(\"https://www.linkedin.com/in/spandn/\"));\n            startActivity(intent);\n        });\n        ImageView devOneWeb = findViewById(R.id.devOneWeb);\n        new Thread(() -> {\n            try {\n                // Create a URL for the desired page\n                URL url = new URL(\"https://raw.githubusercontent.com/the-rebooted-coder/Spandan-Saxena-Portfolio/master/porfolioLink.txt\");\n                //First open the connection\n                HttpURLConnection conn=(HttpURLConnection) url.openConnection();\n                conn.setConnectTimeout(60000); // timing out in a minute\n                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String str;\n                while ((str = in.readLine()) != null) {\n                    urls.add(str);\n                }\n                in.close();\n            } catch (Exception e) {\n                Log.d(\"MyTag\",e.toString());\n            }\n            try {\n                this.runOnUiThread(() -> {\n                    if (!urls.isEmpty()) {\n                    }\n                });\n            }\n            catch (NullPointerException e){\n                //Very Important\n                //DO NOTE REMOVE THIS\n            }\n        }).start();\n        devOneWeb.setOnClickListener(view -> {\n            vibrateDevice();\n            Intent intent = new Intent();\n            intent.setAction(Intent.ACTION_VIEW);\n            intent.addCategory(Intent.CATEGORY_BROWSABLE);\n            intent.setData(Uri.parse(urls.toString().replaceAll(\"\\\\[\", \"\").replaceAll(\"]\",\"\")));\n            startActivity(intent);\n        });\n        ImageView devOneMail = findViewById(R.id.devOneMail);\n        devOneMail.setOnClickListener(view -> {\n            vibrateDevice();\n            Intent email = new Intent(Intent.ACTION_SEND);\n            email.putExtra(android.content.Intent.EXTRA_EMAIL, new String[]{\"connectwithspandan@gmail.com\"});\n            email.putExtra(Intent.EXTRA_SUBJECT, \"TakeNotes Connection\");\n            email.putExtra(Intent.EXTRA_TEXT, \"Type your mail here\");\n            email.setType(\"message/rfc822\");\n            startActivity(Intent.createChooser(email, \"Choose an Email client :\"));\n        });\n    }\n    private void vibrateDevice() {\n        Vibrator v3 = (Vibrator)getSystemService(Context.VIBRATOR_SERVICE);\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            v3.vibrate(VibrationEffect.createOneShot(28, VibrationEffect.DEFAULT_AMPLITUDE));\n        } else {\n            //deprecated in API 26\n            v3.vibrate(25);\n        }\n    }\n}", "item_id": 0, "repo": "crabby0720/Take-Notes", "file": "app/src/main/java/com/aaxena/takenotes/devOnePopup.java", "last_update_at": "2022-03-08T17:41:20+00:00", "question_id": "88992b81223bff8aff8aefc4402b628c603b4e04_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class devOnePopup extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.dev_one_popup);\n        ArrayList<String> urls= new ArrayList<>();\n        ImageView devOneGh = findViewById(R.id.devOneGh);\n        devOneGh.setOnClickListener(view -> {\n            vibrateDevice();\n            Intent intent = new Intent();\n            intent.setAction(Intent.ACTION_VIEW);\n            intent.addCategory(Intent.CATEGORY_BROWSABLE);\n            intent.setData(Uri.parse(\"https://github.com/the-rebooted-coder\"));\n            startActivity(intent);\n        });\n        ImageView devOneIn = findViewById(R.id.devOneLinkedin);\n        devOneIn.setOnClickListener(view -> {\n            vibrateDevice();\n            Intent intent = new Intent();\n            intent.setAction(Intent.ACTION_VIEW);\n            intent.addCategory(Intent.CATEGORY_BROWSABLE);\n            intent.setData(Uri.parse(\"https://www.linkedin.com/in/spandn/\"));\n            startActivity(intent);\n        });\n        ImageView devOneWeb = findViewById(R.id.devOneWeb);\n        new Thread(() -> {\n            try {\n                // Create a URL for the desired page\n                URL url = new URL(\"https://raw.githubusercontent.com/the-rebooted-coder/Spandan-Saxena-Portfolio/master/porfolioLink.txt\");\n                //First open the connection\n                HttpURLConnection conn=(HttpURLConnection) url.openConnection();\n                conn.setConnectTimeout(60000); // timing out in a minute\n                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String str;\n                while ((str = in.readLine()) != null) {\n                    urls.add(str);\n                }\n                in.close();\n            } catch (Exception e) {\n                Log.d(\"MyTag\",e.toString());\n            }\n            try {\n                this.runOnUiThread(() -> {\n                    if (!urls.isEmpty()) {\n                    }\n                });\n            }\n            catch (NullPointerException e){\n                //Very Important\n                //DO NOTE REMOVE THIS\n            }\n        }).start();\n        devOneWeb.setOnClickListener(view -> {\n            vibrateDevice();\n            Intent intent = new Intent();\n            intent.setAction(Intent.ACTION_VIEW);\n            intent.addCategory(Intent.CATEGORY_BROWSABLE);\n            intent.setData(Uri.parse(urls.toString().replaceAll(\"\\\\[\", \"\").replaceAll(\"]\",\"\")));\n            startActivity(intent);\n        });\n        ImageView devOneMail = findViewById(R.id.devOneMail);\n        devOneMail.setOnClickListener(view -> {\n            vibrateDevice();\n            Intent email = new Intent(Intent.ACTION_SEND);\n            email.putExtra(android.content.Intent.EXTRA_EMAIL, new String[]{\"connectwithspandan@gmail.com\"});\n            email.putExtra(Intent.EXTRA_SUBJECT, \"TakeNotes Connection\");\n            email.putExtra(Intent.EXTRA_TEXT, \"Type your mail here\");\n            email.setType(\"message/rfc822\");\n            startActivity(Intent.createChooser(email, \"Choose an Email client :\"));\n        });\n    }\n    private void vibrateDevice() {\n        Vibrator v3 = (Vibrator)getSystemService(Context.VIBRATOR_SERVICE);\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            v3.vibrate(VibrationEffect.createOneShot(28, VibrationEffect.DEFAULT_AMPLITUDE));\n        } else {\n            //deprecated in API 26\n            v3.vibrate(25);\n        }\n    }\n"]], "pred": {"ppl": 1.7119368314743042, "ppl_lower": 2.0261528491973877, "ppl/lowercase_ppl": -1.3134403130666343, "ppl/zlib": 0.0004457921886695636, "Min_5.0% Prob": 6.638807321081356, "Min_10.0% Prob": 4.510631625749627, "Min_20.0% Prob": 2.588313670030662, "Min_30.0% Prob": 1.7755430311116638, "Min_40.0% Prob": 1.3409977107907511, "Min_50.0% Prob": 1.0751865926255681, "Min_60.0% Prob": 0.8966821888734928}}
{"hexsha": "c908f41b54a0d1bb85a745ef538101b743c06fa6", "ext": "java", "lang": "Java", "content": "@Named\n@RequestScoped\npublic class MultiSelectView {\n\n    private List<SelectItem> categories;\n    private String selection;\n\n    @PostConstruct\n    public void init() {\n        categories = new ArrayList<>();\n        SelectItemGroup group1 = new SelectItemGroup(\"Group 1\");\n        SelectItemGroup group2 = new SelectItemGroup(\"Group 2\");\n        SelectItemGroup group3 = new SelectItemGroup(\"Group 3\");\n        SelectItemGroup group4 = new SelectItemGroup(\"Group 4\");\n\n        SelectItemGroup group11 = new SelectItemGroup(\"Group 1.1\");\n        SelectItemGroup group12 = new SelectItemGroup(\"Group 1.2\");\n\n        SelectItemGroup group21 = new SelectItemGroup(\"Group 2.1\");\n\n        SelectItem option31 = new SelectItem(\"Option 3.1\", \"Option 3.1\");\n        SelectItem option32 = new SelectItem(\"Option 3.2\", \"Option 3.2\");\n        SelectItem option33 = new SelectItem(\"Option 3.3\", \"Option 3.3\");\n        SelectItem option34 = new SelectItem(\"Option 3.4\", \"Option 3.4\");\n\n        SelectItem option41 = new SelectItem(\"Option 4.1\", \"Option 4.1\");\n\n        SelectItem option111 = new SelectItem(\"Option 1.1.1\");\n        SelectItem option112 = new SelectItem(\"Option 1.1.2\");\n        group11.setSelectItems(new SelectItem[]{option111, option112});\n\n        SelectItem option121 = new SelectItem(\"Option 1.2.1\", \"Option 1.2.1\");\n        SelectItem option122 = new SelectItem(\"Option 1.2.2\", \"Option 1.2.2\");\n        SelectItem option123 = new SelectItem(\"Option 1.2.3\", \"Option 1.2.3\");\n        group12.setSelectItems(new SelectItem[]{option121, option122, option123});\n\n        SelectItem option211 = new SelectItem(\"Option 2.1.1\", \"Option 2.1.1\");\n        group21.setSelectItems(new SelectItem[]{option211});\n\n        group1.setSelectItems(new SelectItem[]{group11, group12});\n        group2.setSelectItems(new SelectItem[]{group21});\n        group3.setSelectItems(new SelectItem[]{option31, option32, option33, option34});\n        group4.setSelectItems(new SelectItem[]{option41});\n\n        categories.add(group1);\n        categories.add(group2);\n        categories.add(group3);\n        categories.add(group4);\n    }\n\n    public List<SelectItem> getCategories() {\n        return categories;\n    }\n\n    public String getSelection() {\n        return selection;\n    }\n\n    public void setSelection(String selection) {\n        this.selection = selection;\n    }\n}", "item_id": 0, "repo": "psunde/primefaces", "file": "primefaces-showcase/src/main/java/org/primefaces/showcase/view/input/MultiSelectView.java", "last_update_at": "2022-03-25T04:42:06+00:00", "question_id": "c908f41b54a0d1bb85a745ef538101b743c06fa6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Named\n@RequestScoped\npublic class MultiSelectView {\n    private List<SelectItem> categories;\n    private String selection;\n    @PostConstruct\n    public void init() {\n        categories = new ArrayList<>();\n        SelectItemGroup group1 = new SelectItemGroup(\"Group 1\");\n        SelectItemGroup group2 = new SelectItemGroup(\"Group 2\");\n        SelectItemGroup group3 = new SelectItemGroup(\"Group 3\");\n        SelectItemGroup group4 = new SelectItemGroup(\"Group 4\");\n        SelectItemGroup group11 = new SelectItemGroup(\"Group 1.1\");\n        SelectItemGroup group12 = new SelectItemGroup(\"Group 1.2\");\n        SelectItemGroup group21 = new SelectItemGroup(\"Group 2.1\");\n        SelectItem option31 = new SelectItem(\"Option 3.1\", \"Option 3.1\");\n        SelectItem option32 = new SelectItem(\"Option 3.2\", \"Option 3.2\");\n        SelectItem option33 = new SelectItem(\"Option 3.3\", \"Option 3.3\");\n        SelectItem option34 = new SelectItem(\"Option 3.4\", \"Option 3.4\");\n        SelectItem option41 = new SelectItem(\"Option 4.1\", \"Option 4.1\");\n        SelectItem option111 = new SelectItem(\"Option 1.1.1\");\n        SelectItem option112 = new SelectItem(\"Option 1.1.2\");\n        group11.setSelectItems(new SelectItem[]{option111, option112});\n        SelectItem option121 = new SelectItem(\"Option 1.2.1\", \"Option 1.2.1\");\n        SelectItem option122 = new SelectItem(\"Option 1.2.2\", \"Option 1.2.2\");\n        SelectItem option123 = new SelectItem(\"Option 1.2.3\", \"Option 1.2.3\");\n        group12.setSelectItems(new SelectItem[]{option121, option122, option123});\n        SelectItem option211 = new SelectItem(\"Option 2.1.1\", \"Option 2.1.1\");\n        group21.setSelectItems(new SelectItem[]{option211});\n        group1.setSelectItems(new SelectItem[]{group11, group12});\n        group2.setSelectItems(new SelectItem[]{group21});\n        group3.setSelectItems(new SelectItem[]{option31, option32, option33, option34});\n        group4.setSelectItems(new SelectItem[]{option41});\n        categories.add(group1);\n        categories.add(group2);\n        categories.add(group3);\n        categories.add(group4);\n    }\n    public List<SelectItem> getCategories() {\n        return categories;\n    }\n    public String getSelection() {\n        return selection;\n    }\n    public void setSelection(String selection) {\n        this.selection = selection;\n    }\n"]], "pred": {"ppl": 1.2356386184692383, "ppl_lower": 1.3703259229660034, "ppl/lowercase_ppl": -1.4889724663631305, "ppl/zlib": 0.00041815797708480586, "Min_5.0% Prob": 3.420707219176822, "Min_10.0% Prob": 1.9996248434667718, "Min_20.0% Prob": 1.0477657929873792, "Min_30.0% Prob": 0.7042816407872703, "Min_40.0% Prob": 0.5280629151301193, "Min_50.0% Prob": 0.42340981537712186, "Min_60.0% Prob": 0.3525199170068356}}
{"hexsha": "a6d523b703659dc6debf0ce356a2e5cdb450a35a", "ext": "java", "lang": "Java", "content": "public class MOCL {\n    @Deprecated // use clij2 instead\n    CLIJ clij;\n\n    CLIJ2 clij2;\n    MOCL(CLIJ2 clij2, CLIJ clij) {\n        this.clij2 = clij2;\n        this.clij = clij;\n    }\n\n\n    public MOCLBuffer imhist(MOCLBuffer input, int numberOfBins) {\n        float minimumGreyValue = (new Double(clij2.minimumOfAllPixels(input.buffer))).floatValue();\n        float maximumGreyValue = (new Double(clij2.maximumOfAllPixels(input.buffer))).floatValue();\n\n        ClearCLBuffer histogram = clij2.create(new long[]{(long)numberOfBins, 1L, 1L}, NativeTypeEnum.Float);\n        clij2.fillHistogram(input.buffer, histogram, minimumGreyValue, maximumGreyValue);\n\n        return new MOCLBuffer(this, histogram);\n    }\n\n    public MOCLBuffer fliplr(MOCLBuffer input) {\n        ClearCLBuffer output = clij2.create(input.buffer);\n        if (input.buffer.getDimension() == 2) {\n            clij2.flip(input.buffer, output, true, false);\n        } else {\n            clij2.flip(input.buffer, output, true, false, false);\n        }\n        return new MOCLBuffer(this, output);\n    }\n\n    public MOCLBuffer imRead(String imageFile) {\n        ImagePlus imp = IJ.openImage(imageFile);\n        return new MOCLBuffer(this, clij2.convert(imp, ClearCLBuffer.class));\n    }\n\n    public double min(MOCLBuffer input) {\n        return clij2.minimumOfAllPixels(input.buffer);\n    }\n\n    public double max(MOCLBuffer input) {\n        return clij2.maximumOfAllPixels(input.buffer);\n    }\n\n    public double mean(MOCLBuffer input) {\n        return clij2.sumPixels(input.buffer) / input.buffer.getWidth() / input.buffer.getHeight() / input.buffer.getDepth();\n    }\n\n    public MOCLBuffer ones(int numberOfElementsX) {\n        ClearCLBuffer buffer = anys(numberOfElementsX).buffer;\n        clij2.set(buffer, 1f);\n        return new MOCLBuffer(this, buffer);\n    }\n\n    public MOCLBuffer ones(int numberOfElementsX, int numberOfElementsY) {\n        ClearCLBuffer buffer = anys(numberOfElementsX, numberOfElementsY).buffer;\n        clij2.set(buffer, 1f);\n        return new MOCLBuffer(this, buffer);\n    }\n\n    public MOCLBuffer ones(int numberOfElementsX, int numberOfElementsY, int numberOfElementsZ) {\n        ClearCLBuffer buffer = anys(numberOfElementsX, numberOfElementsY, numberOfElementsZ).buffer;\n        clij2.set(buffer, 1f);\n        return new MOCLBuffer(this, buffer);\n    }\n\n    public MOCLBuffer zeros(int numberOfElements) {\n        ClearCLBuffer buffer = anys(numberOfElements).buffer;\n        clij2.set(buffer, 0f);\n        return new MOCLBuffer(this, buffer);\n    }\n\n    public MOCLBuffer zeros(int numberOfElementsX, int numberOfElementsY) {\n        ClearCLBuffer buffer = anys(numberOfElementsX, numberOfElementsY).buffer;\n        clij2.set(buffer, 0f);\n        return new MOCLBuffer(this, buffer);\n    }\n\n    public MOCLBuffer zeros(int numberOfElementsX, int numberOfElementsY, int numberOfElementsZ) {\n        ClearCLBuffer buffer = anys(numberOfElementsX, numberOfElementsY, numberOfElementsZ).buffer;\n        clij2.set(buffer, 0f);\n        return new MOCLBuffer(this, buffer);\n    }\n\n\n    public MOCLBuffer anys(int... numberOfElements) {\n        long[] dimensions = new long[Math.max(Math.min(numberOfElements.length, 3), 2)];\n        for (int i = 0; i < dimensions.length; i++) {\n            if (i < numberOfElements.length) {\n                dimensions[i] = numberOfElements[i];\n            } else {\n                dimensions[i] = dimensions[0];\n            }\n        }\n        return new MOCLBuffer(this, clij2.create(dimensions, NativeTypeEnum.Float));\n    }\n\n    public long[] size(MOCLBuffer input) {\n        return clij2.getSize(input.buffer);\n    }\n\n    public MOCLBuffer colon(int min, int max) {\n        System.out.println(\"MOCL colon2\");\n        ClearCLBuffer intensities = clij2.create(new long[]{max-min + 1, 1}, NativeTypeEnum.Float);\n        ClearCLBuffer temp = clij2.create(intensities);\n        clij2.set(intensities, 1f);\n        clij2.multiplyImageAndCoordinate(intensities, temp, 0);\n        clij2.addImageAndScalar(temp, intensities, new Float(min));\n        temp.close();\n        return new MOCLBuffer(this, intensities);\n    }\n\n    public MOCLBuffer colon(int min, int step, int max) {\n        System.out.println(\"MOCL colon3\");\n        ClearCLBuffer intensities = clij2.create(new long[]{(max-min)/step + 1, 1}, NativeTypeEnum.Float);\n        ClearCLBuffer temp = clij2.create(intensities);\n        clij2.set(intensities, 1f);\n        clij2.multiplyImageAndCoordinate(intensities, temp, 0);\n        clij2.multiplyImageAndScalar(temp, intensities, new Float(step));\n        clij2.addImageAndScalar(intensities, temp, new Float(min));\n        intensities.close();\n        return new MOCLBuffer(this, temp);\n    }\n\n    public MOCLBuffer push(Object object) {\n        if (object instanceof MOCLBuffer) {\n            return (MOCLBuffer)object;\n        }\n        if (object instanceof double[][][]) {\n            Double3 double3 = new Double3((double[][][])object);\n            System.out.println(\"d3 size: \" + double3.data.length + \"/\" + double3.data[0].length + \"/\" + double3.data[0][0].length );\n            Double3ToClearCLBufferConverter converter = new Double3ToClearCLBufferConverter();\n            converter.setCLIJ(clij);\n            return new MOCLBuffer(this, converter.convert(double3));\n        }\n        if (object instanceof double[][]) {\n            Double2 double2 = new Double2((double[][])object);\n            System.out.println(\"d2 size: \" + double2.data.length + \"/\" + double2.data[0].length );\n            Double2ToClearCLBufferConverter converter = new Double2ToClearCLBufferConverter();\n            converter.setCLIJ(clij);\n            return new MOCLBuffer(this, converter.convert(double2));\n        }\n        if (object instanceof double[]) {\n            Double1 double1 = new Double1((double[])object);\n            System.out.println(\"d1 size: \" + double1.data.length );\n            Double1ToClearCLBufferConverter converter = new Double1ToClearCLBufferConverter();\n            converter.setCLIJ(clij);\n            return new MOCLBuffer(this, converter.convert(double1));\n        }\n        if (object instanceof byte[][][]) {\n            Byte3 byte3 = new Byte3((byte[][][])object);\n            System.out.println(\"b3 size: \" + byte3.data.length + \"/\" + byte3.data[0].length + \"/\" + byte3.data[0][0].length );\n            Byte3ToClearCLBufferConverter converter = new Byte3ToClearCLBufferConverter();\n            converter.setCLIJ(clij);\n            return new MOCLBuffer(this, converter.convert(byte3));\n        }\n        if (object instanceof byte[][]) {\n            Byte2 byte2 = new Byte2((byte[][])object);\n            System.out.println(\"b2 size: \" + byte2.data.length + \"/\" + byte2.data[0].length );\n            Byte2ToClearCLBufferConverter converter = new Byte2ToClearCLBufferConverter();\n            converter.setCLIJ(clij);\n            return new MOCLBuffer(this, converter.convert(byte2));\n        }\n        if (object instanceof byte[]) {\n            Byte1 byte1 = new Byte1((byte[])object);\n            System.out.println(\"b1 size: \" + byte1.data.length);\n            Byte1ToClearCLBufferConverter converter = new Byte1ToClearCLBufferConverter();\n            converter.setCLIJ(clij);\n            return new MOCLBuffer(this, converter.convert(byte1));\n        }\n        throw new IllegalArgumentException(\"Conversion of \" + object +\n                \" / \" + object.getClass().getName() + \" not supported\");\n    }\n\n    public Object pull(MOCLBuffer input) {\n        return pull(input.buffer);\n    }\n    public Object pull(ClearCLBuffer buffer) {\n        if (buffer.getNativeType() == NativeTypeEnum.Float) {\n            if (buffer.getDimension() == 2) {\n                return new ClearCLBufferToDouble2Converter().convert(buffer).data;\n            }\n            if (buffer.getDimension() == 3) {\n                return new ClearCLBufferToDouble3Converter().convert(buffer).data;\n            }\n        }\n\n        throw new IllegalArgumentException(\"Conversion of \" + buffer +\n                \" / \" + buffer.getClass().getName() + \" not supported\");\n    }\n}", "item_id": 0, "repo": "clij/clatlab", "file": "src/main/java/net/haesleinhuepf/clatlab/MOCL.java", "last_update_at": "2022-01-14T01:45:20+00:00", "question_id": "a6d523b703659dc6debf0ce356a2e5cdb450a35a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MOCL {\n    @Deprecated // use clij2 instead\n    CLIJ clij;\n    CLIJ2 clij2;\n    MOCL(CLIJ2 clij2, CLIJ clij) {\n        this.clij2 = clij2;\n        this.clij = clij;\n    }\n    public MOCLBuffer imhist(MOCLBuffer input, int numberOfBins) {\n        float minimumGreyValue = (new Double(clij2.minimumOfAllPixels(input.buffer))).floatValue();\n        float maximumGreyValue = (new Double(clij2.maximumOfAllPixels(input.buffer))).floatValue();\n        ClearCLBuffer histogram = clij2.create(new long[]{(long)numberOfBins, 1L, 1L}, NativeTypeEnum.Float);\n        clij2.fillHistogram(input.buffer, histogram, minimumGreyValue, maximumGreyValue);\n        return new MOCLBuffer(this, histogram);\n    }\n    public MOCLBuffer fliplr(MOCLBuffer input) {\n        ClearCLBuffer output = clij2.create(input.buffer);\n        if (input.buffer.getDimension() == 2) {\n            clij2.flip(input.buffer, output, true, false);\n        } else {\n            clij2.flip(input.buffer, output, true, false, false);\n        }\n        return new MOCLBuffer(this, output);\n    }\n    public MOCLBuffer imRead(String imageFile) {\n        ImagePlus imp = IJ.openImage(imageFile);\n        return new MOCLBuffer(this, clij2.convert(imp, ClearCLBuffer.class));\n    }\n    public double min(MOCLBuffer input) {\n        return clij2.minimumOfAllPixels(input.buffer);\n    }\n    public double max(MOCLBuffer input) {\n        return clij2.maximumOfAllPixels(input.buffer);\n    }\n    public double mean(MOCLBuffer input) {\n        return clij2.sumPixels(input.buffer) / input.buffer.getWidth() / input.buffer.getHeight() / input.buffer.getDepth();\n    }\n    public MOCLBuffer ones(int numberOfElementsX) {\n        ClearCLBuffer buffer = anys(numberOfElementsX).buffer;\n        clij2.set(buffer, 1f);\n        return new MOCLBuffer(this, buffer);\n    }\n    public MOCLBuffer ones(int numberOfElementsX, int numberOfElementsY) {\n        ClearCLBuffer buffer = anys(numberOfElementsX, numberOfElementsY).buffer;\n        clij2.set(buffer, 1f);\n        return new MOCLBuffer(this, buffer);\n    }\n    public MOCLBuffer ones(int numberOfElementsX, int numberOfElementsY, int numberOfElementsZ) {\n        ClearCLBuffer buffer = anys(numberOfElementsX, numberOfElementsY, numberOfElementsZ).buffer;\n        clij2.set(buffer, 1f);\n        return new MOCLBuffer(this, buffer);\n    }\n    public MOCLBuffer zeros(int numberOfElements) {\n        ClearCLBuffer buffer = anys(numberOfElements).buffer;\n        clij2.set(buffer, 0f);\n        return new MOCLBuffer(this, buffer);\n    }\n    public MOCLBuffer zeros(int numberOfElementsX, int numberOfElementsY) {\n        ClearCLBuffer buffer = anys(numberOfElementsX, numberOfElementsY).buffer;\n        clij2.set(buffer, 0f);\n        return new MOCLBuffer(this, buffer);\n    }\n    public MOCLBuffer zeros(int numberOfElementsX, int numberOfElementsY, int numberOfElementsZ) {\n        ClearCLBuffer buffer = anys(numberOfElementsX, numberOfElementsY, numberOfElementsZ).buffer;\n        clij2.set(buffer, 0f);\n        return new MOCLBuffer(this, buffer);\n    }\n    public MOCLBuffer anys(int... numberOfElements) {\n        long[] dimensions = new long[Math.max(Math.min(numberOfElements.length, 3), 2)];\n        for (int i = 0; i < dimensions.length; i++) {\n            if (i < numberOfElements.length) {\n                dimensions[i] = numberOfElements[i];\n            } else {\n                dimensions[i] = dimensions[0];\n            }\n        }\n        return new MOCLBuffer(this, clij2.create(dimensions, NativeTypeEnum.Float));\n    }\n    public long[] size(MOCLBuffer input) {\n        return clij2.getSize(input.buffer);\n    }\n    public MOCLBuffer colon(int min, int max) {\n        System.out.println(\"MOCL colon2\");\n        ClearCLBuffer intensities = clij2.create(new long[]{max-min + 1, 1}, NativeTypeEnum.Float);\n        ClearCLBuffer temp = clij2.create(intensities);\n        clij2.set(intensities, 1f);\n        clij2.multiplyImageAndCoordinate(intensities, temp, 0);\n        clij2.addImageAndScalar(temp, intensities, new Float(min));\n        temp.close();\n        return new MOCLBuffer(this, intensities);\n    }\n    public MOCLBuffer colon(int min, int step, int max) {\n        System.out.println(\"MOCL colon3\");\n        ClearCLBuffer intensities = clij2.create(new long[]{(max-min)/step + 1, 1}, NativeTypeEnum.Float);\n        ClearCLBuffer temp = clij2.create(intensities);\n        clij2.set(intensities, 1f);\n        clij2.multiplyImageAndCoordinate(intensities, temp, 0);\n        clij2.multiplyImageAndScalar(temp, intensities, new Float(step));\n        clij2.addImageAndScalar(intensities, temp, new Float(min));\n        intensities.close();\n        return new MOCLBuffer(this, temp);\n    }\n    public MOCLBuffer push(Object object) {\n        if (object instanceof MOCLBuffer) {\n            return (MOCLBuffer)object;\n        }\n        if (object instanceof double[][][]) {\n            Double3 double3 = new Double3((double[][][])object);\n            System.out.println(\"d3 size: \" + double3.data.length + \"/\" + double3.data[0].length + \"/\" + double3.data[0][0].length );\n            Double3ToClearCLBufferConverter converter = new Double3ToClearCLBufferConverter();\n            converter.setCLIJ(clij);\n            return new MOCLBuffer(this, converter.convert(double3));\n        }\n        if (object instanceof double[][]) {\n            Double2 double2 = new Double2((double[][])object);\n            System.out.println(\"d2 size: \" + double2.data.length + \"/\" + double2.data[0].length );\n            Double2ToClearCLBufferConverter converter = new Double2ToClearCLBufferConverter();\n            converter.setCLIJ(clij);\n            return new MOCLBuffer(this, converter.convert(double2));\n        }\n        if (object instanceof double[]) {\n            Double1 double1 = new Double1((double[])object);\n            System.out.println(\"d1 size: \" + double1.data.length );\n            Double1ToClearCLBufferConverter converter = new Double1ToClearCLBufferConverter();\n            converter.setCLIJ(clij);\n            return new MOCLBuffer(this, converter.convert(double1));\n        }\n        if (object instanceof byte[][][]) {\n            Byte3 byte3 = new Byte3((byte[][][])object);\n            System.out.println(\"b3 size: \" + byte3.data.length + \"/\" + byte3.data[0].length + \"/\" + byte3.data[0][0].length );\n            Byte3ToClearCLBufferConverter converter = new Byte3ToClearCLBufferConverter();\n            converter.setCLIJ(clij);\n            return new MOCLBuffer(this, converter.convert(byte3));\n        }\n        if (object instanceof byte[][]) {\n            Byte2 byte2 = new Byte2((byte[][])object);\n            System.out.println(\"b2 size: \" + byte2.data.length + \"/\" + byte2.data[0].length );\n            Byte2ToClearCLBufferConverter converter = new Byte2ToClearCLBufferConverter();\n            converter.setCLIJ(clij);\n            return new MOCLBuffer(this, converter.convert(byte2));\n        }\n        if (object instanceof byte[]) {\n            Byte1 byte1 = new Byte1((byte[])object);\n            System.out.println(\"b1 size: \" + byte1.data.length);\n            Byte1ToClearCLBufferConverter converter = new Byte1ToClearCLBufferConverter();\n            converter.setCLIJ(clij);\n            return new MOCLBuffer(this, converter.convert(byte1));\n        }\n        throw new IllegalArgumentException(\"Conversion of \" + object +\n                \" / \" + object.getClass().getName() + \" not supported\");\n    }\n    public Object pull(MOCLBuffer input) {\n        return pull(input.buffer);\n    }\n    public Object pull(ClearCLBuffer buffer) {\n        if (buffer.getNativeType() == NativeTypeEnum.Float) {\n            if (buffer.getDimension() == 2) {\n                return new ClearCLBufferToDouble2Converter().convert(buffer).data;\n            }\n            if (buffer.getDimension() == 3) {\n                return new ClearCLBufferToDouble3Converter().convert(buffer).data;\n            }\n        }\n        throw new IllegalArgumentException(\"Conversion of \" + buffer +\n                \" / \" + buffer.getClass().getName() + \" not supported\");\n    }\n"]], "pred": {"ppl": 1.486072301864624, "ppl_lower": 1.5940848588943481, "ppl/lowercase_ppl": -1.1771187384387023, "ppl/zlib": 0.0002762458859635339, "Min_5.0% Prob": 5.64126462094924, "Min_10.0% Prob": 3.5590795909657196, "Min_20.0% Prob": 1.948518956080079, "Min_30.0% Prob": 1.316817304064684, "Min_40.0% Prob": 0.9890009750746427, "Min_50.0% Prob": 0.7925172163599121, "Min_60.0% Prob": 0.6609340768841476}}
{"hexsha": "0c12cad6dfbdeee51b9de92181dcea806f9b5436", "ext": "java", "lang": "Java", "content": "public class AFontInfo {\n\n\tpublic String m_name;\n\tpublic float m_size;\n\tpublic boolean m_isBold;\n\tpublic boolean m_isItalic;\n\tpublic boolean m_isUnicode;\n\tpublic String m_charset;\n    public float m_stretchHeight;\n    public final float[] m_padding = new float[4];\n    public final float[] m_spacing = new float[2];\n    public int m_charCount;\n    \n    public void set(AFontInfo o){\n    \tm_name = o.m_name;\n    \tm_size = o.m_size;\n    \tm_isBold = o.m_isBold;\n    \tm_isItalic = o.m_isItalic;\n    \tm_isUnicode = o.m_isUnicode;\n    \tm_charset = o.m_charset;\n    \tm_stretchHeight = o.m_stretchHeight;\n    \tm_charCount = o.m_charCount;\n    \t\n    \tSystem.arraycopy(o.m_padding, 0, m_padding, 0, 4);\n    \tSystem.arraycopy(o.m_spacing, 0, m_spacing, 0, 2);\n    }\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"AFontInfo [m_name=\" + m_name + \", m_size=\" + m_size\n\t\t\t\t+ \", m_isBold=\" + m_isBold + \", m_isItalic=\" + m_isItalic\n\t\t\t\t+ \", m_isUnicode=\" + m_isUnicode + \", m_charset=\" + m_charset\n\t\t\t\t+ \", m_stretchHeight=\" + m_stretchHeight + \", m_padding=\"\n\t\t\t\t+ Arrays.toString(m_padding) + \", m_spacing=\"\n\t\t\t\t+ Arrays.toString(m_spacing) + \", m_charCount=\" + m_charCount\n\t\t\t\t+ \"]\";\n\t}\n}", "item_id": 0, "repo": "mzhg/PostProcessingWork", "file": "testframewok/src/main/java/com/nvidia/developer/opengl/ui/AFontInfo.java", "last_update_at": "2022-03-09T06:06:30+00:00", "question_id": "0c12cad6dfbdeee51b9de92181dcea806f9b5436_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AFontInfo {\n\tpublic String m_name;\n\tpublic float m_size;\n\tpublic boolean m_isBold;\n\tpublic boolean m_isItalic;\n\tpublic boolean m_isUnicode;\n\tpublic String m_charset;\n    public float m_stretchHeight;\n    public final float[] m_padding = new float[4];\n    public final float[] m_spacing = new float[2];\n    public int m_charCount;\n    public void set(AFontInfo o){\n    \tm_name = o.m_name;\n    \tm_size = o.m_size;\n    \tm_isBold = o.m_isBold;\n    \tm_isItalic = o.m_isItalic;\n    \tm_isUnicode = o.m_isUnicode;\n    \tm_charset = o.m_charset;\n    \tm_stretchHeight = o.m_stretchHeight;\n    \tm_charCount = o.m_charCount;\n    \t\n    \tSystem.arraycopy(o.m_padding, 0, m_padding, 0, 4);\n    \tSystem.arraycopy(o.m_spacing, 0, m_spacing, 0, 2);\n    }\n\t@Override\n\tpublic String toString() {\n\t\treturn \"AFontInfo [m_name=\" + m_name + \", m_size=\" + m_size\n\t\t\t\t+ \", m_isBold=\" + m_isBold + \", m_isItalic=\" + m_isItalic\n\t\t\t\t+ \", m_isUnicode=\" + m_isUnicode + \", m_charset=\" + m_charset\n\t\t\t\t+ \", m_stretchHeight=\" + m_stretchHeight + \", m_padding=\"\n\t\t\t\t+ Arrays.toString(m_padding) + \", m_spacing=\"\n\t\t\t\t+ Arrays.toString(m_spacing) + \", m_charCount=\" + m_charCount\n\t\t\t\t+ \"]\";\n\t}\n"]], "pred": {"ppl": 1.3470041751861572, "ppl_lower": 1.5152802467346191, "ppl/lowercase_ppl": -1.395180011361464, "ppl/zlib": 0.0007337019631575151, "Min_5.0% Prob": 4.230849370956421, "Min_10.0% Prob": 2.7403987360000612, "Min_20.0% Prob": 1.4765485615283251, "Min_30.0% Prob": 0.9900661593808836, "Min_40.0% Prob": 0.7457584251825748, "Min_50.0% Prob": 0.5954511176063938, "Min_60.0% Prob": 0.49704699597220453}}
{"hexsha": "c71602557e32261ee53751d465f43707fce0f63e", "ext": "java", "lang": "Java", "content": "public class ListModifiedIndexEntriesCommand extends GitCommand {\n\n    private final File[] roots;\n    private final ProgressMonitor monitor;\n    private final FileListener listener;\n    private final Set<File> files;\n\n    public ListModifiedIndexEntriesCommand (Repository repository, GitClassFactory gitFactory, File[] roots, ProgressMonitor monitor, FileListener listener) {\n        super(repository, gitFactory, monitor);\n        this.roots = roots;\n        this.monitor = monitor;\n        this.listener = listener;\n        this.files = new HashSet<File>();\n    }\n\n    @Override\n    protected void run () throws GitException {\n        Repository repository = getRepository();\n        try {\n            DirCache cache = repository.readDirCache();\n            try {\n                String workTreePath = repository.getWorkTree().getAbsolutePath();\n                Collection<PathFilter> pathFilters = Utils.getPathFilters(repository.getWorkTree(), roots);\n                TreeWalk treeWalk = new TreeWalk(repository);\n                if (!pathFilters.isEmpty()) {\n                    treeWalk.setFilter(PathFilterGroup.create(pathFilters));\n                }\n                treeWalk.setRecursive(true);\n                treeWalk.reset();\n                ObjectId headId = repository.resolve(Constants.HEAD);\n                if (headId != null) {\n                    treeWalk.addTree(new RevWalk(repository).parseTree(headId));\n                } else {\n                    treeWalk.addTree(new EmptyTreeIterator());\n                }\n                // Index\n                treeWalk.addTree(new DirCacheIterator(cache));\n                final int T_HEAD = 0;\n                final int T_INDEX = 1;\n                while (treeWalk.next() && !monitor.isCanceled()) {\n                    String path = treeWalk.getPathString();\n                    File file = new File(workTreePath + File.separator + path);\n                    int mHead = treeWalk.getRawMode(T_HEAD);\n                    int mIndex = treeWalk.getRawMode(T_INDEX);\n                    if (mHead != mIndex || !treeWalk.idEqual(T_HEAD, T_INDEX)) {\n                        files.add(file);\n                        listener.notifyFile(file, path);\n                    }\n                }\n            } finally {\n                cache.unlock();\n            }\n        } catch (CorruptObjectException ex) {\n            throw new GitException(ex);\n        } catch (IOException ex) {\n            throw new GitException(ex);\n        }\n    }\n\n    @Override\n    protected String getCommandDescription () {\n        StringBuilder sb = new StringBuilder(\"git status\"); //NOI18N\n        for (File root : roots) {\n            sb.append(\" \").append(root.getAbsolutePath());\n        }\n        return sb.toString();\n    }\n\n    public File[] getFiles () {\n        return files.toArray(new File[files.size()]);\n    }\n}", "item_id": 0, "repo": "arusinha/incubator-netbeans", "file": "ide/libs.git/src/org/netbeans/libs/git/jgit/commands/ListModifiedIndexEntriesCommand.java", "last_update_at": "2022-03-30T04:46:14+00:00", "question_id": "c71602557e32261ee53751d465f43707fce0f63e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ListModifiedIndexEntriesCommand extends GitCommand {\n    private final File[] roots;\n    private final ProgressMonitor monitor;\n    private final FileListener listener;\n    private final Set<File> files;\n    public ListModifiedIndexEntriesCommand (Repository repository, GitClassFactory gitFactory, File[] roots, ProgressMonitor monitor, FileListener listener) {\n        super(repository, gitFactory, monitor);\n        this.roots = roots;\n        this.monitor = monitor;\n        this.listener = listener;\n        this.files = new HashSet<File>();\n    }\n    @Override\n    protected void run () throws GitException {\n        Repository repository = getRepository();\n        try {\n            DirCache cache = repository.readDirCache();\n            try {\n                String workTreePath = repository.getWorkTree().getAbsolutePath();\n                Collection<PathFilter> pathFilters = Utils.getPathFilters(repository.getWorkTree(), roots);\n                TreeWalk treeWalk = new TreeWalk(repository);\n                if (!pathFilters.isEmpty()) {\n                    treeWalk.setFilter(PathFilterGroup.create(pathFilters));\n                }\n                treeWalk.setRecursive(true);\n                treeWalk.reset();\n                ObjectId headId = repository.resolve(Constants.HEAD);\n                if (headId != null) {\n                    treeWalk.addTree(new RevWalk(repository).parseTree(headId));\n                } else {\n                    treeWalk.addTree(new EmptyTreeIterator());\n                }\n                // Index\n                treeWalk.addTree(new DirCacheIterator(cache));\n                final int T_HEAD = 0;\n                final int T_INDEX = 1;\n                while (treeWalk.next() && !monitor.isCanceled()) {\n                    String path = treeWalk.getPathString();\n                    File file = new File(workTreePath + File.separator + path);\n                    int mHead = treeWalk.getRawMode(T_HEAD);\n                    int mIndex = treeWalk.getRawMode(T_INDEX);\n                    if (mHead != mIndex || !treeWalk.idEqual(T_HEAD, T_INDEX)) {\n                        files.add(file);\n                        listener.notifyFile(file, path);\n                    }\n                }\n            } finally {\n                cache.unlock();\n            }\n        } catch (CorruptObjectException ex) {\n            throw new GitException(ex);\n        } catch (IOException ex) {\n            throw new GitException(ex);\n        }\n    }\n    @Override\n    protected String getCommandDescription () {\n        StringBuilder sb = new StringBuilder(\"git status\"); //NOI18N\n        for (File root : roots) {\n            sb.append(\" \").append(root.getAbsolutePath());\n        }\n        return sb.toString();\n    }\n    public File[] getFiles () {\n        return files.toArray(new File[files.size()]);\n    }\n"]], "pred": {"ppl": 1.5510284900665283, "ppl_lower": 2.114682197570801, "ppl/lowercase_ppl": -1.706250617574467, "ppl/zlib": 0.000463972783153189, "Min_5.0% Prob": 4.845287024974823, "Min_10.0% Prob": 3.39552550845676, "Min_20.0% Prob": 2.045561188004083, "Min_30.0% Prob": 1.433116483743544, "Min_40.0% Prob": 1.0895933679292082, "Min_50.0% Prob": 0.8757912727874807, "Min_60.0% Prob": 0.7309992413874069}}
{"hexsha": "2e5e147d5189cf6082af9d03cbbe31c46a1d667a", "ext": "java", "lang": "Java", "content": "class MojaApl1 extends Frame {\n\n    MojaApl1(String naslov) {\n        super(naslov);\n        setLayout(new FlowLayout());\n        add(new Button(\"OK\"));\n        add(new Button(\"Ponovo\"));\n        add(new Button(\"Prekini\"));\n    }\n\n    public static void main(String args[]) {\n        MojaApl1 apl = new MojaApl1(\"Kako izgledam?\");\n        apl.resize(300,300);\n        apl.setLocation(400,400);\n        apl.show();\n          for (int i=1;i<100000000; i++)Math.random();\n        apl.hide();      \n        System.exit(0);\n        \n    }\n   \n}", "item_id": 0, "repo": "MatfOOP-I/primeri-predavanja-2016-17", "file": "src/v15a/v03/MojaApl1.java", "last_update_at": "2022-01-03T14:21:00+00:00", "question_id": "2e5e147d5189cf6082af9d03cbbe31c46a1d667a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class MojaApl1 extends Frame {\n    MojaApl1(String naslov) {\n        super(naslov);\n        setLayout(new FlowLayout());\n        add(new Button(\"OK\"));\n        add(new Button(\"Ponovo\"));\n        add(new Button(\"Prekini\"));\n    }\n    public static void main(String args[]) {\n        MojaApl1 apl = new MojaApl1(\"Kako izgledam?\");\n        apl.resize(300,300);\n        apl.setLocation(400,400);\n        apl.show();\n          for (int i=1;i<100000000; i++)Math.random();\n        apl.hide();      \n        System.exit(0);\n    }\n"]], "pred": {"ppl": 2.8245937824249268, "ppl_lower": 3.4530258178710938, "ppl/lowercase_ppl": -1.1934641671603956, "ppl/zlib": 0.0037896516803912258, "Min_5.0% Prob": 8.54454836845398, "Min_10.0% Prob": 6.4835971117019655, "Min_20.0% Prob": 4.3691022247076035, "Min_30.0% Prob": 3.238006407022476, "Min_40.0% Prob": 2.536060770601034, "Min_50.0% Prob": 2.062556401193142, "Min_60.0% Prob": 1.7271754614853612}}
{"hexsha": "3cb1672ac4068fdc3bdb136a6273f1daeba3a1a4", "ext": "java", "lang": "Java", "content": "public class IsSquare {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"\u00c9 \" + isSquare(4));\n\t}\n\n\tpublic static boolean isSquare(int num) {\n\t\tif(num == 1 || num == 0)\n\t\t\treturn true;\n\t\tdouble square = num / 2;\n\t\tdouble c = square;\n\n\t\tdo {\n\t\t\tc = square;\n\t\t\tsquare = (c + (num / c)) / 2;\n\t\t} while ((c - square) != 0);\n\n\t\tif(square*square == num) \n\t\t\treturn true;\n\t\treturn false;\n\t}\n}", "item_id": 0, "repo": "CarbonDDR/al-go-rithms", "file": "math/Check_is_square/java/check_is_square.java", "last_update_at": "2022-03-30T17:07:58+00:00", "question_id": "3cb1672ac4068fdc3bdb136a6273f1daeba3a1a4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IsSquare {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"\u00c9 \" + isSquare(4));\n\t}\n\tpublic static boolean isSquare(int num) {\n\t\tif(num == 1 || num == 0)\n\t\t\treturn true;\n\t\tdouble square = num / 2;\n\t\tdouble c = square;\n\t\tdo {\n\t\t\tc = square;\n\t\t\tsquare = (c + (num / c)) / 2;\n\t\t} while ((c - square) != 0);\n\t\tif(square*square == num) \n\t\t\treturn true;\n\t\treturn false;\n\t}\n"]], "pred": {"ppl": 2.2042715549468994, "ppl_lower": 2.579258441925049, "ppl/lowercase_ppl": -1.1987669735901008, "ppl/zlib": 0.0033777653579035723, "Min_5.0% Prob": 6.748665988445282, "Min_10.0% Prob": 4.763487100601196, "Min_20.0% Prob": 3.3408827711554134, "Min_30.0% Prob": 2.507699931369108, "Min_40.0% Prob": 1.9546548489700346, "Min_50.0% Prob": 1.5663543269471374, "Min_60.0% Prob": 1.314088669415672}}
{"hexsha": "2339cd96ccf7d09c03ebd8f3b8526b46b481fa02", "ext": "java", "lang": "Java", "content": "@ApplicationScoped @Alternative\n@SuppressWarnings(\"nls\")\npublic class TestMetricsAccessor implements IMetricsAccessor {\n\n    /**\n     * Constructor.\n     */\n    public TestMetricsAccessor() {\n    }\n\n    /**\n     * @see io.apiman.manager.api.core.IMetricsAccessor#getUsage(java.lang.String, java.lang.String, java.lang.String, io.apiman.manager.api.beans.metrics.HistogramIntervalType, java.util.Date, java.util.Date)\n     */\n    @Override\n    public UsageHistogramBean getUsage(String organizationId, String apiId, String version,\n            HistogramIntervalType interval, DateTime from, DateTime to) {\n        UsageHistogramBean rval = new UsageHistogramBean();\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T00:00:00.000Z\", 17));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T01:00:00.000Z\", 1));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T02:00:00.000Z\", 1));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T03:00:00.000Z\", 29));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T04:00:00.000Z\", 19));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T05:00:00.000Z\", 52));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T06:00:00.000Z\", 6));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T07:00:00.000Z\", 4));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T08:00:00.000Z\", 5));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T09:00:00.000Z\", 27));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T10:00:00.000Z\", 19));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T11:00:00.000Z\", 52));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T12:00:00.000Z\", 6));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T13:00:00.000Z\", 4));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T14:00:00.000Z\", 2));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T15:00:00.000Z\", 17));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T16:00:00.000Z\", 1));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T17:00:00.000Z\", 1));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T18:00:00.000Z\", 29));\n        return rval;\n    }\n\n    /**\n     * @see io.apiman.manager.api.core.IMetricsAccessor#getUsagePerClient(java.lang.String, java.lang.String, java.lang.String, java.util.Date, java.util.Date)\n     */\n    @Override\n    public UsagePerClientBean getUsagePerClient(String organizationId, String apiId, String version,\n            DateTime from, DateTime to) {\n        UsagePerClientBean rval = new UsagePerClientBean();\n        rval.getData().put(\"my-client\", 120384L);\n        rval.getData().put(\"foo-client\", 1263L);\n        rval.getData().put(\"bar-client\", 726392L);\n        return rval;\n    }\n\n    /**\n     * @see io.apiman.manager.api.core.IMetricsAccessor#getUsagePerPlan(java.lang.String, java.lang.String, java.lang.String, java.util.Date, java.util.Date)\n     */\n    @Override\n    public UsagePerPlanBean getUsagePerPlan(String organizationId, String apiId, String version,\n            DateTime from, DateTime to) {\n        UsagePerPlanBean rval = new UsagePerPlanBean();\n        rval.getData().put(\"Gold\", 120384L);\n        rval.getData().put(\"Silver\", 921263L);\n        rval.getData().put(\"Platinum\", 726392L);\n        return rval;\n    }\n\n    /**\n     * @see io.apiman.manager.api.core.IMetricsAccessor#getResponseStats(java.lang.String, java.lang.String, java.lang.String, io.apiman.manager.api.beans.metrics.HistogramIntervalType, org.joda.time.DateTime, org.joda.time.DateTime)\n     */\n    @Override\n    public ResponseStatsHistogramBean getResponseStats(String organizationId, String apiId,\n            String version, HistogramIntervalType interval, DateTime from, DateTime to) {\n        ResponseStatsHistogramBean rval = new ResponseStatsHistogramBean();\n        return rval;\n    }\n\n    /**\n     * @see io.apiman.manager.api.core.IMetricsAccessor#getResponseStatsSummary(java.lang.String, java.lang.String, java.lang.String, org.joda.time.DateTime, org.joda.time.DateTime)\n     */\n    @Override\n    public ResponseStatsSummaryBean getResponseStatsSummary(String organizationId, String apiId,\n            String version, DateTime from, DateTime to) {\n        ResponseStatsSummaryBean rval = new ResponseStatsSummaryBean();\n        return rval;\n    }\n\n    /**\n     * @see io.apiman.manager.api.core.IMetricsAccessor#getResponseStatsPerClient(java.lang.String, java.lang.String, java.lang.String, org.joda.time.DateTime, org.joda.time.DateTime)\n     */\n    @Override\n    public ResponseStatsPerClientBean getResponseStatsPerClient(String organizationId, String apiId,\n            String version, DateTime from, DateTime to) {\n        ResponseStatsPerClientBean rval = new ResponseStatsPerClientBean();\n        return rval;\n    }\n\n    /**\n     * @see io.apiman.manager.api.core.IMetricsAccessor#getResponseStatsPerPlan(java.lang.String, java.lang.String, java.lang.String, org.joda.time.DateTime, org.joda.time.DateTime)\n     */\n    @Override\n    public ResponseStatsPerPlanBean getResponseStatsPerPlan(String organizationId, String apiId,\n            String version, DateTime from, DateTime to) {\n        ResponseStatsPerPlanBean rval = new ResponseStatsPerPlanBean();\n        return rval;\n    }\n\n    /**\n     * @see io.apiman.manager.api.core.IMetricsAccessor#getClientUsagePerApi(java.lang.String, java.lang.String, java.lang.String, org.joda.time.DateTime, org.joda.time.DateTime)\n     */\n    @Override\n    public ClientUsagePerApiBean getClientUsagePerApi(String organizationId, String clientId,\n            String version, DateTime from, DateTime to) {\n        ClientUsagePerApiBean rval = new ClientUsagePerApiBean();\n        return rval;\n    }\n\n}", "item_id": 0, "repo": "shachindrasingh/apiman", "file": "manager/test/api/src/main/java/io/apiman/manager/test/server/TestMetricsAccessor.java", "last_update_at": "2022-03-15T11:22:03+00:00", "question_id": "2339cd96ccf7d09c03ebd8f3b8526b46b481fa02_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ApplicationScoped @Alternative\n@SuppressWarnings(\"nls\")\npublic class TestMetricsAccessor implements IMetricsAccessor {\n    /**\n     * Constructor.\n     */\n    public TestMetricsAccessor() {\n    }\n    /**\n     * @see io.apiman.manager.api.core.IMetricsAccessor#getUsage(java.lang.String, java.lang.String, java.lang.String, io.apiman.manager.api.beans.metrics.HistogramIntervalType, java.util.Date, java.util.Date)\n     */\n    @Override\n    public UsageHistogramBean getUsage(String organizationId, String apiId, String version,\n            HistogramIntervalType interval, DateTime from, DateTime to) {\n        UsageHistogramBean rval = new UsageHistogramBean();\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T00:00:00.000Z\", 17));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T01:00:00.000Z\", 1));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T02:00:00.000Z\", 1));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T03:00:00.000Z\", 29));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T04:00:00.000Z\", 19));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T05:00:00.000Z\", 52));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T06:00:00.000Z\", 6));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T07:00:00.000Z\", 4));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T08:00:00.000Z\", 5));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T09:00:00.000Z\", 27));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T10:00:00.000Z\", 19));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T11:00:00.000Z\", 52));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T12:00:00.000Z\", 6));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T13:00:00.000Z\", 4));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T14:00:00.000Z\", 2));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T15:00:00.000Z\", 17));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T16:00:00.000Z\", 1));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T17:00:00.000Z\", 1));\n        rval.getData().add(new UsageDataPoint(\"2015-06-01T18:00:00.000Z\", 29));\n        return rval;\n    }\n    /**\n     * @see io.apiman.manager.api.core.IMetricsAccessor#getUsagePerClient(java.lang.String, java.lang.String, java.lang.String, java.util.Date, java.util.Date)\n     */\n    @Override\n    public UsagePerClientBean getUsagePerClient(String organizationId, String apiId, String version,\n            DateTime from, DateTime to) {\n        UsagePerClientBean rval = new UsagePerClientBean();\n        rval.getData().put(\"my-client\", 120384L);\n        rval.getData().put(\"foo-client\", 1263L);\n        rval.getData().put(\"bar-client\", 726392L);\n        return rval;\n    }\n    /**\n     * @see io.apiman.manager.api.core.IMetricsAccessor#getUsagePerPlan(java.lang.String, java.lang.String, java.lang.String, java.util.Date, java.util.Date)\n     */\n    @Override\n    public UsagePerPlanBean getUsagePerPlan(String organizationId, String apiId, String version,\n            DateTime from, DateTime to) {\n        UsagePerPlanBean rval = new UsagePerPlanBean();\n        rval.getData().put(\"Gold\", 120384L);\n        rval.getData().put(\"Silver\", 921263L);\n        rval.getData().put(\"Platinum\", 726392L);\n        return rval;\n    }\n    /**\n     * @see io.apiman.manager.api.core.IMetricsAccessor#getResponseStats(java.lang.String, java.lang.String, java.lang.String, io.apiman.manager.api.beans.metrics.HistogramIntervalType, org.joda.time.DateTime, org.joda.time.DateTime)\n     */\n    @Override\n    public ResponseStatsHistogramBean getResponseStats(String organizationId, String apiId,\n            String version, HistogramIntervalType interval, DateTime from, DateTime to) {\n        ResponseStatsHistogramBean rval = new ResponseStatsHistogramBean();\n        return rval;\n    }\n    /**\n     * @see io.apiman.manager.api.core.IMetricsAccessor#getResponseStatsSummary(java.lang.String, java.lang.String, java.lang.String, org.joda.time.DateTime, org.joda.time.DateTime)\n     */\n    @Override\n    public ResponseStatsSummaryBean getResponseStatsSummary(String organizationId, String apiId,\n            String version, DateTime from, DateTime to) {\n        ResponseStatsSummaryBean rval = new ResponseStatsSummaryBean();\n        return rval;\n    }\n    /**\n     * @see io.apiman.manager.api.core.IMetricsAccessor#getResponseStatsPerClient(java.lang.String, java.lang.String, java.lang.String, org.joda.time.DateTime, org.joda.time.DateTime)\n     */\n    @Override\n    public ResponseStatsPerClientBean getResponseStatsPerClient(String organizationId, String apiId,\n            String version, DateTime from, DateTime to) {\n        ResponseStatsPerClientBean rval = new ResponseStatsPerClientBean();\n        return rval;\n    }\n    /**\n     * @see io.apiman.manager.api.core.IMetricsAccessor#getResponseStatsPerPlan(java.lang.String, java.lang.String, java.lang.String, org.joda.time.DateTime, org.joda.time.DateTime)\n     */\n    @Override\n    public ResponseStatsPerPlanBean getResponseStatsPerPlan(String organizationId, String apiId,\n            String version, DateTime from, DateTime to) {\n        ResponseStatsPerPlanBean rval = new ResponseStatsPerPlanBean();\n        return rval;\n    }\n    /**\n     * @see io.apiman.manager.api.core.IMetricsAccessor#getClientUsagePerApi(java.lang.String, java.lang.String, java.lang.String, org.joda.time.DateTime, org.joda.time.DateTime)\n     */\n    @Override\n    public ClientUsagePerApiBean getClientUsagePerApi(String organizationId, String clientId,\n            String version, DateTime from, DateTime to) {\n        ClientUsagePerApiBean rval = new ClientUsagePerApiBean();\n        return rval;\n    }\n"]], "pred": {"ppl": 1.2506710290908813, "ppl_lower": 1.4083067178726196, "ppl/lowercase_ppl": -1.5307033284539178, "ppl/zlib": 0.00029277517087545566, "Min_5.0% Prob": 3.5388412662580904, "Min_10.0% Prob": 2.135812108423196, "Min_20.0% Prob": 1.1176169005898284, "Min_30.0% Prob": 0.7474315349542189, "Min_40.0% Prob": 0.5594237479009816, "Min_50.0% Prob": 0.4477845944581163, "Min_60.0% Prob": 0.37328214954495303}}
{"hexsha": "7bb64d98e72cc58319bf73e2b485510062895646", "ext": "java", "lang": "Java", "content": "public class ResourceRequestKey implements RequestKey {\n\n    private Resources mResources;\n    private int mResId;\n\n    /**\n     * Create a new request key with the given resource id. A resId of 0 will\n     * return a null request key.\n     */\n    public static ResourceRequestKey from(Resources res, int resId) {\n        if (resId != 0) {\n            return new ResourceRequestKey(res, resId);\n        }\n        return null;\n    }\n\n    private ResourceRequestKey(Resources res, int resId) {\n        mResources = res;\n        mResId = resId;\n    }\n\n    @Override\n    public Cancelable createFileDescriptorFactoryAsync(RequestKey requestKey, Callback callback) {\n        return null;\n    }\n\n    @Override\n    public InputStream createInputStream() throws IOException {\n        return mResources.openRawResource(mResId);\n    }\n\n    @Override\n    public boolean hasOrientationExif() throws IOException {\n        return false;\n    }\n\n    // START AUTO-GENERATED CODE\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        ResourceRequestKey that = (ResourceRequestKey) o;\n\n        if (mResId != that.mResId) {\n            return false;\n        }\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        return mResId;\n    }\n\n    // END AUTO-GENERATED CODE\n\n    @Override\n    public String toString() {\n        return String.format(\"ResourceRequestKey: %d\", mResId);\n    }\n}", "item_id": 0, "repo": "Keneral/aframeworks", "file": "opt/bitmap/src/com/android/bitmap/ResourceRequestKey.java", "last_update_at": "2022-03-31T08:39:18+00:00", "question_id": "7bb64d98e72cc58319bf73e2b485510062895646_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ResourceRequestKey implements RequestKey {\n    private Resources mResources;\n    private int mResId;\n    /**\n     * Create a new request key with the given resource id. A resId of 0 will\n     * return a null request key.\n     */\n    public static ResourceRequestKey from(Resources res, int resId) {\n        if (resId != 0) {\n            return new ResourceRequestKey(res, resId);\n        }\n        return null;\n    }\n    private ResourceRequestKey(Resources res, int resId) {\n        mResources = res;\n        mResId = resId;\n    }\n    @Override\n    public Cancelable createFileDescriptorFactoryAsync(RequestKey requestKey, Callback callback) {\n        return null;\n    }\n    @Override\n    public InputStream createInputStream() throws IOException {\n        return mResources.openRawResource(mResId);\n    }\n    @Override\n    public boolean hasOrientationExif() throws IOException {\n        return false;\n    }\n    // START AUTO-GENERATED CODE\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        ResourceRequestKey that = (ResourceRequestKey) o;\n        if (mResId != that.mResId) {\n            return false;\n        }\n        return true;\n    }\n    @Override\n    public int hashCode() {\n        return mResId;\n    }\n    // END AUTO-GENERATED CODE\n    @Override\n    public String toString() {\n        return String.format(\"ResourceRequestKey: %d\", mResId);\n    }\n"]], "pred": {"ppl": 1.9188920259475708, "ppl_lower": 1.9778088331222534, "ppl/lowercase_ppl": -1.0464008093056807, "ppl/zlib": 0.0011936775634649164, "Min_5.0% Prob": 8.239330041976203, "Min_10.0% Prob": 5.4529554372610045, "Min_20.0% Prob": 3.124940693035893, "Min_30.0% Prob": 2.166347006020638, "Min_40.0% Prob": 1.6290564409553492, "Min_50.0% Prob": 1.3025344087883248, "Min_60.0% Prob": 1.088480431610144}}
{"hexsha": "810eefc5dfc6c24d0d668b4652bd64d9a534bf0d", "ext": "java", "lang": "Java", "content": "@EnabledIfSystemProperty(named = \"accountName\", matches = \".*\",\n                         disabledReason = \"Make sure to supply azure accessKey or accountName, e.g:  mvn verify -DaccountName=myacc -DaccessKey=mykey\")\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\nclass QueueOperationsIT extends CamelTestSupport {\n\n    private QueueConfiguration configuration;\n    private QueueServiceClientWrapper serviceClientWrapper;\n\n    @BeforeAll\n    public void setup() throws Exception {\n        final Properties properties = QueueTestUtils.loadAzureAccessFromJvmEnv();\n\n        configuration = new QueueConfiguration();\n        configuration.setAccountName(properties.getProperty(\"account_name\"));\n        configuration.setAccessKey(properties.getProperty(\"access_key\"));\n        configuration.setMaxMessages(5);\n\n        final QueueServiceClient client = QueueClientFactory.createQueueServiceClient(configuration);\n\n        serviceClientWrapper = new QueueServiceClientWrapper(client);\n    }\n\n    @Test\n    public void testCreateDeleteQueue() {\n        final String queueName = RandomStringUtils.randomAlphabetic(10).toLowerCase();\n        final QueueClientWrapper clientWrapper = serviceClientWrapper.getQueueClientWrapper(queueName);\n        final QueueOperations operations = new QueueOperations(configuration, clientWrapper);\n\n        // test create queue\n        final QueueOperationResponse response = operations.createQueue(null);\n\n        assertNotNull(response);\n        assertNotNull(response.getHeaders());\n        assertTrue((boolean) response.getBody());\n        assertTrue(serviceClientWrapper.listQueues(null, null)\n                .stream()\n                .map(QueueItem::getName)\n                .collect(Collectors.toList())\n                .contains(queueName));\n\n        // delete and test\n        final QueueOperationResponse response2 = operations.deleteQueue(null);\n        assertNotNull(response2);\n        assertNotNull(response2.getHeaders());\n        assertTrue((boolean) response2.getBody());\n        assertFalse(serviceClientWrapper.listQueues(null, null)\n                .stream()\n                .map(QueueItem::getName)\n                .collect(Collectors.toList())\n                .contains(queueName));\n    }\n\n    @Test\n    public void testSendMessageAndClearQueue() {\n        final String queueName = RandomStringUtils.randomAlphabetic(10).toLowerCase();\n        final QueueClientWrapper clientWrapper = serviceClientWrapper.getQueueClientWrapper(queueName);\n        final QueueOperations operations = new QueueOperations(configuration, clientWrapper);\n\n        final Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"testing message\");\n\n        final QueueOperationResponse response = operations.sendMessage(exchange);\n\n        assertNotNull(response);\n        assertNotNull(response.getHeaders());\n        assertTrue((boolean) response.getBody());\n        assertNotNull(response.getHeaders().get(QueueConstants.MESSAGE_ID));\n        assertNotNull(response.getHeaders().get(QueueConstants.EXPIRATION_TIME));\n        assertNotNull(response.getHeaders().get(QueueConstants.POP_RECEIPT));\n\n        final QueueMessageItem messageItem\n                = clientWrapper.receiveMessages(1, Duration.ofSeconds(30), null).stream().findFirst().get();\n\n        assertEquals(\"testing message\", messageItem.getBody().toString());\n\n        // test clear queue\n        operations.clearQueue(exchange);\n\n        assertTrue(clientWrapper.receiveMessages(1, null, null).isEmpty());\n\n        // delete testing queue\n        operations.deleteQueue(exchange);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testReceiveAndPeekMessages() {\n        final QueueOperations operations = getQueueOperations();\n\n        final Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"testing message-1\");\n        operations.sendMessage(exchange);\n\n        exchange.getIn().setBody(\"testing message-2\");\n        operations.sendMessage(exchange);\n\n        exchange.getIn().setBody(\"testing message-3\");\n        operations.sendMessage(exchange);\n\n        // test peek messages\n        final QueueOperationResponse peekResponse = operations.peekMessages(exchange);\n        final List<PeekedMessageItem> peekedMessageItems = (List<PeekedMessageItem>) peekResponse.getBody();\n\n        assertEquals(3, peekedMessageItems.size());\n        assertEquals(\"testing message-1\", peekedMessageItems.get(0).getBody().toString());\n        assertEquals(\"testing message-2\", peekedMessageItems.get(1).getBody().toString());\n        assertEquals(\"testing message-3\", peekedMessageItems.get(2).getBody().toString());\n\n        // test receive message\n        exchange.getIn().setHeader(QueueConstants.MAX_MESSAGES, 1);\n        final QueueOperationResponse receiveResponse = operations.receiveMessages(exchange);\n        final List<QueueMessageItem> receivedMessageItems = (List<QueueMessageItem>) receiveResponse.getBody();\n\n        assertEquals(1, receivedMessageItems.size());\n        assertEquals(\"testing message-1\", receivedMessageItems.get(0).getBody().toString());\n\n        // make sure the message has been deQueued\n        assertEquals(2, ((List<PeekedMessageItem>) operations.peekMessages(null).getBody()).size());\n\n        // delete testing queue\n        operations.deleteQueue(exchange);\n    }\n\n    @Test\n    public void testDeleteMessages() {\n        final QueueOperations operations = getQueueOperations();\n\n        final Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"testing message-1\");\n        final QueueOperationResponse sentMessage1 = operations.sendMessage(exchange);\n\n        exchange.getIn().setBody(\"testing message-2\");\n        final QueueOperationResponse sentMessage2 = operations.sendMessage(exchange);\n\n        // test delete message\n        assertThrows(IllegalArgumentException.class, () -> operations.deleteMessage(exchange));\n        exchange.getIn().setHeader(QueueConstants.MESSAGE_ID, sentMessage1.getHeaders().get(QueueConstants.MESSAGE_ID));\n        // we still need pop receipt\n        assertThrows(IllegalArgumentException.class, () -> operations.deleteMessage(exchange));\n        // delete message now\n        exchange.getIn().setHeader(QueueConstants.POP_RECEIPT, sentMessage1.getHeaders().get(QueueConstants.POP_RECEIPT));\n        operations.deleteMessage(exchange);\n\n        // check the what we have in the queue\n        final QueueOperationResponse peekResponse = operations.peekMessages(exchange);\n        @SuppressWarnings(\"unchecked\")\n        final List<PeekedMessageItem> peekedMessageItems = (List<PeekedMessageItem>) peekResponse.getBody();\n\n        assertEquals(1, peekedMessageItems.size());\n        assertEquals(sentMessage2.getHeaders().get(QueueConstants.MESSAGE_ID), peekedMessageItems.get(0).getMessageId());\n\n        // delete testing queue\n        operations.deleteQueue(exchange);\n    }\n\n    @Test\n    public void testUpdateMessage() {\n        final QueueOperations operations = getQueueOperations();\n\n        final Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"testing message-1\");\n        final QueueOperationResponse sentMessage = operations.sendMessage(exchange);\n\n        // let's do our update\n        exchange.getIn().setBody(\"updated message-1\");\n        exchange.getIn().setHeader(QueueConstants.POP_RECEIPT, sentMessage.getHeaders().get(QueueConstants.POP_RECEIPT));\n        exchange.getIn().setHeader(QueueConstants.MESSAGE_ID, sentMessage.getHeaders().get(QueueConstants.MESSAGE_ID));\n        exchange.getIn().setHeader(QueueConstants.VISIBILITY_TIMEOUT, Duration.ofMillis(10));\n\n        final QueueOperationResponse updatedMessage = operations.updateMessage(exchange);\n\n        assertNotNull(updatedMessage);\n        assertNotNull(updatedMessage.getHeaders());\n        assertTrue((boolean) updatedMessage.getBody());\n        assertNotNull(updatedMessage.getHeaders().get(QueueConstants.POP_RECEIPT));\n        assertNotNull(updatedMessage.getHeaders().get(QueueConstants.TIME_NEXT_VISIBLE));\n\n        // check the what we have in the queue\n        final QueueOperationResponse peekResponse = operations.peekMessages(exchange);\n        @SuppressWarnings(\"unchecked\")\n        final List<PeekedMessageItem> peekedMessageItems = (List<PeekedMessageItem>) peekResponse.getBody();\n\n        assertEquals(1, peekedMessageItems.size());\n        assertEquals(\"updated message-1\", peekedMessageItems.get(0).getBody().toString());\n\n        // delete testing queue\n        operations.deleteQueue(exchange);\n    }\n\n    @AfterAll\n    public void tearDown() {\n        // make sure to clean everything\n        final List<QueueItem> queues = serviceClientWrapper.listQueues(null, null);\n\n        if (queues.size() > 0) {\n            queues.forEach(queueItem -> serviceClientWrapper.getQueueClientWrapper(queueItem.getName()).delete(null));\n        }\n    }\n\n    private QueueOperations getQueueOperations() {\n        final String queueName = RandomStringUtils.randomAlphabetic(10).toLowerCase();\n        final QueueClientWrapper clientWrapper = serviceClientWrapper.getQueueClientWrapper(queueName);\n        return new QueueOperations(configuration, clientWrapper);\n    }\n}", "item_id": 0, "repo": "eidottermihi/camel", "file": "components/camel-azure/camel-azure-storage-queue/src/test/java/org/apache/camel/component/azure/storage/queue/operations/integration/QueueOperationsIT.java", "last_update_at": "2022-03-31T14:32:11+00:00", "question_id": "810eefc5dfc6c24d0d668b4652bd64d9a534bf0d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@EnabledIfSystemProperty(named = \"accountName\", matches = \".*\",\n                         disabledReason = \"Make sure to supply azure accessKey or accountName, e.g:  mvn verify -DaccountName=myacc -DaccessKey=mykey\")\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\nclass QueueOperationsIT extends CamelTestSupport {\n    private QueueConfiguration configuration;\n    private QueueServiceClientWrapper serviceClientWrapper;\n    @BeforeAll\n    public void setup() throws Exception {\n        final Properties properties = QueueTestUtils.loadAzureAccessFromJvmEnv();\n        configuration = new QueueConfiguration();\n        configuration.setAccountName(properties.getProperty(\"account_name\"));\n        configuration.setAccessKey(properties.getProperty(\"access_key\"));\n        configuration.setMaxMessages(5);\n        final QueueServiceClient client = QueueClientFactory.createQueueServiceClient(configuration);\n        serviceClientWrapper = new QueueServiceClientWrapper(client);\n    }\n    @Test\n    public void testCreateDeleteQueue() {\n        final String queueName = RandomStringUtils.randomAlphabetic(10).toLowerCase();\n        final QueueClientWrapper clientWrapper = serviceClientWrapper.getQueueClientWrapper(queueName);\n        final QueueOperations operations = new QueueOperations(configuration, clientWrapper);\n        // test create queue\n        final QueueOperationResponse response = operations.createQueue(null);\n        assertNotNull(response);\n        assertNotNull(response.getHeaders());\n        assertTrue((boolean) response.getBody());\n        assertTrue(serviceClientWrapper.listQueues(null, null)\n                .stream()\n                .map(QueueItem::getName)\n                .collect(Collectors.toList())\n                .contains(queueName));\n        // delete and test\n        final QueueOperationResponse response2 = operations.deleteQueue(null);\n        assertNotNull(response2);\n        assertNotNull(response2.getHeaders());\n        assertTrue((boolean) response2.getBody());\n        assertFalse(serviceClientWrapper.listQueues(null, null)\n                .stream()\n                .map(QueueItem::getName)\n                .collect(Collectors.toList())\n                .contains(queueName));\n    }\n    @Test\n    public void testSendMessageAndClearQueue() {\n        final String queueName = RandomStringUtils.randomAlphabetic(10).toLowerCase();\n        final QueueClientWrapper clientWrapper = serviceClientWrapper.getQueueClientWrapper(queueName);\n        final QueueOperations operations = new QueueOperations(configuration, clientWrapper);\n        final Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"testing message\");\n        final QueueOperationResponse response = operations.sendMessage(exchange);\n        assertNotNull(response);\n        assertNotNull(response.getHeaders());\n        assertTrue((boolean) response.getBody());\n        assertNotNull(response.getHeaders().get(QueueConstants.MESSAGE_ID));\n        assertNotNull(response.getHeaders().get(QueueConstants.EXPIRATION_TIME));\n        assertNotNull(response.getHeaders().get(QueueConstants.POP_RECEIPT));\n        final QueueMessageItem messageItem\n                = clientWrapper.receiveMessages(1, Duration.ofSeconds(30), null).stream().findFirst().get();\n        assertEquals(\"testing message\", messageItem.getBody().toString());\n        // test clear queue\n        operations.clearQueue(exchange);\n        assertTrue(clientWrapper.receiveMessages(1, null, null).isEmpty());\n        // delete testing queue\n        operations.deleteQueue(exchange);\n    }\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testReceiveAndPeekMessages() {\n        final QueueOperations operations = getQueueOperations();\n        final Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"testing message-1\");\n        operations.sendMessage(exchange);\n        exchange.getIn().setBody(\"testing message-2\");\n        operations.sendMessage(exchange);\n        exchange.getIn().setBody(\"testing message-3\");\n        operations.sendMessage(exchange);\n        // test peek messages\n        final QueueOperationResponse peekResponse = operations.peekMessages(exchange);\n        final List<PeekedMessageItem> peekedMessageItems = (List<PeekedMessageItem>) peekResponse.getBody();\n        assertEquals(3, peekedMessageItems.size());\n        assertEquals(\"testing message-1\", peekedMessageItems.get(0).getBody().toString());\n        assertEquals(\"testing message-2\", peekedMessageItems.get(1).getBody().toString());\n        assertEquals(\"testing message-3\", peekedMessageItems.get(2).getBody().toString());\n        // test receive message\n        exchange.getIn().setHeader(QueueConstants.MAX_MESSAGES, 1);\n        final QueueOperationResponse receiveResponse = operations.receiveMessages(exchange);\n        final List<QueueMessageItem> receivedMessageItems = (List<QueueMessageItem>) receiveResponse.getBody();\n        assertEquals(1, receivedMessageItems.size());\n        assertEquals(\"testing message-1\", receivedMessageItems.get(0).getBody().toString());\n        // make sure the message has been deQueued\n        assertEquals(2, ((List<PeekedMessageItem>) operations.peekMessages(null).getBody()).size());\n        // delete testing queue\n        operations.deleteQueue(exchange);\n    }\n    @Test\n    public void testDeleteMessages() {\n        final QueueOperations operations = getQueueOperations();\n        final Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"testing message-1\");\n        final QueueOperationResponse sentMessage1 = operations.sendMessage(exchange);\n        exchange.getIn().setBody(\"testing message-2\");\n        final QueueOperationResponse sentMessage2 = operations.sendMessage(exchange);\n        // test delete message\n        assertThrows(IllegalArgumentException.class, () -> operations.deleteMessage(exchange));\n        exchange.getIn().setHeader(QueueConstants.MESSAGE_ID, sentMessage1.getHeaders().get(QueueConstants.MESSAGE_ID));\n        // we still need pop receipt\n        assertThrows(IllegalArgumentException.class, () -> operations.deleteMessage(exchange));\n        // delete message now\n        exchange.getIn().setHeader(QueueConstants.POP_RECEIPT, sentMessage1.getHeaders().get(QueueConstants.POP_RECEIPT));\n        operations.deleteMessage(exchange);\n        // check the what we have in the queue\n        final QueueOperationResponse peekResponse = operations.peekMessages(exchange);\n        @SuppressWarnings(\"unchecked\")\n        final List<PeekedMessageItem> peekedMessageItems = (List<PeekedMessageItem>) peekResponse.getBody();\n        assertEquals(1, peekedMessageItems.size());\n        assertEquals(sentMessage2.getHeaders().get(QueueConstants.MESSAGE_ID), peekedMessageItems.get(0).getMessageId());\n        // delete testing queue\n        operations.deleteQueue(exchange);\n    }\n    @Test\n    public void testUpdateMessage() {\n        final QueueOperations operations = getQueueOperations();\n        final Exchange exchange = new DefaultExchange(context);\n        exchange.getIn().setBody(\"testing message-1\");\n        final QueueOperationResponse sentMessage = operations.sendMessage(exchange);\n        // let's do our update\n        exchange.getIn().setBody(\"updated message-1\");\n        exchange.getIn().setHeader(QueueConstants.POP_RECEIPT, sentMessage.getHeaders().get(QueueConstants.POP_RECEIPT));\n        exchange.getIn().setHeader(QueueConstants.MESSAGE_ID, sentMessage.getHeaders().get(QueueConstants.MESSAGE_ID));\n        exchange.getIn().setHeader(QueueConstants.VISIBILITY_TIMEOUT, Duration.ofMillis(10));\n        final QueueOperationResponse updatedMessage = operations.updateMessage(exchange);\n        assertNotNull(updatedMessage);\n        assertNotNull(updatedMessage.getHeaders());\n        assertTrue((boolean) updatedMessage.getBody());\n        assertNotNull(updatedMessage.getHeaders().get(QueueConstants.POP_RECEIPT));\n        assertNotNull(updatedMessage.getHeaders().get(QueueConstants.TIME_NEXT_VISIBLE));\n        // check the what we have in the queue\n        final QueueOperationResponse peekResponse = operations.peekMessages(exchange);\n        @SuppressWarnings(\"unchecked\")\n        final List<PeekedMessageItem> peekedMessageItems = (List<PeekedMessageItem>) peekResponse.getBody();\n        assertEquals(1, peekedMessageItems.size());\n        assertEquals(\"updated message-1\", peekedMessageItems.get(0).getBody().toString());\n        // delete testing queue\n        operations.deleteQueue(exchange);\n    }\n    @AfterAll\n    public void tearDown() {\n        // make sure to clean everything\n        final List<QueueItem> queues = serviceClientWrapper.listQueues(null, null);\n        if (queues.size() > 0) {\n            queues.forEach(queueItem -> serviceClientWrapper.getQueueClientWrapper(queueItem.getName()).delete(null));\n        }\n    }\n    private QueueOperations getQueueOperations() {\n        final String queueName = RandomStringUtils.randomAlphabetic(10).toLowerCase();\n        final QueueClientWrapper clientWrapper = serviceClientWrapper.getQueueClientWrapper(queueName);\n        return new QueueOperations(configuration, clientWrapper);\n    }\n"]], "pred": {"ppl": 1.6875275373458862, "ppl_lower": 2.207778215408325, "ppl/lowercase_ppl": -1.5135495239517904, "ppl/zlib": 0.0003103585184214683, "Min_5.0% Prob": 5.550794353672102, "Min_10.0% Prob": 3.8354972238634146, "Min_20.0% Prob": 2.3929719340567495, "Min_30.0% Prob": 1.7050965850551922, "Min_40.0% Prob": 1.3003235232166963, "Min_50.0% Prob": 1.0458983146273868, "Min_60.0% Prob": 0.8728815593815987}}
{"hexsha": "31eec84d544bfd37ee508a0621391c6beecda158", "ext": "java", "lang": "Java", "content": "@Generated(\"com.amazonaws:aws-java-sdk-code-generator\")\npublic class SourceFlowConfig implements Serializable, Cloneable, StructuredPojo {\n\n    /**\n     * <p>\n     * The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS\n     * account.\n     * </p>\n     */\n    private String connectorProfileName;\n    /**\n     * <p>\n     * The type of connector, such as Salesforce, Marketo, and so on.\n     * </p>\n     */\n    private String connectorType;\n    /**\n     * <p>\n     * Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields\n     * specified in the configuration are used when querying for the incremental data pull.\n     * </p>\n     */\n    private IncrementalPullConfig incrementalPullConfig;\n    /**\n     * <p>\n     * Specifies the information that is required to query a particular source connector.\n     * </p>\n     */\n    private SourceConnectorProperties sourceConnectorProperties;\n\n    /**\n     * <p>\n     * The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS\n     * account.\n     * </p>\n     * \n     * @param connectorProfileName\n     *        The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS\n     *        account.\n     */\n\n    public void setConnectorProfileName(String connectorProfileName) {\n        this.connectorProfileName = connectorProfileName;\n    }\n\n    /**\n     * <p>\n     * The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS\n     * account.\n     * </p>\n     * \n     * @return The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS\n     *         account.\n     */\n\n    public String getConnectorProfileName() {\n        return this.connectorProfileName;\n    }\n\n    /**\n     * <p>\n     * The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS\n     * account.\n     * </p>\n     * \n     * @param connectorProfileName\n     *        The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS\n     *        account.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n\n    public SourceFlowConfig withConnectorProfileName(String connectorProfileName) {\n        setConnectorProfileName(connectorProfileName);\n        return this;\n    }\n\n    /**\n     * <p>\n     * The type of connector, such as Salesforce, Marketo, and so on.\n     * </p>\n     * \n     * @param connectorType\n     *        The type of connector, such as Salesforce, Marketo, and so on.\n     * @see SourceConnectorType\n     */\n\n    public void setConnectorType(String connectorType) {\n        this.connectorType = connectorType;\n    }\n\n    /**\n     * <p>\n     * The type of connector, such as Salesforce, Marketo, and so on.\n     * </p>\n     * \n     * @return The type of connector, such as Salesforce, Marketo, and so on.\n     * @see SourceConnectorType\n     */\n\n    public String getConnectorType() {\n        return this.connectorType;\n    }\n\n    /**\n     * <p>\n     * The type of connector, such as Salesforce, Marketo, and so on.\n     * </p>\n     * \n     * @param connectorType\n     *        The type of connector, such as Salesforce, Marketo, and so on.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     * @see SourceConnectorType\n     */\n\n    public SourceFlowConfig withConnectorType(String connectorType) {\n        setConnectorType(connectorType);\n        return this;\n    }\n\n    /**\n     * <p>\n     * The type of connector, such as Salesforce, Marketo, and so on.\n     * </p>\n     * \n     * @param connectorType\n     *        The type of connector, such as Salesforce, Marketo, and so on.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     * @see SourceConnectorType\n     */\n\n    public SourceFlowConfig withConnectorType(SourceConnectorType connectorType) {\n        this.connectorType = connectorType.toString();\n        return this;\n    }\n\n    /**\n     * <p>\n     * Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields\n     * specified in the configuration are used when querying for the incremental data pull.\n     * </p>\n     * \n     * @param incrementalPullConfig\n     *        Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the\n     *        fields specified in the configuration are used when querying for the incremental data pull.\n     */\n\n    public void setIncrementalPullConfig(IncrementalPullConfig incrementalPullConfig) {\n        this.incrementalPullConfig = incrementalPullConfig;\n    }\n\n    /**\n     * <p>\n     * Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields\n     * specified in the configuration are used when querying for the incremental data pull.\n     * </p>\n     * \n     * @return Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided,\n     *         the fields specified in the configuration are used when querying for the incremental data pull.\n     */\n\n    public IncrementalPullConfig getIncrementalPullConfig() {\n        return this.incrementalPullConfig;\n    }\n\n    /**\n     * <p>\n     * Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields\n     * specified in the configuration are used when querying for the incremental data pull.\n     * </p>\n     * \n     * @param incrementalPullConfig\n     *        Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the\n     *        fields specified in the configuration are used when querying for the incremental data pull.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n\n    public SourceFlowConfig withIncrementalPullConfig(IncrementalPullConfig incrementalPullConfig) {\n        setIncrementalPullConfig(incrementalPullConfig);\n        return this;\n    }\n\n    /**\n     * <p>\n     * Specifies the information that is required to query a particular source connector.\n     * </p>\n     * \n     * @param sourceConnectorProperties\n     *        Specifies the information that is required to query a particular source connector.\n     */\n\n    public void setSourceConnectorProperties(SourceConnectorProperties sourceConnectorProperties) {\n        this.sourceConnectorProperties = sourceConnectorProperties;\n    }\n\n    /**\n     * <p>\n     * Specifies the information that is required to query a particular source connector.\n     * </p>\n     * \n     * @return Specifies the information that is required to query a particular source connector.\n     */\n\n    public SourceConnectorProperties getSourceConnectorProperties() {\n        return this.sourceConnectorProperties;\n    }\n\n    /**\n     * <p>\n     * Specifies the information that is required to query a particular source connector.\n     * </p>\n     * \n     * @param sourceConnectorProperties\n     *        Specifies the information that is required to query a particular source connector.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n\n    public SourceFlowConfig withSourceConnectorProperties(SourceConnectorProperties sourceConnectorProperties) {\n        setSourceConnectorProperties(sourceConnectorProperties);\n        return this;\n    }\n\n    /**\n     * Returns a string representation of this object. This is useful for testing and debugging. Sensitive data will be\n     * redacted from this string using a placeholder value.\n     *\n     * @return A string representation of this object.\n     *\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (getConnectorProfileName() != null)\n            sb.append(\"ConnectorProfileName: \").append(getConnectorProfileName()).append(\",\");\n        if (getConnectorType() != null)\n            sb.append(\"ConnectorType: \").append(getConnectorType()).append(\",\");\n        if (getIncrementalPullConfig() != null)\n            sb.append(\"IncrementalPullConfig: \").append(getIncrementalPullConfig()).append(\",\");\n        if (getSourceConnectorProperties() != null)\n            sb.append(\"SourceConnectorProperties: \").append(getSourceConnectorProperties());\n        sb.append(\"}\");\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n\n        if (obj instanceof SourceFlowConfig == false)\n            return false;\n        SourceFlowConfig other = (SourceFlowConfig) obj;\n        if (other.getConnectorProfileName() == null ^ this.getConnectorProfileName() == null)\n            return false;\n        if (other.getConnectorProfileName() != null && other.getConnectorProfileName().equals(this.getConnectorProfileName()) == false)\n            return false;\n        if (other.getConnectorType() == null ^ this.getConnectorType() == null)\n            return false;\n        if (other.getConnectorType() != null && other.getConnectorType().equals(this.getConnectorType()) == false)\n            return false;\n        if (other.getIncrementalPullConfig() == null ^ this.getIncrementalPullConfig() == null)\n            return false;\n        if (other.getIncrementalPullConfig() != null && other.getIncrementalPullConfig().equals(this.getIncrementalPullConfig()) == false)\n            return false;\n        if (other.getSourceConnectorProperties() == null ^ this.getSourceConnectorProperties() == null)\n            return false;\n        if (other.getSourceConnectorProperties() != null && other.getSourceConnectorProperties().equals(this.getSourceConnectorProperties()) == false)\n            return false;\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int hashCode = 1;\n\n        hashCode = prime * hashCode + ((getConnectorProfileName() == null) ? 0 : getConnectorProfileName().hashCode());\n        hashCode = prime * hashCode + ((getConnectorType() == null) ? 0 : getConnectorType().hashCode());\n        hashCode = prime * hashCode + ((getIncrementalPullConfig() == null) ? 0 : getIncrementalPullConfig().hashCode());\n        hashCode = prime * hashCode + ((getSourceConnectorProperties() == null) ? 0 : getSourceConnectorProperties().hashCode());\n        return hashCode;\n    }\n\n    @Override\n    public SourceFlowConfig clone() {\n        try {\n            return (SourceFlowConfig) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new IllegalStateException(\"Got a CloneNotSupportedException from Object.clone() \" + \"even though we're Cloneable!\", e);\n        }\n    }\n\n    @com.amazonaws.annotation.SdkInternalApi\n    @Override\n    public void marshall(ProtocolMarshaller protocolMarshaller) {\n        com.amazonaws.services.customerprofiles.model.transform.SourceFlowConfigMarshaller.getInstance().marshall(this, protocolMarshaller);\n    }\n}", "item_id": 0, "repo": "MC-JY/aws-sdk-java", "file": "aws-java-sdk-customerprofiles/src/main/java/com/amazonaws/services/customerprofiles/model/SourceFlowConfig.java", "last_update_at": "2022-03-31T15:56:24+00:00", "question_id": "31eec84d544bfd37ee508a0621391c6beecda158_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Generated(\"com.amazonaws:aws-java-sdk-code-generator\")\npublic class SourceFlowConfig implements Serializable, Cloneable, StructuredPojo {\n    /**\n     * <p>\n     * The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS\n     * account.\n     * </p>\n     */\n    private String connectorProfileName;\n    /**\n     * <p>\n     * The type of connector, such as Salesforce, Marketo, and so on.\n     * </p>\n     */\n    private String connectorType;\n    /**\n     * <p>\n     * Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields\n     * specified in the configuration are used when querying for the incremental data pull.\n     * </p>\n     */\n    private IncrementalPullConfig incrementalPullConfig;\n    /**\n     * <p>\n     * Specifies the information that is required to query a particular source connector.\n     * </p>\n     */\n    private SourceConnectorProperties sourceConnectorProperties;\n    /**\n     * <p>\n     * The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS\n     * account.\n     * </p>\n     * \n     * @param connectorProfileName\n     *        The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS\n     *        account.\n     */\n    public void setConnectorProfileName(String connectorProfileName) {\n        this.connectorProfileName = connectorProfileName;\n    }\n    /**\n     * <p>\n     * The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS\n     * account.\n     * </p>\n     * \n     * @return The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS\n     *         account.\n     */\n    public String getConnectorProfileName() {\n        return this.connectorProfileName;\n    }\n    /**\n     * <p>\n     * The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS\n     * account.\n     * </p>\n     * \n     * @param connectorProfileName\n     *        The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS\n     *        account.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n    public SourceFlowConfig withConnectorProfileName(String connectorProfileName) {\n        setConnectorProfileName(connectorProfileName);\n        return this;\n    }\n    /**\n     * <p>\n     * The type of connector, such as Salesforce, Marketo, and so on.\n     * </p>\n     * \n     * @param connectorType\n     *        The type of connector, such as Salesforce, Marketo, and so on.\n     * @see SourceConnectorType\n     */\n    public void setConnectorType(String connectorType) {\n        this.connectorType = connectorType;\n    }\n    /**\n     * <p>\n     * The type of connector, such as Salesforce, Marketo, and so on.\n     * </p>\n     * \n     * @return The type of connector, such as Salesforce, Marketo, and so on.\n     * @see SourceConnectorType\n     */\n    public String getConnectorType() {\n        return this.connectorType;\n    }\n    /**\n     * <p>\n     * The type of connector, such as Salesforce, Marketo, and so on.\n     * </p>\n     * \n     * @param connectorType\n     *        The type of connector, such as Salesforce, Marketo, and so on.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     * @see SourceConnectorType\n     */\n    public SourceFlowConfig withConnectorType(String connectorType) {\n        setConnectorType(connectorType);\n        return this;\n    }\n    /**\n     * <p>\n     * The type of connector, such as Salesforce, Marketo, and so on.\n     * </p>\n     * \n     * @param connectorType\n     *        The type of connector, such as Salesforce, Marketo, and so on.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     * @see SourceConnectorType\n     */\n    public SourceFlowConfig withConnectorType(SourceConnectorType connectorType) {\n        this.connectorType = connectorType.toString();\n        return this;\n    }\n    /**\n     * <p>\n     * Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields\n     * specified in the configuration are used when querying for the incremental data pull.\n     * </p>\n     * \n     * @param incrementalPullConfig\n     *        Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the\n     *        fields specified in the configuration are used when querying for the incremental data pull.\n     */\n    public void setIncrementalPullConfig(IncrementalPullConfig incrementalPullConfig) {\n        this.incrementalPullConfig = incrementalPullConfig;\n    }\n    /**\n     * <p>\n     * Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields\n     * specified in the configuration are used when querying for the incremental data pull.\n     * </p>\n     * \n     * @return Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided,\n     *         the fields specified in the configuration are used when querying for the incremental data pull.\n     */\n    public IncrementalPullConfig getIncrementalPullConfig() {\n        return this.incrementalPullConfig;\n    }\n    /**\n     * <p>\n     * Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields\n     * specified in the configuration are used when querying for the incremental data pull.\n     * </p>\n     * \n     * @param incrementalPullConfig\n     *        Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the\n     *        fields specified in the configuration are used when querying for the incremental data pull.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n    public SourceFlowConfig withIncrementalPullConfig(IncrementalPullConfig incrementalPullConfig) {\n        setIncrementalPullConfig(incrementalPullConfig);\n        return this;\n    }\n    /**\n     * <p>\n     * Specifies the information that is required to query a particular source connector.\n     * </p>\n     * \n     * @param sourceConnectorProperties\n     *        Specifies the information that is required to query a particular source connector.\n     */\n    public void setSourceConnectorProperties(SourceConnectorProperties sourceConnectorProperties) {\n        this.sourceConnectorProperties = sourceConnectorProperties;\n    }\n    /**\n     * <p>\n     * Specifies the information that is required to query a particular source connector.\n     * </p>\n     * \n     * @return Specifies the information that is required to query a particular source connector.\n     */\n    public SourceConnectorProperties getSourceConnectorProperties() {\n        return this.sourceConnectorProperties;\n    }\n    /**\n     * <p>\n     * Specifies the information that is required to query a particular source connector.\n     * </p>\n     * \n     * @param sourceConnectorProperties\n     *        Specifies the information that is required to query a particular source connector.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n    public SourceFlowConfig withSourceConnectorProperties(SourceConnectorProperties sourceConnectorProperties) {\n        setSourceConnectorProperties(sourceConnectorProperties);\n        return this;\n    }\n    /**\n     * Returns a string representation of this object. This is useful for testing and debugging. Sensitive data will be\n     * redacted from this string using a placeholder value.\n     *\n     * @return A string representation of this object.\n     *\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (getConnectorProfileName() != null)\n            sb.append(\"ConnectorProfileName: \").append(getConnectorProfileName()).append(\",\");\n        if (getConnectorType() != null)\n            sb.append(\"ConnectorType: \").append(getConnectorType()).append(\",\");\n        if (getIncrementalPullConfig() != null)\n            sb.append(\"IncrementalPullConfig: \").append(getIncrementalPullConfig()).append(\",\");\n        if (getSourceConnectorProperties() != null)\n            sb.append(\"SourceConnectorProperties: \").append(getSourceConnectorProperties());\n        sb.append(\"}\");\n        return sb.toString();\n    }\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (obj instanceof SourceFlowConfig == false)\n            return false;\n        SourceFlowConfig other = (SourceFlowConfig) obj;\n        if (other.getConnectorProfileName() == null ^ this.getConnectorProfileName() == null)\n            return false;\n        if (other.getConnectorProfileName() != null && other.getConnectorProfileName().equals(this.getConnectorProfileName()) == false)\n            return false;\n        if (other.getConnectorType() == null ^ this.getConnectorType() == null)\n            return false;\n        if (other.getConnectorType() != null && other.getConnectorType().equals(this.getConnectorType()) == false)\n            return false;\n        if (other.getIncrementalPullConfig() == null ^ this.getIncrementalPullConfig() == null)\n            return false;\n        if (other.getIncrementalPullConfig() != null && other.getIncrementalPullConfig().equals(this.getIncrementalPullConfig()) == false)\n            return false;\n        if (other.getSourceConnectorProperties() == null ^ this.getSourceConnectorProperties() == null)\n            return false;\n        if (other.getSourceConnectorProperties() != null && other.getSourceConnectorProperties().equals(this.getSourceConnectorProperties()) == false)\n            return false;\n        return true;\n    }\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int hashCode = 1;\n        hashCode = prime * hashCode + ((getConnectorProfileName() == null) ? 0 : getConnectorProfileName().hashCode());\n        hashCode = prime * hashCode + ((getConnectorType() == null) ? 0 : getConnectorType().hashCode());\n        hashCode = prime * hashCode + ((getIncrementalPullConfig() == null) ? 0 : getIncrementalPullConfig().hashCode());\n        hashCode = prime * hashCode + ((getSourceConnectorProperties() == null) ? 0 : getSourceConnectorProperties().hashCode());\n        return hashCode;\n    }\n    @Override\n    public SourceFlowConfig clone() {\n        try {\n            return (SourceFlowConfig) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new IllegalStateException(\"Got a CloneNotSupportedException from Object.clone() \" + \"even though we're Cloneable!\", e);\n        }\n    }\n    @com.amazonaws.annotation.SdkInternalApi\n    @Override\n    public void marshall(ProtocolMarshaller protocolMarshaller) {\n        com.amazonaws.services.customerprofiles.model.transform.SourceFlowConfigMarshaller.getInstance().marshall(this, protocolMarshaller);\n    }\n"]], "pred": {"ppl": 1.1739388704299927, "ppl_lower": 1.294806718826294, "ppl/lowercase_ppl": -1.6110871767730806, "ppl/zlib": 9.923555109519007e-05, "Min_5.0% Prob": 3.0915873488959145, "Min_10.0% Prob": 1.6059336735793919, "Min_20.0% Prob": 0.8041508755308956, "Min_30.0% Prob": 0.5361173004716696, "Min_40.0% Prob": 0.4011067615246279, "Min_50.0% Prob": 0.3210428750039969, "Min_60.0% Prob": 0.26762318026298976}}
{"hexsha": "c9b9f94179c277fc91aea7f31f8d1d50bc63c396", "ext": "java", "lang": "Java", "content": "public class Role {\n    public static final String ADMIN_ROLE = \"admin\";\n    public static final String ADMIN_ROLE_DESC = \"System reserved role,Have the highest level of authority!\";\n    public static final Role ADMIN;\n\n    static {\n        ADMIN = new Role();\n        ADMIN.setRoleName(ADMIN_ROLE);\n        ADMIN.setDesc(ADMIN_ROLE_DESC);\n    }\n\n    private String roleName;\n    private String desc;\n    private Map<String, ResourceAction> resourceActionBind = new HashMap<>();\n\n    public String getRoleName() {\n        return roleName;\n    }\n\n    public void setRoleName(String roleName) {\n        this.roleName = roleName;\n    }\n\n    public String getDesc() {\n        return desc;\n    }\n\n    public void setDesc(String desc) {\n        this.desc = desc;\n    }\n\n    public Map<String, ResourceAction> getResourceActionBind() {\n        return resourceActionBind;\n    }\n\n    public void setResourceActionBind(Map<String, ResourceAction> resourceActionBind) {\n        this.resourceActionBind = resourceActionBind;\n    }\n\n    public boolean check(ResourceAction requestAction) {\n        ResourceAction resourceAction = resourceActionBind.get(requestAction.getNamespace());\n        if (resourceAction == null) {\n            return false;\n        }\n        return resourceAction.check(requestAction);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Role)) return false;\n        Role role = (Role) o;\n        return Objects.equal(roleName, role.roleName);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hashCode(roleName);\n    }\n}", "item_id": 0, "repo": "Ahoo-Wang/CoSky", "file": "cosky-rest-api/src/main/java/me/ahoo/cosky/rest/security/rbac/Role.java", "last_update_at": "2022-03-17T06:10:12+00:00", "question_id": "c9b9f94179c277fc91aea7f31f8d1d50bc63c396_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Role {\n    public static final String ADMIN_ROLE = \"admin\";\n    public static final String ADMIN_ROLE_DESC = \"System reserved role,Have the highest level of authority!\";\n    public static final Role ADMIN;\n    static {\n        ADMIN = new Role();\n        ADMIN.setRoleName(ADMIN_ROLE);\n        ADMIN.setDesc(ADMIN_ROLE_DESC);\n    }\n    private String roleName;\n    private String desc;\n    private Map<String, ResourceAction> resourceActionBind = new HashMap<>();\n    public String getRoleName() {\n        return roleName;\n    }\n    public void setRoleName(String roleName) {\n        this.roleName = roleName;\n    }\n    public String getDesc() {\n        return desc;\n    }\n    public void setDesc(String desc) {\n        this.desc = desc;\n    }\n    public Map<String, ResourceAction> getResourceActionBind() {\n        return resourceActionBind;\n    }\n    public void setResourceActionBind(Map<String, ResourceAction> resourceActionBind) {\n        this.resourceActionBind = resourceActionBind;\n    }\n    public boolean check(ResourceAction requestAction) {\n        ResourceAction resourceAction = resourceActionBind.get(requestAction.getNamespace());\n        if (resourceAction == null) {\n            return false;\n        }\n        return resourceAction.check(requestAction);\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Role)) return false;\n        Role role = (Role) o;\n        return Objects.equal(roleName, role.roleName);\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hashCode(roleName);\n    }\n"]], "pred": {"ppl": 1.505359411239624, "ppl_lower": 1.7637792825698853, "ppl/lowercase_ppl": -1.3873224316221462, "ppl/zlib": 0.0008246606474693998, "Min_5.0% Prob": 5.610348950732838, "Min_10.0% Prob": 3.5080399089389376, "Min_20.0% Prob": 1.992269479897287, "Min_30.0% Prob": 1.358087635702557, "Min_40.0% Prob": 1.0227766171356456, "Min_50.0% Prob": 0.8193016685348832, "Min_60.0% Prob": 0.6830740489656347}}
{"hexsha": "d553a9664836aa1644d0c7c667efc465ebb88599", "ext": "java", "lang": "Java", "content": "public class ShowCommand extends Command {\n\n    public static final String COMMAND_WORD = \"show\";\n    public static final String MESSAGE_USAGE = COMMAND_WORD + \": List all potential teammates.\";\n\n    public static final String MESSAGE_SUCCESS = \"Listed your potential teammate(s)!\";\n\n    @Override\n    public CommandResult execute(Model model) {\n        requireNonNull(model);\n        model.updateDisplayPersonList(PREDICATE_SHOW_POTENTIAL_TEAMMATES);\n        return new CommandResult(MESSAGE_SUCCESS);\n    }\n}", "item_id": 0, "repo": "tzhan98/tp", "file": "src/main/java/seedu/address/logic/commands/ShowCommand.java", "last_update_at": "2022-03-31T10:29:48+00:00", "question_id": "d553a9664836aa1644d0c7c667efc465ebb88599_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ShowCommand extends Command {\n    public static final String COMMAND_WORD = \"show\";\n    public static final String MESSAGE_USAGE = COMMAND_WORD + \": List all potential teammates.\";\n    public static final String MESSAGE_SUCCESS = \"Listed your potential teammate(s)!\";\n    @Override\n    public CommandResult execute(Model model) {\n        requireNonNull(model);\n        model.updateDisplayPersonList(PREDICATE_SHOW_POTENTIAL_TEAMMATES);\n        return new CommandResult(MESSAGE_SUCCESS);\n    }\n"]], "pred": {"ppl": 2.0632126331329346, "ppl_lower": 6.175103187561035, "ppl/lowercase_ppl": -2.513620506105852, "ppl/zlib": 0.002586658209440996, "Min_5.0% Prob": 7.237638132912772, "Min_10.0% Prob": 5.41173871925899, "Min_20.0% Prob": 3.2081303062110114, "Min_30.0% Prob": 2.29991194199432, "Min_40.0% Prob": 1.802146144982042, "Min_50.0% Prob": 1.4494764445579216, "Min_60.0% Prob": 1.2083757419604808}}
{"hexsha": "0d1833cd258b31ca5b4938380875a6dcde8abcc4", "ext": "java", "lang": "Java", "content": "public class DataValidatorJSON {\n\n    public DataValidatorJSON() { }\n\n    static final String jInput           = \"input\";\n\n    static final String paramFormat           = \"outputFormat\";\n    static final String paramIndirection      = \"url\";\n    static final String paramData             = \"data\";\n    static final String paramSyntax           = \"languageSyntax\";\n\n    public static JsonObject execute(ValidationAction action) {\n        JsonBuilder obj = new JsonBuilder();\n        obj.startObject();\n\n        String syntax = getArgOrNull(action, paramSyntax);\n        if ( syntax == null || syntax.equals(\"\") )\n            syntax = RDFLanguages.NQUADS.getName();\n\n        Lang language = RDFLanguages.shortnameToLang(syntax);\n        if ( language == null ) {\n            ServletOps.errorBadRequest(\"Unknown syntax: \" + syntax);\n            return null;\n        }\n\n        String string = getArg(action, paramData);\n        StringReader sr = new StringReader(string);\n        obj.key(jInput).value(string);\n        StreamRDF dest = StreamRDFLib.sinkNull();\n\n        try {\n            RDFParser.create().source(sr).lang(language).parse(dest);\n        } catch (RiotParseException ex) {\n            obj.key(jErrors);\n\n            obj.startArray();      // Errors array\n            obj.startObject();\n            obj.key(jParseError).value(ex.getMessage());\n            obj.key(jParseErrorLine).value(ex.getLine());\n            obj.key(jParseErrorCol).value(ex.getCol());\n            obj.finishObject();\n            obj.finishArray();\n\n            obj.finishObject(); // Outer object\n            return obj.build().getAsObject();\n        } catch (RiotException ex) {\n            obj.key(jErrors);\n\n            obj.startArray();      // Errors array\n            obj.startObject();\n            obj.key(jParseError).value(ex.getMessage());\n            obj.finishObject();\n            obj.finishArray();\n\n            obj.finishObject(); // Outer object\n            return obj.build().getAsObject();\n        }\n\n\n        obj.finishObject();\n        return obj.build().getAsObject();\n    }\n}", "item_id": 0, "repo": "Hendrikto/jena", "file": "jena-fuseki2/jena-fuseki-core/src/main/java/org/apache/jena/fuseki/validation/json/DataValidatorJSON.java", "last_update_at": "2022-02-05T16:08:41+00:00", "question_id": "0d1833cd258b31ca5b4938380875a6dcde8abcc4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DataValidatorJSON {\n    public DataValidatorJSON() { }\n    static final String jInput           = \"input\";\n    static final String paramFormat           = \"outputFormat\";\n    static final String paramIndirection      = \"url\";\n    static final String paramData             = \"data\";\n    static final String paramSyntax           = \"languageSyntax\";\n    public static JsonObject execute(ValidationAction action) {\n        JsonBuilder obj = new JsonBuilder();\n        obj.startObject();\n        String syntax = getArgOrNull(action, paramSyntax);\n        if ( syntax == null || syntax.equals(\"\") )\n            syntax = RDFLanguages.NQUADS.getName();\n        Lang language = RDFLanguages.shortnameToLang(syntax);\n        if ( language == null ) {\n            ServletOps.errorBadRequest(\"Unknown syntax: \" + syntax);\n            return null;\n        }\n        String string = getArg(action, paramData);\n        StringReader sr = new StringReader(string);\n        obj.key(jInput).value(string);\n        StreamRDF dest = StreamRDFLib.sinkNull();\n        try {\n            RDFParser.create().source(sr).lang(language).parse(dest);\n        } catch (RiotParseException ex) {\n            obj.key(jErrors);\n            obj.startArray();      // Errors array\n            obj.startObject();\n            obj.key(jParseError).value(ex.getMessage());\n            obj.key(jParseErrorLine).value(ex.getLine());\n            obj.key(jParseErrorCol).value(ex.getCol());\n            obj.finishObject();\n            obj.finishArray();\n            obj.finishObject(); // Outer object\n            return obj.build().getAsObject();\n        } catch (RiotException ex) {\n            obj.key(jErrors);\n            obj.startArray();      // Errors array\n            obj.startObject();\n            obj.key(jParseError).value(ex.getMessage());\n            obj.finishObject();\n            obj.finishArray();\n            obj.finishObject(); // Outer object\n            return obj.build().getAsObject();\n        }\n        obj.finishObject();\n        return obj.build().getAsObject();\n    }\n"]], "pred": {"ppl": 2.2246720790863037, "ppl_lower": 2.750174045562744, "ppl/lowercase_ppl": -1.2651977845241795, "ppl/zlib": 0.00130017808873292, "Min_5.0% Prob": 7.365229359379521, "Min_10.0% Prob": 5.629151790792291, "Min_20.0% Prob": 3.5558794785629617, "Min_30.0% Prob": 2.5523317739819036, "Min_40.0% Prob": 1.9702883015302095, "Min_50.0% Prob": 1.5906935686414891, "Min_60.0% Prob": 1.3301968489293798}}
{"hexsha": "d54f79f395ac7a5835a9bd5c91ec71f13d0fa86d", "ext": "java", "lang": "Java", "content": "public class TransactionTest {\n    private Amount amount;\n    private TransactionDate transactionDate;\n    private DueDate dueDate;\n    private Transaction transaction;\n    private long validId;\n\n    @BeforeEach\n    public void setUp() {\n        amount = new Amount(VALID_AMOUNT_ONE);\n        transactionDate = new TransactionDate(VALID_TRANSACTION_DATE_ONE);\n        dueDate = new DueDate(VALID_DUE_DATE_ONE);\n        validId = VALID_ID;\n\n        Collection<TransactionField> fields = List.of(\n                amount,\n                transactionDate,\n                dueDate\n        );\n        transaction = new Transaction(\n                fields,\n                validId\n        );\n    }\n\n    @Test\n    public void constructor_null_throwsNullArgumentException() {\n        assertThrows(NullPointerException.class, () -> new Transaction((Collection<TransactionField>) null, VALID_ID));\n    }\n\n    @Test\n    public void constructor_missingRequiredField_throwsIllegalArgumentException() {\n        // Missing Transaction Date Field\n        List<TransactionField> incompleteArgumentsOne = List.of(\n                new Amount(VALID_AMOUNT_ONE)\n        );\n        assertThrows(IllegalArgumentException.class, () -> new Transaction(incompleteArgumentsOne, VALID_ID));\n\n        // Missing Amount Field\n        List<TransactionField> incompleteArgumentsTwo = List.of(\n                    new TransactionDate(VALID_TRANSACTION_DATE_ONE)\n        );\n        assertThrows(IllegalArgumentException.class, () -> new Transaction(incompleteArgumentsTwo, VALID_ID));\n    }\n\n    @Test\n    public void isValidTest() {\n        Transaction validTransaction = TRANSACTION_ONE;\n        Transaction invalidTransaction = INVALID_TRANSACTION;\n\n        // valid transaction -> returns True\n        assertTrue(validTransaction.isValid());\n\n        // invalid transaction (due date < transaction date) -> returns false\n        assertFalse(invalidTransaction.isValid());\n    }\n\n    @Test\n    public void removeFieldTest() {\n        DueDate toRemove = dueDate;\n        Collection<TransactionField> fieldsOne = List.of(\n                amount,\n                transactionDate,\n                dueDate\n        );\n\n        Collection<TransactionField> fieldCopy = new ArrayList<>(fieldsOne);\n\n        Transaction transactionOne = new Transaction(fieldsOne, VALID_ID);\n        fieldCopy.remove(toRemove);\n        Transaction expectedTransaction = new Transaction(transactionOne.getTransactionId(), fieldCopy, VALID_ID);\n\n        assertEquals(expectedTransaction, transactionOne.removeField(DueDate.PREFIX));\n    }\n\n    @Test\n    public void addFieldTest() {\n        DueDate toAdd = dueDate;\n\n        Collection<TransactionField> fieldsOne = List.of(\n                amount,\n                transactionDate,\n                dueDate\n        );\n\n        Collection<TransactionField> fieldCopy = new ArrayList<>(fieldsOne);\n\n        Transaction transactionOne = new Transaction(fieldsOne, VALID_ID);\n        fieldCopy.add(toAdd);\n        Transaction expectedTransaction = new Transaction(transactionOne.getTransactionId(), fieldCopy, VALID_ID);\n\n        assertEquals(expectedTransaction, transactionOne.addField(toAdd));\n    }\n\n    @Test\n    public void setStatusToTest() {\n        Status statusPaid = new Status(\"true\");\n\n        Collection<TransactionField> fields = new ArrayList<>(transaction.getFields());\n        fields.add(statusPaid);\n\n        Transaction expectedTransaction = new Transaction(transaction.getTransactionId(),\n                fields,\n                validId\n        );\n\n        assertEquals(expectedTransaction, transaction.setStatusTo(Command.class, new StatusFactoryAlwaysReturnsTrue()));\n    }\n\n    @Test\n    public void equals() {\n        // same values -> returns true\n        Transaction transactionCopy = new Transaction(TRANSACTION_ONE);\n        assertEquals(TRANSACTION_ONE, transactionCopy);\n\n        // same object -> returns true\n        assertEquals(TRANSACTION_ONE, TRANSACTION_ONE);\n\n        // null -> returns false\n        assertNotEquals(null, TRANSACTION_ONE);\n\n        // different type -> returns false\n        assertNotEquals(\"TRANSACTION_ONE\", TRANSACTION_ONE);\n\n        // different Transaction -> returns false\n        assertNotEquals(TRANSACTION_ONE, TRANSACTION_TWO);\n\n        // some fields are missing -> return false\n        assertNotEquals(TRANSACTION_ONE, TRANSACTION_ONE_INCOMPLETE);\n    }\n\n    private class StatusFactoryAlwaysReturnsTrue implements StatusFactoryInterface {\n\n        @Override\n        public Status getStatus(Class<? extends Command> command) {\n            return new Status(\"True\");\n        }\n    }\n}", "item_id": 0, "repo": "LapisRaider/tp", "file": "src/test/java/seedu/address/model/transaction/TransactionTest.java", "last_update_at": "2022-02-14T16:55:17+00:00", "question_id": "d54f79f395ac7a5835a9bd5c91ec71f13d0fa86d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TransactionTest {\n    private Amount amount;\n    private TransactionDate transactionDate;\n    private DueDate dueDate;\n    private Transaction transaction;\n    private long validId;\n    @BeforeEach\n    public void setUp() {\n        amount = new Amount(VALID_AMOUNT_ONE);\n        transactionDate = new TransactionDate(VALID_TRANSACTION_DATE_ONE);\n        dueDate = new DueDate(VALID_DUE_DATE_ONE);\n        validId = VALID_ID;\n        Collection<TransactionField> fields = List.of(\n                amount,\n                transactionDate,\n                dueDate\n        );\n        transaction = new Transaction(\n                fields,\n                validId\n        );\n    }\n    @Test\n    public void constructor_null_throwsNullArgumentException() {\n        assertThrows(NullPointerException.class, () -> new Transaction((Collection<TransactionField>) null, VALID_ID));\n    }\n    @Test\n    public void constructor_missingRequiredField_throwsIllegalArgumentException() {\n        // Missing Transaction Date Field\n        List<TransactionField> incompleteArgumentsOne = List.of(\n                new Amount(VALID_AMOUNT_ONE)\n        );\n        assertThrows(IllegalArgumentException.class, () -> new Transaction(incompleteArgumentsOne, VALID_ID));\n        // Missing Amount Field\n        List<TransactionField> incompleteArgumentsTwo = List.of(\n                    new TransactionDate(VALID_TRANSACTION_DATE_ONE)\n        );\n        assertThrows(IllegalArgumentException.class, () -> new Transaction(incompleteArgumentsTwo, VALID_ID));\n    }\n    @Test\n    public void isValidTest() {\n        Transaction validTransaction = TRANSACTION_ONE;\n        Transaction invalidTransaction = INVALID_TRANSACTION;\n        // valid transaction -> returns True\n        assertTrue(validTransaction.isValid());\n        // invalid transaction (due date < transaction date) -> returns false\n        assertFalse(invalidTransaction.isValid());\n    }\n    @Test\n    public void removeFieldTest() {\n        DueDate toRemove = dueDate;\n        Collection<TransactionField> fieldsOne = List.of(\n                amount,\n                transactionDate,\n                dueDate\n        );\n        Collection<TransactionField> fieldCopy = new ArrayList<>(fieldsOne);\n        Transaction transactionOne = new Transaction(fieldsOne, VALID_ID);\n        fieldCopy.remove(toRemove);\n        Transaction expectedTransaction = new Transaction(transactionOne.getTransactionId(), fieldCopy, VALID_ID);\n        assertEquals(expectedTransaction, transactionOne.removeField(DueDate.PREFIX));\n    }\n    @Test\n    public void addFieldTest() {\n        DueDate toAdd = dueDate;\n        Collection<TransactionField> fieldsOne = List.of(\n                amount,\n                transactionDate,\n                dueDate\n        );\n        Collection<TransactionField> fieldCopy = new ArrayList<>(fieldsOne);\n        Transaction transactionOne = new Transaction(fieldsOne, VALID_ID);\n        fieldCopy.add(toAdd);\n        Transaction expectedTransaction = new Transaction(transactionOne.getTransactionId(), fieldCopy, VALID_ID);\n        assertEquals(expectedTransaction, transactionOne.addField(toAdd));\n    }\n    @Test\n    public void setStatusToTest() {\n        Status statusPaid = new Status(\"true\");\n        Collection<TransactionField> fields = new ArrayList<>(transaction.getFields());\n        fields.add(statusPaid);\n        Transaction expectedTransaction = new Transaction(transaction.getTransactionId(),\n                fields,\n                validId\n        );\n        assertEquals(expectedTransaction, transaction.setStatusTo(Command.class, new StatusFactoryAlwaysReturnsTrue()));\n    }\n    @Test\n    public void equals() {\n        // same values -> returns true\n        Transaction transactionCopy = new Transaction(TRANSACTION_ONE);\n        assertEquals(TRANSACTION_ONE, transactionCopy);\n        // same object -> returns true\n        assertEquals(TRANSACTION_ONE, TRANSACTION_ONE);\n        // null -> returns false\n        assertNotEquals(null, TRANSACTION_ONE);\n        // different type -> returns false\n        assertNotEquals(\"TRANSACTION_ONE\", TRANSACTION_ONE);\n        // different Transaction -> returns false\n        assertNotEquals(TRANSACTION_ONE, TRANSACTION_TWO);\n        // some fields are missing -> return false\n        assertNotEquals(TRANSACTION_ONE, TRANSACTION_ONE_INCOMPLETE);\n    }\n    private class StatusFactoryAlwaysReturnsTrue implements StatusFactoryInterface {\n        @Override\n        public Status getStatus(Class<? extends Command> command) {\n            return new Status(\"True\");\n        }\n    }\n"]], "pred": {"ppl": 1.7348886728286743, "ppl_lower": 1.9630035161972046, "ppl/lowercase_ppl": -1.2242199385184134, "ppl/zlib": 0.0005520473405045225, "Min_5.0% Prob": 6.479197922874899, "Min_10.0% Prob": 4.478613273770201, "Min_20.0% Prob": 2.6468236439076125, "Min_30.0% Prob": 1.8204310523723466, "Min_40.0% Prob": 1.3722086576448895, "Min_50.0% Prob": 1.1012551264050043, "Min_60.0% Prob": 0.918977491583426}}
{"hexsha": "1fc904f0cd7d567a68ecb1abd53f180658d21438", "ext": "java", "lang": "Java", "content": "public class LokiFilter implements Filter{\n\n    static Log log = LogFactory.get(Thread.currentThread().getStackTrace()[1].getClassName());\n\n    @Autowired\n    HttpLogMapper httpLogMapper;\n\n    @Value(\"${loki.adminPort}\")\n    private Integer adminPort;\n\n    public static String getTime() {\n        SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        String  nowtime = df.format(new Date());\n        return nowtime;\n    }\n\n\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        log.info(\"Loki Filter is init.... \");\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse response, FilterChain filterChain) throws IOException, ServletException {\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n\n        String ip = request.getRemoteAddr();\n        String method = request.getMethod();\n        String path = request.getServletPath();\n        Map<String, String[]> param = request.getParameterMap();\n        String parameter = Utils.params2string(param);\n\n        StringBuilder headerStr = new StringBuilder();\n        Enumeration headerNames = request.getHeaderNames();\n        while (headerNames.hasMoreElements()){\n            String headerKey = (String) headerNames.nextElement();\n            String headerValue = request.getHeader(headerKey);\n            headerStr.append(String.format(\"%s: %s\\r\\n\", headerKey, headerValue));\n        }\n\n        StringBuilder body = new StringBuilder();\n        String str = null;\n        try {\n            BufferedReader br = request.getReader();\n            while ((str = br.readLine())!=null){\n                body.append(str);\n            }\n        }catch (Exception e){\n            body.append(e.getMessage());\n        }\n\n        String time = getTime();\n\n        String bheaderStr = Base64.getEncoder().encodeToString(headerStr.toString().getBytes());\n        String bbody = Base64.getEncoder().encodeToString(body.toString().getBytes());\n\n        if (!new AuthService().check(request)){\n            httpLogMapper.addHttpLog(ip,method,path,parameter, bheaderStr, bbody,time);\n        }\n\n        filterChain.doFilter(request, response);\n    }\n\n    @Override\n    public void destroy() {\n        log.info(\"Loki Filter was destroyed....\");\n    }\n}", "item_id": 0, "repo": "superxp/Loki", "file": "src/main/java/net/thekingofduck/loki/core/LokiFilter.java", "last_update_at": "2022-03-09T06:41:59+00:00", "question_id": "1fc904f0cd7d567a68ecb1abd53f180658d21438_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LokiFilter implements Filter{\n    static Log log = LogFactory.get(Thread.currentThread().getStackTrace()[1].getClassName());\n    @Autowired\n    HttpLogMapper httpLogMapper;\n    @Value(\"${loki.adminPort}\")\n    private Integer adminPort;\n    public static String getTime() {\n        SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        String  nowtime = df.format(new Date());\n        return nowtime;\n    }\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        log.info(\"Loki Filter is init.... \");\n    }\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse response, FilterChain filterChain) throws IOException, ServletException {\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        String ip = request.getRemoteAddr();\n        String method = request.getMethod();\n        String path = request.getServletPath();\n        Map<String, String[]> param = request.getParameterMap();\n        String parameter = Utils.params2string(param);\n        StringBuilder headerStr = new StringBuilder();\n        Enumeration headerNames = request.getHeaderNames();\n        while (headerNames.hasMoreElements()){\n            String headerKey = (String) headerNames.nextElement();\n            String headerValue = request.getHeader(headerKey);\n            headerStr.append(String.format(\"%s: %s\\r\\n\", headerKey, headerValue));\n        }\n        StringBuilder body = new StringBuilder();\n        String str = null;\n        try {\n            BufferedReader br = request.getReader();\n            while ((str = br.readLine())!=null){\n                body.append(str);\n            }\n        }catch (Exception e){\n            body.append(e.getMessage());\n        }\n        String time = getTime();\n        String bheaderStr = Base64.getEncoder().encodeToString(headerStr.toString().getBytes());\n        String bbody = Base64.getEncoder().encodeToString(body.toString().getBytes());\n        if (!new AuthService().check(request)){\n            httpLogMapper.addHttpLog(ip,method,path,parameter, bheaderStr, bbody,time);\n        }\n        filterChain.doFilter(request, response);\n    }\n    @Override\n    public void destroy() {\n        log.info(\"Loki Filter was destroyed....\");\n    }\n"]], "pred": {"ppl": 1.9083595275878906, "ppl_lower": 2.2891106605529785, "ppl/lowercase_ppl": -1.2815026538804801, "ppl/zlib": 0.0007558409203800223, "Min_5.0% Prob": 5.970420113925276, "Min_10.0% Prob": 4.520918029849812, "Min_20.0% Prob": 2.948185650741353, "Min_30.0% Prob": 2.097720038941067, "Min_40.0% Prob": 1.601245977704515, "Min_50.0% Prob": 1.2876115294123356, "Min_60.0% Prob": 1.07751376978813}}
{"hexsha": "17b5b32b9ae059fcf6615900d7af00c708add168", "ext": "java", "lang": "Java", "content": "public class ImportExportUtils {\n  private static final String ONTOPIA_RDBMS_URI_PREFIX = \"x-ontopia:tm-rdbms:\";\n  private static final String XTM_EXTENSION = \".xtm\";\n  private static final String TMX_EXTENSION = \".tmx\";\n  private static final String LTM_EXTENSION = \".ltm\";\n  private static final String CTM_EXTENSION = \".ctm\";\n\n  private static Set<ImportExportServiceIF> services;\n  \n  static {\n    loadServices();\n  }\n\n  private static void loadServices() {\n    try {\n      services = ServiceUtils.loadServices(ImportExportServiceIF.class);\n    } catch (IOException ex) {\n      LoggerFactory.getLogger(ImportExportUtils.class).error(\"Could not load import-export services\", ex);\n    }\n  }\n  \n  /**\n   * Returns the loaded ImportExportServiceIF services.\n   * @return the loaded ImportExportServiceIF services.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Set<ImportExportServiceIF> getServices() {\n    return UnmodifiableSet.unmodifiableSet(services);\n  }\n\n  /**\n   * PUBLIC: Given a file reference to a topic map, returns a topic\n   * map reader of the right class. Uses the file extension to\n   * determine what reader to create. Supports '.xtm', and '.ltm'.\n   * \n   * @since 2.0\n   */\n  public static TopicMapReaderIF getReader (File file) throws IOException {\n    return getReader(URIUtils.toURL(file));\n  }\n\n  /**\n   * PUBLIC: Given the file name or URL of a topic map, returns a\n   * topic map reader of the right class. Uses the file extension to\n   * determine what reader to create. Supports '.xtm', and '.ltm'.\n   */\n  public static TopicMapReaderIF getReader (String filename_or_url) {\n    try {\n      return getReader(StreamUtils.getResource(filename_or_url));\n    } catch (IOException ioe) {\n      throw new OntopiaRuntimeException(ioe);\n    }\n  }\n\n  /**\n   * PUBLIC: Given a locator referring to a topic map, returns a topic\n   * map reader of the right class. Uses the file extension to\n   * determine what reader to create. Supports '.xtm', '.tmx', and\n   * '.ltm'.\n   * \n   * @since 2.0\n   */\n  public static TopicMapReaderIF getReader (URL url) {\n    String address = url.toString();\n    try {\n      if (address.startsWith (ONTOPIA_RDBMS_URI_PREFIX))\n        return new RDBMSTopicMapReader (getTopicMapId (address));\n      else if (address.endsWith (XTM_EXTENSION))\n        return new XTMTopicMapReader (url);\n      else if (address.endsWith (LTM_EXTENSION))\n        return new LTMTopicMapReader (url);\n      else if (address.endsWith (TMX_EXTENSION))\n        return new TMXMLReader (url);\n      else if (address.endsWith (\".xml\"))\n        return new TMXMLReader(url); \n      else if (address.endsWith (CTM_EXTENSION))\n        return new CTMTopicMapReader(url);\n      else {\n        for (ImportExportServiceIF service : services) {\n          if (service.canRead(url)) {\n            return service.getReader(url);\n          }\n        }\n        // fallback\n        return new XTMTopicMapReader (url);\n      }\n    } catch (MalformedURLException mufe) {\n      throw new OntopiaRuntimeException(mufe);\n    }\n  }\n\n  /**\n   * PUBLIC: Given the file for a topicmap, returns a topicmap\n   * writer of the right class. Uses the file extension to determine\n   * what writer to create.  Supports '.xtm' and '.tmx'. If the suffix\n   * is unknown, the default writer is a XTM writer.\n   */\n  public static TopicMapWriterIF getWriter (File tmfile) throws IOException {\n    return getWriter(tmfile, null);\n  }\n\n  /**\n   * PUBLIC: Given the file for a topicmap, returns a topicmap\n   * writer of the right class. Uses the file extension to determine\n   * what writer to create.  Supports '.xtm' and '.tmx'. If the suffix\n   * is unknown, the default writer is a XTM writer.\n   */\n  public static TopicMapWriterIF getWriter (File tmfile, String encoding) throws IOException {\n    String name = tmfile.getName();\n    if (name.endsWith(LTM_EXTENSION)) {\n      return new LTMTopicMapWriter(tmfile, encoding);\n    } else if (name.endsWith(TMX_EXTENSION)) {\n      return new TMXMLWriter(tmfile, encoding);\n    } else if (name.endsWith(\".xtm1\")) {\n      return new XTMTopicMapWriter(tmfile, encoding);\n    } else {\n      for (ImportExportServiceIF service : services) {\n        if (service.canWrite(tmfile.toURI().toURL())) {\n          return service.getWriter(new FileOutputStream(tmfile));\n        }\n      }\n      // fallback\n      return new XTM2TopicMapWriter(tmfile);\n    }\n  }\n\n  /**\n   * INTERNAL: Gets the numeric topic map id from an RDBMS URI or a\n   * simple topic map id reference. Examples: x-ontopia:tm-rdbms:123,\n   * x-ontopia:tm-rdbms:M123, 123 and M123.\n   */\n  public static long getTopicMapId (String address) {\n    int offset = 0;\n    if (address.startsWith(\"M\"))\n      offset = 1;\n    else if (address.startsWith(ONTOPIA_RDBMS_URI_PREFIX)) {\n      // Syntax: x-ontopia:tm-rdbms:12345\n      offset = ONTOPIA_RDBMS_URI_PREFIX.length ();\n      \n      // Ignore M suffix on topic map id\n      if (address.charAt (offset) == 'M')\n        offset = offset + 1;\n    }\n    \n    try {\n      return Long.parseLong (address.substring (offset));\n    } catch (NumberFormatException e) {\n      throw new OntopiaRuntimeException (\"'\" + address\n          + \" is not a valid rdbms topic map URI.\");\n    }\n  }\n}", "item_id": 0, "repo": "ontopia/ontopia", "file": "ontopia-engine/src/main/java/net/ontopia/topicmaps/utils/ImportExportUtils.java", "last_update_at": "2022-02-04T11:17:58+00:00", "question_id": "17b5b32b9ae059fcf6615900d7af00c708add168_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ImportExportUtils {\n  private static final String ONTOPIA_RDBMS_URI_PREFIX = \"x-ontopia:tm-rdbms:\";\n  private static final String XTM_EXTENSION = \".xtm\";\n  private static final String TMX_EXTENSION = \".tmx\";\n  private static final String LTM_EXTENSION = \".ltm\";\n  private static final String CTM_EXTENSION = \".ctm\";\n  private static Set<ImportExportServiceIF> services;\n  static {\n    loadServices();\n  }\n  private static void loadServices() {\n    try {\n      services = ServiceUtils.loadServices(ImportExportServiceIF.class);\n    } catch (IOException ex) {\n      LoggerFactory.getLogger(ImportExportUtils.class).error(\"Could not load import-export services\", ex);\n    }\n  }\n  /**\n   * Returns the loaded ImportExportServiceIF services.\n   * @return the loaded ImportExportServiceIF services.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Set<ImportExportServiceIF> getServices() {\n    return UnmodifiableSet.unmodifiableSet(services);\n  }\n  /**\n   * PUBLIC: Given a file reference to a topic map, returns a topic\n   * map reader of the right class. Uses the file extension to\n   * determine what reader to create. Supports '.xtm', and '.ltm'.\n   * \n   * @since 2.0\n   */\n  public static TopicMapReaderIF getReader (File file) throws IOException {\n    return getReader(URIUtils.toURL(file));\n  }\n  /**\n   * PUBLIC: Given the file name or URL of a topic map, returns a\n   * topic map reader of the right class. Uses the file extension to\n   * determine what reader to create. Supports '.xtm', and '.ltm'.\n   */\n  public static TopicMapReaderIF getReader (String filename_or_url) {\n    try {\n      return getReader(StreamUtils.getResource(filename_or_url));\n    } catch (IOException ioe) {\n      throw new OntopiaRuntimeException(ioe);\n    }\n  }\n  /**\n   * PUBLIC: Given a locator referring to a topic map, returns a topic\n   * map reader of the right class. Uses the file extension to\n   * determine what reader to create. Supports '.xtm', '.tmx', and\n   * '.ltm'.\n   * \n   * @since 2.0\n   */\n  public static TopicMapReaderIF getReader (URL url) {\n    String address = url.toString();\n    try {\n      if (address.startsWith (ONTOPIA_RDBMS_URI_PREFIX))\n        return new RDBMSTopicMapReader (getTopicMapId (address));\n      else if (address.endsWith (XTM_EXTENSION))\n        return new XTMTopicMapReader (url);\n      else if (address.endsWith (LTM_EXTENSION))\n        return new LTMTopicMapReader (url);\n      else if (address.endsWith (TMX_EXTENSION))\n        return new TMXMLReader (url);\n      else if (address.endsWith (\".xml\"))\n        return new TMXMLReader(url); \n      else if (address.endsWith (CTM_EXTENSION))\n        return new CTMTopicMapReader(url);\n      else {\n        for (ImportExportServiceIF service : services) {\n          if (service.canRead(url)) {\n            return service.getReader(url);\n          }\n        }\n        // fallback\n        return new XTMTopicMapReader (url);\n      }\n    } catch (MalformedURLException mufe) {\n      throw new OntopiaRuntimeException(mufe);\n    }\n  }\n  /**\n   * PUBLIC: Given the file for a topicmap, returns a topicmap\n   * writer of the right class. Uses the file extension to determine\n   * what writer to create.  Supports '.xtm' and '.tmx'. If the suffix\n   * is unknown, the default writer is a XTM writer.\n   */\n  public static TopicMapWriterIF getWriter (File tmfile) throws IOException {\n    return getWriter(tmfile, null);\n  }\n  /**\n   * PUBLIC: Given the file for a topicmap, returns a topicmap\n   * writer of the right class. Uses the file extension to determine\n   * what writer to create.  Supports '.xtm' and '.tmx'. If the suffix\n   * is unknown, the default writer is a XTM writer.\n   */\n  public static TopicMapWriterIF getWriter (File tmfile, String encoding) throws IOException {\n    String name = tmfile.getName();\n    if (name.endsWith(LTM_EXTENSION)) {\n      return new LTMTopicMapWriter(tmfile, encoding);\n    } else if (name.endsWith(TMX_EXTENSION)) {\n      return new TMXMLWriter(tmfile, encoding);\n    } else if (name.endsWith(\".xtm1\")) {\n      return new XTMTopicMapWriter(tmfile, encoding);\n    } else {\n      for (ImportExportServiceIF service : services) {\n        if (service.canWrite(tmfile.toURI().toURL())) {\n          return service.getWriter(new FileOutputStream(tmfile));\n        }\n      }\n      // fallback\n      return new XTM2TopicMapWriter(tmfile);\n    }\n  }\n  /**\n   * INTERNAL: Gets the numeric topic map id from an RDBMS URI or a\n   * simple topic map id reference. Examples: x-ontopia:tm-rdbms:123,\n   * x-ontopia:tm-rdbms:M123, 123 and M123.\n   */\n  public static long getTopicMapId (String address) {\n    int offset = 0;\n    if (address.startsWith(\"M\"))\n      offset = 1;\n    else if (address.startsWith(ONTOPIA_RDBMS_URI_PREFIX)) {\n      // Syntax: x-ontopia:tm-rdbms:12345\n      offset = ONTOPIA_RDBMS_URI_PREFIX.length ();\n      // Ignore M suffix on topic map id\n      if (address.charAt (offset) == 'M')\n        offset = offset + 1;\n    }\n    try {\n      return Long.parseLong (address.substring (offset));\n    } catch (NumberFormatException e) {\n      throw new OntopiaRuntimeException (\"'\" + address\n          + \" is not a valid rdbms topic map URI.\");\n    }\n  }\n"]], "pred": {"ppl": 1.881399393081665, "ppl_lower": 2.163602352142334, "ppl/lowercase_ppl": -1.2211316827397356, "ppl/zlib": 0.00045931385026670496, "Min_5.0% Prob": 6.3752787159938435, "Min_10.0% Prob": 4.7273656316832, "Min_20.0% Prob": 2.912932563646167, "Min_30.0% Prob": 2.05999129377549, "Min_40.0% Prob": 1.567075668809102, "Min_50.0% Prob": 1.2608039783324805, "Min_60.0% Prob": 1.053218285891958}}
{"hexsha": "88bd29995ec17f435dcc1e8ee672c8a09d9dbfc0", "ext": "java", "lang": "Java", "content": "public class DummySSLServerSocketFactoryTest {\n    @Test\n    public void testKeyStore() throws KeyStoreException {\n        DummySSLServerSocketFactory factory = new DummySSLServerSocketFactory();\n        KeyStore ks = factory.getKeyStore();\n        assertThat(ks.containsAlias(\"greenmail\")).isTrue();\n    }\n}", "item_id": 0, "repo": "hartraft/greenmail", "file": "greenmail-core/src/test/java/com/icegreen/greenmail/test/DummySSLServerSocketFactoryTest.java", "last_update_at": "2022-03-31T21:02:10+00:00", "question_id": "88bd29995ec17f435dcc1e8ee672c8a09d9dbfc0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DummySSLServerSocketFactoryTest {\n    @Test\n    public void testKeyStore() throws KeyStoreException {\n        DummySSLServerSocketFactory factory = new DummySSLServerSocketFactory();\n        KeyStore ks = factory.getKeyStore();\n        assertThat(ks.containsAlias(\"greenmail\")).isTrue();\n    }\n"]], "pred": {"ppl": 2.6848502159118652, "ppl_lower": 3.928327798843384, "ppl/lowercase_ppl": -1.3853577225495937, "ppl/zlib": 0.005579801925972167, "Min_5.0% Prob": 8.476226329803467, "Min_10.0% Prob": 6.084853947162628, "Min_20.0% Prob": 4.049504093825817, "Min_30.0% Prob": 3.05617992579937, "Min_40.0% Prob": 2.418704475276172, "Min_50.0% Prob": 1.984531495720148, "Min_60.0% Prob": 1.6630060793831944}}
{"hexsha": "e3e08ba1ad0dcac6e8b4dfc54c3b11593840f559", "ext": "java", "lang": "Java", "content": "public class SceneDetectionActivity extends AppCompatActivity {\n\n    //region variablesAndObjects\n    private static final String TAG = SceneDetectionActivity.class.getSimpleName();\n\n    private Unbinder unbinder;\n\n    private SceneDetectionTransactor sceneDetectionTransactor;\n\n    private Uri takedImageUri;\n\n    private static final int PERMISSION_CODE_STORAGE_FOR_SELECT_IMAGE = 1;\n    String[] permissionRequestStorageForSelectImage = {Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE};\n    private static final int ACTIVITY_INTENT_CODE_STORAGE_FOR_SELECT_IMAGE = 11;\n\n    private static final int PERMISSION_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO = 2;\n    String[] permissionRequestCameraAndStorageForTakePhoto = {Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE};\n    private static final int ACTIVITY_INTENT_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO = 22;\n\n    private static final int PERMISSION_CODE_CAMERA_FOR_STREAM = 3;\n    String[] permissionRequestCameraForStream = {Manifest.permission.CAMERA};\n\n    private static final int LIVE_OVERLAY = R.id.live_overlay;\n    private static final int IMAGE_VIEW_SCENE_DETECTION = R.id.imageView_sceneDetection;\n    private static final int RESULT_LOGS = R.id.resultLogs;\n    private static final int PROGRESS_BAR = R.id.progressBar;\n\n    private static final int BTN_SCENE_DETECTION_WITH_IMAGE = R.id.btn_sceneDetectionWithImage;\n    private static final int BTN_SCENE_DETECTION_WITH_STORAGE = R.id.btn_sceneDetectionWithStorage;\n    private static final int BTN_SCENE_DETECTION_WITH_TAKE_PICTURE = R.id.btn_sceneDetectionWithTakeAPicture;\n    private static final int BTN_SCENE_DETECTION_WITH_CAMERA_STREAM = R.id.btn_sceneDetectionWithCameraStream;\n    private static final int IV_INFO = R.id.ivInfo;\n\n    private static final String REQUEST_PERMISSION_MESSAGE = \"Would You Like To Go To Permission Settings To Allow?\";\n    private static final String DIALOG_YES_MESSAGE = \"YES GO\";\n    private static final String DIALOG_CANCEL_MESSAGE = \"CANCEL\";\n\n    @Nullable\n    @BindView(LIVE_OVERLAY)\n    GraphicOverlay graphicOverlay;\n\n    @Nullable\n    @BindView(IMAGE_VIEW_SCENE_DETECTION)\n    ImageView imageViewSceneDetection;\n\n    @Nullable\n    @BindView(RESULT_LOGS)\n    TextView resultLogs;\n\n    @Nullable\n    @BindView(PROGRESS_BAR)\n    ProgressBar progressBar;\n\n    //endregion variablesAndObjects\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_scene_detection);\n\n        unbinder = ButterKnife.bind(this);\n        setupToolbar();\n\n        createSceneDetectionTransactor();\n\n        // this is important for get image of imageView by Bitmap and use with AnalyzeWithImage\n        imageViewSceneDetection.setDrawingCacheEnabled(true);\n\n    }\n\n    @OnClick({R.id.btn_sceneDetectionWithImage, R.id.btn_sceneDetectionWithStorage,\n            R.id.btn_sceneDetectionWithTakeAPicture, R.id.btn_sceneDetectionWithCameraStream})\n    public void onItemClick(View v) {\n        switch (v.getId()) {\n            case BTN_SCENE_DETECTION_WITH_IMAGE:\n                clearLogs();\n                showProgress();\n                Bitmap bitmap = imageViewSceneDetection.getDrawingCache();\n                analyseSceneDetectionWithImage(bitmap, false);\n                break;\n            case BTN_SCENE_DETECTION_WITH_STORAGE:\n                clearLogs();\n                showProgress();\n                ActivityCompat.requestPermissions(this, permissionRequestStorageForSelectImage, PERMISSION_CODE_STORAGE_FOR_SELECT_IMAGE);\n                break;\n            case BTN_SCENE_DETECTION_WITH_TAKE_PICTURE:\n                clearLogs();\n                showProgress();\n                ActivityCompat.requestPermissions(this, permissionRequestCameraAndStorageForTakePhoto, PERMISSION_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO);\n                break;\n            case BTN_SCENE_DETECTION_WITH_CAMERA_STREAM:\n                clearLogs();\n                ActivityCompat.requestPermissions(this, permissionRequestCameraForStream, PERMISSION_CODE_CAMERA_FOR_STREAM);\n                break;\n            default:\n                break;\n        }\n    }\n\n\n    private void setupToolbar() {\n        Toolbar toolbar = findViewById(R.id.toolbar);\n        setSupportActionBar(toolbar);\n        getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        getSupportActionBar().setDisplayShowHomeEnabled(true);\n        Util.setToolbar(this, toolbar, getResources().getString(R.string.link_irs_sd));\n    }\n\n    @Override\n    public boolean onSupportNavigateUp() {\n        onBackPressed();\n        return true;\n    }\n\n    private void createSceneDetectionTransactor() {\n        float confidenceMaxResult = 50.0f;\n        Log.d(TAG, \"createSceneDetectionTransactor : confidenceMaxResult : \" + confidenceMaxResult);\n        // You can change confidence parameter\n        sceneDetectionTransactor = new SceneDetectionTransactor(getApplicationContext(), \"\");\n    }\n\n\n    /**\n     * Detection with Asynchronous method\n     * <p>\n     * The scene detection service can classify the scenario content of images and add labels,\n     * such as outdoor scenery, indoor places, and buildings, to help understand the image content.\n     * Based on the detected information, you can create more personalized app experience for users.\n     * Currently, on-device detection on 102 scenarios is supported.\n     * <p>\n     * For details about the scenarios, please refer to this url\n     * https://developer.huawei.com/consumer/en/doc/development/HMSCore-Guides-V5/ml-resource-0000001050038188-V5\n     *\n     * @param bitmap\n     * @param isFromGallery : true = image getting from Gallery. set imageView with this bitmap. false = image using from imageView\n     */\n    private void analyseSceneDetectionWithImage(Bitmap bitmap, boolean isFromGallery) {\n\n        graphicOverlay.clear();\n\n        if (isFromGallery) {\n            imageViewSceneDetection.setImageBitmap(bitmap);\n        } else {\n            imageViewSceneDetection.setImageResource(R.drawable.test_image_scene_detection);\n        }\n\n        // ! important !\n        // for change scale takedImageBitmap by imageViewObject size\n        Bitmap takedImageBitmap = imageViewSceneDetection.getDrawingCache();\n\n        takedImageUri = BitmapUtils.getImageUriFromBitmap(SceneDetectionActivity.this, bitmap);\n\n        MLFrame frame = new MLFrame.Creator().setBitmap(takedImageBitmap).create();\n\n        Log.d(TAG, \"analyseSceneDetectionWithImage : TODO edit here : \" + bitmap.getWidth() + \"-\" + bitmap.getHeight());\n\n        sceneDetectionTransactor.detectInImage(frame)\n                .addOnSuccessListener(sceneDetectionsResults -> {\n                    if (sceneDetectionsResults == null) {\n                        Log.e(TAG, \"analyseSceneDetectionWithImage : remote : detectInImage results is NULL !\");\n                        return;\n                    }\n                    int sceneDetectionsSize = sceneDetectionsResults.size();\n                    Log.e(TAG, \"analyseSceneDetectionWithImage : remote : addOnSuccessListener sceneDetectionsSize : \" + sceneDetectionsSize);\n\n                    if (sceneDetectionsSize > 0) {\n                        graphicOverlay.clear();\n                        CameraImageGraphic imageGraphic = new CameraImageGraphic(graphicOverlay, takedImageBitmap);\n                        graphicOverlay.addGraphic(imageGraphic);\n\n                        StringBuilder sceneDetectionResultMessage = new StringBuilder();\n\n                        for (int i = 0; i < sceneDetectionsSize; ++i) {\n                            MLSceneDetection scene = sceneDetectionsResults.get(i);\n\n                            sceneDetectionResultMessage.append(i).append(\". Scene : \").append(scene.getResult()).append(\" - Confidence : \").append(scene.getConfidence()).append(\"\\n\");\n                        }\n\n                        SceneDetectionGraphic sceneGraphic = new SceneDetectionGraphic(graphicOverlay, getApplicationContext(), sceneDetectionsResults);\n                        graphicOverlay.addGraphic(sceneGraphic);\n                        graphicOverlay.postInvalidate();\n\n                        imageViewSceneDetection.setImageBitmap(BitmapUtils.loadBitmapFromView(graphicOverlay, 1080, 1200));\n\n                        String msg = \"Scene Detection Success Results : \" + sceneDetectionsSize + \" scenes. :\\n\" + sceneDetectionResultMessage.toString();\n                        displaySuccessAnalyseResults(msg);\n\n                    } else {\n                        Utils.showToastMessage(getApplicationContext(), \"No Scene data, Detected Local sceneDetectionsResults size is zero!\");\n                        displayFailureAnalyseResults(\"No Scene data, Detected Local sceneDetectionsResults size is zero!\");\n                    }\n\n                    hideProgress();\n\n                })\n                .addOnFailureListener(e -> {\n                    String errorMessage = e.getMessage();\n                    try {\n                        int errorCode = ((MLException) e).getErrCode();\n                        String errorMsg = e.getMessage();\n                        errorMessage = \"ERROR: \" + errorCode + \" : \" + errorMsg;\n                    } catch (Exception ex) {\n                        Log.e(TAG, \"analyseSceneDetectionWithImage.sceneDetectionTransactor.detectInImage.onFailure (MLException) errCode : \" + ex.getMessage(), ex);\n                    }\n                    Log.e(TAG, \"analyseSceneDetectionWithImage.sceneDetectionTransactor.detectInImage.onFailure exc : \" + errorMessage, e);\n\n                    displayFailureAnalyseResults(errorMessage);\n                    hideProgress();\n                });\n\n        stopSceneDetectionTransactor();\n    }\n\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        Log.i(TAG, \"onRequestPermissionsResult : requestCode : \" + requestCode);\n\n        if (requestCode == PERMISSION_CODE_STORAGE_FOR_SELECT_IMAGE) {\n            if (grantResults.length != 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                Log.d(TAG, \"onRequestPermissionsResult : granted storage permission ForDevice -> Start Intent ACTION_PICK\");\n                // Call the system album. maybe type change will necessary\n                this.startActivityForResult(Utils.createIntentForPickImageFromStorage(), ACTIVITY_INTENT_CODE_STORAGE_FOR_SELECT_IMAGE);\n            } else {\n                hideProgress();\n                Log.w(TAG, \"onRequestPermissionsResult : StoragePermission was NOT GRANTED\");\n                DialogUtils.showDialogPermissionWarning(this,\n                        \"NEED STORAGE PERMISSION\",\n                        REQUEST_PERMISSION_MESSAGE,\n                        R.drawable.icon_folder,\n                        \"You can not use Scene Detection without Storage Permission!\",\n                        DIALOG_YES_MESSAGE, DIALOG_CANCEL_MESSAGE);\n            }\n        }\n\n        if (requestCode == PERMISSION_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO) {\n            if (grantResults.length != 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED &&\n                    grantResults[1] == PackageManager.PERMISSION_GRANTED) {\n                Log.d(TAG, \"onRequestPermissionsResult : granted camera and storage permission -> Start Intent TakePicture\");\n\n                // set taken photo name with timestamp and location\n                @SuppressLint(\"SimpleDateFormat\")\n                String timeStamp = new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\n                String photoFileName = timeStamp + \"_newScenePicture\";\n\n                String storageDirectory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES) + \"/ML Scene\";\n                File imageFile = new File(storageDirectory, photoFileName + \".jpg\");\n                Uri photoUri = Uri.fromFile(imageFile);\n                Log.i(TAG, \"onRequestPermissionsResult storageDirectory : \" + storageDirectory);\n                Log.i(TAG, \"onRequestPermissionsResult photoUri.getPath : \" + photoUri.getPath());\n\n\n                Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);\n                if (takePictureIntent.resolveActivity(this.getPackageManager()) != null) {\n                    ContentValues values = new ContentValues();\n                    values.put(MediaStore.Images.Media.TITLE, photoFileName);\n                    values.put(MediaStore.Images.Media.DESCRIPTION, \"ML Scene Detection Photo From Camera\");\n\n                    takedImageUri = getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);\n                    Log.i(TAG, \"onRequestPermissionsResult takedImageUri --------> : \" + takedImageUri);\n                    takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, takedImageUri);\n                    this.startActivityForResult(takePictureIntent, ACTIVITY_INTENT_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO);\n                } else {\n                    Log.i(TAG, \"takePictureIntent.resolveActivity( this.getPackageManager()) is NULL\");\n                }\n            } else {\n                hideProgress();\n                Log.w(TAG, \"onRequestPermissionsResult : CameraPermission was NOT GRANTED\");\n                DialogUtils.showDialogPermissionWarning(this,\n                        \"NEED CAMERA AND STORAGE PERMISSION\",\n                        REQUEST_PERMISSION_MESSAGE,\n                        R.drawable.icon_folder,\n                        \"You can not use Scene Detection with Take a Picture without Camera And Storage Permission!\",\n                        DIALOG_YES_MESSAGE, DIALOG_CANCEL_MESSAGE);\n            }\n        }\n\n        if (requestCode == PERMISSION_CODE_CAMERA_FOR_STREAM) {\n            if (grantResults.length != 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                Log.d(TAG, \"onRequestPermissionsResult : granted camera and storage permission ForDevice -> Start Custom Camera Capture Activity\");\n                Utils.startActivity(SceneDetectionActivity.this, SceneDetectionCameraActivity.class);\n            } else {\n                Log.w(TAG, \"onRequestPermissionsResult : Camera Permission was NOT GRANTED\");\n                DialogUtils.showDialogPermissionWarning(this,\n                        \"NEED CAMERA PERMISSION\",\n                        REQUEST_PERMISSION_MESSAGE,\n                        R.drawable.icons_switch_camera_black,\n                        \"You can not use Scene Detection with Camera Stream without Camera Permission!\",\n                        DIALOG_YES_MESSAGE, DIALOG_CANCEL_MESSAGE);\n            }\n        }\n\n    }\n\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        Log.i(TAG, \"onActivityResult : requestCode : \" + requestCode + \" resultCode : \" + resultCode);\n        if (resultCode == 0) {\n            Log.w(TAG, \"onActivityResult : onActivityResult No any data detected\");\n            Utils.showToastMessage(getApplicationContext(), \"onActivityResult No any data detected\");\n            hideProgress();\n        } else {\n\n            if (requestCode == ACTIVITY_INTENT_CODE_STORAGE_FOR_SELECT_IMAGE) {\n                Bitmap bitmap;\n                try {\n                    bitmap = MediaStore.Images.Media.getBitmap(this.getContentResolver(), data.getData());\n                    analyseSceneDetectionWithImage(bitmap, true);\n                } catch (IOException e) {\n                    Log.i(TAG, \"onActivityResult activityIntentCodeStorageForSelectImage IOException for getBitmap with data.getData : \" + e.getMessage());\n                    Utils.showToastMessage(getApplicationContext(), \"IOException for getBitmap with data.getData : \" + e.getMessage());\n                    hideProgress();\n                }\n            }\n            if (requestCode == ACTIVITY_INTENT_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO) {\n                Bitmap bitmap;\n                try {\n                    Log.i(TAG, \"onActivityResult takedImageUri --------> \" + takedImageUri);\n                    bitmap = MediaStore.Images.Media.getBitmap(this.getContentResolver(), takedImageUri);\n                    analyseSceneDetectionWithImage(bitmap, true);\n                } catch (Exception e) {\n                    Log.e(TAG, \"onActivityResult activityIntentCodeCameraAndStorageForTakePhoto IOException for getBitmap with data.getData : \" + e.getMessage());\n                    Utils.showToastMessage(getApplicationContext(), \"IOException for getBitmap with data.getData : \" + e.getMessage());\n                    hideProgress();\n                }\n\n            }\n        }\n    }\n\n\n    private void displaySuccessAnalyseResults(String result) {\n        hideProgress();\n        Utils.createVibration(getApplicationContext(), 200);\n        Log.i(TAG, result);\n        resultLogs.setText(result);\n    }\n\n    private void displayFailureAnalyseResults(String msg) {\n        hideProgress();\n        String displayMessage = \"Scene Detection was Failed Results : \\n\" + msg;\n        Utils.createVibration(getApplicationContext(), 400);\n        Log.e(TAG, displayMessage);\n        resultLogs.setText(displayMessage);\n        Utils.showToastMessage(getApplicationContext(), displayMessage);\n    }\n\n\n    private void clearLogs() {\n        resultLogs.setText(R.string.detection_result_descriptions_will_be_here);\n    }\n\n\n    private void showProgress() {\n        progressBar.setVisibility(View.VISIBLE);\n    }\n\n    private void hideProgress() {\n        progressBar.setVisibility(View.GONE);\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        unbinder.unbind();\n\n        stopSceneDetectionTransactor();\n\n    }\n\n    private void stopSceneDetectionTransactor() {\n        if (sceneDetectionTransactor != null) {\n            sceneDetectionTransactor.stop();\n        }\n    }\n\n}", "item_id": 0, "repo": "Explore-In-HMS/HmsSandbox", "file": "feature_mlkit/src/main/java/com/genar/hmssandbox/huawei/feature_mlkit/ui/mlServices/imageRelated/sceneDetection/SceneDetectionActivity.java", "last_update_at": "2022-03-16T12:06:19+00:00", "question_id": "e3e08ba1ad0dcac6e8b4dfc54c3b11593840f559_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SceneDetectionActivity extends AppCompatActivity {\n    //region variablesAndObjects\n    private static final String TAG = SceneDetectionActivity.class.getSimpleName();\n    private Unbinder unbinder;\n    private SceneDetectionTransactor sceneDetectionTransactor;\n    private Uri takedImageUri;\n    private static final int PERMISSION_CODE_STORAGE_FOR_SELECT_IMAGE = 1;\n    String[] permissionRequestStorageForSelectImage = {Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE};\n    private static final int ACTIVITY_INTENT_CODE_STORAGE_FOR_SELECT_IMAGE = 11;\n    private static final int PERMISSION_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO = 2;\n    String[] permissionRequestCameraAndStorageForTakePhoto = {Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE};\n    private static final int ACTIVITY_INTENT_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO = 22;\n    private static final int PERMISSION_CODE_CAMERA_FOR_STREAM = 3;\n    String[] permissionRequestCameraForStream = {Manifest.permission.CAMERA};\n    private static final int LIVE_OVERLAY = R.id.live_overlay;\n    private static final int IMAGE_VIEW_SCENE_DETECTION = R.id.imageView_sceneDetection;\n    private static final int RESULT_LOGS = R.id.resultLogs;\n    private static final int PROGRESS_BAR = R.id.progressBar;\n    private static final int BTN_SCENE_DETECTION_WITH_IMAGE = R.id.btn_sceneDetectionWithImage;\n    private static final int BTN_SCENE_DETECTION_WITH_STORAGE = R.id.btn_sceneDetectionWithStorage;\n    private static final int BTN_SCENE_DETECTION_WITH_TAKE_PICTURE = R.id.btn_sceneDetectionWithTakeAPicture;\n    private static final int BTN_SCENE_DETECTION_WITH_CAMERA_STREAM = R.id.btn_sceneDetectionWithCameraStream;\n    private static final int IV_INFO = R.id.ivInfo;\n    private static final String REQUEST_PERMISSION_MESSAGE = \"Would You Like To Go To Permission Settings To Allow?\";\n    private static final String DIALOG_YES_MESSAGE = \"YES GO\";\n    private static final String DIALOG_CANCEL_MESSAGE = \"CANCEL\";\n    @Nullable\n    @BindView(LIVE_OVERLAY)\n    GraphicOverlay graphicOverlay;\n    @Nullable\n    @BindView(IMAGE_VIEW_SCENE_DETECTION)\n    ImageView imageViewSceneDetection;\n    @Nullable\n    @BindView(RESULT_LOGS)\n    TextView resultLogs;\n    @Nullable\n    @BindView(PROGRESS_BAR)\n    ProgressBar progressBar;\n    //endregion variablesAndObjects\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_scene_detection);\n        unbinder = ButterKnife.bind(this);\n        setupToolbar();\n        createSceneDetectionTransactor();\n        // this is important for get image of imageView by Bitmap and use with AnalyzeWithImage\n        imageViewSceneDetection.setDrawingCacheEnabled(true);\n    }\n    @OnClick({R.id.btn_sceneDetectionWithImage, R.id.btn_sceneDetectionWithStorage,\n            R.id.btn_sceneDetectionWithTakeAPicture, R.id.btn_sceneDetectionWithCameraStream})\n    public void onItemClick(View v) {\n        switch (v.getId()) {\n            case BTN_SCENE_DETECTION_WITH_IMAGE:\n                clearLogs();\n                showProgress();\n                Bitmap bitmap = imageViewSceneDetection.getDrawingCache();\n                analyseSceneDetectionWithImage(bitmap, false);\n                break;\n            case BTN_SCENE_DETECTION_WITH_STORAGE:\n                clearLogs();\n                showProgress();\n                ActivityCompat.requestPermissions(this, permissionRequestStorageForSelectImage, PERMISSION_CODE_STORAGE_FOR_SELECT_IMAGE);\n                break;\n            case BTN_SCENE_DETECTION_WITH_TAKE_PICTURE:\n                clearLogs();\n                showProgress();\n                ActivityCompat.requestPermissions(this, permissionRequestCameraAndStorageForTakePhoto, PERMISSION_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO);\n                break;\n            case BTN_SCENE_DETECTION_WITH_CAMERA_STREAM:\n                clearLogs();\n                ActivityCompat.requestPermissions(this, permissionRequestCameraForStream, PERMISSION_CODE_CAMERA_FOR_STREAM);\n                break;\n            default:\n                break;\n        }\n    }\n    private void setupToolbar() {\n        Toolbar toolbar = findViewById(R.id.toolbar);\n        setSupportActionBar(toolbar);\n        getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        getSupportActionBar().setDisplayShowHomeEnabled(true);\n        Util.setToolbar(this, toolbar, getResources().getString(R.string.link_irs_sd));\n    }\n    @Override\n    public boolean onSupportNavigateUp() {\n        onBackPressed();\n        return true;\n    }\n    private void createSceneDetectionTransactor() {\n        float confidenceMaxResult = 50.0f;\n        Log.d(TAG, \"createSceneDetectionTransactor : confidenceMaxResult : \" + confidenceMaxResult);\n        // You can change confidence parameter\n        sceneDetectionTransactor = new SceneDetectionTransactor(getApplicationContext(), \"\");\n    }\n    /**\n     * Detection with Asynchronous method\n     * <p>\n     * The scene detection service can classify the scenario content of images and add labels,\n     * such as outdoor scenery, indoor places, and buildings, to help understand the image content.\n     * Based on the detected information, you can create more personalized app experience for users.\n     * Currently, on-device detection on 102 scenarios is supported.\n     * <p>\n     * For details about the scenarios, please refer to this url\n     * https://developer.huawei.com/consumer/en/doc/development/HMSCore-Guides-V5/ml-resource-0000001050038188-V5\n     *\n     * @param bitmap\n     * @param isFromGallery : true = image getting from Gallery. set imageView with this bitmap. false = image using from imageView\n     */\n    private void analyseSceneDetectionWithImage(Bitmap bitmap, boolean isFromGallery) {\n        graphicOverlay.clear();\n        if (isFromGallery) {\n            imageViewSceneDetection.setImageBitmap(bitmap);\n        } else {\n            imageViewSceneDetection.setImageResource(R.drawable.test_image_scene_detection);\n        }\n        // ! important !\n        // for change scale takedImageBitmap by imageViewObject size\n        Bitmap takedImageBitmap = imageViewSceneDetection.getDrawingCache();\n        takedImageUri = BitmapUtils.getImageUriFromBitmap(SceneDetectionActivity.this, bitmap);\n        MLFrame frame = new MLFrame.Creator().setBitmap(takedImageBitmap).create();\n        Log.d(TAG, \"analyseSceneDetectionWithImage : TODO edit here : \" + bitmap.getWidth() + \"-\" + bitmap.getHeight());\n        sceneDetectionTransactor.detectInImage(frame)\n                .addOnSuccessListener(sceneDetectionsResults -> {\n                    if (sceneDetectionsResults == null) {\n                        Log.e(TAG, \"analyseSceneDetectionWithImage : remote : detectInImage results is NULL !\");\n                        return;\n                    }\n                    int sceneDetectionsSize = sceneDetectionsResults.size();\n                    Log.e(TAG, \"analyseSceneDetectionWithImage : remote : addOnSuccessListener sceneDetectionsSize : \" + sceneDetectionsSize);\n                    if (sceneDetectionsSize > 0) {\n                        graphicOverlay.clear();\n                        CameraImageGraphic imageGraphic = new CameraImageGraphic(graphicOverlay, takedImageBitmap);\n                        graphicOverlay.addGraphic(imageGraphic);\n                        StringBuilder sceneDetectionResultMessage = new StringBuilder();\n                        for (int i = 0; i < sceneDetectionsSize; ++i) {\n                            MLSceneDetection scene = sceneDetectionsResults.get(i);\n                            sceneDetectionResultMessage.append(i).append(\". Scene : \").append(scene.getResult()).append(\" - Confidence : \").append(scene.getConfidence()).append(\"\\n\");\n                        }\n                        SceneDetectionGraphic sceneGraphic = new SceneDetectionGraphic(graphicOverlay, getApplicationContext(), sceneDetectionsResults);\n                        graphicOverlay.addGraphic(sceneGraphic);\n                        graphicOverlay.postInvalidate();\n                        imageViewSceneDetection.setImageBitmap(BitmapUtils.loadBitmapFromView(graphicOverlay, 1080, 1200));\n                        String msg = \"Scene Detection Success Results : \" + sceneDetectionsSize + \" scenes. :\\n\" + sceneDetectionResultMessage.toString();\n                        displaySuccessAnalyseResults(msg);\n                    } else {\n                        Utils.showToastMessage(getApplicationContext(), \"No Scene data, Detected Local sceneDetectionsResults size is zero!\");\n                        displayFailureAnalyseResults(\"No Scene data, Detected Local sceneDetectionsResults size is zero!\");\n                    }\n                    hideProgress();\n                })\n                .addOnFailureListener(e -> {\n                    String errorMessage = e.getMessage();\n                    try {\n                        int errorCode = ((MLException) e).getErrCode();\n                        String errorMsg = e.getMessage();\n                        errorMessage = \"ERROR: \" + errorCode + \" : \" + errorMsg;\n                    } catch (Exception ex) {\n                        Log.e(TAG, \"analyseSceneDetectionWithImage.sceneDetectionTransactor.detectInImage.onFailure (MLException) errCode : \" + ex.getMessage(), ex);\n                    }\n                    Log.e(TAG, \"analyseSceneDetectionWithImage.sceneDetectionTransactor.detectInImage.onFailure exc : \" + errorMessage, e);\n                    displayFailureAnalyseResults(errorMessage);\n                    hideProgress();\n                });\n        stopSceneDetectionTransactor();\n    }\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        Log.i(TAG, \"onRequestPermissionsResult : requestCode : \" + requestCode);\n        if (requestCode == PERMISSION_CODE_STORAGE_FOR_SELECT_IMAGE) {\n            if (grantResults.length != 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                Log.d(TAG, \"onRequestPermissionsResult : granted storage permission ForDevice -> Start Intent ACTION_PICK\");\n                // Call the system album. maybe type change will necessary\n                this.startActivityForResult(Utils.createIntentForPickImageFromStorage(), ACTIVITY_INTENT_CODE_STORAGE_FOR_SELECT_IMAGE);\n            } else {\n                hideProgress();\n                Log.w(TAG, \"onRequestPermissionsResult : StoragePermission was NOT GRANTED\");\n                DialogUtils.showDialogPermissionWarning(this,\n                        \"NEED STORAGE PERMISSION\",\n                        REQUEST_PERMISSION_MESSAGE,\n                        R.drawable.icon_folder,\n                        \"You can not use Scene Detection without Storage Permission!\",\n                        DIALOG_YES_MESSAGE, DIALOG_CANCEL_MESSAGE);\n            }\n        }\n        if (requestCode == PERMISSION_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO) {\n            if (grantResults.length != 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED &&\n                    grantResults[1] == PackageManager.PERMISSION_GRANTED) {\n                Log.d(TAG, \"onRequestPermissionsResult : granted camera and storage permission -> Start Intent TakePicture\");\n                // set taken photo name with timestamp and location\n                @SuppressLint(\"SimpleDateFormat\")\n                String timeStamp = new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\n                String photoFileName = timeStamp + \"_newScenePicture\";\n                String storageDirectory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES) + \"/ML Scene\";\n                File imageFile = new File(storageDirectory, photoFileName + \".jpg\");\n                Uri photoUri = Uri.fromFile(imageFile);\n                Log.i(TAG, \"onRequestPermissionsResult storageDirectory : \" + storageDirectory);\n                Log.i(TAG, \"onRequestPermissionsResult photoUri.getPath : \" + photoUri.getPath());\n                Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);\n                if (takePictureIntent.resolveActivity(this.getPackageManager()) != null) {\n                    ContentValues values = new ContentValues();\n                    values.put(MediaStore.Images.Media.TITLE, photoFileName);\n                    values.put(MediaStore.Images.Media.DESCRIPTION, \"ML Scene Detection Photo From Camera\");\n                    takedImageUri = getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);\n                    Log.i(TAG, \"onRequestPermissionsResult takedImageUri --------> : \" + takedImageUri);\n                    takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, takedImageUri);\n                    this.startActivityForResult(takePictureIntent, ACTIVITY_INTENT_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO);\n                } else {\n                    Log.i(TAG, \"takePictureIntent.resolveActivity( this.getPackageManager()) is NULL\");\n                }\n            } else {\n                hideProgress();\n                Log.w(TAG, \"onRequestPermissionsResult : CameraPermission was NOT GRANTED\");\n                DialogUtils.showDialogPermissionWarning(this,\n                        \"NEED CAMERA AND STORAGE PERMISSION\",\n                        REQUEST_PERMISSION_MESSAGE,\n                        R.drawable.icon_folder,\n                        \"You can not use Scene Detection with Take a Picture without Camera And Storage Permission!\",\n                        DIALOG_YES_MESSAGE, DIALOG_CANCEL_MESSAGE);\n            }\n        }\n        if (requestCode == PERMISSION_CODE_CAMERA_FOR_STREAM) {\n            if (grantResults.length != 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                Log.d(TAG, \"onRequestPermissionsResult : granted camera and storage permission ForDevice -> Start Custom Camera Capture Activity\");\n                Utils.startActivity(SceneDetectionActivity.this, SceneDetectionCameraActivity.class);\n            } else {\n                Log.w(TAG, \"onRequestPermissionsResult : Camera Permission was NOT GRANTED\");\n                DialogUtils.showDialogPermissionWarning(this,\n                        \"NEED CAMERA PERMISSION\",\n                        REQUEST_PERMISSION_MESSAGE,\n                        R.drawable.icons_switch_camera_black,\n                        \"You can not use Scene Detection with Camera Stream without Camera Permission!\",\n                        DIALOG_YES_MESSAGE, DIALOG_CANCEL_MESSAGE);\n            }\n        }\n    }\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        Log.i(TAG, \"onActivityResult : requestCode : \" + requestCode + \" resultCode : \" + resultCode);\n        if (resultCode == 0) {\n            Log.w(TAG, \"onActivityResult : onActivityResult No any data detected\");\n            Utils.showToastMessage(getApplicationContext(), \"onActivityResult No any data detected\");\n            hideProgress();\n        } else {\n            if (requestCode == ACTIVITY_INTENT_CODE_STORAGE_FOR_SELECT_IMAGE) {\n                Bitmap bitmap;\n                try {\n                    bitmap = MediaStore.Images.Media.getBitmap(this.getContentResolver(), data.getData());\n                    analyseSceneDetectionWithImage(bitmap, true);\n                } catch (IOException e) {\n                    Log.i(TAG, \"onActivityResult activityIntentCodeStorageForSelectImage IOException for getBitmap with data.getData : \" + e.getMessage());\n                    Utils.showToastMessage(getApplicationContext(), \"IOException for getBitmap with data.getData : \" + e.getMessage());\n                    hideProgress();\n                }\n            }\n            if (requestCode == ACTIVITY_INTENT_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO) {\n                Bitmap bitmap;\n                try {\n                    Log.i(TAG, \"onActivityResult takedImageUri --------> \" + takedImageUri);\n                    bitmap = MediaStore.Images.Media.getBitmap(this.getContentResolver(), takedImageUri);\n                    analyseSceneDetectionWithImage(bitmap, true);\n                } catch (Exception e) {\n                    Log.e(TAG, \"onActivityResult activityIntentCodeCameraAndStorageForTakePhoto IOException for getBitmap with data.getData : \" + e.getMessage());\n                    Utils.showToastMessage(getApplicationContext(), \"IOException for getBitmap with data.getData : \" + e.getMessage());\n                    hideProgress();\n                }\n            }\n        }\n    }\n    private void displaySuccessAnalyseResults(String result) {\n        hideProgress();\n        Utils.createVibration(getApplicationContext(), 200);\n        Log.i(TAG, result);\n        resultLogs.setText(result);\n    }\n    private void displayFailureAnalyseResults(String msg) {\n        hideProgress();\n        String displayMessage = \"Scene Detection was Failed Results : \\n\" + msg;\n        Utils.createVibration(getApplicationContext(), 400);\n        Log.e(TAG, displayMessage);\n        resultLogs.setText(displayMessage);\n        Utils.showToastMessage(getApplicationContext(), displayMessage);\n    }\n    private void clearLogs() {\n        resultLogs.setText(R.string.detection_result_descriptions_will_be_here);\n    }\n    private void showProgress() {\n        progressBar.setVisibility(View.VISIBLE);\n    }\n    private void hideProgress() {\n        progressBar.setVisibility(View.GONE);\n    }\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        unbinder.unbind();\n        stopSceneDetectionTransactor();\n    }\n    private void stopSceneDetectionTransactor() {\n        if (sceneDetectionTransactor != null) {\n            sceneDetectionTransactor.stop();\n        }\n    }\n"]], "pred": {"ppl": 1.589239478111267, "ppl_lower": 1.9000539779663086, "ppl/lowercase_ppl": -1.3855899732588692, "ppl/zlib": 0.0001119245194852444, "Min_5.0% Prob": 5.210991368574255, "Min_10.0% Prob": 3.6763660007832097, "Min_20.0% Prob": 2.1959424090443873, "Min_30.0% Prob": 1.5250034921017348, "Min_40.0% Prob": 1.1536651204743202, "Min_50.0% Prob": 0.9261804663516041, "Min_60.0% Prob": 0.7727950804849378}}
{"hexsha": "034c9a3c0d0dff371fc4d01077ef946a827e0e0c", "ext": "java", "lang": "Java", "content": "public class UriParserTest {\n\n    @Test\n    public void parserReturnsHostGivenHttpUrl() {\n\n        // given\n        String url = \"tcp://localhost:8080\";\n        UriParser uriParser = new UriParser();\n\n        // when\n        String parsedHost = uriParser.getHost(url);\n\n        // then\n        assertEquals(\"localhost\", parsedHost);\n\n    }\n\n    @Test\n    public void parserReturnsIpGivenHttpUrl() {\n\n        // given\n        String url = \"tcp://10.120.10.10:8080\";\n        UriParser uriParser = new UriParser();\n\n        // when\n        String parsedHost = uriParser.getHost(url);\n\n        // then\n        assertEquals(\"10.120.10.10\", parsedHost);\n\n    }\n\n    @Test\n    public void parserReturnsPortGivenHttpUrl() {\n\n        // given\n        String url = \"tcp://localhost:8080\";\n        UriParser uriParser = new UriParser();\n\n        // when\n        int parsedPort = uriParser.getPort(url);\n\n        // then\n        assertEquals(8080, parsedPort);\n\n    }\n\n    @Test\n    public void parserReturnsPortGivenIpUrl() {\n\n        // given\n        String url = \"tcp://10.120.10.10:8080\";\n        UriParser uriParser = new UriParser();\n\n        // when\n        int parsedPort = uriParser.getPort(url);\n\n        // then\n        assertEquals(8080, parsedPort);\n\n    }\n\n    @Test\n    public void getHostThrowsOnInvalidUri() {\n\n        // given\n        String url = \"${\";\n        UriParser uriParser = new UriParser();\n\n        // when\n        final ConfigurationException exception = assertThrows(ConfigurationException.class, () -> uriParser.getHost(url));\n\n        // then\n        assertThat(exception.getMessage(), containsString(\"Illegal character in path at index 1: ${\"));\n\n    }\n\n    @Test\n    public void getPortThrowsOnInvalidUri() {\n\n        // given\n        String url = \"%s\";\n        UriParser uriParser = new UriParser();\n\n        // when\n        final ConfigurationException exception = assertThrows(ConfigurationException.class, () -> uriParser.getPort(url));\n\n        // then\n        assertThat(exception.getMessage(), equalTo(\"java.net.URISyntaxException: Malformed escape pair at index 0: %s\"));\n\n    }\n\n}", "item_id": 0, "repo": "Hamzablm/log4j2-elasticsearch", "file": "log4j2-elasticsearch5-bulkprocessor/src/test/java/org/appenders/log4j2/elasticsearch/bulkprocessor/UriParserTest.java", "last_update_at": "2022-02-18T04:13:47+00:00", "question_id": "034c9a3c0d0dff371fc4d01077ef946a827e0e0c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UriParserTest {\n    @Test\n    public void parserReturnsHostGivenHttpUrl() {\n        // given\n        String url = \"tcp://localhost:8080\";\n        UriParser uriParser = new UriParser();\n        // when\n        String parsedHost = uriParser.getHost(url);\n        // then\n        assertEquals(\"localhost\", parsedHost);\n    }\n    @Test\n    public void parserReturnsIpGivenHttpUrl() {\n        // given\n        String url = \"tcp://10.120.10.10:8080\";\n        UriParser uriParser = new UriParser();\n        // when\n        String parsedHost = uriParser.getHost(url);\n        // then\n        assertEquals(\"10.120.10.10\", parsedHost);\n    }\n    @Test\n    public void parserReturnsPortGivenHttpUrl() {\n        // given\n        String url = \"tcp://localhost:8080\";\n        UriParser uriParser = new UriParser();\n        // when\n        int parsedPort = uriParser.getPort(url);\n        // then\n        assertEquals(8080, parsedPort);\n    }\n    @Test\n    public void parserReturnsPortGivenIpUrl() {\n        // given\n        String url = \"tcp://10.120.10.10:8080\";\n        UriParser uriParser = new UriParser();\n        // when\n        int parsedPort = uriParser.getPort(url);\n        // then\n        assertEquals(8080, parsedPort);\n    }\n    @Test\n    public void getHostThrowsOnInvalidUri() {\n        // given\n        String url = \"${\";\n        UriParser uriParser = new UriParser();\n        // when\n        final ConfigurationException exception = assertThrows(ConfigurationException.class, () -> uriParser.getHost(url));\n        // then\n        assertThat(exception.getMessage(), containsString(\"Illegal character in path at index 1: ${\"));\n    }\n    @Test\n    public void getPortThrowsOnInvalidUri() {\n        // given\n        String url = \"%s\";\n        UriParser uriParser = new UriParser();\n        // when\n        final ConfigurationException exception = assertThrows(ConfigurationException.class, () -> uriParser.getPort(url));\n        // then\n        assertThat(exception.getMessage(), equalTo(\"java.net.URISyntaxException: Malformed escape pair at index 0: %s\"));\n    }\n"]], "pred": {"ppl": 1.4430956840515137, "ppl_lower": 1.5838531255722046, "ppl/lowercase_ppl": -1.2537414590332907, "ppl/zlib": 0.0008317246864113147, "Min_5.0% Prob": 5.261875452533845, "Min_10.0% Prob": 3.3030983219223637, "Min_20.0% Prob": 1.806413363605257, "Min_30.0% Prob": 1.2206058822251775, "Min_40.0% Prob": 0.9183606653391654, "Min_50.0% Prob": 0.7330644865396022, "Min_60.0% Prob": 0.6114597018700763}}
{"hexsha": "3ea81b72b10a1a71d38f4038b6a333e9e787f304", "ext": "java", "lang": "Java", "content": "public class ManagementUtil {\n\n    /**\n     * Get the MBeanServerId of Agent ID for the provided MBeanServer.\n     *\n     * @param aMBeanServer MBeanServer whose Server ID/Agent ID is desired.\n     * @return MBeanServerId/Agent ID of provided MBeanServer.\n     */\n    public static String getMBeanServerId(final MBeanServer aMBeanServer) {\n        String serverId = null;\n        final String SERVER_DELEGATE = \"JMImplementation:type=MBeanServerDelegate\";\n        final String MBEAN_SERVER_ID_KEY = \"MBeanServerId\";\n        try {\n            ObjectName delegateObjName = new ObjectName(SERVER_DELEGATE);\n            serverId = (String) aMBeanServer.getAttribute(delegateObjName,\n                    MBEAN_SERVER_ID_KEY);\n        } catch (MalformedObjectNameException malformedObjectNameException) {\n            //System.err.println(\"Problems constructing MBean ObjectName: \" + malformedObjectNameException.getMessage());\n        } catch (AttributeNotFoundException noMatchingAttrException) {\n            //System.err.println(\"Unable to find attribute \" + MBEAN_SERVER_ID_KEY + \" in MBean \" + SERVER_DELEGATE + \": \" + noMatchingAttrException);\n        } catch (MBeanException mBeanException) {\n            //System.err.println(\"Exception thrown by MBean's (\" + SERVER_DELEGATE + \"'s \" + MBEAN_SERVER_ID_KEY + \") getter: \" + mBeanException.getMessage());\n        } catch (ReflectionException reflectionException) {\n            //System.err.println(\"Exception thrown by MBean's (\" + SERVER_DELEGATE + \"'s \" + MBEAN_SERVER_ID_KEY + \") setter: \" + reflectionException.getMessage());\n        } catch (InstanceNotFoundException noMBeanInstance) {\n            //System.err.println(\"No instance of MBean \" + SERVER_DELEGATE + \" found in MBeanServer: \" + noMBeanInstance.getMessage());\n        }\n        return serverId;\n    }\n\n}", "item_id": 0, "repo": "aspan/cloudhopper-commons", "file": "ch-commons-util/src/main/java/com/cloudhopper/commons/util/ManagementUtil.java", "last_update_at": "2022-02-18T10:48:59+00:00", "question_id": "3ea81b72b10a1a71d38f4038b6a333e9e787f304_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ManagementUtil {\n    /**\n     * Get the MBeanServerId of Agent ID for the provided MBeanServer.\n     *\n     * @param aMBeanServer MBeanServer whose Server ID/Agent ID is desired.\n     * @return MBeanServerId/Agent ID of provided MBeanServer.\n     */\n    public static String getMBeanServerId(final MBeanServer aMBeanServer) {\n        String serverId = null;\n        final String SERVER_DELEGATE = \"JMImplementation:type=MBeanServerDelegate\";\n        final String MBEAN_SERVER_ID_KEY = \"MBeanServerId\";\n        try {\n            ObjectName delegateObjName = new ObjectName(SERVER_DELEGATE);\n            serverId = (String) aMBeanServer.getAttribute(delegateObjName,\n                    MBEAN_SERVER_ID_KEY);\n        } catch (MalformedObjectNameException malformedObjectNameException) {\n            //System.err.println(\"Problems constructing MBean ObjectName: \" + malformedObjectNameException.getMessage());\n        } catch (AttributeNotFoundException noMatchingAttrException) {\n            //System.err.println(\"Unable to find attribute \" + MBEAN_SERVER_ID_KEY + \" in MBean \" + SERVER_DELEGATE + \": \" + noMatchingAttrException);\n        } catch (MBeanException mBeanException) {\n            //System.err.println(\"Exception thrown by MBean's (\" + SERVER_DELEGATE + \"'s \" + MBEAN_SERVER_ID_KEY + \") getter: \" + mBeanException.getMessage());\n        } catch (ReflectionException reflectionException) {\n            //System.err.println(\"Exception thrown by MBean's (\" + SERVER_DELEGATE + \"'s \" + MBEAN_SERVER_ID_KEY + \") setter: \" + reflectionException.getMessage());\n        } catch (InstanceNotFoundException noMBeanInstance) {\n            //System.err.println(\"No instance of MBean \" + SERVER_DELEGATE + \" found in MBeanServer: \" + noMBeanInstance.getMessage());\n        }\n        return serverId;\n    }\n"]], "pred": {"ppl": 1.8619284629821777, "ppl_lower": 2.4323441982269287, "ppl/lowercase_ppl": -1.4299183383456604, "ppl/zlib": 0.0010810656672448642, "Min_5.0% Prob": 6.218429708480835, "Min_10.0% Prob": 4.506751184463501, "Min_20.0% Prob": 2.860352528567361, "Min_30.0% Prob": 2.0329355112227954, "Min_40.0% Prob": 1.5480402936158804, "Min_50.0% Prob": 1.243091357813224, "Min_60.0% Prob": 1.0367063617440644}}
{"hexsha": "239868afa7e8dfbabe9951c709d2f08c97880278", "ext": "java", "lang": "Java", "content": "public class GFGAnagramSubstringSearch {\n    \n    public List<Integer> getAllPosition(String mainString, String pat){\n        Map<Character,Integer> patternCharCountMap =  new TreeMap<>();\n        Map<Character,Integer> mainCharCountMap =  new TreeMap<>();\n        \n        List<Integer> output = Lists.newArrayList();\n        \n        int patLength = pat.length();\n        int mainStringLength = mainString.length();\n        \n        for(int count = 0; count < patLength; count++){\n            patternCharCountMap.put(pat.charAt(count),patternCharCountMap.getOrDefault(pat.charAt(count),0)+1);\n            mainCharCountMap.put(mainString.charAt(count),mainCharCountMap.getOrDefault(mainString.charAt(count),0)+1);\n        }\n        \n        for(int count = patLength; count<mainStringLength; count++){\n            if(compare(patternCharCountMap,mainCharCountMap)){\n                output.add(count-patLength);\n            }\n            \n            mainCharCountMap.put(mainString.charAt(count),mainCharCountMap.getOrDefault(mainString.charAt(count),0)+1);\n            mainCharCountMap.put(mainString.charAt(count-patLength),mainCharCountMap.get(mainString.charAt(count-patLength))-1);\n        }\n        \n        if(compare(patternCharCountMap,mainCharCountMap)){\n            output.add(mainStringLength-patLength);\n        }\n        \n        return output;\n    }\n    \n    \n    public boolean compare(Map<Character,Integer> pattern, Map<Character,Integer> actual){\n        \n        for(Character key : pattern.keySet()){\n            if(!actual.containsKey(key) || pattern.get(key) != actual.get(key)){\n                return false;  \n            }\n        }\n        \n        return true;\n    }\n    \n    \n}", "item_id": 0, "repo": "dhiralpandya/AlgorithmRecipe", "file": "src/main/java/com/omtlab/algorithmrecipe/string/map/GFGAnagramSubstringSearch.java", "last_update_at": "2022-01-29T09:02:59+00:00", "question_id": "239868afa7e8dfbabe9951c709d2f08c97880278_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GFGAnagramSubstringSearch {\n    public List<Integer> getAllPosition(String mainString, String pat){\n        Map<Character,Integer> patternCharCountMap =  new TreeMap<>();\n        Map<Character,Integer> mainCharCountMap =  new TreeMap<>();\n        List<Integer> output = Lists.newArrayList();\n        int patLength = pat.length();\n        int mainStringLength = mainString.length();\n        for(int count = 0; count < patLength; count++){\n            patternCharCountMap.put(pat.charAt(count),patternCharCountMap.getOrDefault(pat.charAt(count),0)+1);\n            mainCharCountMap.put(mainString.charAt(count),mainCharCountMap.getOrDefault(mainString.charAt(count),0)+1);\n        }\n        for(int count = patLength; count<mainStringLength; count++){\n            if(compare(patternCharCountMap,mainCharCountMap)){\n                output.add(count-patLength);\n            }\n            mainCharCountMap.put(mainString.charAt(count),mainCharCountMap.getOrDefault(mainString.charAt(count),0)+1);\n            mainCharCountMap.put(mainString.charAt(count-patLength),mainCharCountMap.get(mainString.charAt(count-patLength))-1);\n        }\n        if(compare(patternCharCountMap,mainCharCountMap)){\n            output.add(mainStringLength-patLength);\n        }\n        return output;\n    }\n    public boolean compare(Map<Character,Integer> pattern, Map<Character,Integer> actual){\n        for(Character key : pattern.keySet()){\n            if(!actual.containsKey(key) || pattern.get(key) != actual.get(key)){\n                return false;  \n            }\n        }\n        return true;\n    }\n"]], "pred": {"ppl": 1.5825976133346558, "ppl_lower": 1.7571980953216553, "ppl/lowercase_ppl": -1.2279686108691907, "ppl/zlib": 0.0010001471811018742, "Min_5.0% Prob": 5.603509581607321, "Min_10.0% Prob": 3.7357407022029796, "Min_20.0% Prob": 2.190940407702797, "Min_30.0% Prob": 1.5135373757024047, "Min_40.0% Prob": 1.1418517312917271, "Min_50.0% Prob": 0.9182816323183697, "Min_60.0% Prob": 0.7646746495869338}}
{"hexsha": "ffcbb4fe4625789106460362fa40f62e87e1f2cd", "ext": "java", "lang": "Java", "content": "public class IssuesController extends ModelController<Issue> {\n\n\tpublic IssuesController(Path path) {\n\t\tsuper(path);\n\t}\n\t@Override\n\tprotected HtmlView constructModelListView(List<Issue> records,boolean isCompleteList){\n\t\treturn new ModelListView<Issue>(getPath(), new String[]{\"ID\",\"TITLE\",\"PRIORITY\",\"STATUS\",\"ASSIGNED_TO_ID\",\"RESOLUTION\",\"CREATOR_USER_ID\"}, records, isCompleteList);\n    }\n\t\n\t@Override\n\tprotected HtmlView createBlankView(Path path , Issue record, String formAction){\n\t\tHtmlView bv = super.createBlankView(path, record,formAction);\n\t\tif (bv instanceof AbstractModelView){\n\t\t\tAbstractModelView mev = ((AbstractModelView)bv);\n\t\t\tmev.getIncludedFields().removeAll(Arrays.asList(\"STATUS\",\"RESOLUTION\"));\n\t\t\tConfig.instance().getLogger(IssuesController.class.getName()).info(mev.getIncludedFields().toString());\n\t\t}\n\n\t\treturn bv;\n\t}\n\n\t@SingleRecordAction(tooltip=\"Yank\")\n\tpublic View yank(long id){\n\t\tIssue issue = Database.getTable(Issue.class).get(id);\n\t\tissue.yank();\n\t\treturn afterPersistDBView(issue);\n\t}\n\n\t@Override\n\tprotected Map<Class<? extends Model>, List<String>> getIncludedModelFields() {\n\t\tMap<Class<? extends Model>, List<String>> map =  super.getIncludedModelFields();\n\t\tmap.put(Note.class, ModelReflector.instance(Note.class).getVisibleFields(Arrays.asList(\"ID\",\"LOCK_ID\",\"CREATED_AT\" ,\"UPDATED_AT\",\"CREATOR_USER_ID\")));\n\t\treturn map;\n\t}\n}", "item_id": 0, "repo": "venkatramanm/swf-all", "file": "swf-plugin-bugs/src/main/java/com/venky/swf/plugins/bugs/controller/IssuesController.java", "last_update_at": "2022-02-04T19:41:20+00:00", "question_id": "ffcbb4fe4625789106460362fa40f62e87e1f2cd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IssuesController extends ModelController<Issue> {\n\tpublic IssuesController(Path path) {\n\t\tsuper(path);\n\t}\n\t@Override\n\tprotected HtmlView constructModelListView(List<Issue> records,boolean isCompleteList){\n\t\treturn new ModelListView<Issue>(getPath(), new String[]{\"ID\",\"TITLE\",\"PRIORITY\",\"STATUS\",\"ASSIGNED_TO_ID\",\"RESOLUTION\",\"CREATOR_USER_ID\"}, records, isCompleteList);\n    }\n\t\n\t@Override\n\tprotected HtmlView createBlankView(Path path , Issue record, String formAction){\n\t\tHtmlView bv = super.createBlankView(path, record,formAction);\n\t\tif (bv instanceof AbstractModelView){\n\t\t\tAbstractModelView mev = ((AbstractModelView)bv);\n\t\t\tmev.getIncludedFields().removeAll(Arrays.asList(\"STATUS\",\"RESOLUTION\"));\n\t\t\tConfig.instance().getLogger(IssuesController.class.getName()).info(mev.getIncludedFields().toString());\n\t\t}\n\t\treturn bv;\n\t}\n\t@SingleRecordAction(tooltip=\"Yank\")\n\tpublic View yank(long id){\n\t\tIssue issue = Database.getTable(Issue.class).get(id);\n\t\tissue.yank();\n\t\treturn afterPersistDBView(issue);\n\t}\n\t@Override\n\tprotected Map<Class<? extends Model>, List<String>> getIncludedModelFields() {\n\t\tMap<Class<? extends Model>, List<String>> map =  super.getIncludedModelFields();\n\t\tmap.put(Note.class, ModelReflector.instance(Note.class).getVisibleFields(Arrays.asList(\"ID\",\"LOCK_ID\",\"CREATED_AT\" ,\"UPDATED_AT\",\"CREATOR_USER_ID\")));\n\t\treturn map;\n\t}\n"]], "pred": {"ppl": 3.2600607872009277, "ppl_lower": 4.029074668884277, "ppl/lowercase_ppl": -1.1792186524860229, "ppl/zlib": 0.0018435972567635373, "Min_5.0% Prob": 8.425782120746115, "Min_10.0% Prob": 6.752498720003211, "Min_20.0% Prob": 4.747032134763656, "Min_30.0% Prob": 3.600094870158604, "Min_40.0% Prob": 2.8647444317097306, "Min_50.0% Prob": 2.3409666520075736, "Min_60.0% Prob": 1.9642314079616752}}
{"hexsha": "1e07b4cb88290aa5e3722fcbba740f81298d82b4", "ext": "java", "lang": "Java", "content": "public class Sql2oIntegrationTest {\n\n\n    @Test\n    public void testSql2O() throws SQLException, ParseException {\n        Connection connection = DbHelper.objectDb();\n        try {\n            SingleConnectionDataSource scds = new SingleConnectionDataSource(connection, true);\n            Sql2o sql2o = new Sql2o(scds);\n\n            Query query = sql2o.open().createQuery(DbHelper.TEST_DB_OBJECT_QUERY);\n            query.setAutoDeriveColumnNames(true);\n            query.setResultSetHandlerFactoryBuilder(new SfmResultSetHandlerFactoryBuilder());\n\n            List<DbObject> dbObjects = query.executeAndFetch(DbObject.class);\n\n            assertEquals(1, dbObjects.size());\n            DbHelper.assertDbObjectMapping(dbObjects.get(0));\n\n        } finally {\n            connection.close();\n        }\n    }\n\n\n    //IFJAVA8_START\n    @Test\n    public void testDiscriminator608() throws SQLException {\n        Connection connection = DbHelper.getDbConnection(DbHelper.TargetDB.POSTGRESQL);\n        if ( connection == null) return;\n        try {\n            SingleConnectionDataSource scds = new SingleConnectionDataSource(connection, true);\n            Sql2o sql2o = new Sql2o(scds);\n\n            Query query = sql2o.open().createQuery(\"with t(id, type, name) as (values(1, 's', 'solar'), (2, 'e', 'electric')) select * from t\" +\n                    \"\");\n            query.setAutoDeriveColumnNames(true);\n\n            JdbcMapperFactory jdbcMapperFactory = JdbcMapperFactory\n                    .newInstance()\n                    .discriminator(Device.class,\n                            \"type\",\n                            ResultSet::getString,\n                            b ->\n                                    b.when(\"e\", ElectricDevice.class)\n                                            .when(\"s\", SolarDevice.class));\n\n            query.setResultSetHandlerFactoryBuilder(new SfmResultSetHandlerFactoryBuilder(jdbcMapperFactory));\n\n\n            List<Device> devices = query.executeAndFetch(Device.class);\n\n\n            assertEquals(2, devices.size());\n\n            assertEquals(new SolarDevice(1, \"s\", \"solar\"), devices.get(0));\n            assertEquals(new ElectricDevice(2, \"e\", \"electric\"), devices.get(1));\n\n\n\n        } finally {\n            connection.close();\n        }\n    }\n    //IFJAVA8_END\n\n\n    public static abstract class Device {\n        public final int id;\n        public final String type;\n        public final String name;\n\n        protected Device(int id, String type, String name) {\n            this.id = id;\n            this.type = type;\n            this.name = name;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            Device device = (Device) o;\n\n            if (id != device.id) return false;\n            if (type != null ? !type.equals(device.type) : device.type != null) return false;\n            return name != null ? name.equals(device.name) : device.name == null;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = id;\n            result = 31 * result + (type != null ? type.hashCode() : 0);\n            result = 31 * result + (name != null ? name.hashCode() : 0);\n            return result;\n        }\n    }\n\n    public static class ElectricDevice extends Device {\n        public ElectricDevice(int id, String type, String name) {\n            super(id, type, name);\n        }\n\n\n\n    }\n\n    public static class SolarDevice extends Device {\n        public SolarDevice(int id, String type, String name) {\n            super(id, type, name);\n        }\n    }\n\n}", "item_id": 0, "repo": "khauser/SimpleFlatMapper", "file": "sfm-sql2o/src/test/java/org/simpleflatmapper/sql2o/test/Sql2oIntegrationTest.java", "last_update_at": "2022-03-17T21:19:46+00:00", "question_id": "1e07b4cb88290aa5e3722fcbba740f81298d82b4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Sql2oIntegrationTest {\n    @Test\n    public void testSql2O() throws SQLException, ParseException {\n        Connection connection = DbHelper.objectDb();\n        try {\n            SingleConnectionDataSource scds = new SingleConnectionDataSource(connection, true);\n            Sql2o sql2o = new Sql2o(scds);\n            Query query = sql2o.open().createQuery(DbHelper.TEST_DB_OBJECT_QUERY);\n            query.setAutoDeriveColumnNames(true);\n            query.setResultSetHandlerFactoryBuilder(new SfmResultSetHandlerFactoryBuilder());\n            List<DbObject> dbObjects = query.executeAndFetch(DbObject.class);\n            assertEquals(1, dbObjects.size());\n            DbHelper.assertDbObjectMapping(dbObjects.get(0));\n        } finally {\n            connection.close();\n        }\n    }\n    //IFJAVA8_START\n    @Test\n    public void testDiscriminator608() throws SQLException {\n        Connection connection = DbHelper.getDbConnection(DbHelper.TargetDB.POSTGRESQL);\n        if ( connection == null) return;\n        try {\n            SingleConnectionDataSource scds = new SingleConnectionDataSource(connection, true);\n            Sql2o sql2o = new Sql2o(scds);\n            Query query = sql2o.open().createQuery(\"with t(id, type, name) as (values(1, 's', 'solar'), (2, 'e', 'electric')) select * from t\" +\n                    \"\");\n            query.setAutoDeriveColumnNames(true);\n            JdbcMapperFactory jdbcMapperFactory = JdbcMapperFactory\n                    .newInstance()\n                    .discriminator(Device.class,\n                            \"type\",\n                            ResultSet::getString,\n                            b ->\n                                    b.when(\"e\", ElectricDevice.class)\n                                            .when(\"s\", SolarDevice.class));\n            query.setResultSetHandlerFactoryBuilder(new SfmResultSetHandlerFactoryBuilder(jdbcMapperFactory));\n            List<Device> devices = query.executeAndFetch(Device.class);\n            assertEquals(2, devices.size());\n            assertEquals(new SolarDevice(1, \"s\", \"solar\"), devices.get(0));\n            assertEquals(new ElectricDevice(2, \"e\", \"electric\"), devices.get(1));\n        } finally {\n            connection.close();\n        }\n    }\n    //IFJAVA8_END\n    public static abstract class Device {\n        public final int id;\n        public final String type;\n        public final String name;\n        protected Device(int id, String type, String name) {\n            this.id = id;\n            this.type = type;\n            this.name = name;\n        }\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Device device = (Device) o;\n            if (id != device.id) return false;\n            if (type != null ? !type.equals(device.type) : device.type != null) return false;\n            return name != null ? name.equals(device.name) : device.name == null;\n        }\n        @Override\n        public int hashCode() {\n            int result = id;\n            result = 31 * result + (type != null ? type.hashCode() : 0);\n            result = 31 * result + (name != null ? name.hashCode() : 0);\n            return result;\n        }\n    }\n    public static class ElectricDevice extends Device {\n        public ElectricDevice(int id, String type, String name) {\n            super(id, type, name);\n        }\n    }\n    public static class SolarDevice extends Device {\n        public SolarDevice(int id, String type, String name) {\n            super(id, type, name);\n        }\n    }\n"]], "pred": {"ppl": 1.6697996854782104, "ppl_lower": 1.9196827411651611, "ppl/lowercase_ppl": -1.2720016864264905, "ppl/zlib": 0.0004915663187140809, "Min_5.0% Prob": 6.094622542460759, "Min_10.0% Prob": 4.113419089120688, "Min_20.0% Prob": 2.429827703573765, "Min_30.0% Prob": 1.68569413478464, "Min_40.0% Prob": 1.2795427157663, "Min_50.0% Prob": 1.0252672554419346, "Min_60.0% Prob": 0.854490984835163}}
{"hexsha": "c55147ed1c6bd71ff454f0c5a6482b20027e7707", "ext": "java", "lang": "Java", "content": "public class ElementFieldDecorator extends DefaultFieldDecorator {\n\n\tpublic ElementFieldDecorator(ElementLocatorFactory factory) {\n\t\tsuper(factory);\n\t}\n\t\n\t@Override\n\tprotected boolean isDecoratableList(Field field) {\n\t    if (!List.class.isAssignableFrom(field.getType())) {\n\t      return false;\n\t    }\n\n\t    // Type erasure in Java isn't complete. Attempt to discover the generic\n\t    // type of the list.\n\t    Type genericType = field.getGenericType();\n\t    if (!(genericType instanceof ParameterizedType)) {\n\t      return false;\n\t    }\n\n\t    Type listType = ((ParameterizedType) genericType).getActualTypeArguments()[0];\n\n\t    if (!WebElement.class.equals(listType)) {\n\t      return false;\n\t    }\n\n\t    if (field.getAnnotation(FindElementBy.class) == null &&\n\t    \tfield.getAnnotation(FindBy.class) == null &&\n\t        field.getAnnotation(FindBys.class) == null &&\n\t        field.getAnnotation(FindAll.class) == null) {\n\t      return false;\n\t    }\n\n\t    return true;\n\t  }\n\n}", "item_id": 0, "repo": "sukgu/com.shadow.automation", "file": "src/main/java/io/github/sukgu/support/ElementFieldDecorator.java", "last_update_at": "2022-03-10T13:48:11+00:00", "question_id": "c55147ed1c6bd71ff454f0c5a6482b20027e7707_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ElementFieldDecorator extends DefaultFieldDecorator {\n\tpublic ElementFieldDecorator(ElementLocatorFactory factory) {\n\t\tsuper(factory);\n\t}\n\t\n\t@Override\n\tprotected boolean isDecoratableList(Field field) {\n\t    if (!List.class.isAssignableFrom(field.getType())) {\n\t      return false;\n\t    }\n\t    // Type erasure in Java isn't complete. Attempt to discover the generic\n\t    // type of the list.\n\t    Type genericType = field.getGenericType();\n\t    if (!(genericType instanceof ParameterizedType)) {\n\t      return false;\n\t    }\n\t    Type listType = ((ParameterizedType) genericType).getActualTypeArguments()[0];\n\t    if (!WebElement.class.equals(listType)) {\n\t      return false;\n\t    }\n\t    if (field.getAnnotation(FindElementBy.class) == null &&\n\t    \tfield.getAnnotation(FindBy.class) == null &&\n\t        field.getAnnotation(FindBys.class) == null &&\n\t        field.getAnnotation(FindAll.class) == null) {\n\t      return false;\n\t    }\n\t    return true;\n\t  }\n"]], "pred": {"ppl": 1.7936331033706665, "ppl_lower": 2.4130666255950928, "ppl/lowercase_ppl": -1.5077597014607247, "ppl/zlib": 0.001453341367038861, "Min_5.0% Prob": 5.5696708043416345, "Min_10.0% Prob": 4.097336173057556, "Min_20.0% Prob": 2.6698449029297127, "Min_30.0% Prob": 1.916435489123994, "Min_40.0% Prob": 1.4539262673771771, "Min_50.0% Prob": 1.1653719280170751, "Min_60.0% Prob": 0.9759440723592874}}
{"hexsha": "ce150fb300b4026c8524ced5dcd54a568fa5cb4a", "ext": "java", "lang": "Java", "content": "@RunWith(PowerMockRunner.class)\n    @PrepareForTest({LDAPUtils.class, UserLoginProfileImpl.class})\n    @MockPolicy(Slf4jMockPolicy.class) @PowerMockIgnore(\n        {\"javax.management.*\"}) public class UserLoginProfileImplTest {\n\n private\n  final UserLoginProfileImpl userLoginProfileImpl;\n private\n  final LDAPSearchResults ldapResults;\n private\n  final LDAPEntry entry;\n\n private\n  final LDAPAttribute userIdAttr;\n private\n  final LDAPAttribute objectClassAttr;\n private\n  final LDAPAttribute pathAttr;\n private\n  final LDAPAttribute commonNameAttr;\n private\n  final LDAPAttribute roleAttr;\n\n  @Rule public final ExpectedException exception = ExpectedException.none();\n\n public\n  UserLoginProfileImplTest() {\n    userLoginProfileImpl = new UserLoginProfileImpl();\n    ldapResults = Mockito.mock(LDAPSearchResults.class);\n    entry = Mockito.mock(LDAPEntry.class);\n    userIdAttr = Mockito.mock(LDAPAttribute.class);\n    objectClassAttr = Mockito.mock(LDAPAttribute.class);\n    pathAttr = Mockito.mock(LDAPAttribute.class);\n    commonNameAttr = Mockito.mock(LDAPAttribute.class);\n    roleAttr = Mockito.mock(LDAPAttribute.class);\n  }\n\n  @Before public void setUp() throws Exception {\n    PowerMockito.mockStatic(LDAPUtils.class);\n    Mockito.when(ldapResults.next()).thenReturn(entry);\n  }\n\n  @Test public void Create_UserLoginProfileFailed_ThrowException()\n      throws Exception {\n\n    PowerMockito.mockStatic(UserLoginProfileImpl.class);\n    User user = new User();\n    user.setAccountName(\"s3test\");\n    user.setName(\"s3testuser\");\n    user.setId(\"123\");\n    user.setPassword(\"abcdef\");\n    user.setProfileCreateDate(\"2019-06-16 15:38:53+00:00\");\n    user.setPwdResetRequired(\"true\");\n\n    String dn = \"s3userid=123,ou=users,o=s3test,ou=accounts,dc=s3,\" +\n                \"dc=seagate,dc=com\";\n\n    ArrayList mockList = Mockito.mock(ArrayList.class);\n    PowerMockito.whenNew(ArrayList.class).withNoArguments().thenReturn(\n        mockList);\n\n    PowerMockito.doThrow(new LDAPException())\n        .when(LDAPUtils.class, \"modify\", dn, mockList);\n\n    exception.expect(DataAccessException.class);\n\n    userLoginProfileImpl.save(user);\n  }\n\n  @Test public void Update_UserModifySuccess() throws Exception {\n\n    User user = new User();\n    user.setAccountName(\"s3test\");\n    user.setName(\"s3testuser\");\n    user.setId(\"123\");\n    user.setPassword(\"abcd\");\n    user.setProfileCreateDate(\"2019-06-16 15:38:53+00:00\");\n    user.setPwdResetRequired(\"true\");\n\n    ArrayList modifyList = Mockito.mock(ArrayList.class);\n    LDAPAttribute ldapAttribute = Mockito.mock(LDAPAttribute.class);\n    LDAPModification modification = Mockito.mock(LDAPModification.class);\n\n    PowerMockito.whenNew(ArrayList.class).withNoArguments().thenReturn(\n        modifyList);\n\n    PowerMockito.whenNew(LDAPAttribute.class).withAnyArguments().thenReturn(\n        ldapAttribute);\n\n    PowerMockito.whenNew(LDAPModification.class)\n        .withParameterTypes(int.class, LDAPAttribute.class)\n        .withArguments(LDAPModification.REPLACE, ldapAttribute)\n        .thenReturn(modification);\n\n    String dn = \"s3userid=123,ou=users,o=s3test,ou=accounts,dc=s3,\" +\n                \"dc=seagate,dc=com\";\n\n    userLoginProfileImpl.save(user);\n\n    PowerMockito.verifyNew(LDAPAttribute.class)\n        .withArguments(\"userPassword\", \"abcd\");\n    PowerMockito.verifyNew(LDAPModification.class, times(3))\n        .withArguments(LDAPModification.REPLACE, ldapAttribute);\n    Mockito.verify(modifyList, Mockito.times(3)).add(modification);\n\n    PowerMockito.verifyStatic(Mockito.times(1));\n    LDAPUtils.modify(dn, modifyList);\n  }\n}", "item_id": 0, "repo": "RakeshVaghasiya/cortx-s3server", "file": "auth/server/src/test/java/com/seagates3/dao/ldap/UserLoginProfileImplTest.java", "last_update_at": "2022-03-23T07:49:57+00:00", "question_id": "ce150fb300b4026c8524ced5dcd54a568fa5cb4a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(PowerMockRunner.class)\n    @PrepareForTest({LDAPUtils.class, UserLoginProfileImpl.class})\n    @MockPolicy(Slf4jMockPolicy.class) @PowerMockIgnore(\n        {\"javax.management.*\"}) public class UserLoginProfileImplTest {\n private\n  final UserLoginProfileImpl userLoginProfileImpl;\n private\n  final LDAPSearchResults ldapResults;\n private\n  final LDAPEntry entry;\n private\n  final LDAPAttribute userIdAttr;\n private\n  final LDAPAttribute objectClassAttr;\n private\n  final LDAPAttribute pathAttr;\n private\n  final LDAPAttribute commonNameAttr;\n private\n  final LDAPAttribute roleAttr;\n  @Rule public final ExpectedException exception = ExpectedException.none();\n public\n  UserLoginProfileImplTest() {\n    userLoginProfileImpl = new UserLoginProfileImpl();\n    ldapResults = Mockito.mock(LDAPSearchResults.class);\n    entry = Mockito.mock(LDAPEntry.class);\n    userIdAttr = Mockito.mock(LDAPAttribute.class);\n    objectClassAttr = Mockito.mock(LDAPAttribute.class);\n    pathAttr = Mockito.mock(LDAPAttribute.class);\n    commonNameAttr = Mockito.mock(LDAPAttribute.class);\n    roleAttr = Mockito.mock(LDAPAttribute.class);\n  }\n  @Before public void setUp() throws Exception {\n    PowerMockito.mockStatic(LDAPUtils.class);\n    Mockito.when(ldapResults.next()).thenReturn(entry);\n  }\n  @Test public void Create_UserLoginProfileFailed_ThrowException()\n      throws Exception {\n    PowerMockito.mockStatic(UserLoginProfileImpl.class);\n    User user = new User();\n    user.setAccountName(\"s3test\");\n    user.setName(\"s3testuser\");\n    user.setId(\"123\");\n    user.setPassword(\"abcdef\");\n    user.setProfileCreateDate(\"2019-06-16 15:38:53+00:00\");\n    user.setPwdResetRequired(\"true\");\n    String dn = \"s3userid=123,ou=users,o=s3test,ou=accounts,dc=s3,\" +\n                \"dc=seagate,dc=com\";\n    ArrayList mockList = Mockito.mock(ArrayList.class);\n    PowerMockito.whenNew(ArrayList.class).withNoArguments().thenReturn(\n        mockList);\n    PowerMockito.doThrow(new LDAPException())\n        .when(LDAPUtils.class, \"modify\", dn, mockList);\n    exception.expect(DataAccessException.class);\n    userLoginProfileImpl.save(user);\n  }\n  @Test public void Update_UserModifySuccess() throws Exception {\n    User user = new User();\n    user.setAccountName(\"s3test\");\n    user.setName(\"s3testuser\");\n    user.setId(\"123\");\n    user.setPassword(\"abcd\");\n    user.setProfileCreateDate(\"2019-06-16 15:38:53+00:00\");\n    user.setPwdResetRequired(\"true\");\n    ArrayList modifyList = Mockito.mock(ArrayList.class);\n    LDAPAttribute ldapAttribute = Mockito.mock(LDAPAttribute.class);\n    LDAPModification modification = Mockito.mock(LDAPModification.class);\n    PowerMockito.whenNew(ArrayList.class).withNoArguments().thenReturn(\n        modifyList);\n    PowerMockito.whenNew(LDAPAttribute.class).withAnyArguments().thenReturn(\n        ldapAttribute);\n    PowerMockito.whenNew(LDAPModification.class)\n        .withParameterTypes(int.class, LDAPAttribute.class)\n        .withArguments(LDAPModification.REPLACE, ldapAttribute)\n        .thenReturn(modification);\n    String dn = \"s3userid=123,ou=users,o=s3test,ou=accounts,dc=s3,\" +\n                \"dc=seagate,dc=com\";\n    userLoginProfileImpl.save(user);\n    PowerMockito.verifyNew(LDAPAttribute.class)\n        .withArguments(\"userPassword\", \"abcd\");\n    PowerMockito.verifyNew(LDAPModification.class, times(3))\n        .withArguments(LDAPModification.REPLACE, ldapAttribute);\n    Mockito.verify(modifyList, Mockito.times(3)).add(modification);\n    PowerMockito.verifyStatic(Mockito.times(1));\n    LDAPUtils.modify(dn, modifyList);\n  }\n"]], "pred": {"ppl": 1.7694470882415771, "ppl_lower": 2.0932469367980957, "ppl/lowercase_ppl": -1.2944786813400724, "ppl/zlib": 0.0005963083785376785, "Min_5.0% Prob": 5.852307291591869, "Min_10.0% Prob": 4.219399709327548, "Min_20.0% Prob": 2.671625333381634, "Min_30.0% Prob": 1.8742752308939017, "Min_40.0% Prob": 1.4198811468201482, "Min_50.0% Prob": 1.14032217938956, "Min_60.0% Prob": 0.9517285750387312}}
{"hexsha": "a2a24e9efd0b795da6aa78ab5f20c79a669ff65a", "ext": "java", "lang": "Java", "content": "@State(Scope.Benchmark)\npublic class ParameterFormatterBenchmark {\n    private static final Object[] ARGS = { \"arg1\", \"arg2\", \"arg3\", \"arg4\", \"arg5\", \"arg6\", \"arg7\", \"arg8\",\n            \"arg9\", \"arg10\",};\n\n    @State(Scope.Thread)\n    public static class ThreadState {\n        StringBuilder buffer = new StringBuilder(2048);\n        int[] indices = new int[255];\n        char[] copy = new char[4096];\n    }\n\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency3ParamsV3(final ThreadState state) {\n        state.buffer.setLength(0);\n        final String STR = \"p1={}, p2={}, p3={}\";\n        final int length = STR.length();\n        STR.getChars(0, length, state.copy, 0);\n        final int count = ParameterFormatter.countArgumentPlaceholders3(state.copy, length, state.indices);\n        ParameterFormatter.formatMessage3(state.buffer, state.copy, length, ARGS, count, state.indices);\n        return state.buffer.length();\n    }\n\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency5ParamsV3(final ThreadState state) {\n        state.buffer.setLength(0);\n        final String STR = \"p1={}, p2={}, p3={}, p4={}, p5={}\";\n        final int length = STR.length();\n        STR.getChars(0, length, state.copy, 0);\n        final int count = ParameterFormatter.countArgumentPlaceholders3(state.copy, length, state.indices);\n        ParameterFormatter.formatMessage3(state.buffer, state.copy, length, ARGS, count, state.indices);\n        return state.buffer.length();\n    }\n\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency7ParamsV3(final ThreadState state) {\n        state.buffer.setLength(0);\n        final String STR = \"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}\";\n        final int length = STR.length();\n        STR.getChars(0, length, state.copy, 0);\n        final int count = ParameterFormatter.countArgumentPlaceholders3(state.copy, length, state.indices);\n        ParameterFormatter.formatMessage3(state.buffer, state.copy, length, ARGS, count, state.indices);\n        return state.buffer.length();\n    }\n\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency9ParamsV3(final ThreadState state) {\n        state.buffer.setLength(0);\n        final String STR = \"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}, p8={}, p9={}\";\n        final int length = STR.length();\n        STR.getChars(0, length, state.copy, 0);\n        final int count = ParameterFormatter.countArgumentPlaceholders3(state.copy, length, state.indices);\n        ParameterFormatter.formatMessage3(state.buffer, state.copy, length, ARGS, count, state.indices);\n        return state.buffer.length();\n    }\n\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency3ParamsV2(final ThreadState state) {\n        state.buffer.setLength(0);\n        final int count = ParameterFormatter.countArgumentPlaceholders2(\"p1={}, p2={}, p3={}\", state.indices);\n        ParameterFormatter.formatMessage2(state.buffer, \"p1={}, p2={}, p3={}\", ARGS, count, state.indices);\n        return state.buffer.length();\n    }\n\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency5ParamsV2(final ThreadState state) {\n        state.buffer.setLength(0);\n        final int count = ParameterFormatter.countArgumentPlaceholders2(\"p1={}, p2={}, p3={}, p4={}, p5={}\", state.indices);\n        ParameterFormatter.formatMessage2(state.buffer, \"p1={}, p2={}, p3={}, p4={}, p5={}\", ARGS, count, state.indices);\n        return state.buffer.length();\n    }\n\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency7ParamsV2(final ThreadState state) {\n        state.buffer.setLength(0);\n        final int count = ParameterFormatter.countArgumentPlaceholders2(\"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}\", state.indices);\n        ParameterFormatter.formatMessage2(state.buffer, \"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}\", ARGS, count, state.indices);\n        return state.buffer.length();\n    }\n\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency9ParamsV2(final ThreadState state) {\n        state.buffer.setLength(0);\n        final int count = ParameterFormatter.countArgumentPlaceholders2(\"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}, p8={}, p9={}\", state.indices);\n        ParameterFormatter.formatMessage2(state.buffer, \"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}, p8={}, p9={}\", ARGS, count, state.indices);\n        return state.buffer.length();\n    }\n\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency3Params(final ThreadState state) {\n        state.buffer.setLength(0);\n        final int count = ParameterFormatter.countArgumentPlaceholders(\"p1={}, p2={}, p3={}\");\n        ParameterFormatter.formatMessage(state.buffer, \"p1={}, p2={}, p3={}\", ARGS, count);\n        return state.buffer.length();\n    }\n\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency5Params(final ThreadState state) {\n        state.buffer.setLength(0);\n        final int count = ParameterFormatter.countArgumentPlaceholders(\"p1={}, p2={}, p3={}, p4={}, p5={}\");\n        ParameterFormatter.formatMessage(state.buffer, \"p1={}, p2={}, p3={}, p4={}, p5={}\", ARGS, count);\n        return state.buffer.length();\n    }\n\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency7Params(final ThreadState state) {\n        state.buffer.setLength(0);\n        final int count = ParameterFormatter.countArgumentPlaceholders(\"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}\");\n        ParameterFormatter.formatMessage(state.buffer, \"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}\", ARGS, count);\n        return state.buffer.length();\n    }\n\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency9Params(final ThreadState state) {\n        state.buffer.setLength(0);\n        final int count = ParameterFormatter.countArgumentPlaceholders(\"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}, p8={}, p9={}\");\n        ParameterFormatter.formatMessage(state.buffer, \"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}, p8={}, p9={}\", ARGS, count);\n        return state.buffer.length();\n    }\n}", "item_id": 0, "repo": "NgSekLong/logging-log4j2", "file": "log4j-perf/src/main/java/org/apache/logging/log4j/message/ParameterFormatterBenchmark.java", "last_update_at": "2022-03-31T06:11:10+00:00", "question_id": "a2a24e9efd0b795da6aa78ab5f20c79a669ff65a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@State(Scope.Benchmark)\npublic class ParameterFormatterBenchmark {\n    private static final Object[] ARGS = { \"arg1\", \"arg2\", \"arg3\", \"arg4\", \"arg5\", \"arg6\", \"arg7\", \"arg8\",\n            \"arg9\", \"arg10\",};\n    @State(Scope.Thread)\n    public static class ThreadState {\n        StringBuilder buffer = new StringBuilder(2048);\n        int[] indices = new int[255];\n        char[] copy = new char[4096];\n    }\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency3ParamsV3(final ThreadState state) {\n        state.buffer.setLength(0);\n        final String STR = \"p1={}, p2={}, p3={}\";\n        final int length = STR.length();\n        STR.getChars(0, length, state.copy, 0);\n        final int count = ParameterFormatter.countArgumentPlaceholders3(state.copy, length, state.indices);\n        ParameterFormatter.formatMessage3(state.buffer, state.copy, length, ARGS, count, state.indices);\n        return state.buffer.length();\n    }\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency5ParamsV3(final ThreadState state) {\n        state.buffer.setLength(0);\n        final String STR = \"p1={}, p2={}, p3={}, p4={}, p5={}\";\n        final int length = STR.length();\n        STR.getChars(0, length, state.copy, 0);\n        final int count = ParameterFormatter.countArgumentPlaceholders3(state.copy, length, state.indices);\n        ParameterFormatter.formatMessage3(state.buffer, state.copy, length, ARGS, count, state.indices);\n        return state.buffer.length();\n    }\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency7ParamsV3(final ThreadState state) {\n        state.buffer.setLength(0);\n        final String STR = \"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}\";\n        final int length = STR.length();\n        STR.getChars(0, length, state.copy, 0);\n        final int count = ParameterFormatter.countArgumentPlaceholders3(state.copy, length, state.indices);\n        ParameterFormatter.formatMessage3(state.buffer, state.copy, length, ARGS, count, state.indices);\n        return state.buffer.length();\n    }\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency9ParamsV3(final ThreadState state) {\n        state.buffer.setLength(0);\n        final String STR = \"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}, p8={}, p9={}\";\n        final int length = STR.length();\n        STR.getChars(0, length, state.copy, 0);\n        final int count = ParameterFormatter.countArgumentPlaceholders3(state.copy, length, state.indices);\n        ParameterFormatter.formatMessage3(state.buffer, state.copy, length, ARGS, count, state.indices);\n        return state.buffer.length();\n    }\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency3ParamsV2(final ThreadState state) {\n        state.buffer.setLength(0);\n        final int count = ParameterFormatter.countArgumentPlaceholders2(\"p1={}, p2={}, p3={}\", state.indices);\n        ParameterFormatter.formatMessage2(state.buffer, \"p1={}, p2={}, p3={}\", ARGS, count, state.indices);\n        return state.buffer.length();\n    }\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency5ParamsV2(final ThreadState state) {\n        state.buffer.setLength(0);\n        final int count = ParameterFormatter.countArgumentPlaceholders2(\"p1={}, p2={}, p3={}, p4={}, p5={}\", state.indices);\n        ParameterFormatter.formatMessage2(state.buffer, \"p1={}, p2={}, p3={}, p4={}, p5={}\", ARGS, count, state.indices);\n        return state.buffer.length();\n    }\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency7ParamsV2(final ThreadState state) {\n        state.buffer.setLength(0);\n        final int count = ParameterFormatter.countArgumentPlaceholders2(\"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}\", state.indices);\n        ParameterFormatter.formatMessage2(state.buffer, \"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}\", ARGS, count, state.indices);\n        return state.buffer.length();\n    }\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency9ParamsV2(final ThreadState state) {\n        state.buffer.setLength(0);\n        final int count = ParameterFormatter.countArgumentPlaceholders2(\"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}, p8={}, p9={}\", state.indices);\n        ParameterFormatter.formatMessage2(state.buffer, \"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}, p8={}, p9={}\", ARGS, count, state.indices);\n        return state.buffer.length();\n    }\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency3Params(final ThreadState state) {\n        state.buffer.setLength(0);\n        final int count = ParameterFormatter.countArgumentPlaceholders(\"p1={}, p2={}, p3={}\");\n        ParameterFormatter.formatMessage(state.buffer, \"p1={}, p2={}, p3={}\", ARGS, count);\n        return state.buffer.length();\n    }\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency5Params(final ThreadState state) {\n        state.buffer.setLength(0);\n        final int count = ParameterFormatter.countArgumentPlaceholders(\"p1={}, p2={}, p3={}, p4={}, p5={}\");\n        ParameterFormatter.formatMessage(state.buffer, \"p1={}, p2={}, p3={}, p4={}, p5={}\", ARGS, count);\n        return state.buffer.length();\n    }\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency7Params(final ThreadState state) {\n        state.buffer.setLength(0);\n        final int count = ParameterFormatter.countArgumentPlaceholders(\"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}\");\n        ParameterFormatter.formatMessage(state.buffer, \"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}\", ARGS, count);\n        return state.buffer.length();\n    }\n    @Benchmark\n    @BenchmarkMode(Mode.SampleTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    public int latency9Params(final ThreadState state) {\n        state.buffer.setLength(0);\n        final int count = ParameterFormatter.countArgumentPlaceholders(\"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}, p8={}, p9={}\");\n        ParameterFormatter.formatMessage(state.buffer, \"p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}, p8={}, p9={}\", ARGS, count);\n        return state.buffer.length();\n    }\n"]], "pred": {"ppl": 1.3499656915664673, "ppl_lower": 1.4449265003204346, "ppl/lowercase_ppl": -1.2265378001685674, "ppl/zlib": 0.00047034353992623357, "Min_5.0% Prob": 4.786514296251185, "Min_10.0% Prob": 2.865061099330584, "Min_20.0% Prob": 1.4980026463722336, "Min_30.0% Prob": 1.0021119475200333, "Min_40.0% Prob": 0.7503336178399862, "Min_50.0% Prob": 0.6006813239421943, "Min_60.0% Prob": 0.5007669254153231}}
{"hexsha": "437d1e78154dc2f307c2f7732b10fabb7fd2e481", "ext": "java", "lang": "Java", "content": "public class WizardDialog extends JDialog {\n\n  private static final long serialVersionUID = 1L;\n\n  private WizardController wizardController;\n\n  private final JPanel contentPanel = new JPanel();\n  private JButton nextButton;\n  private JButton backButton;\n\n  /**\n   * Create the dialog.\n   * \n   * @param controller\n   */\n  public WizardDialog(WizardController controller) {\n    this.wizardController = controller;\n    controller.addPropertyChangeListener(new WizardControllerPropertyChangeHandler());\n    controller.addCompletionListener(new WizardCompletionHandler());\n\n    setBounds(100, 100, 450, 300);\n    getContentPane().setLayout(new BorderLayout());\n    contentPanel.setBorder(new EmptyBorder(5, 5, 5, 5));\n    getContentPane().add(contentPanel, BorderLayout.CENTER);\n    contentPanel.setLayout(new BorderLayout(0, 0));\n    {\n      JPanel buttonPane = new JPanel();\n      buttonPane.setLayout(new FlowLayout(FlowLayout.RIGHT));\n      getContentPane().add(buttonPane, BorderLayout.SOUTH);\n      {\n        JButton cancelButton = new JButton(\"Cancel\");\n        cancelButton.addActionListener(new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            wizardController.handleCancelButton();\n          }\n        });\n        cancelButton.setActionCommand(\"Cancel\");\n        buttonPane.add(cancelButton);\n      }\n      {\n        backButton = new JButton(\"Back\");\n        backButton.addActionListener(new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            wizardController.handleBackButton();\n          }\n        });\n        buttonPane.add(backButton);\n      }\n      {\n        nextButton = new JButton(\"Next\");\n        nextButton.addActionListener(new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            wizardController.handleNextButton();\n          }\n        });\n        nextButton.setActionCommand(\"OK\");\n        buttonPane.add(nextButton);\n        getRootPane().setDefaultButton(nextButton);\n      }\n    }\n    initDataBindings();\n    updateControlPanel();\n  }\n\n  protected void initDataBindings() {\n    BeanProperty<WizardController, Boolean> wizardControllerBeanProperty = BeanProperty.create(\"nextButtonEnabled\");\n    BeanProperty<JButton, Boolean> jButtonBeanProperty = BeanProperty.create(\"enabled\");\n    AutoBinding<WizardController, Boolean, JButton, Boolean> autoBinding = Bindings.createAutoBinding(\n        UpdateStrategy.READ, wizardController, wizardControllerBeanProperty,\n        nextButton, jButtonBeanProperty);\n    autoBinding.bind();\n    //\n    BeanProperty<WizardController, Boolean> wizardControllerBeanProperty_1 = BeanProperty.create(\"backButtonEnabled\");\n    AutoBinding<WizardController, Boolean, JButton, Boolean> autoBinding_1 = Bindings.createAutoBinding(\n        UpdateStrategy.READ, wizardController, wizardControllerBeanProperty_1,\n        backButton, jButtonBeanProperty);\n    autoBinding_1.bind();\n  }\n\n  private void updateControlPanel() {\n    contentPanel.removeAll();\n    WizardPanelController controller = wizardController.getCurrentController();\n    if (controller != null) {\n      JPanel panel = controller.getPanel();\n      if (panel != null) {\n        contentPanel.add(panel, BorderLayout.CENTER);\n        contentPanel.revalidate();\n      }\n    }\n  }\n\n  private class WizardControllerPropertyChangeHandler implements\n      PropertyChangeListener {\n\n    @Override\n    public void propertyChange(PropertyChangeEvent evt) {\n      String name = evt.getPropertyName();\n      if (name.equals(WizardController.PROPERTY_CURRENT_PANEL)) {\n        updateControlPanel();\n      }\n    }\n  }\n\n  private class WizardCompletionHandler implements WizardCompletionListener {\n\n    @Override\n    public void handleCanceled() {\n      handleFinished();\n    }\n\n    @Override\n    public void handleFinished() {\n      WizardDialog.this.setVisible(false);\n    }\n  }\n}", "item_id": 0, "repo": "lubbo/onebusaway-openswift", "file": "onebusaway-quickstart/onebusaway-quickstart-mains/src/main/java/org/onebusaway/quickstart/bootstrap/gui/wizard/WizardDialog.java", "last_update_at": "2022-03-08T00:19:10+00:00", "question_id": "437d1e78154dc2f307c2f7732b10fabb7fd2e481_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class WizardDialog extends JDialog {\n  private static final long serialVersionUID = 1L;\n  private WizardController wizardController;\n  private final JPanel contentPanel = new JPanel();\n  private JButton nextButton;\n  private JButton backButton;\n  /**\n   * Create the dialog.\n   * \n   * @param controller\n   */\n  public WizardDialog(WizardController controller) {\n    this.wizardController = controller;\n    controller.addPropertyChangeListener(new WizardControllerPropertyChangeHandler());\n    controller.addCompletionListener(new WizardCompletionHandler());\n    setBounds(100, 100, 450, 300);\n    getContentPane().setLayout(new BorderLayout());\n    contentPanel.setBorder(new EmptyBorder(5, 5, 5, 5));\n    getContentPane().add(contentPanel, BorderLayout.CENTER);\n    contentPanel.setLayout(new BorderLayout(0, 0));\n    {\n      JPanel buttonPane = new JPanel();\n      buttonPane.setLayout(new FlowLayout(FlowLayout.RIGHT));\n      getContentPane().add(buttonPane, BorderLayout.SOUTH);\n      {\n        JButton cancelButton = new JButton(\"Cancel\");\n        cancelButton.addActionListener(new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            wizardController.handleCancelButton();\n          }\n        });\n        cancelButton.setActionCommand(\"Cancel\");\n        buttonPane.add(cancelButton);\n      }\n      {\n        backButton = new JButton(\"Back\");\n        backButton.addActionListener(new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            wizardController.handleBackButton();\n          }\n        });\n        buttonPane.add(backButton);\n      }\n      {\n        nextButton = new JButton(\"Next\");\n        nextButton.addActionListener(new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            wizardController.handleNextButton();\n          }\n        });\n        nextButton.setActionCommand(\"OK\");\n        buttonPane.add(nextButton);\n        getRootPane().setDefaultButton(nextButton);\n      }\n    }\n    initDataBindings();\n    updateControlPanel();\n  }\n  protected void initDataBindings() {\n    BeanProperty<WizardController, Boolean> wizardControllerBeanProperty = BeanProperty.create(\"nextButtonEnabled\");\n    BeanProperty<JButton, Boolean> jButtonBeanProperty = BeanProperty.create(\"enabled\");\n    AutoBinding<WizardController, Boolean, JButton, Boolean> autoBinding = Bindings.createAutoBinding(\n        UpdateStrategy.READ, wizardController, wizardControllerBeanProperty,\n        nextButton, jButtonBeanProperty);\n    autoBinding.bind();\n    //\n    BeanProperty<WizardController, Boolean> wizardControllerBeanProperty_1 = BeanProperty.create(\"backButtonEnabled\");\n    AutoBinding<WizardController, Boolean, JButton, Boolean> autoBinding_1 = Bindings.createAutoBinding(\n        UpdateStrategy.READ, wizardController, wizardControllerBeanProperty_1,\n        backButton, jButtonBeanProperty);\n    autoBinding_1.bind();\n  }\n  private void updateControlPanel() {\n    contentPanel.removeAll();\n    WizardPanelController controller = wizardController.getCurrentController();\n    if (controller != null) {\n      JPanel panel = controller.getPanel();\n      if (panel != null) {\n        contentPanel.add(panel, BorderLayout.CENTER);\n        contentPanel.revalidate();\n      }\n    }\n  }\n  private class WizardControllerPropertyChangeHandler implements\n      PropertyChangeListener {\n    @Override\n    public void propertyChange(PropertyChangeEvent evt) {\n      String name = evt.getPropertyName();\n      if (name.equals(WizardController.PROPERTY_CURRENT_PANEL)) {\n        updateControlPanel();\n      }\n    }\n  }\n  private class WizardCompletionHandler implements WizardCompletionListener {\n    @Override\n    public void handleCanceled() {\n      handleFinished();\n    }\n    @Override\n    public void handleFinished() {\n      WizardDialog.this.setVisible(false);\n    }\n  }\n"]], "pred": {"ppl": 1.3119515180587769, "ppl_lower": 1.5952478647232056, "ppl/lowercase_ppl": -1.7200812378799009, "ppl/zlib": 0.00026541127775173655, "Min_5.0% Prob": 3.5215594464657354, "Min_10.0% Prob": 2.2944863917780856, "Min_20.0% Prob": 1.322611792560886, "Min_30.0% Prob": 0.9016804507769206, "Min_40.0% Prob": 0.6776591395779369, "Min_50.0% Prob": 0.5431881509867084, "Min_60.0% Prob": 0.45302944442828535}}
{"hexsha": "ee65f005a54d16027d653a2c19c40ef485a42b36", "ext": "java", "lang": "Java", "content": "public class PhoenixClusterMetricsCopier extends AbstractPhoenixMetricsCopier {\n  private static final Log LOG = LogFactory.getLog(PhoenixClusterMetricsCopier.class);\n  private Map<TimelineClusterMetric, MetricHostAggregate> aggregateMap = new HashMap<>();\n\n  PhoenixClusterMetricsCopier(String inputTableName, String outputTableName, PhoenixHBaseAccessor hBaseAccessor, Set<String> metricNames, Long startTime, FileWriter processedMetricsFileWriter) {\n    super(inputTableName, outputTableName, hBaseAccessor, metricNames, startTime, processedMetricsFileWriter);\n  }\n\n  @Override\n  protected String getColumnsClause() {\n    return \"METRIC_NAME, \" +\n      \"APP_ID, \" +\n      \"INSTANCE_ID, \" +\n      \"SERVER_TIME, \" +\n      \"METRIC_SUM, \" +\n      \"METRIC_COUNT, \" +\n      \"METRIC_MAX, \" +\n      \"METRIC_MIN\";\n  }\n\n  @Override\n  protected void saveMetrics() throws SQLException {\n    LOG.debug(String.format(\"Saving %s results read from %s into %s\", aggregateMap.size(), inputTable, outputTable));\n    hBaseAccessor.saveClusterAggregateRecordsSecond(aggregateMap, outputTable);\n  }\n\n  @Override\n  protected void addToResults(ResultSet rs) throws SQLException {\n    TimelineClusterMetric timelineMetric = new TimelineClusterMetric(\n            rs.getString(\"METRIC_NAME\"), rs.getString(\"APP_ID\"),\n            rs.getString(\"INSTANCE_ID\"), rs.getLong(\"SERVER_TIME\"));\n\n    MetricHostAggregate metricHostAggregate = new MetricHostAggregate();\n    metricHostAggregate.setSum(rs.getDouble(\"METRIC_SUM\"));\n    metricHostAggregate.setNumberOfSamples(rs.getLong(\"METRIC_COUNT\"));\n    metricHostAggregate.setMax(rs.getDouble(\"METRIC_MAX\"));\n    metricHostAggregate.setMin(rs.getDouble(\"METRIC_MIN\"));\n\n    aggregateMap.put(timelineMetric, metricHostAggregate);\n\n  }\n}", "item_id": 0, "repo": "likenamehaojie/Apache-Ambari-ZH", "file": "ambari-metrics/ambari-metrics-timelineservice/src/main/java/org/apache/ambari/metrics/core/timeline/upgrade/core/PhoenixClusterMetricsCopier.java", "last_update_at": "2022-03-30T04:01:25+00:00", "question_id": "ee65f005a54d16027d653a2c19c40ef485a42b36_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PhoenixClusterMetricsCopier extends AbstractPhoenixMetricsCopier {\n  private static final Log LOG = LogFactory.getLog(PhoenixClusterMetricsCopier.class);\n  private Map<TimelineClusterMetric, MetricHostAggregate> aggregateMap = new HashMap<>();\n  PhoenixClusterMetricsCopier(String inputTableName, String outputTableName, PhoenixHBaseAccessor hBaseAccessor, Set<String> metricNames, Long startTime, FileWriter processedMetricsFileWriter) {\n    super(inputTableName, outputTableName, hBaseAccessor, metricNames, startTime, processedMetricsFileWriter);\n  }\n  @Override\n  protected String getColumnsClause() {\n    return \"METRIC_NAME, \" +\n      \"APP_ID, \" +\n      \"INSTANCE_ID, \" +\n      \"SERVER_TIME, \" +\n      \"METRIC_SUM, \" +\n      \"METRIC_COUNT, \" +\n      \"METRIC_MAX, \" +\n      \"METRIC_MIN\";\n  }\n  @Override\n  protected void saveMetrics() throws SQLException {\n    LOG.debug(String.format(\"Saving %s results read from %s into %s\", aggregateMap.size(), inputTable, outputTable));\n    hBaseAccessor.saveClusterAggregateRecordsSecond(aggregateMap, outputTable);\n  }\n  @Override\n  protected void addToResults(ResultSet rs) throws SQLException {\n    TimelineClusterMetric timelineMetric = new TimelineClusterMetric(\n            rs.getString(\"METRIC_NAME\"), rs.getString(\"APP_ID\"),\n            rs.getString(\"INSTANCE_ID\"), rs.getLong(\"SERVER_TIME\"));\n    MetricHostAggregate metricHostAggregate = new MetricHostAggregate();\n    metricHostAggregate.setSum(rs.getDouble(\"METRIC_SUM\"));\n    metricHostAggregate.setNumberOfSamples(rs.getLong(\"METRIC_COUNT\"));\n    metricHostAggregate.setMax(rs.getDouble(\"METRIC_MAX\"));\n    metricHostAggregate.setMin(rs.getDouble(\"METRIC_MIN\"));\n    aggregateMap.put(timelineMetric, metricHostAggregate);\n  }\n"]], "pred": {"ppl": 1.8619155883789062, "ppl_lower": 2.3231263160705566, "ppl/lowercase_ppl": -1.35602622906361, "ppl/zlib": 0.0009727790985623638, "Min_5.0% Prob": 6.789067427317302, "Min_10.0% Prob": 4.747913083163175, "Min_20.0% Prob": 2.9085369857874785, "Min_30.0% Prob": 2.044516294472145, "Min_40.0% Prob": 1.5535523007369854, "Min_50.0% Prob": 1.2418361711754478, "Min_60.0% Prob": 1.0363046397705453}}
{"hexsha": "861bc13ed7e35b86c7bb9ec24dd1571d7e275d4c", "ext": "java", "lang": "Java", "content": "public class ListQueue {\n\tprivate LinkedList<Integer> list = new LinkedList<Integer>();\n\n\t//private ListQueue() {}\n\t\n\tpublic static ListQueue makeFromQueue(Queue q) {\t\n\t\tif(q.isempty()) {\n\t\t\treturn new ListQueue();\n\t\t} else if(q.isadd()) {\n\t\t\tListQueue res = makeFromQueue(q.getq());\n\t\t\tres.add(q.gete().getv());\n\t\t\treturn res;\n\t\t} else if(q.isremove()) {\n\t\t\tListQueue res = makeFromQueue(q.getq());\n\t\t\tres.remove();\n\t\t\treturn res;\n\t\t}\n\t\tthrow new RuntimeException(\"should not be there\");\t\n\t}\n\t\n\tpublic static int makeFromElem(Elem e) throws Exception {\n\t\tif(e.isval()) {\n\t\t\treturn e.getv();\n\t\t}/* else if(e.istop()) {\n\t\t\tListQueue sq = makeFromQueue(e.getq());\n\t\t\tif(sq.size() > 0) {\n\t\t\t\treturn sq.top();\n\t\t\t} else {\n\t\t\t\tthrow new Exception();\n\t\t\t}\n\t\t}*/\n\t\tthrow new RuntimeException(\"should not be there\");\t\n\t}\n\t\n\tpublic int top() {\n\t\tif(!list.isEmpty()) {\n\t\t\treturn list.getLast();\n\t\t}\n\t\tthrow new RuntimeException(\"should not be there\");\t\n\t}\n\t\n\tpublic void remove() {\n\t\tlist.removeLast();\n\t}\n\t\n\tpublic void add(int e) {\n\t\tlist.addFirst(e);\n\t}\n\t\n\tpublic int size() {\n\t\treturn list.size();\n\t}\n\t\n\n\tpublic static void main(String[] args) {\n\t\tint nb = 2000;\n\t\tBigInteger TWO = BigInteger.ONE.add(BigInteger.ONE);\n\t\t\n\t\tEnumeration<Queue> e = Queue.getEnumeration();\n\t\tlong start = System.currentTimeMillis();\n\t\tBigInteger index = BigInteger.ONE;\n\t\tfor(int i = 0 ; i<nb ; i++) {\n\t\t\tQueue q = e.get(index);\n\t\t\t//System.out.println(q);\n\t\t\t\n\t\t\t//index = index.add(TWO);\n\t\t\tindex = index.multiply(TWO);\n\t\t}\n\t\tlong stop = System.currentTimeMillis();\n\n\t\tSystem.out.println(nb + \" elems in \" + (stop-start));\n\t}\n}", "item_id": 0, "repo": "rewriting/tom", "file": "lab/enumerator/src/examples/adt/queue/ListQueue.java", "last_update_at": "2022-02-03T13:13:21+00:00", "question_id": "861bc13ed7e35b86c7bb9ec24dd1571d7e275d4c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ListQueue {\n\tprivate LinkedList<Integer> list = new LinkedList<Integer>();\n\t//private ListQueue() {}\n\t\n\tpublic static ListQueue makeFromQueue(Queue q) {\t\n\t\tif(q.isempty()) {\n\t\t\treturn new ListQueue();\n\t\t} else if(q.isadd()) {\n\t\t\tListQueue res = makeFromQueue(q.getq());\n\t\t\tres.add(q.gete().getv());\n\t\t\treturn res;\n\t\t} else if(q.isremove()) {\n\t\t\tListQueue res = makeFromQueue(q.getq());\n\t\t\tres.remove();\n\t\t\treturn res;\n\t\t}\n\t\tthrow new RuntimeException(\"should not be there\");\t\n\t}\n\t\n\tpublic static int makeFromElem(Elem e) throws Exception {\n\t\tif(e.isval()) {\n\t\t\treturn e.getv();\n\t\t}/* else if(e.istop()) {\n\t\t\tListQueue sq = makeFromQueue(e.getq());\n\t\t\tif(sq.size() > 0) {\n\t\t\t\treturn sq.top();\n\t\t\t} else {\n\t\t\t\tthrow new Exception();\n\t\t\t}\n\t\t}*/\n\t\tthrow new RuntimeException(\"should not be there\");\t\n\t}\n\t\n\tpublic int top() {\n\t\tif(!list.isEmpty()) {\n\t\t\treturn list.getLast();\n\t\t}\n\t\tthrow new RuntimeException(\"should not be there\");\t\n\t}\n\t\n\tpublic void remove() {\n\t\tlist.removeLast();\n\t}\n\t\n\tpublic void add(int e) {\n\t\tlist.addFirst(e);\n\t}\n\t\n\tpublic int size() {\n\t\treturn list.size();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tint nb = 2000;\n\t\tBigInteger TWO = BigInteger.ONE.add(BigInteger.ONE);\n\t\t\n\t\tEnumeration<Queue> e = Queue.getEnumeration();\n\t\tlong start = System.currentTimeMillis();\n\t\tBigInteger index = BigInteger.ONE;\n\t\tfor(int i = 0 ; i<nb ; i++) {\n\t\t\tQueue q = e.get(index);\n\t\t\t//System.out.println(q);\n\t\t\t\n\t\t\t//index = index.add(TWO);\n\t\t\tindex = index.multiply(TWO);\n\t\t}\n\t\tlong stop = System.currentTimeMillis();\n\t\tSystem.out.println(nb + \" elems in \" + (stop-start));\n\t}\n"]], "pred": {"ppl": 2.003657579421997, "ppl_lower": 2.114468574523926, "ppl/lowercase_ppl": -1.0774549732973817, "ppl/zlib": 0.0011430498356431358, "Min_5.0% Prob": 6.048656202852726, "Min_10.0% Prob": 4.606999430289635, "Min_20.0% Prob": 3.06169825564814, "Min_30.0% Prob": 2.222808963302428, "Min_40.0% Prob": 1.7164169267274951, "Min_50.0% Prob": 1.382593870855777, "Min_60.0% Prob": 1.1556316159032096}}
{"hexsha": "85b632cb8ca1c1254bed4a69c55aa69493c730ac", "ext": "java", "lang": "Java", "content": "public class PassportSecurityConfigurer {\n\n    private ApplicationContext applicationContext;\n\n    PassportSecurityConfigurer(ApplicationContext applicationContext) {\n        this.applicationContext = applicationContext;\n    }\n\n    public void configure(HttpSecurity http) throws Exception {\n        PassportSsoProperties sso = this.applicationContext\n                .getBean(PassportSsoProperties.class);\n        PassportServerProperties server = this.applicationContext\n                .getBean(PassportServerProperties.class);\n        http.csrf().disable();\n        http.headers().frameOptions().disable();\n        //\u53bb\u9664security session\u7ba1\u7406\n        http.sessionManagement().disable();\n        http.securityContext().disable();\n        http.formLogin().loginPage(server.getLoginPage())\n                .loginProcessingUrl(server.getLoginProcess())\n                .successHandler(addSuccessHandler(http,sso))\n                .failureHandler(addFailHandler(http,sso,server))\n                .and()\n                .logout().logoutUrl(server.getLogout())\n                .logoutSuccessHandler(addLogoutSuccessHandler(http,sso))\n                .logoutSuccessUrl(server.getLogoutSuccess())\n                .invalidateHttpSession(true)\n                .clearAuthentication(true);\n        http.addFilterBefore(serverFilter(sso),\n                AbstractPreAuthenticatedProcessingFilter.class);\n    }\n\n\n    private PassportTokenProcessingHandle addSuccessHandler(HttpSecurity http, PassportSsoProperties sso) throws Exception {\n        PassportTokenStore passportTokenStore = this.applicationContext\n                .getBean(PassportTokenStore.class);\n        PassportTokenProcessingHandle handler = new PassportTokenProcessingHandle();\n        if (!StringUtils.isEmpty(sso.getServiceParamName())) {\n            handler.setServiceParamName(sso.getServiceParamName());\n        }\n        if (!StringUtils.isEmpty(sso.getTargetParamName())) {\n            handler.setTargetParamName(sso.getTargetParamName());\n        }\n        if (!StringUtils.isEmpty(sso.getTokenParamName())) {\n            handler.setTokenParamName(sso.getTokenParamName());\n        }\n        handler.setPassportTokenStore(passportTokenStore);\n        return handler;\n    }\n\n    private ServerAuthenticationFailureHandler addFailHandler(HttpSecurity http, PassportSsoProperties sso ,PassportServerProperties server) throws Exception {\n        ServerAuthenticationFailureHandler handler = new ServerAuthenticationFailureHandler(server.getLoginPage());\n        if (!StringUtils.isEmpty(sso.getServiceParamName())) {\n            handler.setServiceParamName(sso.getServiceParamName());\n        }\n        if (!StringUtils.isEmpty(sso.getTargetParamName())) {\n            handler.setTargetParamName(sso.getTargetParamName());\n        }\n        return handler;\n    }\n\n\n    private ServerLogoutSuccessHandler addLogoutSuccessHandler(HttpSecurity http, PassportSsoProperties sso) throws Exception {\n        PassportTokenStore passportTokenStore = this.applicationContext\n                .getBean(PassportTokenStore.class);\n        ServerLogoutSuccessHandler handler = new ServerLogoutSuccessHandler();\n        handler.setPassportTokenStore(passportTokenStore);\n        handler.setCookieOperations(createCookieOperations(sso));\n        if (!StringUtils.isEmpty(sso.getLogoutServiceParamName())) {\n            handler.setLogoutServiceParamName(sso.getLogoutServiceParamName());\n        }\n        if (!StringUtils.isEmpty(sso.getLogoutServiceParamName())) {\n            handler.setLogoutServiceParamName(sso.getLogoutServiceParamName());\n        }\n        return handler;\n    }\n\n    private PassportServerContextFilter serverFilter(\n            PassportSsoProperties sso) {\n        PassportServerContextFilter passportFilter = new PassportServerContextFilter();\n        if(!StringUtils.isEmpty(sso.getServiceParamName())){\n            passportFilter.setServiceParamName(sso.getServiceParamName());\n        }\n        if(!StringUtils.isEmpty(sso.getTargetParamName())){\n            passportFilter.setTargetParamName(sso.getTargetParamName());\n        }\n        return passportFilter;\n    }\n\n    private CookieOperations createCookieOperations(PassportSsoProperties sso) {\n\n        DefaultCookieOperations cookieOperations = new DefaultCookieOperations();\n        if (!StringUtils.isEmpty(sso.getCookieDomain())) {\n            cookieOperations.setDomain(sso.getCookieDomain());\n        }\n        if (!StringUtils.isEmpty(sso.getCookieName())) {\n            cookieOperations.setCookieName(sso.getCookieName());\n        }\n        if (!StringUtils.isEmpty(sso.getCookiePath())) {\n            cookieOperations.setCookiePath(sso.getCookiePath());\n        }\n        if (sso.getCookieMaxage() != 0) {\n            cookieOperations.setCookieMaxage(sso.getCookieMaxage());\n        }\n        return cookieOperations;\n    }\n}", "item_id": 0, "repo": "dudw/vole", "file": "vole-passport-common/src/main/java/com/github/vole/passport/common/config/server/PassportSecurityConfigurer.java", "last_update_at": "2022-03-12T15:04:33+00:00", "question_id": "85b632cb8ca1c1254bed4a69c55aa69493c730ac_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PassportSecurityConfigurer {\n    private ApplicationContext applicationContext;\n    PassportSecurityConfigurer(ApplicationContext applicationContext) {\n        this.applicationContext = applicationContext;\n    }\n    public void configure(HttpSecurity http) throws Exception {\n        PassportSsoProperties sso = this.applicationContext\n                .getBean(PassportSsoProperties.class);\n        PassportServerProperties server = this.applicationContext\n                .getBean(PassportServerProperties.class);\n        http.csrf().disable();\n        http.headers().frameOptions().disable();\n        //\u53bb\u9664security session\u7ba1\u7406\n        http.sessionManagement().disable();\n        http.securityContext().disable();\n        http.formLogin().loginPage(server.getLoginPage())\n                .loginProcessingUrl(server.getLoginProcess())\n                .successHandler(addSuccessHandler(http,sso))\n                .failureHandler(addFailHandler(http,sso,server))\n                .and()\n                .logout().logoutUrl(server.getLogout())\n                .logoutSuccessHandler(addLogoutSuccessHandler(http,sso))\n                .logoutSuccessUrl(server.getLogoutSuccess())\n                .invalidateHttpSession(true)\n                .clearAuthentication(true);\n        http.addFilterBefore(serverFilter(sso),\n                AbstractPreAuthenticatedProcessingFilter.class);\n    }\n    private PassportTokenProcessingHandle addSuccessHandler(HttpSecurity http, PassportSsoProperties sso) throws Exception {\n        PassportTokenStore passportTokenStore = this.applicationContext\n                .getBean(PassportTokenStore.class);\n        PassportTokenProcessingHandle handler = new PassportTokenProcessingHandle();\n        if (!StringUtils.isEmpty(sso.getServiceParamName())) {\n            handler.setServiceParamName(sso.getServiceParamName());\n        }\n        if (!StringUtils.isEmpty(sso.getTargetParamName())) {\n            handler.setTargetParamName(sso.getTargetParamName());\n        }\n        if (!StringUtils.isEmpty(sso.getTokenParamName())) {\n            handler.setTokenParamName(sso.getTokenParamName());\n        }\n        handler.setPassportTokenStore(passportTokenStore);\n        return handler;\n    }\n    private ServerAuthenticationFailureHandler addFailHandler(HttpSecurity http, PassportSsoProperties sso ,PassportServerProperties server) throws Exception {\n        ServerAuthenticationFailureHandler handler = new ServerAuthenticationFailureHandler(server.getLoginPage());\n        if (!StringUtils.isEmpty(sso.getServiceParamName())) {\n            handler.setServiceParamName(sso.getServiceParamName());\n        }\n        if (!StringUtils.isEmpty(sso.getTargetParamName())) {\n            handler.setTargetParamName(sso.getTargetParamName());\n        }\n        return handler;\n    }\n    private ServerLogoutSuccessHandler addLogoutSuccessHandler(HttpSecurity http, PassportSsoProperties sso) throws Exception {\n        PassportTokenStore passportTokenStore = this.applicationContext\n                .getBean(PassportTokenStore.class);\n        ServerLogoutSuccessHandler handler = new ServerLogoutSuccessHandler();\n        handler.setPassportTokenStore(passportTokenStore);\n        handler.setCookieOperations(createCookieOperations(sso));\n        if (!StringUtils.isEmpty(sso.getLogoutServiceParamName())) {\n            handler.setLogoutServiceParamName(sso.getLogoutServiceParamName());\n        }\n        if (!StringUtils.isEmpty(sso.getLogoutServiceParamName())) {\n            handler.setLogoutServiceParamName(sso.getLogoutServiceParamName());\n        }\n        return handler;\n    }\n    private PassportServerContextFilter serverFilter(\n            PassportSsoProperties sso) {\n        PassportServerContextFilter passportFilter = new PassportServerContextFilter();\n        if(!StringUtils.isEmpty(sso.getServiceParamName())){\n            passportFilter.setServiceParamName(sso.getServiceParamName());\n        }\n        if(!StringUtils.isEmpty(sso.getTargetParamName())){\n            passportFilter.setTargetParamName(sso.getTargetParamName());\n        }\n        return passportFilter;\n    }\n    private CookieOperations createCookieOperations(PassportSsoProperties sso) {\n        DefaultCookieOperations cookieOperations = new DefaultCookieOperations();\n        if (!StringUtils.isEmpty(sso.getCookieDomain())) {\n            cookieOperations.setDomain(sso.getCookieDomain());\n        }\n        if (!StringUtils.isEmpty(sso.getCookieName())) {\n            cookieOperations.setCookieName(sso.getCookieName());\n        }\n        if (!StringUtils.isEmpty(sso.getCookiePath())) {\n            cookieOperations.setCookiePath(sso.getCookiePath());\n        }\n        if (sso.getCookieMaxage() != 0) {\n            cookieOperations.setCookieMaxage(sso.getCookieMaxage());\n        }\n        return cookieOperations;\n    }\n"]], "pred": {"ppl": 1.5287424325942993, "ppl_lower": 1.67909574508667, "ppl/lowercase_ppl": -1.221017663951411, "ppl/zlib": 0.0004828731034653335, "Min_5.0% Prob": 5.320824347290338, "Min_10.0% Prob": 3.5152085563715767, "Min_20.0% Prob": 2.0417670108670114, "Min_30.0% Prob": 1.4032379714954717, "Min_40.0% Prob": 1.0579428906053814, "Min_50.0% Prob": 0.8488264508935425, "Min_60.0% Prob": 0.7081197838959487}}
{"hexsha": "ffa10dbb482bd57bf9a36f10349612e56733f413", "ext": "java", "lang": "Java", "content": "public class BriefPreviewConfigTO implements DatasetConfigProvider, DatasetProvider {\n    @Override\n    public List<String> datasets() {\n        return new ArrayList<>();\n    }\n\n    @Override\n    public DatasetConfig forDataset(String dataset) {\n        return new DatasetConfigImpl(new IdentityHashMap<>(), dataset, IdentityHashMap.class, false);\n    }\n\n    @Override\n    public List<DocumentImage> imageFields() {\n        return new ArrayList<>();\n    }\n\n    @Override\n    public DatasetConfig get(String dataset) {\n        return new DatasetConfigImpl(new IdentityHashMap<>(), dataset, IdentityHashMap.class, false);\n    }\n\n\n    @Override\n    public List<String> datasetNames() {\n        return new ArrayList<>();\n    }\n\n    @Override\n    public List<DatasetMeta> datasetsMeta() {\n        return new ArrayList<>();\n    }\n\n\n    class IdentityHashMap<K, V> extends HashMap<K, V> {\n\n        @Override\n        public boolean containsKey(Object o) {\n            return true;\n        }\n\n        @Override\n        public V get(Object o) {\n            IdentityHashMap<Object, Object> objectObjectIdentityHashMap = new IdentityHashMap<>();\n            objectObjectIdentityHashMap.put(\"\", o);\n            return (V) objectObjectIdentityHashMap;\n        }\n    }\n}", "item_id": 0, "repo": "artisjaap/polyglot", "file": "artisjaap-document/src/main/java/be/artisjaap/document/action/to/BriefPreviewConfigTO.java", "last_update_at": "2022-02-26T20:12:38+00:00", "question_id": "ffa10dbb482bd57bf9a36f10349612e56733f413_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BriefPreviewConfigTO implements DatasetConfigProvider, DatasetProvider {\n    @Override\n    public List<String> datasets() {\n        return new ArrayList<>();\n    }\n    @Override\n    public DatasetConfig forDataset(String dataset) {\n        return new DatasetConfigImpl(new IdentityHashMap<>(), dataset, IdentityHashMap.class, false);\n    }\n    @Override\n    public List<DocumentImage> imageFields() {\n        return new ArrayList<>();\n    }\n    @Override\n    public DatasetConfig get(String dataset) {\n        return new DatasetConfigImpl(new IdentityHashMap<>(), dataset, IdentityHashMap.class, false);\n    }\n    @Override\n    public List<String> datasetNames() {\n        return new ArrayList<>();\n    }\n    @Override\n    public List<DatasetMeta> datasetsMeta() {\n        return new ArrayList<>();\n    }\n    class IdentityHashMap<K, V> extends HashMap<K, V> {\n        @Override\n        public boolean containsKey(Object o) {\n            return true;\n        }\n        @Override\n        public V get(Object o) {\n            IdentityHashMap<Object, Object> objectObjectIdentityHashMap = new IdentityHashMap<>();\n            objectObjectIdentityHashMap.put(\"\", o);\n            return (V) objectObjectIdentityHashMap;\n        }\n    }\n"]], "pred": {"ppl": 2.3381993770599365, "ppl_lower": 2.59474515914917, "ppl/lowercase_ppl": -1.1225682636725023, "ppl/zlib": 0.002406178856011066, "Min_5.0% Prob": 8.075408585866292, "Min_10.0% Prob": 5.930874647632722, "Min_20.0% Prob": 3.79146236843533, "Min_30.0% Prob": 2.742415357143321, "Min_40.0% Prob": 2.108744452042239, "Min_50.0% Prob": 1.6934521847487063, "Min_60.0% Prob": 1.4183408687650054}}
{"hexsha": "fce4702d5e677d0eb1413d1bfd1d1edc76bbc07b", "ext": "java", "lang": "Java", "content": "@Slf4j\n public class StudentScoreListener\n  implements ActionListener\n{\n\n  private RubricsService rubricsService = ComponentManager.get(RubricsService.class);\n\n  /**\n   * Standard process action method.\n   * @param ae ActionEvent\n   * @throws AbortProcessingException\n   */\n  public void processAction(ActionEvent ae) throws\n    AbortProcessingException\n  {\n    log.debug(\"StudentScore LISTENER.\");\n    StudentScoresBean bean = (StudentScoresBean) ContextUtil.lookupBean(\"studentScores\");\n\n    // we probably want to change the poster to be consistent\n    String publishedId = ContextUtil.lookupParam(\"publishedIdd\");\n    \n    log.debug(\"Calling studentScores.\");\n    if (!studentScores(publishedId, bean, false))\n    {\n      throw new RuntimeException(\"failed to call studentScores.\");\n    }\n\n  }\n\n  /**\n   * This will populate the StudentScoresBean with the data associated with the\n   * particular versioned assessment based on the publishedId.\n   *\n   * @param publishedId String\n   * @param bean StudentScoresBean\n   * @return boolean\n   */\n  public boolean studentScores(\n    String publishedId, StudentScoresBean bean, boolean isValueChange)\n  {\n    log.debug(\"studentScores()\");\n    try\n    {\n//  SAK-4121, do not pass studentName as f:param, will cause javascript error if name contains apostrophe \n//    bean.setStudentName(cu.lookupParam(\"studentName\"));\n\n      bean.setPublishedId(publishedId);\n      String studentId = ContextUtil.lookupParam(\"studentid\");\n      bean.setStudentId(studentId);\n      AgentFacade agent = new AgentFacade(studentId);\n      bean.setStudentName(agent.getFirstName() + \" \" + agent.getLastName());\n      bean.setLastName(agent.getLastName());\n      bean.setFirstName(agent.getFirstName());\n      bean.setAssessmentGradingId(ContextUtil.lookupParam(\"gradingData\"));\n      bean.setItemId(ContextUtil.lookupParam(\"itemId\"));\n      bean.setEmail(agent.getEmail());\n      \n      DeliveryBean dbean = (DeliveryBean) ContextUtil.lookupBean(\"delivery\");\n      dbean.setActionString(\"gradeAssessment\");\n\n      DeliveryActionListener listener = new DeliveryActionListener();\n      listener.processAction(null);\n      \n      // Added for SAK-13930\n      DeliveryBean updatedDeliveryBean = (DeliveryBean) ContextUtil.lookupBean(\"delivery\");\n      List<SectionContentsBean> parts = updatedDeliveryBean.getPageContents().getPartsContents();\n      for (SectionContentsBean part : parts) {\n        List<ItemContentsBean> items = part.getItemContents();\n        for (ItemContentsBean question : items) {\n          question.setRubricStateDetails(\"\");\n          if (question.getGradingComment() != null && !question.getGradingComment().equals(\"\")) {\n            question.setGradingComment(ComponentManager.get(FormattedText.class).convertFormattedTextToPlaintext(question.getGradingComment()));\n          }\n        }\n      } // End of SAK-13930\n\n      GradingService service = new GradingService();\n      AssessmentGradingData adata= (AssessmentGradingData) service.load(bean.getAssessmentGradingId(), false);\n      bean.setComments(ComponentManager.get(FormattedText.class).convertFormattedTextToPlaintext(adata.getComments()));\n      buildItemContentsMap(dbean, publishedId);\n\n      return true;\n    } catch (Exception e) {\n      log.error(e.getMessage(), e);\n      return false;\n    }\n  }\n  \n  private void buildItemContentsMap(DeliveryBean dbean, String publishedId) {\n\t  Map<Long, ItemContentsBean> itemContentsMap = new HashMap<>();\n\n      dbean.getPageContents().getPartsContents().stream()\n              .filter(Objects::nonNull)\n              .forEach(p -> p.getItemContents().stream()\n                      .filter(Objects::nonNull)\n                      .forEach(i -> {\n                          i.setHasAssociatedRubric(rubricsService.hasAssociatedRubric(RubricsConstants.RBCS_TOOL_SAMIGO, RubricsConstants.RBCS_PUBLISHED_ASSESSMENT_ENTITY_PREFIX + publishedId + \".\" + i.getItemData().getItemId()));\n                          i.getItemGradingDataArray()\n                                  .forEach(d -> itemContentsMap.put(d.getItemGradingId(), i));\n                      }));\n\n\t  dbean.setItemContentsMap(itemContentsMap);\n  }\n}", "item_id": 0, "repo": "dsp-testing/sakai", "file": "samigo/samigo-app/src/java/org/sakaiproject/tool/assessment/ui/listener/evaluation/StudentScoreListener.java", "last_update_at": "2022-01-25T08:33:35+00:00", "question_id": "fce4702d5e677d0eb1413d1bfd1d1edc76bbc07b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\n public class StudentScoreListener\n  implements ActionListener\n{\n  private RubricsService rubricsService = ComponentManager.get(RubricsService.class);\n  /**\n   * Standard process action method.\n   * @param ae ActionEvent\n   * @throws AbortProcessingException\n   */\n  public void processAction(ActionEvent ae) throws\n    AbortProcessingException\n  {\n    log.debug(\"StudentScore LISTENER.\");\n    StudentScoresBean bean = (StudentScoresBean) ContextUtil.lookupBean(\"studentScores\");\n    // we probably want to change the poster to be consistent\n    String publishedId = ContextUtil.lookupParam(\"publishedIdd\");\n    log.debug(\"Calling studentScores.\");\n    if (!studentScores(publishedId, bean, false))\n    {\n      throw new RuntimeException(\"failed to call studentScores.\");\n    }\n  }\n  /**\n   * This will populate the StudentScoresBean with the data associated with the\n   * particular versioned assessment based on the publishedId.\n   *\n   * @param publishedId String\n   * @param bean StudentScoresBean\n   * @return boolean\n   */\n  public boolean studentScores(\n    String publishedId, StudentScoresBean bean, boolean isValueChange)\n  {\n    log.debug(\"studentScores()\");\n    try\n    {\n//  SAK-4121, do not pass studentName as f:param, will cause javascript error if name contains apostrophe \n//    bean.setStudentName(cu.lookupParam(\"studentName\"));\n      bean.setPublishedId(publishedId);\n      String studentId = ContextUtil.lookupParam(\"studentid\");\n      bean.setStudentId(studentId);\n      AgentFacade agent = new AgentFacade(studentId);\n      bean.setStudentName(agent.getFirstName() + \" \" + agent.getLastName());\n      bean.setLastName(agent.getLastName());\n      bean.setFirstName(agent.getFirstName());\n      bean.setAssessmentGradingId(ContextUtil.lookupParam(\"gradingData\"));\n      bean.setItemId(ContextUtil.lookupParam(\"itemId\"));\n      bean.setEmail(agent.getEmail());\n      DeliveryBean dbean = (DeliveryBean) ContextUtil.lookupBean(\"delivery\");\n      dbean.setActionString(\"gradeAssessment\");\n      DeliveryActionListener listener = new DeliveryActionListener();\n      listener.processAction(null);\n      // Added for SAK-13930\n      DeliveryBean updatedDeliveryBean = (DeliveryBean) ContextUtil.lookupBean(\"delivery\");\n      List<SectionContentsBean> parts = updatedDeliveryBean.getPageContents().getPartsContents();\n      for (SectionContentsBean part : parts) {\n        List<ItemContentsBean> items = part.getItemContents();\n        for (ItemContentsBean question : items) {\n          question.setRubricStateDetails(\"\");\n          if (question.getGradingComment() != null && !question.getGradingComment().equals(\"\")) {\n            question.setGradingComment(ComponentManager.get(FormattedText.class).convertFormattedTextToPlaintext(question.getGradingComment()));\n          }\n        }\n      } // End of SAK-13930\n      GradingService service = new GradingService();\n      AssessmentGradingData adata= (AssessmentGradingData) service.load(bean.getAssessmentGradingId(), false);\n      bean.setComments(ComponentManager.get(FormattedText.class).convertFormattedTextToPlaintext(adata.getComments()));\n      buildItemContentsMap(dbean, publishedId);\n      return true;\n    } catch (Exception e) {\n      log.error(e.getMessage(), e);\n      return false;\n    }\n  }\n  private void buildItemContentsMap(DeliveryBean dbean, String publishedId) {\n\t  Map<Long, ItemContentsBean> itemContentsMap = new HashMap<>();\n      dbean.getPageContents().getPartsContents().stream()\n              .filter(Objects::nonNull)\n              .forEach(p -> p.getItemContents().stream()\n                      .filter(Objects::nonNull)\n                      .forEach(i -> {\n                          i.setHasAssociatedRubric(rubricsService.hasAssociatedRubric(RubricsConstants.RBCS_TOOL_SAMIGO, RubricsConstants.RBCS_PUBLISHED_ASSESSMENT_ENTITY_PREFIX + publishedId + \".\" + i.getItemData().getItemId()));\n                          i.getItemGradingDataArray()\n                                  .forEach(d -> itemContentsMap.put(d.getItemGradingId(), i));\n                      }));\n\t  dbean.setItemContentsMap(itemContentsMap);\n  }\n"]], "pred": {"ppl": 2.198716878890991, "ppl_lower": 2.769819974899292, "ppl/lowercase_ppl": -1.2930778111742944, "ppl/zlib": 0.000565189349603842, "Min_5.0% Prob": 7.03372719708611, "Min_10.0% Prob": 5.317786536964715, "Min_20.0% Prob": 3.514012970760757, "Min_30.0% Prob": 2.539886446462737, "Min_40.0% Prob": 1.944356942271545, "Min_50.0% Prob": 1.5700042381838926, "Min_60.0% Prob": 1.3127932733891086}}
{"hexsha": "cd67a3041803f2680c205b9e6146dace4c41f38a", "ext": "java", "lang": "Java", "content": "class DefaultMdxValidatorImpl\n    implements ParseTreeVisitor<ParseTreeNode>, MdxValidator\n{\n    private Stack<Boolean> scalarStack = new Stack<Boolean>();\n    private final SelectNode selectNode;\n\n    /**\n     * Creates a DefaultMdxValidatorImpl.\n     *\n     * @param selectNode Root of parse tree\n     */\n    protected DefaultMdxValidatorImpl(SelectNode selectNode) {\n        this.selectNode = selectNode;\n    }\n\n    public SelectNode validateSelect(SelectNode selectNode)\n        throws OlapException\n    {\n        return null;\n    }\n\n    public ParseTreeNode visit(SelectNode selectNode) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n\n    public ParseTreeNode visit(AxisNode axis) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n\n    public ParseTreeNode visit(WithMemberNode withMemberNode) {\n        ParseTreeNode expression = acceptScalar(withMemberNode.getExpression());\n        withMemberNode.setExpression(expression);\n        final Type type = expression.getType();\n        if (!TypeUtil.canEvaluate(type)) {\n            throw new RuntimeException(\n                \"'Member expression '\" + MdxUtil.toString(expression)\n                + \"' must not be a set'\");\n        }\n        for (PropertyValueNode prop : withMemberNode.getMemberPropertyList()) {\n            prop.accept(this);\n        }\n        return withMemberNode;\n    }\n\n    public ParseTreeNode visit(WithSetNode withSetNode) {\n        ParseTreeNode expression = acceptScalar(withSetNode.getExpression());\n        withSetNode.setExpression(expression);\n        final Type type = expression.getType();\n        if (!TypeUtil.isSet(type)) {\n            final IdentifierNode id = withSetNode.getIdentifier();\n            final String idString = MdxUtil.toString(id);\n            throw new RuntimeException(\n                \"Set expression '\" + idString + \"' must be a set\");\n        }\n        return withSetNode;\n    }\n\n    public ParseTreeNode visit(CallNode call) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n\n    public ParseTreeNode visit(IdentifierNode id) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n\n    public ParseTreeNode visit(ParameterNode parameterNode) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n\n    public ParseTreeNode visit(CubeNode cubeNode) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n\n    public ParseTreeNode visit(DimensionNode dimensionNode) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n\n    public ParseTreeNode visit(HierarchyNode hierarchyNode) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n\n    public ParseTreeNode visit(LevelNode levelExpr) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n\n    public ParseTreeNode visit(MemberNode memberNode) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n\n    public ParseTreeNode visit(LiteralNode literalNode) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n\n    public ParseTreeNode visit(PropertyValueNode propertyValueNode) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n\n    public ParseTreeNode visit(DrillThroughNode drillThroughNode) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n\n    public void accept(AxisNode axis) {\n        ParseTreeNode exp = axis.getExpression().accept(this);\n        final Type type = exp.getType();\n        if (!TypeUtil.isSet(type)) {\n            throw new RuntimeException(\n                \"Axis '\" + axis.getAxis().name() + \"' expression is not a set\");\n        }\n    }\n\n    public ParseTreeNode acceptScalar(ParseTreeNode node) {\n        scalarStack.push(Boolean.TRUE);\n        try {\n            return node.accept(this);\n        } finally {\n            scalarStack.pop();\n        }\n    }\n\n    // from IdentifierNode\n    public ParseTreeNode accept(IdentifierNode identifier) {\n        if (identifier.getSegmentList().size() == 1) {\n            final IdentifierSegment s = identifier.getSegmentList().get(0);\n            if (s.getQuoting() == Quoting.UNQUOTED\n                && isReserved(s.getName()))\n            {\n                return LiteralNode.createSymbol(\n                    s.getRegion(),\n                    s.getName().toUpperCase());\n            }\n        }\n        final ParseTreeNode element =\n            lookup(selectNode, identifier.getSegmentList(), true);\n        if (element == null) {\n            return null;\n        }\n        return element.accept(this);\n    }\n\n    public ParseTreeNode accept(LiteralNode literalNode) {\n        return literalNode;\n    }\n\n    public boolean isReserved(String name) {\n        // todo: implement\n        throw new UnsupportedOperationException();\n    }\n\n    private ParseTreeNode lookup(\n        SelectNode select,\n        List<IdentifierSegment> segments,\n        boolean allowProp)\n    {\n        // todo: something like this:\n        //  final Exp element = Util.lookup(select, names, true);\n        throw new UnsupportedOperationException();\n    }\n}", "item_id": 0, "repo": "jon-hanson/olap4j", "file": "src/org/olap4j/mdx/DefaultMdxValidatorImpl.java", "last_update_at": "2022-03-26T08:03:21+00:00", "question_id": "cd67a3041803f2680c205b9e6146dace4c41f38a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class DefaultMdxValidatorImpl\n    implements ParseTreeVisitor<ParseTreeNode>, MdxValidator\n{\n    private Stack<Boolean> scalarStack = new Stack<Boolean>();\n    private final SelectNode selectNode;\n    /**\n     * Creates a DefaultMdxValidatorImpl.\n     *\n     * @param selectNode Root of parse tree\n     */\n    protected DefaultMdxValidatorImpl(SelectNode selectNode) {\n        this.selectNode = selectNode;\n    }\n    public SelectNode validateSelect(SelectNode selectNode)\n        throws OlapException\n    {\n        return null;\n    }\n    public ParseTreeNode visit(SelectNode selectNode) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n    public ParseTreeNode visit(AxisNode axis) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n    public ParseTreeNode visit(WithMemberNode withMemberNode) {\n        ParseTreeNode expression = acceptScalar(withMemberNode.getExpression());\n        withMemberNode.setExpression(expression);\n        final Type type = expression.getType();\n        if (!TypeUtil.canEvaluate(type)) {\n            throw new RuntimeException(\n                \"'Member expression '\" + MdxUtil.toString(expression)\n                + \"' must not be a set'\");\n        }\n        for (PropertyValueNode prop : withMemberNode.getMemberPropertyList()) {\n            prop.accept(this);\n        }\n        return withMemberNode;\n    }\n    public ParseTreeNode visit(WithSetNode withSetNode) {\n        ParseTreeNode expression = acceptScalar(withSetNode.getExpression());\n        withSetNode.setExpression(expression);\n        final Type type = expression.getType();\n        if (!TypeUtil.isSet(type)) {\n            final IdentifierNode id = withSetNode.getIdentifier();\n            final String idString = MdxUtil.toString(id);\n            throw new RuntimeException(\n                \"Set expression '\" + idString + \"' must be a set\");\n        }\n        return withSetNode;\n    }\n    public ParseTreeNode visit(CallNode call) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n    public ParseTreeNode visit(IdentifierNode id) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n    public ParseTreeNode visit(ParameterNode parameterNode) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n    public ParseTreeNode visit(CubeNode cubeNode) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n    public ParseTreeNode visit(DimensionNode dimensionNode) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n    public ParseTreeNode visit(HierarchyNode hierarchyNode) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n    public ParseTreeNode visit(LevelNode levelExpr) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n    public ParseTreeNode visit(MemberNode memberNode) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n    public ParseTreeNode visit(LiteralNode literalNode) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n    public ParseTreeNode visit(PropertyValueNode propertyValueNode) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n    public ParseTreeNode visit(DrillThroughNode drillThroughNode) {\n        if (false) {\n            return null;\n        }\n        throw new UnsupportedOperationException();\n    }\n    public void accept(AxisNode axis) {\n        ParseTreeNode exp = axis.getExpression().accept(this);\n        final Type type = exp.getType();\n        if (!TypeUtil.isSet(type)) {\n            throw new RuntimeException(\n                \"Axis '\" + axis.getAxis().name() + \"' expression is not a set\");\n        }\n    }\n    public ParseTreeNode acceptScalar(ParseTreeNode node) {\n        scalarStack.push(Boolean.TRUE);\n        try {\n            return node.accept(this);\n        } finally {\n            scalarStack.pop();\n        }\n    }\n    // from IdentifierNode\n    public ParseTreeNode accept(IdentifierNode identifier) {\n        if (identifier.getSegmentList().size() == 1) {\n            final IdentifierSegment s = identifier.getSegmentList().get(0);\n            if (s.getQuoting() == Quoting.UNQUOTED\n                && isReserved(s.getName()))\n            {\n                return LiteralNode.createSymbol(\n                    s.getRegion(),\n                    s.getName().toUpperCase());\n            }\n        }\n        final ParseTreeNode element =\n            lookup(selectNode, identifier.getSegmentList(), true);\n        if (element == null) {\n            return null;\n        }\n        return element.accept(this);\n    }\n    public ParseTreeNode accept(LiteralNode literalNode) {\n        return literalNode;\n    }\n    public boolean isReserved(String name) {\n        // todo: implement\n        throw new UnsupportedOperationException();\n    }\n    private ParseTreeNode lookup(\n        SelectNode select,\n        List<IdentifierSegment> segments,\n        boolean allowProp)\n    {\n        // todo: something like this:\n        //  final Exp element = Util.lookup(select, names, true);\n        throw new UnsupportedOperationException();\n    }\n"]], "pred": {"ppl": 1.633259892463684, "ppl_lower": 1.7464452981948853, "ppl/lowercase_ppl": -1.136582804209734, "ppl/zlib": 0.00043840746348509826, "Min_5.0% Prob": 6.0186548279780965, "Min_10.0% Prob": 4.164137950130537, "Min_20.0% Prob": 2.3977007102586474, "Min_30.0% Prob": 1.6301035574984317, "Min_40.0% Prob": 1.2249541336301633, "Min_50.0% Prob": 0.981578107597033, "Min_60.0% Prob": 0.8185533303214803}}
{"hexsha": "dd98d76b058c48a50eca80f901c078b4127bc5cf", "ext": "java", "lang": "Java", "content": "public class EnterBetweenBracesHandler extends EnterHandlerDelegateAdapter {\n  private static final Logger LOG = Logger.getInstance(\"#com.intellij.codeInsight.editorActions.enter.EnterBetweenBracesHandler\");\n\n  @Override\n  public Result preprocessEnter(@NotNull final PsiFile file, @NotNull final Editor editor, @NotNull final Ref<Integer> caretOffsetRef, @NotNull final Ref<Integer> caretAdvance,\n                                @NotNull final DataContext dataContext, final EditorActionHandler originalHandler) {\n    Document document = editor.getDocument();\n    CharSequence text = document.getCharsSequence();\n    int caretOffset = caretOffsetRef.get().intValue();\n    if (!CodeInsightSettings.getInstance().SMART_INDENT_ON_ENTER) {\n      return Result.Continue;\n    }\n    \n    if (caretOffset <= 0 || caretOffset >= text.length() || !isBracePair(text.charAt(caretOffset - 1), text.charAt(caretOffset))) {\n      return Result.Continue;\n    }\n\n    final int line = document.getLineNumber(caretOffset);\n    final int start = document.getLineStartOffset(line);\n    final CodeDocumentationUtil.CommentContext commentContext =\n      CodeDocumentationUtil.tryParseCommentContext(file, text, caretOffset, start);\n\n    // special case: enter inside \"()\" or \"{}\"\n    String indentInsideJavadoc = commentContext.docAsterisk\n                                 ? CodeDocumentationUtil.getIndentInsideJavadoc(document, caretOffset)\n                                 : null;\n\n    originalHandler.execute(editor, dataContext);\n\n    Project project = editor.getProject();\n    if (indentInsideJavadoc != null && project != null && CodeStyleSettingsManager.getSettings(project).JD_LEADING_ASTERISKS_ARE_ENABLED) {\n      document.insertString(editor.getCaretModel().getOffset(), \"*\" + indentInsideJavadoc);\n    }\n\n    PsiDocumentManager.getInstance(file.getProject()).commitDocument(document);\n    try {\n      CodeStyleManager.getInstance(file.getProject()).adjustLineIndent(file, editor.getCaretModel().getOffset());\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n    return indentInsideJavadoc == null ? Result.Continue : Result.DefaultForceIndent;\n  }\n\n  protected boolean isBracePair(char c1, char c2) {\n    return (c1 == '(' && c2 == ')') || (c1 == '{' && c2 == '}');\n  }\n}", "item_id": 0, "repo": "liveqmock/platform-tools-idea", "file": "platform/lang-impl/src/com/intellij/codeInsight/editorActions/enter/EnterBetweenBracesHandler.java", "last_update_at": "2022-03-09T05:47:53+00:00", "question_id": "dd98d76b058c48a50eca80f901c078b4127bc5cf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EnterBetweenBracesHandler extends EnterHandlerDelegateAdapter {\n  private static final Logger LOG = Logger.getInstance(\"#com.intellij.codeInsight.editorActions.enter.EnterBetweenBracesHandler\");\n  @Override\n  public Result preprocessEnter(@NotNull final PsiFile file, @NotNull final Editor editor, @NotNull final Ref<Integer> caretOffsetRef, @NotNull final Ref<Integer> caretAdvance,\n                                @NotNull final DataContext dataContext, final EditorActionHandler originalHandler) {\n    Document document = editor.getDocument();\n    CharSequence text = document.getCharsSequence();\n    int caretOffset = caretOffsetRef.get().intValue();\n    if (!CodeInsightSettings.getInstance().SMART_INDENT_ON_ENTER) {\n      return Result.Continue;\n    }\n    if (caretOffset <= 0 || caretOffset >= text.length() || !isBracePair(text.charAt(caretOffset - 1), text.charAt(caretOffset))) {\n      return Result.Continue;\n    }\n    final int line = document.getLineNumber(caretOffset);\n    final int start = document.getLineStartOffset(line);\n    final CodeDocumentationUtil.CommentContext commentContext =\n      CodeDocumentationUtil.tryParseCommentContext(file, text, caretOffset, start);\n    // special case: enter inside \"()\" or \"{}\"\n    String indentInsideJavadoc = commentContext.docAsterisk\n                                 ? CodeDocumentationUtil.getIndentInsideJavadoc(document, caretOffset)\n                                 : null;\n    originalHandler.execute(editor, dataContext);\n    Project project = editor.getProject();\n    if (indentInsideJavadoc != null && project != null && CodeStyleSettingsManager.getSettings(project).JD_LEADING_ASTERISKS_ARE_ENABLED) {\n      document.insertString(editor.getCaretModel().getOffset(), \"*\" + indentInsideJavadoc);\n    }\n    PsiDocumentManager.getInstance(file.getProject()).commitDocument(document);\n    try {\n      CodeStyleManager.getInstance(file.getProject()).adjustLineIndent(file, editor.getCaretModel().getOffset());\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n    return indentInsideJavadoc == null ? Result.Continue : Result.DefaultForceIndent;\n  }\n  protected boolean isBracePair(char c1, char c2) {\n    return (c1 == '(' && c2 == ')') || (c1 == '{' && c2 == '}');\n  }\n"]], "pred": {"ppl": 1.6825262308120728, "ppl_lower": 2.7849783897399902, "ppl/lowercase_ppl": -1.9685705443810226, "ppl/zlib": 0.0005755490849489642, "Min_5.0% Prob": 5.537114754319191, "Min_10.0% Prob": 3.9573758125305174, "Min_20.0% Prob": 2.42329756130699, "Min_30.0% Prob": 1.7120831879426022, "Min_40.0% Prob": 1.29814888548305, "Min_50.0% Prob": 1.039563232625369, "Min_60.0% Prob": 0.8682210440042432}}
{"hexsha": "1071a56069e3f3979e741ff7acf3fd60b8979900", "ext": "java", "lang": "Java", "content": "class HelloWorld {\n\tpublic static void main(String[] args) {\n\t\tString[] vetor = {\"aaa\", \"aaa\", \"aaa\", \"bbb\", \"bbb\", \"bbb\", \"ccc\", \"ccc\", \"ccc\", \"ddd\", \"ddd\", \"ddd\"};\n        String[] novoVetor = new String[vetor.length / 3];\n        for (int i = 0; i < vetor.length; i += 3) novoVetor[i / 3] = vetor[i] + vetor[i + 1] + vetor[i + 2];\n        for (String item : novoVetor) System.out.println(item);\n\t}\n}", "item_id": 0, "repo": "piovezan/SOpt", "file": "Java/Algorithm/Concat3x3.java", "last_update_at": "2022-03-26T10:39:30+00:00", "question_id": "1071a56069e3f3979e741ff7acf3fd60b8979900_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class HelloWorld {\n\tpublic static void main(String[] args) {\n\t\tString[] vetor = {\"aaa\", \"aaa\", \"aaa\", \"bbb\", \"bbb\", \"bbb\", \"ccc\", \"ccc\", \"ccc\", \"ddd\", \"ddd\", \"ddd\"};\n        String[] novoVetor = new String[vetor.length / 3];\n        for (int i = 0; i < vetor.length; i += 3) novoVetor[i / 3] = vetor[i] + vetor[i + 1] + vetor[i + 2];\n        for (String item : novoVetor) System.out.println(item);\n\t}\n"]], "pred": {"ppl": 1.7279188632965088, "ppl_lower": 1.941922903060913, "ppl/lowercase_ppl": -1.2134890695828693, "ppl/zlib": 0.0026168311730558297, "Min_5.0% Prob": 5.640711337327957, "Min_10.0% Prob": 4.105354477377499, "Min_20.0% Prob": 2.4917774881635393, "Min_30.0% Prob": 1.7739672278458218, "Min_40.0% Prob": 1.3564658924727373, "Min_50.0% Prob": 1.0916611432108316, "Min_60.0% Prob": 0.9118631299167315}}
{"hexsha": "65e2e4cfba931a6b71441a1bd15fd5501ac7562f", "ext": "java", "lang": "Java", "content": "public abstract class AbstractEmbeddedQuestDbStatusHistoryRepositoryTest extends AbstractStatusHistoryRepositoryTest {\n    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractEmbeddedQuestDbStatusHistoryRepositoryTest.class);\n\n    protected static final String PATH = \"target/questdb\";\n    protected static final long NOW = System.currentTimeMillis();\n    protected static final Date START = new Date(0);\n    protected static final Date INSERTED_AT = new Date(NOW - TimeUnit.MINUTES.toMillis(1));\n    protected static final Date END = new Date(NOW);\n    protected static final Date END_EARLY = new Date(NOW - TimeUnit.MINUTES.toMillis(10));\n\n    protected static final int PREFERRED_DATA_POINTS = 1000;\n    protected static final int DAYS_TO_KEEP_DATA = 7;\n    protected static final long PERSIST_FREQUENCY = 50; //200 milliseconds\n\n    protected EmbeddedQuestDbStatusHistoryRepository testSubject;\n    protected String path;\n\n    @Before\n    public void setUp() throws Exception {\n        path = PATH + System.currentTimeMillis();\n        testSubject = givenTestSubject();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        testSubject.shutdown();\n\n        try {\n            FileUtils.deleteFile(new File(path), true);\n        } catch (final Exception e) {\n            LOGGER.error(\"Could not delete database directory\", e);\n        }\n    }\n\n    private EmbeddedQuestDbStatusHistoryRepository givenTestSubject() {\n        final NiFiProperties niFiProperties = Mockito.mock(NiFiProperties.class);\n\n        Mockito.when(niFiProperties.getIntegerProperty(\n                NiFiProperties.STATUS_REPOSITORY_QUESTDB_PERSIST_NODE_DAYS,\n                NiFiProperties.DEFAULT_COMPONENT_STATUS_REPOSITORY_PERSIST_NODE_DAYS)\n        ).thenReturn(DAYS_TO_KEEP_DATA);\n\n        Mockito.when(niFiProperties.getIntegerProperty(\n                NiFiProperties.STATUS_REPOSITORY_QUESTDB_PERSIST_COMPONENT_DAYS,\n                NiFiProperties.DEFAULT_COMPONENT_STATUS_REPOSITORY_PERSIST_COMPONENT_DAYS)\n        ).thenReturn(DAYS_TO_KEEP_DATA);\n\n        Mockito.when(niFiProperties.getQuestDbStatusRepositoryPath()).thenReturn(Paths.get(path));\n\n        final EmbeddedQuestDbStatusHistoryRepository testSubject = new EmbeddedQuestDbStatusHistoryRepository(niFiProperties, PERSIST_FREQUENCY);\n        testSubject.start();\n        return testSubject;\n    }\n\n    protected void givenWaitUntilPersisted() throws InterruptedException {\n        Thread.sleep(3000); // The actual writing happens asynchronously on a different thread\n    }\n}", "item_id": 0, "repo": "westdart/nifi", "file": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/status/history/AbstractEmbeddedQuestDbStatusHistoryRepositoryTest.java", "last_update_at": "2022-03-31T04:10:07+00:00", "question_id": "65e2e4cfba931a6b71441a1bd15fd5501ac7562f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class AbstractEmbeddedQuestDbStatusHistoryRepositoryTest extends AbstractStatusHistoryRepositoryTest {\n    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractEmbeddedQuestDbStatusHistoryRepositoryTest.class);\n    protected static final String PATH = \"target/questdb\";\n    protected static final long NOW = System.currentTimeMillis();\n    protected static final Date START = new Date(0);\n    protected static final Date INSERTED_AT = new Date(NOW - TimeUnit.MINUTES.toMillis(1));\n    protected static final Date END = new Date(NOW);\n    protected static final Date END_EARLY = new Date(NOW - TimeUnit.MINUTES.toMillis(10));\n    protected static final int PREFERRED_DATA_POINTS = 1000;\n    protected static final int DAYS_TO_KEEP_DATA = 7;\n    protected static final long PERSIST_FREQUENCY = 50; //200 milliseconds\n    protected EmbeddedQuestDbStatusHistoryRepository testSubject;\n    protected String path;\n    @Before\n    public void setUp() throws Exception {\n        path = PATH + System.currentTimeMillis();\n        testSubject = givenTestSubject();\n    }\n    @After\n    public void tearDown() throws Exception {\n        testSubject.shutdown();\n        try {\n            FileUtils.deleteFile(new File(path), true);\n        } catch (final Exception e) {\n            LOGGER.error(\"Could not delete database directory\", e);\n        }\n    }\n    private EmbeddedQuestDbStatusHistoryRepository givenTestSubject() {\n        final NiFiProperties niFiProperties = Mockito.mock(NiFiProperties.class);\n        Mockito.when(niFiProperties.getIntegerProperty(\n                NiFiProperties.STATUS_REPOSITORY_QUESTDB_PERSIST_NODE_DAYS,\n                NiFiProperties.DEFAULT_COMPONENT_STATUS_REPOSITORY_PERSIST_NODE_DAYS)\n        ).thenReturn(DAYS_TO_KEEP_DATA);\n        Mockito.when(niFiProperties.getIntegerProperty(\n                NiFiProperties.STATUS_REPOSITORY_QUESTDB_PERSIST_COMPONENT_DAYS,\n                NiFiProperties.DEFAULT_COMPONENT_STATUS_REPOSITORY_PERSIST_COMPONENT_DAYS)\n        ).thenReturn(DAYS_TO_KEEP_DATA);\n        Mockito.when(niFiProperties.getQuestDbStatusRepositoryPath()).thenReturn(Paths.get(path));\n        final EmbeddedQuestDbStatusHistoryRepository testSubject = new EmbeddedQuestDbStatusHistoryRepository(niFiProperties, PERSIST_FREQUENCY);\n        testSubject.start();\n        return testSubject;\n    }\n    protected void givenWaitUntilPersisted() throws InterruptedException {\n        Thread.sleep(3000); // The actual writing happens asynchronously on a different thread\n    }\n"]], "pred": {"ppl": 2.0090231895446777, "ppl_lower": 2.549084424972534, "ppl/lowercase_ppl": -1.3412686663626778, "ppl/zlib": 0.0008345079289423266, "Min_5.0% Prob": 6.655460688802931, "Min_10.0% Prob": 4.835279583930969, "Min_20.0% Prob": 3.1320736141040406, "Min_30.0% Prob": 2.2628641686308275, "Min_40.0% Prob": 1.7337262818391381, "Min_50.0% Prob": 1.3943976577228079, "Min_60.0% Prob": 1.1632572550761344}}
{"hexsha": "b6de42e2d1ba659a4b0d3b1d73f3bde9f1bdf5f6", "ext": "java", "lang": "Java", "content": "public class InstitutionService {\n    private static Logger _logger = LoggerFactory.getLogger(InstitutionService.class);\n    \n    private static final String SELECT_STATEMENT = \"select * from  mxk_institutions where domain = ? and status = \" + ConstantsStatus.ACTIVE;\n\n    protected static final Cache<String, Institutions> institutionsStore = \n            Caffeine.newBuilder()\n                .expireAfterWrite(ConstantsTimeInterval.ONE_HOUR, TimeUnit.MINUTES)\n                .build();\n    \n    protected JdbcTemplate jdbcTemplate;\n    \n    public InstitutionService(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n        \n    public Institutions findByDomain(String domain) {\n        _logger.trace(\" domain {}\" , domain);\n        Institutions inst = institutionsStore.getIfPresent(domain);\n        if(inst == null) {\n\t        List<Institutions> institutions = \n\t        \t\tjdbcTemplate.query(SELECT_STATEMENT,new InstitutionsRowMapper(),domain);\n\t        \n\t        if (institutions != null && institutions.size() > 0) {\n\t        \tinst = institutions.get(0);\n\t        }\n\t        \n\t        institutionsStore.put(domain, inst);\n        }\n        \n        return inst;\n    }\n    \n    public class InstitutionsRowMapper implements RowMapper<Institutions> {\n        @Override\n        public Institutions mapRow(ResultSet rs, int rowNum) throws SQLException {\n        \tInstitutions institution = new Institutions();\n        \tinstitution.setId(rs.getString(\"id\"));\n        \tinstitution.setName(rs.getString(\"name\"));\n        \tinstitution.setFullName(rs.getString(\"fullname\"));\n        \tinstitution.setLogo(rs.getString(\"logo\"));\n        \tinstitution.setDomain(rs.getString(\"domain\"));\n            return institution;\n        }\n    }\n}", "item_id": 0, "repo": "dromara/MaxKey", "file": "maxkey-core/src/main/java/org/maxkey/persistence/db/InstitutionService.java", "last_update_at": "2022-03-30T23:35:23+00:00", "question_id": "b6de42e2d1ba659a4b0d3b1d73f3bde9f1bdf5f6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class InstitutionService {\n    private static Logger _logger = LoggerFactory.getLogger(InstitutionService.class);\n    private static final String SELECT_STATEMENT = \"select * from  mxk_institutions where domain = ? and status = \" + ConstantsStatus.ACTIVE;\n    protected static final Cache<String, Institutions> institutionsStore = \n            Caffeine.newBuilder()\n                .expireAfterWrite(ConstantsTimeInterval.ONE_HOUR, TimeUnit.MINUTES)\n                .build();\n    protected JdbcTemplate jdbcTemplate;\n    public InstitutionService(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n    public Institutions findByDomain(String domain) {\n        _logger.trace(\" domain {}\" , domain);\n        Institutions inst = institutionsStore.getIfPresent(domain);\n        if(inst == null) {\n\t        List<Institutions> institutions = \n\t        \t\tjdbcTemplate.query(SELECT_STATEMENT,new InstitutionsRowMapper(),domain);\n\t        \n\t        if (institutions != null && institutions.size() > 0) {\n\t        \tinst = institutions.get(0);\n\t        }\n\t        \n\t        institutionsStore.put(domain, inst);\n        }\n        return inst;\n    }\n    public class InstitutionsRowMapper implements RowMapper<Institutions> {\n        @Override\n        public Institutions mapRow(ResultSet rs, int rowNum) throws SQLException {\n        \tInstitutions institution = new Institutions();\n        \tinstitution.setId(rs.getString(\"id\"));\n        \tinstitution.setName(rs.getString(\"name\"));\n        \tinstitution.setFullName(rs.getString(\"fullname\"));\n        \tinstitution.setLogo(rs.getString(\"logo\"));\n        \tinstitution.setDomain(rs.getString(\"domain\"));\n            return institution;\n        }\n    }\n"]], "pred": {"ppl": 1.8916789293289185, "ppl_lower": 2.211111068725586, "ppl/lowercase_ppl": -1.2447670656825458, "ppl/zlib": 0.000980715010989188, "Min_5.0% Prob": 6.3732816240061885, "Min_10.0% Prob": 4.647739026857459, "Min_20.0% Prob": 2.869607173627423, "Min_30.0% Prob": 2.0576898948751765, "Min_40.0% Prob": 1.5723715160162217, "Min_50.0% Prob": 1.2706314950763922, "Min_60.0% Prob": 1.0603017049698045}}
{"hexsha": "ca79ef9e7f06b653ccde96919f39f8fdc51afbd9", "ext": "java", "lang": "Java", "content": "@Configuration\n@ConditionalOnWebApplication(type = Type.ANY)\n@AutoConfigureBefore(InMemoryUserDetailsAutoConfiguration.class)\n@AutoConfigureAfter(LdaptiveAutoConfiguration.class)\n@ConditionalOnClass({\n    ConnectionFactory.class,\n    LdaptiveOperations.class\n})\n@ConditionalOnProperty(\n    prefix = \"bremersee.ldaptive\",\n    name = {\"enabled\", \"authentication-enabled\"},\n    havingValue = \"true\")\n@EnableConfigurationProperties(LdaptiveProperties.class)\n@Slf4j\npublic class LdaptiveUserDetailsAutoConfiguration {\n\n  private final UserDetailsProperties properties;\n\n  private final LdaptiveOperations ldaptiveOperations;\n\n  /**\n   * Instantiates a new ldaptive user details auto configuration.\n   *\n   * @param properties the properties\n   * @param ldaptiveOperationsProvider the ldaptive operations provider\n   */\n  public LdaptiveUserDetailsAutoConfiguration(\n      LdaptiveProperties properties,\n      ObjectProvider<LdaptiveOperations> ldaptiveOperationsProvider) {\n    this.properties = properties.getUserDetails();\n    this.ldaptiveOperations = ldaptiveOperationsProvider.getIfAvailable();\n    Assert.notNull(this.ldaptiveOperations, \"Ldap operations must not be present.\");\n  }\n\n  /**\n   * Init.\n   */\n  @EventListener(ApplicationReadyEvent.class)\n  public void init() {\n    log.info(\"\\n\"\n            + \"*********************************************************************************\\n\"\n            + \"* {}\\n\"\n            + \"*********************************************************************************\\n\"\n            + \"* properties = {}\\n\"\n            + \"*********************************************************************************\",\n        ClassUtils.getUserClass(getClass()).getSimpleName(),\n        properties);\n    Assert.hasText(properties.getUserBaseDn(), \"User base dn must be present.\");\n    Assert.hasText(properties.getUserFindOneFilter(), \"User find one filter must be present.\");\n  }\n\n  /**\n   * Ldaptive user details service.\n   *\n   * @return the ldaptive user details service\n   */\n  @ConditionalOnWebApplication(type = Type.SERVLET)\n  @ConditionalOnMissingBean(value = {UserDetailsService.class})\n  @Bean\n  public LdaptiveUserDetailsService ldaptiveUserDetailsService() {\n    return new LdaptiveUserDetailsService(\n        ldaptiveOperations,\n        properties.getUserBaseDn(),\n        properties.getUserFindOneFilter(),\n        properties.getUserFindOneSearchScope(),\n        properties.getUserAccountControlAttributeName(),\n        properties.getAuthorities(),\n        properties.getAuthorityAttributeName(),\n        properties.isAuthorityDn(),\n        properties.getAuthorityMap(),\n        properties.getAuthorityPrefix());\n  }\n\n  /**\n   * Reactive ldaptive user details service.\n   *\n   * @param reactiveLdaptiveOperationsProvider the reactive ldaptive operations provider\n   * @return the reactive ldaptive user details service\n   */\n  @ConditionalOnWebApplication(type = Type.REACTIVE)\n  @ConditionalOnMissingBean(value = {ReactiveUserDetailsService.class})\n  @Bean\n  public ReactiveLdaptiveUserDetailsService reactiveLdaptiveUserDetailsService(\n      ObjectProvider<ReactiveLdaptiveOperations> reactiveLdaptiveOperationsProvider) {\n    ReactiveLdaptiveOperations reactiveLdaptiveOperations = reactiveLdaptiveOperationsProvider.getIfAvailable();\n    Assert.notNull(reactiveLdaptiveOperations, \"Reactive ldap operations must not be present.\");\n    return new ReactiveLdaptiveUserDetailsService(\n        reactiveLdaptiveOperations,\n        properties.getUserBaseDn(),\n        properties.getUserFindOneFilter(),\n        properties.getUserFindOneSearchScope(),\n        properties.getUserAccountControlAttributeName(),\n        properties.getAuthorities(),\n        properties.getAuthorityAttributeName(),\n        properties.isAuthorityDn(),\n        properties.getAuthorityMap(),\n        properties.getAuthorityPrefix());\n  }\n\n  /**\n   * Ldaptive password matcher.\n   *\n   * @return the ldaptive password matcher\n   */\n  @ConditionalOnMissingBean(value = {PasswordEncoder.class})\n  @Bean\n  public LdaptivePasswordMatcher passwordEncoder() {\n    LdaptivePasswordMatcher matcher = new LdaptivePasswordMatcher(\n        ldaptiveOperations,\n        properties.getUserBaseDn(),\n        properties.getUserFindOneFilter());\n    matcher.setUserPasswordAttributeName(properties.getUserAccountControlAttributeName());\n    matcher.setUserFindOneSearchScope(properties.getUserFindOneSearchScope());\n    matcher.setUserPasswordAttributeName(properties.getUserPasswordAttributeName());\n    matcher.setDelegate(new LdaptivePasswordEncoder(\n        properties.getUserPasswordLabel(),\n        properties.getUserPasswordAlgorithm()));\n    return matcher;\n  }\n\n}", "item_id": 0, "repo": "bremersee/common", "file": "common-base-autoconfigure/src/main/java/org/bremersee/security/authentication/LdaptiveUserDetailsAutoConfiguration.java", "last_update_at": "2022-01-05T20:03:23+00:00", "question_id": "ca79ef9e7f06b653ccde96919f39f8fdc51afbd9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Configuration\n@ConditionalOnWebApplication(type = Type.ANY)\n@AutoConfigureBefore(InMemoryUserDetailsAutoConfiguration.class)\n@AutoConfigureAfter(LdaptiveAutoConfiguration.class)\n@ConditionalOnClass({\n    ConnectionFactory.class,\n    LdaptiveOperations.class\n})\n@ConditionalOnProperty(\n    prefix = \"bremersee.ldaptive\",\n    name = {\"enabled\", \"authentication-enabled\"},\n    havingValue = \"true\")\n@EnableConfigurationProperties(LdaptiveProperties.class)\n@Slf4j\npublic class LdaptiveUserDetailsAutoConfiguration {\n  private final UserDetailsProperties properties;\n  private final LdaptiveOperations ldaptiveOperations;\n  /**\n   * Instantiates a new ldaptive user details auto configuration.\n   *\n   * @param properties the properties\n   * @param ldaptiveOperationsProvider the ldaptive operations provider\n   */\n  public LdaptiveUserDetailsAutoConfiguration(\n      LdaptiveProperties properties,\n      ObjectProvider<LdaptiveOperations> ldaptiveOperationsProvider) {\n    this.properties = properties.getUserDetails();\n    this.ldaptiveOperations = ldaptiveOperationsProvider.getIfAvailable();\n    Assert.notNull(this.ldaptiveOperations, \"Ldap operations must not be present.\");\n  }\n  /**\n   * Init.\n   */\n  @EventListener(ApplicationReadyEvent.class)\n  public void init() {\n    log.info(\"\\n\"\n            + \"*********************************************************************************\\n\"\n            + \"* {}\\n\"\n            + \"*********************************************************************************\\n\"\n            + \"* properties = {}\\n\"\n            + \"*********************************************************************************\",\n        ClassUtils.getUserClass(getClass()).getSimpleName(),\n        properties);\n    Assert.hasText(properties.getUserBaseDn(), \"User base dn must be present.\");\n    Assert.hasText(properties.getUserFindOneFilter(), \"User find one filter must be present.\");\n  }\n  /**\n   * Ldaptive user details service.\n   *\n   * @return the ldaptive user details service\n   */\n  @ConditionalOnWebApplication(type = Type.SERVLET)\n  @ConditionalOnMissingBean(value = {UserDetailsService.class})\n  @Bean\n  public LdaptiveUserDetailsService ldaptiveUserDetailsService() {\n    return new LdaptiveUserDetailsService(\n        ldaptiveOperations,\n        properties.getUserBaseDn(),\n        properties.getUserFindOneFilter(),\n        properties.getUserFindOneSearchScope(),\n        properties.getUserAccountControlAttributeName(),\n        properties.getAuthorities(),\n        properties.getAuthorityAttributeName(),\n        properties.isAuthorityDn(),\n        properties.getAuthorityMap(),\n        properties.getAuthorityPrefix());\n  }\n  /**\n   * Reactive ldaptive user details service.\n   *\n   * @param reactiveLdaptiveOperationsProvider the reactive ldaptive operations provider\n   * @return the reactive ldaptive user details service\n   */\n  @ConditionalOnWebApplication(type = Type.REACTIVE)\n  @ConditionalOnMissingBean(value = {ReactiveUserDetailsService.class})\n  @Bean\n  public ReactiveLdaptiveUserDetailsService reactiveLdaptiveUserDetailsService(\n      ObjectProvider<ReactiveLdaptiveOperations> reactiveLdaptiveOperationsProvider) {\n    ReactiveLdaptiveOperations reactiveLdaptiveOperations = reactiveLdaptiveOperationsProvider.getIfAvailable();\n    Assert.notNull(reactiveLdaptiveOperations, \"Reactive ldap operations must not be present.\");\n    return new ReactiveLdaptiveUserDetailsService(\n        reactiveLdaptiveOperations,\n        properties.getUserBaseDn(),\n        properties.getUserFindOneFilter(),\n        properties.getUserFindOneSearchScope(),\n        properties.getUserAccountControlAttributeName(),\n        properties.getAuthorities(),\n        properties.getAuthorityAttributeName(),\n        properties.isAuthorityDn(),\n        properties.getAuthorityMap(),\n        properties.getAuthorityPrefix());\n  }\n  /**\n   * Ldaptive password matcher.\n   *\n   * @return the ldaptive password matcher\n   */\n  @ConditionalOnMissingBean(value = {PasswordEncoder.class})\n  @Bean\n  public LdaptivePasswordMatcher passwordEncoder() {\n    LdaptivePasswordMatcher matcher = new LdaptivePasswordMatcher(\n        ldaptiveOperations,\n        properties.getUserBaseDn(),\n        properties.getUserFindOneFilter());\n    matcher.setUserPasswordAttributeName(properties.getUserAccountControlAttributeName());\n    matcher.setUserFindOneSearchScope(properties.getUserFindOneSearchScope());\n    matcher.setUserPasswordAttributeName(properties.getUserPasswordAttributeName());\n    matcher.setDelegate(new LdaptivePasswordEncoder(\n        properties.getUserPasswordLabel(),\n        properties.getUserPasswordAlgorithm()));\n    return matcher;\n  }\n"]], "pred": {"ppl": 1.4867690801620483, "ppl_lower": 1.8835283517837524, "ppl/lowercase_ppl": -1.596415126542045, "ppl/zlib": 0.0003858028822884936, "Min_5.0% Prob": 5.020137814914479, "Min_10.0% Prob": 3.315975306080837, "Min_20.0% Prob": 1.9181553923762311, "Min_30.0% Prob": 1.3153956123670332, "Min_40.0% Prob": 0.9902139941462678, "Min_50.0% Prob": 0.7935728118025903, "Min_60.0% Prob": 0.6617612403980419}}
{"hexsha": "50742ed1f7441556a5fd21d3a32ea5052a53ca08", "ext": "java", "lang": "Java", "content": "@SpringJUnitConfig({Jpa3JavaConfig.class})\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\npublic class Stock3CrudPagingRepositoryTest {\n\n\n    @Autowired\n    private Stock3CrudPagingService service;\n\n    @Test\n    void getAllStock() {\n        List<Stock3Entity> stockList = service.getAll();\n        stockList.forEach(System.out::println);\n    }\n\n    @Test\n    void getAllStockSorted() {\n        List<Stock3Entity> stockList = service.getAllSorted(Sort.by(Sort.Order.desc(\"id\")));\n        stockList.forEach(System.out::println);\n    }\n\n    @Test\n    void getAllStockPagination() {\n        Page<Stock3Entity> page = service.getAllPaginated(1, 2, \"id\");\n        if (page.hasContent()) {\n            System.out.println(\"Records exists in the response\");\n        } else {\n            System.out.println(\"No Records exists in the response\");\n        }\n        System.out.println(\"Total ELements : \" + page.getTotalElements());\n        System.out.println(\"Total Pages : \" + page.getTotalPages());\n        System.out.println(\"Count :\" + page.stream().count());\n        System.out.println(\"===PAGE RECORDS===\");\n        page.get().forEach(System.out::println);\n    }\n\n    @Test\n    void saveWithTx() {\n        Stock3Entity entity = new Stock3Entity();\n        entity.setId(\"NSE:MINE\");\n        entity.setName(\"MY COMPANY\");\n        entity.setPrice(20.5);\n        service.save(entity);\n\n        List<Stock3Entity> stockList = service.getAll();\n        stockList.forEach(System.out::println);\n    }\n\n    @Test\n    void customQuery() {\n       List<String> ids = service.getAllStockId();\n       ids.forEach(System.out::println);\n    }\n}", "item_id": 0, "repo": "thanujtk/spring5.teach", "file": "data-access/src/test/java/org/tk/spring/jpa3/Stock3CrudPagingRepositoryTest.java", "last_update_at": "2022-03-22T10:21:51+00:00", "question_id": "50742ed1f7441556a5fd21d3a32ea5052a53ca08_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SpringJUnitConfig({Jpa3JavaConfig.class})\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\npublic class Stock3CrudPagingRepositoryTest {\n    @Autowired\n    private Stock3CrudPagingService service;\n    @Test\n    void getAllStock() {\n        List<Stock3Entity> stockList = service.getAll();\n        stockList.forEach(System.out::println);\n    }\n    @Test\n    void getAllStockSorted() {\n        List<Stock3Entity> stockList = service.getAllSorted(Sort.by(Sort.Order.desc(\"id\")));\n        stockList.forEach(System.out::println);\n    }\n    @Test\n    void getAllStockPagination() {\n        Page<Stock3Entity> page = service.getAllPaginated(1, 2, \"id\");\n        if (page.hasContent()) {\n            System.out.println(\"Records exists in the response\");\n        } else {\n            System.out.println(\"No Records exists in the response\");\n        }\n        System.out.println(\"Total ELements : \" + page.getTotalElements());\n        System.out.println(\"Total Pages : \" + page.getTotalPages());\n        System.out.println(\"Count :\" + page.stream().count());\n        System.out.println(\"===PAGE RECORDS===\");\n        page.get().forEach(System.out::println);\n    }\n    @Test\n    void saveWithTx() {\n        Stock3Entity entity = new Stock3Entity();\n        entity.setId(\"NSE:MINE\");\n        entity.setName(\"MY COMPANY\");\n        entity.setPrice(20.5);\n        service.save(entity);\n        List<Stock3Entity> stockList = service.getAll();\n        stockList.forEach(System.out::println);\n    }\n    @Test\n    void customQuery() {\n       List<String> ids = service.getAllStockId();\n       ids.forEach(System.out::println);\n    }\n"]], "pred": {"ppl": 2.181183099746704, "ppl_lower": 2.6915407180786133, "ppl/lowercase_ppl": -1.2695924226717121, "ppl/zlib": 0.0014102485278390912, "Min_5.0% Prob": 7.505758228302002, "Min_10.0% Prob": 5.57635528087616, "Min_20.0% Prob": 3.5145090051216656, "Min_30.0% Prob": 2.5141199550738462, "Min_40.0% Prob": 1.9300252939092701, "Min_50.0% Prob": 1.554144316712233, "Min_60.0% Prob": 1.3018367049976645}}
{"hexsha": "ab320bfa25b7bdbb6227e772c5c776d1b1d1bc82", "ext": "java", "lang": "Java", "content": "public class DumpDatabaseAction extends Action implements Parcelable {\n    private static final String TAG = LogUtil.BUGLE_DATAMODEL_TAG;\n    public static final String DUMP_NAME = \"db_copy.db\";\n    private static final int BUFFER_SIZE = 16384;\n\n    /**\n     * Copy the database to external storage\n     */\n    public static void dumpDatabase() {\n        final DumpDatabaseAction action = new DumpDatabaseAction();\n        action.start();\n    }\n\n    private DumpDatabaseAction() {\n    }\n\n    @Override\n    protected Object executeAction() {\n        final Context context = Factory.get().getApplicationContext();\n        final String dbName = DatabaseHelper.DATABASE_NAME;\n        BufferedOutputStream bos = null;\n        BufferedInputStream bis = null;\n\n        long originalSize = 0;\n        final File inFile = context.getDatabasePath(dbName);\n        if (inFile.exists() && inFile.isFile()) {\n            originalSize = inFile.length();\n        }\n        final File outFile = DebugUtils.getDebugFile(DUMP_NAME, true);\n        if (outFile != null) {\n            int totalBytes = 0;\n            try {\n                bos = new BufferedOutputStream(new FileOutputStream(outFile));\n                bis = new BufferedInputStream(new FileInputStream(inFile));\n\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int bytesRead;\n                while ((bytesRead = bis.read(buffer)) > 0) {\n                    bos.write(buffer, 0, bytesRead);\n                    totalBytes += bytesRead;\n                }\n            } catch (final IOException e) {\n                LogUtil.w(TAG, \"Exception copying the database;\"\n                        + \" destination may not be complete.\", e);\n            } finally {\n                if (bos != null) {\n                    try {\n                        bos.close();\n                    } catch (final IOException e) {\n                        // Nothing to do\n                    }\n                }\n\n                if (bis != null) {\n                    try {\n                        bis.close();\n                    } catch (final IOException e) {\n                        // Nothing to do\n                    }\n                }\n                DebugUtils.ensureReadable(outFile);\n                LogUtil.i(TAG, \"Dump complete; orig size: \" + originalSize +\n                        \", copy size: \" + totalBytes);\n            }\n        }\n        return null;\n    }\n\n    private DumpDatabaseAction(final Parcel in) {\n        super(in);\n    }\n\n    public static final Parcelable.Creator<DumpDatabaseAction> CREATOR\n            = new Parcelable.Creator<DumpDatabaseAction>() {\n        @Override\n        public DumpDatabaseAction createFromParcel(final Parcel in) {\n            return new DumpDatabaseAction(in);\n        }\n\n        @Override\n        public DumpDatabaseAction[] newArray(final int size) {\n            return new DumpDatabaseAction[size];\n        }\n    };\n\n    @Override\n    public void writeToParcel(final Parcel parcel, final int flags) {\n        writeActionToParcel(parcel, flags);\n    }\n}", "item_id": 0, "repo": "duchoangitt/SmsApp", "file": "app/src/main/java/com/android/messaging/datamodel/action/DumpDatabaseAction.java", "last_update_at": "2022-01-26T04:59:36+00:00", "question_id": "ab320bfa25b7bdbb6227e772c5c776d1b1d1bc82_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DumpDatabaseAction extends Action implements Parcelable {\n    private static final String TAG = LogUtil.BUGLE_DATAMODEL_TAG;\n    public static final String DUMP_NAME = \"db_copy.db\";\n    private static final int BUFFER_SIZE = 16384;\n    /**\n     * Copy the database to external storage\n     */\n    public static void dumpDatabase() {\n        final DumpDatabaseAction action = new DumpDatabaseAction();\n        action.start();\n    }\n    private DumpDatabaseAction() {\n    }\n    @Override\n    protected Object executeAction() {\n        final Context context = Factory.get().getApplicationContext();\n        final String dbName = DatabaseHelper.DATABASE_NAME;\n        BufferedOutputStream bos = null;\n        BufferedInputStream bis = null;\n        long originalSize = 0;\n        final File inFile = context.getDatabasePath(dbName);\n        if (inFile.exists() && inFile.isFile()) {\n            originalSize = inFile.length();\n        }\n        final File outFile = DebugUtils.getDebugFile(DUMP_NAME, true);\n        if (outFile != null) {\n            int totalBytes = 0;\n            try {\n                bos = new BufferedOutputStream(new FileOutputStream(outFile));\n                bis = new BufferedInputStream(new FileInputStream(inFile));\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int bytesRead;\n                while ((bytesRead = bis.read(buffer)) > 0) {\n                    bos.write(buffer, 0, bytesRead);\n                    totalBytes += bytesRead;\n                }\n            } catch (final IOException e) {\n                LogUtil.w(TAG, \"Exception copying the database;\"\n                        + \" destination may not be complete.\", e);\n            } finally {\n                if (bos != null) {\n                    try {\n                        bos.close();\n                    } catch (final IOException e) {\n                        // Nothing to do\n                    }\n                }\n                if (bis != null) {\n                    try {\n                        bis.close();\n                    } catch (final IOException e) {\n                        // Nothing to do\n                    }\n                }\n                DebugUtils.ensureReadable(outFile);\n                LogUtil.i(TAG, \"Dump complete; orig size: \" + originalSize +\n                        \", copy size: \" + totalBytes);\n            }\n        }\n        return null;\n    }\n    private DumpDatabaseAction(final Parcel in) {\n        super(in);\n    }\n    public static final Parcelable.Creator<DumpDatabaseAction> CREATOR\n            = new Parcelable.Creator<DumpDatabaseAction>() {\n        @Override\n        public DumpDatabaseAction createFromParcel(final Parcel in) {\n            return new DumpDatabaseAction(in);\n        }\n        @Override\n        public DumpDatabaseAction[] newArray(final int size) {\n            return new DumpDatabaseAction[size];\n        }\n    };\n    @Override\n    public void writeToParcel(final Parcel parcel, final int flags) {\n        writeActionToParcel(parcel, flags);\n    }\n"]], "pred": {"ppl": 1.7114676237106323, "ppl_lower": 1.9249681234359741, "ppl/lowercase_ppl": -1.2187733700158134, "ppl/zlib": 0.0005591584411034354, "Min_5.0% Prob": 5.875940266408418, "Min_10.0% Prob": 4.041903418929953, "Min_20.0% Prob": 2.5163916606529084, "Min_30.0% Prob": 1.7660229825779148, "Min_40.0% Prob": 1.3421289321960381, "Min_50.0% Prob": 1.0751574967207276, "Min_60.0% Prob": 0.8957303531354031}}
{"hexsha": "5d20351af1ca40e6f69d30e686093f8186a2d643", "ext": "java", "lang": "Java", "content": "@RunWith(Theories.class)\npublic class OtherwiseDeceasedFeatureTest extends EmbeddedDatabaseTest {\n\n    @Resource\n    private OtherwiseDeceasedFeature feature;\n\n    @Resource\n    private OtherwiseDeceasedRepository otherwiseDeceasedRepository;\n\n    @Resource\n    private OtherwiseDeceasedChangeRepository changeRepository;\n\n    private SystemUser privilegedModerator;\n\n    private SystemUser notAuthorised;\n\n    private EntitySupplier es;\n\n    private GameSpecies gameSpecies1;\n    private GameSpecies gameSpecies2;\n\n    private GeoLocation location1;\n    private GeoLocation location2;\n\n    private Municipality municipality1;\n    private Municipality municipality2;\n\n    private Riistanhoitoyhdistys rhy1;\n    private Riistanhoitoyhdistys rhy2;\n\n    @Before\n    public void setUp() {\n        es = getEntitySupplier();\n        privilegedModerator = createNewModerator(SystemUserPrivilege.MUUTOIN_KUOLLEET);\n        notAuthorised = createNewModerator();\n        gameSpecies1 = es.newGameSpecies();\n        gameSpecies2 = es.newGameSpecies();\n        location1 = geoLocation();\n        location2 = geoLocation();\n        municipality1 = es.newMunicipality();\n        municipality2 = es.newMunicipality();\n        rhy1 = es.newRiistanhoitoyhdistys();\n        rhy2 = es.newRiistanhoitoyhdistys();\n        persistInNewTransaction();\n    }\n\n    @Test(expected = AccessDeniedException.class)\n    public void listByYear_moderatorMustHavePrivilege() {\n        onSavedAndAuthenticated(notAuthorised, () -> feature.listByYear(2021));\n    }\n\n    @Test\n    public void listByYear_returnsEmptyListIfNoneFound() {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final List<OtherwiseDeceasedBriefDTO> results = feature.listByYear(2021);\n            assertThat(results, hasSize(0));\n        });\n    }\n\n    @Test\n    public void listByYear_andOnlyByThatYear() {\n        final OtherwiseDeceased item = es.newOtherwiseDeceased(new DateTime(2021, 1, 1, 0, 0, Constants.DEFAULT_TIMEZONE));\n        es.newOtherwiseDeceased(new DateTime(2020, 12, 31, 23, 59, 59, 999, Constants.DEFAULT_TIMEZONE));\n        es.newOtherwiseDeceased(new DateTime(2022, 1, 1, 0, 0, Constants.DEFAULT_TIMEZONE));\n\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            runInTransaction(() -> {\n                final List<OtherwiseDeceasedBriefDTO> results = feature.listByYear(2021);\n                assertThat(results, hasSize(1));\n\n                final OtherwiseDeceasedBriefDTO result = results.get(0);\n                assertThat(result.getPointOfTime(), equalTo(item.getPointOfTime().toLocalDateTime()));\n                assertThat(result.getCause(), equalTo(item.getCause()));\n                assertThat(result.getGameSpeciesCode(), equalTo(item.getSpecies().getOfficialCode()));\n                assertThat(result.getMunicipality().getNameFI(),\n                           equalTo(item.getMunicipality().getNameLocalisation().getFinnish()));\n                assertThat(result.getRhy().getNameFI(), equalTo(item.getRhy().getNameFinnish()));\n                assertThat(result.getRka().getNameFI(), equalTo(item.getRka().getNameFinnish()));\n            });\n        });\n    }\n\n    @Test(expected = AccessDeniedException.class)\n    public void getDetails_moderatorMustHavePrivilege() {\n        onSavedAndAuthenticated(notAuthorised, () -> feature.getDetails(1));\n    }\n\n    @Test(expected = NotFoundException.class)\n    public void getDetails_throwsExceptionIfNotFound() {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            feature.getDetails(1);\n        });\n    }\n\n    @Theory\n    public void getDetails_causeAndSourceValues(final OtherwiseDeceasedCause cause,\n                                                final OtherwiseDeceasedSource source) {\n        final OtherwiseDeceased item = es.newOtherwiseDeceased(cause, source);\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            runInTransaction(() -> {\n                OtherwiseDeceasedDTO result = feature.getDetails(item.getId());\n                assertThatEquals(result, item);\n                checkOutgoingDtoFields(result);\n            });\n        });\n    }\n\n    @Theory\n    public void getDetails_ageAndGenderValues(final GameAge age, final GameGender gender) {\n        final OtherwiseDeceased item = es.newOtherwiseDeceased(age, gender);\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            runInTransaction(() -> {\n                OtherwiseDeceasedDTO result = feature.getDetails(item.getId());\n                assertThatEquals(result, item);\n                checkOutgoingDtoFields(result);\n            });\n        });\n    }\n\n    @Test\n    public void getDetails_optionalFieldsCanBeNull() {\n        final OtherwiseDeceased item = es.newOtherwiseDeceased();\n        item.setWeight(null);\n        item.setDescription(null);\n        item.setAdditionalInfo(null);\n        item.setCauseOther(null);\n        item.setSourceOther(null);\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            runInTransaction(() -> {\n                OtherwiseDeceasedDTO result = feature.getDetails(item.getId());\n                assertThat(result.getWeight(), is(nullValue()));\n                assertThat(result.getDescription(), is(nullValue()));\n                assertThat(result.getAdditionalInfo(), is(nullValue()));\n                assertThat(result.getCauseOther(), is(nullValue()));\n                assertThat(result.getSourceOther(), is(nullValue()));\n                assertThatEquals(result, item);\n                checkOutgoingDtoFields(result);\n            });\n        });\n    }\n\n    @Test(expected = AccessDeniedException.class)\n    public void save_moderatorMustHavePrivilege() {\n        onSavedAndAuthenticated(notAuthorised, () -> {\n            feature.save(newOtherwiseDeceasedDTO());\n        });\n    }\n\n    @Theory\n    public void save_andCreate_withAgeAndGender(final GameAge age, final GameGender gender) {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final OtherwiseDeceasedDTO input = newOtherwiseDeceasedDTO();\n            input.setAge(age);\n            input.setGender(gender);\n            saveAndCheckDTO(input);\n        });\n    }\n\n    @Theory\n    public void save_andCreate_withCauseAndSource(final OtherwiseDeceasedCause cause, final OtherwiseDeceasedSource source) {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final OtherwiseDeceasedDTO input = newOtherwiseDeceasedDTO();\n            input.setCause(cause);\n            input.setSource(source);\n            saveAndCheckDTO(input);\n        });\n    }\n\n    @Theory\n    public void save_andCreate_withRejectedAndNoExactLocation(final boolean isRejected, final boolean noExactLocation) {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final OtherwiseDeceasedDTO input = newOtherwiseDeceasedDTO();\n            input.setRejected(isRejected);\n            input.setNoExactLocation(noExactLocation);\n            saveAndCheckDTO(input);\n        });\n    }\n\n    @Theory\n    public void save_andUpdate_withAgeAndGender(final GameAge age, final GameGender gender) {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final OtherwiseDeceasedDTO created = feature.save(newOtherwiseDeceasedDTO());\n            created.setAge(age);\n            created.setGender(gender);\n            created.setReasonForChange(\"Reason for change\");\n            updateAndCheckDTO(created);\n        });\n    }\n\n    @Theory\n    public void save_andUpdate_withCauseAndSource(final OtherwiseDeceasedCause cause, final OtherwiseDeceasedSource source) {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final OtherwiseDeceasedDTO created = feature.save(newOtherwiseDeceasedDTO());\n            created.setCause(cause);\n            created.setSource(source);\n            created.setReasonForChange(\"Reason for change\");\n            updateAndCheckDTO(created);\n        });\n    }\n\n    @Theory\n    public void save_andUpdate_withRejectedAndNoExactLocation(final boolean isRejected, final boolean noExactLocation) {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final OtherwiseDeceasedDTO created = feature.save(newOtherwiseDeceasedDTO());\n            created.setRejected(isRejected);\n            created.setNoExactLocation(noExactLocation);\n            created.setReasonForChange(\"Reason for change\");\n            updateAndCheckDTO(created);\n        });\n    }\n\n    @Test\n    public void save_andUpdate_location() {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final OtherwiseDeceasedDTO created = feature.save(newOtherwiseDeceasedDTO());\n            created.setGeoLocation(location2);\n            final OtherwiseDeceasedDTO updated = feature.save(created);\n            assertThat(updated.getGeoLocation(), equalTo(location2));\n            assertThat(updated.getMunicipality(), is(notNullValue()));\n            assertThat(updated.getRhy(), is(notNullValue()));\n            assertThat(updated.getRka(), is(notNullValue()));\n            assertThat(updated.getMunicipality(), not(equalTo(created.getMunicipality())));\n            assertThat(updated.getRhy(), not(equalTo(created.getRhy())));\n            assertThat(updated.getRka(), not(equalTo(created.getRka())));\n        });\n    }\n\n    @Test\n    public void save_andUpdate_species() {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final OtherwiseDeceasedDTO created = feature.save(newOtherwiseDeceasedDTO());\n            created.setGameSpeciesCode(gameSpecies2.getOfficialCode());\n            final OtherwiseDeceasedDTO updated = feature.save(created);\n            assertThat(updated.getGameSpeciesCode(), equalTo(created.getGameSpeciesCode()));\n        });\n    }\n\n    @Test(expected = NotFoundException.class)\n    public void save_andUpdate_itemNotFound() {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final OtherwiseDeceasedDTO created = feature.save(newOtherwiseDeceasedDTO());\n            created.setId(created.getId() + 1);\n            feature.save(created);\n        });\n    }\n\n    @Test(expected = AccessDeniedException.class)\n    public void save_withAttachments_moderatorMustHavePrivilege() throws IOException {\n        authenticate(notAuthorised);\n        feature.save(newOtherwiseDeceasedDTO(), emptyList());\n    }\n\n    @Test\n    public void save_withAttachments_butThereIsNone() throws IOException {\n        authenticate(privilegedModerator);\n        final OtherwiseDeceasedDTO dto = newOtherwiseDeceasedDTO();\n        final OtherwiseDeceasedDTO saved = feature.save(dto, emptyList());\n        assertThat(saved.getAttachments(), hasSize(0));\n    }\n\n    @Test\n    public void save_withAttachments_andTheyExists() throws IOException {\n        authenticate(privilegedModerator);\n        final OtherwiseDeceasedDTO dto = newOtherwiseDeceasedDTO();\n        final MultipartFile file = newAttachment();\n        final OtherwiseDeceasedDTO saved = feature.save(dto, Arrays.asList(file));\n        runInTransaction(() -> {\n            assertThat(saved.getAttachments(), hasSize(1));\n            assertThat(saved.getAttachments().get(0).getFilename(), equalTo(file.getOriginalFilename()));\n        });\n    }\n\n    @Test(expected = AccessDeniedException.class)\n    public void reject_moderatorMustHavePrivilege() {\n        onSavedAndAuthenticated(notAuthorised, () -> feature.reject(1));\n    }\n\n    @Test(expected = NotFoundException.class)\n    public void reject_itemNotFound() {\n        onSavedAndAuthenticated(privilegedModerator, () -> feature.reject(1));\n    }\n\n    @Test\n    public void reject_restoredItem() {\n        final OtherwiseDeceased item = es.newOtherwiseDeceased();\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            feature.reject(item.getId());\n            runInTransaction(() -> {\n                final OtherwiseDeceased saved = otherwiseDeceasedRepository.findById(item.getId()).orElseThrow(NotFoundException::new);\n                assertThat(saved.isRejected(), is(true));\n                final List<OtherwiseDeceasedChange> changes = changeRepository.findAllByOtherwiseDeceasedOrderByPointOfTime(saved);\n                assertThat(changes, hasSize(1));\n                final OtherwiseDeceasedChange change = changes.get(0);\n                assertThat(change.getChangeType(), equalTo(OtherwiseDeceasedChange.ChangeType.DELETE));\n                assertThat(change.getReasonForChange(), is(nullValue()));\n                assertThat(change.getUserId(), equalTo(privilegedModerator.getId()));\n            });\n        });\n    }\n\n    @Test\n    public void reject_rejectedItem() {\n        final OtherwiseDeceased item = es.newOtherwiseDeceased();\n        item.setRejected(true);\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            feature.reject(item.getId());\n            runInTransaction(() -> {\n                final OtherwiseDeceased saved = otherwiseDeceasedRepository.findById(item.getId()).orElseThrow(NotFoundException::new);\n                assertThat(saved.isRejected(), is(true));\n                final List<OtherwiseDeceasedChange> changes = changeRepository.findAllByOtherwiseDeceasedOrderByPointOfTime(saved);\n                assertThat(changes, hasSize(0));\n            });\n        });\n    }\n\n    @Test(expected = AccessDeniedException.class)\n    public void restore_moderatorMustHavePrivilege() {\n        onSavedAndAuthenticated(notAuthorised, () -> feature.restore(1));\n    }\n\n    @Test(expected = NotFoundException.class)\n    public void restore_itemNotFound() {\n        onSavedAndAuthenticated(privilegedModerator, () -> feature.restore(1));\n    }\n\n    @Test\n    public void restore_rejectedItem() {\n        final OtherwiseDeceased item = es.newOtherwiseDeceased();\n        item.setRejected(true);\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            feature.restore(item.getId());\n            runInTransaction(() -> {\n                final OtherwiseDeceased saved = otherwiseDeceasedRepository.findById(item.getId()).orElseThrow(NotFoundException::new);\n                assertThat(saved.isRejected(), is(false));\n                final List<OtherwiseDeceasedChange> changes = changeRepository.findAllByOtherwiseDeceasedOrderByPointOfTime(saved);\n                assertThat(changes, hasSize(1));\n                final OtherwiseDeceasedChange change = changes.get(0);\n                assertThat(change.getChangeType(), equalTo(OtherwiseDeceasedChange.ChangeType.RESTORE));\n                assertThat(change.getReasonForChange(), is(nullValue()));\n                assertThat(change.getUserId(), equalTo(privilegedModerator.getId()));\n            });\n        });\n    }\n\n    @Test\n    public void restore_restoredItem() {\n        final OtherwiseDeceased item = es.newOtherwiseDeceased();\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            feature.restore(item.getId());\n            runInTransaction(() -> {\n                final OtherwiseDeceased saved = otherwiseDeceasedRepository.findById(item.getId()).orElseThrow(NotFoundException::new);\n                assertThat(saved.isRejected(), is(false));\n                final List<OtherwiseDeceasedChange> changes = changeRepository.findAllByOtherwiseDeceasedOrderByPointOfTime(saved);\n                assertThat(changes, hasSize(0));\n            });\n        });\n    }\n\n    private MultipartFile newAttachment() {\n        final byte[] attachmentData = new byte[4096];\n        new Random().nextBytes(attachmentData);\n        final String filename = \"test\" + nextLong() + \".png\";\n        return new MockMultipartFile(filename, \"//test/\" + filename, \"image/png\", attachmentData);\n    }\n\n    private void saveAndCheckDTO(final OtherwiseDeceasedDTO input) {\n        final OtherwiseDeceasedDTO output = feature.save(input);\n        assertThatEquals(output, input);\n        checkOutgoingDtoFields(output);\n        checkSavedDtoFields(output);\n        assertThat(output.isRejected(), is(false), \"rejected should be false after creation\");\n        assertThat(output.getChangeHistory(), hasSize(1), \"no change info\");\n        final OtherwiseDeceasedChangeDTO changeDTO = output.getChangeHistory().get(0);\n        assertThat(changeDTO.getReasonForChange(), is(nullValue()), \"change reason not null\");\n        assertThat(changeDTO.getChangeType(), equalTo(OtherwiseDeceasedChange.ChangeType.CREATE), \"change type not CREATE\");\n        assertThat(changeDTO.getAuthor().getId(), equalTo(privilegedModerator.getId()), \"author id mismatch\");\n    }\n\n    private void updateAndCheckDTO(final OtherwiseDeceasedDTO created) {\n        final OtherwiseDeceasedDTO updated = feature.save(created);\n        assertThatEquals(created, updated);\n        checkOutgoingDtoFields(updated);\n        checkSavedDtoFields(updated);\n        assertThat(updated.isRejected(), is(false), \"rejected should be false after creation\");\n\n        assertThat(updated.getChangeHistory(), hasSize(2), \"no change info\");\n        final OtherwiseDeceasedChangeDTO changeDTO = updated.getChangeHistory().get(1);\n        assertThat(changeDTO.getReasonForChange(), equalTo(created.getReasonForChange()), \"change reason mismatch\");\n        assertThat(changeDTO.getChangeType(), equalTo(OtherwiseDeceasedChange.ChangeType.MODIFY), \"change type not MODIFY\");\n        assertThat(changeDTO.getAuthor().getId(), equalTo(privilegedModerator.getId()), \"author id mismatch\");\n    }\n\n    private void assertThatEquals(final OtherwiseDeceasedDTO actual, final OtherwiseDeceasedDTO expected) {\n        assertThat(actual.getGameSpeciesCode(), equalTo(expected.getGameSpeciesCode()), \"species mismatch\");\n        assertThat(actual.getAge(), equalTo(expected.getAge()), \"age mismatch\");\n        assertThat(actual.getGender(), equalTo(expected.getGender()), \"gender mismatch\");\n        assertThat(actual.getWeight(), equalTo(expected.getWeight()), \"weight mismatch\");\n        assertThat(actual.getPointOfTime(), equalTo(expected.getPointOfTime()), \"pointOfTime mismatch\");\n        assertThat(actual.isNoExactLocation(), equalTo(expected.isNoExactLocation()), \"isNoExactLocation mismatch\");\n        assertThat(actual.getGeoLocation(), equalTo(expected.getGeoLocation()), \"geoLocation mismatch\");\n        assertThat(actual.getCause(), equalTo(expected.getCause()), \"cause mismatch\");\n        assertThat(actual.getSource(), equalTo(expected.getSource()), \"source mismatch\");\n        assertThat(actual.getDescription(), equalTo(expected.getDescription()), \"description mismatch\");\n        assertThat(actual.getAdditionalInfo(), equalTo(expected.getAdditionalInfo()), \"additionalInfo mismatch\");\n    }\n\n    private void checkSavedDtoFields(final OtherwiseDeceasedDTO dto) {\n        if (dto.getCauseOther() != null) {\n            assertThat(dto.getCause(), equalTo(OtherwiseDeceasedCause.OTHER), \"causeOther has value but cause is not OTHER\");\n        }\n\n        if (dto.getSourceOther() != null) {\n            assertThat(dto.getSource(), equalTo(OtherwiseDeceasedSource.OTHER), \"sourceOther has value but source is not OTHER\");\n        }\n    }\n\n    private void assertThatEquals(final OtherwiseDeceasedDTO dto, final OtherwiseDeceased entity) {\n        assertThat(dto.getId(), equalTo(entity.getId()), \"id mismatch\");\n        assertThat(dto.getPointOfTime(), equalTo(entity.getPointOfTime().toLocalDateTime()));\n        assertThat(dto.getGameSpeciesCode(), equalTo(entity.getSpecies().getOfficialCode()), \"species mismatch\");\n        assertThat(dto.getAge(), equalTo(entity.getAge()), \"age mismatch\");\n        assertThat(dto.getGender(), equalTo(entity.getGender()), \"gender mismatch\");\n        assertThat(dto.getWeight(), equalTo(entity.getWeight()), \"weight mismatch\");\n        assertThat(dto.getGeoLocation(), equalTo(entity.getGeoLocation()), \"geoLocation mismatch\");\n        assertThat(dto.getMunicipality().getNameLocalisation(), equalTo(entity.getMunicipality().getNameLocalisation()), \"municipality name\");\n        assertThat(dto.getRhy().getNameLocalisation(), equalTo(entity.getRhy().getNameLocalisation()), \"rhy name mismatch\");\n        assertThat(dto.getRka().getNameLocalisation(), equalTo(entity.getRka().getNameLocalisation()), \"rka name mismatch\");\n        assertThat(dto.getCause(), equalTo(entity.getCause()), \"cause mismatch\");\n        assertThat(dto.getCauseOther(), equalTo(entity.getCauseOther()), \"cause mismatch\");\n        assertThat(dto.getSource(), equalTo(entity.getSource()), \"source mismatch\");\n        assertThat(dto.getSourceOther(), equalTo(entity.getSourceOther()), \"sourceOther mismatch\");\n        assertThat(dto.getDescription(), equalTo(entity.getDescription()), \"description mismatch\");\n        assertThat(dto.getAdditionalInfo(), equalTo(entity.getAdditionalInfo()), \"additional info mismatch\");\n        assertThat(dto.isRejected(), equalTo(entity.isRejected()), \"rejected mismatch\");\n        assertThat(dto.getAttachments(), hasSize(entity.getAttachments().size()), \"attachment mismatch\");\n        assertThat(dto.getChangeHistory(), hasSize(entity.getChangeHistory().size()), \"changes mismatch\");\n        assertThatAttachmentsEquals(dto.getAttachments(), entity.getAttachments());\n        assertThatChangesEquals(dto.getChangeHistory(), entity.getChangeHistory());\n    }\n\n    private void assertThatAttachmentsEquals(final List<OtherwiseDeceasedAttachmentDTO> dtos,\n                                             final List<OtherwiseDeceasedAttachment> entities) {\n        assertThat(dtos, hasSize(entities.size()), \"number of attachment mismatch\");\n        final Map<Long, OtherwiseDeceasedAttachment> entityMap = F.indexById(entities);\n        dtos.forEach(dto -> assertThatEquals(dto, entityMap.get(dto.getId())));\n    }\n\n    private void assertThatEquals(final OtherwiseDeceasedAttachmentDTO dto,\n                                  final OtherwiseDeceasedAttachment entity) {\n        assertThat(dto.getId(), equalTo(entity.getId()), \"attachment id mismatch\");\n        assertThat(dto.getFilename(),\n                   equalTo(entity.getAttachmentMetadata().getOriginalFilename()),\n                   \"attachment filename mismatch\");\n    }\n\n    private void assertThatChangesEquals(final List<OtherwiseDeceasedChangeDTO> dtos,\n                                         final List<OtherwiseDeceasedChange> entities) {\n        assertThat(dtos, hasSize(entities.size()));\n        final Map<Long, OtherwiseDeceasedChange> entityMap = F.indexById(entities);\n        dtos.forEach(dto -> assertThatEquals(dto, entityMap.get(dto.getId())));\n    }\n\n    private void assertThatEquals(final OtherwiseDeceasedChangeDTO dto,\n                                  final OtherwiseDeceasedChange entity) {\n        assertThat(dto.getId(), equalTo(entity.getId()));\n        assertThat(dto.getAuthor().getId(), equalTo(entity.getUserId()), \"change author mismatch\");\n        assertThat(dto.getModificationTime(), equalTo(entity.getPointOfTime()), \"change pointOfTime mismatch\");\n        assertThat(dto.getChangeType(), equalTo(entity.getChangeType()), \"change type mismatch\");\n        assertThat(dto.getReasonForChange(), equalTo(entity.getReasonForChange()), \"change reason mismatch\");\n    }\n\n    private void checkOutgoingDtoFields(final OtherwiseDeceasedDTO dto) {\n        assertThat(dto.getId(), is(notNullValue()), \"outgoing dto id is null\");\n        assertThat(dto.getRhy().getOfficialCode(), is(notNullValue()), \"rhy officialCode is null\");\n        assertThat(dto.getRka().getOfficialCode(), is(notNullValue()), \"rka officialCode is null\");\n        assertThat(dto.getReasonForChange(), is(nullValue()), \"reasonForChange is not null\");\n    }\n\n    private OtherwiseDeceasedDTO newOtherwiseDeceasedDTO() {\n        final OtherwiseDeceasedDTO dto = new OtherwiseDeceasedDTO();\n        dto.setGameSpeciesCode(gameSpecies1.getOfficialCode());\n        dto.setAge(some(GameAge.class));\n        dto.setGender(some(GameGender.class));\n        dto.setWeight(weight());\n        dto.setPointOfTime(LocalDateTime.now());\n        dto.setNoExactLocation(someBoolean());\n        dto.setGeoLocation(location1);\n        //dto.setMunicipality()\n        //dto.setRhy()\n        //dto.setRka()\n        dto.setCause(some(OtherwiseDeceasedCause.class));\n        dto.setCauseOther(\"Cause other \" + nextLong());\n        dto.setSource(some(OtherwiseDeceasedSource.class));\n        dto.setSourceOther(\"Source other \" + nextLong());\n        dto.setDescription(\"Description \" + nextLong());\n        dto.setAdditionalInfo(\"Additional ingo \" + nextLong());\n        return dto;\n    }\n}", "item_id": 0, "repo": "suomenriistakeskus/oma-riista-web", "file": "src/test/java/fi/riista/feature/otherwisedeceased/OtherwiseDeceasedFeatureTest.java", "last_update_at": "2022-02-09T06:49:46+00:00", "question_id": "5d20351af1ca40e6f69d30e686093f8186a2d643_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(Theories.class)\npublic class OtherwiseDeceasedFeatureTest extends EmbeddedDatabaseTest {\n    @Resource\n    private OtherwiseDeceasedFeature feature;\n    @Resource\n    private OtherwiseDeceasedRepository otherwiseDeceasedRepository;\n    @Resource\n    private OtherwiseDeceasedChangeRepository changeRepository;\n    private SystemUser privilegedModerator;\n    private SystemUser notAuthorised;\n    private EntitySupplier es;\n    private GameSpecies gameSpecies1;\n    private GameSpecies gameSpecies2;\n    private GeoLocation location1;\n    private GeoLocation location2;\n    private Municipality municipality1;\n    private Municipality municipality2;\n    private Riistanhoitoyhdistys rhy1;\n    private Riistanhoitoyhdistys rhy2;\n    @Before\n    public void setUp() {\n        es = getEntitySupplier();\n        privilegedModerator = createNewModerator(SystemUserPrivilege.MUUTOIN_KUOLLEET);\n        notAuthorised = createNewModerator();\n        gameSpecies1 = es.newGameSpecies();\n        gameSpecies2 = es.newGameSpecies();\n        location1 = geoLocation();\n        location2 = geoLocation();\n        municipality1 = es.newMunicipality();\n        municipality2 = es.newMunicipality();\n        rhy1 = es.newRiistanhoitoyhdistys();\n        rhy2 = es.newRiistanhoitoyhdistys();\n        persistInNewTransaction();\n    }\n    @Test(expected = AccessDeniedException.class)\n    public void listByYear_moderatorMustHavePrivilege() {\n        onSavedAndAuthenticated(notAuthorised, () -> feature.listByYear(2021));\n    }\n    @Test\n    public void listByYear_returnsEmptyListIfNoneFound() {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final List<OtherwiseDeceasedBriefDTO> results = feature.listByYear(2021);\n            assertThat(results, hasSize(0));\n        });\n    }\n    @Test\n    public void listByYear_andOnlyByThatYear() {\n        final OtherwiseDeceased item = es.newOtherwiseDeceased(new DateTime(2021, 1, 1, 0, 0, Constants.DEFAULT_TIMEZONE));\n        es.newOtherwiseDeceased(new DateTime(2020, 12, 31, 23, 59, 59, 999, Constants.DEFAULT_TIMEZONE));\n        es.newOtherwiseDeceased(new DateTime(2022, 1, 1, 0, 0, Constants.DEFAULT_TIMEZONE));\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            runInTransaction(() -> {\n                final List<OtherwiseDeceasedBriefDTO> results = feature.listByYear(2021);\n                assertThat(results, hasSize(1));\n                final OtherwiseDeceasedBriefDTO result = results.get(0);\n                assertThat(result.getPointOfTime(), equalTo(item.getPointOfTime().toLocalDateTime()));\n                assertThat(result.getCause(), equalTo(item.getCause()));\n                assertThat(result.getGameSpeciesCode(), equalTo(item.getSpecies().getOfficialCode()));\n                assertThat(result.getMunicipality().getNameFI(),\n                           equalTo(item.getMunicipality().getNameLocalisation().getFinnish()));\n                assertThat(result.getRhy().getNameFI(), equalTo(item.getRhy().getNameFinnish()));\n                assertThat(result.getRka().getNameFI(), equalTo(item.getRka().getNameFinnish()));\n            });\n        });\n    }\n    @Test(expected = AccessDeniedException.class)\n    public void getDetails_moderatorMustHavePrivilege() {\n        onSavedAndAuthenticated(notAuthorised, () -> feature.getDetails(1));\n    }\n    @Test(expected = NotFoundException.class)\n    public void getDetails_throwsExceptionIfNotFound() {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            feature.getDetails(1);\n        });\n    }\n    @Theory\n    public void getDetails_causeAndSourceValues(final OtherwiseDeceasedCause cause,\n                                                final OtherwiseDeceasedSource source) {\n        final OtherwiseDeceased item = es.newOtherwiseDeceased(cause, source);\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            runInTransaction(() -> {\n                OtherwiseDeceasedDTO result = feature.getDetails(item.getId());\n                assertThatEquals(result, item);\n                checkOutgoingDtoFields(result);\n            });\n        });\n    }\n    @Theory\n    public void getDetails_ageAndGenderValues(final GameAge age, final GameGender gender) {\n        final OtherwiseDeceased item = es.newOtherwiseDeceased(age, gender);\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            runInTransaction(() -> {\n                OtherwiseDeceasedDTO result = feature.getDetails(item.getId());\n                assertThatEquals(result, item);\n                checkOutgoingDtoFields(result);\n            });\n        });\n    }\n    @Test\n    public void getDetails_optionalFieldsCanBeNull() {\n        final OtherwiseDeceased item = es.newOtherwiseDeceased();\n        item.setWeight(null);\n        item.setDescription(null);\n        item.setAdditionalInfo(null);\n        item.setCauseOther(null);\n        item.setSourceOther(null);\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            runInTransaction(() -> {\n                OtherwiseDeceasedDTO result = feature.getDetails(item.getId());\n                assertThat(result.getWeight(), is(nullValue()));\n                assertThat(result.getDescription(), is(nullValue()));\n                assertThat(result.getAdditionalInfo(), is(nullValue()));\n                assertThat(result.getCauseOther(), is(nullValue()));\n                assertThat(result.getSourceOther(), is(nullValue()));\n                assertThatEquals(result, item);\n                checkOutgoingDtoFields(result);\n            });\n        });\n    }\n    @Test(expected = AccessDeniedException.class)\n    public void save_moderatorMustHavePrivilege() {\n        onSavedAndAuthenticated(notAuthorised, () -> {\n            feature.save(newOtherwiseDeceasedDTO());\n        });\n    }\n    @Theory\n    public void save_andCreate_withAgeAndGender(final GameAge age, final GameGender gender) {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final OtherwiseDeceasedDTO input = newOtherwiseDeceasedDTO();\n            input.setAge(age);\n            input.setGender(gender);\n            saveAndCheckDTO(input);\n        });\n    }\n    @Theory\n    public void save_andCreate_withCauseAndSource(final OtherwiseDeceasedCause cause, final OtherwiseDeceasedSource source) {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final OtherwiseDeceasedDTO input = newOtherwiseDeceasedDTO();\n            input.setCause(cause);\n            input.setSource(source);\n            saveAndCheckDTO(input);\n        });\n    }\n    @Theory\n    public void save_andCreate_withRejectedAndNoExactLocation(final boolean isRejected, final boolean noExactLocation) {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final OtherwiseDeceasedDTO input = newOtherwiseDeceasedDTO();\n            input.setRejected(isRejected);\n            input.setNoExactLocation(noExactLocation);\n            saveAndCheckDTO(input);\n        });\n    }\n    @Theory\n    public void save_andUpdate_withAgeAndGender(final GameAge age, final GameGender gender) {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final OtherwiseDeceasedDTO created = feature.save(newOtherwiseDeceasedDTO());\n            created.setAge(age);\n            created.setGender(gender);\n            created.setReasonForChange(\"Reason for change\");\n            updateAndCheckDTO(created);\n        });\n    }\n    @Theory\n    public void save_andUpdate_withCauseAndSource(final OtherwiseDeceasedCause cause, final OtherwiseDeceasedSource source) {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final OtherwiseDeceasedDTO created = feature.save(newOtherwiseDeceasedDTO());\n            created.setCause(cause);\n            created.setSource(source);\n            created.setReasonForChange(\"Reason for change\");\n            updateAndCheckDTO(created);\n        });\n    }\n    @Theory\n    public void save_andUpdate_withRejectedAndNoExactLocation(final boolean isRejected, final boolean noExactLocation) {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final OtherwiseDeceasedDTO created = feature.save(newOtherwiseDeceasedDTO());\n            created.setRejected(isRejected);\n            created.setNoExactLocation(noExactLocation);\n            created.setReasonForChange(\"Reason for change\");\n            updateAndCheckDTO(created);\n        });\n    }\n    @Test\n    public void save_andUpdate_location() {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final OtherwiseDeceasedDTO created = feature.save(newOtherwiseDeceasedDTO());\n            created.setGeoLocation(location2);\n            final OtherwiseDeceasedDTO updated = feature.save(created);\n            assertThat(updated.getGeoLocation(), equalTo(location2));\n            assertThat(updated.getMunicipality(), is(notNullValue()));\n            assertThat(updated.getRhy(), is(notNullValue()));\n            assertThat(updated.getRka(), is(notNullValue()));\n            assertThat(updated.getMunicipality(), not(equalTo(created.getMunicipality())));\n            assertThat(updated.getRhy(), not(equalTo(created.getRhy())));\n            assertThat(updated.getRka(), not(equalTo(created.getRka())));\n        });\n    }\n    @Test\n    public void save_andUpdate_species() {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final OtherwiseDeceasedDTO created = feature.save(newOtherwiseDeceasedDTO());\n            created.setGameSpeciesCode(gameSpecies2.getOfficialCode());\n            final OtherwiseDeceasedDTO updated = feature.save(created);\n            assertThat(updated.getGameSpeciesCode(), equalTo(created.getGameSpeciesCode()));\n        });\n    }\n    @Test(expected = NotFoundException.class)\n    public void save_andUpdate_itemNotFound() {\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            final OtherwiseDeceasedDTO created = feature.save(newOtherwiseDeceasedDTO());\n            created.setId(created.getId() + 1);\n            feature.save(created);\n        });\n    }\n    @Test(expected = AccessDeniedException.class)\n    public void save_withAttachments_moderatorMustHavePrivilege() throws IOException {\n        authenticate(notAuthorised);\n        feature.save(newOtherwiseDeceasedDTO(), emptyList());\n    }\n    @Test\n    public void save_withAttachments_butThereIsNone() throws IOException {\n        authenticate(privilegedModerator);\n        final OtherwiseDeceasedDTO dto = newOtherwiseDeceasedDTO();\n        final OtherwiseDeceasedDTO saved = feature.save(dto, emptyList());\n        assertThat(saved.getAttachments(), hasSize(0));\n    }\n    @Test\n    public void save_withAttachments_andTheyExists() throws IOException {\n        authenticate(privilegedModerator);\n        final OtherwiseDeceasedDTO dto = newOtherwiseDeceasedDTO();\n        final MultipartFile file = newAttachment();\n        final OtherwiseDeceasedDTO saved = feature.save(dto, Arrays.asList(file));\n        runInTransaction(() -> {\n            assertThat(saved.getAttachments(), hasSize(1));\n            assertThat(saved.getAttachments().get(0).getFilename(), equalTo(file.getOriginalFilename()));\n        });\n    }\n    @Test(expected = AccessDeniedException.class)\n    public void reject_moderatorMustHavePrivilege() {\n        onSavedAndAuthenticated(notAuthorised, () -> feature.reject(1));\n    }\n    @Test(expected = NotFoundException.class)\n    public void reject_itemNotFound() {\n        onSavedAndAuthenticated(privilegedModerator, () -> feature.reject(1));\n    }\n    @Test\n    public void reject_restoredItem() {\n        final OtherwiseDeceased item = es.newOtherwiseDeceased();\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            feature.reject(item.getId());\n            runInTransaction(() -> {\n                final OtherwiseDeceased saved = otherwiseDeceasedRepository.findById(item.getId()).orElseThrow(NotFoundException::new);\n                assertThat(saved.isRejected(), is(true));\n                final List<OtherwiseDeceasedChange> changes = changeRepository.findAllByOtherwiseDeceasedOrderByPointOfTime(saved);\n                assertThat(changes, hasSize(1));\n                final OtherwiseDeceasedChange change = changes.get(0);\n                assertThat(change.getChangeType(), equalTo(OtherwiseDeceasedChange.ChangeType.DELETE));\n                assertThat(change.getReasonForChange(), is(nullValue()));\n                assertThat(change.getUserId(), equalTo(privilegedModerator.getId()));\n            });\n        });\n    }\n    @Test\n    public void reject_rejectedItem() {\n        final OtherwiseDeceased item = es.newOtherwiseDeceased();\n        item.setRejected(true);\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            feature.reject(item.getId());\n            runInTransaction(() -> {\n                final OtherwiseDeceased saved = otherwiseDeceasedRepository.findById(item.getId()).orElseThrow(NotFoundException::new);\n                assertThat(saved.isRejected(), is(true));\n                final List<OtherwiseDeceasedChange> changes = changeRepository.findAllByOtherwiseDeceasedOrderByPointOfTime(saved);\n                assertThat(changes, hasSize(0));\n            });\n        });\n    }\n    @Test(expected = AccessDeniedException.class)\n    public void restore_moderatorMustHavePrivilege() {\n        onSavedAndAuthenticated(notAuthorised, () -> feature.restore(1));\n    }\n    @Test(expected = NotFoundException.class)\n    public void restore_itemNotFound() {\n        onSavedAndAuthenticated(privilegedModerator, () -> feature.restore(1));\n    }\n    @Test\n    public void restore_rejectedItem() {\n        final OtherwiseDeceased item = es.newOtherwiseDeceased();\n        item.setRejected(true);\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            feature.restore(item.getId());\n            runInTransaction(() -> {\n                final OtherwiseDeceased saved = otherwiseDeceasedRepository.findById(item.getId()).orElseThrow(NotFoundException::new);\n                assertThat(saved.isRejected(), is(false));\n                final List<OtherwiseDeceasedChange> changes = changeRepository.findAllByOtherwiseDeceasedOrderByPointOfTime(saved);\n                assertThat(changes, hasSize(1));\n                final OtherwiseDeceasedChange change = changes.get(0);\n                assertThat(change.getChangeType(), equalTo(OtherwiseDeceasedChange.ChangeType.RESTORE));\n                assertThat(change.getReasonForChange(), is(nullValue()));\n                assertThat(change.getUserId(), equalTo(privilegedModerator.getId()));\n            });\n        });\n    }\n    @Test\n    public void restore_restoredItem() {\n        final OtherwiseDeceased item = es.newOtherwiseDeceased();\n        onSavedAndAuthenticated(privilegedModerator, () -> {\n            feature.restore(item.getId());\n            runInTransaction(() -> {\n                final OtherwiseDeceased saved = otherwiseDeceasedRepository.findById(item.getId()).orElseThrow(NotFoundException::new);\n                assertThat(saved.isRejected(), is(false));\n                final List<OtherwiseDeceasedChange> changes = changeRepository.findAllByOtherwiseDeceasedOrderByPointOfTime(saved);\n                assertThat(changes, hasSize(0));\n            });\n        });\n    }\n    private MultipartFile newAttachment() {\n        final byte[] attachmentData = new byte[4096];\n        new Random().nextBytes(attachmentData);\n        final String filename = \"test\" + nextLong() + \".png\";\n        return new MockMultipartFile(filename, \"//test/\" + filename, \"image/png\", attachmentData);\n    }\n    private void saveAndCheckDTO(final OtherwiseDeceasedDTO input) {\n        final OtherwiseDeceasedDTO output = feature.save(input);\n        assertThatEquals(output, input);\n        checkOutgoingDtoFields(output);\n        checkSavedDtoFields(output);\n        assertThat(output.isRejected(), is(false), \"rejected should be false after creation\");\n        assertThat(output.getChangeHistory(), hasSize(1), \"no change info\");\n        final OtherwiseDeceasedChangeDTO changeDTO = output.getChangeHistory().get(0);\n        assertThat(changeDTO.getReasonForChange(), is(nullValue()), \"change reason not null\");\n        assertThat(changeDTO.getChangeType(), equalTo(OtherwiseDeceasedChange.ChangeType.CREATE), \"change type not CREATE\");\n        assertThat(changeDTO.getAuthor().getId(), equalTo(privilegedModerator.getId()), \"author id mismatch\");\n    }\n    private void updateAndCheckDTO(final OtherwiseDeceasedDTO created) {\n        final OtherwiseDeceasedDTO updated = feature.save(created);\n        assertThatEquals(created, updated);\n        checkOutgoingDtoFields(updated);\n        checkSavedDtoFields(updated);\n        assertThat(updated.isRejected(), is(false), \"rejected should be false after creation\");\n        assertThat(updated.getChangeHistory(), hasSize(2), \"no change info\");\n        final OtherwiseDeceasedChangeDTO changeDTO = updated.getChangeHistory().get(1);\n        assertThat(changeDTO.getReasonForChange(), equalTo(created.getReasonForChange()), \"change reason mismatch\");\n        assertThat(changeDTO.getChangeType(), equalTo(OtherwiseDeceasedChange.ChangeType.MODIFY), \"change type not MODIFY\");\n        assertThat(changeDTO.getAuthor().getId(), equalTo(privilegedModerator.getId()), \"author id mismatch\");\n    }\n    private void assertThatEquals(final OtherwiseDeceasedDTO actual, final OtherwiseDeceasedDTO expected) {\n        assertThat(actual.getGameSpeciesCode(), equalTo(expected.getGameSpeciesCode()), \"species mismatch\");\n        assertThat(actual.getAge(), equalTo(expected.getAge()), \"age mismatch\");\n        assertThat(actual.getGender(), equalTo(expected.getGender()), \"gender mismatch\");\n        assertThat(actual.getWeight(), equalTo(expected.getWeight()), \"weight mismatch\");\n        assertThat(actual.getPointOfTime(), equalTo(expected.getPointOfTime()), \"pointOfTime mismatch\");\n        assertThat(actual.isNoExactLocation(), equalTo(expected.isNoExactLocation()), \"isNoExactLocation mismatch\");\n        assertThat(actual.getGeoLocation(), equalTo(expected.getGeoLocation()), \"geoLocation mismatch\");\n        assertThat(actual.getCause(), equalTo(expected.getCause()), \"cause mismatch\");\n        assertThat(actual.getSource(), equalTo(expected.getSource()), \"source mismatch\");\n        assertThat(actual.getDescription(), equalTo(expected.getDescription()), \"description mismatch\");\n        assertThat(actual.getAdditionalInfo(), equalTo(expected.getAdditionalInfo()), \"additionalInfo mismatch\");\n    }\n    private void checkSavedDtoFields(final OtherwiseDeceasedDTO dto) {\n        if (dto.getCauseOther() != null) {\n            assertThat(dto.getCause(), equalTo(OtherwiseDeceasedCause.OTHER), \"causeOther has value but cause is not OTHER\");\n        }\n        if (dto.getSourceOther() != null) {\n            assertThat(dto.getSource(), equalTo(OtherwiseDeceasedSource.OTHER), \"sourceOther has value but source is not OTHER\");\n        }\n    }\n    private void assertThatEquals(final OtherwiseDeceasedDTO dto, final OtherwiseDeceased entity) {\n        assertThat(dto.getId(), equalTo(entity.getId()), \"id mismatch\");\n        assertThat(dto.getPointOfTime(), equalTo(entity.getPointOfTime().toLocalDateTime()));\n        assertThat(dto.getGameSpeciesCode(), equalTo(entity.getSpecies().getOfficialCode()), \"species mismatch\");\n        assertThat(dto.getAge(), equalTo(entity.getAge()), \"age mismatch\");\n        assertThat(dto.getGender(), equalTo(entity.getGender()), \"gender mismatch\");\n        assertThat(dto.getWeight(), equalTo(entity.getWeight()), \"weight mismatch\");\n        assertThat(dto.getGeoLocation(), equalTo(entity.getGeoLocation()), \"geoLocation mismatch\");\n        assertThat(dto.getMunicipality().getNameLocalisation(), equalTo(entity.getMunicipality().getNameLocalisation()), \"municipality name\");\n        assertThat(dto.getRhy().getNameLocalisation(), equalTo(entity.getRhy().getNameLocalisation()), \"rhy name mismatch\");\n        assertThat(dto.getRka().getNameLocalisation(), equalTo(entity.getRka().getNameLocalisation()), \"rka name mismatch\");\n        assertThat(dto.getCause(), equalTo(entity.getCause()), \"cause mismatch\");\n        assertThat(dto.getCauseOther(), equalTo(entity.getCauseOther()), \"cause mismatch\");\n        assertThat(dto.getSource(), equalTo(entity.getSource()), \"source mismatch\");\n        assertThat(dto.getSourceOther(), equalTo(entity.getSourceOther()), \"sourceOther mismatch\");\n        assertThat(dto.getDescription(), equalTo(entity.getDescription()), \"description mismatch\");\n        assertThat(dto.getAdditionalInfo(), equalTo(entity.getAdditionalInfo()), \"additional info mismatch\");\n        assertThat(dto.isRejected(), equalTo(entity.isRejected()), \"rejected mismatch\");\n        assertThat(dto.getAttachments(), hasSize(entity.getAttachments().size()), \"attachment mismatch\");\n        assertThat(dto.getChangeHistory(), hasSize(entity.getChangeHistory().size()), \"changes mismatch\");\n        assertThatAttachmentsEquals(dto.getAttachments(), entity.getAttachments());\n        assertThatChangesEquals(dto.getChangeHistory(), entity.getChangeHistory());\n    }\n    private void assertThatAttachmentsEquals(final List<OtherwiseDeceasedAttachmentDTO> dtos,\n                                             final List<OtherwiseDeceasedAttachment> entities) {\n        assertThat(dtos, hasSize(entities.size()), \"number of attachment mismatch\");\n        final Map<Long, OtherwiseDeceasedAttachment> entityMap = F.indexById(entities);\n        dtos.forEach(dto -> assertThatEquals(dto, entityMap.get(dto.getId())));\n    }\n    private void assertThatEquals(final OtherwiseDeceasedAttachmentDTO dto,\n                                  final OtherwiseDeceasedAttachment entity) {\n        assertThat(dto.getId(), equalTo(entity.getId()), \"attachment id mismatch\");\n        assertThat(dto.getFilename(),\n                   equalTo(entity.getAttachmentMetadata().getOriginalFilename()),\n                   \"attachment filename mismatch\");\n    }\n    private void assertThatChangesEquals(final List<OtherwiseDeceasedChangeDTO> dtos,\n                                         final List<OtherwiseDeceasedChange> entities) {\n        assertThat(dtos, hasSize(entities.size()));\n        final Map<Long, OtherwiseDeceasedChange> entityMap = F.indexById(entities);\n        dtos.forEach(dto -> assertThatEquals(dto, entityMap.get(dto.getId())));\n    }\n    private void assertThatEquals(final OtherwiseDeceasedChangeDTO dto,\n                                  final OtherwiseDeceasedChange entity) {\n        assertThat(dto.getId(), equalTo(entity.getId()));\n        assertThat(dto.getAuthor().getId(), equalTo(entity.getUserId()), \"change author mismatch\");\n        assertThat(dto.getModificationTime(), equalTo(entity.getPointOfTime()), \"change pointOfTime mismatch\");\n        assertThat(dto.getChangeType(), equalTo(entity.getChangeType()), \"change type mismatch\");\n        assertThat(dto.getReasonForChange(), equalTo(entity.getReasonForChange()), \"change reason mismatch\");\n    }\n    private void checkOutgoingDtoFields(final OtherwiseDeceasedDTO dto) {\n        assertThat(dto.getId(), is(notNullValue()), \"outgoing dto id is null\");\n        assertThat(dto.getRhy().getOfficialCode(), is(notNullValue()), \"rhy officialCode is null\");\n        assertThat(dto.getRka().getOfficialCode(), is(notNullValue()), \"rka officialCode is null\");\n        assertThat(dto.getReasonForChange(), is(nullValue()), \"reasonForChange is not null\");\n    }\n    private OtherwiseDeceasedDTO newOtherwiseDeceasedDTO() {\n        final OtherwiseDeceasedDTO dto = new OtherwiseDeceasedDTO();\n        dto.setGameSpeciesCode(gameSpecies1.getOfficialCode());\n        dto.setAge(some(GameAge.class));\n        dto.setGender(some(GameGender.class));\n        dto.setWeight(weight());\n        dto.setPointOfTime(LocalDateTime.now());\n        dto.setNoExactLocation(someBoolean());\n        dto.setGeoLocation(location1);\n        //dto.setMunicipality()\n        //dto.setRhy()\n        //dto.setRka()\n        dto.setCause(some(OtherwiseDeceasedCause.class));\n        dto.setCauseOther(\"Cause other \" + nextLong());\n        dto.setSource(some(OtherwiseDeceasedSource.class));\n        dto.setSourceOther(\"Source other \" + nextLong());\n        dto.setDescription(\"Description \" + nextLong());\n        dto.setAdditionalInfo(\"Additional ingo \" + nextLong());\n        return dto;\n    }\n"]], "pred": {"ppl": 1.6562774181365967, "ppl_lower": 2.0988917350769043, "ppl/lowercase_ppl": -1.4693812381123603, "ppl/zlib": 0.0001482293081556986, "Min_5.0% Prob": 6.204884141099219, "Min_10.0% Prob": 4.202794503931906, "Min_20.0% Prob": 2.449134203148823, "Min_30.0% Prob": 1.6737121501511414, "Min_40.0% Prob": 1.2589766340885848, "Min_50.0% Prob": 1.0093933571551046, "Min_60.0% Prob": 0.8418842973126794}}
{"hexsha": "3b02ebef53958906e7e0cdfc4e765a08c6978cdd", "ext": "java", "lang": "Java", "content": "public class MatchLineQuery implements SearchFiltersQuery {\n  private final int _lineNum;\n\n  MatchLineQuery(int lineNum) {\n    _lineNum = lineNum;\n  }\n\n  public int getLineNum() {\n    return _lineNum;\n  }\n\n  @Override\n  public boolean canQuery(IpAccessList acl) {\n    return acl.getLines().size() > _lineNum;\n  }\n\n  @Override\n  @Nonnull\n  public BDD getMatchingBdd(IpAccessList acl, IpAccessListToBdd ipAccessListToBdd, BDDPacket pkt) {\n    checkArgument(canQuery(acl), \"ACL %s is too short to apply match line query\", acl.getName());\n\n    // Generate BDD matching all flows that would match the target line, then subtract out the BDD\n    // of all flows matched by any previous line\n    BDD matchingTargetLine =\n        ipAccessListToBdd.toPermitAndDenyBdds(acl.getLines().get(_lineNum)).getMatchBdd();\n    List<BDD> prevLineBdds =\n        IntStream.range(0, _lineNum)\n            .mapToObj(\n                i -> ipAccessListToBdd.toPermitAndDenyBdds(acl.getLines().get(i)).getMatchBdd())\n            .collect(ImmutableList.toImmutableList());\n    return matchingTargetLine.diff(pkt.getFactory().orAll(prevLineBdds));\n  }\n}", "item_id": 0, "repo": "zabrewer/batfish", "file": "projects/batfish-common-protocol/src/main/java/org/batfish/question/searchfilters/MatchLineQuery.java", "last_update_at": "2022-03-29T09:27:14+00:00", "question_id": "3b02ebef53958906e7e0cdfc4e765a08c6978cdd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MatchLineQuery implements SearchFiltersQuery {\n  private final int _lineNum;\n  MatchLineQuery(int lineNum) {\n    _lineNum = lineNum;\n  }\n  public int getLineNum() {\n    return _lineNum;\n  }\n  @Override\n  public boolean canQuery(IpAccessList acl) {\n    return acl.getLines().size() > _lineNum;\n  }\n  @Override\n  @Nonnull\n  public BDD getMatchingBdd(IpAccessList acl, IpAccessListToBdd ipAccessListToBdd, BDDPacket pkt) {\n    checkArgument(canQuery(acl), \"ACL %s is too short to apply match line query\", acl.getName());\n    // Generate BDD matching all flows that would match the target line, then subtract out the BDD\n    // of all flows matched by any previous line\n    BDD matchingTargetLine =\n        ipAccessListToBdd.toPermitAndDenyBdds(acl.getLines().get(_lineNum)).getMatchBdd();\n    List<BDD> prevLineBdds =\n        IntStream.range(0, _lineNum)\n            .mapToObj(\n                i -> ipAccessListToBdd.toPermitAndDenyBdds(acl.getLines().get(i)).getMatchBdd())\n            .collect(ImmutableList.toImmutableList());\n    return matchingTargetLine.diff(pkt.getFactory().orAll(prevLineBdds));\n  }\n"]], "pred": {"ppl": 2.1842586994171143, "ppl_lower": 3.1097428798675537, "ppl/lowercase_ppl": -1.4521619979092122, "ppl/zlib": 0.001531914711729067, "Min_5.0% Prob": 6.557360119289822, "Min_10.0% Prob": 5.0064518516128125, "Min_20.0% Prob": 3.479613384685001, "Min_30.0% Prob": 2.521917933864253, "Min_40.0% Prob": 1.9476630927732326, "Min_50.0% Prob": 1.560417893895491, "Min_60.0% Prob": 1.3039743996611963}}
{"hexsha": "5b87507066ab7e7c25aba54b78a5daed9a364cb4", "ext": "java", "lang": "Java", "content": "public final class APIJsonMapper {\n\n    /** Module used to extend the object mappers functionality in terms of mapping the APIs data model interfaces */\n    private static final SimpleModule DATA_MODULE = createDataModule();\n\n    /** Module used to extend the object mappers functionality in terms of mapping JDK8 Optionals */\n    private static final Module JDK8_MODULE = new Jdk8Module();\n\n    private APIJsonMapper() {}      // Private constructor. Only static methods\n\n    /**\n     * Maps some <i>TheTVDB.com</i> API response JSON into it's Java model representation.\n     *\n     * @param json          The full JSON as returned by the remote service\n     * @param typeReference Type reference representing the Java model structure to which the JSON should be mapped to\n     * @param <T>           The DTO type to which the JSON's {@code data} node should be mapped to\n     *\n     * @return Extended API response containing the requested data parsed from the given JSON as well as additional\n     *         status information.\n     *\n     * @throws APIException If an IO error occurred during the deserialization of the given JSON object\n     */\n    public static <T> APIResponse<T> readValue(@Nonnull JsonNode json,\n            @Nonnull TypeReference<APIResponse<T>> typeReference) throws APIException {\n        try {\n            return new ObjectMapper()\n                    .registerModule(createAPIResponseModule(((ParameterizedType)typeReference.getType())\n                            .getActualTypeArguments()[0]))\n                    .readValue(json.toString(), typeReference);\n        } catch (JsonProcessingException | IllegalArgumentException ex) {\n            throw new APIException(String.format(API_JSON_PARSE_ERROR, ex.getMessage()), ex);\n        }\n    }\n\n    /**\n     * Creates a JSON module with enhanced functionality regarding the deserialization of <i>TheTVDB.com</i> API JSON\n     * responses. This includes the creation of a new API response deserializer for the given DTO type which also\n     * supports the usage of Java {@code Optional} data types. Unknown properties within the JSON's {@code data} node\n     * will be ignored by default.\n     *\n     * @param dataType DTO type to which the content of the JSON's {@code data} node should be parsed to\n     *\n     * @return JSON module with enhanced functionality for parsing JSON responses received from the remote service\n     */\n    private static Module createAPIResponseModule(@Nonnull Type dataType) {\n        ThrowableFunctionalInterfaces.Function<JsonNode, ?, IOException> dataFunction = dataNode ->\n                new ObjectMapper().registerModules(JDK8_MODULE, DATA_MODULE)\n                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)\n                        .readValue(dataNode.toString(), new StaticTypeReference<>(dataType));\n        return new SimpleModule().addDeserializer(APIResponse.class, new APIResponseDeserializer<>(dataFunction));\n    }\n\n    /**\n     * Creates a JSON module with enhanced functionality regarding the deserialization of the JSON's {@code data} node.\n     * This includes proper handling of nullable collections and well as type resolver mappings for DTO model\n     * interfaces. The latter will automatically be resolved via the {@link APIDataModel} annotation.\n     *\n     * @param <T> the API model interface type, used for adding type resolver mappings\n     *\n     * @return JSON module with enhanced functionality for parsing the actual response DTO models\n     */\n    @SuppressWarnings(\"unchecked\")  // dto implements dtoInterface\n    private static <T> SimpleModule createDataModule() {\n        // Add Interface <-> Implementation mappings to the module. The object mapper will use these mappings to determine the\n        // proper builder to be used to create new instances of a specific interface (via @JsonDeserialize annotation).\n        SimpleAbstractTypeResolver dtoTypeResolver = new SimpleAbstractTypeResolver()\n                .addMapping(Translated.class, EntityTranslation.class); // Use EntityTranslation as default implementation\n        ClassFilter.only().classes().annotatedWith(JsonDeserialize.class)\n                .from(ClassIndex.getAnnotated(APIDataModel.class)).forEach(dto ->\n                        Arrays.stream(dto.getInterfaces()).forEach(dtoInterface ->\n                                dtoTypeResolver.addMapping((Class<T>)dtoInterface, (Class<? extends T>)dto)));\n\n        SimpleModule dataModule = new SimpleModule();\n        dataModule.setDeserializerModifier(new CollectionDeserializerModifier()).setAbstractTypes(dtoTypeResolver);\n        return dataModule;\n    }\n}", "item_id": 0, "repo": "m0nk3y2k4/thetvdb-java-api", "file": "src/main/java/com/github/m0nk3y2k4/thetvdb/internal/util/json/APIJsonMapper.java", "last_update_at": "2022-02-14T19:33:01+00:00", "question_id": "5b87507066ab7e7c25aba54b78a5daed9a364cb4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class APIJsonMapper {\n    /** Module used to extend the object mappers functionality in terms of mapping the APIs data model interfaces */\n    private static final SimpleModule DATA_MODULE = createDataModule();\n    /** Module used to extend the object mappers functionality in terms of mapping JDK8 Optionals */\n    private static final Module JDK8_MODULE = new Jdk8Module();\n    private APIJsonMapper() {}      // Private constructor. Only static methods\n    /**\n     * Maps some <i>TheTVDB.com</i> API response JSON into it's Java model representation.\n     *\n     * @param json          The full JSON as returned by the remote service\n     * @param typeReference Type reference representing the Java model structure to which the JSON should be mapped to\n     * @param <T>           The DTO type to which the JSON's {@code data} node should be mapped to\n     *\n     * @return Extended API response containing the requested data parsed from the given JSON as well as additional\n     *         status information.\n     *\n     * @throws APIException If an IO error occurred during the deserialization of the given JSON object\n     */\n    public static <T> APIResponse<T> readValue(@Nonnull JsonNode json,\n            @Nonnull TypeReference<APIResponse<T>> typeReference) throws APIException {\n        try {\n            return new ObjectMapper()\n                    .registerModule(createAPIResponseModule(((ParameterizedType)typeReference.getType())\n                            .getActualTypeArguments()[0]))\n                    .readValue(json.toString(), typeReference);\n        } catch (JsonProcessingException | IllegalArgumentException ex) {\n            throw new APIException(String.format(API_JSON_PARSE_ERROR, ex.getMessage()), ex);\n        }\n    }\n    /**\n     * Creates a JSON module with enhanced functionality regarding the deserialization of <i>TheTVDB.com</i> API JSON\n     * responses. This includes the creation of a new API response deserializer for the given DTO type which also\n     * supports the usage of Java {@code Optional} data types. Unknown properties within the JSON's {@code data} node\n     * will be ignored by default.\n     *\n     * @param dataType DTO type to which the content of the JSON's {@code data} node should be parsed to\n     *\n     * @return JSON module with enhanced functionality for parsing JSON responses received from the remote service\n     */\n    private static Module createAPIResponseModule(@Nonnull Type dataType) {\n        ThrowableFunctionalInterfaces.Function<JsonNode, ?, IOException> dataFunction = dataNode ->\n                new ObjectMapper().registerModules(JDK8_MODULE, DATA_MODULE)\n                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)\n                        .readValue(dataNode.toString(), new StaticTypeReference<>(dataType));\n        return new SimpleModule().addDeserializer(APIResponse.class, new APIResponseDeserializer<>(dataFunction));\n    }\n    /**\n     * Creates a JSON module with enhanced functionality regarding the deserialization of the JSON's {@code data} node.\n     * This includes proper handling of nullable collections and well as type resolver mappings for DTO model\n     * interfaces. The latter will automatically be resolved via the {@link APIDataModel} annotation.\n     *\n     * @param <T> the API model interface type, used for adding type resolver mappings\n     *\n     * @return JSON module with enhanced functionality for parsing the actual response DTO models\n     */\n    @SuppressWarnings(\"unchecked\")  // dto implements dtoInterface\n    private static <T> SimpleModule createDataModule() {\n        // Add Interface <-> Implementation mappings to the module. The object mapper will use these mappings to determine the\n        // proper builder to be used to create new instances of a specific interface (via @JsonDeserialize annotation).\n        SimpleAbstractTypeResolver dtoTypeResolver = new SimpleAbstractTypeResolver()\n                .addMapping(Translated.class, EntityTranslation.class); // Use EntityTranslation as default implementation\n        ClassFilter.only().classes().annotatedWith(JsonDeserialize.class)\n                .from(ClassIndex.getAnnotated(APIDataModel.class)).forEach(dto ->\n                        Arrays.stream(dto.getInterfaces()).forEach(dtoInterface ->\n                                dtoTypeResolver.addMapping((Class<T>)dtoInterface, (Class<? extends T>)dto)));\n        SimpleModule dataModule = new SimpleModule();\n        dataModule.setDeserializerModifier(new CollectionDeserializerModifier()).setAbstractTypes(dtoTypeResolver);\n        return dataModule;\n    }\n"]], "pred": {"ppl": 3.220701217651367, "ppl_lower": 3.738326072692871, "ppl/lowercase_ppl": -1.1274272792344096, "ppl/zlib": 0.000711867988621386, "Min_5.0% Prob": 7.753098151263068, "Min_10.0% Prob": 6.180532738274219, "Min_20.0% Prob": 4.583011957944608, "Min_30.0% Prob": 3.578210876658072, "Min_40.0% Prob": 2.8442801332561194, "Min_50.0% Prob": 2.321066535324033, "Min_60.0% Prob": 1.947201704882924}}
{"hexsha": "5ef3646e714e5b80e01d25da946c545352922f83", "ext": "java", "lang": "Java", "content": "public class Engine implements EventProcessor, GameManager {\n\n    // Game States\n    public final static int TITLE = 0;\n    public final static int PLAY = 1;\n    public final static int OVER = 2;\n    //public final static int DEMO = 3;\n    //public final static int PAUSE = 4;\n    public final static int WIN = 5;\n    //public final static int MENU = 6;\n    public final static int HOF = 7;\n    public final static int MENU = 8;\n\n    int state;\n    Player player;\n    GameMIDlet midlet;\n\n    /** If != \"\" draw text in the middle of screen */\n    String centerText = \"\";\n\n    private int level;\n    private int calibration;\n    private boolean level_started;\n    private boolean done;\n    private boolean autofire = false;\n\n    //private int numLevels;\n\n    Screen screen;\n    EventHandler eh;\n    private Sound sound;\n\n    Hashtable enemies;\n    Hashtable playerBullets;\n    Hashtable background;\n    private Hashtable foreground;\n    private static final String levelFile = \"/level.evt\";\n\n    public Engine(GameMIDlet midlet) throws Exception {\n        int n;\n        long then;\n\n        this.midlet = midlet;\n        screen = new Screen(this);\n\n        reset();\n\n        state = TITLE;\n\n        then = System.currentTimeMillis();\n        n = 0;\n\n        for (int i = 0; i < 30000; i++) {\n            n++;\n        }\n\n        if (n > 0) {\n            calibration = (int) (System.currentTimeMillis() - then);\n        }\n\n        Thread runner = new Thread(this);\n\n        runner.start();\n    }\n\n    void makeCollisions() throws Exception {\n        String key1, key2;\n        GameObject enemy, bullet;\n\n        // collisions between enemies and player bullets\n        for (Enumeration e = enemies.keys(); e.hasMoreElements();) {\n            key1 = (String) e.nextElement();\n            enemy = (GameObject) enemies.get(key1);\n\n            if (!enemy.bulletCollision)\n                continue;\n\n            for (Enumeration e2 = playerBullets.keys();\n                e2.hasMoreElements();\n                ) {\n                key2 = (String) e2.nextElement();\n                bullet = (GameObject) playerBullets.get(key2);\n\n                if (enemy.collidesWith((Sprite) bullet, true)) {\n                    enemy.energy -= bullet.damage;\n                    bullet.energy -= enemy.damage;\n\n                    if (bullet.energy <= 0) {\n                        bullet.end();\n                        playerBullets.remove(key2);\n                    }\n\n                    if (enemy.energy <= 0) {\n                        player.points += enemy.points;\n                        enemy.end();\n                        enemies.remove(key1);\n                        break;\n                    }\n                }\n            }\n        }\n\n        // collisions between enemies and player\n        if (player.isExploded) return;\n        for (Enumeration e = enemies.keys(); e.hasMoreElements();) {\n            key1 = (String) e.nextElement();\n            enemy = (GameObject) enemies.get(key1);\n\n            if (player.collidesWith((Sprite) enemy, true)) {\n                enemy.energy -= player.damage;\n                player.energy -= enemy.damage;\n\n                if(Settings.getUseVibration());\n                    gcc.DeviceControl.startVibra(100, 300L);\n\n                if (enemy.energy <= 0) {\n                    player.points += enemy.points;\n                    enemy.end();\n                    enemies.remove(key1);\n                }\n\n                if (player.energy <= 0) {\n                    player.lifes--;\n                    player.end();\n\n                    if (player.lifes < 0) {\n                        state = Engine.OVER;\n                        //player = null;\n                    } else {\n                        player.setVisible(false);\n                        player.energy = 100; //TODO FIX:player.params.energy\n                    }\n\n                    return;\n                }\n            }\n        }\n\n    }\n\n    void destroyOutOfScreen(Hashtable h, int x, int y, int x2, int y2) {\n        GameObject o;\n        String key;\n        \n        for (Enumeration e = h.keys(); e.hasMoreElements();) {\n            key = (String) e.nextElement();\n            o = (GameObject) h.get(key);\n\n            if (o.getY() < y\n                || o.getY() > y2\n                || o.getX() < x\n                || o.getX() > x2) {\n                h.remove(key);\n            }\n        }\n    }\n\n    void destroyEndedBackground() {\n        GameObject o;\n        String key;\n\n        for (Enumeration e = background.keys(); e.hasMoreElements();) {\n            key = (String) e.nextElement();\n            o = (GameObject) background.get(key);\n\n            if (o.getFrame() == o.getFrameSequenceLength() - 1\n                && o.loop == 0) {\n                background.remove(key);\n            }\n        }\n    }\n\n    private void reset() throws Exception {\n        level = 0;\n\n        startLevel();\n    }\n\n    private DataInputStream getLevel(String level) throws Exception {\n        DataInputStream dis = null;\n\n        InputStream is = getClass().getResourceAsStream(level);\n\n        if (is == null) {\n            throw new Exception(\"ERROR: loading level file \" + level);\n        }\n\n        dis = new DataInputStream(is);\n\n        return dis;\n    }\n\n    private void restartLevel() throws Exception {\n        synchronized (this) {\n            level_started = true;\n        }\n\n        //screen.clearKeys();\n\n        try {\n            eh = new EventHandler(getLevel(levelFile), this);\n        } catch (IOException e) {\n            throw new Exception(\"ERROR: loading level file \" + levelFile);\n        }\n\n        setScrollSpeed(20);\n        Timing.reset();\n\n        enemies = new Hashtable();\n        playerBullets = new Hashtable();\n        background = new Hashtable();\n        foreground = new Hashtable();\n        sound = new Sound();\n        player = null;\n\n        done = false;\n        //autofire = false;\n    }\n\n    private void startLevel() throws Exception {\n        restartLevel();\n    }\n\n/*\n    private void nextLevel() throws Exception {\n        level++;\n\n        startLevel();\n    }\n*/\n    public void setHof() {\n        state = HOF;\n    }\n    \n    void setMenu(boolean isGameOver) {        \n        if (isGameOver) {\n              screen.menu.deleteContinue();\n          } else {\n              //gameManager.pause();\n              screen.menu.selectContinue();\n          }\n          \n        state = MENU;\n    }\n    \n    GraphicsMenu getMenu() {\n        return screen.menu;\n    }\n    \n    public void toggleAutofire() {       \n        if (autofire) autofire = false;\n        else autofire = true;     \n    }\n\n    public synchronized boolean levelStarted() {\n        boolean x = level_started;\n\n        level_started = false;\n\n        return x;\n    }\n\n    public synchronized void start() {\n        try {\n            reset();\n        } catch (Exception e) {\n            midlet.showErrorMsg(e.getMessage());\n        }\n\n        state = PLAY;\n    }\n\n    public synchronized void stop() {\n        done = true;\n    }\n\n    public void pause() {\n        Timing.setPause(true);\n    }\n\n    public void resume() {\n        state = PLAY;\n        Timing.setPause(false);\n\n        // ugly fix, breaks midp2.0 compatibility\n        //screen.clearKeys();\n    }\n\n    public Canvas getCanvas() {\n        return screen;\n    }\n\n    public void run() {\n        long then;\n        int keyStates, delta;\n\n        then = System.currentTimeMillis();\n\n        while (!done) {\n            try {\n                if (state == PLAY) {\n                    // 1.- process new events\n                    eh.processEvents();\n\n                    // 2.- destroy all objects that are out of the limits\n                    destroyOutOfScreen(\n                        playerBullets,\n                        -50,\n                        -50,\n                        Screen.width + 50,\n                        Screen.height + 50);\n\n                    destroyOutOfScreen(\n                        enemies,\n                        -200,\n                        -200,\n                        Screen.width + 200,\n                        Screen.height + 200);\n\n                    // 4.- collision detection\n                    makeCollisions();\n\n                    // 6.- movement and fire keys\n                    keyStates = screen.getKeyStates();\n                    KeyboardPath.setKeys(keyStates);\n                    if ((autofire || (keyStates & GameCanvas.FIRE_PRESSED) != 0)\n                        && player != null\n                        && player.isVisible())\n                        player.fire();\n\n                }\n\n                screen.drawFrame();\n\n                if (state == PLAY)\n                    destroyEndedBackground();\n\n                delta = (int) (System.currentTimeMillis() - then);\n\n                if (delta < 30 && calibration < 100) {\n                    try {\n                        Thread.sleep(30 - delta);\n                    } catch (InterruptedException e) {\n                    }\n                }\n\n                then = System.currentTimeMillis();\n            } catch (Exception e) {\n                String msg = e.getMessage();\n                if(msg == null) msg = e.toString();\n                e.printStackTrace();\n                state = TITLE;\n                midlet.showErrorMsg(msg);\n            }\n        }\n    }\n\n    public GameObject searchGameObject(String name) {\n        GameObject o;\n\n        o = (GameObject) enemies.get(name);\n        if (o != null)\n            return o;\n\n        o = (GameObject) playerBullets.get(name);\n        if (o != null)\n            return o;\n\n        if (name.equals(\"player\"))\n            return (GameObject) player;\n\n        // TODO  searching in background and foreground\n\n        return null;\n    }\n    \n    public String searchGameObjectKey(GameObject o) {\n        String key;\n        \n        for (Enumeration e = enemies.keys(); e.hasMoreElements();) {\n                    key = (String) e.nextElement();\n                    if((GameObject) enemies.get(key) == o) return key;\n        }\n        \n        return null;\n    }\n\n    public void destroyGameObject(String name, Object creator) throws Exception {\n        GameObject o;\n        \n        if(name.equals(\"*\")) name = searchGameObjectKey((GameObject)creator);\n\n        o = (GameObject) enemies.get(name);\n\n        if (o != null) {\n            o.end();\n            enemies.remove(name);\n        }\n\n        // TODO searching in playerBullets, background and foreground\n    }\n\n    void setScrollSpeed(int s) {\n        screen.starfield.setSpeed(s);\n        Path.setScrollSpeed(s);\n    }\n\n    public void processEvent(Event e, Object creator) throws Exception {\n        switch (e.type) {\n            case Event.ENEMY :\n                //System.out.println(\"ENEMY: \" + e.name);\n                enemies.put(\n                    e.name,\n                    GameObject.gameObjectFactory(\n                        e,\n                        this,\n                        (GameObject) creator));\n                break;\n            case Event.PLAYER :\n                //System.out.println(\"PLAYER: \" + e.name);\n                player = Player.playerFactory(e, this, (GameObject) creator);\n                player.points = 0;\n                TargetPlayerPath.setPlayer((GameObject) player);\n                break;\n            case Event.PLAYERBULLET :\n                //System.out.println(\"PLAYERBULLET: \" + e.name);\n                playerBullets.put(\n                    e.name,\n                    GameObject.gameObjectFactory(\n                        e,\n                        this,\n                        (GameObject) creator));\n                break;\n            case Event.BACKGROUND :\n                //System.out.println(\"BACKGROUND: \" + e.name);\n                background.put(\n                    e.name,\n                    GameObject.gameObjectFactory(\n                        e,\n                        this,\n                        (GameObject) creator));\n                break;\n\n            case Event.END :\n                System.out.println(\"END: \" + e.name);\n                state = WIN;\n                break;\n\n            case Event.LOAD :\n                System.out.println(\"Loading: \" + e.name);\n                eh.load(getLevel(e.name));\n                break;\n\n            case Event.SPEED :\n                GameObject o =\n                    searchGameObject(((ObjectPropParams) e.params).object);\n                if (o != null)\n                    o.path.params.speed += ((ObjectPropParams) e.params).value;\n                break;\n                \n            case Event.LIFE :\n                player.lifes += ((ObjectPropParams) e.params).value;\n                break;\n               \n            case Event.ENERGY :\n                GameObject o2 =\n                    searchGameObject(((ObjectPropParams) e.params).object);\n                if (o2 != null) {\n                    o2.energy += ((ObjectPropParams) e.params).value;\n                    if (o2.energy <= 0) {\n                        o2.end();\n                        enemies.remove(((ObjectPropParams) e.params).object);\n                    }\n\n                    // More energy that 100 not allow\n                    if(o2.energy > 100) o2.energy = 100;\n                }\n                break;\n\n            case Event.SOUND :\n                //System.out.println(\"Playing: \" + e.name);\n                sound.playSound(e.name);\n                break;\n\n            case Event.DESTROY :\n                System.out.println(\n                    \"Destroying: \" + ((ObjectPropParams) e.params).object);\n                destroyGameObject(((ObjectPropParams) e.params).object, creator);\n                break;\n\n            case Event.TEXT:\n                centerText = ResourceBundle.getString(\"i18n.GameTexts\", e.name);\n                break;\n\n            case Event.FIRE:\n                GameObject obj =\n                    searchGameObject(((ChangeEventParams) e.params).object);\n                if (obj != null)\n                    obj.fireEvent = ((ChangeEventParams) e.params).event;\n                break;\n        }\n    }\n}", "item_id": 0, "repo": "bladecoder/ustarfield", "file": "src/starfield/Engine.java", "last_update_at": "2022-03-14T18:57:08+00:00", "question_id": "5ef3646e714e5b80e01d25da946c545352922f83_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Engine implements EventProcessor, GameManager {\n    // Game States\n    public final static int TITLE = 0;\n    public final static int PLAY = 1;\n    public final static int OVER = 2;\n    //public final static int DEMO = 3;\n    //public final static int PAUSE = 4;\n    public final static int WIN = 5;\n    //public final static int MENU = 6;\n    public final static int HOF = 7;\n    public final static int MENU = 8;\n    int state;\n    Player player;\n    GameMIDlet midlet;\n    /** If != \"\" draw text in the middle of screen */\n    String centerText = \"\";\n    private int level;\n    private int calibration;\n    private boolean level_started;\n    private boolean done;\n    private boolean autofire = false;\n    //private int numLevels;\n    Screen screen;\n    EventHandler eh;\n    private Sound sound;\n    Hashtable enemies;\n    Hashtable playerBullets;\n    Hashtable background;\n    private Hashtable foreground;\n    private static final String levelFile = \"/level.evt\";\n    public Engine(GameMIDlet midlet) throws Exception {\n        int n;\n        long then;\n        this.midlet = midlet;\n        screen = new Screen(this);\n        reset();\n        state = TITLE;\n        then = System.currentTimeMillis();\n        n = 0;\n        for (int i = 0; i < 30000; i++) {\n            n++;\n        }\n        if (n > 0) {\n            calibration = (int) (System.currentTimeMillis() - then);\n        }\n        Thread runner = new Thread(this);\n        runner.start();\n    }\n    void makeCollisions() throws Exception {\n        String key1, key2;\n        GameObject enemy, bullet;\n        // collisions between enemies and player bullets\n        for (Enumeration e = enemies.keys(); e.hasMoreElements();) {\n            key1 = (String) e.nextElement();\n            enemy = (GameObject) enemies.get(key1);\n            if (!enemy.bulletCollision)\n                continue;\n            for (Enumeration e2 = playerBullets.keys();\n                e2.hasMoreElements();\n                ) {\n                key2 = (String) e2.nextElement();\n                bullet = (GameObject) playerBullets.get(key2);\n                if (enemy.collidesWith((Sprite) bullet, true)) {\n                    enemy.energy -= bullet.damage;\n                    bullet.energy -= enemy.damage;\n                    if (bullet.energy <= 0) {\n                        bullet.end();\n                        playerBullets.remove(key2);\n                    }\n                    if (enemy.energy <= 0) {\n                        player.points += enemy.points;\n                        enemy.end();\n                        enemies.remove(key1);\n                        break;\n                    }\n                }\n            }\n        }\n        // collisions between enemies and player\n        if (player.isExploded) return;\n        for (Enumeration e = enemies.keys(); e.hasMoreElements();) {\n            key1 = (String) e.nextElement();\n            enemy = (GameObject) enemies.get(key1);\n            if (player.collidesWith((Sprite) enemy, true)) {\n                enemy.energy -= player.damage;\n                player.energy -= enemy.damage;\n                if(Settings.getUseVibration());\n                    gcc.DeviceControl.startVibra(100, 300L);\n                if (enemy.energy <= 0) {\n                    player.points += enemy.points;\n                    enemy.end();\n                    enemies.remove(key1);\n                }\n                if (player.energy <= 0) {\n                    player.lifes--;\n                    player.end();\n                    if (player.lifes < 0) {\n                        state = Engine.OVER;\n                        //player = null;\n                    } else {\n                        player.setVisible(false);\n                        player.energy = 100; //TODO FIX:player.params.energy\n                    }\n                    return;\n                }\n            }\n        }\n    }\n    void destroyOutOfScreen(Hashtable h, int x, int y, int x2, int y2) {\n        GameObject o;\n        String key;\n        for (Enumeration e = h.keys(); e.hasMoreElements();) {\n            key = (String) e.nextElement();\n            o = (GameObject) h.get(key);\n            if (o.getY() < y\n                || o.getY() > y2\n                || o.getX() < x\n                || o.getX() > x2) {\n                h.remove(key);\n            }\n        }\n    }\n    void destroyEndedBackground() {\n        GameObject o;\n        String key;\n        for (Enumeration e = background.keys(); e.hasMoreElements();) {\n            key = (String) e.nextElement();\n            o = (GameObject) background.get(key);\n            if (o.getFrame() == o.getFrameSequenceLength() - 1\n                && o.loop == 0) {\n                background.remove(key);\n            }\n        }\n    }\n    private void reset() throws Exception {\n        level = 0;\n        startLevel();\n    }\n    private DataInputStream getLevel(String level) throws Exception {\n        DataInputStream dis = null;\n        InputStream is = getClass().getResourceAsStream(level);\n        if (is == null) {\n            throw new Exception(\"ERROR: loading level file \" + level);\n        }\n        dis = new DataInputStream(is);\n        return dis;\n    }\n    private void restartLevel() throws Exception {\n        synchronized (this) {\n            level_started = true;\n        }\n        //screen.clearKeys();\n        try {\n            eh = new EventHandler(getLevel(levelFile), this);\n        } catch (IOException e) {\n            throw new Exception(\"ERROR: loading level file \" + levelFile);\n        }\n        setScrollSpeed(20);\n        Timing.reset();\n        enemies = new Hashtable();\n        playerBullets = new Hashtable();\n        background = new Hashtable();\n        foreground = new Hashtable();\n        sound = new Sound();\n        player = null;\n        done = false;\n        //autofire = false;\n    }\n    private void startLevel() throws Exception {\n        restartLevel();\n    }\n/*\n    private void nextLevel() throws Exception {\n        level++;\n        startLevel();\n    }\n*/\n    public void setHof() {\n        state = HOF;\n    }\n    void setMenu(boolean isGameOver) {        \n        if (isGameOver) {\n              screen.menu.deleteContinue();\n          } else {\n              //gameManager.pause();\n              screen.menu.selectContinue();\n          }\n        state = MENU;\n    }\n    GraphicsMenu getMenu() {\n        return screen.menu;\n    }\n    public void toggleAutofire() {       \n        if (autofire) autofire = false;\n        else autofire = true;     \n    }\n    public synchronized boolean levelStarted() {\n        boolean x = level_started;\n        level_started = false;\n        return x;\n    }\n    public synchronized void start() {\n        try {\n            reset();\n        } catch (Exception e) {\n            midlet.showErrorMsg(e.getMessage());\n        }\n        state = PLAY;\n    }\n    public synchronized void stop() {\n        done = true;\n    }\n    public void pause() {\n        Timing.setPause(true);\n    }\n    public void resume() {\n        state = PLAY;\n        Timing.setPause(false);\n        // ugly fix, breaks midp2.0 compatibility\n        //screen.clearKeys();\n    }\n    public Canvas getCanvas() {\n        return screen;\n    }\n    public void run() {\n        long then;\n        int keyStates, delta;\n        then = System.currentTimeMillis();\n        while (!done) {\n            try {\n                if (state == PLAY) {\n                    // 1.- process new events\n                    eh.processEvents();\n                    // 2.- destroy all objects that are out of the limits\n                    destroyOutOfScreen(\n                        playerBullets,\n                        -50,\n                        -50,\n                        Screen.width + 50,\n                        Screen.height + 50);\n                    destroyOutOfScreen(\n                        enemies,\n                        -200,\n                        -200,\n                        Screen.width + 200,\n                        Screen.height + 200);\n                    // 4.- collision detection\n                    makeCollisions();\n                    // 6.- movement and fire keys\n                    keyStates = screen.getKeyStates();\n                    KeyboardPath.setKeys(keyStates);\n                    if ((autofire || (keyStates & GameCanvas.FIRE_PRESSED) != 0)\n                        && player != null\n                        && player.isVisible())\n                        player.fire();\n                }\n                screen.drawFrame();\n                if (state == PLAY)\n                    destroyEndedBackground();\n                delta = (int) (System.currentTimeMillis() - then);\n                if (delta < 30 && calibration < 100) {\n                    try {\n                        Thread.sleep(30 - delta);\n                    } catch (InterruptedException e) {\n                    }\n                }\n                then = System.currentTimeMillis();\n            } catch (Exception e) {\n                String msg = e.getMessage();\n                if(msg == null) msg = e.toString();\n                e.printStackTrace();\n                state = TITLE;\n                midlet.showErrorMsg(msg);\n            }\n        }\n    }\n    public GameObject searchGameObject(String name) {\n        GameObject o;\n        o = (GameObject) enemies.get(name);\n        if (o != null)\n            return o;\n        o = (GameObject) playerBullets.get(name);\n        if (o != null)\n            return o;\n        if (name.equals(\"player\"))\n            return (GameObject) player;\n        // TODO  searching in background and foreground\n        return null;\n    }\n    public String searchGameObjectKey(GameObject o) {\n        String key;\n        for (Enumeration e = enemies.keys(); e.hasMoreElements();) {\n                    key = (String) e.nextElement();\n                    if((GameObject) enemies.get(key) == o) return key;\n        }\n        return null;\n    }\n    public void destroyGameObject(String name, Object creator) throws Exception {\n        GameObject o;\n        if(name.equals(\"*\")) name = searchGameObjectKey((GameObject)creator);\n        o = (GameObject) enemies.get(name);\n        if (o != null) {\n            o.end();\n            enemies.remove(name);\n        }\n        // TODO searching in playerBullets, background and foreground\n    }\n    void setScrollSpeed(int s) {\n        screen.starfield.setSpeed(s);\n        Path.setScrollSpeed(s);\n    }\n    public void processEvent(Event e, Object creator) throws Exception {\n        switch (e.type) {\n            case Event.ENEMY :\n                //System.out.println(\"ENEMY: \" + e.name);\n                enemies.put(\n                    e.name,\n                    GameObject.gameObjectFactory(\n                        e,\n                        this,\n                        (GameObject) creator));\n                break;\n            case Event.PLAYER :\n                //System.out.println(\"PLAYER: \" + e.name);\n                player = Player.playerFactory(e, this, (GameObject) creator);\n                player.points = 0;\n                TargetPlayerPath.setPlayer((GameObject) player);\n                break;\n            case Event.PLAYERBULLET :\n                //System.out.println(\"PLAYERBULLET: \" + e.name);\n                playerBullets.put(\n                    e.name,\n                    GameObject.gameObjectFactory(\n                        e,\n                        this,\n                        (GameObject) creator));\n                break;\n            case Event.BACKGROUND :\n                //System.out.println(\"BACKGROUND: \" + e.name);\n                background.put(\n                    e.name,\n                    GameObject.gameObjectFactory(\n                        e,\n                        this,\n                        (GameObject) creator));\n                break;\n            case Event.END :\n                System.out.println(\"END: \" + e.name);\n                state = WIN;\n                break;\n            case Event.LOAD :\n                System.out.println(\"Loading: \" + e.name);\n                eh.load(getLevel(e.name));\n                break;\n            case Event.SPEED :\n                GameObject o =\n                    searchGameObject(((ObjectPropParams) e.params).object);\n                if (o != null)\n                    o.path.params.speed += ((ObjectPropParams) e.params).value;\n                break;\n            case Event.LIFE :\n                player.lifes += ((ObjectPropParams) e.params).value;\n                break;\n            case Event.ENERGY :\n                GameObject o2 =\n                    searchGameObject(((ObjectPropParams) e.params).object);\n                if (o2 != null) {\n                    o2.energy += ((ObjectPropParams) e.params).value;\n                    if (o2.energy <= 0) {\n                        o2.end();\n                        enemies.remove(((ObjectPropParams) e.params).object);\n                    }\n                    // More energy that 100 not allow\n                    if(o2.energy > 100) o2.energy = 100;\n                }\n                break;\n            case Event.SOUND :\n                //System.out.println(\"Playing: \" + e.name);\n                sound.playSound(e.name);\n                break;\n            case Event.DESTROY :\n                System.out.println(\n                    \"Destroying: \" + ((ObjectPropParams) e.params).object);\n                destroyGameObject(((ObjectPropParams) e.params).object, creator);\n                break;\n            case Event.TEXT:\n                centerText = ResourceBundle.getString(\"i18n.GameTexts\", e.name);\n                break;\n            case Event.FIRE:\n                GameObject obj =\n                    searchGameObject(((ChangeEventParams) e.params).object);\n                if (obj != null)\n                    obj.fireEvent = ((ChangeEventParams) e.params).event;\n                break;\n        }\n    }\n"]], "pred": {"ppl": 2.3028757572174072, "ppl_lower": 2.4246273040771484, "ppl/lowercase_ppl": -1.061761813633502, "ppl/zlib": 0.0002637238922381992, "Min_5.0% Prob": 7.163247893838322, "Min_10.0% Prob": 5.494124031534382, "Min_20.0% Prob": 3.670977978145375, "Min_30.0% Prob": 2.6681585882613863, "Min_40.0% Prob": 2.059610612817965, "Min_50.0% Prob": 1.6631315607803558, "Min_60.0% Prob": 1.3901553657179362}}
{"hexsha": "887bfe128d61bb37141f71e6cdaeb3044bc6271d", "ext": "java", "lang": "Java", "content": "public class TmmLabelUI extends BaseLabelUI {\n\n  private static TmmLabelUI labelUI = null;\n\n  public static ComponentUI createUI(JComponent c) {\n    if (labelUI == null) {\n      labelUI = new TmmLabelUI();\n    }\n    return labelUI;\n  }\n\n  /**\n   * this class supports clip the string on the left/middle/right\n   */\n  protected String layoutCL(JLabel label, FontMetrics fontMetrics, String text, Icon icon, Rectangle viewR, Rectangle iconR, Rectangle textR) {\n    String stringFromSwingUtilities = SwingUtilities.layoutCompoundLabel(label, fontMetrics, text, icon, label.getVerticalAlignment(),\n        label.getHorizontalAlignment(), label.getVerticalTextPosition(), label.getHorizontalTextPosition(), viewR, iconR, textR,\n        label.getIconTextGap());\n\n    int clipPosition = getClipPosition(label);\n\n    switch (clipPosition) {\n      case SwingConstants.LEFT:\n      case SwingConstants.CENTER:\n        return reLayoutString(label, clipPosition, text, stringFromSwingUtilities);\n\n      case SwingConstants.RIGHT:\n      default:\n        return stringFromSwingUtilities;\n    }\n  }\n\n  private int getClipPosition(JLabel label) {\n    Object prop = label.getClientProperty(\"clipPosition\");\n    if (prop != null && prop instanceof Integer) {\n      if ((Integer) prop == SwingConstants.LEFT) {\n        return SwingConstants.LEFT;\n      }\n      else if ((Integer) prop == SwingConstants.RIGHT) {\n        return SwingConstants.RIGHT;\n      }\n      else if ((Integer) prop == SwingConstants.CENTER) {\n        return SwingConstants.CENTER;\n      }\n    }\n    return SwingConstants.RIGHT;\n  }\n\n  private String reLayoutString(JLabel label, int clipPosition, String originalText, String stringFromSwingUtilities) {\n    // clipping needed?\n    if (!stringFromSwingUtilities.endsWith(\"...\")) {\n      return stringFromSwingUtilities;\n    }\n\n    String dots = \"...\";\n    FontMetrics fm = label.getFontMetrics(label.getFont());\n    int targetStringWidth = fm.stringWidth(stringFromSwingUtilities);\n\n    if (clipPosition == SwingConstants.LEFT) {\n      int i = originalText.length() - stringFromSwingUtilities.length();\n      if (i < 0) {\n        return stringFromSwingUtilities;\n      }\n      for (; i < originalText.length(); i++) {\n        String substring = dots + originalText.substring(i);\n        if (fm.stringWidth(substring) <= targetStringWidth) {\n          return substring;\n        }\n      }\n    }\n    else if (clipPosition == SwingConstants.CENTER) {\n      int i = stringFromSwingUtilities.length() / 2;\n      if (i < 0) {\n        return stringFromSwingUtilities;\n      }\n      for (; i > 0; i--) {\n        String substring = originalText.substring(0, i) + dots + originalText.substring(originalText.length() - i);\n        if (fm.stringWidth(substring) <= targetStringWidth) {\n          return substring;\n        }\n      }\n    }\n\n    return stringFromSwingUtilities;\n  }\n}", "item_id": 0, "repo": "nielsmeima/tinyMediaManagerSME", "file": "src/main/java/org/tinymediamanager/ui/plaf/TmmLabelUI.java", "last_update_at": "2022-03-15T14:00:38+00:00", "question_id": "887bfe128d61bb37141f71e6cdaeb3044bc6271d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TmmLabelUI extends BaseLabelUI {\n  private static TmmLabelUI labelUI = null;\n  public static ComponentUI createUI(JComponent c) {\n    if (labelUI == null) {\n      labelUI = new TmmLabelUI();\n    }\n    return labelUI;\n  }\n  /**\n   * this class supports clip the string on the left/middle/right\n   */\n  protected String layoutCL(JLabel label, FontMetrics fontMetrics, String text, Icon icon, Rectangle viewR, Rectangle iconR, Rectangle textR) {\n    String stringFromSwingUtilities = SwingUtilities.layoutCompoundLabel(label, fontMetrics, text, icon, label.getVerticalAlignment(),\n        label.getHorizontalAlignment(), label.getVerticalTextPosition(), label.getHorizontalTextPosition(), viewR, iconR, textR,\n        label.getIconTextGap());\n    int clipPosition = getClipPosition(label);\n    switch (clipPosition) {\n      case SwingConstants.LEFT:\n      case SwingConstants.CENTER:\n        return reLayoutString(label, clipPosition, text, stringFromSwingUtilities);\n      case SwingConstants.RIGHT:\n      default:\n        return stringFromSwingUtilities;\n    }\n  }\n  private int getClipPosition(JLabel label) {\n    Object prop = label.getClientProperty(\"clipPosition\");\n    if (prop != null && prop instanceof Integer) {\n      if ((Integer) prop == SwingConstants.LEFT) {\n        return SwingConstants.LEFT;\n      }\n      else if ((Integer) prop == SwingConstants.RIGHT) {\n        return SwingConstants.RIGHT;\n      }\n      else if ((Integer) prop == SwingConstants.CENTER) {\n        return SwingConstants.CENTER;\n      }\n    }\n    return SwingConstants.RIGHT;\n  }\n  private String reLayoutString(JLabel label, int clipPosition, String originalText, String stringFromSwingUtilities) {\n    // clipping needed?\n    if (!stringFromSwingUtilities.endsWith(\"...\")) {\n      return stringFromSwingUtilities;\n    }\n    String dots = \"...\";\n    FontMetrics fm = label.getFontMetrics(label.getFont());\n    int targetStringWidth = fm.stringWidth(stringFromSwingUtilities);\n    if (clipPosition == SwingConstants.LEFT) {\n      int i = originalText.length() - stringFromSwingUtilities.length();\n      if (i < 0) {\n        return stringFromSwingUtilities;\n      }\n      for (; i < originalText.length(); i++) {\n        String substring = dots + originalText.substring(i);\n        if (fm.stringWidth(substring) <= targetStringWidth) {\n          return substring;\n        }\n      }\n    }\n    else if (clipPosition == SwingConstants.CENTER) {\n      int i = stringFromSwingUtilities.length() / 2;\n      if (i < 0) {\n        return stringFromSwingUtilities;\n      }\n      for (; i > 0; i--) {\n        String substring = originalText.substring(0, i) + dots + originalText.substring(originalText.length() - i);\n        if (fm.stringWidth(substring) <= targetStringWidth) {\n          return substring;\n        }\n      }\n    }\n    return stringFromSwingUtilities;\n  }\n"]], "pred": {"ppl": 1.5511430501937866, "ppl_lower": 1.8371264934539795, "ppl/lowercase_ppl": -1.3854523748684446, "ppl/zlib": 0.0005282696881891208, "Min_5.0% Prob": 5.259237601643517, "Min_10.0% Prob": 3.58637330361775, "Min_20.0% Prob": 2.1158911863430623, "Min_30.0% Prob": 1.4505458357522176, "Min_40.0% Prob": 1.0948563717095003, "Min_50.0% Prob": 0.8774170549481087, "Min_60.0% Prob": 0.7315291984559735}}
{"hexsha": "ff120e95581c5ddc211dfec12cd1d846bc4df051", "ext": "java", "lang": "Java", "content": "public class ConcatStrings {\n  public static void main(String[] args) {\n    String a = \"hello\";\n    String b = \"world\";\n    String c = a + \" \" + b;\n    String d = \"\" + 7 + 5.43 + -2L + 3.14f + \"\\n\";\n    System.out.println(a);\n    System.out.println(b);\n    System.out.println(c);\n    System.out.println(d);\n  }\n}", "item_id": 0, "repo": "obsidian-craft/doppio", "file": "classes/test/ConcatStrings.java", "last_update_at": "2022-03-18T04:22:27+00:00", "question_id": "ff120e95581c5ddc211dfec12cd1d846bc4df051_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ConcatStrings {\n  public static void main(String[] args) {\n    String a = \"hello\";\n    String b = \"world\";\n    String c = a + \" \" + b;\n    String d = \"\" + 7 + 5.43 + -2L + 3.14f + \"\\n\";\n    System.out.println(a);\n    System.out.println(b);\n    System.out.println(c);\n    System.out.println(d);\n  }\n"]], "pred": {"ppl": 2.2819817066192627, "ppl_lower": 2.72301983833313, "ppl/lowercase_ppl": -1.2141670186951972, "ppl/zlib": 0.004910977589446794, "Min_5.0% Prob": 6.01490044593811, "Min_10.0% Prob": 4.988452176253001, "Min_20.0% Prob": 3.5308128744363785, "Min_30.0% Prob": 2.607931226491928, "Min_40.0% Prob": 2.0360746222237744, "Min_50.0% Prob": 1.6511666683480144, "Min_60.0% Prob": 1.382789177302685}}
{"hexsha": "74419c496f81a8b580b109b02df339a4a334ed43", "ext": "java", "lang": "Java", "content": "public class Foo {\n    public static void main(String[] args) {\n        int b1 = Bar.b/*caret*/ar();\n        int b2 = Bar$.MODULE$.b/*caret*/ar();\n        Bar$.MODULE$.bar_/*caret*/$eq(3);\n        Bar2.bar_$/*caret*/eq(2);\n        Bar2.ba/*caret*/r();\n        Bar2$.MODULE$.b/*caret*/ar();\n        Bar2$.MODULE$.bar_/*caret*/$eq(4);\n    }\n}", "item_id": 0, "repo": "khamutov/intellij-scala", "file": "scala/scala-impl/testdata/rename3/settersWithoutVar2/before/tests/Foo.java", "last_update_at": "2022-03-17T12:36:38+00:00", "question_id": "74419c496f81a8b580b109b02df339a4a334ed43_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Foo {\n    public static void main(String[] args) {\n        int b1 = Bar.b/*caret*/ar();\n        int b2 = Bar$.MODULE$.b/*caret*/ar();\n        Bar$.MODULE$.bar_/*caret*/$eq(3);\n        Bar2.bar_$/*caret*/eq(2);\n        Bar2.ba/*caret*/r();\n        Bar2$.MODULE$.b/*caret*/ar();\n        Bar2$.MODULE$.bar_/*caret*/$eq(4);\n    }\n"]], "pred": {"ppl": 2.607748508453369, "ppl_lower": 3.377608060836792, "ppl/lowercase_ppl": -1.2698842235314756, "ppl/zlib": 0.006305836898729606, "Min_5.0% Prob": 8.111042976379395, "Min_10.0% Prob": 6.212976785806509, "Min_20.0% Prob": 4.106882810592651, "Min_30.0% Prob": 3.011849681051766, "Min_40.0% Prob": 2.342544786767526, "Min_50.0% Prob": 1.90008694300617, "Min_60.0% Prob": 1.608108708816694}}
{"hexsha": "a724e49954381bd673f0197b70e942ef91509410", "ext": "java", "lang": "Java", "content": "public class BarChartComponent extends JComponent {\n\n    /**\n     * The empty space between the x and the y axis of the window.\n     */\n    private static final int TOP_BOTTOM_GAP = 20;\n\n    /**\n     * The fixed gap between the description under x axis and x axis, and the description under y axis and y axis.\n     */\n    private static final int FIXED_GAP = 10;\n\n    /**\n     * Default maximum y value.\n     */\n    private static final int DEFAULT_MAX_Y_VALUE = 20;\n\n    /**\n     * Reference to {@link BarChart}.\n     */\n    private BarChart barChart;\n\n\n    /**\n     * The color of mesh.\n     */\n    private static final Color MESH_COLOR = new Color(255, 230, 179);\n\n    /**\n     * The color of bars.\n     */\n    private static final Color COLUMN_COLOR = new Color(244, 119, 71);\n\n    /**\n     * The default font.\n     */\n    private static final Font DEFAULT_FONT = new Font(\"default\", Font.BOLD, 16);\n\n\n    /**\n     * Creates an instance onf {@link BarChartComponent}.\n     *\n     * @param barChart reference to bar chart.\n     */\n    public BarChartComponent(BarChart barChart) {\n        this.barChart = barChart;\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n\n        int availableWidth = getWidth();\n        int availableHeight = getHeight();\n        Graphics2D g2d = (Graphics2D) g;\n        //default font\n        g2d.setFont(DEFAULT_FONT);\n        FontMetrics fm = g2d.getFontMetrics();\n        int stringHeight = fm.getHeight();\n\n        drawAxesDescriptionAndPath(availableWidth, availableHeight, g2d, fm);\n\n\n        List<XYValue> values = barChart.getValues();\n        g2d.setColor(Color.BLACK);\n\n        float x = (float) (TOP_BOTTOM_GAP + stringHeight / 2.0);\n        float y = availableHeight - stringHeight - TOP_BOTTOM_GAP - 2 * FIXED_GAP;\n\n        List<Integer> yValues = getYValues(barChart.getMinY(), barChart.getMaxY(), barChart.getStep());\n\n        int maxValue = DEFAULT_MAX_Y_VALUE;\n        Optional<Integer> val = yValues.stream().max(Integer::compareTo);\n        if (val.isPresent()) {\n            maxValue = val.get();\n        }\n\n\n        int widthOfYNumbers = fm.stringWidth(String.valueOf(maxValue));\n        double realStepY = (double) (availableHeight - stringHeight - TOP_BOTTOM_GAP\n                - FIXED_GAP - 10) / yValues.size();\n        double unitStepY = realStepY / barChart.getStep();\n\n        x += FIXED_GAP + widthOfYNumbers;\n        y = drawNumbersOnYAxis(availableWidth, g2d, fm, x, y, yValues, realStepY);\n\n        double maxY = y + realStepY;\n        y = availableHeight - stringHeight - TOP_BOTTOM_GAP - 2 * FIXED_GAP;\n        x += FIXED_GAP / 2.0;\n        drawYAxis(g2d, x, y);\n        drawXAxis(availableWidth, g2d, fm, x, y);\n\n        double widthOfOneColumn = (availableWidth - x - FIXED_GAP * 4) / values.size();\n        double startXOfColumns = x;\n        int minValue = 0;\n        if (barChart.getMinY() < 0) {\n            minValue = -barChart.getMinY();\n        }\n        drawColumnsAndData(g2d, fm, values, y, unitStepY, maxY, minValue, widthOfOneColumn, startXOfColumns);\n    }\n\n    @Override\n    public Dimension getPreferredSize() {\n        return super.getPreferredSize();\n    }\n\n    /**\n     * Draws columns from the given data, draws shadows and vertical part of mesh.\n     *\n     * @param g2d              the graphics used for drawing\n     * @param fm               font metrics.\n     * @param values           pairs x,y.\n     * @param y                y coordinate.\n     * @param unitStepY        the difference between two points on y axis.\n     * @param maxY             the maximum y value.\n     * @param widthOfOneColumn the width of one column.\n     * @param startXOfColumns  the start x coordinate of columns.\n     */\n    private void drawColumnsAndData(Graphics2D g2d, FontMetrics fm, List<XYValue> values,\n                                    float y, double unitStepY, double maxY, int minY, double widthOfOneColumn,\n                                    double startXOfColumns) {\n        values = values.stream().sorted(Comparator.comparingInt(XYValue::getX)).collect(Collectors.toList());\n        for (XYValue value : values) {\n\n            // draw shadow\n            g2d.setColor(Color.LIGHT_GRAY);\n            Rectangle2D shadowColumn = new Rectangle2D.Double(startXOfColumns + FIXED_GAP,\n                    y - fm.getAscent() / 2.0 + 1 - value.getY() * unitStepY - minY * unitStepY + FIXED_GAP / 2.0,\n                    widthOfOneColumn, unitStepY * value.getY() + minY * unitStepY - FIXED_GAP / 2.0);\n            g2d.fill(shadowColumn);\n\n            //draw column\n            g2d.setColor(COLUMN_COLOR);\n            Rectangle2D column = new Rectangle2D.Double(startXOfColumns + 1,\n                    y - fm.getAscent() / 2.0 + 1 - value.getY() * unitStepY - minY * unitStepY, widthOfOneColumn,\n                    unitStepY * value.getY() + minY * unitStepY);\n            g2d.fill(column);\n\n            //draw x value of column\n            g2d.setColor(Color.BLACK);\n            String val = String.valueOf(value.getX());\n            g2d.drawString(val, (float) (startXOfColumns + widthOfOneColumn / 2.0 - fm.stringWidth(val) / 2.0),\n                    y + FIXED_GAP);\n\n            //draw columns separator\n            startXOfColumns += widthOfOneColumn;\n            Line2D delimiter = new Line2D.Double(startXOfColumns, y - fm.getAscent() / 2.0 + 1,\n                    startXOfColumns, y - fm.getAscent() / 2.0 + 1 - value.getY() * unitStepY - minY * unitStepY);\n            g2d.setColor(Color.LIGHT_GRAY);\n            g2d.draw(delimiter);\n\n            //draw mesh by x axis\n            g2d.setColor(MESH_COLOR);\n            Line2D xMeshLine = new Line2D.Double(startXOfColumns,\n                    y - fm.getAscent() / 2.0 + 1 - value.getY() * unitStepY - minY*unitStepY, startXOfColumns, maxY);\n            g2d.draw(xMeshLine);\n\n            //draw end of the column\n            g2d.setColor(Color.BLACK);\n            Line2D xColumnEnd = new Line2D.Double(startXOfColumns, y - fm.getAscent() / 2.0 + 1,\n                    startXOfColumns, y - fm.getAscent() / 2.0 + 1 + FIXED_GAP / 2.0);\n            g2d.draw(xColumnEnd);\n\n        }\n    }\n\n    /**\n     * Draws x axis and arrow on the end of x axis.\n     *\n     * @param availableWidth the size of window.\n     * @param g2d            the graphics used for drawing.\n     * @param fm             font metrics.\n     * @param x              the x coordinate.\n     * @param y              the y coordinate.\n     */\n    private void drawXAxis(int availableWidth, Graphics2D g2d, FontMetrics fm, float x, float y) {\n        //draw x axis\n        Line2D xAxis = new Line2D.Double(x, y - fm.getAscent() / 2.0 + 1, availableWidth - 2 * FIXED_GAP,\n                y - fm.getAscent() / 2.0 + 1);\n        g2d.draw(xAxis);\n\n        //draw arrow on x axis\n        Path2D arrowX = new Path2D.Double();\n        double firstXX = availableWidth - 2 * FIXED_GAP;\n        double firstXY = y - fm.getAscent() / 2.0 + 1 - FIXED_GAP / 2.0;\n        arrowX.moveTo(firstXX, firstXY);\n        arrowX.lineTo(firstXX, y - fm.getAscent() / 2.0 + 1 + FIXED_GAP / 2.0);\n        arrowX.lineTo(firstXX + FIXED_GAP / 2.0, y - fm.getAscent() / 2.0 + 1);\n        arrowX.closePath();\n        g2d.fill(arrowX);\n    }\n\n    /**\n     * Draws y axis and arrow on the end of y axis.\n     *\n     * @param g2d the graphics used for drawing\n     * @param x   x coordinate.\n     * @param y   y coordinate.\n     */\n    private void drawYAxis(Graphics2D g2d, float x, float y) {\n        //draw y axis\n        Line2D yAxis = new Line2D.Double(x, FIXED_GAP / 2.0 + 1, x, y);\n        g2d.draw(yAxis);\n\n        //draw arrow on y axis\n        Path2D arrowY = new Path2D.Double();\n        double firstXYAxis = x - FIXED_GAP / 2.0;\n        double firstYYAxis = FIXED_GAP;\n        arrowY.moveTo(firstXYAxis, firstYYAxis);\n        arrowY.lineTo(x + FIXED_GAP / 2.0, firstYYAxis);\n        arrowY.lineTo(x, FIXED_GAP / 2.0 - 1);\n        arrowY.closePath();\n        g2d.fill(arrowY);\n    }\n\n    /**\n     * Draws numbers ond y axis and horizontal part of mesh.\n     *\n     * @param availableWidth the width of window\n     * @param g2d            the graphics used for drawing\n     * @param fm             font metrics.\n     * @param x              x coordinate.\n     * @param y              y coordinate.\n     * @param yValues        the values on y axis.\n     * @param realStepY      the real step on y axis.\n     * @return y coordinate of last number.\n     */\n    private float drawNumbersOnYAxis(int availableWidth, Graphics2D g2d, FontMetrics fm, float x, float y,\n                                     List<Integer> yValues, double realStepY) {\n        //draw values on y axis and mesh by y axis\n        for (Integer value : yValues) {\n            String str = String.valueOf(value);\n            Line2D lineNextToNumber = new Line2D.Double(x, y - fm.getAscent() / 2.0 + 1, x + FIXED_GAP / 2.0,\n                    y - fm.getAscent() / 2.0 + 1);\n            Line2D meshLine = new Line2D.Double(x + FIXED_GAP / 2.0, y - fm.getAscent() / 2.0 + 1,\n                    availableWidth - TOP_BOTTOM_GAP, y - fm.getAscent() / 2.0 + 1);\n            g2d.drawString(str, x - fm.stringWidth(str), y);\n            g2d.draw(lineNextToNumber);\n            g2d.setColor(MESH_COLOR);\n            g2d.draw(meshLine);\n            g2d.setColor(Color.BLACK);\n            y -= realStepY;\n        }\n        return y;\n    }\n\n    /**\n     * Draws the description under y and x axes and the path to the file from which the data was loaded.\n     *\n     * @param availableWidth  the width of window.\n     * @param availableHeight the height of window.\n     * @param g2d             the graphics used for drawing.\n     * @param fm              font metrics.\n     */\n    private void drawAxesDescriptionAndPath(int availableWidth, int availableHeight, Graphics2D g2d, FontMetrics fm) {\n        //draw the description under y axis\n        AffineTransform defaultAt = g2d.getTransform();\n        AffineTransform transform = new AffineTransform();\n        transform.rotate(-Math.PI / 2);\n        g2d.setTransform(transform);\n\n        String descriptionY = barChart.getDescriptionY();\n        int stringWidthY = fm.stringWidth(descriptionY);\n        g2d.drawString(descriptionY, (float) (-availableHeight / 2.0 - stringWidthY / 2.0), TOP_BOTTOM_GAP);\n\n        //draw the description under x axis and path to the file\n        g2d.setTransform(defaultAt);\n\n        String descriptionX = barChart.getDescriptionX();\n        int stringWidthX = fm.stringWidth(descriptionX);\n        g2d.drawString(descriptionX, (float) (availableWidth / 2.0 - stringWidthX / 2.0),\n                (float) availableHeight - TOP_BOTTOM_GAP);\n    }\n\n\n    /**\n     * Generates values on y axis.\n     *\n     * @param minY the minimum y value.\n     * @param maxY the maximum y value.\n     * @param step the difference between two points on y axis.\n     * @return values on y axis that will be marked on the graph.\n     */\n    private List<Integer> getYValues(int minY, int maxY, int step) {\n        List<Integer> list = new ArrayList<>();\n        for (int y = minY; y <= maxY; y += step) {\n            list.add(y);\n        }\n        return list;\n    }\n}", "item_id": 0, "repo": "tbozuric/java-course", "file": "HW10/src/main/java/hr/fer/zemris/java/gui/charts/BarChartComponent.java", "last_update_at": "2022-01-04T16:34:55+00:00", "question_id": "a724e49954381bd673f0197b70e942ef91509410_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BarChartComponent extends JComponent {\n    /**\n     * The empty space between the x and the y axis of the window.\n     */\n    private static final int TOP_BOTTOM_GAP = 20;\n    /**\n     * The fixed gap between the description under x axis and x axis, and the description under y axis and y axis.\n     */\n    private static final int FIXED_GAP = 10;\n    /**\n     * Default maximum y value.\n     */\n    private static final int DEFAULT_MAX_Y_VALUE = 20;\n    /**\n     * Reference to {@link BarChart}.\n     */\n    private BarChart barChart;\n    /**\n     * The color of mesh.\n     */\n    private static final Color MESH_COLOR = new Color(255, 230, 179);\n    /**\n     * The color of bars.\n     */\n    private static final Color COLUMN_COLOR = new Color(244, 119, 71);\n    /**\n     * The default font.\n     */\n    private static final Font DEFAULT_FONT = new Font(\"default\", Font.BOLD, 16);\n    /**\n     * Creates an instance onf {@link BarChartComponent}.\n     *\n     * @param barChart reference to bar chart.\n     */\n    public BarChartComponent(BarChart barChart) {\n        this.barChart = barChart;\n    }\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        int availableWidth = getWidth();\n        int availableHeight = getHeight();\n        Graphics2D g2d = (Graphics2D) g;\n        //default font\n        g2d.setFont(DEFAULT_FONT);\n        FontMetrics fm = g2d.getFontMetrics();\n        int stringHeight = fm.getHeight();\n        drawAxesDescriptionAndPath(availableWidth, availableHeight, g2d, fm);\n        List<XYValue> values = barChart.getValues();\n        g2d.setColor(Color.BLACK);\n        float x = (float) (TOP_BOTTOM_GAP + stringHeight / 2.0);\n        float y = availableHeight - stringHeight - TOP_BOTTOM_GAP - 2 * FIXED_GAP;\n        List<Integer> yValues = getYValues(barChart.getMinY(), barChart.getMaxY(), barChart.getStep());\n        int maxValue = DEFAULT_MAX_Y_VALUE;\n        Optional<Integer> val = yValues.stream().max(Integer::compareTo);\n        if (val.isPresent()) {\n            maxValue = val.get();\n        }\n        int widthOfYNumbers = fm.stringWidth(String.valueOf(maxValue));\n        double realStepY = (double) (availableHeight - stringHeight - TOP_BOTTOM_GAP\n                - FIXED_GAP - 10) / yValues.size();\n        double unitStepY = realStepY / barChart.getStep();\n        x += FIXED_GAP + widthOfYNumbers;\n        y = drawNumbersOnYAxis(availableWidth, g2d, fm, x, y, yValues, realStepY);\n        double maxY = y + realStepY;\n        y = availableHeight - stringHeight - TOP_BOTTOM_GAP - 2 * FIXED_GAP;\n        x += FIXED_GAP / 2.0;\n        drawYAxis(g2d, x, y);\n        drawXAxis(availableWidth, g2d, fm, x, y);\n        double widthOfOneColumn = (availableWidth - x - FIXED_GAP * 4) / values.size();\n        double startXOfColumns = x;\n        int minValue = 0;\n        if (barChart.getMinY() < 0) {\n            minValue = -barChart.getMinY();\n        }\n        drawColumnsAndData(g2d, fm, values, y, unitStepY, maxY, minValue, widthOfOneColumn, startXOfColumns);\n    }\n    @Override\n    public Dimension getPreferredSize() {\n        return super.getPreferredSize();\n    }\n    /**\n     * Draws columns from the given data, draws shadows and vertical part of mesh.\n     *\n     * @param g2d              the graphics used for drawing\n     * @param fm               font metrics.\n     * @param values           pairs x,y.\n     * @param y                y coordinate.\n     * @param unitStepY        the difference between two points on y axis.\n     * @param maxY             the maximum y value.\n     * @param widthOfOneColumn the width of one column.\n     * @param startXOfColumns  the start x coordinate of columns.\n     */\n    private void drawColumnsAndData(Graphics2D g2d, FontMetrics fm, List<XYValue> values,\n                                    float y, double unitStepY, double maxY, int minY, double widthOfOneColumn,\n                                    double startXOfColumns) {\n        values = values.stream().sorted(Comparator.comparingInt(XYValue::getX)).collect(Collectors.toList());\n        for (XYValue value : values) {\n            // draw shadow\n            g2d.setColor(Color.LIGHT_GRAY);\n            Rectangle2D shadowColumn = new Rectangle2D.Double(startXOfColumns + FIXED_GAP,\n                    y - fm.getAscent() / 2.0 + 1 - value.getY() * unitStepY - minY * unitStepY + FIXED_GAP / 2.0,\n                    widthOfOneColumn, unitStepY * value.getY() + minY * unitStepY - FIXED_GAP / 2.0);\n            g2d.fill(shadowColumn);\n            //draw column\n            g2d.setColor(COLUMN_COLOR);\n            Rectangle2D column = new Rectangle2D.Double(startXOfColumns + 1,\n                    y - fm.getAscent() / 2.0 + 1 - value.getY() * unitStepY - minY * unitStepY, widthOfOneColumn,\n                    unitStepY * value.getY() + minY * unitStepY);\n            g2d.fill(column);\n            //draw x value of column\n            g2d.setColor(Color.BLACK);\n            String val = String.valueOf(value.getX());\n            g2d.drawString(val, (float) (startXOfColumns + widthOfOneColumn / 2.0 - fm.stringWidth(val) / 2.0),\n                    y + FIXED_GAP);\n            //draw columns separator\n            startXOfColumns += widthOfOneColumn;\n            Line2D delimiter = new Line2D.Double(startXOfColumns, y - fm.getAscent() / 2.0 + 1,\n                    startXOfColumns, y - fm.getAscent() / 2.0 + 1 - value.getY() * unitStepY - minY * unitStepY);\n            g2d.setColor(Color.LIGHT_GRAY);\n            g2d.draw(delimiter);\n            //draw mesh by x axis\n            g2d.setColor(MESH_COLOR);\n            Line2D xMeshLine = new Line2D.Double(startXOfColumns,\n                    y - fm.getAscent() / 2.0 + 1 - value.getY() * unitStepY - minY*unitStepY, startXOfColumns, maxY);\n            g2d.draw(xMeshLine);\n            //draw end of the column\n            g2d.setColor(Color.BLACK);\n            Line2D xColumnEnd = new Line2D.Double(startXOfColumns, y - fm.getAscent() / 2.0 + 1,\n                    startXOfColumns, y - fm.getAscent() / 2.0 + 1 + FIXED_GAP / 2.0);\n            g2d.draw(xColumnEnd);\n        }\n    }\n    /**\n     * Draws x axis and arrow on the end of x axis.\n     *\n     * @param availableWidth the size of window.\n     * @param g2d            the graphics used for drawing.\n     * @param fm             font metrics.\n     * @param x              the x coordinate.\n     * @param y              the y coordinate.\n     */\n    private void drawXAxis(int availableWidth, Graphics2D g2d, FontMetrics fm, float x, float y) {\n        //draw x axis\n        Line2D xAxis = new Line2D.Double(x, y - fm.getAscent() / 2.0 + 1, availableWidth - 2 * FIXED_GAP,\n                y - fm.getAscent() / 2.0 + 1);\n        g2d.draw(xAxis);\n        //draw arrow on x axis\n        Path2D arrowX = new Path2D.Double();\n        double firstXX = availableWidth - 2 * FIXED_GAP;\n        double firstXY = y - fm.getAscent() / 2.0 + 1 - FIXED_GAP / 2.0;\n        arrowX.moveTo(firstXX, firstXY);\n        arrowX.lineTo(firstXX, y - fm.getAscent() / 2.0 + 1 + FIXED_GAP / 2.0);\n        arrowX.lineTo(firstXX + FIXED_GAP / 2.0, y - fm.getAscent() / 2.0 + 1);\n        arrowX.closePath();\n        g2d.fill(arrowX);\n    }\n    /**\n     * Draws y axis and arrow on the end of y axis.\n     *\n     * @param g2d the graphics used for drawing\n     * @param x   x coordinate.\n     * @param y   y coordinate.\n     */\n    private void drawYAxis(Graphics2D g2d, float x, float y) {\n        //draw y axis\n        Line2D yAxis = new Line2D.Double(x, FIXED_GAP / 2.0 + 1, x, y);\n        g2d.draw(yAxis);\n        //draw arrow on y axis\n        Path2D arrowY = new Path2D.Double();\n        double firstXYAxis = x - FIXED_GAP / 2.0;\n        double firstYYAxis = FIXED_GAP;\n        arrowY.moveTo(firstXYAxis, firstYYAxis);\n        arrowY.lineTo(x + FIXED_GAP / 2.0, firstYYAxis);\n        arrowY.lineTo(x, FIXED_GAP / 2.0 - 1);\n        arrowY.closePath();\n        g2d.fill(arrowY);\n    }\n    /**\n     * Draws numbers ond y axis and horizontal part of mesh.\n     *\n     * @param availableWidth the width of window\n     * @param g2d            the graphics used for drawing\n     * @param fm             font metrics.\n     * @param x              x coordinate.\n     * @param y              y coordinate.\n     * @param yValues        the values on y axis.\n     * @param realStepY      the real step on y axis.\n     * @return y coordinate of last number.\n     */\n    private float drawNumbersOnYAxis(int availableWidth, Graphics2D g2d, FontMetrics fm, float x, float y,\n                                     List<Integer> yValues, double realStepY) {\n        //draw values on y axis and mesh by y axis\n        for (Integer value : yValues) {\n            String str = String.valueOf(value);\n            Line2D lineNextToNumber = new Line2D.Double(x, y - fm.getAscent() / 2.0 + 1, x + FIXED_GAP / 2.0,\n                    y - fm.getAscent() / 2.0 + 1);\n            Line2D meshLine = new Line2D.Double(x + FIXED_GAP / 2.0, y - fm.getAscent() / 2.0 + 1,\n                    availableWidth - TOP_BOTTOM_GAP, y - fm.getAscent() / 2.0 + 1);\n            g2d.drawString(str, x - fm.stringWidth(str), y);\n            g2d.draw(lineNextToNumber);\n            g2d.setColor(MESH_COLOR);\n            g2d.draw(meshLine);\n            g2d.setColor(Color.BLACK);\n            y -= realStepY;\n        }\n        return y;\n    }\n    /**\n     * Draws the description under y and x axes and the path to the file from which the data was loaded.\n     *\n     * @param availableWidth  the width of window.\n     * @param availableHeight the height of window.\n     * @param g2d             the graphics used for drawing.\n     * @param fm              font metrics.\n     */\n    private void drawAxesDescriptionAndPath(int availableWidth, int availableHeight, Graphics2D g2d, FontMetrics fm) {\n        //draw the description under y axis\n        AffineTransform defaultAt = g2d.getTransform();\n        AffineTransform transform = new AffineTransform();\n        transform.rotate(-Math.PI / 2);\n        g2d.setTransform(transform);\n        String descriptionY = barChart.getDescriptionY();\n        int stringWidthY = fm.stringWidth(descriptionY);\n        g2d.drawString(descriptionY, (float) (-availableHeight / 2.0 - stringWidthY / 2.0), TOP_BOTTOM_GAP);\n        //draw the description under x axis and path to the file\n        g2d.setTransform(defaultAt);\n        String descriptionX = barChart.getDescriptionX();\n        int stringWidthX = fm.stringWidth(descriptionX);\n        g2d.drawString(descriptionX, (float) (availableWidth / 2.0 - stringWidthX / 2.0),\n                (float) availableHeight - TOP_BOTTOM_GAP);\n    }\n    /**\n     * Generates values on y axis.\n     *\n     * @param minY the minimum y value.\n     * @param maxY the maximum y value.\n     * @param step the difference between two points on y axis.\n     * @return values on y axis that will be marked on the graph.\n     */\n    private List<Integer> getYValues(int minY, int maxY, int step) {\n        List<Integer> list = new ArrayList<>();\n        for (int y = minY; y <= maxY; y += step) {\n            list.add(y);\n        }\n        return list;\n    }\n"]], "pred": {"ppl": 2.1412155628204346, "ppl_lower": 2.378347635269165, "ppl/lowercase_ppl": -1.1379510345248922, "ppl/zlib": 0.00029115628595832016, "Min_5.0% Prob": 6.127114632550408, "Min_10.0% Prob": 4.6547306074815635, "Min_20.0% Prob": 3.2493792854103387, "Min_30.0% Prob": 2.4041721438075982, "Min_40.0% Prob": 1.8725272398851902, "Min_50.0% Prob": 1.5174686470216618, "Min_60.0% Prob": 1.2691617678777964}}
{"hexsha": "b5c9978897ac0d9a7a2a1ca8fb5ada9197f2a1c0", "ext": "java", "lang": "Java", "content": "public class Axis2ConfigurationContextObserverImpl extends\n        AbstractAxis2ConfigurationContextObserver {\n    private static Log log = LogFactory.getLog(Axis2ConfigurationContextObserverImpl.class);\n\n    private HumanTaskServer humanTaskServer;\n\n    public Axis2ConfigurationContextObserverImpl() {\n        humanTaskServer = HumanTaskServerHolder.getInstance().getHtServer();\n    }\n\n    public void createdConfigurationContext(ConfigurationContext configurationContext) {\n//        log.info(\"HUMANTASK createdConfigurationContext\");\n//        Integer tenantId = MultitenantUtils.getTenantId(configurationContext);\n//        AxisConfiguration axisConfig = configurationContext.getAxisConfiguration();\n//        DeploymentEngine deploymentEngine = (DeploymentEngine) axisConfig.getConfigurator();\n//\n//        HumanTaskStore taskStoreForTenant =\n//                htServer.getTaskStoreManager().createHumanTaskStoreForTenant(tenantId, axisConfig);\n//\n//        AxisHumanTaskDeployer humantaskDeployer = new AxisHumanTaskDeployer();\n//        humantaskDeployer.setHumanTaskStore(taskStoreForTenant);\n//        deploymentEngine.addDeployer(humantaskDeployer,\n//                HumanTaskConstants.HUMANTASK_REPO_DIRECTORY,\n//                HumanTaskConstants.HUMANTASK_PACKAGE_EXTENSION);\n\n    }\n\n    public void terminatingConfigurationContext(ConfigurationContext configurationContext) {\n        Integer tenantId = CarbonContext.getThreadLocalCarbonContext().getTenantId();\n        log.info(\"Unloading TenantTaskStore for tenant \" + tenantId + \".\");\n        humanTaskServer.getTaskStoreManager().unloadTenantTaskStore(tenantId);\n    }\n}", "item_id": 0, "repo": "janakamarasena/carbon-business-process", "file": "components/humantask/org.wso2.carbon.humantask/src/main/java/org/wso2/carbon/humantask/core/Axis2ConfigurationContextObserverImpl.java", "last_update_at": "2022-02-17T14:07:04+00:00", "question_id": "b5c9978897ac0d9a7a2a1ca8fb5ada9197f2a1c0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Axis2ConfigurationContextObserverImpl extends\n        AbstractAxis2ConfigurationContextObserver {\n    private static Log log = LogFactory.getLog(Axis2ConfigurationContextObserverImpl.class);\n    private HumanTaskServer humanTaskServer;\n    public Axis2ConfigurationContextObserverImpl() {\n        humanTaskServer = HumanTaskServerHolder.getInstance().getHtServer();\n    }\n    public void createdConfigurationContext(ConfigurationContext configurationContext) {\n//        log.info(\"HUMANTASK createdConfigurationContext\");\n//        Integer tenantId = MultitenantUtils.getTenantId(configurationContext);\n//        AxisConfiguration axisConfig = configurationContext.getAxisConfiguration();\n//        DeploymentEngine deploymentEngine = (DeploymentEngine) axisConfig.getConfigurator();\n//\n//        HumanTaskStore taskStoreForTenant =\n//                htServer.getTaskStoreManager().createHumanTaskStoreForTenant(tenantId, axisConfig);\n//\n//        AxisHumanTaskDeployer humantaskDeployer = new AxisHumanTaskDeployer();\n//        humantaskDeployer.setHumanTaskStore(taskStoreForTenant);\n//        deploymentEngine.addDeployer(humantaskDeployer,\n//                HumanTaskConstants.HUMANTASK_REPO_DIRECTORY,\n//                HumanTaskConstants.HUMANTASK_PACKAGE_EXTENSION);\n    }\n    public void terminatingConfigurationContext(ConfigurationContext configurationContext) {\n        Integer tenantId = CarbonContext.getThreadLocalCarbonContext().getTenantId();\n        log.info(\"Unloading TenantTaskStore for tenant \" + tenantId + \".\");\n        humanTaskServer.getTaskStoreManager().unloadTenantTaskStore(tenantId);\n    }\n"]], "pred": {"ppl": 2.027575731277466, "ppl_lower": 2.6286981105804443, "ppl/lowercase_ppl": -1.3673356558449934, "ppl/zlib": 0.0013236720193968775, "Min_5.0% Prob": 6.567914849235898, "Min_10.0% Prob": 4.798588054520743, "Min_20.0% Prob": 3.1523705566630644, "Min_30.0% Prob": 2.2707605678734817, "Min_40.0% Prob": 1.7470219800139175, "Min_50.0% Prob": 1.4118878997089166, "Min_60.0% Prob": 1.176596220096975}}
{"hexsha": "b53ab9010c6b27272b456d66e13ba741d5650cac", "ext": "java", "lang": "Java", "content": "public final class GateExpansionPulsar extends GateExpansionBuildcraft implements IGateExpansion {\n\n\tpublic static GateExpansionPulsar INSTANCE = new GateExpansionPulsar();\n\n\tprivate GateExpansionPulsar() {\n\t\tsuper(\"pulsar\");\n\t}\n\n\t@Override\n\tpublic GateExpansionController makeController(TileEntity pipeTile) {\n\t\treturn new GateExpansionControllerPulsar(pipeTile);\n\t}\n\n\tprivate class GateExpansionControllerPulsar extends GateExpansionController {\n\n\t\tprivate static final int PULSE_PERIOD = 10;\n\t\tprivate boolean isActive;\n\t\tprivate boolean singlePulse;\n\t\tprivate boolean hasPulsed;\n\t\tprivate int tick;\n\t\tprivate int count;\n\n\t\tpublic GateExpansionControllerPulsar(TileEntity pipeTile) {\n\t\t\tsuper(GateExpansionPulsar.this, pipeTile);\n\n\t\t\t// by default, initialize tick so that not all gates created at\n\t\t\t// one single moment would do the work at the same time. This\n\t\t\t// spreads a bit work load. Note, this is not a problem for\n\t\t\t// existing gates since tick is stored in NBT\n\t\t\ttick = (int) (Math.random() * PULSE_PERIOD);\n\t\t}\n\n\t\t@Override\n\t\tpublic void startResolution() {\n\t\t\tif (isActive()) {\n\t\t\t\tdisablePulse();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean resolveAction(IStatement action, int count) {\n\t\t\tif (action instanceof ActionEnergyPulsar) {\n\t\t\t\tenablePulse(count);\n\t\t\t\treturn true;\n\t\t\t} else if (action instanceof ActionSingleEnergyPulse) {\n\t\t\t\tenableSinglePulse(count);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void addActions(List<IActionInternal> list) {\n\t\t\tsuper.addActions(list);\n\t\t\tlist.add(BuildCraftTransport.actionEnergyPulser);\n\t\t\tlist.add(BuildCraftTransport.actionSingleEnergyPulse);\n\t\t}\n\n\t\t@Override\n\t\tpublic void tick(IGate gate) {\n\t\t\tif (!isActive && hasPulsed) {\n\t\t\t\thasPulsed = false;\n\t\t\t}\n\n\t\t\tif (tick++ % PULSE_PERIOD != 0) {\n\t\t\t\t// only do the treatement once every period\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!isActive) {\n\t\t\t\tgate.setPulsing(false);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (pipeTile instanceof IEnergyHandler && (!singlePulse || !hasPulsed)) {\n\t\t\t\tgate.setPulsing(true);\n\t\t\t\t((IEnergyHandler) pipeTile).receiveEnergy(ForgeDirection.UNKNOWN, Math.min(1 << (count - 1), 64) * 10,\n\t\t\t\t\t\tfalse);\n\t\t\t\thasPulsed = true;\n\t\t\t} else {\n\t\t\t\tgate.setPulsing(true);\n\t\t\t}\n\t\t}\n\n\t\tprivate void enableSinglePulse(int count) {\n\t\t\tsinglePulse = true;\n\t\t\tisActive = true;\n\t\t\tthis.count = count;\n\t\t}\n\n\t\tprivate void enablePulse(int count) {\n\t\t\tisActive = true;\n\t\t\tsinglePulse = false;\n\t\t\tthis.count = count;\n\t\t}\n\n\t\tprivate void disablePulse() {\n\t\t\tif (!isActive) {\n\t\t\t\thasPulsed = false;\n\t\t\t}\n\t\t\tisActive = false;\n\t\t\tthis.count = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isActive() {\n\t\t\treturn isActive;\n\t\t}\n\n\t\t@Override\n\t\tpublic void writeToNBT(NBTTagCompound nbt) {\n\t\t\tnbt.setBoolean(\"singlePulse\", singlePulse);\n\t\t\tnbt.setBoolean(\"isActive\", isActive);\n\t\t\tnbt.setBoolean(\"hasPulsed\", hasPulsed);\n\t\t\tnbt.setByte(\"pulseCount\", (byte) count);\n\t\t\tnbt.setInteger(\"tick\", tick);\n\t\t}\n\n\t\t@Override\n\t\tpublic void readFromNBT(NBTTagCompound nbt) {\n\t\t\tisActive = nbt.getBoolean(\"isActive\");\n\t\t\tsinglePulse = nbt.getBoolean(\"singlePulse\");\n\t\t\thasPulsed = nbt.getBoolean(\"hasPulsed\");\n\t\t\tcount = nbt.getByte(\"pulseCount\");\n\t\t\ttick = nbt.getInteger(\"tick\");\n\t\t}\n\t}\n}", "item_id": 0, "repo": "Eldrinn-Elantey/BuildCraft", "file": "src/main/java/buildcraft/transport/gates/GateExpansionPulsar.java", "last_update_at": "2022-02-07T04:40:06+00:00", "question_id": "b53ab9010c6b27272b456d66e13ba741d5650cac_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class GateExpansionPulsar extends GateExpansionBuildcraft implements IGateExpansion {\n\tpublic static GateExpansionPulsar INSTANCE = new GateExpansionPulsar();\n\tprivate GateExpansionPulsar() {\n\t\tsuper(\"pulsar\");\n\t}\n\t@Override\n\tpublic GateExpansionController makeController(TileEntity pipeTile) {\n\t\treturn new GateExpansionControllerPulsar(pipeTile);\n\t}\n\tprivate class GateExpansionControllerPulsar extends GateExpansionController {\n\t\tprivate static final int PULSE_PERIOD = 10;\n\t\tprivate boolean isActive;\n\t\tprivate boolean singlePulse;\n\t\tprivate boolean hasPulsed;\n\t\tprivate int tick;\n\t\tprivate int count;\n\t\tpublic GateExpansionControllerPulsar(TileEntity pipeTile) {\n\t\t\tsuper(GateExpansionPulsar.this, pipeTile);\n\t\t\t// by default, initialize tick so that not all gates created at\n\t\t\t// one single moment would do the work at the same time. This\n\t\t\t// spreads a bit work load. Note, this is not a problem for\n\t\t\t// existing gates since tick is stored in NBT\n\t\t\ttick = (int) (Math.random() * PULSE_PERIOD);\n\t\t}\n\t\t@Override\n\t\tpublic void startResolution() {\n\t\t\tif (isActive()) {\n\t\t\t\tdisablePulse();\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic boolean resolveAction(IStatement action, int count) {\n\t\t\tif (action instanceof ActionEnergyPulsar) {\n\t\t\t\tenablePulse(count);\n\t\t\t\treturn true;\n\t\t\t} else if (action instanceof ActionSingleEnergyPulse) {\n\t\t\t\tenableSinglePulse(count);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t@Override\n\t\tpublic void addActions(List<IActionInternal> list) {\n\t\t\tsuper.addActions(list);\n\t\t\tlist.add(BuildCraftTransport.actionEnergyPulser);\n\t\t\tlist.add(BuildCraftTransport.actionSingleEnergyPulse);\n\t\t}\n\t\t@Override\n\t\tpublic void tick(IGate gate) {\n\t\t\tif (!isActive && hasPulsed) {\n\t\t\t\thasPulsed = false;\n\t\t\t}\n\t\t\tif (tick++ % PULSE_PERIOD != 0) {\n\t\t\t\t// only do the treatement once every period\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!isActive) {\n\t\t\t\tgate.setPulsing(false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (pipeTile instanceof IEnergyHandler && (!singlePulse || !hasPulsed)) {\n\t\t\t\tgate.setPulsing(true);\n\t\t\t\t((IEnergyHandler) pipeTile).receiveEnergy(ForgeDirection.UNKNOWN, Math.min(1 << (count - 1), 64) * 10,\n\t\t\t\t\t\tfalse);\n\t\t\t\thasPulsed = true;\n\t\t\t} else {\n\t\t\t\tgate.setPulsing(true);\n\t\t\t}\n\t\t}\n\t\tprivate void enableSinglePulse(int count) {\n\t\t\tsinglePulse = true;\n\t\t\tisActive = true;\n\t\t\tthis.count = count;\n\t\t}\n\t\tprivate void enablePulse(int count) {\n\t\t\tisActive = true;\n\t\t\tsinglePulse = false;\n\t\t\tthis.count = count;\n\t\t}\n\t\tprivate void disablePulse() {\n\t\t\tif (!isActive) {\n\t\t\t\thasPulsed = false;\n\t\t\t}\n\t\t\tisActive = false;\n\t\t\tthis.count = 0;\n\t\t}\n\t\t@Override\n\t\tpublic boolean isActive() {\n\t\t\treturn isActive;\n\t\t}\n\t\t@Override\n\t\tpublic void writeToNBT(NBTTagCompound nbt) {\n\t\t\tnbt.setBoolean(\"singlePulse\", singlePulse);\n\t\t\tnbt.setBoolean(\"isActive\", isActive);\n\t\t\tnbt.setBoolean(\"hasPulsed\", hasPulsed);\n\t\t\tnbt.setByte(\"pulseCount\", (byte) count);\n\t\t\tnbt.setInteger(\"tick\", tick);\n\t\t}\n\t\t@Override\n\t\tpublic void readFromNBT(NBTTagCompound nbt) {\n\t\t\tisActive = nbt.getBoolean(\"isActive\");\n\t\t\tsinglePulse = nbt.getBoolean(\"singlePulse\");\n\t\t\thasPulsed = nbt.getBoolean(\"hasPulsed\");\n\t\t\tcount = nbt.getByte(\"pulseCount\");\n\t\t\ttick = nbt.getInteger(\"tick\");\n\t\t}\n\t}\n"]], "pred": {"ppl": 2.026549816131592, "ppl_lower": 2.2887797355651855, "ppl/lowercase_ppl": -1.1722753411075544, "ppl/zlib": 0.00067269976107976, "Min_5.0% Prob": 6.6402805459265615, "Min_10.0% Prob": 5.025655344420788, "Min_20.0% Prob": 3.244790043900995, "Min_30.0% Prob": 2.3158927088469463, "Min_40.0% Prob": 1.760763042503945, "Min_50.0% Prob": 1.413185884705845, "Min_60.0% Prob": 1.1786230926703491}}
{"hexsha": "4bad9ae31b0d00617b43b8e06cb60143072e1a03", "ext": "java", "lang": "Java", "content": "public class DragomeEntityManager\n{\n\tprotected static Map<String, Object> entities= new Hashtable<String, Object>();\n\n\tpublic static String add(Object entity)\n\t{\n\t\tString identityHashCode= getEntityId(entity);\n\t\tentities.put(identityHashCode, entity);\n\t\treturn identityHashCode;\n\t}\n\t\n\tpublic static Object remove(Object entity)\n\t{\n\t\tString identityHashCode= getEntityId(entity);\n\t\treturn entities.remove(identityHashCode);\n\t}\n\n\n\tpublic static Object get(String id)\n\t{\n\t\treturn entities.get(id);\n\t}\n\n\tpublic static String getEntityId(Object object)\n\t{\n\t\treturn System.identityHashCode(object) + \"\";\n\t}\n\n\tpublic static void clear()\n\t{\n\t\tentities.clear();\n\t}\n}", "item_id": 0, "repo": "nosix/dragome-sdk", "file": "dragome-core/src/main/java/com/dragome/helpers/DragomeEntityManager.java", "last_update_at": "2022-01-26T18:43:47+00:00", "question_id": "4bad9ae31b0d00617b43b8e06cb60143072e1a03_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DragomeEntityManager\n{\n\tprotected static Map<String, Object> entities= new Hashtable<String, Object>();\n\tpublic static String add(Object entity)\n\t{\n\t\tString identityHashCode= getEntityId(entity);\n\t\tentities.put(identityHashCode, entity);\n\t\treturn identityHashCode;\n\t}\n\t\n\tpublic static Object remove(Object entity)\n\t{\n\t\tString identityHashCode= getEntityId(entity);\n\t\treturn entities.remove(identityHashCode);\n\t}\n\tpublic static Object get(String id)\n\t{\n\t\treturn entities.get(id);\n\t}\n\tpublic static String getEntityId(Object object)\n\t{\n\t\treturn System.identityHashCode(object) + \"\";\n\t}\n\tpublic static void clear()\n\t{\n\t\tentities.clear();\n\t}\n"]], "pred": {"ppl": 1.8094053268432617, "ppl_lower": 2.1017844676971436, "ppl/lowercase_ppl": -1.2525951631482475, "ppl/zlib": 0.0023163993851109516, "Min_5.0% Prob": 6.077291870117188, "Min_10.0% Prob": 4.3191982337406705, "Min_20.0% Prob": 2.663663523537772, "Min_30.0% Prob": 1.9286633219037737, "Min_40.0% Prob": 1.477778722177304, "Min_50.0% Prob": 1.1882256325156915, "Min_60.0% Prob": 0.9917101908386463}}
{"hexsha": "59a8161407a6a4712485cbca245c5400ab930c1b", "ext": "java", "lang": "Java", "content": "public class BuddyList {\n\tpublic ArrayList<BuddyTeamInfo> m_arrBuddyTeamInfo = new ArrayList<BuddyTeamInfo>();\n\t\n\tpublic void reset() {\n\t\tm_arrBuddyTeamInfo.clear();\n\t}\n\t\n\tpublic int getBuddyTeamCount() {\n\t\treturn m_arrBuddyTeamInfo.size();\n\t}\n\t\n\tpublic BuddyTeamInfo getBuddyTeam(int nTeamIndex) {\n\t\tif (nTeamIndex >= 0 && nTeamIndex < m_arrBuddyTeamInfo.size())\n\t\t\treturn m_arrBuddyTeamInfo.get(nTeamIndex);\n\t\telse\n\t\t\treturn null;\n\t}\n\t\n\tpublic BuddyTeamInfo getBuddyTeamByIndex(int nIndex) {\n\t\tfor (int i = 0; i < m_arrBuddyTeamInfo.size(); i++)\n\t\t{\n\t\t\tBuddyTeamInfo buddyTeamInfo = m_arrBuddyTeamInfo.get(i);\n\t\t\tif (buddyTeamInfo != null && nIndex == buddyTeamInfo.m_nIndex)\n\t\t\t\treturn buddyTeamInfo;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic int getBuddyCount(int nTeamIndex) {\n\t\tBuddyTeamInfo buddyTeamInfo = getBuddyTeam(nTeamIndex);\n\t\tif (buddyTeamInfo != null)\n\t\t\treturn buddyTeamInfo.getBuddyCount();\n\t\telse\n\t\t\treturn 0;\n\t}\n\t\n\tpublic int getOnlineBuddyCount(int nTeamIndex) {\n\t\tBuddyTeamInfo buddyTeamInfo = getBuddyTeam(nTeamIndex);\n\t\tif (buddyTeamInfo != null)\n\t\t\treturn buddyTeamInfo.getOnlineBuddyCount();\n\t\telse\n\t\t\treturn 0;\n\t}\n\t\n\tpublic BuddyInfo getBuddy(int nTeamIndex, int nIndex) {\n\t\tBuddyTeamInfo buddyTeamInfo = getBuddyTeam(nTeamIndex);\n\t\tif (buddyTeamInfo != null)\n\t\t\treturn buddyTeamInfo.getBuddy(nIndex);\n\t\telse\n\t\t\treturn null;\n\t}\n\t\n\tpublic BuddyInfo getBuddy(int nQQUin) {\n\t\tfor (int i = 0; i < m_arrBuddyTeamInfo.size(); i++)\n\t\t{\n\t\t\tBuddyTeamInfo buddyTeamInfo = m_arrBuddyTeamInfo.get(i);\n\t\t\tif (buddyTeamInfo != null)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < buddyTeamInfo.m_arrBuddyInfo.size(); j++)\n\t\t\t\t{\n\t\t\t\t\tBuddyInfo buddyInfo = buddyTeamInfo.m_arrBuddyInfo.get(j);\n\t\t\t\t\tif (buddyInfo != null && buddyInfo.m_nQQUin == nQQUin)\n\t\t\t\t\t\treturn buddyInfo;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic boolean setOnlineBuddyList(OnlineBuddyListResult result) {\n\t\tif (null == result)\n\t\t\treturn false;\n\n\t\tfor (int i = 0; i < result.m_arrOnlineBuddyInfo.size(); i++)\n\t\t{\n\t\t\tOnlineBuddyInfo onlineBuddyInfo = result.m_arrOnlineBuddyInfo.get(i);\n\t\t\tif (onlineBuddyInfo != null)\n\t\t\t{\n\t\t\t\tBuddyInfo buddyInfo = getBuddy(onlineBuddyInfo.m_nUin);\n\t\t\t\tif (buddyInfo != null)\n\t\t\t\t{\n\t\t\t\t\tbuddyInfo.m_nClientType = onlineBuddyInfo.m_nClientType;\n\t\t\t\t\tbuddyInfo.m_nStatus = onlineBuddyInfo.m_nStatus;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic void sortBuddyTeam() {\n\t\tBuddyTeamInfo buddyTeamInfo1, buddyTeamInfo2;\n\t\tboolean bExchange;\n\t\tint nCount;\n\n\t\tnCount = m_arrBuddyTeamInfo.size();\n\t\tfor (int i = 0; i < nCount-1; i++)\n\t\t{\n\t\t\tbExchange = false;\n\t\t\tfor (int j = nCount-1; j > i; j--)\n\t\t\t{\n\t\t\t\tbuddyTeamInfo1 = m_arrBuddyTeamInfo.get(j-1);\n\t\t\t\tbuddyTeamInfo2 = m_arrBuddyTeamInfo.get(j);\n\t\t\t\tif (buddyTeamInfo1 != null && buddyTeamInfo2 != null)\n\t\t\t\t{\n\t\t\t\t\tif (buddyTeamInfo2.m_nSort < buddyTeamInfo1.m_nSort)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_arrBuddyTeamInfo.set(j-1, buddyTeamInfo2);\n\t\t\t\t\t\tm_arrBuddyTeamInfo.set(j, buddyTeamInfo1);\n\t\t\t\t\t\tbExchange = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!bExchange)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tpublic void sortBuddy() {\n\t\tfor (int i = 0; i < m_arrBuddyTeamInfo.size(); i++)\n\t\t{\n\t\t\tBuddyTeamInfo buddyTeamInfo = m_arrBuddyTeamInfo.get(i);\n\t\t\tif (buddyTeamInfo != null)\n\t\t\t\tbuddyTeamInfo.sort();\n\t\t}\n\t}\n\t\n\tpublic boolean addBuddyTeam(BuddyTeamInfo buddyTeamInfo) {\n\t\tif (null == buddyTeamInfo)\n\t\t\treturn false;\n\t\tm_arrBuddyTeamInfo.add(buddyTeamInfo);\n\t\treturn true;\n\t}\n}", "item_id": 0, "repo": "tanranran/MaterialQQLite", "file": "app/src/main/java/com/wyp/materialqqlite/qqclient/protocol/protocoldata/BuddyList.java", "last_update_at": "2022-02-11T16:35:51+00:00", "question_id": "59a8161407a6a4712485cbca245c5400ab930c1b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BuddyList {\n\tpublic ArrayList<BuddyTeamInfo> m_arrBuddyTeamInfo = new ArrayList<BuddyTeamInfo>();\n\t\n\tpublic void reset() {\n\t\tm_arrBuddyTeamInfo.clear();\n\t}\n\t\n\tpublic int getBuddyTeamCount() {\n\t\treturn m_arrBuddyTeamInfo.size();\n\t}\n\t\n\tpublic BuddyTeamInfo getBuddyTeam(int nTeamIndex) {\n\t\tif (nTeamIndex >= 0 && nTeamIndex < m_arrBuddyTeamInfo.size())\n\t\t\treturn m_arrBuddyTeamInfo.get(nTeamIndex);\n\t\telse\n\t\t\treturn null;\n\t}\n\t\n\tpublic BuddyTeamInfo getBuddyTeamByIndex(int nIndex) {\n\t\tfor (int i = 0; i < m_arrBuddyTeamInfo.size(); i++)\n\t\t{\n\t\t\tBuddyTeamInfo buddyTeamInfo = m_arrBuddyTeamInfo.get(i);\n\t\t\tif (buddyTeamInfo != null && nIndex == buddyTeamInfo.m_nIndex)\n\t\t\t\treturn buddyTeamInfo;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic int getBuddyCount(int nTeamIndex) {\n\t\tBuddyTeamInfo buddyTeamInfo = getBuddyTeam(nTeamIndex);\n\t\tif (buddyTeamInfo != null)\n\t\t\treturn buddyTeamInfo.getBuddyCount();\n\t\telse\n\t\t\treturn 0;\n\t}\n\t\n\tpublic int getOnlineBuddyCount(int nTeamIndex) {\n\t\tBuddyTeamInfo buddyTeamInfo = getBuddyTeam(nTeamIndex);\n\t\tif (buddyTeamInfo != null)\n\t\t\treturn buddyTeamInfo.getOnlineBuddyCount();\n\t\telse\n\t\t\treturn 0;\n\t}\n\t\n\tpublic BuddyInfo getBuddy(int nTeamIndex, int nIndex) {\n\t\tBuddyTeamInfo buddyTeamInfo = getBuddyTeam(nTeamIndex);\n\t\tif (buddyTeamInfo != null)\n\t\t\treturn buddyTeamInfo.getBuddy(nIndex);\n\t\telse\n\t\t\treturn null;\n\t}\n\t\n\tpublic BuddyInfo getBuddy(int nQQUin) {\n\t\tfor (int i = 0; i < m_arrBuddyTeamInfo.size(); i++)\n\t\t{\n\t\t\tBuddyTeamInfo buddyTeamInfo = m_arrBuddyTeamInfo.get(i);\n\t\t\tif (buddyTeamInfo != null)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < buddyTeamInfo.m_arrBuddyInfo.size(); j++)\n\t\t\t\t{\n\t\t\t\t\tBuddyInfo buddyInfo = buddyTeamInfo.m_arrBuddyInfo.get(j);\n\t\t\t\t\tif (buddyInfo != null && buddyInfo.m_nQQUin == nQQUin)\n\t\t\t\t\t\treturn buddyInfo;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic boolean setOnlineBuddyList(OnlineBuddyListResult result) {\n\t\tif (null == result)\n\t\t\treturn false;\n\t\tfor (int i = 0; i < result.m_arrOnlineBuddyInfo.size(); i++)\n\t\t{\n\t\t\tOnlineBuddyInfo onlineBuddyInfo = result.m_arrOnlineBuddyInfo.get(i);\n\t\t\tif (onlineBuddyInfo != null)\n\t\t\t{\n\t\t\t\tBuddyInfo buddyInfo = getBuddy(onlineBuddyInfo.m_nUin);\n\t\t\t\tif (buddyInfo != null)\n\t\t\t\t{\n\t\t\t\t\tbuddyInfo.m_nClientType = onlineBuddyInfo.m_nClientType;\n\t\t\t\t\tbuddyInfo.m_nStatus = onlineBuddyInfo.m_nStatus;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic void sortBuddyTeam() {\n\t\tBuddyTeamInfo buddyTeamInfo1, buddyTeamInfo2;\n\t\tboolean bExchange;\n\t\tint nCount;\n\t\tnCount = m_arrBuddyTeamInfo.size();\n\t\tfor (int i = 0; i < nCount-1; i++)\n\t\t{\n\t\t\tbExchange = false;\n\t\t\tfor (int j = nCount-1; j > i; j--)\n\t\t\t{\n\t\t\t\tbuddyTeamInfo1 = m_arrBuddyTeamInfo.get(j-1);\n\t\t\t\tbuddyTeamInfo2 = m_arrBuddyTeamInfo.get(j);\n\t\t\t\tif (buddyTeamInfo1 != null && buddyTeamInfo2 != null)\n\t\t\t\t{\n\t\t\t\t\tif (buddyTeamInfo2.m_nSort < buddyTeamInfo1.m_nSort)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_arrBuddyTeamInfo.set(j-1, buddyTeamInfo2);\n\t\t\t\t\t\tm_arrBuddyTeamInfo.set(j, buddyTeamInfo1);\n\t\t\t\t\t\tbExchange = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!bExchange)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tpublic void sortBuddy() {\n\t\tfor (int i = 0; i < m_arrBuddyTeamInfo.size(); i++)\n\t\t{\n\t\t\tBuddyTeamInfo buddyTeamInfo = m_arrBuddyTeamInfo.get(i);\n\t\t\tif (buddyTeamInfo != null)\n\t\t\t\tbuddyTeamInfo.sort();\n\t\t}\n\t}\n\t\n\tpublic boolean addBuddyTeam(BuddyTeamInfo buddyTeamInfo) {\n\t\tif (null == buddyTeamInfo)\n\t\t\treturn false;\n\t\tm_arrBuddyTeamInfo.add(buddyTeamInfo);\n\t\treturn true;\n\t}\n"]], "pred": {"ppl": 1.2387346029281616, "ppl_lower": 1.3116724491119385, "ppl/lowercase_ppl": -1.2672358533193304, "ppl/zlib": 0.0003041056492352759, "Min_5.0% Prob": 3.2555479021633373, "Min_10.0% Prob": 1.9668806727026023, "Min_20.0% Prob": 1.052174945982794, "Min_30.0% Prob": 0.7108253842414497, "Min_40.0% Prob": 0.5341400991997757, "Min_50.0% Prob": 0.42823354047659323, "Min_60.0% Prob": 0.35720020575261996}}
{"hexsha": "e31c9e0a20536d43963d88976a8713cf3571b64c", "ext": "java", "lang": "Java", "content": "public class EventDefintionParser {\r\n\t\r\n\t@SuppressWarnings(\"rawtypes\")\r\n\tpublic static EventDefinition parserEventDefinition(Element element) {\r\n\t\tString nodeName = element.getName();\r\n\t\tif (BpmnXMLConstants.ELEMENT_TERMINATEEVENTDEFINITION.equalsIgnoreCase(nodeName)) {\r\n\t\t\tTerminateEventDefinition terminateEventDefinition = new TerminateEventDefinition();\r\n\t\t\tterminateEventDefinition.setId(element.attributeValue(BpmnXMLConstants.ATTRIBUTE_ID));\r\n\t\t\treturn terminateEventDefinition;\r\n\t\t} else if (BpmnXMLConstants.ELEMENT_TIMEREVENTDEFINITION.equalsIgnoreCase(nodeName)) {\r\n\t\t\tTimerEventDefinition timerEventDefinition = new TimerEventDefinition();\r\n\t\t\ttimerEventDefinition.setId(element.attributeValue(BpmnXMLConstants.ATTRIBUTE_ID));\r\n\t\t\tElement elem = null;\r\n\t\t\tfor (Iterator iterator = element.elements().iterator(); iterator.hasNext();) {\r\n\t\t\t\telem = (Element) iterator.next();\r\n\t\t\t\tnodeName = elem.getName();\r\n\t\t\t\tif (BpmnXMLConstants.ELEMENT_TIMEDATE.equalsIgnoreCase(nodeName)) {\r\n\t\t\t\t\ttimerEventDefinition.setTimeDate(BpmnXMLUtil.parseExpression(elem));\r\n\t\t\t\t} else if (BpmnXMLConstants.ELEMENT_TIMEDURATION.equalsIgnoreCase(nodeName)) {\r\n\t\t\t\t\ttimerEventDefinition.setTimeDuration(BpmnXMLUtil.parseExpression(elem));\r\n\t\t\t\t} else if (BpmnXMLConstants.ELEMENT_TIMECYCLE.equalsIgnoreCase(nodeName)) {\r\n\t\t\t\t\ttimerEventDefinition.setTimeCycle(BpmnXMLUtil.parseExpression(elem));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn timerEventDefinition;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n}", "item_id": 0, "repo": "FoxBPM/FoxBPM", "file": "modules/foxbpm-bpmn-converter/src/main/java/org/foxbpm/bpmn/converter/parser/EventDefintionParser.java", "last_update_at": "2022-02-09T03:33:31+00:00", "question_id": "e31c9e0a20536d43963d88976a8713cf3571b64c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EventDefintionParser {\r\n\t\r\n\t@SuppressWarnings(\"rawtypes\")\r\n\tpublic static EventDefinition parserEventDefinition(Element element) {\r\n\t\tString nodeName = element.getName();\r\n\t\tif (BpmnXMLConstants.ELEMENT_TERMINATEEVENTDEFINITION.equalsIgnoreCase(nodeName)) {\r\n\t\t\tTerminateEventDefinition terminateEventDefinition = new TerminateEventDefinition();\r\n\t\t\tterminateEventDefinition.setId(element.attributeValue(BpmnXMLConstants.ATTRIBUTE_ID));\r\n\t\t\treturn terminateEventDefinition;\r\n\t\t} else if (BpmnXMLConstants.ELEMENT_TIMEREVENTDEFINITION.equalsIgnoreCase(nodeName)) {\r\n\t\t\tTimerEventDefinition timerEventDefinition = new TimerEventDefinition();\r\n\t\t\ttimerEventDefinition.setId(element.attributeValue(BpmnXMLConstants.ATTRIBUTE_ID));\r\n\t\t\tElement elem = null;\r\n\t\t\tfor (Iterator iterator = element.elements().iterator(); iterator.hasNext();) {\r\n\t\t\t\telem = (Element) iterator.next();\r\n\t\t\t\tnodeName = elem.getName();\r\n\t\t\t\tif (BpmnXMLConstants.ELEMENT_TIMEDATE.equalsIgnoreCase(nodeName)) {\r\n\t\t\t\t\ttimerEventDefinition.setTimeDate(BpmnXMLUtil.parseExpression(elem));\r\n\t\t\t\t} else if (BpmnXMLConstants.ELEMENT_TIMEDURATION.equalsIgnoreCase(nodeName)) {\r\n\t\t\t\t\ttimerEventDefinition.setTimeDuration(BpmnXMLUtil.parseExpression(elem));\r\n\t\t\t\t} else if (BpmnXMLConstants.ELEMENT_TIMECYCLE.equalsIgnoreCase(nodeName)) {\r\n\t\t\t\t\ttimerEventDefinition.setTimeCycle(BpmnXMLUtil.parseExpression(elem));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn timerEventDefinition;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n"]], "pred": {"ppl": 1.3815051317214966, "ppl_lower": 1.55186128616333, "ppl/lowercase_ppl": -1.3598111588445243, "ppl/zlib": 0.0007229834003928205, "Min_5.0% Prob": 4.867182244857152, "Min_10.0% Prob": 3.045539499570926, "Min_20.0% Prob": 1.596471805202285, "Min_30.0% Prob": 1.0764760873633725, "Min_40.0% Prob": 0.8067002569243658, "Min_50.0% Prob": 0.6473615160943125, "Min_60.0% Prob": 0.5385379172172285}}
{"hexsha": "e0edbf6b466ab1df46c252e987057131b79cde73", "ext": "java", "lang": "Java", "content": "public class EncryptedPrivateKeyInfo\n    extends ASN1Encodable\n{\n    private AlgorithmIdentifier algId;\n    private ASN1OctetString     data;\n\n    public EncryptedPrivateKeyInfo(\n        ASN1Sequence  seq)\n    {\n        Enumeration e = seq.getObjects();\n\n        algId = AlgorithmIdentifier.getInstance(e.nextElement());\n        data = (ASN1OctetString)e.nextElement();\n    }\n\n    public EncryptedPrivateKeyInfo(\n        AlgorithmIdentifier algId,\n        byte[]              encoding)\n    {\n        this.algId = algId;\n        this.data = new DEROctetString(encoding);\n    }\n\n    public static EncryptedPrivateKeyInfo getInstance(\n        Object  obj)\n    {\n        if (obj instanceof EncryptedData)\n        {\n            return (EncryptedPrivateKeyInfo)obj;\n        }\n        else if (obj instanceof ASN1Sequence)\n        { \n            return new EncryptedPrivateKeyInfo((ASN1Sequence)obj);\n        }\n\n        throw new IllegalArgumentException(\"unknown object in factory: \" + obj.getClass().getName());\n    }\n    \n    public AlgorithmIdentifier getEncryptionAlgorithm()\n    {\n        return algId;\n    }\n\n    public byte[] getEncryptedData()\n    {\n        return data.getOctets();\n    }\n\n    /**\n     * Produce an object suitable for an ASN1OutputStream.\n     * <pre>\n     * EncryptedPrivateKeyInfo ::= SEQUENCE {\n     *      encryptionAlgorithm AlgorithmIdentifier {{KeyEncryptionAlgorithms}},\n     *      encryptedData EncryptedData\n     * }\n     *\n     * EncryptedData ::= OCTET STRING\n     *\n     * KeyEncryptionAlgorithms ALGORITHM-IDENTIFIER ::= {\n     *          ... -- For local profiles\n     * }\n     * </pre>\n     */\n    public DERObject toASN1Object()\n    {\n        ASN1EncodableVector v = new ASN1EncodableVector();\n\n        v.add(algId);\n        v.add(data);\n\n        return new DERSequence(v);\n    }\n}", "item_id": 0, "repo": "hubsen1980/bitcoinj", "file": "src/com/google/bitcoin/bouncycastle/asn1/pkcs/EncryptedPrivateKeyInfo.java", "last_update_at": "2022-01-22T14:48:09+00:00", "question_id": "e0edbf6b466ab1df46c252e987057131b79cde73_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EncryptedPrivateKeyInfo\n    extends ASN1Encodable\n{\n    private AlgorithmIdentifier algId;\n    private ASN1OctetString     data;\n    public EncryptedPrivateKeyInfo(\n        ASN1Sequence  seq)\n    {\n        Enumeration e = seq.getObjects();\n        algId = AlgorithmIdentifier.getInstance(e.nextElement());\n        data = (ASN1OctetString)e.nextElement();\n    }\n    public EncryptedPrivateKeyInfo(\n        AlgorithmIdentifier algId,\n        byte[]              encoding)\n    {\n        this.algId = algId;\n        this.data = new DEROctetString(encoding);\n    }\n    public static EncryptedPrivateKeyInfo getInstance(\n        Object  obj)\n    {\n        if (obj instanceof EncryptedData)\n        {\n            return (EncryptedPrivateKeyInfo)obj;\n        }\n        else if (obj instanceof ASN1Sequence)\n        { \n            return new EncryptedPrivateKeyInfo((ASN1Sequence)obj);\n        }\n        throw new IllegalArgumentException(\"unknown object in factory: \" + obj.getClass().getName());\n    }\n    public AlgorithmIdentifier getEncryptionAlgorithm()\n    {\n        return algId;\n    }\n    public byte[] getEncryptedData()\n    {\n        return data.getOctets();\n    }\n    /**\n     * Produce an object suitable for an ASN1OutputStream.\n     * <pre>\n     * EncryptedPrivateKeyInfo ::= SEQUENCE {\n     *      encryptionAlgorithm AlgorithmIdentifier {{KeyEncryptionAlgorithms}},\n     *      encryptedData EncryptedData\n     * }\n     *\n     * EncryptedData ::= OCTET STRING\n     *\n     * KeyEncryptionAlgorithms ALGORITHM-IDENTIFIER ::= {\n     *          ... -- For local profiles\n     * }\n     * </pre>\n     */\n    public DERObject toASN1Object()\n    {\n        ASN1EncodableVector v = new ASN1EncodableVector();\n        v.add(algId);\n        v.add(data);\n        return new DERSequence(v);\n    }\n"]], "pred": {"ppl": 1.2805124521255493, "ppl_lower": 1.8170350790023804, "ppl/lowercase_ppl": -2.4152925963621716, "ppl/zlib": 0.0003763475662627748, "Min_5.0% Prob": 3.9515858934475827, "Min_10.0% Prob": 2.3340302189955344, "Min_20.0% Prob": 1.2312427344776335, "Min_30.0% Prob": 0.8240272477504951, "Min_40.0% Prob": 0.6180683245862529, "Min_50.0% Prob": 0.4943243254749563, "Min_60.0% Prob": 0.4130887450647387}}
{"hexsha": "caaaa23e4bcbae8f5db496386b22ad54f3c69403", "ext": "java", "lang": "Java", "content": "@Deprecated\npublic class SpecDependent<V> {\n\n  private static List<SpecDependent<?>> allDependents = new CopyOnWriteArrayList<>();\n\n  public static <V> SpecDependent<V> of(Supplier<V> supplier) {\n    SpecDependent<V> ret = new SpecDependent<>(supplier);\n    allDependents.add(ret);\n    return ret;\n  }\n\n  public static void resetAll() {\n    allDependents.forEach(SpecDependent::reset);\n  }\n\n  private final Supplier<V> supplier;\n  private volatile V cached = null;\n\n  private SpecDependent(Supplier<V> supplier) {\n    this.supplier = supplier;\n  }\n\n  public V get() {\n    V cachedLoc = this.cached;\n    if (cachedLoc != null) {\n      return cachedLoc;\n    } else {\n      V newValue = supplier.get();\n      this.cached = newValue;\n      return newValue;\n    }\n  }\n\n  public void reset() {\n    cached = null;\n  }\n\n  public <R> SpecDependent<R> map(Function<V, R> mapper) {\n    return of(() -> mapper.apply(get()));\n  }\n}", "item_id": 0, "repo": "cloudsmith-io/teku", "file": "util/src/main/java/tech/pegasys/teku/util/config/SpecDependent.java", "last_update_at": "2022-03-25T06:05:22+00:00", "question_id": "caaaa23e4bcbae8f5db496386b22ad54f3c69403_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Deprecated\npublic class SpecDependent<V> {\n  private static List<SpecDependent<?>> allDependents = new CopyOnWriteArrayList<>();\n  public static <V> SpecDependent<V> of(Supplier<V> supplier) {\n    SpecDependent<V> ret = new SpecDependent<>(supplier);\n    allDependents.add(ret);\n    return ret;\n  }\n  public static void resetAll() {\n    allDependents.forEach(SpecDependent::reset);\n  }\n  private final Supplier<V> supplier;\n  private volatile V cached = null;\n  private SpecDependent(Supplier<V> supplier) {\n    this.supplier = supplier;\n  }\n  public V get() {\n    V cachedLoc = this.cached;\n    if (cachedLoc != null) {\n      return cachedLoc;\n    } else {\n      V newValue = supplier.get();\n      this.cached = newValue;\n      return newValue;\n    }\n  }\n  public void reset() {\n    cached = null;\n  }\n  public <R> SpecDependent<R> map(Function<V, R> mapper) {\n    return of(() -> mapper.apply(get()));\n  }\n"]], "pred": {"ppl": 1.6015360355377197, "ppl_lower": 1.90970778465271, "ppl/lowercase_ppl": -1.3736747382482086, "ppl/zlib": 0.0013010032898624524, "Min_5.0% Prob": 5.337669817606608, "Min_10.0% Prob": 3.6712882980223625, "Min_20.0% Prob": 2.2097848828822846, "Min_30.0% Prob": 1.5533373835397528, "Min_40.0% Prob": 1.1723011104419592, "Min_50.0% Prob": 0.9436434022607697, "Min_60.0% Prob": 0.7845876530064122}}
{"hexsha": "ee69ab543989a8c1f99628a2517298366e45baf7", "ext": "java", "lang": "Java", "content": "@Service\npublic class PassiveReplyServiceImpl implements PassiveReplyService {\n\n    @Autowired\n    private KeyWordMapper keyWordMapper;\n    @Autowired\n    private TextMessageMapper textMessageMapper;\n    @Autowired\n    private ImageMessageMapper imageMessageMapper;\n    @Autowired\n    private MusicMessageMapper musicMessageMapper;\n    @Autowired\n    private VideoMessageMapper videoMessageMapper;\n    @Autowired\n    private NewsMessageMapper newsMessageMapper;\n    @Autowired\n    private VoiceMessageMapper voiceMessageMapper;\n\n    @Override\n    public String selectByKeyWord(String fromUserName, String toUserName, String content) {\n\n        String message = null;\n\n        // \u9700\u8981\u56de\u590d\u4ec0\u4e48\u7c7b\u578b\u7684\u6d88\u606f\n        QueryWrapper<KeyWord> query = Wrappers.query();\n        query.select(\"type\").in(\"keyword\", content);\n\n        KeyWord keyWord = keyWordMapper.selectOne(query);\n        if (keyWord == null){\n            message = ErrorMessage.errorMessage(toUserName, fromUserName);\n            return message;\n        }\n\n        // \u83b7\u53d6\u5173\u952e\u5b57\u5bf9\u5e94\u7684\u7c7b\u578b\n        String type = keyWord.getType();\n        if (type.equals(Const.MESSAGE_TEXT)){\n            // TODO \u8981\u56de\u590d\u6587\u672c\u7c7b\u578b\u7684\n            QueryWrapper<TextMessage> queryText = Wrappers.query();\n            queryText.select(\"content\").in(\"keyword\", content);\n            String textContent = textMessageMapper.selectOne(queryText).getContent();\n\n            message = InitTextMessage.initTextMessage(toUserName, fromUserName, textContent);\n\n        }else if (type.equals(Const.MESSAGE_IMAGE)){\n            // \u8981\u56de\u590d\u56fe\u7247\u7c7b\u578b\u7684\n            QueryWrapper<Image> queryImage = Wrappers.query();\n            queryImage.select(\"media_id\").in(\"keyword\", content);\n            String mediaId = imageMessageMapper.selectOne(queryImage).getMediaId();\n\n            message = InitImageMessage.initImageMessage(toUserName, fromUserName, mediaId);\n\n        }else if (type.equals(Const.MESSAGE_VOICE)){\n            // \u8bed\u97f3\n            QueryWrapper queryVoice = Wrappers.query();\n            queryVoice.select(\"media_id\").in(\"keyword\", content);\n            String mediaId = voiceMessageMapper.selectOne(queryVoice).getMediaId();\n\n            message = InitVoiceMessage.initVoiceMessage(toUserName, fromUserName, mediaId);\n\n        }else if (type.equals(Const.MESSAGE_VIDEO)){\n            // \u89c6\u9891\n            QueryWrapper<Video> queryVideo = Wrappers.query();\n            queryVideo.select(\"title\", \"media_id\", \"description\").in(\"keyword\", content);\n            Video video = videoMessageMapper.selectOne(queryVideo);\n\n            String title= video.getTitle() ;\n            String mediaId= video.getMediaId() ;\n            String description = video.getDescription() ;\n\n            message = InitVideoMessage.initVideo(toUserName, fromUserName, title, mediaId, description);\n\n        }else if (type.equals(Const.MESSAGE_MUSIC)){\n            // \u97f3\u4e50\n            QueryWrapper<Music> queryMusic = Wrappers.query();\n            queryMusic.select(\"title\", \"description\", \"music_url\", \"hq_music_url\", \"thumb_media_id\").in(\"keyword\", content);\n            Music music = musicMessageMapper.selectOne(queryMusic);\n\n            String title = music.getTitle();\n            String desc =music.getDescription();\n            String url =music.getMusicUrl();\n            String hqUrl =music.getHQMusicUrl();\n            String thumb =music.getThumbMediaId();\n\n            message = InitMusicMessage.initMusic(toUserName, fromUserName, title, desc, url, hqUrl, thumb);\n\n        }else if (type.equals(Const.MESSAGE_NEWS)){\n            // \u56fe\u6587\n            QueryWrapper<News> queryNews = Wrappers.query();\n            queryNews.select(\"title\", \"description\", \"pic_url\", \"url\").in(\"keyword\", content);\n            News news = newsMessageMapper.selectOne(queryNews);\n\n            String title = news.getTitle() ;\n            String desc = news.getDescription() ;\n            String picUrl = news.getPicUrl() ;\n            String url = news.getUrl() ;\n\n            message = InitNewsMessage.initNewsMessage(toUserName, fromUserName, title, desc, picUrl, url);\n\n        }\n        return message;\n    }\n\n}", "item_id": 0, "repo": "wuqimahei/weixin_cqmyg", "file": "src/main/java/cn/yuyangyang/weixin/service/impl/PassiveReplyServiceImpl.java", "last_update_at": "2022-02-01T01:03:17+00:00", "question_id": "ee69ab543989a8c1f99628a2517298366e45baf7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class PassiveReplyServiceImpl implements PassiveReplyService {\n    @Autowired\n    private KeyWordMapper keyWordMapper;\n    @Autowired\n    private TextMessageMapper textMessageMapper;\n    @Autowired\n    private ImageMessageMapper imageMessageMapper;\n    @Autowired\n    private MusicMessageMapper musicMessageMapper;\n    @Autowired\n    private VideoMessageMapper videoMessageMapper;\n    @Autowired\n    private NewsMessageMapper newsMessageMapper;\n    @Autowired\n    private VoiceMessageMapper voiceMessageMapper;\n    @Override\n    public String selectByKeyWord(String fromUserName, String toUserName, String content) {\n        String message = null;\n        // \u9700\u8981\u56de\u590d\u4ec0\u4e48\u7c7b\u578b\u7684\u6d88\u606f\n        QueryWrapper<KeyWord> query = Wrappers.query();\n        query.select(\"type\").in(\"keyword\", content);\n        KeyWord keyWord = keyWordMapper.selectOne(query);\n        if (keyWord == null){\n            message = ErrorMessage.errorMessage(toUserName, fromUserName);\n            return message;\n        }\n        // \u83b7\u53d6\u5173\u952e\u5b57\u5bf9\u5e94\u7684\u7c7b\u578b\n        String type = keyWord.getType();\n        if (type.equals(Const.MESSAGE_TEXT)){\n            // TODO \u8981\u56de\u590d\u6587\u672c\u7c7b\u578b\u7684\n            QueryWrapper<TextMessage> queryText = Wrappers.query();\n            queryText.select(\"content\").in(\"keyword\", content);\n            String textContent = textMessageMapper.selectOne(queryText).getContent();\n            message = InitTextMessage.initTextMessage(toUserName, fromUserName, textContent);\n        }else if (type.equals(Const.MESSAGE_IMAGE)){\n            // \u8981\u56de\u590d\u56fe\u7247\u7c7b\u578b\u7684\n            QueryWrapper<Image> queryImage = Wrappers.query();\n            queryImage.select(\"media_id\").in(\"keyword\", content);\n            String mediaId = imageMessageMapper.selectOne(queryImage).getMediaId();\n            message = InitImageMessage.initImageMessage(toUserName, fromUserName, mediaId);\n        }else if (type.equals(Const.MESSAGE_VOICE)){\n            // \u8bed\u97f3\n            QueryWrapper queryVoice = Wrappers.query();\n            queryVoice.select(\"media_id\").in(\"keyword\", content);\n            String mediaId = voiceMessageMapper.selectOne(queryVoice).getMediaId();\n            message = InitVoiceMessage.initVoiceMessage(toUserName, fromUserName, mediaId);\n        }else if (type.equals(Const.MESSAGE_VIDEO)){\n            // \u89c6\u9891\n            QueryWrapper<Video> queryVideo = Wrappers.query();\n            queryVideo.select(\"title\", \"media_id\", \"description\").in(\"keyword\", content);\n            Video video = videoMessageMapper.selectOne(queryVideo);\n            String title= video.getTitle() ;\n            String mediaId= video.getMediaId() ;\n            String description = video.getDescription() ;\n            message = InitVideoMessage.initVideo(toUserName, fromUserName, title, mediaId, description);\n        }else if (type.equals(Const.MESSAGE_MUSIC)){\n            // \u97f3\u4e50\n            QueryWrapper<Music> queryMusic = Wrappers.query();\n            queryMusic.select(\"title\", \"description\", \"music_url\", \"hq_music_url\", \"thumb_media_id\").in(\"keyword\", content);\n            Music music = musicMessageMapper.selectOne(queryMusic);\n            String title = music.getTitle();\n            String desc =music.getDescription();\n            String url =music.getMusicUrl();\n            String hqUrl =music.getHQMusicUrl();\n            String thumb =music.getThumbMediaId();\n            message = InitMusicMessage.initMusic(toUserName, fromUserName, title, desc, url, hqUrl, thumb);\n        }else if (type.equals(Const.MESSAGE_NEWS)){\n            // \u56fe\u6587\n            QueryWrapper<News> queryNews = Wrappers.query();\n            queryNews.select(\"title\", \"description\", \"pic_url\", \"url\").in(\"keyword\", content);\n            News news = newsMessageMapper.selectOne(queryNews);\n            String title = news.getTitle() ;\n            String desc = news.getDescription() ;\n            String picUrl = news.getPicUrl() ;\n            String url = news.getUrl() ;\n            message = InitNewsMessage.initNewsMessage(toUserName, fromUserName, title, desc, picUrl, url);\n        }\n        return message;\n    }\n"]], "pred": {"ppl": 1.4566857814788818, "ppl_lower": 1.5821006298065186, "ppl/lowercase_ppl": -1.21955760905564, "ppl/zlib": 0.0003634433262318915, "Min_5.0% Prob": 4.876294453938802, "Min_10.0% Prob": 3.179876526196798, "Min_20.0% Prob": 1.8151237721390583, "Min_30.0% Prob": 1.240060953119027, "Min_40.0% Prob": 0.9354033658968645, "Min_50.0% Prob": 0.7512470214516508, "Min_60.0% Prob": 0.6271835995627625}}
{"hexsha": "fb925714d072e06f4e7b9e268ecb909c0d04c1f2", "ext": "java", "lang": "Java", "content": "class Solution {\r\n    public int findLucky(int[] arr) {\r\n        int freq[]=new int[501];\r\n        for(int i=0;i<arr.length;i++)\r\n        {\r\n            freq[arr[i]]++;\r\n        }\r\n        int ans=-1;\r\n        for(int i=1;i<=500;i++)\r\n        {\r\n            if(freq[i]==i)\r\n                ans=i;\r\n        }\r\n        return ans;\r\n    }\r\n}", "item_id": 0, "repo": "kaustubh0402/problem-solving", "file": "LeetCode/Array/Easy/Lucky Integer.java", "last_update_at": "2022-01-19T08:57:04+00:00", "question_id": "fb925714d072e06f4e7b9e268ecb909c0d04c1f2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Solution {\r\n    public int findLucky(int[] arr) {\r\n        int freq[]=new int[501];\r\n        for(int i=0;i<arr.length;i++)\r\n        {\r\n            freq[arr[i]]++;\r\n        }\r\n        int ans=-1;\r\n        for(int i=1;i<=500;i++)\r\n        {\r\n            if(freq[i]==i)\r\n                ans=i;\r\n        }\r\n        return ans;\r\n    }\r\n"]], "pred": {"ppl": 1.4442026615142822, "ppl_lower": 1.6895830631256104, "ppl/lowercase_ppl": -1.42693854559202, "ppl/zlib": 0.0021246091209938265, "Min_5.0% Prob": 4.279727458953857, "Min_10.0% Prob": 2.8713742593924203, "Min_20.0% Prob": 1.7163511276245118, "Min_30.0% Prob": 1.215372574893204, "Min_40.0% Prob": 0.9099608916044235, "Min_50.0% Prob": 0.737733711037905, "Min_60.0% Prob": 0.6116785688201586}}
{"hexsha": "ff2ac6411e4148567dd75d3fc3447a458153e66e", "ext": "java", "lang": "Java", "content": "public class AutomaticSpellsModule extends Framework_Module_Abstract {\n\n    private final String thisIniName = \"AutomaticSpells.ini\";\n    private final Ini thisIni;\n\n    private final String patchSettings = \"PatchSettings\";\n    private final String NPCInclusions = \"NPCInclusions\";\n    private final String NPCExclusions = \"NPCExclusions\";\n    private final String KeywordExclusions = \"NPCKeywordExclusions\";\n    private final String NPCModExclusions = \"NPCModExclusions\";\n    private final String effectKYWDPrefixes = \"EffectKeywordPrefixes\";\n\n    private final String SPELLEXCLUSIONSCONTAINS = \"SPELLEXCLUSIONSCONTAINS\";\n    private final String SPELLEXCLUSIONSSTARTSWITH = \"SPELLEXCLUSIONSSTARTSWITH\";\n\n    private final String spellModInclusions = \"spellModInclusions\";\n\n    private final Set<String> effectPrefixes = new HashSet<>();\n\n    public AutomaticSpellsModule() throws IOException {\n        name = \"Automatic Spells\";\n        thisIni = new Ini();\n        Config c = thisIni.getConfig();\n        c.setEmptyOption(true);\n        c.setEmptySection(true);\n        thisIni.load(new File(thisIniName));\n\n        effectPrefixes.addAll(thisIni.get(effectKYWDPrefixes).keySet());\n\n        RecordSelector npcsToGetSpells = new RecordSelectorBuilder().type(GRUP_TYPE.NPC_).RecordValidator(ASIS.validNPCs_NoSpellsPerks).build();\n        npcsToGetSpells.addInclusion(new SelectionSet(thisIni.get(NPCInclusions), new Matcher.EDIDStartsWith()));\n        npcsToGetSpells.addExclusion(new SelectionSet(thisIni.get(NPCExclusions), new Matcher.EDIDContains()));\n        npcsToGetSpells.addExclusion(new SelectionSet(thisIni.get(NPCModExclusions), new Matcher.ModContains()));\n        npcsToGetSpells.addExclusion(new SelectionSet(ASIS.getAsisIni().get(\"MODEXCLUSIONS\"), new Matcher.ModContains()));\n        npcsToGetSpells.addExclusion(new SelectionSet(thisIni.get(KeywordExclusions), new Matcher.HasKYWD()));\n        this.addRecordSelector(\"npcsToGetSpells\", npcsToGetSpells);\n\n        RecordSelector spellsToDistribute = new RecordSelectorBuilder().type(GRUP_TYPE.SPEL).RecordValidator(RecordSelector.USE_NON_DELETED).build();\n        spellsToDistribute.addInclusion(new SelectionSet(thisIni.get(spellModInclusions), new Matcher.ModContains()));\n        spellsToDistribute.addExclusion(new SelectionSet(thisIni.get(SPELLEXCLUSIONSCONTAINS), new Matcher.EDIDContains()));\n        spellsToDistribute.addExclusion(new SelectionSet(thisIni.get(SPELLEXCLUSIONSSTARTSWITH), new Matcher.EDIDStartsWith()));\n        spellsToDistribute.addExclusion(new SelectionSet(ASIS.getAsisIni().get(\"MODEXCLUSIONS\"), new Matcher.ModContains()));\n        this.addRecordSelector(\"spellsToDistribute\", spellsToDistribute);\n\n    }\n\n    private Mod merger;\n\n    @Override\n    public void runModuleChanges() {\n        merger = Controller.getAllRecords();\n        Map<SPEL, SpellInfo> spellsMap = getSpellInfos();\n        Map<NPC_, NPCInfo> npcsMap = buildNPCInfos();\n        addSpellsToNPCs(spellsMap, npcsMap);\n    }\n\n    private Map<SPEL, SpellInfo> getSpellInfos() {\n        SPProgressBarPlug.setStatus(\"Automatic Spells: Mapping Spells\");\n        SPProgressBarPlug.incrementBar();\n\n        Map<SPEL, SpellInfo> spellMap = new HashMap<>();\n\n        for (MajorRecord r : getRecordSelector(\"spellsToDistribute\").getValidRecords()) {\n            SPEL s = (SPEL) r;\n            if (s != null) {\n\n                SpellInfo spellInf = getSpellInfo(s);\n                if (spellInf != null) {\n                    spellMap.put(s, spellInf);\n                }\n\n            }\n        }\n        return spellMap;\n    }\n\n    private void addSpellsToNPCs(Map<SPEL, SpellInfo> spellsMap, Map<NPC_, NPCInfo> npcsMap) {\n        try {\n            Mod patch = SPGlobal.getGlobalPatch();\n\n            for (MajorRecord r : getRecordSelector(\"npcsToGetSpells\").getValidRecords()) {\n                NPC_ n = (NPC_) r;\n                if (n == null) {\n                    continue;\n                }\n                NPCInfo theNpcsInfo = npcsMap.get(n);\n                if (theNpcsInfo == null) {\n                    continue;\n                }\n                boolean changed = false;\n\n                ArrayList<FormID> npcSpellsForms = n.getSpells();\n                ArrayList<SPEL> npcSpells = new ArrayList<>();\n                for (FormID f : npcSpellsForms) {\n                    SPEL s = (SPEL) merger.getMajor(f, GRUP_TYPE.SPEL);\n                    if (s != null) {\n                        npcSpells.add(s);\n                    }\n                    // disabled warning because of unhandled SHOU\n//                        else {\n//                            SPGlobal.logError(name, \"NPC: \" + n + \", has spell FormID entry: \" + f\n//                                    + \", which cannot be resolved to a Spell\\n\"\n//                                    + \"Skipping for patch but this is probably a very bad thing\");\n//                        }\n                }\n\n                for (Entry<SPEL, SpellInfo> e : spellsMap.entrySet()) {\n                    if (!npcSpells.contains(e.getKey()) && npcCanGet(theNpcsInfo, e.getValue())) {\n                        n.addSpell(e.getKey().getForm());\n                        changed = true;\n                    }\n                }\n                if (changed) {\n                    ASIS.npcsToWrite.add(n.getForm());\n                    patch.addRecord(n);\n                }\n\n            }\n        } catch (Exception exception) {\n            System.err.println(exception.toString());\n            SPGlobal.logException(exception);\n            SPGlobal.flush();\n            JOptionPane.showMessageDialog(null, \"Something terrible happened running \" + name\n                    + \": \" + exception + \" Check the readme and debug logs.\");\n            System.exit(0);\n        }\n    }\n\n    private Map<NPC_, NPCInfo> buildNPCInfos() {\n        Map<NPC_, NPCInfo> npcMap = new HashMap<>();\n\n        for (MajorRecord r : getRecordSelector(\"npcsToGetSpells\").getValidRecords()) {\n            NPC_ n = (NPC_) r;\n            if (n != null) {\n                NPCInfo theInfo = getNPCInfo(n);\n                if (theInfo != null) {\n                    npcMap.put(n, theInfo);\n                }\n            }\n\n        }\n\n        return npcMap;\n    }\n\n    private boolean npcCanGet(NPCInfo nInfo, SpellInfo spInfo) {\n        Map<Skill, Integer> skillLevels = nInfo.getSkillLevels();\n\n        for (Entry<Skill, Integer> e : spInfo.getNeededSkills().entrySet()) {\n            if (skillLevels.get(e.getKey()) < e.getValue()) {\n                return false;\n            }\n        }\n\n        ArrayList<KYWD> magicKeys = new ArrayList<>();\n        for (FormID keyForm : spInfo.getMainEffect().getKeywordSet().getKeywordRefs()) {\n            KYWD key = (KYWD) merger.getMajor(keyForm, GRUP_TYPE.KYWD);\n            if (key != null) {\n                String edid = key.getEDID().toUpperCase();\n                for (String prefix : effectPrefixes) {\n                    if (edid.startsWith(prefix.toUpperCase())) {\n                        magicKeys.add(key);\n                    }\n                }\n            }\n        }\n        Set<KYWD> effects = nInfo.getHandEffects().get(spInfo.getEquipslot());\n        if (effects != null && magicKeys.size() > 0) {\n            for (KYWD key : magicKeys) {\n                if (effects.contains(key)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private NPC_ unTemplate(NPC_ n, NPC_.TemplateFlag templateFlag) {\n        while (n.isTemplated() && n.get(templateFlag)) {\n            NPC_ nTemp = (NPC_) merger.getMajor(n.getTemplate(), GRUP_TYPE.NPC_);\n            if (nTemp == null) {\n                LVLN lTemp = (LVLN) merger.getMajor(n.getTemplate(), GRUP_TYPE.LVLN);\n                if (lTemp == null) {\n                    SPGlobal.logError(name, \"NPC: \" + n\n                            + \", has template FormID entry: \" + n.getTemplate()\n                            + \", which cannot be resolved to an NPC or Leveled NPC.\\n\"\n                            + \"Skipping for patch but this is probably a very bad thing\");\n                }\n                n = null;\n                break;\n            }\n            n = nTemp;\n        }\n        return n;\n    }\n\n    private SpellInfo getSpellInfo(SPEL s) {\n\n        Skill curSkill = null;\n        int curCost = -1;\n        MGEF curEffect = null;\n        Map<Skill, Integer> neededSkills = new HashMap();\n\n        for (MagicEffectRef ref : s.getMagicEffects()) {\n            FormID refID = ref.getMagicRef();\n            MGEF effect = (MGEF) merger.getMajor(refID, GRUP_TYPE.MGEF);\n            if (effect != null) {\n                ActorValue av = effect.getSkillType();\n                Skill sk = AutomaticPerksModule.getAVasSkill(av);\n                if ((sk != null) && (isMagicSkill(sk))) {\n                    if (!neededSkills.containsKey(sk)) {\n                        neededSkills.put(sk, effect.getSkillLevel());\n                    } else if (effect.getSkillLevel() > neededSkills.get(sk)) {\n                        neededSkills.put(sk, effect.getSkillLevel());\n                    }\n\n                    float mag = ref.getMagnitude();\n                    if (mag < 1.0) {\n                        mag = (float) 1.0;\n                    }\n                    int dur = ref.getDuration();\n                    if (dur == 0) {\n                        dur = 10;\n                    }\n\n                    double cost = effect.getBaseCost() * Math.pow((mag * dur / 10), 1.1);\n                    int iCost = (int) Math.floor(cost);\n                    if (iCost > curCost) {\n                        curSkill = sk;\n                        curCost = iCost;\n                        curEffect = effect;\n                    }\n                }\n            }\n        }\n        SpellInfo info = null;\n        if (curSkill != null) {\n            info = new SpellInfo(s, curSkill, curEffect, neededSkills);\n        }\n        return info;\n    }\n\n    private NPCInfo getNPCInfo(NPC_ n) {\n\n        NPC_ unTemplatedSpells = unTemplate(n, NPC_.TemplateFlag.USE_SPELL_LIST);\n        NPC_ unTemplatedStats = unTemplate(n, NPC_.TemplateFlag.USE_STATS);\n\n        if ((unTemplatedSpells == null) || (unTemplatedStats == null)) {\n            return null;\n        }\n\n        NPCInfo theInfo = new NPCInfo();\n\n        // get effects per equipSlot\n        ArrayList<FormID> spells = unTemplatedSpells.getSpells();\n        Map<SPEL, MGEF> effectsMap = new HashMap<>();\n\n        for (FormID f : spells) {\n            SPEL theSpell = (SPEL) merger.getMajor(f, GRUP_TYPE.SPEL);\n            if (theSpell != null) {\n                int curCost = -1;\n                MGEF mainEffect = null;\n\n                for (MagicEffectRef ref : theSpell.getMagicEffects()) {\n                    FormID refID = ref.getMagicRef();\n                    MGEF effect = (MGEF) merger.getMajor(refID, GRUP_TYPE.MGEF);\n                    if ((effect != null) && (effect.getBaseCost() > 0.0)) {\n                        float mag = ref.getMagnitude();\n                        if (mag < 1.0) {\n                            mag = (float) 1.0;\n                        }\n                        int dur = ref.getDuration();\n                        if (dur == 0) {\n                            dur = 10;\n                        }\n\n                        double cost = effect.getBaseCost() * Math.pow((mag * dur / 10), 1.1);\n                        int iCost = (int) Math.floor(cost);\n                        if (iCost > curCost) {\n                            curCost = iCost;\n                            mainEffect = effect;\n                        }\n\n                    }\n                }\n                if (mainEffect != null) {\n                    effectsMap.put(theSpell, mainEffect);\n                }\n            }\n        }\n        for (Entry<SPEL, MGEF> entry : effectsMap.entrySet()) {\n            FormID equipSlot = entry.getKey().getEquipSlot();\n            for (FormID f : entry.getValue().getKeywordSet().getKeywordRefs()) {\n                KYWD key = (KYWD) merger.getMajor(f, GRUP_TYPE.KYWD);\n                if (key == null) {\n                    String error = \"Magic Effect \" + entry.getValue().getEDID()\n                            + \" has a keyword reference \" + f + \" that cannot be resolved to a loaded keyword. Skipping.\";\n                    SPGlobal.log(name, error);\n                } else {\n                    String edid = key.getEDID().toUpperCase();\n                    for (String prefix : effectPrefixes) {\n                        if (edid.startsWith(prefix.toUpperCase())) {\n                            theInfo.addEquipslotEffect(equipSlot, key);\n                        }\n                    }\n                }\n            }\n        }\n\n        // get skills\n        ArrayList<Skill> skills = new ArrayList<>();\n        skills.add(Skill.ALTERATION);\n        skills.add(Skill.CONJURATION);\n        skills.add(Skill.DESTRUCTION);\n        skills.add(Skill.ILLUSION);\n        skills.add(Skill.RESTORATION);\n        for (Skill s : skills) {\n            theInfo.addSkillLevel(s, unTemplatedStats.get(s));\n        }\n\n        return theInfo;\n    }\n\n    private boolean isMagicSkill(Skill sk) {\n        switch (sk) {\n            case ALTERATION:\n            case CONJURATION:\n            case DESTRUCTION:\n            case ILLUSION:\n            case RESTORATION:\n                return true;\n        }\n        return false;\n\n    }\n\n    private class NPCInfo {\n\n        private final Map<FormID, Set<KYWD>> handEffects;\n        private final Map<Skill, Integer> skillLevels;\n\n        public NPCInfo() {\n            handEffects = new HashMap<>();\n            skillLevels = new HashMap<>();\n        }\n\n        public void addEquipslotEffect(FormID f, KYWD k) {\n            Set<KYWD> keySet = handEffects.get(f);\n            if (keySet == null) {\n                keySet = new HashSet<>();\n                keySet.add(k);\n                handEffects.put(f, keySet);\n            } else {\n                keySet.add(k);\n            }\n        }\n\n        public Map<FormID, Set<KYWD>> getHandEffects() {\n            return handEffects;\n        }\n\n        public void addSkillLevel(Skill theSkill, int i) {\n            skillLevels.put(theSkill, i);\n        }\n\n        public Map<Skill, Integer> getSkillLevels() {\n            return skillLevels;\n        }\n\n    }\n\n    private class SpellInfo {\n\n        private Map<Skill, Integer> neededSkills;\n        private Skill mainSkill;\n        private MGEF mainEffect;\n        private SPEL theSpell;\n        private FormID equipslot;\n\n        private SpellInfo() {\n        }\n\n        private SpellInfo(SPEL theSpell, Skill mainSkill, MGEF mainEffect, Map<Skill, Integer> neededSkills) {\n            this.theSpell = theSpell;\n            this.neededSkills = neededSkills;\n            this.mainSkill = mainSkill;\n            this.mainEffect = mainEffect;\n            equipslot = theSpell.getEquipSlot();\n        }\n\n        public Map<Skill, Integer> getNeededSkills() {\n            return neededSkills;\n        }\n\n        public Skill getMainSkill() {\n            return mainSkill;\n        }\n\n        public MGEF getMainEffect() {\n            return mainEffect;\n        }\n\n        public FormID getEquipslot() {\n            return equipslot;\n        }\n\n    }\n\n}", "item_id": 0, "repo": "Michiel1973/ASIS", "file": "src/asis/AutomaticSpellsModule.java", "last_update_at": "2022-03-07T04:38:39+00:00", "question_id": "ff2ac6411e4148567dd75d3fc3447a458153e66e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AutomaticSpellsModule extends Framework_Module_Abstract {\n    private final String thisIniName = \"AutomaticSpells.ini\";\n    private final Ini thisIni;\n    private final String patchSettings = \"PatchSettings\";\n    private final String NPCInclusions = \"NPCInclusions\";\n    private final String NPCExclusions = \"NPCExclusions\";\n    private final String KeywordExclusions = \"NPCKeywordExclusions\";\n    private final String NPCModExclusions = \"NPCModExclusions\";\n    private final String effectKYWDPrefixes = \"EffectKeywordPrefixes\";\n    private final String SPELLEXCLUSIONSCONTAINS = \"SPELLEXCLUSIONSCONTAINS\";\n    private final String SPELLEXCLUSIONSSTARTSWITH = \"SPELLEXCLUSIONSSTARTSWITH\";\n    private final String spellModInclusions = \"spellModInclusions\";\n    private final Set<String> effectPrefixes = new HashSet<>();\n    public AutomaticSpellsModule() throws IOException {\n        name = \"Automatic Spells\";\n        thisIni = new Ini();\n        Config c = thisIni.getConfig();\n        c.setEmptyOption(true);\n        c.setEmptySection(true);\n        thisIni.load(new File(thisIniName));\n        effectPrefixes.addAll(thisIni.get(effectKYWDPrefixes).keySet());\n        RecordSelector npcsToGetSpells = new RecordSelectorBuilder().type(GRUP_TYPE.NPC_).RecordValidator(ASIS.validNPCs_NoSpellsPerks).build();\n        npcsToGetSpells.addInclusion(new SelectionSet(thisIni.get(NPCInclusions), new Matcher.EDIDStartsWith()));\n        npcsToGetSpells.addExclusion(new SelectionSet(thisIni.get(NPCExclusions), new Matcher.EDIDContains()));\n        npcsToGetSpells.addExclusion(new SelectionSet(thisIni.get(NPCModExclusions), new Matcher.ModContains()));\n        npcsToGetSpells.addExclusion(new SelectionSet(ASIS.getAsisIni().get(\"MODEXCLUSIONS\"), new Matcher.ModContains()));\n        npcsToGetSpells.addExclusion(new SelectionSet(thisIni.get(KeywordExclusions), new Matcher.HasKYWD()));\n        this.addRecordSelector(\"npcsToGetSpells\", npcsToGetSpells);\n        RecordSelector spellsToDistribute = new RecordSelectorBuilder().type(GRUP_TYPE.SPEL).RecordValidator(RecordSelector.USE_NON_DELETED).build();\n        spellsToDistribute.addInclusion(new SelectionSet(thisIni.get(spellModInclusions), new Matcher.ModContains()));\n        spellsToDistribute.addExclusion(new SelectionSet(thisIni.get(SPELLEXCLUSIONSCONTAINS), new Matcher.EDIDContains()));\n        spellsToDistribute.addExclusion(new SelectionSet(thisIni.get(SPELLEXCLUSIONSSTARTSWITH), new Matcher.EDIDStartsWith()));\n        spellsToDistribute.addExclusion(new SelectionSet(ASIS.getAsisIni().get(\"MODEXCLUSIONS\"), new Matcher.ModContains()));\n        this.addRecordSelector(\"spellsToDistribute\", spellsToDistribute);\n    }\n    private Mod merger;\n    @Override\n    public void runModuleChanges() {\n        merger = Controller.getAllRecords();\n        Map<SPEL, SpellInfo> spellsMap = getSpellInfos();\n        Map<NPC_, NPCInfo> npcsMap = buildNPCInfos();\n        addSpellsToNPCs(spellsMap, npcsMap);\n    }\n    private Map<SPEL, SpellInfo> getSpellInfos() {\n        SPProgressBarPlug.setStatus(\"Automatic Spells: Mapping Spells\");\n        SPProgressBarPlug.incrementBar();\n        Map<SPEL, SpellInfo> spellMap = new HashMap<>();\n        for (MajorRecord r : getRecordSelector(\"spellsToDistribute\").getValidRecords()) {\n            SPEL s = (SPEL) r;\n            if (s != null) {\n                SpellInfo spellInf = getSpellInfo(s);\n                if (spellInf != null) {\n                    spellMap.put(s, spellInf);\n                }\n            }\n        }\n        return spellMap;\n    }\n    private void addSpellsToNPCs(Map<SPEL, SpellInfo> spellsMap, Map<NPC_, NPCInfo> npcsMap) {\n        try {\n            Mod patch = SPGlobal.getGlobalPatch();\n            for (MajorRecord r : getRecordSelector(\"npcsToGetSpells\").getValidRecords()) {\n                NPC_ n = (NPC_) r;\n                if (n == null) {\n                    continue;\n                }\n                NPCInfo theNpcsInfo = npcsMap.get(n);\n                if (theNpcsInfo == null) {\n                    continue;\n                }\n                boolean changed = false;\n                ArrayList<FormID> npcSpellsForms = n.getSpells();\n                ArrayList<SPEL> npcSpells = new ArrayList<>();\n                for (FormID f : npcSpellsForms) {\n                    SPEL s = (SPEL) merger.getMajor(f, GRUP_TYPE.SPEL);\n                    if (s != null) {\n                        npcSpells.add(s);\n                    }\n                    // disabled warning because of unhandled SHOU\n//                        else {\n//                            SPGlobal.logError(name, \"NPC: \" + n + \", has spell FormID entry: \" + f\n//                                    + \", which cannot be resolved to a Spell\\n\"\n//                                    + \"Skipping for patch but this is probably a very bad thing\");\n//                        }\n                }\n                for (Entry<SPEL, SpellInfo> e : spellsMap.entrySet()) {\n                    if (!npcSpells.contains(e.getKey()) && npcCanGet(theNpcsInfo, e.getValue())) {\n                        n.addSpell(e.getKey().getForm());\n                        changed = true;\n                    }\n                }\n                if (changed) {\n                    ASIS.npcsToWrite.add(n.getForm());\n                    patch.addRecord(n);\n                }\n            }\n        } catch (Exception exception) {\n            System.err.println(exception.toString());\n            SPGlobal.logException(exception);\n            SPGlobal.flush();\n            JOptionPane.showMessageDialog(null, \"Something terrible happened running \" + name\n                    + \": \" + exception + \" Check the readme and debug logs.\");\n            System.exit(0);\n        }\n    }\n    private Map<NPC_, NPCInfo> buildNPCInfos() {\n        Map<NPC_, NPCInfo> npcMap = new HashMap<>();\n        for (MajorRecord r : getRecordSelector(\"npcsToGetSpells\").getValidRecords()) {\n            NPC_ n = (NPC_) r;\n            if (n != null) {\n                NPCInfo theInfo = getNPCInfo(n);\n                if (theInfo != null) {\n                    npcMap.put(n, theInfo);\n                }\n            }\n        }\n        return npcMap;\n    }\n    private boolean npcCanGet(NPCInfo nInfo, SpellInfo spInfo) {\n        Map<Skill, Integer> skillLevels = nInfo.getSkillLevels();\n        for (Entry<Skill, Integer> e : spInfo.getNeededSkills().entrySet()) {\n            if (skillLevels.get(e.getKey()) < e.getValue()) {\n                return false;\n            }\n        }\n        ArrayList<KYWD> magicKeys = new ArrayList<>();\n        for (FormID keyForm : spInfo.getMainEffect().getKeywordSet().getKeywordRefs()) {\n            KYWD key = (KYWD) merger.getMajor(keyForm, GRUP_TYPE.KYWD);\n            if (key != null) {\n                String edid = key.getEDID().toUpperCase();\n                for (String prefix : effectPrefixes) {\n                    if (edid.startsWith(prefix.toUpperCase())) {\n                        magicKeys.add(key);\n                    }\n                }\n            }\n        }\n        Set<KYWD> effects = nInfo.getHandEffects().get(spInfo.getEquipslot());\n        if (effects != null && magicKeys.size() > 0) {\n            for (KYWD key : magicKeys) {\n                if (effects.contains(key)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    private NPC_ unTemplate(NPC_ n, NPC_.TemplateFlag templateFlag) {\n        while (n.isTemplated() && n.get(templateFlag)) {\n            NPC_ nTemp = (NPC_) merger.getMajor(n.getTemplate(), GRUP_TYPE.NPC_);\n            if (nTemp == null) {\n                LVLN lTemp = (LVLN) merger.getMajor(n.getTemplate(), GRUP_TYPE.LVLN);\n                if (lTemp == null) {\n                    SPGlobal.logError(name, \"NPC: \" + n\n                            + \", has template FormID entry: \" + n.getTemplate()\n                            + \", which cannot be resolved to an NPC or Leveled NPC.\\n\"\n                            + \"Skipping for patch but this is probably a very bad thing\");\n                }\n                n = null;\n                break;\n            }\n            n = nTemp;\n        }\n        return n;\n    }\n    private SpellInfo getSpellInfo(SPEL s) {\n        Skill curSkill = null;\n        int curCost = -1;\n        MGEF curEffect = null;\n        Map<Skill, Integer> neededSkills = new HashMap();\n        for (MagicEffectRef ref : s.getMagicEffects()) {\n            FormID refID = ref.getMagicRef();\n            MGEF effect = (MGEF) merger.getMajor(refID, GRUP_TYPE.MGEF);\n            if (effect != null) {\n                ActorValue av = effect.getSkillType();\n                Skill sk = AutomaticPerksModule.getAVasSkill(av);\n                if ((sk != null) && (isMagicSkill(sk))) {\n                    if (!neededSkills.containsKey(sk)) {\n                        neededSkills.put(sk, effect.getSkillLevel());\n                    } else if (effect.getSkillLevel() > neededSkills.get(sk)) {\n                        neededSkills.put(sk, effect.getSkillLevel());\n                    }\n                    float mag = ref.getMagnitude();\n                    if (mag < 1.0) {\n                        mag = (float) 1.0;\n                    }\n                    int dur = ref.getDuration();\n                    if (dur == 0) {\n                        dur = 10;\n                    }\n                    double cost = effect.getBaseCost() * Math.pow((mag * dur / 10), 1.1);\n                    int iCost = (int) Math.floor(cost);\n                    if (iCost > curCost) {\n                        curSkill = sk;\n                        curCost = iCost;\n                        curEffect = effect;\n                    }\n                }\n            }\n        }\n        SpellInfo info = null;\n        if (curSkill != null) {\n            info = new SpellInfo(s, curSkill, curEffect, neededSkills);\n        }\n        return info;\n    }\n    private NPCInfo getNPCInfo(NPC_ n) {\n        NPC_ unTemplatedSpells = unTemplate(n, NPC_.TemplateFlag.USE_SPELL_LIST);\n        NPC_ unTemplatedStats = unTemplate(n, NPC_.TemplateFlag.USE_STATS);\n        if ((unTemplatedSpells == null) || (unTemplatedStats == null)) {\n            return null;\n        }\n        NPCInfo theInfo = new NPCInfo();\n        // get effects per equipSlot\n        ArrayList<FormID> spells = unTemplatedSpells.getSpells();\n        Map<SPEL, MGEF> effectsMap = new HashMap<>();\n        for (FormID f : spells) {\n            SPEL theSpell = (SPEL) merger.getMajor(f, GRUP_TYPE.SPEL);\n            if (theSpell != null) {\n                int curCost = -1;\n                MGEF mainEffect = null;\n                for (MagicEffectRef ref : theSpell.getMagicEffects()) {\n                    FormID refID = ref.getMagicRef();\n                    MGEF effect = (MGEF) merger.getMajor(refID, GRUP_TYPE.MGEF);\n                    if ((effect != null) && (effect.getBaseCost() > 0.0)) {\n                        float mag = ref.getMagnitude();\n                        if (mag < 1.0) {\n                            mag = (float) 1.0;\n                        }\n                        int dur = ref.getDuration();\n                        if (dur == 0) {\n                            dur = 10;\n                        }\n                        double cost = effect.getBaseCost() * Math.pow((mag * dur / 10), 1.1);\n                        int iCost = (int) Math.floor(cost);\n                        if (iCost > curCost) {\n                            curCost = iCost;\n                            mainEffect = effect;\n                        }\n                    }\n                }\n                if (mainEffect != null) {\n                    effectsMap.put(theSpell, mainEffect);\n                }\n            }\n        }\n        for (Entry<SPEL, MGEF> entry : effectsMap.entrySet()) {\n            FormID equipSlot = entry.getKey().getEquipSlot();\n            for (FormID f : entry.getValue().getKeywordSet().getKeywordRefs()) {\n                KYWD key = (KYWD) merger.getMajor(f, GRUP_TYPE.KYWD);\n                if (key == null) {\n                    String error = \"Magic Effect \" + entry.getValue().getEDID()\n                            + \" has a keyword reference \" + f + \" that cannot be resolved to a loaded keyword. Skipping.\";\n                    SPGlobal.log(name, error);\n                } else {\n                    String edid = key.getEDID().toUpperCase();\n                    for (String prefix : effectPrefixes) {\n                        if (edid.startsWith(prefix.toUpperCase())) {\n                            theInfo.addEquipslotEffect(equipSlot, key);\n                        }\n                    }\n                }\n            }\n        }\n        // get skills\n        ArrayList<Skill> skills = new ArrayList<>();\n        skills.add(Skill.ALTERATION);\n        skills.add(Skill.CONJURATION);\n        skills.add(Skill.DESTRUCTION);\n        skills.add(Skill.ILLUSION);\n        skills.add(Skill.RESTORATION);\n        for (Skill s : skills) {\n            theInfo.addSkillLevel(s, unTemplatedStats.get(s));\n        }\n        return theInfo;\n    }\n    private boolean isMagicSkill(Skill sk) {\n        switch (sk) {\n            case ALTERATION:\n            case CONJURATION:\n            case DESTRUCTION:\n            case ILLUSION:\n            case RESTORATION:\n                return true;\n        }\n        return false;\n    }\n    private class NPCInfo {\n        private final Map<FormID, Set<KYWD>> handEffects;\n        private final Map<Skill, Integer> skillLevels;\n        public NPCInfo() {\n            handEffects = new HashMap<>();\n            skillLevels = new HashMap<>();\n        }\n        public void addEquipslotEffect(FormID f, KYWD k) {\n            Set<KYWD> keySet = handEffects.get(f);\n            if (keySet == null) {\n                keySet = new HashSet<>();\n                keySet.add(k);\n                handEffects.put(f, keySet);\n            } else {\n                keySet.add(k);\n            }\n        }\n        public Map<FormID, Set<KYWD>> getHandEffects() {\n            return handEffects;\n        }\n        public void addSkillLevel(Skill theSkill, int i) {\n            skillLevels.put(theSkill, i);\n        }\n        public Map<Skill, Integer> getSkillLevels() {\n            return skillLevels;\n        }\n    }\n    private class SpellInfo {\n        private Map<Skill, Integer> neededSkills;\n        private Skill mainSkill;\n        private MGEF mainEffect;\n        private SPEL theSpell;\n        private FormID equipslot;\n        private SpellInfo() {\n        }\n        private SpellInfo(SPEL theSpell, Skill mainSkill, MGEF mainEffect, Map<Skill, Integer> neededSkills) {\n            this.theSpell = theSpell;\n            this.neededSkills = neededSkills;\n            this.mainSkill = mainSkill;\n            this.mainEffect = mainEffect;\n            equipslot = theSpell.getEquipSlot();\n        }\n        public Map<Skill, Integer> getNeededSkills() {\n            return neededSkills;\n        }\n        public Skill getMainSkill() {\n            return mainSkill;\n        }\n        public MGEF getMainEffect() {\n            return mainEffect;\n        }\n        public FormID getEquipslot() {\n            return equipslot;\n        }\n    }\n"]], "pred": {"ppl": 2.271343231201172, "ppl_lower": 2.7384965419769287, "ppl/lowercase_ppl": -1.2279914644392111, "ppl/zlib": 0.00023917533186465395, "Min_5.0% Prob": 7.9348555920170805, "Min_10.0% Prob": 5.915622739230885, "Min_20.0% Prob": 3.7429903769025614, "Min_30.0% Prob": 2.6647386701862796, "Min_40.0% Prob": 2.0351212728030816, "Min_50.0% Prob": 1.6382075979751616, "Min_60.0% Prob": 1.3679618324619547}}
{"hexsha": "b5ffab6c0829ecce7539a90a86f83f6d5f5bfd61", "ext": "java", "lang": "Java", "content": "public class solution {\n\n    // Complete the happyLadybugs function below.\n    static String happyLadybugs(String b) {\n        b = b.toLowerCase();\n        // we'll note if string has _ then we can swap places\n        boolean canSwap = false;\n        boolean isEmpty = true;\n        // initialise char freq array\n        int[] chars = new int[26];\n        for (int i = 0; i < b.length(); i++) {\n            if (b.charAt(i) == '_') {\n                canSwap = true;\n            } else {\n                // note the char frequencies\n                chars[((int) b.charAt(i)) - 97]++;\n                isEmpty = false;\n            }\n        }\n        // if the string is empty there are no unhappy lady bugs\n        if (isEmpty) {\n            return \"YES\";\n        }\n        // if there is only one ladybug we can't make it happy\n        if (b.length() <= 1) {\n            return \"NO\";\n        }\n        // if there exists only one ladybug of any color, we can't make them happy\n        for (int i = 0; i < 26; i++) {\n            if (chars[i] == 1) {\n                return \"NO\";\n            }\n        }\n        // for i=0 if right ladybug is not of same color and we can't swap,return NO\n        for (int i = 0; i < b.length(); i++) {\n            if (i == 0) {\n                if (b.charAt(i) != b.charAt(i + 1) && !canSwap) {\n                    return \"NO\";\n                }\n                // for rightmost ladybug, if ladybug is not of same color and we can't swap\n                // return NO\n            } else if (i == b.length() - 1) {\n                if (b.charAt(i) != b.charAt(i - 1) && !canSwap) {\n                    return \"NO\";\n                }\n                // if adjacent ladybug is not of same color and we can't swap, return NO\n            } else {\n                if (b.charAt(i) != b.charAt(i - 1) && b.charAt(i) != b.charAt(i + 1) && !canSwap) {\n                    return \"NO\";\n                }\n            }\n        }\n        return \"YES\";\n    }\n\n    private static final Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] args) throws IOException {\n        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(\"OUTPUT_PATH\")));\n\n        int g = scanner.nextInt();\n        scanner.skip(\"(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])?\");\n\n        for (int gItr = 0; gItr < g; gItr++) {\n            int n = scanner.nextInt();\n            scanner.skip(\"(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])?\");\n\n            String b = scanner.nextLine();\n\n            String result = happyLadybugs(b);\n\n            bufferedWriter.write(result);\n            bufferedWriter.newLine();\n        }\n\n        bufferedWriter.close();\n\n        scanner.close();\n    }\n}", "item_id": 0, "repo": "kitarp29/ds-algo-solutions", "file": "Algorithms/Implementation/Happy Ladybugs/solution.java", "last_update_at": "2022-02-26T17:56:52+00:00", "question_id": "b5ffab6c0829ecce7539a90a86f83f6d5f5bfd61_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class solution {\n    // Complete the happyLadybugs function below.\n    static String happyLadybugs(String b) {\n        b = b.toLowerCase();\n        // we'll note if string has _ then we can swap places\n        boolean canSwap = false;\n        boolean isEmpty = true;\n        // initialise char freq array\n        int[] chars = new int[26];\n        for (int i = 0; i < b.length(); i++) {\n            if (b.charAt(i) == '_') {\n                canSwap = true;\n            } else {\n                // note the char frequencies\n                chars[((int) b.charAt(i)) - 97]++;\n                isEmpty = false;\n            }\n        }\n        // if the string is empty there are no unhappy lady bugs\n        if (isEmpty) {\n            return \"YES\";\n        }\n        // if there is only one ladybug we can't make it happy\n        if (b.length() <= 1) {\n            return \"NO\";\n        }\n        // if there exists only one ladybug of any color, we can't make them happy\n        for (int i = 0; i < 26; i++) {\n            if (chars[i] == 1) {\n                return \"NO\";\n            }\n        }\n        // for i=0 if right ladybug is not of same color and we can't swap,return NO\n        for (int i = 0; i < b.length(); i++) {\n            if (i == 0) {\n                if (b.charAt(i) != b.charAt(i + 1) && !canSwap) {\n                    return \"NO\";\n                }\n                // for rightmost ladybug, if ladybug is not of same color and we can't swap\n                // return NO\n            } else if (i == b.length() - 1) {\n                if (b.charAt(i) != b.charAt(i - 1) && !canSwap) {\n                    return \"NO\";\n                }\n                // if adjacent ladybug is not of same color and we can't swap, return NO\n            } else {\n                if (b.charAt(i) != b.charAt(i - 1) && b.charAt(i) != b.charAt(i + 1) && !canSwap) {\n                    return \"NO\";\n                }\n            }\n        }\n        return \"YES\";\n    }\n    private static final Scanner scanner = new Scanner(System.in);\n    public static void main(String[] args) throws IOException {\n        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(\"OUTPUT_PATH\")));\n        int g = scanner.nextInt();\n        scanner.skip(\"(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])?\");\n        for (int gItr = 0; gItr < g; gItr++) {\n            int n = scanner.nextInt();\n            scanner.skip(\"(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])?\");\n            String b = scanner.nextLine();\n            String result = happyLadybugs(b);\n            bufferedWriter.write(result);\n            bufferedWriter.newLine();\n        }\n        bufferedWriter.close();\n        scanner.close();\n    }\n"]], "pred": {"ppl": 1.6106635332107544, "ppl_lower": 1.811894178390503, "ppl/lowercase_ppl": -1.2469894282086138, "ppl/zlib": 0.0005620828142950104, "Min_5.0% Prob": 5.508380850156148, "Min_10.0% Prob": 3.9522945213885534, "Min_20.0% Prob": 2.296364701358524, "Min_30.0% Prob": 1.58050171705515, "Min_40.0% Prob": 1.1904526836949694, "Min_50.0% Prob": 0.9527532153049524, "Min_60.0% Prob": 0.7952278838922312}}
{"hexsha": "712e63e3cbb226a50631cdb060500a83fbc9674d", "ext": "java", "lang": "Java", "content": "public class MinaComponentWithConfigurationTest extends CamelTestSupport {\n\n    @Test\n    public void testMinaComponentWithConfiguration() throws Exception {\n        MinaComponent comp = context.getComponent(\"mina\", MinaComponent.class);\n\n        MinaConfiguration cfg = new MinaConfiguration();\n        cfg.setTextline(true);\n\n        comp.setConfiguration(cfg);\n        assertSame(cfg, comp.getConfiguration());\n\n        MinaEndpoint e1 = (MinaEndpoint) comp.createEndpoint(\"mina://tcp://localhost:4455\");\n        MinaEndpoint e2 = (MinaEndpoint) comp.createEndpoint(\"mina://tcp://localhost:5566?sync=false\");\n\n        // should not be same\n        assertNotSame(e1, e2);\n        assertNotSame(e1.getConfiguration(), e2.getConfiguration());\n\n        e2.getConfiguration().setPort(5566);\n\n        assertEquals(true, e1.getConfiguration().isSync());\n        assertEquals(false, e2.getConfiguration().isSync());\n        assertEquals(true, e1.getConfiguration().isTextline());\n        assertEquals(true, e2.getConfiguration().isTextline());\n        assertEquals(4455, e1.getConfiguration().getPort());\n        assertEquals(5566, e2.getConfiguration().getPort());\n    }\n}", "item_id": 0, "repo": "grgrzybek/camel", "file": "components/camel-mina/src/test/java/org/apache/camel/component/mina/MinaComponentWithConfigurationTest.java", "last_update_at": "2022-02-22T12:00:36+00:00", "question_id": "712e63e3cbb226a50631cdb060500a83fbc9674d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MinaComponentWithConfigurationTest extends CamelTestSupport {\n    @Test\n    public void testMinaComponentWithConfiguration() throws Exception {\n        MinaComponent comp = context.getComponent(\"mina\", MinaComponent.class);\n        MinaConfiguration cfg = new MinaConfiguration();\n        cfg.setTextline(true);\n        comp.setConfiguration(cfg);\n        assertSame(cfg, comp.getConfiguration());\n        MinaEndpoint e1 = (MinaEndpoint) comp.createEndpoint(\"mina://tcp://localhost:4455\");\n        MinaEndpoint e2 = (MinaEndpoint) comp.createEndpoint(\"mina://tcp://localhost:5566?sync=false\");\n        // should not be same\n        assertNotSame(e1, e2);\n        assertNotSame(e1.getConfiguration(), e2.getConfiguration());\n        e2.getConfiguration().setPort(5566);\n        assertEquals(true, e1.getConfiguration().isSync());\n        assertEquals(false, e2.getConfiguration().isSync());\n        assertEquals(true, e1.getConfiguration().isTextline());\n        assertEquals(true, e2.getConfiguration().isTextline());\n        assertEquals(4455, e1.getConfiguration().getPort());\n        assertEquals(5566, e2.getConfiguration().getPort());\n    }\n"]], "pred": {"ppl": 1.720118761062622, "ppl_lower": 1.9773029088974, "ppl/lowercase_ppl": -1.2568991987556344, "ppl/zlib": 0.0014198778418092926, "Min_5.0% Prob": 5.285732120275497, "Min_10.0% Prob": 3.9077834071535054, "Min_20.0% Prob": 2.5173304216428236, "Min_30.0% Prob": 1.7749978026958426, "Min_40.0% Prob": 1.3496972658304554, "Min_50.0% Prob": 1.0833792729670126, "Min_60.0% Prob": 0.903575657520001}}
{"hexsha": "880abdb15b4618d03cbf39ecef14942bc5afac20", "ext": "java", "lang": "Java", "content": "@Tag(\"ExpirationPolicy\")\npublic class AlwaysExpiresExpirationPolicyTests {\n\n    private static final File JSON_FILE = new File(FileUtils.getTempDirectoryPath(), \"alwaysExpiresExpirationPolicy.json\");\n    private static final ObjectMapper MAPPER = JacksonObjectMapperFactory.builder()\n        .defaultTypingEnabled(true).build().toObjectMapper();\n\n    @Test\n    public void verifySerializeAnAlwaysExpiresExpirationPolicyToJson() throws IOException {\n        val policyWritten = new AlwaysExpiresExpirationPolicy();\n        MAPPER.writeValue(JSON_FILE, policyWritten);\n        val policyRead = MAPPER.readValue(JSON_FILE, AlwaysExpiresExpirationPolicy.class);\n        assertEquals(policyWritten, policyRead);\n    }\n\n    @Test\n    public void verifySerialization() {\n        val policyWritten = new AlwaysExpiresExpirationPolicy();\n        val result = SerializationUtils.serialize(policyWritten);\n        val policyRead = SerializationUtils.deserialize(result, AlwaysExpiresExpirationPolicy.class);\n        assertEquals(policyWritten, policyRead);\n    }\n}", "item_id": 0, "repo": "dgusoff/cas", "file": "core/cas-server-core-tickets/src/test/java/org/apereo/cas/ticket/expiration/AlwaysExpiresExpirationPolicyTests.java", "last_update_at": "2022-03-31T06:02:13+00:00", "question_id": "880abdb15b4618d03cbf39ecef14942bc5afac20_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Tag(\"ExpirationPolicy\")\npublic class AlwaysExpiresExpirationPolicyTests {\n    private static final File JSON_FILE = new File(FileUtils.getTempDirectoryPath(), \"alwaysExpiresExpirationPolicy.json\");\n    private static final ObjectMapper MAPPER = JacksonObjectMapperFactory.builder()\n        .defaultTypingEnabled(true).build().toObjectMapper();\n    @Test\n    public void verifySerializeAnAlwaysExpiresExpirationPolicyToJson() throws IOException {\n        val policyWritten = new AlwaysExpiresExpirationPolicy();\n        MAPPER.writeValue(JSON_FILE, policyWritten);\n        val policyRead = MAPPER.readValue(JSON_FILE, AlwaysExpiresExpirationPolicy.class);\n        assertEquals(policyWritten, policyRead);\n    }\n    @Test\n    public void verifySerialization() {\n        val policyWritten = new AlwaysExpiresExpirationPolicy();\n        val result = SerializationUtils.serialize(policyWritten);\n        val policyRead = SerializationUtils.deserialize(result, AlwaysExpiresExpirationPolicy.class);\n        assertEquals(policyWritten, policyRead);\n    }\n"]], "pred": {"ppl": 1.4040886163711548, "ppl_lower": 2.668489694595337, "ppl/lowercase_ppl": -2.892003955028354, "ppl/zlib": 0.0008907832563918446, "Min_5.0% Prob": 5.190191745758057, "Min_10.0% Prob": 3.031726845988521, "Min_20.0% Prob": 1.6651110760867596, "Min_30.0% Prob": 1.1255792456414597, "Min_40.0% Prob": 0.8471229710719652, "Min_50.0% Prob": 0.678522119446899, "Min_60.0% Prob": 0.5655812139207509}}
{"hexsha": "3ac31d012ac7695f73d7453958de0b80c1268f02", "ext": "java", "lang": "Java", "content": "public class SplitStringEveryNthChar {\n\n    public static List<String> usingSplitMethod(String text, int n) {\n        String[] results = text.split(\"(?<=\\\\G.{\" + n + \"})\");\n\n        return Arrays.asList(results);\n    }\n\n    public static List<String> usingSubstringMethod(String text, int n) {\n        List<String> results = new ArrayList<>();\n        int length = text.length();\n\n        for (int i = 0; i < length; i += n) {\n            results.add(text.substring(i, Math.min(length, i + n)));\n        }\n\n        return results;\n    }\n\n    public static List<String> usingPattern(String text, int n) {\n        List<String> results = new ArrayList<>();\n\n        Pattern pattern = Pattern.compile(\".{1,\" + n + \"}\");\n        Matcher matcher = pattern.matcher(text);\n        while (matcher.find()) {\n            String match = text.substring(matcher.start(), matcher.end());\n            results.add(match);\n        }\n\n        return results;\n    }\n\n    public static List<String> usingGuava(String text, int n) {\n        Iterable<String> parts = Splitter.fixedLength(n)\n            .split(text);\n\n        return ImmutableList.copyOf(parts);\n    }\n\n}", "item_id": 0, "repo": "nill-coffere/tutorials", "file": "core-java-modules/core-java-string-operations-4/src/main/java/com/baeldung/split/SplitStringEveryNthChar.java", "last_update_at": "2022-01-15T18:00:31+00:00", "question_id": "3ac31d012ac7695f73d7453958de0b80c1268f02_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SplitStringEveryNthChar {\n    public static List<String> usingSplitMethod(String text, int n) {\n        String[] results = text.split(\"(?<=\\\\G.{\" + n + \"})\");\n        return Arrays.asList(results);\n    }\n    public static List<String> usingSubstringMethod(String text, int n) {\n        List<String> results = new ArrayList<>();\n        int length = text.length();\n        for (int i = 0; i < length; i += n) {\n            results.add(text.substring(i, Math.min(length, i + n)));\n        }\n        return results;\n    }\n    public static List<String> usingPattern(String text, int n) {\n        List<String> results = new ArrayList<>();\n        Pattern pattern = Pattern.compile(\".{1,\" + n + \"}\");\n        Matcher matcher = pattern.matcher(text);\n        while (matcher.find()) {\n            String match = text.substring(matcher.start(), matcher.end());\n            results.add(match);\n        }\n        return results;\n    }\n    public static List<String> usingGuava(String text, int n) {\n        Iterable<String> parts = Splitter.fixedLength(n)\n            .split(text);\n        return ImmutableList.copyOf(parts);\n    }\n"]], "pred": {"ppl": 1.496347188949585, "ppl_lower": 1.9247702360153198, "ppl/lowercase_ppl": -1.6247217063143402, "ppl/zlib": 0.0009782207058280778, "Min_5.0% Prob": 5.065302938222885, "Min_10.0% Prob": 3.45012248284889, "Min_20.0% Prob": 1.9484586704577973, "Min_30.0% Prob": 1.3390449569374323, "Min_40.0% Prob": 1.006613788382609, "Min_50.0% Prob": 0.8046561407363264, "Min_60.0% Prob": 0.6731662733899662}}
{"hexsha": "04fcbab2b88b36ec9855fcaf98a48bdd402cce18", "ext": "java", "lang": "Java", "content": "public class PemEncrypt{\n\tstatic {\n\t\tif (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == null) {\n\t\t\tSecurity.addProvider(new BouncyCastleProvider());\n\t\t}\n\t}\n\t/**\n\t * Convert plain private key to PEM format and save to disk\n\t */\n    public static String storePrivateKey(byte[] privateKey, EccTypeEnums eccTypeEnums,\n    \t\tString destinationDirectory) throws Exception{\n\t\tCryptoKeyPair cryptoKeyPair = KeyUtils.getCryptKeyPair(privateKey, eccTypeEnums);\n    \tString encryptPkey = encryptPrivateKey(privateKey, eccTypeEnums);\n    \tString fileName = cryptoKeyPair.getAddress() + KeyFileTypeEnums.PEM_FILE.getKeyFilePostfix();\n\t\treturn storePrivateKey(encryptPkey, fileName, destinationDirectory);\n    }\n\n\tpublic static String storePrivateKey(String encryptKey,\n\t\t\t\t\t\t\t\t\t\t String fileName, String destinationDirectory) throws Exception{\n\t\tString filePath = FileOperationUtils.generateFilePath(\n\t\t\t\tfileName,\n\t\t\t\tdestinationDirectory);\n\t\tFileOperationUtils.writeFile(filePath, encryptKey);\n\t\treturn filePath;\n\t}\n    /**\n     * Encrypt private key\n     * @param privateKey\n     * @param eccTypeEnums\n     * @return Encrypted data\n     * @throws IOException\n     */\n    public static String encryptPrivateKey(byte[] privateKey, EccTypeEnums eccTypeEnums) \n    \t\tthrows Exception {\n       \tCryptoKeyPair cryptoKeyPair = KeyUtils.getCryptKeyPair(privateKey, eccTypeEnums);\n\t\tBigInteger key = new BigInteger(1, Numeric.hexStringToByteArray(cryptoKeyPair.getHexPrivateKey()));\n\n        //1. Encapsulate curve meta info and private key bytes in PKCS#8 format\n    \tASN1ObjectIdentifier curveOid = ECUtil.getNamedCurveOid(eccTypeEnums.getEccName());\n    \tX962Parameters params = new X962Parameters(curveOid);\n    \tECPrivateKey keyStructure = new ECPrivateKey(256, key,\n\t\t\t\tnew DERBitString(Numeric.hexStringToByteArray(cryptoKeyPair.getHexPublicKey())),\n\t\t\t\tnull);\n    \tPrivateKeyInfo privateKeyInfo = new PrivateKeyInfo(\n    \t\t\t\tnew AlgorithmIdentifier(X9ObjectIdentifiers.id_ecPublicKey, params),\n    \t\t\t\tkeyStructure);\n    \t\t\n    \t//2. Serialize the private key data to output stream\n    \tByteArrayOutputStream bos = new ByteArrayOutputStream();\n        PemWriter w = new PemWriter (new OutputStreamWriter(bos));\n    \ttry {\n    \t    ASN1Object o = (ASN1Object) privateKeyInfo.toASN1Primitive();\n    \t    w.writeObject (new PemObject (\"PRIVATE KEY\", o.getEncoded(\"DER\")));\n    \t    w.flush();\n    \t    //3. Gather result and return.\n    \t    return new String(bos.toByteArray());\n    \t}\n    \tfinally {\n    \t\ttry {\n    \t\t\tif(w != null){\n    \t\t\t    w.close();\n    \t\t\t}\n    \t\t}\n    \t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n    }\n\n    public static DecryptResult decryptFully(String encryptedKey) throws Exception{\n\t\tPemReader pemReader = new PemReader(new StringReader(encryptedKey));\n\t\tPemObject pemObject =pemReader.readPemObject();\n\t\ttry {\n\t\t\tPKCS8EncodedKeySpec encodedKeySpec = new PKCS8EncodedKeySpec(pemObject.getContent());\n\t\t\tKeyFactory keyFacotry = KeyFactory.getInstance(\"EC\", BouncyCastleProvider.PROVIDER_NAME);\n\t\t\tPrivateKey privateKey =  keyFacotry.generatePrivate(encodedKeySpec);\n\t\t\tBCECPrivateKey k = (BCECPrivateKey)privateKey;\n\t\t\tbyte[] rawkey = Numeric.toBytesPadded(k.getD(), 32);\n\t\t\tString curve = KeyUtils.getCurve(k);\n\t\t\treturn new DecryptResult(rawkey, curve);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif(pemReader != null){\n\t\t\t\t\tpemReader.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n\t}\n    /**\n     * Decrypt encrypt key\n     * @param encryptPrivateKey\n     * @return\n     * @throws IOException\n     */\n\tpublic static byte[] decryptPrivateKey(String encryptPrivateKey) throws Exception{\n\t\treturn decryptPrivateKey(new StringReader(encryptPrivateKey));\n    }   \n\t\n\t/**\n\t * Decrypt encrypt key from pem file\n\t * @param filePath\n\t * @return\n\t * @throws IOException\n\t */\n\tpublic static byte[] decryptPrivateKeyByFile(String filePath) \n\t\t\tthrows Exception{\n\t    FileInputStream fIn = null;\n\t    try {\n\t    \tfIn = new FileInputStream(filePath);\n\t    \treturn decryptPrivateKey(new InputStreamReader(fIn));\n\t    }\n\t    finally {\n    \t\ttry {\n    \t\t\tif(fIn != null) {\n    \t\t\t\tfIn.close();\n    \t\t\t}\n    \t\t}\n    \t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n    }\n\t\n\tprivate static byte[] decryptPrivateKey(Reader reader) throws Exception {\n\t\tPemReader pemReader = new PemReader(reader);\n\t\tPemObject pemObject =pemReader.readPemObject();\n\t    try {\n\t\t\tPKCS8EncodedKeySpec encodedKeySpec = new PKCS8EncodedKeySpec(pemObject.getContent());\n\t\t\tKeyFactory keyFacotry = KeyFactory.getInstance(\"EC\", BouncyCastleProvider.PROVIDER_NAME);\n\n\t\t\tPrivateKey privateKey =  keyFacotry.generatePrivate(encodedKeySpec);\n\t\t\tBCECPrivateKey bcecPrivateKey = (BCECPrivateKey)privateKey;\n\t\t    return Numeric.toBytesPadded(bcecPrivateKey.getD(),32);\n\t    }\n\t    finally {\n    \t\ttry {\n    \t\t\tif(pemReader != null){\n\t\t\t\t\tpemReader.close();\n    \t\t\t}\n    \t\t}\n    \t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n\t}\n}", "item_id": 0, "repo": "MaggieNgWu/Governance-Key", "file": "key-core/src/main/java/com/webank/keygen/encrypt/PemEncrypt.java", "last_update_at": "2022-02-10T08:29:51+00:00", "question_id": "04fcbab2b88b36ec9855fcaf98a48bdd402cce18_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PemEncrypt{\n\tstatic {\n\t\tif (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == null) {\n\t\t\tSecurity.addProvider(new BouncyCastleProvider());\n\t\t}\n\t}\n\t/**\n\t * Convert plain private key to PEM format and save to disk\n\t */\n    public static String storePrivateKey(byte[] privateKey, EccTypeEnums eccTypeEnums,\n    \t\tString destinationDirectory) throws Exception{\n\t\tCryptoKeyPair cryptoKeyPair = KeyUtils.getCryptKeyPair(privateKey, eccTypeEnums);\n    \tString encryptPkey = encryptPrivateKey(privateKey, eccTypeEnums);\n    \tString fileName = cryptoKeyPair.getAddress() + KeyFileTypeEnums.PEM_FILE.getKeyFilePostfix();\n\t\treturn storePrivateKey(encryptPkey, fileName, destinationDirectory);\n    }\n\tpublic static String storePrivateKey(String encryptKey,\n\t\t\t\t\t\t\t\t\t\t String fileName, String destinationDirectory) throws Exception{\n\t\tString filePath = FileOperationUtils.generateFilePath(\n\t\t\t\tfileName,\n\t\t\t\tdestinationDirectory);\n\t\tFileOperationUtils.writeFile(filePath, encryptKey);\n\t\treturn filePath;\n\t}\n    /**\n     * Encrypt private key\n     * @param privateKey\n     * @param eccTypeEnums\n     * @return Encrypted data\n     * @throws IOException\n     */\n    public static String encryptPrivateKey(byte[] privateKey, EccTypeEnums eccTypeEnums) \n    \t\tthrows Exception {\n       \tCryptoKeyPair cryptoKeyPair = KeyUtils.getCryptKeyPair(privateKey, eccTypeEnums);\n\t\tBigInteger key = new BigInteger(1, Numeric.hexStringToByteArray(cryptoKeyPair.getHexPrivateKey()));\n        //1. Encapsulate curve meta info and private key bytes in PKCS#8 format\n    \tASN1ObjectIdentifier curveOid = ECUtil.getNamedCurveOid(eccTypeEnums.getEccName());\n    \tX962Parameters params = new X962Parameters(curveOid);\n    \tECPrivateKey keyStructure = new ECPrivateKey(256, key,\n\t\t\t\tnew DERBitString(Numeric.hexStringToByteArray(cryptoKeyPair.getHexPublicKey())),\n\t\t\t\tnull);\n    \tPrivateKeyInfo privateKeyInfo = new PrivateKeyInfo(\n    \t\t\t\tnew AlgorithmIdentifier(X9ObjectIdentifiers.id_ecPublicKey, params),\n    \t\t\t\tkeyStructure);\n    \t\t\n    \t//2. Serialize the private key data to output stream\n    \tByteArrayOutputStream bos = new ByteArrayOutputStream();\n        PemWriter w = new PemWriter (new OutputStreamWriter(bos));\n    \ttry {\n    \t    ASN1Object o = (ASN1Object) privateKeyInfo.toASN1Primitive();\n    \t    w.writeObject (new PemObject (\"PRIVATE KEY\", o.getEncoded(\"DER\")));\n    \t    w.flush();\n    \t    //3. Gather result and return.\n    \t    return new String(bos.toByteArray());\n    \t}\n    \tfinally {\n    \t\ttry {\n    \t\t\tif(w != null){\n    \t\t\t    w.close();\n    \t\t\t}\n    \t\t}\n    \t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n    }\n    public static DecryptResult decryptFully(String encryptedKey) throws Exception{\n\t\tPemReader pemReader = new PemReader(new StringReader(encryptedKey));\n\t\tPemObject pemObject =pemReader.readPemObject();\n\t\ttry {\n\t\t\tPKCS8EncodedKeySpec encodedKeySpec = new PKCS8EncodedKeySpec(pemObject.getContent());\n\t\t\tKeyFactory keyFacotry = KeyFactory.getInstance(\"EC\", BouncyCastleProvider.PROVIDER_NAME);\n\t\t\tPrivateKey privateKey =  keyFacotry.generatePrivate(encodedKeySpec);\n\t\t\tBCECPrivateKey k = (BCECPrivateKey)privateKey;\n\t\t\tbyte[] rawkey = Numeric.toBytesPadded(k.getD(), 32);\n\t\t\tString curve = KeyUtils.getCurve(k);\n\t\t\treturn new DecryptResult(rawkey, curve);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif(pemReader != null){\n\t\t\t\t\tpemReader.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n\t}\n    /**\n     * Decrypt encrypt key\n     * @param encryptPrivateKey\n     * @return\n     * @throws IOException\n     */\n\tpublic static byte[] decryptPrivateKey(String encryptPrivateKey) throws Exception{\n\t\treturn decryptPrivateKey(new StringReader(encryptPrivateKey));\n    }   \n\t\n\t/**\n\t * Decrypt encrypt key from pem file\n\t * @param filePath\n\t * @return\n\t * @throws IOException\n\t */\n\tpublic static byte[] decryptPrivateKeyByFile(String filePath) \n\t\t\tthrows Exception{\n\t    FileInputStream fIn = null;\n\t    try {\n\t    \tfIn = new FileInputStream(filePath);\n\t    \treturn decryptPrivateKey(new InputStreamReader(fIn));\n\t    }\n\t    finally {\n    \t\ttry {\n    \t\t\tif(fIn != null) {\n    \t\t\t\tfIn.close();\n    \t\t\t}\n    \t\t}\n    \t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n    }\n\t\n\tprivate static byte[] decryptPrivateKey(Reader reader) throws Exception {\n\t\tPemReader pemReader = new PemReader(reader);\n\t\tPemObject pemObject =pemReader.readPemObject();\n\t    try {\n\t\t\tPKCS8EncodedKeySpec encodedKeySpec = new PKCS8EncodedKeySpec(pemObject.getContent());\n\t\t\tKeyFactory keyFacotry = KeyFactory.getInstance(\"EC\", BouncyCastleProvider.PROVIDER_NAME);\n\t\t\tPrivateKey privateKey =  keyFacotry.generatePrivate(encodedKeySpec);\n\t\t\tBCECPrivateKey bcecPrivateKey = (BCECPrivateKey)privateKey;\n\t\t    return Numeric.toBytesPadded(bcecPrivateKey.getD(),32);\n\t    }\n\t    finally {\n    \t\ttry {\n    \t\t\tif(pemReader != null){\n\t\t\t\t\tpemReader.close();\n    \t\t\t}\n    \t\t}\n    \t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n\t}\n"]], "pred": {"ppl": 2.233445167541504, "ppl_lower": 2.7013468742370605, "ppl/lowercase_ppl": -1.2367074721556084, "ppl/zlib": 0.0005515067340382173, "Min_5.0% Prob": 6.412986250484691, "Min_10.0% Prob": 5.001317638976901, "Min_20.0% Prob": 3.4847207747253717, "Min_30.0% Prob": 2.565234111804588, "Min_40.0% Prob": 1.9798776018080326, "Min_50.0% Prob": 1.6000245705596854, "Min_60.0% Prob": 1.3384153189754409}}
{"hexsha": "425452f7137aa855e46a387db6bb1411fe4a3107", "ext": "java", "lang": "Java", "content": "public final class JsonWriter {\n  public static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n  static <T> int sizeInBytes(Writer<T> writer, List<T> value) {\n    int length = value.size();\n    int sizeInBytes = 2; // []\n    if (length > 1) sizeInBytes += length - 1; // comma to join elements\n    for (int i = 0; i < length; i++) {\n      sizeInBytes += writer.sizeInBytes(value.get(i));\n    }\n    return sizeInBytes;\n  }\n\n  /** Inability to encode is a programming bug. */\n  public static <T> byte[] write(Writer<T> writer, T value) {\n    byte[] result = new byte[writer.sizeInBytes(value)];\n    WriteBuffer b = WriteBuffer.wrap(result);\n    try {\n      writer.write(value, b);\n    } catch (RuntimeException e) {\n      int lengthWritten = result.length;\n      for (int i = 0; i < result.length; i++) {\n        if (result[i] == 0) {\n          lengthWritten = i;\n          break;\n        }\n      }\n\n      // Don't use value directly in the message, as its toString might be implemented using this\n      // method. If that's the case, we'd stack overflow. Instead, emit what we've written so far.\n      String message =\n          format(\n              \"Bug found using %s to write %s as json. Wrote %s/%s bytes: %s\",\n              writer.getClass().getSimpleName(),\n              value.getClass().getSimpleName(),\n              lengthWritten,\n              result.length,\n              new String(result, 0, lengthWritten, UTF_8));\n      throw Platform.get().assertionError(message, e);\n    }\n    return result;\n  }\n\n  public static <T> byte[] writeList(Writer<T> writer, List<T> value) {\n    if (value.isEmpty()) return new byte[] {'[', ']'};\n    byte[] result = new byte[sizeInBytes(writer, value)];\n    writeList(writer, value, WriteBuffer.wrap(result));\n    return result;\n  }\n\n  public static <T> int writeList(Writer<T> writer, List<T> value, byte[] out,\n      int pos) {\n    if (value.isEmpty()) {\n      out[pos++] = '[';\n      out[pos++] = ']';\n      return 2;\n    }\n    int initialPos = pos;\n    WriteBuffer result = WriteBuffer.wrap(out, pos);\n    writeList(writer, value, result);\n    return result.pos() - initialPos;\n  }\n\n  public static <T> void writeList(Writer<T> writer, List<T> value, WriteBuffer b) {\n    b.writeByte('[');\n    for (int i = 0, length = value.size(); i < length; ) {\n      writer.write(value.get(i++), b);\n      if (i < length) b.writeByte(',');\n    }\n    b.writeByte(']');\n  }\n}", "item_id": 0, "repo": "mehrdad-shokri/brave", "file": "brave/src/main/java/brave/internal/codec/JsonWriter.java", "last_update_at": "2022-03-31T14:41:51+00:00", "question_id": "425452f7137aa855e46a387db6bb1411fe4a3107_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class JsonWriter {\n  public static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n  static <T> int sizeInBytes(Writer<T> writer, List<T> value) {\n    int length = value.size();\n    int sizeInBytes = 2; // []\n    if (length > 1) sizeInBytes += length - 1; // comma to join elements\n    for (int i = 0; i < length; i++) {\n      sizeInBytes += writer.sizeInBytes(value.get(i));\n    }\n    return sizeInBytes;\n  }\n  /** Inability to encode is a programming bug. */\n  public static <T> byte[] write(Writer<T> writer, T value) {\n    byte[] result = new byte[writer.sizeInBytes(value)];\n    WriteBuffer b = WriteBuffer.wrap(result);\n    try {\n      writer.write(value, b);\n    } catch (RuntimeException e) {\n      int lengthWritten = result.length;\n      for (int i = 0; i < result.length; i++) {\n        if (result[i] == 0) {\n          lengthWritten = i;\n          break;\n        }\n      }\n      // Don't use value directly in the message, as its toString might be implemented using this\n      // method. If that's the case, we'd stack overflow. Instead, emit what we've written so far.\n      String message =\n          format(\n              \"Bug found using %s to write %s as json. Wrote %s/%s bytes: %s\",\n              writer.getClass().getSimpleName(),\n              value.getClass().getSimpleName(),\n              lengthWritten,\n              result.length,\n              new String(result, 0, lengthWritten, UTF_8));\n      throw Platform.get().assertionError(message, e);\n    }\n    return result;\n  }\n  public static <T> byte[] writeList(Writer<T> writer, List<T> value) {\n    if (value.isEmpty()) return new byte[] {'[', ']'};\n    byte[] result = new byte[sizeInBytes(writer, value)];\n    writeList(writer, value, WriteBuffer.wrap(result));\n    return result;\n  }\n  public static <T> int writeList(Writer<T> writer, List<T> value, byte[] out,\n      int pos) {\n    if (value.isEmpty()) {\n      out[pos++] = '[';\n      out[pos++] = ']';\n      return 2;\n    }\n    int initialPos = pos;\n    WriteBuffer result = WriteBuffer.wrap(out, pos);\n    writeList(writer, value, result);\n    return result.pos() - initialPos;\n  }\n  public static <T> void writeList(Writer<T> writer, List<T> value, WriteBuffer b) {\n    b.writeByte('[');\n    for (int i = 0, length = value.size(); i < length; ) {\n      writer.write(value.get(i++), b);\n      if (i < length) b.writeByte(',');\n    }\n    b.writeByte(']');\n  }\n"]], "pred": {"ppl": 1.8770354986190796, "ppl_lower": 2.048583507537842, "ppl/lowercase_ppl": -1.1388848526272417, "ppl/zlib": 0.0007237858274127871, "Min_5.0% Prob": 6.474376414951525, "Min_10.0% Prob": 4.797312188458133, "Min_20.0% Prob": 2.975573364016298, "Min_30.0% Prob": 2.067149023140042, "Min_40.0% Prob": 1.5693595065798573, "Min_50.0% Prob": 1.2572524033616794, "Min_60.0% Prob": 1.0497237412511884}}
{"hexsha": "4fa044fef0f762a3d373af5618f17682dcae776a", "ext": "java", "lang": "Java", "content": "@MeshTestSetting(testSize = TestSize.EMPTY, startServer = false)\npublic class AdminGUIEndpointTest extends AbstractMeshTest {\n\n\t@Before\n\tpublic void setupVerticle() throws Exception {\n\t\tEndpointRegistry registry = mesh().endpointRegistry();\n\t\tregistry.register(AdminGUIEndpoint.class);\n\t\tregistry.register(AdminGUI2Endpoint.class);\n\t}\n\n\t@BeforeClass\n\tpublic static void cleanupConfig() {\n\t\tnew File(AdminGUIEndpoint.CONF_FILE).delete();\n\t\tnew File(AdminGUI2Endpoint.CONF_FILE).delete();\n\t}\n\n\t@Test\n\tpublic void testAdminConfigRendering() throws InterruptedException, ExecutionException, TimeoutException {\n\n\t\tHttpClient client = createHttpClient();\n\t\tCompletableFuture<String> future = new CompletableFuture<>();\n\t\tHttpClientRequest request = client.request(GET, \"/mesh-ui-v1/mesh-ui-config.js\", rh -> {\n\t\t\trh.bodyHandler(bh -> {\n\t\t\t\tif (rh.statusCode() == 200) {\n\t\t\t\t\tfuture.complete(bh.toString());\n\t\t\t\t} else {\n\t\t\t\t\tfuture.completeExceptionally(new Exception(\"Status code wrong {\" + rh.statusCode() + \"}\"));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\trequest.end();\n\n\t\tString response = future.get(10, TimeUnit.SECONDS);\n\t\t// String expectedUrl = \"localhost:\" + port;\n\t\t// assertTrue(\"The meshConfig.js file did not contain the expected url {\" + expectedUrl + \"} Response {\" + response + \"}\",\n\t\t// response.contains(expectedUrl));\n\t\t// System.out.println(response);\n\t\tassertTrue(\"The response string should not contain any html specific characters but it was {\" + response + \"} \", response.indexOf(\"<\") != 0);\n\n\t}\n\n\t@Test\n\tpublic void testRedirect() throws InterruptedException, ExecutionException {\n\t\tHttpClient client = createHttpClient();\n\t\tCompletableFuture<String> future = new CompletableFuture<>();\n\t\tHttpClientRequest request = client.request(GET, \"/\", rh -> {\n\t\t\tfuture.complete(rh.getHeader(\"Location\"));\n\t\t});\n\t\trequest.end();\n\t\tassertEquals(\"/mesh-ui/\", future.get());\n\t}\n}", "item_id": 0, "repo": "philippguertler/mesh", "file": "verticles/admin-gui/src/test/java/com/gentics/mesh/verticle/admin/AdminGUIEndpointTest.java", "last_update_at": "2022-03-31T04:11:06+00:00", "question_id": "4fa044fef0f762a3d373af5618f17682dcae776a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@MeshTestSetting(testSize = TestSize.EMPTY, startServer = false)\npublic class AdminGUIEndpointTest extends AbstractMeshTest {\n\t@Before\n\tpublic void setupVerticle() throws Exception {\n\t\tEndpointRegistry registry = mesh().endpointRegistry();\n\t\tregistry.register(AdminGUIEndpoint.class);\n\t\tregistry.register(AdminGUI2Endpoint.class);\n\t}\n\t@BeforeClass\n\tpublic static void cleanupConfig() {\n\t\tnew File(AdminGUIEndpoint.CONF_FILE).delete();\n\t\tnew File(AdminGUI2Endpoint.CONF_FILE).delete();\n\t}\n\t@Test\n\tpublic void testAdminConfigRendering() throws InterruptedException, ExecutionException, TimeoutException {\n\t\tHttpClient client = createHttpClient();\n\t\tCompletableFuture<String> future = new CompletableFuture<>();\n\t\tHttpClientRequest request = client.request(GET, \"/mesh-ui-v1/mesh-ui-config.js\", rh -> {\n\t\t\trh.bodyHandler(bh -> {\n\t\t\t\tif (rh.statusCode() == 200) {\n\t\t\t\t\tfuture.complete(bh.toString());\n\t\t\t\t} else {\n\t\t\t\t\tfuture.completeExceptionally(new Exception(\"Status code wrong {\" + rh.statusCode() + \"}\"));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\trequest.end();\n\t\tString response = future.get(10, TimeUnit.SECONDS);\n\t\t// String expectedUrl = \"localhost:\" + port;\n\t\t// assertTrue(\"The meshConfig.js file did not contain the expected url {\" + expectedUrl + \"} Response {\" + response + \"}\",\n\t\t// response.contains(expectedUrl));\n\t\t// System.out.println(response);\n\t\tassertTrue(\"The response string should not contain any html specific characters but it was {\" + response + \"} \", response.indexOf(\"<\") != 0);\n\t}\n\t@Test\n\tpublic void testRedirect() throws InterruptedException, ExecutionException {\n\t\tHttpClient client = createHttpClient();\n\t\tCompletableFuture<String> future = new CompletableFuture<>();\n\t\tHttpClientRequest request = client.request(GET, \"/\", rh -> {\n\t\t\tfuture.complete(rh.getHeader(\"Location\"));\n\t\t});\n\t\trequest.end();\n\t\tassertEquals(\"/mesh-ui/\", future.get());\n\t}\n"]], "pred": {"ppl": 2.2439792156219482, "ppl_lower": 2.676287889480591, "ppl/lowercase_ppl": -1.2179769068437474, "ppl/zlib": 0.0010496762667753215, "Min_5.0% Prob": 6.764294262590079, "Min_10.0% Prob": 5.327513076491275, "Min_20.0% Prob": 3.55059753446018, "Min_30.0% Prob": 2.5894852963239785, "Min_40.0% Prob": 2.0069134735948397, "Min_50.0% Prob": 1.614534959859596, "Min_60.0% Prob": 1.3468610094482985}}
{"hexsha": "00c5f865523219b167bfac68902ecabd5bc7eed0", "ext": "java", "lang": "Java", "content": "public abstract class Numbers {\n\n\n  /**\n   * Checks whether tow numbers have equal values (even they are instances of different classes).\n   *\n   * @param x  the first number.\n   * @param y  the second number.\n   * @return   whether they're equal.\n   */\n  public static boolean valuesAreEqual(@Nullable final Number x, @Nullable final Number y) {\n    //noinspection NumberEquality\n    if (x == y) return true;\n    //noinspection SimplifiableIfStatement\n    if (x == null || y == null) return false;\n    return x.getClass() == y.getClass() ? x.equals(y) : x.toString().equals(y.toString());\n  }\n\n\n  /**\n   * Converts an arbitrary number to the specified class of Number.\n   * @param <N>            desired type of number.\n   * @param numberClass    desired class of number.\n   * @param number         the number to convert (nulls are possible).\n   * @return               the converted number.\n   */\n  @SuppressWarnings(\"unchecked\")\n  @Contract(value = \"_,!null -> !null; _,null -> null\", pure = true)\n  public static <N extends Number> N convertNumber(final Class<N> numberClass, final Number number) {\n    if (number == null) return null;\n    if (numberClass.isAssignableFrom(number.getClass())) return (N) number;\n\n    if (numberClass == Byte.class || numberClass == byte.class) return (N) Byte.valueOf(number.byteValue());\n    if (numberClass == Short.class || numberClass == short.class) return (N) Short.valueOf(number.shortValue());\n    if (numberClass == Integer.class || numberClass == int.class) return (N) Integer.valueOf(number.intValue());\n    if (numberClass == Long.class || numberClass == long.class) return (N) Long.valueOf(number.longValue());\n    if (numberClass == Float.class || numberClass == float.class) return (N) Float.valueOf(number.floatValue());\n    if (numberClass == Double.class || numberClass == double.class) return (N) Double.valueOf(number.doubleValue());\n    if (numberClass == BigInteger.class) return (N) new BigInteger(number.toString());\n    if (numberClass == BigDecimal.class) return (N) new BigDecimal(number.toString());\n\n    String message =\n        String.format(\"Unknown how to convert value (%s) of type %s to %s.\",\n                      number.toString(),\n                      number.getClass().getCanonicalName(),\n                      numberClass.getCanonicalName());\n    throw new IllegalArgumentException(message);\n  }\n\n  @Contract(value = \"!null -> !null; null -> null\", pure = true)\n  public static Number convertNumberSmartly(final BigDecimal decimal) {\n    if (decimal == null) return null;\n    if (decimal.equals(Numbers.DECIMAL_ZERO)) return BYTE_ZERO;\n\n    final int precision = decimal.precision();\n    final int scale = decimal.scale();\n\n    Number num;\n    if (scale == 0) {\n      try {\n        if (precision <= 19 && decimal.compareTo(Numbers.DECIMAL_MIN_LONG) >= 0\n                            && decimal.compareTo(Numbers.DECIMAL_MAX_LONG) <= 0) {\n          long v = decimal.longValueExact();\n          if (-128 <= v && v <= 127) num = (byte) v;\n          else if (-32768 <= v && v <= 32767) num = (short) v;\n          else if (Integer.MIN_VALUE <= v && v <= Integer.MAX_VALUE) num = (int) v;\n          else num = v;\n        }\n        else {\n          num = decimal.toBigIntegerExact();\n        }\n      }\n      catch (ArithmeticException ae) {\n        num = decimal;\n      }\n    }\n    else {\n      if (precision <= 6) {\n        num = decimal.floatValue();\n      }\n      else if (precision <= 15) {\n        num = decimal.doubleValue();\n      }\n      else {\n        num = decimal;\n      }\n    }\n\n    return num;\n  }\n\n  public static int parseIntSafe(@Nullable final String str) {\n    if (str == null) {\n      return 0;\n    }\n    try {\n      final String s = str.trim();\n      if (s.isEmpty()) return 0;\n      if (s.charAt(0) == '+') return Integer.parseInt(s.substring(1));\n      return Integer.parseInt(s);\n    }\n    catch (NumberFormatException e) {\n      return 0;\n    }\n  }\n\n\n  public static long parseLongSafe(@Nullable final String str) {\n    if (str == null) {\n      return 0;\n    }\n    try {\n      final String s = str.trim();\n      if (s.isEmpty()) return 0L;\n      if (s.charAt(0) == '+') return Long.parseLong(s.substring(1));\n      return Long.parseLong(s);\n    }\n    catch (NumberFormatException e) {\n      return 0;\n    }\n  }\n\n\n  public static final Byte       BYTE_ZERO        = (byte) 0;\n  public static final BigDecimal DECIMAL_ZERO     = new BigDecimal(0);\n  public static final BigDecimal DECIMAL_MIN_LONG = new BigDecimal(Long.MIN_VALUE);\n  public static final BigDecimal DECIMAL_MAX_LONG = new BigDecimal(Long.MAX_VALUE);\n\n}", "item_id": 0, "repo": "leo-from-spb/jdba", "file": "dekaf-jdbc/src/utils/Numbers.java", "last_update_at": "2022-01-15T22:04:27+00:00", "question_id": "00c5f865523219b167bfac68902ecabd5bc7eed0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class Numbers {\n  /**\n   * Checks whether tow numbers have equal values (even they are instances of different classes).\n   *\n   * @param x  the first number.\n   * @param y  the second number.\n   * @return   whether they're equal.\n   */\n  public static boolean valuesAreEqual(@Nullable final Number x, @Nullable final Number y) {\n    //noinspection NumberEquality\n    if (x == y) return true;\n    //noinspection SimplifiableIfStatement\n    if (x == null || y == null) return false;\n    return x.getClass() == y.getClass() ? x.equals(y) : x.toString().equals(y.toString());\n  }\n  /**\n   * Converts an arbitrary number to the specified class of Number.\n   * @param <N>            desired type of number.\n   * @param numberClass    desired class of number.\n   * @param number         the number to convert (nulls are possible).\n   * @return               the converted number.\n   */\n  @SuppressWarnings(\"unchecked\")\n  @Contract(value = \"_,!null -> !null; _,null -> null\", pure = true)\n  public static <N extends Number> N convertNumber(final Class<N> numberClass, final Number number) {\n    if (number == null) return null;\n    if (numberClass.isAssignableFrom(number.getClass())) return (N) number;\n    if (numberClass == Byte.class || numberClass == byte.class) return (N) Byte.valueOf(number.byteValue());\n    if (numberClass == Short.class || numberClass == short.class) return (N) Short.valueOf(number.shortValue());\n    if (numberClass == Integer.class || numberClass == int.class) return (N) Integer.valueOf(number.intValue());\n    if (numberClass == Long.class || numberClass == long.class) return (N) Long.valueOf(number.longValue());\n    if (numberClass == Float.class || numberClass == float.class) return (N) Float.valueOf(number.floatValue());\n    if (numberClass == Double.class || numberClass == double.class) return (N) Double.valueOf(number.doubleValue());\n    if (numberClass == BigInteger.class) return (N) new BigInteger(number.toString());\n    if (numberClass == BigDecimal.class) return (N) new BigDecimal(number.toString());\n    String message =\n        String.format(\"Unknown how to convert value (%s) of type %s to %s.\",\n                      number.toString(),\n                      number.getClass().getCanonicalName(),\n                      numberClass.getCanonicalName());\n    throw new IllegalArgumentException(message);\n  }\n  @Contract(value = \"!null -> !null; null -> null\", pure = true)\n  public static Number convertNumberSmartly(final BigDecimal decimal) {\n    if (decimal == null) return null;\n    if (decimal.equals(Numbers.DECIMAL_ZERO)) return BYTE_ZERO;\n    final int precision = decimal.precision();\n    final int scale = decimal.scale();\n    Number num;\n    if (scale == 0) {\n      try {\n        if (precision <= 19 && decimal.compareTo(Numbers.DECIMAL_MIN_LONG) >= 0\n                            && decimal.compareTo(Numbers.DECIMAL_MAX_LONG) <= 0) {\n          long v = decimal.longValueExact();\n          if (-128 <= v && v <= 127) num = (byte) v;\n          else if (-32768 <= v && v <= 32767) num = (short) v;\n          else if (Integer.MIN_VALUE <= v && v <= Integer.MAX_VALUE) num = (int) v;\n          else num = v;\n        }\n        else {\n          num = decimal.toBigIntegerExact();\n        }\n      }\n      catch (ArithmeticException ae) {\n        num = decimal;\n      }\n    }\n    else {\n      if (precision <= 6) {\n        num = decimal.floatValue();\n      }\n      else if (precision <= 15) {\n        num = decimal.doubleValue();\n      }\n      else {\n        num = decimal;\n      }\n    }\n    return num;\n  }\n  public static int parseIntSafe(@Nullable final String str) {\n    if (str == null) {\n      return 0;\n    }\n    try {\n      final String s = str.trim();\n      if (s.isEmpty()) return 0;\n      if (s.charAt(0) == '+') return Integer.parseInt(s.substring(1));\n      return Integer.parseInt(s);\n    }\n    catch (NumberFormatException e) {\n      return 0;\n    }\n  }\n  public static long parseLongSafe(@Nullable final String str) {\n    if (str == null) {\n      return 0;\n    }\n    try {\n      final String s = str.trim();\n      if (s.isEmpty()) return 0L;\n      if (s.charAt(0) == '+') return Long.parseLong(s.substring(1));\n      return Long.parseLong(s);\n    }\n    catch (NumberFormatException e) {\n      return 0;\n    }\n  }\n  public static final Byte       BYTE_ZERO        = (byte) 0;\n  public static final BigDecimal DECIMAL_ZERO     = new BigDecimal(0);\n  public static final BigDecimal DECIMAL_MIN_LONG = new BigDecimal(Long.MIN_VALUE);\n  public static final BigDecimal DECIMAL_MAX_LONG = new BigDecimal(Long.MAX_VALUE);\n"]], "pred": {"ppl": 1.6626056432724, "ppl_lower": 1.9004487991333008, "ppl/lowercase_ppl": -1.262997058207217, "ppl/zlib": 0.0003788271507857593, "Min_5.0% Prob": 5.339230415867824, "Min_10.0% Prob": 3.8809226061783586, "Min_20.0% Prob": 2.384626308054316, "Min_30.0% Prob": 1.6699087883960577, "Min_40.0% Prob": 1.2647698618571814, "Min_50.0% Prob": 1.015802075213401, "Min_60.0% Prob": 0.8478682381416205}}
{"hexsha": "6c7fa746468082c1b73f6c4eaff43b6c3bdeef3f", "ext": "java", "lang": "Java", "content": "public class TestableTrustKit extends TrustKit {\n    private TestableTrustKit(Context context, TrustKitConfiguration trustKitConfiguration,\n                             BackgroundReporter reporter) {\n        super(context, trustKitConfiguration);\n        TestableTrustManagerBuilder.setReporter(reporter);\n    }\n\n\n    public static TrustKit initializeWithNetworkSecurityConfiguration(@NonNull Context context,\n                                                                      BackgroundReporter reporter) {\n        TrustKit.initializeWithNetworkSecurityConfiguration(context);\n        TestableTrustManagerBuilder.setReporter(reporter);\n        return TrustKit.getInstance();\n    }\n\n    // This lets us directly specify domain settings without parsing an XML file and inject/mock\n    // the background reporter\n    public static void init(@NonNull Set<DomainPinningPolicy> domainConfigSet,\n                            @NonNull Context context,\n                            BackgroundReporter reporter) {\n        trustKitInstance = new TrustKit(context, new TestableTrustKitConfiguration(domainConfigSet));\n        TestableTrustManagerBuilder.setReporter(reporter);\n    }\n\n\n    public static void init(@NonNull Set<DomainPinningPolicy> domainConfigSet,\n                            boolean shouldOverridePins,\n                            @Nullable Set<Certificate> debugCaCerts,\n                            @NonNull Context context,\n                            BackgroundReporter reporter) {\n        trustKitInstance = new TrustKit(context, new TestableTrustKitConfiguration(domainConfigSet,\n                shouldOverridePins, debugCaCerts));\n        TestableTrustManagerBuilder.setReporter(reporter);\n    }\n\n    public static void reset() {\n        trustKitInstance = null;\n        TestableTrustManagerBuilder.reset();\n    }\n}", "item_id": 0, "repo": "avboy1337/TrustKit-Android", "file": "trustkit/src/androidTest/java/com/datatheorem/android/trustkit/TestableTrustKit.java", "last_update_at": "2022-03-30T08:46:50+00:00", "question_id": "6c7fa746468082c1b73f6c4eaff43b6c3bdeef3f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestableTrustKit extends TrustKit {\n    private TestableTrustKit(Context context, TrustKitConfiguration trustKitConfiguration,\n                             BackgroundReporter reporter) {\n        super(context, trustKitConfiguration);\n        TestableTrustManagerBuilder.setReporter(reporter);\n    }\n    public static TrustKit initializeWithNetworkSecurityConfiguration(@NonNull Context context,\n                                                                      BackgroundReporter reporter) {\n        TrustKit.initializeWithNetworkSecurityConfiguration(context);\n        TestableTrustManagerBuilder.setReporter(reporter);\n        return TrustKit.getInstance();\n    }\n    // This lets us directly specify domain settings without parsing an XML file and inject/mock\n    // the background reporter\n    public static void init(@NonNull Set<DomainPinningPolicy> domainConfigSet,\n                            @NonNull Context context,\n                            BackgroundReporter reporter) {\n        trustKitInstance = new TrustKit(context, new TestableTrustKitConfiguration(domainConfigSet));\n        TestableTrustManagerBuilder.setReporter(reporter);\n    }\n    public static void init(@NonNull Set<DomainPinningPolicy> domainConfigSet,\n                            boolean shouldOverridePins,\n                            @Nullable Set<Certificate> debugCaCerts,\n                            @NonNull Context context,\n                            BackgroundReporter reporter) {\n        trustKitInstance = new TrustKit(context, new TestableTrustKitConfiguration(domainConfigSet,\n                shouldOverridePins, debugCaCerts));\n        TestableTrustManagerBuilder.setReporter(reporter);\n    }\n    public static void reset() {\n        trustKitInstance = null;\n        TestableTrustManagerBuilder.reset();\n    }\n"]], "pred": {"ppl": 2.330674886703491, "ppl_lower": 2.68452525138855, "ppl/lowercase_ppl": -1.167044501423503, "ppl/zlib": 0.0018315105553735433, "Min_5.0% Prob": 6.798939895629883, "Min_10.0% Prob": 5.608644068241119, "Min_20.0% Prob": 3.766889645729536, "Min_30.0% Prob": 2.716635333112449, "Min_40.0% Prob": 2.0912872788346846, "Min_50.0% Prob": 1.6861682242801037, "Min_60.0% Prob": 1.4124443191927647}}
{"hexsha": "4d4db1fbdc6bb8dd3fe1f879ace2edc5f528e17e", "ext": "java", "lang": "Java", "content": "public abstract class AbstractExternalLinkUpdater \nimplements ExternalLinkUpdater {\n\n    protected final Log logger = LogFactory.getLog(getClass());\n    \n    private CSXDAO csxdao;\n    \n    public void setCSXDAO(CSXDAO csxdao) {\n        this.csxdao = csxdao;\n    } //- setCSXDAO\n    \n    private String label;\n    \n    /**\n     * Sets the label that identifies this external source within the database\n     * @param label A label to identify the external source. <b>Note:</b> This\n     * value must match a value in the links_types table within the database.\n     */\n    public void setLabel(String label) {\n        this.label = label;\n    } //- setLabel\n    \n    /* (non-Javadoc)\n     * @see edu.psu.citeseerx.updates.ExternalLinkUpdater#getPapersNoELink(java.lang.Long, java.lang.String)\n     */\n    public List<String> getPapersNoELink(Long amount, String lastID) {\n        return csxdao.getPapersNoELink(label, lastID, amount);\n    } //- getPapersNoELink\n\n    /* (non-Javadoc)\n     * @see edu.psu.citeseerx.updates.ExternalLinkUpdater#updateELinkForPaper(java.lang.String)\n     */\n    public void updateELinkForPaper(String doi) {\n\n        try {\n            Document doc = csxdao.getDocumentFromDB(doi);\n            if (doc != null) {\n                updateELinkForPaper(doc);\n            }else{\n                logger.info(\"No document was found for doi: \" + doi);\n            }\n        }catch (DataAccessException e) {\n            logger.error(\"An error occured updating external links for \" +\n            \t\t\"document: \" + doi, e);\n        }      \n    } //- updateELinkForPaper\n\n\n    /* (non-Javadoc)\n     * @see edu.psu.citeseerx.updates.ExternalLinkUpdater#updateELinkForPaper(edu.psu.citeseerx.domain.Document)\n     */\n    public void updateELinkForPaper(Document doc) {\n        try {\n            String urlPortion = getUrlForPaper(doc);\n            String doi = doc.getDatum(Document.DOI_KEY);\n                \n            if (urlPortion != null) {\n                ExternalLink eLink = new ExternalLink();\n                eLink.setLabel(label);\n                eLink.setPaperID(doi);\n                eLink.setUrl(urlPortion);\n                csxdao.updateExternalLink(eLink);\n            }else{\n                if (csxdao.getExternalLinkExist(label, doi)) {\n                    // The document has an elink for label but it's a wrong one\n                    csxdao.deleteExternalLink(doi, label);\n                }\n            }\n        }catch (DataAccessException e) {\n            logger.error(\"An error occured updating external links for \" +\n                    \"document: \" + doc.getDatum(Document.DOI_KEY), e);\n        }\n        \n    } //- updateELinkForPaper\n\n    \n    /* (non-Javadoc)\n     * @see edu.psu.citeseerx.updates.ExternalLinkUpdater#updateExternalLinks()\n     */\n    public void updateExternalLinks() {\n        String lastID = \"\";\n        boolean finished = false;\n        \n        Long amount = new Long(1000);\n        List<String> docIDs = new ArrayList<String>();\n        logger.info(\"Starting updates for label: \" + label);\n        do {\n            docIDs = getPapersNoELink(amount, lastID);\n            if (docIDs.isEmpty()) {\n                finished = true;\n            }else{\n                for (String doi : docIDs) {\n                    logger.info(\"Updating External Link for document: \" + doi + \n                            \" using \" + label + \" label\");\n                    updateELinkForPaper(doi);\n                    logger.info(\"External Link for document: \" + doi + \n                            \" using \" + label + \" label has been updated\");\n                }\n                lastID = docIDs.get(docIDs.size()-1);\n            }\n        }while(!finished);\n        logger.info(\"Updates for label: \" + label + \" has finished\");\n        \n    } //- updateExternalLinks\n    \n    /* (non-Javadoc)\n     * @see edu.psu.citeseerx.updates.UpdateListener#handleUpdate(edu.psu.citeseerx.domain.Document)\n     */\n    public void handleUpdate(Document doc) {\n        logger.trace(\"Handling update for: \" + doc.getDatum(Document.DOI_KEY));\n        updateELinkForPaper(doc);\n        logger.trace(\"Update for: \" + doc.getDatum(Document.DOI_KEY) + \n                \" finished\");\n    } //- handleUpdate\n\n    /**\n     * Child classes must override this method.\n     * @see edu.psu.citeseerx.updates.external.links.ExternalLinkUpdater#getUrlForPaper(edu.psu.citeseerx.domain.Document)\n     */\n    public String getUrlForPaper(Document doc) {\n        return null;\n    } //- getUrlForPaper\n}", "item_id": 0, "repo": "gaybro8777/CiteSeerX", "file": "src/java/edu/psu/citeseerx/updates/external/links/AbstractExternalLinkUpdater.java", "last_update_at": "2022-03-15T23:59:53+00:00", "question_id": "4d4db1fbdc6bb8dd3fe1f879ace2edc5f528e17e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class AbstractExternalLinkUpdater \nimplements ExternalLinkUpdater {\n    protected final Log logger = LogFactory.getLog(getClass());\n    private CSXDAO csxdao;\n    public void setCSXDAO(CSXDAO csxdao) {\n        this.csxdao = csxdao;\n    } //- setCSXDAO\n    private String label;\n    /**\n     * Sets the label that identifies this external source within the database\n     * @param label A label to identify the external source. <b>Note:</b> This\n     * value must match a value in the links_types table within the database.\n     */\n    public void setLabel(String label) {\n        this.label = label;\n    } //- setLabel\n    /* (non-Javadoc)\n     * @see edu.psu.citeseerx.updates.ExternalLinkUpdater#getPapersNoELink(java.lang.Long, java.lang.String)\n     */\n    public List<String> getPapersNoELink(Long amount, String lastID) {\n        return csxdao.getPapersNoELink(label, lastID, amount);\n    } //- getPapersNoELink\n    /* (non-Javadoc)\n     * @see edu.psu.citeseerx.updates.ExternalLinkUpdater#updateELinkForPaper(java.lang.String)\n     */\n    public void updateELinkForPaper(String doi) {\n        try {\n            Document doc = csxdao.getDocumentFromDB(doi);\n            if (doc != null) {\n                updateELinkForPaper(doc);\n            }else{\n                logger.info(\"No document was found for doi: \" + doi);\n            }\n        }catch (DataAccessException e) {\n            logger.error(\"An error occured updating external links for \" +\n            \t\t\"document: \" + doi, e);\n        }      \n    } //- updateELinkForPaper\n    /* (non-Javadoc)\n     * @see edu.psu.citeseerx.updates.ExternalLinkUpdater#updateELinkForPaper(edu.psu.citeseerx.domain.Document)\n     */\n    public void updateELinkForPaper(Document doc) {\n        try {\n            String urlPortion = getUrlForPaper(doc);\n            String doi = doc.getDatum(Document.DOI_KEY);\n            if (urlPortion != null) {\n                ExternalLink eLink = new ExternalLink();\n                eLink.setLabel(label);\n                eLink.setPaperID(doi);\n                eLink.setUrl(urlPortion);\n                csxdao.updateExternalLink(eLink);\n            }else{\n                if (csxdao.getExternalLinkExist(label, doi)) {\n                    // The document has an elink for label but it's a wrong one\n                    csxdao.deleteExternalLink(doi, label);\n                }\n            }\n        }catch (DataAccessException e) {\n            logger.error(\"An error occured updating external links for \" +\n                    \"document: \" + doc.getDatum(Document.DOI_KEY), e);\n        }\n    } //- updateELinkForPaper\n    /* (non-Javadoc)\n     * @see edu.psu.citeseerx.updates.ExternalLinkUpdater#updateExternalLinks()\n     */\n    public void updateExternalLinks() {\n        String lastID = \"\";\n        boolean finished = false;\n        Long amount = new Long(1000);\n        List<String> docIDs = new ArrayList<String>();\n        logger.info(\"Starting updates for label: \" + label);\n        do {\n            docIDs = getPapersNoELink(amount, lastID);\n            if (docIDs.isEmpty()) {\n                finished = true;\n            }else{\n                for (String doi : docIDs) {\n                    logger.info(\"Updating External Link for document: \" + doi + \n                            \" using \" + label + \" label\");\n                    updateELinkForPaper(doi);\n                    logger.info(\"External Link for document: \" + doi + \n                            \" using \" + label + \" label has been updated\");\n                }\n                lastID = docIDs.get(docIDs.size()-1);\n            }\n        }while(!finished);\n        logger.info(\"Updates for label: \" + label + \" has finished\");\n    } //- updateExternalLinks\n    /* (non-Javadoc)\n     * @see edu.psu.citeseerx.updates.UpdateListener#handleUpdate(edu.psu.citeseerx.domain.Document)\n     */\n    public void handleUpdate(Document doc) {\n        logger.trace(\"Handling update for: \" + doc.getDatum(Document.DOI_KEY));\n        updateELinkForPaper(doc);\n        logger.trace(\"Update for: \" + doc.getDatum(Document.DOI_KEY) + \n                \" finished\");\n    } //- handleUpdate\n    /**\n     * Child classes must override this method.\n     * @see edu.psu.citeseerx.updates.external.links.ExternalLinkUpdater#getUrlForPaper(edu.psu.citeseerx.domain.Document)\n     */\n    public String getUrlForPaper(Document doc) {\n        return null;\n    } //- getUrlForPaper\n"]], "pred": {"ppl": 1.820633053779602, "ppl_lower": 1.9884904623031616, "ppl/lowercase_ppl": -1.1471859675540408, "ppl/zlib": 0.0004968360467299337, "Min_5.0% Prob": 5.732701002382765, "Min_10.0% Prob": 4.189079008850396, "Min_20.0% Prob": 2.746318056302912, "Min_30.0% Prob": 1.94958147192313, "Min_40.0% Prob": 1.4853878428471847, "Min_50.0% Prob": 1.1961980665361402, "Min_60.0% Prob": 0.9990391774531484}}
{"hexsha": "ab3a47d4f901cc5b98e69815713f8762f24f7642", "ext": "java", "lang": "Java", "content": "public class GLTFImporter {\n\n  private static final Logger logger = LoggerFactory.getLogger(GLTFImporter.class);\n  /**\n   * Default GLTFImporter instance\n   */\n  public static final GLTFImporter instance = new GLTFImporter();\n\n  private BufferIO bufferIO = new DefaultBufferIO();\n\n  private final ObjectMapper mapper = new ObjectMapper();\n\n  public GLTFImporter() {\n    mapper.registerModule(JomlModule.getModule());\n  }\n\n  public GLTF load(URI uri) {\n    try {\n      InputStream jsonStream;\n\n      if (uri.toString().endsWith(\".glb\")) {\n        logger.info(\"Loading .glb file: \" + uri.toString());\n        GLBLoader glbLoader = new GLBLoader(this);\n        glbLoader.procesGLB(uri);\n        jsonStream = new ByteBufferBackedInputStream(\n            glbLoader.jsonData().order(ByteOrder.LITTLE_ENDIAN));\n      } else {\n        jsonStream = new ByteBufferBackedInputStream(\n            bufferIO.getDirectByteBuffer(uri).order(ByteOrder.LITTLE_ENDIAN));\n      }\n\n      GLTF gltf = new GLTF(this, uri);\n      ObjectReader reader = mapper.setInjectableValues(injectGLTF(gltf)).readerForUpdating(gltf);\n      reader.readValue(jsonStream);\n      gltf.applyLookupMap();\n\n      boolean valid = validateGLTF(gltf);\n\n      return gltf;\n    } catch (Exception e) {\n      logger.error(\"Error loading gltf file: \" + uri.toString());\n      logger.error(e.getLocalizedMessage());\n      e.printStackTrace();\n      return null;\n    }\n  }\n\n  private boolean validateGLTF(GLTF gltf) {\n    ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n    Validator validator = factory.getValidator();\n\n    Set<ConstraintViolation<GLTF>> violations = validator.validate(gltf);\n\n    boolean ret = true;\n    for (ConstraintViolation<GLTF> violation : violations) {\n      ret = false;\n      logger.error(violation.getMessage());\n    }\n    assert ret : violations;\n    return ret;\n  }\n\n  /**\n   * Inject reference to base GLTF into each node, used for index resolution Also a\n   * RelativePathResolver, called to get a stream from a path\n   *\n   * @param gltf\n   * @return\n   */\n  private InjectableValues injectGLTF(GLTF gltf) {\n    InjectableValues.Std iv = new InjectableValues.Std();\n    iv.addValue(GLTF.class, gltf);\n    return iv;\n  }\n\n  public void setBufferIO(BufferIO bufferIO) {\n    this.bufferIO = bufferIO;\n  }\n\n  BufferIO getBufferIO() {\n    return this.bufferIO;\n  }\n\n  /**\n   * Route bufferIO function through this to ensure little endian.\n   *\n   * @param uri\n   * @return\n   */\n  public ByteBuffer getDirectByteBuffer(URI uri) {\n    return bufferIO.getDirectByteBuffer(uri).order(ByteOrder.LITTLE_ENDIAN).rewind();\n  }\n}", "item_id": 0, "repo": "MESLewis/SimpleGLTF2", "file": "core/src/main/java/com/meslewis/simplegltf2/GLTFImporter.java", "last_update_at": "2022-02-23T09:32:44+00:00", "question_id": "ab3a47d4f901cc5b98e69815713f8762f24f7642_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GLTFImporter {\n  private static final Logger logger = LoggerFactory.getLogger(GLTFImporter.class);\n  /**\n   * Default GLTFImporter instance\n   */\n  public static final GLTFImporter instance = new GLTFImporter();\n  private BufferIO bufferIO = new DefaultBufferIO();\n  private final ObjectMapper mapper = new ObjectMapper();\n  public GLTFImporter() {\n    mapper.registerModule(JomlModule.getModule());\n  }\n  public GLTF load(URI uri) {\n    try {\n      InputStream jsonStream;\n      if (uri.toString().endsWith(\".glb\")) {\n        logger.info(\"Loading .glb file: \" + uri.toString());\n        GLBLoader glbLoader = new GLBLoader(this);\n        glbLoader.procesGLB(uri);\n        jsonStream = new ByteBufferBackedInputStream(\n            glbLoader.jsonData().order(ByteOrder.LITTLE_ENDIAN));\n      } else {\n        jsonStream = new ByteBufferBackedInputStream(\n            bufferIO.getDirectByteBuffer(uri).order(ByteOrder.LITTLE_ENDIAN));\n      }\n      GLTF gltf = new GLTF(this, uri);\n      ObjectReader reader = mapper.setInjectableValues(injectGLTF(gltf)).readerForUpdating(gltf);\n      reader.readValue(jsonStream);\n      gltf.applyLookupMap();\n      boolean valid = validateGLTF(gltf);\n      return gltf;\n    } catch (Exception e) {\n      logger.error(\"Error loading gltf file: \" + uri.toString());\n      logger.error(e.getLocalizedMessage());\n      e.printStackTrace();\n      return null;\n    }\n  }\n  private boolean validateGLTF(GLTF gltf) {\n    ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n    Validator validator = factory.getValidator();\n    Set<ConstraintViolation<GLTF>> violations = validator.validate(gltf);\n    boolean ret = true;\n    for (ConstraintViolation<GLTF> violation : violations) {\n      ret = false;\n      logger.error(violation.getMessage());\n    }\n    assert ret : violations;\n    return ret;\n  }\n  /**\n   * Inject reference to base GLTF into each node, used for index resolution Also a\n   * RelativePathResolver, called to get a stream from a path\n   *\n   * @param gltf\n   * @return\n   */\n  private InjectableValues injectGLTF(GLTF gltf) {\n    InjectableValues.Std iv = new InjectableValues.Std();\n    iv.addValue(GLTF.class, gltf);\n    return iv;\n  }\n  public void setBufferIO(BufferIO bufferIO) {\n    this.bufferIO = bufferIO;\n  }\n  BufferIO getBufferIO() {\n    return this.bufferIO;\n  }\n  /**\n   * Route bufferIO function through this to ensure little endian.\n   *\n   * @param uri\n   * @return\n   */\n  public ByteBuffer getDirectByteBuffer(URI uri) {\n    return bufferIO.getDirectByteBuffer(uri).order(ByteOrder.LITTLE_ENDIAN).rewind();\n  }\n"]], "pred": {"ppl": 2.073565721511841, "ppl_lower": 2.3358237743377686, "ppl/lowercase_ppl": -1.1633071105953001, "ppl/zlib": 0.0007464377647210532, "Min_5.0% Prob": 6.9108512924938665, "Min_10.0% Prob": 5.03736337408962, "Min_20.0% Prob": 3.2902223303646383, "Min_30.0% Prob": 2.3704893244690153, "Min_40.0% Prob": 1.8151431598770085, "Min_50.0% Prob": 1.4581422439325147, "Min_60.0% Prob": 1.2158634381250257}}
{"hexsha": "fc88a55f46be4de2d3cafec09b9a4f5844614d6a", "ext": "java", "lang": "Java", "content": "public class DemoTest {\n    public static void main(String[] args) {\n        IgoChessman black1,black2,black3,white1,white2,white3;\n//        IgoChessmanFactory factory;\n    \n        IgoChessmanFactory factory=IgoChessmanFactory.getInstance();\n    \n        black1=factory.getIgoChessman(\"b\");\n        black2=factory.getIgoChessman(\"b\");\n        black3=factory.getIgoChessman(\"b\");\n    \n        System.out.println(\"\u5224\u65ad\u9ed1\u8272\u68cb\u5b50\u662f\u5426\u76f8\u7b49\" + (black1 == black2));\n    \n        white1 = factory.getIgoChessman(\"w\");\n        white2 = factory.getIgoChessman(\"w\");\n        System.out.println(\"\u5224\u65ad\u767d\u8272\u68cb\u5b50\u662f\u5426\u76f8\u7b49\" + (white1 == white2));\n    \n        \n    }\n}", "item_id": 0, "repo": "fangjiaxiaobai/learn", "file": "13-design-pattern/chapter04-flyweightPattern/src/demo1_chess/DemoTest.java", "last_update_at": "2022-03-31T19:09:06+00:00", "question_id": "fc88a55f46be4de2d3cafec09b9a4f5844614d6a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DemoTest {\n    public static void main(String[] args) {\n        IgoChessman black1,black2,black3,white1,white2,white3;\n//        IgoChessmanFactory factory;\n        IgoChessmanFactory factory=IgoChessmanFactory.getInstance();\n        black1=factory.getIgoChessman(\"b\");\n        black2=factory.getIgoChessman(\"b\");\n        black3=factory.getIgoChessman(\"b\");\n        System.out.println(\"\u5224\u65ad\u9ed1\u8272\u68cb\u5b50\u662f\u5426\u76f8\u7b49\" + (black1 == black2));\n        white1 = factory.getIgoChessman(\"w\");\n        white2 = factory.getIgoChessman(\"w\");\n        System.out.println(\"\u5224\u65ad\u767d\u8272\u68cb\u5b50\u662f\u5426\u76f8\u7b49\" + (white1 == white2));\n    }\n"]], "pred": {"ppl": 1.9419670104980469, "ppl_lower": 2.4337282180786133, "ppl/lowercase_ppl": -1.3400971451751054, "ppl/zlib": 0.002378858001217563, "Min_5.0% Prob": 6.468672188845548, "Min_10.0% Prob": 4.783862113952637, "Min_20.0% Prob": 3.0849524524476792, "Min_30.0% Prob": 2.1791039882775616, "Min_40.0% Prob": 1.6543437185195775, "Min_50.0% Prob": 1.3279118731683284, "Min_60.0% Prob": 1.1077057876263874}}
{"hexsha": "5df317cb66498d7d0ea5ad6761227e44c89b0cf5", "ext": "java", "lang": "Java", "content": "@Service\npublic class ManagementBusInvocationPluginRemote extends IManagementBusInvocationPluginService {\n\n    final private static Logger LOG = LoggerFactory.getLogger(ManagementBusInvocationPluginRemote.class);\n\n    private final RequestSender requestSender;\n\n    @Inject\n    public ManagementBusInvocationPluginRemote(RequestSender requestSender) {\n        this.requestSender = requestSender;\n    }\n\n    @Override\n    public Exchange invoke(final Exchange exchange) {\n\n        LOG.debug(\"Invoking IA on remote OpenTOSCA Container.\");\n        final Message message = exchange.getIn();\n        final Object body = message.getBody();\n\n        // IA invocation request containing the input parameters\n        final IAInvocationRequest invocationRequest = parseBodyToInvocationRequest(body);\n\n        // create request message and add the input parameters as body\n        final BodyType requestBody = new BodyType(invocationRequest);\n        final CollaborationMessage request = new CollaborationMessage(new KeyValueMap(), requestBody);\n\n        // perform remote IA operation\n        final Exchange responseExchange = requestSender.sendRequestToRemoteContainer(message, RemoteOperations.INVOKE_IA_OPERATION, request, 0);\n\n        LOG.debug(\"Received a response for the invocation request!\");\n\n        if (!(responseExchange.getIn().getBody() instanceof CollaborationMessage)) {\n            LOG.error(\"Received message has invalid class: {}\", responseExchange.getIn().getBody().getClass());\n            return exchange;\n        }\n\n        // extract the body and process the contained response\n        final CollaborationMessage responseMessage = responseExchange.getIn().getBody(CollaborationMessage.class);\n        final BodyType responseBody = responseMessage.getBody();\n\n        if (Objects.isNull(responseBody)) {\n            LOG.error(\"Collaboration message contains no body.\");\n            return exchange;\n        }\n\n        final IAInvocationRequest invocationResponse = responseBody.getIAInvocationRequest();\n\n        if (Objects.isNull(invocationResponse)) {\n            LOG.error(\"Body contains no IAInvocationRequest object with the result.\");\n            return exchange;\n        }\n\n        // process output of the response\n        if (invocationResponse.getParams() != null) {\n            LOG.debug(\"Response contains output as HashMap:\");\n\n            final HashMap<String, String> outputParamMap = new HashMap<>();\n\n            for (final KeyValueType outputParam : invocationResponse.getParams().getKeyValuePair()) {\n                LOG.debug(\"Key: {}, Value: {}\", outputParam.getKey(), outputParam.getValue());\n                outputParamMap.put(outputParam.getKey(), outputParam.getValue());\n            }\n            message.setBody(outputParamMap, HashMap.class);\n        } else {\n            if (invocationResponse.getDoc() != null) {\n                LOG.debug(\"Response contains output as Document\");\n\n                try {\n                    final DocumentBuilderFactory dFact = DocumentBuilderFactory.newInstance();\n                    final DocumentBuilder build = dFact.newDocumentBuilder();\n                    final Document document = build.newDocument();\n\n                    final Element element = invocationResponse.getDoc().getAny();\n\n                    document.adoptNode(element);\n                    document.appendChild(element);\n\n                    message.setBody(document, Document.class);\n                } catch (final Exception e) {\n                    LOG.error(\"Unable to parse Document: {}\", e.getMessage());\n                }\n            } else {\n                LOG.warn(\"Response contains no output.\");\n                message.setBody(null);\n            }\n        }\n\n        return exchange;\n    }\n\n    @Override\n    public List<String> getSupportedTypes() {\n        // This plug-in supports only the special type 'remote' which is used to forward invocation\n        // requests to other OpenTOSCA Containers.\n        return Collections.singletonList(Constants.REMOTE_TYPE);\n    }\n\n    /**\n     * Reads the input parameters of the invocation from the exchange body and adds them to a IAInvocationRequest\n     * object.\n     *\n     * @param body the body of the exchange containing the invocation request\n     * @return IAInvocationRequest object with given parameters in the Doc or Params element, if input parameters are\n     * given as Hash Map or as Document.\n     */\n    private IAInvocationRequest parseBodyToInvocationRequest(final Object body) {\n\n        LOG.debug(\"Parsing input parameters for the invocation...\");\n\n        final IAInvocationRequest invocationRequest = new IAInvocationRequest();\n\n        if (body instanceof HashMap) {\n            LOG.debug(\"Adding input params from incoming HashMap to the request.\");\n\n            @SuppressWarnings(\"unchecked\") final HashMap<String, String> paramsMap = (HashMap<String, String>) body;\n\n            final KeyValueMap invocationRequestMap = new KeyValueMap();\n            final List<KeyValueType> invocationRequestPairs = invocationRequestMap.getKeyValuePair();\n\n            for (final Entry<String, String> param : paramsMap.entrySet()) {\n                invocationRequestPairs.add(new KeyValueType(param.getKey(), param.getValue()));\n            }\n\n            invocationRequest.setParams(invocationRequestMap);\n        } else {\n            if (body instanceof Document) {\n                LOG.debug(\"Adding input params from incoming Document to the request.\");\n\n                final Document document = (Document) body;\n                invocationRequest.setDoc(new Doc(document.getDocumentElement()));\n            } else {\n                LOG.warn(\"No input parameters defined!\");\n            }\n        }\n\n        return invocationRequest;\n    }\n}", "item_id": 0, "repo": "OpenTOSCA/container", "file": "org.opentosca.bus/org.opentosca.bus.management.invocation.plugin.remote/src/main/java/org/opentosca/bus/management/invocation/plugin/remote/ManagementBusInvocationPluginRemote.java", "last_update_at": "2022-03-04T07:32:00+00:00", "question_id": "5df317cb66498d7d0ea5ad6761227e44c89b0cf5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class ManagementBusInvocationPluginRemote extends IManagementBusInvocationPluginService {\n    final private static Logger LOG = LoggerFactory.getLogger(ManagementBusInvocationPluginRemote.class);\n    private final RequestSender requestSender;\n    @Inject\n    public ManagementBusInvocationPluginRemote(RequestSender requestSender) {\n        this.requestSender = requestSender;\n    }\n    @Override\n    public Exchange invoke(final Exchange exchange) {\n        LOG.debug(\"Invoking IA on remote OpenTOSCA Container.\");\n        final Message message = exchange.getIn();\n        final Object body = message.getBody();\n        // IA invocation request containing the input parameters\n        final IAInvocationRequest invocationRequest = parseBodyToInvocationRequest(body);\n        // create request message and add the input parameters as body\n        final BodyType requestBody = new BodyType(invocationRequest);\n        final CollaborationMessage request = new CollaborationMessage(new KeyValueMap(), requestBody);\n        // perform remote IA operation\n        final Exchange responseExchange = requestSender.sendRequestToRemoteContainer(message, RemoteOperations.INVOKE_IA_OPERATION, request, 0);\n        LOG.debug(\"Received a response for the invocation request!\");\n        if (!(responseExchange.getIn().getBody() instanceof CollaborationMessage)) {\n            LOG.error(\"Received message has invalid class: {}\", responseExchange.getIn().getBody().getClass());\n            return exchange;\n        }\n        // extract the body and process the contained response\n        final CollaborationMessage responseMessage = responseExchange.getIn().getBody(CollaborationMessage.class);\n        final BodyType responseBody = responseMessage.getBody();\n        if (Objects.isNull(responseBody)) {\n            LOG.error(\"Collaboration message contains no body.\");\n            return exchange;\n        }\n        final IAInvocationRequest invocationResponse = responseBody.getIAInvocationRequest();\n        if (Objects.isNull(invocationResponse)) {\n            LOG.error(\"Body contains no IAInvocationRequest object with the result.\");\n            return exchange;\n        }\n        // process output of the response\n        if (invocationResponse.getParams() != null) {\n            LOG.debug(\"Response contains output as HashMap:\");\n            final HashMap<String, String> outputParamMap = new HashMap<>();\n            for (final KeyValueType outputParam : invocationResponse.getParams().getKeyValuePair()) {\n                LOG.debug(\"Key: {}, Value: {}\", outputParam.getKey(), outputParam.getValue());\n                outputParamMap.put(outputParam.getKey(), outputParam.getValue());\n            }\n            message.setBody(outputParamMap, HashMap.class);\n        } else {\n            if (invocationResponse.getDoc() != null) {\n                LOG.debug(\"Response contains output as Document\");\n                try {\n                    final DocumentBuilderFactory dFact = DocumentBuilderFactory.newInstance();\n                    final DocumentBuilder build = dFact.newDocumentBuilder();\n                    final Document document = build.newDocument();\n                    final Element element = invocationResponse.getDoc().getAny();\n                    document.adoptNode(element);\n                    document.appendChild(element);\n                    message.setBody(document, Document.class);\n                } catch (final Exception e) {\n                    LOG.error(\"Unable to parse Document: {}\", e.getMessage());\n                }\n            } else {\n                LOG.warn(\"Response contains no output.\");\n                message.setBody(null);\n            }\n        }\n        return exchange;\n    }\n    @Override\n    public List<String> getSupportedTypes() {\n        // This plug-in supports only the special type 'remote' which is used to forward invocation\n        // requests to other OpenTOSCA Containers.\n        return Collections.singletonList(Constants.REMOTE_TYPE);\n    }\n    /**\n     * Reads the input parameters of the invocation from the exchange body and adds them to a IAInvocationRequest\n     * object.\n     *\n     * @param body the body of the exchange containing the invocation request\n     * @return IAInvocationRequest object with given parameters in the Doc or Params element, if input parameters are\n     * given as Hash Map or as Document.\n     */\n    private IAInvocationRequest parseBodyToInvocationRequest(final Object body) {\n        LOG.debug(\"Parsing input parameters for the invocation...\");\n        final IAInvocationRequest invocationRequest = new IAInvocationRequest();\n        if (body instanceof HashMap) {\n            LOG.debug(\"Adding input params from incoming HashMap to the request.\");\n            @SuppressWarnings(\"unchecked\") final HashMap<String, String> paramsMap = (HashMap<String, String>) body;\n            final KeyValueMap invocationRequestMap = new KeyValueMap();\n            final List<KeyValueType> invocationRequestPairs = invocationRequestMap.getKeyValuePair();\n            for (final Entry<String, String> param : paramsMap.entrySet()) {\n                invocationRequestPairs.add(new KeyValueType(param.getKey(), param.getValue()));\n            }\n            invocationRequest.setParams(invocationRequestMap);\n        } else {\n            if (body instanceof Document) {\n                LOG.debug(\"Adding input params from incoming Document to the request.\");\n                final Document document = (Document) body;\n                invocationRequest.setDoc(new Doc(document.getDocumentElement()));\n            } else {\n                LOG.warn(\"No input parameters defined!\");\n            }\n        }\n        return invocationRequest;\n    }\n"]], "pred": {"ppl": 2.3664324283599854, "ppl_lower": 2.7432570457458496, "ppl/lowercase_ppl": -1.1715407804907452, "ppl/zlib": 0.0005434596318918086, "Min_5.0% Prob": 7.000538536146576, "Min_10.0% Prob": 5.231521382051356, "Min_20.0% Prob": 3.6065827724980375, "Min_30.0% Prob": 2.6989634712926702, "Min_40.0% Prob": 2.112826346585978, "Min_50.0% Prob": 1.7156179103045315, "Min_60.0% Prob": 1.4358425683191511}}
{"hexsha": "520e43372799a057230e34c5d2fd2fdc1a3b8793", "ext": "java", "lang": "Java", "content": "public class ChronicleSource<C extends Chronicle> implements Closeable {\n\n    private final C chronicle;\n    private final ServerSocketChannel server;\n    private final int delayNS;\n\n    private final String name;\n    private final ExecutorService service;\n    private final Logger logger;\n\n    private volatile boolean closed = false;\n\n    public ChronicleSource(C chronicle, int port, int delayNS) throws IOException {\n        this.chronicle = chronicle;\n        this.delayNS = delayNS;\n        server = ServerSocketChannel.open();\n        server.socket().bind(new InetSocketAddress(port));\n        name = chronicle.name() + \"@\" + port;\n        logger = Logger.getLogger(getClass().getName() + \".\" + name);\n        service = Executors.newCachedThreadPool(new NamedThreadFactory(name));\n        service.execute(new Acceptor());\n    }\n\n    public static void main(String... args) throws IOException {\n        if (args.length < 2) {\n            System.err.println(\"Usage: java \" + ChronicleSource.class.getName() + \" {chronicle-base-path} {port} [delayNS]\");\n            System.exit(-1);\n        }\n        int dataBitsHintSize = Integer.getInteger(\"dataBitsHintSize\", 24);\n        String def = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ? \"Big\" : \"Little\";\n        ByteOrder byteOrder = System.getProperty(\"byteOrder\", def).equalsIgnoreCase(\"Big\") ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n        String basePath = args[0];\n        int port = Integer.parseInt(args[1]);\n        int delayNS = 5 * 1000 * 1000;\n        if (args.length > 2)\n            delayNS = Integer.parseInt(args[2]);\n        IndexedChronicle ic = new IndexedChronicle(basePath, dataBitsHintSize, byteOrder);\n        ChronicleSource cs = new ChronicleSource(ic, port, delayNS);\n    }\n\n    class Acceptor implements Runnable {\n        @Override\n        public void run() {\n            Thread.currentThread().setName(name + \"-acceptor\");\n            try {\n                while (!closed) {\n                    SocketChannel socket = server.accept();\n                    service.execute(new Handler(socket));\n                }\n            } catch (IOException e) {\n                if (!closed)\n                    logger.log(Level.SEVERE, \"Acceptor dying\", e);\n            }\n        }\n    }\n\n    class Handler implements Runnable {\n        private final SocketChannel socket;\n\n        public Handler(SocketChannel socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            try {\n                long index = readIndex(socket);\n                Excerpt excerpt = chronicle.createExcerpt();\n                ByteBuffer bb = TcpUtil.createBuffer(1, chronicle);\n                while (!closed) {\n                    while (!excerpt.index(index))\n                        pause(delayNS);\n                    int size = excerpt.capacity();\n                    int capacity = size + TcpUtil.HEADER_SIZE;\n                    if (capacity > bb.capacity())\n                        bb = TcpUtil.createBuffer(capacity, chronicle);\n\n                    bb.clear();\n                    bb.putLong(index);\n                    bb.putLong(size);\n                    excerpt.read(bb);\n                    bb.flip();\n                    while (bb.remaining() > 0 && socket.write(bb) > 0) ;\n                    if (bb.remaining() > 0) throw new EOFException(\"Failed to send index=\" + index);\n                }\n            } catch (IOException e) {\n                if (!closed)\n                    logger.log(Level.INFO, \"Connect \" + socket + \" died\", e);\n            }\n        }\n\n        private long readIndex(SocketChannel socket) throws IOException {\n            ByteBuffer bb = ByteBuffer.allocate(8);\n            while (bb.remaining() > 0 && socket.read(bb) > 0) ;\n            if (bb.remaining() > 0) throw new EOFException();\n            return bb.getLong(0);\n        }\n    }\n\n    protected void pause(int delayNS) {\n        if (delayNS < 1) return;\n        if (delayNS < 20000)\n            Thread.yield();\n        else\n            LockSupport.parkNanos(delayNS);\n    }\n\n    @Override\n    public void close() throws IOException {\n        closed = true;\n        service.shutdown();\n        try {\n            service.awaitTermination(1, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        chronicle.close();\n    }\n\n}", "item_id": 0, "repo": "UCLA-SEAL/JShrink", "file": "code/experiment_resources/ohloh_projects/Java-Chronicle/src/main/java/vanilla/java/chronicle/tcp/ChronicleSource.java", "last_update_at": "2022-03-14T19:58:38+00:00", "question_id": "520e43372799a057230e34c5d2fd2fdc1a3b8793_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ChronicleSource<C extends Chronicle> implements Closeable {\n    private final C chronicle;\n    private final ServerSocketChannel server;\n    private final int delayNS;\n    private final String name;\n    private final ExecutorService service;\n    private final Logger logger;\n    private volatile boolean closed = false;\n    public ChronicleSource(C chronicle, int port, int delayNS) throws IOException {\n        this.chronicle = chronicle;\n        this.delayNS = delayNS;\n        server = ServerSocketChannel.open();\n        server.socket().bind(new InetSocketAddress(port));\n        name = chronicle.name() + \"@\" + port;\n        logger = Logger.getLogger(getClass().getName() + \".\" + name);\n        service = Executors.newCachedThreadPool(new NamedThreadFactory(name));\n        service.execute(new Acceptor());\n    }\n    public static void main(String... args) throws IOException {\n        if (args.length < 2) {\n            System.err.println(\"Usage: java \" + ChronicleSource.class.getName() + \" {chronicle-base-path} {port} [delayNS]\");\n            System.exit(-1);\n        }\n        int dataBitsHintSize = Integer.getInteger(\"dataBitsHintSize\", 24);\n        String def = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ? \"Big\" : \"Little\";\n        ByteOrder byteOrder = System.getProperty(\"byteOrder\", def).equalsIgnoreCase(\"Big\") ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n        String basePath = args[0];\n        int port = Integer.parseInt(args[1]);\n        int delayNS = 5 * 1000 * 1000;\n        if (args.length > 2)\n            delayNS = Integer.parseInt(args[2]);\n        IndexedChronicle ic = new IndexedChronicle(basePath, dataBitsHintSize, byteOrder);\n        ChronicleSource cs = new ChronicleSource(ic, port, delayNS);\n    }\n    class Acceptor implements Runnable {\n        @Override\n        public void run() {\n            Thread.currentThread().setName(name + \"-acceptor\");\n            try {\n                while (!closed) {\n                    SocketChannel socket = server.accept();\n                    service.execute(new Handler(socket));\n                }\n            } catch (IOException e) {\n                if (!closed)\n                    logger.log(Level.SEVERE, \"Acceptor dying\", e);\n            }\n        }\n    }\n    class Handler implements Runnable {\n        private final SocketChannel socket;\n        public Handler(SocketChannel socket) {\n            this.socket = socket;\n        }\n        @Override\n        public void run() {\n            try {\n                long index = readIndex(socket);\n                Excerpt excerpt = chronicle.createExcerpt();\n                ByteBuffer bb = TcpUtil.createBuffer(1, chronicle);\n                while (!closed) {\n                    while (!excerpt.index(index))\n                        pause(delayNS);\n                    int size = excerpt.capacity();\n                    int capacity = size + TcpUtil.HEADER_SIZE;\n                    if (capacity > bb.capacity())\n                        bb = TcpUtil.createBuffer(capacity, chronicle);\n                    bb.clear();\n                    bb.putLong(index);\n                    bb.putLong(size);\n                    excerpt.read(bb);\n                    bb.flip();\n                    while (bb.remaining() > 0 && socket.write(bb) > 0) ;\n                    if (bb.remaining() > 0) throw new EOFException(\"Failed to send index=\" + index);\n                }\n            } catch (IOException e) {\n                if (!closed)\n                    logger.log(Level.INFO, \"Connect \" + socket + \" died\", e);\n            }\n        }\n        private long readIndex(SocketChannel socket) throws IOException {\n            ByteBuffer bb = ByteBuffer.allocate(8);\n            while (bb.remaining() > 0 && socket.read(bb) > 0) ;\n            if (bb.remaining() > 0) throw new EOFException();\n            return bb.getLong(0);\n        }\n    }\n    protected void pause(int delayNS) {\n        if (delayNS < 1) return;\n        if (delayNS < 20000)\n            Thread.yield();\n        else\n            LockSupport.parkNanos(delayNS);\n    }\n    @Override\n    public void close() throws IOException {\n        closed = true;\n        service.shutdown();\n        try {\n            service.awaitTermination(1, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        chronicle.close();\n    }\n"]], "pred": {"ppl": 1.7387691736221313, "ppl_lower": 2.0056231021881104, "ppl/lowercase_ppl": -1.258103949287007, "ppl/zlib": 0.00039011106589538177, "Min_5.0% Prob": 5.564744168636846, "Min_10.0% Prob": 3.9338953272969115, "Min_20.0% Prob": 2.504306456329776, "Min_30.0% Prob": 1.788439566987792, "Min_40.0% Prob": 1.3679411451179708, "Min_50.0% Prob": 1.1035785494324863, "Min_60.0% Prob": 0.9222623963223475}}
{"hexsha": "42d27d96ec0d02d273dd288592b36e77ef176802", "ext": "java", "lang": "Java", "content": "public class UdpClient {\n\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"127.0.0.1\");\n        int port = 9090;\n        String data = \"udt data\";\n        DatagramPacket datagramPacket = new DatagramPacket(data.getBytes(), data.length(), address, port);\n        socket.send(datagramPacket);\n        socket.close();\n    }\n}", "item_id": 0, "repo": "yangsanchao/java_code", "file": "javase/src/main/java/com/yangsc/udp/UdpClient.java", "last_update_at": "2022-01-04T16:33:15+00:00", "question_id": "42d27d96ec0d02d273dd288592b36e77ef176802_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UdpClient {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"127.0.0.1\");\n        int port = 9090;\n        String data = \"udt data\";\n        DatagramPacket datagramPacket = new DatagramPacket(data.getBytes(), data.length(), address, port);\n        socket.send(datagramPacket);\n        socket.close();\n    }\n"]], "pred": {"ppl": 1.6401333808898926, "ppl_lower": 2.2902793884277344, "ppl/lowercase_ppl": -1.6748411141291142, "ppl/zlib": 0.0020530189557673335, "Min_5.0% Prob": 6.15682323773702, "Min_10.0% Prob": 3.762443285721999, "Min_20.0% Prob": 2.2800970398462734, "Min_30.0% Prob": 1.6182612299154966, "Min_40.0% Prob": 1.2363936393879926, "Min_50.0% Prob": 0.994117889008843, "Min_60.0% Prob": 0.8301625901845117}}
{"hexsha": "1b675423836ba754efdd53d99b2dd931e4e0e564", "ext": "java", "lang": "Java", "content": "@Entity\n@Table(name = \"lib_author\")\n@SequenceGenerator(name = \"seq_lib_author\", sequenceName = \"seq_lib_author\", allocationSize = 1)\npublic class Author {\n\t@Id\n\t@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"seq_lib_author\")\n\t@Column(name = \"id_author\", unique = false, nullable = false, insertable = true, updatable = true)\n\tprivate Integer idAuthor;\n\n\t@Column(name = \"name\", unique = false, nullable = true, insertable = true, updatable = true, length = 30)\n\tprivate String name;\n\n\t@Column(name = \"surname\", unique = false, nullable = true, insertable = true, updatable = true, length = 80)\n\tprivate String surname;\n\n\t@Column(name = \"nickname\", unique = false, nullable = true, insertable = true, updatable = true, length = 80)\n\tprivate String nickname;\n\n\t@Temporal(TemporalType.DATE)\n\t@Column(name = \"birth_date\", unique = false, nullable = true, insertable = true, updatable = true, length = 13)\n\tprivate Date birthDate;\n\n\t@ManyToMany(cascade = { CascadeType.ALL }, fetch = FetchType.LAZY, mappedBy = \"author\")\n\tprivate Set<Book> book = new HashSet<Book>(0);\n\n\tpublic Integer getIdAuthor() {\n\t\treturn idAuthor;\n\t}\n\n\tpublic void setIdAuthor(Integer idAuthor) {\n\t\tthis.idAuthor = idAuthor;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getSurname() {\n\t\treturn surname;\n\t}\n\n\tpublic void setSurname(String surname) {\n\t\tthis.surname = surname;\n\t}\n\n\tpublic String getNickname() {\n\t\treturn nickname;\n\t}\n\n\tpublic void setNickname(String nickname) {\n\t\tthis.nickname = nickname;\n\t}\n\n\tpublic Date getBirthDate() {\n\t\treturn birthDate;\n\t}\n\n\tpublic void setBirthDate(Date birthDate) {\n\t\tthis.birthDate = birthDate;\n\t}\n\n\tpublic Set<Book> getBook() {\n\t\treturn book;\n\t}\n\n\tpublic void setBook(Set<Book> book) {\n\t\tthis.book = book;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tString result = \"\";\n\t\tif(surname != null && name == null)\n\t\t\tresult = surname;\n\t\telse if(surname == null && name != null)\n\t\t\tresult = name;\n\t\telse if( surname != null && name != null)\n\t\t\tresult = surname + \" \" + name;\n\t\treturn result;\n\t}\n}", "item_id": 0, "repo": "SchHolmes/eLibrary", "file": "source/src/hibernate/java/com/javafee/hibernate/dto/library/Author.java", "last_update_at": "2022-02-16T00:56:05+00:00", "question_id": "1b675423836ba754efdd53d99b2dd931e4e0e564_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Entity\n@Table(name = \"lib_author\")\n@SequenceGenerator(name = \"seq_lib_author\", sequenceName = \"seq_lib_author\", allocationSize = 1)\npublic class Author {\n\t@Id\n\t@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"seq_lib_author\")\n\t@Column(name = \"id_author\", unique = false, nullable = false, insertable = true, updatable = true)\n\tprivate Integer idAuthor;\n\t@Column(name = \"name\", unique = false, nullable = true, insertable = true, updatable = true, length = 30)\n\tprivate String name;\n\t@Column(name = \"surname\", unique = false, nullable = true, insertable = true, updatable = true, length = 80)\n\tprivate String surname;\n\t@Column(name = \"nickname\", unique = false, nullable = true, insertable = true, updatable = true, length = 80)\n\tprivate String nickname;\n\t@Temporal(TemporalType.DATE)\n\t@Column(name = \"birth_date\", unique = false, nullable = true, insertable = true, updatable = true, length = 13)\n\tprivate Date birthDate;\n\t@ManyToMany(cascade = { CascadeType.ALL }, fetch = FetchType.LAZY, mappedBy = \"author\")\n\tprivate Set<Book> book = new HashSet<Book>(0);\n\tpublic Integer getIdAuthor() {\n\t\treturn idAuthor;\n\t}\n\tpublic void setIdAuthor(Integer idAuthor) {\n\t\tthis.idAuthor = idAuthor;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic String getSurname() {\n\t\treturn surname;\n\t}\n\tpublic void setSurname(String surname) {\n\t\tthis.surname = surname;\n\t}\n\tpublic String getNickname() {\n\t\treturn nickname;\n\t}\n\tpublic void setNickname(String nickname) {\n\t\tthis.nickname = nickname;\n\t}\n\tpublic Date getBirthDate() {\n\t\treturn birthDate;\n\t}\n\tpublic void setBirthDate(Date birthDate) {\n\t\tthis.birthDate = birthDate;\n\t}\n\tpublic Set<Book> getBook() {\n\t\treturn book;\n\t}\n\tpublic void setBook(Set<Book> book) {\n\t\tthis.book = book;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tString result = \"\";\n\t\tif(surname != null && name == null)\n\t\t\tresult = surname;\n\t\telse if(surname == null && name != null)\n\t\t\tresult = name;\n\t\telse if( surname != null && name != null)\n\t\t\tresult = surname + \" \" + name;\n\t\treturn result;\n\t}\n"]], "pred": {"ppl": 1.2678096294403076, "ppl_lower": 1.4420790672302246, "ppl/lowercase_ppl": -1.542773708435186, "ppl/zlib": 0.0003684638357654068, "Min_5.0% Prob": 3.5455478526450492, "Min_10.0% Prob": 2.1511789153556564, "Min_20.0% Prob": 1.1707946941055156, "Min_30.0% Prob": 0.7874580261259937, "Min_40.0% Prob": 0.5934513875640778, "Min_50.0% Prob": 0.4743216766413146, "Min_60.0% Prob": 0.3957688970319799}}
{"hexsha": "8f6ca7f8a4c249019b6cd8fd1c342027c3632b68", "ext": "java", "lang": "Java", "content": "public class HourlyTemperatureDewPointCommandTest {\n\n    @BeforeEach\n    public void setup() {\n        Messages.getInstance().setLocale(Locale.ENGLISH);\n    }\n\n    @Test\n    public void testExecute() {\n        Command command = new HourlyTemperatureDewPointCommand();\n        StringBuilder sb = new StringBuilder();\n        assertThat(command.execute(\"T00261015\", sb), Matchers.emptyString());\n        assertThat(sb.toString(), Matchers.containsString(\"hourly temperature of 2.6\u00b0C and dew point of -1.5\u00b0C\"));\n    }\n\n    @Test\n    public void testExecuteOnlyTemperature() {\n        Command command = new HourlyTemperatureDewPointCommand();\n        StringBuilder sb = new StringBuilder();\n        assertEquals(\"AO1\", command.execute(\"T0026 AO1\", sb));\n        assertThat(sb.toString(), Matchers.containsString(\"hourly temperature of 2.6\u00b0C\"));\n        assertThat(sb.toString(), Matchers.not(Matchers.containsString(\"dew point of\")));\n    }\n\n    @Test\n    public void testCanParse() {\n        Command command = new HourlyTemperatureDewPointCommand();\n        assertTrue(command.canParse(\"T0026\"));\n    }\n\n}", "item_id": 0, "repo": "mivek/MetarParser", "file": "metarParser-parsers/src/test/java/io/github/mivek/command/remark/HourlyTemperatureDewPointCommandTest.java", "last_update_at": "2022-03-22T00:42:27+00:00", "question_id": "8f6ca7f8a4c249019b6cd8fd1c342027c3632b68_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HourlyTemperatureDewPointCommandTest {\n    @BeforeEach\n    public void setup() {\n        Messages.getInstance().setLocale(Locale.ENGLISH);\n    }\n    @Test\n    public void testExecute() {\n        Command command = new HourlyTemperatureDewPointCommand();\n        StringBuilder sb = new StringBuilder();\n        assertThat(command.execute(\"T00261015\", sb), Matchers.emptyString());\n        assertThat(sb.toString(), Matchers.containsString(\"hourly temperature of 2.6\u00b0C and dew point of -1.5\u00b0C\"));\n    }\n    @Test\n    public void testExecuteOnlyTemperature() {\n        Command command = new HourlyTemperatureDewPointCommand();\n        StringBuilder sb = new StringBuilder();\n        assertEquals(\"AO1\", command.execute(\"T0026 AO1\", sb));\n        assertThat(sb.toString(), Matchers.containsString(\"hourly temperature of 2.6\u00b0C\"));\n        assertThat(sb.toString(), Matchers.not(Matchers.containsString(\"dew point of\")));\n    }\n    @Test\n    public void testCanParse() {\n        Command command = new HourlyTemperatureDewPointCommand();\n        assertTrue(command.canParse(\"T0026\"));\n    }\n"]], "pred": {"ppl": 2.0520517826080322, "ppl_lower": 2.7138826847076416, "ppl/lowercase_ppl": -1.388876675279434, "ppl/zlib": 0.002019213938705676, "Min_5.0% Prob": 6.631097793579102, "Min_10.0% Prob": 5.137374311685562, "Min_20.0% Prob": 3.347719482275156, "Min_30.0% Prob": 2.347501254355421, "Min_40.0% Prob": 1.7888248500819424, "Min_50.0% Prob": 1.4353778277773683, "Min_60.0% Prob": 1.2023677779314088}}
{"hexsha": "4c26605d62dce4f6ede90780d1eb1c63dff18a88", "ext": "java", "lang": "Java", "content": "public class ActionValueHeuristic extends AbstractPlayer implements ToDoubleBiFunction<AbstractAction, AbstractGameState> {\n\n    Random rnd = new Random(System.currentTimeMillis());\n\n    String filename;\n\n    protected double RND_WEIGHT;\n    double defaultValue = 0.0;\n\n    Map<String, Map<Integer, Double>> actionValues = new HashMap<>();\n    Map<Integer, String> actionNames = new HashMap<>();\n    Function<AbstractGameState, String> bucketFunction = s -> \"\";\n\n    public ActionValueHeuristic(\n            Map<String, Map<Integer, Double>> advantages,\n            double rndWeight,\n            Function<AbstractGameState, String> bucketFn,\n            double defaultValue\n    ) {\n        actionValues = advantages;\n        RND_WEIGHT = rndWeight;\n        if (bucketFn == null)\n            throw new IllegalArgumentException(\"Must specify a bucket function\");\n        bucketFunction = bucketFn;\n        this.defaultValue = defaultValue;\n    }\n\n    public ActionValueHeuristic(String filename) {\n        this.filename = filename;\n        initialiseFromFile();\n    }\n\n    @Override\n    public void initializePlayer(AbstractGameState state) {\n        initialiseFromFile();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void initialiseFromFile() {\n\n        try {\n            if (filename != null && (new File(filename)).exists()) {\n                BufferedReader reader = new BufferedReader(new FileReader(filename));\n                String[] header = reader.readLine().split(\",\");\n                RND_WEIGHT = Double.parseDouble(header[0]);\n                if (header.length > 1) {\n                    try {\n                        Class<?> bucketClass = Class.forName(header[1]);\n                        bucketFunction = (Function<AbstractGameState, String>) bucketClass.getConstructor().newInstance();\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                        bucketFunction = s -> \"\";\n                    }\n                }\n                reader.readLine();\n                // we expect columns: bucket, hash, value estimate, name (optional)\n\n                String nextLine = reader.readLine();\n                while (nextLine != null) {\n                    List<String> data = Arrays.stream(nextLine.split(\",\")).collect(toList());\n\n                    String bucket = data.get(0).trim();\n                    Map<Integer, Double> advantages = getActionValues(bucket);\n\n                    int hash = Integer.parseInt(data.get(1).trim());\n                    double advantage = Double.parseDouble(data.get(2).trim());\n                    advantages.put(hash, advantage);\n                    if (data.size() > 3) {\n                        String name = data.get(3).trim();\n                        actionNames.put(hash, name);\n                    }\n                    nextLine = reader.readLine();\n                }\n\n                reader.close();\n            } else {\n                System.out.println(\"File not found : \" + filename);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private Map<Integer, Double> getActionValues(String bucket) {\n        if (!actionValues.containsKey(bucket))\n            actionValues.put(bucket, new HashMap<>());\n        return actionValues.get(bucket);\n    }\n\n\n    @Override\n    public AbstractAction getAction(AbstractGameState gameState, List<AbstractAction> possibleActions) {\n\n        if (possibleActions.size() == 1)\n            return possibleActions.get(0);\n\n        double bestValue = Double.NEGATIVE_INFINITY;\n        String bucket = bucketFunction.apply(gameState);\n        AbstractAction retValue = possibleActions.get(0);\n\n        for (AbstractAction action : possibleActions) {\n            double actionValue = actionValue(action, bucket);\n            if (actionValue > bestValue) {\n                retValue = action;\n                bestValue = actionValue;\n            }\n        }\n        return retValue;\n    }\n\n    private double actionValue(AbstractAction action, String bucket) {\n        Map<Integer, Double> actionValues = getActionValues(bucket);\n        Map<Integer, Double> defaultValues = getActionValues(\"\");\n        int hash = action.hashCode();\n        double actionValue = defaultValue;\n        if (actionValues.containsKey(hash)) {\n            actionValue = actionValues.get(hash);\n        } else if (defaultValues.containsKey(hash)) {\n            actionValue = defaultValues.get(hash);\n        }\n\n        actionValue += rnd.nextDouble() * RND_WEIGHT;\n        actionNames.putIfAbsent(hash, action.toString());\n        return actionValue;\n    }\n\n    Set<Integer> unknownHashCodes = new HashSet<>();\n\n    @Override\n    public double applyAsDouble(AbstractAction abstractAction, AbstractGameState gameState) {\n        String bucket = bucketFunction.apply(gameState);\n//        if (!actionValues.isEmpty() && !actionValues.containsKey(hash) && !unknownHashCodes.contains(hash)) {\n//            unknownHashCodes.add(hash);\n//            System.out.println(\"Action not found : \" + hash + \" \" + abstractAction.toString() + \" : \" + bucket);\n//        }\n        return actionValue(abstractAction, bucket);\n    }\n}", "item_id": 0, "repo": "GAIGResearch/TabletopGames", "file": "src/main/java/players/heuristics/ActionValueHeuristic.java", "last_update_at": "2022-03-15T13:18:58+00:00", "question_id": "4c26605d62dce4f6ede90780d1eb1c63dff18a88_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ActionValueHeuristic extends AbstractPlayer implements ToDoubleBiFunction<AbstractAction, AbstractGameState> {\n    Random rnd = new Random(System.currentTimeMillis());\n    String filename;\n    protected double RND_WEIGHT;\n    double defaultValue = 0.0;\n    Map<String, Map<Integer, Double>> actionValues = new HashMap<>();\n    Map<Integer, String> actionNames = new HashMap<>();\n    Function<AbstractGameState, String> bucketFunction = s -> \"\";\n    public ActionValueHeuristic(\n            Map<String, Map<Integer, Double>> advantages,\n            double rndWeight,\n            Function<AbstractGameState, String> bucketFn,\n            double defaultValue\n    ) {\n        actionValues = advantages;\n        RND_WEIGHT = rndWeight;\n        if (bucketFn == null)\n            throw new IllegalArgumentException(\"Must specify a bucket function\");\n        bucketFunction = bucketFn;\n        this.defaultValue = defaultValue;\n    }\n    public ActionValueHeuristic(String filename) {\n        this.filename = filename;\n        initialiseFromFile();\n    }\n    @Override\n    public void initializePlayer(AbstractGameState state) {\n        initialiseFromFile();\n    }\n    @SuppressWarnings(\"unchecked\")\n    private void initialiseFromFile() {\n        try {\n            if (filename != null && (new File(filename)).exists()) {\n                BufferedReader reader = new BufferedReader(new FileReader(filename));\n                String[] header = reader.readLine().split(\",\");\n                RND_WEIGHT = Double.parseDouble(header[0]);\n                if (header.length > 1) {\n                    try {\n                        Class<?> bucketClass = Class.forName(header[1]);\n                        bucketFunction = (Function<AbstractGameState, String>) bucketClass.getConstructor().newInstance();\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                        bucketFunction = s -> \"\";\n                    }\n                }\n                reader.readLine();\n                // we expect columns: bucket, hash, value estimate, name (optional)\n                String nextLine = reader.readLine();\n                while (nextLine != null) {\n                    List<String> data = Arrays.stream(nextLine.split(\",\")).collect(toList());\n                    String bucket = data.get(0).trim();\n                    Map<Integer, Double> advantages = getActionValues(bucket);\n                    int hash = Integer.parseInt(data.get(1).trim());\n                    double advantage = Double.parseDouble(data.get(2).trim());\n                    advantages.put(hash, advantage);\n                    if (data.size() > 3) {\n                        String name = data.get(3).trim();\n                        actionNames.put(hash, name);\n                    }\n                    nextLine = reader.readLine();\n                }\n                reader.close();\n            } else {\n                System.out.println(\"File not found : \" + filename);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    private Map<Integer, Double> getActionValues(String bucket) {\n        if (!actionValues.containsKey(bucket))\n            actionValues.put(bucket, new HashMap<>());\n        return actionValues.get(bucket);\n    }\n    @Override\n    public AbstractAction getAction(AbstractGameState gameState, List<AbstractAction> possibleActions) {\n        if (possibleActions.size() == 1)\n            return possibleActions.get(0);\n        double bestValue = Double.NEGATIVE_INFINITY;\n        String bucket = bucketFunction.apply(gameState);\n        AbstractAction retValue = possibleActions.get(0);\n        for (AbstractAction action : possibleActions) {\n            double actionValue = actionValue(action, bucket);\n            if (actionValue > bestValue) {\n                retValue = action;\n                bestValue = actionValue;\n            }\n        }\n        return retValue;\n    }\n    private double actionValue(AbstractAction action, String bucket) {\n        Map<Integer, Double> actionValues = getActionValues(bucket);\n        Map<Integer, Double> defaultValues = getActionValues(\"\");\n        int hash = action.hashCode();\n        double actionValue = defaultValue;\n        if (actionValues.containsKey(hash)) {\n            actionValue = actionValues.get(hash);\n        } else if (defaultValues.containsKey(hash)) {\n            actionValue = defaultValues.get(hash);\n        }\n        actionValue += rnd.nextDouble() * RND_WEIGHT;\n        actionNames.putIfAbsent(hash, action.toString());\n        return actionValue;\n    }\n    Set<Integer> unknownHashCodes = new HashSet<>();\n    @Override\n    public double applyAsDouble(AbstractAction abstractAction, AbstractGameState gameState) {\n        String bucket = bucketFunction.apply(gameState);\n//        if (!actionValues.isEmpty() && !actionValues.containsKey(hash) && !unknownHashCodes.contains(hash)) {\n//            unknownHashCodes.add(hash);\n//            System.out.println(\"Action not found : \" + hash + \" \" + abstractAction.toString() + \" : \" + bucket);\n//        }\n        return actionValue(abstractAction, bucket);\n    }\n"]], "pred": {"ppl": 1.8081800937652588, "ppl_lower": 2.0625548362731934, "ppl/lowercase_ppl": -1.2222183401474547, "ppl/zlib": 0.00040709337896408193, "Min_5.0% Prob": 5.888358060051413, "Min_10.0% Prob": 4.282289202306785, "Min_20.0% Prob": 2.725448928042954, "Min_30.0% Prob": 1.930843065912817, "Min_40.0% Prob": 1.4702204044152296, "Min_50.0% Prob": 1.1828624103145415, "Min_60.0% Prob": 0.987710851160308}}
{"hexsha": "d435873e6a99c0887e0e3314e1e98a372d5792a7", "ext": "java", "lang": "Java", "content": "public class AtomicsPatchToolsTest extends BaseTest {\n\n    @Test\n    public void testAtomicPatchTools(Method method) {\n        String methodName = method.getName();\n        String atomicName1 = methodName + 1;\n        String atomicName2 = methodName + 2;\n        String atomicName3 = methodName + 3;\n\n        clientAPI.getIgnite().atomicLong(atomicName1, 1, true);\n        clientAPI.getIgnite().atomicLong(atomicName2, 1, true);\n        clientAPI.getIgnite().atomicLong(atomicName3, 1, true);\n\n        controller = new Controller(clientAPI.getIgnite(),\n                () -> Stream.of(atomicName1, atomicName2, atomicName3).collect(Collectors.toList()));\n\n        controller.serializeDataToAvro(source.getPath());\n\n        PatchContext context = new PatchContext(source, destination);\n        context.prepare();\n\n        Map<String, Long> map = new HashMap<>();\n        map.put(atomicName1, (long) 1);\n        map.put(atomicName2, (long) 1);\n        map.put(atomicName3, (long) 1);\n        clientAPI.clearIgniteAndCheckIgniteIsEmpty(map);\n\n        TransformAction<TransformAtomicsOutput> action = new SelectAtomicsAction.Builder()\n                .context(context)\n                .from(source.getPath().toString())\n                .build();\n        TransformAction<TransformAtomicsOutput> duplicatedAtomicAction = new MapAtomicsAction.Builder()\n                .action(action)\n                .map(row -> {\n                    String atomicName = row.getValue(FieldNames.IGNITE_ATOMIC_LONG_NAME_FIELD_NAME);\n                    return Row.fromRow(row)\n                            .withFieldValue(FieldNames.IGNITE_ATOMIC_LONG_NAME_FIELD_NAME, atomicName + 1)\n                            .build();\n                }).build();\n\n        action = new MapAtomicsAction.Builder()\n                .action(action)\n                .map(row -> {\n                    String atomicName = row.getValue(FieldNames.IGNITE_ATOMIC_LONG_NAME_FIELD_NAME);\n                    long val = row.getValue(FieldNames.IGNITE_ATOMIC_LONG_VALUE_FIELD_NAME);\n                    if (atomicName1.equals(atomicName)) {\n                        val = 2;\n                        map.put(atomicName, val);\n                    }\n                    return Row.fromRow(row)\n                            .withFieldValue(FieldNames.IGNITE_ATOMIC_LONG_VALUE_FIELD_NAME, val)\n                            .build();\n                }).build();\n\n        action = new MergeRowsAtomicsAction(action, duplicatedAtomicAction);\n        new AtomicsWriter(action).writeTo(destination.getPath().toString());\n\n        context.getPipeline().run().waitUntilFinish();\n\n        controller.deserializeDataFromAvro(destination.getPath());\n\n        long atomicName1Val = clientAPI.getIgnite().atomicLong(atomicName1, 1, false).get();\n        Assert.assertEquals(atomicName1Val, 2);\n\n        map.put(atomicName1 + 1, (long) 1);\n        map.put(atomicName2 + 1, (long) 1);\n        map.put(atomicName3 + 1, (long) 1);\n\n        clientAPI.clearIgniteAndCheckIgniteIsEmpty(map);\n    }\n}", "item_id": 0, "repo": "Alliedium/ignite-migration-tool", "file": "products/patchtools/src/test/java/org/alliedium/ignite/migration/patchtools/AtomicsPatchToolsTest.java", "last_update_at": "2022-03-30T22:10:25+00:00", "question_id": "d435873e6a99c0887e0e3314e1e98a372d5792a7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AtomicsPatchToolsTest extends BaseTest {\n    @Test\n    public void testAtomicPatchTools(Method method) {\n        String methodName = method.getName();\n        String atomicName1 = methodName + 1;\n        String atomicName2 = methodName + 2;\n        String atomicName3 = methodName + 3;\n        clientAPI.getIgnite().atomicLong(atomicName1, 1, true);\n        clientAPI.getIgnite().atomicLong(atomicName2, 1, true);\n        clientAPI.getIgnite().atomicLong(atomicName3, 1, true);\n        controller = new Controller(clientAPI.getIgnite(),\n                () -> Stream.of(atomicName1, atomicName2, atomicName3).collect(Collectors.toList()));\n        controller.serializeDataToAvro(source.getPath());\n        PatchContext context = new PatchContext(source, destination);\n        context.prepare();\n        Map<String, Long> map = new HashMap<>();\n        map.put(atomicName1, (long) 1);\n        map.put(atomicName2, (long) 1);\n        map.put(atomicName3, (long) 1);\n        clientAPI.clearIgniteAndCheckIgniteIsEmpty(map);\n        TransformAction<TransformAtomicsOutput> action = new SelectAtomicsAction.Builder()\n                .context(context)\n                .from(source.getPath().toString())\n                .build();\n        TransformAction<TransformAtomicsOutput> duplicatedAtomicAction = new MapAtomicsAction.Builder()\n                .action(action)\n                .map(row -> {\n                    String atomicName = row.getValue(FieldNames.IGNITE_ATOMIC_LONG_NAME_FIELD_NAME);\n                    return Row.fromRow(row)\n                            .withFieldValue(FieldNames.IGNITE_ATOMIC_LONG_NAME_FIELD_NAME, atomicName + 1)\n                            .build();\n                }).build();\n        action = new MapAtomicsAction.Builder()\n                .action(action)\n                .map(row -> {\n                    String atomicName = row.getValue(FieldNames.IGNITE_ATOMIC_LONG_NAME_FIELD_NAME);\n                    long val = row.getValue(FieldNames.IGNITE_ATOMIC_LONG_VALUE_FIELD_NAME);\n                    if (atomicName1.equals(atomicName)) {\n                        val = 2;\n                        map.put(atomicName, val);\n                    }\n                    return Row.fromRow(row)\n                            .withFieldValue(FieldNames.IGNITE_ATOMIC_LONG_VALUE_FIELD_NAME, val)\n                            .build();\n                }).build();\n        action = new MergeRowsAtomicsAction(action, duplicatedAtomicAction);\n        new AtomicsWriter(action).writeTo(destination.getPath().toString());\n        context.getPipeline().run().waitUntilFinish();\n        controller.deserializeDataFromAvro(destination.getPath());\n        long atomicName1Val = clientAPI.getIgnite().atomicLong(atomicName1, 1, false).get();\n        Assert.assertEquals(atomicName1Val, 2);\n        map.put(atomicName1 + 1, (long) 1);\n        map.put(atomicName2 + 1, (long) 1);\n        map.put(atomicName3 + 1, (long) 1);\n        clientAPI.clearIgniteAndCheckIgniteIsEmpty(map);\n    }\n"]], "pred": {"ppl": 2.0822887420654297, "ppl_lower": 2.4401447772979736, "ppl/lowercase_ppl": -1.2162191174260808, "ppl/zlib": 0.0009284400576287122, "Min_5.0% Prob": 6.962438173072282, "Min_10.0% Prob": 5.275292341099229, "Min_20.0% Prob": 3.3667685093218194, "Min_30.0% Prob": 2.397922187585097, "Min_40.0% Prob": 1.8256150319399338, "Min_50.0% Prob": 1.466005543006524, "Min_60.0% Prob": 1.2227469661868322}}
{"hexsha": "6af3f32ebf817c19ce1c1ebf7583a79712c31618", "ext": "java", "lang": "Java", "content": "public class SumToLeafNodes {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tTreeNode root = new TreeNode(1);\n\n\t\tTreeNode child1 = new TreeNode(1);\n\t\tTreeNode child2 = new TreeNode(1);\n\t\tchild1.left = child2;\n\t\troot.right = child1;\n\n\t\tSystem.out.println(sumNumbers(root));\n\t}\n\n\tpublic static int sumNumbers(TreeNode root) {\n\t\treturn sumNumbersHelper(root, 0);\n\t}\n\n\tprivate static int sumNumbersHelper(TreeNode root, int parentSum) {\n\t\tif (root == null)\n\t\t\treturn 0;\n\t\tif (root.left == null && root.right == null)\n\t\t\treturn parentSum * 10 + root.val;\n\t\treturn sumNumbersHelper(root.left, parentSum * 10 + root.val)\n\t\t\t\t+ sumNumbersHelper(root.right, parentSum * 10 + root.val);\n\t}\n}", "item_id": 0, "repo": "jamsrandorjb/AlgorithmProblems", "file": "src/leetcode/tree/SumToLeafNodes.java", "last_update_at": "2022-03-03T10:19:27+00:00", "question_id": "6af3f32ebf817c19ce1c1ebf7583a79712c31618_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SumToLeafNodes {\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tTreeNode root = new TreeNode(1);\n\t\tTreeNode child1 = new TreeNode(1);\n\t\tTreeNode child2 = new TreeNode(1);\n\t\tchild1.left = child2;\n\t\troot.right = child1;\n\t\tSystem.out.println(sumNumbers(root));\n\t}\n\tpublic static int sumNumbers(TreeNode root) {\n\t\treturn sumNumbersHelper(root, 0);\n\t}\n\tprivate static int sumNumbersHelper(TreeNode root, int parentSum) {\n\t\tif (root == null)\n\t\t\treturn 0;\n\t\tif (root.left == null && root.right == null)\n\t\t\treturn parentSum * 10 + root.val;\n\t\treturn sumNumbersHelper(root.left, parentSum * 10 + root.val)\n\t\t\t\t+ sumNumbersHelper(root.right, parentSum * 10 + root.val);\n\t}\n"]], "pred": {"ppl": 1.487510323524475, "ppl_lower": 1.8421368598937988, "ppl/lowercase_ppl": -1.5384547739065415, "ppl/zlib": 0.0012977248320198884, "Min_5.0% Prob": 4.878739448694082, "Min_10.0% Prob": 3.2227126451639028, "Min_20.0% Prob": 1.9010583248275976, "Min_30.0% Prob": 1.3068065743280362, "Min_40.0% Prob": 0.9931950168772823, "Min_50.0% Prob": 0.7923291829083059, "Min_60.0% Prob": 0.6628728023806846}}
{"hexsha": "0c3eba503fb8044e681ad301af929a519c1f7b16", "ext": "java", "lang": "Java", "content": "public class CCC_2014_J5_S2 {\n\n  public static Scanner scan = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    int n = scan.nextInt();\n    scan.nextLine();\n    ArrayList<String> students1 = new ArrayList<String>(Arrays.asList(scan.nextLine().split(\" \")));\n    ArrayList<String> students2 = new ArrayList<String>(Arrays.asList(scan.nextLine().split(\" \")));\n\n  main:\n    for (int x = 0; x < n; x++) {\n      for (int y = 0; y < n; y++) {\n        if (y == x)\n          continue;\n        if (students1.get(x).equals(students2.get(y)) && students2.get(x).equals(students1.get(y)))\n          continue main;\n      }\n      System.out.println(\"bad\");\n      System.exit(0);\n    }\n    System.out.println(\"good\");\n  }\n}", "item_id": 0, "repo": "anshika581/competitive-programming-1", "file": "src/contest/ccc/CCC_2014_J5_S2.java", "last_update_at": "2022-02-12T13:50:27+00:00", "question_id": "0c3eba503fb8044e681ad301af929a519c1f7b16_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CCC_2014_J5_S2 {\n  public static Scanner scan = new Scanner(System.in);\n  public static void main(String[] args) {\n    int n = scan.nextInt();\n    scan.nextLine();\n    ArrayList<String> students1 = new ArrayList<String>(Arrays.asList(scan.nextLine().split(\" \")));\n    ArrayList<String> students2 = new ArrayList<String>(Arrays.asList(scan.nextLine().split(\" \")));\n  main:\n    for (int x = 0; x < n; x++) {\n      for (int y = 0; y < n; y++) {\n        if (y == x)\n          continue;\n        if (students1.get(x).equals(students2.get(y)) && students2.get(x).equals(students1.get(y)))\n          continue main;\n      }\n      System.out.println(\"bad\");\n      System.exit(0);\n    }\n    System.out.println(\"good\");\n  }\n"]], "pred": {"ppl": 1.758605718612671, "ppl_lower": 2.0019748210906982, "ppl/lowercase_ppl": -1.2295977433133394, "ppl/zlib": 0.0017978385024072618, "Min_5.0% Prob": 6.291856984297435, "Min_10.0% Prob": 4.361032190322876, "Min_20.0% Prob": 2.645950021147728, "Min_30.0% Prob": 1.8319546270527338, "Min_40.0% Prob": 1.4039792449831372, "Min_50.0% Prob": 1.1243136221850951, "Min_60.0% Prob": 0.9418126144752789}}
{"hexsha": "1d615816737b5bd4944e0bd0fd4529565a4e81d5", "ext": "java", "lang": "Java", "content": "public class OperationalLimitType extends IdentifiedObject {\n\t/**\n\t * The default value of the '{@link #getDirection() <em>Direction</em>}' attribute.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @see #getDirection()\n\t * @generated\n\t * @ordered\n\t */\n\tprotected static final OperationalLimitDirectionKind DIRECTION_EDEFAULT = OperationalLimitDirectionKind.LOW;\n\n\t/**\n\t * The cached value of the '{@link #getDirection() <em>Direction</em>}' attribute.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @see #getDirection()\n\t * @generated\n\t * @ordered\n\t */\n\tprotected OperationalLimitDirectionKind direction = DIRECTION_EDEFAULT;\n\n\t/**\n\t * This is true if the Direction attribute has been set.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t * @ordered\n\t */\n\tprotected boolean directionESet;\n\n\t/**\n\t * The cached value of the '{@link #getOperationalLimit() <em>Operational Limit</em>}' reference list.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @see #getOperationalLimit()\n\t * @generated\n\t * @ordered\n\t */\n\tprotected EList<OperationalLimit> operationalLimit;\n\n\t/**\n\t * The default value of the '{@link #getAcceptableDuration() <em>Acceptable Duration</em>}' attribute.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @see #getAcceptableDuration()\n\t * @generated\n\t * @ordered\n\t */\n\tprotected static final float ACCEPTABLE_DURATION_EDEFAULT = 0.0F;\n\n\t/**\n\t * The cached value of the '{@link #getAcceptableDuration() <em>Acceptable Duration</em>}' attribute.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @see #getAcceptableDuration()\n\t * @generated\n\t * @ordered\n\t */\n\tprotected float acceptableDuration = ACCEPTABLE_DURATION_EDEFAULT;\n\n\t/**\n\t * This is true if the Acceptable Duration attribute has been set.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t * @ordered\n\t */\n\tprotected boolean acceptableDurationESet;\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tprotected OperationalLimitType() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tprotected EClass eStaticClass() {\n\t\treturn OperationalLimitsPackage.Literals.OPERATIONAL_LIMIT_TYPE;\n\t}\n\n\t/**\n\t * Returns the value of the '<em><b>Direction</b></em>' attribute.\n\t * The literals are from the enumeration {@link CIM15.IEC61970.OperationalLimits.OperationalLimitDirectionKind}.\n\t * <!-- begin-user-doc -->\n\t * <p>\n\t * If the meaning of the '<em>Direction</em>' attribute isn't clear,\n\t * there really should be more of a description here...\n\t * </p>\n\t * <!-- end-user-doc -->\n\t * @return the value of the '<em>Direction</em>' attribute.\n\t * @see CIM15.IEC61970.OperationalLimits.OperationalLimitDirectionKind\n\t * @see #isSetDirection()\n\t * @see #unsetDirection()\n\t * @see #setDirection(OperationalLimitDirectionKind)\n\t * @generated\n\t */\n\tpublic OperationalLimitDirectionKind getDirection() {\n\t\treturn direction;\n\t}\n\n\t/**\n\t * Sets the value of the '{@link CIM15.IEC61970.OperationalLimits.OperationalLimitType#getDirection <em>Direction</em>}' attribute.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @param value the new value of the '<em>Direction</em>' attribute.\n\t * @see CIM15.IEC61970.OperationalLimits.OperationalLimitDirectionKind\n\t * @see #isSetDirection()\n\t * @see #unsetDirection()\n\t * @see #getDirection()\n\t * @generated\n\t */\n\tpublic void setDirection(OperationalLimitDirectionKind newDirection) {\n\t\tdirection = newDirection == null ? DIRECTION_EDEFAULT : newDirection;\n\t\tdirectionESet = true;\n\t}\n\n\t/**\n\t * Unsets the value of the '{@link CIM15.IEC61970.OperationalLimits.OperationalLimitType#getDirection <em>Direction</em>}' attribute.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @see #isSetDirection()\n\t * @see #getDirection()\n\t * @see #setDirection(OperationalLimitDirectionKind)\n\t * @generated\n\t */\n\tpublic void unsetDirection() {\n\t\tdirection = DIRECTION_EDEFAULT;\n\t\tdirectionESet = false;\n\t}\n\n\t/**\n\t * Returns whether the value of the '{@link CIM15.IEC61970.OperationalLimits.OperationalLimitType#getDirection <em>Direction</em>}' attribute is set.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @return whether the value of the '<em>Direction</em>' attribute is set.\n\t * @see #unsetDirection()\n\t * @see #getDirection()\n\t * @see #setDirection(OperationalLimitDirectionKind)\n\t * @generated\n\t */\n\tpublic boolean isSetDirection() {\n\t\treturn directionESet;\n\t}\n\n\t/**\n\t * Returns the value of the '<em><b>Operational Limit</b></em>' reference list.\n\t * The list contents are of type {@link CIM15.IEC61970.OperationalLimits.OperationalLimit}.\n\t * It is bidirectional and its opposite is '{@link CIM15.IEC61970.OperationalLimits.OperationalLimit#getOperationalLimitType <em>Operational Limit Type</em>}'.\n\t * <!-- begin-user-doc -->\n\t * <p>\n\t * If the meaning of the '<em>Operational Limit</em>' reference list isn't clear,\n\t * there really should be more of a description here...\n\t * </p>\n\t * <!-- end-user-doc -->\n\t * @return the value of the '<em>Operational Limit</em>' reference list.\n\t * @see CIM15.IEC61970.OperationalLimits.OperationalLimit#getOperationalLimitType\n\t * @generated\n\t */\n\tpublic EList<OperationalLimit> getOperationalLimit() {\n\t\tif (operationalLimit == null) {\n\t\t\toperationalLimit = new BasicInternalEList<OperationalLimit>(OperationalLimit.class);\n\t\t}\n\t\treturn operationalLimit;\n\t}\n\n\t/**\n\t * Returns the value of the '<em><b>Acceptable Duration</b></em>' attribute.\n\t * <!-- begin-user-doc -->\n\t * <p>\n\t * If the meaning of the '<em>Acceptable Duration</em>' attribute isn't clear,\n\t * there really should be more of a description here...\n\t * </p>\n\t * <!-- end-user-doc -->\n\t * @return the value of the '<em>Acceptable Duration</em>' attribute.\n\t * @see #isSetAcceptableDuration()\n\t * @see #unsetAcceptableDuration()\n\t * @see #setAcceptableDuration(float)\n\t * @generated\n\t */\n\tpublic float getAcceptableDuration() {\n\t\treturn acceptableDuration;\n\t}\n\n\t/**\n\t * Sets the value of the '{@link CIM15.IEC61970.OperationalLimits.OperationalLimitType#getAcceptableDuration <em>Acceptable Duration</em>}' attribute.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @param value the new value of the '<em>Acceptable Duration</em>' attribute.\n\t * @see #isSetAcceptableDuration()\n\t * @see #unsetAcceptableDuration()\n\t * @see #getAcceptableDuration()\n\t * @generated\n\t */\n\tpublic void setAcceptableDuration(float newAcceptableDuration) {\n\t\tacceptableDuration = newAcceptableDuration;\n\t\tacceptableDurationESet = true;\n\t}\n\n\t/**\n\t * Unsets the value of the '{@link CIM15.IEC61970.OperationalLimits.OperationalLimitType#getAcceptableDuration <em>Acceptable Duration</em>}' attribute.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @see #isSetAcceptableDuration()\n\t * @see #getAcceptableDuration()\n\t * @see #setAcceptableDuration(float)\n\t * @generated\n\t */\n\tpublic void unsetAcceptableDuration() {\n\t\tacceptableDuration = ACCEPTABLE_DURATION_EDEFAULT;\n\t\tacceptableDurationESet = false;\n\t}\n\n\t/**\n\t * Returns whether the value of the '{@link CIM15.IEC61970.OperationalLimits.OperationalLimitType#getAcceptableDuration <em>Acceptable Duration</em>}' attribute is set.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @return whether the value of the '<em>Acceptable Duration</em>' attribute is set.\n\t * @see #unsetAcceptableDuration()\n\t * @see #getAcceptableDuration()\n\t * @see #setAcceptableDuration(float)\n\t * @generated\n\t */\n\tpublic boolean isSetAcceptableDuration() {\n\t\treturn acceptableDurationESet;\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs) {\n\t\tswitch (featureID) {\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__OPERATIONAL_LIMIT:\n\t\t\t\treturn ((InternalEList<InternalEObject>)(InternalEList<?>)getOperationalLimit()).basicAdd(otherEnd, msgs);\n\t\t}\n\t\treturn super.eInverseAdd(otherEnd, featureID, msgs);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs) {\n\t\tswitch (featureID) {\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__OPERATIONAL_LIMIT:\n\t\t\t\treturn ((InternalEList<?>)getOperationalLimit()).basicRemove(otherEnd, msgs);\n\t\t}\n\t\treturn super.eInverseRemove(otherEnd, featureID, msgs);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic Object eGet(int featureID, boolean resolve, boolean coreType) {\n\t\tswitch (featureID) {\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__DIRECTION:\n\t\t\t\treturn getDirection();\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__OPERATIONAL_LIMIT:\n\t\t\t\treturn getOperationalLimit();\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__ACCEPTABLE_DURATION:\n\t\t\t\treturn getAcceptableDuration();\n\t\t}\n\t\treturn super.eGet(featureID, resolve, coreType);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic void eSet(int featureID, Object newValue) {\n\t\tswitch (featureID) {\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__DIRECTION:\n\t\t\t\tsetDirection((OperationalLimitDirectionKind)newValue);\n\t\t\t\treturn;\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__OPERATIONAL_LIMIT:\n\t\t\t\tgetOperationalLimit().clear();\n\t\t\t\tgetOperationalLimit().addAll((Collection<? extends OperationalLimit>)newValue);\n\t\t\t\treturn;\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__ACCEPTABLE_DURATION:\n\t\t\t\tsetAcceptableDuration((Float)newValue);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eSet(featureID, newValue);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eUnset(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__DIRECTION:\n\t\t\t\tunsetDirection();\n\t\t\t\treturn;\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__OPERATIONAL_LIMIT:\n\t\t\t\tgetOperationalLimit().clear();\n\t\t\t\treturn;\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__ACCEPTABLE_DURATION:\n\t\t\t\tunsetAcceptableDuration();\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eUnset(featureID);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic boolean eIsSet(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__DIRECTION:\n\t\t\t\treturn isSetDirection();\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__OPERATIONAL_LIMIT:\n\t\t\t\treturn operationalLimit != null && !operationalLimit.isEmpty();\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__ACCEPTABLE_DURATION:\n\t\t\t\treturn isSetAcceptableDuration();\n\t\t}\n\t\treturn super.eIsSet(featureID);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic String toString() {\n\t\tif (eIsProxy()) return super.toString();\n\n\t\tStringBuffer result = new StringBuffer(super.toString());\n\t\tresult.append(\" (direction: \");\n\t\tif (directionESet) result.append(direction); else result.append(\"<unset>\");\n\t\tresult.append(\", acceptableDuration: \");\n\t\tif (acceptableDurationESet) result.append(acceptableDuration); else result.append(\"<unset>\");\n\t\tresult.append(')');\n\t\treturn result.toString();\n\t}\n\n}", "item_id": 0, "repo": "SES-fortiss/SmartGridCoSimulation", "file": "core/cim15/src/CIM15/IEC61970/OperationalLimits/OperationalLimitType.java", "last_update_at": "2022-01-16T14:21:49+00:00", "question_id": "1d615816737b5bd4944e0bd0fd4529565a4e81d5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OperationalLimitType extends IdentifiedObject {\n\t/**\n\t * The default value of the '{@link #getDirection() <em>Direction</em>}' attribute.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @see #getDirection()\n\t * @generated\n\t * @ordered\n\t */\n\tprotected static final OperationalLimitDirectionKind DIRECTION_EDEFAULT = OperationalLimitDirectionKind.LOW;\n\t/**\n\t * The cached value of the '{@link #getDirection() <em>Direction</em>}' attribute.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @see #getDirection()\n\t * @generated\n\t * @ordered\n\t */\n\tprotected OperationalLimitDirectionKind direction = DIRECTION_EDEFAULT;\n\t/**\n\t * This is true if the Direction attribute has been set.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t * @ordered\n\t */\n\tprotected boolean directionESet;\n\t/**\n\t * The cached value of the '{@link #getOperationalLimit() <em>Operational Limit</em>}' reference list.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @see #getOperationalLimit()\n\t * @generated\n\t * @ordered\n\t */\n\tprotected EList<OperationalLimit> operationalLimit;\n\t/**\n\t * The default value of the '{@link #getAcceptableDuration() <em>Acceptable Duration</em>}' attribute.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @see #getAcceptableDuration()\n\t * @generated\n\t * @ordered\n\t */\n\tprotected static final float ACCEPTABLE_DURATION_EDEFAULT = 0.0F;\n\t/**\n\t * The cached value of the '{@link #getAcceptableDuration() <em>Acceptable Duration</em>}' attribute.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @see #getAcceptableDuration()\n\t * @generated\n\t * @ordered\n\t */\n\tprotected float acceptableDuration = ACCEPTABLE_DURATION_EDEFAULT;\n\t/**\n\t * This is true if the Acceptable Duration attribute has been set.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t * @ordered\n\t */\n\tprotected boolean acceptableDurationESet;\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tprotected OperationalLimitType() {\n\t\tsuper();\n\t}\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tprotected EClass eStaticClass() {\n\t\treturn OperationalLimitsPackage.Literals.OPERATIONAL_LIMIT_TYPE;\n\t}\n\t/**\n\t * Returns the value of the '<em><b>Direction</b></em>' attribute.\n\t * The literals are from the enumeration {@link CIM15.IEC61970.OperationalLimits.OperationalLimitDirectionKind}.\n\t * <!-- begin-user-doc -->\n\t * <p>\n\t * If the meaning of the '<em>Direction</em>' attribute isn't clear,\n\t * there really should be more of a description here...\n\t * </p>\n\t * <!-- end-user-doc -->\n\t * @return the value of the '<em>Direction</em>' attribute.\n\t * @see CIM15.IEC61970.OperationalLimits.OperationalLimitDirectionKind\n\t * @see #isSetDirection()\n\t * @see #unsetDirection()\n\t * @see #setDirection(OperationalLimitDirectionKind)\n\t * @generated\n\t */\n\tpublic OperationalLimitDirectionKind getDirection() {\n\t\treturn direction;\n\t}\n\t/**\n\t * Sets the value of the '{@link CIM15.IEC61970.OperationalLimits.OperationalLimitType#getDirection <em>Direction</em>}' attribute.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @param value the new value of the '<em>Direction</em>' attribute.\n\t * @see CIM15.IEC61970.OperationalLimits.OperationalLimitDirectionKind\n\t * @see #isSetDirection()\n\t * @see #unsetDirection()\n\t * @see #getDirection()\n\t * @generated\n\t */\n\tpublic void setDirection(OperationalLimitDirectionKind newDirection) {\n\t\tdirection = newDirection == null ? DIRECTION_EDEFAULT : newDirection;\n\t\tdirectionESet = true;\n\t}\n\t/**\n\t * Unsets the value of the '{@link CIM15.IEC61970.OperationalLimits.OperationalLimitType#getDirection <em>Direction</em>}' attribute.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @see #isSetDirection()\n\t * @see #getDirection()\n\t * @see #setDirection(OperationalLimitDirectionKind)\n\t * @generated\n\t */\n\tpublic void unsetDirection() {\n\t\tdirection = DIRECTION_EDEFAULT;\n\t\tdirectionESet = false;\n\t}\n\t/**\n\t * Returns whether the value of the '{@link CIM15.IEC61970.OperationalLimits.OperationalLimitType#getDirection <em>Direction</em>}' attribute is set.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @return whether the value of the '<em>Direction</em>' attribute is set.\n\t * @see #unsetDirection()\n\t * @see #getDirection()\n\t * @see #setDirection(OperationalLimitDirectionKind)\n\t * @generated\n\t */\n\tpublic boolean isSetDirection() {\n\t\treturn directionESet;\n\t}\n\t/**\n\t * Returns the value of the '<em><b>Operational Limit</b></em>' reference list.\n\t * The list contents are of type {@link CIM15.IEC61970.OperationalLimits.OperationalLimit}.\n\t * It is bidirectional and its opposite is '{@link CIM15.IEC61970.OperationalLimits.OperationalLimit#getOperationalLimitType <em>Operational Limit Type</em>}'.\n\t * <!-- begin-user-doc -->\n\t * <p>\n\t * If the meaning of the '<em>Operational Limit</em>' reference list isn't clear,\n\t * there really should be more of a description here...\n\t * </p>\n\t * <!-- end-user-doc -->\n\t * @return the value of the '<em>Operational Limit</em>' reference list.\n\t * @see CIM15.IEC61970.OperationalLimits.OperationalLimit#getOperationalLimitType\n\t * @generated\n\t */\n\tpublic EList<OperationalLimit> getOperationalLimit() {\n\t\tif (operationalLimit == null) {\n\t\t\toperationalLimit = new BasicInternalEList<OperationalLimit>(OperationalLimit.class);\n\t\t}\n\t\treturn operationalLimit;\n\t}\n\t/**\n\t * Returns the value of the '<em><b>Acceptable Duration</b></em>' attribute.\n\t * <!-- begin-user-doc -->\n\t * <p>\n\t * If the meaning of the '<em>Acceptable Duration</em>' attribute isn't clear,\n\t * there really should be more of a description here...\n\t * </p>\n\t * <!-- end-user-doc -->\n\t * @return the value of the '<em>Acceptable Duration</em>' attribute.\n\t * @see #isSetAcceptableDuration()\n\t * @see #unsetAcceptableDuration()\n\t * @see #setAcceptableDuration(float)\n\t * @generated\n\t */\n\tpublic float getAcceptableDuration() {\n\t\treturn acceptableDuration;\n\t}\n\t/**\n\t * Sets the value of the '{@link CIM15.IEC61970.OperationalLimits.OperationalLimitType#getAcceptableDuration <em>Acceptable Duration</em>}' attribute.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @param value the new value of the '<em>Acceptable Duration</em>' attribute.\n\t * @see #isSetAcceptableDuration()\n\t * @see #unsetAcceptableDuration()\n\t * @see #getAcceptableDuration()\n\t * @generated\n\t */\n\tpublic void setAcceptableDuration(float newAcceptableDuration) {\n\t\tacceptableDuration = newAcceptableDuration;\n\t\tacceptableDurationESet = true;\n\t}\n\t/**\n\t * Unsets the value of the '{@link CIM15.IEC61970.OperationalLimits.OperationalLimitType#getAcceptableDuration <em>Acceptable Duration</em>}' attribute.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @see #isSetAcceptableDuration()\n\t * @see #getAcceptableDuration()\n\t * @see #setAcceptableDuration(float)\n\t * @generated\n\t */\n\tpublic void unsetAcceptableDuration() {\n\t\tacceptableDuration = ACCEPTABLE_DURATION_EDEFAULT;\n\t\tacceptableDurationESet = false;\n\t}\n\t/**\n\t * Returns whether the value of the '{@link CIM15.IEC61970.OperationalLimits.OperationalLimitType#getAcceptableDuration <em>Acceptable Duration</em>}' attribute is set.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @return whether the value of the '<em>Acceptable Duration</em>' attribute is set.\n\t * @see #unsetAcceptableDuration()\n\t * @see #getAcceptableDuration()\n\t * @see #setAcceptableDuration(float)\n\t * @generated\n\t */\n\tpublic boolean isSetAcceptableDuration() {\n\t\treturn acceptableDurationESet;\n\t}\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs) {\n\t\tswitch (featureID) {\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__OPERATIONAL_LIMIT:\n\t\t\t\treturn ((InternalEList<InternalEObject>)(InternalEList<?>)getOperationalLimit()).basicAdd(otherEnd, msgs);\n\t\t}\n\t\treturn super.eInverseAdd(otherEnd, featureID, msgs);\n\t}\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs) {\n\t\tswitch (featureID) {\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__OPERATIONAL_LIMIT:\n\t\t\t\treturn ((InternalEList<?>)getOperationalLimit()).basicRemove(otherEnd, msgs);\n\t\t}\n\t\treturn super.eInverseRemove(otherEnd, featureID, msgs);\n\t}\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic Object eGet(int featureID, boolean resolve, boolean coreType) {\n\t\tswitch (featureID) {\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__DIRECTION:\n\t\t\t\treturn getDirection();\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__OPERATIONAL_LIMIT:\n\t\t\t\treturn getOperationalLimit();\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__ACCEPTABLE_DURATION:\n\t\t\t\treturn getAcceptableDuration();\n\t\t}\n\t\treturn super.eGet(featureID, resolve, coreType);\n\t}\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic void eSet(int featureID, Object newValue) {\n\t\tswitch (featureID) {\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__DIRECTION:\n\t\t\t\tsetDirection((OperationalLimitDirectionKind)newValue);\n\t\t\t\treturn;\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__OPERATIONAL_LIMIT:\n\t\t\t\tgetOperationalLimit().clear();\n\t\t\t\tgetOperationalLimit().addAll((Collection<? extends OperationalLimit>)newValue);\n\t\t\t\treturn;\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__ACCEPTABLE_DURATION:\n\t\t\t\tsetAcceptableDuration((Float)newValue);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eSet(featureID, newValue);\n\t}\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eUnset(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__DIRECTION:\n\t\t\t\tunsetDirection();\n\t\t\t\treturn;\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__OPERATIONAL_LIMIT:\n\t\t\t\tgetOperationalLimit().clear();\n\t\t\t\treturn;\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__ACCEPTABLE_DURATION:\n\t\t\t\tunsetAcceptableDuration();\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eUnset(featureID);\n\t}\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic boolean eIsSet(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__DIRECTION:\n\t\t\t\treturn isSetDirection();\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__OPERATIONAL_LIMIT:\n\t\t\t\treturn operationalLimit != null && !operationalLimit.isEmpty();\n\t\t\tcase OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__ACCEPTABLE_DURATION:\n\t\t\t\treturn isSetAcceptableDuration();\n\t\t}\n\t\treturn super.eIsSet(featureID);\n\t}\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic String toString() {\n\t\tif (eIsProxy()) return super.toString();\n\t\tStringBuffer result = new StringBuffer(super.toString());\n\t\tresult.append(\" (direction: \");\n\t\tif (directionESet) result.append(direction); else result.append(\"<unset>\");\n\t\tresult.append(\", acceptableDuration: \");\n\t\tif (acceptableDurationESet) result.append(acceptableDuration); else result.append(\"<unset>\");\n\t\tresult.append(')');\n\t\treturn result.toString();\n\t}\n"]], "pred": {"ppl": 1.6555302143096924, "ppl_lower": 1.8844339847564697, "ppl/lowercase_ppl": -1.2568948512802305, "ppl/zlib": 0.00030405387738554923, "Min_5.0% Prob": 6.623338680641324, "Min_10.0% Prob": 4.3958445016075585, "Min_20.0% Prob": 2.465441672460121, "Min_30.0% Prob": 1.6754313875720197, "Min_40.0% Prob": 1.2589363629672412, "Min_50.0% Prob": 1.0087125213505106, "Min_60.0% Prob": 0.8411577262722532}}
{"hexsha": "a51f15390d2709779fb27cb6a557fca2488c6e3d", "ext": "java", "lang": "Java", "content": "@Order(-9)\n@Component\npublic class DoubleInterpolatorSupportingContextMenuItem implements PropertyValueContextMenuItem {\n    private CurveEditorTab curveEditorTab;\n    private DockableTabRepository dockableTabRepository;\n\n    public DoubleInterpolatorSupportingContextMenuItem(CurveEditorTab curveEditorTab, DockableTabRepository dockableTabRepository) {\n        this.curveEditorTab = curveEditorTab;\n        this.dockableTabRepository = dockableTabRepository;\n    }\n\n    @Override\n    public boolean supports(PropertyValueContextMenuRequest request) {\n        return request.valueProvider.getInterpolator() instanceof DoubleInterpolator;\n    }\n\n    @Override\n    public MenuItem createMenuItem(PropertyValueContextMenuRequest request) {\n        MenuItem revealInEditorMenuItem = new MenuItem(\"Reveal curve in editor\");\n        revealInEditorMenuItem.setOnAction(e -> {\n            OpenTabRequest tabOpenRequest = OpenTabRequest.builder()\n                    .withTabToOpen(curveEditorTab)\n                    .withTarget(MAIN_WINDOW)\n                    .withSameTabPaneAs(Optional.of(AddableContentDockableTabFactory.ID))\n                    .build();\n            dockableTabRepository.openTab(tabOpenRequest);\n            curveEditorTab.revealInEditor(request.valueProvider);\n        });\n        return revealInEditorMenuItem;\n    }\n\n}", "item_id": 0, "repo": "helospark/tactview", "file": "tactview-ui/src/main/java/com/helospark/tactview/ui/javafx/uicomponents/propertyvalue/contextmenu/DoubleInterpolatorSupportingContextMenuItem.java", "last_update_at": "2022-02-22T15:07:27+00:00", "question_id": "a51f15390d2709779fb27cb6a557fca2488c6e3d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Order(-9)\n@Component\npublic class DoubleInterpolatorSupportingContextMenuItem implements PropertyValueContextMenuItem {\n    private CurveEditorTab curveEditorTab;\n    private DockableTabRepository dockableTabRepository;\n    public DoubleInterpolatorSupportingContextMenuItem(CurveEditorTab curveEditorTab, DockableTabRepository dockableTabRepository) {\n        this.curveEditorTab = curveEditorTab;\n        this.dockableTabRepository = dockableTabRepository;\n    }\n    @Override\n    public boolean supports(PropertyValueContextMenuRequest request) {\n        return request.valueProvider.getInterpolator() instanceof DoubleInterpolator;\n    }\n    @Override\n    public MenuItem createMenuItem(PropertyValueContextMenuRequest request) {\n        MenuItem revealInEditorMenuItem = new MenuItem(\"Reveal curve in editor\");\n        revealInEditorMenuItem.setOnAction(e -> {\n            OpenTabRequest tabOpenRequest = OpenTabRequest.builder()\n                    .withTabToOpen(curveEditorTab)\n                    .withTarget(MAIN_WINDOW)\n                    .withSameTabPaneAs(Optional.of(AddableContentDockableTabFactory.ID))\n                    .build();\n            dockableTabRepository.openTab(tabOpenRequest);\n            curveEditorTab.revealInEditor(request.valueProvider);\n        });\n        return revealInEditorMenuItem;\n    }\n"]], "pred": {"ppl": 2.881887435913086, "ppl_lower": 3.741487979888916, "ppl/lowercase_ppl": -1.2466239061916335, "ppl/zlib": 0.002311016242763131, "Min_5.0% Prob": 8.855641722679138, "Min_10.0% Prob": 7.042876330288974, "Min_20.0% Prob": 4.733343608451612, "Min_30.0% Prob": 3.4450627583445925, "Min_40.0% Prob": 2.628665267188746, "Min_50.0% Prob": 2.1191755909338057, "Min_60.0% Prob": 1.7703519643836623}}
{"hexsha": "ce26cb7a0fbee81d713706f4faea17a7415b46ea", "ext": "java", "lang": "Java", "content": "public final class Markers {\n\n    /** Caches markers loaded from resources file. */\n    private static final List<Marker> MARKER_CACHE = Lists.newArrayList();\n    /** Singleton for empty path. */\n    private static final GeneralPath EMPTY_PATH = new GeneralPath();\n\n    //region STATIC INSTANCES\n\n    public static final BlankMarker BLANK = new BlankMarker();\n    public static final CircleMarker CIRCLE = new CircleMarker();\n    public static final SquareMarker SQUARE = new SquareMarker();\n    public static final DiamondMarker DIAMOND = new DiamondMarker();\n    public static final TriangleMarker TRIANGLE = new TriangleMarker();\n    public static final StarMarker5 STAR = new StarMarker5();\n    public static final StarMarker7 STAR7 = new StarMarker7();\n    public static final StarMarker11 STAR11 = new StarMarker11();\n    public static final PlusMarker PLUS = new PlusMarker();\n    public static final CrossMarker CROSS = new CrossMarker();\n    public static final TargetMarker TARGET = new TargetMarker();\n    public static final ArrowMarker ARROW = new ArrowMarker();\n    public static final GapArrowMarker GAP_ARROW = new GapArrowMarker();\n    public static final ThickArrowMarker THICK_ARROW = new ThickArrowMarker();\n    public static final ChevronMarker CHEVRON_MARKER = new ChevronMarker();\n    public static final TriangleMarkerForward TRIANGLE_ARROW = new TriangleMarkerForward();\n    public static final ArrowheadMarker ARROWHEAD = new ArrowheadMarker();\n    public static final TeardropMarker TEARDROP = new TeardropMarker();\n    public static final HappyFaceMarker HAPPYFACE = new HappyFaceMarker();\n    public static final HouseMarker HOUSE = new HouseMarker();\n\n    //endregion\n\n    /**\n     * Utility class\n     */\n    private Markers() {\n    }\n\n    /**\n     * Retrieve list of available shapes.\n     * @return list of marker constants\n     */\n    public static List<Marker> getAvailableMarkers() {\n        if (MARKER_CACHE.isEmpty()) {\n            ServiceLoader<Marker> loader = ServiceLoader.load(Marker.class);\n            Iterables.addAll(MARKER_CACHE, loader);\n        }\n        return Collections.unmodifiableList(MARKER_CACHE);\n    }\n\n    /**\n     * Blank marker.\n     */\n    public static class BlankMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            return EMPTY_PATH;\n        }\n    }\n\n    /**\n     * Circle marker.\n     */\n    public static class CircleMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            return new Ellipse2D.Double(p.getX() - radius, p.getY() - radius, 2 * radius, 2 * radius);\n        }\n    }\n\n    /**\n     * Square marker.\n     */\n    public static class SquareMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            return new Rectangle2D.Double(\n                    p.getX() - radius / Math.sqrt(2),\n                    p.getY() - radius / Math.sqrt(2),\n                    2 * radius / Math.sqrt(2),\n                    2 * radius / Math.sqrt(2));\n        }\n    }\n\n    /**\n     * Diamond marker.\n     */\n    public static class DiamondMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) x, (float) (y - radius));\n            path.lineTo((float) (x - radius), (float) y);\n            path.lineTo((float) x, (float) (y + radius));\n            path.lineTo((float) (x + radius), (float) y);\n            path.closePath();\n            return path;\n        }\n    }\n\n    /**\n     * Triangle marker, pointing up.\n     */\n    public static class TriangleMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) x, (float) (y - radius));\n            path.lineTo((float) (x + radius * Math.cos(Math.PI * 1.16667)),\n                    (float) (y - radius * Math.sin(Math.PI * 1.16667)));\n            path.lineTo((float) (x + radius * Math.cos(Math.PI * 1.83333)),\n                    (float) (y - radius * Math.sin(Math.PI * 1.83333)));\n            path.closePath();\n            return path;\n        }\n    }\n\n    /**\n     * Five point star marker.\n     */\n    public static class StarMarker5 implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) x, (float) (y - radius));\n            for (int i = 0; i < 5; i++) {\n                double theta = Math.PI / 2 + 2 * Math.PI * i / 5;\n                path.lineTo((float) (x + radius * Math.cos(theta)),\n                        (float) (y - radius * Math.sin(theta)));\n                theta += Math.PI / 5;\n                path.lineTo((float) (x + radius / Math.sqrt(8) * Math.cos(theta)),\n                        (float) (y - radius / Math.sqrt(8) * Math.sin(theta)));\n            }\n            path.closePath();\n            return path;\n        }\n    }\n\n    /**\n     * Seven point star marker.\n     */\n    public static class StarMarker7 implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) x, (float) (y - radius));\n            for (int i = 0; i < 7; i++) {\n                double theta = Math.PI / 2 + 2 * Math.PI * i / 7;\n                path.lineTo((float) (x + radius * Math.cos(theta)),\n                        (float) (y - radius * Math.sin(theta)));\n                theta += Math.PI / 7;\n                path.lineTo((float) (x + radius / 2 * Math.cos(theta)),\n                        (float) (y - radius / 2 * Math.sin(theta)));\n            }\n            path.closePath();\n            return path;\n        }\n    }\n\n    /**\n     * Eleven point star marker.\n     */\n    public static class StarMarker11 implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) x, (float) (y - radius));\n            for (int i = 0; i < 11; i++) {\n                double theta = Math.PI / 2 + 2 * Math.PI * i / 11;\n                path.lineTo((float) (x + radius * Math.cos(theta)),\n                        (float) (y - radius * Math.sin(theta)));\n                theta += Math.PI / 11;\n                path.lineTo((float) (x + radius / 1.5 * Math.cos(theta)),\n                        (float) (y - radius / 1.5 * Math.sin(theta)));\n            }\n            path.closePath();\n            return path;\n        }\n    }\n\n    /**\n     * Plus marker.\n     */\n    public static class PlusMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) x, (float) (y - radius));\n            path.lineTo((float) x, (float) (y + radius));\n            path.moveTo((float) (x - radius), (float) y);\n            path.lineTo((float) (x + radius), (float) y);\n            return new Area(new BasicStroke(radius/3).createStrokedShape(path));\n        }\n    }\n\n    /**\n     * Cross marker.\n     */\n    public static class CrossMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            double r2 = 0.7 * radius;\n            path.moveTo((float) (x - r2), (float) (y - r2));\n            path.lineTo((float) (x + r2), (float) (y + r2));\n            path.moveTo((float) (x - r2), (float) (y + r2));\n            path.lineTo((float) (x + r2), (float) (y - r2));\n            return new Area(new BasicStroke(radius/3).createStrokedShape(path));\n        }\n    }\n\n    /**\n     * Target marker (with circle and crosshairs).\n     */\n    public static class TargetMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) x, (float) (y - radius));\n            path.lineTo((float) x, (float) (y + radius));\n            path.moveTo((float) (x - radius), (float) y);\n            path.lineTo((float) (x + radius), (float) y);\n            path.append(new Ellipse2D.Double(x - .6 * radius, y - .6 * radius, 1.2 * radius, 1.2 * radius), false);\n            return new Area(new BasicStroke(radius/6).createStrokedShape(path));\n        }\n    }\n\n    /**\n     * Arrow marker, pointing forward.\n     */\n    public static class GapArrowMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) (x + .5 * radius), (float) (y - .5 * radius));\n            path.lineTo((float) (x + radius), (float) y);\n            path.lineTo((float) (x + .5*radius), (float) (y + .5*radius));\n            path.moveTo((float) (x + .4*radius), (float) y);\n            path.lineTo((float) (x - radius), (float) y);\n            Shape wideShape = new Area(new BasicStroke(radius/4).createStrokedShape(path));\n            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(wideShape);\n        }\n    }\n\n    /**\n     * Arrow marker, pointing forward.\n     */\n    public static class ArrowMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) (x + .5 * radius), (float) (y - .5 * radius));\n            path.lineTo((float) (x + radius), (float) y);\n            path.lineTo((float) (x + .5*radius), (float) (y + .5*radius));\n            path.moveTo((float) (x + .8*radius), (float) y);\n            path.lineTo((float) (x - radius), (float) y);\n            Shape wideShape = new Area(new BasicStroke(radius/4).createStrokedShape(path));\n            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(wideShape);\n        }\n    }\n\n    /**\n     * Thicker arrow marker, pointing forward.\n     */\n    public static class ThickArrowMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) (x + .5 * radius), (float) (y - .5 * radius));\n            path.lineTo((float) (x + radius), (float) y);\n            path.lineTo((float) (x + .5*radius), (float) (y + .5*radius));\n            path.moveTo((float) (x + .6*radius), (float) y);\n            path.lineTo((float) (x - radius), (float) y);\n            Shape wideShape = new Area(new BasicStroke(radius/2).createStrokedShape(path));\n            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(wideShape);\n        }\n    }\n\n    /**\n     * Chevron marker, pointing forward.\n     */\n    public static class ChevronMarker implements Marker {\n\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX(), y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) (x + .3 * radius), (float) (y - .5 * radius));\n            path.lineTo((float) (x + .8 * radius), (float) y);\n            path.lineTo((float) (x + .3 * radius), (float) (y + .5 * radius));\n            path.moveTo((float) (x - .7 * radius), (float) (y - .5 * radius));\n            path.lineTo((float) (x - .2 * radius), (float) y);\n            path.lineTo((float) (x - .7 * radius), (float) (y + .5 * radius));\n            Shape wideShape = new Area(new BasicStroke(radius/4).createStrokedShape(path));\n            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(wideShape);\n        }\n    }\n\n    /**\n     * Triangle marker, pointing forward.\n     */\n    public static class TriangleMarkerForward implements Marker {\n\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX(), y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) (x + radius), (float) y);\n            path.lineTo((float) (x + radius * Math.cos(Math.PI * 0.6667)),\n                    (float) (y - radius * Math.sin(Math.PI * 0.6667)));\n            path.lineTo((float) (x + radius * Math.cos(Math.PI * 1.3333)),\n                    (float) (y - radius * Math.sin(Math.PI * 1.3333)));\n            path.closePath();\n            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(path);\n        }\n    }\n\n    /**\n     * Arrowhead marker, pointing forward.\n     */\n    public static class ArrowheadMarker implements Marker {\n\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX(), y = p.getY();\n            GeneralPath gp10 = new GeneralPath();\n            gp10.moveTo((float) (x + radius), (float) y);\n            gp10.lineTo((float) (x - radius), (float) (y + radius));\n            gp10.lineTo((float) (x - .5 * radius), (float) y);\n            gp10.lineTo((float) (x - radius), (float) (y - radius));\n            gp10.closePath();\n            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(gp10);\n        }\n    }\n\n    /**\n     * Teardrop marker, pointing forward.\n     */\n    public static class TeardropMarker implements Marker {\n\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX(), y = p.getY();\n            GeneralPath gp11 = new GeneralPath();\n            gp11.moveTo(-.25f, -.5f);\n            gp11.curveTo(-1f, -.5f, -1f, .5f, -.25f, .5f);\n            gp11.curveTo(.5f, .5f, .5f, 0, 1f, 0);\n            gp11.curveTo(.5f, 0, .5f, -.5f, -.2f, -.5f);\n            gp11.closePath();\n            gp11.transform(new AffineTransform(radius, 0, 0, radius, x, y));\n            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(gp11);\n        }\n    }\n\n    /**\n     * Happy face marker.\n     */\n    public static class HappyFaceMarker implements Marker {\n\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX(), y = p.getY();\n            Area a = new Area(new Ellipse2D.Double(x - radius, y - radius, 2 * radius, 2 * radius));\n            a.subtract(new Area(new Ellipse2D.Double(x - radius / 3 - radius / 6, y - radius / 2, radius / 3, radius / 3)));\n            a.subtract(new Area(new Ellipse2D.Double(x + radius / 3 - radius / 6, y - radius / 2, radius / 3, radius / 3)));\n            a.subtract(new Area(new Arc2D.Double(x - radius / 2, y - radius / 2, radius, radius, 200, 140, Arc2D.CHORD)));\n            return a;\n        }\n    }\n\n    /**\n     * House-shaped marker.\n     */\n    public static class HouseMarker implements Marker {\n\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX(), y = p.getY();\n            GeneralPath gp13 = new GeneralPath();\n            gp13.moveTo(-.9f, -.9f);\n            gp13.lineTo(.9f, -.9f);\n            gp13.lineTo(.9f, .4f);\n            gp13.lineTo(1f, .4f);\n            gp13.lineTo(.75f, .625f);\n            gp13.lineTo(.75f, 1f);\n            gp13.lineTo(.5f, 1f);\n            gp13.lineTo(.5f, .75f);\n            gp13.lineTo(0f, 1f);\n            gp13.lineTo(-1f, .4f);\n            gp13.lineTo(-.9f, .4f);\n            gp13.lineTo(-.9f, -.9f);\n            gp13.closePath();\n            gp13.transform(new AffineTransform(radius, 0, 0, -radius, x, y));\n            return gp13;\n        }\n    }\n\n}", "item_id": 0, "repo": "triathematician/blaisemath", "file": "blaise-common/src/main/java/com/googlecode/blaisemath/primitive/Markers.java", "last_update_at": "2022-03-31T14:54:47+00:00", "question_id": "ce26cb7a0fbee81d713706f4faea17a7415b46ea_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class Markers {\n    /** Caches markers loaded from resources file. */\n    private static final List<Marker> MARKER_CACHE = Lists.newArrayList();\n    /** Singleton for empty path. */\n    private static final GeneralPath EMPTY_PATH = new GeneralPath();\n    //region STATIC INSTANCES\n    public static final BlankMarker BLANK = new BlankMarker();\n    public static final CircleMarker CIRCLE = new CircleMarker();\n    public static final SquareMarker SQUARE = new SquareMarker();\n    public static final DiamondMarker DIAMOND = new DiamondMarker();\n    public static final TriangleMarker TRIANGLE = new TriangleMarker();\n    public static final StarMarker5 STAR = new StarMarker5();\n    public static final StarMarker7 STAR7 = new StarMarker7();\n    public static final StarMarker11 STAR11 = new StarMarker11();\n    public static final PlusMarker PLUS = new PlusMarker();\n    public static final CrossMarker CROSS = new CrossMarker();\n    public static final TargetMarker TARGET = new TargetMarker();\n    public static final ArrowMarker ARROW = new ArrowMarker();\n    public static final GapArrowMarker GAP_ARROW = new GapArrowMarker();\n    public static final ThickArrowMarker THICK_ARROW = new ThickArrowMarker();\n    public static final ChevronMarker CHEVRON_MARKER = new ChevronMarker();\n    public static final TriangleMarkerForward TRIANGLE_ARROW = new TriangleMarkerForward();\n    public static final ArrowheadMarker ARROWHEAD = new ArrowheadMarker();\n    public static final TeardropMarker TEARDROP = new TeardropMarker();\n    public static final HappyFaceMarker HAPPYFACE = new HappyFaceMarker();\n    public static final HouseMarker HOUSE = new HouseMarker();\n    //endregion\n    /**\n     * Utility class\n     */\n    private Markers() {\n    }\n    /**\n     * Retrieve list of available shapes.\n     * @return list of marker constants\n     */\n    public static List<Marker> getAvailableMarkers() {\n        if (MARKER_CACHE.isEmpty()) {\n            ServiceLoader<Marker> loader = ServiceLoader.load(Marker.class);\n            Iterables.addAll(MARKER_CACHE, loader);\n        }\n        return Collections.unmodifiableList(MARKER_CACHE);\n    }\n    /**\n     * Blank marker.\n     */\n    public static class BlankMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            return EMPTY_PATH;\n        }\n    }\n    /**\n     * Circle marker.\n     */\n    public static class CircleMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            return new Ellipse2D.Double(p.getX() - radius, p.getY() - radius, 2 * radius, 2 * radius);\n        }\n    }\n    /**\n     * Square marker.\n     */\n    public static class SquareMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            return new Rectangle2D.Double(\n                    p.getX() - radius / Math.sqrt(2),\n                    p.getY() - radius / Math.sqrt(2),\n                    2 * radius / Math.sqrt(2),\n                    2 * radius / Math.sqrt(2));\n        }\n    }\n    /**\n     * Diamond marker.\n     */\n    public static class DiamondMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) x, (float) (y - radius));\n            path.lineTo((float) (x - radius), (float) y);\n            path.lineTo((float) x, (float) (y + radius));\n            path.lineTo((float) (x + radius), (float) y);\n            path.closePath();\n            return path;\n        }\n    }\n    /**\n     * Triangle marker, pointing up.\n     */\n    public static class TriangleMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) x, (float) (y - radius));\n            path.lineTo((float) (x + radius * Math.cos(Math.PI * 1.16667)),\n                    (float) (y - radius * Math.sin(Math.PI * 1.16667)));\n            path.lineTo((float) (x + radius * Math.cos(Math.PI * 1.83333)),\n                    (float) (y - radius * Math.sin(Math.PI * 1.83333)));\n            path.closePath();\n            return path;\n        }\n    }\n    /**\n     * Five point star marker.\n     */\n    public static class StarMarker5 implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) x, (float) (y - radius));\n            for (int i = 0; i < 5; i++) {\n                double theta = Math.PI / 2 + 2 * Math.PI * i / 5;\n                path.lineTo((float) (x + radius * Math.cos(theta)),\n                        (float) (y - radius * Math.sin(theta)));\n                theta += Math.PI / 5;\n                path.lineTo((float) (x + radius / Math.sqrt(8) * Math.cos(theta)),\n                        (float) (y - radius / Math.sqrt(8) * Math.sin(theta)));\n            }\n            path.closePath();\n            return path;\n        }\n    }\n    /**\n     * Seven point star marker.\n     */\n    public static class StarMarker7 implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) x, (float) (y - radius));\n            for (int i = 0; i < 7; i++) {\n                double theta = Math.PI / 2 + 2 * Math.PI * i / 7;\n                path.lineTo((float) (x + radius * Math.cos(theta)),\n                        (float) (y - radius * Math.sin(theta)));\n                theta += Math.PI / 7;\n                path.lineTo((float) (x + radius / 2 * Math.cos(theta)),\n                        (float) (y - radius / 2 * Math.sin(theta)));\n            }\n            path.closePath();\n            return path;\n        }\n    }\n    /**\n     * Eleven point star marker.\n     */\n    public static class StarMarker11 implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) x, (float) (y - radius));\n            for (int i = 0; i < 11; i++) {\n                double theta = Math.PI / 2 + 2 * Math.PI * i / 11;\n                path.lineTo((float) (x + radius * Math.cos(theta)),\n                        (float) (y - radius * Math.sin(theta)));\n                theta += Math.PI / 11;\n                path.lineTo((float) (x + radius / 1.5 * Math.cos(theta)),\n                        (float) (y - radius / 1.5 * Math.sin(theta)));\n            }\n            path.closePath();\n            return path;\n        }\n    }\n    /**\n     * Plus marker.\n     */\n    public static class PlusMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) x, (float) (y - radius));\n            path.lineTo((float) x, (float) (y + radius));\n            path.moveTo((float) (x - radius), (float) y);\n            path.lineTo((float) (x + radius), (float) y);\n            return new Area(new BasicStroke(radius/3).createStrokedShape(path));\n        }\n    }\n    /**\n     * Cross marker.\n     */\n    public static class CrossMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            double r2 = 0.7 * radius;\n            path.moveTo((float) (x - r2), (float) (y - r2));\n            path.lineTo((float) (x + r2), (float) (y + r2));\n            path.moveTo((float) (x - r2), (float) (y + r2));\n            path.lineTo((float) (x + r2), (float) (y - r2));\n            return new Area(new BasicStroke(radius/3).createStrokedShape(path));\n        }\n    }\n    /**\n     * Target marker (with circle and crosshairs).\n     */\n    public static class TargetMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) x, (float) (y - radius));\n            path.lineTo((float) x, (float) (y + radius));\n            path.moveTo((float) (x - radius), (float) y);\n            path.lineTo((float) (x + radius), (float) y);\n            path.append(new Ellipse2D.Double(x - .6 * radius, y - .6 * radius, 1.2 * radius, 1.2 * radius), false);\n            return new Area(new BasicStroke(radius/6).createStrokedShape(path));\n        }\n    }\n    /**\n     * Arrow marker, pointing forward.\n     */\n    public static class GapArrowMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) (x + .5 * radius), (float) (y - .5 * radius));\n            path.lineTo((float) (x + radius), (float) y);\n            path.lineTo((float) (x + .5*radius), (float) (y + .5*radius));\n            path.moveTo((float) (x + .4*radius), (float) y);\n            path.lineTo((float) (x - radius), (float) y);\n            Shape wideShape = new Area(new BasicStroke(radius/4).createStrokedShape(path));\n            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(wideShape);\n        }\n    }\n    /**\n     * Arrow marker, pointing forward.\n     */\n    public static class ArrowMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) (x + .5 * radius), (float) (y - .5 * radius));\n            path.lineTo((float) (x + radius), (float) y);\n            path.lineTo((float) (x + .5*radius), (float) (y + .5*radius));\n            path.moveTo((float) (x + .8*radius), (float) y);\n            path.lineTo((float) (x - radius), (float) y);\n            Shape wideShape = new Area(new BasicStroke(radius/4).createStrokedShape(path));\n            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(wideShape);\n        }\n    }\n    /**\n     * Thicker arrow marker, pointing forward.\n     */\n    public static class ThickArrowMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX();\n            double y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) (x + .5 * radius), (float) (y - .5 * radius));\n            path.lineTo((float) (x + radius), (float) y);\n            path.lineTo((float) (x + .5*radius), (float) (y + .5*radius));\n            path.moveTo((float) (x + .6*radius), (float) y);\n            path.lineTo((float) (x - radius), (float) y);\n            Shape wideShape = new Area(new BasicStroke(radius/2).createStrokedShape(path));\n            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(wideShape);\n        }\n    }\n    /**\n     * Chevron marker, pointing forward.\n     */\n    public static class ChevronMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX(), y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) (x + .3 * radius), (float) (y - .5 * radius));\n            path.lineTo((float) (x + .8 * radius), (float) y);\n            path.lineTo((float) (x + .3 * radius), (float) (y + .5 * radius));\n            path.moveTo((float) (x - .7 * radius), (float) (y - .5 * radius));\n            path.lineTo((float) (x - .2 * radius), (float) y);\n            path.lineTo((float) (x - .7 * radius), (float) (y + .5 * radius));\n            Shape wideShape = new Area(new BasicStroke(radius/4).createStrokedShape(path));\n            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(wideShape);\n        }\n    }\n    /**\n     * Triangle marker, pointing forward.\n     */\n    public static class TriangleMarkerForward implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX(), y = p.getY();\n            GeneralPath path = new GeneralPath();\n            path.moveTo((float) (x + radius), (float) y);\n            path.lineTo((float) (x + radius * Math.cos(Math.PI * 0.6667)),\n                    (float) (y - radius * Math.sin(Math.PI * 0.6667)));\n            path.lineTo((float) (x + radius * Math.cos(Math.PI * 1.3333)),\n                    (float) (y - radius * Math.sin(Math.PI * 1.3333)));\n            path.closePath();\n            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(path);\n        }\n    }\n    /**\n     * Arrowhead marker, pointing forward.\n     */\n    public static class ArrowheadMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX(), y = p.getY();\n            GeneralPath gp10 = new GeneralPath();\n            gp10.moveTo((float) (x + radius), (float) y);\n            gp10.lineTo((float) (x - radius), (float) (y + radius));\n            gp10.lineTo((float) (x - .5 * radius), (float) y);\n            gp10.lineTo((float) (x - radius), (float) (y - radius));\n            gp10.closePath();\n            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(gp10);\n        }\n    }\n    /**\n     * Teardrop marker, pointing forward.\n     */\n    public static class TeardropMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX(), y = p.getY();\n            GeneralPath gp11 = new GeneralPath();\n            gp11.moveTo(-.25f, -.5f);\n            gp11.curveTo(-1f, -.5f, -1f, .5f, -.25f, .5f);\n            gp11.curveTo(.5f, .5f, .5f, 0, 1f, 0);\n            gp11.curveTo(.5f, 0, .5f, -.5f, -.2f, -.5f);\n            gp11.closePath();\n            gp11.transform(new AffineTransform(radius, 0, 0, radius, x, y));\n            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(gp11);\n        }\n    }\n    /**\n     * Happy face marker.\n     */\n    public static class HappyFaceMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX(), y = p.getY();\n            Area a = new Area(new Ellipse2D.Double(x - radius, y - radius, 2 * radius, 2 * radius));\n            a.subtract(new Area(new Ellipse2D.Double(x - radius / 3 - radius / 6, y - radius / 2, radius / 3, radius / 3)));\n            a.subtract(new Area(new Ellipse2D.Double(x + radius / 3 - radius / 6, y - radius / 2, radius / 3, radius / 3)));\n            a.subtract(new Area(new Arc2D.Double(x - radius / 2, y - radius / 2, radius, radius, 200, 140, Arc2D.CHORD)));\n            return a;\n        }\n    }\n    /**\n     * House-shaped marker.\n     */\n    public static class HouseMarker implements Marker {\n        @Override\n        public Shape create(Point2D p, double angle, float radius) {\n            double x = p.getX(), y = p.getY();\n            GeneralPath gp13 = new GeneralPath();\n            gp13.moveTo(-.9f, -.9f);\n            gp13.lineTo(.9f, -.9f);\n            gp13.lineTo(.9f, .4f);\n            gp13.lineTo(1f, .4f);\n            gp13.lineTo(.75f, .625f);\n            gp13.lineTo(.75f, 1f);\n            gp13.lineTo(.5f, 1f);\n            gp13.lineTo(.5f, .75f);\n            gp13.lineTo(0f, 1f);\n            gp13.lineTo(-1f, .4f);\n            gp13.lineTo(-.9f, .4f);\n            gp13.lineTo(-.9f, -.9f);\n            gp13.closePath();\n            gp13.transform(new AffineTransform(radius, 0, 0, -radius, x, y));\n            return gp13;\n        }\n    }\n"]], "pred": {"ppl": 1.5578961372375488, "ppl_lower": 1.7420047521591187, "ppl/lowercase_ppl": -1.25195394584615, "ppl/zlib": 0.00022067510257125478, "Min_5.0% Prob": 5.781590485105328, "Min_10.0% Prob": 3.925135323814317, "Min_20.0% Prob": 2.1718561113172887, "Min_30.0% Prob": 1.4728393361118495, "Min_40.0% Prob": 1.1067477767959164, "Min_50.0% Prob": 0.8869605473554356, "Min_60.0% Prob": 0.7396835850264579}}
{"hexsha": "13e37529ab5063608e3978a47857d1e7e547875c", "ext": "java", "lang": "Java", "content": "public class StackTest\n{\n\t@Test\n\tpublic void test()\n\t{\n\t\tStack<String> stack = new Stack<String>(3);\n\t\tstack.push(\"1\");\n\t\tstack.push(\"2\");\n\t\tstack.push(\"3\");\n\t\t\n\t\tassertEquals(\"3\", stack.peek());\n\t\tassertEquals(\"2\", stack.peek(1));\n\t\t\n\t\tassertEquals(\"3\", stack.pop());\n\t\tStack<String> clone = new Stack<String>(stack);\n\t\t\n\t\tassertEquals(\"2\", stack.pop());\n\t\tassertEquals(\"1\", stack.pop());\n\t\t\n\t\tassertEquals(\"2\", clone.pop());\n\t\tassertEquals(\"1\", clone.pop());\n\t}\n}", "item_id": 0, "repo": "clir/clearnlp", "file": "src/test/java/edu/emory/clir/clearnlp/collection/stack/StackTest.java", "last_update_at": "2022-02-20T00:21:27+00:00", "question_id": "13e37529ab5063608e3978a47857d1e7e547875c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StackTest\n{\n\t@Test\n\tpublic void test()\n\t{\n\t\tStack<String> stack = new Stack<String>(3);\n\t\tstack.push(\"1\");\n\t\tstack.push(\"2\");\n\t\tstack.push(\"3\");\n\t\t\n\t\tassertEquals(\"3\", stack.peek());\n\t\tassertEquals(\"2\", stack.peek(1));\n\t\t\n\t\tassertEquals(\"3\", stack.pop());\n\t\tStack<String> clone = new Stack<String>(stack);\n\t\t\n\t\tassertEquals(\"2\", stack.pop());\n\t\tassertEquals(\"1\", stack.pop());\n\t\t\n\t\tassertEquals(\"2\", clone.pop());\n\t\tassertEquals(\"1\", clone.pop());\n\t}\n"]], "pred": {"ppl": 1.5657870769500732, "ppl_lower": 1.786328911781311, "ppl/lowercase_ppl": -1.2938834706952815, "ppl/zlib": 0.002562220697923878, "Min_5.0% Prob": 4.791546821594238, "Min_10.0% Prob": 3.282174620363447, "Min_20.0% Prob": 2.0442255958914757, "Min_30.0% Prob": 1.4586415216326714, "Min_40.0% Prob": 1.1056421774707428, "Min_50.0% Prob": 0.8948625226883771, "Min_60.0% Prob": 0.7499216798812561}}
{"hexsha": "78e3280be407b82ae1c39910a09eeccd26a5b911", "ext": "java", "lang": "Java", "content": "public class EphemeralFsFileSystemCheckerTest {\n\n    FileSystem fs;\n    Path root;\n    Path file;\n    \n    @Before\n    public void setUp() throws IOException {\n        fs = EphemeralFsFileSystemBuilder\n                .unixFs()\n                .build();\n        root = fs.getRootDirectories().iterator().next();\n        file = root.resolve(\"file\");\n        Files.write(file, new byte[] {1,2,3});\n        \n    }\n    \n    @After\n    public void tearDown() throws IOException {\n        fs.close();\n    }\n    \n    @Test\n    public void testDontThrowIfChannelClosed() throws Exception {\n        Files.newByteChannel(file).close();\n        EphemeralFsFileSystemChecker.assertNoOpenResources(fs);\n    }\n    \n    @Test\n    public void testThrowIfChannelOpen() throws Exception {\n        Files.newByteChannel(file);\n        assertNotOpenThrows();\n    }\n    \n    @Test\n    public void testThrowIfChannelOpenFileDeleted() throws Exception {\n        Files.newByteChannel(file);\n        Files.delete(file);\n        assertNotOpenThrows();\n    }\n\n    @Test\n    public void testDontThrowIfAsyncChannelClosed() throws Exception {\n        fs.provider().newAsynchronousFileChannel(file, new HashSet<OpenOption>(), null).close();\n        fs.close();\n    }\n    \n    @Test\n    public void testThrowIfAsyncChannelOpen() throws Exception {\n        fs.provider().newAsynchronousFileChannel(file, new HashSet<OpenOption>(), null);\n        assertNotOpenThrows();\n    }\n\n    @Test\n    public void testDontThrowIfDirectoryStreamClosed() throws Exception {\n        Files.newDirectoryStream(root).close();\n        fs.close();\n    }\n    \n    @Test\n    public void testThrowIfDirectoryStreamOpen() throws Exception {\n        Files.newDirectoryStream(root);\n        assertNotOpenThrows();\n    }\n    \n    @Test\n    public void testDontThrowIfWatchServiceClosed() throws Exception {\n        fs.newWatchService().close();\n        fs.close();\n    }\n    \n    @Test\n    public void testThrowIfWatchServiceOpen() throws Exception {\n        fs.newWatchService();\n        assertNotOpenThrows();\n    }\n    \n    \n    @Test\n    public void testDirtyFile() throws Exception {\n        Files.write(file, new byte[] {1});\n        assertFsyncFileThrows(file);\n    }\n\n    @Test\n    public void testDirtyFileInSubDir() throws Exception {\n        Path dir = Files.createDirectory(root.resolve(\"dir\"));\n        Path fileInDir = Files.createFile(dir.resolve(\"fileInDir\"));\n        assertFsyncFileThrows(dir);\n        FileSyncTest.sync(fileInDir);\n        EphemeralFsFileSystemChecker.assertAllFilesFsynced(dir);\n    }\n    \n    \n    @Test\n    public void testDsyncNonExistentFile() throws Exception {\n        try {\n            EphemeralFsFileSystemChecker.assertAllFilesFsynced(root.resolve(\"doesNotExist\"));\n            fail();\n        } catch(IllegalArgumentException e) {\n            //pass\n        }\n    }\n    \n    @Test\n    public void testCleanFile() throws Exception {\n        FileSyncTest.sync(file);\n        EphemeralFsFileSystemChecker.assertAllFilesFsynced(file);\n    }\n\n    @Test\n    public void testFsyncDirOnFile() throws Exception {\n        try {\n            EphemeralFsFileSystemChecker.assertAllDirectoriesFsynced(file, false);\n            fail();\n        } catch(IllegalArgumentException e) {\n            //pass\n        }\n    }\n    \n    @Test\n    public void testFsyncDirOnNonExistent() throws Exception {\n        try {\n            EphemeralFsFileSystemChecker.assertAllDirectoriesFsynced(root.resolve(\"dir\"), false);\n            fail();\n        } catch(IllegalArgumentException e) {\n            //pass\n        }\n    }\n    \n    \n    @Test\n    public void testFsyncDirOnDirtyDirs() throws Exception {\n        Path dir = Files.createDirectory(root.resolve(\"dir\"));\n        Files.createFile(dir.resolve(\"fileInDir\"));\n        FileSyncTest.sync(root);\n        \n        assertFsyncDirectoryThrows(root, true);\n        assertFsyncDirectoryThrows(dir, true);\n        assertFsyncDirectoryThrows(dir, false);\n        \n        FileSyncTest.sync(dir);\n        \n        EphemeralFsFileSystemChecker.assertAllDirectoriesFsynced(root, true);\n        EphemeralFsFileSystemChecker.assertAllDirectoriesFsynced(dir, true);\n        EphemeralFsFileSystemChecker.assertAllDirectoriesFsynced(dir, false);\n    }\n    \n    private void assertNotOpenThrows() {\n        boolean notThrown = false;\n        try {\n            EphemeralFsFileSystemChecker.assertNoOpenResources(fs);\n            notThrown = true;\n        } catch(AssertionError e) {\n            assertTrue(e.getMessage().contains(\"Failed to close\"));\n        }\n        if(notThrown) {\n            fail();\n        }\n    }\n    \n    private void assertFsyncFileThrows(Path path) {\n        boolean notThrown = false;\n        try {\n            EphemeralFsFileSystemChecker.assertAllFilesFsynced(path);\n            notThrown = true;\n        } catch(AssertionError e) {\n            assertTrue(e.getMessage().contains(\"Failed to sync\"));\n        }\n        if(notThrown) {\n            fail();\n        }\n    }\n    \n    \n    private void assertFsyncDirectoryThrows(Path path, boolean recursive) {\n        boolean notThrown = false;\n        try {\n            EphemeralFsFileSystemChecker.assertAllDirectoriesFsynced(path, recursive);\n            notThrown = true;\n        } catch(AssertionError e) {\n            assertTrue(e.getMessage().contains(\"Failed to sync\"));\n        }\n        if(notThrown) {\n            fail();\n        }\n    }\n}", "item_id": 0, "repo": "sbridges/ephemeralfs", "file": "src/test/java/com/github/sbridges/ephemeralfs/EphemeralFsFileSystemCheckerTest.java", "last_update_at": "2022-02-22T22:26:21+00:00", "question_id": "78e3280be407b82ae1c39910a09eeccd26a5b911_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EphemeralFsFileSystemCheckerTest {\n    FileSystem fs;\n    Path root;\n    Path file;\n    @Before\n    public void setUp() throws IOException {\n        fs = EphemeralFsFileSystemBuilder\n                .unixFs()\n                .build();\n        root = fs.getRootDirectories().iterator().next();\n        file = root.resolve(\"file\");\n        Files.write(file, new byte[] {1,2,3});\n    }\n    @After\n    public void tearDown() throws IOException {\n        fs.close();\n    }\n    @Test\n    public void testDontThrowIfChannelClosed() throws Exception {\n        Files.newByteChannel(file).close();\n        EphemeralFsFileSystemChecker.assertNoOpenResources(fs);\n    }\n    @Test\n    public void testThrowIfChannelOpen() throws Exception {\n        Files.newByteChannel(file);\n        assertNotOpenThrows();\n    }\n    @Test\n    public void testThrowIfChannelOpenFileDeleted() throws Exception {\n        Files.newByteChannel(file);\n        Files.delete(file);\n        assertNotOpenThrows();\n    }\n    @Test\n    public void testDontThrowIfAsyncChannelClosed() throws Exception {\n        fs.provider().newAsynchronousFileChannel(file, new HashSet<OpenOption>(), null).close();\n        fs.close();\n    }\n    @Test\n    public void testThrowIfAsyncChannelOpen() throws Exception {\n        fs.provider().newAsynchronousFileChannel(file, new HashSet<OpenOption>(), null);\n        assertNotOpenThrows();\n    }\n    @Test\n    public void testDontThrowIfDirectoryStreamClosed() throws Exception {\n        Files.newDirectoryStream(root).close();\n        fs.close();\n    }\n    @Test\n    public void testThrowIfDirectoryStreamOpen() throws Exception {\n        Files.newDirectoryStream(root);\n        assertNotOpenThrows();\n    }\n    @Test\n    public void testDontThrowIfWatchServiceClosed() throws Exception {\n        fs.newWatchService().close();\n        fs.close();\n    }\n    @Test\n    public void testThrowIfWatchServiceOpen() throws Exception {\n        fs.newWatchService();\n        assertNotOpenThrows();\n    }\n    @Test\n    public void testDirtyFile() throws Exception {\n        Files.write(file, new byte[] {1});\n        assertFsyncFileThrows(file);\n    }\n    @Test\n    public void testDirtyFileInSubDir() throws Exception {\n        Path dir = Files.createDirectory(root.resolve(\"dir\"));\n        Path fileInDir = Files.createFile(dir.resolve(\"fileInDir\"));\n        assertFsyncFileThrows(dir);\n        FileSyncTest.sync(fileInDir);\n        EphemeralFsFileSystemChecker.assertAllFilesFsynced(dir);\n    }\n    @Test\n    public void testDsyncNonExistentFile() throws Exception {\n        try {\n            EphemeralFsFileSystemChecker.assertAllFilesFsynced(root.resolve(\"doesNotExist\"));\n            fail();\n        } catch(IllegalArgumentException e) {\n            //pass\n        }\n    }\n    @Test\n    public void testCleanFile() throws Exception {\n        FileSyncTest.sync(file);\n        EphemeralFsFileSystemChecker.assertAllFilesFsynced(file);\n    }\n    @Test\n    public void testFsyncDirOnFile() throws Exception {\n        try {\n            EphemeralFsFileSystemChecker.assertAllDirectoriesFsynced(file, false);\n            fail();\n        } catch(IllegalArgumentException e) {\n            //pass\n        }\n    }\n    @Test\n    public void testFsyncDirOnNonExistent() throws Exception {\n        try {\n            EphemeralFsFileSystemChecker.assertAllDirectoriesFsynced(root.resolve(\"dir\"), false);\n            fail();\n        } catch(IllegalArgumentException e) {\n            //pass\n        }\n    }\n    @Test\n    public void testFsyncDirOnDirtyDirs() throws Exception {\n        Path dir = Files.createDirectory(root.resolve(\"dir\"));\n        Files.createFile(dir.resolve(\"fileInDir\"));\n        FileSyncTest.sync(root);\n        assertFsyncDirectoryThrows(root, true);\n        assertFsyncDirectoryThrows(dir, true);\n        assertFsyncDirectoryThrows(dir, false);\n        FileSyncTest.sync(dir);\n        EphemeralFsFileSystemChecker.assertAllDirectoriesFsynced(root, true);\n        EphemeralFsFileSystemChecker.assertAllDirectoriesFsynced(dir, true);\n        EphemeralFsFileSystemChecker.assertAllDirectoriesFsynced(dir, false);\n    }\n    private void assertNotOpenThrows() {\n        boolean notThrown = false;\n        try {\n            EphemeralFsFileSystemChecker.assertNoOpenResources(fs);\n            notThrown = true;\n        } catch(AssertionError e) {\n            assertTrue(e.getMessage().contains(\"Failed to close\"));\n        }\n        if(notThrown) {\n            fail();\n        }\n    }\n    private void assertFsyncFileThrows(Path path) {\n        boolean notThrown = false;\n        try {\n            EphemeralFsFileSystemChecker.assertAllFilesFsynced(path);\n            notThrown = true;\n        } catch(AssertionError e) {\n            assertTrue(e.getMessage().contains(\"Failed to sync\"));\n        }\n        if(notThrown) {\n            fail();\n        }\n    }\n    private void assertFsyncDirectoryThrows(Path path, boolean recursive) {\n        boolean notThrown = false;\n        try {\n            EphemeralFsFileSystemChecker.assertAllDirectoriesFsynced(path, recursive);\n            notThrown = true;\n        } catch(AssertionError e) {\n            assertTrue(e.getMessage().contains(\"Failed to sync\"));\n        }\n        if(notThrown) {\n            fail();\n        }\n    }\n"]], "pred": {"ppl": 1.6166261434555054, "ppl_lower": 1.8062503337860107, "ppl/lowercase_ppl": -1.2309018526006048, "ppl/zlib": 0.0005104583953914092, "Min_5.0% Prob": 5.319548588173062, "Min_10.0% Prob": 3.7353742204460443, "Min_20.0% Prob": 2.2755879391642178, "Min_30.0% Prob": 1.5817913877856886, "Min_40.0% Prob": 1.1956241829480183, "Min_50.0% Prob": 0.959728258669216, "Min_60.0% Prob": 0.8009331058600665}}
{"hexsha": "a3589cc7dee4241865c07f0cbed7b077fb849d91", "ext": "java", "lang": "Java", "content": "public class XMLWriter {\n  /**\n   * The number of characters to indent by for each nesting level of a tag to be\n   * written. Some <code>writeRaw</code> methods accept a nesting level used\n   * as a multiplier for this factor.\n   */\n  public static final int INDENT_WIDTH = 2;\n  /**\n   * The default encoding to be used when writing byte streams - currently the\n   * UTF-8 encoding\n   */\n  public static final String DEFAULT_ENCODING = \"UTF-8\";\n  private static String DEFAULT_DECLARATION = \"<?xml version=\\\"1.0\\\" ?>\\n\";\n  private PrintOutputStream internalwriter;\n\n  public PrintOutputStream getInternalWriter() {\n    return internalwriter;\n  }\n\n  /**\n   * Creates an XMLWriter wrapping the supplied OutputStream. Character data is\n   * converted using the default encoding scheme above\n   * \n   * @param os\n   *          The output stream to be wrapped.\n   */\n\n  public XMLWriter(OutputStream os) {\n    internalwriter = new OutputStreamPOS(os, DEFAULT_ENCODING);\n  }\n\n  /**\n   * Creates an XMLWriter wrapping the supplied Writer.\n   * \n   * @param internalwriter\n   *          The writer to be wrapped.\n   */\n\n  public XMLWriter(Writer internalwriter) {\n    this.internalwriter = new WriterPOS(internalwriter);\n  }\n\n  public XMLWriter(PrintOutputStream pos) {\n    this.internalwriter = pos;\n  }\n\n  /**\n   * Writes the supplied data to the wrapped stream without conversion.\n   * \n   * @param towrite\n   *          A character array holding the data to be written.\n   * @param start\n   *          The offset of the data to be written within the array.\n   * @param length\n   *          The length of the data to be written.\n   */\n\n  public void writeRaw(char[] towrite, int start, int length) {\n    internalwriter.write(towrite, start, length);\n  }\n\n  /**\n   * Writes the supplied string to the wrapped stream without conversion.\n   * \n   * @param tag The string to be written.\n   * @return the writer\n   */\n\n  public XMLWriter writeRaw(String tag) {\n    internalwriter.print(tag);\n    return this;\n  }\n\n  public static void indent(int nestinglevel, PrintOutputStream writer) {\n    for (int i = 0; i < nestinglevel * INDENT_WIDTH; ++i) {\n      writer.print(\" \");\n    }\n  }\n\n  // write with specified indenting and without deentitising\n  /**\n   * Writes the supplied string to the wrapped stream with the specified indent\n   * level.\n   * \n   * @param tag\n   *          The string to be written.\n   * @param nestinglevel\n   *          The multiplier for the <code>INDENT_WIDTH</code>, giving the\n   *          number of spaces to be written before the supplied string.\n   */\n  public void writeRaw(String tag, int nestinglevel) {\n    indent(nestinglevel, internalwriter);\n    internalwriter.print(tag);\n    // Logger.println(tag, Logger.DEBUG_SUBATOMIC);\n  }\n\n  public void closeTag(String tag, int nestinglevel, boolean writtenchildren) {\n    if (writtenchildren) {\n      indent(nestinglevel, internalwriter);\n      internalwriter.print(\"</\");\n      internalwriter.print(tag);\n      internalwriter.print(\">\");\n    }\n    else {\n      internalwriter.print(\"/>\");\n    }\n    if (nestinglevel >= 0) {\n      internalwriter.print(\"\\n\");\n    }\n  }\n\n  /**\n   * Returns the default declaration that will be written by the\n   * <code>writeDeclaration</code> method.\n   * \n   * @return The required default declaration.\n   */\n  public static String getDefaultDeclaration() {\n    return DEFAULT_DECLARATION;\n  }\n\n  /**\n   * Writes a default declaration to the wrapped stream.\n   */\n\n  public void writeDeclaration() {\n    internalwriter.print(DEFAULT_DECLARATION);\n  }\n\n  public static String[] entitytable;\n\n  static {\n    entitytable = new String['>' + 1];\n    entitytable['&'] = \"&amp;\";\n    entitytable['<'] = \"&lt;\";\n    entitytable['>'] = \"&gt;\";\n    entitytable['\"'] = \"&quot;\";\n    // HTML 4.0 does not define &apos; and does not plan to\n    entitytable['\\''] = \"&#39;\";\n  }\n\n  /**\n   * Writes the supplied data to the wrapped stream, escaping all mandatory\n   * XML entities, being &amp;, &lt;, &gt;, &quot;.\n   * NB apostrophe is no longer encoded, since this seems to give a measurable\n   * Increase in speed. (&#39; is\n   * escaped to &amp;#39; since HTML 4.0 does not define the &amp;apos; entity\n   * and does not plan to)\n   * \n   * @param towrite\n   *          A character array holding the data to be written.\n   * @param start\n   *          The offset of the data to be written within the array.\n   * @param length\n   *          The length of the data to be written.\n   */\n\n  // This odd strategy is based on the observation that MOST attributes/XML\n  // data do NOT contain any of the entity characters, but those that do\n  // are likely to contain more than one. This could no doubt be tuned\n  // even further but there is only a maximum of 5% slack left in typical\n  // page rendering -\n  // original timing:             690\u00b5s\n  // timing with strategy:        680\u00b5s\n  // timing with strategy - apos: 658\u00b5s\n  // timing with unencoded write: 650\u00b5s\n  // timing with write as no-op:  630\u00b5s\n  public final void write(char[] towrite, int start, int length) {\n    int limit = start + length;\n    // String ent = null;\n     //while (length > 0) {\n    for (; length > 0; --length) {\n      char c = towrite[limit - length];\n      if (c == '&' || c == '<' || c == '>' || c == '\"') break;\n      //on JDK 1.5, amazingly this line puts it back up to 670 with the 4 cases.\n      //if ((c & 35) != 32) continue;\n//      switch (c) {\n//      \n//      case '&':\n//      // ent = \"&amp;\";\n//      // break outer;\n//      case '<':\n//      // ent = \"&lt;\";\n//      // break outer;\n//      case '>':\n//      // ent = \"&gt;\";\n//      // break outer;\n//      case '\"':\n//      // ent = \"&quot;\";\n//      // break outer;\n//      case '\\'':\n//        // ent = \"&#39;\";\n//        break outer;\n//      }\n    }\n    internalwriter.write(towrite, start, limit - start - length);\n    // if (ent != null) {\n    // internalwriter.print(ent);\n    // --length;\n    // }\n    // }\n    if (length > 0) {\n//      writeEntity(towrite[limit - length], internalwriter);\n//      --length;\n      writeSlow(towrite, start + limit - length, length);\n    }\n     //}\n  }\n\n  public static final void writeEntity(char c, PrintOutputStream pos) {\n    switch (c) {\n    case '&':\n      pos.print(\"&amp;\");\n      return;\n    case '<':\n      pos.print(\"&lt;\");\n      return;\n    case '>':\n      pos.print(\"&gt;\");\n      return;\n    case '\"':\n      pos.print(\"&quot;\");\n      return;\n    case '\\'':\n      pos.print(\"&#39;\");\n      return;\n    }\n    return;\n  }\n\n  public final void writeSlow(char[] towrite, int start, int length) {\n    // AMAZINGLY, in 1.5 it is quicker to create this here than economise it.\n    CharWrap svb = new CharWrap(length + 10);\n    int limit = start + length;\n    for (int i = length; i > 0; --i) {\n      char c = towrite[limit - i];\n      switch (c) {\n      case '&':\n        svb.append(\"&amp;\");\n        svb.ensureCapacity(svb.size + i);\n        break;\n      case '<':\n        svb.append(\"&lt;\");\n        svb.ensureCapacity(svb.size + i);\n        break;\n      case '>':\n        svb.append(\"&gt;\");\n        svb.ensureCapacity(svb.size + i);\n        break;\n      case '\"':\n        svb.append(\"&quot;\");\n        svb.ensureCapacity(svb.size + i);\n        break;\n\n      // HTML 4.0 does not define &apos; and does not plan to\n      case '\\'':\n        svb.append(\"&#39;\");\n        svb.ensureCapacity(svb.size + i);\n        break;\n      default:\n        svb.appendFast(c);\n      }\n      // String lookup = c > entitytable.length? null : entitytable[c];\n      // // optimised on the basis that entitising is RARE - we only check\n      // // available capacity at that point.\n      // if (lookup == null) {\n      // svb.appendFast(c);\n      // }\n      // else {\n      // svb.append(lookup);\n      // svb.ensureCapacity(svb.size + (limit - i));\n      // }\n    }\n    internalwriter.write(svb.storage, svb.offset, svb.size);\n  }\n\n  /**\n   * Writes the supplied data to the wrapped stream, escaping all mandatory\n   * XML/HTML entities, being &amp;, &lt;, &gt;, &quot; and &#39;. &#39; is\n   * escaped to &amp;#39; since HTML 4.0 does not define the &amp;apos; entity\n   * and does not plan to.\n   * \n   * @param towrite\n   *          The string to be written.\n   */\n\n  public void write(String towrite) {\n    char[] array = (towrite == null ? \"null\" : towrite).toCharArray();\n    write(array, 0, array.length);\n  }\n\n  /**\n   * Flushes the wrapped stream.\n   */\n\n  public void flush() {\n    internalwriter.flush();\n  }\n\n  /**\n   * Closes this XMLWriter object, in effect flushing it and making it unusable\n   * for any further write operations.\n   * <p>\n   * Closing this does not close the underlying input stream!\n   */\n  public void close() {\n    if (internalwriter != null) {\n      try {\n        flush();\n      }\n      catch (Throwable t) {\n        Logger.println(\"Unhandled exception closing XML Writer: \" + t,\n            Logger.DEBUG_SEVERE);\n        // internalwriter.close();\n        internalwriter = null;\n      }\n    }\n  }\n}", "item_id": 0, "repo": "jonespm/rsf", "file": "rsf-core/ponderutilcore/src/uk/org/ponder/xml/XMLWriter.java", "last_update_at": "2022-01-04T16:54:06+00:00", "question_id": "a3589cc7dee4241865c07f0cbed7b077fb849d91_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class XMLWriter {\n  /**\n   * The number of characters to indent by for each nesting level of a tag to be\n   * written. Some <code>writeRaw</code> methods accept a nesting level used\n   * as a multiplier for this factor.\n   */\n  public static final int INDENT_WIDTH = 2;\n  /**\n   * The default encoding to be used when writing byte streams - currently the\n   * UTF-8 encoding\n   */\n  public static final String DEFAULT_ENCODING = \"UTF-8\";\n  private static String DEFAULT_DECLARATION = \"<?xml version=\\\"1.0\\\" ?>\\n\";\n  private PrintOutputStream internalwriter;\n  public PrintOutputStream getInternalWriter() {\n    return internalwriter;\n  }\n  /**\n   * Creates an XMLWriter wrapping the supplied OutputStream. Character data is\n   * converted using the default encoding scheme above\n   * \n   * @param os\n   *          The output stream to be wrapped.\n   */\n  public XMLWriter(OutputStream os) {\n    internalwriter = new OutputStreamPOS(os, DEFAULT_ENCODING);\n  }\n  /**\n   * Creates an XMLWriter wrapping the supplied Writer.\n   * \n   * @param internalwriter\n   *          The writer to be wrapped.\n   */\n  public XMLWriter(Writer internalwriter) {\n    this.internalwriter = new WriterPOS(internalwriter);\n  }\n  public XMLWriter(PrintOutputStream pos) {\n    this.internalwriter = pos;\n  }\n  /**\n   * Writes the supplied data to the wrapped stream without conversion.\n   * \n   * @param towrite\n   *          A character array holding the data to be written.\n   * @param start\n   *          The offset of the data to be written within the array.\n   * @param length\n   *          The length of the data to be written.\n   */\n  public void writeRaw(char[] towrite, int start, int length) {\n    internalwriter.write(towrite, start, length);\n  }\n  /**\n   * Writes the supplied string to the wrapped stream without conversion.\n   * \n   * @param tag The string to be written.\n   * @return the writer\n   */\n  public XMLWriter writeRaw(String tag) {\n    internalwriter.print(tag);\n    return this;\n  }\n  public static void indent(int nestinglevel, PrintOutputStream writer) {\n    for (int i = 0; i < nestinglevel * INDENT_WIDTH; ++i) {\n      writer.print(\" \");\n    }\n  }\n  // write with specified indenting and without deentitising\n  /**\n   * Writes the supplied string to the wrapped stream with the specified indent\n   * level.\n   * \n   * @param tag\n   *          The string to be written.\n   * @param nestinglevel\n   *          The multiplier for the <code>INDENT_WIDTH</code>, giving the\n   *          number of spaces to be written before the supplied string.\n   */\n  public void writeRaw(String tag, int nestinglevel) {\n    indent(nestinglevel, internalwriter);\n    internalwriter.print(tag);\n    // Logger.println(tag, Logger.DEBUG_SUBATOMIC);\n  }\n  public void closeTag(String tag, int nestinglevel, boolean writtenchildren) {\n    if (writtenchildren) {\n      indent(nestinglevel, internalwriter);\n      internalwriter.print(\"</\");\n      internalwriter.print(tag);\n      internalwriter.print(\">\");\n    }\n    else {\n      internalwriter.print(\"/>\");\n    }\n    if (nestinglevel >= 0) {\n      internalwriter.print(\"\\n\");\n    }\n  }\n  /**\n   * Returns the default declaration that will be written by the\n   * <code>writeDeclaration</code> method.\n   * \n   * @return The required default declaration.\n   */\n  public static String getDefaultDeclaration() {\n    return DEFAULT_DECLARATION;\n  }\n  /**\n   * Writes a default declaration to the wrapped stream.\n   */\n  public void writeDeclaration() {\n    internalwriter.print(DEFAULT_DECLARATION);\n  }\n  public static String[] entitytable;\n  static {\n    entitytable = new String['>' + 1];\n    entitytable['&'] = \"&amp;\";\n    entitytable['<'] = \"&lt;\";\n    entitytable['>'] = \"&gt;\";\n    entitytable['\"'] = \"&quot;\";\n    // HTML 4.0 does not define &apos; and does not plan to\n    entitytable['\\''] = \"&#39;\";\n  }\n  /**\n   * Writes the supplied data to the wrapped stream, escaping all mandatory\n   * XML entities, being &amp;, &lt;, &gt;, &quot;.\n   * NB apostrophe is no longer encoded, since this seems to give a measurable\n   * Increase in speed. (&#39; is\n   * escaped to &amp;#39; since HTML 4.0 does not define the &amp;apos; entity\n   * and does not plan to)\n   * \n   * @param towrite\n   *          A character array holding the data to be written.\n   * @param start\n   *          The offset of the data to be written within the array.\n   * @param length\n   *          The length of the data to be written.\n   */\n  // This odd strategy is based on the observation that MOST attributes/XML\n  // data do NOT contain any of the entity characters, but those that do\n  // are likely to contain more than one. This could no doubt be tuned\n  // even further but there is only a maximum of 5% slack left in typical\n  // page rendering -\n  // original timing:             690\u00b5s\n  // timing with strategy:        680\u00b5s\n  // timing with strategy - apos: 658\u00b5s\n  // timing with unencoded write: 650\u00b5s\n  // timing with write as no-op:  630\u00b5s\n  public final void write(char[] towrite, int start, int length) {\n    int limit = start + length;\n    // String ent = null;\n     //while (length > 0) {\n    for (; length > 0; --length) {\n      char c = towrite[limit - length];\n      if (c == '&' || c == '<' || c == '>' || c == '\"') break;\n      //on JDK 1.5, amazingly this line puts it back up to 670 with the 4 cases.\n      //if ((c & 35) != 32) continue;\n//      switch (c) {\n//      \n//      case '&':\n//      // ent = \"&amp;\";\n//      // break outer;\n//      case '<':\n//      // ent = \"&lt;\";\n//      // break outer;\n//      case '>':\n//      // ent = \"&gt;\";\n//      // break outer;\n//      case '\"':\n//      // ent = \"&quot;\";\n//      // break outer;\n//      case '\\'':\n//        // ent = \"&#39;\";\n//        break outer;\n//      }\n    }\n    internalwriter.write(towrite, start, limit - start - length);\n    // if (ent != null) {\n    // internalwriter.print(ent);\n    // --length;\n    // }\n    // }\n    if (length > 0) {\n//      writeEntity(towrite[limit - length], internalwriter);\n//      --length;\n      writeSlow(towrite, start + limit - length, length);\n    }\n     //}\n  }\n  public static final void writeEntity(char c, PrintOutputStream pos) {\n    switch (c) {\n    case '&':\n      pos.print(\"&amp;\");\n      return;\n    case '<':\n      pos.print(\"&lt;\");\n      return;\n    case '>':\n      pos.print(\"&gt;\");\n      return;\n    case '\"':\n      pos.print(\"&quot;\");\n      return;\n    case '\\'':\n      pos.print(\"&#39;\");\n      return;\n    }\n    return;\n  }\n  public final void writeSlow(char[] towrite, int start, int length) {\n    // AMAZINGLY, in 1.5 it is quicker to create this here than economise it.\n    CharWrap svb = new CharWrap(length + 10);\n    int limit = start + length;\n    for (int i = length; i > 0; --i) {\n      char c = towrite[limit - i];\n      switch (c) {\n      case '&':\n        svb.append(\"&amp;\");\n        svb.ensureCapacity(svb.size + i);\n        break;\n      case '<':\n        svb.append(\"&lt;\");\n        svb.ensureCapacity(svb.size + i);\n        break;\n      case '>':\n        svb.append(\"&gt;\");\n        svb.ensureCapacity(svb.size + i);\n        break;\n      case '\"':\n        svb.append(\"&quot;\");\n        svb.ensureCapacity(svb.size + i);\n        break;\n      // HTML 4.0 does not define &apos; and does not plan to\n      case '\\'':\n        svb.append(\"&#39;\");\n        svb.ensureCapacity(svb.size + i);\n        break;\n      default:\n        svb.appendFast(c);\n      }\n      // String lookup = c > entitytable.length? null : entitytable[c];\n      // // optimised on the basis that entitising is RARE - we only check\n      // // available capacity at that point.\n      // if (lookup == null) {\n      // svb.appendFast(c);\n      // }\n      // else {\n      // svb.append(lookup);\n      // svb.ensureCapacity(svb.size + (limit - i));\n      // }\n    }\n    internalwriter.write(svb.storage, svb.offset, svb.size);\n  }\n  /**\n   * Writes the supplied data to the wrapped stream, escaping all mandatory\n   * XML/HTML entities, being &amp;, &lt;, &gt;, &quot; and &#39;. &#39; is\n   * escaped to &amp;#39; since HTML 4.0 does not define the &amp;apos; entity\n   * and does not plan to.\n   * \n   * @param towrite\n   *          The string to be written.\n   */\n  public void write(String towrite) {\n    char[] array = (towrite == null ? \"null\" : towrite).toCharArray();\n    write(array, 0, array.length);\n  }\n  /**\n   * Flushes the wrapped stream.\n   */\n  public void flush() {\n    internalwriter.flush();\n  }\n  /**\n   * Closes this XMLWriter object, in effect flushing it and making it unusable\n   * for any further write operations.\n   * <p>\n   * Closing this does not close the underlying input stream!\n   */\n  public void close() {\n    if (internalwriter != null) {\n      try {\n        flush();\n      }\n      catch (Throwable t) {\n        Logger.println(\"Unhandled exception closing XML Writer: \" + t,\n            Logger.DEBUG_SEVERE);\n        // internalwriter.close();\n        internalwriter = null;\n      }\n    }\n  }\n"]], "pred": {"ppl": 2.087570905685425, "ppl_lower": 2.221524238586426, "ppl/lowercase_ppl": -1.0845004261108475, "ppl/zlib": 0.00028604786007051225, "Min_5.0% Prob": 6.655791095658844, "Min_10.0% Prob": 4.9872096239351755, "Min_20.0% Prob": 3.2914235340613947, "Min_30.0% Prob": 2.3663170982420056, "Min_40.0% Prob": 1.8184470824332575, "Min_50.0% Prob": 1.4680341785580444, "Min_60.0% Prob": 1.2266969261371925}}
{"hexsha": "7a68b1fd390160594b29921e2b89c02b7536286f", "ext": "java", "lang": "Java", "content": "public final class FHIRValidationUtil {\n    public static final Comparator<Issue> ISSUE_COMPARATOR = new Comparator<Issue>() {\n        @Override\n        public int compare(Issue first, Issue second) {\n            return first.getSeverity().getValueAsEnum().compareTo(second.getSeverity().getValueAsEnum());\n        }\n    };\n\n    private FHIRValidationUtil() { }\n\n    public static List<Issue> getErrors(List<Issue> issues) {\n        Objects.requireNonNull(issues);\n        List<Issue> errors = new ArrayList<>();\n        for (Issue issue : issues) {\n            if (IssueSeverity.ERROR.equals(issue.getSeverity())) {\n                errors.add(issue);\n            }\n        }\n        return errors;\n    }\n\n    public static List<Issue> getWarnings(List<Issue> issues) {\n        Objects.requireNonNull(issues);\n        List<Issue> warnings = new ArrayList<>();\n        for (Issue issue : issues) {\n            if (IssueSeverity.WARNING.equals(issue.getSeverity())) {\n                warnings.add(issue);\n            }\n        }\n        return warnings;\n    }\n\n    public static List<Issue> getInformation(List<Issue> issues) {\n        Objects.requireNonNull(issues);\n        List<Issue> information = new ArrayList<>();\n        for (Issue issue : issues) {\n            if (IssueSeverity.INFORMATION.equals(issue.getSeverity())) {\n                information.add(issue);\n            }\n        }\n        return information;\n    }\n\n    public static boolean hasErrors(List<Issue> issues) {\n        for (Issue issue : issues) {\n            if (IssueSeverity.ERROR.equals(issue.getSeverity())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static boolean hasWarnings(List<Issue> issues) {\n        for (Issue issue : issues) {\n            if (IssueSeverity.WARNING.equals(issue.getSeverity())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static boolean hasInformation(List<Issue> issues) {\n        for (Issue issue : issues) {\n            if (IssueSeverity.INFORMATION.equals(issue.getSeverity())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static int countErrors(List<Issue> issues) {\n        return getErrors(issues).size();\n    }\n\n    public static int countWarnings(List<Issue> issues) {\n        return getWarnings(issues).size();\n    }\n\n    public static int countInformation(List<Issue> issues) {\n        return getInformation(issues).size();\n    }\n}", "item_id": 0, "repo": "mpayne2/FHIR", "file": "fhir-validation/src/main/java/com/ibm/fhir/validation/util/FHIRValidationUtil.java", "last_update_at": "2022-03-25T10:30:35+00:00", "question_id": "7a68b1fd390160594b29921e2b89c02b7536286f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class FHIRValidationUtil {\n    public static final Comparator<Issue> ISSUE_COMPARATOR = new Comparator<Issue>() {\n        @Override\n        public int compare(Issue first, Issue second) {\n            return first.getSeverity().getValueAsEnum().compareTo(second.getSeverity().getValueAsEnum());\n        }\n    };\n    private FHIRValidationUtil() { }\n    public static List<Issue> getErrors(List<Issue> issues) {\n        Objects.requireNonNull(issues);\n        List<Issue> errors = new ArrayList<>();\n        for (Issue issue : issues) {\n            if (IssueSeverity.ERROR.equals(issue.getSeverity())) {\n                errors.add(issue);\n            }\n        }\n        return errors;\n    }\n    public static List<Issue> getWarnings(List<Issue> issues) {\n        Objects.requireNonNull(issues);\n        List<Issue> warnings = new ArrayList<>();\n        for (Issue issue : issues) {\n            if (IssueSeverity.WARNING.equals(issue.getSeverity())) {\n                warnings.add(issue);\n            }\n        }\n        return warnings;\n    }\n    public static List<Issue> getInformation(List<Issue> issues) {\n        Objects.requireNonNull(issues);\n        List<Issue> information = new ArrayList<>();\n        for (Issue issue : issues) {\n            if (IssueSeverity.INFORMATION.equals(issue.getSeverity())) {\n                information.add(issue);\n            }\n        }\n        return information;\n    }\n    public static boolean hasErrors(List<Issue> issues) {\n        for (Issue issue : issues) {\n            if (IssueSeverity.ERROR.equals(issue.getSeverity())) {\n                return true;\n            }\n        }\n        return false;\n    }\n    public static boolean hasWarnings(List<Issue> issues) {\n        for (Issue issue : issues) {\n            if (IssueSeverity.WARNING.equals(issue.getSeverity())) {\n                return true;\n            }\n        }\n        return false;\n    }\n    public static boolean hasInformation(List<Issue> issues) {\n        for (Issue issue : issues) {\n            if (IssueSeverity.INFORMATION.equals(issue.getSeverity())) {\n                return true;\n            }\n        }\n        return false;\n    }\n    public static int countErrors(List<Issue> issues) {\n        return getErrors(issues).size();\n    }\n    public static int countWarnings(List<Issue> issues) {\n        return getWarnings(issues).size();\n    }\n    public static int countInformation(List<Issue> issues) {\n        return getInformation(issues).size();\n    }\n"]], "pred": {"ppl": 1.1910420656204224, "ppl_lower": 1.3408112525939941, "ppl/lowercase_ppl": -1.6774991477779864, "ppl/zlib": 0.00036651700069178345, "Min_5.0% Prob": 2.9336608245566085, "Min_10.0% Prob": 1.6726093777530902, "Min_20.0% Prob": 0.869943149375251, "Min_30.0% Prob": 0.5825190311989974, "Min_40.0% Prob": 0.43738407845887345, "Min_50.0% Prob": 0.35003683714107986, "Min_60.0% Prob": 0.2917444075280179}}
{"hexsha": "f4943d7420777c94e74d1fa22194380d253cac60", "ext": "java", "lang": "Java", "content": "public class AbsenceNoticeFilter implements Predicate<AbsenceNoticeRow> {\n\t\n\tprivate final Locale locale;\n\tprivate final String searchString;\n\tprivate final List<UserPropertyHandler> userPropertyHandlers;\n\t\n\tpublic AbsenceNoticeFilter(String searchString, List<UserPropertyHandler> userPropertyHandlers, Locale locale) {\n\t\tthis.searchString = searchString.toLowerCase();\n\t\tthis.userPropertyHandlers = userPropertyHandlers;\n\t\tthis.locale = locale;\n\t}\n\t\n\t@Override\n\tpublic boolean test(AbsenceNoticeRow row) {\n\t\tList<RepositoryEntry> entries = row.getEntriesList();\n\t\tif(entries != null && !entries.isEmpty()) {\n\t\t\tfor(RepositoryEntry entry:entries) {\n\t\t\t\tif(FilterHelper.test(entry, searchString)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tList<LectureBlock> lectureBlocks = row.getLectureBlocks();\n\t\tif(lectureBlocks != null && !lectureBlocks.isEmpty()) {\n\t\t\tfor(LectureBlock lectureBlock:lectureBlocks) {\n\t\t\t\tif(FilterHelper.test(lectureBlock, searchString)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tList<Identity> teachers = row.getTeachers();\n\t\tif(teachers != null && !teachers.isEmpty()) {\n\t\t\tfor(Identity teacher:teachers) {\n\t\t\t\tif(FilterHelper.test(teacher, searchString)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn FilterHelper.test(row.getAbsentIdentity().getUser(), searchString, userPropertyHandlers, locale);\n\t}\n}", "item_id": 0, "repo": "GeorgeKirev/OpenOLAT", "file": "src/main/java/org/olat/modules/lecture/ui/filter/AbsenceNoticeFilter.java", "last_update_at": "2022-03-23T06:42:12+00:00", "question_id": "f4943d7420777c94e74d1fa22194380d253cac60_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AbsenceNoticeFilter implements Predicate<AbsenceNoticeRow> {\n\t\n\tprivate final Locale locale;\n\tprivate final String searchString;\n\tprivate final List<UserPropertyHandler> userPropertyHandlers;\n\t\n\tpublic AbsenceNoticeFilter(String searchString, List<UserPropertyHandler> userPropertyHandlers, Locale locale) {\n\t\tthis.searchString = searchString.toLowerCase();\n\t\tthis.userPropertyHandlers = userPropertyHandlers;\n\t\tthis.locale = locale;\n\t}\n\t\n\t@Override\n\tpublic boolean test(AbsenceNoticeRow row) {\n\t\tList<RepositoryEntry> entries = row.getEntriesList();\n\t\tif(entries != null && !entries.isEmpty()) {\n\t\t\tfor(RepositoryEntry entry:entries) {\n\t\t\t\tif(FilterHelper.test(entry, searchString)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tList<LectureBlock> lectureBlocks = row.getLectureBlocks();\n\t\tif(lectureBlocks != null && !lectureBlocks.isEmpty()) {\n\t\t\tfor(LectureBlock lectureBlock:lectureBlocks) {\n\t\t\t\tif(FilterHelper.test(lectureBlock, searchString)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tList<Identity> teachers = row.getTeachers();\n\t\tif(teachers != null && !teachers.isEmpty()) {\n\t\t\tfor(Identity teacher:teachers) {\n\t\t\t\tif(FilterHelper.test(teacher, searchString)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn FilterHelper.test(row.getAbsentIdentity().getUser(), searchString, userPropertyHandlers, locale);\n\t}\n"]], "pred": {"ppl": 1.4398852586746216, "ppl_lower": 1.6728448867797852, "ppl/lowercase_ppl": -1.4113475495704224, "ppl/zlib": 0.0008192436605330664, "Min_5.0% Prob": 5.095839821774026, "Min_10.0% Prob": 3.2219041700058795, "Min_20.0% Prob": 1.7835248345607206, "Min_30.0% Prob": 1.21131396100817, "Min_40.0% Prob": 0.9092962612888138, "Min_50.0% Prob": 0.7300032404111895, "Min_60.0% Prob": 0.607428400157624}}
{"hexsha": "c8560978a51a44a8cc7697f0678b099716f16761", "ext": "java", "lang": "Java", "content": "@Generated(\"com.amazonaws:aws-java-sdk-code-generator\")\npublic class RegisterGameServerRequest extends com.amazonaws.AmazonWebServiceRequest implements Serializable, Cloneable {\n\n    /**\n     * <p>\n     * A unique identifier for the game server group where the game server is running. Use either the\n     * <a>GameServerGroup</a> name or ARN value.\n     * </p>\n     */\n    private String gameServerGroupName;\n    /**\n     * <p>\n     * A custom string that uniquely identifies the game server to register. Game server IDs are developer-defined and\n     * must be unique across all game server groups in your AWS account.\n     * </p>\n     */\n    private String gameServerId;\n    /**\n     * <p>\n     * The unique identifier for the instance where the game server is running. This ID is available in the instance\n     * metadata. EC2 instance IDs use a 17-character format, for example: <code>i-1234567890abcdef0</code>.\n     * </p>\n     */\n    private String instanceId;\n    /**\n     * <p>\n     * Information that is needed to make inbound client connections to the game server. This might include the IP\n     * address and port, DNS name, and other information.\n     * </p>\n     */\n    private String connectionInfo;\n    /**\n     * <p>\n     * A set of custom game server properties, formatted as a single string value. This data is passed to a game client\n     * or service when it requests information on game servers using <a>ListGameServers</a> or <a>ClaimGameServer</a>.\n     * </p>\n     */\n    private String gameServerData;\n\n    /**\n     * <p>\n     * A unique identifier for the game server group where the game server is running. Use either the\n     * <a>GameServerGroup</a> name or ARN value.\n     * </p>\n     * \n     * @param gameServerGroupName\n     *        A unique identifier for the game server group where the game server is running. Use either the\n     *        <a>GameServerGroup</a> name or ARN value.\n     */\n\n    public void setGameServerGroupName(String gameServerGroupName) {\n        this.gameServerGroupName = gameServerGroupName;\n    }\n\n    /**\n     * <p>\n     * A unique identifier for the game server group where the game server is running. Use either the\n     * <a>GameServerGroup</a> name or ARN value.\n     * </p>\n     * \n     * @return A unique identifier for the game server group where the game server is running. Use either the\n     *         <a>GameServerGroup</a> name or ARN value.\n     */\n\n    public String getGameServerGroupName() {\n        return this.gameServerGroupName;\n    }\n\n    /**\n     * <p>\n     * A unique identifier for the game server group where the game server is running. Use either the\n     * <a>GameServerGroup</a> name or ARN value.\n     * </p>\n     * \n     * @param gameServerGroupName\n     *        A unique identifier for the game server group where the game server is running. Use either the\n     *        <a>GameServerGroup</a> name or ARN value.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n\n    public RegisterGameServerRequest withGameServerGroupName(String gameServerGroupName) {\n        setGameServerGroupName(gameServerGroupName);\n        return this;\n    }\n\n    /**\n     * <p>\n     * A custom string that uniquely identifies the game server to register. Game server IDs are developer-defined and\n     * must be unique across all game server groups in your AWS account.\n     * </p>\n     * \n     * @param gameServerId\n     *        A custom string that uniquely identifies the game server to register. Game server IDs are\n     *        developer-defined and must be unique across all game server groups in your AWS account.\n     */\n\n    public void setGameServerId(String gameServerId) {\n        this.gameServerId = gameServerId;\n    }\n\n    /**\n     * <p>\n     * A custom string that uniquely identifies the game server to register. Game server IDs are developer-defined and\n     * must be unique across all game server groups in your AWS account.\n     * </p>\n     * \n     * @return A custom string that uniquely identifies the game server to register. Game server IDs are\n     *         developer-defined and must be unique across all game server groups in your AWS account.\n     */\n\n    public String getGameServerId() {\n        return this.gameServerId;\n    }\n\n    /**\n     * <p>\n     * A custom string that uniquely identifies the game server to register. Game server IDs are developer-defined and\n     * must be unique across all game server groups in your AWS account.\n     * </p>\n     * \n     * @param gameServerId\n     *        A custom string that uniquely identifies the game server to register. Game server IDs are\n     *        developer-defined and must be unique across all game server groups in your AWS account.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n\n    public RegisterGameServerRequest withGameServerId(String gameServerId) {\n        setGameServerId(gameServerId);\n        return this;\n    }\n\n    /**\n     * <p>\n     * The unique identifier for the instance where the game server is running. This ID is available in the instance\n     * metadata. EC2 instance IDs use a 17-character format, for example: <code>i-1234567890abcdef0</code>.\n     * </p>\n     * \n     * @param instanceId\n     *        The unique identifier for the instance where the game server is running. This ID is available in the\n     *        instance metadata. EC2 instance IDs use a 17-character format, for example:\n     *        <code>i-1234567890abcdef0</code>.\n     */\n\n    public void setInstanceId(String instanceId) {\n        this.instanceId = instanceId;\n    }\n\n    /**\n     * <p>\n     * The unique identifier for the instance where the game server is running. This ID is available in the instance\n     * metadata. EC2 instance IDs use a 17-character format, for example: <code>i-1234567890abcdef0</code>.\n     * </p>\n     * \n     * @return The unique identifier for the instance where the game server is running. This ID is available in the\n     *         instance metadata. EC2 instance IDs use a 17-character format, for example:\n     *         <code>i-1234567890abcdef0</code>.\n     */\n\n    public String getInstanceId() {\n        return this.instanceId;\n    }\n\n    /**\n     * <p>\n     * The unique identifier for the instance where the game server is running. This ID is available in the instance\n     * metadata. EC2 instance IDs use a 17-character format, for example: <code>i-1234567890abcdef0</code>.\n     * </p>\n     * \n     * @param instanceId\n     *        The unique identifier for the instance where the game server is running. This ID is available in the\n     *        instance metadata. EC2 instance IDs use a 17-character format, for example:\n     *        <code>i-1234567890abcdef0</code>.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n\n    public RegisterGameServerRequest withInstanceId(String instanceId) {\n        setInstanceId(instanceId);\n        return this;\n    }\n\n    /**\n     * <p>\n     * Information that is needed to make inbound client connections to the game server. This might include the IP\n     * address and port, DNS name, and other information.\n     * </p>\n     * \n     * @param connectionInfo\n     *        Information that is needed to make inbound client connections to the game server. This might include the\n     *        IP address and port, DNS name, and other information.\n     */\n\n    public void setConnectionInfo(String connectionInfo) {\n        this.connectionInfo = connectionInfo;\n    }\n\n    /**\n     * <p>\n     * Information that is needed to make inbound client connections to the game server. This might include the IP\n     * address and port, DNS name, and other information.\n     * </p>\n     * \n     * @return Information that is needed to make inbound client connections to the game server. This might include the\n     *         IP address and port, DNS name, and other information.\n     */\n\n    public String getConnectionInfo() {\n        return this.connectionInfo;\n    }\n\n    /**\n     * <p>\n     * Information that is needed to make inbound client connections to the game server. This might include the IP\n     * address and port, DNS name, and other information.\n     * </p>\n     * \n     * @param connectionInfo\n     *        Information that is needed to make inbound client connections to the game server. This might include the\n     *        IP address and port, DNS name, and other information.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n\n    public RegisterGameServerRequest withConnectionInfo(String connectionInfo) {\n        setConnectionInfo(connectionInfo);\n        return this;\n    }\n\n    /**\n     * <p>\n     * A set of custom game server properties, formatted as a single string value. This data is passed to a game client\n     * or service when it requests information on game servers using <a>ListGameServers</a> or <a>ClaimGameServer</a>.\n     * </p>\n     * \n     * @param gameServerData\n     *        A set of custom game server properties, formatted as a single string value. This data is passed to a game\n     *        client or service when it requests information on game servers using <a>ListGameServers</a> or\n     *        <a>ClaimGameServer</a>.\n     */\n\n    public void setGameServerData(String gameServerData) {\n        this.gameServerData = gameServerData;\n    }\n\n    /**\n     * <p>\n     * A set of custom game server properties, formatted as a single string value. This data is passed to a game client\n     * or service when it requests information on game servers using <a>ListGameServers</a> or <a>ClaimGameServer</a>.\n     * </p>\n     * \n     * @return A set of custom game server properties, formatted as a single string value. This data is passed to a game\n     *         client or service when it requests information on game servers using <a>ListGameServers</a> or\n     *         <a>ClaimGameServer</a>.\n     */\n\n    public String getGameServerData() {\n        return this.gameServerData;\n    }\n\n    /**\n     * <p>\n     * A set of custom game server properties, formatted as a single string value. This data is passed to a game client\n     * or service when it requests information on game servers using <a>ListGameServers</a> or <a>ClaimGameServer</a>.\n     * </p>\n     * \n     * @param gameServerData\n     *        A set of custom game server properties, formatted as a single string value. This data is passed to a game\n     *        client or service when it requests information on game servers using <a>ListGameServers</a> or\n     *        <a>ClaimGameServer</a>.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n\n    public RegisterGameServerRequest withGameServerData(String gameServerData) {\n        setGameServerData(gameServerData);\n        return this;\n    }\n\n    /**\n     * Returns a string representation of this object. This is useful for testing and debugging. Sensitive data will be\n     * redacted from this string using a placeholder value.\n     *\n     * @return A string representation of this object.\n     *\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (getGameServerGroupName() != null)\n            sb.append(\"GameServerGroupName: \").append(getGameServerGroupName()).append(\",\");\n        if (getGameServerId() != null)\n            sb.append(\"GameServerId: \").append(getGameServerId()).append(\",\");\n        if (getInstanceId() != null)\n            sb.append(\"InstanceId: \").append(getInstanceId()).append(\",\");\n        if (getConnectionInfo() != null)\n            sb.append(\"ConnectionInfo: \").append(getConnectionInfo()).append(\",\");\n        if (getGameServerData() != null)\n            sb.append(\"GameServerData: \").append(getGameServerData());\n        sb.append(\"}\");\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n\n        if (obj instanceof RegisterGameServerRequest == false)\n            return false;\n        RegisterGameServerRequest other = (RegisterGameServerRequest) obj;\n        if (other.getGameServerGroupName() == null ^ this.getGameServerGroupName() == null)\n            return false;\n        if (other.getGameServerGroupName() != null && other.getGameServerGroupName().equals(this.getGameServerGroupName()) == false)\n            return false;\n        if (other.getGameServerId() == null ^ this.getGameServerId() == null)\n            return false;\n        if (other.getGameServerId() != null && other.getGameServerId().equals(this.getGameServerId()) == false)\n            return false;\n        if (other.getInstanceId() == null ^ this.getInstanceId() == null)\n            return false;\n        if (other.getInstanceId() != null && other.getInstanceId().equals(this.getInstanceId()) == false)\n            return false;\n        if (other.getConnectionInfo() == null ^ this.getConnectionInfo() == null)\n            return false;\n        if (other.getConnectionInfo() != null && other.getConnectionInfo().equals(this.getConnectionInfo()) == false)\n            return false;\n        if (other.getGameServerData() == null ^ this.getGameServerData() == null)\n            return false;\n        if (other.getGameServerData() != null && other.getGameServerData().equals(this.getGameServerData()) == false)\n            return false;\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int hashCode = 1;\n\n        hashCode = prime * hashCode + ((getGameServerGroupName() == null) ? 0 : getGameServerGroupName().hashCode());\n        hashCode = prime * hashCode + ((getGameServerId() == null) ? 0 : getGameServerId().hashCode());\n        hashCode = prime * hashCode + ((getInstanceId() == null) ? 0 : getInstanceId().hashCode());\n        hashCode = prime * hashCode + ((getConnectionInfo() == null) ? 0 : getConnectionInfo().hashCode());\n        hashCode = prime * hashCode + ((getGameServerData() == null) ? 0 : getGameServerData().hashCode());\n        return hashCode;\n    }\n\n    @Override\n    public RegisterGameServerRequest clone() {\n        return (RegisterGameServerRequest) super.clone();\n    }\n\n}", "item_id": 0, "repo": "rbalamohan/aws-sdk-java", "file": "aws-java-sdk-gamelift/src/main/java/com/amazonaws/services/gamelift/model/RegisterGameServerRequest.java", "last_update_at": "2022-03-31T15:56:24+00:00", "question_id": "c8560978a51a44a8cc7697f0678b099716f16761_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Generated(\"com.amazonaws:aws-java-sdk-code-generator\")\npublic class RegisterGameServerRequest extends com.amazonaws.AmazonWebServiceRequest implements Serializable, Cloneable {\n    /**\n     * <p>\n     * A unique identifier for the game server group where the game server is running. Use either the\n     * <a>GameServerGroup</a> name or ARN value.\n     * </p>\n     */\n    private String gameServerGroupName;\n    /**\n     * <p>\n     * A custom string that uniquely identifies the game server to register. Game server IDs are developer-defined and\n     * must be unique across all game server groups in your AWS account.\n     * </p>\n     */\n    private String gameServerId;\n    /**\n     * <p>\n     * The unique identifier for the instance where the game server is running. This ID is available in the instance\n     * metadata. EC2 instance IDs use a 17-character format, for example: <code>i-1234567890abcdef0</code>.\n     * </p>\n     */\n    private String instanceId;\n    /**\n     * <p>\n     * Information that is needed to make inbound client connections to the game server. This might include the IP\n     * address and port, DNS name, and other information.\n     * </p>\n     */\n    private String connectionInfo;\n    /**\n     * <p>\n     * A set of custom game server properties, formatted as a single string value. This data is passed to a game client\n     * or service when it requests information on game servers using <a>ListGameServers</a> or <a>ClaimGameServer</a>.\n     * </p>\n     */\n    private String gameServerData;\n    /**\n     * <p>\n     * A unique identifier for the game server group where the game server is running. Use either the\n     * <a>GameServerGroup</a> name or ARN value.\n     * </p>\n     * \n     * @param gameServerGroupName\n     *        A unique identifier for the game server group where the game server is running. Use either the\n     *        <a>GameServerGroup</a> name or ARN value.\n     */\n    public void setGameServerGroupName(String gameServerGroupName) {\n        this.gameServerGroupName = gameServerGroupName;\n    }\n    /**\n     * <p>\n     * A unique identifier for the game server group where the game server is running. Use either the\n     * <a>GameServerGroup</a> name or ARN value.\n     * </p>\n     * \n     * @return A unique identifier for the game server group where the game server is running. Use either the\n     *         <a>GameServerGroup</a> name or ARN value.\n     */\n    public String getGameServerGroupName() {\n        return this.gameServerGroupName;\n    }\n    /**\n     * <p>\n     * A unique identifier for the game server group where the game server is running. Use either the\n     * <a>GameServerGroup</a> name or ARN value.\n     * </p>\n     * \n     * @param gameServerGroupName\n     *        A unique identifier for the game server group where the game server is running. Use either the\n     *        <a>GameServerGroup</a> name or ARN value.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n    public RegisterGameServerRequest withGameServerGroupName(String gameServerGroupName) {\n        setGameServerGroupName(gameServerGroupName);\n        return this;\n    }\n    /**\n     * <p>\n     * A custom string that uniquely identifies the game server to register. Game server IDs are developer-defined and\n     * must be unique across all game server groups in your AWS account.\n     * </p>\n     * \n     * @param gameServerId\n     *        A custom string that uniquely identifies the game server to register. Game server IDs are\n     *        developer-defined and must be unique across all game server groups in your AWS account.\n     */\n    public void setGameServerId(String gameServerId) {\n        this.gameServerId = gameServerId;\n    }\n    /**\n     * <p>\n     * A custom string that uniquely identifies the game server to register. Game server IDs are developer-defined and\n     * must be unique across all game server groups in your AWS account.\n     * </p>\n     * \n     * @return A custom string that uniquely identifies the game server to register. Game server IDs are\n     *         developer-defined and must be unique across all game server groups in your AWS account.\n     */\n    public String getGameServerId() {\n        return this.gameServerId;\n    }\n    /**\n     * <p>\n     * A custom string that uniquely identifies the game server to register. Game server IDs are developer-defined and\n     * must be unique across all game server groups in your AWS account.\n     * </p>\n     * \n     * @param gameServerId\n     *        A custom string that uniquely identifies the game server to register. Game server IDs are\n     *        developer-defined and must be unique across all game server groups in your AWS account.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n    public RegisterGameServerRequest withGameServerId(String gameServerId) {\n        setGameServerId(gameServerId);\n        return this;\n    }\n    /**\n     * <p>\n     * The unique identifier for the instance where the game server is running. This ID is available in the instance\n     * metadata. EC2 instance IDs use a 17-character format, for example: <code>i-1234567890abcdef0</code>.\n     * </p>\n     * \n     * @param instanceId\n     *        The unique identifier for the instance where the game server is running. This ID is available in the\n     *        instance metadata. EC2 instance IDs use a 17-character format, for example:\n     *        <code>i-1234567890abcdef0</code>.\n     */\n    public void setInstanceId(String instanceId) {\n        this.instanceId = instanceId;\n    }\n    /**\n     * <p>\n     * The unique identifier for the instance where the game server is running. This ID is available in the instance\n     * metadata. EC2 instance IDs use a 17-character format, for example: <code>i-1234567890abcdef0</code>.\n     * </p>\n     * \n     * @return The unique identifier for the instance where the game server is running. This ID is available in the\n     *         instance metadata. EC2 instance IDs use a 17-character format, for example:\n     *         <code>i-1234567890abcdef0</code>.\n     */\n    public String getInstanceId() {\n        return this.instanceId;\n    }\n    /**\n     * <p>\n     * The unique identifier for the instance where the game server is running. This ID is available in the instance\n     * metadata. EC2 instance IDs use a 17-character format, for example: <code>i-1234567890abcdef0</code>.\n     * </p>\n     * \n     * @param instanceId\n     *        The unique identifier for the instance where the game server is running. This ID is available in the\n     *        instance metadata. EC2 instance IDs use a 17-character format, for example:\n     *        <code>i-1234567890abcdef0</code>.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n    public RegisterGameServerRequest withInstanceId(String instanceId) {\n        setInstanceId(instanceId);\n        return this;\n    }\n    /**\n     * <p>\n     * Information that is needed to make inbound client connections to the game server. This might include the IP\n     * address and port, DNS name, and other information.\n     * </p>\n     * \n     * @param connectionInfo\n     *        Information that is needed to make inbound client connections to the game server. This might include the\n     *        IP address and port, DNS name, and other information.\n     */\n    public void setConnectionInfo(String connectionInfo) {\n        this.connectionInfo = connectionInfo;\n    }\n    /**\n     * <p>\n     * Information that is needed to make inbound client connections to the game server. This might include the IP\n     * address and port, DNS name, and other information.\n     * </p>\n     * \n     * @return Information that is needed to make inbound client connections to the game server. This might include the\n     *         IP address and port, DNS name, and other information.\n     */\n    public String getConnectionInfo() {\n        return this.connectionInfo;\n    }\n    /**\n     * <p>\n     * Information that is needed to make inbound client connections to the game server. This might include the IP\n     * address and port, DNS name, and other information.\n     * </p>\n     * \n     * @param connectionInfo\n     *        Information that is needed to make inbound client connections to the game server. This might include the\n     *        IP address and port, DNS name, and other information.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n    public RegisterGameServerRequest withConnectionInfo(String connectionInfo) {\n        setConnectionInfo(connectionInfo);\n        return this;\n    }\n    /**\n     * <p>\n     * A set of custom game server properties, formatted as a single string value. This data is passed to a game client\n     * or service when it requests information on game servers using <a>ListGameServers</a> or <a>ClaimGameServer</a>.\n     * </p>\n     * \n     * @param gameServerData\n     *        A set of custom game server properties, formatted as a single string value. This data is passed to a game\n     *        client or service when it requests information on game servers using <a>ListGameServers</a> or\n     *        <a>ClaimGameServer</a>.\n     */\n    public void setGameServerData(String gameServerData) {\n        this.gameServerData = gameServerData;\n    }\n    /**\n     * <p>\n     * A set of custom game server properties, formatted as a single string value. This data is passed to a game client\n     * or service when it requests information on game servers using <a>ListGameServers</a> or <a>ClaimGameServer</a>.\n     * </p>\n     * \n     * @return A set of custom game server properties, formatted as a single string value. This data is passed to a game\n     *         client or service when it requests information on game servers using <a>ListGameServers</a> or\n     *         <a>ClaimGameServer</a>.\n     */\n    public String getGameServerData() {\n        return this.gameServerData;\n    }\n    /**\n     * <p>\n     * A set of custom game server properties, formatted as a single string value. This data is passed to a game client\n     * or service when it requests information on game servers using <a>ListGameServers</a> or <a>ClaimGameServer</a>.\n     * </p>\n     * \n     * @param gameServerData\n     *        A set of custom game server properties, formatted as a single string value. This data is passed to a game\n     *        client or service when it requests information on game servers using <a>ListGameServers</a> or\n     *        <a>ClaimGameServer</a>.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n    public RegisterGameServerRequest withGameServerData(String gameServerData) {\n        setGameServerData(gameServerData);\n        return this;\n    }\n    /**\n     * Returns a string representation of this object. This is useful for testing and debugging. Sensitive data will be\n     * redacted from this string using a placeholder value.\n     *\n     * @return A string representation of this object.\n     *\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (getGameServerGroupName() != null)\n            sb.append(\"GameServerGroupName: \").append(getGameServerGroupName()).append(\",\");\n        if (getGameServerId() != null)\n            sb.append(\"GameServerId: \").append(getGameServerId()).append(\",\");\n        if (getInstanceId() != null)\n            sb.append(\"InstanceId: \").append(getInstanceId()).append(\",\");\n        if (getConnectionInfo() != null)\n            sb.append(\"ConnectionInfo: \").append(getConnectionInfo()).append(\",\");\n        if (getGameServerData() != null)\n            sb.append(\"GameServerData: \").append(getGameServerData());\n        sb.append(\"}\");\n        return sb.toString();\n    }\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (obj instanceof RegisterGameServerRequest == false)\n            return false;\n        RegisterGameServerRequest other = (RegisterGameServerRequest) obj;\n        if (other.getGameServerGroupName() == null ^ this.getGameServerGroupName() == null)\n            return false;\n        if (other.getGameServerGroupName() != null && other.getGameServerGroupName().equals(this.getGameServerGroupName()) == false)\n            return false;\n        if (other.getGameServerId() == null ^ this.getGameServerId() == null)\n            return false;\n        if (other.getGameServerId() != null && other.getGameServerId().equals(this.getGameServerId()) == false)\n            return false;\n        if (other.getInstanceId() == null ^ this.getInstanceId() == null)\n            return false;\n        if (other.getInstanceId() != null && other.getInstanceId().equals(this.getInstanceId()) == false)\n            return false;\n        if (other.getConnectionInfo() == null ^ this.getConnectionInfo() == null)\n            return false;\n        if (other.getConnectionInfo() != null && other.getConnectionInfo().equals(this.getConnectionInfo()) == false)\n            return false;\n        if (other.getGameServerData() == null ^ this.getGameServerData() == null)\n            return false;\n        if (other.getGameServerData() != null && other.getGameServerData().equals(this.getGameServerData()) == false)\n            return false;\n        return true;\n    }\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int hashCode = 1;\n        hashCode = prime * hashCode + ((getGameServerGroupName() == null) ? 0 : getGameServerGroupName().hashCode());\n        hashCode = prime * hashCode + ((getGameServerId() == null) ? 0 : getGameServerId().hashCode());\n        hashCode = prime * hashCode + ((getInstanceId() == null) ? 0 : getInstanceId().hashCode());\n        hashCode = prime * hashCode + ((getConnectionInfo() == null) ? 0 : getConnectionInfo().hashCode());\n        hashCode = prime * hashCode + ((getGameServerData() == null) ? 0 : getGameServerData().hashCode());\n        return hashCode;\n    }\n    @Override\n    public RegisterGameServerRequest clone() {\n        return (RegisterGameServerRequest) super.clone();\n    }\n"]], "pred": {"ppl": 1.1601543426513672, "ppl_lower": 1.3807270526885986, "ppl/lowercase_ppl": -2.171683513767726, "ppl/zlib": 8.532627816035205e-05, "Min_5.0% Prob": 2.7240942436106064, "Min_10.0% Prob": 1.471238140893333, "Min_20.0% Prob": 0.7443953660127305, "Min_30.0% Prob": 0.4966088828189052, "Min_40.0% Prob": 0.3715607728416857, "Min_50.0% Prob": 0.29739585072553976, "Min_60.0% Prob": 0.24791117955505726}}
{"hexsha": "95f062987e4f33a4b0ff85b3fdd299b38fc36e6a", "ext": "java", "lang": "Java", "content": "@ControllerAdvice\n@RestController\n@Slf4j\npublic class ExceptionHandlerConfig {\n\n        /**\n         * AuthenticationException Shiro\u8ba4\u8bc1\u5f02\u5e38\n         */\n        @ExceptionHandler(value = {AuthenticationException.class, AuthorizationException.class})\n        public String authenticationExceptionHandler(Exception e, HttpServletResponse response){\n            response.setStatus(HttpStatus.UNAUTHORIZED.value());\n            log.info(\"\" + e);\n            return \"\ud83d\udc7b \u6743\u9650\u5f02\u5e38\uff01\";\n        }\n\n        @ExceptionHandler(value = Exception.class)\n        public String exceptionHandler(Exception e, HttpServletResponse response){\n            response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());\n            log.info(\"\" + e);\n            return \"\ud83d\udc7b \u7cfb\u7edf\u5f02\u5e38\uff01\";\n        }\n}", "item_id": 0, "repo": "lengqie/iResearch", "file": "src/main/java/com/iresearch/config/ExceptionHandlerConfig.java", "last_update_at": "2022-01-25T07:13:51+00:00", "question_id": "95f062987e4f33a4b0ff85b3fdd299b38fc36e6a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ControllerAdvice\n@RestController\n@Slf4j\npublic class ExceptionHandlerConfig {\n        /**\n         * AuthenticationException Shiro\u8ba4\u8bc1\u5f02\u5e38\n         */\n        @ExceptionHandler(value = {AuthenticationException.class, AuthorizationException.class})\n        public String authenticationExceptionHandler(Exception e, HttpServletResponse response){\n            response.setStatus(HttpStatus.UNAUTHORIZED.value());\n            log.info(\"\" + e);\n            return \"\ud83d\udc7b \u6743\u9650\u5f02\u5e38\uff01\";\n        }\n        @ExceptionHandler(value = Exception.class)\n        public String exceptionHandler(Exception e, HttpServletResponse response){\n            response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());\n            log.info(\"\" + e);\n            return \"\ud83d\udc7b \u7cfb\u7edf\u5f02\u5e38\uff01\";\n        }\n"]], "pred": {"ppl": 2.11619234085083, "ppl_lower": 2.741448402404785, "ppl/lowercase_ppl": -1.3453330170842965, "ppl/zlib": 0.002237666890112684, "Min_5.0% Prob": 7.727367782592774, "Min_10.0% Prob": 5.198769013086955, "Min_20.0% Prob": 3.3778488153503057, "Min_30.0% Prob": 2.434842019090577, "Min_40.0% Prob": 1.8646957907116128, "Min_50.0% Prob": 1.5026539756251234, "Min_60.0% Prob": 1.254611445010625}}
{"hexsha": "7c9b79d7800b1c2da0644539e482608dc1daaec6", "ext": "java", "lang": "Java", "content": "public class TotalTradingValume extends KeyedProcessFunction<Long, TotalBuyCount, TotalBuyCount> {\n\n    private ValueState<Long> totalValue;\n\n    @Override\n    public void open(Configuration parameters) throws Exception {\n        totalValue = getRuntimeContext().getState(new ValueStateDescriptor<Long>(\"total-buy-count\"\n                , Long.class, 0L));\n    }\n\n    @Override\n    public void processElement(TotalBuyCount value, Context ctx, Collector<TotalBuyCount> out) throws Exception {\n        totalValue.update(totalValue.value() + value.getCount());\n\n        ctx.timerService().registerEventTimeTimer(value.getWindowEnd() + 1);\n\n    }\n\n    @Override\n    public void onTimer(long timestamp, OnTimerContext ctx, Collector<TotalBuyCount> out) throws Exception {\n        Long count = totalValue.value();\n\n        out.collect(new TotalBuyCount(\"buy\", ctx.getCurrentKey(), count));\n        totalValue.clear();\n\n    }\n}", "item_id": 0, "repo": "metaword/bigdata-study", "file": "filnk-userbehavior-analysis/src/main/java/com/aifurion/trading/TotalTradingValume.java", "last_update_at": "2022-03-25T09:37:22+00:00", "question_id": "7c9b79d7800b1c2da0644539e482608dc1daaec6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TotalTradingValume extends KeyedProcessFunction<Long, TotalBuyCount, TotalBuyCount> {\n    private ValueState<Long> totalValue;\n    @Override\n    public void open(Configuration parameters) throws Exception {\n        totalValue = getRuntimeContext().getState(new ValueStateDescriptor<Long>(\"total-buy-count\"\n                , Long.class, 0L));\n    }\n    @Override\n    public void processElement(TotalBuyCount value, Context ctx, Collector<TotalBuyCount> out) throws Exception {\n        totalValue.update(totalValue.value() + value.getCount());\n        ctx.timerService().registerEventTimeTimer(value.getWindowEnd() + 1);\n    }\n    @Override\n    public void onTimer(long timestamp, OnTimerContext ctx, Collector<TotalBuyCount> out) throws Exception {\n        Long count = totalValue.value();\n        out.collect(new TotalBuyCount(\"buy\", ctx.getCurrentKey(), count));\n        totalValue.clear();\n    }\n"]], "pred": {"ppl": 1.8260937929153442, "ppl_lower": 3.0256896018981934, "ppl/lowercase_ppl": -1.838554257926164, "ppl/zlib": 0.0014687296246013804, "Min_5.0% Prob": 6.847983002662659, "Min_10.0% Prob": 4.583206396102906, "Min_20.0% Prob": 2.8254738812353097, "Min_30.0% Prob": 1.986017386183927, "Min_40.0% Prob": 1.4967552513687634, "Min_50.0% Prob": 1.2068055092804426, "Min_60.0% Prob": 1.0030251584286662}}
{"hexsha": "1f58d128d2c01cbdd0a61b6d9c611c7ceb60633e", "ext": "java", "lang": "Java", "content": "@Configuration\n@Import(SolaceBinderHealthIndicatorConfiguration.class)\n@EnableConfigurationProperties({ SolaceExtendedBindingProperties.class })\npublic class SolaceMessageChannelBinderConfiguration {\n\tprivate final JCSMPProperties jcsmpProperties;\n\tprivate final SolaceExtendedBindingProperties solaceExtendedBindingProperties;\n\tprivate final SolaceSessionEventHandler solaceSessionEventHandler;\n\n\tprivate JCSMPSession jcsmpSession;\n\tprivate Context context;\n\n\tprivate static final Log logger = LogFactory.getLog(SolaceMessageChannelBinderConfiguration.class);\n\n\tpublic SolaceMessageChannelBinderConfiguration(JCSMPProperties jcsmpProperties,\n\t\t\t\t\t\t\t\t\t\t\t\t   SolaceExtendedBindingProperties solaceExtendedBindingProperties,\n\t\t\t\t\t\t\t\t\t\t\t\t   @Nullable SolaceSessionEventHandler solaceSessionEventHandler) {\n\t\tthis.jcsmpProperties = jcsmpProperties;\n\t\tthis.solaceExtendedBindingProperties = solaceExtendedBindingProperties;\n\t\tthis.solaceSessionEventHandler = solaceSessionEventHandler;\n\t}\n\n\t@PostConstruct\n\tprivate void initSession() throws JCSMPException {\n\t\tJCSMPProperties jcsmpProperties = (JCSMPProperties) this.jcsmpProperties.clone();\n\t\tjcsmpProperties.setProperty(JCSMPProperties.CLIENT_INFO_PROVIDER, new SolaceBinderClientInfoProvider());\n\t\ttry {\n\t\t\tif (solaceSessionEventHandler != null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Registering Solace Session Event handler on session\");\n\t\t\t\t}\n\t\t\t\tcontext = JCSMPFactory.onlyInstance().createContext(new ContextProperties());\n\t\t\t\tjcsmpSession = JCSMPFactory.onlyInstance().createSession(jcsmpProperties, context, solaceSessionEventHandler);\n\t\t\t} else {\n\t\t\t\tjcsmpSession = JCSMPFactory.onlyInstance().createSession(jcsmpProperties);\n\t\t\t}\n\t\t\tlogger.info(String.format(\"Connecting JCSMP session %s\", jcsmpSession.getSessionName()));\n\t\t\tjcsmpSession.connect();\n\t\t\tif (solaceSessionEventHandler != null) {\n\t\t\t\tsolaceSessionEventHandler.connected();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tif (context != null) {\n\t\t\t\tcontext.destroy();\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\t@Bean\n\tSolaceMessageChannelBinder solaceMessageChannelBinder() {\n\t\tSolaceMessageChannelBinder binder = new SolaceMessageChannelBinder(jcsmpSession, context, provisioningProvider());\n\t\tbinder.setExtendedBindingProperties(solaceExtendedBindingProperties);\n\t\treturn binder;\n\t}\n\n\t@Bean\n\tSolaceQueueProvisioner provisioningProvider() {\n\t\treturn new SolaceQueueProvisioner(jcsmpSession);\n\t}\n\n}", "item_id": 0, "repo": "Nephery/solace-spring-cloud", "file": "solace-spring-cloud-stream-binder/solace-spring-cloud-stream-binder/src/main/java/com/solace/spring/cloud/stream/binder/config/SolaceMessageChannelBinderConfiguration.java", "last_update_at": "2022-03-28T02:34:46+00:00", "question_id": "1f58d128d2c01cbdd0a61b6d9c611c7ceb60633e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Configuration\n@Import(SolaceBinderHealthIndicatorConfiguration.class)\n@EnableConfigurationProperties({ SolaceExtendedBindingProperties.class })\npublic class SolaceMessageChannelBinderConfiguration {\n\tprivate final JCSMPProperties jcsmpProperties;\n\tprivate final SolaceExtendedBindingProperties solaceExtendedBindingProperties;\n\tprivate final SolaceSessionEventHandler solaceSessionEventHandler;\n\tprivate JCSMPSession jcsmpSession;\n\tprivate Context context;\n\tprivate static final Log logger = LogFactory.getLog(SolaceMessageChannelBinderConfiguration.class);\n\tpublic SolaceMessageChannelBinderConfiguration(JCSMPProperties jcsmpProperties,\n\t\t\t\t\t\t\t\t\t\t\t\t   SolaceExtendedBindingProperties solaceExtendedBindingProperties,\n\t\t\t\t\t\t\t\t\t\t\t\t   @Nullable SolaceSessionEventHandler solaceSessionEventHandler) {\n\t\tthis.jcsmpProperties = jcsmpProperties;\n\t\tthis.solaceExtendedBindingProperties = solaceExtendedBindingProperties;\n\t\tthis.solaceSessionEventHandler = solaceSessionEventHandler;\n\t}\n\t@PostConstruct\n\tprivate void initSession() throws JCSMPException {\n\t\tJCSMPProperties jcsmpProperties = (JCSMPProperties) this.jcsmpProperties.clone();\n\t\tjcsmpProperties.setProperty(JCSMPProperties.CLIENT_INFO_PROVIDER, new SolaceBinderClientInfoProvider());\n\t\ttry {\n\t\t\tif (solaceSessionEventHandler != null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Registering Solace Session Event handler on session\");\n\t\t\t\t}\n\t\t\t\tcontext = JCSMPFactory.onlyInstance().createContext(new ContextProperties());\n\t\t\t\tjcsmpSession = JCSMPFactory.onlyInstance().createSession(jcsmpProperties, context, solaceSessionEventHandler);\n\t\t\t} else {\n\t\t\t\tjcsmpSession = JCSMPFactory.onlyInstance().createSession(jcsmpProperties);\n\t\t\t}\n\t\t\tlogger.info(String.format(\"Connecting JCSMP session %s\", jcsmpSession.getSessionName()));\n\t\t\tjcsmpSession.connect();\n\t\t\tif (solaceSessionEventHandler != null) {\n\t\t\t\tsolaceSessionEventHandler.connected();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tif (context != null) {\n\t\t\t\tcontext.destroy();\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}\n\t@Bean\n\tSolaceMessageChannelBinder solaceMessageChannelBinder() {\n\t\tSolaceMessageChannelBinder binder = new SolaceMessageChannelBinder(jcsmpSession, context, provisioningProvider());\n\t\tbinder.setExtendedBindingProperties(solaceExtendedBindingProperties);\n\t\treturn binder;\n\t}\n\t@Bean\n\tSolaceQueueProvisioner provisioningProvider() {\n\t\treturn new SolaceQueueProvisioner(jcsmpSession);\n\t}\n"]], "pred": {"ppl": 1.6044515371322632, "ppl_lower": 1.9232763051986694, "ppl/lowercase_ppl": -1.3833652145654336, "ppl/zlib": 0.0006458770174439785, "Min_5.0% Prob": 5.477036031516823, "Min_10.0% Prob": 3.8029008362744308, "Min_20.0% Prob": 2.27070879271707, "Min_30.0% Prob": 1.5640850299046383, "Min_40.0% Prob": 1.178958852132563, "Min_50.0% Prob": 0.9459276979417613, "Min_60.0% Prob": 0.7891727228792844}}
{"hexsha": "abe0f26e99350ce8103fe5f9bc16929960bed0a3", "ext": "java", "lang": "Java", "content": "public class Math {\n\n\tpublic static Integer pow(Integer a, Integer b) {\n\t\treturn (int) java.lang.Math.pow(a, b);\n\t}\n\t\n\tpublic static Integer sbin(Integer in, Integer size) {\n\t\tswitch(size) {\n\t\tcase 1: return (int) Short.valueOf(in.toString());\n\t\tcase 2: return (int) Integer.valueOf(in.toString()).shortValue();\n\t\tcase 4: return (int) Long.valueOf(in.toString()).intValue();\n\t\t}\n\t\treturn in;\n\t}\n\t\n\tpublic static Integer defaultIndicator(Integer size, Boolean signed) {\n\t\tif(signed) return -1;\n\t\t\n\t\tswitch(size) {\n\t\tcase 1: return 0xff;\n\t\tcase 2: return 0xffff;\n\t\tcase 3: return 0xffffff;\n\t\tcase 4: return 0xffffffff;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Unsupported size \"+size);\n\t}\n\n\t   public static Integer calculateFlagValue(Integer size, Integer bit) {\n\t        BitSet set = new BitSet(size);\n\t        set.set(size - bit - 1);\n\t        return (int) set.toLongArray()[0];\n\t    }\n\n}", "item_id": 0, "repo": "moritzfl/afplib", "file": "org.afplib.generator/src/org/afplib/generator/util/Math.java", "last_update_at": "2022-02-09T15:35:59+00:00", "question_id": "abe0f26e99350ce8103fe5f9bc16929960bed0a3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Math {\n\tpublic static Integer pow(Integer a, Integer b) {\n\t\treturn (int) java.lang.Math.pow(a, b);\n\t}\n\t\n\tpublic static Integer sbin(Integer in, Integer size) {\n\t\tswitch(size) {\n\t\tcase 1: return (int) Short.valueOf(in.toString());\n\t\tcase 2: return (int) Integer.valueOf(in.toString()).shortValue();\n\t\tcase 4: return (int) Long.valueOf(in.toString()).intValue();\n\t\t}\n\t\treturn in;\n\t}\n\t\n\tpublic static Integer defaultIndicator(Integer size, Boolean signed) {\n\t\tif(signed) return -1;\n\t\t\n\t\tswitch(size) {\n\t\tcase 1: return 0xff;\n\t\tcase 2: return 0xffff;\n\t\tcase 3: return 0xffffff;\n\t\tcase 4: return 0xffffffff;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Unsupported size \"+size);\n\t}\n\t   public static Integer calculateFlagValue(Integer size, Integer bit) {\n\t        BitSet set = new BitSet(size);\n\t        set.set(size - bit - 1);\n\t        return (int) set.toLongArray()[0];\n\t    }\n"]], "pred": {"ppl": 2.176368236541748, "ppl_lower": 2.5982980728149414, "ppl/lowercase_ppl": -1.2278626425327641, "ppl/zlib": 0.002041095908211125, "Min_5.0% Prob": 7.9929618537425995, "Min_10.0% Prob": 5.696859896183014, "Min_20.0% Prob": 3.5505964609292837, "Min_30.0% Prob": 2.513154137195373, "Min_40.0% Prob": 1.922586165197933, "Min_50.0% Prob": 1.5477567716933243, "Min_60.0% Prob": 1.2986052850622456}}
{"hexsha": "5471a6f78601740bd0ac1ab416a1b3e5eeb4aa3f", "ext": "java", "lang": "Java", "content": "@Slf4j\n@Aspect\n@Component\npublic class GuavaRateLimiterAspect {\n    private static final ConcurrentMap<String, com.google.common.util.concurrent.RateLimiter> RATE_LIMITER_CACHE = new ConcurrentHashMap<>();\n\n    @Pointcut(\"@annotation(com.sakura.common.ratelimit.guava.RateLimiter)\")\n    public void rateLimit() {\n\n    }\n\n    @Around(\"rateLimit()\")\n    public Object pointcut(ProceedingJoinPoint point) throws Throwable {\n        MethodSignature signature = (MethodSignature) point.getSignature();\n        Method method = signature.getMethod();\n        // \u901a\u8fc7 AnnotationUtils.findAnnotation \u83b7\u53d6 RateLimiter \u6ce8\u89e3\n        RateLimiter rateLimiter = AnnotationUtils.findAnnotation(method, RateLimiter.class);\n        if (rateLimiter != null && rateLimiter.qps() > RateLimiter.NOT_LIMITED) {\n            double qps = rateLimiter.qps();\n            if (RATE_LIMITER_CACHE.get(method.getName()) == null) {\n                // \u521d\u59cb\u5316 QPS\n                RATE_LIMITER_CACHE.put(method.getName(), com.google.common.util.concurrent.RateLimiter.create(qps));\n            }\n\n            log.debug(\"\u3010{}\u3011\u7684QPS\u8bbe\u7f6e\u4e3a: {}\", method.getName(), RATE_LIMITER_CACHE.get(method.getName()).getRate());\n            // \u5c1d\u8bd5\u83b7\u53d6\u4ee4\u724c\n            if (RATE_LIMITER_CACHE.get(method.getName()) != null && !RATE_LIMITER_CACHE.get(method.getName()).tryAcquire(rateLimiter.timeout(), rateLimiter.timeUnit())) {\n                throw new YWarmingException(\"\u624b\u901f\u592a\u5feb\u4e86\uff0c\u6162\u70b9\u513f\u5427~\");\n            }\n        }\n        return point.proceed();\n    }\n}", "item_id": 0, "repo": "yanjingfan/boot-parent", "file": "sakura-common/src/main/java/com/sakura/common/ratelimit/guava/GuavaRateLimiterAspect.java", "last_update_at": "2022-03-26T02:04:24+00:00", "question_id": "5471a6f78601740bd0ac1ab416a1b3e5eeb4aa3f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\n@Aspect\n@Component\npublic class GuavaRateLimiterAspect {\n    private static final ConcurrentMap<String, com.google.common.util.concurrent.RateLimiter> RATE_LIMITER_CACHE = new ConcurrentHashMap<>();\n    @Pointcut(\"@annotation(com.sakura.common.ratelimit.guava.RateLimiter)\")\n    public void rateLimit() {\n    }\n    @Around(\"rateLimit()\")\n    public Object pointcut(ProceedingJoinPoint point) throws Throwable {\n        MethodSignature signature = (MethodSignature) point.getSignature();\n        Method method = signature.getMethod();\n        // \u901a\u8fc7 AnnotationUtils.findAnnotation \u83b7\u53d6 RateLimiter \u6ce8\u89e3\n        RateLimiter rateLimiter = AnnotationUtils.findAnnotation(method, RateLimiter.class);\n        if (rateLimiter != null && rateLimiter.qps() > RateLimiter.NOT_LIMITED) {\n            double qps = rateLimiter.qps();\n            if (RATE_LIMITER_CACHE.get(method.getName()) == null) {\n                // \u521d\u59cb\u5316 QPS\n                RATE_LIMITER_CACHE.put(method.getName(), com.google.common.util.concurrent.RateLimiter.create(qps));\n            }\n            log.debug(\"\u3010{}\u3011\u7684QPS\u8bbe\u7f6e\u4e3a: {}\", method.getName(), RATE_LIMITER_CACHE.get(method.getName()).getRate());\n            // \u5c1d\u8bd5\u83b7\u53d6\u4ee4\u724c\n            if (RATE_LIMITER_CACHE.get(method.getName()) != null && !RATE_LIMITER_CACHE.get(method.getName()).tryAcquire(rateLimiter.timeout(), rateLimiter.timeUnit())) {\n                throw new YWarmingException(\"\u624b\u901f\u592a\u5feb\u4e86\uff0c\u6162\u70b9\u513f\u5427~\");\n            }\n        }\n        return point.proceed();\n    }\n"]], "pred": {"ppl": 1.7125859260559082, "ppl_lower": 2.2364978790283203, "ppl/lowercase_ppl": -1.4961050453494857, "ppl/zlib": 0.0007763412203384567, "Min_5.0% Prob": 6.356849710146586, "Min_10.0% Prob": 4.265397193480511, "Min_20.0% Prob": 2.530582089813388, "Min_30.0% Prob": 1.771599997671283, "Min_40.0% Prob": 1.3401726507936336, "Min_50.0% Prob": 1.0771004719076662, "Min_60.0% Prob": 0.8988879455999329}}
{"hexsha": "0129bba8e6670e159e58ac1642fa9d85cc3c37d7", "ext": "java", "lang": "Java", "content": "public class CompositeCredentialsRepository<T extends Credentials> {\n  private Map<String, CredentialsRepository<? extends T>> allRepositories;\n\n  public CompositeCredentialsRepository(List<CredentialsRepository<? extends T>> repositories) {\n    allRepositories = new HashMap<>();\n    repositories.forEach(this::registerRepository);\n  }\n\n  public void registerRepository(CredentialsRepository<? extends T> repository) {\n    allRepositories.put(repository.getType(), repository);\n  }\n\n  public T getCredentials(String credentialsName, String type) {\n    CredentialsRepository<? extends T> repository = allRepositories.get(type);\n    if (repository == null) {\n      throw new UnknownCredentialsTypeException(\"No credentials of type '\" + type + \"' found\");\n    }\n\n    T creds = repository.getOne(credentialsName);\n    if (creds == null) {\n      throw new MissingCredentialsException(\n          \"Credentials '\" + credentialsName + \"' of type '\" + type + \"' cannot be found\");\n    }\n    return creds;\n  }\n\n  /**\n   * Helper method during migration from single to multiple credential repositories\n   *\n   * @param name\n   * @return Account with the given name across all repositories\n   */\n  @Nullable\n  public T getFirstCredentialsWithName(String name) {\n    return allRepositories.values().stream()\n        .map(r -> r.getOne(name))\n        .filter(Objects::nonNull)\n        .findFirst()\n        .orElse(null);\n  }\n\n  /** @return All credentials across all repositories */\n  public List<T> getAllCredentials() {\n    return Collections.unmodifiableList(\n        allRepositories.values().stream()\n            .map(CredentialsRepository::getAll)\n            .flatMap(Collection::stream)\n            .collect(Collectors.toList()));\n  }\n}", "item_id": 0, "repo": "Uva-Vj/kork", "file": "kork-credentials-api/src/main/java/com/netflix/spinnaker/credentials/CompositeCredentialsRepository.java", "last_update_at": "2022-02-04T23:06:37+00:00", "question_id": "0129bba8e6670e159e58ac1642fa9d85cc3c37d7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CompositeCredentialsRepository<T extends Credentials> {\n  private Map<String, CredentialsRepository<? extends T>> allRepositories;\n  public CompositeCredentialsRepository(List<CredentialsRepository<? extends T>> repositories) {\n    allRepositories = new HashMap<>();\n    repositories.forEach(this::registerRepository);\n  }\n  public void registerRepository(CredentialsRepository<? extends T> repository) {\n    allRepositories.put(repository.getType(), repository);\n  }\n  public T getCredentials(String credentialsName, String type) {\n    CredentialsRepository<? extends T> repository = allRepositories.get(type);\n    if (repository == null) {\n      throw new UnknownCredentialsTypeException(\"No credentials of type '\" + type + \"' found\");\n    }\n    T creds = repository.getOne(credentialsName);\n    if (creds == null) {\n      throw new MissingCredentialsException(\n          \"Credentials '\" + credentialsName + \"' of type '\" + type + \"' cannot be found\");\n    }\n    return creds;\n  }\n  /**\n   * Helper method during migration from single to multiple credential repositories\n   *\n   * @param name\n   * @return Account with the given name across all repositories\n   */\n  @Nullable\n  public T getFirstCredentialsWithName(String name) {\n    return allRepositories.values().stream()\n        .map(r -> r.getOne(name))\n        .filter(Objects::nonNull)\n        .findFirst()\n        .orElse(null);\n  }\n  /** @return All credentials across all repositories */\n  public List<T> getAllCredentials() {\n    return Collections.unmodifiableList(\n        allRepositories.values().stream()\n            .map(CredentialsRepository::getAll)\n            .flatMap(Collection::stream)\n            .collect(Collectors.toList()));\n  }\n"]], "pred": {"ppl": 1.795154333114624, "ppl_lower": 2.102790117263794, "ppl/lowercase_ppl": -1.2703410120501752, "ppl/zlib": 0.0009316735632090208, "Min_5.0% Prob": 6.008644526655024, "Min_10.0% Prob": 4.180504403331063, "Min_20.0% Prob": 2.6481664688749746, "Min_30.0% Prob": 1.8968469953220901, "Min_40.0% Prob": 1.4541284704411572, "Min_50.0% Prob": 1.1665494386949555, "Min_60.0% Prob": 0.9747872107187813}}
{"hexsha": "6a1ebeef7e33b35166dde776a778aec860d3c4ab", "ext": "java", "lang": "Java", "content": "@Component(\"BeaconOwnerMapperV2\")\npublic class BeaconOwnerMapper {\n\n  private final AddressMapper addressMapper;\n\n  @Autowired\n  public BeaconOwnerMapper(AddressMapper addressMapper) {\n    this.addressMapper = addressMapper;\n  }\n\n  public BeaconOwner fromDTO(CreateBeaconOwnerDTO dto) {\n    BeaconOwner beaconOwner = new BeaconOwner();\n\n    beaconOwner.setFullName(dto.getFullName());\n    beaconOwner.setEmail(dto.getEmail());\n    beaconOwner.setTelephoneNumber(dto.getTelephoneNumber());\n    beaconOwner.setAlternativeTelephoneNumber(\n      dto.getAlternativeTelephoneNumber()\n    );\n    beaconOwner.setAddress(addressMapper.fromDTO(dto.getAddressDTO()));\n\n    return beaconOwner;\n  }\n\n  public BeaconOwnerDTO toDTO(BeaconOwner beaconOwner) {\n    return BeaconOwnerDTO\n      .builder()\n      .id(Objects.requireNonNull(beaconOwner.getId()).unwrap())\n      .fullName(beaconOwner.getFullName())\n      .email(beaconOwner.getEmail())\n      .telephoneNumber(beaconOwner.getTelephoneNumber())\n      .alternativeTelephoneNumber(beaconOwner.getAlternativeTelephoneNumber())\n      .addressDTO(addressMapper.toDTO(beaconOwner.getAddress()))\n      .createdDate(beaconOwner.getCreatedDate())\n      .lastModifiedDate(beaconOwner.getLastModifiedDate())\n      .beaconId(beaconOwner.getBeaconId().unwrap())\n      .build();\n  }\n}", "item_id": 0, "repo": "mcagov/beacons", "file": "service/src/main/java/uk/gov/mca/beacons/api/beaconowner/mappers/BeaconOwnerMapper.java", "last_update_at": "2022-03-30T21:09:30+00:00", "question_id": "6a1ebeef7e33b35166dde776a778aec860d3c4ab_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component(\"BeaconOwnerMapperV2\")\npublic class BeaconOwnerMapper {\n  private final AddressMapper addressMapper;\n  @Autowired\n  public BeaconOwnerMapper(AddressMapper addressMapper) {\n    this.addressMapper = addressMapper;\n  }\n  public BeaconOwner fromDTO(CreateBeaconOwnerDTO dto) {\n    BeaconOwner beaconOwner = new BeaconOwner();\n    beaconOwner.setFullName(dto.getFullName());\n    beaconOwner.setEmail(dto.getEmail());\n    beaconOwner.setTelephoneNumber(dto.getTelephoneNumber());\n    beaconOwner.setAlternativeTelephoneNumber(\n      dto.getAlternativeTelephoneNumber()\n    );\n    beaconOwner.setAddress(addressMapper.fromDTO(dto.getAddressDTO()));\n    return beaconOwner;\n  }\n  public BeaconOwnerDTO toDTO(BeaconOwner beaconOwner) {\n    return BeaconOwnerDTO\n      .builder()\n      .id(Objects.requireNonNull(beaconOwner.getId()).unwrap())\n      .fullName(beaconOwner.getFullName())\n      .email(beaconOwner.getEmail())\n      .telephoneNumber(beaconOwner.getTelephoneNumber())\n      .alternativeTelephoneNumber(beaconOwner.getAlternativeTelephoneNumber())\n      .addressDTO(addressMapper.toDTO(beaconOwner.getAddress()))\n      .createdDate(beaconOwner.getCreatedDate())\n      .lastModifiedDate(beaconOwner.getLastModifiedDate())\n      .beaconId(beaconOwner.getBeaconId().unwrap())\n      .build();\n  }\n"]], "pred": {"ppl": 1.5035465955734253, "ppl_lower": 1.8426733016967773, "ppl/lowercase_ppl": -1.4987183944367761, "ppl/zlib": 0.0009898706659431258, "Min_5.0% Prob": 5.706030678749085, "Min_10.0% Prob": 3.6486042679809945, "Min_20.0% Prob": 2.0163726689944785, "Min_30.0% Prob": 1.356932528540492, "Min_40.0% Prob": 1.0190680976845548, "Min_50.0% Prob": 0.8152015042105806, "Min_60.0% Prob": 0.6817537341348361}}
{"hexsha": "a85695ef802e7948648ed14b95efaf52ed62e4b2", "ext": "java", "lang": "Java", "content": "class KeyFrequency<T extends Comparable<T>> implements Comparable<KeyFrequency<T>> {\n    private T key;\n    private int count;\n\n    public KeyFrequency(T key, int count) {\n        this.key = key;\n        this.count = count;\n    }\n\n    public T getKey() {\n        return key;\n    }\n\n    public int getCount() {\n        return count;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n\n        if (obj == null) {\n            return false;\n        }\n        if (obj == this) {\n            return true;\n        }\n        if (obj.getClass() != getClass()) {\n            return false;\n        }\n        @SuppressWarnings(\"unchecked\")\n        KeyFrequency<T> rhs = (KeyFrequency<T>) obj;\n\n        return new EqualsBuilder().append(count, rhs.key).isEquals();\n    }\n\n    // Needs to be implemented to determine order for the TreeSet\n    @Override\n    public int compareTo(KeyFrequency<T> other) {\n        // Ensures higher-counts (more frequent items) come first\n        // the order becomes:  MOST-FREQUENT to LESS-FREQUENT in the TreeSet\n        int compareTo = Integer.compare(other.count, this.count);\n        if (compareTo == 0) {\n            // If they are equal, we compare with the keys instead\n            return other.key.compareTo(this.key);\n        } else {\n            return compareTo;\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        return new HashCodeBuilder().append(count).append(key).toHashCode();\n    }\n}", "item_id": 0, "repo": "path-pattern-finder/path-pattern-finder", "file": "src/main/java/com/owenfeehan/pathpatternfinder/describer/frequencymap/KeyFrequency.java", "last_update_at": "2022-01-30T10:50:04+00:00", "question_id": "a85695ef802e7948648ed14b95efaf52ed62e4b2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class KeyFrequency<T extends Comparable<T>> implements Comparable<KeyFrequency<T>> {\n    private T key;\n    private int count;\n    public KeyFrequency(T key, int count) {\n        this.key = key;\n        this.count = count;\n    }\n    public T getKey() {\n        return key;\n    }\n    public int getCount() {\n        return count;\n    }\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (obj == this) {\n            return true;\n        }\n        if (obj.getClass() != getClass()) {\n            return false;\n        }\n        @SuppressWarnings(\"unchecked\")\n        KeyFrequency<T> rhs = (KeyFrequency<T>) obj;\n        return new EqualsBuilder().append(count, rhs.key).isEquals();\n    }\n    // Needs to be implemented to determine order for the TreeSet\n    @Override\n    public int compareTo(KeyFrequency<T> other) {\n        // Ensures higher-counts (more frequent items) come first\n        // the order becomes:  MOST-FREQUENT to LESS-FREQUENT in the TreeSet\n        int compareTo = Integer.compare(other.count, this.count);\n        if (compareTo == 0) {\n            // If they are equal, we compare with the keys instead\n            return other.key.compareTo(this.key);\n        } else {\n            return compareTo;\n        }\n    }\n    @Override\n    public int hashCode() {\n        return new HashCodeBuilder().append(count).append(key).toHashCode();\n    }\n"]], "pred": {"ppl": 1.9247039556503296, "ppl_lower": 2.2437245845794678, "ppl/lowercase_ppl": -1.2342266320358015, "ppl/zlib": 0.0011734268219362163, "Min_5.0% Prob": 6.521556297938029, "Min_10.0% Prob": 4.658088042622521, "Min_20.0% Prob": 2.9887361703884032, "Min_30.0% Prob": 2.136544712833942, "Min_40.0% Prob": 1.628456670746562, "Min_50.0% Prob": 1.3071428040042519, "Min_60.0% Prob": 1.0905580006591562}}
{"hexsha": "4bc54bf695113851842bace065137e2a083b3b86", "ext": "java", "lang": "Java", "content": "@Category({ Unit.class })\npublic class PluginManagerTest {\n\n    private static String previousConfig = null;\n\n    /**\n     * Preparation before executing this test class.\n     */\n    @BeforeClass\n    public static void prepare() {\n        previousConfig = PersoniumUnitConfig.getPluginDefaultLoadClassname();\n        PersoniumUnitConfig.set(PersoniumUnitConfig.PLUGIN_DEFAULT_LOAD_CLASSNAME,\n                AuthPluginLoaderForTesting.class.getName());\n    }\n\n    /**\n     * Clean up after executing this test class.\n     */\n    @AfterClass\n    public static void cleanup() {\n        if (previousConfig == null) {\n            PersoniumUnitConfig.getProperties().remove(PersoniumUnitConfig.PLUGIN_DEFAULT_LOAD_CLASSNAME);\n        } else {\n            PersoniumUnitConfig.set(PersoniumUnitConfig.PLUGIN_DEFAULT_LOAD_CLASSNAME, previousConfig);\n        }\n    }\n\n    /**\n     * Test that PluginManager can find correct plugin by grantType.\n     *\n     * @throws Exception .\n     */\n    @Test\n    public void PluginManger_can_find_AuthPlugin_by_grantType() throws Exception {\n        String testGrantType = AuthPluginLoaderForTesting.DEFAULT_GRANT_TYPES.iterator().next();\n        PluginManager pm = new PluginManager();\n        assertTrue(\"PluginManager failed to load plugins\", (pm.size() > 0));\n\n        PluginInfo pi = (PluginInfo) pm.getPluginsByGrantType(testGrantType);\n        assertNotNull(\"getPluginsByGrantType [\" + testGrantType + \"] returns null\", pi);\n    }\n\n    /**\n     * Test that PluginManager returns null if invalid grantType is presented.\n     *\n     * @throws Exception .\n     */\n    @Test\n    public void PluginManager_returns_null_if_invalid_grantType() throws Exception {\n        String invalidGrantType = \"urn:x-dc1:oidc:hoge:code\";\n\n        PluginManager pm = new PluginManager();\n        assertTrue(\"PluginManager failed to load plugins\", (pm.size() > 0));\n\n        PluginInfo pi = pm.getPluginsByGrantType(invalidGrantType);\n        assertNull(\"PluginManager returns not null\", pi);\n    }\n\n    /**\n     * PluginManager_can_returns_list_of_AuthPlugin.\n     *\n     * @throws Exception .\n     */\n    @Test\n    public void PluginManager_can_returns_list_of_AuthPlugin() throws Exception {\n        boolean bFind = true;\n\n        PluginManager pm = new PluginManager();\n        List<PluginInfo> pl = pm.getPluginsByType(AuthConst.PLUGIN_TYPE);\n\n        assertTrue(\"PluginManager returns 0 plugin.\", (pl.size() > 0));\n        for (int i = 0; i < pl.size(); i++) {\n            PluginInfo pi = (PluginInfo) pl.get(i);\n            if (!pi.getType().equals(AuthConst.PLUGIN_TYPE)) {\n                bFind = false;\n            }\n        }\n        assertTrue(bFind);\n    }\n\n}", "item_id": 0, "repo": "personium/personium-core", "file": "src/test/java/io/personium/core/plugin/PluginManagerTest.java", "last_update_at": "2022-01-28T13:42:30+00:00", "question_id": "4bc54bf695113851842bace065137e2a083b3b86_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Category({ Unit.class })\npublic class PluginManagerTest {\n    private static String previousConfig = null;\n    /**\n     * Preparation before executing this test class.\n     */\n    @BeforeClass\n    public static void prepare() {\n        previousConfig = PersoniumUnitConfig.getPluginDefaultLoadClassname();\n        PersoniumUnitConfig.set(PersoniumUnitConfig.PLUGIN_DEFAULT_LOAD_CLASSNAME,\n                AuthPluginLoaderForTesting.class.getName());\n    }\n    /**\n     * Clean up after executing this test class.\n     */\n    @AfterClass\n    public static void cleanup() {\n        if (previousConfig == null) {\n            PersoniumUnitConfig.getProperties().remove(PersoniumUnitConfig.PLUGIN_DEFAULT_LOAD_CLASSNAME);\n        } else {\n            PersoniumUnitConfig.set(PersoniumUnitConfig.PLUGIN_DEFAULT_LOAD_CLASSNAME, previousConfig);\n        }\n    }\n    /**\n     * Test that PluginManager can find correct plugin by grantType.\n     *\n     * @throws Exception .\n     */\n    @Test\n    public void PluginManger_can_find_AuthPlugin_by_grantType() throws Exception {\n        String testGrantType = AuthPluginLoaderForTesting.DEFAULT_GRANT_TYPES.iterator().next();\n        PluginManager pm = new PluginManager();\n        assertTrue(\"PluginManager failed to load plugins\", (pm.size() > 0));\n        PluginInfo pi = (PluginInfo) pm.getPluginsByGrantType(testGrantType);\n        assertNotNull(\"getPluginsByGrantType [\" + testGrantType + \"] returns null\", pi);\n    }\n    /**\n     * Test that PluginManager returns null if invalid grantType is presented.\n     *\n     * @throws Exception .\n     */\n    @Test\n    public void PluginManager_returns_null_if_invalid_grantType() throws Exception {\n        String invalidGrantType = \"urn:x-dc1:oidc:hoge:code\";\n        PluginManager pm = new PluginManager();\n        assertTrue(\"PluginManager failed to load plugins\", (pm.size() > 0));\n        PluginInfo pi = pm.getPluginsByGrantType(invalidGrantType);\n        assertNull(\"PluginManager returns not null\", pi);\n    }\n    /**\n     * PluginManager_can_returns_list_of_AuthPlugin.\n     *\n     * @throws Exception .\n     */\n    @Test\n    public void PluginManager_can_returns_list_of_AuthPlugin() throws Exception {\n        boolean bFind = true;\n        PluginManager pm = new PluginManager();\n        List<PluginInfo> pl = pm.getPluginsByType(AuthConst.PLUGIN_TYPE);\n        assertTrue(\"PluginManager returns 0 plugin.\", (pl.size() > 0));\n        for (int i = 0; i < pl.size(); i++) {\n            PluginInfo pi = (PluginInfo) pl.get(i);\n            if (!pi.getType().equals(AuthConst.PLUGIN_TYPE)) {\n                bFind = false;\n            }\n        }\n        assertTrue(bFind);\n    }\n"]], "pred": {"ppl": 1.9663623571395874, "ppl_lower": 2.3993093967437744, "ppl/lowercase_ppl": -1.2942915545286153, "ppl/zlib": 0.000830694492153857, "Min_5.0% Prob": 6.373169409923064, "Min_10.0% Prob": 4.88227467964857, "Min_20.0% Prob": 3.1962556544786844, "Min_30.0% Prob": 2.2219495498119515, "Min_40.0% Prob": 1.6865006265834497, "Min_50.0% Prob": 1.3504876857670975, "Min_60.0% Prob": 1.1274121165577757}}
{"hexsha": "dc5a24894ccbf1611f745866f805653d9f7ec629", "ext": "java", "lang": "Java", "content": "public class AppAboutActivity extends BaseActivityWrapper {\n    @BindView(R.id.app_content_tv)\n    TextView appContentTv;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        initService(false);\n        super.onCreate(savedInstanceState);\n        showBottomView(false);\n        setContentView(R.layout.activity_app_about);\n        ButterKnife.bind(this);\n        appContentTv.setMovementMethod(LinkMovementMethod.getInstance());\n        StringUtil.removeUnderlines((Spannable)appContentTv.getText());\n\n    }\n\n    @OnClick(R.id.m_return_img)\n    public void onViewClicked() {\n        finish();\n    }\n}", "item_id": 0, "repo": "Go-oG/TextureMusic", "file": "app/src/main/java/wzp/com/texturemusic/localmodule/ui/activity/AppAboutActivity.java", "last_update_at": "2022-01-18T07:02:09+00:00", "question_id": "dc5a24894ccbf1611f745866f805653d9f7ec629_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AppAboutActivity extends BaseActivityWrapper {\n    @BindView(R.id.app_content_tv)\n    TextView appContentTv;\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        initService(false);\n        super.onCreate(savedInstanceState);\n        showBottomView(false);\n        setContentView(R.layout.activity_app_about);\n        ButterKnife.bind(this);\n        appContentTv.setMovementMethod(LinkMovementMethod.getInstance());\n        StringUtil.removeUnderlines((Spannable)appContentTv.getText());\n    }\n    @OnClick(R.id.m_return_img)\n    public void onViewClicked() {\n        finish();\n    }\n"]], "pred": {"ppl": 2.4502220153808594, "ppl_lower": 3.623375654220581, "ppl/lowercase_ppl": -1.4365507461421143, "ppl/zlib": 0.002597619243402392, "Min_5.0% Prob": 8.065375222100151, "Min_10.0% Prob": 6.187810672654046, "Min_20.0% Prob": 3.965431594186359, "Min_30.0% Prob": 2.8929298647024013, "Min_40.0% Prob": 2.218384793972316, "Min_50.0% Prob": 1.7983344031477368, "Min_60.0% Prob": 1.5037370545815232}}
{"hexsha": "6c6c9df46325cc266a0f0f402a2e97f98e4bc02e", "ext": "java", "lang": "Java", "content": "public abstract class RefPtgBase extends OperandPtg {\n\n\t/**\n\t * YK: subclasses of RefPtgBase are used by the FormulaParser and FormulaEvaluator accross HSSF and XSSF.\n\t * The bit mask should accommodate the maximum number of avaiable columns, i.e. 0x3FFF.\n\t *\n\t * @see org.apache.poi.ss.SpreadsheetVersion\n\t */\n\tprivate static final BitField column = BitFieldFactory.getInstance(0x3FFF);\n\n\tprivate static final BitField rowRelative = BitFieldFactory.getInstance(0x8000);\n\tprivate static final BitField colRelative = BitFieldFactory.getInstance(0x4000);\n\n\n\t/** The row index - zero based unsigned 16 bit value */\n\tprivate int field_1_row;\n\t/**\n\t * Field 2 - lower 8 bits is the zero based unsigned byte column index - bit\n\t * 16 - isRowRelative - bit 15 - isColumnRelative\n\t */\n\tprivate int field_2_col;\n\n\tprotected RefPtgBase() {}\n\n\tprotected RefPtgBase(RefPtgBase other) {\n\t\tsuper(other);\n\t\tfield_1_row = other.field_1_row;\n\t\tfield_2_col = other.field_2_col;\n\t}\n\n\tprotected RefPtgBase(CellReference c) {\n\t\tsetRow(c.getRow());\n\t\tsetColumn(c.getCol());\n\t\tsetColRelative(!c.isColAbsolute());\n\t\tsetRowRelative(!c.isRowAbsolute());\n\t}\n\n\tprotected final void readCoordinates(LittleEndianInput in) {\n\t\tfield_1_row = in.readUShort();\n\t\tfield_2_col = in.readUShort();\n\t}\n\n\tprotected final void writeCoordinates(LittleEndianOutput out) {\n\t\tout.writeShort(field_1_row);\n\t\tout.writeShort(field_2_col);\n\t}\n\n\tpublic final void setRow(int rowIndex) {\n\t\tfield_1_row = rowIndex;\n\t}\n\n\t/**\n\t * @return the row number as an int\n\t */\n\tpublic final int getRow() {\n\t\treturn field_1_row;\n\t}\n\n\tpublic final boolean isRowRelative() {\n\t\treturn rowRelative.isSet(field_2_col);\n\t}\n\n\tpublic final void setRowRelative(boolean rel) {\n\t\tfield_2_col = rowRelative.setBoolean(field_2_col, rel);\n\t}\n\n\tpublic final boolean isColRelative() {\n\t\treturn colRelative.isSet(field_2_col);\n\t}\n\n\tpublic final void setColRelative(boolean rel) {\n\t\tfield_2_col = colRelative.setBoolean(field_2_col, rel);\n\t}\n\n\tpublic final void setColumn(int col) {\n\t\tfield_2_col = column.setValue(field_2_col, col);\n\t}\n\n\tpublic final int getColumn() {\n\t\treturn column.getValue(field_2_col);\n\t}\n\n\tprotected String formatReferenceAsString() {\n\t\t// Only make cell references as needed. Memory is an issue\n\t\tCellReference cr = new CellReference(getRow(), getColumn(), !isRowRelative(), !isColRelative());\n\t\treturn cr.formatAsString();\n\t}\n\n\t@Override\n    public final byte getDefaultOperandClass() {\n\t\treturn Ptg.CLASS_REF;\n\t}\n\n\t@Override\n\tpublic Map<String, Supplier<?>> getGenericProperties() {\n\t\treturn GenericRecordUtil.getGenericProperties(\n\t\t\t\"row\", this::getRow,\n\t\t\t\"rowRelative\", this::isRowRelative,\n\t\t\t\"column\", this::getColumn,\n\t\t\t\"colRelative\", this::isColRelative,\n\t\t\t\"formatReference\", this::formatReferenceAsString\n\t\t);\n\t}\n}", "item_id": 0, "repo": "FiddlersCode/poi", "file": "src/java/org/apache/poi/ss/formula/ptg/RefPtgBase.java", "last_update_at": "2022-03-31T12:02:04+00:00", "question_id": "6c6c9df46325cc266a0f0f402a2e97f98e4bc02e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class RefPtgBase extends OperandPtg {\n\t/**\n\t * YK: subclasses of RefPtgBase are used by the FormulaParser and FormulaEvaluator accross HSSF and XSSF.\n\t * The bit mask should accommodate the maximum number of avaiable columns, i.e. 0x3FFF.\n\t *\n\t * @see org.apache.poi.ss.SpreadsheetVersion\n\t */\n\tprivate static final BitField column = BitFieldFactory.getInstance(0x3FFF);\n\tprivate static final BitField rowRelative = BitFieldFactory.getInstance(0x8000);\n\tprivate static final BitField colRelative = BitFieldFactory.getInstance(0x4000);\n\t/** The row index - zero based unsigned 16 bit value */\n\tprivate int field_1_row;\n\t/**\n\t * Field 2 - lower 8 bits is the zero based unsigned byte column index - bit\n\t * 16 - isRowRelative - bit 15 - isColumnRelative\n\t */\n\tprivate int field_2_col;\n\tprotected RefPtgBase() {}\n\tprotected RefPtgBase(RefPtgBase other) {\n\t\tsuper(other);\n\t\tfield_1_row = other.field_1_row;\n\t\tfield_2_col = other.field_2_col;\n\t}\n\tprotected RefPtgBase(CellReference c) {\n\t\tsetRow(c.getRow());\n\t\tsetColumn(c.getCol());\n\t\tsetColRelative(!c.isColAbsolute());\n\t\tsetRowRelative(!c.isRowAbsolute());\n\t}\n\tprotected final void readCoordinates(LittleEndianInput in) {\n\t\tfield_1_row = in.readUShort();\n\t\tfield_2_col = in.readUShort();\n\t}\n\tprotected final void writeCoordinates(LittleEndianOutput out) {\n\t\tout.writeShort(field_1_row);\n\t\tout.writeShort(field_2_col);\n\t}\n\tpublic final void setRow(int rowIndex) {\n\t\tfield_1_row = rowIndex;\n\t}\n\t/**\n\t * @return the row number as an int\n\t */\n\tpublic final int getRow() {\n\t\treturn field_1_row;\n\t}\n\tpublic final boolean isRowRelative() {\n\t\treturn rowRelative.isSet(field_2_col);\n\t}\n\tpublic final void setRowRelative(boolean rel) {\n\t\tfield_2_col = rowRelative.setBoolean(field_2_col, rel);\n\t}\n\tpublic final boolean isColRelative() {\n\t\treturn colRelative.isSet(field_2_col);\n\t}\n\tpublic final void setColRelative(boolean rel) {\n\t\tfield_2_col = colRelative.setBoolean(field_2_col, rel);\n\t}\n\tpublic final void setColumn(int col) {\n\t\tfield_2_col = column.setValue(field_2_col, col);\n\t}\n\tpublic final int getColumn() {\n\t\treturn column.getValue(field_2_col);\n\t}\n\tprotected String formatReferenceAsString() {\n\t\t// Only make cell references as needed. Memory is an issue\n\t\tCellReference cr = new CellReference(getRow(), getColumn(), !isRowRelative(), !isColRelative());\n\t\treturn cr.formatAsString();\n\t}\n\t@Override\n    public final byte getDefaultOperandClass() {\n\t\treturn Ptg.CLASS_REF;\n\t}\n\t@Override\n\tpublic Map<String, Supplier<?>> getGenericProperties() {\n\t\treturn GenericRecordUtil.getGenericProperties(\n\t\t\t\"row\", this::getRow,\n\t\t\t\"rowRelative\", this::isRowRelative,\n\t\t\t\"column\", this::getColumn,\n\t\t\t\"colRelative\", this::isColRelative,\n\t\t\t\"formatReference\", this::formatReferenceAsString\n\t\t);\n\t}\n"]], "pred": {"ppl": 1.668941617012024, "ppl_lower": 2.0405771732330322, "ppl/lowercase_ppl": -1.3925167707831942, "ppl/zlib": 0.000519989505835753, "Min_5.0% Prob": 5.819806658491796, "Min_10.0% Prob": 4.079290452052136, "Min_20.0% Prob": 2.4572975091180025, "Min_30.0% Prob": 1.6901530676147565, "Min_40.0% Prob": 1.277506096982302, "Min_50.0% Prob": 1.024412055642401, "Min_60.0% Prob": 0.8542401485697867}}
{"hexsha": "330058bcf9f3666d677a4d46192e73844525de95", "ext": "java", "lang": "Java", "content": "@ExtendWith(VertxExtension.class)\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\npublic class GetAuctionsIntegrationTest extends AbstractIntegrationTest {\n\n    private PostgreSQLContainer postgres;\n    private AuctionsRepository auctionsRepository;\n    private BidsRepository bidsRepository;\n    Vertx vertx;\n\n    @BeforeAll\n    public void beforeAll(VertxTestContext testContext) throws Throwable {\n        this.postgres = new PostgreSQLContainer(\"postgres:12.6\");\n        this.vertx = Vertx.vertx();\n\n        deployServerAndClient(postgres, this.vertx, testContext, new ApiVerticle());\n\n        SqlConnectionManager connectionManager = new SqlConnectionManager(this.postgres.getJdbcUrl(), this.postgres.getUsername(), this.postgres.getPassword());\n        this.auctionsRepository = new AuctionsRepository(connectionManager);\n        this.bidsRepository = new BidsRepository(connectionManager);\n    }\n    @AfterAll\n    public void afterAll(VertxTestContext testContext) {\n        this.vertx.close(testContext.completing());\n        this.postgres.close();\n    }\n\n    @Test\n    public void getAuctionsTest(VertxTestContext testContext) throws SQLException {\n        @Var Auction auction = testAuctionObject(1);\n        Auction newAuction1 = auctionsRepository.createComplete(auction);\n        auction = testAuctionObject(2);\n        Auction newAuction2 = auctionsRepository.createComplete(auction);\n\n        webClient.get(9005, \"localhost\", \"/v1/auctions/\")\n                .as(BodyCodec.buffer())\n                .send(testContext.succeeding(response -> testContext.verify(() -> {\n                    assertNotNull(response);\n                    JsonArray body = new JsonArray(response.body());\n                    assertNotNull(body);\n                    assertEquals(2, body.size());\n                    verifyAuction(newAuction1, body.getJsonObject(0));\n                    verifyAuction(newAuction2, body.getJsonObject(1));\n\n                    auctionsRepository.deleteAllAuctions();\n                    testContext.completeNow();\n                })));\n    }\n\n    @Test\n    public void getPendingAuctionsTest(VertxTestContext testContext) throws SQLException {\n        getAuction(testContext,  \"/v1/pendingauctions/\", Auction.PENDING, 2);\n    }\n\n    @Test\n    public void getActiveAuctionsTest(VertxTestContext testContext) throws SQLException {\n        getAuction(testContext,  \"/v1/activeauctions/\", Auction.ACTIVE, 1);\n    }\n\n    @Test\n    public void getClosedAuctionsTest(VertxTestContext testContext) throws SQLException {\n        getAuction(testContext,  \"/v1/closedauctions/\", Auction.CLOSED, 1);\n    }\n\n    @Test\n    public void getEndedAuctionsTest(VertxTestContext testContext) throws SQLException {\n        getAuction(testContext,  \"/v1/endedauctions/\", Auction.ENDED, 1);\n    }\n\n    @Test\n    public void getAuctionReserveNotMet(VertxTestContext testContext) throws SQLException {\n        // reserve not met auction\n        @Var Auction auction = testAuctionObject(1);\n        auction.setWinningbid(0L);\n        auction.setReserve(5L);\n        auction = auctionsRepository.createComplete(auction);\n\n        Bid bid = testBidObject(1, auction.getId());\n        bid.setStatus(\"Bid below reserve\");\n        bidsRepository.add(bid);\n\n        // reserve met auction\n        Auction newAuction = testAuctionObject(2);\n        newAuction.setWinningbid(2L);\n        newAuction.setReserve(0L);\n        auctionsRepository.createComplete(newAuction);\n\n        Auction finalAuction = auction;\n        webClient.get(9005, \"localhost\", \"/v1/reservenotmetauctions\")\n                .as(BodyCodec.buffer())\n                .send(testContext.succeeding(response -> testContext.verify(() -> {\n                    assertNotNull(response);\n                    JsonArray body = new JsonArray(response.body());\n                    assertNotNull(body);\n                    assertEquals(1, body.size());\n                    verifyAuction(finalAuction, body.getJsonObject(0));\n\n                    bidsRepository.deleteAllBids();\n                    auctionsRepository.deleteAllAuctions();\n                    testContext.completeNow();\n                })));\n    }\n\n  @Test\n  public void getAuctionSold(VertxTestContext testContext) throws SQLException {\n    // reserve met auction\n    Auction auction = testAuctionObject(1);\n    auction.setStatus(Auction.ENDED);\n    auction.setWinningbid(6L);\n    auction.setReserve(5L);\n    auctionsRepository.createComplete(auction);\n    // ended not sold\n    Auction newAuction = testAuctionObject(2);\n    newAuction.setWinningbid(0L);\n    newAuction.setReserve(0L);\n    newAuction.setStatus(Auction.ENDED);\n    auctionsRepository.createComplete(newAuction);\n    // ended below reserve\n    Auction newAuction2 = testAuctionObject(3);\n    newAuction2.setWinningbid(1L);\n    newAuction2.setReserve(5L);\n    newAuction2.setStatus(Auction.ENDED);\n    auctionsRepository.createComplete(newAuction2);\n\n    webClient.get(9005, \"localhost\", \"/v1/soldauctions\")\n            .as(BodyCodec.buffer())\n            .send(testContext.succeeding(response -> testContext.verify(() -> {\n              assertNotNull(response);\n              JsonArray body = new JsonArray(response.body());\n              assertNotNull(body);\n              assertEquals(1, body.size());\n              verifyAuction(auction, body.getJsonObject(0));\n\n              auctionsRepository.deleteAllAuctions();\n              testContext.completeNow();\n            })));\n  }\n\n  public void getAuction(VertxTestContext testContext, String url, String status, int expectedCount) throws SQLException {\n        Auction auction = testAuctionObject(1);\n        auctionsRepository.createComplete(auction);\n        @Var Auction newAuction = testAuctionObject(2);\n        newAuction.setStatus(status);\n        newAuction = auctionsRepository.createComplete(newAuction);\n\n        Auction finalNewAuction = newAuction;\n        webClient.get(9005, \"localhost\", url)\n                .as(BodyCodec.buffer())\n                .send(testContext.succeeding(response -> testContext.verify(() -> {\n                    assertNotNull(response);\n                    JsonArray body = new JsonArray(response.body());\n                    assertNotNull(body);\n                    assertEquals(expectedCount, body.size());\n                    verifyAuction(finalNewAuction, body.getJsonObject(expectedCount - 1));\n\n                    auctionsRepository.deleteAllAuctions();\n                    testContext.completeNow();\n                })));\n    }\n}", "item_id": 0, "repo": "topshef/hedera-nft-auction-demo", "file": "hedera-nft-auction-demo-java-node/src/testIntegration/java/com/hedera/demo/auction/test/integration/restapi/GetAuctionsIntegrationTest.java", "last_update_at": "2022-02-27T04:30:46+00:00", "question_id": "330058bcf9f3666d677a4d46192e73844525de95_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ExtendWith(VertxExtension.class)\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\npublic class GetAuctionsIntegrationTest extends AbstractIntegrationTest {\n    private PostgreSQLContainer postgres;\n    private AuctionsRepository auctionsRepository;\n    private BidsRepository bidsRepository;\n    Vertx vertx;\n    @BeforeAll\n    public void beforeAll(VertxTestContext testContext) throws Throwable {\n        this.postgres = new PostgreSQLContainer(\"postgres:12.6\");\n        this.vertx = Vertx.vertx();\n        deployServerAndClient(postgres, this.vertx, testContext, new ApiVerticle());\n        SqlConnectionManager connectionManager = new SqlConnectionManager(this.postgres.getJdbcUrl(), this.postgres.getUsername(), this.postgres.getPassword());\n        this.auctionsRepository = new AuctionsRepository(connectionManager);\n        this.bidsRepository = new BidsRepository(connectionManager);\n    }\n    @AfterAll\n    public void afterAll(VertxTestContext testContext) {\n        this.vertx.close(testContext.completing());\n        this.postgres.close();\n    }\n    @Test\n    public void getAuctionsTest(VertxTestContext testContext) throws SQLException {\n        @Var Auction auction = testAuctionObject(1);\n        Auction newAuction1 = auctionsRepository.createComplete(auction);\n        auction = testAuctionObject(2);\n        Auction newAuction2 = auctionsRepository.createComplete(auction);\n        webClient.get(9005, \"localhost\", \"/v1/auctions/\")\n                .as(BodyCodec.buffer())\n                .send(testContext.succeeding(response -> testContext.verify(() -> {\n                    assertNotNull(response);\n                    JsonArray body = new JsonArray(response.body());\n                    assertNotNull(body);\n                    assertEquals(2, body.size());\n                    verifyAuction(newAuction1, body.getJsonObject(0));\n                    verifyAuction(newAuction2, body.getJsonObject(1));\n                    auctionsRepository.deleteAllAuctions();\n                    testContext.completeNow();\n                })));\n    }\n    @Test\n    public void getPendingAuctionsTest(VertxTestContext testContext) throws SQLException {\n        getAuction(testContext,  \"/v1/pendingauctions/\", Auction.PENDING, 2);\n    }\n    @Test\n    public void getActiveAuctionsTest(VertxTestContext testContext) throws SQLException {\n        getAuction(testContext,  \"/v1/activeauctions/\", Auction.ACTIVE, 1);\n    }\n    @Test\n    public void getClosedAuctionsTest(VertxTestContext testContext) throws SQLException {\n        getAuction(testContext,  \"/v1/closedauctions/\", Auction.CLOSED, 1);\n    }\n    @Test\n    public void getEndedAuctionsTest(VertxTestContext testContext) throws SQLException {\n        getAuction(testContext,  \"/v1/endedauctions/\", Auction.ENDED, 1);\n    }\n    @Test\n    public void getAuctionReserveNotMet(VertxTestContext testContext) throws SQLException {\n        // reserve not met auction\n        @Var Auction auction = testAuctionObject(1);\n        auction.setWinningbid(0L);\n        auction.setReserve(5L);\n        auction = auctionsRepository.createComplete(auction);\n        Bid bid = testBidObject(1, auction.getId());\n        bid.setStatus(\"Bid below reserve\");\n        bidsRepository.add(bid);\n        // reserve met auction\n        Auction newAuction = testAuctionObject(2);\n        newAuction.setWinningbid(2L);\n        newAuction.setReserve(0L);\n        auctionsRepository.createComplete(newAuction);\n        Auction finalAuction = auction;\n        webClient.get(9005, \"localhost\", \"/v1/reservenotmetauctions\")\n                .as(BodyCodec.buffer())\n                .send(testContext.succeeding(response -> testContext.verify(() -> {\n                    assertNotNull(response);\n                    JsonArray body = new JsonArray(response.body());\n                    assertNotNull(body);\n                    assertEquals(1, body.size());\n                    verifyAuction(finalAuction, body.getJsonObject(0));\n                    bidsRepository.deleteAllBids();\n                    auctionsRepository.deleteAllAuctions();\n                    testContext.completeNow();\n                })));\n    }\n  @Test\n  public void getAuctionSold(VertxTestContext testContext) throws SQLException {\n    // reserve met auction\n    Auction auction = testAuctionObject(1);\n    auction.setStatus(Auction.ENDED);\n    auction.setWinningbid(6L);\n    auction.setReserve(5L);\n    auctionsRepository.createComplete(auction);\n    // ended not sold\n    Auction newAuction = testAuctionObject(2);\n    newAuction.setWinningbid(0L);\n    newAuction.setReserve(0L);\n    newAuction.setStatus(Auction.ENDED);\n    auctionsRepository.createComplete(newAuction);\n    // ended below reserve\n    Auction newAuction2 = testAuctionObject(3);\n    newAuction2.setWinningbid(1L);\n    newAuction2.setReserve(5L);\n    newAuction2.setStatus(Auction.ENDED);\n    auctionsRepository.createComplete(newAuction2);\n    webClient.get(9005, \"localhost\", \"/v1/soldauctions\")\n            .as(BodyCodec.buffer())\n            .send(testContext.succeeding(response -> testContext.verify(() -> {\n              assertNotNull(response);\n              JsonArray body = new JsonArray(response.body());\n              assertNotNull(body);\n              assertEquals(1, body.size());\n              verifyAuction(auction, body.getJsonObject(0));\n              auctionsRepository.deleteAllAuctions();\n              testContext.completeNow();\n            })));\n  }\n  public void getAuction(VertxTestContext testContext, String url, String status, int expectedCount) throws SQLException {\n        Auction auction = testAuctionObject(1);\n        auctionsRepository.createComplete(auction);\n        @Var Auction newAuction = testAuctionObject(2);\n        newAuction.setStatus(status);\n        newAuction = auctionsRepository.createComplete(newAuction);\n        Auction finalNewAuction = newAuction;\n        webClient.get(9005, \"localhost\", url)\n                .as(BodyCodec.buffer())\n                .send(testContext.succeeding(response -> testContext.verify(() -> {\n                    assertNotNull(response);\n                    JsonArray body = new JsonArray(response.body());\n                    assertNotNull(body);\n                    assertEquals(expectedCount, body.size());\n                    verifyAuction(finalNewAuction, body.getJsonObject(expectedCount - 1));\n                    auctionsRepository.deleteAllAuctions();\n                    testContext.completeNow();\n                })));\n    }\n"]], "pred": {"ppl": 1.6868847608566284, "ppl_lower": 2.0993542671203613, "ppl/lowercase_ppl": -1.4183461864458151, "ppl/zlib": 0.00042754169348145605, "Min_5.0% Prob": 5.819473715389476, "Min_10.0% Prob": 4.05748827901541, "Min_20.0% Prob": 2.4776117090208856, "Min_30.0% Prob": 1.7239876249013772, "Min_40.0% Prob": 1.3017504597424294, "Min_50.0% Prob": 1.0454106712239974, "Min_60.0% Prob": 0.8722476690679448}}
{"hexsha": "75b6031078551de6ded6f770baf25ff4cf923d05", "ext": "java", "lang": "Java", "content": "public class ImCommit extends Function {\n\t\n\tpublic Node optimize(Context ctx) {\n\t\treturn this;\n\t}\n\n\tpublic Object calculate(Context ctx) {\n\t\tif (param == null) {\n\t\t\tMessageManager mm = EngineMessage.get();\n\t\t\tthrow new RQException(ImConnection.m_prjName + mm.getMessage(\"function.missingParam\"));\n\t\t}\n\t\toption = this.getOption();\n\t\t\n\t\tObject client = param.getLeafExpression().calculate(ctx);\n\t\tif ((client instanceof ImConnection)) {\n\t\t\tImConnection cli = (ImConnection)client;\n\t\t\tif (option!=null && option.indexOf(\"a\")>-1){\n\t\t\t\tcli.m_consumer.commitAsync();\n\t\t\t}else{\n\t\t\t\tcli.m_consumer.commitSync();\n\t\t\t}\n\t\t}else{\n\t\t\tMessageManager mm = EngineMessage.get();\n\t\t\tthrow new RQException(ImConnection.m_prjName + mm.getMessage(\"function.paramTypeError\"));\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n}", "item_id": 0, "repo": "liwe1980/esProc", "file": "importlibs/kafkacli/src/com/scudata/lib/kafka/function/ImCommit.java", "last_update_at": "2022-03-31T07:40:51+00:00", "question_id": "75b6031078551de6ded6f770baf25ff4cf923d05_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ImCommit extends Function {\n\t\n\tpublic Node optimize(Context ctx) {\n\t\treturn this;\n\t}\n\tpublic Object calculate(Context ctx) {\n\t\tif (param == null) {\n\t\t\tMessageManager mm = EngineMessage.get();\n\t\t\tthrow new RQException(ImConnection.m_prjName + mm.getMessage(\"function.missingParam\"));\n\t\t}\n\t\toption = this.getOption();\n\t\t\n\t\tObject client = param.getLeafExpression().calculate(ctx);\n\t\tif ((client instanceof ImConnection)) {\n\t\t\tImConnection cli = (ImConnection)client;\n\t\t\tif (option!=null && option.indexOf(\"a\")>-1){\n\t\t\t\tcli.m_consumer.commitAsync();\n\t\t\t}else{\n\t\t\t\tcli.m_consumer.commitSync();\n\t\t\t}\n\t\t}else{\n\t\t\tMessageManager mm = EngineMessage.get();\n\t\t\tthrow new RQException(ImConnection.m_prjName + mm.getMessage(\"function.paramTypeError\"));\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n"]], "pred": {"ppl": 2.670987844467163, "ppl_lower": 3.4914615154266357, "ppl/lowercase_ppl": -1.272657619757184, "ppl/zlib": 0.0026916394059942877, "Min_5.0% Prob": 9.545504129849947, "Min_10.0% Prob": 7.071410267441361, "Min_20.0% Prob": 4.451236508109353, "Min_30.0% Prob": 3.184600758983428, "Min_40.0% Prob": 2.443294397882513, "Min_50.0% Prob": 1.9646425677878823, "Min_60.0% Prob": 1.639187061049401}}
{"hexsha": "8a0f34e82e7baee7789025dc81122cef0b294a40", "ext": "java", "lang": "Java", "content": "public class ProjectContextMenuTest extends BaseProjectTest {\n  @Rule public TestProjectCreator projectCreator = new TestProjectCreator();\n  @Rule public TemporaryFolder tempFolder = new TemporaryFolder();\n  @Rule public ThreadDumpingWatchdog timer = new ThreadDumpingWatchdog(2, TimeUnit.MINUTES);\n\n  @Test\n  public void testPlainJavaProject() {\n    IProject project = projectCreator.withFacets(JavaFacet.VERSION_1_8).getProject();\n    SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());\n    assertThat(\n        selected.contextMenu(\"Debug As\"), not(MenuMatcher.hasMenuItem(endsWith(\"App Engine\"))));\n    assertThat(\n        selected.contextMenu(\"Run As\"), not(MenuMatcher.hasMenuItem(endsWith(\"App Engine\"))));\n    assertThat(\n        selected.contextMenu(), not(MenuMatcher.hasMenuItem(\"Deploy to App Engine Standard...\")));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        MenuMatcher.hasMenuItem(\"Convert to App Engine Standard Project\"));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        not(MenuMatcher.hasMenuItem(\"Reconfigure for App Engine Java 8 runtime\")));\n  }\n\n  @Test\n  public void testDynamicWebProjectJava7() {\n    IProject project =\n        projectCreator.withFacets(JavaFacet.VERSION_1_7, WebFacetUtils.WEB_25).getProject();\n    SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());\n    assertThat(\n        selected.contextMenu(\"Debug As\"), not(MenuMatcher.hasMenuItem(endsWith(\"App Engine\"))));\n    assertThat(\n        selected.contextMenu(\"Run As\"), not(MenuMatcher.hasMenuItem(endsWith(\"App Engine\"))));\n    assertThat(\n        selected.contextMenu(), not(MenuMatcher.hasMenuItem(\"Deploy to App Engine Standard...\")));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        MenuMatcher.hasMenuItem(\"Convert to App Engine Standard Project\"));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        not(MenuMatcher.hasMenuItem(\"Reconfigure for App Engine Java 8 runtime\")));\n  }\n\n  @Test\n  public void testDynamicWebProjectJava8() {\n    IProject project =\n        projectCreator.withFacets(JavaFacet.VERSION_1_8, WebFacetUtils.WEB_31).getProject();\n    SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());\n    assertThat(\n        selected.contextMenu(\"Debug As\"), not(MenuMatcher.hasMenuItem(endsWith(\"App Engine\"))));\n    assertThat(\n        selected.contextMenu(\"Run As\"), not(MenuMatcher.hasMenuItem(endsWith(\"App Engine\"))));\n    assertThat(\n        selected.contextMenu(), not(MenuMatcher.hasMenuItem(\"Deploy to App Engine Standard...\")));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        MenuMatcher.hasMenuItem(\"Convert to App Engine Standard Project\"));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        not(MenuMatcher.hasMenuItem(\"Reconfigure for App Engine Java 8 runtime\")));\n  }\n\n  @Test\n  public void testAppEngineStandardJava7() {\n    IProject project =\n        projectCreator\n            .withFacets(AppEngineStandardFacet.JRE7, JavaFacet.VERSION_1_7, WebFacetUtils.WEB_25)\n            .getProject();\n    SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());\n    assertThat(selected.contextMenu(\"Debug As\"), MenuMatcher.hasMenuItem(endsWith(\"App Engine\")));\n    assertThat(selected.contextMenu(\"Run As\"), MenuMatcher.hasMenuItem(endsWith(\"App Engine\")));\n    assertThat(selected.contextMenu(), MenuMatcher.hasMenuItem(\"Deploy to App Engine Standard...\"));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        not(MenuMatcher.hasMenuItem(\"Convert to App Engine Standard Project\")));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        MenuMatcher.hasMenuItem(\"Reconfigure for App Engine Java 8 runtime\"));\n  }\n\n  @Test\n  public void testAppEngineStandardJava8() {\n    IProject project =\n        projectCreator\n            .withFacets(\n                AppEngineStandardFacet.FACET.getVersion(\"JRE8\"),\n                JavaFacet.VERSION_1_8,\n                WebFacetUtils.WEB_31)\n            .getProject();\n    SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());\n    assertThat(selected.contextMenu(\"Debug As\"), MenuMatcher.hasMenuItem(endsWith(\"App Engine\")));\n    assertThat(selected.contextMenu(\"Run As\"), MenuMatcher.hasMenuItem(endsWith(\"App Engine\")));\n    assertThat(selected.contextMenu(), MenuMatcher.hasMenuItem(\"Deploy to App Engine Standard...\"));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        not(MenuMatcher.hasMenuItem(\"Convert to App Engine Standard Project\")));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        not(MenuMatcher.hasMenuItem(\"Reconfigure for App Engine Java 8 runtime\")));\n  }\n\n  @Test\n  public void testMavenAppEngineStandardJava8() {\n    project =\n        SwtBotAppEngineActions.createMavenWebAppProject(\n            bot,\n            \"projectContextMenuJava8\",\n            tempFolder.getRoot().getPath(),\n            \"com.example.maven7\",\n            AppEngineRuntime.STANDARD_JAVA_8,\n            \"com.google.cloud.tools.eclipse.tests\",\n            \"projectContextMenuJava8\");\n    SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());\n    assertThat(selected.contextMenu(\"Debug As\"), MenuMatcher.hasMenuItem(endsWith(\"App Engine\")));\n    assertThat(selected.contextMenu(\"Run As\"), MenuMatcher.hasMenuItem(endsWith(\"App Engine\")));\n    assertThat(selected.contextMenu(), MenuMatcher.hasMenuItem(\"Deploy to App Engine Standard...\"));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        not(MenuMatcher.hasMenuItem(\"Convert to App Engine Standard Project\")));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        not(MenuMatcher.hasMenuItem(\"Reconfigure for App Engine Java 8 runtime\")));\n  }\n}", "item_id": 0, "repo": "lak-proddev/google-cloud-eclipse", "file": "plugins/com.google.cloud.tools.eclipse.integration.appengine/src/com/google/cloud/tools/eclipse/integration/appengine/ProjectContextMenuTest.java", "last_update_at": "2022-01-21T15:43:22+00:00", "question_id": "8a0f34e82e7baee7789025dc81122cef0b294a40_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProjectContextMenuTest extends BaseProjectTest {\n  @Rule public TestProjectCreator projectCreator = new TestProjectCreator();\n  @Rule public TemporaryFolder tempFolder = new TemporaryFolder();\n  @Rule public ThreadDumpingWatchdog timer = new ThreadDumpingWatchdog(2, TimeUnit.MINUTES);\n  @Test\n  public void testPlainJavaProject() {\n    IProject project = projectCreator.withFacets(JavaFacet.VERSION_1_8).getProject();\n    SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());\n    assertThat(\n        selected.contextMenu(\"Debug As\"), not(MenuMatcher.hasMenuItem(endsWith(\"App Engine\"))));\n    assertThat(\n        selected.contextMenu(\"Run As\"), not(MenuMatcher.hasMenuItem(endsWith(\"App Engine\"))));\n    assertThat(\n        selected.contextMenu(), not(MenuMatcher.hasMenuItem(\"Deploy to App Engine Standard...\")));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        MenuMatcher.hasMenuItem(\"Convert to App Engine Standard Project\"));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        not(MenuMatcher.hasMenuItem(\"Reconfigure for App Engine Java 8 runtime\")));\n  }\n  @Test\n  public void testDynamicWebProjectJava7() {\n    IProject project =\n        projectCreator.withFacets(JavaFacet.VERSION_1_7, WebFacetUtils.WEB_25).getProject();\n    SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());\n    assertThat(\n        selected.contextMenu(\"Debug As\"), not(MenuMatcher.hasMenuItem(endsWith(\"App Engine\"))));\n    assertThat(\n        selected.contextMenu(\"Run As\"), not(MenuMatcher.hasMenuItem(endsWith(\"App Engine\"))));\n    assertThat(\n        selected.contextMenu(), not(MenuMatcher.hasMenuItem(\"Deploy to App Engine Standard...\")));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        MenuMatcher.hasMenuItem(\"Convert to App Engine Standard Project\"));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        not(MenuMatcher.hasMenuItem(\"Reconfigure for App Engine Java 8 runtime\")));\n  }\n  @Test\n  public void testDynamicWebProjectJava8() {\n    IProject project =\n        projectCreator.withFacets(JavaFacet.VERSION_1_8, WebFacetUtils.WEB_31).getProject();\n    SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());\n    assertThat(\n        selected.contextMenu(\"Debug As\"), not(MenuMatcher.hasMenuItem(endsWith(\"App Engine\"))));\n    assertThat(\n        selected.contextMenu(\"Run As\"), not(MenuMatcher.hasMenuItem(endsWith(\"App Engine\"))));\n    assertThat(\n        selected.contextMenu(), not(MenuMatcher.hasMenuItem(\"Deploy to App Engine Standard...\")));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        MenuMatcher.hasMenuItem(\"Convert to App Engine Standard Project\"));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        not(MenuMatcher.hasMenuItem(\"Reconfigure for App Engine Java 8 runtime\")));\n  }\n  @Test\n  public void testAppEngineStandardJava7() {\n    IProject project =\n        projectCreator\n            .withFacets(AppEngineStandardFacet.JRE7, JavaFacet.VERSION_1_7, WebFacetUtils.WEB_25)\n            .getProject();\n    SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());\n    assertThat(selected.contextMenu(\"Debug As\"), MenuMatcher.hasMenuItem(endsWith(\"App Engine\")));\n    assertThat(selected.contextMenu(\"Run As\"), MenuMatcher.hasMenuItem(endsWith(\"App Engine\")));\n    assertThat(selected.contextMenu(), MenuMatcher.hasMenuItem(\"Deploy to App Engine Standard...\"));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        not(MenuMatcher.hasMenuItem(\"Convert to App Engine Standard Project\")));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        MenuMatcher.hasMenuItem(\"Reconfigure for App Engine Java 8 runtime\"));\n  }\n  @Test\n  public void testAppEngineStandardJava8() {\n    IProject project =\n        projectCreator\n            .withFacets(\n                AppEngineStandardFacet.FACET.getVersion(\"JRE8\"),\n                JavaFacet.VERSION_1_8,\n                WebFacetUtils.WEB_31)\n            .getProject();\n    SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());\n    assertThat(selected.contextMenu(\"Debug As\"), MenuMatcher.hasMenuItem(endsWith(\"App Engine\")));\n    assertThat(selected.contextMenu(\"Run As\"), MenuMatcher.hasMenuItem(endsWith(\"App Engine\")));\n    assertThat(selected.contextMenu(), MenuMatcher.hasMenuItem(\"Deploy to App Engine Standard...\"));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        not(MenuMatcher.hasMenuItem(\"Convert to App Engine Standard Project\")));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        not(MenuMatcher.hasMenuItem(\"Reconfigure for App Engine Java 8 runtime\")));\n  }\n  @Test\n  public void testMavenAppEngineStandardJava8() {\n    project =\n        SwtBotAppEngineActions.createMavenWebAppProject(\n            bot,\n            \"projectContextMenuJava8\",\n            tempFolder.getRoot().getPath(),\n            \"com.example.maven7\",\n            AppEngineRuntime.STANDARD_JAVA_8,\n            \"com.google.cloud.tools.eclipse.tests\",\n            \"projectContextMenuJava8\");\n    SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());\n    assertThat(selected.contextMenu(\"Debug As\"), MenuMatcher.hasMenuItem(endsWith(\"App Engine\")));\n    assertThat(selected.contextMenu(\"Run As\"), MenuMatcher.hasMenuItem(endsWith(\"App Engine\")));\n    assertThat(selected.contextMenu(), MenuMatcher.hasMenuItem(\"Deploy to App Engine Standard...\"));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        not(MenuMatcher.hasMenuItem(\"Convert to App Engine Standard Project\")));\n    assertThat(\n        selected.contextMenu(\"Configure\"),\n        not(MenuMatcher.hasMenuItem(\"Reconfigure for App Engine Java 8 runtime\")));\n  }\n"]], "pred": {"ppl": 1.3924007415771484, "ppl_lower": 1.6169296503067017, "ppl/lowercase_ppl": -1.4516204889662438, "ppl/zlib": 0.00045038014903968224, "Min_5.0% Prob": 4.574283300661573, "Min_10.0% Prob": 2.927294012378244, "Min_20.0% Prob": 1.6272270791963035, "Min_30.0% Prob": 1.1014539289464749, "Min_40.0% Prob": 0.8268006347668583, "Min_50.0% Prob": 0.6624260194521715, "Min_60.0% Prob": 0.5523601002821419}}
{"hexsha": "cb164d377ea45c88976dfb5ca642cb5257e618f5", "ext": "java", "lang": "Java", "content": "public class HarvestedItem \n{\n\tprivate Context context;\n\tprivate TableRow harvestRow;\n\n\t\n\tHarvestedItem(Context c, TableRow row)\n    {\n        context = c;\n        harvestRow = row;\n    }\n    \n    \n    public static void exists(Context c) throws SQLException {\n    \tDatabaseManager.queryTable(c, \"harvested_item\", \"SELECT COUNT(*) FROM harvested_item\");    \t\n    }\n\t\n\t\n    /**\n     * Find the harvest parameters corresponding to the specified DSpace item \n     * @return a HarvestedItem object corresponding to this item, null if not found.\n     */\n    public static HarvestedItem find(Context c, int item_id) throws SQLException \n    {\n    \tTableRow row = DatabaseManager.findByUnique(c, \"harvested_item\", \"item_id\", item_id);\n    \t\n    \tif (row == null) {\n    \t\treturn null;\n    \t}\n    \t\n    \treturn new HarvestedItem(c, row);\n    }\n    \n    \n    /*\n     * select foo.item_id from (select item.item_id, item.owning_collection from item join item2bundle on item.item_id=item2bundle.item_id where item2bundle.bundle_id=22) as foo join collection on foo.owning_collection=collection.collection_id where collection.collection_id=5;\n     */\n    \n    /**\n     * Retrieve a DSpace Item that corresponds to this particular combination of owning collection and OAI ID. \n     * @param context \n     * @param itemOaiID the string used by the OAI-PMH provider to identify the item\n     * @param collectionID id of the local collection that the item should be found in\n     * @return DSpace Item or null if no item was found\n     */\n    public static Item getItemByOAIId(Context context, String itemOaiID, int collectionID) throws SQLException\n    {\n    \t/*\n         * FYI: This method has to be scoped to a collection. Otherwise, we could have collisions as more \n         * than one collection might be importing the same item. That is OAI_ID's might be unique to the \n         * provider but not to the harvester.\n         */\n   \t \tItem resolvedItem = null;\n        TableRowIterator tri = null;\n        final String selectItemFromOaiId = \"SELECT dsi.item_id FROM \" + \n        \t\"(SELECT item.item_id, item.owning_collection FROM item JOIN harvested_item ON item.item_id=harvested_item.item_id WHERE harvested_item.oai_id=?) \" + \n        \t\"dsi JOIN collection ON dsi.owning_collection=collection.collection_id WHERE collection.collection_id=?\";\n        \n        try\n        {\n            tri = DatabaseManager.query(context, selectItemFromOaiId, itemOaiID, collectionID);\n\n            if (tri.hasNext())\n            {\n                TableRow row = tri.next();\n                int itemID = row.getIntColumn(\"item_id\");\n                resolvedItem = Item.find(context, itemID);\n            }\n            else {\n           \t return null;\n            }\n        }\n        finally {\n            if (tri != null)\n            {\n                tri.close();\n            }\n        }\n\n        return resolvedItem;\n    }\n        \n    /**\n     * Create a new harvested item row for a specified item id.  \n     * @return a new HarvestedItem object\n     */\n    public static HarvestedItem create(Context c, int itemId, String itemOAIid) throws SQLException {\n    \tTableRow row = DatabaseManager.row(\"harvested_item\");\n    \trow.setColumn(\"item_id\", itemId);\n    \trow.setColumn(\"oai_id\", itemOAIid);\n    \tDatabaseManager.insert(c, row);\n    \t\n    \treturn new HarvestedItem(c, row);    \t\n    }\n    \n    \n    public String getItemID()\n    {\n        String oai_id = harvestRow.getStringColumn(\"item_id\");\n\n        return oai_id;\n    }\n\n    /**\n     * Get the oai_id associated with this item \n     */\n    public String getOaiID()\n    {\n        String oai_id = harvestRow.getStringColumn(\"oai_id\");\n\n        return oai_id;\n    }\n    \n    /**\n     * Set the oai_id associated with this item \n     */\n    public void setOaiID(String itemOaiID)\n    {\n    \tharvestRow.setColumn(\"oai_id\",itemOaiID);\n        return;\n    }\n    \n    \n    public void setHarvestDate(Date date) {\n    \tif (date == null) {    \t\n    \t\tdate = new Date();\n    \t}\n    \tharvestRow.setColumn(\"last_harvested\", date);\n    }\n    \n    public Date getHarvestDate() {\n    \treturn harvestRow.getDateColumn(\"last_harvested\");\n    }\n    \n    \n    \n    public void delete() throws SQLException {\n    \tDatabaseManager.delete(context, harvestRow);\n    }\n    \n    \n    \n    public void update() throws SQLException, IOException, AuthorizeException {\n        DatabaseManager.update(context, harvestRow);\n    }\n\n}", "item_id": 0, "repo": "enrique/DSpace-Iteso", "file": "dspace-api/src/main/java/org/dspace/harvest/HarvestedItem.java", "last_update_at": "2022-03-31T18:38:55+00:00", "question_id": "cb164d377ea45c88976dfb5ca642cb5257e618f5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HarvestedItem \n{\n\tprivate Context context;\n\tprivate TableRow harvestRow;\n\t\n\tHarvestedItem(Context c, TableRow row)\n    {\n        context = c;\n        harvestRow = row;\n    }\n    public static void exists(Context c) throws SQLException {\n    \tDatabaseManager.queryTable(c, \"harvested_item\", \"SELECT COUNT(*) FROM harvested_item\");    \t\n    }\n\t\n\t\n    /**\n     * Find the harvest parameters corresponding to the specified DSpace item \n     * @return a HarvestedItem object corresponding to this item, null if not found.\n     */\n    public static HarvestedItem find(Context c, int item_id) throws SQLException \n    {\n    \tTableRow row = DatabaseManager.findByUnique(c, \"harvested_item\", \"item_id\", item_id);\n    \t\n    \tif (row == null) {\n    \t\treturn null;\n    \t}\n    \t\n    \treturn new HarvestedItem(c, row);\n    }\n    /*\n     * select foo.item_id from (select item.item_id, item.owning_collection from item join item2bundle on item.item_id=item2bundle.item_id where item2bundle.bundle_id=22) as foo join collection on foo.owning_collection=collection.collection_id where collection.collection_id=5;\n     */\n    /**\n     * Retrieve a DSpace Item that corresponds to this particular combination of owning collection and OAI ID. \n     * @param context \n     * @param itemOaiID the string used by the OAI-PMH provider to identify the item\n     * @param collectionID id of the local collection that the item should be found in\n     * @return DSpace Item or null if no item was found\n     */\n    public static Item getItemByOAIId(Context context, String itemOaiID, int collectionID) throws SQLException\n    {\n    \t/*\n         * FYI: This method has to be scoped to a collection. Otherwise, we could have collisions as more \n         * than one collection might be importing the same item. That is OAI_ID's might be unique to the \n         * provider but not to the harvester.\n         */\n   \t \tItem resolvedItem = null;\n        TableRowIterator tri = null;\n        final String selectItemFromOaiId = \"SELECT dsi.item_id FROM \" + \n        \t\"(SELECT item.item_id, item.owning_collection FROM item JOIN harvested_item ON item.item_id=harvested_item.item_id WHERE harvested_item.oai_id=?) \" + \n        \t\"dsi JOIN collection ON dsi.owning_collection=collection.collection_id WHERE collection.collection_id=?\";\n        try\n        {\n            tri = DatabaseManager.query(context, selectItemFromOaiId, itemOaiID, collectionID);\n            if (tri.hasNext())\n            {\n                TableRow row = tri.next();\n                int itemID = row.getIntColumn(\"item_id\");\n                resolvedItem = Item.find(context, itemID);\n            }\n            else {\n           \t return null;\n            }\n        }\n        finally {\n            if (tri != null)\n            {\n                tri.close();\n            }\n        }\n        return resolvedItem;\n    }\n    /**\n     * Create a new harvested item row for a specified item id.  \n     * @return a new HarvestedItem object\n     */\n    public static HarvestedItem create(Context c, int itemId, String itemOAIid) throws SQLException {\n    \tTableRow row = DatabaseManager.row(\"harvested_item\");\n    \trow.setColumn(\"item_id\", itemId);\n    \trow.setColumn(\"oai_id\", itemOAIid);\n    \tDatabaseManager.insert(c, row);\n    \t\n    \treturn new HarvestedItem(c, row);    \t\n    }\n    public String getItemID()\n    {\n        String oai_id = harvestRow.getStringColumn(\"item_id\");\n        return oai_id;\n    }\n    /**\n     * Get the oai_id associated with this item \n     */\n    public String getOaiID()\n    {\n        String oai_id = harvestRow.getStringColumn(\"oai_id\");\n        return oai_id;\n    }\n    /**\n     * Set the oai_id associated with this item \n     */\n    public void setOaiID(String itemOaiID)\n    {\n    \tharvestRow.setColumn(\"oai_id\",itemOaiID);\n        return;\n    }\n    public void setHarvestDate(Date date) {\n    \tif (date == null) {    \t\n    \t\tdate = new Date();\n    \t}\n    \tharvestRow.setColumn(\"last_harvested\", date);\n    }\n    public Date getHarvestDate() {\n    \treturn harvestRow.getDateColumn(\"last_harvested\");\n    }\n    public void delete() throws SQLException {\n    \tDatabaseManager.delete(context, harvestRow);\n    }\n    public void update() throws SQLException, IOException, AuthorizeException {\n        DatabaseManager.update(context, harvestRow);\n    }\n"]], "pred": {"ppl": 2.3025453090667725, "ppl_lower": 2.4927806854248047, "ppl/lowercase_ppl": -1.0951825152429586, "ppl/zlib": 0.0006096602099112626, "Min_5.0% Prob": 6.309428102829877, "Min_10.0% Prob": 4.856672293999615, "Min_20.0% Prob": 3.442577682873782, "Min_30.0% Prob": 2.598976119865779, "Min_40.0% Prob": 2.0370408898825167, "Min_50.0% Prob": 1.6562003853882128, "Min_60.0% Prob": 1.388049448197662}}
{"hexsha": "4f553d5c585d4988755d56c55275e6546d2f4137", "ext": "java", "lang": "Java", "content": "public class RtpSource {\n    /**\n     * RFC 3550: The dropout parameter MAX_DROPOUT should be a small fraction of the 16-bit sequence\n     * number space to give a reasonable probability that new sequence numbers after a restart will\n     * not fall in the acceptable range for sequence numbers from before the restart.\n     */\n    private static final int MAX_DROPOUT = 3000;\n\n    /**\n     * RFC 3550: the sequence number is considered valid if it is no more than MAX_DROPOUT ahead of\n     * maxSeq nor more than MAX_MISORDER behind\n     */\n    private static final int MAX_MISORDER = 100;\n\n    /**\n     * RFC 3550: RTP sequence number module\n     */\n    private static final int RTP_SEQ_MOD = (1 << 16);\n\n    /**\n     * CNAME value\n     */\n    private static String sCname = \"anonymous@127.0.0.1\";\n\n    /**\n     * Source is not valid until MIN_SEQUENTIAL packets with sequential sequence numbers have been\n     * received.\n     */\n    private static int MIN_SEQUENCIAL = 0;\n\n    /**\n     * Is this source and ActiveSender.\n     */\n    public boolean activeSender;\n\n    /**\n     * Source description\n     */\n    public int ssrc;\n\n    /**\n     * Highest Sequence number received from this source\n     */\n    private int maxSeq;\n\n    /**\n     * Keep track of the wrapping around of RTP sequence numbers, since RTP Seq No. are only 16 bits\n     */\n    private int cycles;\n\n    /**\n     * Sequence Number of the first RTP packet received from this source\n     */\n    private int baseSeq;\n\n    /**\n     * Last 'bad' sequence number + 1\n     */\n    private int badSeq;\n\n    /**\n     * Sequence packets till source is valid\n     */\n    private int probation;\n\n    /**\n     * Packets received\n     */\n    private int received;\n\n    /**\n     * Packet expected at last interval\n     */\n    private int expectedPrior;\n\n    /**\n     * Packet received at last interval\n     */\n    private int receivedPrior;\n\n    /**\n     * Estimated jitter.\n     */\n    public long jitter;\n\n    /**\n     * Last SR Packet timestamp\n     */\n    private long lastSenderReport;\n\n    /**\n     * Constructor requires an SSRC for it to be a valid source. The constructor initializes all the\n     * source class members to a default value\n     * \n     * @param sourceSSRC SSRC of the new source\n     */\n    RtpSource(int sourceSSRC) {\n        ssrc = sourceSSRC;\n        lastSenderReport = 0;\n        probation = MIN_SEQUENCIAL;\n        jitter = 0;\n        initSeq(-1);\n    }\n\n    /**\n     * Generates the extended sequence number.\n     * \n     * @param seq Original sequence number\n     * @return Extended sequence number\n     */\n    public int generateExtendedSequenceNumber(int seq) {\n        return seq + (RTP_SEQ_MOD * cycles);\n    }\n\n    /**\n     * Updates the statistics related to Sender Reports. Should be invoked when a RTCP Sender Report\n     * is received.\n     * \n     * @param srp Sender Report\n     */\n    public void receivedSenderReport(RtcpSenderReportPacket srp) {\n        // RFC 3550: last SR timestamp (LSR): 32 bits - The middle 32 bits out\n        // of 64 in the NTP timestamp received as part of the most recent RTCP\n        // sender report\n        lastSenderReport = (((srp.ntptimestampmsw << 32) | srp.ntptimestamplsw) & 0x0000ffffffff0000L) >>> 16;\n    }\n\n    /**\n     * Updates the statistics related to RTP packets Should be invoked every time this source\n     * receive an RTP Packet .\n     * \n     * @param packet\n     */\n    public void receiveRtpPacket(RtpPacket packet) {\n        if (baseSeq == -1) {\n            // First packet received\n            initSeq(packet.seqnum);\n        }\n        updateSeq(packet.seqnum);\n    }\n\n    /**\n     * Generate the Reception Report\n     * \n     * @return ReceptionReport\n     */\n    public ReceptionReport generateReceptionReport() {\n        ReceptionReport report = new ReceptionReport(ssrc);\n        updateReceptionReport(report);\n        return report;\n    }\n\n    /**\n     * Updates the reception report with latest data. The statistics calculation is based on the\n     * algorithms present in RFC 3550\n     * \n     * @param report Reception report to update\n     */\n    public void updateReceptionReport(ReceptionReport report) {\n        // Calculate the number of packets lost\n        int extendedMax = getExtendedSequenceNumber();\n        int expected = extendedMax - baseSeq + 1;\n        report.setCumulativeNumberOfPacketsLost(expected - received);\n\n        // TODO : Calculate the delay after last sender report received\n        report.setDelaySinceLastSenderReport(0);\n        report.setExtendedHighestSequenceNumberReceived(getExtendedSequenceNumber());\n\n        // Calculate the fraction lost\n        long expectedInterval = expected - expectedPrior;\n        expectedPrior = expected;\n        int receivedInterval = received - receivedPrior;\n        receivedPrior = received;\n        long lostInterval = expectedInterval - receivedInterval;\n        if (expectedInterval == 0 || lostInterval <= 0) {\n            report.setFractionLost(0);\n        } else {\n            report.setFractionLost((lostInterval << 8) / (double) expectedInterval);\n        }\n\n        // TODO : Calculate jitter\n        report.setInterarrivalJitter(0);\n\n        report.setLastSenderReport(lastSenderReport);\n        report.setSsrc(ssrc);\n    }\n\n    /**\n     * Set the Source description\n     * \n     * @param ssrc\n     */\n    public void setSsrc(int ssrc) {\n        this.ssrc = ssrc;\n    }\n\n    /**\n     * Initiate sequence. RFC 3550\n     * \n     * @param sequenceNumber\n     */\n    private void initSeq(int sequenceNumber) {\n        baseSeq = sequenceNumber;\n        maxSeq = sequenceNumber;\n        badSeq = RTP_SEQ_MOD + 1; // so seq == bad_seq is false\n        cycles = 0;\n        received = 0;\n        receivedPrior = 0;\n        expectedPrior = 0;\n    }\n\n    /**\n     * Ensures that a source is declared valid only after MIN_SEQUENTIAL packets have been received\n     * in sequence.It also validates the sequence number seq of a newly received packet and updates\n     * the sequence state. Algorithm in the RFC 3550 (Appendix A.1)\n     * \n     * @param seq Sequence Number\n     */\n    private int updateSeq(int seq) {\n        long udelta = seq - maxSeq;\n\n        // Source is not valid until MIN_SEQUENTIAL packets with sequential\n        // sequence numbers have been received.\n        if (probation > 0) {\n            if (seq == maxSeq + 1) {\n                probation--;\n                maxSeq = seq;\n                if (probation == 0) {\n                    initSeq(seq);\n                    received++;\n                    return 1;\n                }\n            } else {\n                probation = MIN_SEQUENCIAL - 1;\n                maxSeq = seq;\n                return 1;\n            }\n            return 0;\n        } else if (udelta < MAX_DROPOUT) {\n            // in order, with permissible gap\n            if (seq < maxSeq && (udelta >= (MAX_MISORDER * -1))) {\n                // late packet within interval\n                received++;\n                return 1;\n            }\n\n            if (seq < maxSeq) {\n                // Sequence number wrapped - count another 64K cycle.\n                cycles++;\n            }\n            maxSeq = seq;\n        } else if (udelta <= RTP_SEQ_MOD - MAX_MISORDER) {\n            // the sequence number made a very large jump\n            if (seq == badSeq) {\n                // Two sequential packets -- assume that the other side\n                // restarted without telling us so just re-sync\n                // (i.e., pretend this was the first packet).\n                initSeq(seq);\n            } else {\n                badSeq = (seq + 1) & (RTP_SEQ_MOD - 1);\n                return 0;\n            }\n        } else {\n            // duplicate or reordered packet\n        }\n        received++;\n        return 1;\n    }\n\n    /**\n     * Return the extended sequence number for a source considering that sequences cycle.\n     * \n     * @return Extended sequence number\n     */\n    private int getExtendedSequenceNumber() {\n        return generateExtendedSequenceNumber(maxSeq);\n    }\n\n    /**\n     * Gets Cname\n     * \n     * @return Cname\n     */\n    public static String getCname() {\n        return sCname;\n    }\n\n    /**\n     * Sets Cname\n     * \n     * @param cname\n     */\n    public static void setCname(String cname) {\n        sCname = cname;\n    }\n}", "item_id": 0, "repo": "snowman0911/rcsjta", "file": "core/src/com/gsma/rcs/core/ims/protocol/rtp/core/RtpSource.java", "last_update_at": "2022-01-20T00:10:14+00:00", "question_id": "4f553d5c585d4988755d56c55275e6546d2f4137_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RtpSource {\n    /**\n     * RFC 3550: The dropout parameter MAX_DROPOUT should be a small fraction of the 16-bit sequence\n     * number space to give a reasonable probability that new sequence numbers after a restart will\n     * not fall in the acceptable range for sequence numbers from before the restart.\n     */\n    private static final int MAX_DROPOUT = 3000;\n    /**\n     * RFC 3550: the sequence number is considered valid if it is no more than MAX_DROPOUT ahead of\n     * maxSeq nor more than MAX_MISORDER behind\n     */\n    private static final int MAX_MISORDER = 100;\n    /**\n     * RFC 3550: RTP sequence number module\n     */\n    private static final int RTP_SEQ_MOD = (1 << 16);\n    /**\n     * CNAME value\n     */\n    private static String sCname = \"anonymous@127.0.0.1\";\n    /**\n     * Source is not valid until MIN_SEQUENTIAL packets with sequential sequence numbers have been\n     * received.\n     */\n    private static int MIN_SEQUENCIAL = 0;\n    /**\n     * Is this source and ActiveSender.\n     */\n    public boolean activeSender;\n    /**\n     * Source description\n     */\n    public int ssrc;\n    /**\n     * Highest Sequence number received from this source\n     */\n    private int maxSeq;\n    /**\n     * Keep track of the wrapping around of RTP sequence numbers, since RTP Seq No. are only 16 bits\n     */\n    private int cycles;\n    /**\n     * Sequence Number of the first RTP packet received from this source\n     */\n    private int baseSeq;\n    /**\n     * Last 'bad' sequence number + 1\n     */\n    private int badSeq;\n    /**\n     * Sequence packets till source is valid\n     */\n    private int probation;\n    /**\n     * Packets received\n     */\n    private int received;\n    /**\n     * Packet expected at last interval\n     */\n    private int expectedPrior;\n    /**\n     * Packet received at last interval\n     */\n    private int receivedPrior;\n    /**\n     * Estimated jitter.\n     */\n    public long jitter;\n    /**\n     * Last SR Packet timestamp\n     */\n    private long lastSenderReport;\n    /**\n     * Constructor requires an SSRC for it to be a valid source. The constructor initializes all the\n     * source class members to a default value\n     * \n     * @param sourceSSRC SSRC of the new source\n     */\n    RtpSource(int sourceSSRC) {\n        ssrc = sourceSSRC;\n        lastSenderReport = 0;\n        probation = MIN_SEQUENCIAL;\n        jitter = 0;\n        initSeq(-1);\n    }\n    /**\n     * Generates the extended sequence number.\n     * \n     * @param seq Original sequence number\n     * @return Extended sequence number\n     */\n    public int generateExtendedSequenceNumber(int seq) {\n        return seq + (RTP_SEQ_MOD * cycles);\n    }\n    /**\n     * Updates the statistics related to Sender Reports. Should be invoked when a RTCP Sender Report\n     * is received.\n     * \n     * @param srp Sender Report\n     */\n    public void receivedSenderReport(RtcpSenderReportPacket srp) {\n        // RFC 3550: last SR timestamp (LSR): 32 bits - The middle 32 bits out\n        // of 64 in the NTP timestamp received as part of the most recent RTCP\n        // sender report\n        lastSenderReport = (((srp.ntptimestampmsw << 32) | srp.ntptimestamplsw) & 0x0000ffffffff0000L) >>> 16;\n    }\n    /**\n     * Updates the statistics related to RTP packets Should be invoked every time this source\n     * receive an RTP Packet .\n     * \n     * @param packet\n     */\n    public void receiveRtpPacket(RtpPacket packet) {\n        if (baseSeq == -1) {\n            // First packet received\n            initSeq(packet.seqnum);\n        }\n        updateSeq(packet.seqnum);\n    }\n    /**\n     * Generate the Reception Report\n     * \n     * @return ReceptionReport\n     */\n    public ReceptionReport generateReceptionReport() {\n        ReceptionReport report = new ReceptionReport(ssrc);\n        updateReceptionReport(report);\n        return report;\n    }\n    /**\n     * Updates the reception report with latest data. The statistics calculation is based on the\n     * algorithms present in RFC 3550\n     * \n     * @param report Reception report to update\n     */\n    public void updateReceptionReport(ReceptionReport report) {\n        // Calculate the number of packets lost\n        int extendedMax = getExtendedSequenceNumber();\n        int expected = extendedMax - baseSeq + 1;\n        report.setCumulativeNumberOfPacketsLost(expected - received);\n        // TODO : Calculate the delay after last sender report received\n        report.setDelaySinceLastSenderReport(0);\n        report.setExtendedHighestSequenceNumberReceived(getExtendedSequenceNumber());\n        // Calculate the fraction lost\n        long expectedInterval = expected - expectedPrior;\n        expectedPrior = expected;\n        int receivedInterval = received - receivedPrior;\n        receivedPrior = received;\n        long lostInterval = expectedInterval - receivedInterval;\n        if (expectedInterval == 0 || lostInterval <= 0) {\n            report.setFractionLost(0);\n        } else {\n            report.setFractionLost((lostInterval << 8) / (double) expectedInterval);\n        }\n        // TODO : Calculate jitter\n        report.setInterarrivalJitter(0);\n        report.setLastSenderReport(lastSenderReport);\n        report.setSsrc(ssrc);\n    }\n    /**\n     * Set the Source description\n     * \n     * @param ssrc\n     */\n    public void setSsrc(int ssrc) {\n        this.ssrc = ssrc;\n    }\n    /**\n     * Initiate sequence. RFC 3550\n     * \n     * @param sequenceNumber\n     */\n    private void initSeq(int sequenceNumber) {\n        baseSeq = sequenceNumber;\n        maxSeq = sequenceNumber;\n        badSeq = RTP_SEQ_MOD + 1; // so seq == bad_seq is false\n        cycles = 0;\n        received = 0;\n        receivedPrior = 0;\n        expectedPrior = 0;\n    }\n    /**\n     * Ensures that a source is declared valid only after MIN_SEQUENTIAL packets have been received\n     * in sequence.It also validates the sequence number seq of a newly received packet and updates\n     * the sequence state. Algorithm in the RFC 3550 (Appendix A.1)\n     * \n     * @param seq Sequence Number\n     */\n    private int updateSeq(int seq) {\n        long udelta = seq - maxSeq;\n        // Source is not valid until MIN_SEQUENTIAL packets with sequential\n        // sequence numbers have been received.\n        if (probation > 0) {\n            if (seq == maxSeq + 1) {\n                probation--;\n                maxSeq = seq;\n                if (probation == 0) {\n                    initSeq(seq);\n                    received++;\n                    return 1;\n                }\n            } else {\n                probation = MIN_SEQUENCIAL - 1;\n                maxSeq = seq;\n                return 1;\n            }\n            return 0;\n        } else if (udelta < MAX_DROPOUT) {\n            // in order, with permissible gap\n            if (seq < maxSeq && (udelta >= (MAX_MISORDER * -1))) {\n                // late packet within interval\n                received++;\n                return 1;\n            }\n            if (seq < maxSeq) {\n                // Sequence number wrapped - count another 64K cycle.\n                cycles++;\n            }\n            maxSeq = seq;\n        } else if (udelta <= RTP_SEQ_MOD - MAX_MISORDER) {\n            // the sequence number made a very large jump\n            if (seq == badSeq) {\n                // Two sequential packets -- assume that the other side\n                // restarted without telling us so just re-sync\n                // (i.e., pretend this was the first packet).\n                initSeq(seq);\n            } else {\n                badSeq = (seq + 1) & (RTP_SEQ_MOD - 1);\n                return 0;\n            }\n        } else {\n            // duplicate or reordered packet\n        }\n        received++;\n        return 1;\n    }\n    /**\n     * Return the extended sequence number for a source considering that sequences cycle.\n     * \n     * @return Extended sequence number\n     */\n    private int getExtendedSequenceNumber() {\n        return generateExtendedSequenceNumber(maxSeq);\n    }\n    /**\n     * Gets Cname\n     * \n     * @return Cname\n     */\n    public static String getCname() {\n        return sCname;\n    }\n    /**\n     * Sets Cname\n     * \n     * @param cname\n     */\n    public static void setCname(String cname) {\n        sCname = cname;\n    }\n"]], "pred": {"ppl": 2.721255302429199, "ppl_lower": 2.9645636081695557, "ppl/lowercase_ppl": -1.085543035800821, "ppl/zlib": 0.0004252732719166349, "Min_5.0% Prob": 7.366757729474236, "Min_10.0% Prob": 5.872610919615802, "Min_20.0% Prob": 4.221023568335702, "Min_30.0% Prob": 3.1661335340901915, "Min_40.0% Prob": 2.46630997354652, "Min_50.0% Prob": 1.9958349873189707, "Min_60.0% Prob": 1.6686028226766414}}
{"hexsha": "2e2b06c7d8ad0a86be19473e3d9962250b68326b", "ext": "java", "lang": "Java", "content": "public class MessageDeserializer extends StdDeserializer<Message> {\n\n    public MessageDeserializer(){\n        this(null);\n    }\n\n    public MessageDeserializer(Class<?> vc) {\n        super(vc);\n    }\n\n    @Override\n    public Message deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonNode node = p.getCodec().readTree(p);\n\n        String key = node.fieldNames().next();\n\n        JsonNode subNode = node.get(key);\n\n        Message message = new Message();\n        message.key = key;\n\n        Iterator<String> it = subNode.fieldNames();\n\n        while(it.hasNext()){\n            String lang = it.next();\n            message.addMessage(lang, subNode.get(lang).textValue());\n        }\n\n\n        return message;\n    }\n}", "item_id": 0, "repo": "LAEQ/vifeco", "file": "src/main/java/org/laeq/model/serializer/MessageDeserializer.java", "last_update_at": "2022-02-16T19:23:53+00:00", "question_id": "2e2b06c7d8ad0a86be19473e3d9962250b68326b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MessageDeserializer extends StdDeserializer<Message> {\n    public MessageDeserializer(){\n        this(null);\n    }\n    public MessageDeserializer(Class<?> vc) {\n        super(vc);\n    }\n    @Override\n    public Message deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonNode node = p.getCodec().readTree(p);\n        String key = node.fieldNames().next();\n        JsonNode subNode = node.get(key);\n        Message message = new Message();\n        message.key = key;\n        Iterator<String> it = subNode.fieldNames();\n        while(it.hasNext()){\n            String lang = it.next();\n            message.addMessage(lang, subNode.get(lang).textValue());\n        }\n        return message;\n    }\n"]], "pred": {"ppl": 1.5405927896499634, "ppl_lower": 2.102997064590454, "ppl/lowercase_ppl": -1.7200828273946351, "ppl/zlib": 0.001267352700011029, "Min_5.0% Prob": 5.215683351863515, "Min_10.0% Prob": 3.40499254248359, "Min_20.0% Prob": 2.053138514134017, "Min_30.0% Prob": 1.4210041016340256, "Min_40.0% Prob": 1.0783673271071166, "Min_50.0% Prob": 0.866155800231817, "Min_60.0% Prob": 0.7229048963777269}}
{"hexsha": "c5812b5fc57c9ed14c99590ca5a4ee654a5a4ccc", "ext": "java", "lang": "Java", "content": "class ReplayingDecoderBuffer implements ChannelBuffer {\n\n    private static final Error REPLAY = new ReplayError();\n\n    private final ChannelBuffer buffer;\n    private boolean terminated;\n\n    ReplayingDecoderBuffer(ChannelBuffer buffer) {\n        this.buffer = buffer;\n    }\n\n    void terminate() {\n        terminated = true;\n    }\n\n    @Override\n    public int capacity() {\n        if (terminated) {\n            return buffer.capacity();\n        } else {\n            return Integer.MAX_VALUE;\n        }\n    }\n\n    @Override\n    public boolean isDirect() {\n        return buffer.isDirect();\n    }\n\n    @Override\n    public boolean hasArray() {\n        return false;\n    }\n\n    @Override\n    public byte[] array() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public int arrayOffset() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void clear() {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        return this == obj;\n    }\n\n    @Override\n    public int compareTo(ChannelBuffer buffer) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public ChannelBuffer copy() {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public ChannelBuffer copy(int index, int length) {\n        checkIndex(index, length);\n        return buffer.copy(index, length);\n    }\n\n    @Override\n    public void discardReadBytes() {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void ensureWritableBytes(int writableBytes) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public ChannelBuffer duplicate() {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public byte getByte(int index) {\n        checkIndex(index);\n        return buffer.getByte(index);\n    }\n\n    @Override\n    public short getUnsignedByte(int index) {\n        checkIndex(index);\n        return buffer.getUnsignedByte(index);\n    }\n\n    @Override\n    public void getBytes(int index, byte[] dst, int dstIndex, int length) {\n        checkIndex(index, length);\n        buffer.getBytes(index, dst, dstIndex, length);\n    }\n\n    @Override\n    public void getBytes(int index, byte[] dst) {\n        checkIndex(index, dst.length);\n        buffer.getBytes(index, dst);\n    }\n\n    @Override\n    public void getBytes(int index, ByteBuffer dst) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void getBytes(int index, ChannelBuffer dst, int dstIndex, int length) {\n        checkIndex(index, length);\n        buffer.getBytes(index, dst, dstIndex, length);\n    }\n\n    @Override\n    public void getBytes(int index, ChannelBuffer dst, int length) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void getBytes(int index, ChannelBuffer dst) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public int getBytes(int index, GatheringByteChannel out, int length)\n            throws IOException {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void getBytes(int index, OutputStream out, int length)\n            throws IOException {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public int getInt(int index) {\n        checkIndex(index, 4);\n        return buffer.getInt(index);\n    }\n\n    @Override\n    public long getUnsignedInt(int index) {\n        checkIndex(index, 4);\n        return buffer.getUnsignedInt(index);\n    }\n\n    @Override\n    public long getLong(int index) {\n        checkIndex(index, 8);\n        return buffer.getLong(index);\n    }\n\n    @Override\n    public int getMedium(int index) {\n        checkIndex(index, 3);\n        return buffer.getMedium(index);\n    }\n\n    @Override\n    public int getUnsignedMedium(int index) {\n        checkIndex(index, 3);\n        return buffer.getUnsignedMedium(index);\n    }\n\n    @Override\n    public short getShort(int index) {\n        checkIndex(index, 2);\n        return buffer.getShort(index);\n    }\n\n    @Override\n    public int getUnsignedShort(int index) {\n        checkIndex(index, 2);\n        return buffer.getUnsignedShort(index);\n    }\n\n    @Override\n    public char getChar(int index) {\n        checkIndex(index, 2);\n        return buffer.getChar(index);\n    }\n\n    @Override\n    public float getFloat(int index) {\n        checkIndex(index, 4);\n        return buffer.getFloat(index);\n    }\n\n    @Override\n    public double getDouble(int index) {\n        checkIndex(index, 8);\n        return buffer.getDouble(index);\n    }\n\n    @Override\n    public int hashCode() {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public int indexOf(int fromIndex, int toIndex, byte value) {\n        int endIndex = buffer.indexOf(fromIndex, toIndex, value);\n        if (endIndex < 0) {\n            throw REPLAY;\n        }\n        return endIndex;\n    }\n\n    @Override\n    public int indexOf(int fromIndex, int toIndex,\n            ChannelBufferIndexFinder indexFinder) {\n        int endIndex = buffer.indexOf(fromIndex, toIndex, indexFinder);\n        if (endIndex < 0) {\n            throw REPLAY;\n        }\n        return endIndex;\n    }\n\n    @Override\n    public int bytesBefore(byte value) {\n        int bytes = buffer.bytesBefore(value);\n        if (bytes < 0) {\n            throw REPLAY;\n        }\n        return bytes;\n    }\n\n    @Override\n    public int bytesBefore(ChannelBufferIndexFinder indexFinder) {\n        int bytes = buffer.bytesBefore(indexFinder);\n        if (bytes < 0) {\n            throw REPLAY;\n        }\n        return bytes;\n    }\n\n    @Override\n    public int bytesBefore(int length, byte value) {\n        checkReadableBytes(length);\n        int bytes = buffer.bytesBefore(length, value);\n        if (bytes < 0) {\n            throw REPLAY;\n        }\n        return bytes;\n    }\n\n    @Override\n    public int bytesBefore(int length, ChannelBufferIndexFinder indexFinder) {\n        checkReadableBytes(length);\n        int bytes = buffer.bytesBefore(length, indexFinder);\n        if (bytes < 0) {\n            throw REPLAY;\n        }\n        return bytes;\n    }\n\n    @Override\n    public int bytesBefore(int index, int length, byte value) {\n        int bytes = buffer.bytesBefore(index, length, value);\n        if (bytes < 0) {\n            throw REPLAY;\n        }\n        return bytes;\n    }\n\n    @Override\n    public int bytesBefore(int index, int length,\n            ChannelBufferIndexFinder indexFinder) {\n        int bytes = buffer.bytesBefore(index, length, indexFinder);\n        if (bytes < 0) {\n            throw REPLAY;\n        }\n        return bytes;\n    }\n\n    @Override\n    public void markReaderIndex() {\n        buffer.markReaderIndex();\n    }\n\n    @Override\n    public void markWriterIndex() {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public ChannelBufferFactory factory() {\n        return buffer.factory();\n    }\n\n    @Override\n    public ByteOrder order() {\n        return buffer.order();\n    }\n\n    @Override\n    public boolean readable() {\n        return terminated? buffer.readable() : true;\n    }\n\n    @Override\n    public int readableBytes() {\n        if (terminated) {\n            return buffer.readableBytes();\n        } else {\n            return Integer.MAX_VALUE - buffer.readerIndex();\n        }\n    }\n\n    @Override\n    public byte readByte() {\n        checkReadableBytes(1);\n        return buffer.readByte();\n    }\n\n    @Override\n    public short readUnsignedByte() {\n        checkReadableBytes(1);\n        return buffer.readUnsignedByte();\n    }\n\n    @Override\n    public void readBytes(byte[] dst, int dstIndex, int length) {\n        checkReadableBytes(length);\n        buffer.readBytes(dst, dstIndex, length);\n    }\n\n    @Override\n    public void readBytes(byte[] dst) {\n        checkReadableBytes(dst.length);\n        buffer.readBytes(dst);\n    }\n\n    @Override\n    public void readBytes(ByteBuffer dst) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void readBytes(ChannelBuffer dst, int dstIndex, int length) {\n        checkReadableBytes(length);\n        buffer.readBytes(dst, dstIndex, length);\n    }\n\n    @Override\n    public void readBytes(ChannelBuffer dst, int length) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void readBytes(ChannelBuffer dst) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public int readBytes(GatheringByteChannel out, int length)\n            throws IOException {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public ChannelBuffer readBytes(int length) {\n        checkReadableBytes(length);\n        return buffer.readBytes(length);\n    }\n\n    @Override\n    public ChannelBuffer readSlice(int length) {\n        checkReadableBytes(length);\n        return buffer.readSlice(length);\n    }\n\n    @Override\n    public void readBytes(OutputStream out, int length) throws IOException {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public int readerIndex() {\n        return buffer.readerIndex();\n    }\n\n    @Override\n    public void readerIndex(int readerIndex) {\n        buffer.readerIndex(readerIndex);\n    }\n\n    @Override\n    public int readInt() {\n        checkReadableBytes(4);\n        return buffer.readInt();\n    }\n\n    @Override\n    public long readUnsignedInt() {\n        checkReadableBytes(4);\n        return buffer.readUnsignedInt();\n    }\n\n    @Override\n    public long readLong() {\n        checkReadableBytes(8);\n        return buffer.readLong();\n    }\n\n    @Override\n    public int readMedium() {\n        checkReadableBytes(3);\n        return buffer.readMedium();\n    }\n\n    @Override\n    public int readUnsignedMedium() {\n        checkReadableBytes(3);\n        return buffer.readUnsignedMedium();\n    }\n\n    @Override\n    public short readShort() {\n        checkReadableBytes(2);\n        return buffer.readShort();\n    }\n\n    @Override\n    public int readUnsignedShort() {\n        checkReadableBytes(2);\n        return buffer.readUnsignedShort();\n    }\n\n    @Override\n    public char readChar() {\n        checkReadableBytes(2);\n        return buffer.readChar();\n    }\n\n    @Override\n    public float readFloat() {\n        checkReadableBytes(4);\n        return buffer.readFloat();\n    }\n\n    @Override\n    public double readDouble() {\n        checkReadableBytes(8);\n        return buffer.readDouble();\n    }\n\n    @Override\n    public void resetReaderIndex() {\n        buffer.resetReaderIndex();\n    }\n\n    @Override\n    public void resetWriterIndex() {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void setByte(int index, int value) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void setBytes(int index, byte[] src, int srcIndex, int length) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void setBytes(int index, byte[] src) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void setBytes(int index, ByteBuffer src) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void setBytes(int index, ChannelBuffer src, int srcIndex, int length) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void setBytes(int index, ChannelBuffer src, int length) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void setBytes(int index, ChannelBuffer src) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public int setBytes(int index, InputStream in, int length)\n            throws IOException {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void setZero(int index, int length) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public int setBytes(int index, ScatteringByteChannel in, int length)\n            throws IOException {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void setIndex(int readerIndex, int writerIndex) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void setInt(int index, int value) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void setLong(int index, long value) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void setMedium(int index, int value) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void setShort(int index, int value) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void setChar(int index, int value) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void setFloat(int index, float value) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void setDouble(int index, double value) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void skipBytes(int length) {\n        checkReadableBytes(length);\n        buffer.skipBytes(length);\n    }\n\n    @Override\n    public ChannelBuffer slice() {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public ChannelBuffer slice(int index, int length) {\n        checkIndex(index, length);\n        return buffer.slice(index, length);\n    }\n\n    @Override\n    public ByteBuffer toByteBuffer() {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public ByteBuffer toByteBuffer(int index, int length) {\n        checkIndex(index, length);\n        return buffer.toByteBuffer(index, length);\n    }\n\n    @Override\n    public ByteBuffer[] toByteBuffers() {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public ByteBuffer[] toByteBuffers(int index, int length) {\n        checkIndex(index, length);\n        return buffer.toByteBuffers(index, length);\n    }\n\n    @Override\n    public String toString(int index, int length, Charset charset) {\n        checkIndex(index, length);\n        return buffer.toString(index, length, charset);\n    }\n\n    @Override\n    public String toString(Charset charsetName) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getSimpleName() + '(' +\n               \"ridx=\" +\n               readerIndex() +\n               \", \" +\n               \"widx=\" +\n               writerIndex() +\n               ')';\n    }\n\n    @Override\n    public boolean writable() {\n        return false;\n    }\n\n    @Override\n    public int writableBytes() {\n        return 0;\n    }\n\n    @Override\n    public void writeByte(int value) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void writeBytes(byte[] src, int srcIndex, int length) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void writeBytes(byte[] src) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void writeBytes(ByteBuffer src) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void writeBytes(ChannelBuffer src, int srcIndex, int length) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void writeBytes(ChannelBuffer src, int length) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void writeBytes(ChannelBuffer src) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public int writeBytes(InputStream in, int length) throws IOException {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public int writeBytes(ScatteringByteChannel in, int length)\n            throws IOException {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void writeInt(int value) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void writeLong(long value) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void writeMedium(int value) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void writeZero(int length) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public int writerIndex() {\n        return buffer.writerIndex();\n    }\n\n    @Override\n    public void writerIndex(int writerIndex) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void writeShort(int value) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void writeChar(int value) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void writeFloat(float value) {\n        throw new UnreplayableOperationException();\n    }\n\n    @Override\n    public void writeDouble(double value) {\n        throw new UnreplayableOperationException();\n    }\n\n    private void checkIndex(int index) {\n        if (index > buffer.writerIndex()) {\n            throw REPLAY;\n        }\n    }\n\n    private void checkIndex(int index, int length) {\n        if (index + length > buffer.writerIndex()) {\n            throw REPLAY;\n        }\n    }\n\n    private void checkReadableBytes(int readableBytes) {\n        if (buffer.readableBytes() < readableBytes) {\n            throw REPLAY;\n        }\n    }\n}", "item_id": 0, "repo": "codefollower/Open-Source-Research", "file": "Douyu-0.7.1/douyu-netty/src/main/java/com/codefollower/douyu/netty/handler/codec/replay/ReplayingDecoderBuffer.java", "last_update_at": "2022-03-30T05:47:21+00:00", "question_id": "c5812b5fc57c9ed14c99590ca5a4ee654a5a4ccc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class ReplayingDecoderBuffer implements ChannelBuffer {\n    private static final Error REPLAY = new ReplayError();\n    private final ChannelBuffer buffer;\n    private boolean terminated;\n    ReplayingDecoderBuffer(ChannelBuffer buffer) {\n        this.buffer = buffer;\n    }\n    void terminate() {\n        terminated = true;\n    }\n    @Override\n    public int capacity() {\n        if (terminated) {\n            return buffer.capacity();\n        } else {\n            return Integer.MAX_VALUE;\n        }\n    }\n    @Override\n    public boolean isDirect() {\n        return buffer.isDirect();\n    }\n    @Override\n    public boolean hasArray() {\n        return false;\n    }\n    @Override\n    public byte[] array() {\n        throw new UnsupportedOperationException();\n    }\n    @Override\n    public int arrayOffset() {\n        throw new UnsupportedOperationException();\n    }\n    @Override\n    public void clear() {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public boolean equals(Object obj) {\n        return this == obj;\n    }\n    @Override\n    public int compareTo(ChannelBuffer buffer) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public ChannelBuffer copy() {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public ChannelBuffer copy(int index, int length) {\n        checkIndex(index, length);\n        return buffer.copy(index, length);\n    }\n    @Override\n    public void discardReadBytes() {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void ensureWritableBytes(int writableBytes) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public ChannelBuffer duplicate() {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public byte getByte(int index) {\n        checkIndex(index);\n        return buffer.getByte(index);\n    }\n    @Override\n    public short getUnsignedByte(int index) {\n        checkIndex(index);\n        return buffer.getUnsignedByte(index);\n    }\n    @Override\n    public void getBytes(int index, byte[] dst, int dstIndex, int length) {\n        checkIndex(index, length);\n        buffer.getBytes(index, dst, dstIndex, length);\n    }\n    @Override\n    public void getBytes(int index, byte[] dst) {\n        checkIndex(index, dst.length);\n        buffer.getBytes(index, dst);\n    }\n    @Override\n    public void getBytes(int index, ByteBuffer dst) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void getBytes(int index, ChannelBuffer dst, int dstIndex, int length) {\n        checkIndex(index, length);\n        buffer.getBytes(index, dst, dstIndex, length);\n    }\n    @Override\n    public void getBytes(int index, ChannelBuffer dst, int length) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void getBytes(int index, ChannelBuffer dst) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public int getBytes(int index, GatheringByteChannel out, int length)\n            throws IOException {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void getBytes(int index, OutputStream out, int length)\n            throws IOException {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public int getInt(int index) {\n        checkIndex(index, 4);\n        return buffer.getInt(index);\n    }\n    @Override\n    public long getUnsignedInt(int index) {\n        checkIndex(index, 4);\n        return buffer.getUnsignedInt(index);\n    }\n    @Override\n    public long getLong(int index) {\n        checkIndex(index, 8);\n        return buffer.getLong(index);\n    }\n    @Override\n    public int getMedium(int index) {\n        checkIndex(index, 3);\n        return buffer.getMedium(index);\n    }\n    @Override\n    public int getUnsignedMedium(int index) {\n        checkIndex(index, 3);\n        return buffer.getUnsignedMedium(index);\n    }\n    @Override\n    public short getShort(int index) {\n        checkIndex(index, 2);\n        return buffer.getShort(index);\n    }\n    @Override\n    public int getUnsignedShort(int index) {\n        checkIndex(index, 2);\n        return buffer.getUnsignedShort(index);\n    }\n    @Override\n    public char getChar(int index) {\n        checkIndex(index, 2);\n        return buffer.getChar(index);\n    }\n    @Override\n    public float getFloat(int index) {\n        checkIndex(index, 4);\n        return buffer.getFloat(index);\n    }\n    @Override\n    public double getDouble(int index) {\n        checkIndex(index, 8);\n        return buffer.getDouble(index);\n    }\n    @Override\n    public int hashCode() {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public int indexOf(int fromIndex, int toIndex, byte value) {\n        int endIndex = buffer.indexOf(fromIndex, toIndex, value);\n        if (endIndex < 0) {\n            throw REPLAY;\n        }\n        return endIndex;\n    }\n    @Override\n    public int indexOf(int fromIndex, int toIndex,\n            ChannelBufferIndexFinder indexFinder) {\n        int endIndex = buffer.indexOf(fromIndex, toIndex, indexFinder);\n        if (endIndex < 0) {\n            throw REPLAY;\n        }\n        return endIndex;\n    }\n    @Override\n    public int bytesBefore(byte value) {\n        int bytes = buffer.bytesBefore(value);\n        if (bytes < 0) {\n            throw REPLAY;\n        }\n        return bytes;\n    }\n    @Override\n    public int bytesBefore(ChannelBufferIndexFinder indexFinder) {\n        int bytes = buffer.bytesBefore(indexFinder);\n        if (bytes < 0) {\n            throw REPLAY;\n        }\n        return bytes;\n    }\n    @Override\n    public int bytesBefore(int length, byte value) {\n        checkReadableBytes(length);\n        int bytes = buffer.bytesBefore(length, value);\n        if (bytes < 0) {\n            throw REPLAY;\n        }\n        return bytes;\n    }\n    @Override\n    public int bytesBefore(int length, ChannelBufferIndexFinder indexFinder) {\n        checkReadableBytes(length);\n        int bytes = buffer.bytesBefore(length, indexFinder);\n        if (bytes < 0) {\n            throw REPLAY;\n        }\n        return bytes;\n    }\n    @Override\n    public int bytesBefore(int index, int length, byte value) {\n        int bytes = buffer.bytesBefore(index, length, value);\n        if (bytes < 0) {\n            throw REPLAY;\n        }\n        return bytes;\n    }\n    @Override\n    public int bytesBefore(int index, int length,\n            ChannelBufferIndexFinder indexFinder) {\n        int bytes = buffer.bytesBefore(index, length, indexFinder);\n        if (bytes < 0) {\n            throw REPLAY;\n        }\n        return bytes;\n    }\n    @Override\n    public void markReaderIndex() {\n        buffer.markReaderIndex();\n    }\n    @Override\n    public void markWriterIndex() {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public ChannelBufferFactory factory() {\n        return buffer.factory();\n    }\n    @Override\n    public ByteOrder order() {\n        return buffer.order();\n    }\n    @Override\n    public boolean readable() {\n        return terminated? buffer.readable() : true;\n    }\n    @Override\n    public int readableBytes() {\n        if (terminated) {\n            return buffer.readableBytes();\n        } else {\n            return Integer.MAX_VALUE - buffer.readerIndex();\n        }\n    }\n    @Override\n    public byte readByte() {\n        checkReadableBytes(1);\n        return buffer.readByte();\n    }\n    @Override\n    public short readUnsignedByte() {\n        checkReadableBytes(1);\n        return buffer.readUnsignedByte();\n    }\n    @Override\n    public void readBytes(byte[] dst, int dstIndex, int length) {\n        checkReadableBytes(length);\n        buffer.readBytes(dst, dstIndex, length);\n    }\n    @Override\n    public void readBytes(byte[] dst) {\n        checkReadableBytes(dst.length);\n        buffer.readBytes(dst);\n    }\n    @Override\n    public void readBytes(ByteBuffer dst) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void readBytes(ChannelBuffer dst, int dstIndex, int length) {\n        checkReadableBytes(length);\n        buffer.readBytes(dst, dstIndex, length);\n    }\n    @Override\n    public void readBytes(ChannelBuffer dst, int length) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void readBytes(ChannelBuffer dst) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public int readBytes(GatheringByteChannel out, int length)\n            throws IOException {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public ChannelBuffer readBytes(int length) {\n        checkReadableBytes(length);\n        return buffer.readBytes(length);\n    }\n    @Override\n    public ChannelBuffer readSlice(int length) {\n        checkReadableBytes(length);\n        return buffer.readSlice(length);\n    }\n    @Override\n    public void readBytes(OutputStream out, int length) throws IOException {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public int readerIndex() {\n        return buffer.readerIndex();\n    }\n    @Override\n    public void readerIndex(int readerIndex) {\n        buffer.readerIndex(readerIndex);\n    }\n    @Override\n    public int readInt() {\n        checkReadableBytes(4);\n        return buffer.readInt();\n    }\n    @Override\n    public long readUnsignedInt() {\n        checkReadableBytes(4);\n        return buffer.readUnsignedInt();\n    }\n    @Override\n    public long readLong() {\n        checkReadableBytes(8);\n        return buffer.readLong();\n    }\n    @Override\n    public int readMedium() {\n        checkReadableBytes(3);\n        return buffer.readMedium();\n    }\n    @Override\n    public int readUnsignedMedium() {\n        checkReadableBytes(3);\n        return buffer.readUnsignedMedium();\n    }\n    @Override\n    public short readShort() {\n        checkReadableBytes(2);\n        return buffer.readShort();\n    }\n    @Override\n    public int readUnsignedShort() {\n        checkReadableBytes(2);\n        return buffer.readUnsignedShort();\n    }\n    @Override\n    public char readChar() {\n        checkReadableBytes(2);\n        return buffer.readChar();\n    }\n    @Override\n    public float readFloat() {\n        checkReadableBytes(4);\n        return buffer.readFloat();\n    }\n    @Override\n    public double readDouble() {\n        checkReadableBytes(8);\n        return buffer.readDouble();\n    }\n    @Override\n    public void resetReaderIndex() {\n        buffer.resetReaderIndex();\n    }\n    @Override\n    public void resetWriterIndex() {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void setByte(int index, int value) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void setBytes(int index, byte[] src, int srcIndex, int length) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void setBytes(int index, byte[] src) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void setBytes(int index, ByteBuffer src) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void setBytes(int index, ChannelBuffer src, int srcIndex, int length) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void setBytes(int index, ChannelBuffer src, int length) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void setBytes(int index, ChannelBuffer src) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public int setBytes(int index, InputStream in, int length)\n            throws IOException {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void setZero(int index, int length) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public int setBytes(int index, ScatteringByteChannel in, int length)\n            throws IOException {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void setIndex(int readerIndex, int writerIndex) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void setInt(int index, int value) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void setLong(int index, long value) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void setMedium(int index, int value) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void setShort(int index, int value) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void setChar(int index, int value) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void setFloat(int index, float value) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void setDouble(int index, double value) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void skipBytes(int length) {\n        checkReadableBytes(length);\n        buffer.skipBytes(length);\n    }\n    @Override\n    public ChannelBuffer slice() {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public ChannelBuffer slice(int index, int length) {\n        checkIndex(index, length);\n        return buffer.slice(index, length);\n    }\n    @Override\n    public ByteBuffer toByteBuffer() {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public ByteBuffer toByteBuffer(int index, int length) {\n        checkIndex(index, length);\n        return buffer.toByteBuffer(index, length);\n    }\n    @Override\n    public ByteBuffer[] toByteBuffers() {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public ByteBuffer[] toByteBuffers(int index, int length) {\n        checkIndex(index, length);\n        return buffer.toByteBuffers(index, length);\n    }\n    @Override\n    public String toString(int index, int length, Charset charset) {\n        checkIndex(index, length);\n        return buffer.toString(index, length, charset);\n    }\n    @Override\n    public String toString(Charset charsetName) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public String toString() {\n        return getClass().getSimpleName() + '(' +\n               \"ridx=\" +\n               readerIndex() +\n               \", \" +\n               \"widx=\" +\n               writerIndex() +\n               ')';\n    }\n    @Override\n    public boolean writable() {\n        return false;\n    }\n    @Override\n    public int writableBytes() {\n        return 0;\n    }\n    @Override\n    public void writeByte(int value) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void writeBytes(byte[] src, int srcIndex, int length) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void writeBytes(byte[] src) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void writeBytes(ByteBuffer src) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void writeBytes(ChannelBuffer src, int srcIndex, int length) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void writeBytes(ChannelBuffer src, int length) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void writeBytes(ChannelBuffer src) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public int writeBytes(InputStream in, int length) throws IOException {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public int writeBytes(ScatteringByteChannel in, int length)\n            throws IOException {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void writeInt(int value) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void writeLong(long value) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void writeMedium(int value) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void writeZero(int length) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public int writerIndex() {\n        return buffer.writerIndex();\n    }\n    @Override\n    public void writerIndex(int writerIndex) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void writeShort(int value) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void writeChar(int value) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void writeFloat(float value) {\n        throw new UnreplayableOperationException();\n    }\n    @Override\n    public void writeDouble(double value) {\n        throw new UnreplayableOperationException();\n    }\n    private void checkIndex(int index) {\n        if (index > buffer.writerIndex()) {\n            throw REPLAY;\n        }\n    }\n    private void checkIndex(int index, int length) {\n        if (index + length > buffer.writerIndex()) {\n            throw REPLAY;\n        }\n    }\n    private void checkReadableBytes(int readableBytes) {\n        if (buffer.readableBytes() < readableBytes) {\n            throw REPLAY;\n        }\n    }\n"]], "pred": {"ppl": 1.2469618320465088, "ppl_lower": 1.3715449571609497, "ppl/lowercase_ppl": -1.4314608617895692, "ppl/zlib": 0.00012214170360149736, "Min_5.0% Prob": 3.6059567717944874, "Min_10.0% Prob": 2.125755672945696, "Min_20.0% Prob": 1.1022896176140171, "Min_30.0% Prob": 0.7369658719349556, "Min_40.0% Prob": 0.5517647531316764, "Min_50.0% Prob": 0.441749528923025, "Min_60.0% Prob": 0.368293310104758}}
{"hexsha": "ce6dc5a582b585ce72817a1ced6012c5be5bca7c", "ext": "java", "lang": "Java", "content": "public final class TbiIndex extends Index{\n\t\n\tprivate TIndex[] mIndex;\n\t\n\tpublic void readMagic() throws IOException {\n\t\tbyte[] buf = new byte[4];\n        is.read(buf, 0, 4); // read \"TBI\\1\"\n    }\n\t\n\tpublic void readFormat() throws IOException {\n\t\tmSeq = new String[GlobalParameter.readInt(is)]; // # sequences\n\t\tmChr2tid = new HashMap<String, Integer>();\n\t\tmTid2chr = new HashMap<Integer, String>();\n\t\tmPreset = GlobalParameter.readInt(is);\n\t\tmSc = GlobalParameter.readInt(is);\n\t\tmBc = GlobalParameter.readInt(is);\n\t\tmEc = GlobalParameter.readInt(is);\n\n\t\tmMeta = GlobalParameter.readInt(is);\n\t\tmSkip = GlobalParameter.readInt(is); // read skip\n\t}\n\t\n\tpublic TbiIndex(String indexPath) {\n\t\tsuper(indexPath, true);\n\t\ttry {\n\t\t\tread();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic void read() throws IOException {\n\t\tsuper.read();\n\n\t\tif((mPreset & 0xffff) == 2) {\n\t\t\tthis.format = Format.newVCF();\n\t\t\tthis.format.numHeaderLinesToSkip = mSkip;\n\t\t} else {\n\t\t\tthis.format = new Format(mPreset, mSc, mBc, mEc, mSkip, Character.toString((char) mMeta), -1, -1, false);\n\t\t}\n\t}\n\t\n\tpublic void readIndex() throws IOException {\n\t\tmIndex = new TIndex[mSeq.length];\n\t\tint i, j, k;\n\t\tfor (i = 0; i < mSeq.length; ++i) {\n\n\t\t\tint n_bin = GlobalParameter.readInt(is);\n\t\t\tmIndex[i] = new TIndex();\n\t\t\tmIndex[i].b = new HashMap<Integer, TPair64[]>(n_bin);\n\t\t\tfor (j = 0; j < n_bin; ++j) {\n\t\t\t\tint bin = GlobalParameter.readInt(is);\n\t\t\t\tTPair64[] chunks = new TPair64[GlobalParameter.readInt(is)];\n\t\t\t\tfor (k = 0; k < chunks.length; ++k) {\n\t\t\t\t\tlong u = GlobalParameter.readLong(is, buf);\n\t\t\t\t\tlong v = GlobalParameter.readLong(is, buf);\n\t\t\t\t\tchunks[k] = new TPair64(u, v); // in C, this is inefficient\n\t\t\t\t}\n\t\t\t\tmIndex[i].b.put(bin, chunks);\n\t\t\t}\n\t\t\t\n\t\t\t// the linear index\n\t\t\tmIndex[i].l = new long[GlobalParameter.readInt(is)];\n\n\t\t\tfor (k = 0; k < mIndex[i].l.length; ++k) {\n\t\t\t\tmIndex[i].l[k] = GlobalParameter.readLong(is, buf);\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tminOffForChr.put(i, 0l);\n\t\t\t\t} else {\n\t\t\t\t\tif (mIndex[i].l[k] > 0) {\n\t\t\t\t\t\tif (minOffForChr.get(i) == null) {\n\t\t\t\t\t\t\tminOffForChr.put(i, mIndex[i].l[k]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (mIndex[i].l[k] < minOffForChr.get(i)) {\n\t\t\t\t\t\t\t\tminOffForChr.put(i, mIndex[i].l[k]);\n\t\t\t\t\t\t\t\tthrow new InvalidArgumentException(\"That is  impossible! in SweepReader read index.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic TIndex[] getmIndex() {\n\t\treturn mIndex;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tTbiIndex index  = new TbiIndex(\"ALL.chr1.phase3_shapeit2_mvncall_integrated_v3plus_nounphased.rsID.genotypes.GRCh38_dbSNP.vcf.gz.tbi\");\n\t\t\n\t\tSystem.out.println(index.mSc);\n\t\tSystem.out.println(index.mBc);\n\t\tSystem.out.println(index.mEc);\n\t\tSystem.out.println(index.mPreset);\n\t}\n\n\t@Override\n\tpublic String[] getColumnNames() {\n\t\treturn null;\n\t}\n}", "item_id": 0, "repo": "mikeyhuang/VarNote", "file": "src/main/java/org/mulinlab/varnote/utils/database/index/TbiIndex.java", "last_update_at": "2022-03-26T19:53:05+00:00", "question_id": "ce6dc5a582b585ce72817a1ced6012c5be5bca7c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class TbiIndex extends Index{\n\t\n\tprivate TIndex[] mIndex;\n\t\n\tpublic void readMagic() throws IOException {\n\t\tbyte[] buf = new byte[4];\n        is.read(buf, 0, 4); // read \"TBI\\1\"\n    }\n\t\n\tpublic void readFormat() throws IOException {\n\t\tmSeq = new String[GlobalParameter.readInt(is)]; // # sequences\n\t\tmChr2tid = new HashMap<String, Integer>();\n\t\tmTid2chr = new HashMap<Integer, String>();\n\t\tmPreset = GlobalParameter.readInt(is);\n\t\tmSc = GlobalParameter.readInt(is);\n\t\tmBc = GlobalParameter.readInt(is);\n\t\tmEc = GlobalParameter.readInt(is);\n\t\tmMeta = GlobalParameter.readInt(is);\n\t\tmSkip = GlobalParameter.readInt(is); // read skip\n\t}\n\t\n\tpublic TbiIndex(String indexPath) {\n\t\tsuper(indexPath, true);\n\t\ttry {\n\t\t\tread();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic void read() throws IOException {\n\t\tsuper.read();\n\t\tif((mPreset & 0xffff) == 2) {\n\t\t\tthis.format = Format.newVCF();\n\t\t\tthis.format.numHeaderLinesToSkip = mSkip;\n\t\t} else {\n\t\t\tthis.format = new Format(mPreset, mSc, mBc, mEc, mSkip, Character.toString((char) mMeta), -1, -1, false);\n\t\t}\n\t}\n\t\n\tpublic void readIndex() throws IOException {\n\t\tmIndex = new TIndex[mSeq.length];\n\t\tint i, j, k;\n\t\tfor (i = 0; i < mSeq.length; ++i) {\n\t\t\tint n_bin = GlobalParameter.readInt(is);\n\t\t\tmIndex[i] = new TIndex();\n\t\t\tmIndex[i].b = new HashMap<Integer, TPair64[]>(n_bin);\n\t\t\tfor (j = 0; j < n_bin; ++j) {\n\t\t\t\tint bin = GlobalParameter.readInt(is);\n\t\t\t\tTPair64[] chunks = new TPair64[GlobalParameter.readInt(is)];\n\t\t\t\tfor (k = 0; k < chunks.length; ++k) {\n\t\t\t\t\tlong u = GlobalParameter.readLong(is, buf);\n\t\t\t\t\tlong v = GlobalParameter.readLong(is, buf);\n\t\t\t\t\tchunks[k] = new TPair64(u, v); // in C, this is inefficient\n\t\t\t\t}\n\t\t\t\tmIndex[i].b.put(bin, chunks);\n\t\t\t}\n\t\t\t\n\t\t\t// the linear index\n\t\t\tmIndex[i].l = new long[GlobalParameter.readInt(is)];\n\t\t\tfor (k = 0; k < mIndex[i].l.length; ++k) {\n\t\t\t\tmIndex[i].l[k] = GlobalParameter.readLong(is, buf);\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tminOffForChr.put(i, 0l);\n\t\t\t\t} else {\n\t\t\t\t\tif (mIndex[i].l[k] > 0) {\n\t\t\t\t\t\tif (minOffForChr.get(i) == null) {\n\t\t\t\t\t\t\tminOffForChr.put(i, mIndex[i].l[k]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (mIndex[i].l[k] < minOffForChr.get(i)) {\n\t\t\t\t\t\t\t\tminOffForChr.put(i, mIndex[i].l[k]);\n\t\t\t\t\t\t\t\tthrow new InvalidArgumentException(\"That is  impossible! in SweepReader read index.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic TIndex[] getmIndex() {\n\t\treturn mIndex;\n\t}\n\tpublic static void main(String[] args) {\n\t\tTbiIndex index  = new TbiIndex(\"ALL.chr1.phase3_shapeit2_mvncall_integrated_v3plus_nounphased.rsID.genotypes.GRCh38_dbSNP.vcf.gz.tbi\");\n\t\t\n\t\tSystem.out.println(index.mSc);\n\t\tSystem.out.println(index.mBc);\n\t\tSystem.out.println(index.mEc);\n\t\tSystem.out.println(index.mPreset);\n\t}\n\t@Override\n\tpublic String[] getColumnNames() {\n\t\treturn null;\n\t}\n"]], "pred": {"ppl": 2.116065740585327, "ppl_lower": 2.333599090576172, "ppl/lowercase_ppl": -1.1305477255415808, "ppl/zlib": 0.0007172809395626718, "Min_5.0% Prob": 6.7895601122987035, "Min_10.0% Prob": 5.24484054481282, "Min_20.0% Prob": 3.43279504746783, "Min_30.0% Prob": 2.437050660159074, "Min_40.0% Prob": 1.858306741674401, "Min_50.0% Prob": 1.4960201176834782, "Min_60.0% Prob": 1.2496634068083}}
{"hexsha": "9f18838ea34795383f96a3aed3403aa73d15789e", "ext": "java", "lang": "Java", "content": "public class TabCompleter implements org.bukkit.command.TabCompleter {\n\n\tprivate static final List<String> COMMANDS = Arrays.asList(\"reload\");\n\npublic List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {\n        final List<String> completions = new ArrayList<>();\n        StringUtil.copyPartialMatches(args[0], COMMANDS, completions);\n        Collections.sort(completions);\n        return completions;\n    }\n}", "item_id": 0, "repo": "AWmeister546/knockout", "file": "plugin/src/main/java/me/smaks6/plugin/commands/tabcomplete/TabCompleter.java", "last_update_at": "2022-01-13T17:43:29+00:00", "question_id": "9f18838ea34795383f96a3aed3403aa73d15789e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TabCompleter implements org.bukkit.command.TabCompleter {\n\tprivate static final List<String> COMMANDS = Arrays.asList(\"reload\");\npublic List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {\n        final List<String> completions = new ArrayList<>();\n        StringUtil.copyPartialMatches(args[0], COMMANDS, completions);\n        Collections.sort(completions);\n        return completions;\n    }\n"]], "pred": {"ppl": 1.8806661367416382, "ppl_lower": 3.9735755920410156, "ppl/lowercase_ppl": -2.184308831844209, "ppl/zlib": 0.0024965456210931237, "Min_5.0% Prob": 6.517973979314168, "Min_10.0% Prob": 4.788500905036926, "Min_20.0% Prob": 2.8444761657714843, "Min_30.0% Prob": 2.067703640138781, "Min_40.0% Prob": 1.5673390699923038, "Min_50.0% Prob": 1.2693956583257644, "Min_60.0% Prob": 1.0514679334809383}}
{"hexsha": "7b9661fa862d71c1346c5fffebf199796071b814", "ext": "java", "lang": "Java", "content": "public class ReorganizeStringTest {\n\n    private final ReorganizeString testObject = new ReorganizeString();\n\n    @Test\n    public void testReorganizeString() {\n        String s = \"aab\";\n        assertEquals(\"aba\", testObject.reorganizeString(s));\n\n        s = \"aaab\";\n        assertEquals(\"\", testObject.reorganizeString(s));\n    }\n}", "item_id": 0, "repo": "ani03sha/OnlineJudge", "file": "LeetCode/src/test/java/org/redquark/onlinejudges/leetcode/heap/ReorganizeStringTest.java", "last_update_at": "2022-03-14T10:44:52+00:00", "question_id": "7b9661fa862d71c1346c5fffebf199796071b814_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ReorganizeStringTest {\n    private final ReorganizeString testObject = new ReorganizeString();\n    @Test\n    public void testReorganizeString() {\n        String s = \"aab\";\n        assertEquals(\"aba\", testObject.reorganizeString(s));\n        s = \"aaab\";\n        assertEquals(\"\", testObject.reorganizeString(s));\n    }\n"]], "pred": {"ppl": 1.6463005542755127, "ppl_lower": 2.356098175048828, "ppl/lowercase_ppl": -1.7190655770745304, "ppl/zlib": 0.00317535466465805, "Min_5.0% Prob": 6.629748225212097, "Min_10.0% Prob": 4.066551698578729, "Min_20.0% Prob": 2.3988708336102333, "Min_30.0% Prob": 1.6508300607574398, "Min_40.0% Prob": 1.245799311556113, "Min_50.0% Prob": 0.9952565001665937, "Min_60.0% Prob": 0.8417891746001511}}
{"hexsha": "ede52d42fa146366dea9ca2a2ef82e8c516028e3", "ext": "java", "lang": "Java", "content": "public class PlayerCounter {\n    private Label botText, peopleText;\n    private int bots, people;\n    private boolean square;\n\n    public PlayerCounter(Label botText, Label peopleText, boolean square) {\n        this.botText = botText;\n        this.peopleText = peopleText;\n\n        this.people = 1;\n        this.bots = 1;\n        this.square = square;\n    }\n\n    public void update(int bots, int people, boolean square){\n        if(people <= 0) return;\n        if(bots <= 0) return;\n        if(square){\n            if(people + bots > 4)\n                if(!this.square){bots = 1; people = 1;} //too much players!\n                else return;\n        }\n        else{\n            if(people + bots > 6) return; //too much players!\n        }\n\n        botText.setText(bots);\n        peopleText.setText(people);\n\n        this.bots = bots;\n        this.people = people;\n        this.square = square;\n    }\n\n    public Label getBotText() {\n        return botText;\n    }\n\n    public Label getPeopleText() {\n        return peopleText;\n    }\n\n    public int getBots() {\n        return bots;\n    }\n\n    public int getPeople() {\n        return people;\n    }\n\n    public boolean isSquare() {\n        return square;\n    }\n}", "item_id": 0, "repo": "mmelnizky/Halma-1", "file": "core/src/rocks/poopjournal/halma/redesign/PlayerCounter.java", "last_update_at": "2022-02-26T17:39:21+00:00", "question_id": "ede52d42fa146366dea9ca2a2ef82e8c516028e3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PlayerCounter {\n    private Label botText, peopleText;\n    private int bots, people;\n    private boolean square;\n    public PlayerCounter(Label botText, Label peopleText, boolean square) {\n        this.botText = botText;\n        this.peopleText = peopleText;\n        this.people = 1;\n        this.bots = 1;\n        this.square = square;\n    }\n    public void update(int bots, int people, boolean square){\n        if(people <= 0) return;\n        if(bots <= 0) return;\n        if(square){\n            if(people + bots > 4)\n                if(!this.square){bots = 1; people = 1;} //too much players!\n                else return;\n        }\n        else{\n            if(people + bots > 6) return; //too much players!\n        }\n        botText.setText(bots);\n        peopleText.setText(people);\n        this.bots = bots;\n        this.people = people;\n        this.square = square;\n    }\n    public Label getBotText() {\n        return botText;\n    }\n    public Label getPeopleText() {\n        return peopleText;\n    }\n    public int getBots() {\n        return bots;\n    }\n    public int getPeople() {\n        return people;\n    }\n    public boolean isSquare() {\n        return square;\n    }\n"]], "pred": {"ppl": 1.8569653034210205, "ppl_lower": 1.9721108675003052, "ppl/lowercase_ppl": -1.0971992886789501, "ppl/zlib": 0.0017888543294377834, "Min_5.0% Prob": 6.389926155408223, "Min_10.0% Prob": 4.541197647651036, "Min_20.0% Prob": 2.838367434397136, "Min_30.0% Prob": 2.0200885889727043, "Min_40.0% Prob": 1.5348610633550441, "Min_50.0% Prob": 1.2382626887308537, "Min_60.0% Prob": 1.0308744636742764}}
{"hexsha": "ee1daddd0b9026a345a6b60439b4b644bd27a360", "ext": "java", "lang": "Java", "content": "public class NamedQueriesBeanDefinitionBuilder {\n\n\tprivate final String defaultLocation;\n\tprivate String locations;\n\n\t/**\n\t * Creates a new {@link NamedQueriesBeanDefinitionBuilder} using the given default location.\n\t *\n\t * @param defaultLocation must not be {@literal null} or empty.\n\t */\n\t@SuppressWarnings(\"null\")\n\tpublic NamedQueriesBeanDefinitionBuilder(String defaultLocation) {\n\n\t\tAssert.hasText(defaultLocation, \"DefaultLocation must not be null nor empty!\");\n\t\tthis.defaultLocation = defaultLocation;\n\t}\n\n\t/**\n\t * Sets the (comma-separated) locations to load the properties files from to back the {@link NamedQueries} instance.\n\t *\n\t * @param locations must not be {@literal null} or empty.\n\t */\n\tpublic void setLocations(String locations) {\n\n\t\tAssert.hasText(locations, \"Locations must not be null nor empty!\");\n\n\t\tthis.locations = locations;\n\t}\n\n\t/**\n\t * Builds a new {@link BeanDefinition} from the given source.\n\t *\n\t * @param source\n\t * @return\n\t */\n\tpublic BeanDefinition build(@Nullable Object source) {\n\n\t\tBeanDefinitionBuilder properties = BeanDefinitionBuilder.rootBeanDefinition(PropertiesFactoryBean.class);\n\n\t\tString locationsToUse = StringUtils.hasText(locations) ? locations : defaultLocation;\n\t\tproperties.addPropertyValue(\"locations\", locationsToUse);\n\n\t\tif (!StringUtils.hasText(locations)) {\n\t\t\tproperties.addPropertyValue(\"ignoreResourceNotFound\", true);\n\t\t}\n\n\t\tAbstractBeanDefinition propertiesDefinition = properties.getBeanDefinition();\n\t\tpropertiesDefinition.setSource(source);\n\n\t\tBeanDefinitionBuilder namedQueries = BeanDefinitionBuilder.rootBeanDefinition(PropertiesBasedNamedQueries.class);\n\t\tnamedQueries.addConstructorArgValue(propertiesDefinition);\n\n\t\tAbstractBeanDefinition namedQueriesDefinition = namedQueries.getBeanDefinition();\n\t\tnamedQueriesDefinition.setSource(source);\n\n\t\treturn namedQueriesDefinition;\n\t}\n}", "item_id": 0, "repo": "zorglube/spring-data-commons", "file": "src/main/java/org/springframework/data/repository/config/NamedQueriesBeanDefinitionBuilder.java", "last_update_at": "2022-03-14T03:23:01+00:00", "question_id": "ee1daddd0b9026a345a6b60439b4b644bd27a360_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NamedQueriesBeanDefinitionBuilder {\n\tprivate final String defaultLocation;\n\tprivate String locations;\n\t/**\n\t * Creates a new {@link NamedQueriesBeanDefinitionBuilder} using the given default location.\n\t *\n\t * @param defaultLocation must not be {@literal null} or empty.\n\t */\n\t@SuppressWarnings(\"null\")\n\tpublic NamedQueriesBeanDefinitionBuilder(String defaultLocation) {\n\t\tAssert.hasText(defaultLocation, \"DefaultLocation must not be null nor empty!\");\n\t\tthis.defaultLocation = defaultLocation;\n\t}\n\t/**\n\t * Sets the (comma-separated) locations to load the properties files from to back the {@link NamedQueries} instance.\n\t *\n\t * @param locations must not be {@literal null} or empty.\n\t */\n\tpublic void setLocations(String locations) {\n\t\tAssert.hasText(locations, \"Locations must not be null nor empty!\");\n\t\tthis.locations = locations;\n\t}\n\t/**\n\t * Builds a new {@link BeanDefinition} from the given source.\n\t *\n\t * @param source\n\t * @return\n\t */\n\tpublic BeanDefinition build(@Nullable Object source) {\n\t\tBeanDefinitionBuilder properties = BeanDefinitionBuilder.rootBeanDefinition(PropertiesFactoryBean.class);\n\t\tString locationsToUse = StringUtils.hasText(locations) ? locations : defaultLocation;\n\t\tproperties.addPropertyValue(\"locations\", locationsToUse);\n\t\tif (!StringUtils.hasText(locations)) {\n\t\t\tproperties.addPropertyValue(\"ignoreResourceNotFound\", true);\n\t\t}\n\t\tAbstractBeanDefinition propertiesDefinition = properties.getBeanDefinition();\n\t\tpropertiesDefinition.setSource(source);\n\t\tBeanDefinitionBuilder namedQueries = BeanDefinitionBuilder.rootBeanDefinition(PropertiesBasedNamedQueries.class);\n\t\tnamedQueries.addConstructorArgValue(propertiesDefinition);\n\t\tAbstractBeanDefinition namedQueriesDefinition = namedQueries.getBeanDefinition();\n\t\tnamedQueriesDefinition.setSource(source);\n\t\treturn namedQueriesDefinition;\n\t}\n"]], "pred": {"ppl": 1.6081072092056274, "ppl_lower": 2.0928428173065186, "ppl/lowercase_ppl": -1.554596678105662, "ppl/zlib": 0.0007852195717782296, "Min_5.0% Prob": 5.503189105987548, "Min_10.0% Prob": 3.7604492832632626, "Min_20.0% Prob": 2.249472916704937, "Min_30.0% Prob": 1.5582361425122908, "Min_40.0% Prob": 1.1823694832658997, "Min_50.0% Prob": 0.9488706471448815, "Min_60.0% Prob": 0.7935177454672333}}
{"hexsha": "851b85e6a3f156eb8ab512df1acc07ee0706e6b3", "ext": "java", "lang": "Java", "content": "public class Gossiper {\n    private static final Logger log = LoggerFactory.getLogger(Gossiper.class);\n\n    private final Orderer                   orderer;\n    private final List<BloomFilter<Digest>> biffs;\n    private final Lock                      mx = new ReentrantLock();\n\n    public Gossiper(Controller controller) {\n        this(controller.orderer());\n    }\n\n    public Gossiper(Orderer orderer) {\n        this.orderer = orderer;\n        biffs = new ArrayList<>();\n        Config config = orderer.getConfig();\n        int count = Math.max(4, config.nProc()); \n        for (int i = 0; i < count; i++) {\n            biffs.add(new DigestBloomFilter(Utils.bitStreamEntropy().nextLong(),\n                                            config.epochLength() * config.numberOfEpochs() * config.nProc() * 2,\n                                            config.fpr()));\n        }\n    }\n\n    public Gossip gossip() {\n        return gossip(DigestAlgorithm.DEFAULT.getOrigin());\n    }\n\n    public Gossip gossip(Digest context) {\n        log.trace(\"Gossiping for: {} on: {}\", context, orderer.getConfig().pid());\n        mx.lock();\n        try {\n            return Gossip.newBuilder().setContext(context.toDigeste())\n                         .setHave(biffs.get(Utils.bitStreamEntropy().nextInt(biffs.size())).toBff()).build();\n        } finally {\n            mx.unlock();\n        }\n    }\n\n    public Update gossip(Gossip gossip) {\n        Update update = orderer.missing(BloomFilter.from(gossip.getHave()));\n        log.trace(\"Gossip received for: {} missing: {} on: {}\", Digest.from(gossip.getContext()),\n                  update.getMissingCount(), orderer.getConfig().pid());\n        return update;\n    }\n\n    public void update(Update update) {\n        List<PreUnit> missing = update.getMissingList().stream()\n                                      .map(pus -> PreUnit.from(pus, orderer.getConfig().digestAlgorithm()))\n//                                      .filter(pu -> pu.verify(config.verifiers()))\n                                      .toList();\n        if (missing.isEmpty()) {\n            return;\n        }\n        log.trace(\"Gossip update: {} on: {}\", missing.size(), orderer.getConfig().pid());\n        mx.lock();\n        try {\n            missing.forEach(pu -> {\n                biffs.forEach(biff -> biff.add(pu.hash()));\n            });\n        } finally {\n            mx.unlock();\n        }\n        orderer.addPreunits(PreUnit.topologicalSort(new ArrayList<>(missing)));\n    }\n}", "item_id": 0, "repo": "ChiralBehaviors/apollo", "file": "ethereal/src/main/java/com/salesforce/apollo/ethereal/Gossiper.java", "last_update_at": "2022-03-12T10:33:33+00:00", "question_id": "851b85e6a3f156eb8ab512df1acc07ee0706e6b3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Gossiper {\n    private static final Logger log = LoggerFactory.getLogger(Gossiper.class);\n    private final Orderer                   orderer;\n    private final List<BloomFilter<Digest>> biffs;\n    private final Lock                      mx = new ReentrantLock();\n    public Gossiper(Controller controller) {\n        this(controller.orderer());\n    }\n    public Gossiper(Orderer orderer) {\n        this.orderer = orderer;\n        biffs = new ArrayList<>();\n        Config config = orderer.getConfig();\n        int count = Math.max(4, config.nProc()); \n        for (int i = 0; i < count; i++) {\n            biffs.add(new DigestBloomFilter(Utils.bitStreamEntropy().nextLong(),\n                                            config.epochLength() * config.numberOfEpochs() * config.nProc() * 2,\n                                            config.fpr()));\n        }\n    }\n    public Gossip gossip() {\n        return gossip(DigestAlgorithm.DEFAULT.getOrigin());\n    }\n    public Gossip gossip(Digest context) {\n        log.trace(\"Gossiping for: {} on: {}\", context, orderer.getConfig().pid());\n        mx.lock();\n        try {\n            return Gossip.newBuilder().setContext(context.toDigeste())\n                         .setHave(biffs.get(Utils.bitStreamEntropy().nextInt(biffs.size())).toBff()).build();\n        } finally {\n            mx.unlock();\n        }\n    }\n    public Update gossip(Gossip gossip) {\n        Update update = orderer.missing(BloomFilter.from(gossip.getHave()));\n        log.trace(\"Gossip received for: {} missing: {} on: {}\", Digest.from(gossip.getContext()),\n                  update.getMissingCount(), orderer.getConfig().pid());\n        return update;\n    }\n    public void update(Update update) {\n        List<PreUnit> missing = update.getMissingList().stream()\n                                      .map(pus -> PreUnit.from(pus, orderer.getConfig().digestAlgorithm()))\n//                                      .filter(pu -> pu.verify(config.verifiers()))\n                                      .toList();\n        if (missing.isEmpty()) {\n            return;\n        }\n        log.trace(\"Gossip update: {} on: {}\", missing.size(), orderer.getConfig().pid());\n        mx.lock();\n        try {\n            missing.forEach(pu -> {\n                biffs.forEach(biff -> biff.add(pu.hash()));\n            });\n        } finally {\n            mx.unlock();\n        }\n        orderer.addPreunits(PreUnit.topologicalSort(new ArrayList<>(missing)));\n    }\n"]], "pred": {"ppl": 2.327688217163086, "ppl_lower": 2.780693292617798, "ppl/lowercase_ppl": -1.210474406213882, "ppl/zlib": 0.0010341194535675407, "Min_5.0% Prob": 7.515429755619594, "Min_10.0% Prob": 5.679144432846929, "Min_20.0% Prob": 3.6855738204675954, "Min_30.0% Prob": 2.6851900128003594, "Min_40.0% Prob": 2.0771452637610737, "Min_50.0% Prob": 1.681584296304555, "Min_60.0% Prob": 1.4052906244263783}}
{"hexsha": "882a1296db27426c0da0b3e0cd41386ad5204be5", "ext": "java", "lang": "Java", "content": "public class JlineReplTest {\n  private static ReplParser parser;\n  private static JlineRepl repl;\n\n  @BeforeAll public static void setup() throws IOException {\n    repl = new JlineRepl(ImmutableSeq.empty(), PlainReplTest.config);\n    parser = new ReplParser(repl.commandManager, repl);\n  }\n\n  @Test public void sanity() {\n    assertEquals(\"\", repl.renderDoc(Doc.empty()));\n  }\n\n  @Test public void command() {\n    assertEquals(List.of(\":type\", \"Type\"), parser.parse(\":type Type\", 2).words());\n  }\n\n  @Test public void shellLike() {\n    // Different lexing strategy depending on the prefix\n    assertEquals(List.of(\":cd\", \"../oh/my/./kiva\"), parser.parse(\":cd ../oh/my/./kiva\", 2).words());\n    assertEquals(List.of(\":type\", \".\", \"/\"), parser.parse(\":type ./\", 2).words());\n  }\n\n  @Test public void shellLike2() {\n    // Different lexing strategy depending on the prefix\n    assertEquals(List.of(\":cd\", \"(Ty\"), parser.parse(\":cd (Ty\", 2).words());\n    assertEquals(List.of(\":type\", \"(\", \"Ty\"), parser.parse(\":type (Ty\", 2).words());\n  }\n\n  @Test public void sucZero() {\n    assertEquals(List.of(\"suc\", \"zero\"), parser.parse(\"suc zero\", 2).words());\n  }\n\n  @Test public void ws() {\n    assertEquals(\"zero\", parser.parse(\"suc     zero\", 5).word());\n    assertEquals(\"\", parser.parse(\"suc  zero      \", 12).word());\n  }\n\n  @Test public void parenTyCode() {\n    var line = parser.parse(\"(Ty\", 2);\n    var candidates = new ArrayList<Candidate>();\n    new AyaCompleters.Code(repl).complete(repl.lineReader, line, candidates);\n    assertFalse(candidates.isEmpty());\n    assertTrue(candidates.stream().anyMatch(c -> \"Type\".equals(c.value())));\n  }\n\n  @Test public void sucZeroIx() {\n    assertEquals(0, parser.parse(\"suc zero\", 0).wordIndex());\n    assertEquals(0, parser.parse(\"suc zero\", 1).wordIndex());\n    assertEquals(0, parser.parse(\"suc zero\", 2).wordIndex());\n    assertEquals(0, parser.parse(\"suc zero\", 3).wordIndex());\n    assertEquals(1, parser.parse(\"suc zero\", 4).wordIndex());\n    assertEquals(1, parser.parse(\"suc zero\", 5).wordIndex());\n    assertEquals(1, parser.parse(\"suc zero\", 6).wordIndex());\n    assertEquals(1, parser.parse(\"suc zero\", 7).wordIndex());\n    var lastToken = parser.parse(\"suc zero\", 8);\n    assertEquals(1, lastToken.wordIndex());\n    assertEquals(\"zero\", lastToken.word());\n  }\n}", "item_id": 0, "repo": "refparo/aya-dev", "file": "cli/src/test/java/org/aya/cli/JlineReplTest.java", "last_update_at": "2022-03-30T16:28:14+00:00", "question_id": "882a1296db27426c0da0b3e0cd41386ad5204be5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JlineReplTest {\n  private static ReplParser parser;\n  private static JlineRepl repl;\n  @BeforeAll public static void setup() throws IOException {\n    repl = new JlineRepl(ImmutableSeq.empty(), PlainReplTest.config);\n    parser = new ReplParser(repl.commandManager, repl);\n  }\n  @Test public void sanity() {\n    assertEquals(\"\", repl.renderDoc(Doc.empty()));\n  }\n  @Test public void command() {\n    assertEquals(List.of(\":type\", \"Type\"), parser.parse(\":type Type\", 2).words());\n  }\n  @Test public void shellLike() {\n    // Different lexing strategy depending on the prefix\n    assertEquals(List.of(\":cd\", \"../oh/my/./kiva\"), parser.parse(\":cd ../oh/my/./kiva\", 2).words());\n    assertEquals(List.of(\":type\", \".\", \"/\"), parser.parse(\":type ./\", 2).words());\n  }\n  @Test public void shellLike2() {\n    // Different lexing strategy depending on the prefix\n    assertEquals(List.of(\":cd\", \"(Ty\"), parser.parse(\":cd (Ty\", 2).words());\n    assertEquals(List.of(\":type\", \"(\", \"Ty\"), parser.parse(\":type (Ty\", 2).words());\n  }\n  @Test public void sucZero() {\n    assertEquals(List.of(\"suc\", \"zero\"), parser.parse(\"suc zero\", 2).words());\n  }\n  @Test public void ws() {\n    assertEquals(\"zero\", parser.parse(\"suc     zero\", 5).word());\n    assertEquals(\"\", parser.parse(\"suc  zero      \", 12).word());\n  }\n  @Test public void parenTyCode() {\n    var line = parser.parse(\"(Ty\", 2);\n    var candidates = new ArrayList<Candidate>();\n    new AyaCompleters.Code(repl).complete(repl.lineReader, line, candidates);\n    assertFalse(candidates.isEmpty());\n    assertTrue(candidates.stream().anyMatch(c -> \"Type\".equals(c.value())));\n  }\n  @Test public void sucZeroIx() {\n    assertEquals(0, parser.parse(\"suc zero\", 0).wordIndex());\n    assertEquals(0, parser.parse(\"suc zero\", 1).wordIndex());\n    assertEquals(0, parser.parse(\"suc zero\", 2).wordIndex());\n    assertEquals(0, parser.parse(\"suc zero\", 3).wordIndex());\n    assertEquals(1, parser.parse(\"suc zero\", 4).wordIndex());\n    assertEquals(1, parser.parse(\"suc zero\", 5).wordIndex());\n    assertEquals(1, parser.parse(\"suc zero\", 6).wordIndex());\n    assertEquals(1, parser.parse(\"suc zero\", 7).wordIndex());\n    var lastToken = parser.parse(\"suc zero\", 8);\n    assertEquals(1, lastToken.wordIndex());\n    assertEquals(\"zero\", lastToken.word());\n  }\n"]], "pred": {"ppl": 2.294598340988159, "ppl_lower": 2.5017566680908203, "ppl/lowercase_ppl": -1.1040690215513, "ppl/zlib": 0.0012896860456143688, "Min_5.0% Prob": 7.71775632155569, "Min_10.0% Prob": 5.843445824338244, "Min_20.0% Prob": 3.7700054943561554, "Min_30.0% Prob": 2.6895612527070374, "Min_40.0% Prob": 2.0616829086179487, "Min_50.0% Prob": 1.656432183170619, "Min_60.0% Prob": 1.384073236826727}}
{"hexsha": "558dd50cbac15bc958917bfc817abee9cfe9c414", "ext": "java", "lang": "Java", "content": "@RunWith(AndroidJUnit4.class)\npublic class CardedAwardListElementTest {\n\n    private static final int WIDTH_DP = 400;\n    private static final List<IAwardRecipient> SINGLE_TEAM = new ArrayList<>();\n    private static final List<IAwardRecipient> MULTI_TEAM = new ArrayList<>();\n    private static final List<IAwardRecipient> INDIVIDUAL = new ArrayList<>();\n    private static final List<IAwardRecipient> INDIVIDUAL_NO_TEAM = new ArrayList<>();\n    private static final List<IAwardRecipient> MULTI_INDIVIDUAL = new ArrayList<>();\n    private static final Map<String, Team> TEAM_MAP = new HashMap<>();\n\n    static {\n        SINGLE_TEAM.add(buildWinnerDict(null, \"frc1124\"));\n        MULTI_TEAM.add(buildWinnerDict(null, \"frc1124\"));\n        MULTI_TEAM.add(buildWinnerDict(null, \"frc254\"));\n        INDIVIDUAL.add(buildWinnerDict(\"Foo Bar\", \"frc1124\"));\n        INDIVIDUAL_NO_TEAM.add(buildWinnerDict(\"Foo Bar\",  null));\n        MULTI_INDIVIDUAL.add(buildWinnerDict(\"Foo Bar\", \"frc1124\"));\n        MULTI_INDIVIDUAL.add(buildWinnerDict(\"Foo Baz\", \"frc254\"));\n\n        Team team = ModelMaker.getModel(Team.class, \"frc1124\");\n        TEAM_MAP.put(\"frc1124\", team);\n        TEAM_MAP.put(\"frc254\", team);\n    }\n\n    @Test\n    public void testRenderSingleTeam() {\n        View view = getView(null, \"Test Award\", \"2016test\", SINGLE_TEAM, TEAM_MAP, null);\n        ViewHelpers.setupView(view)\n                   .setExactWidthDp(WIDTH_DP)\n                   .layout();\n\n        Screenshot.snap(view)\n                  .record();\n    }\n\n    @Test\n    public void testRenderSelectedTeam() {\n        View view = getView(null, \"Test Award\", \"2016test\", SINGLE_TEAM, TEAM_MAP, \"1124\");\n        ViewHelpers.setupView(view)\n                   .setExactWidthDp(WIDTH_DP)\n                   .layout();\n\n        Screenshot.snap(view)\n                  .record();\n    }\n\n    @Test\n    public void testRenderMultiWinner() {\n        View view = getView(null, \"Test Award\", \"2016test\", MULTI_TEAM, TEAM_MAP, null);\n        ViewHelpers.setupView(view)\n                   .setExactWidthDp(WIDTH_DP)\n                   .layout();\n\n        Screenshot.snap(view)\n                  .record();\n    }\n\n    @Test\n    public void testRenderIndividual() {\n        View view = getView(null, \"Test Award\", \"2016test\", INDIVIDUAL, TEAM_MAP, null);\n        ViewHelpers.setupView(view)\n                   .setExactWidthDp(WIDTH_DP)\n                   .layout();\n\n        Screenshot.snap(view)\n                  .record();\n    }\n\n    @Test\n    public void testRenderIndividualNoTeam() {\n        View view = getView(null, \"Test Award\", \"2016test\", INDIVIDUAL_NO_TEAM, TEAM_MAP, null);\n        ViewHelpers.setupView(view)\n                   .setExactWidthDp(WIDTH_DP)\n                   .layout();\n\n        Screenshot.snap(view)\n                  .record();\n    }\n\n    @Test\n    public void testRenderMultiIndividual() {\n        View view = getView(null, \"Test Award\", \"2016test\", MULTI_INDIVIDUAL, TEAM_MAP, null);\n        ViewHelpers.setupView(view)\n                   .setExactWidthDp(WIDTH_DP)\n                   .layout();\n\n        Screenshot.snap(view)\n                  .record();\n    }\n\n    private View getView(\n            APICache datafeed,\n            String name,\n            String eventKey,\n            List<IAwardRecipient> winners,\n            Map<String, Team> teams,\n            String selectedTeamKey) {\n        CardedAwardListElement element = new CardedAwardListElement(datafeed, name, eventKey,\n                                                                    winners, teams,\n                                                                    selectedTeamKey);\n        Context targetContext = InstrumentationRegistry.getTargetContext();\n        LayoutInflater inflater = LayoutInflater.from(targetContext);\n        return element.getView(targetContext, inflater, null);\n    }\n\n    private static IAwardRecipient buildWinnerDict(String awardee, String teamKey) {\n        Award.AwardRecipient winner = new Award.AwardRecipient();\n        if (awardee != null) winner.setAwardee(awardee);\n        if (teamKey != null) winner.setTeamKey(teamKey);\n        return winner;\n    }\n}", "item_id": 0, "repo": "Teityan/the-blue-alliance-android", "file": "android/src/androidTest/java/com/thebluealliance/androidclient/listitems/CardedAwardListElementTest.java", "last_update_at": "2022-03-28T15:14:00+00:00", "question_id": "558dd50cbac15bc958917bfc817abee9cfe9c414_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(AndroidJUnit4.class)\npublic class CardedAwardListElementTest {\n    private static final int WIDTH_DP = 400;\n    private static final List<IAwardRecipient> SINGLE_TEAM = new ArrayList<>();\n    private static final List<IAwardRecipient> MULTI_TEAM = new ArrayList<>();\n    private static final List<IAwardRecipient> INDIVIDUAL = new ArrayList<>();\n    private static final List<IAwardRecipient> INDIVIDUAL_NO_TEAM = new ArrayList<>();\n    private static final List<IAwardRecipient> MULTI_INDIVIDUAL = new ArrayList<>();\n    private static final Map<String, Team> TEAM_MAP = new HashMap<>();\n    static {\n        SINGLE_TEAM.add(buildWinnerDict(null, \"frc1124\"));\n        MULTI_TEAM.add(buildWinnerDict(null, \"frc1124\"));\n        MULTI_TEAM.add(buildWinnerDict(null, \"frc254\"));\n        INDIVIDUAL.add(buildWinnerDict(\"Foo Bar\", \"frc1124\"));\n        INDIVIDUAL_NO_TEAM.add(buildWinnerDict(\"Foo Bar\",  null));\n        MULTI_INDIVIDUAL.add(buildWinnerDict(\"Foo Bar\", \"frc1124\"));\n        MULTI_INDIVIDUAL.add(buildWinnerDict(\"Foo Baz\", \"frc254\"));\n        Team team = ModelMaker.getModel(Team.class, \"frc1124\");\n        TEAM_MAP.put(\"frc1124\", team);\n        TEAM_MAP.put(\"frc254\", team);\n    }\n    @Test\n    public void testRenderSingleTeam() {\n        View view = getView(null, \"Test Award\", \"2016test\", SINGLE_TEAM, TEAM_MAP, null);\n        ViewHelpers.setupView(view)\n                   .setExactWidthDp(WIDTH_DP)\n                   .layout();\n        Screenshot.snap(view)\n                  .record();\n    }\n    @Test\n    public void testRenderSelectedTeam() {\n        View view = getView(null, \"Test Award\", \"2016test\", SINGLE_TEAM, TEAM_MAP, \"1124\");\n        ViewHelpers.setupView(view)\n                   .setExactWidthDp(WIDTH_DP)\n                   .layout();\n        Screenshot.snap(view)\n                  .record();\n    }\n    @Test\n    public void testRenderMultiWinner() {\n        View view = getView(null, \"Test Award\", \"2016test\", MULTI_TEAM, TEAM_MAP, null);\n        ViewHelpers.setupView(view)\n                   .setExactWidthDp(WIDTH_DP)\n                   .layout();\n        Screenshot.snap(view)\n                  .record();\n    }\n    @Test\n    public void testRenderIndividual() {\n        View view = getView(null, \"Test Award\", \"2016test\", INDIVIDUAL, TEAM_MAP, null);\n        ViewHelpers.setupView(view)\n                   .setExactWidthDp(WIDTH_DP)\n                   .layout();\n        Screenshot.snap(view)\n                  .record();\n    }\n    @Test\n    public void testRenderIndividualNoTeam() {\n        View view = getView(null, \"Test Award\", \"2016test\", INDIVIDUAL_NO_TEAM, TEAM_MAP, null);\n        ViewHelpers.setupView(view)\n                   .setExactWidthDp(WIDTH_DP)\n                   .layout();\n        Screenshot.snap(view)\n                  .record();\n    }\n    @Test\n    public void testRenderMultiIndividual() {\n        View view = getView(null, \"Test Award\", \"2016test\", MULTI_INDIVIDUAL, TEAM_MAP, null);\n        ViewHelpers.setupView(view)\n                   .setExactWidthDp(WIDTH_DP)\n                   .layout();\n        Screenshot.snap(view)\n                  .record();\n    }\n    private View getView(\n            APICache datafeed,\n            String name,\n            String eventKey,\n            List<IAwardRecipient> winners,\n            Map<String, Team> teams,\n            String selectedTeamKey) {\n        CardedAwardListElement element = new CardedAwardListElement(datafeed, name, eventKey,\n                                                                    winners, teams,\n                                                                    selectedTeamKey);\n        Context targetContext = InstrumentationRegistry.getTargetContext();\n        LayoutInflater inflater = LayoutInflater.from(targetContext);\n        return element.getView(targetContext, inflater, null);\n    }\n    private static IAwardRecipient buildWinnerDict(String awardee, String teamKey) {\n        Award.AwardRecipient winner = new Award.AwardRecipient();\n        if (awardee != null) winner.setAwardee(awardee);\n        if (teamKey != null) winner.setTeamKey(teamKey);\n        return winner;\n    }\n"]], "pred": {"ppl": 1.406565546989441, "ppl_lower": 1.6350483894348145, "ppl/lowercase_ppl": -1.4412165605487994, "ppl/zlib": 0.00042750745710453975, "Min_5.0% Prob": 5.242894037097108, "Min_10.0% Prob": 3.136617277182785, "Min_20.0% Prob": 1.6888260054675972, "Min_30.0% Prob": 1.1367871236768277, "Min_40.0% Prob": 0.8524306543794186, "Min_50.0% Prob": 0.6827112904167962, "Min_60.0% Prob": 0.5692538990260089}}
{"hexsha": "f91046b4c380f8846b75378c46037baabe9fc5c2", "ext": "java", "lang": "Java", "content": "@Configuration\npublic class KaptchaConfig {\n\n    @Bean\n    public Producer kaptchaProducer(){\n        Properties properties = new Properties();\n        properties.setProperty(\"kaptcha.image.width\",\"100\");\n        properties.setProperty(\"kaptcha.image.height\",\"40\");\n        properties.setProperty(\"kaptcha.textproducer.font.size\",\"32\");\n        properties.setProperty(\"kaptcha.textproducer.font.color\",\"0,0,0\");\n        properties.setProperty(\"kaptcha.textproducer.char.string\",\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\");\n        properties.setProperty(\"kaptcha.textproducer.char.length\",\"4\");\n        properties.setProperty(\"kaptcha.noise.impl\",\"com.google.code.kaptcha.impl.NoNoise\");\n\n\n        DefaultKaptcha defaultKaptcha = new DefaultKaptcha();\n        Config config = new Config(properties);\n        defaultKaptcha.setConfig(config);\n        return defaultKaptcha;\n    }\n\n}", "item_id": 0, "repo": "RournasHike/nowcoder-forum", "file": "src/main/java/com/nowcoder/community/config/KaptchaConfig.java", "last_update_at": "2022-02-08T08:41:34+00:00", "question_id": "f91046b4c380f8846b75378c46037baabe9fc5c2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Configuration\npublic class KaptchaConfig {\n    @Bean\n    public Producer kaptchaProducer(){\n        Properties properties = new Properties();\n        properties.setProperty(\"kaptcha.image.width\",\"100\");\n        properties.setProperty(\"kaptcha.image.height\",\"40\");\n        properties.setProperty(\"kaptcha.textproducer.font.size\",\"32\");\n        properties.setProperty(\"kaptcha.textproducer.font.color\",\"0,0,0\");\n        properties.setProperty(\"kaptcha.textproducer.char.string\",\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\");\n        properties.setProperty(\"kaptcha.textproducer.char.length\",\"4\");\n        properties.setProperty(\"kaptcha.noise.impl\",\"com.google.code.kaptcha.impl.NoNoise\");\n        DefaultKaptcha defaultKaptcha = new DefaultKaptcha();\n        Config config = new Config(properties);\n        defaultKaptcha.setConfig(config);\n        return defaultKaptcha;\n    }\n"]], "pred": {"ppl": 1.3004696369171143, "ppl_lower": 1.7994121313095093, "ppl/lowercase_ppl": -2.236022429756702, "ppl/zlib": 0.0007615230678148425, "Min_5.0% Prob": 3.612819884504591, "Min_10.0% Prob": 2.3307080460446223, "Min_20.0% Prob": 1.2723039280165707, "Min_30.0% Prob": 0.8746545795570402, "Min_40.0% Prob": 0.6569565938900045, "Min_50.0% Prob": 0.5248151600582304, "Min_60.0% Prob": 0.4392210125919072}}
{"hexsha": "0c9f503a5bfd09fe39a43e15dae71bfc345de3fb", "ext": "java", "lang": "Java", "content": "@Repository\npublic class DynamicFieldRuleDao extends ACUITYDaoSupport implements IDynamicFieldRuleDao {\n\n    @Override\n    public FieldRule insertDynamicField(long mappingRuleId, String name) {\n        getJdbcTemplate().update(\"insert into MAP_DYNAMIC_FIELD(MDFI_NAME, MDFI_MMR_ID) VALUES(?, ?)\", name, mappingRuleId);\n        return getDynamicFieldByMappingRuleId(mappingRuleId);\n    }\n\n    @Override\n    public FieldRule getDynamicFieldByMappingRuleId(long mappingRuleId) {\n        List<FieldRule> fieldRules = getJdbcTemplate().query(\"select * from MAP_DYNAMIC_FIELD where MDFI_MMR_ID = ?\", ROW_MAPPER, mappingRuleId);\n        if (fieldRules.isEmpty()) {\n            return null;\n        }\n        return fieldRules.get(0);\n    }\n\n    @Override\n    public void deleteDynamicField(long mappingRuleId) {\n        getJdbcTemplate().update(\"delete from MAP_DYNAMIC_FIELD where MDFI_MMR_ID = ?\", mappingRuleId);\n    }\n\n    @Override\n    public List<FieldRule> selectAll() {\n        return getJdbcTemplate().query(\"select * from MAP_DYNAMIC_FIELD\", ROW_MAPPER);\n    }\n\n    private static final RowMapper<FieldRule> ROW_MAPPER = (rs, rowNum) -> {\n        FieldRule fieldRule = new FieldRule();\n        fieldRule.setId(rs.getLong(\"MDFI_ID\"));\n        fieldRule.setName(rs.getString(\"MDFI_NAME\"));\n        fieldRule.setType(\"String\");\n        fieldRule.setMandatory(false);\n        FieldDescription fieldDescription = new FieldDescription();\n        fieldDescription.setText(rs.getString(\"MDFI_NAME\"));\n        fieldDescription.setId(rs.getLong(\"MDFI_ID\"));\n        fieldRule.setDescription(fieldDescription);\n        fieldRule.setEntityProcessOrder(999);\n        fieldRule.setOrder(new BigDecimal(999));\n        fieldRule.setDynamic(true);\n        return fieldRule;\n    };\n}", "item_id": 0, "repo": "digital-ECMT/acuity-admin", "file": "acuity-etl/src/main/java/com/acuity/visualisations/mapping/dao/impl/DynamicFieldRuleDao.java", "last_update_at": "2022-01-26T14:52:56+00:00", "question_id": "0c9f503a5bfd09fe39a43e15dae71bfc345de3fb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Repository\npublic class DynamicFieldRuleDao extends ACUITYDaoSupport implements IDynamicFieldRuleDao {\n    @Override\n    public FieldRule insertDynamicField(long mappingRuleId, String name) {\n        getJdbcTemplate().update(\"insert into MAP_DYNAMIC_FIELD(MDFI_NAME, MDFI_MMR_ID) VALUES(?, ?)\", name, mappingRuleId);\n        return getDynamicFieldByMappingRuleId(mappingRuleId);\n    }\n    @Override\n    public FieldRule getDynamicFieldByMappingRuleId(long mappingRuleId) {\n        List<FieldRule> fieldRules = getJdbcTemplate().query(\"select * from MAP_DYNAMIC_FIELD where MDFI_MMR_ID = ?\", ROW_MAPPER, mappingRuleId);\n        if (fieldRules.isEmpty()) {\n            return null;\n        }\n        return fieldRules.get(0);\n    }\n    @Override\n    public void deleteDynamicField(long mappingRuleId) {\n        getJdbcTemplate().update(\"delete from MAP_DYNAMIC_FIELD where MDFI_MMR_ID = ?\", mappingRuleId);\n    }\n    @Override\n    public List<FieldRule> selectAll() {\n        return getJdbcTemplate().query(\"select * from MAP_DYNAMIC_FIELD\", ROW_MAPPER);\n    }\n    private static final RowMapper<FieldRule> ROW_MAPPER = (rs, rowNum) -> {\n        FieldRule fieldRule = new FieldRule();\n        fieldRule.setId(rs.getLong(\"MDFI_ID\"));\n        fieldRule.setName(rs.getString(\"MDFI_NAME\"));\n        fieldRule.setType(\"String\");\n        fieldRule.setMandatory(false);\n        FieldDescription fieldDescription = new FieldDescription();\n        fieldDescription.setText(rs.getString(\"MDFI_NAME\"));\n        fieldDescription.setId(rs.getLong(\"MDFI_ID\"));\n        fieldRule.setDescription(fieldDescription);\n        fieldRule.setEntityProcessOrder(999);\n        fieldRule.setOrder(new BigDecimal(999));\n        fieldRule.setDynamic(true);\n        return fieldRule;\n    };\n"]], "pred": {"ppl": 1.8250459432601929, "ppl_lower": 2.072439193725586, "ppl/lowercase_ppl": -1.211303218673838, "ppl/zlib": 0.001040839379077391, "Min_5.0% Prob": 6.98859167098999, "Min_10.0% Prob": 4.931698956579532, "Min_20.0% Prob": 2.870883341667787, "Min_30.0% Prob": 1.9771140686236321, "Min_40.0% Prob": 1.5002432719327754, "Min_50.0% Prob": 1.201130160395656, "Min_60.0% Prob": 1.0034301964631596}}
{"hexsha": "071b49531cc25c60f4140d15d2b50ee011ddffc1", "ext": "java", "lang": "Java", "content": "public class GenerateEventsForDemoTest {\n    private static int NUMBER_OF_SEND_COMMANDS = 58;\n    private static int NUMBER_OF_SEND_AND_WAIT_COMMANDS = 9;\n\n    private static final int NUMBER_OF_ADD_ROOM_COMMANDS = 20;\n    private static final int NUMBER_OF_PAY_COMMANDS = 9;\n    private static final int NUMBER_OF_REGISTER_ACCOUNT_COMMANDS = 9;\n    private static final int NUMBER_OF_BOOK_ROOM_COMMANDS = 5;\n    private static final int NUMBER_OF_CHECK_OUT_COMMANDS = 5;\n    private static final int NUMBER_OF_MARK_ROOM_AS_PREPARED_COMMANDS = 5;\n    private static final int NUMBER_OF_CHECK_IN_COMMANDS = 5;\n    private static final int NUMBER_OF_PROCESS_PAYMENT_COMMANDS = 9;\n\n    private CommandGateway commandGateway = mock(CommandGateway.class);\n    private RoomAvailabilityEntityRepository roomAvailabilityEntityRepository = mock(RoomAvailabilityEntityRepository.class);\n    private UUIDProvider uuidProvider = mock(UUIDProvider.class);\n    private UUID accountId = UUID.randomUUID();\n    private UUID bookingId = UUID.randomUUID();\n    private UUID paymentId = UUID.randomUUID();\n    @InjectMocks\n    private GenerateEventsForDemo generateEventsForDemo;\n\n    @BeforeEach\n    void setUp() {\n        generateEventsForDemo = new GenerateEventsForDemo(commandGateway, roomAvailabilityEntityRepository,\n                                                          uuidProvider);\n        when(uuidProvider.getAccountId()).thenReturn(accountId);\n        when(uuidProvider.getBookingId()).thenReturn(bookingId);\n        when(uuidProvider.getPaymentId()).thenReturn(paymentId);\n    }\n\n    @Test\n    void sendCommandsForBookingTest(){\n        generateEventsForDemo.sendCommandsForBooking();\n        verifySendCommands();\n        verifySendAndWaitCommands();\n    }\n\n    @Test\n    void doNotAddRoomsWhenRoomsAlreadyExist(){\n        when(roomAvailabilityEntityRepository.existsById(100)).thenReturn(true);\n        generateEventsForDemo.sendCommandsForBooking();\n        ArgumentCaptor<Object> commandSendCaptor = ArgumentCaptor.forClass(Object.class);\n        verify(commandGateway, times(38)).send(commandSendCaptor.capture());\n       assertEquals(0L, commandSendCaptor.getAllValues().stream().filter(o -> o instanceof AddRoomCommand).count());\n    }\n\n    private void verifySendCommands() {\n        ArgumentCaptor<Object> commandSendCaptor = ArgumentCaptor.forClass(Object.class);\n        verify(commandGateway, times(NUMBER_OF_SEND_COMMANDS)).send(commandSendCaptor.capture());\n\n        List<AddRoomCommand> addRoomCommandList = new ArrayList<>();\n        List<RegisterAccountCommand> registerAccountCommandList = new ArrayList<>();\n        List<BookRoomCommand> bookRoomCommandList = new ArrayList<>();\n        List<CheckOutCommand> checkOutCommandList = new ArrayList<>();\n        List<ProcessPaymentCommand> processPaymentCommands = new ArrayList<>();\n        List<MarkRoomAsPreparedCommand> markRoomAsPreparedCommandList = new ArrayList<>();\n        List<CheckInCommand> checkInCommandList = new ArrayList<>();\n\n        for (Object command : commandSendCaptor.getAllValues()){\n            if (command instanceof AddRoomCommand){\n                addRoomCommandList.add((AddRoomCommand) command);\n            }\n            if (command instanceof RegisterAccountCommand){\n                registerAccountCommandList.add((RegisterAccountCommand) command);\n            }\n            if (command instanceof BookRoomCommand){\n                bookRoomCommandList.add((BookRoomCommand) command);\n            }\n            if (command instanceof CheckOutCommand){\n                checkOutCommandList.add((CheckOutCommand) command);\n            }\n            if (command instanceof ProcessPaymentCommand){\n                processPaymentCommands.add((ProcessPaymentCommand) command);\n            }\n            if (command instanceof MarkRoomAsPreparedCommand){\n                markRoomAsPreparedCommandList.add((MarkRoomAsPreparedCommand) command);\n            }\n            if (command instanceof CheckInCommand){\n                checkInCommandList.add((CheckInCommand) command);\n            }\n\n        }\n        assertEquals(NUMBER_OF_ADD_ROOM_COMMANDS, addRoomCommandList.size());\n        assertEquals(NUMBER_OF_REGISTER_ACCOUNT_COMMANDS, registerAccountCommandList.size());\n        assertEquals(NUMBER_OF_BOOK_ROOM_COMMANDS, bookRoomCommandList.size());\n        assertEquals(NUMBER_OF_CHECK_OUT_COMMANDS, checkOutCommandList.size());\n        assertEquals(NUMBER_OF_PROCESS_PAYMENT_COMMANDS, processPaymentCommands.size());\n        assertEquals(NUMBER_OF_MARK_ROOM_AS_PREPARED_COMMANDS, markRoomAsPreparedCommandList.size());\n        assertEquals(NUMBER_OF_CHECK_IN_COMMANDS, checkInCommandList.size());\n\n        checkAddRoomCommands(addRoomCommandList);\n        checkRegisterAccountCommands(registerAccountCommandList);\n        IntStream.range(100, 105).forEach(roomNumber -> checkBookRoomCommands(bookRoomCommandList, roomNumber));\n        IntStream.range(100, 105).forEach(roomNumber -> checkMarkRoomAsPreparedCommand(markRoomAsPreparedCommandList, roomNumber));\n        IntStream.range(100, 105).forEach(roomNumber -> checkCheckInCommand(checkInCommandList, roomNumber));\n        IntStream.range(100, 105).forEach(roomNumber -> checkCheckOutCommand(checkOutCommandList, roomNumber));\n        checkProcessPaymentCommands(processPaymentCommands);\n    }\n\n    private void verifySendAndWaitCommands() {\n        ArgumentCaptor<Object> commandSendAndWaitCaptor = ArgumentCaptor.forClass(Object.class);\n        verify(commandGateway, times(NUMBER_OF_SEND_AND_WAIT_COMMANDS)).sendAndWait(commandSendAndWaitCaptor.capture());\n\n\n        List<PayCommand> payCommandList = new ArrayList<>();\n\n        for (Object command: commandSendAndWaitCaptor.getAllValues()){\n\n            if (command instanceof PayCommand){\n                payCommandList.add((PayCommand) command);\n            }\n        }\n        assertEquals(NUMBER_OF_PAY_COMMANDS, payCommandList.size());\n        checkPayCommands(payCommandList);\n    }\n\n\n    private void checkAddRoomCommands(List<AddRoomCommand> addRoomCommandsList) {\n        IntStream.range(100, 105).forEach(roomNumber -> checkAddRoomCommand(addRoomCommandsList, roomNumber, SINGLE_ROOM_SEA_SIDE_DESCRIPTION));\n        IntStream.range(105, 110).forEach(roomNumber -> checkAddRoomCommand(addRoomCommandsList, roomNumber, SINGLE_ROOM_MOUNTAIN_SIDE_DESCRIPTION));\n        IntStream.range(200, 205).forEach(roomNumber -> checkAddRoomCommand(addRoomCommandsList, roomNumber, DOUBLE_ROOM_SEA_SIDE_DESCRIPTION));\n        IntStream.range(205, 210).forEach(roomNumber -> checkAddRoomCommand(addRoomCommandsList, roomNumber, DOUBLE_ROOM_MOUNTAIN_SIDE_DESCRIPTION));\n    }\n\n    private void checkAddRoomCommand(List<AddRoomCommand> addRoomCommandsList, int roomNumber, String roomDescription){\n        assertTrue(addRoomCommandsList.contains(new AddRoomCommand(roomNumber, roomDescription)));\n    }\n\n    private void checkRegisterAccountCommands(List<RegisterAccountCommand> registerAccountCommandList){\n        assertTrue(registerAccountCommandList.contains(new RegisterAccountCommand(accountId,String.format(USER_NAME_FORMAT,\n                                                                                                      accountId), USER_PASSWORD)));\n    }\n\n    private void checkBookRoomCommands(List<BookRoomCommand> bookRoomCommandList, int roomNumber){\n        assertTrue(bookRoomCommandList.stream().anyMatch(bookRoomCommand -> checkBookRoomCommand(bookRoomCommand, roomNumber)));\n    }\n\n    private boolean checkBookRoomCommand(BookRoomCommand bookRoomCommand, int roomNumber) {\n        return bookRoomCommand.getRoomNumber() == roomNumber && bookRoomCommand.getRoomBooking().getAccountID().equals(accountId) && bookRoomCommand.getRoomBooking().getBookingId().equals(bookingId);\n    }\n\n    private void  checkMarkRoomAsPreparedCommand(List<MarkRoomAsPreparedCommand> markRoomAsPreparedCommandList, int roomNumber){\n        assertTrue(markRoomAsPreparedCommandList.contains(new MarkRoomAsPreparedCommand(roomNumber, bookingId)));\n    }\n    private void  checkCheckInCommand(List<CheckInCommand> checkInCommandList, int roomNumber){\n        assertTrue(checkInCommandList.contains(new CheckInCommand(roomNumber, bookingId)));\n    }\n\n    private void  checkCheckOutCommand(List<CheckOutCommand> checkOutCommandList, int roomNumber){\n        assertTrue(checkOutCommandList.contains(new CheckOutCommand(roomNumber, bookingId)));\n    }\n\n    private void checkPayCommands(List<PayCommand> payCommandList){\n        assertTrue(payCommandList.contains(new PayCommand(paymentId, accountId, TOTAL_BOOKING_AMOUNT)));\n    }\n    private void checkProcessPaymentCommands(List<ProcessPaymentCommand> processPaymentCommandList){\n        assertTrue(processPaymentCommandList.contains(new ProcessPaymentCommand(paymentId)));\n    }\n}", "item_id": 0, "repo": "MiguelAngelVega/hotel-demo", "file": "booking/src/test/java/io/axoniq/demo/hotel/booking/util/GenerateEventsForDemoTest.java", "last_update_at": "2022-03-24T05:42:51+00:00", "question_id": "071b49531cc25c60f4140d15d2b50ee011ddffc1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GenerateEventsForDemoTest {\n    private static int NUMBER_OF_SEND_COMMANDS = 58;\n    private static int NUMBER_OF_SEND_AND_WAIT_COMMANDS = 9;\n    private static final int NUMBER_OF_ADD_ROOM_COMMANDS = 20;\n    private static final int NUMBER_OF_PAY_COMMANDS = 9;\n    private static final int NUMBER_OF_REGISTER_ACCOUNT_COMMANDS = 9;\n    private static final int NUMBER_OF_BOOK_ROOM_COMMANDS = 5;\n    private static final int NUMBER_OF_CHECK_OUT_COMMANDS = 5;\n    private static final int NUMBER_OF_MARK_ROOM_AS_PREPARED_COMMANDS = 5;\n    private static final int NUMBER_OF_CHECK_IN_COMMANDS = 5;\n    private static final int NUMBER_OF_PROCESS_PAYMENT_COMMANDS = 9;\n    private CommandGateway commandGateway = mock(CommandGateway.class);\n    private RoomAvailabilityEntityRepository roomAvailabilityEntityRepository = mock(RoomAvailabilityEntityRepository.class);\n    private UUIDProvider uuidProvider = mock(UUIDProvider.class);\n    private UUID accountId = UUID.randomUUID();\n    private UUID bookingId = UUID.randomUUID();\n    private UUID paymentId = UUID.randomUUID();\n    @InjectMocks\n    private GenerateEventsForDemo generateEventsForDemo;\n    @BeforeEach\n    void setUp() {\n        generateEventsForDemo = new GenerateEventsForDemo(commandGateway, roomAvailabilityEntityRepository,\n                                                          uuidProvider);\n        when(uuidProvider.getAccountId()).thenReturn(accountId);\n        when(uuidProvider.getBookingId()).thenReturn(bookingId);\n        when(uuidProvider.getPaymentId()).thenReturn(paymentId);\n    }\n    @Test\n    void sendCommandsForBookingTest(){\n        generateEventsForDemo.sendCommandsForBooking();\n        verifySendCommands();\n        verifySendAndWaitCommands();\n    }\n    @Test\n    void doNotAddRoomsWhenRoomsAlreadyExist(){\n        when(roomAvailabilityEntityRepository.existsById(100)).thenReturn(true);\n        generateEventsForDemo.sendCommandsForBooking();\n        ArgumentCaptor<Object> commandSendCaptor = ArgumentCaptor.forClass(Object.class);\n        verify(commandGateway, times(38)).send(commandSendCaptor.capture());\n       assertEquals(0L, commandSendCaptor.getAllValues().stream().filter(o -> o instanceof AddRoomCommand).count());\n    }\n    private void verifySendCommands() {\n        ArgumentCaptor<Object> commandSendCaptor = ArgumentCaptor.forClass(Object.class);\n        verify(commandGateway, times(NUMBER_OF_SEND_COMMANDS)).send(commandSendCaptor.capture());\n        List<AddRoomCommand> addRoomCommandList = new ArrayList<>();\n        List<RegisterAccountCommand> registerAccountCommandList = new ArrayList<>();\n        List<BookRoomCommand> bookRoomCommandList = new ArrayList<>();\n        List<CheckOutCommand> checkOutCommandList = new ArrayList<>();\n        List<ProcessPaymentCommand> processPaymentCommands = new ArrayList<>();\n        List<MarkRoomAsPreparedCommand> markRoomAsPreparedCommandList = new ArrayList<>();\n        List<CheckInCommand> checkInCommandList = new ArrayList<>();\n        for (Object command : commandSendCaptor.getAllValues()){\n            if (command instanceof AddRoomCommand){\n                addRoomCommandList.add((AddRoomCommand) command);\n            }\n            if (command instanceof RegisterAccountCommand){\n                registerAccountCommandList.add((RegisterAccountCommand) command);\n            }\n            if (command instanceof BookRoomCommand){\n                bookRoomCommandList.add((BookRoomCommand) command);\n            }\n            if (command instanceof CheckOutCommand){\n                checkOutCommandList.add((CheckOutCommand) command);\n            }\n            if (command instanceof ProcessPaymentCommand){\n                processPaymentCommands.add((ProcessPaymentCommand) command);\n            }\n            if (command instanceof MarkRoomAsPreparedCommand){\n                markRoomAsPreparedCommandList.add((MarkRoomAsPreparedCommand) command);\n            }\n            if (command instanceof CheckInCommand){\n                checkInCommandList.add((CheckInCommand) command);\n            }\n        }\n        assertEquals(NUMBER_OF_ADD_ROOM_COMMANDS, addRoomCommandList.size());\n        assertEquals(NUMBER_OF_REGISTER_ACCOUNT_COMMANDS, registerAccountCommandList.size());\n        assertEquals(NUMBER_OF_BOOK_ROOM_COMMANDS, bookRoomCommandList.size());\n        assertEquals(NUMBER_OF_CHECK_OUT_COMMANDS, checkOutCommandList.size());\n        assertEquals(NUMBER_OF_PROCESS_PAYMENT_COMMANDS, processPaymentCommands.size());\n        assertEquals(NUMBER_OF_MARK_ROOM_AS_PREPARED_COMMANDS, markRoomAsPreparedCommandList.size());\n        assertEquals(NUMBER_OF_CHECK_IN_COMMANDS, checkInCommandList.size());\n        checkAddRoomCommands(addRoomCommandList);\n        checkRegisterAccountCommands(registerAccountCommandList);\n        IntStream.range(100, 105).forEach(roomNumber -> checkBookRoomCommands(bookRoomCommandList, roomNumber));\n        IntStream.range(100, 105).forEach(roomNumber -> checkMarkRoomAsPreparedCommand(markRoomAsPreparedCommandList, roomNumber));\n        IntStream.range(100, 105).forEach(roomNumber -> checkCheckInCommand(checkInCommandList, roomNumber));\n        IntStream.range(100, 105).forEach(roomNumber -> checkCheckOutCommand(checkOutCommandList, roomNumber));\n        checkProcessPaymentCommands(processPaymentCommands);\n    }\n    private void verifySendAndWaitCommands() {\n        ArgumentCaptor<Object> commandSendAndWaitCaptor = ArgumentCaptor.forClass(Object.class);\n        verify(commandGateway, times(NUMBER_OF_SEND_AND_WAIT_COMMANDS)).sendAndWait(commandSendAndWaitCaptor.capture());\n        List<PayCommand> payCommandList = new ArrayList<>();\n        for (Object command: commandSendAndWaitCaptor.getAllValues()){\n            if (command instanceof PayCommand){\n                payCommandList.add((PayCommand) command);\n            }\n        }\n        assertEquals(NUMBER_OF_PAY_COMMANDS, payCommandList.size());\n        checkPayCommands(payCommandList);\n    }\n    private void checkAddRoomCommands(List<AddRoomCommand> addRoomCommandsList) {\n        IntStream.range(100, 105).forEach(roomNumber -> checkAddRoomCommand(addRoomCommandsList, roomNumber, SINGLE_ROOM_SEA_SIDE_DESCRIPTION));\n        IntStream.range(105, 110).forEach(roomNumber -> checkAddRoomCommand(addRoomCommandsList, roomNumber, SINGLE_ROOM_MOUNTAIN_SIDE_DESCRIPTION));\n        IntStream.range(200, 205).forEach(roomNumber -> checkAddRoomCommand(addRoomCommandsList, roomNumber, DOUBLE_ROOM_SEA_SIDE_DESCRIPTION));\n        IntStream.range(205, 210).forEach(roomNumber -> checkAddRoomCommand(addRoomCommandsList, roomNumber, DOUBLE_ROOM_MOUNTAIN_SIDE_DESCRIPTION));\n    }\n    private void checkAddRoomCommand(List<AddRoomCommand> addRoomCommandsList, int roomNumber, String roomDescription){\n        assertTrue(addRoomCommandsList.contains(new AddRoomCommand(roomNumber, roomDescription)));\n    }\n    private void checkRegisterAccountCommands(List<RegisterAccountCommand> registerAccountCommandList){\n        assertTrue(registerAccountCommandList.contains(new RegisterAccountCommand(accountId,String.format(USER_NAME_FORMAT,\n                                                                                                      accountId), USER_PASSWORD)));\n    }\n    private void checkBookRoomCommands(List<BookRoomCommand> bookRoomCommandList, int roomNumber){\n        assertTrue(bookRoomCommandList.stream().anyMatch(bookRoomCommand -> checkBookRoomCommand(bookRoomCommand, roomNumber)));\n    }\n    private boolean checkBookRoomCommand(BookRoomCommand bookRoomCommand, int roomNumber) {\n        return bookRoomCommand.getRoomNumber() == roomNumber && bookRoomCommand.getRoomBooking().getAccountID().equals(accountId) && bookRoomCommand.getRoomBooking().getBookingId().equals(bookingId);\n    }\n    private void  checkMarkRoomAsPreparedCommand(List<MarkRoomAsPreparedCommand> markRoomAsPreparedCommandList, int roomNumber){\n        assertTrue(markRoomAsPreparedCommandList.contains(new MarkRoomAsPreparedCommand(roomNumber, bookingId)));\n    }\n    private void  checkCheckInCommand(List<CheckInCommand> checkInCommandList, int roomNumber){\n        assertTrue(checkInCommandList.contains(new CheckInCommand(roomNumber, bookingId)));\n    }\n    private void  checkCheckOutCommand(List<CheckOutCommand> checkOutCommandList, int roomNumber){\n        assertTrue(checkOutCommandList.contains(new CheckOutCommand(roomNumber, bookingId)));\n    }\n    private void checkPayCommands(List<PayCommand> payCommandList){\n        assertTrue(payCommandList.contains(new PayCommand(paymentId, accountId, TOTAL_BOOKING_AMOUNT)));\n    }\n    private void checkProcessPaymentCommands(List<ProcessPaymentCommand> processPaymentCommandList){\n        assertTrue(processPaymentCommandList.contains(new ProcessPaymentCommand(paymentId)));\n    }\n"]], "pred": {"ppl": 1.5852720737457275, "ppl_lower": 1.7374224662780762, "ppl/lowercase_ppl": -1.1989048785885357, "ppl/zlib": 0.0002867181381196197, "Min_5.0% Prob": 5.288315534591675, "Min_10.0% Prob": 3.814733100872414, "Min_20.0% Prob": 2.2352741653574446, "Min_30.0% Prob": 1.5266483489886609, "Min_40.0% Prob": 1.1490844865932988, "Min_50.0% Prob": 0.9214916057700616, "Min_60.0% Prob": 0.7686886303527524}}
{"hexsha": "b417ebe95df69faf5bdcc32a6ba96e48adb4e5f2", "ext": "java", "lang": "Java", "content": "class ByteTokenizerTest {\n\n    @Test\n    void compact() {\n        ByteTokenizer tokenizer = new ByteTokenizer();\n        tokenizer.add(ByteBuffer.wrap(\"hello world\".getBytes()));\n        Assertions.assertArrayEquals(\"hello\".getBytes(), tokenizer.next(\" \".getBytes()));\n        Assertions.assertEquals(11, tokenizer.capacity());\n        Assertions.assertEquals(5, tokenizer.remaining());\n        tokenizer.compact();\n        Assertions.assertEquals(5, tokenizer.capacity());\n        Assertions.assertEquals(5, tokenizer.remaining());\n        Assertions.assertArrayEquals(\"world\".getBytes(), tokenizer.next(5));\n        tokenizer.compact();\n        Assertions.assertEquals(0, tokenizer.capacity());\n        Assertions.assertEquals(0, tokenizer.remaining());\n    }\n\n    @Test\n    void expandingArray() {\n        ByteTokenizer tokenizer = new ByteTokenizer();\n        Assertions.assertEquals(0, tokenizer.remaining());\n        Assertions.assertEquals(0, tokenizer.size());\n        Assertions.assertEquals(0, tokenizer.capacity());\n        addAndAssert(tokenizer, \"a\", 1, 1, 1);\n        addAndAssert(tokenizer, \"b\", 2, 2, 2);\n        addAndAssert(tokenizer, \"c\", 3, 3, 4);\n        addAndAssert(tokenizer, \"xxxxxxx\", 10, 10, 10);\n    }\n\n    static void addAndAssert(ByteTokenizer tokenizer, String data, int remaining, int size, int capacity) {\n        tokenizer.add(ByteBuffer.wrap(data.getBytes()));\n        Assertions.assertEquals(remaining, tokenizer.remaining());\n        Assertions.assertEquals(size, tokenizer.size());\n        Assertions.assertEquals(capacity, tokenizer.capacity());\n    }\n\n    @Test\n    void noBytes() {\n        ByteTokenizer tokenizer = new ByteTokenizer();\n        Assertions.assertEquals(0, tokenizer.remaining());\n        Assertions.assertNull(tokenizer.next(1));\n        Assertions.assertNull(tokenizer.next(\" \".getBytes()));\n    }\n\n    @Test\n    void nextWithLength() {\n        ByteTokenizer tokenizer = new ByteTokenizer();\n        tokenizer.add(ByteBuffer.wrap(\"hello\".getBytes()));\n        Assertions.assertArrayEquals(\"h\".getBytes(), tokenizer.next(1));\n        Assertions.assertArrayEquals(\"ello\".getBytes(), tokenizer.next(4));\n        Assertions.assertNull(tokenizer.next(1));\n    }\n\n    @Test\n    void nextWithDelimiter() {\n        ByteTokenizer tokenizer = new ByteTokenizer();\n        tokenizer.add(ByteBuffer.wrap(\"hello\".getBytes()));\n        tokenizer.add(ByteBuffer.wrap(\" \".getBytes()));\n        tokenizer.add(ByteBuffer.wrap(\"world\".getBytes()));\n        tokenizer.add(ByteBuffer.wrap(\"\\r\\n\".getBytes()));\n        Assertions.assertArrayEquals(\"hello\".getBytes(), tokenizer.next(\" \".getBytes()));\n        Assertions.assertNull(tokenizer.next(\" \".getBytes()));\n        Assertions.assertArrayEquals(\"world\".getBytes(), tokenizer.next(\"\\r\\n\".getBytes()));\n        Assertions.assertNull(tokenizer.next(\"\\r\\n\".getBytes()));\n    }\n\n}", "item_id": 0, "repo": "beatngu13/microhttp", "file": "src/test/java/org/microhttp/ByteTokenizerTest.java", "last_update_at": "2022-03-30T02:21:58+00:00", "question_id": "b417ebe95df69faf5bdcc32a6ba96e48adb4e5f2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class ByteTokenizerTest {\n    @Test\n    void compact() {\n        ByteTokenizer tokenizer = new ByteTokenizer();\n        tokenizer.add(ByteBuffer.wrap(\"hello world\".getBytes()));\n        Assertions.assertArrayEquals(\"hello\".getBytes(), tokenizer.next(\" \".getBytes()));\n        Assertions.assertEquals(11, tokenizer.capacity());\n        Assertions.assertEquals(5, tokenizer.remaining());\n        tokenizer.compact();\n        Assertions.assertEquals(5, tokenizer.capacity());\n        Assertions.assertEquals(5, tokenizer.remaining());\n        Assertions.assertArrayEquals(\"world\".getBytes(), tokenizer.next(5));\n        tokenizer.compact();\n        Assertions.assertEquals(0, tokenizer.capacity());\n        Assertions.assertEquals(0, tokenizer.remaining());\n    }\n    @Test\n    void expandingArray() {\n        ByteTokenizer tokenizer = new ByteTokenizer();\n        Assertions.assertEquals(0, tokenizer.remaining());\n        Assertions.assertEquals(0, tokenizer.size());\n        Assertions.assertEquals(0, tokenizer.capacity());\n        addAndAssert(tokenizer, \"a\", 1, 1, 1);\n        addAndAssert(tokenizer, \"b\", 2, 2, 2);\n        addAndAssert(tokenizer, \"c\", 3, 3, 4);\n        addAndAssert(tokenizer, \"xxxxxxx\", 10, 10, 10);\n    }\n    static void addAndAssert(ByteTokenizer tokenizer, String data, int remaining, int size, int capacity) {\n        tokenizer.add(ByteBuffer.wrap(data.getBytes()));\n        Assertions.assertEquals(remaining, tokenizer.remaining());\n        Assertions.assertEquals(size, tokenizer.size());\n        Assertions.assertEquals(capacity, tokenizer.capacity());\n    }\n    @Test\n    void noBytes() {\n        ByteTokenizer tokenizer = new ByteTokenizer();\n        Assertions.assertEquals(0, tokenizer.remaining());\n        Assertions.assertNull(tokenizer.next(1));\n        Assertions.assertNull(tokenizer.next(\" \".getBytes()));\n    }\n    @Test\n    void nextWithLength() {\n        ByteTokenizer tokenizer = new ByteTokenizer();\n        tokenizer.add(ByteBuffer.wrap(\"hello\".getBytes()));\n        Assertions.assertArrayEquals(\"h\".getBytes(), tokenizer.next(1));\n        Assertions.assertArrayEquals(\"ello\".getBytes(), tokenizer.next(4));\n        Assertions.assertNull(tokenizer.next(1));\n    }\n    @Test\n    void nextWithDelimiter() {\n        ByteTokenizer tokenizer = new ByteTokenizer();\n        tokenizer.add(ByteBuffer.wrap(\"hello\".getBytes()));\n        tokenizer.add(ByteBuffer.wrap(\" \".getBytes()));\n        tokenizer.add(ByteBuffer.wrap(\"world\".getBytes()));\n        tokenizer.add(ByteBuffer.wrap(\"\\r\\n\".getBytes()));\n        Assertions.assertArrayEquals(\"hello\".getBytes(), tokenizer.next(\" \".getBytes()));\n        Assertions.assertNull(tokenizer.next(\" \".getBytes()));\n        Assertions.assertArrayEquals(\"world\".getBytes(), tokenizer.next(\"\\r\\n\".getBytes()));\n        Assertions.assertNull(tokenizer.next(\"\\r\\n\".getBytes()));\n    }\n"]], "pred": {"ppl": 1.4120233058929443, "ppl_lower": 1.4736690521240234, "ppl/lowercase_ppl": -1.1238512230988877, "ppl/zlib": 0.000763326647178625, "Min_5.0% Prob": 4.4799447873743565, "Min_10.0% Prob": 2.97222656586084, "Min_20.0% Prob": 1.6734424085317257, "Min_30.0% Prob": 1.1450185455530881, "Min_40.0% Prob": 0.8617196607788256, "Min_50.0% Prob": 0.6896045824215395, "Min_60.0% Prob": 0.5756244326379576}}
{"hexsha": "38da4edfe24143fd0f72613e4d60bd71ef6d4b1a", "ext": "java", "lang": "Java", "content": "public class PersistedOptions {\n\n\t/** Prefix used for keys to store normalization. */\n\tprivate static final String NORMALIZATION_KEY_PREFIX = \"NORMALIZATION:\";\n\n\t/** Key used to store the chunk length. */\n\tprivate static final String CHUNK_LENGTH_KEY = \"CHUNK_LENGTH\";\n\n\t/** The store used. */\n\tprivate final ICloneIndexStore store;\n\n\t/** Cache for normalizations. */\n\tprivate final Map<ELanguage, IUnitProvider<ITextResource, Unit>> normalizationCache = new EnumMap<ELanguage, IUnitProvider<ITextResource, Unit>>(\n\t\t\tELanguage.class);\n\n\t/** Value used for unset/uncached chunk length. */\n\tpublic static final int UNSET = -1;\n\n\t/** Caches the chunk length. */\n\tprivate int cachedChunkLength = UNSET;\n\n\t/** Constructor. */\n\tpublic PersistedOptions(ICloneIndexStore store) {\n\t\tthis.store = store;\n\t}\n\n\t/** Returns the normalization to be used for a given language. */\n\tpublic IUnitProvider<ITextResource, Unit> getNormalization(\n\t\t\tELanguage language) throws StorageException {\n\t\tIUnitProvider<ITextResource, Unit> normalization = normalizationCache\n\t\t\t\t.get(language);\n\t\tif (normalization == null) {\n\t\t\tnormalization = readNormalization(store, language);\n\t\t\tnormalizationCache.put(language, normalization);\n\t\t}\n\t\treturn normalization;\n\t}\n\n\t/**\n\t * Returns the stored chunk length. If no length is set, an exception is\n\t * thrown as this is a required field.\n\t */\n\tpublic int getChunkLength() throws StorageException {\n\t\tif (cachedChunkLength <= 0) {\n\t\t\tcachedChunkLength = readChunkLength(store);\n\t\t\tif (cachedChunkLength <= 0) {\n\t\t\t\tthrow new StorageException(\n\t\t\t\t\t\t\"No chunk length found in store! Clone index not initialized?\");\n\t\t\t}\n\t\t}\n\t\treturn cachedChunkLength;\n\t}\n\n\t/**\n\t * Sets the chunk length used. If the chunk length was already set and\n\t * differs from the new provided value, a {@link StorageException} is\n\t * thrown, as this would cause an inconsistent index.\n\t * \n\t * @param chunkLength\n\t *            the chunk length (must be positive).\n\t */\n\tpublic static void setChunkLength(ICloneIndexStore store, int chunkLength)\n\t\t\tthrows StorageException {\n\t\tCCSMAssert.isTrue(chunkLength > 0, \"Only positive values allowed.\");\n\t\tint oldLength = readChunkLength(store);\n\t\tif (oldLength < 0) {\n\t\t\tstore.setOption(CHUNK_LENGTH_KEY, chunkLength);\n\t\t} else if (oldLength != chunkLength) {\n\t\t\tthrow new StorageException(\n\t\t\t\t\t\"Attempt to replace chunk length with different value!\");\n\t\t}\n\t}\n\n\t/**\n\t * Returns the stored chunk length. If no length is set, {@link #UNSET} is\n\t * returned.\n\t */\n\tpublic static int readChunkLength(ICloneIndexStore store)\n\t\t\tthrows StorageException {\n\t\tInteger chunkLength = (Integer) store.getOption(CHUNK_LENGTH_KEY);\n\t\tif (chunkLength == null) {\n\t\t\treturn UNSET;\n\t\t}\n\t\treturn chunkLength;\n\t}\n\n\t/**\n\t * Sets the normalization for the given language. If the normalization was\n\t * already set and differs from the new provided normalization, a\n\t * {@link StorageException} is thrown, as this would cause an inconsistent\n\t * index. Equality of normalizations is checked by their serializations.\n\t */\n\tpublic static void setNormalization(ICloneIndexStore store,\n\t\t\tELanguage language,\n\t\t\tIUnitProvider<? extends ITextResource, Unit> normalization)\n\t\t\tthrows StorageException {\n\t\tCCSMAssert.isNotNull(normalization);\n\n\t\tIUnitProvider<ITextResource, Unit> oldNormalization = readNormalization(\n\t\t\t\tstore, language);\n\t\tif (oldNormalization == null) {\n\t\t\tstore.setOption(normalizationKey(language), normalization);\n\t\t} else {\n\t\t\tensureNormalizationsEqual(language, normalization, oldNormalization);\n\t\t}\n\t}\n\n\t/**\n\t * Ensures that both normalizations are equals by serializing them and\n\t * comparing bytes.\n\t */\n\tprivate static void ensureNormalizationsEqual(ELanguage language,\n\t\t\tIUnitProvider<? extends ITextResource, Unit> normalization,\n\t\t\tIUnitProvider<? extends ITextResource, Unit> oldNormalization)\n\t\t\tthrows StorageException {\n\t\ttry {\n\t\t\tbyte[] normalizationData = SerializationUtils\n\t\t\t\t\t.serializeToByteArray(normalization);\n\t\t\tbyte[] oldNormalizationData = SerializationUtils\n\t\t\t\t\t.serializeToByteArray(oldNormalization);\n\t\t\tif (!Arrays.equals(normalizationData, oldNormalizationData)) {\n\t\t\t\tthrow new StorageException(\n\t\t\t\t\t\t\"Attempt to replace normalization for language \"\n\t\t\t\t\t\t\t\t+ language + \" with different normalization!\");\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new StorageException(\"Error during serialization!\", e);\n\t\t}\n\t}\n\n\t/** Reads a normalization from a store. */\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static IUnitProvider<ITextResource, Unit> readNormalization(\n\t\t\tICloneIndexStore store, ELanguage language) throws StorageException {\n\t\treturn (IUnitProvider<ITextResource, Unit>) store\n\t\t\t\t.getOption(normalizationKey(language));\n\t}\n\n\t/** Returns the name used to store normalization for the given language. */\n\tprivate static String normalizationKey(ELanguage language) {\n\t\treturn NORMALIZATION_KEY_PREFIX + language.name();\n\t}\n}", "item_id": 0, "repo": "assessorgeneral/ConQAT", "file": "org.conqat.engine.code_clones/src/org/conqat/engine/code_clones/index/PersistedOptions.java", "last_update_at": "2022-03-04T16:42:35+00:00", "question_id": "38da4edfe24143fd0f72613e4d60bd71ef6d4b1a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PersistedOptions {\n\t/** Prefix used for keys to store normalization. */\n\tprivate static final String NORMALIZATION_KEY_PREFIX = \"NORMALIZATION:\";\n\t/** Key used to store the chunk length. */\n\tprivate static final String CHUNK_LENGTH_KEY = \"CHUNK_LENGTH\";\n\t/** The store used. */\n\tprivate final ICloneIndexStore store;\n\t/** Cache for normalizations. */\n\tprivate final Map<ELanguage, IUnitProvider<ITextResource, Unit>> normalizationCache = new EnumMap<ELanguage, IUnitProvider<ITextResource, Unit>>(\n\t\t\tELanguage.class);\n\t/** Value used for unset/uncached chunk length. */\n\tpublic static final int UNSET = -1;\n\t/** Caches the chunk length. */\n\tprivate int cachedChunkLength = UNSET;\n\t/** Constructor. */\n\tpublic PersistedOptions(ICloneIndexStore store) {\n\t\tthis.store = store;\n\t}\n\t/** Returns the normalization to be used for a given language. */\n\tpublic IUnitProvider<ITextResource, Unit> getNormalization(\n\t\t\tELanguage language) throws StorageException {\n\t\tIUnitProvider<ITextResource, Unit> normalization = normalizationCache\n\t\t\t\t.get(language);\n\t\tif (normalization == null) {\n\t\t\tnormalization = readNormalization(store, language);\n\t\t\tnormalizationCache.put(language, normalization);\n\t\t}\n\t\treturn normalization;\n\t}\n\t/**\n\t * Returns the stored chunk length. If no length is set, an exception is\n\t * thrown as this is a required field.\n\t */\n\tpublic int getChunkLength() throws StorageException {\n\t\tif (cachedChunkLength <= 0) {\n\t\t\tcachedChunkLength = readChunkLength(store);\n\t\t\tif (cachedChunkLength <= 0) {\n\t\t\t\tthrow new StorageException(\n\t\t\t\t\t\t\"No chunk length found in store! Clone index not initialized?\");\n\t\t\t}\n\t\t}\n\t\treturn cachedChunkLength;\n\t}\n\t/**\n\t * Sets the chunk length used. If the chunk length was already set and\n\t * differs from the new provided value, a {@link StorageException} is\n\t * thrown, as this would cause an inconsistent index.\n\t * \n\t * @param chunkLength\n\t *            the chunk length (must be positive).\n\t */\n\tpublic static void setChunkLength(ICloneIndexStore store, int chunkLength)\n\t\t\tthrows StorageException {\n\t\tCCSMAssert.isTrue(chunkLength > 0, \"Only positive values allowed.\");\n\t\tint oldLength = readChunkLength(store);\n\t\tif (oldLength < 0) {\n\t\t\tstore.setOption(CHUNK_LENGTH_KEY, chunkLength);\n\t\t} else if (oldLength != chunkLength) {\n\t\t\tthrow new StorageException(\n\t\t\t\t\t\"Attempt to replace chunk length with different value!\");\n\t\t}\n\t}\n\t/**\n\t * Returns the stored chunk length. If no length is set, {@link #UNSET} is\n\t * returned.\n\t */\n\tpublic static int readChunkLength(ICloneIndexStore store)\n\t\t\tthrows StorageException {\n\t\tInteger chunkLength = (Integer) store.getOption(CHUNK_LENGTH_KEY);\n\t\tif (chunkLength == null) {\n\t\t\treturn UNSET;\n\t\t}\n\t\treturn chunkLength;\n\t}\n\t/**\n\t * Sets the normalization for the given language. If the normalization was\n\t * already set and differs from the new provided normalization, a\n\t * {@link StorageException} is thrown, as this would cause an inconsistent\n\t * index. Equality of normalizations is checked by their serializations.\n\t */\n\tpublic static void setNormalization(ICloneIndexStore store,\n\t\t\tELanguage language,\n\t\t\tIUnitProvider<? extends ITextResource, Unit> normalization)\n\t\t\tthrows StorageException {\n\t\tCCSMAssert.isNotNull(normalization);\n\t\tIUnitProvider<ITextResource, Unit> oldNormalization = readNormalization(\n\t\t\t\tstore, language);\n\t\tif (oldNormalization == null) {\n\t\t\tstore.setOption(normalizationKey(language), normalization);\n\t\t} else {\n\t\t\tensureNormalizationsEqual(language, normalization, oldNormalization);\n\t\t}\n\t}\n\t/**\n\t * Ensures that both normalizations are equals by serializing them and\n\t * comparing bytes.\n\t */\n\tprivate static void ensureNormalizationsEqual(ELanguage language,\n\t\t\tIUnitProvider<? extends ITextResource, Unit> normalization,\n\t\t\tIUnitProvider<? extends ITextResource, Unit> oldNormalization)\n\t\t\tthrows StorageException {\n\t\ttry {\n\t\t\tbyte[] normalizationData = SerializationUtils\n\t\t\t\t\t.serializeToByteArray(normalization);\n\t\t\tbyte[] oldNormalizationData = SerializationUtils\n\t\t\t\t\t.serializeToByteArray(oldNormalization);\n\t\t\tif (!Arrays.equals(normalizationData, oldNormalizationData)) {\n\t\t\t\tthrow new StorageException(\n\t\t\t\t\t\t\"Attempt to replace normalization for language \"\n\t\t\t\t\t\t\t\t+ language + \" with different normalization!\");\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new StorageException(\"Error during serialization!\", e);\n\t\t}\n\t}\n\t/** Reads a normalization from a store. */\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static IUnitProvider<ITextResource, Unit> readNormalization(\n\t\t\tICloneIndexStore store, ELanguage language) throws StorageException {\n\t\treturn (IUnitProvider<ITextResource, Unit>) store\n\t\t\t\t.getOption(normalizationKey(language));\n\t}\n\t/** Returns the name used to store normalization for the given language. */\n\tprivate static String normalizationKey(ELanguage language) {\n\t\treturn NORMALIZATION_KEY_PREFIX + language.name();\n\t}\n"]], "pred": {"ppl": 1.725204348564148, "ppl_lower": 1.9389965534210205, "ppl/lowercase_ppl": -1.2142221600454624, "ppl/zlib": 0.0003948917497486471, "Min_5.0% Prob": 5.5946984197579175, "Min_10.0% Prob": 4.077089286318012, "Min_20.0% Prob": 2.568476578038113, "Min_30.0% Prob": 1.7934363502400372, "Min_40.0% Prob": 1.3573420394239333, "Min_50.0% Prob": 1.0903259350438903, "Min_60.0% Prob": 0.9098342110810811}}
{"hexsha": "af4d1d96f88db892ebd8778831685e9df6719013", "ext": "java", "lang": "Java", "content": "public final class ElasticsearchRestInstrumenterFactory {\n\n  public static Instrumenter<String, Response> create(String instrumentationName) {\n    ElasticsearchRestAttributesExtractor attributesExtractor =\n        new ElasticsearchRestAttributesExtractor();\n    SpanNameExtractor<String> spanNameExtractor = DbSpanNameExtractor.create(attributesExtractor);\n    ElasticsearchRestNetAttributesExtractor netAttributesExtractor =\n        new ElasticsearchRestNetAttributesExtractor();\n\n    return Instrumenter.<String, Response>newBuilder(\n            GlobalOpenTelemetry.get(), instrumentationName, spanNameExtractor)\n        .addAttributesExtractor(attributesExtractor)\n        .addAttributesExtractor(netAttributesExtractor)\n        .addAttributesExtractor(PeerServiceAttributesExtractor.create(netAttributesExtractor))\n        .newInstrumenter(SpanKindExtractor.alwaysClient());\n  }\n\n  private ElasticsearchRestInstrumenterFactory() {}\n}", "item_id": 0, "repo": "aras112/opentelemetry-java-instrumentation", "file": "instrumentation/elasticsearch/elasticsearch-rest-common/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/elasticsearch/rest/ElasticsearchRestInstrumenterFactory.java", "last_update_at": "2022-03-31T05:06:26+00:00", "question_id": "af4d1d96f88db892ebd8778831685e9df6719013_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class ElasticsearchRestInstrumenterFactory {\n  public static Instrumenter<String, Response> create(String instrumentationName) {\n    ElasticsearchRestAttributesExtractor attributesExtractor =\n        new ElasticsearchRestAttributesExtractor();\n    SpanNameExtractor<String> spanNameExtractor = DbSpanNameExtractor.create(attributesExtractor);\n    ElasticsearchRestNetAttributesExtractor netAttributesExtractor =\n        new ElasticsearchRestNetAttributesExtractor();\n    return Instrumenter.<String, Response>newBuilder(\n            GlobalOpenTelemetry.get(), instrumentationName, spanNameExtractor)\n        .addAttributesExtractor(attributesExtractor)\n        .addAttributesExtractor(netAttributesExtractor)\n        .addAttributesExtractor(PeerServiceAttributesExtractor.create(netAttributesExtractor))\n        .newInstrumenter(SpanKindExtractor.alwaysClient());\n  }\n  private ElasticsearchRestInstrumenterFactory() {}\n"]], "pred": {"ppl": 1.806687355041504, "ppl_lower": 2.8983583450317383, "ppl/lowercase_ppl": -1.7990761183737036, "ppl/zlib": 0.0018837419676683606, "Min_5.0% Prob": 6.175072388215498, "Min_10.0% Prob": 4.490395600145513, "Min_20.0% Prob": 2.783520755442706, "Min_30.0% Prob": 1.9480302960357883, "Min_40.0% Prob": 1.4746258383701472, "Min_50.0% Prob": 1.1820864673661575, "Min_60.0% Prob": 0.9855997289282228}}
{"hexsha": "d6d82d1885fb859a68a6fadb3df0bf67c0d889c5", "ext": "java", "lang": "Java", "content": "public class TypedNodeTransformationMakerList extends TypedNodeMaker {\n\t\t\n\tpublic TypedNodeTransformationMakerList(NodeType nodeType, ValueMaker valueMaker) {\n\t\tsuper(nodeType, valueMaker);\n\t}\n\t@Override\n\tpublic Node makeNode(ResultRow tuple) {\n\t\tString value = this.valueMaker.makeValue(tuple);\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.nodeType.makeNode(value);\n\t}\n\t\n@Override\n\tpublic void accept(NodeMakerVisitor visitor) {\n\tsuper.accept(visitor);\n\t\t//visitor.visit(this); //DIMIS FIX ME NOW!!!!!!!\n\t\tSystem.out.print(\"visit?\");\n\t}\n}", "item_id": 0, "repo": "kkyzir/GeoTriples", "file": "geotriples-processors/geotriples-r2rml/src/main/java/org/d2rq/nodes/TypedNodeTransformationMakerList.java", "last_update_at": "2022-01-28T22:58:26+00:00", "question_id": "d6d82d1885fb859a68a6fadb3df0bf67c0d889c5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TypedNodeTransformationMakerList extends TypedNodeMaker {\n\t\t\n\tpublic TypedNodeTransformationMakerList(NodeType nodeType, ValueMaker valueMaker) {\n\t\tsuper(nodeType, valueMaker);\n\t}\n\t@Override\n\tpublic Node makeNode(ResultRow tuple) {\n\t\tString value = this.valueMaker.makeValue(tuple);\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.nodeType.makeNode(value);\n\t}\n\t\n@Override\n\tpublic void accept(NodeMakerVisitor visitor) {\n\tsuper.accept(visitor);\n\t\t//visitor.visit(this); //DIMIS FIX ME NOW!!!!!!!\n\t\tSystem.out.print(\"visit?\");\n\t}\n"]], "pred": {"ppl": 3.379948139190674, "ppl_lower": 4.285699367523193, "ppl/lowercase_ppl": -1.1949512377498899, "ppl/zlib": 0.004199518503250013, "Min_5.0% Prob": 8.455214405059815, "Min_10.0% Prob": 6.863771367073059, "Min_20.0% Prob": 4.967606562376022, "Min_30.0% Prob": 3.7837749034166337, "Min_40.0% Prob": 2.9816136587411166, "Min_50.0% Prob": 2.424606912881136, "Min_60.0% Prob": 2.032487030358364}}
{"hexsha": "b8e83a39b33a7d415d7cd84878ffca2dcb3ebb56", "ext": "java", "lang": "Java", "content": "final class CreateTableQueryImpl\n    extends AbstractQuery<CreateTableQuery>\n    implements CreateTableQuery {\n\n  private boolean table = false;\n  private boolean columns = false;\n\n  CreateTableQueryImpl(\n      @NotNull DialectProvider dialectProvider,\n      @NotNull ConnectionSource connectionSource) {\n    super(dialectProvider, connectionSource);\n\n    this.builder.append(\"CREATE TABLE \");\n  }\n\n  @Override\n  protected CreateTableQuery self() {\n    return this;\n  }\n\n  @Override\n  public CreateTableQuery table(@NotNull String table) {\n    if (check()) {\n      return this;\n    }\n\n    if (!this.table) {\n      this.builder.append(\" \").append(dialectProvider.protectValue(table));\n\n      this.table = true;\n    }\n    return this;\n  }\n\n  @Override\n  public CreateTableQuery ifNotExists() {\n    if (check()) {\n      return this;\n    }\n\n    if (!table) {\n      this.builder.append(\"IF NOT EXISTS\");\n    }\n    return this;\n  }\n\n  @Override\n  public CreateTableQuery rawColumns(@NotNull String... columns) {\n    if (check()) {\n      return this;\n    }\n\n    if (!table) {\n      return this;\n    }\n\n    final StringJoiner joiner = new StringJoiner(\", \", \" (\", \")\");\n\n    for (final String column : columns) {\n      joiner.add(column);\n    }\n\n    this.builder.append(joiner);\n\n    this.columns = true;\n\n    return this;\n  }\n\n  @Override\n  public CreateTableQuery columns(@NotNull Iterable<? extends ColumnMeta> columnMeta) {\n    if (check()) {\n      return this;\n    }\n\n    if (!table) {\n      return this;\n    }\n\n    final StringJoiner joiner = new StringJoiner(\", \", \" (\", \")\");\n\n    for (final ColumnMeta meta : columnMeta) {\n      joiner.add(dialectProvider.columnMetaToString(meta));\n    }\n\n    this.builder.append(joiner);\n\n    columns = true;\n\n    return this;\n  }\n\n  @Override\n  protected boolean subQuerySupported(@NotNull Query<?> sub) {\n    return false;\n  }\n\n  @Override\n  protected boolean check() {\n    return table && columns;\n  }\n}", "item_id": 0, "repo": "MaxWainer/framework", "file": "orm/api/src/main/java/dev/framework/orm/implementation/CreateTableQueryImpl.java", "last_update_at": "2022-03-29T12:57:04+00:00", "question_id": "b8e83a39b33a7d415d7cd84878ffca2dcb3ebb56_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["final class CreateTableQueryImpl\n    extends AbstractQuery<CreateTableQuery>\n    implements CreateTableQuery {\n  private boolean table = false;\n  private boolean columns = false;\n  CreateTableQueryImpl(\n      @NotNull DialectProvider dialectProvider,\n      @NotNull ConnectionSource connectionSource) {\n    super(dialectProvider, connectionSource);\n    this.builder.append(\"CREATE TABLE \");\n  }\n  @Override\n  protected CreateTableQuery self() {\n    return this;\n  }\n  @Override\n  public CreateTableQuery table(@NotNull String table) {\n    if (check()) {\n      return this;\n    }\n    if (!this.table) {\n      this.builder.append(\" \").append(dialectProvider.protectValue(table));\n      this.table = true;\n    }\n    return this;\n  }\n  @Override\n  public CreateTableQuery ifNotExists() {\n    if (check()) {\n      return this;\n    }\n    if (!table) {\n      this.builder.append(\"IF NOT EXISTS\");\n    }\n    return this;\n  }\n  @Override\n  public CreateTableQuery rawColumns(@NotNull String... columns) {\n    if (check()) {\n      return this;\n    }\n    if (!table) {\n      return this;\n    }\n    final StringJoiner joiner = new StringJoiner(\", \", \" (\", \")\");\n    for (final String column : columns) {\n      joiner.add(column);\n    }\n    this.builder.append(joiner);\n    this.columns = true;\n    return this;\n  }\n  @Override\n  public CreateTableQuery columns(@NotNull Iterable<? extends ColumnMeta> columnMeta) {\n    if (check()) {\n      return this;\n    }\n    if (!table) {\n      return this;\n    }\n    final StringJoiner joiner = new StringJoiner(\", \", \" (\", \")\");\n    for (final ColumnMeta meta : columnMeta) {\n      joiner.add(dialectProvider.columnMetaToString(meta));\n    }\n    this.builder.append(joiner);\n    columns = true;\n    return this;\n  }\n  @Override\n  protected boolean subQuerySupported(@NotNull Query<?> sub) {\n    return false;\n  }\n  @Override\n  protected boolean check() {\n    return table && columns;\n  }\n"]], "pred": {"ppl": 1.7584006786346436, "ppl_lower": 1.8616254329681396, "ppl/lowercase_ppl": -1.1010716337813322, "ppl/zlib": 0.0010589206202736667, "Min_5.0% Prob": 5.875464760023972, "Min_10.0% Prob": 4.355689864734123, "Min_20.0% Prob": 2.666441661425126, "Min_30.0% Prob": 1.8517622993835672, "Min_40.0% Prob": 1.408652543910166, "Min_50.0% Prob": 1.1288312820577835, "Min_60.0% Prob": 0.9407387019640406}}
{"hexsha": "a9fe0b44577e5e671587b5147fdd73f0ab27ba15", "ext": "java", "lang": "Java", "content": "@Slf4j\r\npublic class Producer1 {\r\n\r\n    public static void main(String[] args){\r\n        Properties properties = new Properties();\r\n        properties.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, \"localhost:9092\");\r\n        properties.setProperty(ProducerConfig.CLIENT_ID_CONFIG, \"producer-01\");\r\n        properties.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\r\n        properties.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\r\n\r\n        try (KafkaProducer<String, String> producer = new KafkaProducer<>(properties)) {\r\n            ProducerRecord<String, String> record = new ProducerRecord<>(\"my-topic-01\", \"hello kafka\");\r\n            producer.send(record, (recordMetadata, e) -> {\r\n                if (e != null) {\r\n                    log.error(\"\u53d1\u9001\u6d88\u606f\u5931\u8d25: \", e);\r\n                } else {\r\n                    log.info(recordMetadata.topic() + \"-p:\"+recordMetadata.partition() +\"-o:\" + recordMetadata.offset());\r\n                }\r\n            });\r\n        } catch (Exception e) {\r\n            log.error(\"\u53d1\u9001\u6d88\u606f\u5931\u8d25: \", e);\r\n        }\r\n\r\n        new Stack().clear();\r\n    }\r\n}", "item_id": 0, "repo": "JackCharles/JavaProjects", "file": "daily-practice/src/main/java/com/zjee/kafka/Producer1.java", "last_update_at": "2022-03-31T22:46:59+00:00", "question_id": "a9fe0b44577e5e671587b5147fdd73f0ab27ba15_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\r\npublic class Producer1 {\r\n\r\n    public static void main(String[] args){\r\n        Properties properties = new Properties();\r\n        properties.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, \"localhost:9092\");\r\n        properties.setProperty(ProducerConfig.CLIENT_ID_CONFIG, \"producer-01\");\r\n        properties.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\r\n        properties.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\r\n\r\n        try (KafkaProducer<String, String> producer = new KafkaProducer<>(properties)) {\r\n            ProducerRecord<String, String> record = new ProducerRecord<>(\"my-topic-01\", \"hello kafka\");\r\n            producer.send(record, (recordMetadata, e) -> {\r\n                if (e != null) {\r\n                    log.error(\"\u53d1\u9001\u6d88\u606f\u5931\u8d25: \", e);\r\n                } else {\r\n                    log.info(recordMetadata.topic() + \"-p:\"+recordMetadata.partition() +\"-o:\" + recordMetadata.offset());\r\n                }\r\n            });\r\n        } catch (Exception e) {\r\n            log.error(\"\u53d1\u9001\u6d88\u606f\u5931\u8d25: \", e);\r\n        }\r\n\r\n        new Stack().clear();\r\n    }\r\n"]], "pred": {"ppl": 1.6727246046066284, "ppl_lower": 2.064462423324585, "ppl/lowercase_ppl": -1.4090086795411112, "ppl/zlib": 0.001026853885714916, "Min_5.0% Prob": 6.287358492612839, "Min_10.0% Prob": 4.148754701469883, "Min_20.0% Prob": 2.4248318587666127, "Min_30.0% Prob": 1.6808945980697576, "Min_40.0% Prob": 1.2851332784143847, "Min_50.0% Prob": 1.0304689250187948, "Min_60.0% Prob": 0.8579612351068766}}
{"hexsha": "d838cc8d671db03f477f194c75d8ecc5d220e129", "ext": "java", "lang": "Java", "content": "public final class Suppliers {\n\tprivate Suppliers() {}\n\n\t/**\n\t * Returns a new supplier which is the composition of the provided function\n\t * and supplier. In other words, the new supplier's value will be computed by\n\t * retrieving the value from {@code supplier}, and then applying\n\t * {@code function} to that value. Note that the resulting supplier will not\n\t * call {@code supplier} or invoke {@code function} until it is called.\n\t */\n\tpublic static <F, T> Supplier<T> compose(Function<? super F, T> function, Supplier<F> supplier) {\n\t\treturn () -> function.apply(supplier.get());\n\t}\n\n\t/**\n\t * Returns a supplier which caches the instance retrieved during the first\n\t * call to {@code get()} and returns that value on subsequent calls to\n\t * {@code get()}. See:\n\t * <a href=\"http://en.wikipedia.org/wiki/Memoization\">memoization</a>\n\t *\n\t * <p>The returned supplier is thread-safe.\n\t *\n\t * <p>If {@code delegate} is an instance created by an earlier call to {@code\n\t * memoize}, it is returned directly.\n\t */\n\tpublic static <T> Supplier<T> memoize(Supplier<T> delegate) {\n\t\treturn (delegate instanceof MemoizingSupplier) ? delegate : new MemoizingSupplier<>(Objects.requireNonNull(delegate));\n\t}\n\n\t@SuppressFBWarnings(value = \"IS2_INCONSISTENT_SYNC\", justification = \"It's a lightweight mechanism which ensures that delegate only gets called once.\")\n\tstatic class MemoizingSupplier<T> implements Supplier<T> {\n\t\tfinal Supplier<T> delegate;\n\t\tvolatile boolean initialized;\n\t\t// \"value\" does not need to be volatile; visibility piggy-backs\n\t\t// on volatile read of \"initialized\".\n\t\tT value;\n\n\t\tMemoizingSupplier(Supplier<T> delegate) {\n\t\t\tthis.delegate = delegate;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get() {\n\t\t\t// A 2-field variant of Double Checked Locking.\n\t\t\tif (!initialized) {\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\tif (!initialized) {\n\t\t\t\t\t\tT t = delegate.get();\n\t\t\t\t\t\tvalue = t;\n\t\t\t\t\t\tinitialized = true;\n\t\t\t\t\t\treturn t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Suppliers.memoize(\" + delegate + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * Returns a supplier that caches the instance supplied by the delegate and\n\t * removes the cached value after the specified time has passed. Subsequent\n\t * calls to {@code get()} return the cached value if the expiration time has\n\t * not passed. After the expiration time, a new value is retrieved, cached,\n\t * and returned. See:\n\t * <a href=\"http://en.wikipedia.org/wiki/Memoization\">memoization</a>\n\t *\n\t * <p>The returned supplier is thread-safe.\n\t *\n\t * @param duration the length of time after a value is created that it\n\t *     should stop being returned by subsequent {@code get()} calls\n\t * @param unit the unit that {@code duration} is expressed in\n\t * @throws IllegalArgumentException if {@code duration} is not positive\n\t * @since 2.0\n\t */\n\tpublic static <T> Supplier<T> memoizeWithExpiration(Supplier<T> delegate, long duration, TimeUnit unit) {\n\t\treturn new ExpiringMemoizingSupplier<>(delegate, duration, unit);\n\t}\n\n\tstatic class ExpiringMemoizingSupplier<T> implements Supplier<T> {\n\t\tfinal Supplier<T> delegate;\n\t\tfinal long durationNanos;\n\t\tvolatile T value;\n\t\t// The special value 0 means \"not yet initialized\".\n\t\tvolatile long expirationNanos;\n\n\t\tExpiringMemoizingSupplier(Supplier<T> delegate, long duration, TimeUnit unit) {\n\t\t\tthis.delegate = Objects.requireNonNull(delegate);\n\t\t\tthis.durationNanos = unit.toNanos(duration);\n\t\t\tif (!(duration > 0)) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic T get() {\n\t\t\t// Another variant of Double Checked Locking.\n\t\t\t//\n\t\t\t// We use two volatile reads.  We could reduce this to one by\n\t\t\t// putting our fields into a holder class, but (at least on x86)\n\t\t\t// the extra memory consumption and indirection are more\n\t\t\t// expensive than the extra volatile reads.\n\t\t\tlong nanos = expirationNanos;\n\t\t\tlong now = System.nanoTime();\n\t\t\tif (nanos == 0 || now - nanos >= 0) {\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\tif (nanos == expirationNanos) { // recheck for lost race\n\t\t\t\t\t\tT t = delegate.get();\n\t\t\t\t\t\tvalue = t;\n\t\t\t\t\t\tnanos = now + durationNanos;\n\t\t\t\t\t\t// In the very unlikely event that nanos is 0, set it to 1;\n\t\t\t\t\t\t// no one will notice 1 ns of tardiness.\n\t\t\t\t\t\texpirationNanos = (nanos == 0) ? 1 : nanos;\n\t\t\t\t\t\treturn t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t// This is a little strange if the unit the user provided was not NANOS,\n\t\t\t// but we don't want to store the unit just for toString\n\t\t\treturn \"Suppliers.memoizeWithExpiration(\" + delegate + \", \" + durationNanos + \", NANOS)\";\n\t\t}\n\t}\n\n\t/**\n\t * Returns a supplier that always supplies {@code instance}.\n\t */\n\tpublic static <T> Supplier<T> ofInstance(@Nullable T instance) {\n\t\treturn () -> instance;\n\t}\n\n\t/**\n\t * Returns a supplier whose {@code get()} method synchronizes on\n\t * {@code delegate} before calling it, making it thread-safe.\n\t */\n\tpublic static <T> Supplier<T> synchronizedSupplier(Supplier<T> delegate) {\n\t\treturn new ThreadSafeSupplier<>(Objects.requireNonNull(delegate));\n\t}\n\n\tprivate static class ThreadSafeSupplier<T> implements Supplier<T> {\n\t\tfinal Supplier<T> delegate;\n\n\t\tThreadSafeSupplier(Supplier<T> delegate) {\n\t\t\tthis.delegate = delegate;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get() {\n\t\t\tsynchronized (delegate) {\n\t\t\t\treturn delegate.get();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Suppliers.synchronizedSupplier(\" + delegate + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * Returns a function that accepts a supplier and returns the result of\n\t * invoking {@link Supplier#get} on that supplier.\n\t *\n\t * @since 8.0\n\t */\n\tpublic static <T> Function<Supplier<T>, T> supplierFunction() {\n\t\treturn Supplier::get;\n\t}\n}", "item_id": 0, "repo": "nedtwigg/durian", "file": "src/com/diffplug/common/base/Suppliers.java", "last_update_at": "2022-03-15T05:52:36+00:00", "question_id": "d838cc8d671db03f477f194c75d8ecc5d220e129_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class Suppliers {\n\tprivate Suppliers() {}\n\t/**\n\t * Returns a new supplier which is the composition of the provided function\n\t * and supplier. In other words, the new supplier's value will be computed by\n\t * retrieving the value from {@code supplier}, and then applying\n\t * {@code function} to that value. Note that the resulting supplier will not\n\t * call {@code supplier} or invoke {@code function} until it is called.\n\t */\n\tpublic static <F, T> Supplier<T> compose(Function<? super F, T> function, Supplier<F> supplier) {\n\t\treturn () -> function.apply(supplier.get());\n\t}\n\t/**\n\t * Returns a supplier which caches the instance retrieved during the first\n\t * call to {@code get()} and returns that value on subsequent calls to\n\t * {@code get()}. See:\n\t * <a href=\"http://en.wikipedia.org/wiki/Memoization\">memoization</a>\n\t *\n\t * <p>The returned supplier is thread-safe.\n\t *\n\t * <p>If {@code delegate} is an instance created by an earlier call to {@code\n\t * memoize}, it is returned directly.\n\t */\n\tpublic static <T> Supplier<T> memoize(Supplier<T> delegate) {\n\t\treturn (delegate instanceof MemoizingSupplier) ? delegate : new MemoizingSupplier<>(Objects.requireNonNull(delegate));\n\t}\n\t@SuppressFBWarnings(value = \"IS2_INCONSISTENT_SYNC\", justification = \"It's a lightweight mechanism which ensures that delegate only gets called once.\")\n\tstatic class MemoizingSupplier<T> implements Supplier<T> {\n\t\tfinal Supplier<T> delegate;\n\t\tvolatile boolean initialized;\n\t\t// \"value\" does not need to be volatile; visibility piggy-backs\n\t\t// on volatile read of \"initialized\".\n\t\tT value;\n\t\tMemoizingSupplier(Supplier<T> delegate) {\n\t\t\tthis.delegate = delegate;\n\t\t}\n\t\t@Override\n\t\tpublic T get() {\n\t\t\t// A 2-field variant of Double Checked Locking.\n\t\t\tif (!initialized) {\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\tif (!initialized) {\n\t\t\t\t\t\tT t = delegate.get();\n\t\t\t\t\t\tvalue = t;\n\t\t\t\t\t\tinitialized = true;\n\t\t\t\t\t\treturn t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Suppliers.memoize(\" + delegate + \")\";\n\t\t}\n\t}\n\t/**\n\t * Returns a supplier that caches the instance supplied by the delegate and\n\t * removes the cached value after the specified time has passed. Subsequent\n\t * calls to {@code get()} return the cached value if the expiration time has\n\t * not passed. After the expiration time, a new value is retrieved, cached,\n\t * and returned. See:\n\t * <a href=\"http://en.wikipedia.org/wiki/Memoization\">memoization</a>\n\t *\n\t * <p>The returned supplier is thread-safe.\n\t *\n\t * @param duration the length of time after a value is created that it\n\t *     should stop being returned by subsequent {@code get()} calls\n\t * @param unit the unit that {@code duration} is expressed in\n\t * @throws IllegalArgumentException if {@code duration} is not positive\n\t * @since 2.0\n\t */\n\tpublic static <T> Supplier<T> memoizeWithExpiration(Supplier<T> delegate, long duration, TimeUnit unit) {\n\t\treturn new ExpiringMemoizingSupplier<>(delegate, duration, unit);\n\t}\n\tstatic class ExpiringMemoizingSupplier<T> implements Supplier<T> {\n\t\tfinal Supplier<T> delegate;\n\t\tfinal long durationNanos;\n\t\tvolatile T value;\n\t\t// The special value 0 means \"not yet initialized\".\n\t\tvolatile long expirationNanos;\n\t\tExpiringMemoizingSupplier(Supplier<T> delegate, long duration, TimeUnit unit) {\n\t\t\tthis.delegate = Objects.requireNonNull(delegate);\n\t\t\tthis.durationNanos = unit.toNanos(duration);\n\t\t\tif (!(duration > 0)) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic T get() {\n\t\t\t// Another variant of Double Checked Locking.\n\t\t\t//\n\t\t\t// We use two volatile reads.  We could reduce this to one by\n\t\t\t// putting our fields into a holder class, but (at least on x86)\n\t\t\t// the extra memory consumption and indirection are more\n\t\t\t// expensive than the extra volatile reads.\n\t\t\tlong nanos = expirationNanos;\n\t\t\tlong now = System.nanoTime();\n\t\t\tif (nanos == 0 || now - nanos >= 0) {\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\tif (nanos == expirationNanos) { // recheck for lost race\n\t\t\t\t\t\tT t = delegate.get();\n\t\t\t\t\t\tvalue = t;\n\t\t\t\t\t\tnanos = now + durationNanos;\n\t\t\t\t\t\t// In the very unlikely event that nanos is 0, set it to 1;\n\t\t\t\t\t\t// no one will notice 1 ns of tardiness.\n\t\t\t\t\t\texpirationNanos = (nanos == 0) ? 1 : nanos;\n\t\t\t\t\t\treturn t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t// This is a little strange if the unit the user provided was not NANOS,\n\t\t\t// but we don't want to store the unit just for toString\n\t\t\treturn \"Suppliers.memoizeWithExpiration(\" + delegate + \", \" + durationNanos + \", NANOS)\";\n\t\t}\n\t}\n\t/**\n\t * Returns a supplier that always supplies {@code instance}.\n\t */\n\tpublic static <T> Supplier<T> ofInstance(@Nullable T instance) {\n\t\treturn () -> instance;\n\t}\n\t/**\n\t * Returns a supplier whose {@code get()} method synchronizes on\n\t * {@code delegate} before calling it, making it thread-safe.\n\t */\n\tpublic static <T> Supplier<T> synchronizedSupplier(Supplier<T> delegate) {\n\t\treturn new ThreadSafeSupplier<>(Objects.requireNonNull(delegate));\n\t}\n\tprivate static class ThreadSafeSupplier<T> implements Supplier<T> {\n\t\tfinal Supplier<T> delegate;\n\t\tThreadSafeSupplier(Supplier<T> delegate) {\n\t\t\tthis.delegate = delegate;\n\t\t}\n\t\t@Override\n\t\tpublic T get() {\n\t\t\tsynchronized (delegate) {\n\t\t\t\treturn delegate.get();\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Suppliers.synchronizedSupplier(\" + delegate + \")\";\n\t\t}\n\t}\n\t/**\n\t * Returns a function that accepts a supplier and returns the result of\n\t * invoking {@link Supplier#get} on that supplier.\n\t *\n\t * @since 8.0\n\t */\n\tpublic static <T> Function<Supplier<T>, T> supplierFunction() {\n\t\treturn Supplier::get;\n\t}\n"]], "pred": {"ppl": 1.3742109537124634, "ppl_lower": 1.704321026802063, "ppl/lowercase_ppl": -1.677259611914341, "ppl/zlib": 0.00017053632755207354, "Min_5.0% Prob": 4.256222283138948, "Min_10.0% Prob": 2.743235344395918, "Min_20.0% Prob": 1.5439718028932226, "Min_30.0% Prob": 1.0533109444004842, "Min_40.0% Prob": 0.7931956507306555, "Min_50.0% Prob": 0.6359561609702071, "Min_60.0% Prob": 0.5303805586783182}}
{"hexsha": "ea908cdd43afca34a367de1c2cc5222f2011e9b6", "ext": "java", "lang": "Java", "content": "public final class ProcessStartListener implements EventListener<ChannelInitEvent> {\n\n    private final Map<UUID, CompletableFuture<ProxyProcessMeta>> waitingProxies = new ConcurrentHashMap<>();\n    private final Map<UUID, CompletableFuture<ServerProcessMeta>> waitingServers = new ConcurrentHashMap<>();\n\n    @Override\n    public void onCall(final ChannelInitEvent event) {\n        if (event.getINetworkComponent() instanceof ProxyServer) {\n            final ProxyServer proxyServer = (ProxyServer) event.getINetworkComponent();\n            UUID uuid = proxyServer.getProcessMeta().getProperties().getObject(\"cloudnet:requestId\", UUID.class);\n            this.waitingProxies.remove(uuid).complete(proxyServer.getProcessMeta());\n        } else if (event.getINetworkComponent() instanceof MinecraftServer) {\n            final MinecraftServer proxyServer = (MinecraftServer) event.getINetworkComponent();\n            UUID uuid = proxyServer.getProcessMeta().getServerConfig().getProperties().getObject(\"cloudnet:requestId\", UUID.class);\n            this.waitingServers.remove(uuid).complete(proxyServer.getProcessMeta());\n        }\n    }\n\n    public CompletableFuture<ProxyProcessMeta> waitForProxy(UUID uuid) {\n        CompletableFuture<ProxyProcessMeta> future = new CompletableFuture<>();\n        this.waitingProxies.put(uuid, future);\n        return future;\n    }\n\n    public CompletableFuture<ServerProcessMeta> waitForServer(UUID uuid) {\n        CompletableFuture<ServerProcessMeta> future = new CompletableFuture<>();\n        this.waitingServers.put(uuid, future);\n        return future;\n    }\n}", "item_id": 0, "repo": "pavog/CloudNet", "file": "cloudnet-master/src/main/java/eu/cloudnetservice/cloudnet/v2/master/process/ProcessStartListener.java", "last_update_at": "2022-03-10T17:23:04+00:00", "question_id": "ea908cdd43afca34a367de1c2cc5222f2011e9b6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class ProcessStartListener implements EventListener<ChannelInitEvent> {\n    private final Map<UUID, CompletableFuture<ProxyProcessMeta>> waitingProxies = new ConcurrentHashMap<>();\n    private final Map<UUID, CompletableFuture<ServerProcessMeta>> waitingServers = new ConcurrentHashMap<>();\n    @Override\n    public void onCall(final ChannelInitEvent event) {\n        if (event.getINetworkComponent() instanceof ProxyServer) {\n            final ProxyServer proxyServer = (ProxyServer) event.getINetworkComponent();\n            UUID uuid = proxyServer.getProcessMeta().getProperties().getObject(\"cloudnet:requestId\", UUID.class);\n            this.waitingProxies.remove(uuid).complete(proxyServer.getProcessMeta());\n        } else if (event.getINetworkComponent() instanceof MinecraftServer) {\n            final MinecraftServer proxyServer = (MinecraftServer) event.getINetworkComponent();\n            UUID uuid = proxyServer.getProcessMeta().getServerConfig().getProperties().getObject(\"cloudnet:requestId\", UUID.class);\n            this.waitingServers.remove(uuid).complete(proxyServer.getProcessMeta());\n        }\n    }\n    public CompletableFuture<ProxyProcessMeta> waitForProxy(UUID uuid) {\n        CompletableFuture<ProxyProcessMeta> future = new CompletableFuture<>();\n        this.waitingProxies.put(uuid, future);\n        return future;\n    }\n    public CompletableFuture<ServerProcessMeta> waitForServer(UUID uuid) {\n        CompletableFuture<ServerProcessMeta> future = new CompletableFuture<>();\n        this.waitingServers.put(uuid, future);\n        return future;\n    }\n"]], "pred": {"ppl": 1.6970255374908447, "ppl_lower": 1.859913945198059, "ppl/lowercase_ppl": -1.1732977230277022, "ppl/zlib": 0.0011778998546740946, "Min_5.0% Prob": 6.93113785982132, "Min_10.0% Prob": 4.510343005017536, "Min_20.0% Prob": 2.564831265589086, "Min_30.0% Prob": 1.7536448189701006, "Min_40.0% Prob": 1.3203360704852767, "Min_50.0% Prob": 1.0572574160845452, "Min_60.0% Prob": 0.8813193935817638}}
{"hexsha": "d18ab24e1f43d1617b7d520a872d3d5a55e1cbfc", "ext": "java", "lang": "Java", "content": "public class AlgoTestRunner {\n\n\tprotected static final Logger s_log = MR4CLogging.getLogger(AlgoTestRunner.class);\n\n\tprivate AlgoTestSource m_testSrc;\n\tprivate MR4CConfig m_bbConf;\n\tprivate Map<String,DatasetDiff> m_diffs = new HashMap<String,DatasetDiff>();\n\tprivate boolean m_passed=true;\n\n\tpublic static void main(String argv[]) throws Exception {\n\t\tAlgoTestRunnerConfig config = new AlgoTestRunnerConfig(true);\n\t\tconfig.setCommandLineArguments(argv);\n\t\tconfig.configure();\n\t\tAlgoTestRunner runner = new AlgoTestRunner(config);\n\t\trunner.executeStandalone();\n\t}\n\n\tpublic AlgoTestRunner(AlgoTestRunnerConfig runnerConfig) throws IOException {\n\t\tthis(\n\t\t\trunnerConfig.getSource(),\n\t\t\trunnerConfig.getMR4CConfig()\n\t\t);\n\t}\n\n\tpublic AlgoTestRunner(AlgoTestSource testSrc) throws IOException {\n\t\tthis(\n\t\t\ttestSrc,\n\t\t\tMR4CConfig.getDefaultInstance()\n\t\t);\n\t}\n\n\tpublic AlgoTestRunner(AlgoTestSource testSrc, MR4CConfig bbConf) throws IOException {\n\t\tm_testSrc = testSrc;\n\t\tm_bbConf = bbConf;\n\t}\n\n\tpublic void executeStandalone() throws IOException {\n\t\texecute();\n\t\tcheckResults();\n\t}\n\n\tpublic void execute() throws IOException {\n\t\tExecutionSource exeSrc = m_testSrc.getExecutionSource();\n\t\tAlgoRunner algoRunner = new AlgoRunner(exeSrc, m_bbConf);\n\t\talgoRunner.executeStandalone();\n\t}\n\n\tpublic void checkResults() throws IOException {\n\t\tfor ( String name : m_testSrc.getOutputDiffNames() ) {\n\t\t\tDiffSource diffSrc = m_testSrc.getOutputDiffSource(name);\n\t\t\tDiffRunner diffRunner = new DiffRunner(diffSrc);\n\t\t\tdiffRunner.setMinimalOutput(true);\n\t\t\tdiffRunner.execute();\n\t\t\tDatasetDiff diff = diffRunner.getDiff();\n\t\t\tm_diffs.put(name, diff);\n\t\t\tif ( diff.different() ) {\n\t\t\t\tm_passed = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean isPassed() {\n\t\treturn m_passed;\n\t}\n\n\tpublic Map<String,DatasetDiff> getDiffs() {\n\t\treturn m_diffs;\n\t}\n\n\tpublic static class AlgoTestRunnerConfig extends MR4CRunnerConfig<AlgoTestSource> {\n\n\t\tpublic AlgoTestRunnerConfig(boolean dumpToFiles) {\n\t\t\tsuper(s_log, dumpToFiles);\n\t\t}\n\n\t\tprotected AlgoTestSource loadSource(URI confFile) throws IOException {\n\t\t\tConfiguredAlgoTestSource src = new ConfiguredAlgoTestSource(confFile);\n\t\t\tsrc.loadConfig();\n\t\t\treturn src;\n\t\t}\n\n\t}\n\n}", "item_id": 0, "repo": "icarazob/mr4c", "file": "java/src/java/com/google/mr4c/AlgoTestRunner.java", "last_update_at": "2022-03-23T10:16:07+00:00", "question_id": "d18ab24e1f43d1617b7d520a872d3d5a55e1cbfc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AlgoTestRunner {\n\tprotected static final Logger s_log = MR4CLogging.getLogger(AlgoTestRunner.class);\n\tprivate AlgoTestSource m_testSrc;\n\tprivate MR4CConfig m_bbConf;\n\tprivate Map<String,DatasetDiff> m_diffs = new HashMap<String,DatasetDiff>();\n\tprivate boolean m_passed=true;\n\tpublic static void main(String argv[]) throws Exception {\n\t\tAlgoTestRunnerConfig config = new AlgoTestRunnerConfig(true);\n\t\tconfig.setCommandLineArguments(argv);\n\t\tconfig.configure();\n\t\tAlgoTestRunner runner = new AlgoTestRunner(config);\n\t\trunner.executeStandalone();\n\t}\n\tpublic AlgoTestRunner(AlgoTestRunnerConfig runnerConfig) throws IOException {\n\t\tthis(\n\t\t\trunnerConfig.getSource(),\n\t\t\trunnerConfig.getMR4CConfig()\n\t\t);\n\t}\n\tpublic AlgoTestRunner(AlgoTestSource testSrc) throws IOException {\n\t\tthis(\n\t\t\ttestSrc,\n\t\t\tMR4CConfig.getDefaultInstance()\n\t\t);\n\t}\n\tpublic AlgoTestRunner(AlgoTestSource testSrc, MR4CConfig bbConf) throws IOException {\n\t\tm_testSrc = testSrc;\n\t\tm_bbConf = bbConf;\n\t}\n\tpublic void executeStandalone() throws IOException {\n\t\texecute();\n\t\tcheckResults();\n\t}\n\tpublic void execute() throws IOException {\n\t\tExecutionSource exeSrc = m_testSrc.getExecutionSource();\n\t\tAlgoRunner algoRunner = new AlgoRunner(exeSrc, m_bbConf);\n\t\talgoRunner.executeStandalone();\n\t}\n\tpublic void checkResults() throws IOException {\n\t\tfor ( String name : m_testSrc.getOutputDiffNames() ) {\n\t\t\tDiffSource diffSrc = m_testSrc.getOutputDiffSource(name);\n\t\t\tDiffRunner diffRunner = new DiffRunner(diffSrc);\n\t\t\tdiffRunner.setMinimalOutput(true);\n\t\t\tdiffRunner.execute();\n\t\t\tDatasetDiff diff = diffRunner.getDiff();\n\t\t\tm_diffs.put(name, diff);\n\t\t\tif ( diff.different() ) {\n\t\t\t\tm_passed = false;\n\t\t\t}\n\t\t}\n\t}\n\tpublic boolean isPassed() {\n\t\treturn m_passed;\n\t}\n\tpublic Map<String,DatasetDiff> getDiffs() {\n\t\treturn m_diffs;\n\t}\n\tpublic static class AlgoTestRunnerConfig extends MR4CRunnerConfig<AlgoTestSource> {\n\t\tpublic AlgoTestRunnerConfig(boolean dumpToFiles) {\n\t\t\tsuper(s_log, dumpToFiles);\n\t\t}\n\t\tprotected AlgoTestSource loadSource(URI confFile) throws IOException {\n\t\t\tConfiguredAlgoTestSource src = new ConfiguredAlgoTestSource(confFile);\n\t\t\tsrc.loadConfig();\n\t\t\treturn src;\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.7851283550262451, "ppl_lower": 1.9810813665390015, "ppl/lowercase_ppl": -1.1797312508619298, "ppl/zlib": 0.0007981960333665356, "Min_5.0% Prob": 6.481344593198676, "Min_10.0% Prob": 4.5960746693920775, "Min_20.0% Prob": 2.721448287463957, "Min_30.0% Prob": 1.894711396596974, "Min_40.0% Prob": 1.4430020670376478, "Min_50.0% Prob": 1.1578640871988513, "Min_60.0% Prob": 0.9654661296165344}}
{"hexsha": "cdc194423e239fc7f925c4e4d08b2c2096099253", "ext": "java", "lang": "Java", "content": "class Solution {\n    public List<String> findAllConcatenatedWordsInADict(String[] words) { \n        List<String> res = new LinkedList<>();\n        Set<String> set = new HashSet<>();\n        int minlen = Integer.MAX_VALUE;\n        \n        //build dict\n        for(String word : words){\n            if(word.length()>0){\n                set.add(word);\n                minlen = Math.min(minlen, word.length());\n            }\n        }\n        \n        //check each word and add good ones to dict\n        for(String word : words){\n            if(canForm(word, 0, minlen, set)){\n                res.add(word);\n            }\n        }\n        return res;\n    \n    }\n    \n    //no need to remove and add current word in this setup\n    private static boolean canForm(String word, int start, int offset, Set<String> set){\n        for(int mid=start+offset; mid<=word.length()-offset;mid++){\n            if(set.contains(word.substring(start,mid)) &&\n              (set.contains(word.substring(mid)) || canForm(word, mid, offset, set))) {//backtrack\n                return true;\n                }\n        }\n        return false;\n    }\n}", "item_id": 0, "repo": "rakhi2001/ecom7", "file": "Java/472.java", "last_update_at": "2022-03-31T06:05:53+00:00", "question_id": "cdc194423e239fc7f925c4e4d08b2c2096099253_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Solution {\n    public List<String> findAllConcatenatedWordsInADict(String[] words) { \n        List<String> res = new LinkedList<>();\n        Set<String> set = new HashSet<>();\n        int minlen = Integer.MAX_VALUE;\n        //build dict\n        for(String word : words){\n            if(word.length()>0){\n                set.add(word);\n                minlen = Math.min(minlen, word.length());\n            }\n        }\n        //check each word and add good ones to dict\n        for(String word : words){\n            if(canForm(word, 0, minlen, set)){\n                res.add(word);\n            }\n        }\n        return res;\n    }\n    //no need to remove and add current word in this setup\n    private static boolean canForm(String word, int start, int offset, Set<String> set){\n        for(int mid=start+offset; mid<=word.length()-offset;mid++){\n            if(set.contains(word.substring(start,mid)) &&\n              (set.contains(word.substring(mid)) || canForm(word, mid, offset, set))) {//backtrack\n                return true;\n                }\n        }\n        return false;\n    }\n"]], "pred": {"ppl": 2.287482738494873, "ppl_lower": 2.809941530227661, "ppl/lowercase_ppl": -1.2486086325066004, "ppl/zlib": 0.0017910215846880905, "Min_5.0% Prob": 7.446294784545898, "Min_10.0% Prob": 5.5117745245656655, "Min_20.0% Prob": 3.707475971791052, "Min_30.0% Prob": 2.668591983215783, "Min_40.0% Prob": 2.040050986409187, "Min_50.0% Prob": 1.6499343296417441, "Min_60.0% Prob": 1.3815416508020564}}
{"hexsha": "444ca9cb78c29026a7ce2db01d9000d5b632deb6", "ext": "java", "lang": "Java", "content": "@Component(immediate = true, service = MepStore.class)\npublic class DistributedMepStore extends AbstractStore<CfmMepEvent, MepStoreDelegate>\n    implements MepStore {\n\n    private final Logger log = LoggerFactory.getLogger(getClass());\n\n    @Reference(cardinality = ReferenceCardinality.MANDATORY)\n    protected StorageService storageService;\n\n    private ConsistentMap<MepKeyId, Mep> mepConsistentMap;\n    private Map<MepKeyId, Mep> mepMap;\n\n    private MapEventListener<MepKeyId, Mep> mapListener = null;\n\n    @Activate\n    public void activate() {\n        mepConsistentMap = storageService\n                .<MepKeyId, Mep>consistentMapBuilder()\n                .withName(\"onos-cfm-mep-map\")\n                .withSerializer(Serializer.using(new KryoNamespace.Builder()\n                        .register(KryoNamespaces.API)\n                        .register(DefaultMep.class)\n                        .register(MepId.class)\n                        .register(MepKeyId.class)\n                        .register(NetworkResource.class)\n                        .register(DeviceId.class)\n                        .register(PortNumber.class)\n                        .register(Mep.MepDirection.class)\n                        .register(VlanId.class)\n                        .register(Mep.Priority.class)\n                        .register(Mep.FngAddress.class)\n                        .register(Mep.FngAddressType.class)\n                        .register(IpAddress.class)\n                        .register(Mep.LowestFaultDefect.class)\n                        .register(Duration.class)\n                        .register(MdIdCharStr.class)\n                        .register(MdIdDomainName.class)\n                        .register(MdIdMacUint.class)\n                        .register(MdIdNone.class)\n                        .register(MaIdCharStr.class)\n                        .register(MaIdShort.class)\n                        .register(MaId2Octet.class)\n                        .register(MaIdIccY1731.class)\n                        .register(MaIdPrimaryVid.class)\n                        .register(MaIdRfc2685VpnId.class)\n                        .build(\"mep\")))\n                .build();\n        mapListener = new InternalMepListener();\n        mepConsistentMap.addListener(mapListener);\n\n        mepMap = mepConsistentMap.asJavaMap();\n        log.info(\"MepStore started\");\n    }\n\n    @Deactivate\n    public void deactivate() {\n        mepConsistentMap.removeListener(mapListener);\n        log.info(\"MepStore stopped\");\n    }\n\n    @Override\n    public Collection<Mep> getAllMeps() {\n        return mepMap.values();\n    }\n\n    @Override\n    public Collection<Mep> getMepsByMd(MdId mdName) {\n        return mepMap.values().stream()\n                .filter(mep -> mep.mdId().equals(mdName))\n                .collect(Collectors.toList());\n    }\n\n    @Override\n    public Collection<Mep> getMepsByMdMa(MdId mdName, MaIdShort maName) {\n        return mepMap.values().stream()\n                .filter(mep -> mep.mdId().equals(mdName) && mep.maId().equals(maName))\n                .collect(Collectors.toList());\n    }\n\n    @Override\n    public Collection<Mep> getMepsByDeviceId(DeviceId deviceId) {\n        return mepMap.values().stream()\n                .filter(mep -> mep.deviceId().equals(deviceId))\n                .collect(Collectors.toList());\n    }\n\n    @Override\n    public Optional<Mep> getMep(MepKeyId mepKeyId) {\n        return mepMap.values().stream()\n                .filter(mep -> mep.mdId().equals(mepKeyId.mdId()) &&\n                        mep.maId().equals(mepKeyId.maId()) &&\n                        mep.mepId().equals(mepKeyId.mepId()))\n                .findFirst();\n    }\n\n    @Override\n    public boolean deleteMep(MepKeyId mepKeyId) {\n        return mepMap.remove(mepKeyId) == null ? false : true;\n    }\n\n    @Override\n    public boolean createUpdateMep(MepKeyId mepKeyId, Mep mep) {\n        return mepMap.put(mepKeyId, mep) == null ? false : true;\n    }\n\n    private class InternalMepListener implements MapEventListener<MepKeyId, Mep> {\n\n        @Override\n        public void event(MapEvent<MepKeyId, Mep> mapEvent) {\n            final CfmMepEvent.Type type;\n\n            switch (mapEvent.type()) {\n                case INSERT:\n                    type = CfmMepEvent.Type.MEP_ADDED;\n                    break;\n                case UPDATE:\n                    type = CfmMepEvent.Type.MEP_UPDATED;\n                    break;\n                default:\n                case REMOVE:\n                    type = CfmMepEvent.Type.MEP_REMOVED;\n            }\n            notifyDelegate(new CfmMepEvent(type, mapEvent.key()));\n        }\n    }\n}", "item_id": 0, "repo": "meodaiduoi/onos", "file": "apps/cfm/app/src/main/java/org/onosproject/incubator/net/l2monitoring/cfm/impl/DistributedMepStore.java", "last_update_at": "2022-03-30T09:09:05+00:00", "question_id": "444ca9cb78c29026a7ce2db01d9000d5b632deb6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component(immediate = true, service = MepStore.class)\npublic class DistributedMepStore extends AbstractStore<CfmMepEvent, MepStoreDelegate>\n    implements MepStore {\n    private final Logger log = LoggerFactory.getLogger(getClass());\n    @Reference(cardinality = ReferenceCardinality.MANDATORY)\n    protected StorageService storageService;\n    private ConsistentMap<MepKeyId, Mep> mepConsistentMap;\n    private Map<MepKeyId, Mep> mepMap;\n    private MapEventListener<MepKeyId, Mep> mapListener = null;\n    @Activate\n    public void activate() {\n        mepConsistentMap = storageService\n                .<MepKeyId, Mep>consistentMapBuilder()\n                .withName(\"onos-cfm-mep-map\")\n                .withSerializer(Serializer.using(new KryoNamespace.Builder()\n                        .register(KryoNamespaces.API)\n                        .register(DefaultMep.class)\n                        .register(MepId.class)\n                        .register(MepKeyId.class)\n                        .register(NetworkResource.class)\n                        .register(DeviceId.class)\n                        .register(PortNumber.class)\n                        .register(Mep.MepDirection.class)\n                        .register(VlanId.class)\n                        .register(Mep.Priority.class)\n                        .register(Mep.FngAddress.class)\n                        .register(Mep.FngAddressType.class)\n                        .register(IpAddress.class)\n                        .register(Mep.LowestFaultDefect.class)\n                        .register(Duration.class)\n                        .register(MdIdCharStr.class)\n                        .register(MdIdDomainName.class)\n                        .register(MdIdMacUint.class)\n                        .register(MdIdNone.class)\n                        .register(MaIdCharStr.class)\n                        .register(MaIdShort.class)\n                        .register(MaId2Octet.class)\n                        .register(MaIdIccY1731.class)\n                        .register(MaIdPrimaryVid.class)\n                        .register(MaIdRfc2685VpnId.class)\n                        .build(\"mep\")))\n                .build();\n        mapListener = new InternalMepListener();\n        mepConsistentMap.addListener(mapListener);\n        mepMap = mepConsistentMap.asJavaMap();\n        log.info(\"MepStore started\");\n    }\n    @Deactivate\n    public void deactivate() {\n        mepConsistentMap.removeListener(mapListener);\n        log.info(\"MepStore stopped\");\n    }\n    @Override\n    public Collection<Mep> getAllMeps() {\n        return mepMap.values();\n    }\n    @Override\n    public Collection<Mep> getMepsByMd(MdId mdName) {\n        return mepMap.values().stream()\n                .filter(mep -> mep.mdId().equals(mdName))\n                .collect(Collectors.toList());\n    }\n    @Override\n    public Collection<Mep> getMepsByMdMa(MdId mdName, MaIdShort maName) {\n        return mepMap.values().stream()\n                .filter(mep -> mep.mdId().equals(mdName) && mep.maId().equals(maName))\n                .collect(Collectors.toList());\n    }\n    @Override\n    public Collection<Mep> getMepsByDeviceId(DeviceId deviceId) {\n        return mepMap.values().stream()\n                .filter(mep -> mep.deviceId().equals(deviceId))\n                .collect(Collectors.toList());\n    }\n    @Override\n    public Optional<Mep> getMep(MepKeyId mepKeyId) {\n        return mepMap.values().stream()\n                .filter(mep -> mep.mdId().equals(mepKeyId.mdId()) &&\n                        mep.maId().equals(mepKeyId.maId()) &&\n                        mep.mepId().equals(mepKeyId.mepId()))\n                .findFirst();\n    }\n    @Override\n    public boolean deleteMep(MepKeyId mepKeyId) {\n        return mepMap.remove(mepKeyId) == null ? false : true;\n    }\n    @Override\n    public boolean createUpdateMep(MepKeyId mepKeyId, Mep mep) {\n        return mepMap.put(mepKeyId, mep) == null ? false : true;\n    }\n    private class InternalMepListener implements MapEventListener<MepKeyId, Mep> {\n        @Override\n        public void event(MapEvent<MepKeyId, Mep> mapEvent) {\n            final CfmMepEvent.Type type;\n            switch (mapEvent.type()) {\n                case INSERT:\n                    type = CfmMepEvent.Type.MEP_ADDED;\n                    break;\n                case UPDATE:\n                    type = CfmMepEvent.Type.MEP_UPDATED;\n                    break;\n                default:\n                case REMOVE:\n                    type = CfmMepEvent.Type.MEP_REMOVED;\n            }\n            notifyDelegate(new CfmMepEvent(type, mapEvent.key()));\n        }\n    }\n"]], "pred": {"ppl": 1.5443426370620728, "ppl_lower": 2.134902000427246, "ppl/lowercase_ppl": -1.7451073107775865, "ppl/zlib": 0.00038562408356583193, "Min_5.0% Prob": 5.479559510361915, "Min_10.0% Prob": 3.674740722366408, "Min_20.0% Prob": 2.1018680247898196, "Min_30.0% Prob": 1.4396616383729612, "Min_40.0% Prob": 1.0840265881201858, "Min_50.0% Prob": 0.8693118782161777, "Min_60.0% Prob": 0.7250483587728342}}
{"hexsha": "6ebe14be1f20975df8ddde807635d4212e191180", "ext": "java", "lang": "Java", "content": "public class LogBuiltin extends Builtin {\n  @Override public String repr() {\n    return \"\u235f\";\n  }\n  \n  \n  static final double LN2 = Math.log(2);\n  \n  public static final NumMV NF = new NumMV() {\n    public Value call(Num w) {\n      return w.log(Num.E);\n    }\n    public void call(double[] res, double[] a) {\n      for (int i = 0; i < a.length; i++) res[i] = Math.log(a[i]);\n    }\n    public Num call(BigValue w) {\n      if (w.i.signum() <= 0) {\n        if (w.i.signum() == -1) throw new DomainError(\"logarithm of negative number\", w);\n        return Num.NEGINF;\n      }\n      if (w.i.bitLength()<1023) return new Num(Math.log(w.i.doubleValue())); // safe quick path\n      int len = w.i.bitLength();\n      int shift = len > 64? len - 64 : 0; // 64 msb should be enough to get most out of log\n      double d = w.i.shiftRight(shift).doubleValue();\n      return new Num(Math.log(d) + LN2*shift);\n    }\n  };\n  public Value call(Value w) {\n    return numM(NF, w);\n  }\n  public Value callInv(Value w) {\n    return numM(StarBuiltin.NF, w);\n  }\n  \n  public static final D_NNeN DNF = new D_NNeN() {\n    public double on(double a, double w) {\n      return Math.log(w) / Math.log(a);\n    }\n    public void on(double[] res, double a, double[] w) {\n      double la = Math.log(a);\n      for (int i = 0; i < w.length; i++) res[i] = Math.log(w[i]) / la;\n    }\n    public void on(double[] res, double[] a, double w) {\n      double lw = Math.log(w);\n      for (int i = 0; i < a.length; i++) res[i] = lw / Math.log(a[i]);\n    }\n    public void on(double[] res, double[] a, double[] w) {\n      for (int i = 0; i < a.length; i++) res[i] = Math.log(w[i]) / Math.log(a[i]);\n    }\n    public Value call(double a, BigValue w) {\n      double res = ((Num) NF.call(w)).num/Math.log(a);\n      if (a==2) { // quick path to make sure 2\u235f makes sense\n        int expected = w.i.bitLength()-1;\n        // System.out.println(res+\" > \"+expected);\n        if (res < expected) return Num.of(expected);\n        if (res >= expected+1) { // have to get the double juuuust below expected\n          long repr = Double.doubleToRawLongBits(expected+1);\n          repr--; // should be safe as positive int values are always well into the proper double domain\n          return new Num(Double.longBitsToDouble(repr));\n        }\n      }\n      return new Num(res);\n    }\n  };\n  public Value call(Value a0, Value w0) {\n    return numD(DNF, a0, w0);\n  }\n  \n  @Override public Value callInvW(Value a, Value w) {\n    return numD(StarBuiltin.DNF, a, w);\n  }\n  @Override public Value callInvA(Value a, Value w) {\n    return numD(RootBuiltin.DNF, a, w);\n  }\n}", "item_id": 0, "repo": "AndersonTorres/APL", "file": "src/APL/types/functions/builtins/fns/LogBuiltin.java", "last_update_at": "2022-03-16T17:35:32+00:00", "question_id": "6ebe14be1f20975df8ddde807635d4212e191180_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LogBuiltin extends Builtin {\n  @Override public String repr() {\n    return \"\u235f\";\n  }\n  static final double LN2 = Math.log(2);\n  public static final NumMV NF = new NumMV() {\n    public Value call(Num w) {\n      return w.log(Num.E);\n    }\n    public void call(double[] res, double[] a) {\n      for (int i = 0; i < a.length; i++) res[i] = Math.log(a[i]);\n    }\n    public Num call(BigValue w) {\n      if (w.i.signum() <= 0) {\n        if (w.i.signum() == -1) throw new DomainError(\"logarithm of negative number\", w);\n        return Num.NEGINF;\n      }\n      if (w.i.bitLength()<1023) return new Num(Math.log(w.i.doubleValue())); // safe quick path\n      int len = w.i.bitLength();\n      int shift = len > 64? len - 64 : 0; // 64 msb should be enough to get most out of log\n      double d = w.i.shiftRight(shift).doubleValue();\n      return new Num(Math.log(d) + LN2*shift);\n    }\n  };\n  public Value call(Value w) {\n    return numM(NF, w);\n  }\n  public Value callInv(Value w) {\n    return numM(StarBuiltin.NF, w);\n  }\n  public static final D_NNeN DNF = new D_NNeN() {\n    public double on(double a, double w) {\n      return Math.log(w) / Math.log(a);\n    }\n    public void on(double[] res, double a, double[] w) {\n      double la = Math.log(a);\n      for (int i = 0; i < w.length; i++) res[i] = Math.log(w[i]) / la;\n    }\n    public void on(double[] res, double[] a, double w) {\n      double lw = Math.log(w);\n      for (int i = 0; i < a.length; i++) res[i] = lw / Math.log(a[i]);\n    }\n    public void on(double[] res, double[] a, double[] w) {\n      for (int i = 0; i < a.length; i++) res[i] = Math.log(w[i]) / Math.log(a[i]);\n    }\n    public Value call(double a, BigValue w) {\n      double res = ((Num) NF.call(w)).num/Math.log(a);\n      if (a==2) { // quick path to make sure 2\u235f makes sense\n        int expected = w.i.bitLength()-1;\n        // System.out.println(res+\" > \"+expected);\n        if (res < expected) return Num.of(expected);\n        if (res >= expected+1) { // have to get the double juuuust below expected\n          long repr = Double.doubleToRawLongBits(expected+1);\n          repr--; // should be safe as positive int values are always well into the proper double domain\n          return new Num(Double.longBitsToDouble(repr));\n        }\n      }\n      return new Num(res);\n    }\n  };\n  public Value call(Value a0, Value w0) {\n    return numD(DNF, a0, w0);\n  }\n  @Override public Value callInvW(Value a, Value w) {\n    return numD(StarBuiltin.DNF, a, w);\n  }\n  @Override public Value callInvA(Value a, Value w) {\n    return numD(RootBuiltin.DNF, a, w);\n  }\n"]], "pred": {"ppl": 2.257079601287842, "ppl_lower": 2.628934144973755, "ppl/lowercase_ppl": -1.1873381887644328, "ppl/zlib": 0.0008936023774303122, "Min_5.0% Prob": 6.88686948126935, "Min_10.0% Prob": 5.182671551955374, "Min_20.0% Prob": 3.504970569987046, "Min_30.0% Prob": 2.578083251129117, "Min_40.0% Prob": 1.9994744485992146, "Min_50.0% Prob": 1.6204985288762246, "Min_60.0% Prob": 1.3562753999184967}}
{"hexsha": "d8642d783d805ae418aec30e5673ceea837328e1", "ext": "java", "lang": "Java", "content": "public class ArrayOfDoubledPairs {\n    public static void main(String[] args) {\n\n        ArrayOfDoubledPairs arrayOfDoubledPairs = new ArrayOfDoubledPairs();\n       // arrayOfDoubledPairs.canReorderDoubled(new int[]{4, -2, 2, -4});\n        arrayOfDoubledPairs.canReorderDoubled(new int[]{-33,0});\n    }\n\n    public boolean canReorderDoubled(int[] arr) {\n\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        for (int num : arr) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        Arrays.sort(arr);\n        for (int num : arr) {\n            if(!map.containsKey(num)) continue;\n            int doubleNum = num * 2;\n            int halfNum=Integer.MAX_VALUE;\n            if(num%2==0)\n                halfNum=num/2;\n\n            if (map.containsKey(doubleNum)) {\n                map.put(num, map.get(num) - 1);\n                if (map.get(num) == 0)\n                    map.remove(num);\n\n                if(!map.containsKey(doubleNum)) return false;\n                map.put(doubleNum, map.get(doubleNum) - 1);\n                if (map.get(doubleNum) == 0)\n                    map.remove(doubleNum);\n\n            } else if(map.containsKey(halfNum)){\n                if(halfNum!= Integer.MAX_VALUE){\n                    map.put(num, map.get(num) - 1);\n                    if (map.get(num) == 0)\n                        map.remove(num);\n                    if(!map.containsKey(halfNum)) return false;\n\n                    map.put(halfNum, map.get(halfNum) - 1);\n                    if (map.get(halfNum) == 0)\n                        map.remove(halfNum);\n                }\n            }\n        }\n        if (map.isEmpty()) return true;\n        return false;\n    }\n}", "item_id": 0, "repo": "nanofaroque/Life-coding", "file": "src/effort_2021/ArrayOfDoubledPairs.java", "last_update_at": "2022-03-31T18:43:52+00:00", "question_id": "d8642d783d805ae418aec30e5673ceea837328e1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ArrayOfDoubledPairs {\n    public static void main(String[] args) {\n        ArrayOfDoubledPairs arrayOfDoubledPairs = new ArrayOfDoubledPairs();\n       // arrayOfDoubledPairs.canReorderDoubled(new int[]{4, -2, 2, -4});\n        arrayOfDoubledPairs.canReorderDoubled(new int[]{-33,0});\n    }\n    public boolean canReorderDoubled(int[] arr) {\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        for (int num : arr) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        Arrays.sort(arr);\n        for (int num : arr) {\n            if(!map.containsKey(num)) continue;\n            int doubleNum = num * 2;\n            int halfNum=Integer.MAX_VALUE;\n            if(num%2==0)\n                halfNum=num/2;\n            if (map.containsKey(doubleNum)) {\n                map.put(num, map.get(num) - 1);\n                if (map.get(num) == 0)\n                    map.remove(num);\n                if(!map.containsKey(doubleNum)) return false;\n                map.put(doubleNum, map.get(doubleNum) - 1);\n                if (map.get(doubleNum) == 0)\n                    map.remove(doubleNum);\n            } else if(map.containsKey(halfNum)){\n                if(halfNum!= Integer.MAX_VALUE){\n                    map.put(num, map.get(num) - 1);\n                    if (map.get(num) == 0)\n                        map.remove(num);\n                    if(!map.containsKey(halfNum)) return false;\n                    map.put(halfNum, map.get(halfNum) - 1);\n                    if (map.get(halfNum) == 0)\n                        map.remove(halfNum);\n                }\n            }\n        }\n        if (map.isEmpty()) return true;\n        return false;\n    }\n"]], "pred": {"ppl": 1.5599991083145142, "ppl_lower": 1.8369243144989014, "ppl/lowercase_ppl": -1.3674674508290732, "ppl/zlib": 0.0009075209176898411, "Min_5.0% Prob": 5.224079847335815, "Min_10.0% Prob": 3.4672791086710415, "Min_20.0% Prob": 2.0900179227193196, "Min_30.0% Prob": 1.459075371123803, "Min_40.0% Prob": 1.104694822723312, "Min_50.0% Prob": 0.8888891859776304, "Min_60.0% Prob": 0.740459200058369}}
{"hexsha": "d11d295afdb7aa2ecfcb7a3f568ee00239877175", "ext": "java", "lang": "Java", "content": "public class IgniteSqlDistributedJoin2SelfTest extends AbstractIndexingCommonTest {\n    /** */\n    private static final int NODES_COUNT = 3;\n\n    /** */\n    private static final String PERSON_CACHE = \"person\";\n\n    /** */\n    private static final String MED_INFO_CACHE = \"medical_info\";\n\n    /** */\n    private static final String BLOOD_INFO_PJ_CACHE = \"blood_group_info_PJ\";\n\n    /** */\n    private static final String BLOOD_INFO_P_CACHE = \"blood_group_info_P\";\n\n    /** {@inheritDoc} */\n    @Override protected void afterTest() throws Exception {\n        stopAllGrids();\n\n        super.afterTest();\n    }\n\n    /**\n     * Check distributed OUTER join of 3 tables (T1 -> T2 -> T3) returns correct result\n     * for non-collocated data.\n     *\n     * <ul>\n     *     <li>Create single cache with multiple query entities.</li>\n     *     <li>Put data into cache.</li>\n     *     <li>Check query with distributedJoin=true returns correct results.</li>\n     * </ul>\n     *\n     * @throws Exception If failed.\n     */\n    @Ignore(\"https://ggsystems.atlassian.net/browse/GG-29449\")\n    @Test\n    public void testNonCollocatedDistributedJoinSingleCache() throws Exception {\n        startGridsMultiThreaded(NODES_COUNT, false);\n\n        QueryEntity bgQueryEntity = new QueryEntity(String.class, BloodGroupInfoP.class)\n            .setTableName(BLOOD_INFO_P_CACHE)\n            .setKeyFieldName(\"blood_group\");\n\n        bgQueryEntity.getFields().put(\"blood_group\", String.class.toString());\n\n        IgniteCache<Object, Object> cache = ignite(0).createCache(\n            new CacheConfiguration<>(DEFAULT_CACHE_NAME)\n                .setQueryEntities(Arrays.asList(\n                    new QueryEntity(String.class, Person.class).setTableName(PERSON_CACHE),\n                    new QueryEntity(Long.class, MedicalInfo.class).setTableName(MED_INFO_CACHE),\n                    new QueryEntity(Long.class, BloodGroupInfoPJ.class).setTableName(BLOOD_INFO_PJ_CACHE),\n                    bgQueryEntity\n                ))\n        );\n\n        awaitPartitionMapExchange();\n\n        populatePersonData(cache);\n        populateMedInfoData(cache);\n        populateBloodGrpPJData(cache);\n        populateBloodGrpPData(cache);\n\n        checkQueries(cache);\n    }\n\n    /**\n     * Check distributed OUTER join of 3 tables (T1 -> T2 -> T3) returns correct result\n     * for non-collocated data.\n     *\n     * <ul>\n     *     <li>Create caches for query entities (single query entity per cache).</li>\n     *     <li>Put data into cache.</li>\n     *     <li>Check query with distributedJoin=true returns correct results.</li>\n     * </ul>\n     *\n     * @throws Exception If failed.\n     */\n    @Test\n    public void testNonCollocatedDistributedJoin() throws Exception {\n        startGridsMultiThreaded(NODES_COUNT, false);\n\n        IgniteCache<Object, Object> personCache = ignite(0).createCache(\n            new CacheConfiguration<>(PERSON_CACHE).setQueryEntities(Collections.singleton(\n                new QueryEntity(String.class, Person.class)))\n                .setSqlSchema(\"PUBLIC\")\n        );\n\n        IgniteCache<Object, Object> medInfoCache = ignite(0).createCache(\n            new CacheConfiguration<>(MED_INFO_CACHE).setQueryEntities(Collections.singleton(\n                new QueryEntity(Long.class, MedicalInfo.class).setTableName(MED_INFO_CACHE)))\n                .setSqlSchema(\"PUBLIC\")\n        );\n\n        IgniteCache<Object, Object> bloodGrpCache1 = ignite(0).createCache(\n            new CacheConfiguration<>(BLOOD_INFO_PJ_CACHE).setQueryEntities(Collections.singleton(\n                new QueryEntity(Long.class, BloodGroupInfoPJ.class).setTableName(BLOOD_INFO_PJ_CACHE)))\n                .setSqlSchema(\"PUBLIC\")\n        );\n\n        final QueryEntity bgQueryEntity = new QueryEntity(String.class, BloodGroupInfoP.class).setTableName(BLOOD_INFO_P_CACHE)\n            .setKeyFieldName(\"blood_group\");\n        bgQueryEntity.getFields().put(\"blood_group\", String.class.toString());\n\n        IgniteCache<Object, Object> bloodGrpCache2 = ignite(0).createCache(\n            new CacheConfiguration<>(BLOOD_INFO_P_CACHE).setQueryEntities(Collections.singleton(\n                bgQueryEntity))\n                .setSqlSchema(\"PUBLIC\")\n        );\n\n        awaitPartitionMapExchange();\n\n        populatePersonData(personCache);\n        populateMedInfoData(medInfoCache);\n        populateBloodGrpPJData(bloodGrpCache1);\n        populateBloodGrpPData(bloodGrpCache2);\n\n        checkQueries(personCache);\n    }\n\n    /**\n     * Start queries and check query results.\n     *\n     * @param cache Cache.\n     */\n    private void checkQueries(IgniteCache<Object, Object> cache) {\n        // Join on secondary index.\n        SqlFieldsQuery qry1 = new SqlFieldsQuery(\"SELECT person.id, person.name, medical_info.blood_group, blood_group_info_PJ.universal_donor FROM person\\n\" +\n            \"  LEFT JOIN medical_info ON medical_info.name = person.name \\n\" +\n            \"  LEFT JOIN blood_group_info_PJ ON blood_group_info_PJ.blood_group = medical_info.blood_group;\");\n\n        // Join on primary index.\n        SqlFieldsQuery qry2 = new SqlFieldsQuery(\"SELECT person.id, person.name, medical_info.blood_group, blood_group_info_P.universal_donor FROM person\\n\" +\n            \"  LEFT JOIN medical_info ON medical_info.name = person.name \\n\" +\n            \"  LEFT JOIN blood_group_info_P ON blood_group_info_P.blood_group = medical_info.blood_group;\");\n\n        qry1.setDistributedJoins(true);\n        qry2.setDistributedJoins(true);\n\n        final String res1 = queryResultAsString(cache.query(qry1).getAll());\n        final String res2 = queryResultAsString(cache.query(qry2).getAll());\n\n        log.info(\"Query1 result: \\n\" + res1);\n        log.info(\"Query2 result: \\n\" + res2);\n\n        String expOut = \"2001,Shravya,null,null\\n\" +\n            \"2002,Kiran,O+,O+A+B+AB+\\n\" +\n            \"2003,Harika,AB+,AB+\\n\" +\n            \"2004,Srinivas,null,null\\n\" +\n            \"2005,Madhavi,A+,A+AB+\\n\" +\n            \"2006,Deeps,null,null\\n\" +\n            \"2007,Hope,null,null\\n\";\n\n        assertEquals(\"Wrong result\", expOut, res1);\n        assertEquals(\"Wrong result\", expOut, res2);\n    }\n\n    /**\n     * Convert query result to string.\n     *\n     * @param res Query result set.\n     * @return String representation.\n     */\n    private String queryResultAsString(List<List<?>> res) {\n        List<String> results = new ArrayList<>();\n\n        for (List<?> row : res) {\n            StringBuilder sb = new StringBuilder();\n            for (Iterator<?> iterator = row.iterator(); iterator.hasNext(); ) {\n                sb.append(iterator.next());\n\n                if (iterator.hasNext())\n                    sb.append(',');\n            }\n            results.add(sb.toString());\n        }\n\n        results.sort(String::compareTo);\n\n        StringBuilder sb = new StringBuilder();\n\n        for (String result : results)\n            sb.append(result).append('\\n');\n\n        return sb.toString();\n    }\n\n    /**\n     * @param cache Ignite cache.\n     */\n    private void populatePersonData(IgniteCache<Object, Object> cache) {\n        cache.put(\"Shravya\", new Person(2001, \"Shravya\"));\n        cache.put(\"Kiran\", new Person(2002, \"Kiran\"));\n        cache.put(\"Harika\", new Person(2003, \"Harika\"));\n        cache.put(\"Srinivas\", new Person(2004, \"Srinivas\"));\n        cache.put(\"Madhavi\", new Person(2005, \"Madhavi\"));\n        cache.put(\"Deeps\", new Person(2006, \"Deeps\"));\n        cache.put(\"Hope\", new Person(2007, \"Hope\"));\n    }\n\n    /**\n     * @param cache Ignite cache.\n     */\n    private void populateMedInfoData(IgniteCache<Object, Object> cache) {\n        cache.put(2001L, new MedicalInfo(2001, \"Madhavi\", \"A+\"));\n        cache.put(2002L, new MedicalInfo(2002, \"Diggi\", \"B+\"));\n        cache.put(2003L, new MedicalInfo(2003, \"Kiran\", \"O+\"));\n        cache.put(2004L, new MedicalInfo(2004, \"Harika\", \"AB+\"));\n    }\n\n    /**\n     * @param cache Ignite cache.\n     */\n    private void populateBloodGrpPJData(IgniteCache<Object, Object> cache) {\n        cache.put(2001L, new BloodGroupInfoPJ(2001, \"A+\", \"A+AB+\"));\n        cache.put(2002L, new BloodGroupInfoPJ(2002, \"O+\", \"O+A+B+AB+\"));\n        cache.put(2003L, new BloodGroupInfoPJ(2003, \"B+\", \"B+AB+\"));\n        cache.put(2004L, new BloodGroupInfoPJ(2004, \"AB+\", \"AB+\"));\n        cache.put(2005L, new BloodGroupInfoPJ(2005, \"O-\", \"EveryOne\"));\n    }\n\n    /**\n     * @param cache Ignite cache.\n     */\n    private void populateBloodGrpPData(IgniteCache<Object, Object> cache) {\n        cache.put(\"A+\", new BloodGroupInfoP(2001, \"A+\", \"A+AB+\"));\n        cache.put(\"O+\", new BloodGroupInfoP(2002, \"O+\", \"O+A+B+AB+\"));\n        cache.put(\"B+\", new BloodGroupInfoP(2003, \"B+\", \"B+AB+\"));\n        cache.put(\"AB+\", new BloodGroupInfoP(2004, \"AB+\", \"AB+\"));\n        cache.put(\"O-\", new BloodGroupInfoP(2005, \"O-\", \"EveryOne\"));\n    }\n\n    /**\n     *\n     */\n    private static class Person {\n        /** */\n        @QuerySqlField\n        private long id;\n\n        /** */\n        @QuerySqlField\n        private String name;\n\n        Person(long id, String name) {\n            this.id = id;\n            this.name = name;\n        }\n\n        public long getId() { return id; }\n\n        public void setId(long id) { this.id = id; }\n\n        public String getName() { return name; }\n\n        public void setName(String name) { this.name = name; }\n    }\n\n    /**\n     *\n     */\n    private static class MedicalInfo {\n        /** */\n        @QuerySqlField\n        private long id;\n\n        /** */\n        @QuerySqlField(index = true)\n        private String name;\n\n        /** */\n        @QuerySqlField(name = \"blood_group\")\n        private String bloodGroup;\n\n        MedicalInfo(long id, String name, String bloodGroup) {\n            this.id = id;\n            this.name = name;\n            this.bloodGroup = bloodGroup;\n        }\n\n        public void setId(long id) { this.id = id; }\n\n        public long getId() { return id; }\n\n        public String getName() { return name; }\n\n        public void setName(String name) { this.name = name; }\n\n        public String getBloodGroup() { return bloodGroup; }\n\n        public void setBloodGroup(String bloodGroup) { this.bloodGroup = bloodGroup; }\n    }\n\n    /**\n     *\n     */\n    private static class BloodGroupInfoPJ {\n        /** */\n        @QuerySqlField\n        private long id;\n\n        /** */\n        @QuerySqlField(index = true, name = \"blood_group\")\n        private String bloodGroup;\n\n        /** */\n        @QuerySqlField(name = \"universal_donor\")\n        private String universalDonor;\n\n        BloodGroupInfoPJ(long id, String bloodGroup, String universalDonor) {\n            this.id = id;\n            this.bloodGroup = bloodGroup;\n            this.universalDonor = universalDonor;\n        }\n\n        public void setId(long id) { this.id = id; }\n\n        public long getId() { return id; }\n\n        public String getBloodGroup() { return bloodGroup; }\n\n        public void setBloodGroup(String bloodGroup) { this.bloodGroup = bloodGroup; }\n\n        public String getUniversalDonor() { return universalDonor; }\n\n        public void setUniversalDonor(String universalDonor) { this.universalDonor = universalDonor; }\n    }\n\n    /**\n     *\n     */\n    private static class BloodGroupInfoP {\n        /** */\n        private long id;\n\n        /** */\n        @QuerySqlField\n        private String bloodGroup;  // PK\n\n        /** */\n        @QuerySqlField(name = \"universal_donor\")\n        private String universalDonor;\n\n        BloodGroupInfoP(long id, String bloodGroup, String universalDonor) {\n            this.id = id;\n            this.bloodGroup = bloodGroup;\n            this.universalDonor = universalDonor;\n        }\n\n        public void setId(long id) { this.id = id; }\n\n        public long getId() { return id; }\n\n        public String getBloodGroup() { return bloodGroup; }\n\n        public void setBloodGroup(String bloodGroup) { this.bloodGroup = bloodGroup; }\n\n        public String getUniversalDonor() { return universalDonor; }\n\n        public void setUniversalDonor(String universalDonor) { this.universalDonor = universalDonor; }\n    }\n}", "item_id": 0, "repo": "tsdb-io/gridgain", "file": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/IgniteSqlDistributedJoin2SelfTest.java", "last_update_at": "2022-03-28T05:28:55+00:00", "question_id": "d11d295afdb7aa2ecfcb7a3f568ee00239877175_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IgniteSqlDistributedJoin2SelfTest extends AbstractIndexingCommonTest {\n    /** */\n    private static final int NODES_COUNT = 3;\n    /** */\n    private static final String PERSON_CACHE = \"person\";\n    /** */\n    private static final String MED_INFO_CACHE = \"medical_info\";\n    /** */\n    private static final String BLOOD_INFO_PJ_CACHE = \"blood_group_info_PJ\";\n    /** */\n    private static final String BLOOD_INFO_P_CACHE = \"blood_group_info_P\";\n    /** {@inheritDoc} */\n    @Override protected void afterTest() throws Exception {\n        stopAllGrids();\n        super.afterTest();\n    }\n    /**\n     * Check distributed OUTER join of 3 tables (T1 -> T2 -> T3) returns correct result\n     * for non-collocated data.\n     *\n     * <ul>\n     *     <li>Create single cache with multiple query entities.</li>\n     *     <li>Put data into cache.</li>\n     *     <li>Check query with distributedJoin=true returns correct results.</li>\n     * </ul>\n     *\n     * @throws Exception If failed.\n     */\n    @Ignore(\"https://ggsystems.atlassian.net/browse/GG-29449\")\n    @Test\n    public void testNonCollocatedDistributedJoinSingleCache() throws Exception {\n        startGridsMultiThreaded(NODES_COUNT, false);\n        QueryEntity bgQueryEntity = new QueryEntity(String.class, BloodGroupInfoP.class)\n            .setTableName(BLOOD_INFO_P_CACHE)\n            .setKeyFieldName(\"blood_group\");\n        bgQueryEntity.getFields().put(\"blood_group\", String.class.toString());\n        IgniteCache<Object, Object> cache = ignite(0).createCache(\n            new CacheConfiguration<>(DEFAULT_CACHE_NAME)\n                .setQueryEntities(Arrays.asList(\n                    new QueryEntity(String.class, Person.class).setTableName(PERSON_CACHE),\n                    new QueryEntity(Long.class, MedicalInfo.class).setTableName(MED_INFO_CACHE),\n                    new QueryEntity(Long.class, BloodGroupInfoPJ.class).setTableName(BLOOD_INFO_PJ_CACHE),\n                    bgQueryEntity\n                ))\n        );\n        awaitPartitionMapExchange();\n        populatePersonData(cache);\n        populateMedInfoData(cache);\n        populateBloodGrpPJData(cache);\n        populateBloodGrpPData(cache);\n        checkQueries(cache);\n    }\n    /**\n     * Check distributed OUTER join of 3 tables (T1 -> T2 -> T3) returns correct result\n     * for non-collocated data.\n     *\n     * <ul>\n     *     <li>Create caches for query entities (single query entity per cache).</li>\n     *     <li>Put data into cache.</li>\n     *     <li>Check query with distributedJoin=true returns correct results.</li>\n     * </ul>\n     *\n     * @throws Exception If failed.\n     */\n    @Test\n    public void testNonCollocatedDistributedJoin() throws Exception {\n        startGridsMultiThreaded(NODES_COUNT, false);\n        IgniteCache<Object, Object> personCache = ignite(0).createCache(\n            new CacheConfiguration<>(PERSON_CACHE).setQueryEntities(Collections.singleton(\n                new QueryEntity(String.class, Person.class)))\n                .setSqlSchema(\"PUBLIC\")\n        );\n        IgniteCache<Object, Object> medInfoCache = ignite(0).createCache(\n            new CacheConfiguration<>(MED_INFO_CACHE).setQueryEntities(Collections.singleton(\n                new QueryEntity(Long.class, MedicalInfo.class).setTableName(MED_INFO_CACHE)))\n                .setSqlSchema(\"PUBLIC\")\n        );\n        IgniteCache<Object, Object> bloodGrpCache1 = ignite(0).createCache(\n            new CacheConfiguration<>(BLOOD_INFO_PJ_CACHE).setQueryEntities(Collections.singleton(\n                new QueryEntity(Long.class, BloodGroupInfoPJ.class).setTableName(BLOOD_INFO_PJ_CACHE)))\n                .setSqlSchema(\"PUBLIC\")\n        );\n        final QueryEntity bgQueryEntity = new QueryEntity(String.class, BloodGroupInfoP.class).setTableName(BLOOD_INFO_P_CACHE)\n            .setKeyFieldName(\"blood_group\");\n        bgQueryEntity.getFields().put(\"blood_group\", String.class.toString());\n        IgniteCache<Object, Object> bloodGrpCache2 = ignite(0).createCache(\n            new CacheConfiguration<>(BLOOD_INFO_P_CACHE).setQueryEntities(Collections.singleton(\n                bgQueryEntity))\n                .setSqlSchema(\"PUBLIC\")\n        );\n        awaitPartitionMapExchange();\n        populatePersonData(personCache);\n        populateMedInfoData(medInfoCache);\n        populateBloodGrpPJData(bloodGrpCache1);\n        populateBloodGrpPData(bloodGrpCache2);\n        checkQueries(personCache);\n    }\n    /**\n     * Start queries and check query results.\n     *\n     * @param cache Cache.\n     */\n    private void checkQueries(IgniteCache<Object, Object> cache) {\n        // Join on secondary index.\n        SqlFieldsQuery qry1 = new SqlFieldsQuery(\"SELECT person.id, person.name, medical_info.blood_group, blood_group_info_PJ.universal_donor FROM person\\n\" +\n            \"  LEFT JOIN medical_info ON medical_info.name = person.name \\n\" +\n            \"  LEFT JOIN blood_group_info_PJ ON blood_group_info_PJ.blood_group = medical_info.blood_group;\");\n        // Join on primary index.\n        SqlFieldsQuery qry2 = new SqlFieldsQuery(\"SELECT person.id, person.name, medical_info.blood_group, blood_group_info_P.universal_donor FROM person\\n\" +\n            \"  LEFT JOIN medical_info ON medical_info.name = person.name \\n\" +\n            \"  LEFT JOIN blood_group_info_P ON blood_group_info_P.blood_group = medical_info.blood_group;\");\n        qry1.setDistributedJoins(true);\n        qry2.setDistributedJoins(true);\n        final String res1 = queryResultAsString(cache.query(qry1).getAll());\n        final String res2 = queryResultAsString(cache.query(qry2).getAll());\n        log.info(\"Query1 result: \\n\" + res1);\n        log.info(\"Query2 result: \\n\" + res2);\n        String expOut = \"2001,Shravya,null,null\\n\" +\n            \"2002,Kiran,O+,O+A+B+AB+\\n\" +\n            \"2003,Harika,AB+,AB+\\n\" +\n            \"2004,Srinivas,null,null\\n\" +\n            \"2005,Madhavi,A+,A+AB+\\n\" +\n            \"2006,Deeps,null,null\\n\" +\n            \"2007,Hope,null,null\\n\";\n        assertEquals(\"Wrong result\", expOut, res1);\n        assertEquals(\"Wrong result\", expOut, res2);\n    }\n    /**\n     * Convert query result to string.\n     *\n     * @param res Query result set.\n     * @return String representation.\n     */\n    private String queryResultAsString(List<List<?>> res) {\n        List<String> results = new ArrayList<>();\n        for (List<?> row : res) {\n            StringBuilder sb = new StringBuilder();\n            for (Iterator<?> iterator = row.iterator(); iterator.hasNext(); ) {\n                sb.append(iterator.next());\n                if (iterator.hasNext())\n                    sb.append(',');\n            }\n            results.add(sb.toString());\n        }\n        results.sort(String::compareTo);\n        StringBuilder sb = new StringBuilder();\n        for (String result : results)\n            sb.append(result).append('\\n');\n        return sb.toString();\n    }\n    /**\n     * @param cache Ignite cache.\n     */\n    private void populatePersonData(IgniteCache<Object, Object> cache) {\n        cache.put(\"Shravya\", new Person(2001, \"Shravya\"));\n        cache.put(\"Kiran\", new Person(2002, \"Kiran\"));\n        cache.put(\"Harika\", new Person(2003, \"Harika\"));\n        cache.put(\"Srinivas\", new Person(2004, \"Srinivas\"));\n        cache.put(\"Madhavi\", new Person(2005, \"Madhavi\"));\n        cache.put(\"Deeps\", new Person(2006, \"Deeps\"));\n        cache.put(\"Hope\", new Person(2007, \"Hope\"));\n    }\n    /**\n     * @param cache Ignite cache.\n     */\n    private void populateMedInfoData(IgniteCache<Object, Object> cache) {\n        cache.put(2001L, new MedicalInfo(2001, \"Madhavi\", \"A+\"));\n        cache.put(2002L, new MedicalInfo(2002, \"Diggi\", \"B+\"));\n        cache.put(2003L, new MedicalInfo(2003, \"Kiran\", \"O+\"));\n        cache.put(2004L, new MedicalInfo(2004, \"Harika\", \"AB+\"));\n    }\n    /**\n     * @param cache Ignite cache.\n     */\n    private void populateBloodGrpPJData(IgniteCache<Object, Object> cache) {\n        cache.put(2001L, new BloodGroupInfoPJ(2001, \"A+\", \"A+AB+\"));\n        cache.put(2002L, new BloodGroupInfoPJ(2002, \"O+\", \"O+A+B+AB+\"));\n        cache.put(2003L, new BloodGroupInfoPJ(2003, \"B+\", \"B+AB+\"));\n        cache.put(2004L, new BloodGroupInfoPJ(2004, \"AB+\", \"AB+\"));\n        cache.put(2005L, new BloodGroupInfoPJ(2005, \"O-\", \"EveryOne\"));\n    }\n    /**\n     * @param cache Ignite cache.\n     */\n    private void populateBloodGrpPData(IgniteCache<Object, Object> cache) {\n        cache.put(\"A+\", new BloodGroupInfoP(2001, \"A+\", \"A+AB+\"));\n        cache.put(\"O+\", new BloodGroupInfoP(2002, \"O+\", \"O+A+B+AB+\"));\n        cache.put(\"B+\", new BloodGroupInfoP(2003, \"B+\", \"B+AB+\"));\n        cache.put(\"AB+\", new BloodGroupInfoP(2004, \"AB+\", \"AB+\"));\n        cache.put(\"O-\", new BloodGroupInfoP(2005, \"O-\", \"EveryOne\"));\n    }\n    /**\n     *\n     */\n    private static class Person {\n        /** */\n        @QuerySqlField\n        private long id;\n        /** */\n        @QuerySqlField\n        private String name;\n        Person(long id, String name) {\n            this.id = id;\n            this.name = name;\n        }\n        public long getId() { return id; }\n        public void setId(long id) { this.id = id; }\n        public String getName() { return name; }\n        public void setName(String name) { this.name = name; }\n    }\n    /**\n     *\n     */\n    private static class MedicalInfo {\n        /** */\n        @QuerySqlField\n        private long id;\n        /** */\n        @QuerySqlField(index = true)\n        private String name;\n        /** */\n        @QuerySqlField(name = \"blood_group\")\n        private String bloodGroup;\n        MedicalInfo(long id, String name, String bloodGroup) {\n            this.id = id;\n            this.name = name;\n            this.bloodGroup = bloodGroup;\n        }\n        public void setId(long id) { this.id = id; }\n        public long getId() { return id; }\n        public String getName() { return name; }\n        public void setName(String name) { this.name = name; }\n        public String getBloodGroup() { return bloodGroup; }\n        public void setBloodGroup(String bloodGroup) { this.bloodGroup = bloodGroup; }\n    }\n    /**\n     *\n     */\n    private static class BloodGroupInfoPJ {\n        /** */\n        @QuerySqlField\n        private long id;\n        /** */\n        @QuerySqlField(index = true, name = \"blood_group\")\n        private String bloodGroup;\n        /** */\n        @QuerySqlField(name = \"universal_donor\")\n        private String universalDonor;\n        BloodGroupInfoPJ(long id, String bloodGroup, String universalDonor) {\n            this.id = id;\n            this.bloodGroup = bloodGroup;\n            this.universalDonor = universalDonor;\n        }\n        public void setId(long id) { this.id = id; }\n        public long getId() { return id; }\n        public String getBloodGroup() { return bloodGroup; }\n        public void setBloodGroup(String bloodGroup) { this.bloodGroup = bloodGroup; }\n        public String getUniversalDonor() { return universalDonor; }\n        public void setUniversalDonor(String universalDonor) { this.universalDonor = universalDonor; }\n    }\n    /**\n     *\n     */\n    private static class BloodGroupInfoP {\n        /** */\n        private long id;\n        /** */\n        @QuerySqlField\n        private String bloodGroup;  // PK\n        /** */\n        @QuerySqlField(name = \"universal_donor\")\n        private String universalDonor;\n        BloodGroupInfoP(long id, String bloodGroup, String universalDonor) {\n            this.id = id;\n            this.bloodGroup = bloodGroup;\n            this.universalDonor = universalDonor;\n        }\n        public void setId(long id) { this.id = id; }\n        public long getId() { return id; }\n        public String getBloodGroup() { return bloodGroup; }\n        public void setBloodGroup(String bloodGroup) { this.bloodGroup = bloodGroup; }\n        public String getUniversalDonor() { return universalDonor; }\n        public void setUniversalDonor(String universalDonor) { this.universalDonor = universalDonor; }\n    }\n"]], "pred": {"ppl": 1.6523067951202393, "ppl_lower": 2.0894968509674072, "ppl/lowercase_ppl": -1.4674708148935813, "ppl/zlib": 0.00022063812354500682, "Min_5.0% Prob": 5.607112758299884, "Min_10.0% Prob": 4.053563901022369, "Min_20.0% Prob": 2.428055641405723, "Min_30.0% Prob": 1.6655750769415711, "Min_40.0% Prob": 1.2532624292658747, "Min_50.0% Prob": 1.0046212792445754, "Min_60.0% Prob": 0.8378717832827142}}
{"hexsha": "1f358335f6509eed32cebe6c1c4ecc98507950c3", "ext": "java", "lang": "Java", "content": "public class ArrayHelperTest\n    extends TestCase\n{\n    private final Allocator<Integer> alloc = allocator(Integer.class);\n\n    public void testSubArray()\n    {\n        Integer[] orig = {1, 2, 3};\n\n        verifyValues(subArray(alloc, orig, 0, 0));\n        verifyValues(subArray(alloc, orig, 0, 1), 1);\n        verifyValues(subArray(alloc, orig, 0, 2), 1, 2);\n        verifyValues(subArray(alloc, orig, 0, 3), 1, 2, 3);\n\n        verifyValues(subArray(alloc, orig, 1, 1));\n        verifyValues(subArray(alloc, orig, 1, 2), 2);\n        verifyValues(subArray(alloc, orig, 1, 3), 2, 3);\n\n        verifyValues(subArray(alloc, orig, 2, 2));\n        verifyValues(subArray(alloc, orig, 2, 3), 3);\n\n        verifyValues(subArray(alloc, orig, 3, 3));\n    }\n\n    public void testSubArray2()\n    {\n        Integer[] a = {1, 2, 3};\n        Integer[] b = {4, 5, 6};\n\n        verifyValues(subArray(alloc, a, b, 0, 0));\n        verifyValues(subArray(alloc, a, b, 0, 1), 1);\n        verifyValues(subArray(alloc, a, b, 0, 2), 1, 2);\n        verifyValues(subArray(alloc, a, b, 0, 3), 1, 2, 3);\n\n        verifyValues(subArray(alloc, a, b, 1, 1));\n        verifyValues(subArray(alloc, a, b, 1, 2), 2);\n        verifyValues(subArray(alloc, a, b, 1, 3), 2, 3);\n\n        verifyValues(subArray(alloc, a, b, 3, 3));\n        verifyValues(subArray(alloc, a, b, 3, 4), 4);\n        verifyValues(subArray(alloc, a, b, 3, 5), 4, 5);\n        verifyValues(subArray(alloc, a, b, 3, 6), 4, 5, 6);\n\n        verifyValues(subArray(alloc, a, b, 4, 4));\n        verifyValues(subArray(alloc, a, b, 4, 5), 5);\n        verifyValues(subArray(alloc, a, b, 4, 6), 5, 6);\n\n        verifyValues(subArray(alloc, a, b, 2, 3), 3);\n        verifyValues(subArray(alloc, a, b, 2, 4), 3, 4);\n        verifyValues(subArray(alloc, a, b, 2, 5), 3, 4, 5);\n        verifyValues(subArray(alloc, a, b, 2, 6), 3, 4, 5, 6);\n\n        verifyValues(subArray(alloc, a, b, 1, 3), 2, 3);\n        verifyValues(subArray(alloc, a, b, 1, 4), 2, 3, 4);\n        verifyValues(subArray(alloc, a, b, 1, 5), 2, 3, 4, 5);\n        verifyValues(subArray(alloc, a, b, 1, 6), 2, 3, 4, 5, 6);\n\n    }\n\n    public void testAssign()\n    {\n        Integer[] orig = {1, 2, 3};\n\n        verifyValues(assign(orig, 0, 9), 9, 2, 3);\n        verifyValues(assign(orig, 1, 9), 1, 9, 3);\n        verifyValues(assign(orig, 2, 9), 1, 2, 9);\n\n        try {\n            assign(orig, 3, 9);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n    }\n\n    public void testAppend()\n    {\n        verifyValues(append(alloc, new Integer[0], 9), 9);\n        verifyValues(append(alloc, new Integer[]{1}, 9), 1, 9);\n    }\n\n    public void testInsert()\n    {\n        verifyValues(insert(alloc, new Integer[0], 0, 9), 9);\n\n        verifyValues(insert(new Integer[]{1}, 0, 9), 9, 1);\n        verifyValues(insert(alloc, new Integer[]{1}, 1, 9), 1, 9);\n\n        verifyValues(insert(alloc, new Integer[]{1, 2}, 0, 9), 9, 1, 2);\n        verifyValues(insert(new Integer[]{1, 2}, 1, 9), 1, 9, 2);\n        verifyValues(insert(alloc, new Integer[]{1, 2}, 2, 9), 1, 2, 9);\n    }\n\n    public void testDelete()\n    {\n        // length 1\n        Integer[] orig = {1};\n        verifyValues(ArrayHelper.<Integer>delete(alloc, orig, 0));\n\n        // length 2\n        orig = new Integer[]{1, 2};\n        verifyValues(delete(alloc, orig, 0), 2);\n        verifyValues(delete(orig, 1), 1);\n\n        // length 3\n        orig = new Integer[]{1, 2, 3};\n        verifyValues(delete(alloc, orig, 0), 2, 3);\n        verifyValues(delete(orig, 1), 1, 3);\n        verifyValues(delete(alloc, orig, 2), 1, 2);\n    }\n\n    public void testConcat()\n    {\n        verifyValues(concat(alloc, new Integer[]{}, new Integer[]{}));\n        verifyValues(concat(alloc, new Integer[]{1}, new Integer[]{}), 1);\n        verifyValues(concat(alloc, new Integer[]{}, new Integer[]{1}), 1);\n        verifyValues(concat(alloc, new Integer[]{1}, new Integer[]{2}), 1, 2);\n    }\n\n    public void testAssignAppend()\n    {\n        try {\n            assignAppend(alloc, new Integer[0], 9, 10);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n        verifyValues(assignAppend(alloc, new Integer[]{1}, 9, 10), 9, 10);\n        verifyValues(assignAppend(alloc, new Integer[]{1, 2}, 9, 10), 1, 9, 10);\n    }\n\n    public void testAssignTwo()\n    {\n        try {\n            assignTwo(new Integer[]{}, 0, 9, 10);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n        try {\n            assignTwo(new Integer[]{1}, 0, 9, 10);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n        try {\n            assignTwo(new Integer[]{1, 2}, 1, 9, 10);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n        verifyValues(assignTwo(new Integer[]{1, 2}, 0, 9, 10), 9, 10);\n        verifyValues(assignTwo(new Integer[]{\n            1, 2, 3\n        }, 0, 9, 10), 9, 10, 3);\n        verifyValues(assignTwo(new Integer[]{\n            1, 2, 3\n        }, 1, 9, 10), 1, 9, 10);\n    }\n\n    public void testAssignInsertNode()\n    {\n        try {\n            assignInsert(alloc, new Integer[]{}, 0, 9, 10);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n        try {\n            assignInsert(alloc, new Integer[]{1}, 1, 9, 10);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n\n        verifyValues(assignInsert(alloc, new Integer[]{1}, 0, 9, 10), 9, 10);\n        verifyValues(assignInsert(alloc, new Integer[]{\n            1, 2\n        }, 0, 9, 10), 9, 10, 2);\n        verifyValues(assignInsert(alloc, new Integer[]{\n            1, 2\n        }, 1, 9, 10), 1, 9, 10);\n\n        try {\n            assignInsert(alloc, new Integer[]{1, 2}, 2, 9, 10);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n    }\n\n    public void testAssignDelete()\n    {\n        try {\n            assignDelete(alloc, new Integer[]{1}, 0, 9);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n\n        verifyValues(assignDelete(alloc, new Integer[]{1, 2}, 0, 9), 9);\n        try {\n            assignDelete(alloc, new Integer[]{1, 2}, 1, 9);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n\n        verifyValues(assignDelete(alloc, new Integer[]{1, 2, 3}, 0, 9), 9, 3);\n        verifyValues(assignDelete(alloc, new Integer[]{1, 2, 3}, 1, 9), 1, 9);\n        try {\n            assignDelete(alloc, new Integer[]{1, 2, 3}, 2, 9);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n    }\n\n    public void testPrefix()\n    {\n        verifyValues(a(), prefix(alloc, a(), 0));\n        verifyValues(a(), prefix(alloc, a(1), 0));\n        verifyValues(a(), prefix(alloc, a(1, 2), 0));\n        verifyValues(a(1), prefix(alloc, a(1, 2), 1));\n        verifyValues(a(1, 2), prefix(alloc, a(1, 2), 2));\n        verifyOutOfBounds(() -> prefix(alloc, a(), 1));\n        verifyOutOfBounds(() -> prefix(alloc, a(1), 2));\n    }\n\n    public void testPrefixInsert()\n    {\n        verifyValues(a(9), prefixInsert(alloc, a(), 0, 0, 9));\n        verifyValues(a(9), prefixInsert(alloc, a(1), 0, 0, 9));\n        verifyValues(a(9, 1), prefixInsert(alloc, a(1), 1, 0, 9));\n        verifyValues(a(1, 9), prefixInsert(alloc, a(1), 1, 1, 9));\n        verifyValues(a(9), prefixInsert(alloc, a(1, 2), 0, 0, 9));\n        verifyValues(a(9, 1), prefixInsert(alloc, a(1, 2), 1, 0, 9));\n        verifyValues(a(1, 9), prefixInsert(alloc, a(1, 2), 1, 1, 9));\n        verifyValues(a(1, 2, 9), prefixInsert(alloc, a(1, 2), 2, 2, 9));\n        verifyOutOfBounds(() -> prefixInsert(alloc, a(), 1, 0, 9));\n        verifyOutOfBounds(() -> prefixInsert(alloc, a(1), 2, 0, 9));\n        verifyOutOfBounds(() -> prefixInsert(alloc, a(1), 1, 2, 9));\n    }\n\n    public void testSuffix()\n    {\n        verifyValues(a(), suffix(alloc, a(), 0));\n        verifyValues(a(), suffix(alloc, a(1), 1));\n        verifyValues(a(), suffix(alloc, a(1, 2), 2));\n        verifyValues(a(2), suffix(alloc, a(1, 2), 1));\n        verifyValues(a(1, 2), suffix(alloc, a(1, 2), 0));\n        verifyValues(a(1, 2, 3), suffix(alloc, a(1, 2, 3), 0));\n        verifyValues(a(2, 3), suffix(alloc, a(1, 2, 3), 1));\n        verifyValues(a(3), suffix(alloc, a(1, 2, 3), 2));\n        verifyValues(a(), suffix(alloc, a(1, 2, 3), 3));\n        verifyOutOfBounds(() -> suffix(alloc, a(), 1));\n        verifyOutOfBounds(() -> suffix(alloc, a(1), 2));\n        verifyOutOfBounds(() -> suffix(alloc, a(1, 2), 3));\n    }\n\n    public void testSuffixInsert()\n    {\n        verifyValues(a(9), suffixInsert(alloc, a(), 0, 0, 9));\n        verifyValues(a(9), suffixInsert(alloc, a(1), 1, 1, 9));\n        verifyValues(a(9, 1), suffixInsert(alloc, a(1), 0, 0, 9));\n        verifyValues(a(1, 9), suffixInsert(alloc, a(1), 0, 1, 9));\n        verifyValues(a(9), suffixInsert(alloc, a(1, 2), 2, 2, 9));\n        verifyValues(a(2, 9), suffixInsert(alloc, a(1, 2), 1, 2, 9));\n        verifyValues(a(9, 2), suffixInsert(alloc, a(1, 2), 1, 1, 9));\n        verifyValues(a(9, 1, 2), suffixInsert(alloc, a(1, 2), 0, 0, 9));\n        verifyValues(a(1, 9, 2), suffixInsert(alloc, a(1, 2), 0, 1, 9));\n        verifyValues(a(1, 2, 9), suffixInsert(alloc, a(1, 2), 0, 2, 9));\n        verifyOutOfBounds(() -> suffixInsert(alloc, a(), 1, 1, 9));\n        verifyOutOfBounds(() -> suffixInsert(alloc, a(1), 2, 1, 9));\n        verifyOutOfBounds(() -> suffixInsert(alloc, a(1, 2), 1, 0, 9));\n    }\n\n    public void testReverse()\n    {\n        verifyValues(reverse(alloc, new Integer[0]));\n        verifyValues(reverse(alloc, new Integer[]{1}), 1);\n        verifyValues(reverse(alloc, new Integer[]{1, 2}), 2, 1);\n        verifyValues(reverse(alloc, new Integer[]{1, 2, 3}), 3, 2, 1);\n        verifyValues(reverse(alloc, new Integer[]{1, 2, 3, 4}), 4, 3, 2, 1);\n        verifyValues(reverse(alloc, new Integer[]{1, 2, 3, 4, 5}), 5, 4, 3, 2, 1);\n        verifyValues(reverse(alloc, new Integer[]{1, 2, 3, 4, 5, 6}), 6, 5, 4, 3, 2, 1);\n    }\n\n    private void verifyOutOfBounds(Callable<Integer[]> op)\n    {\n        try {\n            op.call();\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    private <T> void verifyValues(T[] actual,\n                                  Integer... expected)\n    {\n        assertEquals(asList(expected), asList(actual));\n    }\n\n    private Integer[] a(Integer... values)\n    {\n        return values;\n    }\n}", "item_id": 0, "repo": "brianburton/java-immutable-collections", "file": "src/test/java/org/javimmutable/collections/common/ArrayHelperTest.java", "last_update_at": "2022-02-18T11:56:11+00:00", "question_id": "1f358335f6509eed32cebe6c1c4ecc98507950c3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ArrayHelperTest\n    extends TestCase\n{\n    private final Allocator<Integer> alloc = allocator(Integer.class);\n    public void testSubArray()\n    {\n        Integer[] orig = {1, 2, 3};\n        verifyValues(subArray(alloc, orig, 0, 0));\n        verifyValues(subArray(alloc, orig, 0, 1), 1);\n        verifyValues(subArray(alloc, orig, 0, 2), 1, 2);\n        verifyValues(subArray(alloc, orig, 0, 3), 1, 2, 3);\n        verifyValues(subArray(alloc, orig, 1, 1));\n        verifyValues(subArray(alloc, orig, 1, 2), 2);\n        verifyValues(subArray(alloc, orig, 1, 3), 2, 3);\n        verifyValues(subArray(alloc, orig, 2, 2));\n        verifyValues(subArray(alloc, orig, 2, 3), 3);\n        verifyValues(subArray(alloc, orig, 3, 3));\n    }\n    public void testSubArray2()\n    {\n        Integer[] a = {1, 2, 3};\n        Integer[] b = {4, 5, 6};\n        verifyValues(subArray(alloc, a, b, 0, 0));\n        verifyValues(subArray(alloc, a, b, 0, 1), 1);\n        verifyValues(subArray(alloc, a, b, 0, 2), 1, 2);\n        verifyValues(subArray(alloc, a, b, 0, 3), 1, 2, 3);\n        verifyValues(subArray(alloc, a, b, 1, 1));\n        verifyValues(subArray(alloc, a, b, 1, 2), 2);\n        verifyValues(subArray(alloc, a, b, 1, 3), 2, 3);\n        verifyValues(subArray(alloc, a, b, 3, 3));\n        verifyValues(subArray(alloc, a, b, 3, 4), 4);\n        verifyValues(subArray(alloc, a, b, 3, 5), 4, 5);\n        verifyValues(subArray(alloc, a, b, 3, 6), 4, 5, 6);\n        verifyValues(subArray(alloc, a, b, 4, 4));\n        verifyValues(subArray(alloc, a, b, 4, 5), 5);\n        verifyValues(subArray(alloc, a, b, 4, 6), 5, 6);\n        verifyValues(subArray(alloc, a, b, 2, 3), 3);\n        verifyValues(subArray(alloc, a, b, 2, 4), 3, 4);\n        verifyValues(subArray(alloc, a, b, 2, 5), 3, 4, 5);\n        verifyValues(subArray(alloc, a, b, 2, 6), 3, 4, 5, 6);\n        verifyValues(subArray(alloc, a, b, 1, 3), 2, 3);\n        verifyValues(subArray(alloc, a, b, 1, 4), 2, 3, 4);\n        verifyValues(subArray(alloc, a, b, 1, 5), 2, 3, 4, 5);\n        verifyValues(subArray(alloc, a, b, 1, 6), 2, 3, 4, 5, 6);\n    }\n    public void testAssign()\n    {\n        Integer[] orig = {1, 2, 3};\n        verifyValues(assign(orig, 0, 9), 9, 2, 3);\n        verifyValues(assign(orig, 1, 9), 1, 9, 3);\n        verifyValues(assign(orig, 2, 9), 1, 2, 9);\n        try {\n            assign(orig, 3, 9);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n    }\n    public void testAppend()\n    {\n        verifyValues(append(alloc, new Integer[0], 9), 9);\n        verifyValues(append(alloc, new Integer[]{1}, 9), 1, 9);\n    }\n    public void testInsert()\n    {\n        verifyValues(insert(alloc, new Integer[0], 0, 9), 9);\n        verifyValues(insert(new Integer[]{1}, 0, 9), 9, 1);\n        verifyValues(insert(alloc, new Integer[]{1}, 1, 9), 1, 9);\n        verifyValues(insert(alloc, new Integer[]{1, 2}, 0, 9), 9, 1, 2);\n        verifyValues(insert(new Integer[]{1, 2}, 1, 9), 1, 9, 2);\n        verifyValues(insert(alloc, new Integer[]{1, 2}, 2, 9), 1, 2, 9);\n    }\n    public void testDelete()\n    {\n        // length 1\n        Integer[] orig = {1};\n        verifyValues(ArrayHelper.<Integer>delete(alloc, orig, 0));\n        // length 2\n        orig = new Integer[]{1, 2};\n        verifyValues(delete(alloc, orig, 0), 2);\n        verifyValues(delete(orig, 1), 1);\n        // length 3\n        orig = new Integer[]{1, 2, 3};\n        verifyValues(delete(alloc, orig, 0), 2, 3);\n        verifyValues(delete(orig, 1), 1, 3);\n        verifyValues(delete(alloc, orig, 2), 1, 2);\n    }\n    public void testConcat()\n    {\n        verifyValues(concat(alloc, new Integer[]{}, new Integer[]{}));\n        verifyValues(concat(alloc, new Integer[]{1}, new Integer[]{}), 1);\n        verifyValues(concat(alloc, new Integer[]{}, new Integer[]{1}), 1);\n        verifyValues(concat(alloc, new Integer[]{1}, new Integer[]{2}), 1, 2);\n    }\n    public void testAssignAppend()\n    {\n        try {\n            assignAppend(alloc, new Integer[0], 9, 10);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n        verifyValues(assignAppend(alloc, new Integer[]{1}, 9, 10), 9, 10);\n        verifyValues(assignAppend(alloc, new Integer[]{1, 2}, 9, 10), 1, 9, 10);\n    }\n    public void testAssignTwo()\n    {\n        try {\n            assignTwo(new Integer[]{}, 0, 9, 10);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n        try {\n            assignTwo(new Integer[]{1}, 0, 9, 10);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n        try {\n            assignTwo(new Integer[]{1, 2}, 1, 9, 10);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n        verifyValues(assignTwo(new Integer[]{1, 2}, 0, 9, 10), 9, 10);\n        verifyValues(assignTwo(new Integer[]{\n            1, 2, 3\n        }, 0, 9, 10), 9, 10, 3);\n        verifyValues(assignTwo(new Integer[]{\n            1, 2, 3\n        }, 1, 9, 10), 1, 9, 10);\n    }\n    public void testAssignInsertNode()\n    {\n        try {\n            assignInsert(alloc, new Integer[]{}, 0, 9, 10);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n        try {\n            assignInsert(alloc, new Integer[]{1}, 1, 9, 10);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n        verifyValues(assignInsert(alloc, new Integer[]{1}, 0, 9, 10), 9, 10);\n        verifyValues(assignInsert(alloc, new Integer[]{\n            1, 2\n        }, 0, 9, 10), 9, 10, 2);\n        verifyValues(assignInsert(alloc, new Integer[]{\n            1, 2\n        }, 1, 9, 10), 1, 9, 10);\n        try {\n            assignInsert(alloc, new Integer[]{1, 2}, 2, 9, 10);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n    }\n    public void testAssignDelete()\n    {\n        try {\n            assignDelete(alloc, new Integer[]{1}, 0, 9);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n        verifyValues(assignDelete(alloc, new Integer[]{1, 2}, 0, 9), 9);\n        try {\n            assignDelete(alloc, new Integer[]{1, 2}, 1, 9);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n        verifyValues(assignDelete(alloc, new Integer[]{1, 2, 3}, 0, 9), 9, 3);\n        verifyValues(assignDelete(alloc, new Integer[]{1, 2, 3}, 1, 9), 1, 9);\n        try {\n            assignDelete(alloc, new Integer[]{1, 2, 3}, 2, 9);\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        }\n    }\n    public void testPrefix()\n    {\n        verifyValues(a(), prefix(alloc, a(), 0));\n        verifyValues(a(), prefix(alloc, a(1), 0));\n        verifyValues(a(), prefix(alloc, a(1, 2), 0));\n        verifyValues(a(1), prefix(alloc, a(1, 2), 1));\n        verifyValues(a(1, 2), prefix(alloc, a(1, 2), 2));\n        verifyOutOfBounds(() -> prefix(alloc, a(), 1));\n        verifyOutOfBounds(() -> prefix(alloc, a(1), 2));\n    }\n    public void testPrefixInsert()\n    {\n        verifyValues(a(9), prefixInsert(alloc, a(), 0, 0, 9));\n        verifyValues(a(9), prefixInsert(alloc, a(1), 0, 0, 9));\n        verifyValues(a(9, 1), prefixInsert(alloc, a(1), 1, 0, 9));\n        verifyValues(a(1, 9), prefixInsert(alloc, a(1), 1, 1, 9));\n        verifyValues(a(9), prefixInsert(alloc, a(1, 2), 0, 0, 9));\n        verifyValues(a(9, 1), prefixInsert(alloc, a(1, 2), 1, 0, 9));\n        verifyValues(a(1, 9), prefixInsert(alloc, a(1, 2), 1, 1, 9));\n        verifyValues(a(1, 2, 9), prefixInsert(alloc, a(1, 2), 2, 2, 9));\n        verifyOutOfBounds(() -> prefixInsert(alloc, a(), 1, 0, 9));\n        verifyOutOfBounds(() -> prefixInsert(alloc, a(1), 2, 0, 9));\n        verifyOutOfBounds(() -> prefixInsert(alloc, a(1), 1, 2, 9));\n    }\n    public void testSuffix()\n    {\n        verifyValues(a(), suffix(alloc, a(), 0));\n        verifyValues(a(), suffix(alloc, a(1), 1));\n        verifyValues(a(), suffix(alloc, a(1, 2), 2));\n        verifyValues(a(2), suffix(alloc, a(1, 2), 1));\n        verifyValues(a(1, 2), suffix(alloc, a(1, 2), 0));\n        verifyValues(a(1, 2, 3), suffix(alloc, a(1, 2, 3), 0));\n        verifyValues(a(2, 3), suffix(alloc, a(1, 2, 3), 1));\n        verifyValues(a(3), suffix(alloc, a(1, 2, 3), 2));\n        verifyValues(a(), suffix(alloc, a(1, 2, 3), 3));\n        verifyOutOfBounds(() -> suffix(alloc, a(), 1));\n        verifyOutOfBounds(() -> suffix(alloc, a(1), 2));\n        verifyOutOfBounds(() -> suffix(alloc, a(1, 2), 3));\n    }\n    public void testSuffixInsert()\n    {\n        verifyValues(a(9), suffixInsert(alloc, a(), 0, 0, 9));\n        verifyValues(a(9), suffixInsert(alloc, a(1), 1, 1, 9));\n        verifyValues(a(9, 1), suffixInsert(alloc, a(1), 0, 0, 9));\n        verifyValues(a(1, 9), suffixInsert(alloc, a(1), 0, 1, 9));\n        verifyValues(a(9), suffixInsert(alloc, a(1, 2), 2, 2, 9));\n        verifyValues(a(2, 9), suffixInsert(alloc, a(1, 2), 1, 2, 9));\n        verifyValues(a(9, 2), suffixInsert(alloc, a(1, 2), 1, 1, 9));\n        verifyValues(a(9, 1, 2), suffixInsert(alloc, a(1, 2), 0, 0, 9));\n        verifyValues(a(1, 9, 2), suffixInsert(alloc, a(1, 2), 0, 1, 9));\n        verifyValues(a(1, 2, 9), suffixInsert(alloc, a(1, 2), 0, 2, 9));\n        verifyOutOfBounds(() -> suffixInsert(alloc, a(), 1, 1, 9));\n        verifyOutOfBounds(() -> suffixInsert(alloc, a(1), 2, 1, 9));\n        verifyOutOfBounds(() -> suffixInsert(alloc, a(1, 2), 1, 0, 9));\n    }\n    public void testReverse()\n    {\n        verifyValues(reverse(alloc, new Integer[0]));\n        verifyValues(reverse(alloc, new Integer[]{1}), 1);\n        verifyValues(reverse(alloc, new Integer[]{1, 2}), 2, 1);\n        verifyValues(reverse(alloc, new Integer[]{1, 2, 3}), 3, 2, 1);\n        verifyValues(reverse(alloc, new Integer[]{1, 2, 3, 4}), 4, 3, 2, 1);\n        verifyValues(reverse(alloc, new Integer[]{1, 2, 3, 4, 5}), 5, 4, 3, 2, 1);\n        verifyValues(reverse(alloc, new Integer[]{1, 2, 3, 4, 5, 6}), 6, 5, 4, 3, 2, 1);\n    }\n    private void verifyOutOfBounds(Callable<Integer[]> op)\n    {\n        try {\n            op.call();\n            fail();\n        } catch (ArrayIndexOutOfBoundsException ignored) {\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n    private <T> void verifyValues(T[] actual,\n                                  Integer... expected)\n    {\n        assertEquals(asList(expected), asList(actual));\n    }\n    private Integer[] a(Integer... values)\n    {\n        return values;\n    }\n"]], "pred": {"ppl": 1.2325507402420044, "ppl_lower": 1.2629057168960571, "ppl/lowercase_ppl": -1.116360826239606, "ppl/zlib": 0.00015295230039550614, "Min_5.0% Prob": 3.275052795223161, "Min_10.0% Prob": 1.950048746431575, "Min_20.0% Prob": 1.0358843474338453, "Min_30.0% Prob": 0.6968339217485848, "Min_40.0% Prob": 0.5224658185803994, "Min_50.0% Prob": 0.4184320633628391, "Min_60.0% Prob": 0.3488821422210803}}
{"hexsha": "584adf95b12d49372efde44a112841a25b0668ab", "ext": "java", "lang": "Java", "content": "public class JsonTreeSerializer {\n    private boolean serializeNulls = false;\n    private boolean prettyFormat = false;\n\n    public boolean isSerializeNulls() {\n        return serializeNulls;\n    }\n\n    public void setSerializeNulls(boolean serializeNulls) {\n        this.serializeNulls = serializeNulls;\n    }\n\n    public boolean isPrettyFormat() {\n        return prettyFormat;\n    }\n\n    public void setPrettyFormat(boolean prettyFormat) {\n        this.prettyFormat = prettyFormat;\n    }\n\n    /**\n     * Converts a tree of {@link JsonTreeNode}s into its equivalent JSON representation.\n     *\n     * @param jsonElement root of a tree of {@link JsonTreeNode}s\n     * @return JSON String representation of the tree\n     * @since 1.4\n     */\n    public String toJson(JsonTreeNode jsonElement) {\n        StringWriter writer = new StringWriter();\n        toJson(jsonElement, writer);\n        return writer.toString();\n    }\n\n    /**\n     * Writes out the equivalent JSON for a tree of {@link JsonTreeNode}s.\n     *\n     * @param jsonElement root of a tree of {@link JsonTreeNode}s\n     * @param writer      Writer to which the Json representation needs to be written\n     * @throws JsonException if there was a problem writing to the writer\n     * @since 1.4\n     */\n    public void toJson(JsonTreeNode jsonElement, Appendable writer) throws JsonException {\n        try {\n            JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));\n            toJson(jsonElement, jsonWriter);\n        } catch (IOException e) {\n            throw new JsonException(e);\n        }\n    }\n\n\n    /**\n     * Returns a new JSON writer configured for the settings on this JSON instance.\n     */\n    private JsonWriter newJsonWriter(Writer writer) throws IOException {\n        JsonWriter jsonWriter = new JsonWriter(writer);\n        if (prettyFormat) {\n            jsonWriter.setIndent(\"  \");\n        }\n        jsonWriter.setSerializeNulls(serializeNulls);\n        return jsonWriter;\n    }\n\n    /**\n     * Writes the JSON for {@code jsonElement} to {@code writer}.\n     *\n     * @throws JsonException if there was a problem writing to the writer\n     */\n    public void toJson(JsonTreeNode jsonElement, JsonWriter writer) throws JsonException {\n        boolean oldLenient = writer.isLenient();\n        writer.setLenient(true);\n        boolean oldHtmlSafe = writer.isHtmlSafe();\n        writer.setHtmlSafe(true);\n        boolean oldSerializeNulls = writer.getSerializeNulls();\n        writer.setSerializeNulls(serializeNulls);\n        try {\n            Streams.write(jsonElement, writer);\n        } catch (IOException e) {\n            throw new JsonException(e);\n        } catch (AssertionError e) {\n            throw new JsonException(\"AssertionError \" + e.getMessage(), e);\n        } finally {\n            writer.setLenient(oldLenient);\n            writer.setHtmlSafe(oldHtmlSafe);\n            writer.setSerializeNulls(oldSerializeNulls);\n        }\n    }\n\n}", "item_id": 0, "repo": "jxt4995038/easyjson", "file": "easyjson-core/src/main/java/com/jn/easyjson/core/tree/JsonTreeSerializer.java", "last_update_at": "2022-03-31T05:12:50+00:00", "question_id": "584adf95b12d49372efde44a112841a25b0668ab_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JsonTreeSerializer {\n    private boolean serializeNulls = false;\n    private boolean prettyFormat = false;\n    public boolean isSerializeNulls() {\n        return serializeNulls;\n    }\n    public void setSerializeNulls(boolean serializeNulls) {\n        this.serializeNulls = serializeNulls;\n    }\n    public boolean isPrettyFormat() {\n        return prettyFormat;\n    }\n    public void setPrettyFormat(boolean prettyFormat) {\n        this.prettyFormat = prettyFormat;\n    }\n    /**\n     * Converts a tree of {@link JsonTreeNode}s into its equivalent JSON representation.\n     *\n     * @param jsonElement root of a tree of {@link JsonTreeNode}s\n     * @return JSON String representation of the tree\n     * @since 1.4\n     */\n    public String toJson(JsonTreeNode jsonElement) {\n        StringWriter writer = new StringWriter();\n        toJson(jsonElement, writer);\n        return writer.toString();\n    }\n    /**\n     * Writes out the equivalent JSON for a tree of {@link JsonTreeNode}s.\n     *\n     * @param jsonElement root of a tree of {@link JsonTreeNode}s\n     * @param writer      Writer to which the Json representation needs to be written\n     * @throws JsonException if there was a problem writing to the writer\n     * @since 1.4\n     */\n    public void toJson(JsonTreeNode jsonElement, Appendable writer) throws JsonException {\n        try {\n            JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));\n            toJson(jsonElement, jsonWriter);\n        } catch (IOException e) {\n            throw new JsonException(e);\n        }\n    }\n    /**\n     * Returns a new JSON writer configured for the settings on this JSON instance.\n     */\n    private JsonWriter newJsonWriter(Writer writer) throws IOException {\n        JsonWriter jsonWriter = new JsonWriter(writer);\n        if (prettyFormat) {\n            jsonWriter.setIndent(\"  \");\n        }\n        jsonWriter.setSerializeNulls(serializeNulls);\n        return jsonWriter;\n    }\n    /**\n     * Writes the JSON for {@code jsonElement} to {@code writer}.\n     *\n     * @throws JsonException if there was a problem writing to the writer\n     */\n    public void toJson(JsonTreeNode jsonElement, JsonWriter writer) throws JsonException {\n        boolean oldLenient = writer.isLenient();\n        writer.setLenient(true);\n        boolean oldHtmlSafe = writer.isHtmlSafe();\n        writer.setHtmlSafe(true);\n        boolean oldSerializeNulls = writer.getSerializeNulls();\n        writer.setSerializeNulls(serializeNulls);\n        try {\n            Streams.write(jsonElement, writer);\n        } catch (IOException e) {\n            throw new JsonException(e);\n        } catch (AssertionError e) {\n            throw new JsonException(\"AssertionError \" + e.getMessage(), e);\n        } finally {\n            writer.setLenient(oldLenient);\n            writer.setHtmlSafe(oldHtmlSafe);\n            writer.setSerializeNulls(oldSerializeNulls);\n        }\n    }\n"]], "pred": {"ppl": 1.4263328313827515, "ppl_lower": 1.6813241243362427, "ppl/lowercase_ppl": -1.463170525450494, "ppl/zlib": 0.00046177723907641694, "Min_5.0% Prob": 4.024107786325308, "Min_10.0% Prob": 2.8608382756893453, "Min_20.0% Prob": 1.7022294621368883, "Min_30.0% Prob": 1.1713444601982197, "Min_40.0% Prob": 0.8847547630322682, "Min_50.0% Prob": 0.709198467471369, "Min_60.0% Prob": 0.5923214032193111}}
{"hexsha": "47652e4681f1e3790901ae86009d47ccdf505ce3", "ext": "java", "lang": "Java", "content": "public class OverflowTest {\n    @Test\n    public void ok() {\n        // normal content size\n        Json.createReaderFactory(new HashMap<String, Object>() {{\n            put(JsonParserFactoryImpl.MAX_STRING_LENGTH, \"10\");\n            put(JsonParserFactoryImpl.BUFFER_LENGTH, \"2\");\n        }}).createReader(new StringReader(\"{\\\"a\\\":\\\"b\\\",\\n\\\"another\\\":\\\"value\\\"}\")).readObject();\n\n        // oversized\n        final JsonObject object = Json.createReaderFactory(new HashMap<String, Object>() {{\n            put(JsonParserFactoryImpl.MAX_STRING_LENGTH, \"10\");\n            put(JsonParserFactoryImpl.BUFFER_LENGTH, \"2\");\n        }}).createReader(new StringReader(\"{\\\"a\\\":\\\"b\\\",\\n\\\"another\\\":\\\"value very long\\\"}\")).readObject();\n        assertEquals(\"value very long\", object.getString(\"another\"));\n    }\n\n    @Test(expected = ArrayIndexOutOfBoundsException.class)\n    public void ko() {\n        Json.createReaderFactory(new HashMap<String, Object>() {{\n            put(JsonParserFactoryImpl.MAX_STRING_LENGTH, \"10\");\n            put(JsonParserFactoryImpl.BUFFER_LENGTH, \"2\");\n            put(JsonParserFactoryImpl.AUTO_ADJUST_STRING_BUFFER, \"false\");\n        }}).createReader(new StringReader(\"{\\\"another\\\":\\\"value too long\\\"}\")).readObject();\n    }\n\n    @Test\n    public void testVeryLargeJson() {\n        JsonWriterFactory writerFactory = Json.createWriterFactory(new HashMap<String, Object>() {{\n            put(JsonParserFactoryImpl.BUFFER_LENGTH, \"256\");\n        }});\n\n        int itemSize = 50_000;\n\n        StringWriter sw = new StringWriter();\n        JsonWriter writer = writerFactory.createWriter(sw);\n\n        JsonArrayBuilder arrayBuilder = Json.createArrayBuilder();\n        for (int i = 0; i < itemSize; i++) {\n            arrayBuilder.add(\"0123456789012345-\" + i);\n        }\n        writer.writeArray(arrayBuilder.build());\n        writer.close();\n\n        String json = sw.toString();\n        System.out.println(\"Created a JSON of size \" + json.length() + \" bytes\");\n\n        // read it back in\n        JsonArray jsonArray = Json.createReader(new StringReader(json)).readArray();\n        Assert.assertEquals(itemSize, jsonArray.size());\n\n    }\n}", "item_id": 0, "repo": "mkarg/johnzon", "file": "johnzon-core/src/test/java/org/apache/johnzon/core/OverflowTest.java", "last_update_at": "2022-03-22T06:48:57+00:00", "question_id": "47652e4681f1e3790901ae86009d47ccdf505ce3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OverflowTest {\n    @Test\n    public void ok() {\n        // normal content size\n        Json.createReaderFactory(new HashMap<String, Object>() {{\n            put(JsonParserFactoryImpl.MAX_STRING_LENGTH, \"10\");\n            put(JsonParserFactoryImpl.BUFFER_LENGTH, \"2\");\n        }}).createReader(new StringReader(\"{\\\"a\\\":\\\"b\\\",\\n\\\"another\\\":\\\"value\\\"}\")).readObject();\n        // oversized\n        final JsonObject object = Json.createReaderFactory(new HashMap<String, Object>() {{\n            put(JsonParserFactoryImpl.MAX_STRING_LENGTH, \"10\");\n            put(JsonParserFactoryImpl.BUFFER_LENGTH, \"2\");\n        }}).createReader(new StringReader(\"{\\\"a\\\":\\\"b\\\",\\n\\\"another\\\":\\\"value very long\\\"}\")).readObject();\n        assertEquals(\"value very long\", object.getString(\"another\"));\n    }\n    @Test(expected = ArrayIndexOutOfBoundsException.class)\n    public void ko() {\n        Json.createReaderFactory(new HashMap<String, Object>() {{\n            put(JsonParserFactoryImpl.MAX_STRING_LENGTH, \"10\");\n            put(JsonParserFactoryImpl.BUFFER_LENGTH, \"2\");\n            put(JsonParserFactoryImpl.AUTO_ADJUST_STRING_BUFFER, \"false\");\n        }}).createReader(new StringReader(\"{\\\"another\\\":\\\"value too long\\\"}\")).readObject();\n    }\n    @Test\n    public void testVeryLargeJson() {\n        JsonWriterFactory writerFactory = Json.createWriterFactory(new HashMap<String, Object>() {{\n            put(JsonParserFactoryImpl.BUFFER_LENGTH, \"256\");\n        }});\n        int itemSize = 50_000;\n        StringWriter sw = new StringWriter();\n        JsonWriter writer = writerFactory.createWriter(sw);\n        JsonArrayBuilder arrayBuilder = Json.createArrayBuilder();\n        for (int i = 0; i < itemSize; i++) {\n            arrayBuilder.add(\"0123456789012345-\" + i);\n        }\n        writer.writeArray(arrayBuilder.build());\n        writer.close();\n        String json = sw.toString();\n        System.out.println(\"Created a JSON of size \" + json.length() + \" bytes\");\n        // read it back in\n        JsonArray jsonArray = Json.createReader(new StringReader(json)).readArray();\n        Assert.assertEquals(itemSize, jsonArray.size());\n    }\n"]], "pred": {"ppl": 1.8593758344650269, "ppl_lower": 2.2207179069519043, "ppl/lowercase_ppl": -1.2863237146227045, "ppl/zlib": 0.0009081125308047885, "Min_5.0% Prob": 6.306499163309733, "Min_10.0% Prob": 4.549443760856253, "Min_20.0% Prob": 2.846899022900961, "Min_30.0% Prob": 2.0223762781723686, "Min_40.0% Prob": 1.5373220361496618, "Min_50.0% Prob": 1.2382704052734355, "Min_60.0% Prob": 1.0325109352531836}}
{"hexsha": "f323f9da6a88cae4706fde69a15a962c56d24aa8", "ext": "java", "lang": "Java", "content": "@Singleton\npublic class GenericEsRestClient implements EsRestClient {\n    private static final BasicHeader APPLICATION_JSON_HEADER = new BasicHeader(\"Content-Type\", \"application/json\");\n    private static final BasicHeader APPLICATION_XNDJSON_HEADER = new BasicHeader(\"Content-Type\", \"application/x-ndjson\");\n\n    private Random random;\n\n    private CloseableHttpClient httpClient;\n    private ArrayList<URI> hosts;\n\n    @Override\n    public void init(List<URI> hosts, EsConfig config) {\n        this.random = new Random();\n        this.hosts = new ArrayList<>(hosts);\n\n        RequestConfig requestConfig =\n                RequestConfig.custom()\n                        .setConnectTimeout(config.getConnectTimeoutSeconds() * 1000)\n                        .setSocketTimeout(config.getSocketTimeoutSeconds() * 1000)\n                        .setConnectionRequestTimeout(config.getConnectionRequestTimeoutSeconds() * 1000)\n                        .build();\n\n        HttpClientBuilder httpClientBuilder =\n                HttpClients.custom()\n                        .setDefaultRequestConfig(requestConfig)\n                        .setRetryHandler(new DefaultHttpRequestRetryHandler(0, false));\n\n        customizeHttpClientBuilder(httpClientBuilder, config);\n\n        this.httpClient = httpClientBuilder.build();\n    }\n\n    @Override\n    public StatusLine writeSingleDocument(String index, String docType, String id, String document) throws IOException {\n        if (this.httpClient == null) {\n            throw new RuntimeException(\"GenericEsRestClient must be initialized\");\n        }\n\n        HttpPut put = new HttpPut(String.format(\"%s/%s/%s/%s\", selectHost().toString(), index, docType, id));\n        put.setEntity(new StringEntity(document));\n        put.addHeader(APPLICATION_JSON_HEADER);\n\n        try (CloseableHttpResponse response = this.httpClient.execute(put)) {\n            return response.getStatusLine();\n        }\n    }\n\n    @Override\n    public StatusLine readSingleDocument(String index, String docType, String id) throws IOException {\n        if (this.httpClient == null) {\n            throw new RuntimeException(\"GenericEsRestClient must be initialized\");\n        }\n\n        HttpGet get = new HttpGet(String.format(\"%s/%s/%s/%s\", selectHost().toString(), index, docType, id));\n        try (CloseableHttpResponse response = this.httpClient.execute(get)) {\n            return response.getStatusLine();\n        }\n    }\n\n    @Override\n    public StatusLine writeDocumentsBulk(String bulkPayload) throws IOException {\n        if (this.httpClient == null) {\n            throw new RuntimeException(\"GenericEsRestClient must be initialized\");\n        }\n\n        HttpPost post = new HttpPost(String.format(\"%s/%s\", selectHost().toString(), \"_bulk\"));\n        post.setEntity(new StringEntity(bulkPayload));\n        post.addHeader(APPLICATION_XNDJSON_HEADER);\n\n        try (CloseableHttpResponse response = this.httpClient.execute(post)) {\n            return response.getStatusLine();\n        }\n    }\n\n    /**\n     * Override this method to add custom configuration to the Apache HttpClient before it is built, called during init phase.\n     * @param clientBuilder - HTTP client builder with preset RequestConfig and 0-retry DefaultHttpRequestRetryHandler\n     * @param config - ES REST plugin configuration\n     */\n    protected void customizeHttpClientBuilder(HttpClientBuilder clientBuilder, EsConfig config) {\n    }\n\n    protected URI selectHost() {\n        if (this.hosts.size() == 1) {\n            return this.hosts.get(0);\n        } else {\n            return this.hosts.get(this.random.nextInt(this.hosts.size()));\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        this.httpClient.close();\n    }\n}", "item_id": 0, "repo": "Netflix/ndbench", "file": "ndbench-es-plugins/src/main/java/com/netflix/ndbench/plugin/es/GenericEsRestClient.java", "last_update_at": "2022-03-11T06:04:23+00:00", "question_id": "f323f9da6a88cae4706fde69a15a962c56d24aa8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Singleton\npublic class GenericEsRestClient implements EsRestClient {\n    private static final BasicHeader APPLICATION_JSON_HEADER = new BasicHeader(\"Content-Type\", \"application/json\");\n    private static final BasicHeader APPLICATION_XNDJSON_HEADER = new BasicHeader(\"Content-Type\", \"application/x-ndjson\");\n    private Random random;\n    private CloseableHttpClient httpClient;\n    private ArrayList<URI> hosts;\n    @Override\n    public void init(List<URI> hosts, EsConfig config) {\n        this.random = new Random();\n        this.hosts = new ArrayList<>(hosts);\n        RequestConfig requestConfig =\n                RequestConfig.custom()\n                        .setConnectTimeout(config.getConnectTimeoutSeconds() * 1000)\n                        .setSocketTimeout(config.getSocketTimeoutSeconds() * 1000)\n                        .setConnectionRequestTimeout(config.getConnectionRequestTimeoutSeconds() * 1000)\n                        .build();\n        HttpClientBuilder httpClientBuilder =\n                HttpClients.custom()\n                        .setDefaultRequestConfig(requestConfig)\n                        .setRetryHandler(new DefaultHttpRequestRetryHandler(0, false));\n        customizeHttpClientBuilder(httpClientBuilder, config);\n        this.httpClient = httpClientBuilder.build();\n    }\n    @Override\n    public StatusLine writeSingleDocument(String index, String docType, String id, String document) throws IOException {\n        if (this.httpClient == null) {\n            throw new RuntimeException(\"GenericEsRestClient must be initialized\");\n        }\n        HttpPut put = new HttpPut(String.format(\"%s/%s/%s/%s\", selectHost().toString(), index, docType, id));\n        put.setEntity(new StringEntity(document));\n        put.addHeader(APPLICATION_JSON_HEADER);\n        try (CloseableHttpResponse response = this.httpClient.execute(put)) {\n            return response.getStatusLine();\n        }\n    }\n    @Override\n    public StatusLine readSingleDocument(String index, String docType, String id) throws IOException {\n        if (this.httpClient == null) {\n            throw new RuntimeException(\"GenericEsRestClient must be initialized\");\n        }\n        HttpGet get = new HttpGet(String.format(\"%s/%s/%s/%s\", selectHost().toString(), index, docType, id));\n        try (CloseableHttpResponse response = this.httpClient.execute(get)) {\n            return response.getStatusLine();\n        }\n    }\n    @Override\n    public StatusLine writeDocumentsBulk(String bulkPayload) throws IOException {\n        if (this.httpClient == null) {\n            throw new RuntimeException(\"GenericEsRestClient must be initialized\");\n        }\n        HttpPost post = new HttpPost(String.format(\"%s/%s\", selectHost().toString(), \"_bulk\"));\n        post.setEntity(new StringEntity(bulkPayload));\n        post.addHeader(APPLICATION_XNDJSON_HEADER);\n        try (CloseableHttpResponse response = this.httpClient.execute(post)) {\n            return response.getStatusLine();\n        }\n    }\n    /**\n     * Override this method to add custom configuration to the Apache HttpClient before it is built, called during init phase.\n     * @param clientBuilder - HTTP client builder with preset RequestConfig and 0-retry DefaultHttpRequestRetryHandler\n     * @param config - ES REST plugin configuration\n     */\n    protected void customizeHttpClientBuilder(HttpClientBuilder clientBuilder, EsConfig config) {\n    }\n    protected URI selectHost() {\n        if (this.hosts.size() == 1) {\n            return this.hosts.get(0);\n        } else {\n            return this.hosts.get(this.random.nextInt(this.hosts.size()));\n        }\n    }\n    @Override\n    public void close() throws IOException {\n        this.httpClient.close();\n    }\n"]], "pred": {"ppl": 1.5761544704437256, "ppl_lower": 1.8179011344909668, "ppl/lowercase_ppl": -1.3136228024935463, "ppl/zlib": 0.0004549880008735481, "Min_5.0% Prob": 5.774683840731357, "Min_10.0% Prob": 3.840673213256033, "Min_20.0% Prob": 2.1870531824858563, "Min_30.0% Prob": 1.5028238665639309, "Min_40.0% Prob": 1.1345941131199269, "Min_50.0% Prob": 0.9092691036313773, "Min_60.0% Prob": 0.7581486725107472}}
{"hexsha": "8583e4992664b245cbdaf2549ac75cb70f5efc47", "ext": "java", "lang": "Java", "content": "public class CubeSegmentTupleIterator implements ITupleIterator {\n\n    public static final Logger logger = LoggerFactory.getLogger(CubeSegmentTupleIterator.class);\n\n    public static final int SCAN_CACHE = 1024;\n\n    private final CubeInstance cube;\n    private final CubeSegment cubeSeg;\n    private final Collection<TblColRef> dimensions;\n    private final TupleFilter filter;\n    private final Collection<TblColRef> groupBy;\n    private final Collection<RowValueDecoder> rowValueDecoders;\n    private final StorageContext context;\n    private final String tableName;\n    private final HTableInterface table;\n    private final RowKeyDecoder rowKeyDecoder;\n    private final Iterator<HBaseKeyRange> rangeIterator;\n\n    private Scan scan;\n    private ResultScanner scanner;\n    private Iterator<Result> resultIterator;\n    private TupleInfo tupleInfo;\n    private Tuple tuple;\n    private int scanCount;\n\n    public CubeSegmentTupleIterator(CubeSegment cubeSeg, Collection<HBaseKeyRange> keyRanges, HConnection conn, Collection<TblColRef> dimensions, TupleFilter filter, Collection<TblColRef> groupBy, Collection<RowValueDecoder> rowValueDecoders, StorageContext context) {\n        this.cube = cubeSeg.getCubeInstance();\n        this.cubeSeg = cubeSeg;\n        this.dimensions = dimensions;\n        this.filter = filter;\n        this.groupBy = groupBy;\n        this.rowValueDecoders = rowValueDecoders;\n        this.context = context;\n        this.tableName = cubeSeg.getStorageLocationIdentifier();\n        this.rowKeyDecoder = new RowKeyDecoder(this.cubeSeg);\n        this.scanCount = 0;\n\n        try {\n            this.table = conn.getTable(tableName);\n        } catch (Throwable t) {\n            throw new StorageException(\"Error when open connection to table \" + tableName, t);\n        }\n        this.rangeIterator = keyRanges.iterator();\n        scanNextRange();\n    }\n\n    @Override\n    public void close() {\n        closeScanner();\n        closeTable();\n    }\n\n    private void closeScanner() {\n        if (logger.isDebugEnabled() && scan != null) {\n            logger.debug(\"Scan \" + scan.toString());\n            byte[] metricsBytes = scan.getAttribute(Scan.SCAN_ATTRIBUTES_METRICS_DATA);\n            if (metricsBytes != null) {\n                ScanMetrics scanMetrics = ProtobufUtil.toScanMetrics(metricsBytes);\n                logger.debug(\"HBase Metrics: \" + \"count={}, ms={}, bytes={}, remote_bytes={}, regions={}, not_serving_region={}, rpc={}, rpc_retries={}, remote_rpc={}, remote_rpc_retries={}\", new Object[] { scanCount, scanMetrics.sumOfMillisSecBetweenNexts, scanMetrics.countOfBytesInResults, scanMetrics.countOfBytesInRemoteResults, scanMetrics.countOfRegions, scanMetrics.countOfNSRE, scanMetrics.countOfRPCcalls, scanMetrics.countOfRPCRetries, scanMetrics.countOfRemoteRPCcalls, scanMetrics.countOfRemoteRPCRetries });\n            }\n        }\n        try {\n            if (scanner != null) {\n                scanner.close();\n                scanner = null;\n            }\n        } catch (Throwable t) {\n            throw new StorageException(\"Error when close scanner for table \" + tableName, t);\n        }\n    }\n\n    private void closeTable() {\n        try {\n            if (table != null) {\n                table.close();\n            }\n        } catch (Throwable t) {\n            throw new StorageException(\"Error when close table \" + tableName, t);\n        }\n    }\n\n    @Override\n    public boolean hasNext() {\n        return rangeIterator.hasNext() || resultIterator.hasNext();\n    }\n\n    @Override\n    public Tuple next() {\n        // get next result from hbase\n        Result result = null;\n        while (hasNext()) {\n            if (resultIterator.hasNext()) {\n                result = this.resultIterator.next();\n                scanCount++;\n                break;\n            } else {\n                scanNextRange();\n            }\n        }\n        if (result == null) {\n            return null;\n        }\n        // translate result to tuple\n        try {\n            translateResult(result, this.tuple);\n        } catch (IOException e) {\n            throw new IllegalStateException(\"Can't translate result \" + result, e);\n        }\n        return this.tuple;\n    }\n\n    private void scanNextRange() {\n        if (this.rangeIterator.hasNext()) {\n            closeScanner();\n            HBaseKeyRange keyRange = this.rangeIterator.next();\n            this.tupleInfo = buildTupleInfo(keyRange.getCuboid());\n            this.tuple = new Tuple(this.tupleInfo);\n\n            this.resultIterator = doScan(keyRange);\n        } else {\n            this.resultIterator = Collections.<Result> emptyList().iterator();\n        }\n    }\n\n    private final Iterator<Result> doScan(HBaseKeyRange keyRange) {\n\n        Iterator<Result> iter = null;\n        try {\n            scan = buildScan(keyRange);\n            applyFuzzyFilter(scan, keyRange);\n            logScan(keyRange);\n\n            scanner = ObserverEnabler.scanWithCoprocessorIfBeneficial(cubeSeg, keyRange.getCuboid(), filter, groupBy, rowValueDecoders, context, table, scan);\n\n            iter = scanner.iterator();\n        } catch (Throwable t) {\n            String msg = MessageFormat.format(\"Error when scan from lower key {1} to upper key {2} on table {0}.\", tableName, Bytes.toString(keyRange.getStartKey()), Bytes.toString(keyRange.getStopKey()));\n            throw new StorageException(msg, t);\n        }\n        return iter;\n    }\n\n    private void logScan(HBaseKeyRange keyRange) {\n        StringBuilder info = new StringBuilder();\n        info.append(\"\\nScan hbase table \").append(tableName).append(\": \");\n        if (keyRange.getCuboid().requirePostAggregation()) {\n            info.append(\"cuboid require post aggregation, from \");\n        } else {\n            info.append(\"cuboid exact match, from \");\n        }\n        info.append(keyRange.getCuboid().getInputID());\n        info.append(\" to \");\n        info.append(keyRange.getCuboid().getId());\n        info.append(\"\\nStart: \");\n        info.append(keyRange.getStartKeyAsString());\n        info.append(\"     - \");\n        info.append(Bytes.toStringBinary(keyRange.getStartKey()));\n        info.append(\"\\nStop:  \");\n        info.append(keyRange.getStopKeyAsString());\n        info.append(\" - \");\n        info.append(Bytes.toStringBinary(keyRange.getStopKey()));\n        if (this.scan.getFilter() != null) {\n            info.append(\"\\nFuzzy: \");\n            info.append(keyRange.getFuzzyKeyAsString());\n        }\n        logger.info(info.toString());\n    }\n\n    private Scan buildScan(HBaseKeyRange keyRange) {\n        Scan scan = new Scan();\n        scan.setCaching(SCAN_CACHE);\n        scan.setCacheBlocks(true);\n        scan.setAttribute(Scan.SCAN_ATTRIBUTES_METRICS_ENABLE, Bytes.toBytes(Boolean.TRUE));\n        for (RowValueDecoder valueDecoder : this.rowValueDecoders) {\n            HBaseColumnDesc hbaseColumn = valueDecoder.getHBaseColumn();\n            byte[] byteFamily = Bytes.toBytes(hbaseColumn.getColumnFamilyName());\n            byte[] byteQualifier = Bytes.toBytes(hbaseColumn.getQualifier());\n            scan.addColumn(byteFamily, byteQualifier);\n        }\n        scan.setStartRow(keyRange.getStartKey());\n        scan.setStopRow(keyRange.getStopKey());\n        return scan;\n    }\n\n    private void applyFuzzyFilter(Scan scan, HBaseKeyRange keyRange) {\n        List<Pair<byte[], byte[]>> fuzzyKeys = keyRange.getFuzzyKeys();\n        if (fuzzyKeys != null && fuzzyKeys.size() > 0) {\n            FuzzyRowFilter rowFilter = new FuzzyRowFilter(fuzzyKeys);\n\n            Filter filter = scan.getFilter();\n            if (filter != null) {\n                // may have existed InclusiveStopFilter, see buildScan\n                FilterList filterList = new FilterList();\n                filterList.addFilter(filter);\n                filterList.addFilter(rowFilter);\n                scan.setFilter(filterList);\n            } else {\n                scan.setFilter(rowFilter);\n            }\n        }\n    }\n\n    private TupleInfo buildTupleInfo(Cuboid cuboid) {\n        TupleInfo info = new TupleInfo();\n        int index = 0;\n        rowKeyDecoder.setCuboid(cuboid);\n        List<TblColRef> rowColumns = rowKeyDecoder.getColumns();\n        List<String> colNames = rowKeyDecoder.getNames(context.getAliasMap());\n        for (int i = 0; i < rowColumns.size(); i++) {\n            TblColRef column = rowColumns.get(i);\n            if (!dimensions.contains(column)) {\n                continue;\n            }\n            // add normal column\n            info.setField(colNames.get(i), rowColumns.get(i), rowColumns.get(i).getType().getName(), index++);\n        }\n\n        // derived columns and filler\n        Map<Array<TblColRef>, List<DeriveInfo>> hostToDerivedInfo = cubeSeg.getCubeDesc().getHostToDerivedInfo(rowColumns, null);\n        for (Entry<Array<TblColRef>, List<DeriveInfo>> entry : hostToDerivedInfo.entrySet()) {\n            TblColRef[] hostCols = entry.getKey().data;\n            for (DeriveInfo deriveInfo : entry.getValue()) {\n                // mark name for each derived field\n                for (TblColRef derivedCol : deriveInfo.columns) {\n                    String derivedField = getFieldName(derivedCol, context.getAliasMap());\n                    info.setField(derivedField, derivedCol, derivedCol.getType().getName(), index++);\n                }\n                // add filler\n                info.addDerivedColumnFiller(Tuple.newDerivedColumnFiller(rowColumns, hostCols, deriveInfo, info, CubeManager.getInstance(this.cube.getConfig()), cubeSeg));\n            }\n        }\n\n        for (RowValueDecoder rowValueDecoder : this.rowValueDecoders) {\n            List<String> names = rowValueDecoder.getNames();\n            MeasureDesc[] measures = rowValueDecoder.getMeasures();\n            for (int i = 0; i < measures.length; i++) {\n                String dataType = measures[i].getFunction().getSQLType();\n                info.setField(names.get(i), null, dataType, index++);\n            }\n        }\n        return info;\n    }\n\n    private String getFieldName(TblColRef column, Map<TblColRef, String> aliasMap) {\n        String name = null;\n        if (aliasMap != null) {\n            name = aliasMap.get(column);\n        }\n        if (name == null) {\n            name = column.getName();\n        }\n        return name;\n    }\n\n    private void translateResult(Result res, Tuple tuple) throws IOException {\n        // groups\n        byte[] rowkey = res.getRow();\n        rowKeyDecoder.decode(rowkey);\n        List<TblColRef> columns = rowKeyDecoder.getColumns();\n        List<String> dimensionNames = rowKeyDecoder.getNames(context.getAliasMap());\n        List<String> dimensionValues = rowKeyDecoder.getValues();\n        for (int i = 0; i < dimensionNames.size(); i++) {\n            TblColRef column = columns.get(i);\n            if (!tuple.hasColumn(column)) {\n                continue;\n            }\n            tuple.setDimensionValue(dimensionNames.get(i), dimensionValues.get(i));\n        }\n\n        // derived\n        for (IDerivedColumnFiller filler : tupleInfo.getDerivedColumnFillers()) {\n            filler.fillDerivedColumns(dimensionValues, tuple);\n        }\n\n        // aggregations\n        for (RowValueDecoder rowValueDecoder : this.rowValueDecoders) {\n            HBaseColumnDesc hbaseColumn = rowValueDecoder.getHBaseColumn();\n            String columnFamily = hbaseColumn.getColumnFamilyName();\n            String qualifier = hbaseColumn.getQualifier();\n            // FIXME: avoidable bytes array creation, why not use res.getValueAsByteBuffer directly?\n            byte[] valueBytes = res.getValue(Bytes.toBytes(columnFamily), Bytes.toBytes(qualifier));\n            rowValueDecoder.decode(valueBytes);\n            List<String> measureNames = rowValueDecoder.getNames();\n            Object[] measureValues = rowValueDecoder.getValues();\n            BitSet projectionIndex = rowValueDecoder.getProjectionIndex();\n            for (int i = projectionIndex.nextSetBit(0); i >= 0; i = projectionIndex.nextSetBit(i + 1)) {\n                tuple.setMeasureValue(measureNames.get(i), measureValues[i]);\n            }\n        }\n    }\n}", "item_id": 0, "repo": "LouisaChen/incubator-kylin", "file": "storage/src/main/java/org/apache/kylin/storage/hbase/CubeSegmentTupleIterator.java", "last_update_at": "2022-02-17T01:06:54+00:00", "question_id": "8583e4992664b245cbdaf2549ac75cb70f5efc47_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CubeSegmentTupleIterator implements ITupleIterator {\n    public static final Logger logger = LoggerFactory.getLogger(CubeSegmentTupleIterator.class);\n    public static final int SCAN_CACHE = 1024;\n    private final CubeInstance cube;\n    private final CubeSegment cubeSeg;\n    private final Collection<TblColRef> dimensions;\n    private final TupleFilter filter;\n    private final Collection<TblColRef> groupBy;\n    private final Collection<RowValueDecoder> rowValueDecoders;\n    private final StorageContext context;\n    private final String tableName;\n    private final HTableInterface table;\n    private final RowKeyDecoder rowKeyDecoder;\n    private final Iterator<HBaseKeyRange> rangeIterator;\n    private Scan scan;\n    private ResultScanner scanner;\n    private Iterator<Result> resultIterator;\n    private TupleInfo tupleInfo;\n    private Tuple tuple;\n    private int scanCount;\n    public CubeSegmentTupleIterator(CubeSegment cubeSeg, Collection<HBaseKeyRange> keyRanges, HConnection conn, Collection<TblColRef> dimensions, TupleFilter filter, Collection<TblColRef> groupBy, Collection<RowValueDecoder> rowValueDecoders, StorageContext context) {\n        this.cube = cubeSeg.getCubeInstance();\n        this.cubeSeg = cubeSeg;\n        this.dimensions = dimensions;\n        this.filter = filter;\n        this.groupBy = groupBy;\n        this.rowValueDecoders = rowValueDecoders;\n        this.context = context;\n        this.tableName = cubeSeg.getStorageLocationIdentifier();\n        this.rowKeyDecoder = new RowKeyDecoder(this.cubeSeg);\n        this.scanCount = 0;\n        try {\n            this.table = conn.getTable(tableName);\n        } catch (Throwable t) {\n            throw new StorageException(\"Error when open connection to table \" + tableName, t);\n        }\n        this.rangeIterator = keyRanges.iterator();\n        scanNextRange();\n    }\n    @Override\n    public void close() {\n        closeScanner();\n        closeTable();\n    }\n    private void closeScanner() {\n        if (logger.isDebugEnabled() && scan != null) {\n            logger.debug(\"Scan \" + scan.toString());\n            byte[] metricsBytes = scan.getAttribute(Scan.SCAN_ATTRIBUTES_METRICS_DATA);\n            if (metricsBytes != null) {\n                ScanMetrics scanMetrics = ProtobufUtil.toScanMetrics(metricsBytes);\n                logger.debug(\"HBase Metrics: \" + \"count={}, ms={}, bytes={}, remote_bytes={}, regions={}, not_serving_region={}, rpc={}, rpc_retries={}, remote_rpc={}, remote_rpc_retries={}\", new Object[] { scanCount, scanMetrics.sumOfMillisSecBetweenNexts, scanMetrics.countOfBytesInResults, scanMetrics.countOfBytesInRemoteResults, scanMetrics.countOfRegions, scanMetrics.countOfNSRE, scanMetrics.countOfRPCcalls, scanMetrics.countOfRPCRetries, scanMetrics.countOfRemoteRPCcalls, scanMetrics.countOfRemoteRPCRetries });\n            }\n        }\n        try {\n            if (scanner != null) {\n                scanner.close();\n                scanner = null;\n            }\n        } catch (Throwable t) {\n            throw new StorageException(\"Error when close scanner for table \" + tableName, t);\n        }\n    }\n    private void closeTable() {\n        try {\n            if (table != null) {\n                table.close();\n            }\n        } catch (Throwable t) {\n            throw new StorageException(\"Error when close table \" + tableName, t);\n        }\n    }\n    @Override\n    public boolean hasNext() {\n        return rangeIterator.hasNext() || resultIterator.hasNext();\n    }\n    @Override\n    public Tuple next() {\n        // get next result from hbase\n        Result result = null;\n        while (hasNext()) {\n            if (resultIterator.hasNext()) {\n                result = this.resultIterator.next();\n                scanCount++;\n                break;\n            } else {\n                scanNextRange();\n            }\n        }\n        if (result == null) {\n            return null;\n        }\n        // translate result to tuple\n        try {\n            translateResult(result, this.tuple);\n        } catch (IOException e) {\n            throw new IllegalStateException(\"Can't translate result \" + result, e);\n        }\n        return this.tuple;\n    }\n    private void scanNextRange() {\n        if (this.rangeIterator.hasNext()) {\n            closeScanner();\n            HBaseKeyRange keyRange = this.rangeIterator.next();\n            this.tupleInfo = buildTupleInfo(keyRange.getCuboid());\n            this.tuple = new Tuple(this.tupleInfo);\n            this.resultIterator = doScan(keyRange);\n        } else {\n            this.resultIterator = Collections.<Result> emptyList().iterator();\n        }\n    }\n    private final Iterator<Result> doScan(HBaseKeyRange keyRange) {\n        Iterator<Result> iter = null;\n        try {\n            scan = buildScan(keyRange);\n            applyFuzzyFilter(scan, keyRange);\n            logScan(keyRange);\n            scanner = ObserverEnabler.scanWithCoprocessorIfBeneficial(cubeSeg, keyRange.getCuboid(), filter, groupBy, rowValueDecoders, context, table, scan);\n            iter = scanner.iterator();\n        } catch (Throwable t) {\n            String msg = MessageFormat.format(\"Error when scan from lower key {1} to upper key {2} on table {0}.\", tableName, Bytes.toString(keyRange.getStartKey()), Bytes.toString(keyRange.getStopKey()));\n            throw new StorageException(msg, t);\n        }\n        return iter;\n    }\n    private void logScan(HBaseKeyRange keyRange) {\n        StringBuilder info = new StringBuilder();\n        info.append(\"\\nScan hbase table \").append(tableName).append(\": \");\n        if (keyRange.getCuboid().requirePostAggregation()) {\n            info.append(\"cuboid require post aggregation, from \");\n        } else {\n            info.append(\"cuboid exact match, from \");\n        }\n        info.append(keyRange.getCuboid().getInputID());\n        info.append(\" to \");\n        info.append(keyRange.getCuboid().getId());\n        info.append(\"\\nStart: \");\n        info.append(keyRange.getStartKeyAsString());\n        info.append(\"     - \");\n        info.append(Bytes.toStringBinary(keyRange.getStartKey()));\n        info.append(\"\\nStop:  \");\n        info.append(keyRange.getStopKeyAsString());\n        info.append(\" - \");\n        info.append(Bytes.toStringBinary(keyRange.getStopKey()));\n        if (this.scan.getFilter() != null) {\n            info.append(\"\\nFuzzy: \");\n            info.append(keyRange.getFuzzyKeyAsString());\n        }\n        logger.info(info.toString());\n    }\n    private Scan buildScan(HBaseKeyRange keyRange) {\n        Scan scan = new Scan();\n        scan.setCaching(SCAN_CACHE);\n        scan.setCacheBlocks(true);\n        scan.setAttribute(Scan.SCAN_ATTRIBUTES_METRICS_ENABLE, Bytes.toBytes(Boolean.TRUE));\n        for (RowValueDecoder valueDecoder : this.rowValueDecoders) {\n            HBaseColumnDesc hbaseColumn = valueDecoder.getHBaseColumn();\n            byte[] byteFamily = Bytes.toBytes(hbaseColumn.getColumnFamilyName());\n            byte[] byteQualifier = Bytes.toBytes(hbaseColumn.getQualifier());\n            scan.addColumn(byteFamily, byteQualifier);\n        }\n        scan.setStartRow(keyRange.getStartKey());\n        scan.setStopRow(keyRange.getStopKey());\n        return scan;\n    }\n    private void applyFuzzyFilter(Scan scan, HBaseKeyRange keyRange) {\n        List<Pair<byte[], byte[]>> fuzzyKeys = keyRange.getFuzzyKeys();\n        if (fuzzyKeys != null && fuzzyKeys.size() > 0) {\n            FuzzyRowFilter rowFilter = new FuzzyRowFilter(fuzzyKeys);\n            Filter filter = scan.getFilter();\n            if (filter != null) {\n                // may have existed InclusiveStopFilter, see buildScan\n                FilterList filterList = new FilterList();\n                filterList.addFilter(filter);\n                filterList.addFilter(rowFilter);\n                scan.setFilter(filterList);\n            } else {\n                scan.setFilter(rowFilter);\n            }\n        }\n    }\n    private TupleInfo buildTupleInfo(Cuboid cuboid) {\n        TupleInfo info = new TupleInfo();\n        int index = 0;\n        rowKeyDecoder.setCuboid(cuboid);\n        List<TblColRef> rowColumns = rowKeyDecoder.getColumns();\n        List<String> colNames = rowKeyDecoder.getNames(context.getAliasMap());\n        for (int i = 0; i < rowColumns.size(); i++) {\n            TblColRef column = rowColumns.get(i);\n            if (!dimensions.contains(column)) {\n                continue;\n            }\n            // add normal column\n            info.setField(colNames.get(i), rowColumns.get(i), rowColumns.get(i).getType().getName(), index++);\n        }\n        // derived columns and filler\n        Map<Array<TblColRef>, List<DeriveInfo>> hostToDerivedInfo = cubeSeg.getCubeDesc().getHostToDerivedInfo(rowColumns, null);\n        for (Entry<Array<TblColRef>, List<DeriveInfo>> entry : hostToDerivedInfo.entrySet()) {\n            TblColRef[] hostCols = entry.getKey().data;\n            for (DeriveInfo deriveInfo : entry.getValue()) {\n                // mark name for each derived field\n                for (TblColRef derivedCol : deriveInfo.columns) {\n                    String derivedField = getFieldName(derivedCol, context.getAliasMap());\n                    info.setField(derivedField, derivedCol, derivedCol.getType().getName(), index++);\n                }\n                // add filler\n                info.addDerivedColumnFiller(Tuple.newDerivedColumnFiller(rowColumns, hostCols, deriveInfo, info, CubeManager.getInstance(this.cube.getConfig()), cubeSeg));\n            }\n        }\n        for (RowValueDecoder rowValueDecoder : this.rowValueDecoders) {\n            List<String> names = rowValueDecoder.getNames();\n            MeasureDesc[] measures = rowValueDecoder.getMeasures();\n            for (int i = 0; i < measures.length; i++) {\n                String dataType = measures[i].getFunction().getSQLType();\n                info.setField(names.get(i), null, dataType, index++);\n            }\n        }\n        return info;\n    }\n    private String getFieldName(TblColRef column, Map<TblColRef, String> aliasMap) {\n        String name = null;\n        if (aliasMap != null) {\n            name = aliasMap.get(column);\n        }\n        if (name == null) {\n            name = column.getName();\n        }\n        return name;\n    }\n    private void translateResult(Result res, Tuple tuple) throws IOException {\n        // groups\n        byte[] rowkey = res.getRow();\n        rowKeyDecoder.decode(rowkey);\n        List<TblColRef> columns = rowKeyDecoder.getColumns();\n        List<String> dimensionNames = rowKeyDecoder.getNames(context.getAliasMap());\n        List<String> dimensionValues = rowKeyDecoder.getValues();\n        for (int i = 0; i < dimensionNames.size(); i++) {\n            TblColRef column = columns.get(i);\n            if (!tuple.hasColumn(column)) {\n                continue;\n            }\n            tuple.setDimensionValue(dimensionNames.get(i), dimensionValues.get(i));\n        }\n        // derived\n        for (IDerivedColumnFiller filler : tupleInfo.getDerivedColumnFillers()) {\n            filler.fillDerivedColumns(dimensionValues, tuple);\n        }\n        // aggregations\n        for (RowValueDecoder rowValueDecoder : this.rowValueDecoders) {\n            HBaseColumnDesc hbaseColumn = rowValueDecoder.getHBaseColumn();\n            String columnFamily = hbaseColumn.getColumnFamilyName();\n            String qualifier = hbaseColumn.getQualifier();\n            // FIXME: avoidable bytes array creation, why not use res.getValueAsByteBuffer directly?\n            byte[] valueBytes = res.getValue(Bytes.toBytes(columnFamily), Bytes.toBytes(qualifier));\n            rowValueDecoder.decode(valueBytes);\n            List<String> measureNames = rowValueDecoder.getNames();\n            Object[] measureValues = rowValueDecoder.getValues();\n            BitSet projectionIndex = rowValueDecoder.getProjectionIndex();\n            for (int i = projectionIndex.nextSetBit(0); i >= 0; i = projectionIndex.nextSetBit(i + 1)) {\n                tuple.setMeasureValue(measureNames.get(i), measureValues[i]);\n            }\n        }\n    }\n"]], "pred": {"ppl": 1.7113205194473267, "ppl_lower": 2.0829362869262695, "ppl/lowercase_ppl": -1.365765788937857, "ppl/zlib": 0.00017592184220384768, "Min_5.0% Prob": 5.4590499728333715, "Min_10.0% Prob": 4.02588925408382, "Min_20.0% Prob": 2.4770986551747605, "Min_30.0% Prob": 1.7523737132451893, "Min_40.0% Prob": 1.3347950001363358, "Min_50.0% Prob": 1.0734380100436378, "Min_60.0% Prob": 0.8960600329614677}}
{"hexsha": "5d42bfbd525a96e3872e60902d366d8b52535d51", "ext": "java", "lang": "Java", "content": "class RegistryDataControllerTest extends BaseControllerTest {\n\n    private static final String REGISTRY_TYPE_NAME = RegistryTestEntity.class.getName();\n\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    @Autowired\n    private PlatformTransactionManager platformTransactionManager;\n\n    @Test\n    void shouldBulkListRegistry() throws Exception {\n        // given\n        executeInTransaction(platformTransactionManager, () -> createRegistryTestEntityList(entityManager));\n\n        String requestUrl = fullUrl(\"list-bulk\");\n        ListBulkRegistryRequest request = createBulkListRegistryRequest(REGISTRY_TYPE_NAME, \"name%\");\n\n        // when\n        ResultActions result = performPostRequest(requestUrl, request);\n\n        // then\n        result.andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.['\" + REGISTRY_TYPE_NAME + \"'].content\").isNotEmpty());\n    }\n\n    @Test\n    void shouldListRegistry() throws Exception {\n        // given\n        executeInTransaction(platformTransactionManager, () -> createRegistryTestEntityList(entityManager));\n\n        String requestUrl = fullUrl(\"list\");\n        ListRegistryRequest request = createListRegistryRequest(REGISTRY_TYPE_NAME, \"name%\");\n\n        // when\n        ResultActions result = performPostRequest(requestUrl, request);\n\n        // then\n        result.andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.numberOfElements\").value(5));\n    }\n\n    @Test\n    void shouldCreateRegistryEntity() throws Exception {\n        // given\n        String requestUrl = fullUrl(\"create\");\n        String entityName = \"name for creating\";\n        CreateRegistryRequest request = createRegistryRequest(objectMapper, REGISTRY_TYPE_NAME, entityName);\n\n        // when\n        ResultActions result = performPostRequest(requestUrl, request);\n\n        // then\n        result.andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.name\").value(entityName));\n    }\n\n    @Test\n    void shouldReturnErrorWhenCreateInputDataIsNotValid() throws Exception {\n        // given\n        String requestUrl = fullUrl(\"create\");\n        CreateRegistryRequest request = createRegistryRequest(objectMapper, REGISTRY_TYPE_NAME, null);\n\n        // when\n        ResultActions result = performPostRequest(requestUrl, request);\n\n        // then\n        result.andExpect(status().isBadRequest());\n    }\n\n    @Test\n    void shouldUpdateRegistryEntity() throws Exception {\n        // given\n        RegistryTestEntity registryTestEntity = executeInTransaction(platformTransactionManager, () -> createRegistryTestEntity(entityManager));\n\n        String requestUrl = fullUrl(\"update\");\n        String entityName = \"name for creating update\";\n        UpdateRegistryRequest request = updateRegistryRequest(objectMapper, REGISTRY_TYPE_NAME, registryTestEntity.getId(), entityName);\n\n        // when\n        ResultActions result = performPostRequest(requestUrl, request);\n\n        // then\n        result.andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.name\").value(entityName));\n    }\n\n    @Test\n    void shouldReturnErrorWhenUpdatingWithInvalidData() throws Exception {\n        // given\n        RegistryTestEntity registryTestEntity = executeInTransaction(platformTransactionManager, () -> createRegistryTestEntity(entityManager));\n\n        String requestUrl = fullUrl(\"update\");\n        UpdateRegistryRequest request = updateRegistryRequest(objectMapper, REGISTRY_TYPE_NAME, registryTestEntity.getId(), null);\n\n        // when\n        ResultActions result = performPostRequest(requestUrl, request);\n\n        // then\n        result.andExpect(status().isBadRequest());\n    }\n\n    @Test\n    void shouldNotFailUpdatingRegistryEntityWithAssociation() throws Exception {\n        // given\n        RegistryTestEntity registryTestEntity = executeInTransaction(platformTransactionManager, () -> createRegistryTestEntityWithParent(entityManager));\n\n        String requestUrl = fullUrl(\"update\");\n        String entityName = \"name for update\";\n        UpdateRegistryRequest request = updateRegistryRequest(objectMapper, REGISTRY_TYPE_NAME, registryTestEntity.getId(), entityName);\n\n        // when\n        ResultActions result = performPostRequest(requestUrl, request);\n\n        // then\n        result.andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.name\").value(entityName));\n    }\n\n    @Test\n    void shouldDeleteRegistryEntity() throws Exception {\n        // given\n        RegistryTestEntity registryTestEntity = executeInTransaction(platformTransactionManager, () -> createRegistryTestEntity(entityManager));\n\n        String requestUrl = fullUrl(\"delete\");\n        DeleteRegistryRequest request = createDeleteRegistryRequest(RegistryTestEntity.class.getName(), registryTestEntity.getId());\n\n        // when\n        ResultActions result = performPostRequest(requestUrl, request);\n\n        // then\n        result.andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.id\").value(registryTestEntity.getId()));\n    }\n\n    @Test\n    void shouldDeleteRegistryEntityWithEmbeddedId() throws Exception {\n        // given\n        RegistryTestEmbeddedUserGroup registryTestEmbeddedUserGroup = executeInTransaction(platformTransactionManager, () -> createRegistryTestEmbeddedUserGroup(entityManager));\n\n        String requestUrl = fullUrl(\"delete\");\n        DeleteRegistryRequest request = createDeleteEmbeddedUserGroupRequest(registryTestEmbeddedUserGroup.getUserGroupId());\n\n        // when\n        ResultActions result = performPostRequest(requestUrl, request);\n\n        // then\n        result.andExpect(status().isOk());\n    }\n\n    @AfterEach\n    void cleanup() {\n        executeInTransaction(platformTransactionManager, () -> entityManager.createQuery(\"delete from \" + RegistryTestEntity.class.getName()).executeUpdate());\n    }\n\n    private String fullUrl(String path) {\n        return String.format(\"/nrich/registry/data/%s\", path);\n    }\n}", "item_id": 0, "repo": "croz-ltd/nrich", "file": "nrich-registry/src/test/java/net/croz/nrich/registry/data/controller/RegistryDataControllerTest.java", "last_update_at": "2022-03-10T07:27:58+00:00", "question_id": "5d42bfbd525a96e3872e60902d366d8b52535d51_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class RegistryDataControllerTest extends BaseControllerTest {\n    private static final String REGISTRY_TYPE_NAME = RegistryTestEntity.class.getName();\n    @PersistenceContext\n    private EntityManager entityManager;\n    @Autowired\n    private PlatformTransactionManager platformTransactionManager;\n    @Test\n    void shouldBulkListRegistry() throws Exception {\n        // given\n        executeInTransaction(platformTransactionManager, () -> createRegistryTestEntityList(entityManager));\n        String requestUrl = fullUrl(\"list-bulk\");\n        ListBulkRegistryRequest request = createBulkListRegistryRequest(REGISTRY_TYPE_NAME, \"name%\");\n        // when\n        ResultActions result = performPostRequest(requestUrl, request);\n        // then\n        result.andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.['\" + REGISTRY_TYPE_NAME + \"'].content\").isNotEmpty());\n    }\n    @Test\n    void shouldListRegistry() throws Exception {\n        // given\n        executeInTransaction(platformTransactionManager, () -> createRegistryTestEntityList(entityManager));\n        String requestUrl = fullUrl(\"list\");\n        ListRegistryRequest request = createListRegistryRequest(REGISTRY_TYPE_NAME, \"name%\");\n        // when\n        ResultActions result = performPostRequest(requestUrl, request);\n        // then\n        result.andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.numberOfElements\").value(5));\n    }\n    @Test\n    void shouldCreateRegistryEntity() throws Exception {\n        // given\n        String requestUrl = fullUrl(\"create\");\n        String entityName = \"name for creating\";\n        CreateRegistryRequest request = createRegistryRequest(objectMapper, REGISTRY_TYPE_NAME, entityName);\n        // when\n        ResultActions result = performPostRequest(requestUrl, request);\n        // then\n        result.andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.name\").value(entityName));\n    }\n    @Test\n    void shouldReturnErrorWhenCreateInputDataIsNotValid() throws Exception {\n        // given\n        String requestUrl = fullUrl(\"create\");\n        CreateRegistryRequest request = createRegistryRequest(objectMapper, REGISTRY_TYPE_NAME, null);\n        // when\n        ResultActions result = performPostRequest(requestUrl, request);\n        // then\n        result.andExpect(status().isBadRequest());\n    }\n    @Test\n    void shouldUpdateRegistryEntity() throws Exception {\n        // given\n        RegistryTestEntity registryTestEntity = executeInTransaction(platformTransactionManager, () -> createRegistryTestEntity(entityManager));\n        String requestUrl = fullUrl(\"update\");\n        String entityName = \"name for creating update\";\n        UpdateRegistryRequest request = updateRegistryRequest(objectMapper, REGISTRY_TYPE_NAME, registryTestEntity.getId(), entityName);\n        // when\n        ResultActions result = performPostRequest(requestUrl, request);\n        // then\n        result.andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.name\").value(entityName));\n    }\n    @Test\n    void shouldReturnErrorWhenUpdatingWithInvalidData() throws Exception {\n        // given\n        RegistryTestEntity registryTestEntity = executeInTransaction(platformTransactionManager, () -> createRegistryTestEntity(entityManager));\n        String requestUrl = fullUrl(\"update\");\n        UpdateRegistryRequest request = updateRegistryRequest(objectMapper, REGISTRY_TYPE_NAME, registryTestEntity.getId(), null);\n        // when\n        ResultActions result = performPostRequest(requestUrl, request);\n        // then\n        result.andExpect(status().isBadRequest());\n    }\n    @Test\n    void shouldNotFailUpdatingRegistryEntityWithAssociation() throws Exception {\n        // given\n        RegistryTestEntity registryTestEntity = executeInTransaction(platformTransactionManager, () -> createRegistryTestEntityWithParent(entityManager));\n        String requestUrl = fullUrl(\"update\");\n        String entityName = \"name for update\";\n        UpdateRegistryRequest request = updateRegistryRequest(objectMapper, REGISTRY_TYPE_NAME, registryTestEntity.getId(), entityName);\n        // when\n        ResultActions result = performPostRequest(requestUrl, request);\n        // then\n        result.andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.name\").value(entityName));\n    }\n    @Test\n    void shouldDeleteRegistryEntity() throws Exception {\n        // given\n        RegistryTestEntity registryTestEntity = executeInTransaction(platformTransactionManager, () -> createRegistryTestEntity(entityManager));\n        String requestUrl = fullUrl(\"delete\");\n        DeleteRegistryRequest request = createDeleteRegistryRequest(RegistryTestEntity.class.getName(), registryTestEntity.getId());\n        // when\n        ResultActions result = performPostRequest(requestUrl, request);\n        // then\n        result.andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.id\").value(registryTestEntity.getId()));\n    }\n    @Test\n    void shouldDeleteRegistryEntityWithEmbeddedId() throws Exception {\n        // given\n        RegistryTestEmbeddedUserGroup registryTestEmbeddedUserGroup = executeInTransaction(platformTransactionManager, () -> createRegistryTestEmbeddedUserGroup(entityManager));\n        String requestUrl = fullUrl(\"delete\");\n        DeleteRegistryRequest request = createDeleteEmbeddedUserGroupRequest(registryTestEmbeddedUserGroup.getUserGroupId());\n        // when\n        ResultActions result = performPostRequest(requestUrl, request);\n        // then\n        result.andExpect(status().isOk());\n    }\n    @AfterEach\n    void cleanup() {\n        executeInTransaction(platformTransactionManager, () -> entityManager.createQuery(\"delete from \" + RegistryTestEntity.class.getName()).executeUpdate());\n    }\n    private String fullUrl(String path) {\n        return String.format(\"/nrich/registry/data/%s\", path);\n    }\n"]], "pred": {"ppl": 1.509283185005188, "ppl_lower": 1.6735678911209106, "ppl/lowercase_ppl": -1.2510064173738253, "ppl/zlib": 0.0004667061521523414, "Min_5.0% Prob": 5.218981555863922, "Min_10.0% Prob": 3.4881840488489937, "Min_20.0% Prob": 2.0075486316254327, "Min_30.0% Prob": 1.3663189878894224, "Min_40.0% Prob": 1.0271634648856878, "Min_50.0% Prob": 0.8234345081573035, "Min_60.0% Prob": 0.6867767714296709}}
{"hexsha": "78f5a083638aa3008d8699e518e6dfa6bb395155", "ext": "java", "lang": "Java", "content": "public class DecimalTransform {\n\n  /**\n   Add a value to a column\n   */\n  public static BigDecimal add(BigDecimal bd1, Object o) {\n    BigDecimal bd2 = objectToBigDecimal(o);\n    if (bd1 == null) {\n      return bd2;\n    }\n    return bd1.add(bd2);\n  }\n\n  /**\n   Subtract a value from a column\n   */\n  public static BigDecimal subtract(BigDecimal bd1, Object o) {\n    BigDecimal bd2 = objectToBigDecimal(o);\n    if (bd1 == null) {\n      return bd2.negate();\n    }\n    return bd1.subtract(bd2);\n  }\n\n  /**\n   Multiply the column by a given value\n   */\n  public static BigDecimal multiply(BigDecimal bd1, Object o) {\n    BigDecimal bd2 = objectToBigDecimal(o);\n    if (bd1 == null) {\n      return BigDecimal.ZERO;\n    }\n    return bd1.multiply(bd2);\n  }\n\n  /**\n   Divide the column by a given value and return the quotient\n   */\n  public static BigDecimal divideq(BigDecimal bd1, Object o) {\n    BigDecimal bd2 = objectToBigDecimal(o);\n    if (bd2.equals(BigDecimal.ZERO)) {\n      return null;\n    }\n    if (bd1 == null) {\n      return BigDecimal.ZERO;\n    }\n    return bd1.divide(bd2, BigDecimal.ROUND_HALF_EVEN);\n  }\n\n  /**\n   Divide the column by a given value and return the remainder\n   */\n  public static BigDecimal divider(BigDecimal bd1, Object o) {\n    BigDecimal bd2 = objectToBigDecimal(o);\n    if (bd2.equals(BigDecimal.ZERO)) {\n      return null;\n    }\n    if (bd1 == null) {\n      return BigDecimal.ZERO;\n    }\n    return bd1.remainder(bd2);\n  }\n\n  /**\n  Get the absolute value\n   */\n  public static BigDecimal abs(BigDecimal bd) {\n    return bd.abs();\n  }\n\n  /**\n   Get the precision of a decimal value\n   */\n  public static int precision(BigDecimal bd) {\n    return bd.precision();\n  }\n\n  /**\n   Get the scale of a decimal value\n   */\n  public static int scale(BigDecimal bd) {\n    return bd.scale();\n  }\n\n  /**\n   Get the unscaled value of a decimal value\n   */\n  public static BigInteger unscaled(BigDecimal bd) {\n    return bd.unscaledValue();\n  }\n\n  /**\n   Move the decimal point n places to the left\n   */\n  public static BigDecimal decimal_left(BigDecimal bd, int n) {\n    int newScale = bd.scale() + n;\n    bd = bd.setScale(newScale, BigDecimal.ROUND_UP);\n    bd = bd.divide(BigDecimal.valueOf(Math.pow(10, n)), BigDecimal.ROUND_HALF_EVEN);\n    return bd.stripTrailingZeros();\n  }\n\n  /**\n   Move the decimal point n places to the right\n   */\n  public static BigDecimal decimal_right(BigDecimal bd, int n) {\n    int newScale = Math.max(bd.scale() - n, 0);\n    bd = bd.multiply(BigDecimal.valueOf(Math.pow(10, n)));\n    bd = bd.setScale(newScale, BigDecimal.ROUND_DOWN);\n    return bd;\n  }\n\n  /**\n   Get the nth power of a decimal\n   */\n  public static BigDecimal pow(BigDecimal bd, int pow) {\n    return bd.pow(pow);\n  }\n\n  /**\n   Negate a decimal\n   */\n  public static BigDecimal negate(BigDecimal bd) {\n    bd = bd.negate();\n    if (bd.compareTo(BigDecimal.ZERO) == 0) {\n      return BigDecimal.ZERO;\n    }\n    return bd;\n  }\n\n  /**\n   Strip trailing zeros in a decimal\n   */\n  public static BigDecimal strip_zero(BigDecimal bd) {\n    return bd.stripTrailingZeros();\n  }\n\n  /**\n   Sign of a value\n   */\n  public static int sign(BigDecimal bd) {\n    return Integer.compare(bd.compareTo(BigDecimal.ZERO), 0);\n  }\n\n  private static BigDecimal objectToBigDecimal(Object o) {\n    if (o instanceof BigDecimal) {\n      return (BigDecimal) o;\n    } else if (o instanceof Integer) {\n      return BigDecimal.valueOf((Integer) o);\n    } else if (o instanceof Double) {\n      return BigDecimal.valueOf((Double) o);\n    } else {\n      return null;\n    }\n  }\n}", "item_id": 0, "repo": "buzila/wrangler", "file": "wrangler-core/src/main/java/io/cdap/wrangler/utils/DecimalTransform.java", "last_update_at": "2022-03-30T07:43:42+00:00", "question_id": "78f5a083638aa3008d8699e518e6dfa6bb395155_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DecimalTransform {\n  /**\n   Add a value to a column\n   */\n  public static BigDecimal add(BigDecimal bd1, Object o) {\n    BigDecimal bd2 = objectToBigDecimal(o);\n    if (bd1 == null) {\n      return bd2;\n    }\n    return bd1.add(bd2);\n  }\n  /**\n   Subtract a value from a column\n   */\n  public static BigDecimal subtract(BigDecimal bd1, Object o) {\n    BigDecimal bd2 = objectToBigDecimal(o);\n    if (bd1 == null) {\n      return bd2.negate();\n    }\n    return bd1.subtract(bd2);\n  }\n  /**\n   Multiply the column by a given value\n   */\n  public static BigDecimal multiply(BigDecimal bd1, Object o) {\n    BigDecimal bd2 = objectToBigDecimal(o);\n    if (bd1 == null) {\n      return BigDecimal.ZERO;\n    }\n    return bd1.multiply(bd2);\n  }\n  /**\n   Divide the column by a given value and return the quotient\n   */\n  public static BigDecimal divideq(BigDecimal bd1, Object o) {\n    BigDecimal bd2 = objectToBigDecimal(o);\n    if (bd2.equals(BigDecimal.ZERO)) {\n      return null;\n    }\n    if (bd1 == null) {\n      return BigDecimal.ZERO;\n    }\n    return bd1.divide(bd2, BigDecimal.ROUND_HALF_EVEN);\n  }\n  /**\n   Divide the column by a given value and return the remainder\n   */\n  public static BigDecimal divider(BigDecimal bd1, Object o) {\n    BigDecimal bd2 = objectToBigDecimal(o);\n    if (bd2.equals(BigDecimal.ZERO)) {\n      return null;\n    }\n    if (bd1 == null) {\n      return BigDecimal.ZERO;\n    }\n    return bd1.remainder(bd2);\n  }\n  /**\n  Get the absolute value\n   */\n  public static BigDecimal abs(BigDecimal bd) {\n    return bd.abs();\n  }\n  /**\n   Get the precision of a decimal value\n   */\n  public static int precision(BigDecimal bd) {\n    return bd.precision();\n  }\n  /**\n   Get the scale of a decimal value\n   */\n  public static int scale(BigDecimal bd) {\n    return bd.scale();\n  }\n  /**\n   Get the unscaled value of a decimal value\n   */\n  public static BigInteger unscaled(BigDecimal bd) {\n    return bd.unscaledValue();\n  }\n  /**\n   Move the decimal point n places to the left\n   */\n  public static BigDecimal decimal_left(BigDecimal bd, int n) {\n    int newScale = bd.scale() + n;\n    bd = bd.setScale(newScale, BigDecimal.ROUND_UP);\n    bd = bd.divide(BigDecimal.valueOf(Math.pow(10, n)), BigDecimal.ROUND_HALF_EVEN);\n    return bd.stripTrailingZeros();\n  }\n  /**\n   Move the decimal point n places to the right\n   */\n  public static BigDecimal decimal_right(BigDecimal bd, int n) {\n    int newScale = Math.max(bd.scale() - n, 0);\n    bd = bd.multiply(BigDecimal.valueOf(Math.pow(10, n)));\n    bd = bd.setScale(newScale, BigDecimal.ROUND_DOWN);\n    return bd;\n  }\n  /**\n   Get the nth power of a decimal\n   */\n  public static BigDecimal pow(BigDecimal bd, int pow) {\n    return bd.pow(pow);\n  }\n  /**\n   Negate a decimal\n   */\n  public static BigDecimal negate(BigDecimal bd) {\n    bd = bd.negate();\n    if (bd.compareTo(BigDecimal.ZERO) == 0) {\n      return BigDecimal.ZERO;\n    }\n    return bd;\n  }\n  /**\n   Strip trailing zeros in a decimal\n   */\n  public static BigDecimal strip_zero(BigDecimal bd) {\n    return bd.stripTrailingZeros();\n  }\n  /**\n   Sign of a value\n   */\n  public static int sign(BigDecimal bd) {\n    return Integer.compare(bd.compareTo(BigDecimal.ZERO), 0);\n  }\n  private static BigDecimal objectToBigDecimal(Object o) {\n    if (o instanceof BigDecimal) {\n      return (BigDecimal) o;\n    } else if (o instanceof Integer) {\n      return BigDecimal.valueOf((Integer) o);\n    } else if (o instanceof Double) {\n      return BigDecimal.valueOf((Double) o);\n    } else {\n      return null;\n    }\n  }\n"]], "pred": {"ppl": 1.3436951637268066, "ppl_lower": 1.4070894718170166, "ppl/lowercase_ppl": -1.1560470915776349, "ppl/zlib": 0.00038820420981839385, "Min_5.0% Prob": 4.298628613060596, "Min_10.0% Prob": 2.6813196925555958, "Min_20.0% Prob": 1.4537094424606538, "Min_30.0% Prob": 0.9811993544385617, "Min_40.0% Prob": 0.736879138889652, "Min_50.0% Prob": 0.5907271560008133, "Min_60.0% Prob": 0.4927825501986641}}
{"hexsha": "9c67837ea760b121b225a8bd8fc5b55c664154a0", "ext": "java", "lang": "Java", "content": "public class DecoratedRunnableScheduledFuture<V> extends Decorated implements RunnableScheduledFuture<V> {\n\n    private final RunnableScheduledFuture<V> target;\n\n    /**\n     * Create a new DecoratedRunnableScheduledFuture. Private, use factory to create.\n     *\n     * @param target the RunnableScheduledFuture to decorate\n     */\n    private DecoratedRunnableScheduledFuture(final RunnableScheduledFuture<V> target) {\n        this.target = target;\n    }\n\n    /**\n     * Factory method to decorate a RunnableScheduledFuture only if it is not already a DecoratedRunnableScheduledFuture.\n     *\n     * @param target the RunnableScheduledFuture to consider for decoration\n     * @return a DecoratedRunnableScheduledFuture representing the input RunnableScheduledFuture\n     */\n    public static RunnableScheduledFuture maybeCreate(RunnableScheduledFuture target) {\n        if (target == null) {\n            return null;\n        }\n\n        if (target instanceof DecoratedRunnableScheduledFuture) {\n            return target;\n        }\n\n        return new DecoratedRunnableScheduledFuture(target);\n    }\n\n    /**\n     * When the RunnableScheduledFuture is executed, perform DiSCo TransactionContext propagation, as necessary\n     *\n     * {@inheritDoc}\n     */\n    @Override\n    public void run() {\n        before();\n        try {\n            target.run();\n        } catch (Throwable t) {\n            throw t;\n        } finally {\n            after();\n        }\n    }\n\n    // Delegate all abstract methods\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int compareTo(Delayed o) {\n        return target.compareTo(o);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isPeriodic() {\n        return this.target.isPeriodic();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isDone() {\n        return this.target.isDone();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getDelay(TimeUnit unit) {\n        return this.target.getDelay(unit);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean cancel(boolean mayInterruptIfRunning) {\n        return this.target.cancel(mayInterruptIfRunning);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isCancelled() {\n        return this.target.isCancelled();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public V get() throws InterruptedException, ExecutionException {\n        return this.target.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n        return this.target.get(timeout, unit);\n    }\n}", "item_id": 0, "repo": "sullis/disco", "file": "disco-java-agent/disco-java-agent-core/src/main/java/software/amazon/disco/agent/concurrent/decorate/DecoratedRunnableScheduledFuture.java", "last_update_at": "2022-02-11T02:31:47+00:00", "question_id": "9c67837ea760b121b225a8bd8fc5b55c664154a0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DecoratedRunnableScheduledFuture<V> extends Decorated implements RunnableScheduledFuture<V> {\n    private final RunnableScheduledFuture<V> target;\n    /**\n     * Create a new DecoratedRunnableScheduledFuture. Private, use factory to create.\n     *\n     * @param target the RunnableScheduledFuture to decorate\n     */\n    private DecoratedRunnableScheduledFuture(final RunnableScheduledFuture<V> target) {\n        this.target = target;\n    }\n    /**\n     * Factory method to decorate a RunnableScheduledFuture only if it is not already a DecoratedRunnableScheduledFuture.\n     *\n     * @param target the RunnableScheduledFuture to consider for decoration\n     * @return a DecoratedRunnableScheduledFuture representing the input RunnableScheduledFuture\n     */\n    public static RunnableScheduledFuture maybeCreate(RunnableScheduledFuture target) {\n        if (target == null) {\n            return null;\n        }\n        if (target instanceof DecoratedRunnableScheduledFuture) {\n            return target;\n        }\n        return new DecoratedRunnableScheduledFuture(target);\n    }\n    /**\n     * When the RunnableScheduledFuture is executed, perform DiSCo TransactionContext propagation, as necessary\n     *\n     * {@inheritDoc}\n     */\n    @Override\n    public void run() {\n        before();\n        try {\n            target.run();\n        } catch (Throwable t) {\n            throw t;\n        } finally {\n            after();\n        }\n    }\n    // Delegate all abstract methods\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int compareTo(Delayed o) {\n        return target.compareTo(o);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isPeriodic() {\n        return this.target.isPeriodic();\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isDone() {\n        return this.target.isDone();\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getDelay(TimeUnit unit) {\n        return this.target.getDelay(unit);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean cancel(boolean mayInterruptIfRunning) {\n        return this.target.cancel(mayInterruptIfRunning);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isCancelled() {\n        return this.target.isCancelled();\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public V get() throws InterruptedException, ExecutionException {\n        return this.target.get();\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n        return this.target.get(timeout, unit);\n    }\n"]], "pred": {"ppl": 1.570010781288147, "ppl_lower": 1.6634650230407715, "ppl/lowercase_ppl": -1.1281812206733537, "ppl/zlib": 0.0006633565976458125, "Min_5.0% Prob": 6.29911986777657, "Min_10.0% Prob": 4.06653788842653, "Min_20.0% Prob": 2.2250287244035527, "Min_30.0% Prob": 1.5017514590775862, "Min_40.0% Prob": 1.1262662643414552, "Min_50.0% Prob": 0.9028914384373234, "Min_60.0% Prob": 0.7516728344655946}}
{"hexsha": "266a4ba1687a28a03b291a47133a4040e02190d1", "ext": "java", "lang": "Java", "content": "public class Stack {\n  private static class StackNode {\n    private int data;\n    private StackNode next;\n\n    public StackNode(int data) {\n      this.data = data;\n    }\n  }\n\n  private StackNode top;\n\n  public int pop() {\n    if (top == null) throw new EmptyStackException();\n    int data = top.data;\n    top = top.next;\n    return data;\n  }\n\n  public void push(int data) {\n    StackNode newTop = new StackNode(data);\n    newTop.next = top;\n    top = newTop;\n  }\n\n  public int peek() {\n    if (top == null) throw new EmptyStackException();\n    return top.data;\n  }\n\n  public boolean isEmpty() {\n    return top == null;\n  }\n}", "item_id": 0, "repo": "palash24/algorithms-and-data-structures", "file": "cracking-the-coding-interview/0018-Stack.java", "last_update_at": "2022-03-14T13:30:40+00:00", "question_id": "266a4ba1687a28a03b291a47133a4040e02190d1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Stack {\n  private static class StackNode {\n    private int data;\n    private StackNode next;\n    public StackNode(int data) {\n      this.data = data;\n    }\n  }\n  private StackNode top;\n  public int pop() {\n    if (top == null) throw new EmptyStackException();\n    int data = top.data;\n    top = top.next;\n    return data;\n  }\n  public void push(int data) {\n    StackNode newTop = new StackNode(data);\n    newTop.next = top;\n    top = newTop;\n  }\n  public int peek() {\n    if (top == null) throw new EmptyStackException();\n    return top.data;\n  }\n  public boolean isEmpty() {\n    return top == null;\n  }\n"]], "pred": {"ppl": 1.291987419128418, "ppl_lower": 1.4216433763504028, "ppl/lowercase_ppl": -1.3732969761836622, "ppl/zlib": 0.0010674236158178991, "Min_5.0% Prob": 3.3670747756958006, "Min_10.0% Prob": 2.186915558576584, "Min_20.0% Prob": 1.2628533661365509, "Min_30.0% Prob": 0.8483692136150404, "Min_40.0% Prob": 0.642693739004985, "Min_50.0% Prob": 0.511551045486247, "Min_60.0% Prob": 0.4280287513221217}}
{"hexsha": "13a95c5a4baf8cfcab37776de31ce155fd66c37a", "ext": "java", "lang": "Java", "content": "public class HTree<T> {\n    private final HNode<T> root;\n\n    public HTree() {\n        root = new HNode<>(HPath.empty());\n    }\n\n    /**\n     * Add {@code value} by {@code path} to the tree.\n     *\n     * @param path  the path\n     * @param value the value\n     * @return previously added {@code value} or {@code null} otherwise\n     */\n    @Nullable\n    public T put(HPath path, T value) {\n        HNode<T> current = root;\n        HPath.TagIterator iterator = path.it();\n        while (iterator.hasNext()) {\n            TinyString next = iterator.next();\n            HNode<T> parent = current;\n            HPath base = parent.path;\n            HNode<T> child = parent.children.computeIfAbsent(next, (tag) -> new HNode<T>(parent, HPath.combine(base, tag)));\n            current = child;\n        }\n        T previousValue = current.value;\n        current.value = value;\n        return previousValue;\n    }\n\n    /**\n     * {@link Navigator} navigates to parent or child nodes. Starts from the root of tree.\n     *\n     * @return navigator\n     */\n    public Navigator navigator() {\n        return new Navigator();\n    }\n\n    /**\n     * {@link Navigator} navigates to parent or child nodes. Starts from the root of tree.\n     */\n    public class Navigator {\n        private HNode<T> current = HTree.this.root;\n\n        /**\n         * Returns the value is stored in the current node.\n         *\n         * @return the value is stored in the current node, or {@code null} otherwise\n         */\n        @Nullable\n        public T getValue() {\n            return current.value;\n        }\n\n        /**\n         * Navigates to the child node.\n         *\n         * @param tag the child node tag\n         * @return {@code true} if the child node exists, otherwise {@code false}\n         */\n        public boolean navigateToChild(TinyString tag) {\n            HNode<T> child = current.children.get(tag);\n            if (child == null) {\n                return false;\n            }\n            current = child;\n            return true;\n        }\n\n        /**\n         * Navigates to the parent node.\n         * <p>\n         * Do nothing if the current is the root itself.\n         */\n        public void navigateToParent() {\n            current = current.parent;\n        }\n\n        /**\n         * Returns {@code true} if the current node has child nodes.\n         *\n         * @return {@code true} if the current node has child nodes, otherwise {@code false}\n         */\n        public boolean hasChildren() {\n            return !current.children.isEmpty();\n        }\n\n        public boolean hasValue() {\n            return current.value != null;\n        }\n\n        /**\n         * Returns {@code true} if the current node is the root.\n         *\n         * @return {@code true} if the current node is the root, otherwise {@code false}\n         */\n        public boolean isRoot() {\n            return current == HTree.this.root;\n        }\n\n        /**\n         * Returns path to the current node.\n         *\n         * @return path of the current node\n         */\n        public HPath path() {\n            return current.path;\n        }\n\n        /**\n         * Return the set of child nodes tags.\n         * <p>\n         * This set is a view. It means that changes in the {@link HTree} are also applied to the set.\n         *\n         * @return the set of child nodes tags\n         */\n        public Set<TinyString> children() {\n            return current.children.keySet();\n        }\n    }\n\n    private static class HNode<T> {\n        final Map<TinyString, HNode<T>> children = new LinkedHashMap<>();\n        final HNode<T> parent;\n        final HPath path;\n        T value;\n\n        private HNode(@NotNull HPath path) {\n            this.parent = this;\n            this.path = path;\n        }\n\n        private HNode(@NotNull HNode<T> parent, @NotNull HPath path) {\n            this.path = path;\n            this.parent = parent;\n        }\n    }\n}", "item_id": 0, "repo": "InHavk/hercules", "file": "hercules-protocol/src/main/java/ru/kontur/vostok/hercules/protocol/hpath/HTree.java", "last_update_at": "2022-02-14T06:01:07+00:00", "question_id": "13a95c5a4baf8cfcab37776de31ce155fd66c37a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HTree<T> {\n    private final HNode<T> root;\n    public HTree() {\n        root = new HNode<>(HPath.empty());\n    }\n    /**\n     * Add {@code value} by {@code path} to the tree.\n     *\n     * @param path  the path\n     * @param value the value\n     * @return previously added {@code value} or {@code null} otherwise\n     */\n    @Nullable\n    public T put(HPath path, T value) {\n        HNode<T> current = root;\n        HPath.TagIterator iterator = path.it();\n        while (iterator.hasNext()) {\n            TinyString next = iterator.next();\n            HNode<T> parent = current;\n            HPath base = parent.path;\n            HNode<T> child = parent.children.computeIfAbsent(next, (tag) -> new HNode<T>(parent, HPath.combine(base, tag)));\n            current = child;\n        }\n        T previousValue = current.value;\n        current.value = value;\n        return previousValue;\n    }\n    /**\n     * {@link Navigator} navigates to parent or child nodes. Starts from the root of tree.\n     *\n     * @return navigator\n     */\n    public Navigator navigator() {\n        return new Navigator();\n    }\n    /**\n     * {@link Navigator} navigates to parent or child nodes. Starts from the root of tree.\n     */\n    public class Navigator {\n        private HNode<T> current = HTree.this.root;\n        /**\n         * Returns the value is stored in the current node.\n         *\n         * @return the value is stored in the current node, or {@code null} otherwise\n         */\n        @Nullable\n        public T getValue() {\n            return current.value;\n        }\n        /**\n         * Navigates to the child node.\n         *\n         * @param tag the child node tag\n         * @return {@code true} if the child node exists, otherwise {@code false}\n         */\n        public boolean navigateToChild(TinyString tag) {\n            HNode<T> child = current.children.get(tag);\n            if (child == null) {\n                return false;\n            }\n            current = child;\n            return true;\n        }\n        /**\n         * Navigates to the parent node.\n         * <p>\n         * Do nothing if the current is the root itself.\n         */\n        public void navigateToParent() {\n            current = current.parent;\n        }\n        /**\n         * Returns {@code true} if the current node has child nodes.\n         *\n         * @return {@code true} if the current node has child nodes, otherwise {@code false}\n         */\n        public boolean hasChildren() {\n            return !current.children.isEmpty();\n        }\n        public boolean hasValue() {\n            return current.value != null;\n        }\n        /**\n         * Returns {@code true} if the current node is the root.\n         *\n         * @return {@code true} if the current node is the root, otherwise {@code false}\n         */\n        public boolean isRoot() {\n            return current == HTree.this.root;\n        }\n        /**\n         * Returns path to the current node.\n         *\n         * @return path of the current node\n         */\n        public HPath path() {\n            return current.path;\n        }\n        /**\n         * Return the set of child nodes tags.\n         * <p>\n         * This set is a view. It means that changes in the {@link HTree} are also applied to the set.\n         *\n         * @return the set of child nodes tags\n         */\n        public Set<TinyString> children() {\n            return current.children.keySet();\n        }\n    }\n    private static class HNode<T> {\n        final Map<TinyString, HNode<T>> children = new LinkedHashMap<>();\n        final HNode<T> parent;\n        final HPath path;\n        T value;\n        private HNode(@NotNull HPath path) {\n            this.parent = this;\n            this.path = path;\n        }\n        private HNode(@NotNull HNode<T> parent, @NotNull HPath path) {\n            this.path = path;\n            this.parent = parent;\n        }\n    }\n"]], "pred": {"ppl": 1.6772947311401367, "ppl_lower": 1.7989439964294434, "ppl/lowercase_ppl": -1.135382860101919, "ppl/zlib": 0.0005125690945877625, "Min_5.0% Prob": 5.435635211420994, "Min_10.0% Prob": 3.8574088695002535, "Min_20.0% Prob": 2.390575947422607, "Min_30.0% Prob": 1.6906618735953873, "Min_40.0% Prob": 1.2840437381403078, "Min_50.0% Prob": 1.0329315754167605, "Min_60.0% Prob": 0.8625093440792628}}
{"hexsha": "712595250bef07f4676f2d0c370b36502bfb16b8", "ext": "java", "lang": "Java", "content": "public class CervejaEntityListener {\n\t\n\t@Autowired\n\tprivate FotoStorage fotoStorage;\n\t\n\t@PostLoad\n\tpublic void postLoad(final Cerveja cerveja) {\n\t\tSpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this);\n\t\t\n\t\tcerveja.setUrlFoto(fotoStorage.getUrl(cerveja.getFotoOuMock()));\n\t\tcerveja.setUrlThumbnailFoto(fotoStorage.getUrl(FotoStorage.THUMBNAIL_PREFIX + cerveja.getFotoOuMock()));\n\t\t\n\t}\n\n}", "item_id": 0, "repo": "marcelofilipov/brewer-all", "file": "brewer-web/src/main/java/com/thefilipov/brewer/repository/listener/CervejaEntityListener.java", "last_update_at": "2022-01-04T16:35:58+00:00", "question_id": "712595250bef07f4676f2d0c370b36502bfb16b8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CervejaEntityListener {\n\t\n\t@Autowired\n\tprivate FotoStorage fotoStorage;\n\t\n\t@PostLoad\n\tpublic void postLoad(final Cerveja cerveja) {\n\t\tSpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this);\n\t\t\n\t\tcerveja.setUrlFoto(fotoStorage.getUrl(cerveja.getFotoOuMock()));\n\t\tcerveja.setUrlThumbnailFoto(fotoStorage.getUrl(FotoStorage.THUMBNAIL_PREFIX + cerveja.getFotoOuMock()));\n\t\t\n\t}\n"]], "pred": {"ppl": 2.4025630950927734, "ppl_lower": 4.105794906616211, "ppl/lowercase_ppl": -1.6113418823792298, "ppl/zlib": 0.0035631549747273403, "Min_5.0% Prob": 9.129767349788121, "Min_10.0% Prob": 6.469527228673299, "Min_20.0% Prob": 3.9474346656953134, "Min_30.0% Prob": 2.850575174326482, "Min_40.0% Prob": 2.1745629918671425, "Min_50.0% Prob": 1.7593080479313026, "Min_60.0% Prob": 1.4591892352828415}}
{"hexsha": "d9e53affc9f2a0161650f064ee8e04c7926595c6", "ext": "java", "lang": "Java", "content": "@WebServlet(\"/nest-backend/CsDetail.do\")\npublic class CsDetailServlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\n//\tprivate SimpleDateFormat sFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n//\tprivate CsDetailService csDetailService;\n//\t@Override\n//\tpublic void init() throws ServletException {\n//\t\tcsDetailService = new CsDetailService();\n//\t}\n\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n\n\t\tdoPost(req, res);\n\n\t}\n\n\t@Override\n\tprotected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n\n\t\treq.setCharacterEncoding(\"UTF-8\");\n//\t\tres.setContentType(\"text/html; charset=UTF-8\");\n\t\tString action = req.getParameter(\"action\");\n\n\t\t\n\t\t// fendshop_mainpage\u9078\u53d6\u76ee\u524dbusid\uff0c\u8f49\u8df3\u5230fendcs_reply\u9801\n\t\tif (\"from_shopmain_to_CsReply_with_Busid\".equals(action)) {\n\n\t\t\tList<String> errorMsgs = new LinkedList<String>();\n\t\t\t// Store this set in the request scope, in case we need to\n\t\t\t// send the ErrorPage view.\n\t\t\treq.setAttribute(\"errorMsgs\", errorMsgs);\n\n\t\t\ttry {\n\t\t\t\t/*************************** 1.\u63a5\u6536\u8acb\u6c42\u53c3\u6578 ****************************************/\n\t\t\t\tInteger busid = Integer.parseInt(req.getParameter(\"busid\"));\n\t\t\t\t//= new Integer(req.getParameter(\"caseid\"));\n\n\t\t\t\t/*************************** 2.\u958b\u59cb\u67e5\u8a62\u8cc7\u6599 ****************************************/\n\t\t\t\tBusService busSvc = new BusService();\n\t\t\t\tBusVO busVO = busSvc.select(busid);\n\n\t\t\t\t/*************************** 3.\u67e5\u8a62\u5b8c\u6210,\u6e96\u5099\u8f49\u4ea4(Send the Success view) ************/\n\t\t\t\treq.setAttribute(\"busVO_from_ShopMainpage\", busVO); // \u8cc7\u6599\u5eab\u53d6\u51fa\u7684busVO\u7269\u4ef6,\u5b58\u5165req\n\t\t\t\tString url = \"/nest-frontend/fendcs_reply.jsp\";\n\t\t\t\tRequestDispatcher successView = req.getRequestDispatcher(url);// \u6210\u529f\u8f49\u4ea4 update_emp_input.jsp\n\t\t\t\tsuccessView.forward(req, res);\n\n\t\t\t\t/*************************** \u5176\u4ed6\u53ef\u80fd\u7684\u932f\u8aa4\u8655\u7406 **********************************/\n\t\t\t} catch (Exception e) {\n\t\t\t\terrorMsgs.add(\"\u7121\u6cd5\u53d6\u5f97\u8981\u4fee\u6539\u7684\u8cc7\u6599:\" + e.getMessage());\n\t\t\t\tRequestDispatcher failureView = req.getRequestDispatcher(\"/nest-frontend/fendshop_mainpage.jsp\");\n\t\t\t\tfailureView.forward(req, res);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// fendshop_mainpage\u9078\u53d6\u76ee\u524dbusid\uff0c\u8f49\u8df3\u5230fendcs_reply\u9801\n\t\tif (\"from_Order_to_CsReply\".equals(action)) {\n\n\t\t\tList<String> errorMsgs = new LinkedList<String>();\n\t\t\t// Store this set in the request scope, in case we need to\n\t\t\t// send the ErrorPage view.\n\t\t\treq.setAttribute(\"errorMsgs\", errorMsgs);\n\n\t\t\ttry {\n\t\t\t\t/*************************** 1.\u63a5\u6536\u8acb\u6c42\u53c3\u6578 ****************************************/\n\t\t\t\tInteger busid = Integer.parseInt(req.getParameter(\"busid\"));\n\t\t\t\t//= new Integer(req.getParameter(\"caseid\"));\n\n\t\t\t\t/*************************** 2.\u958b\u59cb\u67e5\u8a62\u8cc7\u6599 ****************************************/\n\t\t\t\tBusService busSvc = new BusService();\n\t\t\t\tBusVO busVO = busSvc.select(busid);\n\n\t\t\t\t/*************************** 3.\u67e5\u8a62\u5b8c\u6210,\u6e96\u5099\u8f49\u4ea4(Send the Success view) ************/\n\t\t\t\treq.setAttribute(\"busVO_from_ShopMainpage\", busVO); // \u8cc7\u6599\u5eab\u53d6\u51fa\u7684busVO\u7269\u4ef6,\u5b58\u5165req\n\t\t\t\tString url = \"/nest-frontend/fendcs_reply.jsp\";\n\t\t\t\tRequestDispatcher successView = req.getRequestDispatcher(url);// \u6210\u529f\u8f49\u4ea4 update_emp_input.jsp\n\t\t\t\tsuccessView.forward(req, res);\n\n\t\t\t\t/*************************** \u5176\u4ed6\u53ef\u80fd\u7684\u932f\u8aa4\u8655\u7406 **********************************/\n\t\t\t} catch (Exception e) {\n\t\t\t\terrorMsgs.add(\"\u7121\u6cd5\u53d6\u5f97\u8981\u4fee\u6539\u7684\u8cc7\u6599:\" + e.getMessage());\n\t\t\t\tRequestDispatcher failureView = req.getRequestDispatcher(\"/nest-frontend/fendshop_mainpage.jsp\");\n\t\t\t\tfailureView.forward(req, res);\n\t\t\t}\n\t\t}\n\t\t\n//\t\t// \u806f\u7e6b\u5ba2\u670d (\u5f85\u6e2c\u8a66)\n//\t\tif (\"contact_Ord_Detail\".equals(action)) { // \u4f86\u81eaorderDetail\u7684\u8acb\u6c42\n//\n//\t\t\tList<String> errorMsgs = new LinkedList<String>();\n//\t\t\t// Store this set in the request scope, in case we need to send the ErrorPage\n//\t\t\t// view.\n//\t\t\treq.setAttribute(\"errorMsgs\", errorMsgs);\n//\n//\t\t\ttry {\n//\t\t\t\t// \u63a5\u6536\u8acb\u6c42\u53c3\u6578\n//\t\t\t\t// \u53d6\u5f97\u8a02\u55aeid\n//\t\t\t\tInteger orderId = new Integer(req.getParameter(\"orderId\"));\n//\t\t\t\t// \u958b\u59cb\u67e5\u8a62\u8cc7\u6599\n//\t\t\t\tOrderService orderSvc = new OrderService();\n//\t\t\t\tOrderVO orderVO = orderSvc.getOneByOrderId(orderId);\n//\t\t\t\t// \u67e5\u8a62\u5b8c\u6210\uff0c\u6e96\u5099\u8f49\u4ea4\n//\t\t\t\treq.setAttribute(\"orderVO\", orderVO); // \u8cc7\u6599\u5eab\u53d6\u51faorderVO\u7269\u4ef6,\u5b58\u5165req\n//\t\t\t\tString url = \"fendcs_reply.jsp\";\n//\t\t\t\tRequestDispatcher successView = req.getRequestDispatcher(url);// \u6210\u529f\u8f49\u4ea4\u9801\u9762\n//\t\t\t\tsuccessView.forward(req, res);\n//\n//\t\t\t\t// \u5176\u4ed6\u932f\u8aa4\u8655\u7406\n//\t\t\t} catch (Exception e) {\n//\t\t\t\terrorMsgs.add(\"\u7121\u6cd5\u53d6\u5f97\u8981\u4fee\u6539\u7684\u8cc7\u6599:\" + e.getMessage());\n//\t\t\t\tRequestDispatcher failureView = req.getRequestDispatcher(\"accountCenter.jsp\");\n//\t\t\t\tfailureView.forward(req, res);\n//\t\t\t}\n//\t\t}\n\n\n\t}\n\n}", "item_id": 0, "repo": "ruejot/jeegit-TFA105G3", "file": "src/main/java/com/csdetail/controller/CsDetailServlet.java", "last_update_at": "2022-03-01T06:40:41+00:00", "question_id": "d9e53affc9f2a0161650f064ee8e04c7926595c6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@WebServlet(\"/nest-backend/CsDetail.do\")\npublic class CsDetailServlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n//\tprivate SimpleDateFormat sFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n//\tprivate CsDetailService csDetailService;\n//\t@Override\n//\tpublic void init() throws ServletException {\n//\t\tcsDetailService = new CsDetailService();\n//\t}\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n\t\tdoPost(req, res);\n\t}\n\t@Override\n\tprotected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n\t\treq.setCharacterEncoding(\"UTF-8\");\n//\t\tres.setContentType(\"text/html; charset=UTF-8\");\n\t\tString action = req.getParameter(\"action\");\n\t\t\n\t\t// fendshop_mainpage\u9078\u53d6\u76ee\u524dbusid\uff0c\u8f49\u8df3\u5230fendcs_reply\u9801\n\t\tif (\"from_shopmain_to_CsReply_with_Busid\".equals(action)) {\n\t\t\tList<String> errorMsgs = new LinkedList<String>();\n\t\t\t// Store this set in the request scope, in case we need to\n\t\t\t// send the ErrorPage view.\n\t\t\treq.setAttribute(\"errorMsgs\", errorMsgs);\n\t\t\ttry {\n\t\t\t\t/*************************** 1.\u63a5\u6536\u8acb\u6c42\u53c3\u6578 ****************************************/\n\t\t\t\tInteger busid = Integer.parseInt(req.getParameter(\"busid\"));\n\t\t\t\t//= new Integer(req.getParameter(\"caseid\"));\n\t\t\t\t/*************************** 2.\u958b\u59cb\u67e5\u8a62\u8cc7\u6599 ****************************************/\n\t\t\t\tBusService busSvc = new BusService();\n\t\t\t\tBusVO busVO = busSvc.select(busid);\n\t\t\t\t/*************************** 3.\u67e5\u8a62\u5b8c\u6210,\u6e96\u5099\u8f49\u4ea4(Send the Success view) ************/\n\t\t\t\treq.setAttribute(\"busVO_from_ShopMainpage\", busVO); // \u8cc7\u6599\u5eab\u53d6\u51fa\u7684busVO\u7269\u4ef6,\u5b58\u5165req\n\t\t\t\tString url = \"/nest-frontend/fendcs_reply.jsp\";\n\t\t\t\tRequestDispatcher successView = req.getRequestDispatcher(url);// \u6210\u529f\u8f49\u4ea4 update_emp_input.jsp\n\t\t\t\tsuccessView.forward(req, res);\n\t\t\t\t/*************************** \u5176\u4ed6\u53ef\u80fd\u7684\u932f\u8aa4\u8655\u7406 **********************************/\n\t\t\t} catch (Exception e) {\n\t\t\t\terrorMsgs.add(\"\u7121\u6cd5\u53d6\u5f97\u8981\u4fee\u6539\u7684\u8cc7\u6599:\" + e.getMessage());\n\t\t\t\tRequestDispatcher failureView = req.getRequestDispatcher(\"/nest-frontend/fendshop_mainpage.jsp\");\n\t\t\t\tfailureView.forward(req, res);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// fendshop_mainpage\u9078\u53d6\u76ee\u524dbusid\uff0c\u8f49\u8df3\u5230fendcs_reply\u9801\n\t\tif (\"from_Order_to_CsReply\".equals(action)) {\n\t\t\tList<String> errorMsgs = new LinkedList<String>();\n\t\t\t// Store this set in the request scope, in case we need to\n\t\t\t// send the ErrorPage view.\n\t\t\treq.setAttribute(\"errorMsgs\", errorMsgs);\n\t\t\ttry {\n\t\t\t\t/*************************** 1.\u63a5\u6536\u8acb\u6c42\u53c3\u6578 ****************************************/\n\t\t\t\tInteger busid = Integer.parseInt(req.getParameter(\"busid\"));\n\t\t\t\t//= new Integer(req.getParameter(\"caseid\"));\n\t\t\t\t/*************************** 2.\u958b\u59cb\u67e5\u8a62\u8cc7\u6599 ****************************************/\n\t\t\t\tBusService busSvc = new BusService();\n\t\t\t\tBusVO busVO = busSvc.select(busid);\n\t\t\t\t/*************************** 3.\u67e5\u8a62\u5b8c\u6210,\u6e96\u5099\u8f49\u4ea4(Send the Success view) ************/\n\t\t\t\treq.setAttribute(\"busVO_from_ShopMainpage\", busVO); // \u8cc7\u6599\u5eab\u53d6\u51fa\u7684busVO\u7269\u4ef6,\u5b58\u5165req\n\t\t\t\tString url = \"/nest-frontend/fendcs_reply.jsp\";\n\t\t\t\tRequestDispatcher successView = req.getRequestDispatcher(url);// \u6210\u529f\u8f49\u4ea4 update_emp_input.jsp\n\t\t\t\tsuccessView.forward(req, res);\n\t\t\t\t/*************************** \u5176\u4ed6\u53ef\u80fd\u7684\u932f\u8aa4\u8655\u7406 **********************************/\n\t\t\t} catch (Exception e) {\n\t\t\t\terrorMsgs.add(\"\u7121\u6cd5\u53d6\u5f97\u8981\u4fee\u6539\u7684\u8cc7\u6599:\" + e.getMessage());\n\t\t\t\tRequestDispatcher failureView = req.getRequestDispatcher(\"/nest-frontend/fendshop_mainpage.jsp\");\n\t\t\t\tfailureView.forward(req, res);\n\t\t\t}\n\t\t}\n\t\t\n//\t\t// \u806f\u7e6b\u5ba2\u670d (\u5f85\u6e2c\u8a66)\n//\t\tif (\"contact_Ord_Detail\".equals(action)) { // \u4f86\u81eaorderDetail\u7684\u8acb\u6c42\n//\n//\t\t\tList<String> errorMsgs = new LinkedList<String>();\n//\t\t\t// Store this set in the request scope, in case we need to send the ErrorPage\n//\t\t\t// view.\n//\t\t\treq.setAttribute(\"errorMsgs\", errorMsgs);\n//\n//\t\t\ttry {\n//\t\t\t\t// \u63a5\u6536\u8acb\u6c42\u53c3\u6578\n//\t\t\t\t// \u53d6\u5f97\u8a02\u55aeid\n//\t\t\t\tInteger orderId = new Integer(req.getParameter(\"orderId\"));\n//\t\t\t\t// \u958b\u59cb\u67e5\u8a62\u8cc7\u6599\n//\t\t\t\tOrderService orderSvc = new OrderService();\n//\t\t\t\tOrderVO orderVO = orderSvc.getOneByOrderId(orderId);\n//\t\t\t\t// \u67e5\u8a62\u5b8c\u6210\uff0c\u6e96\u5099\u8f49\u4ea4\n//\t\t\t\treq.setAttribute(\"orderVO\", orderVO); // \u8cc7\u6599\u5eab\u53d6\u51faorderVO\u7269\u4ef6,\u5b58\u5165req\n//\t\t\t\tString url = \"fendcs_reply.jsp\";\n//\t\t\t\tRequestDispatcher successView = req.getRequestDispatcher(url);// \u6210\u529f\u8f49\u4ea4\u9801\u9762\n//\t\t\t\tsuccessView.forward(req, res);\n//\n//\t\t\t\t// \u5176\u4ed6\u932f\u8aa4\u8655\u7406\n//\t\t\t} catch (Exception e) {\n//\t\t\t\terrorMsgs.add(\"\u7121\u6cd5\u53d6\u5f97\u8981\u4fee\u6539\u7684\u8cc7\u6599:\" + e.getMessage());\n//\t\t\t\tRequestDispatcher failureView = req.getRequestDispatcher(\"accountCenter.jsp\");\n//\t\t\t\tfailureView.forward(req, res);\n//\t\t\t}\n//\t\t}\n\t}\n"]], "pred": {"ppl": 1.6662769317626953, "ppl_lower": 1.9802368879318237, "ppl/lowercase_ppl": -1.3380875632810982, "ppl/zlib": 0.0003844817435832468, "Min_5.0% Prob": 6.518212818631939, "Min_10.0% Prob": 4.3720416987643524, "Min_20.0% Prob": 2.4783009213998035, "Min_30.0% Prob": 1.6918799089864383, "Min_40.0% Prob": 1.2738953955029764, "Min_50.0% Prob": 1.021474343174139, "Min_60.0% Prob": 0.8519389776332186}}
{"hexsha": "64541162fbc9654d7ff25e39af33e8fde41fc476", "ext": "java", "lang": "Java", "content": "class CassandraBuilderTests {\n\n\tprivate final CassandraBuilder builder = new CassandraBuilder();\n\n\t@Test\n\tvoid invalidName() {\n\t\tassertThatThrownBy(() -> this.builder.name(\"\")).hasStackTraceContaining(\"Name must not be empty\");\n\t}\n\n\t@Test\n\tvoid generatedName() {\n\t\tCassandra c1 = this.builder.build();\n\t\tCassandra c2 = this.builder.build();\n\t\tassertThat(c1.getName()).isNotEqualTo(c2.getName());\n\t}\n\n\t@Test\n\tvoid name() {\n\t\tCassandraBuilder cassandra = this.builder.name(\"cassandra\");\n\t\tassertThat(cassandra).hasFieldOrPropertyWithValue(\"name\", \"cassandra\");\n\t\tassertThat(this.builder.getName()).isEqualTo(\"cassandra\");\n\t}\n\n\t@Test\n\tvoid version() {\n\t\tassertThat(this.builder.getVersion()).isEqualTo(CassandraBuilder.DEFAULT_VERSION);\n\t\tCassandra cassandra = this.builder.version(\"3.11.11\").build();\n\t\tassertThat(cassandra).hasFieldOrPropertyWithValue(\"version\", Version.parse(\"3.11.11\"));\n\t\tassertThat(this.builder.getVersion()).isEqualTo(Version.parse(\"3.11.11\"));\n\t}\n\n\t@Test\n\tvoid registerShutdownHook() {\n\t\tCassandra cassandra = this.builder.registerShutdownHook(false).build();\n\t\tassertThat(cassandra).hasFieldOrPropertyWithValue(\"registerShutdownHook\", false);\n\t}\n\n\t@Test\n\tvoid startupTimeout() {\n\t\tCassandra cassandra = this.builder.startupTimeout(Duration.ofMinutes(1)).build();\n\t\tassertThat(cassandra).hasFieldOrPropertyWithValue(\"startupTimeout\", Duration.ofMinutes(1));\n\t}\n\n\t@Test\n\tvoid startupNegative() {\n\t\tassertThatThrownBy(() -> this.builder.startupTimeout(Duration.ofMinutes(-1)))\n\t\t\t\t.hasStackTraceContaining(\"Startup Timeout must be positive\");\n\t}\n\n\t@Test\n\tvoid startupZero() {\n\t\tassertThatThrownBy(() -> this.builder.startupTimeout(Duration.ofMinutes(-1)))\n\t\t\t\t.hasStackTraceContaining(\"Startup Timeout must be positive\");\n\t}\n\n\t@Test\n\tvoid workingDirectory(@TempDir Path workingDirectory) {\n\t\tCassandra cassandra = this.builder.workingDirectory(() -> workingDirectory).build();\n\t\tassertThat(cassandra).hasFieldOrPropertyWithValue(\"workingDirectory\", workingDirectory);\n\t}\n\n\t@Test\n\tvoid invalidWorkingDirectory() {\n\t\tassertThatThrownBy(() -> this.builder.workingDirectory(() -> {\n\t\t\tthrow new IOException(\"\");\n\t\t}).build()).hasStackTraceContaining(\"Unable to get a working directory\");\n\t}\n\n\t@Test\n\tvoid workingDirectoryInitializer() {\n\t\tWorkingDirectoryInitializer workingDirectoryInitializer = (workingDirectory, version) -> {\n\t\t};\n\t\tCassandra cassandra = this.builder.workingDirectoryInitializer(workingDirectoryInitializer).build();\n\t\tassertThat(cassandra).hasFieldOrPropertyWithValue(\"workingDirectoryInitializer\", workingDirectoryInitializer);\n\t}\n\n\t@Test\n\tvoid workingDirectoryDestroyer() {\n\t\tWorkingDirectoryDestroyer workingDirectoryDestroyer = (workingDirectory, version) -> {\n\t\t};\n\t\tCassandra cassandra = this.builder.workingDirectoryDestroyer(workingDirectoryDestroyer).build();\n\t\tassertThat(cassandra).hasFieldOrPropertyWithValue(\"workingDirectoryDestroyer\", workingDirectoryDestroyer);\n\t}\n\n\t@Test\n\tvoid workingDirectoryCustomizers() {\n\t\tWorkingDirectoryCustomizer w1 = WorkingDirectoryCustomizer\n\t\t\t\t.addResource(new ClassPathResource(\"text.txt\"), \"conf/text.txt\");\n\t\tWorkingDirectoryCustomizer w2 = WorkingDirectoryCustomizer\n\t\t\t\t.addResource(new ClassPathResource(\"empty.txt\"), \"conf/empty.txt\");\n\t\tassertThat(this.builder.workingDirectoryCustomizers(w1).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"workingDirectoryCustomizers\", Collections.singleton(w1));\n\t\tassertThat(this.builder.workingDirectoryCustomizers(w2).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"workingDirectoryCustomizers\", Collections.singleton(w2));\n\t\tassertThat(this.builder.addWorkingDirectoryCustomizers(w1).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"workingDirectoryCustomizers\", new LinkedHashSet<>(Arrays.asList(w2, w1)));\n\n\t}\n\n\t@Test\n\tvoid logger() {\n\t\tLogger logger = Logger.get(\"TEST\");\n\t\tassertThat(this.builder.logger(logger).build()).hasFieldOrPropertyWithValue(\"logger\", logger);\n\t}\n\n\t@Test\n\tvoid environmentVariables() {\n\t\tPath javaHome = Paths.get(System.getProperty(\"java.home\"));\n\t\tassertThat(this.builder.addEnvironmentVariable(\"JAVA_HOME\", javaHome).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.environmentVariables\",\n\t\t\t\t\t\tmapOf(\"JAVA_HOME\", javaHome));\n\t\tassertThat(this.builder.addEnvironmentVariables(mapOf(\"EXTRA_CLASSPATH\", \"lib.jar\")).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.environmentVariables\",\n\t\t\t\t\t\tmapOf(\"JAVA_HOME\", javaHome, \"EXTRA_CLASSPATH\", \"lib.jar\"));\n\t\tassertThat(this.builder.environmentVariables(mapOf(\"EXTRA_CLASSPATH\", \"lib.jar\")).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.environmentVariables\",\n\t\t\t\t\t\tmapOf(\"EXTRA_CLASSPATH\", \"lib.jar\"));\n\t}\n\n\t@Test\n\tvoid systemProperties() {\n\t\tClassPathResource resource = new ClassPathResource(\"test.txt\");\n\t\tassertThat(this.builder.addSystemProperty(\"cassandra.rpc_port\", 9160).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.systemProperties\", mapOf(\"cassandra.rpc_port\", 9160));\n\t\tassertThat(this.builder.addSystemProperties(mapOf(\"cassandra.config\", resource)).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.systemProperties\",\n\t\t\t\t\t\tmapOf(\"cassandra.rpc_port\", 9160, \"cassandra.config\", resource));\n\t\tassertThat(this.builder.systemProperties(mapOf(\"cassandra.config\", resource))\n\t\t\t\t.build()).hasFieldOrPropertyWithValue(\"databaseFactory.systemProperties\",\n\t\t\t\tmapOf(\"cassandra.config\", resource));\n\t}\n\n\t@Test\n\tvoid configurationFile() {\n\t\tClassPathResource resource = new ClassPathResource(\"test.txt\");\n\t\tassertThat(this.builder.configFile(resource).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.systemProperties\",\n\t\t\t\t\t\tmapOf(\"cassandra.config\", resource));\n\t}\n\n\t@Test\n\tvoid jvmOptions() {\n\t\tassertThat(this.builder.jvmOptions(\"-Xmx512m\").build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.jvmOptions\",\n\t\t\t\t\t\tCollections.singleton(\"-Xmx512m\"));\n\n\t\tassertThat(this.builder.addJvmOptions(\"-Xmx1024m\").build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.jvmOptions\",\n\t\t\t\t\t\tnew LinkedHashSet<>(Arrays.asList(\"-Xmx512m\", \"-Xmx1024m\")));\n\n\t\tassertThat(this.builder.jvmOptions(\"-Xmx1024m\").build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.jvmOptions\",\n\t\t\t\t\t\tCollections.singleton(\"-Xmx1024m\"));\n\t}\n\n\t@Test\n\tvoid configProperties() {\n\t\tassertThat(this.builder.addConfigProperty(\"rpc_port\", 9160).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.configProperties\", mapOf(\"rpc_port\", 9160));\n\t\tassertThat(this.builder\n\t\t\t\t.addConfigProperties(mapOf(\"start_rpc\", true)).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.configProperties\",\n\t\t\t\t\t\tmapOf(\"rpc_port\", 9160, \"start_rpc\", true));\n\t\tassertThat(this.builder.configProperties(mapOf(\"start_rpc\", true)).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.configProperties\", mapOf(\"start_rpc\", true));\n\t}\n\n\t@Test\n\tvoid configPropertiesArrayType() {\n\t\tassertThat(this.builder.addConfigProperty(\"data_file_directories\", new String[]{\"./data/data\"}).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.configProperties\", mapOf(\"data_file_directories\",\n\t\t\t\t\t\tCollections.singletonList(\"./data/data\")));\n\t}\n\n\t@Test\n\tvoid configure() {\n\t\tthis.builder.configure(builder -> builder.name(\"super\"));\n\t\tassertThat(this.builder.build()).hasFieldOrPropertyWithValue(\"name\", \"super\");\n\t}\n\n\tprivate static <K, V> Map<K, V> mapOf(K k1, V v1) {\n\t\tMap<K, V> map = new LinkedHashMap<>();\n\t\tmap.put(k1, v1);\n\t\treturn map;\n\t}\n\n\tprivate static <K, V> Map<K, V> mapOf(K k1, V v1, K k2, V v2) {\n\t\tMap<K, V> map = new LinkedHashMap<>();\n\t\tmap.put(k1, v1);\n\t\tmap.put(k2, v2);\n\t\treturn map;\n\t}\n\n}", "item_id": 0, "repo": "eugenediatlov/embedded-cassandra", "file": "src/test/java/com/github/nosan/embedded/cassandra/CassandraBuilderTests.java", "last_update_at": "2022-03-17T02:09:57+00:00", "question_id": "64541162fbc9654d7ff25e39af33e8fde41fc476_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class CassandraBuilderTests {\n\tprivate final CassandraBuilder builder = new CassandraBuilder();\n\t@Test\n\tvoid invalidName() {\n\t\tassertThatThrownBy(() -> this.builder.name(\"\")).hasStackTraceContaining(\"Name must not be empty\");\n\t}\n\t@Test\n\tvoid generatedName() {\n\t\tCassandra c1 = this.builder.build();\n\t\tCassandra c2 = this.builder.build();\n\t\tassertThat(c1.getName()).isNotEqualTo(c2.getName());\n\t}\n\t@Test\n\tvoid name() {\n\t\tCassandraBuilder cassandra = this.builder.name(\"cassandra\");\n\t\tassertThat(cassandra).hasFieldOrPropertyWithValue(\"name\", \"cassandra\");\n\t\tassertThat(this.builder.getName()).isEqualTo(\"cassandra\");\n\t}\n\t@Test\n\tvoid version() {\n\t\tassertThat(this.builder.getVersion()).isEqualTo(CassandraBuilder.DEFAULT_VERSION);\n\t\tCassandra cassandra = this.builder.version(\"3.11.11\").build();\n\t\tassertThat(cassandra).hasFieldOrPropertyWithValue(\"version\", Version.parse(\"3.11.11\"));\n\t\tassertThat(this.builder.getVersion()).isEqualTo(Version.parse(\"3.11.11\"));\n\t}\n\t@Test\n\tvoid registerShutdownHook() {\n\t\tCassandra cassandra = this.builder.registerShutdownHook(false).build();\n\t\tassertThat(cassandra).hasFieldOrPropertyWithValue(\"registerShutdownHook\", false);\n\t}\n\t@Test\n\tvoid startupTimeout() {\n\t\tCassandra cassandra = this.builder.startupTimeout(Duration.ofMinutes(1)).build();\n\t\tassertThat(cassandra).hasFieldOrPropertyWithValue(\"startupTimeout\", Duration.ofMinutes(1));\n\t}\n\t@Test\n\tvoid startupNegative() {\n\t\tassertThatThrownBy(() -> this.builder.startupTimeout(Duration.ofMinutes(-1)))\n\t\t\t\t.hasStackTraceContaining(\"Startup Timeout must be positive\");\n\t}\n\t@Test\n\tvoid startupZero() {\n\t\tassertThatThrownBy(() -> this.builder.startupTimeout(Duration.ofMinutes(-1)))\n\t\t\t\t.hasStackTraceContaining(\"Startup Timeout must be positive\");\n\t}\n\t@Test\n\tvoid workingDirectory(@TempDir Path workingDirectory) {\n\t\tCassandra cassandra = this.builder.workingDirectory(() -> workingDirectory).build();\n\t\tassertThat(cassandra).hasFieldOrPropertyWithValue(\"workingDirectory\", workingDirectory);\n\t}\n\t@Test\n\tvoid invalidWorkingDirectory() {\n\t\tassertThatThrownBy(() -> this.builder.workingDirectory(() -> {\n\t\t\tthrow new IOException(\"\");\n\t\t}).build()).hasStackTraceContaining(\"Unable to get a working directory\");\n\t}\n\t@Test\n\tvoid workingDirectoryInitializer() {\n\t\tWorkingDirectoryInitializer workingDirectoryInitializer = (workingDirectory, version) -> {\n\t\t};\n\t\tCassandra cassandra = this.builder.workingDirectoryInitializer(workingDirectoryInitializer).build();\n\t\tassertThat(cassandra).hasFieldOrPropertyWithValue(\"workingDirectoryInitializer\", workingDirectoryInitializer);\n\t}\n\t@Test\n\tvoid workingDirectoryDestroyer() {\n\t\tWorkingDirectoryDestroyer workingDirectoryDestroyer = (workingDirectory, version) -> {\n\t\t};\n\t\tCassandra cassandra = this.builder.workingDirectoryDestroyer(workingDirectoryDestroyer).build();\n\t\tassertThat(cassandra).hasFieldOrPropertyWithValue(\"workingDirectoryDestroyer\", workingDirectoryDestroyer);\n\t}\n\t@Test\n\tvoid workingDirectoryCustomizers() {\n\t\tWorkingDirectoryCustomizer w1 = WorkingDirectoryCustomizer\n\t\t\t\t.addResource(new ClassPathResource(\"text.txt\"), \"conf/text.txt\");\n\t\tWorkingDirectoryCustomizer w2 = WorkingDirectoryCustomizer\n\t\t\t\t.addResource(new ClassPathResource(\"empty.txt\"), \"conf/empty.txt\");\n\t\tassertThat(this.builder.workingDirectoryCustomizers(w1).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"workingDirectoryCustomizers\", Collections.singleton(w1));\n\t\tassertThat(this.builder.workingDirectoryCustomizers(w2).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"workingDirectoryCustomizers\", Collections.singleton(w2));\n\t\tassertThat(this.builder.addWorkingDirectoryCustomizers(w1).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"workingDirectoryCustomizers\", new LinkedHashSet<>(Arrays.asList(w2, w1)));\n\t}\n\t@Test\n\tvoid logger() {\n\t\tLogger logger = Logger.get(\"TEST\");\n\t\tassertThat(this.builder.logger(logger).build()).hasFieldOrPropertyWithValue(\"logger\", logger);\n\t}\n\t@Test\n\tvoid environmentVariables() {\n\t\tPath javaHome = Paths.get(System.getProperty(\"java.home\"));\n\t\tassertThat(this.builder.addEnvironmentVariable(\"JAVA_HOME\", javaHome).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.environmentVariables\",\n\t\t\t\t\t\tmapOf(\"JAVA_HOME\", javaHome));\n\t\tassertThat(this.builder.addEnvironmentVariables(mapOf(\"EXTRA_CLASSPATH\", \"lib.jar\")).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.environmentVariables\",\n\t\t\t\t\t\tmapOf(\"JAVA_HOME\", javaHome, \"EXTRA_CLASSPATH\", \"lib.jar\"));\n\t\tassertThat(this.builder.environmentVariables(mapOf(\"EXTRA_CLASSPATH\", \"lib.jar\")).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.environmentVariables\",\n\t\t\t\t\t\tmapOf(\"EXTRA_CLASSPATH\", \"lib.jar\"));\n\t}\n\t@Test\n\tvoid systemProperties() {\n\t\tClassPathResource resource = new ClassPathResource(\"test.txt\");\n\t\tassertThat(this.builder.addSystemProperty(\"cassandra.rpc_port\", 9160).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.systemProperties\", mapOf(\"cassandra.rpc_port\", 9160));\n\t\tassertThat(this.builder.addSystemProperties(mapOf(\"cassandra.config\", resource)).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.systemProperties\",\n\t\t\t\t\t\tmapOf(\"cassandra.rpc_port\", 9160, \"cassandra.config\", resource));\n\t\tassertThat(this.builder.systemProperties(mapOf(\"cassandra.config\", resource))\n\t\t\t\t.build()).hasFieldOrPropertyWithValue(\"databaseFactory.systemProperties\",\n\t\t\t\tmapOf(\"cassandra.config\", resource));\n\t}\n\t@Test\n\tvoid configurationFile() {\n\t\tClassPathResource resource = new ClassPathResource(\"test.txt\");\n\t\tassertThat(this.builder.configFile(resource).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.systemProperties\",\n\t\t\t\t\t\tmapOf(\"cassandra.config\", resource));\n\t}\n\t@Test\n\tvoid jvmOptions() {\n\t\tassertThat(this.builder.jvmOptions(\"-Xmx512m\").build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.jvmOptions\",\n\t\t\t\t\t\tCollections.singleton(\"-Xmx512m\"));\n\t\tassertThat(this.builder.addJvmOptions(\"-Xmx1024m\").build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.jvmOptions\",\n\t\t\t\t\t\tnew LinkedHashSet<>(Arrays.asList(\"-Xmx512m\", \"-Xmx1024m\")));\n\t\tassertThat(this.builder.jvmOptions(\"-Xmx1024m\").build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.jvmOptions\",\n\t\t\t\t\t\tCollections.singleton(\"-Xmx1024m\"));\n\t}\n\t@Test\n\tvoid configProperties() {\n\t\tassertThat(this.builder.addConfigProperty(\"rpc_port\", 9160).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.configProperties\", mapOf(\"rpc_port\", 9160));\n\t\tassertThat(this.builder\n\t\t\t\t.addConfigProperties(mapOf(\"start_rpc\", true)).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.configProperties\",\n\t\t\t\t\t\tmapOf(\"rpc_port\", 9160, \"start_rpc\", true));\n\t\tassertThat(this.builder.configProperties(mapOf(\"start_rpc\", true)).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.configProperties\", mapOf(\"start_rpc\", true));\n\t}\n\t@Test\n\tvoid configPropertiesArrayType() {\n\t\tassertThat(this.builder.addConfigProperty(\"data_file_directories\", new String[]{\"./data/data\"}).build())\n\t\t\t\t.hasFieldOrPropertyWithValue(\"databaseFactory.configProperties\", mapOf(\"data_file_directories\",\n\t\t\t\t\t\tCollections.singletonList(\"./data/data\")));\n\t}\n\t@Test\n\tvoid configure() {\n\t\tthis.builder.configure(builder -> builder.name(\"super\"));\n\t\tassertThat(this.builder.build()).hasFieldOrPropertyWithValue(\"name\", \"super\");\n\t}\n\tprivate static <K, V> Map<K, V> mapOf(K k1, V v1) {\n\t\tMap<K, V> map = new LinkedHashMap<>();\n\t\tmap.put(k1, v1);\n\t\treturn map;\n\t}\n\tprivate static <K, V> Map<K, V> mapOf(K k1, V v1, K k2, V v2) {\n\t\tMap<K, V> map = new LinkedHashMap<>();\n\t\tmap.put(k1, v1);\n\t\tmap.put(k2, v2);\n\t\treturn map;\n\t}\n"]], "pred": {"ppl": 1.4850937128067017, "ppl_lower": 1.6083183288574219, "ppl/lowercase_ppl": -1.2015567622646304, "ppl/zlib": 0.0002771393668750423, "Min_5.0% Prob": 5.38648224811928, "Min_10.0% Prob": 3.5221555408309486, "Min_20.0% Prob": 1.9365466002594023, "Min_30.0% Prob": 1.3128955758304572, "Min_40.0% Prob": 0.9868205842450444, "Min_50.0% Prob": 0.7910932109179978, "Min_60.0% Prob": 0.6598362858909703}}
{"hexsha": "96bc17cd388491f2fadc1aef43f3e9b97f58150e", "ext": "java", "lang": "Java", "content": "class RequestInfoTest {\n    private static final String TENANT_NAME = \"vmware_gms\";\n    private static final String TENANT_URL = \"https://impl.workday.com\";\n    private static final String ROUTING_PREFIX = \"https://dev.hero.example.com/connectors/id/\";\n    private static final Locale LOCALE = Locale.ENGLISH;\n    private static final String BASE_URL = \"http://workday.com\";\n    private static final String CONNECTOR_AUTH = \"connectorAuth\";\n\n    @Test\n    void testCardsConfigGetters() {\n        RequestInfo requestInfo = RequestInfo.builder().tenantName(TENANT_NAME)\n                .tenantUrl(TENANT_URL)\n                .baseUrl(BASE_URL)\n                .routingPrefix(ROUTING_PREFIX)\n                .connectorAuth(CONNECTOR_AUTH)\n                .isPreHire(true)\n                .locale(LOCALE)\n                .build();\n        assertForGetters(requestInfo);\n    }\n\n    @Test\n    void testCardsConfigSetters() {\n        RequestInfo requestInfo = RequestInfo.builder().build();\n        requestInfo.setBaseUrl(BASE_URL);\n        requestInfo.setConnectorAuth(CONNECTOR_AUTH);\n        requestInfo.setRoutingPrefix(ROUTING_PREFIX);\n        requestInfo.setTenantName(TENANT_NAME);\n        requestInfo.setTenantUrl(TENANT_URL);\n        requestInfo.setPreHire(true);\n        requestInfo.setLocale(LOCALE);\n        assertForGetters(requestInfo);\n    }\n\n    private void assertForGetters(RequestInfo requestInfo) {\n        assertThat(requestInfo.getBaseUrl()).isEqualTo(BASE_URL);\n        assertThat(requestInfo.getRoutingPrefix()).isEqualTo(ROUTING_PREFIX);\n        assertThat(requestInfo.getConnectorAuth()).isEqualTo(CONNECTOR_AUTH);\n        assertThat(requestInfo.getTenantName()).isEqualTo(TENANT_NAME);\n        assertThat(requestInfo.getTenantUrl()).isEqualTo(TENANT_URL);\n        assertThat(requestInfo.isPreHire()).isTrue();\n        assertThat(requestInfo.getLocale()).isEqualTo(LOCALE);\n    }\n}", "item_id": 0, "repo": "vmware/connectors-workspace-one", "file": "hub-workday-connector/src/test/java/com/vmware/ws1connectors/workday/models/RequestInfoTest.java", "last_update_at": "2022-03-24T06:02:22+00:00", "question_id": "96bc17cd388491f2fadc1aef43f3e9b97f58150e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class RequestInfoTest {\n    private static final String TENANT_NAME = \"vmware_gms\";\n    private static final String TENANT_URL = \"https://impl.workday.com\";\n    private static final String ROUTING_PREFIX = \"https://dev.hero.example.com/connectors/id/\";\n    private static final Locale LOCALE = Locale.ENGLISH;\n    private static final String BASE_URL = \"http://workday.com\";\n    private static final String CONNECTOR_AUTH = \"connectorAuth\";\n    @Test\n    void testCardsConfigGetters() {\n        RequestInfo requestInfo = RequestInfo.builder().tenantName(TENANT_NAME)\n                .tenantUrl(TENANT_URL)\n                .baseUrl(BASE_URL)\n                .routingPrefix(ROUTING_PREFIX)\n                .connectorAuth(CONNECTOR_AUTH)\n                .isPreHire(true)\n                .locale(LOCALE)\n                .build();\n        assertForGetters(requestInfo);\n    }\n    @Test\n    void testCardsConfigSetters() {\n        RequestInfo requestInfo = RequestInfo.builder().build();\n        requestInfo.setBaseUrl(BASE_URL);\n        requestInfo.setConnectorAuth(CONNECTOR_AUTH);\n        requestInfo.setRoutingPrefix(ROUTING_PREFIX);\n        requestInfo.setTenantName(TENANT_NAME);\n        requestInfo.setTenantUrl(TENANT_URL);\n        requestInfo.setPreHire(true);\n        requestInfo.setLocale(LOCALE);\n        assertForGetters(requestInfo);\n    }\n    private void assertForGetters(RequestInfo requestInfo) {\n        assertThat(requestInfo.getBaseUrl()).isEqualTo(BASE_URL);\n        assertThat(requestInfo.getRoutingPrefix()).isEqualTo(ROUTING_PREFIX);\n        assertThat(requestInfo.getConnectorAuth()).isEqualTo(CONNECTOR_AUTH);\n        assertThat(requestInfo.getTenantName()).isEqualTo(TENANT_NAME);\n        assertThat(requestInfo.getTenantUrl()).isEqualTo(TENANT_URL);\n        assertThat(requestInfo.isPreHire()).isTrue();\n        assertThat(requestInfo.getLocale()).isEqualTo(LOCALE);\n    }\n"]], "pred": {"ppl": 1.7366721630096436, "ppl_lower": 2.125836133956909, "ppl/lowercase_ppl": -1.3663137483631644, "ppl/zlib": 0.0010973573200257463, "Min_5.0% Prob": 6.711491880745723, "Min_10.0% Prob": 4.614599396442545, "Min_20.0% Prob": 2.6786894482271424, "Min_30.0% Prob": 1.830680481682735, "Min_40.0% Prob": 1.3795301855565851, "Min_50.0% Prob": 1.105195613595625, "Min_60.0% Prob": 0.9213811916004112}}
{"hexsha": "597cb386f0507eb9d85e2dab18be5e4417796955", "ext": "java", "lang": "Java", "content": "public class MyHello {\n    public void hello() {\n        System.out.println(\"my hello\");\n    }\n\n    public static void main(String[] args) {\n        int num1 = 1;\n        int num2 = 130;\n        int num3 = num1 + num2;\n        int num4 = num2 - num1;\n        int num5 = num1 * num2;\n        int num6 = num2 / num1;\n\n        final int num7 = 5;\n        Integer num88 = 6;\n\n        if (num88 == 0) {\n            System.out.println(num1);\n        }\n\n        List<Integer> nums = new ArrayList<>();\n        nums.add(1);\n        nums.add(2);\n\n        for (int num : nums) {\n            System.out.println(num);\n        }\n\n        if (nums.size() == num2) {\n            System.out.println(num2);\n        }\n    }\n}", "item_id": 0, "repo": "yangjun823823/JAVA-000", "file": "Week_01/example/src/com/company/MyHello.java", "last_update_at": "2022-03-28T06:48:06+00:00", "question_id": "597cb386f0507eb9d85e2dab18be5e4417796955_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MyHello {\n    public void hello() {\n        System.out.println(\"my hello\");\n    }\n    public static void main(String[] args) {\n        int num1 = 1;\n        int num2 = 130;\n        int num3 = num1 + num2;\n        int num4 = num2 - num1;\n        int num5 = num1 * num2;\n        int num6 = num2 / num1;\n        final int num7 = 5;\n        Integer num88 = 6;\n        if (num88 == 0) {\n            System.out.println(num1);\n        }\n        List<Integer> nums = new ArrayList<>();\n        nums.add(1);\n        nums.add(2);\n        for (int num : nums) {\n            System.out.println(num);\n        }\n        if (nums.size() == num2) {\n            System.out.println(num2);\n        }\n    }\n"]], "pred": {"ppl": 2.036806344985962, "ppl_lower": 2.2574644088745117, "ppl/lowercase_ppl": -1.1445904206550885, "ppl/zlib": 0.0025774748695287543, "Min_5.0% Prob": 6.47398320833842, "Min_10.0% Prob": 4.708806077639262, "Min_20.0% Prob": 3.074790899850884, "Min_30.0% Prob": 2.2487490634395653, "Min_40.0% Prob": 1.7323313959094944, "Min_50.0% Prob": 1.4117039832301805, "Min_60.0% Prob": 1.179214896596208}}
{"hexsha": "869164de1c197bfc35626ca87d397d1eb869eeb6", "ext": "java", "lang": "Java", "content": "public class UploadUtils\n{\n\tprivate FileItem item;\n\tprivate String extension = \"\";\n\n\tpublic UploadUtils(FileItem item)\n\t{\n\t\tthis.item = item;\n\t}\n\n\tpublic String getExtension()\n\t{\n\t\tif (this.extension == null || this.extension.equals(\"\")) {\n\t\t\tthis.extension = this.item.getName().substring(this.item.getName().lastIndexOf('.') + 1);\n\t\t}\n\n\t\treturn this.extension;\n\t}\n\n\tpublic String getOriginalName() {\n\t\treturn item.getName();\n\t}\n\n\tpublic byte[] getBytes() {\n\t\treturn item.get();\n\t}\n\n\tpublic void saveUploadedFile(String filename) \n\t{\n\t\tBufferedInputStream inputStream = null;\n\t\tFileOutputStream outputStream = null;\n\n\t\ttry {\n\t\t\tinputStream = new BufferedInputStream(this.item.getInputStream());\n\t\t\toutputStream = new FileOutputStream(filename);\n\n\t\t\tint c;\n\t\t\tbyte[] b = new byte[4096];\n\t\t\twhile ((c = inputStream.read(b)) != -1) {\n\t\t\t\toutputStream.write(b, 0, c);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new ForumException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (outputStream != null) {\n\t\t\t\ttry {\n\t\t\t\t\toutputStream.flush();\n\t\t\t\t\toutputStream.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException e) { }\n\t\t\t}\n\n\t\t\tif (inputStream != null) {\n\t\t\t\ttry {\n\t\t\t\t\tinputStream.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException e) { }\n\t\t\t}\n\t\t}\n\t}\n}", "item_id": 0, "repo": "f450/jforum2", "file": "src/main/java/net/jforum/view/forum/common/UploadUtils.java", "last_update_at": "2022-02-16T00:57:11+00:00", "question_id": "869164de1c197bfc35626ca87d397d1eb869eeb6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UploadUtils\n{\n\tprivate FileItem item;\n\tprivate String extension = \"\";\n\tpublic UploadUtils(FileItem item)\n\t{\n\t\tthis.item = item;\n\t}\n\tpublic String getExtension()\n\t{\n\t\tif (this.extension == null || this.extension.equals(\"\")) {\n\t\t\tthis.extension = this.item.getName().substring(this.item.getName().lastIndexOf('.') + 1);\n\t\t}\n\t\treturn this.extension;\n\t}\n\tpublic String getOriginalName() {\n\t\treturn item.getName();\n\t}\n\tpublic byte[] getBytes() {\n\t\treturn item.get();\n\t}\n\tpublic void saveUploadedFile(String filename) \n\t{\n\t\tBufferedInputStream inputStream = null;\n\t\tFileOutputStream outputStream = null;\n\t\ttry {\n\t\t\tinputStream = new BufferedInputStream(this.item.getInputStream());\n\t\t\toutputStream = new FileOutputStream(filename);\n\t\t\tint c;\n\t\t\tbyte[] b = new byte[4096];\n\t\t\twhile ((c = inputStream.read(b)) != -1) {\n\t\t\t\toutputStream.write(b, 0, c);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new ForumException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (outputStream != null) {\n\t\t\t\ttry {\n\t\t\t\t\toutputStream.flush();\n\t\t\t\t\toutputStream.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException e) { }\n\t\t\t}\n\t\t\tif (inputStream != null) {\n\t\t\t\ttry {\n\t\t\t\t\tinputStream.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException e) { }\n\t\t\t}\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.4445298910140991, "ppl_lower": 1.5165985822677612, "ppl/lowercase_ppl": -1.1323769591907074, "ppl/zlib": 0.0007875458965592373, "Min_5.0% Prob": 4.3818085763765415, "Min_10.0% Prob": 2.9770137434420376, "Min_20.0% Prob": 1.7508433574950824, "Min_30.0% Prob": 1.210385915477361, "Min_40.0% Prob": 0.9173265903251854, "Min_50.0% Prob": 0.7353913803131152, "Min_60.0% Prob": 0.6132212726753934}}
{"hexsha": "34267c4672306c3aff1bdc22f78d0fe4c1cbaf88", "ext": "java", "lang": "Java", "content": "public class ODataMapDomain extends IODataMapName\n{\n    public ODataMapDomain(String name)\n    {\n        super(name);\n    }\n\n    @Override\n    public Object getValue(IOServiceContext context, HashMap<String, Object> currentEntry)\n    {\n        ClientValue value = (ClientValue)currentEntry.get(name);\n        if(value == null)\n            return null;\n\t\tClientEnumValue enumValue = value.asEnum();\n        return enumValue != null ? new ClientPrimitiveValueImpl.BuilderImpl().buildInt32(((ODataConnection)context.getConnection()).getEnumValue(enumValue)) : null;\n    }    \n}", "item_id": 0, "repo": "ggallotti/JavaClasses", "file": "gxodata/src/main/java/com/genexus/db/odata/ODataMapDomain.java", "last_update_at": "2022-01-13T02:20:18+00:00", "question_id": "34267c4672306c3aff1bdc22f78d0fe4c1cbaf88_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ODataMapDomain extends IODataMapName\n{\n    public ODataMapDomain(String name)\n    {\n        super(name);\n    }\n    @Override\n    public Object getValue(IOServiceContext context, HashMap<String, Object> currentEntry)\n    {\n        ClientValue value = (ClientValue)currentEntry.get(name);\n        if(value == null)\n            return null;\n\t\tClientEnumValue enumValue = value.asEnum();\n        return enumValue != null ? new ClientPrimitiveValueImpl.BuilderImpl().buildInt32(((ODataConnection)context.getConnection()).getEnumValue(enumValue)) : null;\n    }    \n"]], "pred": {"ppl": 4.217030048370361, "ppl_lower": 5.201461315155029, "ppl/lowercase_ppl": -1.1457883218159775, "ppl/zlib": 0.004781166446084688, "Min_5.0% Prob": 9.769259589059013, "Min_10.0% Prob": 7.974525229136149, "Min_20.0% Prob": 5.738456695310531, "Min_30.0% Prob": 4.326409692459918, "Min_40.0% Prob": 3.4327337420175947, "Min_50.0% Prob": 2.823284338923949, "Min_60.0% Prob": 2.4000668322786374}}
{"hexsha": "2a2ed52eef7e140b7ed18778ee17e63c4b72238e", "ext": "java", "lang": "Java", "content": "@Singleton\npublic class PortalManager implements IPortalManager    {\n    private final Logger logger;\n    private final IPortalPredicateManager predicateManager;\n    private final IPortalActivityManager portalActivityManager;\n\n    // Multiple portals can have the same origin position\n    private final Map<Location, Set<IPortal>> portals = new HashMap<>();\n    private final Map<UUID, IPortal> portalsById = new HashMap<>();\n\n    @Inject\n    public PortalManager(Logger logger, IPortalPredicateManager predicateManager, IPortalActivityManager portalActivityManager) {\n        this.logger = logger;\n        this.predicateManager = predicateManager;\n        this.portalActivityManager = portalActivityManager;\n    }\n\n    @Override\n    public Collection<IPortal> getAllPortals() {\n        return portalsById.values();\n    }\n\n    @Override\n    public Collection<IPortal> getPortalsAt(Location originLoc) {\n        Set<IPortal> portalsAtLoc = portals.get(originLoc);\n        return portalsAtLoc == null ? Collections.emptyList() : portalsAtLoc;\n    }\n\n    @Override\n    public IPortal getPortalById(@Nullable UUID id) {\n        return portalsById.get(id);\n    }\n\n    @Override\n    public IPortal findClosestPortal(@NotNull Location position, double maximumDistance, Predicate<IPortal> predicate) {\n        IPortal currentClosest = null;\n        double currentClosestDistance = maximumDistance;\n        for(Map.Entry<Location, Set<IPortal>> entry : portals.entrySet()) {\n\n            Location portalPos = entry.getKey();\n            // Avoid throwing an exception when portals not in this world are checked\n            if(portalPos.getWorld() != position.getWorld()) {continue;}\n            double distance = portalPos.distance(position);\n\n            if(distance >= currentClosestDistance) {continue;}\n\n            // Check to see if any portals here match the predicate\n            for(IPortal portal : entry.getValue()) {\n                if(!predicate.test(portal)) {continue;}\n\n                currentClosest = portal;\n                currentClosestDistance = distance;\n                break;\n            }\n        }\n\n        return currentClosest;\n    }\n\n    @Override\n    public @NotNull Collection<IPortal> findActivatablePortals(@NotNull Player player) {\n        List<IPortal> result = new ArrayList<>();\n\n        for(Set<IPortal> portalSet : portals.values()) {\n            for(IPortal portal : portalSet) {\n                // Test that the portal passes all predicates for activation\n                if(predicateManager.isActivatable(portal, player)) {\n                    result.add(portal);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    @Override\n    public void registerPortal(@NotNull IPortal portal) {\n        logger.fine(\"Registering portal with origin position %s\", portal.getOriginPos());\n\n        // Add a new portal array if one doesn't already exist for this location\n        Location originLoc = portal.getOriginPos().getLocation();\n        if(!portals.containsKey(originLoc)) {\n            portals.put(originLoc, new HashSet<>());\n        }\n        portalsById.put(portal.getId(), portal);\n\n        portals.get(originLoc).add(portal);\n    }\n\n    @Override\n    public int removePortalsAt(@NotNull Location originLoc) {\n        Set<IPortal> portalsRemoved = portals.remove(originLoc);\n        if(portalsRemoved == null) {return 0;}\n\n        // Make sure to also remove them from the ID map\n        for(IPortal portal : portalsRemoved) {\n            portalsById.remove(portal.getId());\n        }\n\n        logger.fine(\"Unregistering %d portal(s) at position %s\", portalsRemoved.size(), originLoc);\n        return portalsRemoved.size();\n    }\n\n    @Override\n    public boolean removePortal(@NotNull IPortal portal) {\n        logger.fine(\"Unregistering portal at position %s\", portal.getOriginPos().getLocation());\n\n        Set<IPortal> portalsAtLoc = portals.get(portal.getOriginPos().getLocation());\n        if(portalsAtLoc == null) {return false;}\n\n        boolean wasRemoved = portalsAtLoc.remove(portal);\n        // Remove the portal array if there are no longer any portals at this location\n        if(portalsAtLoc.size() == 0) {\n            portals.remove(portal.getOriginPos().getLocation());\n        }\n        portalsById.remove(portal.getId());\n        return wasRemoved;\n    }\n\n    @Override\n    public boolean removePortalById(@NotNull UUID id) {\n        IPortal removed = portalsById.remove(id);\n        if(removed == null) {return false;}\n        removePortal(removed); // Also remove it in the location map\n\n        return true;\n    }\n\n    @Override\n    public void onReload() {\n        portalActivityManager.resetActivity();\n    }\n}", "item_id": 0, "repo": "AshleyThew/BetterPortals", "file": "bukkit/src/main/java/com/lauriethefish/betterportals/bukkit/portal/PortalManager.java", "last_update_at": "2022-03-31T15:24:20+00:00", "question_id": "2a2ed52eef7e140b7ed18778ee17e63c4b72238e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Singleton\npublic class PortalManager implements IPortalManager    {\n    private final Logger logger;\n    private final IPortalPredicateManager predicateManager;\n    private final IPortalActivityManager portalActivityManager;\n    // Multiple portals can have the same origin position\n    private final Map<Location, Set<IPortal>> portals = new HashMap<>();\n    private final Map<UUID, IPortal> portalsById = new HashMap<>();\n    @Inject\n    public PortalManager(Logger logger, IPortalPredicateManager predicateManager, IPortalActivityManager portalActivityManager) {\n        this.logger = logger;\n        this.predicateManager = predicateManager;\n        this.portalActivityManager = portalActivityManager;\n    }\n    @Override\n    public Collection<IPortal> getAllPortals() {\n        return portalsById.values();\n    }\n    @Override\n    public Collection<IPortal> getPortalsAt(Location originLoc) {\n        Set<IPortal> portalsAtLoc = portals.get(originLoc);\n        return portalsAtLoc == null ? Collections.emptyList() : portalsAtLoc;\n    }\n    @Override\n    public IPortal getPortalById(@Nullable UUID id) {\n        return portalsById.get(id);\n    }\n    @Override\n    public IPortal findClosestPortal(@NotNull Location position, double maximumDistance, Predicate<IPortal> predicate) {\n        IPortal currentClosest = null;\n        double currentClosestDistance = maximumDistance;\n        for(Map.Entry<Location, Set<IPortal>> entry : portals.entrySet()) {\n            Location portalPos = entry.getKey();\n            // Avoid throwing an exception when portals not in this world are checked\n            if(portalPos.getWorld() != position.getWorld()) {continue;}\n            double distance = portalPos.distance(position);\n            if(distance >= currentClosestDistance) {continue;}\n            // Check to see if any portals here match the predicate\n            for(IPortal portal : entry.getValue()) {\n                if(!predicate.test(portal)) {continue;}\n                currentClosest = portal;\n                currentClosestDistance = distance;\n                break;\n            }\n        }\n        return currentClosest;\n    }\n    @Override\n    public @NotNull Collection<IPortal> findActivatablePortals(@NotNull Player player) {\n        List<IPortal> result = new ArrayList<>();\n        for(Set<IPortal> portalSet : portals.values()) {\n            for(IPortal portal : portalSet) {\n                // Test that the portal passes all predicates for activation\n                if(predicateManager.isActivatable(portal, player)) {\n                    result.add(portal);\n                }\n            }\n        }\n        return result;\n    }\n    @Override\n    public void registerPortal(@NotNull IPortal portal) {\n        logger.fine(\"Registering portal with origin position %s\", portal.getOriginPos());\n        // Add a new portal array if one doesn't already exist for this location\n        Location originLoc = portal.getOriginPos().getLocation();\n        if(!portals.containsKey(originLoc)) {\n            portals.put(originLoc, new HashSet<>());\n        }\n        portalsById.put(portal.getId(), portal);\n        portals.get(originLoc).add(portal);\n    }\n    @Override\n    public int removePortalsAt(@NotNull Location originLoc) {\n        Set<IPortal> portalsRemoved = portals.remove(originLoc);\n        if(portalsRemoved == null) {return 0;}\n        // Make sure to also remove them from the ID map\n        for(IPortal portal : portalsRemoved) {\n            portalsById.remove(portal.getId());\n        }\n        logger.fine(\"Unregistering %d portal(s) at position %s\", portalsRemoved.size(), originLoc);\n        return portalsRemoved.size();\n    }\n    @Override\n    public boolean removePortal(@NotNull IPortal portal) {\n        logger.fine(\"Unregistering portal at position %s\", portal.getOriginPos().getLocation());\n        Set<IPortal> portalsAtLoc = portals.get(portal.getOriginPos().getLocation());\n        if(portalsAtLoc == null) {return false;}\n        boolean wasRemoved = portalsAtLoc.remove(portal);\n        // Remove the portal array if there are no longer any portals at this location\n        if(portalsAtLoc.size() == 0) {\n            portals.remove(portal.getOriginPos().getLocation());\n        }\n        portalsById.remove(portal.getId());\n        return wasRemoved;\n    }\n    @Override\n    public boolean removePortalById(@NotNull UUID id) {\n        IPortal removed = portalsById.remove(id);\n        if(removed == null) {return false;}\n        removePortal(removed); // Also remove it in the location map\n        return true;\n    }\n    @Override\n    public void onReload() {\n        portalActivityManager.resetActivity();\n    }\n"]], "pred": {"ppl": 1.6800357103347778, "ppl_lower": 1.8336174488067627, "ppl/lowercase_ppl": -1.1686067403210725, "ppl/zlib": 0.00040218220879140485, "Min_5.0% Prob": 5.492450802933936, "Min_10.0% Prob": 3.8398753322807013, "Min_20.0% Prob": 2.411250908585156, "Min_30.0% Prob": 1.7018982956514639, "Min_40.0% Prob": 1.290434251723852, "Min_50.0% Prob": 1.0368893215789983, "Min_60.0% Prob": 0.8653613294586449}}
{"hexsha": "306644f4c481adbba4a4ad24f09fd723df6a4b34", "ext": "java", "lang": "Java", "content": "public class BaseActivity extends AppCompatActivity {\n\n    public BaseActivity baseActivity;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        baseActivity = this;\n        RxActivityTool.addActivity(this);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n    }\n}", "item_id": 0, "repo": "Yumore/RxMVP", "file": "utility/src/main/java/com/yumore/utility/activity/BaseActivity.java", "last_update_at": "2022-03-05T16:49:46+00:00", "question_id": "306644f4c481adbba4a4ad24f09fd723df6a4b34_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BaseActivity extends AppCompatActivity {\n    public BaseActivity baseActivity;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        baseActivity = this;\n        RxActivityTool.addActivity(this);\n    }\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n    }\n"]], "pred": {"ppl": 1.6869899034500122, "ppl_lower": 2.261258125305176, "ppl/lowercase_ppl": -1.5602407016769946, "ppl/zlib": 0.0024902181839613342, "Min_5.0% Prob": 6.239202976226807, "Min_10.0% Prob": 4.3296368230472915, "Min_20.0% Prob": 2.4977174428376285, "Min_30.0% Prob": 1.7334735129367222, "Min_40.0% Prob": 1.3150751053101637, "Min_50.0% Prob": 1.0544068941677158, "Min_60.0% Prob": 0.8791897655817482}}
{"hexsha": "15c78d13dc4b8fc23a4f4731380ad0f83af9d811", "ext": "java", "lang": "Java", "content": "public class Card7_022 extends AbstractRebel {\n    public Card7_022() {\n        super(Side.LIGHT, 3, 2, 1, 2, 3, \"Incom Engineer\");\n        setLore(\"After narrowly escaping the nationalization of Incom by the Empire, many former employees joined the Rebellion. They spent long hours maintaining X-wings and T-47s.\");\n        setGameText(\"At same and related locations, adds 2 to your total battle destiny where your X-wing, T-47, T-16 and Z-95 is present and makes those vehicles and starships immune to attrition < 3 (< 5 if he is present with your maintenance droid).\");\n        addIcons(Icon.SPECIAL_EDITION);\n    }\n\n    @Override\n    protected List<Modifier> getGameTextWhileActiveInPlayModifiers(SwccgGame game, final PhysicalCard self) {\n        List<Modifier> modifiers = new LinkedList<Modifier>();\n        modifiers.add(new TotalBattleDestinyModifier(self, new DuringBattleAtCondition(Filters.and(Filters.sameOrRelatedLocation(self),\n                Filters.wherePresent(self, Filters.and(Filters.your(self), Filters.or(Filters.X_wing, Filters.T_47, Filters.T_16, Filters.Z_95))))),\n                2, self.getOwner(), true));\n        modifiers.add(new ImmuneToAttritionLessThanModifier(self, Filters.and(Filters.your(self), Filters.or(Filters.X_wing,\n                Filters.T_47, Filters.T_16, Filters.Z_95), Filters.presentAt(Filters.sameOrRelatedLocation(self))),\n                new ConditionEvaluator(3, 5, new PresentWithCondition(self, Filters.and(Filters.your(self), Filters.maintenance_droid)))));\n        return modifiers;\n    }\n}", "item_id": 0, "repo": "stbly/gemp-swccg-public", "file": "gemp-swccg-cards/src/main/java/com/gempukku/swccgo/cards/set7/light/Card7_022.java", "last_update_at": "2022-02-10T18:23:49+00:00", "question_id": "15c78d13dc4b8fc23a4f4731380ad0f83af9d811_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Card7_022 extends AbstractRebel {\n    public Card7_022() {\n        super(Side.LIGHT, 3, 2, 1, 2, 3, \"Incom Engineer\");\n        setLore(\"After narrowly escaping the nationalization of Incom by the Empire, many former employees joined the Rebellion. They spent long hours maintaining X-wings and T-47s.\");\n        setGameText(\"At same and related locations, adds 2 to your total battle destiny where your X-wing, T-47, T-16 and Z-95 is present and makes those vehicles and starships immune to attrition < 3 (< 5 if he is present with your maintenance droid).\");\n        addIcons(Icon.SPECIAL_EDITION);\n    }\n    @Override\n    protected List<Modifier> getGameTextWhileActiveInPlayModifiers(SwccgGame game, final PhysicalCard self) {\n        List<Modifier> modifiers = new LinkedList<Modifier>();\n        modifiers.add(new TotalBattleDestinyModifier(self, new DuringBattleAtCondition(Filters.and(Filters.sameOrRelatedLocation(self),\n                Filters.wherePresent(self, Filters.and(Filters.your(self), Filters.or(Filters.X_wing, Filters.T_47, Filters.T_16, Filters.Z_95))))),\n                2, self.getOwner(), true));\n        modifiers.add(new ImmuneToAttritionLessThanModifier(self, Filters.and(Filters.your(self), Filters.or(Filters.X_wing,\n                Filters.T_47, Filters.T_16, Filters.Z_95), Filters.presentAt(Filters.sameOrRelatedLocation(self))),\n                new ConditionEvaluator(3, 5, new PresentWithCondition(self, Filters.and(Filters.your(self), Filters.maintenance_droid)))));\n        return modifiers;\n    }\n"]], "pred": {"ppl": 2.0043303966522217, "ppl_lower": 3.909579277038574, "ppl/lowercase_ppl": -1.9608946965779652, "ppl/zlib": 0.0009961461865647839, "Min_5.0% Prob": 6.774129981994629, "Min_10.0% Prob": 5.02484827041626, "Min_20.0% Prob": 3.2409809609450915, "Min_30.0% Prob": 2.2966872990915648, "Min_40.0% Prob": 1.7355482170697798, "Min_50.0% Prob": 1.389838582533595, "Min_60.0% Prob": 1.1617595323370646}}
{"hexsha": "5a5703e6f6582e2edfa87e767c9a4b78f0a507b9", "ext": "java", "lang": "Java", "content": "public class TestFederationStateStoreInputValidator {\n\n  private static final Logger LOG =\n      LoggerFactory.getLogger(TestFederationStateStoreInputValidator.class);\n\n  private static SubClusterId subClusterId;\n  private static String amRMServiceAddress;\n  private static String clientRMServiceAddress;\n  private static String rmAdminServiceAddress;\n  private static String rmWebServiceAddress;\n  private static int lastHeartBeat;\n  private static SubClusterState stateNew;\n  private static SubClusterState stateLost;\n  private static ApplicationId appId;\n  private static int lastStartTime;\n  private static String capability;\n  private static String queue;\n  private static String type;\n  private static ByteBuffer params;\n\n  private static SubClusterId subClusterIdInvalid;\n  private static SubClusterId subClusterIdNull;\n\n  private static int lastHeartBeatNegative;\n  private static int lastStartTimeNegative;\n\n  private static SubClusterState stateNull;\n  private static ApplicationId appIdNull;\n\n  private static String capabilityNull;\n  private static String capabilityEmpty;\n\n  private static String addressNull;\n  private static String addressEmpty;\n  private static String addressWrong;\n  private static String addressWrongPort;\n\n  private static String queueEmpty;\n  private static String queueNull;\n\n  private static String typeEmpty;\n  private static String typeNull;\n\n  @BeforeClass\n  public static void setUp() {\n    subClusterId = SubClusterId.newInstance(\"abc\");\n    amRMServiceAddress = \"localhost:8032\";\n    clientRMServiceAddress = \"localhost:8034\";\n    rmAdminServiceAddress = \"localhost:8031\";\n    rmWebServiceAddress = \"localhost:8088\";\n    lastHeartBeat = 1000;\n    stateNew = SubClusterState.SC_NEW;\n    stateLost = SubClusterState.SC_LOST;\n    lastStartTime = 1000;\n    capability = \"Memory VCores\";\n    appId = ApplicationId.newInstance(lastStartTime, 1);\n    queue = \"default\";\n    type = \"random\";\n    params = ByteBuffer.allocate(10);\n    params.put((byte) 0xFF);\n\n    subClusterIdInvalid = SubClusterId.newInstance(\"\");\n    subClusterIdNull = null;\n\n    lastHeartBeatNegative = -10;\n    lastStartTimeNegative = -10;\n\n    stateNull = null;\n    appIdNull = null;\n\n    capabilityNull = null;\n    capabilityEmpty = \"\";\n\n    addressNull = null;\n    addressEmpty = \"\";\n    addressWrong = \"AddressWrong\";\n    addressWrongPort = \"Address:WrongPort\";\n\n    queueEmpty = \"\";\n    queueNull = null;\n\n    typeEmpty = \"\";\n    typeNull = null;\n  }\n\n  @Test\n  public void testValidateSubClusterRegisterRequest() {\n\n    // Execution with valid inputs\n\n    SubClusterInfo subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    // Execution with null request\n\n    try {\n      SubClusterRegisterRequest request = null;\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubClusterRegister Request.\"));\n    }\n\n    // Execution with null SubClusterInfo\n\n    subClusterInfo = null;\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster Information.\"));\n    }\n\n    // Execution with Null SubClusterId\n\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterIdNull, amRMServiceAddress,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster Id information.\"));\n    }\n\n    // Execution with Invalid SubClusterId\n\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterIdInvalid, amRMServiceAddress,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid SubCluster Id information.\"));\n    }\n\n    // Execution with Null State\n\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNull, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster State information.\"));\n    }\n\n    // Execution with Null Capability\n\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capabilityNull);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    // Execution with Empty Capability\n\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capabilityEmpty);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n  }\n\n  @Test\n  public void testValidateSubClusterRegisterRequestTimestamp() {\n\n    // Execution with Negative Last Heartbeat\n\n    SubClusterInfo subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeatNegative, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid timestamp information.\"));\n    }\n\n    // Execution with Negative Last StartTime\n\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTimeNegative, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid timestamp information.\"));\n    }\n  }\n\n  @Test\n  public void testValidateSubClusterRegisterRequestAddress() {\n    // Execution with Null Address for amRMServiceAddress\n\n    SubClusterInfo subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, addressNull,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing SubCluster Endpoint information.\"));\n    }\n\n    // Execution with Empty Address for amRMServiceAddress\n\n    subClusterInfo = SubClusterInfo.newInstance(subClusterId, addressEmpty,\n        clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n        lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing SubCluster Endpoint information.\"));\n    }\n\n    // Execution with Null Address for clientRMServiceAddress\n\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            addressNull, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing SubCluster Endpoint information.\"));\n    }\n\n    // Execution with Empty Address for clientRMServiceAddress\n\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            addressEmpty, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing SubCluster Endpoint information.\"));\n    }\n\n    // Execution with Null Address for rmAdminServiceAddress\n\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, addressNull, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing SubCluster Endpoint information.\"));\n    }\n\n    // Execution with Empty Address for rmAdminServiceAddress\n\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, addressEmpty, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing SubCluster Endpoint information.\"));\n    }\n\n    // Execution with Null Address for rmWebServiceAddress\n\n    subClusterInfo = SubClusterInfo.newInstance(subClusterId,\n        amRMServiceAddress, clientRMServiceAddress, rmAdminServiceAddress,\n        addressNull, lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing SubCluster Endpoint information.\"));\n    }\n\n    // Execution with Empty Address for rmWebServiceAddress\n\n    subClusterInfo = SubClusterInfo.newInstance(subClusterId,\n        amRMServiceAddress, clientRMServiceAddress, rmAdminServiceAddress,\n        addressEmpty, lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing SubCluster Endpoint information.\"));\n    }\n  }\n\n  @Test\n  public void testValidateSubClusterRegisterRequestAddressInvalid() {\n\n    // Address is not in host:port format for amRMService\n\n    SubClusterInfo subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, addressWrong,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNull, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage().contains(\"valid host:port authority:\"));\n    }\n\n    // Address is not in host:port format for clientRMService\n\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            addressWrong, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNull, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage().contains(\"valid host:port authority:\"));\n    }\n\n    // Address is not in host:port format for rmAdminService\n\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, addressWrong, rmWebServiceAddress,\n            lastHeartBeat, stateNull, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage().contains(\"valid host:port authority:\"));\n    }\n\n    // Address is not in host:port format for rmWebService\n\n    subClusterInfo = SubClusterInfo.newInstance(subClusterId,\n        amRMServiceAddress, clientRMServiceAddress, rmAdminServiceAddress,\n        addressWrong, lastHeartBeat, stateNull, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage().contains(\"valid host:port authority:\"));\n    }\n\n    // Port is not an integer for amRMService\n\n    subClusterInfo = SubClusterInfo.newInstance(subClusterId, addressWrongPort,\n        clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n        lastHeartBeat, stateNull, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage().contains(\"valid host:port authority:\"));\n    }\n\n    // Port is not an integer for clientRMService\n\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            addressWrongPort, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNull, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage().contains(\"valid host:port authority:\"));\n    }\n\n    // Port is not an integer for rmAdminService\n\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, addressWrongPort, rmWebServiceAddress,\n            lastHeartBeat, stateNull, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage().contains(\"valid host:port authority:\"));\n    }\n\n    // Port is not an integer for rmWebService\n\n    subClusterInfo = SubClusterInfo.newInstance(subClusterId,\n        amRMServiceAddress, clientRMServiceAddress, rmAdminServiceAddress,\n        addressWrongPort, lastHeartBeat, stateNull, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage().contains(\"valid host:port authority:\"));\n    }\n\n  }\n\n  @Test\n  public void testValidateSubClusterDeregisterRequest() {\n\n    // Execution with valid inputs\n\n    try {\n      SubClusterDeregisterRequest request =\n          SubClusterDeregisterRequest.newInstance(subClusterId, stateLost);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    // Execution with null request\n\n    try {\n      SubClusterDeregisterRequest request = null;\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubClusterDeregister Request.\"));\n    }\n\n    // Execution with null SubClusterId\n\n    try {\n      SubClusterDeregisterRequest request =\n          SubClusterDeregisterRequest.newInstance(subClusterIdNull, stateLost);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster Id information.\"));\n    }\n\n    // Execution with invalid SubClusterId\n\n    try {\n      SubClusterDeregisterRequest request = SubClusterDeregisterRequest\n          .newInstance(subClusterIdInvalid, stateLost);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid SubCluster Id information.\"));\n    }\n\n    // Execution with null SubClusterState\n\n    try {\n      SubClusterDeregisterRequest request =\n          SubClusterDeregisterRequest.newInstance(subClusterId, stateNull);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster State information.\"));\n    }\n\n    // Execution with invalid SubClusterState\n\n    try {\n      SubClusterDeregisterRequest request =\n          SubClusterDeregisterRequest.newInstance(subClusterId, stateNew);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage().startsWith(\"Invalid non-final state: \"));\n    }\n  }\n\n  @Test\n  public void testSubClusterHeartbeatRequest() {\n\n    // Execution with valid inputs\n\n    try {\n      SubClusterHeartbeatRequest request = SubClusterHeartbeatRequest\n          .newInstance(subClusterId, lastHeartBeat, stateLost, capability);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    // Execution with null request\n\n    try {\n      SubClusterHeartbeatRequest request = null;\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubClusterHeartbeat Request.\"));\n    }\n\n    // Execution with null SubClusterId\n\n    try {\n      SubClusterHeartbeatRequest request = SubClusterHeartbeatRequest\n          .newInstance(subClusterIdNull, lastHeartBeat, stateLost, capability);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster Id information.\"));\n    }\n\n    // Execution with invalid SubClusterId\n\n    try {\n      SubClusterHeartbeatRequest request =\n          SubClusterHeartbeatRequest.newInstance(subClusterIdInvalid,\n              lastHeartBeat, stateLost, capability);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid SubCluster Id information.\"));\n    }\n\n    // Execution with null SubClusterState\n\n    try {\n      SubClusterHeartbeatRequest request = SubClusterHeartbeatRequest\n          .newInstance(subClusterId, lastHeartBeat, stateNull, capability);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster State information.\"));\n    }\n\n    // Execution with negative Last Heartbeat\n\n    try {\n      SubClusterHeartbeatRequest request =\n          SubClusterHeartbeatRequest.newInstance(subClusterId,\n              lastHeartBeatNegative, stateLost, capability);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid timestamp information.\"));\n    }\n\n    // Execution with null Capability\n\n    try {\n      SubClusterHeartbeatRequest request = SubClusterHeartbeatRequest\n          .newInstance(subClusterId, lastHeartBeat, stateLost, capabilityNull);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid capability information.\"));\n    }\n\n    // Execution with empty Capability\n\n    try {\n      SubClusterHeartbeatRequest request = SubClusterHeartbeatRequest\n          .newInstance(subClusterId, lastHeartBeat, stateLost, capabilityEmpty);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid capability information.\"));\n    }\n  }\n\n  @Test\n  public void testGetSubClusterInfoRequest() {\n\n    // Execution with valid inputs\n\n    try {\n      GetSubClusterInfoRequest request =\n          GetSubClusterInfoRequest.newInstance(subClusterId);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    // Execution with null request\n\n    try {\n      GetSubClusterInfoRequest request = null;\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing GetSubClusterInfo Request.\"));\n    }\n\n    // Execution with null SubClusterId\n\n    try {\n      GetSubClusterInfoRequest request =\n          GetSubClusterInfoRequest.newInstance(subClusterIdNull);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster Id information.\"));\n    }\n\n    // Execution with invalid SubClusterId\n\n    try {\n      GetSubClusterInfoRequest request =\n          GetSubClusterInfoRequest.newInstance(subClusterIdInvalid);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid SubCluster Id information.\"));\n    }\n  }\n\n  @Test\n  public void testAddApplicationHomeSubClusterRequest() {\n\n    // Execution with valid inputs\n\n    ApplicationHomeSubCluster applicationHomeSubCluster =\n        ApplicationHomeSubCluster.newInstance(appId, subClusterId);\n    try {\n      AddApplicationHomeSubClusterRequest request =\n          AddApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    // Execution with null request\n\n    try {\n      AddApplicationHomeSubClusterRequest request = null;\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing AddApplicationHomeSubCluster Request.\"));\n    }\n\n    // Execution with null ApplicationHomeSubCluster\n\n    applicationHomeSubCluster = null;\n    try {\n      AddApplicationHomeSubClusterRequest request =\n          AddApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing ApplicationHomeSubCluster Info.\"));\n    }\n\n    // Execution with null SubClusterId\n\n    applicationHomeSubCluster =\n        ApplicationHomeSubCluster.newInstance(appId, subClusterIdNull);\n    try {\n      AddApplicationHomeSubClusterRequest request =\n          AddApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster Id information.\"));\n    }\n\n    // Execution with invalid SubClusterId\n\n    applicationHomeSubCluster =\n        ApplicationHomeSubCluster.newInstance(appId, subClusterIdInvalid);\n    try {\n      AddApplicationHomeSubClusterRequest request =\n          AddApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid SubCluster Id information.\"));\n    }\n\n    // Execution with Null ApplicationId\n\n    applicationHomeSubCluster =\n        ApplicationHomeSubCluster.newInstance(appIdNull, subClusterId);\n    try {\n      AddApplicationHomeSubClusterRequest request =\n          AddApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Application Id.\"));\n    }\n  }\n\n  @Test\n  public void testUpdateApplicationHomeSubClusterRequest() {\n\n    // Execution with valid inputs\n\n    ApplicationHomeSubCluster applicationHomeSubCluster =\n        ApplicationHomeSubCluster.newInstance(appId, subClusterId);\n    try {\n      UpdateApplicationHomeSubClusterRequest request =\n          UpdateApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    // Execution with null request\n\n    try {\n      UpdateApplicationHomeSubClusterRequest request = null;\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing UpdateApplicationHomeSubCluster Request.\"));\n    }\n\n    // Execution with null ApplicationHomeSubCluster\n\n    applicationHomeSubCluster = null;\n    try {\n      UpdateApplicationHomeSubClusterRequest request =\n          UpdateApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing ApplicationHomeSubCluster Info.\"));\n    }\n\n    // Execution with null SubClusteId\n\n    applicationHomeSubCluster =\n        ApplicationHomeSubCluster.newInstance(appId, subClusterIdNull);\n    try {\n      UpdateApplicationHomeSubClusterRequest request =\n          UpdateApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster Id information.\"));\n    }\n\n    // Execution with invalid SubClusterId\n\n    applicationHomeSubCluster =\n        ApplicationHomeSubCluster.newInstance(appId, subClusterIdInvalid);\n    try {\n      UpdateApplicationHomeSubClusterRequest request =\n          UpdateApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid SubCluster Id information.\"));\n    }\n\n    // Execution with null ApplicationId\n\n    applicationHomeSubCluster =\n        ApplicationHomeSubCluster.newInstance(appIdNull, subClusterId);\n    try {\n      UpdateApplicationHomeSubClusterRequest request =\n          UpdateApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Application Id.\"));\n    }\n  }\n\n  @Test\n  public void testGetApplicationHomeSubClusterRequest() {\n\n    // Execution with valid inputs\n\n    try {\n      GetApplicationHomeSubClusterRequest request =\n          GetApplicationHomeSubClusterRequest.newInstance(appId);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    // Execution with null request\n\n    try {\n      GetApplicationHomeSubClusterRequest request = null;\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing GetApplicationHomeSubCluster Request.\"));\n    }\n\n    // Execution with null ApplicationId\n\n    try {\n      GetApplicationHomeSubClusterRequest request =\n          GetApplicationHomeSubClusterRequest.newInstance(appIdNull);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Application Id.\"));\n    }\n\n  }\n\n  @Test\n  public void testDeleteApplicationHomeSubClusterRequestNull() {\n\n    // Execution with valid inputs\n\n    try {\n      DeleteApplicationHomeSubClusterRequest request =\n          DeleteApplicationHomeSubClusterRequest.newInstance(appId);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    // Execution with null request\n\n    try {\n      DeleteApplicationHomeSubClusterRequest request = null;\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing DeleteApplicationHomeSubCluster Request.\"));\n    }\n\n    // Execution with null ApplicationId\n\n    try {\n      DeleteApplicationHomeSubClusterRequest request =\n          DeleteApplicationHomeSubClusterRequest.newInstance(appIdNull);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Application Id.\"));\n    }\n\n  }\n\n  @Test\n  public void testGetSubClusterPolicyConfigurationRequest() {\n\n    // Execution with valid inputs\n\n    try {\n      GetSubClusterPolicyConfigurationRequest request =\n          GetSubClusterPolicyConfigurationRequest.newInstance(queue);\n      FederationPolicyStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    // Execution with null request\n\n    try {\n      GetSubClusterPolicyConfigurationRequest request = null;\n      FederationPolicyStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing GetSubClusterPolicyConfiguration Request.\"));\n    }\n\n    // Execution with null queue id\n\n    try {\n      GetSubClusterPolicyConfigurationRequest request =\n          GetSubClusterPolicyConfigurationRequest.newInstance(queueNull);\n      FederationPolicyStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Queue.\"));\n    }\n\n    // Execution with empty queue id\n\n    try {\n      GetSubClusterPolicyConfigurationRequest request =\n          GetSubClusterPolicyConfigurationRequest.newInstance(queueEmpty);\n      FederationPolicyStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Queue.\"));\n    }\n\n  }\n\n  @Test\n  public void testSetSubClusterPolicyConfigurationRequest() {\n\n    // Execution with valid inputs\n\n    try {\n      SubClusterPolicyConfiguration policy =\n          SubClusterPolicyConfiguration.newInstance(queue, type, params);\n      SetSubClusterPolicyConfigurationRequest request =\n          SetSubClusterPolicyConfigurationRequest.newInstance(policy);\n      FederationPolicyStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    // Execution with null request\n\n    try {\n      SetSubClusterPolicyConfigurationRequest request = null;\n      FederationPolicyStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing SetSubClusterPolicyConfiguration Request.\"));\n    }\n\n    // Execution with null SubClusterPolicyConfiguration\n\n    try {\n      SubClusterPolicyConfiguration policy = null;\n      SetSubClusterPolicyConfigurationRequest request =\n          SetSubClusterPolicyConfigurationRequest.newInstance(policy);\n      FederationPolicyStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubClusterPolicyConfiguration.\"));\n    }\n\n    // Execution with null queue id\n\n    try {\n      SubClusterPolicyConfiguration policy =\n          SubClusterPolicyConfiguration.newInstance(queueNull, type, params);\n      SetSubClusterPolicyConfigurationRequest request =\n          SetSubClusterPolicyConfigurationRequest.newInstance(policy);\n      FederationPolicyStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Queue.\"));\n    }\n\n    // Execution with empty queue id\n\n    try {\n      SubClusterPolicyConfiguration policy =\n          SubClusterPolicyConfiguration.newInstance(queueEmpty, type, params);\n      SetSubClusterPolicyConfigurationRequest request =\n          SetSubClusterPolicyConfigurationRequest.newInstance(policy);\n      FederationPolicyStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Queue.\"));\n    }\n\n    // Execution with null policy type\n\n    try {\n      SubClusterPolicyConfiguration policy =\n          SubClusterPolicyConfiguration.newInstance(queue, typeNull, params);\n      SetSubClusterPolicyConfigurationRequest request =\n          SetSubClusterPolicyConfigurationRequest.newInstance(policy);\n      FederationPolicyStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Policy Type.\"));\n    }\n\n    // Execution with empty policy type\n\n    try {\n      SubClusterPolicyConfiguration policy =\n          SubClusterPolicyConfiguration.newInstance(queue, typeEmpty, params);\n      SetSubClusterPolicyConfigurationRequest request =\n          SetSubClusterPolicyConfigurationRequest.newInstance(policy);\n      FederationPolicyStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Policy Type.\"));\n    }\n  }\n\n}", "item_id": 0, "repo": "bzhaoopenstack/hadoop", "file": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/test/java/org/apache/hadoop/yarn/server/federation/store/utils/TestFederationStateStoreInputValidator.java", "last_update_at": "2022-03-31T15:28:37+00:00", "question_id": "5a5703e6f6582e2edfa87e767c9a4b78f0a507b9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestFederationStateStoreInputValidator {\n  private static final Logger LOG =\n      LoggerFactory.getLogger(TestFederationStateStoreInputValidator.class);\n  private static SubClusterId subClusterId;\n  private static String amRMServiceAddress;\n  private static String clientRMServiceAddress;\n  private static String rmAdminServiceAddress;\n  private static String rmWebServiceAddress;\n  private static int lastHeartBeat;\n  private static SubClusterState stateNew;\n  private static SubClusterState stateLost;\n  private static ApplicationId appId;\n  private static int lastStartTime;\n  private static String capability;\n  private static String queue;\n  private static String type;\n  private static ByteBuffer params;\n  private static SubClusterId subClusterIdInvalid;\n  private static SubClusterId subClusterIdNull;\n  private static int lastHeartBeatNegative;\n  private static int lastStartTimeNegative;\n  private static SubClusterState stateNull;\n  private static ApplicationId appIdNull;\n  private static String capabilityNull;\n  private static String capabilityEmpty;\n  private static String addressNull;\n  private static String addressEmpty;\n  private static String addressWrong;\n  private static String addressWrongPort;\n  private static String queueEmpty;\n  private static String queueNull;\n  private static String typeEmpty;\n  private static String typeNull;\n  @BeforeClass\n  public static void setUp() {\n    subClusterId = SubClusterId.newInstance(\"abc\");\n    amRMServiceAddress = \"localhost:8032\";\n    clientRMServiceAddress = \"localhost:8034\";\n    rmAdminServiceAddress = \"localhost:8031\";\n    rmWebServiceAddress = \"localhost:8088\";\n    lastHeartBeat = 1000;\n    stateNew = SubClusterState.SC_NEW;\n    stateLost = SubClusterState.SC_LOST;\n    lastStartTime = 1000;\n    capability = \"Memory VCores\";\n    appId = ApplicationId.newInstance(lastStartTime, 1);\n    queue = \"default\";\n    type = \"random\";\n    params = ByteBuffer.allocate(10);\n    params.put((byte) 0xFF);\n    subClusterIdInvalid = SubClusterId.newInstance(\"\");\n    subClusterIdNull = null;\n    lastHeartBeatNegative = -10;\n    lastStartTimeNegative = -10;\n    stateNull = null;\n    appIdNull = null;\n    capabilityNull = null;\n    capabilityEmpty = \"\";\n    addressNull = null;\n    addressEmpty = \"\";\n    addressWrong = \"AddressWrong\";\n    addressWrongPort = \"Address:WrongPort\";\n    queueEmpty = \"\";\n    queueNull = null;\n    typeEmpty = \"\";\n    typeNull = null;\n  }\n  @Test\n  public void testValidateSubClusterRegisterRequest() {\n    // Execution with valid inputs\n    SubClusterInfo subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n    // Execution with null request\n    try {\n      SubClusterRegisterRequest request = null;\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubClusterRegister Request.\"));\n    }\n    // Execution with null SubClusterInfo\n    subClusterInfo = null;\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster Information.\"));\n    }\n    // Execution with Null SubClusterId\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterIdNull, amRMServiceAddress,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster Id information.\"));\n    }\n    // Execution with Invalid SubClusterId\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterIdInvalid, amRMServiceAddress,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid SubCluster Id information.\"));\n    }\n    // Execution with Null State\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNull, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster State information.\"));\n    }\n    // Execution with Null Capability\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capabilityNull);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n    // Execution with Empty Capability\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capabilityEmpty);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n  }\n  @Test\n  public void testValidateSubClusterRegisterRequestTimestamp() {\n    // Execution with Negative Last Heartbeat\n    SubClusterInfo subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeatNegative, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid timestamp information.\"));\n    }\n    // Execution with Negative Last StartTime\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTimeNegative, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid timestamp information.\"));\n    }\n  }\n  @Test\n  public void testValidateSubClusterRegisterRequestAddress() {\n    // Execution with Null Address for amRMServiceAddress\n    SubClusterInfo subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, addressNull,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing SubCluster Endpoint information.\"));\n    }\n    // Execution with Empty Address for amRMServiceAddress\n    subClusterInfo = SubClusterInfo.newInstance(subClusterId, addressEmpty,\n        clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n        lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing SubCluster Endpoint information.\"));\n    }\n    // Execution with Null Address for clientRMServiceAddress\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            addressNull, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing SubCluster Endpoint information.\"));\n    }\n    // Execution with Empty Address for clientRMServiceAddress\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            addressEmpty, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing SubCluster Endpoint information.\"));\n    }\n    // Execution with Null Address for rmAdminServiceAddress\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, addressNull, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing SubCluster Endpoint information.\"));\n    }\n    // Execution with Empty Address for rmAdminServiceAddress\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, addressEmpty, rmWebServiceAddress,\n            lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing SubCluster Endpoint information.\"));\n    }\n    // Execution with Null Address for rmWebServiceAddress\n    subClusterInfo = SubClusterInfo.newInstance(subClusterId,\n        amRMServiceAddress, clientRMServiceAddress, rmAdminServiceAddress,\n        addressNull, lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing SubCluster Endpoint information.\"));\n    }\n    // Execution with Empty Address for rmWebServiceAddress\n    subClusterInfo = SubClusterInfo.newInstance(subClusterId,\n        amRMServiceAddress, clientRMServiceAddress, rmAdminServiceAddress,\n        addressEmpty, lastHeartBeat, stateNew, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing SubCluster Endpoint information.\"));\n    }\n  }\n  @Test\n  public void testValidateSubClusterRegisterRequestAddressInvalid() {\n    // Address is not in host:port format for amRMService\n    SubClusterInfo subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, addressWrong,\n            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNull, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage().contains(\"valid host:port authority:\"));\n    }\n    // Address is not in host:port format for clientRMService\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            addressWrong, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNull, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage().contains(\"valid host:port authority:\"));\n    }\n    // Address is not in host:port format for rmAdminService\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, addressWrong, rmWebServiceAddress,\n            lastHeartBeat, stateNull, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage().contains(\"valid host:port authority:\"));\n    }\n    // Address is not in host:port format for rmWebService\n    subClusterInfo = SubClusterInfo.newInstance(subClusterId,\n        amRMServiceAddress, clientRMServiceAddress, rmAdminServiceAddress,\n        addressWrong, lastHeartBeat, stateNull, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage().contains(\"valid host:port authority:\"));\n    }\n    // Port is not an integer for amRMService\n    subClusterInfo = SubClusterInfo.newInstance(subClusterId, addressWrongPort,\n        clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,\n        lastHeartBeat, stateNull, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage().contains(\"valid host:port authority:\"));\n    }\n    // Port is not an integer for clientRMService\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            addressWrongPort, rmAdminServiceAddress, rmWebServiceAddress,\n            lastHeartBeat, stateNull, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage().contains(\"valid host:port authority:\"));\n    }\n    // Port is not an integer for rmAdminService\n    subClusterInfo =\n        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,\n            clientRMServiceAddress, addressWrongPort, rmWebServiceAddress,\n            lastHeartBeat, stateNull, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage().contains(\"valid host:port authority:\"));\n    }\n    // Port is not an integer for rmWebService\n    subClusterInfo = SubClusterInfo.newInstance(subClusterId,\n        amRMServiceAddress, clientRMServiceAddress, rmAdminServiceAddress,\n        addressWrongPort, lastHeartBeat, stateNull, lastStartTime, capability);\n    try {\n      SubClusterRegisterRequest request =\n          SubClusterRegisterRequest.newInstance(subClusterInfo);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage().contains(\"valid host:port authority:\"));\n    }\n  }\n  @Test\n  public void testValidateSubClusterDeregisterRequest() {\n    // Execution with valid inputs\n    try {\n      SubClusterDeregisterRequest request =\n          SubClusterDeregisterRequest.newInstance(subClusterId, stateLost);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n    // Execution with null request\n    try {\n      SubClusterDeregisterRequest request = null;\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubClusterDeregister Request.\"));\n    }\n    // Execution with null SubClusterId\n    try {\n      SubClusterDeregisterRequest request =\n          SubClusterDeregisterRequest.newInstance(subClusterIdNull, stateLost);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster Id information.\"));\n    }\n    // Execution with invalid SubClusterId\n    try {\n      SubClusterDeregisterRequest request = SubClusterDeregisterRequest\n          .newInstance(subClusterIdInvalid, stateLost);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid SubCluster Id information.\"));\n    }\n    // Execution with null SubClusterState\n    try {\n      SubClusterDeregisterRequest request =\n          SubClusterDeregisterRequest.newInstance(subClusterId, stateNull);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster State information.\"));\n    }\n    // Execution with invalid SubClusterState\n    try {\n      SubClusterDeregisterRequest request =\n          SubClusterDeregisterRequest.newInstance(subClusterId, stateNew);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(e.getMessage().startsWith(\"Invalid non-final state: \"));\n    }\n  }\n  @Test\n  public void testSubClusterHeartbeatRequest() {\n    // Execution with valid inputs\n    try {\n      SubClusterHeartbeatRequest request = SubClusterHeartbeatRequest\n          .newInstance(subClusterId, lastHeartBeat, stateLost, capability);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n    // Execution with null request\n    try {\n      SubClusterHeartbeatRequest request = null;\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubClusterHeartbeat Request.\"));\n    }\n    // Execution with null SubClusterId\n    try {\n      SubClusterHeartbeatRequest request = SubClusterHeartbeatRequest\n          .newInstance(subClusterIdNull, lastHeartBeat, stateLost, capability);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster Id information.\"));\n    }\n    // Execution with invalid SubClusterId\n    try {\n      SubClusterHeartbeatRequest request =\n          SubClusterHeartbeatRequest.newInstance(subClusterIdInvalid,\n              lastHeartBeat, stateLost, capability);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid SubCluster Id information.\"));\n    }\n    // Execution with null SubClusterState\n    try {\n      SubClusterHeartbeatRequest request = SubClusterHeartbeatRequest\n          .newInstance(subClusterId, lastHeartBeat, stateNull, capability);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster State information.\"));\n    }\n    // Execution with negative Last Heartbeat\n    try {\n      SubClusterHeartbeatRequest request =\n          SubClusterHeartbeatRequest.newInstance(subClusterId,\n              lastHeartBeatNegative, stateLost, capability);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid timestamp information.\"));\n    }\n    // Execution with null Capability\n    try {\n      SubClusterHeartbeatRequest request = SubClusterHeartbeatRequest\n          .newInstance(subClusterId, lastHeartBeat, stateLost, capabilityNull);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid capability information.\"));\n    }\n    // Execution with empty Capability\n    try {\n      SubClusterHeartbeatRequest request = SubClusterHeartbeatRequest\n          .newInstance(subClusterId, lastHeartBeat, stateLost, capabilityEmpty);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid capability information.\"));\n    }\n  }\n  @Test\n  public void testGetSubClusterInfoRequest() {\n    // Execution with valid inputs\n    try {\n      GetSubClusterInfoRequest request =\n          GetSubClusterInfoRequest.newInstance(subClusterId);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n    // Execution with null request\n    try {\n      GetSubClusterInfoRequest request = null;\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing GetSubClusterInfo Request.\"));\n    }\n    // Execution with null SubClusterId\n    try {\n      GetSubClusterInfoRequest request =\n          GetSubClusterInfoRequest.newInstance(subClusterIdNull);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster Id information.\"));\n    }\n    // Execution with invalid SubClusterId\n    try {\n      GetSubClusterInfoRequest request =\n          GetSubClusterInfoRequest.newInstance(subClusterIdInvalid);\n      FederationMembershipStateStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid SubCluster Id information.\"));\n    }\n  }\n  @Test\n  public void testAddApplicationHomeSubClusterRequest() {\n    // Execution with valid inputs\n    ApplicationHomeSubCluster applicationHomeSubCluster =\n        ApplicationHomeSubCluster.newInstance(appId, subClusterId);\n    try {\n      AddApplicationHomeSubClusterRequest request =\n          AddApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n    // Execution with null request\n    try {\n      AddApplicationHomeSubClusterRequest request = null;\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing AddApplicationHomeSubCluster Request.\"));\n    }\n    // Execution with null ApplicationHomeSubCluster\n    applicationHomeSubCluster = null;\n    try {\n      AddApplicationHomeSubClusterRequest request =\n          AddApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing ApplicationHomeSubCluster Info.\"));\n    }\n    // Execution with null SubClusterId\n    applicationHomeSubCluster =\n        ApplicationHomeSubCluster.newInstance(appId, subClusterIdNull);\n    try {\n      AddApplicationHomeSubClusterRequest request =\n          AddApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster Id information.\"));\n    }\n    // Execution with invalid SubClusterId\n    applicationHomeSubCluster =\n        ApplicationHomeSubCluster.newInstance(appId, subClusterIdInvalid);\n    try {\n      AddApplicationHomeSubClusterRequest request =\n          AddApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid SubCluster Id information.\"));\n    }\n    // Execution with Null ApplicationId\n    applicationHomeSubCluster =\n        ApplicationHomeSubCluster.newInstance(appIdNull, subClusterId);\n    try {\n      AddApplicationHomeSubClusterRequest request =\n          AddApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Application Id.\"));\n    }\n  }\n  @Test\n  public void testUpdateApplicationHomeSubClusterRequest() {\n    // Execution with valid inputs\n    ApplicationHomeSubCluster applicationHomeSubCluster =\n        ApplicationHomeSubCluster.newInstance(appId, subClusterId);\n    try {\n      UpdateApplicationHomeSubClusterRequest request =\n          UpdateApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n    // Execution with null request\n    try {\n      UpdateApplicationHomeSubClusterRequest request = null;\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing UpdateApplicationHomeSubCluster Request.\"));\n    }\n    // Execution with null ApplicationHomeSubCluster\n    applicationHomeSubCluster = null;\n    try {\n      UpdateApplicationHomeSubClusterRequest request =\n          UpdateApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing ApplicationHomeSubCluster Info.\"));\n    }\n    // Execution with null SubClusteId\n    applicationHomeSubCluster =\n        ApplicationHomeSubCluster.newInstance(appId, subClusterIdNull);\n    try {\n      UpdateApplicationHomeSubClusterRequest request =\n          UpdateApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubCluster Id information.\"));\n    }\n    // Execution with invalid SubClusterId\n    applicationHomeSubCluster =\n        ApplicationHomeSubCluster.newInstance(appId, subClusterIdInvalid);\n    try {\n      UpdateApplicationHomeSubClusterRequest request =\n          UpdateApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      LOG.info(e.getMessage());\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Invalid SubCluster Id information.\"));\n    }\n    // Execution with null ApplicationId\n    applicationHomeSubCluster =\n        ApplicationHomeSubCluster.newInstance(appIdNull, subClusterId);\n    try {\n      UpdateApplicationHomeSubClusterRequest request =\n          UpdateApplicationHomeSubClusterRequest\n              .newInstance(applicationHomeSubCluster);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Application Id.\"));\n    }\n  }\n  @Test\n  public void testGetApplicationHomeSubClusterRequest() {\n    // Execution with valid inputs\n    try {\n      GetApplicationHomeSubClusterRequest request =\n          GetApplicationHomeSubClusterRequest.newInstance(appId);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n    // Execution with null request\n    try {\n      GetApplicationHomeSubClusterRequest request = null;\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing GetApplicationHomeSubCluster Request.\"));\n    }\n    // Execution with null ApplicationId\n    try {\n      GetApplicationHomeSubClusterRequest request =\n          GetApplicationHomeSubClusterRequest.newInstance(appIdNull);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Application Id.\"));\n    }\n  }\n  @Test\n  public void testDeleteApplicationHomeSubClusterRequestNull() {\n    // Execution with valid inputs\n    try {\n      DeleteApplicationHomeSubClusterRequest request =\n          DeleteApplicationHomeSubClusterRequest.newInstance(appId);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n    // Execution with null request\n    try {\n      DeleteApplicationHomeSubClusterRequest request = null;\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing DeleteApplicationHomeSubCluster Request.\"));\n    }\n    // Execution with null ApplicationId\n    try {\n      DeleteApplicationHomeSubClusterRequest request =\n          DeleteApplicationHomeSubClusterRequest.newInstance(appIdNull);\n      FederationApplicationHomeSubClusterStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Application Id.\"));\n    }\n  }\n  @Test\n  public void testGetSubClusterPolicyConfigurationRequest() {\n    // Execution with valid inputs\n    try {\n      GetSubClusterPolicyConfigurationRequest request =\n          GetSubClusterPolicyConfigurationRequest.newInstance(queue);\n      FederationPolicyStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n    // Execution with null request\n    try {\n      GetSubClusterPolicyConfigurationRequest request = null;\n      FederationPolicyStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing GetSubClusterPolicyConfiguration Request.\"));\n    }\n    // Execution with null queue id\n    try {\n      GetSubClusterPolicyConfigurationRequest request =\n          GetSubClusterPolicyConfigurationRequest.newInstance(queueNull);\n      FederationPolicyStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Queue.\"));\n    }\n    // Execution with empty queue id\n    try {\n      GetSubClusterPolicyConfigurationRequest request =\n          GetSubClusterPolicyConfigurationRequest.newInstance(queueEmpty);\n      FederationPolicyStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Queue.\"));\n    }\n  }\n  @Test\n  public void testSetSubClusterPolicyConfigurationRequest() {\n    // Execution with valid inputs\n    try {\n      SubClusterPolicyConfiguration policy =\n          SubClusterPolicyConfiguration.newInstance(queue, type, params);\n      SetSubClusterPolicyConfigurationRequest request =\n          SetSubClusterPolicyConfigurationRequest.newInstance(policy);\n      FederationPolicyStoreInputValidator\n          .validate(request);\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.fail(e.getMessage());\n    }\n    // Execution with null request\n    try {\n      SetSubClusterPolicyConfigurationRequest request = null;\n      FederationPolicyStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage()\n          .startsWith(\"Missing SetSubClusterPolicyConfiguration Request.\"));\n    }\n    // Execution with null SubClusterPolicyConfiguration\n    try {\n      SubClusterPolicyConfiguration policy = null;\n      SetSubClusterPolicyConfigurationRequest request =\n          SetSubClusterPolicyConfigurationRequest.newInstance(policy);\n      FederationPolicyStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(\n          e.getMessage().startsWith(\"Missing SubClusterPolicyConfiguration.\"));\n    }\n    // Execution with null queue id\n    try {\n      SubClusterPolicyConfiguration policy =\n          SubClusterPolicyConfiguration.newInstance(queueNull, type, params);\n      SetSubClusterPolicyConfigurationRequest request =\n          SetSubClusterPolicyConfigurationRequest.newInstance(policy);\n      FederationPolicyStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Queue.\"));\n    }\n    // Execution with empty queue id\n    try {\n      SubClusterPolicyConfiguration policy =\n          SubClusterPolicyConfiguration.newInstance(queueEmpty, type, params);\n      SetSubClusterPolicyConfigurationRequest request =\n          SetSubClusterPolicyConfigurationRequest.newInstance(policy);\n      FederationPolicyStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Queue.\"));\n    }\n    // Execution with null policy type\n    try {\n      SubClusterPolicyConfiguration policy =\n          SubClusterPolicyConfiguration.newInstance(queue, typeNull, params);\n      SetSubClusterPolicyConfigurationRequest request =\n          SetSubClusterPolicyConfigurationRequest.newInstance(policy);\n      FederationPolicyStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Policy Type.\"));\n    }\n    // Execution with empty policy type\n    try {\n      SubClusterPolicyConfiguration policy =\n          SubClusterPolicyConfiguration.newInstance(queue, typeEmpty, params);\n      SetSubClusterPolicyConfigurationRequest request =\n          SetSubClusterPolicyConfigurationRequest.newInstance(policy);\n      FederationPolicyStoreInputValidator\n          .validate(request);\n      Assert.fail();\n    } catch (FederationStateStoreInvalidInputException e) {\n      Assert.assertTrue(e.getMessage().startsWith(\"Missing Policy Type.\"));\n    }\n  }\n"]], "pred": {"ppl": 1.620609164237976, "ppl_lower": 1.81346595287323, "ppl/lowercase_ppl": -1.232885892713991, "ppl/zlib": 0.00020927702898618786, "Min_5.0% Prob": 5.40890004120621, "Min_10.0% Prob": 3.7591276040264203, "Min_20.0% Prob": 2.271780291316556, "Min_30.0% Prob": 1.5838928769275644, "Min_40.0% Prob": 1.2009653067239048, "Min_50.0% Prob": 0.9650508014452434, "Min_60.0% Prob": 0.8053837610810515}}
{"hexsha": "8fe234960f05cc9705af00e1e9e5d2b0274e7a2c", "ext": "java", "lang": "Java", "content": "@Service\npublic class GeocoderService {\n    private static final String KEY = \"AIzaSyDw_d6dfxDEI7MAvqfGXEIsEMwjC1PWRno\";\n\n    private final WebClient client;\n\n    public GeocoderService(WebClient.Builder builder) {\n        client = builder.baseUrl(\"https://maps.googleapis.com\")\n                .build();\n    }\n\n    public Castle fillInLatLng(Castle castle) {\n        String encoded = Stream.of(castle.getCity(), castle.getState())\n                .map(s -> URLEncoder.encode(s, StandardCharsets.UTF_8))\n                .collect(Collectors.joining(\",\"));\n        Response response = client.get()\n                .uri((uriBuilder -> uriBuilder.path(\"/maps/api/geocode/json\")\n                        .queryParam(\"address\", encoded)\n                        .queryParam(\"key\", KEY)\n                        .build()\n                ))\n                .retrieve()\n                .bodyToMono(Response.class)\n                .block(Duration.ofSeconds(2L));\n        if (response != null) {\n            castle.setLatitude(response.getLocation().getLat());\n            castle.setLongitude(response.getLocation().getLng());\n        }\n        return castle;\n    }\n}", "item_id": 0, "repo": "VestiDev/spring-data-fundamentals-questjpa", "file": "src/main/java/com/oreilly/quest/services/GeocoderService.java", "last_update_at": "2022-01-21T11:19:10+00:00", "question_id": "8fe234960f05cc9705af00e1e9e5d2b0274e7a2c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class GeocoderService {\n    private static final String KEY = \"AIzaSyDw_d6dfxDEI7MAvqfGXEIsEMwjC1PWRno\";\n    private final WebClient client;\n    public GeocoderService(WebClient.Builder builder) {\n        client = builder.baseUrl(\"https://maps.googleapis.com\")\n                .build();\n    }\n    public Castle fillInLatLng(Castle castle) {\n        String encoded = Stream.of(castle.getCity(), castle.getState())\n                .map(s -> URLEncoder.encode(s, StandardCharsets.UTF_8))\n                .collect(Collectors.joining(\",\"));\n        Response response = client.get()\n                .uri((uriBuilder -> uriBuilder.path(\"/maps/api/geocode/json\")\n                        .queryParam(\"address\", encoded)\n                        .queryParam(\"key\", KEY)\n                        .build()\n                ))\n                .retrieve()\n                .bodyToMono(Response.class)\n                .block(Duration.ofSeconds(2L));\n        if (response != null) {\n            castle.setLatitude(response.getLocation().getLat());\n            castle.setLongitude(response.getLocation().getLng());\n        }\n        return castle;\n    }\n"]], "pred": {"ppl": 2.6210598945617676, "ppl_lower": 3.636478900909424, "ppl/lowercase_ppl": -1.3398135273238174, "ppl/zlib": 0.001838890793660056, "Min_5.0% Prob": 8.373200829823812, "Min_10.0% Prob": 6.347980576176798, "Min_20.0% Prob": 4.364360692009093, "Min_30.0% Prob": 3.1491170541236273, "Min_40.0% Prob": 2.399279561744431, "Min_50.0% Prob": 1.928778409243286, "Min_60.0% Prob": 1.6084175993449479}}
{"hexsha": "2f5561f6ce3943600beaddf87b4fd1d3011cf09c", "ext": "java", "lang": "Java", "content": "public class RemindersAppTestsInit {\n\n    @BeforeClass(alwaysRun = true)\n    public void setUp() {\n        initMobile(RemindersApp.class);\n        AppiumDriver driver = (AppiumDriver) getDriver();\n        driver.launchApp();\n        logger.toLog(\"Run Reminders App Tests\");\n    }\n\n    @BeforeMethod(alwaysRun = true)\n    public void continueThroughWelcomePage() {\n        if (RemindersApp.continueButton.isDisplayed())\n            RemindersApp.continueButton.click();\n    }\n\n    @AfterMethod(alwaysRun = true)\n    public void resetApp() {\n        AppManager.resetApp();\n    }\n\n    @AfterClass(alwaysRun = true)\n    public void tearDown() {\n        WebDriverFactory.quit();\n    }\n}", "item_id": 0, "repo": "StrikS/jdi-light", "file": "jdi-light-mobile-tests/src/test/java/nativeapp_ios/RemindersAppTestsInit.java", "last_update_at": "2022-03-22T16:30:59+00:00", "question_id": "2f5561f6ce3943600beaddf87b4fd1d3011cf09c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RemindersAppTestsInit {\n    @BeforeClass(alwaysRun = true)\n    public void setUp() {\n        initMobile(RemindersApp.class);\n        AppiumDriver driver = (AppiumDriver) getDriver();\n        driver.launchApp();\n        logger.toLog(\"Run Reminders App Tests\");\n    }\n    @BeforeMethod(alwaysRun = true)\n    public void continueThroughWelcomePage() {\n        if (RemindersApp.continueButton.isDisplayed())\n            RemindersApp.continueButton.click();\n    }\n    @AfterMethod(alwaysRun = true)\n    public void resetApp() {\n        AppManager.resetApp();\n    }\n    @AfterClass(alwaysRun = true)\n    public void tearDown() {\n        WebDriverFactory.quit();\n    }\n"]], "pred": {"ppl": 2.7428336143493652, "ppl_lower": 3.5267586708068848, "ppl/lowercase_ppl": -1.2491474514866094, "ppl/zlib": 0.0034436571735148003, "Min_5.0% Prob": 8.02368860244751, "Min_10.0% Prob": 6.544561111927033, "Min_20.0% Prob": 4.354911002516746, "Min_30.0% Prob": 3.2026105453570684, "Min_40.0% Prob": 2.487912108376622, "Min_50.0% Prob": 2.001567325600893, "Min_60.0% Prob": 1.6797161722201701}}
{"hexsha": "15ad78e5472a8c012961055bbc9a24c9d8373779", "ext": "java", "lang": "Java", "content": "class LanguagesHighlightsLayer extends AbstractHighlightsContainer {\n\n    private Document document;\n    \n    LanguagesHighlightsLayer (Document document) {\n        this.document = document;\n    }\n\n    public HighlightsSequence getHighlights (int startOffset, int endOffset) {\n        TokenSequence seq = TokenHierarchy.get (document).tokenSequence();\n        if (seq != null) {\n            return new Highlights (seq, startOffset, endOffset); //NOI18N\n        } else {\n            return HighlightsSequence.EMPTY;\n        }\n    }\n\n    \n    private static class Highlights implements HighlightsSequence {\n\n        private int                 endOffset;\n        private int                 startOffset1;\n        private int                 endOffset1;\n        private SimpleAttributeSet  attributeSet;\n        private TokenSequence       tokenSequence;\n        private String              mimeType;\n        \n        \n        private Highlights (TokenSequence tokenSequence, int startOffset, int endOffset) {\n            this.tokenSequence = tokenSequence;\n            this.mimeType = tokenSequence.language().mimeType();\n            this.endOffset = endOffset;\n            startOffset1 = startOffset;\n            endOffset1 = startOffset;\n        }\n        \n        public boolean moveNext () {\n            if (tokenSequence == null) return false;\n            attributeSet = new SimpleAttributeSet ();\n            do {\n                startOffset1 = endOffset1;\n                mark (tokenSequence);\n                if (endOffset1 > startOffset1) return true;\n                tokenSequence.move (startOffset1);\n                if (!tokenSequence.moveNext ()) return false;\n                Token token = tokenSequence.token ();\n                endOffset1 = tokenSequence.offset () + token.length ();\n            } while (endOffset1 < endOffset);\n            return false;\n        }\n\n        public int getStartOffset () {\n            return startOffset1;\n        }\n\n        public int getEndOffset () {\n            return endOffset1;\n        }\n\n        public AttributeSet getAttributes () {\n            return attributeSet;\n        }\n\n        private void mark (TokenSequence ts) {\n            ts.move (startOffset1);\n            if (!ts.moveNext ()) return;\n            Token token = ts.token ();\n            TokenSequence ts2 = ts.embedded ();\n            if (ts2 == null) return;\n            String mimeTypeOut = ts.language ().mimeType ();\n            String mimeTypeIn = ts2.language ().mimeType ();\n            if (token.id ().name ().equals (SLexer.EMBEDDING_TOKEN_TYPE_NAME)) {\n                Color c = getPreprocessorImportsColor (mimeTypeIn);\n                if (c != null) {\n                    attributeSet.addAttribute (StyleConstants.Background, c);\n                    attributeSet.addAttribute (HighlightsContainer.ATTR_EXTENDS_EOL, Boolean.TRUE);\n                    endOffset1 = tokenSequence.offset () + token.length ();\n                }\n            } else\n            if (!mimeTypeOut.equals (mimeTypeIn)) {\n                Color c = getTokenImportsColor (mimeTypeOut, mimeTypeIn, token.id ().name ());\n                if (c != null) {\n                    attributeSet.addAttribute (StyleConstants.Background, c);\n                    attributeSet.addAttribute (HighlightsContainer.ATTR_EXTENDS_EOL, Boolean.TRUE);\n                    endOffset1 = tokenSequence.offset () + token.length ();\n                }\n            }\n            mark (ts2);\n        }\n\n        private Map<String,Map<String,Color>> tokenImportColors = new HashMap<String,Map<String,Color>> ();\n\n        private Color getPreprocessorImportsColor (String mimeTypeIn) {\n            if (preprocessorImportColors == null) {\n                preprocessorImportColors = new HashMap<String,Color> ();\n                try {\n                    Language l = LanguagesManager.getDefault ().\n                        getLanguage (mimeType);\n                    Feature properties = l.getPreprocessorImport ();\n                    if (properties != null) {\n                        String mimeType = (String) properties.getValue (\"mimeType\");\n                        Color color = ColorsManager.readColor (\n                            (String) properties.getValue (\"background_color\")\n                        );\n                        if (color != null)\n                            preprocessorImportColors.put (mimeType, color);\n                    }\n                } catch (ParseException ex) {\n                }\n            }\n            return preprocessorImportColors.get (mimeTypeIn);\n        }\n\n        private Map<String,Color> preprocessorImportColors;\n\n        private Color getTokenImportsColor (String mimeTypeOut, String mimeTypeIn, String tokenTypeIn) {\n            Map<String,Color> m = tokenImportColors.get (mimeTypeOut);\n            if (m == null) {\n                m = new HashMap<String,Color> ();\n                tokenImportColors.put (mimeTypeOut, m);\n                try {\n                    Language l = LanguagesManager.getDefault ().\n                        getLanguage (mimeTypeOut);\n                    Map<String,Feature> m2 = l.getTokenImports ();\n                    Iterator<String> it = m2.keySet ().iterator ();\n                    while (it.hasNext ()) {\n                        String tokenType = it.next ();\n                        Feature properties = m2.get (tokenType);\n                        Color color = ColorsManager.readColor (\n                            (String) properties.getValue (\"background_color\")\n                        );\n                        if (color != null)\n                            m.put (tokenType, color);\n                    }\n                } catch (LanguageDefinitionNotFoundException ex) {\n                }\n            }\n            if (m.containsKey (tokenTypeIn))\n                return m.get (tokenTypeIn);\n            return m.get (mimeTypeIn);\n        }\n    }\n}", "item_id": 0, "repo": "timfel/netbeans", "file": "ide/languages/src/org/netbeans/modules/languages/features/LanguagesHighlightsLayer.java", "last_update_at": "2022-03-30T04:46:14+00:00", "question_id": "15ad78e5472a8c012961055bbc9a24c9d8373779_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class LanguagesHighlightsLayer extends AbstractHighlightsContainer {\n    private Document document;\n    LanguagesHighlightsLayer (Document document) {\n        this.document = document;\n    }\n    public HighlightsSequence getHighlights (int startOffset, int endOffset) {\n        TokenSequence seq = TokenHierarchy.get (document).tokenSequence();\n        if (seq != null) {\n            return new Highlights (seq, startOffset, endOffset); //NOI18N\n        } else {\n            return HighlightsSequence.EMPTY;\n        }\n    }\n    private static class Highlights implements HighlightsSequence {\n        private int                 endOffset;\n        private int                 startOffset1;\n        private int                 endOffset1;\n        private SimpleAttributeSet  attributeSet;\n        private TokenSequence       tokenSequence;\n        private String              mimeType;\n        private Highlights (TokenSequence tokenSequence, int startOffset, int endOffset) {\n            this.tokenSequence = tokenSequence;\n            this.mimeType = tokenSequence.language().mimeType();\n            this.endOffset = endOffset;\n            startOffset1 = startOffset;\n            endOffset1 = startOffset;\n        }\n        public boolean moveNext () {\n            if (tokenSequence == null) return false;\n            attributeSet = new SimpleAttributeSet ();\n            do {\n                startOffset1 = endOffset1;\n                mark (tokenSequence);\n                if (endOffset1 > startOffset1) return true;\n                tokenSequence.move (startOffset1);\n                if (!tokenSequence.moveNext ()) return false;\n                Token token = tokenSequence.token ();\n                endOffset1 = tokenSequence.offset () + token.length ();\n            } while (endOffset1 < endOffset);\n            return false;\n        }\n        public int getStartOffset () {\n            return startOffset1;\n        }\n        public int getEndOffset () {\n            return endOffset1;\n        }\n        public AttributeSet getAttributes () {\n            return attributeSet;\n        }\n        private void mark (TokenSequence ts) {\n            ts.move (startOffset1);\n            if (!ts.moveNext ()) return;\n            Token token = ts.token ();\n            TokenSequence ts2 = ts.embedded ();\n            if (ts2 == null) return;\n            String mimeTypeOut = ts.language ().mimeType ();\n            String mimeTypeIn = ts2.language ().mimeType ();\n            if (token.id ().name ().equals (SLexer.EMBEDDING_TOKEN_TYPE_NAME)) {\n                Color c = getPreprocessorImportsColor (mimeTypeIn);\n                if (c != null) {\n                    attributeSet.addAttribute (StyleConstants.Background, c);\n                    attributeSet.addAttribute (HighlightsContainer.ATTR_EXTENDS_EOL, Boolean.TRUE);\n                    endOffset1 = tokenSequence.offset () + token.length ();\n                }\n            } else\n            if (!mimeTypeOut.equals (mimeTypeIn)) {\n                Color c = getTokenImportsColor (mimeTypeOut, mimeTypeIn, token.id ().name ());\n                if (c != null) {\n                    attributeSet.addAttribute (StyleConstants.Background, c);\n                    attributeSet.addAttribute (HighlightsContainer.ATTR_EXTENDS_EOL, Boolean.TRUE);\n                    endOffset1 = tokenSequence.offset () + token.length ();\n                }\n            }\n            mark (ts2);\n        }\n        private Map<String,Map<String,Color>> tokenImportColors = new HashMap<String,Map<String,Color>> ();\n        private Color getPreprocessorImportsColor (String mimeTypeIn) {\n            if (preprocessorImportColors == null) {\n                preprocessorImportColors = new HashMap<String,Color> ();\n                try {\n                    Language l = LanguagesManager.getDefault ().\n                        getLanguage (mimeType);\n                    Feature properties = l.getPreprocessorImport ();\n                    if (properties != null) {\n                        String mimeType = (String) properties.getValue (\"mimeType\");\n                        Color color = ColorsManager.readColor (\n                            (String) properties.getValue (\"background_color\")\n                        );\n                        if (color != null)\n                            preprocessorImportColors.put (mimeType, color);\n                    }\n                } catch (ParseException ex) {\n                }\n            }\n            return preprocessorImportColors.get (mimeTypeIn);\n        }\n        private Map<String,Color> preprocessorImportColors;\n        private Color getTokenImportsColor (String mimeTypeOut, String mimeTypeIn, String tokenTypeIn) {\n            Map<String,Color> m = tokenImportColors.get (mimeTypeOut);\n            if (m == null) {\n                m = new HashMap<String,Color> ();\n                tokenImportColors.put (mimeTypeOut, m);\n                try {\n                    Language l = LanguagesManager.getDefault ().\n                        getLanguage (mimeTypeOut);\n                    Map<String,Feature> m2 = l.getTokenImports ();\n                    Iterator<String> it = m2.keySet ().iterator ();\n                    while (it.hasNext ()) {\n                        String tokenType = it.next ();\n                        Feature properties = m2.get (tokenType);\n                        Color color = ColorsManager.readColor (\n                            (String) properties.getValue (\"background_color\")\n                        );\n                        if (color != null)\n                            m.put (tokenType, color);\n                    }\n                } catch (LanguageDefinitionNotFoundException ex) {\n                }\n            }\n            if (m.containsKey (tokenTypeIn))\n                return m.get (tokenTypeIn);\n            return m.get (mimeTypeIn);\n        }\n    }\n"]], "pred": {"ppl": 1.8811619281768799, "ppl_lower": 2.202699661254883, "ppl/lowercase_ppl": -1.249717807969552, "ppl/zlib": 0.0004913605231976084, "Min_5.0% Prob": 6.343238199458403, "Min_10.0% Prob": 4.554120921621136, "Min_20.0% Prob": 2.8720768172951305, "Min_30.0% Prob": 2.0459228373723093, "Min_40.0% Prob": 1.5643724220597657, "Min_50.0% Prob": 1.2602434511790361, "Min_60.0% Prob": 1.0529057693760386}}
{"hexsha": "061eb84ea711d2b46d85f4f5b292ea03238d4daa", "ext": "java", "lang": "Java", "content": "class QuestionTest {\n\n    @Test\n    @DisplayName(\"[Question, \uc0dd\uc131] \ubb38\uc81c\")\n    void createQuestion() {\n        //given\n        Workbook workbook = Workbook.builder()\n                .memberId(1L)\n                .title(\"\uc6b4\uc601\uccb4\uc81c 5\uc8fc\ucc28\")\n                .description(\"\uc6b4\uc601\uccb4\uc81c \uc911\uac04\uace0\uc0ac \ub300\ube44\")\n                .build();\n\n        Commentary commentary = Commentary.builder()\n                .comment(\"\ubb38\uc81c\uc5d0 \ub300\ud55c \ud574\uc124 \uc800\uc7a5\")\n                .build();\n\n        //when\n        Question question = Question.builder()\n                .title(\"\ub2e4\uc74c \ubcf4\uae30 \uc911 \uc54c\ub9de\uc740 \uac83\uc744 \uace0\ub974\uc138\uc694.\")\n                .content(\"\ubcf4\uae30\ub85c \uc8fc\uc5b4\uc9c8 \uc0c1\ud669\uc774\ub098 \ub300\ud654\uac00 \ub4e4\uc5b4\uac08 \uc790\ub9ac\")\n                .category(Category.SHORT)\n                .commentary(commentary)\n                .workbook(workbook)\n                .build();\n\n        //then\n        assertThat(question).isInstanceOf(Question.class);\n        assertThat(question.getTitle()).isEqualTo(\"\ub2e4\uc74c \ubcf4\uae30 \uc911 \uc54c\ub9de\uc740 \uac83\uc744 \uace0\ub974\uc138\uc694.\");\n        assertThat(question.getContent()).isEqualTo(\"\ubcf4\uae30\ub85c \uc8fc\uc5b4\uc9c8 \uc0c1\ud669\uc774\ub098 \ub300\ud654\uac00 \ub4e4\uc5b4\uac08 \uc790\ub9ac\");\n        assertThat(question.getCategory()).isEqualTo(Category.SHORT);\n\n        assertThat(question.getCommentary().getComment()).isEqualTo(commentary.getComment());\n        assertThat(question.getWorkbook().getTitle()).isEqualTo(workbook.getTitle());\n    }\n\n}", "item_id": 0, "repo": "capstone-information-communication/study-with-deeplearning", "file": "backend/src/test/java/core/backend/question/domain/QuestionTest.java", "last_update_at": "2022-03-31T05:40:12+00:00", "question_id": "061eb84ea711d2b46d85f4f5b292ea03238d4daa_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class QuestionTest {\n    @Test\n    @DisplayName(\"[Question, \uc0dd\uc131] \ubb38\uc81c\")\n    void createQuestion() {\n        //given\n        Workbook workbook = Workbook.builder()\n                .memberId(1L)\n                .title(\"\uc6b4\uc601\uccb4\uc81c 5\uc8fc\ucc28\")\n                .description(\"\uc6b4\uc601\uccb4\uc81c \uc911\uac04\uace0\uc0ac \ub300\ube44\")\n                .build();\n        Commentary commentary = Commentary.builder()\n                .comment(\"\ubb38\uc81c\uc5d0 \ub300\ud55c \ud574\uc124 \uc800\uc7a5\")\n                .build();\n        //when\n        Question question = Question.builder()\n                .title(\"\ub2e4\uc74c \ubcf4\uae30 \uc911 \uc54c\ub9de\uc740 \uac83\uc744 \uace0\ub974\uc138\uc694.\")\n                .content(\"\ubcf4\uae30\ub85c \uc8fc\uc5b4\uc9c8 \uc0c1\ud669\uc774\ub098 \ub300\ud654\uac00 \ub4e4\uc5b4\uac08 \uc790\ub9ac\")\n                .category(Category.SHORT)\n                .commentary(commentary)\n                .workbook(workbook)\n                .build();\n        //then\n        assertThat(question).isInstanceOf(Question.class);\n        assertThat(question.getTitle()).isEqualTo(\"\ub2e4\uc74c \ubcf4\uae30 \uc911 \uc54c\ub9de\uc740 \uac83\uc744 \uace0\ub974\uc138\uc694.\");\n        assertThat(question.getContent()).isEqualTo(\"\ubcf4\uae30\ub85c \uc8fc\uc5b4\uc9c8 \uc0c1\ud669\uc774\ub098 \ub300\ud654\uac00 \ub4e4\uc5b4\uac08 \uc790\ub9ac\");\n        assertThat(question.getCategory()).isEqualTo(Category.SHORT);\n        assertThat(question.getCommentary().getComment()).isEqualTo(commentary.getComment());\n        assertThat(question.getWorkbook().getTitle()).isEqualTo(workbook.getTitle());\n    }\n"]], "pred": {"ppl": 1.99930739402771, "ppl_lower": 2.3940327167510986, "ppl/lowercase_ppl": -1.2600725215874433, "ppl/zlib": 0.001297379808234221, "Min_5.0% Prob": 6.334759127009999, "Min_10.0% Prob": 4.803057529709556, "Min_20.0% Prob": 3.13807672533122, "Min_30.0% Prob": 2.258721689834739, "Min_40.0% Prob": 1.7287139791190962, "Min_50.0% Prob": 1.3832588235919292, "Min_60.0% Prob": 1.1549097925670586}}
{"hexsha": "295e757ccd9b473d77b2a3f31aaf1e984a636358", "ext": "java", "lang": "Java", "content": "public class OldHostSupplierAdapter implements Supplier<List<Host>> {\n    private final Supplier<Map<BigInteger, List<Host>>> source;\n    \n    public OldHostSupplierAdapter(Supplier<Map<BigInteger, List<Host>>> source) {\n        this.source = source;\n    }\n    \n    @Override\n    public List<Host> get() {\n        Map<BigInteger, List<Host>> tokenHostMap = source.get();\n        Set<Host> hosts = Sets.newHashSet();\n        for (Entry<BigInteger, List<Host>> entry : tokenHostMap.entrySet()) { \n            for (Host host : entry.getValue()) {\n                if (!hosts.contains(host)) {\n                    hosts.add(host);\n                }\n                \n                String token = entry.getKey().toString();\n                host.getTokenRanges().add(new TokenRangeImpl(token, token, null));\n            }\n        }\n        return Lists.newArrayList(hosts);\n    }\n\n}", "item_id": 0, "repo": "Netflix/astyanax", "file": "astyanax-core/src/main/java/com/netflix/astyanax/connectionpool/impl/OldHostSupplierAdapter.java", "last_update_at": "2022-03-29T16:25:01+00:00", "question_id": "295e757ccd9b473d77b2a3f31aaf1e984a636358_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OldHostSupplierAdapter implements Supplier<List<Host>> {\n    private final Supplier<Map<BigInteger, List<Host>>> source;\n    public OldHostSupplierAdapter(Supplier<Map<BigInteger, List<Host>>> source) {\n        this.source = source;\n    }\n    @Override\n    public List<Host> get() {\n        Map<BigInteger, List<Host>> tokenHostMap = source.get();\n        Set<Host> hosts = Sets.newHashSet();\n        for (Entry<BigInteger, List<Host>> entry : tokenHostMap.entrySet()) { \n            for (Host host : entry.getValue()) {\n                if (!hosts.contains(host)) {\n                    hosts.add(host);\n                }\n                String token = entry.getKey().toString();\n                host.getTokenRanges().add(new TokenRangeImpl(token, token, null));\n            }\n        }\n        return Lists.newArrayList(hosts);\n    }\n"]], "pred": {"ppl": 1.9458132982254028, "ppl_lower": 2.460709571838379, "ppl/lowercase_ppl": -1.3526765127065983, "ppl/zlib": 0.0019128736720077212, "Min_5.0% Prob": 7.511734922726949, "Min_10.0% Prob": 5.120453834533691, "Min_20.0% Prob": 3.129134905834993, "Min_30.0% Prob": 2.1912895643876658, "Min_40.0% Prob": 1.661632536444813, "Min_50.0% Prob": 1.3335711971390993, "Min_60.0% Prob": 1.1129334485449363}}
{"hexsha": "b6dfb9f5d1cd6359d28f7f100320c5ff9bf04764", "ext": "java", "lang": "Java", "content": "public class Alerts extends BaseBlock\n{\n\tprivate int m_nFileFrequency;\n\t/**\n\t * List of rules\n\t */\n\tprivate ArrayList<AlertRule> m_oRules = new ArrayList();\n\n\t/**\n\t * Bounding box of the study area\n\t */\n\tprivate int[] m_nStudyArea;\n\n\tprivate FilenameFormatter m_oFormatter;\n\n\t/**\n\t * Array of obs types needed to evaluate the rules for this block\n\t */\n\tprivate int[] m_nObsTypes;\n\n\t/**\n\t * Length the area arrays need to be based off of the rules for this block\n\t */\n\tprivate int m_nArrayLength;\n\n\t/**\n\t * Reusable array to initial values for a new area\n\t */\n\tprivate long[] m_lInitialValues;\n\n\t/**\n\t * Header for the csv file\n\t */\n\tpublic static final String g_sHEADER = \"ObsType,Source,ObjId,ObsTime1,ObsTime2,TimeRecv,Lat1,Lon1,Lat2,Lon2,Elev,Value,Conf\\n\";\n\n\n\t/**\n\t * Comparator used to compare long arrays that represent areas in this\n\t * block. Compares first by lon1, then lon2, then lat1, then lat2.\n\t */\n\tpublic static final Comparator<long[]> COMPBYAREA = (long[] o1, long[] o2) -> \n\t{\n\t\tint nReturn = Long.compare(o1[2], o2[2]); // compare by lon1\n\t\tif (nReturn == 0)\n\t\t{\n\t\t\tnReturn = Long.compare(o1[3], o2[3]); // then lon2\n\t\t\tif (nReturn == 0)\n\t\t\t{\n\t\t\t\tnReturn = Long.compare(o1[0], o2[0]); // then lat1\n\t\t\t\tif (nReturn == 0)\n\t\t\t\t\tnReturn = Long.compare(o1[1], o2[1]); // then lat2\n\t\t\t}\n\t\t}\n\n\t\treturn nReturn;\n\t};\n\n\n\t/**\n\t * Reads in the rules and creates the necessary objects from the config\n\t * file.\n\t *\n\t * @return true if no errors occur, false otherwise\n\t * @throws Exception\n\t */\n\t@Override\n\tpublic boolean start() throws Exception\n\t{\n\t\tString[] sRules = m_oConfig.getStringArray(\"rules\", null);\n\t\tint nArrayPosition = 5;\n\t\tfor (String sRule : sRules) // for each configured rule create the object\n\t\t{\n\t\t\tString[] sConditions = m_oConfig.getStringArray(sRule, null);\n\t\t\tif (sConditions.length % 4 != 1 || sConditions.length == 0) // rules have this struct {alert type, list of conditions} (conditions have 4 elements each)\n\t\t\t{\n\t\t\t\tm_oLogger.error(\"Incorrect length for rule: \" + sRule);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tAlertRule oAdd = new AlertRule(sConditions, nArrayPosition);\n\t\t\tm_oRules.add(oAdd);\n\t\t\tnArrayPosition += (oAdd.m_oAlgorithm.size() * 2);\n\t\t}\n\t\tm_nArrayLength = nArrayPosition;\n\t\tm_lInitialValues = new long[m_nArrayLength - 5];\n\t\tfor (int i = 0; i < m_lInitialValues.length;)\n\t\t{\n\t\t\tm_lInitialValues[i++] = Long.MAX_VALUE;\n\t\t\tm_lInitialValues[i++] = Long.MIN_VALUE;\n\t\t}\n\t\treturn true;\n\t}\n\n\n\t/**\n\t * Resets are configurable variables\n\t */\n\t@Override\n\tpublic void reset()\n\t{\n\t\tm_nFileFrequency = m_oConfig.getInt(\"freq\", 86400000);\n\t\tm_oFormatter = new FilenameFormatter(m_oConfig.getString(\"format\", \"\"));\n\t\tString[] sObsTypes = m_oConfig.getStringArray(\"obs\", null);\n\t\tm_nObsTypes = new int[sObsTypes.length];\n\t\tfor (int i = 0; i < sObsTypes.length; i++)\n\t\t\tm_nObsTypes[i] = Integer.valueOf(sObsTypes[i], 36);\n\t\tString[] sBox = m_oConfig.getStringArray(\"box\", \"\");\n\t\tm_nStudyArea = new int[4];\n\n\t\tm_nStudyArea[0] = Integer.MAX_VALUE;\n\t\tm_nStudyArea[1] = Integer.MIN_VALUE;\n\t\tm_nStudyArea[2] = Integer.MAX_VALUE;\n\t\tm_nStudyArea[3] = Integer.MIN_VALUE;\n\t\tfor (int i = 0; i < sBox.length;)\n\t\t{\n\t\t\tint nLon = Integer.parseInt(sBox[i++]);\n\t\t\tint nLat = Integer.parseInt(sBox[i++]);\n\n\t\t\tif (nLon < m_nStudyArea[2])\n\t\t\t\tm_nStudyArea[2] = nLon;\n\n\t\t\tif (nLon > m_nStudyArea[3])\n\t\t\t\tm_nStudyArea[3] = nLon;\n\n\t\t\tif (nLat < m_nStudyArea[0])\n\t\t\t\tm_nStudyArea[0] = nLat;\n\n\t\t\tif (nLat > m_nStudyArea[1])\n\t\t\t\tm_nStudyArea[1] = nLat;\n\t\t}\n\t}\n\n\n\t/**\n\t * Processes Notifications received from other blocks.\n\t *\n\t * @param oNotification the received Notification\n\t */\n\t@Override\n\tpublic void process(String[] sMessage)\n\t{\n\t\tif (sMessage[MESSAGE].compareTo(\"new data\") == 0)\n\t\t{\n\t\t\tString sStore = sMessage[FROM];\n\t\t\tlong lStartTime = Long.parseLong(sMessage[2]);\n\t\t\tlong lEndTime = Long.parseLong(sMessage[3]);\n\t\t\tint[] nObsTypes = new int[sMessage.length - 4];\n\t\t\tint nIndex = 0;\n\t\t\tfor (int i = 4; i < sMessage.length; i++)\n\t\t\t\tnObsTypes[nIndex++] = Integer.parseInt(sMessage[i]);\n\t\t\tcreateAlerts(sStore, nObsTypes, lStartTime, lEndTime);\n\t\t}\n\t}\n\n\n\t/**\n\t * Ran when a notification of new data is sent from a data Store. This\n\t * function checks alert rules for the current forecasts in the study area.\n\t * We use a long array for each area that could have an alert. The format of\n\t * the arrays is: [lat1, lat2, lon1, lon2, objId, (pairs of start and end\n\t * times for each condition for each rule)]\n\t */\n\tpublic void createAlerts(String sStore, int[] nObsTypes, long lStartTime, long lEndTime)\n\t{\n\t\ttry\n\t\t{\n\t\t\tSegmentShps oShps = (SegmentShps)Directory.getInstance().lookup(\"SegmentShps\");\n\t\t\tBaseBlock oStore = (BaseBlock)Directory.getInstance().lookup(sStore);\n\t\t\tArrayList<Obs> oAlerts = new ArrayList();\n\t\t\tArrayList<long[]> oAreas = new ArrayList();\n\t\t\tlong[] lSearch = new long[6];\n\n\t\t\tfor (int j = 0; j < nObsTypes.length; j++) // for each obs type\n\t\t\t{\n\t\t\t\tboolean bCreateAlerts = false;\n\t\t\t\tfor (int nCreateObsType : m_nObsTypes)\n\t\t\t\t{\n\t\t\t\t\tif (nCreateObsType == nObsTypes[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tbCreateAlerts = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!bCreateAlerts)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tImrcpObsResultSet oData = (ImrcpObsResultSet)oStore.getData(nObsTypes[j], lStartTime, lEndTime, m_nStudyArea[0], m_nStudyArea[1], m_nStudyArea[2], m_nStudyArea[3], System.currentTimeMillis()); // get Obs\n\t\t\t\tfor (Obs oObs : oData)\n\t\t\t\t{\n\t\t\t\t\tif (Util.isSegment(oObs.m_nObjId))\n\t\t\t\t\t{\n\t\t\t\t\t\tSegment oSegment = oShps.getLinkById(oObs.m_nObjId);\n\t\t\t\t\t\tif (oSegment == null || !oSegment.m_sType.equals(\"H\")) // skip segments that are not highways\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (AlertRule oRule : m_oRules) // go through all the rules once, setting when each condition was met\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int nCondIndex = 0; nCondIndex < oRule.m_oAlgorithm.size(); nCondIndex++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAlertCondition oCond = oRule.m_oAlgorithm.get(nCondIndex);\n\t\t\t\t\t\t\tif (oObs.m_nObsTypeId != oCond.m_nObsType) // not the correct obs type\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif (!oCond.evaluate(oObs.m_dValue)) // does not fall within the range of the condition\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\tlSearch[0] = oObs.m_nLat1; // lat1\n\t\t\t\t\t\t\tlSearch[1] = oObs.m_nLat2; // lat2\n\t\t\t\t\t\t\tlSearch[2] = oObs.m_nLon1; // lon1\n\t\t\t\t\t\t\tlSearch[3] = oObs.m_nLon2; // lon2\n\t\t\t\t\t\t\tif (lSearch[1] == Integer.MIN_VALUE) // point observations\n\t\t\t\t\t\t\t\tlSearch[1] = lSearch[0];\n\t\t\t\t\t\t\tif (lSearch[3] == Integer.MIN_VALUE)\n\t\t\t\t\t\t\t\tlSearch[3] = lSearch[2];\n\t\t\t\t\t\t\tlSearch[4] = oObs.m_lObsTime1; // obstime1\n\t\t\t\t\t\t\tlSearch[5] = oObs.m_lObsTime2; // obstime2\n\n\t\t\t\t\t\t\tint nIndex = Collections.binarySearch(oAreas, lSearch, COMPBYAREA); // search if the an array for the area has been made yet\n\t\t\t\t\t\t\tif (nIndex < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnIndex = ~nIndex;\n\t\t\t\t\t\t\t\tlong[] lTemp = new long[m_nArrayLength];\n\t\t\t\t\t\t\t\tSystem.arraycopy(lSearch, 0, lTemp, 0, 4);\n\t\t\t\t\t\t\t\tSystem.arraycopy(m_lInitialValues, 0, lTemp, 5, m_lInitialValues.length); // initialize all the condition timestamps\n\t\t\t\t\t\t\t\tlTemp[4] = oObs.m_nObjId; // objid\n\t\t\t\t\t\t\t\toAreas.add(nIndex, lTemp);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (int i = 0; i < oAreas.size(); i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlong[] lArea = oAreas.get(i);\n\t\t\t\t\t\t\t\tif (lArea[1] >= lSearch[0] && lArea[0] <= lSearch[1] && lArea[3] >= lSearch[2] && lArea[2] <= lSearch[3]) // check if the current area intersects the areas in the list\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tint nAreaCond = oRule.m_nArrayPosition + (nCondIndex * 2);\n\t\t\t\t\t\t\t\t\tif (lArea[nAreaCond] > lSearch[4]) // check if the endtime is later than the current endtime\n\t\t\t\t\t\t\t\t\t\tlArea[nAreaCond] = lSearch[4]; // if so use the earlier endtime\n\t\t\t\t\t\t\t\t\t++nAreaCond;\n\t\t\t\t\t\t\t\t\tif (lArea[nAreaCond] < lSearch[5]) // check if the start time is earlier than the current start time\n\t\t\t\t\t\t\t\t\t\tlArea[nAreaCond] = lSearch[5]; // if so use the later start time\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (AlertRule oRule : m_oRules) // evaluate all the rules for each area\n\t\t\t{\n\t\t\t\tfor (long[] lArea : oAreas)\n\t\t\t\t{\n\t\t\t\t\tObs oObs = oRule.evaluateRuleForArea(lArea, lStartTime);\n\t\t\t\t\tif (oObs != null)\n\t\t\t\t\t\toAlerts.add(oObs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong lFileStartTime = (lStartTime / m_nFileFrequency) * m_nFileFrequency;\n\t\t\tlong lFileEndTime = lFileStartTime + m_nFileFrequency * 2;\n\t\t\tString sFilename = m_oFormatter.format(lFileStartTime, lFileStartTime, lFileEndTime);\n\t\t\tnew File(sFilename.substring(0, sFilename.lastIndexOf(\"/\"))).mkdirs();\n\t\t\ttry (BufferedWriter oOut = new BufferedWriter(new FileWriter(sFilename, true))) // write the alert file\n\t\t\t{\n\t\t\t\tif (new File(sFilename).length() == 0)\n\t\t\t\t\toOut.write(g_sHEADER);\n\t\t\t\tfor (Obs oAlert : oAlerts)\n\t\t\t\t\toAlert.writeCsv(oOut);\n\t\t\t}\n\n\t\t\tnotify(\"file download\", sFilename);\n\t\t}\n\t\tcatch (Exception oException)\n\t\t{\n\t\t\tm_oLogger.error(oException, oException);\n\t\t}\n\t}\n}", "item_id": 0, "repo": "OSADP/IMRCP", "file": "source/imrcp/comp/Alerts.java", "last_update_at": "2022-03-29T09:37:19+00:00", "question_id": "b6dfb9f5d1cd6359d28f7f100320c5ff9bf04764_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Alerts extends BaseBlock\n{\n\tprivate int m_nFileFrequency;\n\t/**\n\t * List of rules\n\t */\n\tprivate ArrayList<AlertRule> m_oRules = new ArrayList();\n\t/**\n\t * Bounding box of the study area\n\t */\n\tprivate int[] m_nStudyArea;\n\tprivate FilenameFormatter m_oFormatter;\n\t/**\n\t * Array of obs types needed to evaluate the rules for this block\n\t */\n\tprivate int[] m_nObsTypes;\n\t/**\n\t * Length the area arrays need to be based off of the rules for this block\n\t */\n\tprivate int m_nArrayLength;\n\t/**\n\t * Reusable array to initial values for a new area\n\t */\n\tprivate long[] m_lInitialValues;\n\t/**\n\t * Header for the csv file\n\t */\n\tpublic static final String g_sHEADER = \"ObsType,Source,ObjId,ObsTime1,ObsTime2,TimeRecv,Lat1,Lon1,Lat2,Lon2,Elev,Value,Conf\\n\";\n\t/**\n\t * Comparator used to compare long arrays that represent areas in this\n\t * block. Compares first by lon1, then lon2, then lat1, then lat2.\n\t */\n\tpublic static final Comparator<long[]> COMPBYAREA = (long[] o1, long[] o2) -> \n\t{\n\t\tint nReturn = Long.compare(o1[2], o2[2]); // compare by lon1\n\t\tif (nReturn == 0)\n\t\t{\n\t\t\tnReturn = Long.compare(o1[3], o2[3]); // then lon2\n\t\t\tif (nReturn == 0)\n\t\t\t{\n\t\t\t\tnReturn = Long.compare(o1[0], o2[0]); // then lat1\n\t\t\t\tif (nReturn == 0)\n\t\t\t\t\tnReturn = Long.compare(o1[1], o2[1]); // then lat2\n\t\t\t}\n\t\t}\n\t\treturn nReturn;\n\t};\n\t/**\n\t * Reads in the rules and creates the necessary objects from the config\n\t * file.\n\t *\n\t * @return true if no errors occur, false otherwise\n\t * @throws Exception\n\t */\n\t@Override\n\tpublic boolean start() throws Exception\n\t{\n\t\tString[] sRules = m_oConfig.getStringArray(\"rules\", null);\n\t\tint nArrayPosition = 5;\n\t\tfor (String sRule : sRules) // for each configured rule create the object\n\t\t{\n\t\t\tString[] sConditions = m_oConfig.getStringArray(sRule, null);\n\t\t\tif (sConditions.length % 4 != 1 || sConditions.length == 0) // rules have this struct {alert type, list of conditions} (conditions have 4 elements each)\n\t\t\t{\n\t\t\t\tm_oLogger.error(\"Incorrect length for rule: \" + sRule);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tAlertRule oAdd = new AlertRule(sConditions, nArrayPosition);\n\t\t\tm_oRules.add(oAdd);\n\t\t\tnArrayPosition += (oAdd.m_oAlgorithm.size() * 2);\n\t\t}\n\t\tm_nArrayLength = nArrayPosition;\n\t\tm_lInitialValues = new long[m_nArrayLength - 5];\n\t\tfor (int i = 0; i < m_lInitialValues.length;)\n\t\t{\n\t\t\tm_lInitialValues[i++] = Long.MAX_VALUE;\n\t\t\tm_lInitialValues[i++] = Long.MIN_VALUE;\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * Resets are configurable variables\n\t */\n\t@Override\n\tpublic void reset()\n\t{\n\t\tm_nFileFrequency = m_oConfig.getInt(\"freq\", 86400000);\n\t\tm_oFormatter = new FilenameFormatter(m_oConfig.getString(\"format\", \"\"));\n\t\tString[] sObsTypes = m_oConfig.getStringArray(\"obs\", null);\n\t\tm_nObsTypes = new int[sObsTypes.length];\n\t\tfor (int i = 0; i < sObsTypes.length; i++)\n\t\t\tm_nObsTypes[i] = Integer.valueOf(sObsTypes[i], 36);\n\t\tString[] sBox = m_oConfig.getStringArray(\"box\", \"\");\n\t\tm_nStudyArea = new int[4];\n\t\tm_nStudyArea[0] = Integer.MAX_VALUE;\n\t\tm_nStudyArea[1] = Integer.MIN_VALUE;\n\t\tm_nStudyArea[2] = Integer.MAX_VALUE;\n\t\tm_nStudyArea[3] = Integer.MIN_VALUE;\n\t\tfor (int i = 0; i < sBox.length;)\n\t\t{\n\t\t\tint nLon = Integer.parseInt(sBox[i++]);\n\t\t\tint nLat = Integer.parseInt(sBox[i++]);\n\t\t\tif (nLon < m_nStudyArea[2])\n\t\t\t\tm_nStudyArea[2] = nLon;\n\t\t\tif (nLon > m_nStudyArea[3])\n\t\t\t\tm_nStudyArea[3] = nLon;\n\t\t\tif (nLat < m_nStudyArea[0])\n\t\t\t\tm_nStudyArea[0] = nLat;\n\t\t\tif (nLat > m_nStudyArea[1])\n\t\t\t\tm_nStudyArea[1] = nLat;\n\t\t}\n\t}\n\t/**\n\t * Processes Notifications received from other blocks.\n\t *\n\t * @param oNotification the received Notification\n\t */\n\t@Override\n\tpublic void process(String[] sMessage)\n\t{\n\t\tif (sMessage[MESSAGE].compareTo(\"new data\") == 0)\n\t\t{\n\t\t\tString sStore = sMessage[FROM];\n\t\t\tlong lStartTime = Long.parseLong(sMessage[2]);\n\t\t\tlong lEndTime = Long.parseLong(sMessage[3]);\n\t\t\tint[] nObsTypes = new int[sMessage.length - 4];\n\t\t\tint nIndex = 0;\n\t\t\tfor (int i = 4; i < sMessage.length; i++)\n\t\t\t\tnObsTypes[nIndex++] = Integer.parseInt(sMessage[i]);\n\t\t\tcreateAlerts(sStore, nObsTypes, lStartTime, lEndTime);\n\t\t}\n\t}\n\t/**\n\t * Ran when a notification of new data is sent from a data Store. This\n\t * function checks alert rules for the current forecasts in the study area.\n\t * We use a long array for each area that could have an alert. The format of\n\t * the arrays is: [lat1, lat2, lon1, lon2, objId, (pairs of start and end\n\t * times for each condition for each rule)]\n\t */\n\tpublic void createAlerts(String sStore, int[] nObsTypes, long lStartTime, long lEndTime)\n\t{\n\t\ttry\n\t\t{\n\t\t\tSegmentShps oShps = (SegmentShps)Directory.getInstance().lookup(\"SegmentShps\");\n\t\t\tBaseBlock oStore = (BaseBlock)Directory.getInstance().lookup(sStore);\n\t\t\tArrayList<Obs> oAlerts = new ArrayList();\n\t\t\tArrayList<long[]> oAreas = new ArrayList();\n\t\t\tlong[] lSearch = new long[6];\n\t\t\tfor (int j = 0; j < nObsTypes.length; j++) // for each obs type\n\t\t\t{\n\t\t\t\tboolean bCreateAlerts = false;\n\t\t\t\tfor (int nCreateObsType : m_nObsTypes)\n\t\t\t\t{\n\t\t\t\t\tif (nCreateObsType == nObsTypes[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tbCreateAlerts = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!bCreateAlerts)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tImrcpObsResultSet oData = (ImrcpObsResultSet)oStore.getData(nObsTypes[j], lStartTime, lEndTime, m_nStudyArea[0], m_nStudyArea[1], m_nStudyArea[2], m_nStudyArea[3], System.currentTimeMillis()); // get Obs\n\t\t\t\tfor (Obs oObs : oData)\n\t\t\t\t{\n\t\t\t\t\tif (Util.isSegment(oObs.m_nObjId))\n\t\t\t\t\t{\n\t\t\t\t\t\tSegment oSegment = oShps.getLinkById(oObs.m_nObjId);\n\t\t\t\t\t\tif (oSegment == null || !oSegment.m_sType.equals(\"H\")) // skip segments that are not highways\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (AlertRule oRule : m_oRules) // go through all the rules once, setting when each condition was met\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int nCondIndex = 0; nCondIndex < oRule.m_oAlgorithm.size(); nCondIndex++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAlertCondition oCond = oRule.m_oAlgorithm.get(nCondIndex);\n\t\t\t\t\t\t\tif (oObs.m_nObsTypeId != oCond.m_nObsType) // not the correct obs type\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif (!oCond.evaluate(oObs.m_dValue)) // does not fall within the range of the condition\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tlSearch[0] = oObs.m_nLat1; // lat1\n\t\t\t\t\t\t\tlSearch[1] = oObs.m_nLat2; // lat2\n\t\t\t\t\t\t\tlSearch[2] = oObs.m_nLon1; // lon1\n\t\t\t\t\t\t\tlSearch[3] = oObs.m_nLon2; // lon2\n\t\t\t\t\t\t\tif (lSearch[1] == Integer.MIN_VALUE) // point observations\n\t\t\t\t\t\t\t\tlSearch[1] = lSearch[0];\n\t\t\t\t\t\t\tif (lSearch[3] == Integer.MIN_VALUE)\n\t\t\t\t\t\t\t\tlSearch[3] = lSearch[2];\n\t\t\t\t\t\t\tlSearch[4] = oObs.m_lObsTime1; // obstime1\n\t\t\t\t\t\t\tlSearch[5] = oObs.m_lObsTime2; // obstime2\n\t\t\t\t\t\t\tint nIndex = Collections.binarySearch(oAreas, lSearch, COMPBYAREA); // search if the an array for the area has been made yet\n\t\t\t\t\t\t\tif (nIndex < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnIndex = ~nIndex;\n\t\t\t\t\t\t\t\tlong[] lTemp = new long[m_nArrayLength];\n\t\t\t\t\t\t\t\tSystem.arraycopy(lSearch, 0, lTemp, 0, 4);\n\t\t\t\t\t\t\t\tSystem.arraycopy(m_lInitialValues, 0, lTemp, 5, m_lInitialValues.length); // initialize all the condition timestamps\n\t\t\t\t\t\t\t\tlTemp[4] = oObs.m_nObjId; // objid\n\t\t\t\t\t\t\t\toAreas.add(nIndex, lTemp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int i = 0; i < oAreas.size(); i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlong[] lArea = oAreas.get(i);\n\t\t\t\t\t\t\t\tif (lArea[1] >= lSearch[0] && lArea[0] <= lSearch[1] && lArea[3] >= lSearch[2] && lArea[2] <= lSearch[3]) // check if the current area intersects the areas in the list\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tint nAreaCond = oRule.m_nArrayPosition + (nCondIndex * 2);\n\t\t\t\t\t\t\t\t\tif (lArea[nAreaCond] > lSearch[4]) // check if the endtime is later than the current endtime\n\t\t\t\t\t\t\t\t\t\tlArea[nAreaCond] = lSearch[4]; // if so use the earlier endtime\n\t\t\t\t\t\t\t\t\t++nAreaCond;\n\t\t\t\t\t\t\t\t\tif (lArea[nAreaCond] < lSearch[5]) // check if the start time is earlier than the current start time\n\t\t\t\t\t\t\t\t\t\tlArea[nAreaCond] = lSearch[5]; // if so use the later start time\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (AlertRule oRule : m_oRules) // evaluate all the rules for each area\n\t\t\t{\n\t\t\t\tfor (long[] lArea : oAreas)\n\t\t\t\t{\n\t\t\t\t\tObs oObs = oRule.evaluateRuleForArea(lArea, lStartTime);\n\t\t\t\t\tif (oObs != null)\n\t\t\t\t\t\toAlerts.add(oObs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong lFileStartTime = (lStartTime / m_nFileFrequency) * m_nFileFrequency;\n\t\t\tlong lFileEndTime = lFileStartTime + m_nFileFrequency * 2;\n\t\t\tString sFilename = m_oFormatter.format(lFileStartTime, lFileStartTime, lFileEndTime);\n\t\t\tnew File(sFilename.substring(0, sFilename.lastIndexOf(\"/\"))).mkdirs();\n\t\t\ttry (BufferedWriter oOut = new BufferedWriter(new FileWriter(sFilename, true))) // write the alert file\n\t\t\t{\n\t\t\t\tif (new File(sFilename).length() == 0)\n\t\t\t\t\toOut.write(g_sHEADER);\n\t\t\t\tfor (Obs oAlert : oAlerts)\n\t\t\t\t\toAlert.writeCsv(oOut);\n\t\t\t}\n\t\t\tnotify(\"file download\", sFilename);\n\t\t}\n\t\tcatch (Exception oException)\n\t\t{\n\t\t\tm_oLogger.error(oException, oException);\n\t\t}\n\t}\n"]], "pred": {"ppl": 2.4560863971710205, "ppl_lower": 2.6738440990448, "ppl/lowercase_ppl": -1.0945369460163252, "ppl/zlib": 0.0003048063730215042, "Min_5.0% Prob": 7.450320112938974, "Min_10.0% Prob": 5.771515441875832, "Min_20.0% Prob": 3.9053947025654363, "Min_30.0% Prob": 2.860116276865691, "Min_40.0% Prob": 2.2106525478998433, "Min_50.0% Prob": 1.7900064921265362, "Min_60.0% Prob": 1.49764175694527}}
{"hexsha": "0a4e7f177cec35878781aac9ee4be2a683a746ef", "ext": "java", "lang": "Java", "content": "class DefineNamedBindingsStatementCustomizer implements StatementCustomizer {\n    @Override\n    public void beforeTemplating(PreparedStatement stmt, StatementContext ctx) {\n        final Set<String> alreadyDefined = ctx.getAttributes().keySet();\n        final Binding binding = ctx.getBinding();\n        final SetNullHandler handler = new SetNullHandler(ctx);\n        binding.getNames().stream()\n            .filter(name -> !alreadyDefined.contains(name))\n            .forEach(name -> binding.findForName(name, ctx).ifPresent(\n                    a -> handler.define(name, a)));\n    }\n\n    private static class SetNullHandler implements InvocationHandler {\n        private static final Map<Class<?>, Object> DEFAULT_VALUES = Stream.of(\n            boolean.class,\n            char.class,\n            byte.class,\n            short.class,\n            int.class,\n            long.class,\n            float.class,\n            double.class\n        ).collect(Collectors.toMap(identity(), SetNullHandler::defaultValue));\n\n        private final StatementContext ctx;\n        private final PreparedStatement fakeStmt = (PreparedStatement)\n                Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class<?>[] {PreparedStatement.class}, this);\n        private boolean setNull;\n        private boolean setCalled;\n\n        SetNullHandler(StatementContext ctx) {\n            this.ctx = ctx;\n        }\n\n        private static Object defaultValue(Class<?> clazz) {\n            return Array.get(Array.newInstance(clazz, 1), 0);\n        }\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws SQLException {\n            if (\"unwrap\".equals(method.getName())\n                && args.length == 1\n                && method.getParameterTypes()[0].equals(Class.class)) {\n                throw new SQLException(\"The current implementation of DefineNamedBindings is incompatible with \"\n                    + \"arguments that rely on java.sql.Wrapper.unwrap(Class<?>)\");\n            }\n\n            if (\"getConnection\".equals(method.getName())) {\n                return ctx.getConnection();\n            }\n\n            if (method.getName().startsWith(\"set\")) {\n                setCalled = true;\n                boolean argNull = args.length > 1 && args[1] == null;\n                setNull = argNull || \"setNull\".equals(method.getName());\n            }\n\n            return DEFAULT_VALUES.get(method.getReturnType());\n        }\n\n        void define(String name, Argument arg) {\n            setNull = false;\n            setCalled = false;\n            Unchecked.runnable(() -> arg.apply(1, fakeStmt, ctx)).run();\n            if (setCalled) {\n                ctx.define(name, !setNull);\n            }\n        }\n    }\n}", "item_id": 0, "repo": "drunderscore/jdbi", "file": "core/src/main/java/org/jdbi/v3/core/statement/DefineNamedBindingsStatementCustomizer.java", "last_update_at": "2022-03-31T22:39:30+00:00", "question_id": "0a4e7f177cec35878781aac9ee4be2a683a746ef_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class DefineNamedBindingsStatementCustomizer implements StatementCustomizer {\n    @Override\n    public void beforeTemplating(PreparedStatement stmt, StatementContext ctx) {\n        final Set<String> alreadyDefined = ctx.getAttributes().keySet();\n        final Binding binding = ctx.getBinding();\n        final SetNullHandler handler = new SetNullHandler(ctx);\n        binding.getNames().stream()\n            .filter(name -> !alreadyDefined.contains(name))\n            .forEach(name -> binding.findForName(name, ctx).ifPresent(\n                    a -> handler.define(name, a)));\n    }\n    private static class SetNullHandler implements InvocationHandler {\n        private static final Map<Class<?>, Object> DEFAULT_VALUES = Stream.of(\n            boolean.class,\n            char.class,\n            byte.class,\n            short.class,\n            int.class,\n            long.class,\n            float.class,\n            double.class\n        ).collect(Collectors.toMap(identity(), SetNullHandler::defaultValue));\n        private final StatementContext ctx;\n        private final PreparedStatement fakeStmt = (PreparedStatement)\n                Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class<?>[] {PreparedStatement.class}, this);\n        private boolean setNull;\n        private boolean setCalled;\n        SetNullHandler(StatementContext ctx) {\n            this.ctx = ctx;\n        }\n        private static Object defaultValue(Class<?> clazz) {\n            return Array.get(Array.newInstance(clazz, 1), 0);\n        }\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws SQLException {\n            if (\"unwrap\".equals(method.getName())\n                && args.length == 1\n                && method.getParameterTypes()[0].equals(Class.class)) {\n                throw new SQLException(\"The current implementation of DefineNamedBindings is incompatible with \"\n                    + \"arguments that rely on java.sql.Wrapper.unwrap(Class<?>)\");\n            }\n            if (\"getConnection\".equals(method.getName())) {\n                return ctx.getConnection();\n            }\n            if (method.getName().startsWith(\"set\")) {\n                setCalled = true;\n                boolean argNull = args.length > 1 && args[1] == null;\n                setNull = argNull || \"setNull\".equals(method.getName());\n            }\n            return DEFAULT_VALUES.get(method.getReturnType());\n        }\n        void define(String name, Argument arg) {\n            setNull = false;\n            setCalled = false;\n            Unchecked.runnable(() -> arg.apply(1, fakeStmt, ctx)).run();\n            if (setCalled) {\n                ctx.define(name, !setNull);\n            }\n        }\n    }\n"]], "pred": {"ppl": 2.2076520919799805, "ppl_lower": 2.7074198722839355, "ppl/lowercase_ppl": -1.2576827143733755, "ppl/zlib": 0.0007802261566126174, "Min_5.0% Prob": 6.978860476437737, "Min_10.0% Prob": 5.20997506984766, "Min_20.0% Prob": 3.497460716876431, "Min_30.0% Prob": 2.551576940477758, "Min_40.0% Prob": 1.9651351006080706, "Min_50.0% Prob": 1.5796760168314152, "Min_60.0% Prob": 1.3193900223159376}}
{"hexsha": "cee3f2d9ac0ef0557dadf9ab913037859b04fd66", "ext": "java", "lang": "Java", "content": "public class TestElasticsearchProcessManager {\n    private ElasticsearchProcessManager elasticSearchProcessManager;\n\n    @Before\n    public void setup() {\n        IConfiguration config = new FakeConfiguration(\"us-east-1\", \"test_cluster\", \"us-east-1a\", \"i-1234afd3\");\n        elasticSearchProcessManager = new ElasticsearchProcessManager(config);\n    }\n\n    @Test\n    public void logProcessOutput_BadApp() throws IOException, InterruptedException {\n        Process p = null;\n        try {\n            p = new ProcessBuilder(\"ls\", \"/tmppppp\").start();\n            int exitValue = p.waitFor();\n            assertTrue(0 != exitValue);\n            elasticSearchProcessManager.logProcessOutput(p);\n        } catch (IOException ioe) {\n            if (p != null) {\n                elasticSearchProcessManager.logProcessOutput(p);\n            }\n        }\n    }\n\n    /**\n     * Note: this will succeed on a *nix machine, unclear about anything else...\n     */\n    @Test\n    public void logProcessOutput_GoodApp() throws IOException, InterruptedException {\n        Process p = new ProcessBuilder(\"true\").start();\n        int exitValue = p.waitFor();\n        assertEquals(0, exitValue);\n        elasticSearchProcessManager.logProcessOutput(p);\n    }\n}", "item_id": 0, "repo": "tulumvinh/Raigad", "file": "raigad/src/test/java/com/netflix/raigad/defaultimpl/TestElasticsearchProcessManager.java", "last_update_at": "2022-02-10T14:34:28+00:00", "question_id": "cee3f2d9ac0ef0557dadf9ab913037859b04fd66_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestElasticsearchProcessManager {\n    private ElasticsearchProcessManager elasticSearchProcessManager;\n    @Before\n    public void setup() {\n        IConfiguration config = new FakeConfiguration(\"us-east-1\", \"test_cluster\", \"us-east-1a\", \"i-1234afd3\");\n        elasticSearchProcessManager = new ElasticsearchProcessManager(config);\n    }\n    @Test\n    public void logProcessOutput_BadApp() throws IOException, InterruptedException {\n        Process p = null;\n        try {\n            p = new ProcessBuilder(\"ls\", \"/tmppppp\").start();\n            int exitValue = p.waitFor();\n            assertTrue(0 != exitValue);\n            elasticSearchProcessManager.logProcessOutput(p);\n        } catch (IOException ioe) {\n            if (p != null) {\n                elasticSearchProcessManager.logProcessOutput(p);\n            }\n        }\n    }\n    /**\n     * Note: this will succeed on a *nix machine, unclear about anything else...\n     */\n    @Test\n    public void logProcessOutput_GoodApp() throws IOException, InterruptedException {\n        Process p = new ProcessBuilder(\"true\").start();\n        int exitValue = p.waitFor();\n        assertEquals(0, exitValue);\n        elasticSearchProcessManager.logProcessOutput(p);\n    }\n"]], "pred": {"ppl": 2.4860470294952393, "ppl_lower": 2.942539930343628, "ppl/lowercase_ppl": -1.1851107355090196, "ppl/zlib": 0.002023764245882237, "Min_5.0% Prob": 7.973041087388992, "Min_10.0% Prob": 6.00650829076767, "Min_20.0% Prob": 3.96495075409229, "Min_30.0% Prob": 2.931543390468224, "Min_40.0% Prob": 2.251347859662313, "Min_50.0% Prob": 1.8123428656782474, "Min_60.0% Prob": 1.520076354373342}}
{"hexsha": "397e2803a0780030cd16dfe99876ba33baa4cc6c", "ext": "java", "lang": "Java", "content": "@Controller\n@RequestMapping(value = \"/item\")\npublic class ItemController extends BaseController {\n\tprivate static final Logger logger = LoggerFactory.getLogger(ItemController.class);\n\n\t@Inject\n\t@Named(\"bidService\")\n\tprivate BidService bidService;\n\n\n\t@RequestMapping(value = \"/current/auction/{auctionId}\", method = RequestMethod.GET)\n\tpublic @ResponseBody\n\tItemRepresentation getCurrentItem(@PathVariable long auctionId, HttpServletResponse response) {\n\t\tString username = this.getSecurityUtil().getUsernameFromPrincipal();\n\n\t\tlogger.info(\"ItemController::getCurrentItem auctionId = \" + auctionId + \", username = \" + username);\n\n\t\tItemRepresentation returnItem = null;\n\t\ttry {\n\t\t\treturnItem = bidService.getCurrentItem(auctionId);\n\t\t} catch (AuctionNotActiveException ex) {\n\t\t\tresponse.setStatus(HttpServletResponse.SC_GONE);\n\t\t\tresponse.setContentType(\"text/html\");\n\t\t\ttry {\n\t\t\t\tPrintWriter responseWriter = response.getWriter();\n\t\t\t\tresponseWriter.print(\"AuctionComplete\");\n\t\t\t\tresponseWriter.close();\n\t\t\t\treturn null;\n\t\t\t} catch (IOException e1) {\n\t\t\t\tlogger.warn(\"ItemController::getCurrentItem: got IOException when writing AuctionComplete message to reponse\"\n\t\t\t\t\t\t+ e1.getMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (returnItem == null) {\n\t\t\tresponse.setStatus(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\n\t\t}\n\t\t\n\t\treturn returnItem;\n\t}\n\n}", "item_id": 0, "repo": "saintdle/weathervane", "file": "auctionBidService/src/main/java/com/vmware/weathervane/auction/controllers/ItemController.java", "last_update_at": "2022-02-23T21:21:00+00:00", "question_id": "397e2803a0780030cd16dfe99876ba33baa4cc6c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Controller\n@RequestMapping(value = \"/item\")\npublic class ItemController extends BaseController {\n\tprivate static final Logger logger = LoggerFactory.getLogger(ItemController.class);\n\t@Inject\n\t@Named(\"bidService\")\n\tprivate BidService bidService;\n\t@RequestMapping(value = \"/current/auction/{auctionId}\", method = RequestMethod.GET)\n\tpublic @ResponseBody\n\tItemRepresentation getCurrentItem(@PathVariable long auctionId, HttpServletResponse response) {\n\t\tString username = this.getSecurityUtil().getUsernameFromPrincipal();\n\t\tlogger.info(\"ItemController::getCurrentItem auctionId = \" + auctionId + \", username = \" + username);\n\t\tItemRepresentation returnItem = null;\n\t\ttry {\n\t\t\treturnItem = bidService.getCurrentItem(auctionId);\n\t\t} catch (AuctionNotActiveException ex) {\n\t\t\tresponse.setStatus(HttpServletResponse.SC_GONE);\n\t\t\tresponse.setContentType(\"text/html\");\n\t\t\ttry {\n\t\t\t\tPrintWriter responseWriter = response.getWriter();\n\t\t\t\tresponseWriter.print(\"AuctionComplete\");\n\t\t\t\tresponseWriter.close();\n\t\t\t\treturn null;\n\t\t\t} catch (IOException e1) {\n\t\t\t\tlogger.warn(\"ItemController::getCurrentItem: got IOException when writing AuctionComplete message to reponse\"\n\t\t\t\t\t\t+ e1.getMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (returnItem == null) {\n\t\t\tresponse.setStatus(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\n\t\t}\n\t\t\n\t\treturn returnItem;\n\t}\n"]], "pred": {"ppl": 1.962388038635254, "ppl_lower": 2.2880892753601074, "ppl/lowercase_ppl": -1.227771583102743, "ppl/zlib": 0.0011198706290200186, "Min_5.0% Prob": 6.101938349860055, "Min_10.0% Prob": 4.441685387066433, "Min_20.0% Prob": 2.9378843165579296, "Min_30.0% Prob": 2.142666191808761, "Min_40.0% Prob": 1.663962802982756, "Min_50.0% Prob": 1.3413793794916704, "Min_60.0% Prob": 1.1226335839615038}}
{"hexsha": "b9aea6b7b81ad451b5ee08ec7644a93e03ff3ba9", "ext": "java", "lang": "Java", "content": "public class GenericRDFGenerator extends RdfGenerator {\n\n\tprivate static Logger logger = LoggerFactory.getLogger(GenericRDFGenerator.class);\n\n\tprotected R2RMLMappingManager mappingManager = new R2RMLMappingManager();\n\tprotected JSONLDContextManager contextManager = new JSONLDContextManager();\n\t\n\tpublic enum InputType {\n\t\tCSV,\n\t\tJSON,\n\t\tXML,\n\t\tAVRO,\n\t\tEXCEL,\n\t\tJL,\n\t\tOBJECT\n\t};\n\t\n\tpublic GenericRDFGenerator() {\n\t\tthis(null);\n\t}\n\t\n\tpublic GenericRDFGenerator(String selectionName) {\n\t\tsuper(selectionName);\n\t}\n\n\tpublic void addModel(R2RMLMappingIdentifier id) {\n\t\tthis.mappingManager.addModel(id);\n\t}\n\n    public void addContext(ContextIdentifier id) {\n    \tthis.contextManager.addContext(id);\n    }\n    \n    public JSONObject getContext(ContextIdentifier id) throws IOException {\n    \treturn this.contextManager.getContext(null, id);\n    }\n    \n    public WorksheetR2RMLJenaModelParser getModelParser(String modelName) throws JSONException, KarmaException {\n    \treturn this.mappingManager.getModelParser(modelName);\n    }\n    \n\tprivate void generateRDF(String modelName, String sourceName,String contextName, RDFGeneratorInputWrapper input, InputType dataType,  InputProperties inputTypeParameters, \n\t\t\tboolean addProvenance, List<KR2RMLRDFWriter> writers, RootStrategy rootStrategy, \n\t\t\tList<String> tripleMapToKill, List<String> tripleMapToStop, List<String> POMToKill, ServletContextParameterMap contextParameters)\n\t\t\t\t\tthrows KarmaException, IOException {\n\t\t\n\t\tR2RMLMappingIdentifier id = mappingManager.getMappingIdentifierByName(modelName);\n\t\tContextIdentifier contextId = contextManager.getContextIdentifier(contextName);\n\t\tJSONObject context = contextManager.getContext(contextName, contextId);\n\t\tinitializeRDFWriters(writers, id, contextId, context);\n\t\t//Check if the parser for this model exists, else create one\n\t\tWorksheetR2RMLJenaModelParser modelParser = mappingManager.getModelParser(modelName);\n\t\tgenerateRDF(modelParser, sourceName, input, dataType, inputTypeParameters, addProvenance, writers, rootStrategy, tripleMapToKill, tripleMapToStop, POMToKill, contextParameters);\n\t}\n\n\tprivate void initializeRDFWriters(List<KR2RMLRDFWriter> writers, R2RMLMappingIdentifier id,\n\t\t\tContextIdentifier contextId, JSONObject context) {\n\t\tfor (KR2RMLRDFWriter writer : writers) {\n\t\t\tif (writer instanceof JSONKR2RMLRDFWriter) {\n\t\t\t\tJSONKR2RMLRDFWriter t = (JSONKR2RMLRDFWriter)writer;\n\t\t\t\tt.setGlobalContext(context, contextId);\n\t\t\t}\n\t\t\twriter.setR2RMLMappingIdentifier(id);\n\t\t}\n\t}\n\n\t\n\tprivate void generateRDF(WorksheetR2RMLJenaModelParser modelParser, String sourceName, RDFGeneratorInputWrapper input, InputType dataType,  InputProperties inputTypeParameters,\n\t\t\tboolean addProvenance, List<KR2RMLRDFWriter> writers, RootStrategy rootStrategy, \n\t\t\tList<String> tripleMapToKill, List<String> tripleMapToStop, List<String> POMToKill, ServletContextParameterMap contextParameters) throws KarmaException, IOException {\n\t\tlogger.debug(\"Generating rdf for \" + sourceName);\n\t\t\n\t\tif(contextParameters == null)\n\t\t{\n\t\t\tcontextParameters = ContextParametersRegistry.getInstance().getDefault();\n\t\t\tlogger.debug(\"No context specified.  Defaulting to: \" + contextParameters.getKarmaHome());\n\t\t}\n\t\tlogger.debug(\"Initializing workspace for {}\", sourceName);\n\t\tWorkspace workspace = initializeWorkspace(contextParameters);\n\t\tlogger.debug(\"Initialized workspace for {}\", sourceName);\n\t\ttry\n\t\t{\n\t\t\n\t\t\tlogger.debug(\"Generating worksheet for {}\", sourceName);\n\t\t\tWorksheet worksheet = null;\n\t\t\tif(input.getHeaders() != null) {\n\t\t\t\tworksheet = WorksheetGenerator.generateWorksheet(sourceName, input.getHeaders(), input.getValues(), workspace);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tInputStream data = input.getInputAsStream();\n\t\t\t\tworksheet = WorksheetGenerator.generateWorksheet(sourceName, new BufferedInputStream(data), dataType, inputTypeParameters,\n\t\t\t\t\tworkspace);\n\t\t\t}\n\t\t\tlogger.debug(\"Generated worksheet for {}\", sourceName);\n\t\t\tlogger.debug(\"Parsing mapping for {}\", sourceName);\n\t\t\t//Generate mappping data for the worksheet using the model parser\n\t\t\tKR2RMLMapping mapping = modelParser.parse();\n\t\t\tlogger.debug(\"Parsed mapping for {}\", sourceName);\n\t\t\tapplyHistoryToWorksheet(workspace, worksheet, mapping);\n\t\t\tSuperSelection selection = SuperSelectionManager.DEFAULT_SELECTION;\n\t\t\tif (selectionName != null && !selectionName.trim().isEmpty())\n\t\t\t\tselection = worksheet.getSuperSelectionManager().getSuperSelection(selectionName);\n\t\t\tif (selection == null)\n\t\t\t\treturn;\n\t\t\t//Generate RDF using the mapping data\n\t\t\tErrorReport errorReport = new ErrorReport();\n\t\t\tif(rootStrategy == null)\n\t\t\t{\n\t\t\t\trootStrategy = new SteinerTreeRootStrategy(new WorksheetDepthRootStrategy());\n\t\t\t}\n\t\t\tlogger.debug(\"Generating output for {}\", sourceName);\n\t\t\tKR2RMLWorksheetRDFGenerator rdfGen = new KR2RMLWorksheetRDFGenerator(worksheet,\n\t\t\t        workspace, writers,\n\t\t\t        addProvenance, rootStrategy, tripleMapToKill, tripleMapToStop, POMToKill, \n\t\t\t        mapping, errorReport, selection);\n\t\t\trdfGen.generateRDF(true);\n\t\t\tlogger.debug(\"Generated output for {}\", sourceName);\n\t\t}\n\t\tcatch( Exception e)\n\t\t{\n\t\t\tlogger.error(\"Error occurred while generating RDF\", e);\n\t\t\tthrow new KarmaException(e.getMessage());\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tremoveWorkspace(workspace);\n\t\t}\n\t\t\n\t\tlogger.debug(\"Generated rdf for {}\", sourceName);\n\t}\n\t\n\tpublic void generateRDF(RDFGeneratorRequest request) throws KarmaException, IOException\n\t{\n\t\tgenerateRDF(request.getModelName(), request.getSourceName(), request.getContextName(), \n\t\t\t\trequest.getInput(), request.getDataType(), request.getInputTypeProperties(), request.isAddProvenance(), \n\t\t\t\trequest.getWriters(), request.getStrategy(), \n\t\t\t\trequest.getTripleMapToKill(), request.getTripleMapToStop(), request.getPOMToKill(), request.getContextParameters());\n\t}\n\n\t\n\n}", "item_id": 0, "repo": "rpatil524/Web-Karma", "file": "karma-offline/src/main/java/edu/isi/karma/rdf/GenericRDFGenerator.java", "last_update_at": "2022-03-15T07:55:38+00:00", "question_id": "b9aea6b7b81ad451b5ee08ec7644a93e03ff3ba9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GenericRDFGenerator extends RdfGenerator {\n\tprivate static Logger logger = LoggerFactory.getLogger(GenericRDFGenerator.class);\n\tprotected R2RMLMappingManager mappingManager = new R2RMLMappingManager();\n\tprotected JSONLDContextManager contextManager = new JSONLDContextManager();\n\t\n\tpublic enum InputType {\n\t\tCSV,\n\t\tJSON,\n\t\tXML,\n\t\tAVRO,\n\t\tEXCEL,\n\t\tJL,\n\t\tOBJECT\n\t};\n\t\n\tpublic GenericRDFGenerator() {\n\t\tthis(null);\n\t}\n\t\n\tpublic GenericRDFGenerator(String selectionName) {\n\t\tsuper(selectionName);\n\t}\n\tpublic void addModel(R2RMLMappingIdentifier id) {\n\t\tthis.mappingManager.addModel(id);\n\t}\n    public void addContext(ContextIdentifier id) {\n    \tthis.contextManager.addContext(id);\n    }\n    public JSONObject getContext(ContextIdentifier id) throws IOException {\n    \treturn this.contextManager.getContext(null, id);\n    }\n    public WorksheetR2RMLJenaModelParser getModelParser(String modelName) throws JSONException, KarmaException {\n    \treturn this.mappingManager.getModelParser(modelName);\n    }\n\tprivate void generateRDF(String modelName, String sourceName,String contextName, RDFGeneratorInputWrapper input, InputType dataType,  InputProperties inputTypeParameters, \n\t\t\tboolean addProvenance, List<KR2RMLRDFWriter> writers, RootStrategy rootStrategy, \n\t\t\tList<String> tripleMapToKill, List<String> tripleMapToStop, List<String> POMToKill, ServletContextParameterMap contextParameters)\n\t\t\t\t\tthrows KarmaException, IOException {\n\t\t\n\t\tR2RMLMappingIdentifier id = mappingManager.getMappingIdentifierByName(modelName);\n\t\tContextIdentifier contextId = contextManager.getContextIdentifier(contextName);\n\t\tJSONObject context = contextManager.getContext(contextName, contextId);\n\t\tinitializeRDFWriters(writers, id, contextId, context);\n\t\t//Check if the parser for this model exists, else create one\n\t\tWorksheetR2RMLJenaModelParser modelParser = mappingManager.getModelParser(modelName);\n\t\tgenerateRDF(modelParser, sourceName, input, dataType, inputTypeParameters, addProvenance, writers, rootStrategy, tripleMapToKill, tripleMapToStop, POMToKill, contextParameters);\n\t}\n\tprivate void initializeRDFWriters(List<KR2RMLRDFWriter> writers, R2RMLMappingIdentifier id,\n\t\t\tContextIdentifier contextId, JSONObject context) {\n\t\tfor (KR2RMLRDFWriter writer : writers) {\n\t\t\tif (writer instanceof JSONKR2RMLRDFWriter) {\n\t\t\t\tJSONKR2RMLRDFWriter t = (JSONKR2RMLRDFWriter)writer;\n\t\t\t\tt.setGlobalContext(context, contextId);\n\t\t\t}\n\t\t\twriter.setR2RMLMappingIdentifier(id);\n\t\t}\n\t}\n\t\n\tprivate void generateRDF(WorksheetR2RMLJenaModelParser modelParser, String sourceName, RDFGeneratorInputWrapper input, InputType dataType,  InputProperties inputTypeParameters,\n\t\t\tboolean addProvenance, List<KR2RMLRDFWriter> writers, RootStrategy rootStrategy, \n\t\t\tList<String> tripleMapToKill, List<String> tripleMapToStop, List<String> POMToKill, ServletContextParameterMap contextParameters) throws KarmaException, IOException {\n\t\tlogger.debug(\"Generating rdf for \" + sourceName);\n\t\t\n\t\tif(contextParameters == null)\n\t\t{\n\t\t\tcontextParameters = ContextParametersRegistry.getInstance().getDefault();\n\t\t\tlogger.debug(\"No context specified.  Defaulting to: \" + contextParameters.getKarmaHome());\n\t\t}\n\t\tlogger.debug(\"Initializing workspace for {}\", sourceName);\n\t\tWorkspace workspace = initializeWorkspace(contextParameters);\n\t\tlogger.debug(\"Initialized workspace for {}\", sourceName);\n\t\ttry\n\t\t{\n\t\t\n\t\t\tlogger.debug(\"Generating worksheet for {}\", sourceName);\n\t\t\tWorksheet worksheet = null;\n\t\t\tif(input.getHeaders() != null) {\n\t\t\t\tworksheet = WorksheetGenerator.generateWorksheet(sourceName, input.getHeaders(), input.getValues(), workspace);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tInputStream data = input.getInputAsStream();\n\t\t\t\tworksheet = WorksheetGenerator.generateWorksheet(sourceName, new BufferedInputStream(data), dataType, inputTypeParameters,\n\t\t\t\t\tworkspace);\n\t\t\t}\n\t\t\tlogger.debug(\"Generated worksheet for {}\", sourceName);\n\t\t\tlogger.debug(\"Parsing mapping for {}\", sourceName);\n\t\t\t//Generate mappping data for the worksheet using the model parser\n\t\t\tKR2RMLMapping mapping = modelParser.parse();\n\t\t\tlogger.debug(\"Parsed mapping for {}\", sourceName);\n\t\t\tapplyHistoryToWorksheet(workspace, worksheet, mapping);\n\t\t\tSuperSelection selection = SuperSelectionManager.DEFAULT_SELECTION;\n\t\t\tif (selectionName != null && !selectionName.trim().isEmpty())\n\t\t\t\tselection = worksheet.getSuperSelectionManager().getSuperSelection(selectionName);\n\t\t\tif (selection == null)\n\t\t\t\treturn;\n\t\t\t//Generate RDF using the mapping data\n\t\t\tErrorReport errorReport = new ErrorReport();\n\t\t\tif(rootStrategy == null)\n\t\t\t{\n\t\t\t\trootStrategy = new SteinerTreeRootStrategy(new WorksheetDepthRootStrategy());\n\t\t\t}\n\t\t\tlogger.debug(\"Generating output for {}\", sourceName);\n\t\t\tKR2RMLWorksheetRDFGenerator rdfGen = new KR2RMLWorksheetRDFGenerator(worksheet,\n\t\t\t        workspace, writers,\n\t\t\t        addProvenance, rootStrategy, tripleMapToKill, tripleMapToStop, POMToKill, \n\t\t\t        mapping, errorReport, selection);\n\t\t\trdfGen.generateRDF(true);\n\t\t\tlogger.debug(\"Generated output for {}\", sourceName);\n\t\t}\n\t\tcatch( Exception e)\n\t\t{\n\t\t\tlogger.error(\"Error occurred while generating RDF\", e);\n\t\t\tthrow new KarmaException(e.getMessage());\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tremoveWorkspace(workspace);\n\t\t}\n\t\t\n\t\tlogger.debug(\"Generated rdf for {}\", sourceName);\n\t}\n\t\n\tpublic void generateRDF(RDFGeneratorRequest request) throws KarmaException, IOException\n\t{\n\t\tgenerateRDF(request.getModelName(), request.getSourceName(), request.getContextName(), \n\t\t\t\trequest.getInput(), request.getDataType(), request.getInputTypeProperties(), request.isAddProvenance(), \n\t\t\t\trequest.getWriters(), request.getStrategy(), \n\t\t\t\trequest.getTripleMapToKill(), request.getTripleMapToStop(), request.getPOMToKill(), request.getContextParameters());\n\t}\n\t\n"]], "pred": {"ppl": 2.3453359603881836, "ppl_lower": 2.5830109119415283, "ppl/lowercase_ppl": -1.1132377230138288, "ppl/zlib": 0.0005311081983343349, "Min_5.0% Prob": 7.745731802547679, "Min_10.0% Prob": 5.74954588506736, "Min_20.0% Prob": 3.735740214586258, "Min_30.0% Prob": 2.721853785362898, "Min_40.0% Prob": 2.102171622271351, "Min_50.0% Prob": 1.6985497590292924, "Min_60.0% Prob": 1.4202843503069382}}
{"hexsha": "30b43951ad5eee1293c46ed19eef06130536df62", "ext": "java", "lang": "Java", "content": "public class KHashingPanel extends JPanel {\n  private static final JLabel LABEL = new JLabel(\"Choose one of 3 options below.\");\n\n  private static final JLabel LABEL_EMPTY_1 = new JLabel(\" \");\n  private static final JLabel LABEL_OPTION_1 = new JLabel(\"1. Get SHA3 of a chosen file.\");\n  private static final JButton BUTTON_OPTION_1 = new JButton(\"SHA3 - file\");\n\n  private static final JLabel LABEL_EMPTY_2 = new JLabel(\" \");\n  private static final JLabel LABEL_OPTION_2 = new JLabel(\n      \"2. Get SHA3 of an input text. Enter your text in blank field below.\");\n  private static final JTextArea TEXT_OPTION_2 = new JTextArea();\n  private static final JScrollPane SCROLL_OPTION_2 = new JScrollPane(TEXT_OPTION_2);\n  private static final JButton BUTTON_OPTION_2 = new JButton(\"SHA3 - text input\");\n\n  private static final JLabel LABEL_EMPTY_3 = new JLabel(\" \");\n  private static final JLabel LABEL_OPTION_3 = new JLabel(\n      \"3. Get MAC of a chosen file. Enter MAC passphrase below (empty field is an empty passphrase)\");\n  private static final JTextArea TEXT_OPTION_3 = new JTextArea();\n  private static final JScrollPane SCROLL_OPTION_3 = new JScrollPane(TEXT_OPTION_3);\n  private static final JButton BUTTON_OPTION_3 = new JButton(\"MAC - file\");\n\n  private static final JLabel LABEL_EMPTY_4 = new JLabel(\" \");\n\n  public KHashingPanel(JTextArea console) {\n    this.setLayout(new BoxLayout(this, BoxLayout.PAGE_AXIS));\n    TEXT_OPTION_2.setLineWrap(true);\n    TEXT_OPTION_3.setLineWrap(true);\n\n    try {\n      UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n    } catch (Exception e) {\n      System.out.println(e);\n    }\n\n    addButtonBehavior(console);\n\n    this.add(LABEL);\n\n    this.add(LABEL_EMPTY_1);\n    this.add(LABEL_OPTION_1);\n    this.add(BUTTON_OPTION_1);\n\n    this.add(LABEL_EMPTY_2);\n    this.add(LABEL_OPTION_2);\n    this.add(SCROLL_OPTION_2);\n    this.add(BUTTON_OPTION_2);\n\n    this.add(LABEL_EMPTY_3);\n    this.add(LABEL_OPTION_3);\n    this.add(SCROLL_OPTION_3);\n    this.add(BUTTON_OPTION_3);\n\n    this.add(LABEL_EMPTY_4);\n\n    this.setVisible(true);\n\n  }\n\n  /**\n   * A helper method to add listener to components\n   */\n  private void addButtonBehavior(JTextArea console) {\n    BUTTON_OPTION_1.addActionListener(event -> {\n      final File directory = UtilGui.fileBrowse();\n      String outval = directory == null ? \"Error: You must chose a file!\"\n          : \"SHA3 of your file is: \" + KCrypt.get_sha3_file(directory);\n      console.setText(outval);\n    });\n    BUTTON_OPTION_2.addActionListener(event -> {\n      final String m = TEXT_OPTION_2.getText();\n      console.setText(\"SHA3 of your text input is: \" + KCrypt.get_sha3_text(m));\n    });\n    BUTTON_OPTION_3.addActionListener(event -> {\n      final File directory = UtilGui.fileBrowse();\n      String passphrase = TEXT_OPTION_3.getText();\n      String outval = directory == null ? \"Error: You must chose a file!\"\n          : \"MAC of your file is: \" + KCrypt.get_mac_file(directory, passphrase);\n      console.setText(outval);\n\n    });\n  }\n}", "item_id": 0, "repo": "hunghvu/encryption-and-digital-signatures", "file": "src/gui/KHashingPanel.java", "last_update_at": "2022-03-02T16:26:02+00:00", "question_id": "30b43951ad5eee1293c46ed19eef06130536df62_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class KHashingPanel extends JPanel {\n  private static final JLabel LABEL = new JLabel(\"Choose one of 3 options below.\");\n  private static final JLabel LABEL_EMPTY_1 = new JLabel(\" \");\n  private static final JLabel LABEL_OPTION_1 = new JLabel(\"1. Get SHA3 of a chosen file.\");\n  private static final JButton BUTTON_OPTION_1 = new JButton(\"SHA3 - file\");\n  private static final JLabel LABEL_EMPTY_2 = new JLabel(\" \");\n  private static final JLabel LABEL_OPTION_2 = new JLabel(\n      \"2. Get SHA3 of an input text. Enter your text in blank field below.\");\n  private static final JTextArea TEXT_OPTION_2 = new JTextArea();\n  private static final JScrollPane SCROLL_OPTION_2 = new JScrollPane(TEXT_OPTION_2);\n  private static final JButton BUTTON_OPTION_2 = new JButton(\"SHA3 - text input\");\n  private static final JLabel LABEL_EMPTY_3 = new JLabel(\" \");\n  private static final JLabel LABEL_OPTION_3 = new JLabel(\n      \"3. Get MAC of a chosen file. Enter MAC passphrase below (empty field is an empty passphrase)\");\n  private static final JTextArea TEXT_OPTION_3 = new JTextArea();\n  private static final JScrollPane SCROLL_OPTION_3 = new JScrollPane(TEXT_OPTION_3);\n  private static final JButton BUTTON_OPTION_3 = new JButton(\"MAC - file\");\n  private static final JLabel LABEL_EMPTY_4 = new JLabel(\" \");\n  public KHashingPanel(JTextArea console) {\n    this.setLayout(new BoxLayout(this, BoxLayout.PAGE_AXIS));\n    TEXT_OPTION_2.setLineWrap(true);\n    TEXT_OPTION_3.setLineWrap(true);\n    try {\n      UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n    } catch (Exception e) {\n      System.out.println(e);\n    }\n    addButtonBehavior(console);\n    this.add(LABEL);\n    this.add(LABEL_EMPTY_1);\n    this.add(LABEL_OPTION_1);\n    this.add(BUTTON_OPTION_1);\n    this.add(LABEL_EMPTY_2);\n    this.add(LABEL_OPTION_2);\n    this.add(SCROLL_OPTION_2);\n    this.add(BUTTON_OPTION_2);\n    this.add(LABEL_EMPTY_3);\n    this.add(LABEL_OPTION_3);\n    this.add(SCROLL_OPTION_3);\n    this.add(BUTTON_OPTION_3);\n    this.add(LABEL_EMPTY_4);\n    this.setVisible(true);\n  }\n  /**\n   * A helper method to add listener to components\n   */\n  private void addButtonBehavior(JTextArea console) {\n    BUTTON_OPTION_1.addActionListener(event -> {\n      final File directory = UtilGui.fileBrowse();\n      String outval = directory == null ? \"Error: You must chose a file!\"\n          : \"SHA3 of your file is: \" + KCrypt.get_sha3_file(directory);\n      console.setText(outval);\n    });\n    BUTTON_OPTION_2.addActionListener(event -> {\n      final String m = TEXT_OPTION_2.getText();\n      console.setText(\"SHA3 of your text input is: \" + KCrypt.get_sha3_text(m));\n    });\n    BUTTON_OPTION_3.addActionListener(event -> {\n      final File directory = UtilGui.fileBrowse();\n      String passphrase = TEXT_OPTION_3.getText();\n      String outval = directory == null ? \"Error: You must chose a file!\"\n          : \"MAC of your file is: \" + KCrypt.get_mac_file(directory, passphrase);\n      console.setText(outval);\n    });\n  }\n"]], "pred": {"ppl": 1.6469234228134155, "ppl_lower": 1.8391069173812866, "ppl/lowercase_ppl": -1.2212249880416848, "ppl/zlib": 0.0005953567484035687, "Min_5.0% Prob": 5.658202592064352, "Min_10.0% Prob": 4.03096357981364, "Min_20.0% Prob": 2.41499454791055, "Min_30.0% Prob": 1.656279347252612, "Min_40.0% Prob": 1.2454323630374662, "Min_50.0% Prob": 0.9981730690307062, "Min_60.0% Prob": 0.8324454013407488}}
{"hexsha": "fe89af7acaa65eceae4b9f95b8e9df9bd5e37b91", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"serial\")\npublic class JerichoDocumentPreprocessing implements DocumentPreprocessing {\n\n\t@Override\n\tpublic String preprocessRawDocument(String html) {\n        Source source = new Source(html);\n        source.fullSequentialParse();\n\n        TextExtractor extractor = source.getFirstElement(HTMLElementName.BODY).getTextExtractor();\n\n        extractor.setConvertNonBreakingSpaces(true);\n        extractor.setExcludeNonHTMLElements(false);\n        extractor.setIncludeAttributes(false);\n\n        return extractor.toString();\n\t}\n}", "item_id": 0, "repo": "chatnoir-eu/chatnoir-copycat", "file": "copycat-modules/document-preprocessing/src/main/java/de/webis/copycat/document_preprocessing/JerichoDocumentPreprocessing.java", "last_update_at": "2022-01-31T03:33:24+00:00", "question_id": "fe89af7acaa65eceae4b9f95b8e9df9bd5e37b91_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"serial\")\npublic class JerichoDocumentPreprocessing implements DocumentPreprocessing {\n\t@Override\n\tpublic String preprocessRawDocument(String html) {\n        Source source = new Source(html);\n        source.fullSequentialParse();\n        TextExtractor extractor = source.getFirstElement(HTMLElementName.BODY).getTextExtractor();\n        extractor.setConvertNonBreakingSpaces(true);\n        extractor.setExcludeNonHTMLElements(false);\n        extractor.setIncludeAttributes(false);\n        return extractor.toString();\n\t}\n"]], "pred": {"ppl": 2.8466548919677734, "ppl_lower": 5.513577938079834, "ppl/lowercase_ppl": -1.6319099616129726, "ppl/zlib": 0.003670682746711325, "Min_5.0% Prob": 8.085386276245117, "Min_10.0% Prob": 6.490266118730817, "Min_20.0% Prob": 4.437079589942406, "Min_30.0% Prob": 3.3131660399111835, "Min_40.0% Prob": 2.6049748271189888, "Min_50.0% Prob": 2.094680520361417, "Min_60.0% Prob": 1.7442916830239648}}
{"hexsha": "992af0e005facaad163ec2e5e5ed238d810ac350", "ext": "java", "lang": "Java", "content": "public class Navigations {\n\n    /**\n     * Returns the next step position to navigate to.\n     * In case an error key was set in the runtime services, throw an error event and return null.\n     *\n     * @param runEnv                   the run environment\n     * @param systemContext            the system context\n     * @param currentStepId            the current step's id\n     * @return the step id the score engine needs to navigate to the next step\n     */\n    public Long navigate(@Param(ScoreLangConstants.RUN_ENV) RunEnvironment runEnv,\n                         @Param(SYSTEM_CONTEXT) SystemContext systemContext,\n                         @Param(CURRENT_STEP_ID_KEY) Long currentStepId) {\n\n        if (shouldPause(systemContext)) {\n            return currentStepId;\n        }\n\n        // If we have an error key stored, we fire an error event and return null as the next position\n        if (systemContext.hasStepErrorKey()) {\n            AbstractExecutionData.fireEvent(\n                    systemContext,\n                runEnv,\n                ScoreLangConstants.SLANG_EXECUTION_EXCEPTION,\n                \"Error detected during step\",\n                LanguageEventData.StepType.NAVIGATION,\n                null,\n                extractContext(runEnv),\n                Pair.of(LanguageEventData.EXCEPTION, systemContext.getStepErrorKey()));\n            throw new RuntimeException(systemContext.getStepErrorKey());\n        }\n\n        // return the next step position from the run env\n        return runEnv.removeNextStepPosition();\n\n    }\n\n    private boolean shouldPause(SystemContext systemContext) {\n        return systemContext.isPaused() && !systemContext.hasStepErrorKey();\n    }\n\n    private Map<String, Value> extractContext(@Param(ScoreLangConstants.RUN_ENV) RunEnvironment runEnv) {\n        Context context = runEnv.getStack().popContext();\n        Map<String, Value> contextMap;\n        if (context != null) {\n            runEnv.getStack().pushContext(context);\n            contextMap = context.getImmutableViewOfVariables();\n        } else {\n            contextMap = new HashMap<>();\n        }\n        return contextMap;\n    }\n\n}", "item_id": 0, "repo": "srinisubramanian/cloud-slang", "file": "cloudslang-runtime/src/main/java/io/cloudslang/lang/runtime/navigations/Navigations.java", "last_update_at": "2022-03-06T00:10:22+00:00", "question_id": "992af0e005facaad163ec2e5e5ed238d810ac350_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Navigations {\n    /**\n     * Returns the next step position to navigate to.\n     * In case an error key was set in the runtime services, throw an error event and return null.\n     *\n     * @param runEnv                   the run environment\n     * @param systemContext            the system context\n     * @param currentStepId            the current step's id\n     * @return the step id the score engine needs to navigate to the next step\n     */\n    public Long navigate(@Param(ScoreLangConstants.RUN_ENV) RunEnvironment runEnv,\n                         @Param(SYSTEM_CONTEXT) SystemContext systemContext,\n                         @Param(CURRENT_STEP_ID_KEY) Long currentStepId) {\n        if (shouldPause(systemContext)) {\n            return currentStepId;\n        }\n        // If we have an error key stored, we fire an error event and return null as the next position\n        if (systemContext.hasStepErrorKey()) {\n            AbstractExecutionData.fireEvent(\n                    systemContext,\n                runEnv,\n                ScoreLangConstants.SLANG_EXECUTION_EXCEPTION,\n                \"Error detected during step\",\n                LanguageEventData.StepType.NAVIGATION,\n                null,\n                extractContext(runEnv),\n                Pair.of(LanguageEventData.EXCEPTION, systemContext.getStepErrorKey()));\n            throw new RuntimeException(systemContext.getStepErrorKey());\n        }\n        // return the next step position from the run env\n        return runEnv.removeNextStepPosition();\n    }\n    private boolean shouldPause(SystemContext systemContext) {\n        return systemContext.isPaused() && !systemContext.hasStepErrorKey();\n    }\n    private Map<String, Value> extractContext(@Param(ScoreLangConstants.RUN_ENV) RunEnvironment runEnv) {\n        Context context = runEnv.getStack().popContext();\n        Map<String, Value> contextMap;\n        if (context != null) {\n            runEnv.getStack().pushContext(context);\n            contextMap = context.getImmutableViewOfVariables();\n        } else {\n            contextMap = new HashMap<>();\n        }\n        return contextMap;\n    }\n"]], "pred": {"ppl": 2.71087384223938, "ppl_lower": 3.6896846294403076, "ppl/lowercase_ppl": -1.3091135144913197, "ppl/zlib": 0.0013173989880136017, "Min_5.0% Prob": 7.493436079758864, "Min_10.0% Prob": 5.926257092997713, "Min_20.0% Prob": 4.196071342477259, "Min_30.0% Prob": 3.125319866091013, "Min_40.0% Prob": 2.4488995462096352, "Min_50.0% Prob": 1.9803491031074345, "Min_60.0% Prob": 1.6603088633273728}}
{"hexsha": "879dc8dd9e67585a4d687d3eb68b0979e66c2335", "ext": "java", "lang": "Java", "content": "@Component\npublic class MutationCreationMapper implements Mapper<Mutation, MutationCreationDTO>\n{\n    private final MutationCommonMapper mutationCommonMapper;\n    private final GeneCreationMapper geneCreationMapper;\n\n    public MutationCreationMapper(\n        MutationCommonMapper mutationCommonMapper, GeneCreationMapper geneCreationMapper)\n    {\n        this.mutationCommonMapper = mutationCommonMapper;\n        this.geneCreationMapper = geneCreationMapper;\n    }\n\n    @Override\n    public MutationCreationDTO toDto(Mutation mutation)\n    {\n        return null;\n    }\n\n    @Override\n    public Mutation toEntity(MutationCreationDTO mutationCreationDTO)\n    {\n        Mutation mutation = new Mutation();\n        if (mutationCreationDTO.getMutationCommonDTO() != null)\n        {\n            mutation = mutationCommonMapper.toEntity(mutationCreationDTO.getMutationCommonDTO());\n        }\n        addGenes(mutation, mutationCreationDTO);\n        return mutation;\n    }\n\n    private void addGenes(Mutation mutation, MutationCreationDTO mutationCreationDTO)\n    {\n        List<GeneCreationDTO> geneCreationDTOS = mutationCreationDTO.getGeneCreationDTOS();\n        Set<Gene> genes = new HashSet<>( geneCreationMapper.toEntities(geneCreationDTOS));\n        mutation.setGenes(genes);\n    }\n}", "item_id": 0, "repo": "ogunes-ebi/impc-production-tracker", "file": "impc_prod_tracker/rest-api/src/main/java/org/gentar/biology/mutation/MutationCreationMapper.java", "last_update_at": "2022-01-10T14:35:36+00:00", "question_id": "879dc8dd9e67585a4d687d3eb68b0979e66c2335_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\npublic class MutationCreationMapper implements Mapper<Mutation, MutationCreationDTO>\n{\n    private final MutationCommonMapper mutationCommonMapper;\n    private final GeneCreationMapper geneCreationMapper;\n    public MutationCreationMapper(\n        MutationCommonMapper mutationCommonMapper, GeneCreationMapper geneCreationMapper)\n    {\n        this.mutationCommonMapper = mutationCommonMapper;\n        this.geneCreationMapper = geneCreationMapper;\n    }\n    @Override\n    public MutationCreationDTO toDto(Mutation mutation)\n    {\n        return null;\n    }\n    @Override\n    public Mutation toEntity(MutationCreationDTO mutationCreationDTO)\n    {\n        Mutation mutation = new Mutation();\n        if (mutationCreationDTO.getMutationCommonDTO() != null)\n        {\n            mutation = mutationCommonMapper.toEntity(mutationCreationDTO.getMutationCommonDTO());\n        }\n        addGenes(mutation, mutationCreationDTO);\n        return mutation;\n    }\n    private void addGenes(Mutation mutation, MutationCreationDTO mutationCreationDTO)\n    {\n        List<GeneCreationDTO> geneCreationDTOS = mutationCreationDTO.getGeneCreationDTOS();\n        Set<Gene> genes = new HashSet<>( geneCreationMapper.toEntities(geneCreationDTOS));\n        mutation.setGenes(genes);\n    }\n"]], "pred": {"ppl": 1.4856417179107666, "ppl_lower": 1.7009906768798828, "ppl/lowercase_ppl": -1.341960617295428, "ppl/zlib": 0.001111929247711274, "Min_5.0% Prob": 5.1322565204218815, "Min_10.0% Prob": 3.305801313174398, "Min_20.0% Prob": 1.9109244280821318, "Min_30.0% Prob": 1.3141216338652633, "Min_40.0% Prob": 0.9891481791296369, "Min_50.0% Prob": 0.7910006270801813, "Min_60.0% Prob": 0.6612959903714275}}
{"hexsha": "d90ec197047b76cfb33f23408fe71de503ea3f2c", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"serial\")\r\npublic class VariableType implements java.io.Serializable, org.vcell.util.Matchable {\r\n\r\n\tprivate int type = -1;\r\n\tprivate VariableDomain variableDomain;\r\n\tprivate final String name;\r\n\tprivate final String units;\r\n\tprivate final String label;\r\n\t/**\r\n\t * mark types that were not previously supported by {@link #getVariableTypeFromInteger(int)}, issue warning if triggered\r\n\t */\r\n\tprivate boolean legacyWarn = false;\r\n\tprivate static final List<VariableType> allTypes = new ArrayList<>();\r\n\tprivate static final Logger LG = LogManager.getLogger(VariableType.class);\r\n\t\r\n\t//match constants in numerics SimTypes.h\r\n\tprivate static final int UNKNOWN_TYPE = 0;\r\n\tprivate static final int VOLUME_TYPE = 1;\r\n\tprivate static final int MEMBRANE_TYPE = 2;\r\n\tprivate static final int CONTOUR_TYPE = 3;\r\n\tprivate static final int VOLUME_REGION_TYPE = 4;\r\n\tprivate static final int MEMBRANE_REGION_TYPE = 5;\r\n\tprivate static final int CONTOUR_REGION_TYPE = 6;\r\n\tprivate static final int NONSPATIAL_TYPE = 7;\r\n\tprivate static final int VOLUME_PARTICLE = 8; \r\n\tprivate static final int MEMBRANE_PARTICLE = 9; \r\n\tprivate static final int POINT_VARIABLE_TYPE = 10; \r\n\t/**\r\n\t * not generated by solver \r\n\t */\r\n\tprivate static final int POSTPROCESSING_TYPE = 999;\r\n\t\r\n//\tprivate static final String[] NAMES = {\"Unknown\",\"Volume\",\"Membrane\",\"Contour\",\"Volume_Region\",\"Membrane_Region\",\"Contour_Region\",\"Nonspatial\",\"Post_Process\"};\r\n//\tprivate static final String[] LABEL = {\"Unknown\",\"Conc\",\"Density\",\"Density\",\"Conc\",\"Density\",\"Density\",\"Conc\",\"Unknown\"};\r\n//\tprivate static final String[] UNITS = {\"Unknown\",\"uM\",\"molecules/um^2\",\"molecules/um\",\"uM\",\"molecules/um^2\",\"molecules/um\",\"uM\",\"Unknown\"};\r\n\t\r\n\tpublic static final VariableType UNKNOWN = new VariableType(UNKNOWN_TYPE,\"Unknown\",\"Unknown\",\"Unknown\");\r\n\tpublic static final VariableType VOLUME = new TwoCodeType(VOLUME_TYPE,VOLUME_PARTICLE,\"Volume\",\"uM\",\"Conc\");\r\n\tpublic static final VariableType MEMBRANE = new TwoCodeType(MEMBRANE_TYPE,MEMBRANE_PARTICLE,\"Membrane\",\"molecules/um^2\",\"Density\");\r\n\tpublic static final VariableType CONTOUR = new VariableType(CONTOUR_TYPE,\"Contour\",\"molecules/um\",\"Density\");\r\n\tpublic static final VariableType VOLUME_REGION = new VariableType(VOLUME_REGION_TYPE,\"Volume_Region\",\"uM\",\"Conc\");\r\n\tpublic static final VariableType MEMBRANE_REGION = new VariableType(MEMBRANE_REGION_TYPE,\"Membrane_Region\",\"molecules/um^2\",\"Density\");\r\n\tpublic static final VariableType CONTOUR_REGION = new VariableType(CONTOUR_REGION_TYPE,\"Contour_Region\",\"molecules/um\",\"Density\");\r\n\tpublic static final VariableType NONSPATIAL = new VariableType(NONSPATIAL_TYPE,\"Nonspatial\",\"uM\",\"Conc\");\r\n\tpublic static final VariableType POSTPROCESSING = new VariableType(POSTPROCESSING_TYPE,\"Post_Process\",\"Unknown\",\"Unknown\");\r\n\tpublic static final VariableType POINT_VARIABLE = new VariableType(POINT_VARIABLE_TYPE,\"Point\",\"uM\",\"Conc\");\r\n\tstatic {\r\n\t\tUNKNOWN.legacyWarn = true;\r\n\t\tNONSPATIAL.legacyWarn = true;\r\n\t}\r\n\t\r\n\tpublic enum VariableDomain {\r\n\t\tVARIABLEDOMAIN_POSTPROCESSING(\"PostProcessing\"),\r\n\t\tVARIABLEDOMAIN_UNKNOWN(\"Unknown\"),\r\n\t\tVARIABLEDOMAIN_VOLUME(\"Volume\"),\r\n\t\tVARIABLEDOMAIN_MEMBRANE(\"Membrane\"),\r\n\t\tVARIABLEDOMAIN_CONTOUR(\"Contour\"),\r\n\t\tVARIABLEDOMAIN_NONSPATIAL(\"Nonspatial\"),\r\n\t\tVARIABLEDOMAIN_POINT(\"Point\");\r\n\t\t\r\n\t\tprivate String name = null;\r\n\t\tprivate VariableDomain(String arg_name) {\r\n\t\t\tname = arg_name;\r\n\t\t}\r\n\t\tpublic String getName() {\r\n\t\t\treturn name;\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t * create and store reference in class list\r\n\t * @param varType\r\n\t */\r\n\tprotected VariableType(int varType, String name, String units, String label) {\r\n\t\tsuper();\r\n\t\tthis.type = varType;\r\n\t\tthis.name = name;\r\n\t\tthis.units = units;\r\n\t\tthis.label = label;\r\n\t\tswitch (type) {\r\n\t\tcase UNKNOWN_TYPE:\r\n\t\t\tvariableDomain = VariableDomain.VARIABLEDOMAIN_UNKNOWN;\r\n\t\t\tbreak;\r\n\t\tcase POSTPROCESSING_TYPE:\r\n\t\t\tvariableDomain = VariableDomain.VARIABLEDOMAIN_POSTPROCESSING;\r\n\t\t\tbreak;\r\n\t\tcase VOLUME_TYPE:\r\n\t\tcase VOLUME_REGION_TYPE:\r\n\t\t\tvariableDomain = VariableDomain.VARIABLEDOMAIN_VOLUME;\r\n\t\t\tbreak;\r\n\t\tcase MEMBRANE_TYPE:\r\n\t\tcase MEMBRANE_REGION_TYPE:\r\n\t\t\tvariableDomain = VariableDomain.VARIABLEDOMAIN_MEMBRANE;\r\n\t\t\tbreak;\r\n\t\tcase CONTOUR_TYPE:\r\n\t\tcase CONTOUR_REGION_TYPE:\r\n\t\t\tvariableDomain = VariableDomain.VARIABLEDOMAIN_CONTOUR;\r\n\t\t\tbreak;\r\n\t\tcase NONSPATIAL_TYPE:\r\n\t\t\tvariableDomain = VariableDomain.VARIABLEDOMAIN_NONSPATIAL;\r\n\t\t\tbreak;\r\n\t\tcase POINT_VARIABLE_TYPE:\r\n\t\t\tvariableDomain = VariableDomain.VARIABLEDOMAIN_POINT;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthrow new RuntimeException(\"Unknown variable type \" + type);\r\n\t\t}\r\n\t\tallTypes.add(this);\r\n\t}\r\n/**\r\n * Insert the method's description here.\r\n * Creation date: (5/24/2001 9:28:51 PM)\r\n * @return boolean\r\n * @param obj cbit.util.Matchable\r\n */\r\npublic boolean compareEqual(Matchable obj) {\r\n\treturn equals(obj);\r\n}\r\n/**\r\n * Insert the method's description here.\r\n * Creation date: (10/3/00 5:42:33 PM)\r\n */\r\npublic boolean equals(Object obj) {\r\n\tif (obj == null) {\r\n\t\treturn false;\r\n\t}\r\n\tif (!(obj instanceof VariableType)) {\r\n\t\treturn false;\r\n\t}\r\n\tVariableType pdeVT = (VariableType) obj;\r\n\tif (type!=pdeVT.type) {\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\npublic String getDefaultLabel() {\r\n\t return  label;\r\n}\r\n\r\npublic String getDefaultUnits() {\r\n\treturn units; \r\n}\r\n\r\npublic int getType() {\r\n\treturn type;\r\n}\r\n\r\npublic String getTypeName() {\r\n\treturn name;\r\n}\r\n///**\r\n// * Insert the method's description here.\r\n// * Creation date: (10/3/00 2:48:55 PM)\r\n// * @return cbit.vcell.simdata.PDEVariableType\r\n// * @param mesh cbit.vcell.solvers.CartesianMesh\r\n// * @param dataLength int\r\n// */\r\n//public static final VariableType getVariableTypeFromInteger(int varType) {\r\n//\tif (varType==VOLUME.type){\r\n//\t\treturn VOLUME;\r\n//\t}else if (varType==MEMBRANE.type){\r\n//\t\treturn MEMBRANE;\r\n//\t}else if (varType==CONTOUR.type){\r\n//\t\treturn CONTOUR;\r\n//\t}else if (varType==VOLUME_REGION.type){\r\n//\t\treturn VOLUME_REGION;\r\n//\t}else if (varType==MEMBRANE_REGION.type){\r\n//\t\treturn MEMBRANE_REGION;\r\n//\t}else if (varType==CONTOUR_REGION.type){\r\n//\t\treturn CONTOUR_REGION;\r\n//\t}else{\r\n//\t\tthrow new IllegalArgumentException(\"varType=\"+varType+\" is undefined\");\r\n//\t}\r\n//}\r\n\r\n\r\n\r\n/**\r\n * search types to match criteria\r\n * @param criteria\r\n * @param errorMsg to display if miss\r\n * @return type that matches\r\n * @throws IllegalArgumentException if no match\r\n */\r\nprivate static final VariableType find(Predicate<VariableType> criteria, String errorMsg) {\r\n\tOptional<VariableType> vt = allTypes.stream().filter( criteria ).findFirst();\r\n\tif (vt.isPresent()) {\r\n\t\treturn vt.get();\r\n\t}\r\n\t\r\n\tthrow new IllegalArgumentException(\"varType=\"+errorMsg+\" is undefined\");\t\r\n\t\r\n}\r\npublic static final VariableType getVariableTypeFromInteger(int varType) {\r\n\tPredicate<VariableType> pred = v -> v.supportsCode(varType);\r\n\treturn find(pred,Integer.toString(varType));\r\n\t\r\n}\r\npublic static final VariableType getVariableTypeFromVariableTypeName(String type) {\t\r\n\tPredicate<VariableType> pred = v -> v.name.equals(type);\r\n\treturn find(pred,type);\r\n}\r\n\r\npublic static final VariableType getVariableTypeFromVariableTypeNameIgnoreCase(String type) {\t\r\n\tPredicate<VariableType> pred = v -> v.name.equalsIgnoreCase(type);\r\n\treturn find(pred,type);\r\n}\r\n\r\n/**\r\n * Insert the method's description here.\r\n * Creation date: (10/5/00 11:01:55 AM)\r\n * @return int\r\n */\r\npublic int hashCode() {\r\n\treturn type;\r\n}\r\n/**\r\n * Insert the method's description here.\r\n * Creation date: (7/6/01 4:05:42 PM)\r\n * @return boolean\r\n * @param varType cbit.vcell.simdata.VariableType\r\n */\r\npublic boolean isExpansionOf(VariableType varType) {\r\n\t//\r\n\t// an enclosing domain (e.g. VOLUME) is an expansion of an enclosed region (e.g. VOLUME_REGION).\r\n\t//\r\n\t// example: if VOLUME_REGION and VOLUME data are used in same function,\r\n\t// then function must be evaluated at each volume index (hence VOLUME wins).\r\n\t//\r\n\tif (type == VOLUME_TYPE && varType.type == VOLUME_REGION_TYPE) return true;\r\n\tif (type == MEMBRANE_TYPE && varType.type == MEMBRANE_REGION_TYPE) return true;\r\n\tif (type == CONTOUR_TYPE && varType.type == CONTOUR_REGION_TYPE) return true;\r\n\tif (type != POINT_VARIABLE_TYPE && varType.type == POINT_VARIABLE_TYPE) return true;\r\n\treturn false;\r\n}\r\n/**\r\n * Insert the method's description here.\r\n * Creation date: (5/8/01 2:12:01 PM)\r\n * @return java.lang.String\r\n */\r\npublic String toString() {\r\n\treturn getTypeName()+\"_VariableType\";\r\n}\r\npublic final VariableDomain getVariableDomain() {\r\n\treturn variableDomain;\r\n}\r\n\r\npublic static VariableType getVariableType(Variable var) {\r\n\tif (var instanceof VolVariable || var instanceof VolumeParticleVariable) {\r\n\t\treturn VariableType.VOLUME;\r\n\t} else if (var instanceof VolumeRegionVariable) {\r\n\t\treturn VariableType.VOLUME_REGION;\r\n\t} else if (var instanceof MemVariable || var instanceof MembraneParticleVariable) {\r\n\t\treturn VariableType.MEMBRANE;\r\n\t} else if (var instanceof MembraneRegionVariable) {\r\n\t\treturn VariableType.MEMBRANE_REGION;\r\n\t} else if (var instanceof FilamentVariable) {\r\n\t\treturn VariableType.CONTOUR;\r\n\t} else if (var instanceof FilamentRegionVariable) {\r\n\t\treturn VariableType.CONTOUR_REGION;\r\n\t} else if (var instanceof InsideVariable) {\r\n\t\treturn VariableType.MEMBRANE;\r\n\t} else if (var instanceof OutsideVariable) {\r\n\t\treturn VariableType.MEMBRANE;\r\n\t} else if (var instanceof DataGenerator){\r\n\t\treturn VariableType.POSTPROCESSING;\r\n\t} else {\r\n\t\treturn VariableType.UNKNOWN;\r\n\t}\r\n}\r\npublic boolean incompatibleWith(VariableType funcType) {\r\n\tif ((this.type == POSTPROCESSING_TYPE || funcType.type == POSTPROCESSING_TYPE) && this.type != funcType.type){\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\n/**\r\n * does variable support code value? \r\n * @param code\r\n * @return true if does\r\n */\r\nprotected boolean supportsCode(int code) {\r\n\tfinal boolean matches = ( code == type );\r\n\tif (matches && legacyWarn  && LG.isWarnEnabled()) {\r\n\t\tLG.warn(\"code match found on \" + code + \", \" + getTypeName() + \", not previously supported\");\r\n\t}\r\n\treturn matches;\r\n}\r\n\r\nprivate static class TwoCodeType extends VariableType {\r\n\r\n\tprivate final int secondaryType;\r\n\r\n\tprotected TwoCodeType(int varType, int secondaryType,String name, String units, String label) {\r\n\t\tsuper(varType, name, units, label);\r\n\t\tthis.secondaryType = secondaryType;\r\n\t}\r\n\r\n\t/**\r\n\t * check against both codes\r\n\t */\r\n\t@Override\r\n\tprotected boolean supportsCode(int code) {\r\n\t\treturn super.supportsCode(code) || code == secondaryType;\r\n\t}\r\n\t\r\n\t\r\n\t\r\n}\r\n\r\n}", "item_id": 0, "repo": "vcellmike/Biosimulators_VCell", "file": "vcell-core/src/main/java/cbit/vcell/math/VariableType.java", "last_update_at": "2022-02-08T02:25:19+00:00", "question_id": "d90ec197047b76cfb33f23408fe71de503ea3f2c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"serial\")\r\npublic class VariableType implements java.io.Serializable, org.vcell.util.Matchable {\r\n\r\n\tprivate int type = -1;\r\n\tprivate VariableDomain variableDomain;\r\n\tprivate final String name;\r\n\tprivate final String units;\r\n\tprivate final String label;\r\n\t/**\r\n\t * mark types that were not previously supported by {@link #getVariableTypeFromInteger(int)}, issue warning if triggered\r\n\t */\r\n\tprivate boolean legacyWarn = false;\r\n\tprivate static final List<VariableType> allTypes = new ArrayList<>();\r\n\tprivate static final Logger LG = LogManager.getLogger(VariableType.class);\r\n\t\r\n\t//match constants in numerics SimTypes.h\r\n\tprivate static final int UNKNOWN_TYPE = 0;\r\n\tprivate static final int VOLUME_TYPE = 1;\r\n\tprivate static final int MEMBRANE_TYPE = 2;\r\n\tprivate static final int CONTOUR_TYPE = 3;\r\n\tprivate static final int VOLUME_REGION_TYPE = 4;\r\n\tprivate static final int MEMBRANE_REGION_TYPE = 5;\r\n\tprivate static final int CONTOUR_REGION_TYPE = 6;\r\n\tprivate static final int NONSPATIAL_TYPE = 7;\r\n\tprivate static final int VOLUME_PARTICLE = 8; \r\n\tprivate static final int MEMBRANE_PARTICLE = 9; \r\n\tprivate static final int POINT_VARIABLE_TYPE = 10; \r\n\t/**\r\n\t * not generated by solver \r\n\t */\r\n\tprivate static final int POSTPROCESSING_TYPE = 999;\r\n\t\r\n//\tprivate static final String[] NAMES = {\"Unknown\",\"Volume\",\"Membrane\",\"Contour\",\"Volume_Region\",\"Membrane_Region\",\"Contour_Region\",\"Nonspatial\",\"Post_Process\"};\r\n//\tprivate static final String[] LABEL = {\"Unknown\",\"Conc\",\"Density\",\"Density\",\"Conc\",\"Density\",\"Density\",\"Conc\",\"Unknown\"};\r\n//\tprivate static final String[] UNITS = {\"Unknown\",\"uM\",\"molecules/um^2\",\"molecules/um\",\"uM\",\"molecules/um^2\",\"molecules/um\",\"uM\",\"Unknown\"};\r\n\t\r\n\tpublic static final VariableType UNKNOWN = new VariableType(UNKNOWN_TYPE,\"Unknown\",\"Unknown\",\"Unknown\");\r\n\tpublic static final VariableType VOLUME = new TwoCodeType(VOLUME_TYPE,VOLUME_PARTICLE,\"Volume\",\"uM\",\"Conc\");\r\n\tpublic static final VariableType MEMBRANE = new TwoCodeType(MEMBRANE_TYPE,MEMBRANE_PARTICLE,\"Membrane\",\"molecules/um^2\",\"Density\");\r\n\tpublic static final VariableType CONTOUR = new VariableType(CONTOUR_TYPE,\"Contour\",\"molecules/um\",\"Density\");\r\n\tpublic static final VariableType VOLUME_REGION = new VariableType(VOLUME_REGION_TYPE,\"Volume_Region\",\"uM\",\"Conc\");\r\n\tpublic static final VariableType MEMBRANE_REGION = new VariableType(MEMBRANE_REGION_TYPE,\"Membrane_Region\",\"molecules/um^2\",\"Density\");\r\n\tpublic static final VariableType CONTOUR_REGION = new VariableType(CONTOUR_REGION_TYPE,\"Contour_Region\",\"molecules/um\",\"Density\");\r\n\tpublic static final VariableType NONSPATIAL = new VariableType(NONSPATIAL_TYPE,\"Nonspatial\",\"uM\",\"Conc\");\r\n\tpublic static final VariableType POSTPROCESSING = new VariableType(POSTPROCESSING_TYPE,\"Post_Process\",\"Unknown\",\"Unknown\");\r\n\tpublic static final VariableType POINT_VARIABLE = new VariableType(POINT_VARIABLE_TYPE,\"Point\",\"uM\",\"Conc\");\r\n\tstatic {\r\n\t\tUNKNOWN.legacyWarn = true;\r\n\t\tNONSPATIAL.legacyWarn = true;\r\n\t}\r\n\t\r\n\tpublic enum VariableDomain {\r\n\t\tVARIABLEDOMAIN_POSTPROCESSING(\"PostProcessing\"),\r\n\t\tVARIABLEDOMAIN_UNKNOWN(\"Unknown\"),\r\n\t\tVARIABLEDOMAIN_VOLUME(\"Volume\"),\r\n\t\tVARIABLEDOMAIN_MEMBRANE(\"Membrane\"),\r\n\t\tVARIABLEDOMAIN_CONTOUR(\"Contour\"),\r\n\t\tVARIABLEDOMAIN_NONSPATIAL(\"Nonspatial\"),\r\n\t\tVARIABLEDOMAIN_POINT(\"Point\");\r\n\t\t\r\n\t\tprivate String name = null;\r\n\t\tprivate VariableDomain(String arg_name) {\r\n\t\t\tname = arg_name;\r\n\t\t}\r\n\t\tpublic String getName() {\r\n\t\t\treturn name;\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t * create and store reference in class list\r\n\t * @param varType\r\n\t */\r\n\tprotected VariableType(int varType, String name, String units, String label) {\r\n\t\tsuper();\r\n\t\tthis.type = varType;\r\n\t\tthis.name = name;\r\n\t\tthis.units = units;\r\n\t\tthis.label = label;\r\n\t\tswitch (type) {\r\n\t\tcase UNKNOWN_TYPE:\r\n\t\t\tvariableDomain = VariableDomain.VARIABLEDOMAIN_UNKNOWN;\r\n\t\t\tbreak;\r\n\t\tcase POSTPROCESSING_TYPE:\r\n\t\t\tvariableDomain = VariableDomain.VARIABLEDOMAIN_POSTPROCESSING;\r\n\t\t\tbreak;\r\n\t\tcase VOLUME_TYPE:\r\n\t\tcase VOLUME_REGION_TYPE:\r\n\t\t\tvariableDomain = VariableDomain.VARIABLEDOMAIN_VOLUME;\r\n\t\t\tbreak;\r\n\t\tcase MEMBRANE_TYPE:\r\n\t\tcase MEMBRANE_REGION_TYPE:\r\n\t\t\tvariableDomain = VariableDomain.VARIABLEDOMAIN_MEMBRANE;\r\n\t\t\tbreak;\r\n\t\tcase CONTOUR_TYPE:\r\n\t\tcase CONTOUR_REGION_TYPE:\r\n\t\t\tvariableDomain = VariableDomain.VARIABLEDOMAIN_CONTOUR;\r\n\t\t\tbreak;\r\n\t\tcase NONSPATIAL_TYPE:\r\n\t\t\tvariableDomain = VariableDomain.VARIABLEDOMAIN_NONSPATIAL;\r\n\t\t\tbreak;\r\n\t\tcase POINT_VARIABLE_TYPE:\r\n\t\t\tvariableDomain = VariableDomain.VARIABLEDOMAIN_POINT;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthrow new RuntimeException(\"Unknown variable type \" + type);\r\n\t\t}\r\n\t\tallTypes.add(this);\r\n\t}\r\n/**\r\n * Insert the method's description here.\r\n * Creation date: (5/24/2001 9:28:51 PM)\r\n * @return boolean\r\n * @param obj cbit.util.Matchable\r\n */\r\npublic boolean compareEqual(Matchable obj) {\r\n\treturn equals(obj);\r\n}\r\n/**\r\n * Insert the method's description here.\r\n * Creation date: (10/3/00 5:42:33 PM)\r\n */\r\npublic boolean equals(Object obj) {\r\n\tif (obj == null) {\r\n\t\treturn false;\r\n\t}\r\n\tif (!(obj instanceof VariableType)) {\r\n\t\treturn false;\r\n\t}\r\n\tVariableType pdeVT = (VariableType) obj;\r\n\tif (type!=pdeVT.type) {\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\npublic String getDefaultLabel() {\r\n\t return  label;\r\n}\r\n\r\npublic String getDefaultUnits() {\r\n\treturn units; \r\n}\r\n\r\npublic int getType() {\r\n\treturn type;\r\n}\r\n\r\npublic String getTypeName() {\r\n\treturn name;\r\n}\r\n///**\r\n// * Insert the method's description here.\r\n// * Creation date: (10/3/00 2:48:55 PM)\r\n// * @return cbit.vcell.simdata.PDEVariableType\r\n// * @param mesh cbit.vcell.solvers.CartesianMesh\r\n// * @param dataLength int\r\n// */\r\n//public static final VariableType getVariableTypeFromInteger(int varType) {\r\n//\tif (varType==VOLUME.type){\r\n//\t\treturn VOLUME;\r\n//\t}else if (varType==MEMBRANE.type){\r\n//\t\treturn MEMBRANE;\r\n//\t}else if (varType==CONTOUR.type){\r\n//\t\treturn CONTOUR;\r\n//\t}else if (varType==VOLUME_REGION.type){\r\n//\t\treturn VOLUME_REGION;\r\n//\t}else if (varType==MEMBRANE_REGION.type){\r\n//\t\treturn MEMBRANE_REGION;\r\n//\t}else if (varType==CONTOUR_REGION.type){\r\n//\t\treturn CONTOUR_REGION;\r\n//\t}else{\r\n//\t\tthrow new IllegalArgumentException(\"varType=\"+varType+\" is undefined\");\r\n//\t}\r\n//}\r\n\r\n\r\n\r\n/**\r\n * search types to match criteria\r\n * @param criteria\r\n * @param errorMsg to display if miss\r\n * @return type that matches\r\n * @throws IllegalArgumentException if no match\r\n */\r\nprivate static final VariableType find(Predicate<VariableType> criteria, String errorMsg) {\r\n\tOptional<VariableType> vt = allTypes.stream().filter( criteria ).findFirst();\r\n\tif (vt.isPresent()) {\r\n\t\treturn vt.get();\r\n\t}\r\n\t\r\n\tthrow new IllegalArgumentException(\"varType=\"+errorMsg+\" is undefined\");\t\r\n\t\r\n}\r\npublic static final VariableType getVariableTypeFromInteger(int varType) {\r\n\tPredicate<VariableType> pred = v -> v.supportsCode(varType);\r\n\treturn find(pred,Integer.toString(varType));\r\n\t\r\n}\r\npublic static final VariableType getVariableTypeFromVariableTypeName(String type) {\t\r\n\tPredicate<VariableType> pred = v -> v.name.equals(type);\r\n\treturn find(pred,type);\r\n}\r\n\r\npublic static final VariableType getVariableTypeFromVariableTypeNameIgnoreCase(String type) {\t\r\n\tPredicate<VariableType> pred = v -> v.name.equalsIgnoreCase(type);\r\n\treturn find(pred,type);\r\n}\r\n\r\n/**\r\n * Insert the method's description here.\r\n * Creation date: (10/5/00 11:01:55 AM)\r\n * @return int\r\n */\r\npublic int hashCode() {\r\n\treturn type;\r\n}\r\n/**\r\n * Insert the method's description here.\r\n * Creation date: (7/6/01 4:05:42 PM)\r\n * @return boolean\r\n * @param varType cbit.vcell.simdata.VariableType\r\n */\r\npublic boolean isExpansionOf(VariableType varType) {\r\n\t//\r\n\t// an enclosing domain (e.g. VOLUME) is an expansion of an enclosed region (e.g. VOLUME_REGION).\r\n\t//\r\n\t// example: if VOLUME_REGION and VOLUME data are used in same function,\r\n\t// then function must be evaluated at each volume index (hence VOLUME wins).\r\n\t//\r\n\tif (type == VOLUME_TYPE && varType.type == VOLUME_REGION_TYPE) return true;\r\n\tif (type == MEMBRANE_TYPE && varType.type == MEMBRANE_REGION_TYPE) return true;\r\n\tif (type == CONTOUR_TYPE && varType.type == CONTOUR_REGION_TYPE) return true;\r\n\tif (type != POINT_VARIABLE_TYPE && varType.type == POINT_VARIABLE_TYPE) return true;\r\n\treturn false;\r\n}\r\n/**\r\n * Insert the method's description here.\r\n * Creation date: (5/8/01 2:12:01 PM)\r\n * @return java.lang.String\r\n */\r\npublic String toString() {\r\n\treturn getTypeName()+\"_VariableType\";\r\n}\r\npublic final VariableDomain getVariableDomain() {\r\n\treturn variableDomain;\r\n}\r\n\r\npublic static VariableType getVariableType(Variable var) {\r\n\tif (var instanceof VolVariable || var instanceof VolumeParticleVariable) {\r\n\t\treturn VariableType.VOLUME;\r\n\t} else if (var instanceof VolumeRegionVariable) {\r\n\t\treturn VariableType.VOLUME_REGION;\r\n\t} else if (var instanceof MemVariable || var instanceof MembraneParticleVariable) {\r\n\t\treturn VariableType.MEMBRANE;\r\n\t} else if (var instanceof MembraneRegionVariable) {\r\n\t\treturn VariableType.MEMBRANE_REGION;\r\n\t} else if (var instanceof FilamentVariable) {\r\n\t\treturn VariableType.CONTOUR;\r\n\t} else if (var instanceof FilamentRegionVariable) {\r\n\t\treturn VariableType.CONTOUR_REGION;\r\n\t} else if (var instanceof InsideVariable) {\r\n\t\treturn VariableType.MEMBRANE;\r\n\t} else if (var instanceof OutsideVariable) {\r\n\t\treturn VariableType.MEMBRANE;\r\n\t} else if (var instanceof DataGenerator){\r\n\t\treturn VariableType.POSTPROCESSING;\r\n\t} else {\r\n\t\treturn VariableType.UNKNOWN;\r\n\t}\r\n}\r\npublic boolean incompatibleWith(VariableType funcType) {\r\n\tif ((this.type == POSTPROCESSING_TYPE || funcType.type == POSTPROCESSING_TYPE) && this.type != funcType.type){\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\n/**\r\n * does variable support code value? \r\n * @param code\r\n * @return true if does\r\n */\r\nprotected boolean supportsCode(int code) {\r\n\tfinal boolean matches = ( code == type );\r\n\tif (matches && legacyWarn  && LG.isWarnEnabled()) {\r\n\t\tLG.warn(\"code match found on \" + code + \", \" + getTypeName() + \", not previously supported\");\r\n\t}\r\n\treturn matches;\r\n}\r\n\r\nprivate static class TwoCodeType extends VariableType {\r\n\r\n\tprivate final int secondaryType;\r\n\r\n\tprotected TwoCodeType(int varType, int secondaryType,String name, String units, String label) {\r\n\t\tsuper(varType, name, units, label);\r\n\t\tthis.secondaryType = secondaryType;\r\n\t}\r\n\r\n\t/**\r\n\t * check against both codes\r\n\t */\r\n\t@Override\r\n\tprotected boolean supportsCode(int code) {\r\n\t\treturn super.supportsCode(code) || code == secondaryType;\r\n\t}\r\n\t\r\n\t\r\n\t\r\n}\r\n\r\n"]], "pred": {"ppl": 1.8317044973373413, "ppl_lower": 2.080583333969116, "ppl/lowercase_ppl": -1.2104948239666056, "ppl/zlib": 0.0002235033060050026, "Min_5.0% Prob": 6.486582522298775, "Min_10.0% Prob": 4.746733760132509, "Min_20.0% Prob": 2.8752663471535143, "Min_30.0% Prob": 1.9919817193466074, "Min_40.0% Prob": 1.5070145469441245, "Min_50.0% Prob": 1.2100490038802596, "Min_60.0% Prob": 1.0096769846070308}}
{"hexsha": "6c671a06a15db1ca2f40789f19c4f875f173bdec", "ext": "java", "lang": "Java", "content": "@RunWith(value = Parameterized.class)\npublic class CertificateResourceIT extends IntegrationTestBase {\n\n    public CertificateResourceIT(Type tokenType) throws Exception  {\n        super(true, tokenType);\n    }\n\n    @Parameters\n    public static Object[] data() {\n           return new Object[] { AccessToken.Type.JWT, AccessToken.Type.SAML };\n    }\n\n    private static String TEST_CERT_DN = \"C=US, ST=WA, L=Bellevue, O=VMware, OU=SSO, CN=junkcert\";\n    private static CertificateDTO testCert;\n\n    @BeforeClass\n    public static void init() throws GeneralSecurityException, IOException, HttpException, ClientException, SOAPException {\n        IntegrationTestBase.init(true);\n\n        testCert = TestGenerator.generateCertificate(TEST_CERT_DN);\n    }\n\n    @AfterClass\n    public static void cleanup() throws ClientProtocolException, HttpException, ClientException, IOException {\n        IntegrationTestBase.cleanup(true);\n    }\n\n    @Test\n    public void testSet() throws GeneralSecurityException, IOException, HttpException, ClientException, SOAPException {\n        List<CertificateDTO> certificates = new ArrayList<CertificateDTO>();\n        certificates.add(testCert);\n        certificates.add(TestGenerator.generateCertificate(TEST_CERT_DN + \"1\"));\n\n        TenantCredentialsDTO credentials = new TenantCredentialsDTO.Builder()\n            .withPrivateKey(new PrivateKeyDTO(TestGenerator.getKeyPair().getPrivate()))\n            .withCertificates(certificates)\n            .build();\n\n        testAdminClient.certificate().setCredentials(testTenant.getName(), credentials);\n\n        List<CertificateChainDTO> chains = testAdminClient.certificate().get(testTenant.getName(), CertificateScope.TENANT, CertificateGranularity.CHAIN);\n        assertFalse(chains.isEmpty());\n\n        List<CertificateDTO> retrievedCerts = chains.get(chains.size() - 1).getCertificates();\n        assertContainsCertificates(credentials.getCertificates(), retrievedCerts);\n\n        // TODO If the server used the history of the signing certificates, it could still validate old tokens...\n        // Update the client so we have a valid token\n        testAdminClient = TestClientFactory.createClient(properties.getHost(),\n                testTenant.getName(),\n                testTenant.getUsername(),\n                testTenant.getPassword());\n    }\n\n    @Test\n    public void testGet() throws ClientProtocolException, HttpException, ClientException, IOException {\n        List<CertificateChainDTO> chains = testAdminClient.certificate().get(testTenant.getName(), CertificateScope.TENANT, CertificateGranularity.CHAIN);\n\n        assertFalse(chains.isEmpty());\n        List<CertificateDTO> certs = chains.get(0).getCertificates();\n\n        assertContainsCertificates(testTenant.getCredentials().getCertificates(), certs);\n    }\n\n}", "item_id": 0, "repo": "debojyoti-majumder/lightwave", "file": "vmidentity/rest/idm/client/src/integration-test/java/com/vmware/identity/rest/idm/client/test/integration/CertificateResourceIT.java", "last_update_at": "2022-03-17T05:34:09+00:00", "question_id": "6c671a06a15db1ca2f40789f19c4f875f173bdec_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(value = Parameterized.class)\npublic class CertificateResourceIT extends IntegrationTestBase {\n    public CertificateResourceIT(Type tokenType) throws Exception  {\n        super(true, tokenType);\n    }\n    @Parameters\n    public static Object[] data() {\n           return new Object[] { AccessToken.Type.JWT, AccessToken.Type.SAML };\n    }\n    private static String TEST_CERT_DN = \"C=US, ST=WA, L=Bellevue, O=VMware, OU=SSO, CN=junkcert\";\n    private static CertificateDTO testCert;\n    @BeforeClass\n    public static void init() throws GeneralSecurityException, IOException, HttpException, ClientException, SOAPException {\n        IntegrationTestBase.init(true);\n        testCert = TestGenerator.generateCertificate(TEST_CERT_DN);\n    }\n    @AfterClass\n    public static void cleanup() throws ClientProtocolException, HttpException, ClientException, IOException {\n        IntegrationTestBase.cleanup(true);\n    }\n    @Test\n    public void testSet() throws GeneralSecurityException, IOException, HttpException, ClientException, SOAPException {\n        List<CertificateDTO> certificates = new ArrayList<CertificateDTO>();\n        certificates.add(testCert);\n        certificates.add(TestGenerator.generateCertificate(TEST_CERT_DN + \"1\"));\n        TenantCredentialsDTO credentials = new TenantCredentialsDTO.Builder()\n            .withPrivateKey(new PrivateKeyDTO(TestGenerator.getKeyPair().getPrivate()))\n            .withCertificates(certificates)\n            .build();\n        testAdminClient.certificate().setCredentials(testTenant.getName(), credentials);\n        List<CertificateChainDTO> chains = testAdminClient.certificate().get(testTenant.getName(), CertificateScope.TENANT, CertificateGranularity.CHAIN);\n        assertFalse(chains.isEmpty());\n        List<CertificateDTO> retrievedCerts = chains.get(chains.size() - 1).getCertificates();\n        assertContainsCertificates(credentials.getCertificates(), retrievedCerts);\n        // TODO If the server used the history of the signing certificates, it could still validate old tokens...\n        // Update the client so we have a valid token\n        testAdminClient = TestClientFactory.createClient(properties.getHost(),\n                testTenant.getName(),\n                testTenant.getUsername(),\n                testTenant.getPassword());\n    }\n    @Test\n    public void testGet() throws ClientProtocolException, HttpException, ClientException, IOException {\n        List<CertificateChainDTO> chains = testAdminClient.certificate().get(testTenant.getName(), CertificateScope.TENANT, CertificateGranularity.CHAIN);\n        assertFalse(chains.isEmpty());\n        List<CertificateDTO> certs = chains.get(0).getCertificates();\n        assertContainsCertificates(testTenant.getCredentials().getCertificates(), certs);\n    }\n"]], "pred": {"ppl": 2.379760980606079, "ppl_lower": 2.8793020248413086, "ppl/lowercase_ppl": -1.219778369120695, "ppl/zlib": 0.0009774521469259852, "Min_5.0% Prob": 7.387216142705969, "Min_10.0% Prob": 5.59692001024882, "Min_20.0% Prob": 3.7600037972132365, "Min_30.0% Prob": 2.7483238599035476, "Min_40.0% Prob": 2.1366891414423783, "Min_50.0% Prob": 1.7277313917477926, "Min_60.0% Prob": 1.444797499295738}}
{"hexsha": "293427dcf404bcb02f8d8b80d8f20b38609a6093", "ext": "java", "lang": "Java", "content": "final class V0ModMetadataParser {\n\tprivate static final Pattern WEBSITE_PATTERN = Pattern.compile(\"\\\\((.+)\\\\)\");\n\tprivate static final Pattern EMAIL_PATTERN = Pattern.compile(\"<(.+)>\");\n\n\tpublic static LoaderModMetadata parse(Logger logger, JsonReader reader) throws IOException, ParseMetadataException {\n\t\tList<ParseWarning> warnings = new ArrayList<>();\n\n\t\t// All the values the `fabric.mod.json` may contain:\n\t\t// Required\n\t\tString id = null;\n\t\tVersion version = null;\n\n\t\t// Optional (mod loading)\n\t\tMap<String, ModDependency> requires = new HashMap<>();\n\t\tMap<String, ModDependency> conflicts = new HashMap<>();\n\t\tV0ModMetadata.Mixins mixins = null;\n\t\tModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal\n\t\tString initializer = null;\n\t\tList<String> initializers = new ArrayList<>();\n\n\t\tString name = null;\n\t\tString description = null;\n\t\tMap<String, ModDependency> recommends = new HashMap<>();\n\t\tList<Person> authors = new ArrayList<>();\n\t\tList<Person> contributors = new ArrayList<>();\n\t\tContactInformation links = null;\n\t\tString license = null;\n\n\t\twhile (reader.hasNext()) {\n\t\t\tfinal String key = reader.nextName();\n\n\t\t\tswitch (key) {\n\t\t\tcase \"schemaVersion\":\n\t\t\t\t// Duplicate field, make sure it matches our current schema version\n\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n\t\t\t\t\tthrow new ParseMetadataException(\"Duplicate \\\"schemaVersion\\\" field is not a number\", reader);\n\t\t\t\t}\n\n\t\t\t\tfinal int read = reader.nextInt();\n\n\t\t\t\tif (read != 0) {\n\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Duplicate \\\"schemaVersion\\\" field does not match the predicted schema version of 0. Duplicate field value is %s\", read), reader);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase \"id\":\n\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\tthrow new ParseMetadataException(\"Mod id must be a non-empty string with a length of 3-64 characters.\", reader);\n\t\t\t\t}\n\n\t\t\t\tid = reader.nextString();\n\t\t\t\tbreak;\n\t\t\tcase \"version\":\n\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\tthrow new ParseMetadataException(\"Version must be a non-empty string\", reader);\n\t\t\t\t}\n\n\t\t\t\tfinal String rawVersion = reader.nextString();\n\n\t\t\t\ttry {\n\t\t\t\t\tversion = VersionDeserializer.deserialize(rawVersion);\n\t\t\t\t} catch (VersionParsingException e) {\n\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Failed to parse version: %s\", rawVersion), e);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase \"requires\":\n\t\t\t\treadDependenciesContainer(reader, requires, \"requires\");\n\t\t\t\tbreak;\n\t\t\tcase \"conflicts\":\n\t\t\t\treadDependenciesContainer(reader, conflicts, \"conflicts\");\n\t\t\t\tbreak;\n\t\t\tcase \"mixins\":\n\t\t\t\tmixins = readMixins(warnings, reader);\n\t\t\t\tbreak;\n\t\t\tcase \"side\":\n\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\tthrow new ParseMetadataException(\"Side must be a string\", reader);\n\t\t\t\t}\n\n\t\t\t\tfinal String rawEnvironment = reader.nextString();\n\n\t\t\t\tswitch (rawEnvironment) {\n\t\t\t\tcase \"universal\":\n\t\t\t\t\tenvironment = ModEnvironment.UNIVERSAL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"client\":\n\t\t\t\t\tenvironment = ModEnvironment.CLIENT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"server\":\n\t\t\t\t\tenvironment = ModEnvironment.SERVER;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twarnings.add(new ParseWarning(reader.locationString(), rawEnvironment, \"Invalid side type\"));\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase \"initializer\":\n\t\t\t\t// `initializer` and `initializers` cannot be used at the same time\n\t\t\t\tif (!initializers.isEmpty()) {\n\t\t\t\t\tthrow new ParseMetadataException(\"initializer and initializers should not be set at the same time! (mod ID '\" + id + \"')\");\n\t\t\t\t}\n\n\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\tthrow new ParseMetadataException(\"Initializer must be a non-empty string\", reader);\n\t\t\t\t}\n\n\t\t\t\tinitializer = reader.nextString();\n\t\t\t\tbreak;\n\t\t\tcase \"initializers\":\n\t\t\t\t// `initializer` and `initializers` cannot be used at the same time\n\t\t\t\tif (initializer != null) {\n\t\t\t\t\tthrow new ParseMetadataException(\"initializer and initializers should not be set at the same time! (mod ID '\" + id + \"')\");\n\t\t\t\t}\n\n\t\t\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n\t\t\t\t\tthrow new ParseMetadataException(\"Initializers must be in a list\", reader);\n\t\t\t\t}\n\n\t\t\t\treader.beginArray();\n\n\t\t\t\twhile (reader.hasNext()) {\n\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\t\tthrow new ParseMetadataException(\"Initializer in initializers list must be a string\", reader);\n\t\t\t\t\t}\n\n\t\t\t\t\tinitializers.add(reader.nextString());\n\t\t\t\t}\n\n\t\t\t\treader.endArray();\n\n\t\t\t\tbreak;\n\t\t\tcase \"name\":\n\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\tthrow new ParseMetadataException(\"Name must be a string\", reader);\n\t\t\t\t}\n\n\t\t\t\tname = reader.nextString();\n\t\t\t\tbreak;\n\t\t\tcase \"description\":\n\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\tthrow new ParseMetadataException(\"Mod description must be a string\", reader);\n\t\t\t\t}\n\n\t\t\t\tdescription = reader.nextString();\n\t\t\t\tbreak;\n\t\t\tcase \"recommends\":\n\t\t\t\treadDependenciesContainer(reader, recommends, \"recommends\");\n\t\t\t\tbreak;\n\t\t\tcase \"authors\":\n\t\t\t\treadPeople(warnings, reader, authors);\n\t\t\t\tbreak;\n\t\t\tcase \"contributors\":\n\t\t\t\treadPeople(warnings, reader, contributors);\n\t\t\t\tbreak;\n\t\t\tcase \"links\":\n\t\t\t\tlinks = readLinks(warnings, reader);\n\t\t\t\tbreak;\n\t\t\tcase \"license\":\n\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\tthrow new ParseMetadataException(\"License name must be a string\", reader);\n\t\t\t\t}\n\n\t\t\t\tlicense = reader.nextString();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\twarnings.add(new ParseWarning(reader.locationString(), key, \"Unsupported root entry\"));\n\t\t\t\treader.skipValue();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Validate all required fields are resolved\n\t\tif (id == null) {\n\t\t\tthrow new ParseMetadataException.MissingRequired(\"id\");\n\t\t}\n\n\t\tif (version == null) {\n\t\t\tthrow new ParseMetadataException.MissingRequired(\"version\");\n\t\t}\n\n\t\tFabricModMetadataReader.logWarningMessages(logger, id, warnings);\n\n\t\t// Optional stuff\n\t\tif (links == null) {\n\t\t\tlinks = ContactInformation.EMPTY;\n\t\t}\n\n\t\treturn new V0ModMetadata(id, version, requires, conflicts, mixins, environment, initializer, initializers, name, description, recommends, authors, contributors, links, license);\n\t}\n\n\tprivate static ContactInformation readLinks(List<ParseWarning> warnings, JsonReader reader) throws IOException, ParseMetadataException {\n\t\tfinal Map<String, String> contactInfo = new HashMap<>();\n\n\t\tswitch (reader.peek()) {\n\t\tcase STRING:\n\t\t\tcontactInfo.put(\"homepage\", reader.nextString());\n\t\t\tbreak;\n\t\tcase BEGIN_OBJECT:\n\t\t\treader.beginObject();\n\n\t\t\twhile (reader.hasNext()) {\n\t\t\t\tfinal String key = reader.nextName();\n\n\t\t\t\tswitch (key) {\n\t\t\t\tcase \"homepage\":\n\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\t\tthrow new ParseMetadataException(\"homepage link must be a string\", reader);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontactInfo.put(\"homepage\", reader.nextString());\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"issues\":\n\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\t\tthrow new ParseMetadataException(\"issues link must be a string\", reader);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontactInfo.put(\"issues\", reader.nextString());\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sources\":\n\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\t\tthrow new ParseMetadataException(\"sources link must be a string\", reader);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontactInfo.put(\"sources\", reader.nextString());\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twarnings.add(new ParseWarning(reader.locationString(), key, \"Unsupported links entry\"));\n\t\t\t\t\treader.skipValue();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treader.endObject();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new ParseMetadataException(\"Expected links to be an object or string\", reader);\n\t\t}\n\n\t\treturn new MapBackedContactInformation(contactInfo);\n\t}\n\n\tprivate static V0ModMetadata.Mixins readMixins(List<ParseWarning> warnings, JsonReader reader) throws IOException, ParseMetadataException {\n\t\tfinal List<String> client = new ArrayList<>();\n\t\tfinal List<String> common = new ArrayList<>();\n\t\tfinal List<String> server = new ArrayList<>();\n\n\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n\t\t\tthrow new ParseMetadataException(\"Expected mixins to be an object.\", reader);\n\t\t}\n\n\t\treader.beginObject();\n\n\t\twhile (reader.hasNext()) {\n\t\t\tfinal String environment = reader.nextName();\n\n\t\t\tswitch (environment) {\n\t\t\tcase \"client\":\n\t\t\t\tclient.addAll(readStringArray(reader, \"client\"));\n\t\t\t\tbreak;\n\t\t\tcase \"common\":\n\t\t\t\tcommon.addAll(readStringArray(reader, \"common\"));\n\t\t\t\tbreak;\n\t\t\tcase \"server\":\n\t\t\t\tserver.addAll(readStringArray(reader, \"server\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\twarnings.add(new ParseWarning(reader.locationString(), environment, \"Invalid environment type\"));\n\t\t\t\treader.skipValue();\n\t\t\t}\n\t\t}\n\n\t\treader.endObject();\n\t\treturn new V0ModMetadata.Mixins(client, common, server);\n\t}\n\n\tprivate static List<String> readStringArray(JsonReader reader, String key) throws IOException, ParseMetadataException {\n\t\tswitch (reader.peek()) {\n\t\tcase NULL:\n\t\t\treader.nextNull();\n\t\t\treturn Collections.emptyList();\n\t\tcase STRING:\n\t\t\treturn Collections.singletonList(reader.nextString());\n\t\tcase BEGIN_ARRAY:\n\t\t\treader.beginArray();\n\t\t\tfinal List<String> list = new ArrayList<>();\n\n\t\t\twhile (reader.hasNext()) {\n\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Expected entries in %s to be an array of strings\", key), reader);\n\t\t\t\t}\n\n\t\t\t\tlist.add(reader.nextString());\n\t\t\t}\n\n\t\t\treader.endArray();\n\t\t\treturn list;\n\t\tdefault:\n\t\t\tthrow new ParseMetadataException(String.format(\"Expected %s to be a string or an array of strings\", key), reader);\n\t\t}\n\t}\n\n\tprivate static void readDependenciesContainer(JsonReader reader, Map<String, ModDependency> dependencies, String name) throws IOException, ParseMetadataException {\n\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n\t\t\tthrow new ParseMetadataException(String.format(\"%s must be an object containing dependencies.\", name), reader);\n\t\t}\n\n\t\treader.beginObject();\n\n\t\twhile (reader.hasNext()) {\n\t\t\tfinal String modId = reader.nextName();\n\t\t\tfinal List<String> versionMatchers = new ArrayList<>();\n\n\t\t\tswitch (reader.peek()) {\n\t\t\tcase STRING:\n\t\t\t\tversionMatchers.add(reader.nextString());\n\t\t\t\tbreak;\n\t\t\tcase BEGIN_ARRAY:\n\t\t\t\treader.beginArray();\n\n\t\t\t\twhile (reader.hasNext()) {\n\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\t\tthrow new ParseMetadataException(\"List of version requirements must be strings\", reader);\n\t\t\t\t\t}\n\n\t\t\t\t\tversionMatchers.add(reader.nextString());\n\t\t\t\t}\n\n\t\t\t\treader.endArray();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new ParseMetadataException(\"Expected version to be a string or array\", reader);\n\t\t\t}\n\n\t\t\tdependencies.put(modId, new ModDependencyImpl(modId, versionMatchers));\n\t\t}\n\n\t\treader.endObject();\n\t}\n\n\tprivate static void readPeople(List<ParseWarning> warnings, JsonReader reader, List<Person> people) throws IOException, ParseMetadataException {\n\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n\t\t\tthrow new ParseMetadataException(\"List of people must be an array\", reader);\n\t\t}\n\n\t\treader.beginArray();\n\n\t\twhile (reader.hasNext()) {\n\t\t\tpeople.add(readPerson(warnings, reader));\n\t\t}\n\n\t\treader.endArray();\n\t}\n\n\tprivate static Person readPerson(List<ParseWarning> warnings, JsonReader reader) throws IOException, ParseMetadataException {\n\t\tfinal HashMap<String, String> contactMap = new HashMap<>();\n\t\tString name = \"\";\n\n\t\tswitch (reader.peek()) {\n\t\tcase STRING:\n\t\t\tfinal String person = reader.nextString();\n\t\t\tString[] parts = person.split(\" \");\n\n\t\t\tMatcher websiteMatcher = V0ModMetadataParser.WEBSITE_PATTERN.matcher(parts[parts.length - 1]);\n\n\t\t\tif (websiteMatcher.matches()) {\n\t\t\t\tcontactMap.put(\"website\", websiteMatcher.group(1));\n\t\t\t\tparts = Arrays.copyOf(parts, parts.length - 1);\n\t\t\t}\n\n\t\t\tMatcher emailMatcher = V0ModMetadataParser.EMAIL_PATTERN.matcher(parts[parts.length - 1]);\n\n\t\t\tif (emailMatcher.matches()) {\n\t\t\t\tcontactMap.put(\"email\", emailMatcher.group(1));\n\t\t\t\tparts = Arrays.copyOf(parts, parts.length - 1);\n\t\t\t}\n\n\t\t\tname = String.join(\" \", parts);\n\n\t\t\treturn new ContactInfoBackedPerson(name, new MapBackedContactInformation(contactMap));\n\t\tcase BEGIN_OBJECT:\n\t\t\treader.beginObject();\n\n\t\t\twhile (reader.hasNext()) {\n\t\t\t\tfinal String key = reader.nextName();\n\n\t\t\t\tswitch (key) {\n\t\t\t\tcase \"name\":\n\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tname = reader.nextString();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"email\":\n\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontactMap.put(\"email\", reader.nextString());\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"website\":\n\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontactMap.put(\"website\", reader.nextString());\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twarnings.add(new ParseWarning(reader.locationString(), key, \"Unsupported contact information entry\"));\n\t\t\t\t\treader.skipValue();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treader.endObject();\n\t\t\treturn new ContactInfoBackedPerson(name, new MapBackedContactInformation(contactMap));\n\t\tdefault:\n\t\t\tthrow new ParseMetadataException(\"Expected person to be a string or object\", reader);\n\t\t}\n\t}\n}", "item_id": 0, "repo": "Earthcomputer/quilt-loader", "file": "src/main/java/org/quiltmc/loader/impl/metadata/V0ModMetadataParser.java", "last_update_at": "2022-03-27T11:15:25+00:00", "question_id": "293427dcf404bcb02f8d8b80d8f20b38609a6093_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["final class V0ModMetadataParser {\n\tprivate static final Pattern WEBSITE_PATTERN = Pattern.compile(\"\\\\((.+)\\\\)\");\n\tprivate static final Pattern EMAIL_PATTERN = Pattern.compile(\"<(.+)>\");\n\tpublic static LoaderModMetadata parse(Logger logger, JsonReader reader) throws IOException, ParseMetadataException {\n\t\tList<ParseWarning> warnings = new ArrayList<>();\n\t\t// All the values the `fabric.mod.json` may contain:\n\t\t// Required\n\t\tString id = null;\n\t\tVersion version = null;\n\t\t// Optional (mod loading)\n\t\tMap<String, ModDependency> requires = new HashMap<>();\n\t\tMap<String, ModDependency> conflicts = new HashMap<>();\n\t\tV0ModMetadata.Mixins mixins = null;\n\t\tModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal\n\t\tString initializer = null;\n\t\tList<String> initializers = new ArrayList<>();\n\t\tString name = null;\n\t\tString description = null;\n\t\tMap<String, ModDependency> recommends = new HashMap<>();\n\t\tList<Person> authors = new ArrayList<>();\n\t\tList<Person> contributors = new ArrayList<>();\n\t\tContactInformation links = null;\n\t\tString license = null;\n\t\twhile (reader.hasNext()) {\n\t\t\tfinal String key = reader.nextName();\n\t\t\tswitch (key) {\n\t\t\tcase \"schemaVersion\":\n\t\t\t\t// Duplicate field, make sure it matches our current schema version\n\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n\t\t\t\t\tthrow new ParseMetadataException(\"Duplicate \\\"schemaVersion\\\" field is not a number\", reader);\n\t\t\t\t}\n\t\t\t\tfinal int read = reader.nextInt();\n\t\t\t\tif (read != 0) {\n\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Duplicate \\\"schemaVersion\\\" field does not match the predicted schema version of 0. Duplicate field value is %s\", read), reader);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"id\":\n\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\tthrow new ParseMetadataException(\"Mod id must be a non-empty string with a length of 3-64 characters.\", reader);\n\t\t\t\t}\n\t\t\t\tid = reader.nextString();\n\t\t\t\tbreak;\n\t\t\tcase \"version\":\n\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\tthrow new ParseMetadataException(\"Version must be a non-empty string\", reader);\n\t\t\t\t}\n\t\t\t\tfinal String rawVersion = reader.nextString();\n\t\t\t\ttry {\n\t\t\t\t\tversion = VersionDeserializer.deserialize(rawVersion);\n\t\t\t\t} catch (VersionParsingException e) {\n\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Failed to parse version: %s\", rawVersion), e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"requires\":\n\t\t\t\treadDependenciesContainer(reader, requires, \"requires\");\n\t\t\t\tbreak;\n\t\t\tcase \"conflicts\":\n\t\t\t\treadDependenciesContainer(reader, conflicts, \"conflicts\");\n\t\t\t\tbreak;\n\t\t\tcase \"mixins\":\n\t\t\t\tmixins = readMixins(warnings, reader);\n\t\t\t\tbreak;\n\t\t\tcase \"side\":\n\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\tthrow new ParseMetadataException(\"Side must be a string\", reader);\n\t\t\t\t}\n\t\t\t\tfinal String rawEnvironment = reader.nextString();\n\t\t\t\tswitch (rawEnvironment) {\n\t\t\t\tcase \"universal\":\n\t\t\t\t\tenvironment = ModEnvironment.UNIVERSAL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"client\":\n\t\t\t\t\tenvironment = ModEnvironment.CLIENT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"server\":\n\t\t\t\t\tenvironment = ModEnvironment.SERVER;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twarnings.add(new ParseWarning(reader.locationString(), rawEnvironment, \"Invalid side type\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"initializer\":\n\t\t\t\t// `initializer` and `initializers` cannot be used at the same time\n\t\t\t\tif (!initializers.isEmpty()) {\n\t\t\t\t\tthrow new ParseMetadataException(\"initializer and initializers should not be set at the same time! (mod ID '\" + id + \"')\");\n\t\t\t\t}\n\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\tthrow new ParseMetadataException(\"Initializer must be a non-empty string\", reader);\n\t\t\t\t}\n\t\t\t\tinitializer = reader.nextString();\n\t\t\t\tbreak;\n\t\t\tcase \"initializers\":\n\t\t\t\t// `initializer` and `initializers` cannot be used at the same time\n\t\t\t\tif (initializer != null) {\n\t\t\t\t\tthrow new ParseMetadataException(\"initializer and initializers should not be set at the same time! (mod ID '\" + id + \"')\");\n\t\t\t\t}\n\t\t\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n\t\t\t\t\tthrow new ParseMetadataException(\"Initializers must be in a list\", reader);\n\t\t\t\t}\n\t\t\t\treader.beginArray();\n\t\t\t\twhile (reader.hasNext()) {\n\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\t\tthrow new ParseMetadataException(\"Initializer in initializers list must be a string\", reader);\n\t\t\t\t\t}\n\t\t\t\t\tinitializers.add(reader.nextString());\n\t\t\t\t}\n\t\t\t\treader.endArray();\n\t\t\t\tbreak;\n\t\t\tcase \"name\":\n\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\tthrow new ParseMetadataException(\"Name must be a string\", reader);\n\t\t\t\t}\n\t\t\t\tname = reader.nextString();\n\t\t\t\tbreak;\n\t\t\tcase \"description\":\n\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\tthrow new ParseMetadataException(\"Mod description must be a string\", reader);\n\t\t\t\t}\n\t\t\t\tdescription = reader.nextString();\n\t\t\t\tbreak;\n\t\t\tcase \"recommends\":\n\t\t\t\treadDependenciesContainer(reader, recommends, \"recommends\");\n\t\t\t\tbreak;\n\t\t\tcase \"authors\":\n\t\t\t\treadPeople(warnings, reader, authors);\n\t\t\t\tbreak;\n\t\t\tcase \"contributors\":\n\t\t\t\treadPeople(warnings, reader, contributors);\n\t\t\t\tbreak;\n\t\t\tcase \"links\":\n\t\t\t\tlinks = readLinks(warnings, reader);\n\t\t\t\tbreak;\n\t\t\tcase \"license\":\n\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\tthrow new ParseMetadataException(\"License name must be a string\", reader);\n\t\t\t\t}\n\t\t\t\tlicense = reader.nextString();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\twarnings.add(new ParseWarning(reader.locationString(), key, \"Unsupported root entry\"));\n\t\t\t\treader.skipValue();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Validate all required fields are resolved\n\t\tif (id == null) {\n\t\t\tthrow new ParseMetadataException.MissingRequired(\"id\");\n\t\t}\n\t\tif (version == null) {\n\t\t\tthrow new ParseMetadataException.MissingRequired(\"version\");\n\t\t}\n\t\tFabricModMetadataReader.logWarningMessages(logger, id, warnings);\n\t\t// Optional stuff\n\t\tif (links == null) {\n\t\t\tlinks = ContactInformation.EMPTY;\n\t\t}\n\t\treturn new V0ModMetadata(id, version, requires, conflicts, mixins, environment, initializer, initializers, name, description, recommends, authors, contributors, links, license);\n\t}\n\tprivate static ContactInformation readLinks(List<ParseWarning> warnings, JsonReader reader) throws IOException, ParseMetadataException {\n\t\tfinal Map<String, String> contactInfo = new HashMap<>();\n\t\tswitch (reader.peek()) {\n\t\tcase STRING:\n\t\t\tcontactInfo.put(\"homepage\", reader.nextString());\n\t\t\tbreak;\n\t\tcase BEGIN_OBJECT:\n\t\t\treader.beginObject();\n\t\t\twhile (reader.hasNext()) {\n\t\t\t\tfinal String key = reader.nextName();\n\t\t\t\tswitch (key) {\n\t\t\t\tcase \"homepage\":\n\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\t\tthrow new ParseMetadataException(\"homepage link must be a string\", reader);\n\t\t\t\t\t}\n\t\t\t\t\tcontactInfo.put(\"homepage\", reader.nextString());\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"issues\":\n\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\t\tthrow new ParseMetadataException(\"issues link must be a string\", reader);\n\t\t\t\t\t}\n\t\t\t\t\tcontactInfo.put(\"issues\", reader.nextString());\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sources\":\n\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\t\tthrow new ParseMetadataException(\"sources link must be a string\", reader);\n\t\t\t\t\t}\n\t\t\t\t\tcontactInfo.put(\"sources\", reader.nextString());\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twarnings.add(new ParseWarning(reader.locationString(), key, \"Unsupported links entry\"));\n\t\t\t\t\treader.skipValue();\n\t\t\t\t}\n\t\t\t}\n\t\t\treader.endObject();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new ParseMetadataException(\"Expected links to be an object or string\", reader);\n\t\t}\n\t\treturn new MapBackedContactInformation(contactInfo);\n\t}\n\tprivate static V0ModMetadata.Mixins readMixins(List<ParseWarning> warnings, JsonReader reader) throws IOException, ParseMetadataException {\n\t\tfinal List<String> client = new ArrayList<>();\n\t\tfinal List<String> common = new ArrayList<>();\n\t\tfinal List<String> server = new ArrayList<>();\n\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n\t\t\tthrow new ParseMetadataException(\"Expected mixins to be an object.\", reader);\n\t\t}\n\t\treader.beginObject();\n\t\twhile (reader.hasNext()) {\n\t\t\tfinal String environment = reader.nextName();\n\t\t\tswitch (environment) {\n\t\t\tcase \"client\":\n\t\t\t\tclient.addAll(readStringArray(reader, \"client\"));\n\t\t\t\tbreak;\n\t\t\tcase \"common\":\n\t\t\t\tcommon.addAll(readStringArray(reader, \"common\"));\n\t\t\t\tbreak;\n\t\t\tcase \"server\":\n\t\t\t\tserver.addAll(readStringArray(reader, \"server\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\twarnings.add(new ParseWarning(reader.locationString(), environment, \"Invalid environment type\"));\n\t\t\t\treader.skipValue();\n\t\t\t}\n\t\t}\n\t\treader.endObject();\n\t\treturn new V0ModMetadata.Mixins(client, common, server);\n\t}\n\tprivate static List<String> readStringArray(JsonReader reader, String key) throws IOException, ParseMetadataException {\n\t\tswitch (reader.peek()) {\n\t\tcase NULL:\n\t\t\treader.nextNull();\n\t\t\treturn Collections.emptyList();\n\t\tcase STRING:\n\t\t\treturn Collections.singletonList(reader.nextString());\n\t\tcase BEGIN_ARRAY:\n\t\t\treader.beginArray();\n\t\t\tfinal List<String> list = new ArrayList<>();\n\t\t\twhile (reader.hasNext()) {\n\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Expected entries in %s to be an array of strings\", key), reader);\n\t\t\t\t}\n\t\t\t\tlist.add(reader.nextString());\n\t\t\t}\n\t\t\treader.endArray();\n\t\t\treturn list;\n\t\tdefault:\n\t\t\tthrow new ParseMetadataException(String.format(\"Expected %s to be a string or an array of strings\", key), reader);\n\t\t}\n\t}\n\tprivate static void readDependenciesContainer(JsonReader reader, Map<String, ModDependency> dependencies, String name) throws IOException, ParseMetadataException {\n\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n\t\t\tthrow new ParseMetadataException(String.format(\"%s must be an object containing dependencies.\", name), reader);\n\t\t}\n\t\treader.beginObject();\n\t\twhile (reader.hasNext()) {\n\t\t\tfinal String modId = reader.nextName();\n\t\t\tfinal List<String> versionMatchers = new ArrayList<>();\n\t\t\tswitch (reader.peek()) {\n\t\t\tcase STRING:\n\t\t\t\tversionMatchers.add(reader.nextString());\n\t\t\t\tbreak;\n\t\t\tcase BEGIN_ARRAY:\n\t\t\t\treader.beginArray();\n\t\t\t\twhile (reader.hasNext()) {\n\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\t\tthrow new ParseMetadataException(\"List of version requirements must be strings\", reader);\n\t\t\t\t\t}\n\t\t\t\t\tversionMatchers.add(reader.nextString());\n\t\t\t\t}\n\t\t\t\treader.endArray();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new ParseMetadataException(\"Expected version to be a string or array\", reader);\n\t\t\t}\n\t\t\tdependencies.put(modId, new ModDependencyImpl(modId, versionMatchers));\n\t\t}\n\t\treader.endObject();\n\t}\n\tprivate static void readPeople(List<ParseWarning> warnings, JsonReader reader, List<Person> people) throws IOException, ParseMetadataException {\n\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n\t\t\tthrow new ParseMetadataException(\"List of people must be an array\", reader);\n\t\t}\n\t\treader.beginArray();\n\t\twhile (reader.hasNext()) {\n\t\t\tpeople.add(readPerson(warnings, reader));\n\t\t}\n\t\treader.endArray();\n\t}\n\tprivate static Person readPerson(List<ParseWarning> warnings, JsonReader reader) throws IOException, ParseMetadataException {\n\t\tfinal HashMap<String, String> contactMap = new HashMap<>();\n\t\tString name = \"\";\n\t\tswitch (reader.peek()) {\n\t\tcase STRING:\n\t\t\tfinal String person = reader.nextString();\n\t\t\tString[] parts = person.split(\" \");\n\t\t\tMatcher websiteMatcher = V0ModMetadataParser.WEBSITE_PATTERN.matcher(parts[parts.length - 1]);\n\t\t\tif (websiteMatcher.matches()) {\n\t\t\t\tcontactMap.put(\"website\", websiteMatcher.group(1));\n\t\t\t\tparts = Arrays.copyOf(parts, parts.length - 1);\n\t\t\t}\n\t\t\tMatcher emailMatcher = V0ModMetadataParser.EMAIL_PATTERN.matcher(parts[parts.length - 1]);\n\t\t\tif (emailMatcher.matches()) {\n\t\t\t\tcontactMap.put(\"email\", emailMatcher.group(1));\n\t\t\t\tparts = Arrays.copyOf(parts, parts.length - 1);\n\t\t\t}\n\t\t\tname = String.join(\" \", parts);\n\t\t\treturn new ContactInfoBackedPerson(name, new MapBackedContactInformation(contactMap));\n\t\tcase BEGIN_OBJECT:\n\t\t\treader.beginObject();\n\t\t\twhile (reader.hasNext()) {\n\t\t\t\tfinal String key = reader.nextName();\n\t\t\t\tswitch (key) {\n\t\t\t\tcase \"name\":\n\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tname = reader.nextString();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"email\":\n\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontactMap.put(\"email\", reader.nextString());\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"website\":\n\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontactMap.put(\"website\", reader.nextString());\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twarnings.add(new ParseWarning(reader.locationString(), key, \"Unsupported contact information entry\"));\n\t\t\t\t\treader.skipValue();\n\t\t\t\t}\n\t\t\t}\n\t\t\treader.endObject();\n\t\t\treturn new ContactInfoBackedPerson(name, new MapBackedContactInformation(contactMap));\n\t\tdefault:\n\t\t\tthrow new ParseMetadataException(\"Expected person to be a string or object\", reader);\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.7861465215682983, "ppl_lower": 2.008242607116699, "ppl/lowercase_ppl": -1.2020470159958094, "ppl/zlib": 0.00022605632035904572, "Min_5.0% Prob": 6.223811878877528, "Min_10.0% Prob": 4.474672380615683, "Min_20.0% Prob": 2.7530735504685664, "Min_30.0% Prob": 1.915290472675967, "Min_40.0% Prob": 1.4463807491763223, "Min_50.0% Prob": 1.160339254510467, "Min_60.0% Prob": 0.9678578810305996}}
{"hexsha": "3ffb5cabc55fea8cb734e91d425ffb34b89aa274", "ext": "java", "lang": "Java", "content": "public class PowerOffAction extends OmniAction {\n    public static final String APP_NAME = \"Signals\";\n    public static final String ACTION_NAME = \"Power Off Device\";\n\n    public PowerOffAction(HashMap<String, String> parameters) throws libretasks.app.controller.util.OmnidroidException {\n        super(libretasks.app.controller.external.actions.SignalsActionService.class.getName(),\n                libretasks.app.controller.Action.BY_SERVICE);\n    }\n\n    @Override\n    public Intent getIntent() {\n        Intent intent = new Intent();\n        intent.setClassName(LIBRETASKS_PACKAGE_NAME, libretasks.app.controller.external.actions.SignalsActionService.class.getName());\n        intent.putExtra(libretasks.app.controller.external.actions.SignalsActionService.OPERATION_TYPE,\n                libretasks.app.controller.external.actions.SignalsActionService.POWER_OFF_DEVICE);\n        intent.putExtra(DATABASE_ID, databaseId);\n        intent.putExtra(ACTION_TYPE, actionType);\n        intent.putExtra(NOTIFICATION, showNotification);\n        return intent;\n    }\n\n    @Override\n    public String getDescription() {\n        return APP_NAME + \"-\" + ACTION_NAME;\n    }\n\n\n}", "item_id": 0, "repo": "biotinker/omnidroid", "file": "LibreTasks/src/libretasks/app/controller/actions/PowerOffAction.java", "last_update_at": "2022-03-15T21:04:14+00:00", "question_id": "3ffb5cabc55fea8cb734e91d425ffb34b89aa274_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PowerOffAction extends OmniAction {\n    public static final String APP_NAME = \"Signals\";\n    public static final String ACTION_NAME = \"Power Off Device\";\n    public PowerOffAction(HashMap<String, String> parameters) throws libretasks.app.controller.util.OmnidroidException {\n        super(libretasks.app.controller.external.actions.SignalsActionService.class.getName(),\n                libretasks.app.controller.Action.BY_SERVICE);\n    }\n    @Override\n    public Intent getIntent() {\n        Intent intent = new Intent();\n        intent.setClassName(LIBRETASKS_PACKAGE_NAME, libretasks.app.controller.external.actions.SignalsActionService.class.getName());\n        intent.putExtra(libretasks.app.controller.external.actions.SignalsActionService.OPERATION_TYPE,\n                libretasks.app.controller.external.actions.SignalsActionService.POWER_OFF_DEVICE);\n        intent.putExtra(DATABASE_ID, databaseId);\n        intent.putExtra(ACTION_TYPE, actionType);\n        intent.putExtra(NOTIFICATION, showNotification);\n        return intent;\n    }\n    @Override\n    public String getDescription() {\n        return APP_NAME + \"-\" + ACTION_NAME;\n    }\n"]], "pred": {"ppl": 2.5631277561187744, "ppl_lower": 3.545003890991211, "ppl/lowercase_ppl": -1.3445614286368255, "ppl/zlib": 0.00206863360980195, "Min_5.0% Prob": 8.723361492156982, "Min_10.0% Prob": 6.608305677771568, "Min_20.0% Prob": 4.256084008142352, "Min_30.0% Prob": 3.037766302625338, "Min_40.0% Prob": 2.33070075919386, "Min_50.0% Prob": 1.8712548216492493, "Min_60.0% Prob": 1.5671456785187357}}
{"hexsha": "2214f58d235e1e07260fcf8b252e03451c36e4c3", "ext": "java", "lang": "Java", "content": "public class ObjectDetailsDatabaseBuilder {\n\n    private static final String DEFAULT_TABLE_NAME = \"ocfl_object_details\";\n\n    private boolean storeInventory;\n    private long waitTime;\n    private TimeUnit timeUnit;\n    private DataSource dataSource;\n    private String tableName;\n\n    public ObjectDetailsDatabaseBuilder() {\n        storeInventory = true;\n        waitTime = 10;\n        timeUnit = TimeUnit.SECONDS;\n    }\n\n    /**\n     * If serialized inventories should be stored in the database. Default: true.\n     *\n     * @param storeInventory true if serialized inventories should be stored in the database.\n     * @return builder\n     */\n    public ObjectDetailsDatabaseBuilder storeInventory(boolean storeInventory) {\n        this.storeInventory = storeInventory;\n        return this;\n    }\n\n    /**\n     * Used to override the amount of time the client will wait to obtain a lock. Default: 10 seconds.\n     *\n     * @param waitTime wait time (MariaDB uses seconds, while PostgreSQL and H2 use milliseconds)\n     * @param timeUnit unit of time\n     * @return builder\n     */\n    public ObjectDetailsDatabaseBuilder waitTime(long waitTime, TimeUnit timeUnit) {\n        this.waitTime = Enforce.expressionTrue(waitTime > 0, waitTime, \"waitTime must be greater than 0\");\n        this.timeUnit = Enforce.notNull(timeUnit, \"timeUnit cannot be null\");\n        return this;\n    }\n\n    /**\n     * Sets the DataSource to use for the object details table. This is a required field.\n     *\n     * @param dataSource the DataSource\n     * @return builder\n     */\n    public ObjectDetailsDatabaseBuilder dataSource(DataSource dataSource) {\n        this.dataSource = Enforce.notNull(dataSource, \"dataSource cannot be null\");\n        return this;\n    }\n\n    /**\n     * Sets the name of the table to use to store object details. Default: ocfl_object_details\n     *\n     * @param tableName the table name to use\n     * @return builder\n     */\n    public ObjectDetailsDatabaseBuilder tableName(String tableName) {\n        this.tableName = tableName;\n        return this;\n    }\n\n    /**\n     * Constructs a new {@link ObjectDetailsDatabase} instance using the given dataSource. If the database does not\n     * already contain an object details table, it attempts to create one.\n     *\n     * @return ObjectDetailsDatabase\n     */\n    public ObjectDetailsDatabase build() {\n        Enforce.notNull(dataSource, \"dataSource cannot be null\");\n\n        var resolvedTableName = tableName == null ? DEFAULT_TABLE_NAME : tableName;\n\n        var dbType = DbType.fromDataSource(dataSource);\n        ObjectDetailsDatabase database;\n\n        switch (dbType) {\n            case POSTGRES:\n                database = new PostgresObjectDetailsDatabase(resolvedTableName, dataSource, storeInventory, waitTime, timeUnit);\n                break;\n            case MARIADB:\n                database = new MariaDbObjectDetailsDatabase(resolvedTableName, dataSource, storeInventory, waitTime, timeUnit);\n                break;\n            case H2:\n                database = new H2ObjectDetailsDatabase(resolvedTableName, dataSource, storeInventory, waitTime, timeUnit);\n                break;\n            default:\n                throw new OcflJavaException(String.format(\"Database type %s is not mapped to an ObjectDetailsDatabase implementation.\", dbType));\n        }\n\n        new TableCreator(dbType, dataSource).createObjectDetailsTable(resolvedTableName);\n\n        return database;\n    }\n\n}", "item_id": 0, "repo": "pwinckles/ocfl-java", "file": "ocfl-java-core/src/main/java/edu/wisc/library/ocfl/core/db/ObjectDetailsDatabaseBuilder.java", "last_update_at": "2022-03-29T18:10:14+00:00", "question_id": "2214f58d235e1e07260fcf8b252e03451c36e4c3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ObjectDetailsDatabaseBuilder {\n    private static final String DEFAULT_TABLE_NAME = \"ocfl_object_details\";\n    private boolean storeInventory;\n    private long waitTime;\n    private TimeUnit timeUnit;\n    private DataSource dataSource;\n    private String tableName;\n    public ObjectDetailsDatabaseBuilder() {\n        storeInventory = true;\n        waitTime = 10;\n        timeUnit = TimeUnit.SECONDS;\n    }\n    /**\n     * If serialized inventories should be stored in the database. Default: true.\n     *\n     * @param storeInventory true if serialized inventories should be stored in the database.\n     * @return builder\n     */\n    public ObjectDetailsDatabaseBuilder storeInventory(boolean storeInventory) {\n        this.storeInventory = storeInventory;\n        return this;\n    }\n    /**\n     * Used to override the amount of time the client will wait to obtain a lock. Default: 10 seconds.\n     *\n     * @param waitTime wait time (MariaDB uses seconds, while PostgreSQL and H2 use milliseconds)\n     * @param timeUnit unit of time\n     * @return builder\n     */\n    public ObjectDetailsDatabaseBuilder waitTime(long waitTime, TimeUnit timeUnit) {\n        this.waitTime = Enforce.expressionTrue(waitTime > 0, waitTime, \"waitTime must be greater than 0\");\n        this.timeUnit = Enforce.notNull(timeUnit, \"timeUnit cannot be null\");\n        return this;\n    }\n    /**\n     * Sets the DataSource to use for the object details table. This is a required field.\n     *\n     * @param dataSource the DataSource\n     * @return builder\n     */\n    public ObjectDetailsDatabaseBuilder dataSource(DataSource dataSource) {\n        this.dataSource = Enforce.notNull(dataSource, \"dataSource cannot be null\");\n        return this;\n    }\n    /**\n     * Sets the name of the table to use to store object details. Default: ocfl_object_details\n     *\n     * @param tableName the table name to use\n     * @return builder\n     */\n    public ObjectDetailsDatabaseBuilder tableName(String tableName) {\n        this.tableName = tableName;\n        return this;\n    }\n    /**\n     * Constructs a new {@link ObjectDetailsDatabase} instance using the given dataSource. If the database does not\n     * already contain an object details table, it attempts to create one.\n     *\n     * @return ObjectDetailsDatabase\n     */\n    public ObjectDetailsDatabase build() {\n        Enforce.notNull(dataSource, \"dataSource cannot be null\");\n        var resolvedTableName = tableName == null ? DEFAULT_TABLE_NAME : tableName;\n        var dbType = DbType.fromDataSource(dataSource);\n        ObjectDetailsDatabase database;\n        switch (dbType) {\n            case POSTGRES:\n                database = new PostgresObjectDetailsDatabase(resolvedTableName, dataSource, storeInventory, waitTime, timeUnit);\n                break;\n            case MARIADB:\n                database = new MariaDbObjectDetailsDatabase(resolvedTableName, dataSource, storeInventory, waitTime, timeUnit);\n                break;\n            case H2:\n                database = new H2ObjectDetailsDatabase(resolvedTableName, dataSource, storeInventory, waitTime, timeUnit);\n                break;\n            default:\n                throw new OcflJavaException(String.format(\"Database type %s is not mapped to an ObjectDetailsDatabase implementation.\", dbType));\n        }\n        new TableCreator(dbType, dataSource).createObjectDetailsTable(resolvedTableName);\n        return database;\n    }\n"]], "pred": {"ppl": 1.7356663942337036, "ppl_lower": 1.8573582172393799, "ppl/lowercase_ppl": -1.1228958825836532, "ppl/zlib": 0.0005524964213938589, "Min_5.0% Prob": 6.166948638179085, "Min_10.0% Prob": 4.2179717150601475, "Min_20.0% Prob": 2.57249334894798, "Min_30.0% Prob": 1.8074581207086642, "Min_40.0% Prob": 1.3727375195700338, "Min_50.0% Prob": 1.1016056574584747, "Min_60.0% Prob": 0.9187415675992132}}
{"hexsha": "314162009daa2234d115fa8a7912cba3d4305e99", "ext": "java", "lang": "Java", "content": "public final class ObjectToFieldsSerializer implements ObjectSerializer {\n\n    /** The Constant visited. */\n    private static final ArrayList<Object> visited = new ArrayList<Object>();\n\n    /**\n     * Converts an object to a string representation that lists all fields.\n     *\n     * @param auditFields the audit fields\n     * @param object an object\n     * @param objectName the object name\n     * @param deidentify the de-identify\n     */\n    public final void toFields(List<Field> auditFields, Object object, String objectName, DeIdentify deidentify) {\n        String localOjectName = objectName;\n        if (object == null) {\n            auditFields.add(new Field(localOjectName, CoreConstants.NULL));\n            return;\n        }\n        \n        Class<?> clazz = object.getClass();\n        if (!visited.contains(object)) {\n            visited.add(object);\n            if (isPrimitive(object)) {\n                String primitiveValue = String.valueOf(object);\n                if (deidentify != null) {\n                    primitiveValue = DeIdentifyUtil.deidentify(primitiveValue, deidentify.left(), deidentify.right(),\n                            deidentify.fromLeft(), deidentify.fromRight());\n                }\n                auditFields.add(new Field(localOjectName, primitiveValue, object.getClass()\n                        .getName()));\n            } else if (clazz.isArray()) {\n                if (Array.getLength(object) == 0) {\n                    auditFields.add(new Field(localOjectName + CoreConstants.DOLLAR_CHAR + clazz.getName(),\n                            CoreConstants.EMPTY));\n                } else {\n                    // String internalLocalOjectName = localOjectName + CoreConstants.DOLLAR_CHAR +\n                    // clazz.getName();\n                    for (int i = 0; i < Array.getLength(object); i++) {\n                        Object objVal = Array.get(object, i);\n                        String internalLocalOjectName = localOjectName + CoreConstants.OPEN_BRACES_CHAR + \"arg\"\n                                + i + CoreConstants.CLOSE_BRACES_CHAR;\n                        if (clazz.getComponentType().isPrimitive())\n                            auditFields.add(new Field(internalLocalOjectName, String\n                                    .valueOf(objVal), objVal.getClass().getName()));\n                        else if (objVal != null) {\n                            toFields(auditFields, objVal, internalLocalOjectName, null);\n                        }\n                    }\n                }\n            } else if (object instanceof Collection<?>) {\n                Collection<?> collection = (Collection<?>) object;\n                if (collection.isEmpty()) {\n                    auditFields.add(new Field(localOjectName + CoreConstants.DOLLAR_CHAR + clazz.getName(),\n                            CoreConstants.EMPTY));\n                } else {\n                    String internalLocalOjectName = localOjectName + CoreConstants.DOLLAR_CHAR + object.getClass().getName();\n                int i = 0;\n                for (Object collectionObject : collection) {\n                    String internalLocalOjectName2 = internalLocalOjectName +  CoreConstants.OPEN_BRACES_CHAR + \"arg\" + i\n                            + CoreConstants.CLOSE_BRACES_CHAR;\n                    if (isPrimitive(collectionObject)) {\n                        auditFields.add(new Field(internalLocalOjectName2, String\n                                .valueOf(collectionObject), collectionObject.getClass().getName()));\n                    } else if (collectionObject != null) {\n                        toFields(auditFields, collectionObject, internalLocalOjectName2, null);\n                    }\n                    i++;\n                }\n                }\n            } else {\n                String internalLocalOjectName = localOjectName + CoreConstants.DOLLAR_CHAR + clazz.getName();\n                do {\n                    java.lang.reflect.Field[] fields = clazz.getDeclaredFields();\n                    AccessibleObject.setAccessible(fields, true);\n                    for (java.lang.reflect.Field field : fields) {\n                        if (!Modifier.isStatic(field.getModifiers()) && !field.isAnnotationPresent(IgnoreAudit.class)) {\n                            String internalLocalOjectName2 = internalLocalOjectName + CoreConstants.DOLLAR_CHAR + field.getName();\n                            boolean deidentifyFlag = false;\n                            DeIdentify deidentifyAnn = null;\n                            if (field.isAnnotationPresent(DeIdentify.class)) {\n                                deidentifyAnn = field.getAnnotation(DeIdentify.class);\n                                deidentifyFlag = true;\n                            }\n                            try {\n                                Object objValue = field.get(object);\n                                if (isPrimitive(object)) {\n                                    String paramValue = String.valueOf(object);\n                                    if (deidentifyFlag) {\n                                        paramValue = DeIdentifyUtil.deidentify(paramValue, deidentifyAnn.left(),\n                                                deidentifyAnn.right(), deidentifyAnn.fromLeft(),\n                                                deidentifyAnn.fromRight());\n                                    }\n                                    auditFields.add(new Field(internalLocalOjectName2, paramValue,\n                                            object.getClass().getName()));\n                                } else {\n                                    if (objValue != null) {\n                                        toFields(auditFields, objValue, internalLocalOjectName2, deidentifyAnn);\n                                    }\n                                }\n                            } catch (IllegalArgumentException e) {\n                                throw new Audit4jRuntimeException(\n                                        \"Error due to converting object to string representation. \", e);\n                            } catch (IllegalAccessException e) {\n                                throw new Audit4jRuntimeException(\n                                        \"Error due to converting object to string representation. \", e);\n                            } catch (Exception e) {\n                                throw new Audit4jRuntimeException(\n                                        \"Error due to converting object to string representation. \", e);\n                            }\n                        }\n                    }\n                    clazz = clazz.getSuperclass();\n                } while (clazz != null);\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n     * @see org.audit4j.core.ObjectSerializer#serialize(java.util.List, java.lang.Object, java.lang.String, org.audit4j.core.annotation.DeIdentify)\n     */\n    @Override\n    public void serialize(List<Field> auditFields, Object object,\n            String objectName,  DeIdentify deidentify) {\n        visited.clear();\n       toFields(auditFields, object, objectName, deidentify);\n    }\n\n    /**\n     * Checks if is primitive.\n     * \n     * @param object\n     *            the object\n     * @return true, if is primitive\n     */\n    public final static boolean isPrimitive(Object object) {\n        if (object instanceof String || object instanceof Number || object instanceof Boolean\n                || object instanceof Character) {\n            return true;\n        }\n        return false;\n    }\n    \n}", "item_id": 0, "repo": "domhurr/audit4j-core", "file": "src/main/java/org/audit4j/core/ObjectToFieldsSerializer.java", "last_update_at": "2022-03-13T06:45:22+00:00", "question_id": "314162009daa2234d115fa8a7912cba3d4305e99_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class ObjectToFieldsSerializer implements ObjectSerializer {\n    /** The Constant visited. */\n    private static final ArrayList<Object> visited = new ArrayList<Object>();\n    /**\n     * Converts an object to a string representation that lists all fields.\n     *\n     * @param auditFields the audit fields\n     * @param object an object\n     * @param objectName the object name\n     * @param deidentify the de-identify\n     */\n    public final void toFields(List<Field> auditFields, Object object, String objectName, DeIdentify deidentify) {\n        String localOjectName = objectName;\n        if (object == null) {\n            auditFields.add(new Field(localOjectName, CoreConstants.NULL));\n            return;\n        }\n        Class<?> clazz = object.getClass();\n        if (!visited.contains(object)) {\n            visited.add(object);\n            if (isPrimitive(object)) {\n                String primitiveValue = String.valueOf(object);\n                if (deidentify != null) {\n                    primitiveValue = DeIdentifyUtil.deidentify(primitiveValue, deidentify.left(), deidentify.right(),\n                            deidentify.fromLeft(), deidentify.fromRight());\n                }\n                auditFields.add(new Field(localOjectName, primitiveValue, object.getClass()\n                        .getName()));\n            } else if (clazz.isArray()) {\n                if (Array.getLength(object) == 0) {\n                    auditFields.add(new Field(localOjectName + CoreConstants.DOLLAR_CHAR + clazz.getName(),\n                            CoreConstants.EMPTY));\n                } else {\n                    // String internalLocalOjectName = localOjectName + CoreConstants.DOLLAR_CHAR +\n                    // clazz.getName();\n                    for (int i = 0; i < Array.getLength(object); i++) {\n                        Object objVal = Array.get(object, i);\n                        String internalLocalOjectName = localOjectName + CoreConstants.OPEN_BRACES_CHAR + \"arg\"\n                                + i + CoreConstants.CLOSE_BRACES_CHAR;\n                        if (clazz.getComponentType().isPrimitive())\n                            auditFields.add(new Field(internalLocalOjectName, String\n                                    .valueOf(objVal), objVal.getClass().getName()));\n                        else if (objVal != null) {\n                            toFields(auditFields, objVal, internalLocalOjectName, null);\n                        }\n                    }\n                }\n            } else if (object instanceof Collection<?>) {\n                Collection<?> collection = (Collection<?>) object;\n                if (collection.isEmpty()) {\n                    auditFields.add(new Field(localOjectName + CoreConstants.DOLLAR_CHAR + clazz.getName(),\n                            CoreConstants.EMPTY));\n                } else {\n                    String internalLocalOjectName = localOjectName + CoreConstants.DOLLAR_CHAR + object.getClass().getName();\n                int i = 0;\n                for (Object collectionObject : collection) {\n                    String internalLocalOjectName2 = internalLocalOjectName +  CoreConstants.OPEN_BRACES_CHAR + \"arg\" + i\n                            + CoreConstants.CLOSE_BRACES_CHAR;\n                    if (isPrimitive(collectionObject)) {\n                        auditFields.add(new Field(internalLocalOjectName2, String\n                                .valueOf(collectionObject), collectionObject.getClass().getName()));\n                    } else if (collectionObject != null) {\n                        toFields(auditFields, collectionObject, internalLocalOjectName2, null);\n                    }\n                    i++;\n                }\n                }\n            } else {\n                String internalLocalOjectName = localOjectName + CoreConstants.DOLLAR_CHAR + clazz.getName();\n                do {\n                    java.lang.reflect.Field[] fields = clazz.getDeclaredFields();\n                    AccessibleObject.setAccessible(fields, true);\n                    for (java.lang.reflect.Field field : fields) {\n                        if (!Modifier.isStatic(field.getModifiers()) && !field.isAnnotationPresent(IgnoreAudit.class)) {\n                            String internalLocalOjectName2 = internalLocalOjectName + CoreConstants.DOLLAR_CHAR + field.getName();\n                            boolean deidentifyFlag = false;\n                            DeIdentify deidentifyAnn = null;\n                            if (field.isAnnotationPresent(DeIdentify.class)) {\n                                deidentifyAnn = field.getAnnotation(DeIdentify.class);\n                                deidentifyFlag = true;\n                            }\n                            try {\n                                Object objValue = field.get(object);\n                                if (isPrimitive(object)) {\n                                    String paramValue = String.valueOf(object);\n                                    if (deidentifyFlag) {\n                                        paramValue = DeIdentifyUtil.deidentify(paramValue, deidentifyAnn.left(),\n                                                deidentifyAnn.right(), deidentifyAnn.fromLeft(),\n                                                deidentifyAnn.fromRight());\n                                    }\n                                    auditFields.add(new Field(internalLocalOjectName2, paramValue,\n                                            object.getClass().getName()));\n                                } else {\n                                    if (objValue != null) {\n                                        toFields(auditFields, objValue, internalLocalOjectName2, deidentifyAnn);\n                                    }\n                                }\n                            } catch (IllegalArgumentException e) {\n                                throw new Audit4jRuntimeException(\n                                        \"Error due to converting object to string representation. \", e);\n                            } catch (IllegalAccessException e) {\n                                throw new Audit4jRuntimeException(\n                                        \"Error due to converting object to string representation. \", e);\n                            } catch (Exception e) {\n                                throw new Audit4jRuntimeException(\n                                        \"Error due to converting object to string representation. \", e);\n                            }\n                        }\n                    }\n                    clazz = clazz.getSuperclass();\n                } while (clazz != null);\n            }\n        }\n    }\n    /* (non-Javadoc)\n     * @see org.audit4j.core.ObjectSerializer#serialize(java.util.List, java.lang.Object, java.lang.String, org.audit4j.core.annotation.DeIdentify)\n     */\n    @Override\n    public void serialize(List<Field> auditFields, Object object,\n            String objectName,  DeIdentify deidentify) {\n        visited.clear();\n       toFields(auditFields, object, objectName, deidentify);\n    }\n    /**\n     * Checks if is primitive.\n     * \n     * @param object\n     *            the object\n     * @return true, if is primitive\n     */\n    public final static boolean isPrimitive(Object object) {\n        if (object instanceof String || object instanceof Number || object instanceof Boolean\n                || object instanceof Character) {\n            return true;\n        }\n        return false;\n    }\n"]], "pred": {"ppl": 1.7271504402160645, "ppl_lower": 1.8478162288665771, "ppl/lowercase_ppl": -1.1235772499892944, "ppl/zlib": 0.0003496307780499953, "Min_5.0% Prob": 6.137814783582501, "Min_10.0% Prob": 4.251036098190382, "Min_20.0% Prob": 2.563217709461848, "Min_30.0% Prob": 1.7910177038824246, "Min_40.0% Prob": 1.357308134928455, "Min_50.0% Prob": 1.0911855255791265, "Min_60.0% Prob": 0.9111636839450001}}
{"hexsha": "c7dd78e22c07b8e0fc390ffbd3b466b0c8e42f39", "ext": "java", "lang": "Java", "content": "public class CustomViewRowImpl extends ViewRowImpl {\r\n    @Override\r\n    protected ViewRowAttrHintsImpl createViewRowAttrHints(AttributeDefImpl attrDef) {\r\n        return new CustomViewRowAttrHints(attrDef,this);\r\n    }\r\n    class CustomViewRowAttrHints extends ViewRowAttrHintsImpl {\r\n        protected CustomViewRowAttrHints(AttributeDefImpl attr, ViewRowImpl viewRow) {\r\n           super(attr,viewRow);\r\n        }\r\n        @Override\r\n        public String getHint(LocaleContext locale, String sHintName) {\r\n            if (\"rowState\".equals(sHintName)) {\r\n              ViewRowImpl vri = getViewRow();\r\n              if (vri != null) {\r\n                  Entity e = vri.getEntity(0);\r\n                  if (e != null) {\r\n                      return translateStatusToString(e.getEntityState());\r\n                  }\r\n                  return null;\r\n              }\r\n            }\r\n            else if (\"valueChanged\".equals(sHintName)) {\r\n                ViewRowImpl vri = getViewRow();\r\n                if (vri != null) {\r\n                    boolean changed = vri.isAttributeChanged(getViewAttributeDef().getName());\r\n                    return changed ? \"true\":\"false\";\r\n                }\r\n            }\r\n            return super.getHint(locale, sHintName);\r\n        }\r\n        private String translateStatusToString(byte b) {\r\n          String ret = null;\r\n          switch (b) {\r\n            case Entity.STATUS_DELETED: {\r\n              ret = \"Deleted\";\r\n              break;\r\n            }\r\n            case Entity.STATUS_INITIALIZED: {\r\n              ret = \"Initialized\";\r\n              break;\r\n            }\r\n            case Entity.STATUS_MODIFIED: {\r\n              ret = \"Modified\";\r\n              break;\r\n            }\r\n            case Entity.STATUS_UNMODIFIED: {\r\n              ret = \"Unmodified\";\r\n              break;\r\n            }\r\n            case Entity.STATUS_NEW: {\r\n              ret = \"New\";\r\n              break;\r\n            }\r\n          }\r\n          return ret;\r\n        }        \r\n    }\r\n}", "item_id": 0, "repo": "amruth006/adf-samples-master", "file": "src/NestedTransactionExample/FrameworkExtensions/src/oramag/model/fwkext/CustomViewRowImpl.java", "last_update_at": "2022-03-20T15:19:44+00:00", "question_id": "c7dd78e22c07b8e0fc390ffbd3b466b0c8e42f39_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CustomViewRowImpl extends ViewRowImpl {\r\n    @Override\r\n    protected ViewRowAttrHintsImpl createViewRowAttrHints(AttributeDefImpl attrDef) {\r\n        return new CustomViewRowAttrHints(attrDef,this);\r\n    }\r\n    class CustomViewRowAttrHints extends ViewRowAttrHintsImpl {\r\n        protected CustomViewRowAttrHints(AttributeDefImpl attr, ViewRowImpl viewRow) {\r\n           super(attr,viewRow);\r\n        }\r\n        @Override\r\n        public String getHint(LocaleContext locale, String sHintName) {\r\n            if (\"rowState\".equals(sHintName)) {\r\n              ViewRowImpl vri = getViewRow();\r\n              if (vri != null) {\r\n                  Entity e = vri.getEntity(0);\r\n                  if (e != null) {\r\n                      return translateStatusToString(e.getEntityState());\r\n                  }\r\n                  return null;\r\n              }\r\n            }\r\n            else if (\"valueChanged\".equals(sHintName)) {\r\n                ViewRowImpl vri = getViewRow();\r\n                if (vri != null) {\r\n                    boolean changed = vri.isAttributeChanged(getViewAttributeDef().getName());\r\n                    return changed ? \"true\":\"false\";\r\n                }\r\n            }\r\n            return super.getHint(locale, sHintName);\r\n        }\r\n        private String translateStatusToString(byte b) {\r\n          String ret = null;\r\n          switch (b) {\r\n            case Entity.STATUS_DELETED: {\r\n              ret = \"Deleted\";\r\n              break;\r\n            }\r\n            case Entity.STATUS_INITIALIZED: {\r\n              ret = \"Initialized\";\r\n              break;\r\n            }\r\n            case Entity.STATUS_MODIFIED: {\r\n              ret = \"Modified\";\r\n              break;\r\n            }\r\n            case Entity.STATUS_UNMODIFIED: {\r\n              ret = \"Unmodified\";\r\n              break;\r\n            }\r\n            case Entity.STATUS_NEW: {\r\n              ret = \"New\";\r\n              break;\r\n            }\r\n          }\r\n          return ret;\r\n        }        \r\n    }\r\n"]], "pred": {"ppl": 2.0190553665161133, "ppl_lower": 2.3509137630462646, "ppl/lowercase_ppl": -1.2165782528964495, "ppl/zlib": 0.0012457974498168644, "Min_5.0% Prob": 6.277841587861379, "Min_10.0% Prob": 4.878278547403764, "Min_20.0% Prob": 3.1799429986211987, "Min_30.0% Prob": 2.2764714808272037, "Min_40.0% Prob": 1.7491753643585577, "Min_50.0% Prob": 1.4039512235791451, "Min_60.0% Prob": 1.1706936169562598}}
{"hexsha": "699d4c1baf64343d127ae1f4f38e4cacda7c5f18", "ext": "java", "lang": "Java", "content": "@Path(\"/endp\")\n@RolesAllowed({\"Echoer\", \"Tester\"})\n@ApplicationScoped\npublic class ApplicationScopedEndpoint {\n\n    @Inject\n    private JsonWebToken jwt;\n\n    @Inject\n    @Claim(\"raw_token\")\n    private ClaimValue<String> rawToken;\n\n    @Inject\n    @Claim(\"raw_token\")\n    private Provider<String> providedRawToken;\n\n    @GET\n    @Path(\"/verifyInjectedRawTokenClaimValue\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public JsonObject verifyInjectedRawTokenClaimValue(@QueryParam(\"raw_token\") String rt) {\n        return verifyRawToken(rawToken.getValue(), rt);\n    }\n\n    @GET\n    @Path(\"/verifyInjectedRawTokenJwt\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public JsonObject verifyInjectedRawTokenJwt(@QueryParam(\"raw_token\") String rt) {\n        return verifyRawToken(jwt.getRawToken(), rt);\n    }\n\n    @GET\n    @Path(\"/verifyInjectedRawTokenProvider\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public JsonObject verifyInjectedRawTokenProvider(@QueryParam(\"raw_token\") String rt) {\n        return verifyRawToken(providedRawToken.get(), rt);\n    }\n\n    private static JsonObject verifyRawToken(String injectedRawToken, String rawTokenQueryParam) {\n        boolean pass = false;\n        String msg;\n        if (injectedRawToken == null || injectedRawToken.length() == 0) {\n            msg = Claims.raw_token.name() + \"value is null or empty, FAIL\";\n        } else if (injectedRawToken.equals(rawTokenQueryParam)) {\n            msg = Claims.raw_token.name() + \" PASS\";\n            pass = true;\n        } else {\n            msg = String.format(\"%s: %s != %s\", Claims.raw_token.name(), injectedRawToken, rawTokenQueryParam);\n        }\n        JsonObject result = Json.createObjectBuilder()\n                .add(\"pass\", pass)\n                .add(\"msg\", msg)\n                .add(\"injectedRawToken\", injectedRawToken)\n                .build();\n        return result;\n    }\n}", "item_id": 0, "repo": "deviantdev/microprofile-jwt-auth", "file": "tck/src/test/java/org/eclipse/microprofile/jwt/tck/container/jaxrs/ApplicationScopedEndpoint.java", "last_update_at": "2022-02-07T14:58:25+00:00", "question_id": "699d4c1baf64343d127ae1f4f38e4cacda7c5f18_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Path(\"/endp\")\n@RolesAllowed({\"Echoer\", \"Tester\"})\n@ApplicationScoped\npublic class ApplicationScopedEndpoint {\n    @Inject\n    private JsonWebToken jwt;\n    @Inject\n    @Claim(\"raw_token\")\n    private ClaimValue<String> rawToken;\n    @Inject\n    @Claim(\"raw_token\")\n    private Provider<String> providedRawToken;\n    @GET\n    @Path(\"/verifyInjectedRawTokenClaimValue\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public JsonObject verifyInjectedRawTokenClaimValue(@QueryParam(\"raw_token\") String rt) {\n        return verifyRawToken(rawToken.getValue(), rt);\n    }\n    @GET\n    @Path(\"/verifyInjectedRawTokenJwt\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public JsonObject verifyInjectedRawTokenJwt(@QueryParam(\"raw_token\") String rt) {\n        return verifyRawToken(jwt.getRawToken(), rt);\n    }\n    @GET\n    @Path(\"/verifyInjectedRawTokenProvider\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public JsonObject verifyInjectedRawTokenProvider(@QueryParam(\"raw_token\") String rt) {\n        return verifyRawToken(providedRawToken.get(), rt);\n    }\n    private static JsonObject verifyRawToken(String injectedRawToken, String rawTokenQueryParam) {\n        boolean pass = false;\n        String msg;\n        if (injectedRawToken == null || injectedRawToken.length() == 0) {\n            msg = Claims.raw_token.name() + \"value is null or empty, FAIL\";\n        } else if (injectedRawToken.equals(rawTokenQueryParam)) {\n            msg = Claims.raw_token.name() + \" PASS\";\n            pass = true;\n        } else {\n            msg = String.format(\"%s: %s != %s\", Claims.raw_token.name(), injectedRawToken, rawTokenQueryParam);\n        }\n        JsonObject result = Json.createObjectBuilder()\n                .add(\"pass\", pass)\n                .add(\"msg\", msg)\n                .add(\"injectedRawToken\", injectedRawToken)\n                .build();\n        return result;\n    }\n"]], "pred": {"ppl": 1.7177234888076782, "ppl_lower": 2.179892063140869, "ppl/lowercase_ppl": -1.4404354219560445, "ppl/zlib": 0.0009376080782264154, "Min_5.0% Prob": 5.977671495505741, "Min_10.0% Prob": 4.240984105638096, "Min_20.0% Prob": 2.548034065328868, "Min_30.0% Prob": 1.7850285914434483, "Min_40.0% Prob": 1.3479424567761278, "Min_50.0% Prob": 1.0828392320388518, "Min_60.0% Prob": 0.9014047898495003}}
{"hexsha": "6b8394dbe86cfd0bdc0059240230c1467417c2df", "ext": "java", "lang": "Java", "content": "public class MnemonicSOMLibFormatInputReader extends SOMLibFormatInputReader {\n    protected void processUnitElement(String line, int j, int i) {\n        processUnitElement(line, 0, j, i);\n    }\n\n    @Override\n    protected void processUnitElement(String line, int k, int j, int i) {\n        if (line.startsWith(\"null\")) {\n            unitInfo[i][j][k] = null;\n        } else {\n            super.processUnitElement(line, k, j, i);\n        }\n    }\n\n    public MnemonicSOMLibFormatInputReader(String unitDescriptionFileName, String mapDescriptionFileName, int dimension)\n            throws FileNotFoundException, SOMLibFileFormatException {\n        this(null, unitDescriptionFileName, unitDescriptionFileName, dimension);\n    }\n\n    public MnemonicSOMLibFormatInputReader(String weightVectorFileName, String unitDescriptionFileName,\n            String mapDescriptionFileName) throws FileNotFoundException, SOMLibFileFormatException {\n        super(weightVectorFileName, unitDescriptionFileName, mapDescriptionFileName);\n    }\n\n    public MnemonicSOMLibFormatInputReader(String weightVectorFileName, String unitDescriptionFileName,\n            String mapDescriptionFileName, int dimension) throws FileNotFoundException, SOMLibFileFormatException {\n        super(null, unitDescriptionFileName, mapDescriptionFileName);\n        this.dim = dimension;\n        generateWRandomWeightvectors();\n    }\n\n    /** Generates random weight vectors, but only for those units that are occupied. */\n    private void generateWRandomWeightvectors() {\n        Random rand = new Random();\n        for (int col = 0; col < getXSize(); col++) {\n            for (int row = 0; row < getYSize(); row++) {\n                for (int slice = 0; slice < getZSize(); slice++) {\n                    if (unitInfo[col][row][slice] != null) {\n                        double[] weightVector = new double[dim];\n                        for (int i = 0; i < weightVector.length; i++) {\n                            weightVector[i] = rand.nextDouble();\n                        }\n                        unitInfo[col][row][slice].vector = VectorTools.normaliseVectorToUnitLength(weightVector);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public double[][][][] getVectors() {\n        double[][][][] res = new double[xSize][ySize][zSize][];\n        for (int k = 0; k < zSize; k++) {\n            for (int j = 0; j < ySize; j++) {\n                for (int i = 0; i < xSize; i++) {\n                    if (unitInfo[i][j][k] != null) {\n                        res[i][j][k] = unitInfo[i][j][k].vector;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n\n    @Override\n    public int getNrVecMapped(int x, int y, int z) {\n        if (unitInfo[x][y][z] != null) {\n            return super.getNrVecMapped(x, y, z);\n        } else {\n            return 0;\n        }\n    }\n\n    @Override\n    public String[] getMappedVecs(int x, int y, int z) {\n        if (unitInfo[x][y][z] != null) {\n            return super.getMappedVecs(x, y, z);\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public double[] getMappedVecsDist(int x, int y, int z) {\n        if (unitInfo[x][y][z] != null) {\n            return super.getMappedVecsDist(x, y, z);\n        } else {\n            return null;\n        }\n    }\n\n}", "item_id": 0, "repo": "ChrisPrein/TUW_SelfOrganizingSystems_WS2021", "file": "java_somtoolbox/src/core/at/tuwien/ifs/somtoolbox/input/MnemonicSOMLibFormatInputReader.java", "last_update_at": "2022-01-30T12:47:26+00:00", "question_id": "6b8394dbe86cfd0bdc0059240230c1467417c2df_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MnemonicSOMLibFormatInputReader extends SOMLibFormatInputReader {\n    protected void processUnitElement(String line, int j, int i) {\n        processUnitElement(line, 0, j, i);\n    }\n    @Override\n    protected void processUnitElement(String line, int k, int j, int i) {\n        if (line.startsWith(\"null\")) {\n            unitInfo[i][j][k] = null;\n        } else {\n            super.processUnitElement(line, k, j, i);\n        }\n    }\n    public MnemonicSOMLibFormatInputReader(String unitDescriptionFileName, String mapDescriptionFileName, int dimension)\n            throws FileNotFoundException, SOMLibFileFormatException {\n        this(null, unitDescriptionFileName, unitDescriptionFileName, dimension);\n    }\n    public MnemonicSOMLibFormatInputReader(String weightVectorFileName, String unitDescriptionFileName,\n            String mapDescriptionFileName) throws FileNotFoundException, SOMLibFileFormatException {\n        super(weightVectorFileName, unitDescriptionFileName, mapDescriptionFileName);\n    }\n    public MnemonicSOMLibFormatInputReader(String weightVectorFileName, String unitDescriptionFileName,\n            String mapDescriptionFileName, int dimension) throws FileNotFoundException, SOMLibFileFormatException {\n        super(null, unitDescriptionFileName, mapDescriptionFileName);\n        this.dim = dimension;\n        generateWRandomWeightvectors();\n    }\n    /** Generates random weight vectors, but only for those units that are occupied. */\n    private void generateWRandomWeightvectors() {\n        Random rand = new Random();\n        for (int col = 0; col < getXSize(); col++) {\n            for (int row = 0; row < getYSize(); row++) {\n                for (int slice = 0; slice < getZSize(); slice++) {\n                    if (unitInfo[col][row][slice] != null) {\n                        double[] weightVector = new double[dim];\n                        for (int i = 0; i < weightVector.length; i++) {\n                            weightVector[i] = rand.nextDouble();\n                        }\n                        unitInfo[col][row][slice].vector = VectorTools.normaliseVectorToUnitLength(weightVector);\n                    }\n                }\n            }\n        }\n    }\n    @Override\n    public double[][][][] getVectors() {\n        double[][][][] res = new double[xSize][ySize][zSize][];\n        for (int k = 0; k < zSize; k++) {\n            for (int j = 0; j < ySize; j++) {\n                for (int i = 0; i < xSize; i++) {\n                    if (unitInfo[i][j][k] != null) {\n                        res[i][j][k] = unitInfo[i][j][k].vector;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    @Override\n    public int getNrVecMapped(int x, int y, int z) {\n        if (unitInfo[x][y][z] != null) {\n            return super.getNrVecMapped(x, y, z);\n        } else {\n            return 0;\n        }\n    }\n    @Override\n    public String[] getMappedVecs(int x, int y, int z) {\n        if (unitInfo[x][y][z] != null) {\n            return super.getMappedVecs(x, y, z);\n        } else {\n            return null;\n        }\n    }\n    @Override\n    public double[] getMappedVecsDist(int x, int y, int z) {\n        if (unitInfo[x][y][z] != null) {\n            return super.getMappedVecsDist(x, y, z);\n        } else {\n            return null;\n        }\n    }\n"]], "pred": {"ppl": 1.7447627782821655, "ppl_lower": 1.847683310508728, "ppl/lowercase_ppl": -1.1029681486476166, "ppl/zlib": 0.0006796319935718793, "Min_5.0% Prob": 6.3759752926619155, "Min_10.0% Prob": 4.48552418011491, "Min_20.0% Prob": 2.6748223464119243, "Min_30.0% Prob": 1.8372975503263524, "Min_40.0% Prob": 1.390544217064937, "Min_50.0% Prob": 1.1133361032161002, "Min_60.0% Prob": 0.9276997916641964}}
{"hexsha": "3bc70e63acbe1c19bb491b824e4d6d5ab3c3b8f7", "ext": "java", "lang": "Java", "content": "public class RawCustomResourceOperationsImpl extends OperationSupport implements Nameable<RawCustomResourceOperationsImpl>,\n  Namespaceable<RawCustomResourceOperationsImpl>,\n  AnyNamespaceable<RawCustomResourceOperationsImpl>,\n  Listable<Map<String, Object>>,\n  Gettable<Map<String, Object>>,\n  GracePeriodConfigurable<RawCustomResourceOperationsImpl>,\n  PropagationPolicyConfigurable<RawCustomResourceOperationsImpl>,\n  DryRunable<RawCustomResourceOperationsImpl>,\n  Deletable {\n\n  private static final String METADATA = \"metadata\";\n  private static final String RESOURCE_VERSION = \"resourceVersion\";\n  private static final String STATUS_SUBRESOURCE_ENDPOINT = \"/status\";\n  private final CustomResourceDefinitionContext customResourceDefinition;\n  private final ObjectMapper objectMapper;\n  private final ListOptions listOptions;\n  private final long gracePeriodInSeconds;\n  private final String deletionPropagation;\n  private final boolean cascading;\n\n  private enum HttpCallMethod { GET, POST, PUT, PATCH, DELETE }\n\n  private RawCustomResourceOperationsImpl(OkHttpClient client, Config config, CustomResourceDefinitionContext crdContext, String namespace, String name, long gracePeriodInSeconds, boolean cascading, String deletionPropagation, ListOptions listOptions, boolean dryRun) {\n    super(client, config);\n    this.customResourceDefinition = crdContext;\n    this.objectMapper = PatchUtils.patchMapper();\n    this.namespace = namespace;\n    this.name = name;\n    this.gracePeriodInSeconds = gracePeriodInSeconds;\n    this.cascading = cascading;\n    this.deletionPropagation = deletionPropagation;\n    this.listOptions = listOptions;\n    this.dryRun = dryRun;\n  }\n\n  public RawCustomResourceOperationsImpl(OkHttpClient client, Config config, CustomResourceDefinitionContext customResourceDefinition) {\n    this(client, config, customResourceDefinition, null, null, 0, false, DeletionPropagation.BACKGROUND.toString(), null, false);\n  }\n\n  @Override\n  public RawCustomResourceOperationsImpl withName(String name) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun);\n  }\n\n  @Override\n  public RawCustomResourceOperationsImpl inNamespace(String namespace) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun);\n  }\n\n  @Override\n  public RawCustomResourceOperationsImpl inAnyNamespace() {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun);\n  }\n\n  @Override\n  public RawCustomResourceOperationsImpl withGracePeriod(long gracePeriodSeconds) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodSeconds, cascading, deletionPropagation, listOptions, dryRun);\n  }\n\n  @Override\n  public RawCustomResourceOperationsImpl withPropagationPolicy(DeletionPropagation propagationPolicy) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, propagationPolicy.toString(), listOptions, dryRun);\n  }\n\n  @Override\n  public RawCustomResourceOperationsImpl dryRun(boolean isDryRun) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, isDryRun);\n  }\n\n  /**\n   * Load a custom resource object from an inputstream into a HashMap\n   *\n   * @param fileInputStream file input stream\n   * @return custom resource as HashMap\n   * @throws IOException exception in case any read operation fails.\n   */\n  public Map<String, Object> load(InputStream fileInputStream) throws IOException {\n    return convertJsonOrYamlStringToMap(IOHelpers.readFully(fileInputStream));\n  }\n\n  /**\n   * Load a custom resource object from a JSON string into a HashMap\n   *\n   * @param objectAsJsonString object as JSON string\n   * @return custom resource as HashMap\n   * @throws IOException exception in case any problem in reading json.\n   */\n  public Map<String, Object> load(String objectAsJsonString) throws IOException {\n    return convertJsonOrYamlStringToMap(objectAsJsonString);\n  }\n\n  /**\n   * Create a custom resource which is a non-namespaced object.\n   *\n   * @param objectAsString object as JSON string\n   * @return Object as HashMap\n   * @throws IOException exception in case of any network/read problems\n   */\n  public Map<String, Object> create(String objectAsString) throws IOException {\n    return validateAndSubmitRequest(objectAsString, HttpCallMethod.POST);\n  }\n\n  /**\n   * Create a custom resource which is non-namespaced.\n   *\n   * @param object object a HashMap\n   * @return Object as HashMap\n   * @throws IOException in case of problems while reading HashMap\n   */\n  public Map<String, Object> create(Map<String, Object> object) throws IOException {\n    return validateAndSubmitRequest(objectMapper.writeValueAsString(object), HttpCallMethod.POST);\n  }\n\n  /**\n   * Create a custom resource which is a namespaced object.\n   *\n   * @param namespace namespace in which we want object to be created.\n   * @param objectAsString Object as JSON string\n   * @return Object as HashMap\n   * @throws IOException in case of problems while reading JSON object\n   */\n  public Map<String, Object> create(String namespace, String objectAsString) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).create(objectAsString);\n  }\n\n  /**\n   * Create a custom resource which is non-namespaced object.\n   *\n   * @param objectAsStream object as a file input stream\n   * @return Object as HashMap\n   * @throws IOException in case of problems while reading file\n   */\n  public Map<String, Object> create(InputStream objectAsStream) throws IOException {\n    return validateAndSubmitRequest(IOHelpers.readFully(objectAsStream), HttpCallMethod.POST);\n  }\n\n  /**\n   * Create a custom resource which is a namespaced object.\n   *\n   * @param namespace namespace in which we want object to be created\n   * @param objectAsStream object as file input stream\n   * @return Object as HashMap\n   * @throws IOException in case of problems while reading file\n   */\n  public Map<String, Object> create(String namespace, InputStream objectAsStream) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).create(objectAsStream);\n  }\n\n  /**\n   * Create a custom resource which is a namespaced object.\n   *\n   * @param namespace namespace in which we want object to be created.\n   * @param object object as a HashMap\n   * @return Object as HashMap\n   * @throws IOException in case of problems faced while serializing HashMap\n   */\n  public Map<String, Object> create(String namespace, Map<String, Object> object) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).create(object);\n  }\n\n  /**\n   *\n   * Create or replace a custom resource which is a non-namespaced object.\n   *\n   * @param objectAsString object as JSON string\n   * @return Object as HashMap\n   * @throws IOException in case of network/serializiation failures or failures from Kuberntes API\n   */\n  public Map<String, Object> createOrReplace(String objectAsString) throws IOException {\n    return createOrReplaceObject(load(objectAsString));\n  }\n\n  /**\n   * Create or replace a custom resource which is a non-namespced object.\n   *\n   * @param customResourceObject object as HashMap\n   * @return Object as HashMap\n   * @throws IOException in case of network/serialization failures or failures from Kubernetes API\n   */\n  public Map<String, Object> createOrReplace(Map<String, Object> customResourceObject) throws IOException {\n    return createOrReplaceObject(customResourceObject);\n  }\n\n  /**\n   * Create or replace a custom resource which is non-namespaced object.\n   *\n   * @param inputStream object as file input stream\n   * @return Object as HashMap\n   * @throws IOException in case of network/serialization failures or failures from Kubernetes API\n   */\n  public Map<String, Object> createOrReplace(InputStream inputStream) throws IOException {\n    return createOrReplaceObject(load(inputStream));\n  }\n\n  /**\n   * Create or replace a custom resource which is namespaced object.\n   *\n   * @param namespace desired namespace\n   * @param objectAsString object as JSON String\n   * @return Object as HashMap\n   * @throws IOException in case of network/serialization failures or failures from Kubernetes API\n   */\n  public Map<String, Object> createOrReplace(String namespace, String objectAsString) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).createOrReplace(objectAsString);\n  }\n\n  /**\n   * Create or replace a custom resource which is namespaced object.\n   *\n   * @param namespace desired namespace\n   * @param customResourceObject object as HashMap\n   * @return Object as HashMap\n   * @throws IOException in case of network/serialization failures or failures from Kubernetes API\n   */\n  public Map<String, Object> createOrReplace(String namespace, Map<String, Object> customResourceObject) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).createOrReplace(customResourceObject);\n  }\n\n  /**\n   * Create or replace a custom resource which is namespaced object.\n   *\n   * @param namespace desired namespace\n   * @param objectAsStream object as file input stream\n   * @return Object as HashMap\n   * @throws IOException in case of network/serialization failures or failures from Kubernetes API\n   */\n  public Map<String, Object> createOrReplace(String namespace, InputStream objectAsStream) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).createOrReplace(objectAsStream);\n  }\n\n  private Map<String, Object> replace(String namespace, String name, Map<String, Object> object) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).replace(object);\n  }\n\n  private Map<String, Object> replace(String name, Map<String, Object> object) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).replace(object);\n  }\n\n  private Map<String, Object> replace(Map<String, Object> object) throws IOException {\n    return validateAndSubmitRequest(objectMapper.writeValueAsString(object), HttpCallMethod.PUT);\n  }\n\n  /**\n   * Edit a custom resource object which is a non-namespaced object.\n   *\n   * @param name name of the custom resource\n   * @param object new object as a HashMap\n   * @return Object as HashMap\n   * @throws IOException in case of network/serialization failures or failures from Kubernetes API\n   */\n  public Map<String, Object> edit(String name, Map<String, Object> object) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).edit(object);\n  }\n\n  /**\n   * Edit a custom resource object which is a non-namespaced object.\n   *\n   * @param name name of the custom resource\n   * @param objectAsString new object as a JSON String\n   * @return Object as HashMap\n   * @throws IOException in case of network/serialization failures or failures from Kubernetes API\n   */\n  public Map<String, Object> edit(String name, String objectAsString) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).edit(objectAsString);\n  }\n\n  /**\n   * Edit a custom resource object which is a namespaced object.\n   *\n   * @param namespace desired namespace\n   * @param name name of the custom resource\n   * @param object new object as a HashMap\n   * @return Object as HashMap\n   * @throws IOException in case of network/serialization failures or failures from Kubernetes API\n   */\n  public Map<String, Object> edit(String namespace, String name, Map<String, Object> object) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).edit(object);\n  }\n\n  /**\n   * Edit a custom resource object which is a namespaced object.\n   *\n   * @param namespace desired namespace\n   * @param name name of the custom resource\n   * @param objectAsString new object as a JSON string\n   * @return Object as HashMap\n   * @throws IOException in case of network/serialization failures or failures from Kubernetes API\n   */\n  public Map<String, Object> edit(String namespace, String name, String objectAsString) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).edit(objectAsString);\n  }\n\n  /**\n   * Edit a custom resource object.\n   *\n   * @param objectAsString new object as JSON string\n   * @return Object as HashMap\n   * @throws IOException in case of network/serializatino failures or failures from Kubernetes API\n   */\n  public Map<String, Object> edit(String objectAsString) throws IOException {\n    Map<String, Object> object = convertJsonOrYamlStringToMap(objectAsString);\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).edit(object);\n  }\n\n  /**\n   * Edit a custom resource object.\n   *\n   * @param object new object as Map\n   * @return Object as HashMap\n   * @throws IOException in case of network/serializatino failures or failures from Kubernetes API\n   */\n  public Map<String, Object> edit(Map<String, Object> object) throws IOException {\n    String objectAsString = getPatchDiff(namespace, name, object);\n    return validateAndSubmitRequest(objectAsString, HttpCallMethod.PATCH);\n  }\n\n  /**\n   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related\n   * to the CustomResource\n   *\n   * @param name name of custom resource\n   * @param objectAsMap custom resource as a HashMap\n   * @return updated CustomResource as HashMap\n   * @throws IOException in case any failure to parse Map\n   */\n  public Map<String, Object> updateStatus(String name, Map<String, Object> objectAsMap) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).updateStatus(objectAsMap);\n  }\n\n  /**\n   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related\n   * to the CustomResource\n   *\n   * @param name name of CustomResource\n   * @param objectAsJsonString CustomResource as a JSON string\n   * @return updated CustomResource as a HashMap\n   * @throws IOException in case any failure to parse Map\n   */\n  public Map<String, Object> updateStatus(String name, String objectAsJsonString) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).updateStatus(objectAsJsonString);\n  }\n\n  /**\n   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related\n   * to the CustomResource\n   *\n   * @param namespace namespace of CustomResource\n   * @param name name of CustomResource\n   * @param objectAsMap CustomResource as a HashMap\n   * @return updated CustomResource as a HashMap\n   * @throws IOException in case any failure to parse Map\n   */\n  public Map<String, Object> updateStatus(String namespace, String name, Map<String, Object> objectAsMap) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).updateStatus(objectAsMap);\n  }\n\n  /**\n   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related\n   * to the CustomResource\n   *\n   * @param name name of CustomResource\n   * @param objectAsStream stream pointing to CustomResource\n   * @return updated CustomResource as a HashMap\n   * @throws IOException in case any failure to parse Map\n   */\n  public Map<String, Object> updateStatus(String name, InputStream objectAsStream) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).updateStatus(objectAsStream);\n  }\n\n  /**\n   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related\n   * to the CustomResource\n   *\n   * @param namespace namespace of CustomResource\n   * @param name name of CustomResource\n   * @param objectAsStream CustomResource object as a stream\n   * @return updated CustomResource as a HashMap\n   * @throws IOException in case any failure to parse Map\n   */\n  public Map<String, Object> updateStatus(String namespace, String name, InputStream objectAsStream) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).updateStatus(objectAsStream);\n  }\n\n  /**\n   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related\n   * to the CustomResource\n   *\n   * @param namespace namespace of CustomResource\n   * @param name name of CustomResource\n   * @param objectAsJsonString CustomResource object as a JSON string\n   * @return updated CustomResource as a HashMap\n   * @throws IOException in case any failure to parse Map\n   */\n  public Map<String, Object> updateStatus(String namespace, String name, String objectAsJsonString) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).updateStatus(objectAsJsonString);\n  }\n\n  /**\n   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related\n   * to the CustomResource\n   *\n   * @param objectAsJsonString CustomResource object as a JSON string\n   * @return updated CustomResource as HashMap\n   * @throws IOException in case any failures to parse provided object or failure from Kubernetes API\n   */\n  public Map<String, Object> updateStatus(String objectAsJsonString) throws IOException {\n    return validateAndSubmitRequest(fetchUrl(null) + STATUS_SUBRESOURCE_ENDPOINT, objectAsJsonString, HttpCallMethod.PUT);\n  }\n\n  /**\n   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related\n   * to the CustomResource\n   *\n   * @param objectAsMap CustomResource object as a HashMap\n   * @return updated CustomResource as HashMap\n   * @throws IOException in case any failures to parse provided object or failure from Kubernetes API\n   */\n  public Map<String, Object> updateStatus(Map<String, Object> objectAsMap) throws IOException {\n    return validateAndSubmitRequest(fetchUrl(null) + STATUS_SUBRESOURCE_ENDPOINT, objectMapper.writeValueAsString(objectAsMap), HttpCallMethod.PUT);\n  }\n\n  /**\n   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related\n   * to the CustomResource\n   *\n   * @param objectAsInputStream CustomResource object as a InputStream\n   * @return updated CustomResource as HashMap\n   * @throws IOException in case any failures to parse provided object or failure from Kubernetes API\n   */\n  public Map<String, Object> updateStatus(InputStream objectAsInputStream) throws IOException {\n    return validateAndSubmitRequest(fetchUrl(null) + STATUS_SUBRESOURCE_ENDPOINT, IOHelpers.readFully(objectAsInputStream), HttpCallMethod.PUT);\n  }\n\n  @Override\n  public Map<String, Object> get() {\n    return makeCall(fetchUrl(null), null, HttpCallMethod.GET);\n  }\n\n  /**\n   * Get a custom resource from the cluster which is non-namespaced.\n   *\n   * @param name name of custom resource\n   * @return Object as HashMap\n   */\n  public Map<String, Object> get(String name) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).get();\n  }\n\n  /**\n   * Get a custom resource from the cluster which is namespaced.\n   *\n   * @param namespace desired namespace\n   * @param name name of custom resource\n   * @return Object as HashMap\n   */\n  public Map<String, Object> get(String namespace, String name) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).get();\n  }\n\n  /**\n   * List all custom resources in all namespaces\n   *\n   * @return list of custom resources as HashMap\n   */\n  public Map<String, Object> list() {\n    return makeCall(fetchUrl(null), null, HttpCallMethod.GET);\n  }\n\n  @Override\n  public Map<String, Object> list(Integer limitVal, String continueVal) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, new ListOptionsBuilder()\n      .withLimit(limitVal.longValue())\n      .withContinue(continueVal)\n      .build(), dryRun).list();\n  }\n\n  @Override\n  public Map<String, Object> list(ListOptions listOptions) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).list();\n  }\n\n  /**\n   * List all custom resources in a specific namespace\n   *\n   * @param namespace desired namespace\n   * @return list of custom resources as HashMap\n   */\n  public Map<String, Object> list(String namespace) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).list();\n  }\n\n  /**\n   * List all custom resources in a specific namespace with some labels\n   *\n   * @param namespace desired namespace\n   * @param labels labels as a HashMap\n   * @return list of custom resources as HashMap\n   */\n  public Map<String, Object> list(String namespace, Map<String, String> labels) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null,\n      gracePeriodInSeconds, cascading, deletionPropagation, new ListOptionsBuilder().withLabelSelector(getLabelsQueryParam(labels)).build(), dryRun).list();\n  }\n\n  /**\n   * Delete all Namespaced Scoped Custom Resources in a specified namespace\n   * <b>OR</b>\n   * Delete a Cluster Scoped Custom Resource with specified name\n   *\n   * <p>\n   * Note: This method behaves differently based on the scope of CRD:\n   *\n   * If specified CRD is of Namespaced scope, this method would delete all Custom Resources in namespace which is\n   * specified as parameter.\n   * If specified CRD is of Cluster scope, this method would delete a Custom Resource matching the name which is\n   * specified as parameter\n   * </p>\n   *\n   * @param namespaceOrName desired namespace(if CRD is Namespaced) or name(If CRD is Cluster)\n   * @return deleted objects as HashMap\n   */\n  public boolean delete(String namespaceOrName) {\n    return pickNamespaceOrNameBasedOnScopeAndDelete(namespaceOrName, null);\n  }\n\n  /**\n   * Delete all Namespaced Scoped Custom Resources in a specified namespace\n   * <b>OR</b>\n   * Delete a Cluster Scoped Custom Resource with specified name\n   *\n   * <p>\n   * Note: This method behaves differently based on the scope of CRD:\n   *\n   * If specified CRD is of Namespaced scope, this method would delete all Custom Resources in namespace which is\n   * specified as parameter.\n   * If specified CRD is of Cluster scope, this method would delete a Custom Resource matching the name which is\n   * specified as parameter\n   * </p>\n   *\n   * @param namespaceOrName desired namespace(If CRD is Namespaced) or name(If CRD is Cluster)\n   * @param cascading whether dependent object need to be orphaned or not.  If true/false, the \"orphan\"\n   *                   finalizer will be added to/removed from the object's finalizers list.\n   * @return a boolean value whether item was deleted or item didn't exist in server\n   * @throws IOException in case of any network/parsing exception\n   */\n  public boolean delete(String namespaceOrName, boolean cascading) throws IOException {\n    return pickNamespaceOrNameBasedOnScopeAndDelete(namespaceOrName, objectMapper.writeValueAsString(fetchDeleteOptions(cascading, null)));\n  }\n\n  /**\n   * Delete all Namespaced Scoped Custom Resources in a specified namespace\n   * <b>OR</b>\n   * Delete a Cluster Scoped Custom Resource with specified name\n   *\n   * <p>\n   * Note: This method behaves differently based on the scope of CRD:\n   *\n   * If specified CRD is of Namespaced scope, this method would delete all Custom Resources in namespace which is\n   * specified as parameter.\n   * If specified CRD is of Cluster scope, this method would delete a Custom Resource matching the name which is\n   * specified as parameter\n   * </p>\n   *\n   * @param namespaceOrName desired namespace(If CRD is Namespaced) or name(If CRD is Cluster)\n   * @param deleteOptions object provided by Kubernetes API for more fine grained control over deletion.\n   *                       For more information please see https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#deleteoptions-v1-meta\n   * @return a boolean value whether item was deleted or item didn't exist in server\n   * @throws IOException in case of any network/object parse problems\n   */\n  public boolean delete(String namespaceOrName, DeleteOptions deleteOptions) throws IOException {\n    return pickNamespaceOrNameBasedOnScopeAndDelete(namespaceOrName, objectMapper.writeValueAsString(deleteOptions));\n  }\n\n  /**\n   * Delete a custom resource in a specific namespace\n   *\n   * @param namespace desired namespace\n   * @param name custom resource's name\n   * @return a boolean value whether item was deleted or item didn't exist in server\n   * @throws IOException in case of any network/object parse problems\n   */\n  public boolean delete(String namespace, String name) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).delete();\n  }\n\n  /**\n   * Delete a custom resource in a specific namespace\n   *\n   * @param namespace required namespace\n   * @param name required name of custom resource\n   * @param cascading whether dependent object need to be orphaned or not.  If true/false, the \"orphan\"\n   *                   finalizer will be added to/removed from the object's finalizers list.\n   * @return a boolean value whether item was deleted or item didn't exist in server\n   * @throws IOException exception related to network/object parsing\n   */\n  public boolean delete(String namespace, String name, boolean cascading) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, null, listOptions, dryRun).delete();\n  }\n\n  /**\n   * Delete a custom resource in a specific namespace\n   *\n   * @param namespace required namespace\n   * @param name required name of custom resource\n   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents\n   *                            may be set, but not both. The default policy is decided by the existing finalizer set in\n   *                            the metadata.finalizers and the resource-specific default policy.\n   *                            Acceptable values are:\n   *                            'Orphan' - orphan the dependents;\n   *                            'Background' - allow the garbage collector to delete the dependents in the background;\n   *                            'Foreground' - a cascading policy that deletes all dependents in the foreground.\n   * @return a boolean value whether item was deleted or item didn't exist in server\n   * @throws IOException in case of network/object parse exception\n   */\n  public boolean delete(String namespace, String name, String propagationPolicy) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, propagationPolicy, listOptions, dryRun).delete();\n  }\n\n  /**\n   * Delete a custom resource in a specific namespace\n   *\n   * @param namespace required namespace\n   * @param name name of custom resource\n   * @param deleteOptions object provided by Kubernetes API for more fine grained control over deletion.\n   *                       For more information please see https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#deleteoptions-v1-meta\n   * @return a boolean value whether item was deleted or item didn't exist in server\n   * @throws IOException in case of any network/object parse exception\n   */\n  public boolean delete(String namespace, String name, DeleteOptions deleteOptions) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name,\n      gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).handleDelete(objectMapper.writeValueAsString(deleteOptions));\n  }\n\n  @Override\n  public Boolean delete() {\n    try {\n      return handleDelete(objectMapper.writeValueAsString(fetchDeleteOptions(cascading, null)));\n    } catch (JsonProcessingException jpe) {\n      throw KubernetesClientException.launderThrowable(jpe);\n    }\n  }\n\n  /**\n   * Watch custom resources in a specific namespace. Here Watcher is provided\n   * for string type only. User has to deserialize object itself.\n   *\n   * @param namespace namespace to watch\n   * @param watcher watcher object which reports updates with object\n   * @return watch object for watching resource\n   * @throws IOException in case of network error\n   */\n  public Watch watch(String namespace, Watcher<String> watcher) throws IOException {\n    return watch(namespace, null, null, new ListOptionsBuilder().build(), watcher);\n  }\n\n  /**\n   * Watch a custom resource in a specific namespace with some resourceVersion. Here\n   * watcher is provided from string type only. User has to deserialize object itself.\n   *\n   * @param namespace namespace to watch\n   * @param resourceVersion resource version since when to watch\n   * @param watcher watcher object which reports updates\n   * @return watch object for watching resource\n   * @throws IOException in case of network error\n   */\n  public Watch watch(String namespace, String resourceVersion, Watcher<String> watcher) throws IOException {\n    return watch(namespace, null, null, new ListOptionsBuilder().withResourceVersion(resourceVersion).build(), watcher);\n  }\n\n  /**\n   * Watch a custom resource in a specific namespace with some resourceVersion. Here\n   * watcher is provided from string type only. User has to deserialize object itself.\n   *\n   * @param namespace namespace to watch\n   * @param options {@link ListOptions} list options for watching\n   * @param watcher watcher object which reports updates\n   * @return watch object for watching resource\n   * @throws IOException in case of network error\n   */\n  public Watch watch(String namespace, ListOptions options, Watcher<String> watcher) throws IOException {\n    return watch(namespace, null, null, options, watcher);\n  }\n\n  /**\n   * Watchers custom resources across all namespaces. Here watcher is provided\n   * for string type only. User has to deserialize object itself.\n   *\n   * @param watcher watcher object which reports events\n   * @return watch object for watching resource\n   * @throws IOException in case of network error\n   */\n  public Watch watch(Watcher<String> watcher) throws IOException {\n    return watch(null, null, null, new ListOptionsBuilder().build(), watcher);\n  }\n\n  /**\n   * Watch custom resources in the parameters specified.\n   *\n   * Most of the parameters except watcher are optional, they would be\n   * skipped if passed null. Here watcher is provided for string type\n   * only. User has to deserialize the object itself.\n   *\n   * @param namespace namespace to watch (optional\n   * @param name name of custom resource (optional)\n   * @param labels HashMap containing labels (optional)\n   * @param resourceVersion resource version to start watch from\n   * @param watcher watcher object which reports events\n   * @return watch object for watching resource\n   * @throws IOException in case of network error\n   */\n  public Watch watch(String namespace, String name, Map<String, String> labels, String resourceVersion, Watcher<String> watcher) throws IOException {\n    return watch(namespace, name, labels, new ListOptionsBuilder().withResourceVersion(resourceVersion).build(), watcher);\n  }\n\n  /**\n   * Watch custom resources in the parameters specified.\n   *\n   * Most of the parameters except watcher are optional, they would be\n   * skipped if passed null. Here watcher is provided for string type\n   * only. User has to deserialize the object itself.\n   *\n   * @param namespace namespace to watch (optional\n   * @param name name of custom resource (optional)\n   * @param labels HashMap containing labels (optional)\n   * @param options {@link ListOptions} list options for watch\n   * @param watcher watcher object which reports events\n   * @return watch object for watching resource\n   * @throws IOException in case of network error\n   */\n  public Watch watch(String namespace, String name, Map<String, String> labels, ListOptions options, Watcher<String> watcher) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition,\n      namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun)\n      .watch(labels, options, watcher);\n  }\n\n  /**\n   * Watch custom resources in the parameters specified.\n   *\n   * Most of the parameters except watcher are optional, they would be\n   * skipped if passed null. Here watcher is provided for string type\n   * only. User has to deserialize the object itself.\n   *\n   * @param labels HashMap containing labels (optional)\n   * @param options {@link ListOptions} list options for watch\n   * @param watcher watcher object which reports events\n   * @return watch object for watching resource\n   * @throws IOException in case of network error\n   */\n  public Watch watch(Map<String, String> labels, ListOptions options, Watcher<String> watcher) throws IOException {\n    if (options == null) {\n      options = new ListOptions();\n    }\n    options.setWatch(true);\n    HttpUrl.Builder watchUrlBuilder = fetchWatchUrl(labels, options);\n\n    OkHttpClient.Builder clonedClientBuilder = client.newBuilder();\n    clonedClientBuilder.readTimeout(getConfig() != null ?\n      getConfig().getWebsocketTimeout() : Config.DEFAULT_WEBSOCKET_TIMEOUT, TimeUnit.MILLISECONDS);\n    clonedClientBuilder.pingInterval(getConfig() != null ?\n      getConfig().getWebsocketPingInterval() : Config.DEFAULT_WEBSOCKET_PING_INTERVAL, TimeUnit.MILLISECONDS);\n\n    OkHttpClient clonedOkHttpClient = clonedClientBuilder.build();\n    WatcherToggle<String> watcherToggle = new WatcherToggle<>(watcher, true);\n    RawWatchConnectionManager watch = null;\n    try {\n      watch = new RawWatchConnectionManager(\n        clonedOkHttpClient, watchUrlBuilder, options, objectMapper, watcher,\n        getConfig() != null ? getConfig().getWatchReconnectLimit() : -1,\n        getConfig() != null ? getConfig().getWatchReconnectInterval() : 1000,\n        5);\n      watch.waitUntilReady();\n      return watch;\n    } catch (KubernetesClientException ke) {\n\n      if (ke.getCode() != 200) {\n        if(watch != null){\n          //release the watch\n          watch.close();\n        }\n\n        throw ke;\n      }\n\n      if(watch != null){\n        //release the watch after disabling the watcher (to avoid premature call to onClose)\n        watcherToggle.disable();\n        watch.close();\n      }\n\n      // If the HTTP return code is 200, we retry the watch again using a persistent hanging\n      // HTTP GET. This is meant to handle cases like kubectl local proxy which does not support\n      // websockets. Issue: https://github.com/kubernetes/kubernetes/issues/25126\n      return new RawWatchConnectionManager(\n        clonedOkHttpClient, watchUrlBuilder, options, objectMapper, watcher,\n        getConfig() != null ? getConfig().getWatchReconnectLimit() : -1,\n        getConfig() != null ? getConfig().getWatchReconnectInterval() : 1000,\n        5);\n    }\n  }\n\n  private Map<String, Object> createOrReplaceObject(Map<String, Object> objectAsMap) throws IOException {\n    Map<String, Object> metadata = (Map<String, Object>) objectAsMap.get(METADATA);\n    if (metadata == null) {\n      throw KubernetesClientException.launderThrowable(new IllegalStateException(\"Invalid object provided -- metadata is required.\"));\n    }\n\n    Map<String, Object> ret;\n\n    // can't include resourceVersion in create calls\n    String originalResourceVersion = (String) metadata.get(RESOURCE_VERSION);\n    metadata.remove(RESOURCE_VERSION);\n\n    try {\n      if(this.namespace != null) {\n        ret = create(this.namespace, objectAsMap);\n      } else {\n        ret = create(objectAsMap);\n      }\n    } catch (KubernetesClientException exception) {\n      if (exception.getCode() != HttpURLConnection.HTTP_CONFLICT) {\n        throw exception;\n      }\n\n      try {\n        String nameFromObject = (String) metadata.get(\"name\");\n        // re-add for edit call\n        if (originalResourceVersion != null) {\n          metadata.put(RESOURCE_VERSION, originalResourceVersion);\n        } else {\n          // we get resourceVersion from existing object\n          // possible race condition if object has been deleted since the HTTP_CONFLICT exception?\n          Map<String, Object> currentObjectAsMap = this.namespace != null ?\n            get(namespace, nameFromObject) : get(nameFromObject);\n          Map<String, Object> currentMetadata = (Map<String, Object>) currentObjectAsMap.get(METADATA);\n          metadata.put(RESOURCE_VERSION, currentMetadata.get(RESOURCE_VERSION));\n        }\n        ret = this.namespace != null ?\n          replace(this.namespace, nameFromObject, objectAsMap) : replace(nameFromObject, objectAsMap);\n      } catch (NullPointerException nullPointerException) {\n        throw KubernetesClientException.launderThrowable(new IllegalStateException(\"Invalid object provided -- metadata.name is required.\"));\n      }\n    }\n    return ret;\n  }\n\n  /**\n   * Converts yaml/json object as string to a HashMap.\n   * This method checks whether\n   *\n   * @param objectAsString JSON or Yaml object as plain string\n   * @return object being deserialized to a HashMap\n   * @throws IOException in case of any parsing error\n   */\n  private Map<String, Object> convertJsonOrYamlStringToMap(String objectAsString) throws IOException {\n    HashMap<String, Object> retVal = null;\n    if (IOHelpers.isJSONValid(objectAsString)) {\n      retVal =  objectMapper.readValue(objectAsString, HashMap.class);\n    } else {\n      retVal = objectMapper.readValue(IOHelpers.convertYamlToJson(objectAsString), HashMap.class);\n    }\n    return retVal;\n  }\n\n  protected HttpUrl.Builder fetchWatchUrl(Map<String, String> labels, ListOptions options) throws MalformedURLException {\n    String configuredName = this.name;\n    // Get Url without resource name configured\n    this.name = null;\n    String resourceUrl = fetchUrl(labels);\n    if (resourceUrl.endsWith(\"/\")) {\n      resourceUrl = resourceUrl.substring(0, resourceUrl.length() - 1);\n    }\n    URL url = new URL(resourceUrl);\n    HttpUrl.Builder httpUrlBuilder = HttpUrl.get(url).newBuilder();\n\n    if (configuredName != null) {\n      httpUrlBuilder.addQueryParameter(\"fieldSelector\", \"metadata.name=\" + configuredName);\n    }\n\n    HttpClientUtils.appendListOptionParams(httpUrlBuilder, options);\n    return httpUrlBuilder;\n  }\n\n  private String fetchUrl(Map<String, String> labels) {\n    if (config.getMasterUrl() == null) {\n      return null;\n    }\n\n    HttpUrl.Builder urlBuilder = HttpUrl.get(getNamespacedUrl(namespace, name)).newBuilder();\n    if (labels != null) {\n      urlBuilder.addQueryParameter(\"labelSelector\", getLabelsQueryParam(labels));\n    }\n    if (listOptions != null) {\n      urlBuilder = HttpClientUtils.appendListOptionParams(urlBuilder, listOptions);\n    }\n    if (dryRun) {\n      urlBuilder.addQueryParameter(\"dryRun\", \"All\");\n    }\n    return urlBuilder.toString();\n  }\n\n  private String getNamespacedUrl(String namespace, String name) {\n    StringBuilder urlBuilder = new StringBuilder(config.getMasterUrl());\n\n    urlBuilder.append(config.getMasterUrl().endsWith(\"/\") ? \"\" : \"/\");\n\n    if (Utils.isNotNullOrEmpty(customResourceDefinition.getGroup())) {\n      urlBuilder.append(\"apis/\");\n      urlBuilder.append(customResourceDefinition.getGroup())\n        .append(\"/\");\n    } else {\n      urlBuilder.append(\"api/\");\n    }\n    urlBuilder.append(customResourceDefinition.getVersion())\n      .append(\"/\");\n\n    if(customResourceDefinition.getScope().equals(\"Namespaced\") && namespace != null) {\n      urlBuilder.append(\"namespaces/\").append(namespace).append(\"/\");\n    }\n    urlBuilder.append(customResourceDefinition.getPlural());\n    if (name != null) {\n      urlBuilder.append(\"/\").append(name);\n    }\n    return urlBuilder.toString();\n  }\n\n  private String getLabelsQueryParam(Map<String, String> labels) {\n    StringBuilder labelQueryBuilder = new StringBuilder();\n    for(Map.Entry<String, String> entry : labels.entrySet()) {\n      if(labelQueryBuilder.length() > 0) {\n        labelQueryBuilder.append(\",\");\n      }\n      labelQueryBuilder.append(entry.getKey()).append(\"=\").append(entry.getValue());\n    }\n    return labelQueryBuilder.toString();\n  }\n\n  private Map<String, Object> makeCall(String url, String body, HttpCallMethod callMethod) {\n    return makeCall(url, body, callMethod, true);\n  }\n\n  private Map<String, Object> makeCall(String url, String body, HttpCallMethod callMethod, boolean shouldRequestFailure) {\n    Request request = (body == null) ? getRequest(url, callMethod) : getRequest(url, body, callMethod);\n    try (Response response = client.newCall(request).execute()) {\n      if (response.isSuccessful()) {\n        String respBody = response.body().string();\n        if(Utils.isNullOrEmpty(respBody))\n          return new HashMap<>();\n        else\n          return objectMapper.readValue(respBody, HashMap.class);\n      } else {\n        return handleFailure(request, response, shouldRequestFailure);\n      }\n    } catch(Exception e) {\n      throw KubernetesClientException.launderThrowable(e);\n    }\n  }\n\n  private Map<String, Object> handleFailure(Request request, Response response, boolean shouldRequestFailure) throws IOException {\n    if (shouldRequestFailure) {\n      throw requestFailure(request, createStatus(response));\n    }\n    return objectMapper.readValue(response.body().string(), HashMap.class);\n  }\n\n  private boolean handleDelete(String requestBody) {\n    Map<String, Object> response = makeCall(fetchUrl(null), requestBody, HttpCallMethod.DELETE, false);\n\n    // In most cases Status object is sent on deletion, but when deprecated DeleteOptions.orphanDependents\n    // is used; object which is being deleted is sent\n    if (!response.isEmpty() && response.get(\"kind\").toString().equals(\"Status\")) {\n      return response.get(\"status\").toString().equals(\"Success\");\n    }\n    return true;\n  }\n\n  private Map<String, Object> validateAndSubmitRequest(String objectAsString, HttpCallMethod httpCallMethod) throws IOException {\n    return validateAndSubmitRequest(fetchUrl(null), objectAsString, httpCallMethod);\n  }\n\n  private Map<String, Object> validateAndSubmitRequest(String resourceUrl, String objectAsString, HttpCallMethod httpCallMethod) throws IOException {\n    if (IOHelpers.isJSONValid(objectAsString)) {\n      return makeCall(resourceUrl, objectAsString, httpCallMethod);\n    } else {\n      return makeCall(resourceUrl, IOHelpers.convertYamlToJson(objectAsString), httpCallMethod);\n    }\n  }\n\n  private Request getRequest(String url, HttpCallMethod httpCallMethod) {\n    Request.Builder requestBuilder = new Request.Builder();\n    switch(httpCallMethod) {\n      case GET:\n        requestBuilder.get().url(url);\n        break;\n      case DELETE:\n        requestBuilder.delete().url(url);\n        break;\n    }\n\n    return requestBuilder.build();\n  }\n\n  private Request getRequest(String url, String body, HttpCallMethod httpCallMethod) {\n    Request.Builder requestBuilder = new Request.Builder();\n    RequestBody requestBody = RequestBody.create(MediaType.parse(\"application/json\"), body);\n    switch(httpCallMethod) {\n      case DELETE:\n        return requestBuilder.delete(requestBody).url(url).build();\n      case POST:\n        return requestBuilder.post(requestBody).url(url).build();\n      case PUT:\n        return requestBuilder.put(requestBody).url(url).build();\n      case PATCH:\n        return requestBuilder.patch(RequestBody.create(JSON_PATCH, body)).url(url).build();\n    }\n    return requestBuilder.build();\n  }\n\n  private String getPatchDiff(String namespace, String customResourceName, Map<String, Object> customResource) throws IOException {\n    Map<String, Object> oldObject = get(namespace, customResourceName);\n\n    // Exclude changes to the status\n    oldObject.put(\"status\", null);\n    customResource.put(\"status\", null);\n\n    JsonNode newone = JsonDiff.asJson(PatchUtils.patchMapper().valueToTree(oldObject), PatchUtils.patchMapper().valueToTree(customResource));\n\n    return objectMapper.writeValueAsString(newone);\n  }\n\n  private DeleteOptions fetchDeleteOptions(boolean cascading, String propagationPolicy) {\n    DeleteOptionsBuilder deleteOptionsBuilder = new DeleteOptionsBuilder();\n    String resolvedPropagationPolicy = resolvePropagationPolicy(propagationPolicy);\n    if (resolvedPropagationPolicy != null) {\n      deleteOptionsBuilder.withPropagationPolicy(resolvedPropagationPolicy);\n    } else {\n      deleteOptionsBuilder.withOrphanDependents(!cascading);\n    }\n    if (this.gracePeriodInSeconds > 0) {\n      deleteOptionsBuilder.withGracePeriodSeconds(this.gracePeriodInSeconds);\n    }\n    if (this.dryRun) {\n      deleteOptionsBuilder.withDryRun(Collections.singletonList(\"All\"));\n    }\n    return deleteOptionsBuilder.build();\n  }\n\n  private String resolvePropagationPolicy(String propagationPolicyProvided) {\n    if (propagationPolicyProvided != null) {\n      return propagationPolicyProvided;\n    } else if (this.deletionPropagation != null) {\n      return this.deletionPropagation;\n    }\n    return null;\n  }\n\n  private boolean pickNamespaceOrNameBasedOnScopeAndDelete(String namespaceOrName, String deleteOptionsAsString) {\n    String operationNamespace = null;\n    String operationName = null;\n    if (customResourceDefinition.getScope().equals(\"Namespaced\")) {\n      operationNamespace = namespaceOrName;\n    } else {\n      operationName = namespaceOrName;\n    }\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, operationNamespace, operationName, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun)\n      .handleDelete(deleteOptionsAsString);\n  }\n}", "item_id": 0, "repo": "ryantse/kubernetes-client", "file": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/dsl/internal/RawCustomResourceOperationsImpl.java", "last_update_at": "2022-01-04T07:41:02+00:00", "question_id": "3bc70e63acbe1c19bb491b824e4d6d5ab3c3b8f7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RawCustomResourceOperationsImpl extends OperationSupport implements Nameable<RawCustomResourceOperationsImpl>,\n  Namespaceable<RawCustomResourceOperationsImpl>,\n  AnyNamespaceable<RawCustomResourceOperationsImpl>,\n  Listable<Map<String, Object>>,\n  Gettable<Map<String, Object>>,\n  GracePeriodConfigurable<RawCustomResourceOperationsImpl>,\n  PropagationPolicyConfigurable<RawCustomResourceOperationsImpl>,\n  DryRunable<RawCustomResourceOperationsImpl>,\n  Deletable {\n  private static final String METADATA = \"metadata\";\n  private static final String RESOURCE_VERSION = \"resourceVersion\";\n  private static final String STATUS_SUBRESOURCE_ENDPOINT = \"/status\";\n  private final CustomResourceDefinitionContext customResourceDefinition;\n  private final ObjectMapper objectMapper;\n  private final ListOptions listOptions;\n  private final long gracePeriodInSeconds;\n  private final String deletionPropagation;\n  private final boolean cascading;\n  private enum HttpCallMethod { GET, POST, PUT, PATCH, DELETE }\n  private RawCustomResourceOperationsImpl(OkHttpClient client, Config config, CustomResourceDefinitionContext crdContext, String namespace, String name, long gracePeriodInSeconds, boolean cascading, String deletionPropagation, ListOptions listOptions, boolean dryRun) {\n    super(client, config);\n    this.customResourceDefinition = crdContext;\n    this.objectMapper = PatchUtils.patchMapper();\n    this.namespace = namespace;\n    this.name = name;\n    this.gracePeriodInSeconds = gracePeriodInSeconds;\n    this.cascading = cascading;\n    this.deletionPropagation = deletionPropagation;\n    this.listOptions = listOptions;\n    this.dryRun = dryRun;\n  }\n  public RawCustomResourceOperationsImpl(OkHttpClient client, Config config, CustomResourceDefinitionContext customResourceDefinition) {\n    this(client, config, customResourceDefinition, null, null, 0, false, DeletionPropagation.BACKGROUND.toString(), null, false);\n  }\n  @Override\n  public RawCustomResourceOperationsImpl withName(String name) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun);\n  }\n  @Override\n  public RawCustomResourceOperationsImpl inNamespace(String namespace) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun);\n  }\n  @Override\n  public RawCustomResourceOperationsImpl inAnyNamespace() {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun);\n  }\n  @Override\n  public RawCustomResourceOperationsImpl withGracePeriod(long gracePeriodSeconds) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodSeconds, cascading, deletionPropagation, listOptions, dryRun);\n  }\n  @Override\n  public RawCustomResourceOperationsImpl withPropagationPolicy(DeletionPropagation propagationPolicy) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, propagationPolicy.toString(), listOptions, dryRun);\n  }\n  @Override\n  public RawCustomResourceOperationsImpl dryRun(boolean isDryRun) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, isDryRun);\n  }\n  /**\n   * Load a custom resource object from an inputstream into a HashMap\n   *\n   * @param fileInputStream file input stream\n   * @return custom resource as HashMap\n   * @throws IOException exception in case any read operation fails.\n   */\n  public Map<String, Object> load(InputStream fileInputStream) throws IOException {\n    return convertJsonOrYamlStringToMap(IOHelpers.readFully(fileInputStream));\n  }\n  /**\n   * Load a custom resource object from a JSON string into a HashMap\n   *\n   * @param objectAsJsonString object as JSON string\n   * @return custom resource as HashMap\n   * @throws IOException exception in case any problem in reading json.\n   */\n  public Map<String, Object> load(String objectAsJsonString) throws IOException {\n    return convertJsonOrYamlStringToMap(objectAsJsonString);\n  }\n  /**\n   * Create a custom resource which is a non-namespaced object.\n   *\n   * @param objectAsString object as JSON string\n   * @return Object as HashMap\n   * @throws IOException exception in case of any network/read problems\n   */\n  public Map<String, Object> create(String objectAsString) throws IOException {\n    return validateAndSubmitRequest(objectAsString, HttpCallMethod.POST);\n  }\n  /**\n   * Create a custom resource which is non-namespaced.\n   *\n   * @param object object a HashMap\n   * @return Object as HashMap\n   * @throws IOException in case of problems while reading HashMap\n   */\n  public Map<String, Object> create(Map<String, Object> object) throws IOException {\n    return validateAndSubmitRequest(objectMapper.writeValueAsString(object), HttpCallMethod.POST);\n  }\n  /**\n   * Create a custom resource which is a namespaced object.\n   *\n   * @param namespace namespace in which we want object to be created.\n   * @param objectAsString Object as JSON string\n   * @return Object as HashMap\n   * @throws IOException in case of problems while reading JSON object\n   */\n  public Map<String, Object> create(String namespace, String objectAsString) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).create(objectAsString);\n  }\n  /**\n   * Create a custom resource which is non-namespaced object.\n   *\n   * @param objectAsStream object as a file input stream\n   * @return Object as HashMap\n   * @throws IOException in case of problems while reading file\n   */\n  public Map<String, Object> create(InputStream objectAsStream) throws IOException {\n    return validateAndSubmitRequest(IOHelpers.readFully(objectAsStream), HttpCallMethod.POST);\n  }\n  /**\n   * Create a custom resource which is a namespaced object.\n   *\n   * @param namespace namespace in which we want object to be created\n   * @param objectAsStream object as file input stream\n   * @return Object as HashMap\n   * @throws IOException in case of problems while reading file\n   */\n  public Map<String, Object> create(String namespace, InputStream objectAsStream) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).create(objectAsStream);\n  }\n  /**\n   * Create a custom resource which is a namespaced object.\n   *\n   * @param namespace namespace in which we want object to be created.\n   * @param object object as a HashMap\n   * @return Object as HashMap\n   * @throws IOException in case of problems faced while serializing HashMap\n   */\n  public Map<String, Object> create(String namespace, Map<String, Object> object) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).create(object);\n  }\n  /**\n   *\n   * Create or replace a custom resource which is a non-namespaced object.\n   *\n   * @param objectAsString object as JSON string\n   * @return Object as HashMap\n   * @throws IOException in case of network/serializiation failures or failures from Kuberntes API\n   */\n  public Map<String, Object> createOrReplace(String objectAsString) throws IOException {\n    return createOrReplaceObject(load(objectAsString));\n  }\n  /**\n   * Create or replace a custom resource which is a non-namespced object.\n   *\n   * @param customResourceObject object as HashMap\n   * @return Object as HashMap\n   * @throws IOException in case of network/serialization failures or failures from Kubernetes API\n   */\n  public Map<String, Object> createOrReplace(Map<String, Object> customResourceObject) throws IOException {\n    return createOrReplaceObject(customResourceObject);\n  }\n  /**\n   * Create or replace a custom resource which is non-namespaced object.\n   *\n   * @param inputStream object as file input stream\n   * @return Object as HashMap\n   * @throws IOException in case of network/serialization failures or failures from Kubernetes API\n   */\n  public Map<String, Object> createOrReplace(InputStream inputStream) throws IOException {\n    return createOrReplaceObject(load(inputStream));\n  }\n  /**\n   * Create or replace a custom resource which is namespaced object.\n   *\n   * @param namespace desired namespace\n   * @param objectAsString object as JSON String\n   * @return Object as HashMap\n   * @throws IOException in case of network/serialization failures or failures from Kubernetes API\n   */\n  public Map<String, Object> createOrReplace(String namespace, String objectAsString) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).createOrReplace(objectAsString);\n  }\n  /**\n   * Create or replace a custom resource which is namespaced object.\n   *\n   * @param namespace desired namespace\n   * @param customResourceObject object as HashMap\n   * @return Object as HashMap\n   * @throws IOException in case of network/serialization failures or failures from Kubernetes API\n   */\n  public Map<String, Object> createOrReplace(String namespace, Map<String, Object> customResourceObject) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).createOrReplace(customResourceObject);\n  }\n  /**\n   * Create or replace a custom resource which is namespaced object.\n   *\n   * @param namespace desired namespace\n   * @param objectAsStream object as file input stream\n   * @return Object as HashMap\n   * @throws IOException in case of network/serialization failures or failures from Kubernetes API\n   */\n  public Map<String, Object> createOrReplace(String namespace, InputStream objectAsStream) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).createOrReplace(objectAsStream);\n  }\n  private Map<String, Object> replace(String namespace, String name, Map<String, Object> object) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).replace(object);\n  }\n  private Map<String, Object> replace(String name, Map<String, Object> object) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).replace(object);\n  }\n  private Map<String, Object> replace(Map<String, Object> object) throws IOException {\n    return validateAndSubmitRequest(objectMapper.writeValueAsString(object), HttpCallMethod.PUT);\n  }\n  /**\n   * Edit a custom resource object which is a non-namespaced object.\n   *\n   * @param name name of the custom resource\n   * @param object new object as a HashMap\n   * @return Object as HashMap\n   * @throws IOException in case of network/serialization failures or failures from Kubernetes API\n   */\n  public Map<String, Object> edit(String name, Map<String, Object> object) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).edit(object);\n  }\n  /**\n   * Edit a custom resource object which is a non-namespaced object.\n   *\n   * @param name name of the custom resource\n   * @param objectAsString new object as a JSON String\n   * @return Object as HashMap\n   * @throws IOException in case of network/serialization failures or failures from Kubernetes API\n   */\n  public Map<String, Object> edit(String name, String objectAsString) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).edit(objectAsString);\n  }\n  /**\n   * Edit a custom resource object which is a namespaced object.\n   *\n   * @param namespace desired namespace\n   * @param name name of the custom resource\n   * @param object new object as a HashMap\n   * @return Object as HashMap\n   * @throws IOException in case of network/serialization failures or failures from Kubernetes API\n   */\n  public Map<String, Object> edit(String namespace, String name, Map<String, Object> object) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).edit(object);\n  }\n  /**\n   * Edit a custom resource object which is a namespaced object.\n   *\n   * @param namespace desired namespace\n   * @param name name of the custom resource\n   * @param objectAsString new object as a JSON string\n   * @return Object as HashMap\n   * @throws IOException in case of network/serialization failures or failures from Kubernetes API\n   */\n  public Map<String, Object> edit(String namespace, String name, String objectAsString) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).edit(objectAsString);\n  }\n  /**\n   * Edit a custom resource object.\n   *\n   * @param objectAsString new object as JSON string\n   * @return Object as HashMap\n   * @throws IOException in case of network/serializatino failures or failures from Kubernetes API\n   */\n  public Map<String, Object> edit(String objectAsString) throws IOException {\n    Map<String, Object> object = convertJsonOrYamlStringToMap(objectAsString);\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).edit(object);\n  }\n  /**\n   * Edit a custom resource object.\n   *\n   * @param object new object as Map\n   * @return Object as HashMap\n   * @throws IOException in case of network/serializatino failures or failures from Kubernetes API\n   */\n  public Map<String, Object> edit(Map<String, Object> object) throws IOException {\n    String objectAsString = getPatchDiff(namespace, name, object);\n    return validateAndSubmitRequest(objectAsString, HttpCallMethod.PATCH);\n  }\n  /**\n   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related\n   * to the CustomResource\n   *\n   * @param name name of custom resource\n   * @param objectAsMap custom resource as a HashMap\n   * @return updated CustomResource as HashMap\n   * @throws IOException in case any failure to parse Map\n   */\n  public Map<String, Object> updateStatus(String name, Map<String, Object> objectAsMap) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).updateStatus(objectAsMap);\n  }\n  /**\n   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related\n   * to the CustomResource\n   *\n   * @param name name of CustomResource\n   * @param objectAsJsonString CustomResource as a JSON string\n   * @return updated CustomResource as a HashMap\n   * @throws IOException in case any failure to parse Map\n   */\n  public Map<String, Object> updateStatus(String name, String objectAsJsonString) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).updateStatus(objectAsJsonString);\n  }\n  /**\n   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related\n   * to the CustomResource\n   *\n   * @param namespace namespace of CustomResource\n   * @param name name of CustomResource\n   * @param objectAsMap CustomResource as a HashMap\n   * @return updated CustomResource as a HashMap\n   * @throws IOException in case any failure to parse Map\n   */\n  public Map<String, Object> updateStatus(String namespace, String name, Map<String, Object> objectAsMap) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).updateStatus(objectAsMap);\n  }\n  /**\n   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related\n   * to the CustomResource\n   *\n   * @param name name of CustomResource\n   * @param objectAsStream stream pointing to CustomResource\n   * @return updated CustomResource as a HashMap\n   * @throws IOException in case any failure to parse Map\n   */\n  public Map<String, Object> updateStatus(String name, InputStream objectAsStream) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).updateStatus(objectAsStream);\n  }\n  /**\n   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related\n   * to the CustomResource\n   *\n   * @param namespace namespace of CustomResource\n   * @param name name of CustomResource\n   * @param objectAsStream CustomResource object as a stream\n   * @return updated CustomResource as a HashMap\n   * @throws IOException in case any failure to parse Map\n   */\n  public Map<String, Object> updateStatus(String namespace, String name, InputStream objectAsStream) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).updateStatus(objectAsStream);\n  }\n  /**\n   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related\n   * to the CustomResource\n   *\n   * @param namespace namespace of CustomResource\n   * @param name name of CustomResource\n   * @param objectAsJsonString CustomResource object as a JSON string\n   * @return updated CustomResource as a HashMap\n   * @throws IOException in case any failure to parse Map\n   */\n  public Map<String, Object> updateStatus(String namespace, String name, String objectAsJsonString) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).updateStatus(objectAsJsonString);\n  }\n  /**\n   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related\n   * to the CustomResource\n   *\n   * @param objectAsJsonString CustomResource object as a JSON string\n   * @return updated CustomResource as HashMap\n   * @throws IOException in case any failures to parse provided object or failure from Kubernetes API\n   */\n  public Map<String, Object> updateStatus(String objectAsJsonString) throws IOException {\n    return validateAndSubmitRequest(fetchUrl(null) + STATUS_SUBRESOURCE_ENDPOINT, objectAsJsonString, HttpCallMethod.PUT);\n  }\n  /**\n   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related\n   * to the CustomResource\n   *\n   * @param objectAsMap CustomResource object as a HashMap\n   * @return updated CustomResource as HashMap\n   * @throws IOException in case any failures to parse provided object or failure from Kubernetes API\n   */\n  public Map<String, Object> updateStatus(Map<String, Object> objectAsMap) throws IOException {\n    return validateAndSubmitRequest(fetchUrl(null) + STATUS_SUBRESOURCE_ENDPOINT, objectMapper.writeValueAsString(objectAsMap), HttpCallMethod.PUT);\n  }\n  /**\n   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related\n   * to the CustomResource\n   *\n   * @param objectAsInputStream CustomResource object as a InputStream\n   * @return updated CustomResource as HashMap\n   * @throws IOException in case any failures to parse provided object or failure from Kubernetes API\n   */\n  public Map<String, Object> updateStatus(InputStream objectAsInputStream) throws IOException {\n    return validateAndSubmitRequest(fetchUrl(null) + STATUS_SUBRESOURCE_ENDPOINT, IOHelpers.readFully(objectAsInputStream), HttpCallMethod.PUT);\n  }\n  @Override\n  public Map<String, Object> get() {\n    return makeCall(fetchUrl(null), null, HttpCallMethod.GET);\n  }\n  /**\n   * Get a custom resource from the cluster which is non-namespaced.\n   *\n   * @param name name of custom resource\n   * @return Object as HashMap\n   */\n  public Map<String, Object> get(String name) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).get();\n  }\n  /**\n   * Get a custom resource from the cluster which is namespaced.\n   *\n   * @param namespace desired namespace\n   * @param name name of custom resource\n   * @return Object as HashMap\n   */\n  public Map<String, Object> get(String namespace, String name) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).get();\n  }\n  /**\n   * List all custom resources in all namespaces\n   *\n   * @return list of custom resources as HashMap\n   */\n  public Map<String, Object> list() {\n    return makeCall(fetchUrl(null), null, HttpCallMethod.GET);\n  }\n  @Override\n  public Map<String, Object> list(Integer limitVal, String continueVal) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, new ListOptionsBuilder()\n      .withLimit(limitVal.longValue())\n      .withContinue(continueVal)\n      .build(), dryRun).list();\n  }\n  @Override\n  public Map<String, Object> list(ListOptions listOptions) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).list();\n  }\n  /**\n   * List all custom resources in a specific namespace\n   *\n   * @param namespace desired namespace\n   * @return list of custom resources as HashMap\n   */\n  public Map<String, Object> list(String namespace) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).list();\n  }\n  /**\n   * List all custom resources in a specific namespace with some labels\n   *\n   * @param namespace desired namespace\n   * @param labels labels as a HashMap\n   * @return list of custom resources as HashMap\n   */\n  public Map<String, Object> list(String namespace, Map<String, String> labels) {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null,\n      gracePeriodInSeconds, cascading, deletionPropagation, new ListOptionsBuilder().withLabelSelector(getLabelsQueryParam(labels)).build(), dryRun).list();\n  }\n  /**\n   * Delete all Namespaced Scoped Custom Resources in a specified namespace\n   * <b>OR</b>\n   * Delete a Cluster Scoped Custom Resource with specified name\n   *\n   * <p>\n   * Note: This method behaves differently based on the scope of CRD:\n   *\n   * If specified CRD is of Namespaced scope, this method would delete all Custom Resources in namespace which is\n   * specified as parameter.\n   * If specified CRD is of Cluster scope, this method would delete a Custom Resource matching the name which is\n   * specified as parameter\n   * </p>\n   *\n   * @param namespaceOrName desired namespace(if CRD is Namespaced) or name(If CRD is Cluster)\n   * @return deleted objects as HashMap\n   */\n  public boolean delete(String namespaceOrName) {\n    return pickNamespaceOrNameBasedOnScopeAndDelete(namespaceOrName, null);\n  }\n  /**\n   * Delete all Namespaced Scoped Custom Resources in a specified namespace\n   * <b>OR</b>\n   * Delete a Cluster Scoped Custom Resource with specified name\n   *\n   * <p>\n   * Note: This method behaves differently based on the scope of CRD:\n   *\n   * If specified CRD is of Namespaced scope, this method would delete all Custom Resources in namespace which is\n   * specified as parameter.\n   * If specified CRD is of Cluster scope, this method would delete a Custom Resource matching the name which is\n   * specified as parameter\n   * </p>\n   *\n   * @param namespaceOrName desired namespace(If CRD is Namespaced) or name(If CRD is Cluster)\n   * @param cascading whether dependent object need to be orphaned or not.  If true/false, the \"orphan\"\n   *                   finalizer will be added to/removed from the object's finalizers list.\n   * @return a boolean value whether item was deleted or item didn't exist in server\n   * @throws IOException in case of any network/parsing exception\n   */\n  public boolean delete(String namespaceOrName, boolean cascading) throws IOException {\n    return pickNamespaceOrNameBasedOnScopeAndDelete(namespaceOrName, objectMapper.writeValueAsString(fetchDeleteOptions(cascading, null)));\n  }\n  /**\n   * Delete all Namespaced Scoped Custom Resources in a specified namespace\n   * <b>OR</b>\n   * Delete a Cluster Scoped Custom Resource with specified name\n   *\n   * <p>\n   * Note: This method behaves differently based on the scope of CRD:\n   *\n   * If specified CRD is of Namespaced scope, this method would delete all Custom Resources in namespace which is\n   * specified as parameter.\n   * If specified CRD is of Cluster scope, this method would delete a Custom Resource matching the name which is\n   * specified as parameter\n   * </p>\n   *\n   * @param namespaceOrName desired namespace(If CRD is Namespaced) or name(If CRD is Cluster)\n   * @param deleteOptions object provided by Kubernetes API for more fine grained control over deletion.\n   *                       For more information please see https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#deleteoptions-v1-meta\n   * @return a boolean value whether item was deleted or item didn't exist in server\n   * @throws IOException in case of any network/object parse problems\n   */\n  public boolean delete(String namespaceOrName, DeleteOptions deleteOptions) throws IOException {\n    return pickNamespaceOrNameBasedOnScopeAndDelete(namespaceOrName, objectMapper.writeValueAsString(deleteOptions));\n  }\n  /**\n   * Delete a custom resource in a specific namespace\n   *\n   * @param namespace desired namespace\n   * @param name custom resource's name\n   * @return a boolean value whether item was deleted or item didn't exist in server\n   * @throws IOException in case of any network/object parse problems\n   */\n  public boolean delete(String namespace, String name) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).delete();\n  }\n  /**\n   * Delete a custom resource in a specific namespace\n   *\n   * @param namespace required namespace\n   * @param name required name of custom resource\n   * @param cascading whether dependent object need to be orphaned or not.  If true/false, the \"orphan\"\n   *                   finalizer will be added to/removed from the object's finalizers list.\n   * @return a boolean value whether item was deleted or item didn't exist in server\n   * @throws IOException exception related to network/object parsing\n   */\n  public boolean delete(String namespace, String name, boolean cascading) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, null, listOptions, dryRun).delete();\n  }\n  /**\n   * Delete a custom resource in a specific namespace\n   *\n   * @param namespace required namespace\n   * @param name required name of custom resource\n   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents\n   *                            may be set, but not both. The default policy is decided by the existing finalizer set in\n   *                            the metadata.finalizers and the resource-specific default policy.\n   *                            Acceptable values are:\n   *                            'Orphan' - orphan the dependents;\n   *                            'Background' - allow the garbage collector to delete the dependents in the background;\n   *                            'Foreground' - a cascading policy that deletes all dependents in the foreground.\n   * @return a boolean value whether item was deleted or item didn't exist in server\n   * @throws IOException in case of network/object parse exception\n   */\n  public boolean delete(String namespace, String name, String propagationPolicy) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, propagationPolicy, listOptions, dryRun).delete();\n  }\n  /**\n   * Delete a custom resource in a specific namespace\n   *\n   * @param namespace required namespace\n   * @param name name of custom resource\n   * @param deleteOptions object provided by Kubernetes API for more fine grained control over deletion.\n   *                       For more information please see https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#deleteoptions-v1-meta\n   * @return a boolean value whether item was deleted or item didn't exist in server\n   * @throws IOException in case of any network/object parse exception\n   */\n  public boolean delete(String namespace, String name, DeleteOptions deleteOptions) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name,\n      gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).handleDelete(objectMapper.writeValueAsString(deleteOptions));\n  }\n  @Override\n  public Boolean delete() {\n    try {\n      return handleDelete(objectMapper.writeValueAsString(fetchDeleteOptions(cascading, null)));\n    } catch (JsonProcessingException jpe) {\n      throw KubernetesClientException.launderThrowable(jpe);\n    }\n  }\n  /**\n   * Watch custom resources in a specific namespace. Here Watcher is provided\n   * for string type only. User has to deserialize object itself.\n   *\n   * @param namespace namespace to watch\n   * @param watcher watcher object which reports updates with object\n   * @return watch object for watching resource\n   * @throws IOException in case of network error\n   */\n  public Watch watch(String namespace, Watcher<String> watcher) throws IOException {\n    return watch(namespace, null, null, new ListOptionsBuilder().build(), watcher);\n  }\n  /**\n   * Watch a custom resource in a specific namespace with some resourceVersion. Here\n   * watcher is provided from string type only. User has to deserialize object itself.\n   *\n   * @param namespace namespace to watch\n   * @param resourceVersion resource version since when to watch\n   * @param watcher watcher object which reports updates\n   * @return watch object for watching resource\n   * @throws IOException in case of network error\n   */\n  public Watch watch(String namespace, String resourceVersion, Watcher<String> watcher) throws IOException {\n    return watch(namespace, null, null, new ListOptionsBuilder().withResourceVersion(resourceVersion).build(), watcher);\n  }\n  /**\n   * Watch a custom resource in a specific namespace with some resourceVersion. Here\n   * watcher is provided from string type only. User has to deserialize object itself.\n   *\n   * @param namespace namespace to watch\n   * @param options {@link ListOptions} list options for watching\n   * @param watcher watcher object which reports updates\n   * @return watch object for watching resource\n   * @throws IOException in case of network error\n   */\n  public Watch watch(String namespace, ListOptions options, Watcher<String> watcher) throws IOException {\n    return watch(namespace, null, null, options, watcher);\n  }\n  /**\n   * Watchers custom resources across all namespaces. Here watcher is provided\n   * for string type only. User has to deserialize object itself.\n   *\n   * @param watcher watcher object which reports events\n   * @return watch object for watching resource\n   * @throws IOException in case of network error\n   */\n  public Watch watch(Watcher<String> watcher) throws IOException {\n    return watch(null, null, null, new ListOptionsBuilder().build(), watcher);\n  }\n  /**\n   * Watch custom resources in the parameters specified.\n   *\n   * Most of the parameters except watcher are optional, they would be\n   * skipped if passed null. Here watcher is provided for string type\n   * only. User has to deserialize the object itself.\n   *\n   * @param namespace namespace to watch (optional\n   * @param name name of custom resource (optional)\n   * @param labels HashMap containing labels (optional)\n   * @param resourceVersion resource version to start watch from\n   * @param watcher watcher object which reports events\n   * @return watch object for watching resource\n   * @throws IOException in case of network error\n   */\n  public Watch watch(String namespace, String name, Map<String, String> labels, String resourceVersion, Watcher<String> watcher) throws IOException {\n    return watch(namespace, name, labels, new ListOptionsBuilder().withResourceVersion(resourceVersion).build(), watcher);\n  }\n  /**\n   * Watch custom resources in the parameters specified.\n   *\n   * Most of the parameters except watcher are optional, they would be\n   * skipped if passed null. Here watcher is provided for string type\n   * only. User has to deserialize the object itself.\n   *\n   * @param namespace namespace to watch (optional\n   * @param name name of custom resource (optional)\n   * @param labels HashMap containing labels (optional)\n   * @param options {@link ListOptions} list options for watch\n   * @param watcher watcher object which reports events\n   * @return watch object for watching resource\n   * @throws IOException in case of network error\n   */\n  public Watch watch(String namespace, String name, Map<String, String> labels, ListOptions options, Watcher<String> watcher) throws IOException {\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition,\n      namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun)\n      .watch(labels, options, watcher);\n  }\n  /**\n   * Watch custom resources in the parameters specified.\n   *\n   * Most of the parameters except watcher are optional, they would be\n   * skipped if passed null. Here watcher is provided for string type\n   * only. User has to deserialize the object itself.\n   *\n   * @param labels HashMap containing labels (optional)\n   * @param options {@link ListOptions} list options for watch\n   * @param watcher watcher object which reports events\n   * @return watch object for watching resource\n   * @throws IOException in case of network error\n   */\n  public Watch watch(Map<String, String> labels, ListOptions options, Watcher<String> watcher) throws IOException {\n    if (options == null) {\n      options = new ListOptions();\n    }\n    options.setWatch(true);\n    HttpUrl.Builder watchUrlBuilder = fetchWatchUrl(labels, options);\n    OkHttpClient.Builder clonedClientBuilder = client.newBuilder();\n    clonedClientBuilder.readTimeout(getConfig() != null ?\n      getConfig().getWebsocketTimeout() : Config.DEFAULT_WEBSOCKET_TIMEOUT, TimeUnit.MILLISECONDS);\n    clonedClientBuilder.pingInterval(getConfig() != null ?\n      getConfig().getWebsocketPingInterval() : Config.DEFAULT_WEBSOCKET_PING_INTERVAL, TimeUnit.MILLISECONDS);\n    OkHttpClient clonedOkHttpClient = clonedClientBuilder.build();\n    WatcherToggle<String> watcherToggle = new WatcherToggle<>(watcher, true);\n    RawWatchConnectionManager watch = null;\n    try {\n      watch = new RawWatchConnectionManager(\n        clonedOkHttpClient, watchUrlBuilder, options, objectMapper, watcher,\n        getConfig() != null ? getConfig().getWatchReconnectLimit() : -1,\n        getConfig() != null ? getConfig().getWatchReconnectInterval() : 1000,\n        5);\n      watch.waitUntilReady();\n      return watch;\n    } catch (KubernetesClientException ke) {\n      if (ke.getCode() != 200) {\n        if(watch != null){\n          //release the watch\n          watch.close();\n        }\n        throw ke;\n      }\n      if(watch != null){\n        //release the watch after disabling the watcher (to avoid premature call to onClose)\n        watcherToggle.disable();\n        watch.close();\n      }\n      // If the HTTP return code is 200, we retry the watch again using a persistent hanging\n      // HTTP GET. This is meant to handle cases like kubectl local proxy which does not support\n      // websockets. Issue: https://github.com/kubernetes/kubernetes/issues/25126\n      return new RawWatchConnectionManager(\n        clonedOkHttpClient, watchUrlBuilder, options, objectMapper, watcher,\n        getConfig() != null ? getConfig().getWatchReconnectLimit() : -1,\n        getConfig() != null ? getConfig().getWatchReconnectInterval() : 1000,\n        5);\n    }\n  }\n  private Map<String, Object> createOrReplaceObject(Map<String, Object> objectAsMap) throws IOException {\n    Map<String, Object> metadata = (Map<String, Object>) objectAsMap.get(METADATA);\n    if (metadata == null) {\n      throw KubernetesClientException.launderThrowable(new IllegalStateException(\"Invalid object provided -- metadata is required.\"));\n    }\n    Map<String, Object> ret;\n    // can't include resourceVersion in create calls\n    String originalResourceVersion = (String) metadata.get(RESOURCE_VERSION);\n    metadata.remove(RESOURCE_VERSION);\n    try {\n      if(this.namespace != null) {\n        ret = create(this.namespace, objectAsMap);\n      } else {\n        ret = create(objectAsMap);\n      }\n    } catch (KubernetesClientException exception) {\n      if (exception.getCode() != HttpURLConnection.HTTP_CONFLICT) {\n        throw exception;\n      }\n      try {\n        String nameFromObject = (String) metadata.get(\"name\");\n        // re-add for edit call\n        if (originalResourceVersion != null) {\n          metadata.put(RESOURCE_VERSION, originalResourceVersion);\n        } else {\n          // we get resourceVersion from existing object\n          // possible race condition if object has been deleted since the HTTP_CONFLICT exception?\n          Map<String, Object> currentObjectAsMap = this.namespace != null ?\n            get(namespace, nameFromObject) : get(nameFromObject);\n          Map<String, Object> currentMetadata = (Map<String, Object>) currentObjectAsMap.get(METADATA);\n          metadata.put(RESOURCE_VERSION, currentMetadata.get(RESOURCE_VERSION));\n        }\n        ret = this.namespace != null ?\n          replace(this.namespace, nameFromObject, objectAsMap) : replace(nameFromObject, objectAsMap);\n      } catch (NullPointerException nullPointerException) {\n        throw KubernetesClientException.launderThrowable(new IllegalStateException(\"Invalid object provided -- metadata.name is required.\"));\n      }\n    }\n    return ret;\n  }\n  /**\n   * Converts yaml/json object as string to a HashMap.\n   * This method checks whether\n   *\n   * @param objectAsString JSON or Yaml object as plain string\n   * @return object being deserialized to a HashMap\n   * @throws IOException in case of any parsing error\n   */\n  private Map<String, Object> convertJsonOrYamlStringToMap(String objectAsString) throws IOException {\n    HashMap<String, Object> retVal = null;\n    if (IOHelpers.isJSONValid(objectAsString)) {\n      retVal =  objectMapper.readValue(objectAsString, HashMap.class);\n    } else {\n      retVal = objectMapper.readValue(IOHelpers.convertYamlToJson(objectAsString), HashMap.class);\n    }\n    return retVal;\n  }\n  protected HttpUrl.Builder fetchWatchUrl(Map<String, String> labels, ListOptions options) throws MalformedURLException {\n    String configuredName = this.name;\n    // Get Url without resource name configured\n    this.name = null;\n    String resourceUrl = fetchUrl(labels);\n    if (resourceUrl.endsWith(\"/\")) {\n      resourceUrl = resourceUrl.substring(0, resourceUrl.length() - 1);\n    }\n    URL url = new URL(resourceUrl);\n    HttpUrl.Builder httpUrlBuilder = HttpUrl.get(url).newBuilder();\n    if (configuredName != null) {\n      httpUrlBuilder.addQueryParameter(\"fieldSelector\", \"metadata.name=\" + configuredName);\n    }\n    HttpClientUtils.appendListOptionParams(httpUrlBuilder, options);\n    return httpUrlBuilder;\n  }\n  private String fetchUrl(Map<String, String> labels) {\n    if (config.getMasterUrl() == null) {\n      return null;\n    }\n    HttpUrl.Builder urlBuilder = HttpUrl.get(getNamespacedUrl(namespace, name)).newBuilder();\n    if (labels != null) {\n      urlBuilder.addQueryParameter(\"labelSelector\", getLabelsQueryParam(labels));\n    }\n    if (listOptions != null) {\n      urlBuilder = HttpClientUtils.appendListOptionParams(urlBuilder, listOptions);\n    }\n    if (dryRun) {\n      urlBuilder.addQueryParameter(\"dryRun\", \"All\");\n    }\n    return urlBuilder.toString();\n  }\n  private String getNamespacedUrl(String namespace, String name) {\n    StringBuilder urlBuilder = new StringBuilder(config.getMasterUrl());\n    urlBuilder.append(config.getMasterUrl().endsWith(\"/\") ? \"\" : \"/\");\n    if (Utils.isNotNullOrEmpty(customResourceDefinition.getGroup())) {\n      urlBuilder.append(\"apis/\");\n      urlBuilder.append(customResourceDefinition.getGroup())\n        .append(\"/\");\n    } else {\n      urlBuilder.append(\"api/\");\n    }\n    urlBuilder.append(customResourceDefinition.getVersion())\n      .append(\"/\");\n    if(customResourceDefinition.getScope().equals(\"Namespaced\") && namespace != null) {\n      urlBuilder.append(\"namespaces/\").append(namespace).append(\"/\");\n    }\n    urlBuilder.append(customResourceDefinition.getPlural());\n    if (name != null) {\n      urlBuilder.append(\"/\").append(name);\n    }\n    return urlBuilder.toString();\n  }\n  private String getLabelsQueryParam(Map<String, String> labels) {\n    StringBuilder labelQueryBuilder = new StringBuilder();\n    for(Map.Entry<String, String> entry : labels.entrySet()) {\n      if(labelQueryBuilder.length() > 0) {\n        labelQueryBuilder.append(\",\");\n      }\n      labelQueryBuilder.append(entry.getKey()).append(\"=\").append(entry.getValue());\n    }\n    return labelQueryBuilder.toString();\n  }\n  private Map<String, Object> makeCall(String url, String body, HttpCallMethod callMethod) {\n    return makeCall(url, body, callMethod, true);\n  }\n  private Map<String, Object> makeCall(String url, String body, HttpCallMethod callMethod, boolean shouldRequestFailure) {\n    Request request = (body == null) ? getRequest(url, callMethod) : getRequest(url, body, callMethod);\n    try (Response response = client.newCall(request).execute()) {\n      if (response.isSuccessful()) {\n        String respBody = response.body().string();\n        if(Utils.isNullOrEmpty(respBody))\n          return new HashMap<>();\n        else\n          return objectMapper.readValue(respBody, HashMap.class);\n      } else {\n        return handleFailure(request, response, shouldRequestFailure);\n      }\n    } catch(Exception e) {\n      throw KubernetesClientException.launderThrowable(e);\n    }\n  }\n  private Map<String, Object> handleFailure(Request request, Response response, boolean shouldRequestFailure) throws IOException {\n    if (shouldRequestFailure) {\n      throw requestFailure(request, createStatus(response));\n    }\n    return objectMapper.readValue(response.body().string(), HashMap.class);\n  }\n  private boolean handleDelete(String requestBody) {\n    Map<String, Object> response = makeCall(fetchUrl(null), requestBody, HttpCallMethod.DELETE, false);\n    // In most cases Status object is sent on deletion, but when deprecated DeleteOptions.orphanDependents\n    // is used; object which is being deleted is sent\n    if (!response.isEmpty() && response.get(\"kind\").toString().equals(\"Status\")) {\n      return response.get(\"status\").toString().equals(\"Success\");\n    }\n    return true;\n  }\n  private Map<String, Object> validateAndSubmitRequest(String objectAsString, HttpCallMethod httpCallMethod) throws IOException {\n    return validateAndSubmitRequest(fetchUrl(null), objectAsString, httpCallMethod);\n  }\n  private Map<String, Object> validateAndSubmitRequest(String resourceUrl, String objectAsString, HttpCallMethod httpCallMethod) throws IOException {\n    if (IOHelpers.isJSONValid(objectAsString)) {\n      return makeCall(resourceUrl, objectAsString, httpCallMethod);\n    } else {\n      return makeCall(resourceUrl, IOHelpers.convertYamlToJson(objectAsString), httpCallMethod);\n    }\n  }\n  private Request getRequest(String url, HttpCallMethod httpCallMethod) {\n    Request.Builder requestBuilder = new Request.Builder();\n    switch(httpCallMethod) {\n      case GET:\n        requestBuilder.get().url(url);\n        break;\n      case DELETE:\n        requestBuilder.delete().url(url);\n        break;\n    }\n    return requestBuilder.build();\n  }\n  private Request getRequest(String url, String body, HttpCallMethod httpCallMethod) {\n    Request.Builder requestBuilder = new Request.Builder();\n    RequestBody requestBody = RequestBody.create(MediaType.parse(\"application/json\"), body);\n    switch(httpCallMethod) {\n      case DELETE:\n        return requestBuilder.delete(requestBody).url(url).build();\n      case POST:\n        return requestBuilder.post(requestBody).url(url).build();\n      case PUT:\n        return requestBuilder.put(requestBody).url(url).build();\n      case PATCH:\n        return requestBuilder.patch(RequestBody.create(JSON_PATCH, body)).url(url).build();\n    }\n    return requestBuilder.build();\n  }\n  private String getPatchDiff(String namespace, String customResourceName, Map<String, Object> customResource) throws IOException {\n    Map<String, Object> oldObject = get(namespace, customResourceName);\n    // Exclude changes to the status\n    oldObject.put(\"status\", null);\n    customResource.put(\"status\", null);\n    JsonNode newone = JsonDiff.asJson(PatchUtils.patchMapper().valueToTree(oldObject), PatchUtils.patchMapper().valueToTree(customResource));\n    return objectMapper.writeValueAsString(newone);\n  }\n  private DeleteOptions fetchDeleteOptions(boolean cascading, String propagationPolicy) {\n    DeleteOptionsBuilder deleteOptionsBuilder = new DeleteOptionsBuilder();\n    String resolvedPropagationPolicy = resolvePropagationPolicy(propagationPolicy);\n    if (resolvedPropagationPolicy != null) {\n      deleteOptionsBuilder.withPropagationPolicy(resolvedPropagationPolicy);\n    } else {\n      deleteOptionsBuilder.withOrphanDependents(!cascading);\n    }\n    if (this.gracePeriodInSeconds > 0) {\n      deleteOptionsBuilder.withGracePeriodSeconds(this.gracePeriodInSeconds);\n    }\n    if (this.dryRun) {\n      deleteOptionsBuilder.withDryRun(Collections.singletonList(\"All\"));\n    }\n    return deleteOptionsBuilder.build();\n  }\n  private String resolvePropagationPolicy(String propagationPolicyProvided) {\n    if (propagationPolicyProvided != null) {\n      return propagationPolicyProvided;\n    } else if (this.deletionPropagation != null) {\n      return this.deletionPropagation;\n    }\n    return null;\n  }\n  private boolean pickNamespaceOrNameBasedOnScopeAndDelete(String namespaceOrName, String deleteOptionsAsString) {\n    String operationNamespace = null;\n    String operationName = null;\n    if (customResourceDefinition.getScope().equals(\"Namespaced\")) {\n      operationNamespace = namespaceOrName;\n    } else {\n      operationName = namespaceOrName;\n    }\n    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, operationNamespace, operationName, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun)\n      .handleDelete(deleteOptionsAsString);\n  }\n"]], "pred": {"ppl": 1.5659514665603638, "ppl_lower": 1.7236311435699463, "ppl/lowercase_ppl": -1.2139151802889951, "ppl/zlib": 6.82950517906223e-05, "Min_5.0% Prob": 5.519428533666274, "Min_10.0% Prob": 3.847129333253, "Min_20.0% Prob": 2.196678050300654, "Min_30.0% Prob": 1.4922043184134988, "Min_40.0% Prob": 1.1202683597996668, "Min_50.0% Prob": 0.8974865157277471, "Min_60.0% Prob": 0.7483675155461443}}
{"hexsha": "7db28ce1d6d4756e539c17aa84d4ca1667e68f76", "ext": "java", "lang": "Java", "content": "class CSharpNamespaceDetectorTest extends ResourceTest {\n    @ParameterizedTest(name = \"{index} => file={0}, expected package={1}\")\n    @CsvSource({\n            \"ActionBinding.cs, Avaloq.SmartClient.Utilities\",\n            \"ActionBinding-Original-Formatting.cs, Avaloq.SmartClient.Utilities\",\n            \"Program.cs, ConsoleApplication1\", // see Jenkins-48869\n            \"Class1.cs, ConsoleApplication1\",  // see Jenkins-48869\n            \"pom.xml, -\",\n            \"MavenJavaTest.txt, -\"})\n    void shouldExtractPackageNameFromJavaSource(final String fileName, final String expectedPackage) throws IOException {\n        try (InputStream stream = asInputStream(fileName)) {\n            assertThat(new CSharpNamespaceDetector().detectPackageName(stream, StandardCharsets.UTF_8))\n                    .isEqualTo(expectedPackage);\n        }\n    }\n\n    @Test\n    void shouldAcceptCorrectFileSuffix() {\n        CSharpNamespaceDetector namespaceDetector = new CSharpNamespaceDetector();\n        assertThat(namespaceDetector.accepts(\"ActionBinding.cs\"))\n                .as(\"Does not accept a C# file.\").isTrue();\n        assertThat(namespaceDetector.accepts(\"ActionBinding.cs.c\"))\n                .as(\"Accepts a non-C# file.\").isFalse();\n        assertThat(namespaceDetector.accepts(\"Action.java\"))\n                .as(\"Accepts a non-C# file.\").isFalse();\n        assertThat(namespaceDetector.accepts(\"pom.xml\"))\n                .as(\"Accepts a non-C# file.\").isFalse();\n    }\n}", "item_id": 0, "repo": "lcmrvk/analysis-model", "file": "src/test/java/edu/hm/hafner/analysis/CSharpNamespaceDetectorTest.java", "last_update_at": "2022-03-04T07:09:56+00:00", "question_id": "7db28ce1d6d4756e539c17aa84d4ca1667e68f76_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class CSharpNamespaceDetectorTest extends ResourceTest {\n    @ParameterizedTest(name = \"{index} => file={0}, expected package={1}\")\n    @CsvSource({\n            \"ActionBinding.cs, Avaloq.SmartClient.Utilities\",\n            \"ActionBinding-Original-Formatting.cs, Avaloq.SmartClient.Utilities\",\n            \"Program.cs, ConsoleApplication1\", // see Jenkins-48869\n            \"Class1.cs, ConsoleApplication1\",  // see Jenkins-48869\n            \"pom.xml, -\",\n            \"MavenJavaTest.txt, -\"})\n    void shouldExtractPackageNameFromJavaSource(final String fileName, final String expectedPackage) throws IOException {\n        try (InputStream stream = asInputStream(fileName)) {\n            assertThat(new CSharpNamespaceDetector().detectPackageName(stream, StandardCharsets.UTF_8))\n                    .isEqualTo(expectedPackage);\n        }\n    }\n    @Test\n    void shouldAcceptCorrectFileSuffix() {\n        CSharpNamespaceDetector namespaceDetector = new CSharpNamespaceDetector();\n        assertThat(namespaceDetector.accepts(\"ActionBinding.cs\"))\n                .as(\"Does not accept a C# file.\").isTrue();\n        assertThat(namespaceDetector.accepts(\"ActionBinding.cs.c\"))\n                .as(\"Accepts a non-C# file.\").isFalse();\n        assertThat(namespaceDetector.accepts(\"Action.java\"))\n                .as(\"Accepts a non-C# file.\").isFalse();\n        assertThat(namespaceDetector.accepts(\"pom.xml\"))\n                .as(\"Accepts a non-C# file.\").isFalse();\n    }\n"]], "pred": {"ppl": 2.778080701828003, "ppl_lower": 3.3022851943969727, "ppl/lowercase_ppl": -1.1691731599834831, "ppl/zlib": 0.0019169986758804007, "Min_5.0% Prob": 7.604257941246033, "Min_10.0% Prob": 6.265561348054467, "Min_20.0% Prob": 4.394629798284391, "Min_30.0% Prob": 3.238666760344659, "Min_40.0% Prob": 2.523214093121615, "Min_50.0% Prob": 2.0341515512642077, "Min_60.0% Prob": 1.702896727031217}}
{"hexsha": "5272a48eb8d04dd3b917451b61e3c73bf3dceaca", "ext": "java", "lang": "Java", "content": "public class StreamGroupedFold<IN, OUT> extends StreamFold<IN, OUT> {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate KeySelector<IN, ?> keySelector;\n\tprivate Map<Object, OUT> values;\n\tprivate OUT initialValue;\n\n\tpublic StreamGroupedFold(FoldFunction<IN, OUT> folder, KeySelector<IN, ?> keySelector,\n\t\t\tOUT initialValue, TypeInformation<OUT> outTypeInformation) {\n\t\tsuper(folder, initialValue, outTypeInformation);\n\t\tthis.keySelector = keySelector;\n\t\tthis.initialValue = initialValue;\n\t\tvalues = new HashMap<Object, OUT>();\n\t}\n\n\t@Override\n\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tObject key = keySelector.getKey(element.getValue());\n\t\tOUT accumulator = values.get(key);\n\n\t\tif (accumulator != null) {\n\t\t\tOUT folded = userFunction.fold(outTypeSerializer.copy(accumulator), element.getValue());\n\t\t\tvalues.put(key, folded);\n\t\t\toutput.collect(element.replace(folded));\n\t\t} else {\n\t\t\tOUT first = userFunction.fold(outTypeSerializer.copy(initialValue), element.getValue());\n\t\t\tvalues.put(key, first);\n\t\t\toutput.collect(element.replace(first));\n\t\t}\n\t}\n\n}", "item_id": 0, "repo": "rainiraj/flink", "file": "flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/operators/StreamGroupedFold.java", "last_update_at": "2022-02-19T21:11:52+00:00", "question_id": "5272a48eb8d04dd3b917451b61e3c73bf3dceaca_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StreamGroupedFold<IN, OUT> extends StreamFold<IN, OUT> {\n\tprivate static final long serialVersionUID = 1L;\n\tprivate KeySelector<IN, ?> keySelector;\n\tprivate Map<Object, OUT> values;\n\tprivate OUT initialValue;\n\tpublic StreamGroupedFold(FoldFunction<IN, OUT> folder, KeySelector<IN, ?> keySelector,\n\t\t\tOUT initialValue, TypeInformation<OUT> outTypeInformation) {\n\t\tsuper(folder, initialValue, outTypeInformation);\n\t\tthis.keySelector = keySelector;\n\t\tthis.initialValue = initialValue;\n\t\tvalues = new HashMap<Object, OUT>();\n\t}\n\t@Override\n\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tObject key = keySelector.getKey(element.getValue());\n\t\tOUT accumulator = values.get(key);\n\t\tif (accumulator != null) {\n\t\t\tOUT folded = userFunction.fold(outTypeSerializer.copy(accumulator), element.getValue());\n\t\t\tvalues.put(key, folded);\n\t\t\toutput.collect(element.replace(folded));\n\t\t} else {\n\t\t\tOUT first = userFunction.fold(outTypeSerializer.copy(initialValue), element.getValue());\n\t\t\tvalues.put(key, first);\n\t\t\toutput.collect(element.replace(first));\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.6683415174484253, "ppl_lower": 2.1803781986236572, "ppl/lowercase_ppl": -1.5229632928992396, "ppl/zlib": 0.00114503362337927, "Min_5.0% Prob": 5.764376948861515, "Min_10.0% Prob": 4.0224393265587945, "Min_20.0% Prob": 2.4006132066249846, "Min_30.0% Prob": 1.6801647711367833, "Min_40.0% Prob": 1.2783458641863295, "Min_50.0% Prob": 1.0213574231655167, "Min_60.0% Prob": 0.8533322323992036}}
{"hexsha": "173808021b4d348f18c162c0617b49a566289b7a", "ext": "java", "lang": "Java", "content": "public class FlyingCapEntity extends Entity implements FlyingItemEntity {\n\tprivate static final TrackedData<Integer> COLOR = DataTracker.registerData(FlyingCapEntity.class, TrackedDataHandlerRegistry.INTEGER);\n\t\n\t// synced\n\tprivate ItemStack stack;\n\tprivate String throwerId;\n\tprivate Vec3d startAngle;\n\tprivate Vec3d startPos;\n\tprivate boolean leftThrower = false;\n\tpublic int ticksAtEnd;\n\tprivate PreferredCapSlot preferredSlot;\n\t// not synced\n\t@Nullable\n\tprivate PlayerEntity thrower;\n\t\n\tpublic FlyingCapEntity(EntityType<FlyingCapEntity> entityType, World world) {\n\t\tsuper(entityType, world);\n\t}\n\t\n\tpublic FlyingCapEntity(World world, ItemStack itemStack, PlayerEntity thrower, double x, double y, double z, PreferredCapSlot slot) {\n\t\tsuper(BingBingWahoo.FLYING_CAP, world);\n\t\tthis.setItem(itemStack.copy());\n\t\tthis.thrower = thrower;\n\t\tthis.throwerId = thrower.getUuidAsString();\n\t\tthis.startAngle = thrower.getRotationVec(0).normalize().multiply(0.1);\n\t\tsetPos(x, y, z);\n\t\tthis.startPos = getPos();\n\t\tthis.preferredSlot = slot;\n\t}\n\t\n\tpublic void sendData(ServerPlayerEntity player) {\n\t\tNbtCompound data = new NbtCompound();\n\t\twriteCustomDataToNbt(data);\n\t\tPacketByteBuf buf = PacketByteBufs.create()\n\t\t\t\t.writeNbt(data)\n\t\t\t\t.writeString(getUuidAsString());\n\t\tServerPlayNetworking.send(player, CAP_ENTITY_SPAWN, buf);\n\t}\n\t\n\t@Override\n\tpublic void onStartedTrackingBy(ServerPlayerEntity player) {\n\t\tsuper.onStartedTrackingBy(player);\n\t\tsendData(player);\n\t}\n\t\n\t@Override\n\tprotected void initDataTracker() {\n\t\tdataTracker.startTracking(COLOR, 0xFFFFFF);\n\t}\n\t\n\tpublic void setItem(ItemStack stack) {\n\t\tthis.stack = stack;\n\t\tif (stack.getItem() instanceof MysteriousCapItem cap) {\n\t\t\tsetColor(cap.getColor(stack));\n\t\t}\n\t}\n\t\n\tpublic void setColor(int color) {\n\t\tdataTracker.set(COLOR, color);\n\t}\n\t\n\t@Override\n\tpublic void readCustomDataFromNbt(NbtCompound nbt) {\n\t\tItemStack stack = ItemStack.fromNbt(nbt.getCompound(\"Item\"));\n\t\tsetItem(stack);\n\t\tthis.throwerId = nbt.getString(\"Thrower\");\n\t\tthis.startAngle = new Vec3d(nbt.getDouble(\"StartAngleX\"), nbt.getDouble(\"StartAngleY\"), nbt.getDouble(\"StartAngleZ\"));\n\t\tthis.startPos = new Vec3d(nbt.getDouble(\"StartPosX\"), nbt.getDouble(\"StartPosY\"), nbt.getDouble(\"StartPosZ\"));\n\t\tthis.leftThrower = nbt.getBoolean(\"LeftThrower\");\n\t\tthis.ticksAtEnd = nbt.getInt(\"TicksAtEnd\");\n\t\tthis.preferredSlot = PreferredCapSlot.values()[nbt.getInt(\"PreferredSlot\")];\n\t}\n\t\n\t@Override\n\tpublic void writeCustomDataToNbt(NbtCompound nbt) {\n\t\tnbt.put(\"Item\", getStack().writeNbt(new NbtCompound()));\n\t\tnbt.putString(\"Thrower\", throwerId);\n\t\tnbt.putDouble(\"StartAngleX\", startAngle.getX());\n\t\tnbt.putDouble(\"StartAngleY\", startAngle.getY());\n\t\tnbt.putDouble(\"StartAngleZ\", startAngle.getZ());\n\t\tnbt.putDouble(\"StartPosX\", startPos.getX());\n\t\tnbt.putDouble(\"StartPosY\", startPos.getY());\n\t\tnbt.putDouble(\"StartPosZ\", startPos.getZ());\n\t\tnbt.putBoolean(\"LeftThrower\", leftThrower);\n\t\tnbt.putInt(\"TicksAtEnd\", ticksAtEnd);\n\t\tnbt.putInt(\"PreferredSlot\", preferredSlot.ordinal());\n\t}\n\t\n\t@Override\n\tpublic void tick() {\n\t\tsuper.tick();\n\t\ttryFindThrower();\n\t\ttryMove();\n\t\t\n\t\tif (!world.isClient()) {\n\t\t\tList<Entity> collisions = world.getOtherEntities(this, getBoundingBox().stretch(getVelocity()).expand(1), e -> !e.isSpectator() && e.collides());\n\t\t\t\n\t\t\tif (shouldLeaveThrower(collisions)) {\n\t\t\t\tleftThrower = true;\n\t\t\t}\n\t\t\t\n\t\t\tfor (Entity entity : collisions) {\n\t\t\t\tif (entity instanceof PlayerEntity thrower) {\n\t\t\t\t\tif ((leftThrower || ticksAtEnd != 0) && throwerId.equals(entity.getUuidAsString())) {\n\t\t\t\t\t\tif (!tryReequipCap()) { // set in correct slot\n\t\t\t\t\t\t\tif (!thrower.giveItemStack(getStack())) { // throw randomly in inventory\n\t\t\t\t\t\t\t\tworld.spawnEntity(new ItemEntity(world, thrower.getX(), thrower.getY(), thrower.getZ(), getStack())); // drop on ground\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremove(KILLED);\n\t\t\t\t\t\tworld.playSound(null,\n\t\t\t\t\t\t\t\tthrower.getX(),\n\t\t\t\t\t\t\t\tthrower.getY(),\n\t\t\t\t\t\t\t\tthrower.getZ(),\n\t\t\t\t\t\t\t\tSoundEvents.ENTITY_ITEM_PICKUP,\n\t\t\t\t\t\t\t\tSoundCategory.PLAYERS,\n\t\t\t\t\t\t\t\t0.2F,\n\t\t\t\t\t\t\t\t((thrower.getRandom().nextFloat() - thrower.getRandom().nextFloat()) * 0.7F + 1.0F) * 2.0F\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (entity instanceof LivingEntity living && !(entity instanceof PlayerEntity) && thrower instanceof ServerPlayerEntity player) {\n\t\t\t\t\tif (Identity.CONFIG.enableSwaps || player.hasPermissionLevel(3)) {\n\t\t\t\t\t\tLivingEntity copy = (LivingEntity) living.getType().create(world);\n\t\t\t\t\t\tif (copy != null) {\n\t\t\t\t\t\t\tcopy.readNbt(living.writeNbt(new NbtCompound()));\n\t\t\t\t\t\t\tComponents.CURRENT_IDENTITY.get(player).setIdentity(copy);\n\t\t\t\t\t\t\tplayer.calculateDimensions();\n\t\t\t\t\t\t\tplayer.teleport((ServerWorld) world, living.getX(), living.getY(), living.getZ(), living.getYaw(), living.getPitch());\n\t\t\t\t\t\t\tworld.playSound(null, living.getX(), living.getY(), living.getZ(),\n\t\t\t\t\t\t\t\t\tSoundEvents.ENTITY_ENDERMAN_TELEPORT, SoundCategory.PLAYERS, 1, 1);\n\t\t\t\t\t\t\tNbtCompound captured = new NbtCompound();\n\t\t\t\t\t\t\tcaptured.put(\"Entity\", living.writeNbt(new NbtCompound()));\n\t\t\t\t\t\t\tcaptured.putString(\"Type\", Registry.ENTITY_TYPE.getId(living.getType()).toString());\n\t\t\t\t\t\t\t((ServerPlayerEntityExtensions) player).wahoo$setCaptured(captured);\n\t\t\t\t\t\t\tliving.discard();\n\t\t\t\t\t\t\tItemStack stack = getStack();\n\t\t\t\t\t\t\tif (!tryReequipCap()) { // set in correct slot\n\t\t\t\t\t\t\t\tif (!player.giveItemStack(stack)) { // throw randomly in inventory\n\t\t\t\t\t\t\t\t\tworld.spawnEntity(new ItemEntity(world, player.getX(), player.getY(), player.getZ(), stack)); // drop on ground\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tremove(KILLED);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (entity != thrower && entity instanceof LivingEntity living) {\n\t\t\t\t\tliving.damage(DamageSource.thrownProjectile(this, thrower), 3);\n\t\t\t\t\tticksAtEnd = 10;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (age > 500) kill();\n\t\t}\n\t}\n\t\n\tprivate boolean tryReequipCap() {\n\t\tif (thrower != null) {\n\t\t\tItemStack stack = getStack();\n\t\t\t// first try preferred slot\n\t\t\tif (preferredSlot.shouldEquip(thrower, stack)) {\n\t\t\t\tpreferredSlot.equip(thrower, stack);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\t// then try all slots\n\t\t\tfor (PreferredCapSlot slot : PreferredCapSlot.values()) {\n\t\t\t\tif (slot.shouldEquip(thrower, stack)) {\n\t\t\t\t\tslot.shouldEquip(thrower, stack);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate void tryFindThrower() {\n\t\tif (thrower == null) {\n\t\t\tfor (PlayerEntity player : world.getPlayers()) {\n\t\t\t\tif (player.getUuidAsString().equals(throwerId)) {\n\t\t\t\t\tthrower = player;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void tryMove() {\n\t\tif (thrower != null) {\n\t\t\tVec3d toMove = Vec3d.ZERO;\n\t\t\tif (ticksAtEnd == 0) {\n\t\t\t\tdouble mult = Math.cos(age / 5f) * 10;\n\t\t\t\ttoMove = startAngle.multiply(mult);\n\t\t\t\t// valley of the cosine wave - slow down as it approaches the end\n\t\t\t\tticksAtEnd = mult <= 0 ? 1 : 0;\n\t\t\t} else {\n\t\t\t\tticksAtEnd++;\n\t\t\t\tif (ticksAtEnd > 10) {\n\t\t\t\t\tif (thrower != null) {\n\t\t\t\t\t\tVec3d distance = thrower.getEyePos().subtract(getPos());\n\t\t\t\t\t\ttoMove = distance.multiply(0.2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (toMove != Vec3d.ZERO) {\n\t\t\t\tmove(MovementType.SELF, toMove);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate boolean shouldLeaveThrower(List<Entity> collisions) {\n\t\tfor(Entity entity : collisions) {\n\t\t\tif (entity.getUuidAsString().equals(throwerId)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic boolean collides() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic boolean canUsePortals() {\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic void kill() {\n\t\tsuper.kill();\n\t\tdropStack(stack.copy());\n\t}\n\n\t@Override\n\tpublic ItemStack getStack() {\n\t\treturn stack;\n\t}\n\t\n\t@Override\n\tpublic Packet<?> createSpawnPacket() {\n\t\treturn new EntitySpawnS2CPacket(this);\n\t}\n\t\n\tpublic static void spawn(ServerPlayerEntity thrower, ItemStack capStack, PreferredCapSlot preferredSlot) {\n\t\tif (capStack != null && capStack.isOf(MYSTERIOUS_CAP)) {\n\t\t\tFlyingCapEntity cap = new FlyingCapEntity(thrower.world, capStack.copy(), thrower, thrower.getX(), thrower.getEyeY() - 0.1, thrower.getZ(), preferredSlot);\n\t\t\tthrower.world.spawnEntity(cap);\n\t\t}\n\t}\n}", "item_id": 0, "repo": "Ignoramuses/bing-bing-wahoo", "file": "src/main/java/net/ignoramuses/bingBingWahoo/cap/FlyingCapEntity.java", "last_update_at": "2022-02-15T13:18:21+00:00", "question_id": "173808021b4d348f18c162c0617b49a566289b7a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FlyingCapEntity extends Entity implements FlyingItemEntity {\n\tprivate static final TrackedData<Integer> COLOR = DataTracker.registerData(FlyingCapEntity.class, TrackedDataHandlerRegistry.INTEGER);\n\t\n\t// synced\n\tprivate ItemStack stack;\n\tprivate String throwerId;\n\tprivate Vec3d startAngle;\n\tprivate Vec3d startPos;\n\tprivate boolean leftThrower = false;\n\tpublic int ticksAtEnd;\n\tprivate PreferredCapSlot preferredSlot;\n\t// not synced\n\t@Nullable\n\tprivate PlayerEntity thrower;\n\t\n\tpublic FlyingCapEntity(EntityType<FlyingCapEntity> entityType, World world) {\n\t\tsuper(entityType, world);\n\t}\n\t\n\tpublic FlyingCapEntity(World world, ItemStack itemStack, PlayerEntity thrower, double x, double y, double z, PreferredCapSlot slot) {\n\t\tsuper(BingBingWahoo.FLYING_CAP, world);\n\t\tthis.setItem(itemStack.copy());\n\t\tthis.thrower = thrower;\n\t\tthis.throwerId = thrower.getUuidAsString();\n\t\tthis.startAngle = thrower.getRotationVec(0).normalize().multiply(0.1);\n\t\tsetPos(x, y, z);\n\t\tthis.startPos = getPos();\n\t\tthis.preferredSlot = slot;\n\t}\n\t\n\tpublic void sendData(ServerPlayerEntity player) {\n\t\tNbtCompound data = new NbtCompound();\n\t\twriteCustomDataToNbt(data);\n\t\tPacketByteBuf buf = PacketByteBufs.create()\n\t\t\t\t.writeNbt(data)\n\t\t\t\t.writeString(getUuidAsString());\n\t\tServerPlayNetworking.send(player, CAP_ENTITY_SPAWN, buf);\n\t}\n\t\n\t@Override\n\tpublic void onStartedTrackingBy(ServerPlayerEntity player) {\n\t\tsuper.onStartedTrackingBy(player);\n\t\tsendData(player);\n\t}\n\t\n\t@Override\n\tprotected void initDataTracker() {\n\t\tdataTracker.startTracking(COLOR, 0xFFFFFF);\n\t}\n\t\n\tpublic void setItem(ItemStack stack) {\n\t\tthis.stack = stack;\n\t\tif (stack.getItem() instanceof MysteriousCapItem cap) {\n\t\t\tsetColor(cap.getColor(stack));\n\t\t}\n\t}\n\t\n\tpublic void setColor(int color) {\n\t\tdataTracker.set(COLOR, color);\n\t}\n\t\n\t@Override\n\tpublic void readCustomDataFromNbt(NbtCompound nbt) {\n\t\tItemStack stack = ItemStack.fromNbt(nbt.getCompound(\"Item\"));\n\t\tsetItem(stack);\n\t\tthis.throwerId = nbt.getString(\"Thrower\");\n\t\tthis.startAngle = new Vec3d(nbt.getDouble(\"StartAngleX\"), nbt.getDouble(\"StartAngleY\"), nbt.getDouble(\"StartAngleZ\"));\n\t\tthis.startPos = new Vec3d(nbt.getDouble(\"StartPosX\"), nbt.getDouble(\"StartPosY\"), nbt.getDouble(\"StartPosZ\"));\n\t\tthis.leftThrower = nbt.getBoolean(\"LeftThrower\");\n\t\tthis.ticksAtEnd = nbt.getInt(\"TicksAtEnd\");\n\t\tthis.preferredSlot = PreferredCapSlot.values()[nbt.getInt(\"PreferredSlot\")];\n\t}\n\t\n\t@Override\n\tpublic void writeCustomDataToNbt(NbtCompound nbt) {\n\t\tnbt.put(\"Item\", getStack().writeNbt(new NbtCompound()));\n\t\tnbt.putString(\"Thrower\", throwerId);\n\t\tnbt.putDouble(\"StartAngleX\", startAngle.getX());\n\t\tnbt.putDouble(\"StartAngleY\", startAngle.getY());\n\t\tnbt.putDouble(\"StartAngleZ\", startAngle.getZ());\n\t\tnbt.putDouble(\"StartPosX\", startPos.getX());\n\t\tnbt.putDouble(\"StartPosY\", startPos.getY());\n\t\tnbt.putDouble(\"StartPosZ\", startPos.getZ());\n\t\tnbt.putBoolean(\"LeftThrower\", leftThrower);\n\t\tnbt.putInt(\"TicksAtEnd\", ticksAtEnd);\n\t\tnbt.putInt(\"PreferredSlot\", preferredSlot.ordinal());\n\t}\n\t\n\t@Override\n\tpublic void tick() {\n\t\tsuper.tick();\n\t\ttryFindThrower();\n\t\ttryMove();\n\t\t\n\t\tif (!world.isClient()) {\n\t\t\tList<Entity> collisions = world.getOtherEntities(this, getBoundingBox().stretch(getVelocity()).expand(1), e -> !e.isSpectator() && e.collides());\n\t\t\t\n\t\t\tif (shouldLeaveThrower(collisions)) {\n\t\t\t\tleftThrower = true;\n\t\t\t}\n\t\t\t\n\t\t\tfor (Entity entity : collisions) {\n\t\t\t\tif (entity instanceof PlayerEntity thrower) {\n\t\t\t\t\tif ((leftThrower || ticksAtEnd != 0) && throwerId.equals(entity.getUuidAsString())) {\n\t\t\t\t\t\tif (!tryReequipCap()) { // set in correct slot\n\t\t\t\t\t\t\tif (!thrower.giveItemStack(getStack())) { // throw randomly in inventory\n\t\t\t\t\t\t\t\tworld.spawnEntity(new ItemEntity(world, thrower.getX(), thrower.getY(), thrower.getZ(), getStack())); // drop on ground\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremove(KILLED);\n\t\t\t\t\t\tworld.playSound(null,\n\t\t\t\t\t\t\t\tthrower.getX(),\n\t\t\t\t\t\t\t\tthrower.getY(),\n\t\t\t\t\t\t\t\tthrower.getZ(),\n\t\t\t\t\t\t\t\tSoundEvents.ENTITY_ITEM_PICKUP,\n\t\t\t\t\t\t\t\tSoundCategory.PLAYERS,\n\t\t\t\t\t\t\t\t0.2F,\n\t\t\t\t\t\t\t\t((thrower.getRandom().nextFloat() - thrower.getRandom().nextFloat()) * 0.7F + 1.0F) * 2.0F\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (entity instanceof LivingEntity living && !(entity instanceof PlayerEntity) && thrower instanceof ServerPlayerEntity player) {\n\t\t\t\t\tif (Identity.CONFIG.enableSwaps || player.hasPermissionLevel(3)) {\n\t\t\t\t\t\tLivingEntity copy = (LivingEntity) living.getType().create(world);\n\t\t\t\t\t\tif (copy != null) {\n\t\t\t\t\t\t\tcopy.readNbt(living.writeNbt(new NbtCompound()));\n\t\t\t\t\t\t\tComponents.CURRENT_IDENTITY.get(player).setIdentity(copy);\n\t\t\t\t\t\t\tplayer.calculateDimensions();\n\t\t\t\t\t\t\tplayer.teleport((ServerWorld) world, living.getX(), living.getY(), living.getZ(), living.getYaw(), living.getPitch());\n\t\t\t\t\t\t\tworld.playSound(null, living.getX(), living.getY(), living.getZ(),\n\t\t\t\t\t\t\t\t\tSoundEvents.ENTITY_ENDERMAN_TELEPORT, SoundCategory.PLAYERS, 1, 1);\n\t\t\t\t\t\t\tNbtCompound captured = new NbtCompound();\n\t\t\t\t\t\t\tcaptured.put(\"Entity\", living.writeNbt(new NbtCompound()));\n\t\t\t\t\t\t\tcaptured.putString(\"Type\", Registry.ENTITY_TYPE.getId(living.getType()).toString());\n\t\t\t\t\t\t\t((ServerPlayerEntityExtensions) player).wahoo$setCaptured(captured);\n\t\t\t\t\t\t\tliving.discard();\n\t\t\t\t\t\t\tItemStack stack = getStack();\n\t\t\t\t\t\t\tif (!tryReequipCap()) { // set in correct slot\n\t\t\t\t\t\t\t\tif (!player.giveItemStack(stack)) { // throw randomly in inventory\n\t\t\t\t\t\t\t\t\tworld.spawnEntity(new ItemEntity(world, player.getX(), player.getY(), player.getZ(), stack)); // drop on ground\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tremove(KILLED);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (entity != thrower && entity instanceof LivingEntity living) {\n\t\t\t\t\tliving.damage(DamageSource.thrownProjectile(this, thrower), 3);\n\t\t\t\t\tticksAtEnd = 10;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (age > 500) kill();\n\t\t}\n\t}\n\t\n\tprivate boolean tryReequipCap() {\n\t\tif (thrower != null) {\n\t\t\tItemStack stack = getStack();\n\t\t\t// first try preferred slot\n\t\t\tif (preferredSlot.shouldEquip(thrower, stack)) {\n\t\t\t\tpreferredSlot.equip(thrower, stack);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\t// then try all slots\n\t\t\tfor (PreferredCapSlot slot : PreferredCapSlot.values()) {\n\t\t\t\tif (slot.shouldEquip(thrower, stack)) {\n\t\t\t\t\tslot.shouldEquip(thrower, stack);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate void tryFindThrower() {\n\t\tif (thrower == null) {\n\t\t\tfor (PlayerEntity player : world.getPlayers()) {\n\t\t\t\tif (player.getUuidAsString().equals(throwerId)) {\n\t\t\t\t\tthrower = player;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void tryMove() {\n\t\tif (thrower != null) {\n\t\t\tVec3d toMove = Vec3d.ZERO;\n\t\t\tif (ticksAtEnd == 0) {\n\t\t\t\tdouble mult = Math.cos(age / 5f) * 10;\n\t\t\t\ttoMove = startAngle.multiply(mult);\n\t\t\t\t// valley of the cosine wave - slow down as it approaches the end\n\t\t\t\tticksAtEnd = mult <= 0 ? 1 : 0;\n\t\t\t} else {\n\t\t\t\tticksAtEnd++;\n\t\t\t\tif (ticksAtEnd > 10) {\n\t\t\t\t\tif (thrower != null) {\n\t\t\t\t\t\tVec3d distance = thrower.getEyePos().subtract(getPos());\n\t\t\t\t\t\ttoMove = distance.multiply(0.2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (toMove != Vec3d.ZERO) {\n\t\t\t\tmove(MovementType.SELF, toMove);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate boolean shouldLeaveThrower(List<Entity> collisions) {\n\t\tfor(Entity entity : collisions) {\n\t\t\tif (entity.getUuidAsString().equals(throwerId)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic boolean collides() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic boolean canUsePortals() {\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic void kill() {\n\t\tsuper.kill();\n\t\tdropStack(stack.copy());\n\t}\n\t@Override\n\tpublic ItemStack getStack() {\n\t\treturn stack;\n\t}\n\t\n\t@Override\n\tpublic Packet<?> createSpawnPacket() {\n\t\treturn new EntitySpawnS2CPacket(this);\n\t}\n\t\n\tpublic static void spawn(ServerPlayerEntity thrower, ItemStack capStack, PreferredCapSlot preferredSlot) {\n\t\tif (capStack != null && capStack.isOf(MYSTERIOUS_CAP)) {\n\t\t\tFlyingCapEntity cap = new FlyingCapEntity(thrower.world, capStack.copy(), thrower, thrower.getX(), thrower.getEyeY() - 0.1, thrower.getZ(), preferredSlot);\n\t\t\tthrower.world.spawnEntity(cap);\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.5495214462280273, "ppl_lower": 1.87417733669281, "ppl/lowercase_ppl": -1.4343540303128368, "ppl/zlib": 0.00017441104694973535, "Min_5.0% Prob": 5.2239302326651185, "Min_10.0% Prob": 3.5609777254216812, "Min_20.0% Prob": 2.1176827473967683, "Min_30.0% Prob": 1.45452400612237, "Min_40.0% Prob": 1.0937317798419657, "Min_50.0% Prob": 0.8763326559386192, "Min_60.0% Prob": 0.7307532123161052}}
{"hexsha": "36158a59483bf5c1c163ec629f05c240b02810ec", "ext": "java", "lang": "Java", "content": "public class AuthSession {\n    public static String USERNAME, PASSWORD, HWID;\n    public static String I_USERNAME, I_PASSWORD, I_HWID;\n\n    public static void entry() {\n        ConfigUtils configUtils = new ConfigUtils(\"auth\", \"\");\n        USERNAME = (String)configUtils.get(\"u\");\n        PASSWORD = (String)configUtils.get(\"p\");\n        HWID = \"NOHWID\";\n        try {\n            String fullHWID = System.getenv(\"COMPUTERNAME\") + System.getProperty(\"user.name\") + System.getenv(\"PROCESSOR_IDENTIFIER\") + System.getenv(\"PROCESSOR_LEVEL\");\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(fullHWID.getBytes());\n\n            StringBuffer buffer = new StringBuffer();\n\n            byte[] md5Bytes = md5.digest();\n            for (byte md5Byte : md5Bytes) {\n                String hex = Integer.toHexString(0xff & md5Byte);\n                buffer.append(hex.length() == 1 ? '0' : hex);\n            }\n            HWID = \"HWID!!\" + buffer.toString();\n        } catch (Exception exception) {}\n\n        I_USERNAME = StringEscapeUtils.escapeHtml4(USERNAME);\n        I_PASSWORD = StringEscapeUtils.escapeHtml4(PASSWORD);\n        I_HWID = StringEscapeUtils.escapeHtml4(HWID);\n    }\n}", "item_id": 0, "repo": "cdscr/HT-Rewrite", "file": "src/main/java/me/htrewrite/client/util/AuthSession.java", "last_update_at": "2022-03-22T10:48:29+00:00", "question_id": "36158a59483bf5c1c163ec629f05c240b02810ec_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AuthSession {\n    public static String USERNAME, PASSWORD, HWID;\n    public static String I_USERNAME, I_PASSWORD, I_HWID;\n    public static void entry() {\n        ConfigUtils configUtils = new ConfigUtils(\"auth\", \"\");\n        USERNAME = (String)configUtils.get(\"u\");\n        PASSWORD = (String)configUtils.get(\"p\");\n        HWID = \"NOHWID\";\n        try {\n            String fullHWID = System.getenv(\"COMPUTERNAME\") + System.getProperty(\"user.name\") + System.getenv(\"PROCESSOR_IDENTIFIER\") + System.getenv(\"PROCESSOR_LEVEL\");\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(fullHWID.getBytes());\n            StringBuffer buffer = new StringBuffer();\n            byte[] md5Bytes = md5.digest();\n            for (byte md5Byte : md5Bytes) {\n                String hex = Integer.toHexString(0xff & md5Byte);\n                buffer.append(hex.length() == 1 ? '0' : hex);\n            }\n            HWID = \"HWID!!\" + buffer.toString();\n        } catch (Exception exception) {}\n        I_USERNAME = StringEscapeUtils.escapeHtml4(USERNAME);\n        I_PASSWORD = StringEscapeUtils.escapeHtml4(PASSWORD);\n        I_HWID = StringEscapeUtils.escapeHtml4(HWID);\n    }\n"]], "pred": {"ppl": 2.0498390197753906, "ppl_lower": 2.702174663543701, "ppl/lowercase_ppl": -1.3849408303740813, "ppl/zlib": 0.0014157026886155455, "Min_5.0% Prob": 6.298629363377889, "Min_10.0% Prob": 4.982648717032538, "Min_20.0% Prob": 3.24682918150131, "Min_30.0% Prob": 2.343000151081519, "Min_40.0% Prob": 1.7889269435030668, "Min_50.0% Prob": 1.4363540777855592, "Min_60.0% Prob": 1.1976090053020558}}
{"hexsha": "c37a60f06f927d0a1679c78786265b35b5add6b3", "ext": "java", "lang": "Java", "content": "@RunWith(Arquillian.class)\npublic class ConfigurationOptionsEndpointTest extends AbstractTest\n{\n    @ArquillianResource\n    private URL contextPath;\n\n    @Test\n    @RunAsClient\n    public void testConfigurationOptionsList() throws Exception\n    {\n        ResteasyClient client = ServiceTestUtil.getResteasyClient();\n        String uri = contextPath + ConfigurationOptionsEndpoint.CONFIGURATION_OPTIONS_PATH;\n        ResteasyWebTarget target = client.target(uri);\n        Response response = target.request().get();\n        Assert.assertEquals(200, response.getStatus());\n\n        // Just read it as a List of Maps, as ConfigurationOption can't easily be deserialized by jackson (abstract class).\n        List<?> optionList = response.readEntity(List.class);\n        Assert.assertNotNull(optionList);\n        Assert.assertTrue(optionList.size() > 1);\n\n        int previousPriority = Integer.MIN_VALUE;\n        for (Map<String, Object> option : (List<Map<String, Object>>)optionList)\n        {\n            int priority = (int)option.get(\"priority\");\n            if (priority < previousPriority)\n                Assert.fail(\"Options are not listed in priority order\");\n        }\n        response.close();\n    }\n\n    @Test\n    @RunAsClient\n    public void testValidationOkBoolean() throws Exception\n    {\n        Assert.assertTrue(validateOption(SourceModeOption.NAME, \"true\"));\n    }\n\n    @Test\n    @RunAsClient\n    public void testValidationBadPath() throws Exception\n    {\n        Assert.assertFalse(validateOption(UserIgnorePathOption.NAME, \"/not/really/here\"));\n    }\n\n    @Test\n    @RunAsClient\n    public void testValidationOkPath() throws Exception\n    {\n        Assert.assertTrue(validateOption(UserIgnorePathOption.NAME, \"src/main/java\"));\n    }\n\n    private boolean validateOption(String name, String value) {\n        ResteasyClient client = ServiceTestUtil.getResteasyClient();\n        String uri = contextPath + ConfigurationOptionsEndpoint.CONFIGURATION_OPTIONS_PATH + \"/\" + ConfigurationOptionsEndpoint.VALIDATE_OPTION;\n        ResteasyWebTarget target = client.target(uri);\n\n        AdvancedOption option = new AdvancedOption();\n        option.setName(name);\n        option.setValue(value);\n\n        Response response = target.request().post(Entity.entity(option, MediaType.APPLICATION_JSON_TYPE));\n        Assert.assertEquals(200, response.getStatus());\n\n        Map<String, Object> optionMap = response.readEntity(Map.class);\n        switch ((String)optionMap.get(\"level\"))\n        {\n            case \"SUCCESS\":\n            case \"WARNING\":\n                return true;\n            default:\n                return false;\n        }\n    }\n}", "item_id": 0, "repo": "jonathanvila/windup-web", "file": "services/src/test/java/org/jboss/windup/web/services/rest/ConfigurationOptionsEndpointTest.java", "last_update_at": "2022-03-02T09:44:54+00:00", "question_id": "c37a60f06f927d0a1679c78786265b35b5add6b3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(Arquillian.class)\npublic class ConfigurationOptionsEndpointTest extends AbstractTest\n{\n    @ArquillianResource\n    private URL contextPath;\n    @Test\n    @RunAsClient\n    public void testConfigurationOptionsList() throws Exception\n    {\n        ResteasyClient client = ServiceTestUtil.getResteasyClient();\n        String uri = contextPath + ConfigurationOptionsEndpoint.CONFIGURATION_OPTIONS_PATH;\n        ResteasyWebTarget target = client.target(uri);\n        Response response = target.request().get();\n        Assert.assertEquals(200, response.getStatus());\n        // Just read it as a List of Maps, as ConfigurationOption can't easily be deserialized by jackson (abstract class).\n        List<?> optionList = response.readEntity(List.class);\n        Assert.assertNotNull(optionList);\n        Assert.assertTrue(optionList.size() > 1);\n        int previousPriority = Integer.MIN_VALUE;\n        for (Map<String, Object> option : (List<Map<String, Object>>)optionList)\n        {\n            int priority = (int)option.get(\"priority\");\n            if (priority < previousPriority)\n                Assert.fail(\"Options are not listed in priority order\");\n        }\n        response.close();\n    }\n    @Test\n    @RunAsClient\n    public void testValidationOkBoolean() throws Exception\n    {\n        Assert.assertTrue(validateOption(SourceModeOption.NAME, \"true\"));\n    }\n    @Test\n    @RunAsClient\n    public void testValidationBadPath() throws Exception\n    {\n        Assert.assertFalse(validateOption(UserIgnorePathOption.NAME, \"/not/really/here\"));\n    }\n    @Test\n    @RunAsClient\n    public void testValidationOkPath() throws Exception\n    {\n        Assert.assertTrue(validateOption(UserIgnorePathOption.NAME, \"src/main/java\"));\n    }\n    private boolean validateOption(String name, String value) {\n        ResteasyClient client = ServiceTestUtil.getResteasyClient();\n        String uri = contextPath + ConfigurationOptionsEndpoint.CONFIGURATION_OPTIONS_PATH + \"/\" + ConfigurationOptionsEndpoint.VALIDATE_OPTION;\n        ResteasyWebTarget target = client.target(uri);\n        AdvancedOption option = new AdvancedOption();\n        option.setName(name);\n        option.setValue(value);\n        Response response = target.request().post(Entity.entity(option, MediaType.APPLICATION_JSON_TYPE));\n        Assert.assertEquals(200, response.getStatus());\n        Map<String, Object> optionMap = response.readEntity(Map.class);\n        switch ((String)optionMap.get(\"level\"))\n        {\n            case \"SUCCESS\":\n            case \"WARNING\":\n                return true;\n            default:\n                return false;\n        }\n    }\n"]], "pred": {"ppl": 1.994122862815857, "ppl_lower": 2.386367082595825, "ppl/lowercase_ppl": -1.2601662698193843, "ppl/zlib": 0.0007798918484724763, "Min_5.0% Prob": 7.1870362758636475, "Min_10.0% Prob": 5.175967475642329, "Min_20.0% Prob": 3.216022104024887, "Min_30.0% Prob": 2.254015233224401, "Min_40.0% Prob": 1.7198384361684538, "Min_50.0% Prob": 1.3782060968686936, "Min_60.0% Prob": 1.1508832998851386}}
{"hexsha": "c279024e4dc6e942f3a284a3279b9989d23b7c49", "ext": "java", "lang": "Java", "content": "public class WorldmapConnectionsTest extends Application {\n    private static final  Random RND = new Random();\n    private World         worldMap;\n    private MapConnection animatedConnection;\n\n    @Override public void init() {\n        worldMap = WorldBuilder.create()\n                               .resolution(Resolution.HI_RES)\n                               .zoomEnabled(true)\n                               .hoverEnabled(false)\n                               .selectionEnabled(false)\n                               .backgroundColor(Color.WHITE)\n                               .fillColor(Color.LIGHTGRAY)\n                               .connectionWidth(1)\n                               .weightedMapPoints(WeightedMapPoints.NONE)\n                               .weightedMapConnections(false)\n                               .arrowsVisible(false)\n                               .drawImagePath(true)\n                               .mapPointTextVisible(true)\n                               .textColor(Color.BLACK)\n                               .build();\n\n        MapPoint calgary           = new MapPoint(\"Calgary\", Color.RED,51.08299176,-114.0799982);\n        MapPoint san_francisco     = new MapPoint(\"San Francisco\", Color.BLUE, 37.74000775,-122.4599777);\n        MapPoint new_york          = new MapPoint(\"New York\", Color.BLUE,40.74997906,-73.98001693);\n        MapPoint chicago           = new MapPoint(\"Chicago\", Color.BLUE,41.82999066,-87.75005497);\n        MapPoint denver            = new MapPoint(\"Denver\",Color.BLUE, 39.73918805,-104.984016);\n\n        MapPoint mexico_city       = new MapPoint(\"Mexico City\",Color.GREEN, 19.44244244,-99.1309882);\n        MapPoint buenos_aires      = new MapPoint(\"Buenos Aires\", Color.LIGHTBLUE, -34.60250161,-58.39753137);\n        MapPoint santiago_de_chile = new MapPoint(\"Santiago de Chile\", Color.BLUE,-33.45001382,-70.66704085);\n        MapPoint sao_paulo         = new MapPoint(\"Sao Paulo\", Color.GREEN, -23.55867959,-46.62501998);\n\n        MapPoint berlin            = new MapPoint(\"Berlin\", Color.DARKORANGE, 52.52181866, 13.40154862);\n        MapPoint paris             = new MapPoint(\"Paris\", Color.DARKBLUE, 48.86669293,2.333335326);\n        MapPoint madrid            = new MapPoint(\"Madrid\", Color.YELLOW,40.40002626,-3.683351686);\n\n        MapPoint johannesburg      = new MapPoint(\"Johannesburg\", Color.BROWN,-26.17004474,28.03000972);\n        MapPoint casablanca        = new MapPoint(\"Casablanca\", Color.SADDLEBROWN,33.59997622,-7.616367433);\n        MapPoint tunis             = new MapPoint(\"Tunis\", Color.DARKGREEN,36.80277814,10.1796781);\n        MapPoint alexandria        = new MapPoint(\"Alexandria\", Color.BLACK,31.20001935,29.94999589);\n        MapPoint nairobi           = new MapPoint(\"Nairobi\", Color.LIGHTBLUE,-1.283346742,36.81665686);\n        MapPoint abidjan           = new MapPoint(\"Abidjan\", Color.IVORY,5.319996967,-4.04004826);\n\n        MapPoint moscow            = new MapPoint(\"Moscow\", Color.RED,55.75216412,37.61552283);\n        MapPoint novosibirsk       = new MapPoint(\"Novosibirsk\", Color.RED,55.02996014,82.96004187);\n        MapPoint magadan           = new MapPoint(\"Magadan\", Color.RED,59.57497988,150.8100089);\n\n        MapPoint abu_dabi          = new MapPoint(\"Abu Dhabi\", Color.GOLD, 24.46668357,54.36659338);\n        MapPoint mumbai            = new MapPoint(\"Mumbai\", Color.GOLD, 19.01699038,72.8569893);\n        MapPoint hyderabad         = new MapPoint(\"Hyderabad\", Color.GOLD,17.39998313,78.47995357);\n\n        MapPoint beijing           = new MapPoint(\"Beijing\", Color.DARKRED,39.92889223,116.3882857);\n        MapPoint chongqing          = new MapPoint(\"Chongqing\", Color.DARKRED,29.56497703,106.5949816);\n        MapPoint hong_kong         = new MapPoint(\"Hong Kong\", Color.DARKRED,22.3049809,114.1850093);\n        MapPoint singapore         = new MapPoint(\"Singapore\", Color.CRIMSON, 1.293033466,103.8558207);\n        MapPoint tokio             = new MapPoint(\"Tokio\",Color.RED, 35.652832,139.839478);\n\n        MapPoint sydney            = new MapPoint(\"Sydney\", Color.BLUE, -33.865143, 151.209900);\n        MapPoint perth             = new MapPoint(\"Perth\", Color.BLUE, -31.95501463,115.8399987);\n        MapPoint christchurch      = new MapPoint(\"Christchurch\", Color.BLUE, -43.53503131,172.6300207);\n\n\n        List<MapPoint> northAmerica = List.of(calgary, san_francisco, chicago, new_york, denver);\n        List<MapPoint> southAmerica = List.of(mexico_city, buenos_aires, santiago_de_chile, sao_paulo);\n        List<MapPoint> europe       = List.of(madrid, paris, berlin);\n        List<MapPoint> afrika       = List.of(johannesburg, casablanca, tunis, alexandria, nairobi, abidjan);\n        List<MapPoint> russia       = List.of(moscow, novosibirsk, magadan);\n        List<MapPoint> india        = List.of(abu_dabi, mumbai, hyderabad);\n        List<MapPoint> asia         = List.of(beijing, hong_kong, singapore, tokio, chongqing);\n        List<MapPoint> australia    = List.of(sydney, perth, christchurch);\n\n        worldMap.addMapPoints(berlin, paris, san_francisco, abu_dabi, new_york, chicago, denver, sao_paulo, madrid, calgary,\n                              mexico_city, buenos_aires, santiago_de_chile, johannesburg, moscow, novosibirsk, magadan,\n                              mumbai, beijing, hong_kong, sydney, christchurch, tokio, singapore, casablanca, tunis, alexandria, nairobi,\n                              abidjan, hyderabad, chongqing, perth);\n\n        /*\n        northAmerica.forEach(mapPoint -> {\n            worldMap.addMapConnections(new MapConnection(berlin, mapPoint, RND.nextInt(130) + 10, berlin.getFill(), Color.ORANGERED, true));\n        });\n        asia.forEach(mapPoint -> {\n            worldMap.addMapConnections(new MapConnection(berlin, mapPoint, RND.nextInt(130) + 10, berlin.getFill(), Color.ORANGERED, true));\n        });\n        australia.forEach(mapPoint -> {\n            worldMap.addMapConnections(new MapConnection(beijing, mapPoint, RND.nextInt(130) + 10, beijing.getFill(), Color.PURPLE, true));\n            worldMap.addMapConnections(new MapConnection(hong_kong, mapPoint, RND.nextInt(130) + 10, beijing.getFill(), Color.PURPLE, true));\n        });\n        europe.forEach(mapPoint -> {\n            worldMap.addMapConnections(new MapConnection(johannesburg, mapPoint, RND.nextInt(130) + 10, johannesburg.getFill(), Color.ORANGE, true));\n        });\n        southAmerica.forEach(mapPoint -> {\n            worldMap.addMapConnections(new MapConnection(johannesburg, mapPoint, RND.nextInt(130) + 10, johannesburg.getFill(), Color.ORANGE, true));\n        });\n        */\n\n        MapConnection sanfrancisco_mumbai     = new MapConnection(san_francisco, mumbai, 90, Color.ORANGERED, Color.BLUE, true);\n        MapConnection sanfrancisco_newyork    = new MapConnection(san_francisco, new_york, 100, Color.ORANGERED, Color.BLUE, true);\n        MapConnection sanfrancisco_abudabi    = new MapConnection(san_francisco, abu_dabi, 60, Color.ORANGERED, Color.BLUE, true);\n        MapConnection sanfrancisco_mexicocity = new MapConnection(san_francisco, mexico_city, 30, Color.ORANGERED, Color.BLUE, true);\n        MapConnection sanfrancisco_santiago   = new MapConnection(san_francisco, santiago_de_chile, 70, Color.ORANGERED, Color.BLUE, true);\n\n\n        animatedConnection = new MapConnection(berlin, christchurch, 1, Color.CRIMSON);\n        animatedConnection.setLineWidth(5);\n\n        //worldMap.addMapConnections(sanfrancisco_mumbai, sanfrancisco_abudabi, sanfrancisco_newyork, sanfrancisco_mexicocity, sanfrancisco_santiago);\n    }\n\n    @Override public void start(Stage stage) {\n        StackPane pane = new StackPane(worldMap);\n\n        Scene scene = new Scene(pane);\n\n        stage.setTitle(\"Worldmap Connections\");\n        stage.setScene(scene);\n        stage.show();\n\n        Image plane = new Image(WorldmapConnectionsTest.class.getResourceAsStream(\"plane.png\"));\n        pane.setOnMousePressed(e -> worldMap.animateImageAlongConnection(plane, animatedConnection));\n    }\n\n    @Override public void stop() {\n        System.exit(0);\n    }\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n}", "item_id": 0, "repo": "markus-olbrich/charts", "file": "src/test/java/eu/hansolo/fx/charts/WorldmapConnectionsTest.java", "last_update_at": "2022-03-30T17:38:30+00:00", "question_id": "c279024e4dc6e942f3a284a3279b9989d23b7c49_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class WorldmapConnectionsTest extends Application {\n    private static final  Random RND = new Random();\n    private World         worldMap;\n    private MapConnection animatedConnection;\n    @Override public void init() {\n        worldMap = WorldBuilder.create()\n                               .resolution(Resolution.HI_RES)\n                               .zoomEnabled(true)\n                               .hoverEnabled(false)\n                               .selectionEnabled(false)\n                               .backgroundColor(Color.WHITE)\n                               .fillColor(Color.LIGHTGRAY)\n                               .connectionWidth(1)\n                               .weightedMapPoints(WeightedMapPoints.NONE)\n                               .weightedMapConnections(false)\n                               .arrowsVisible(false)\n                               .drawImagePath(true)\n                               .mapPointTextVisible(true)\n                               .textColor(Color.BLACK)\n                               .build();\n        MapPoint calgary           = new MapPoint(\"Calgary\", Color.RED,51.08299176,-114.0799982);\n        MapPoint san_francisco     = new MapPoint(\"San Francisco\", Color.BLUE, 37.74000775,-122.4599777);\n        MapPoint new_york          = new MapPoint(\"New York\", Color.BLUE,40.74997906,-73.98001693);\n        MapPoint chicago           = new MapPoint(\"Chicago\", Color.BLUE,41.82999066,-87.75005497);\n        MapPoint denver            = new MapPoint(\"Denver\",Color.BLUE, 39.73918805,-104.984016);\n        MapPoint mexico_city       = new MapPoint(\"Mexico City\",Color.GREEN, 19.44244244,-99.1309882);\n        MapPoint buenos_aires      = new MapPoint(\"Buenos Aires\", Color.LIGHTBLUE, -34.60250161,-58.39753137);\n        MapPoint santiago_de_chile = new MapPoint(\"Santiago de Chile\", Color.BLUE,-33.45001382,-70.66704085);\n        MapPoint sao_paulo         = new MapPoint(\"Sao Paulo\", Color.GREEN, -23.55867959,-46.62501998);\n        MapPoint berlin            = new MapPoint(\"Berlin\", Color.DARKORANGE, 52.52181866, 13.40154862);\n        MapPoint paris             = new MapPoint(\"Paris\", Color.DARKBLUE, 48.86669293,2.333335326);\n        MapPoint madrid            = new MapPoint(\"Madrid\", Color.YELLOW,40.40002626,-3.683351686);\n        MapPoint johannesburg      = new MapPoint(\"Johannesburg\", Color.BROWN,-26.17004474,28.03000972);\n        MapPoint casablanca        = new MapPoint(\"Casablanca\", Color.SADDLEBROWN,33.59997622,-7.616367433);\n        MapPoint tunis             = new MapPoint(\"Tunis\", Color.DARKGREEN,36.80277814,10.1796781);\n        MapPoint alexandria        = new MapPoint(\"Alexandria\", Color.BLACK,31.20001935,29.94999589);\n        MapPoint nairobi           = new MapPoint(\"Nairobi\", Color.LIGHTBLUE,-1.283346742,36.81665686);\n        MapPoint abidjan           = new MapPoint(\"Abidjan\", Color.IVORY,5.319996967,-4.04004826);\n        MapPoint moscow            = new MapPoint(\"Moscow\", Color.RED,55.75216412,37.61552283);\n        MapPoint novosibirsk       = new MapPoint(\"Novosibirsk\", Color.RED,55.02996014,82.96004187);\n        MapPoint magadan           = new MapPoint(\"Magadan\", Color.RED,59.57497988,150.8100089);\n        MapPoint abu_dabi          = new MapPoint(\"Abu Dhabi\", Color.GOLD, 24.46668357,54.36659338);\n        MapPoint mumbai            = new MapPoint(\"Mumbai\", Color.GOLD, 19.01699038,72.8569893);\n        MapPoint hyderabad         = new MapPoint(\"Hyderabad\", Color.GOLD,17.39998313,78.47995357);\n        MapPoint beijing           = new MapPoint(\"Beijing\", Color.DARKRED,39.92889223,116.3882857);\n        MapPoint chongqing          = new MapPoint(\"Chongqing\", Color.DARKRED,29.56497703,106.5949816);\n        MapPoint hong_kong         = new MapPoint(\"Hong Kong\", Color.DARKRED,22.3049809,114.1850093);\n        MapPoint singapore         = new MapPoint(\"Singapore\", Color.CRIMSON, 1.293033466,103.8558207);\n        MapPoint tokio             = new MapPoint(\"Tokio\",Color.RED, 35.652832,139.839478);\n        MapPoint sydney            = new MapPoint(\"Sydney\", Color.BLUE, -33.865143, 151.209900);\n        MapPoint perth             = new MapPoint(\"Perth\", Color.BLUE, -31.95501463,115.8399987);\n        MapPoint christchurch      = new MapPoint(\"Christchurch\", Color.BLUE, -43.53503131,172.6300207);\n        List<MapPoint> northAmerica = List.of(calgary, san_francisco, chicago, new_york, denver);\n        List<MapPoint> southAmerica = List.of(mexico_city, buenos_aires, santiago_de_chile, sao_paulo);\n        List<MapPoint> europe       = List.of(madrid, paris, berlin);\n        List<MapPoint> afrika       = List.of(johannesburg, casablanca, tunis, alexandria, nairobi, abidjan);\n        List<MapPoint> russia       = List.of(moscow, novosibirsk, magadan);\n        List<MapPoint> india        = List.of(abu_dabi, mumbai, hyderabad);\n        List<MapPoint> asia         = List.of(beijing, hong_kong, singapore, tokio, chongqing);\n        List<MapPoint> australia    = List.of(sydney, perth, christchurch);\n        worldMap.addMapPoints(berlin, paris, san_francisco, abu_dabi, new_york, chicago, denver, sao_paulo, madrid, calgary,\n                              mexico_city, buenos_aires, santiago_de_chile, johannesburg, moscow, novosibirsk, magadan,\n                              mumbai, beijing, hong_kong, sydney, christchurch, tokio, singapore, casablanca, tunis, alexandria, nairobi,\n                              abidjan, hyderabad, chongqing, perth);\n        /*\n        northAmerica.forEach(mapPoint -> {\n            worldMap.addMapConnections(new MapConnection(berlin, mapPoint, RND.nextInt(130) + 10, berlin.getFill(), Color.ORANGERED, true));\n        });\n        asia.forEach(mapPoint -> {\n            worldMap.addMapConnections(new MapConnection(berlin, mapPoint, RND.nextInt(130) + 10, berlin.getFill(), Color.ORANGERED, true));\n        });\n        australia.forEach(mapPoint -> {\n            worldMap.addMapConnections(new MapConnection(beijing, mapPoint, RND.nextInt(130) + 10, beijing.getFill(), Color.PURPLE, true));\n            worldMap.addMapConnections(new MapConnection(hong_kong, mapPoint, RND.nextInt(130) + 10, beijing.getFill(), Color.PURPLE, true));\n        });\n        europe.forEach(mapPoint -> {\n            worldMap.addMapConnections(new MapConnection(johannesburg, mapPoint, RND.nextInt(130) + 10, johannesburg.getFill(), Color.ORANGE, true));\n        });\n        southAmerica.forEach(mapPoint -> {\n            worldMap.addMapConnections(new MapConnection(johannesburg, mapPoint, RND.nextInt(130) + 10, johannesburg.getFill(), Color.ORANGE, true));\n        });\n        */\n        MapConnection sanfrancisco_mumbai     = new MapConnection(san_francisco, mumbai, 90, Color.ORANGERED, Color.BLUE, true);\n        MapConnection sanfrancisco_newyork    = new MapConnection(san_francisco, new_york, 100, Color.ORANGERED, Color.BLUE, true);\n        MapConnection sanfrancisco_abudabi    = new MapConnection(san_francisco, abu_dabi, 60, Color.ORANGERED, Color.BLUE, true);\n        MapConnection sanfrancisco_mexicocity = new MapConnection(san_francisco, mexico_city, 30, Color.ORANGERED, Color.BLUE, true);\n        MapConnection sanfrancisco_santiago   = new MapConnection(san_francisco, santiago_de_chile, 70, Color.ORANGERED, Color.BLUE, true);\n        animatedConnection = new MapConnection(berlin, christchurch, 1, Color.CRIMSON);\n        animatedConnection.setLineWidth(5);\n        //worldMap.addMapConnections(sanfrancisco_mumbai, sanfrancisco_abudabi, sanfrancisco_newyork, sanfrancisco_mexicocity, sanfrancisco_santiago);\n    }\n    @Override public void start(Stage stage) {\n        StackPane pane = new StackPane(worldMap);\n        Scene scene = new Scene(pane);\n        stage.setTitle(\"Worldmap Connections\");\n        stage.setScene(scene);\n        stage.show();\n        Image plane = new Image(WorldmapConnectionsTest.class.getResourceAsStream(\"plane.png\"));\n        pane.setOnMousePressed(e -> worldMap.animateImageAlongConnection(plane, animatedConnection));\n    }\n    @Override public void stop() {\n        System.exit(0);\n    }\n    public static void main(String[] args) {\n        launch(args);\n    }\n"]], "pred": {"ppl": 2.765789270401001, "ppl_lower": 2.840237617492676, "ppl/lowercase_ppl": -1.0261093012279532, "ppl/zlib": 0.00045538318919308623, "Min_5.0% Prob": 6.272602530086742, "Min_10.0% Prob": 4.848112529399348, "Min_20.0% Prob": 3.662174279783286, "Min_30.0% Prob": 3.071796378279044, "Min_40.0% Prob": 2.494168604498679, "Min_50.0% Prob": 2.028430296935564, "Min_60.0% Prob": 1.6961365203140684}}
{"hexsha": "553ac2961251b17fe305cb3a660f476888ad224f", "ext": "java", "lang": "Java", "content": "public class PooledExecutorWithDMStats extends ThreadPoolExecutor {\n\n  private final PoolStatHelper poolStatHelper;\n\n  private final ThreadsMonitoring threadsMonitoring;\n\n  /**\n   * Used to buffer up tasks that would be have been rejected. Only used (i.e. non-null) if\n   * constructor queue is not a SynchronousQueue.\n   */\n  private BlockingQueue<Runnable> blockingWorkQueue;\n\n  /**\n   * Used to consume items off the bufferQueue and put them into the pools synchronous queue. Only\n   * used (i.e. non-null) if constructor queue is not a SynchronousQueue.\n   */\n  private Thread bufferConsumer;\n\n  /**\n   * Create a new pool that uses the supplied Channel for queuing, and with all default parameter\n   * settings except for pool size.\n   **/\n  public PooledExecutorWithDMStats(int poolSize, long keepAliveTime, TimeUnit unit,\n      BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, PoolStatHelper poolStatHelper,\n      ThreadsMonitoring threadsMonitoring) {\n    this(poolSize, keepAliveTime, unit, getSynchronousQueue(workQueue), threadFactory,\n        newRejectedExecutionHandler(workQueue), poolStatHelper, threadsMonitoring);\n\n    if (!(workQueue instanceof SynchronousQueue)) {\n      blockingWorkQueue = workQueue;\n      // create a thread that takes from bufferQueue and puts into result\n      final BlockingQueue<Runnable> takeQueue = workQueue;\n      final BlockingQueue<Runnable> putQueue = getQueue();\n      Runnable r = () -> {\n        try {\n          for (;;) {\n            SystemFailure.checkFailure();\n            Runnable job = takeQueue.take();\n            putQueue.put(job);\n          }\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          // this thread is being shutdown so just return;\n        }\n      };\n      bufferConsumer = threadFactory.newThread(r);\n      bufferConsumer.start();\n    }\n  }\n\n  /**\n   * Create a new pool\n   */\n  public PooledExecutorWithDMStats(int poolSize, long keepAliveTime, TimeUnit unit,\n      SynchronousQueue<Runnable> workQueue, ThreadFactory threadFactory,\n      RejectedExecutionHandler rejectedExecutionHandler, PoolStatHelper poolStatHelper,\n      ThreadsMonitoring threadsMonitoring) {\n    super(getCorePoolSize(poolSize), poolSize, keepAliveTime, unit, workQueue, threadFactory,\n        rejectedExecutionHandler);\n\n    this.poolStatHelper = poolStatHelper;\n    this.threadsMonitoring = threadsMonitoring;\n  }\n\n  @Override\n  public void shutdown() {\n    try {\n      super.shutdown();\n    } finally {\n      terminated();\n    }\n  }\n\n  @Override\n  protected void terminated() {\n    if (bufferConsumer != null) {\n      bufferConsumer.interrupt();\n    }\n    super.terminated();\n  }\n\n  @Override\n  public List<Runnable> shutdownNow() {\n    terminated();\n    List<Runnable> l = super.shutdownNow();\n    if (blockingWorkQueue != null) {\n      blockingWorkQueue.drainTo(l);\n    }\n    return l;\n  }\n\n  @Override\n  protected void beforeExecute(Thread t, Runnable r) {\n    if (poolStatHelper != null) {\n      poolStatHelper.startJob();\n    }\n    if (threadsMonitoring != null) {\n      threadsMonitoring.startMonitor(ThreadsMonitoring.Mode.PooledExecutor);\n    }\n  }\n\n  @Override\n  protected void afterExecute(Runnable r, Throwable ex) {\n    if (poolStatHelper != null) {\n      poolStatHelper.endJob();\n    }\n    if (threadsMonitoring != null) {\n      threadsMonitoring.endMonitor();\n    }\n  }\n\n  private static int getCorePoolSize(int maxSize) {\n    if (maxSize == Integer.MAX_VALUE) {\n      return 0;\n    }\n    return 1;\n  }\n\n  /**\n   * This handler does a put which will just wait until the queue has room.\n   */\n  public static class BlockHandler implements RejectedExecutionHandler {\n    @Override\n    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n      if (executor.isShutdown()) {\n        throw new RejectedExecutionException(\"executor has been shutdown\");\n      }\n      try {\n        executor.getQueue().put(r);\n      } catch (InterruptedException ie) {\n        Thread.currentThread().interrupt();\n        throw new RejectedExecutionException(\"interrupted\", ie);\n      }\n    }\n  }\n  /**\n   * This handler fronts a synchronous queue, that is owned by the parent ThreadPoolExecutor, with a\n   * the\n   * client supplied BlockingQueue that supports storage (the buffer queue). A dedicated thread is\n   * used to consume off the buffer queue and put into the synchronous queue.\n   */\n  public static class BufferHandler implements RejectedExecutionHandler {\n    @Override\n    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n      if (executor.isShutdown()) {\n        throw new RejectedExecutionException(\"executor has been shutdown\");\n      }\n      try {\n        PooledExecutorWithDMStats pool = (PooledExecutorWithDMStats) executor;\n        pool.blockingWorkQueue.put(r);\n      } catch (InterruptedException ie) {\n        Thread.currentThread().interrupt();\n        throw new RejectedExecutionException(\"interrupted\", ie);\n      }\n    }\n  }\n\n  private static SynchronousQueue<Runnable> getSynchronousQueue(BlockingQueue<Runnable> q) {\n    if (q instanceof SynchronousQueue) {\n      return (SynchronousQueue<Runnable>) q;\n    }\n    return new SynchronousQueue<>();\n  }\n\n  private static RejectedExecutionHandler newRejectedExecutionHandler(BlockingQueue<Runnable> q) {\n    if (q instanceof SynchronousQueue) {\n      return new CallerRunsPolicy();\n    }\n    // create a thread that takes from bufferQueue and puts into result\n    return new BufferHandler();\n  }\n}", "item_id": 0, "repo": "mhansonp/geode", "file": "geode-core/src/main/java/org/apache/geode/distributed/internal/PooledExecutorWithDMStats.java", "last_update_at": "2022-03-30T09:55:23+00:00", "question_id": "553ac2961251b17fe305cb3a660f476888ad224f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PooledExecutorWithDMStats extends ThreadPoolExecutor {\n  private final PoolStatHelper poolStatHelper;\n  private final ThreadsMonitoring threadsMonitoring;\n  /**\n   * Used to buffer up tasks that would be have been rejected. Only used (i.e. non-null) if\n   * constructor queue is not a SynchronousQueue.\n   */\n  private BlockingQueue<Runnable> blockingWorkQueue;\n  /**\n   * Used to consume items off the bufferQueue and put them into the pools synchronous queue. Only\n   * used (i.e. non-null) if constructor queue is not a SynchronousQueue.\n   */\n  private Thread bufferConsumer;\n  /**\n   * Create a new pool that uses the supplied Channel for queuing, and with all default parameter\n   * settings except for pool size.\n   **/\n  public PooledExecutorWithDMStats(int poolSize, long keepAliveTime, TimeUnit unit,\n      BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, PoolStatHelper poolStatHelper,\n      ThreadsMonitoring threadsMonitoring) {\n    this(poolSize, keepAliveTime, unit, getSynchronousQueue(workQueue), threadFactory,\n        newRejectedExecutionHandler(workQueue), poolStatHelper, threadsMonitoring);\n    if (!(workQueue instanceof SynchronousQueue)) {\n      blockingWorkQueue = workQueue;\n      // create a thread that takes from bufferQueue and puts into result\n      final BlockingQueue<Runnable> takeQueue = workQueue;\n      final BlockingQueue<Runnable> putQueue = getQueue();\n      Runnable r = () -> {\n        try {\n          for (;;) {\n            SystemFailure.checkFailure();\n            Runnable job = takeQueue.take();\n            putQueue.put(job);\n          }\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          // this thread is being shutdown so just return;\n        }\n      };\n      bufferConsumer = threadFactory.newThread(r);\n      bufferConsumer.start();\n    }\n  }\n  /**\n   * Create a new pool\n   */\n  public PooledExecutorWithDMStats(int poolSize, long keepAliveTime, TimeUnit unit,\n      SynchronousQueue<Runnable> workQueue, ThreadFactory threadFactory,\n      RejectedExecutionHandler rejectedExecutionHandler, PoolStatHelper poolStatHelper,\n      ThreadsMonitoring threadsMonitoring) {\n    super(getCorePoolSize(poolSize), poolSize, keepAliveTime, unit, workQueue, threadFactory,\n        rejectedExecutionHandler);\n    this.poolStatHelper = poolStatHelper;\n    this.threadsMonitoring = threadsMonitoring;\n  }\n  @Override\n  public void shutdown() {\n    try {\n      super.shutdown();\n    } finally {\n      terminated();\n    }\n  }\n  @Override\n  protected void terminated() {\n    if (bufferConsumer != null) {\n      bufferConsumer.interrupt();\n    }\n    super.terminated();\n  }\n  @Override\n  public List<Runnable> shutdownNow() {\n    terminated();\n    List<Runnable> l = super.shutdownNow();\n    if (blockingWorkQueue != null) {\n      blockingWorkQueue.drainTo(l);\n    }\n    return l;\n  }\n  @Override\n  protected void beforeExecute(Thread t, Runnable r) {\n    if (poolStatHelper != null) {\n      poolStatHelper.startJob();\n    }\n    if (threadsMonitoring != null) {\n      threadsMonitoring.startMonitor(ThreadsMonitoring.Mode.PooledExecutor);\n    }\n  }\n  @Override\n  protected void afterExecute(Runnable r, Throwable ex) {\n    if (poolStatHelper != null) {\n      poolStatHelper.endJob();\n    }\n    if (threadsMonitoring != null) {\n      threadsMonitoring.endMonitor();\n    }\n  }\n  private static int getCorePoolSize(int maxSize) {\n    if (maxSize == Integer.MAX_VALUE) {\n      return 0;\n    }\n    return 1;\n  }\n  /**\n   * This handler does a put which will just wait until the queue has room.\n   */\n  public static class BlockHandler implements RejectedExecutionHandler {\n    @Override\n    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n      if (executor.isShutdown()) {\n        throw new RejectedExecutionException(\"executor has been shutdown\");\n      }\n      try {\n        executor.getQueue().put(r);\n      } catch (InterruptedException ie) {\n        Thread.currentThread().interrupt();\n        throw new RejectedExecutionException(\"interrupted\", ie);\n      }\n    }\n  }\n  /**\n   * This handler fronts a synchronous queue, that is owned by the parent ThreadPoolExecutor, with a\n   * the\n   * client supplied BlockingQueue that supports storage (the buffer queue). A dedicated thread is\n   * used to consume off the buffer queue and put into the synchronous queue.\n   */\n  public static class BufferHandler implements RejectedExecutionHandler {\n    @Override\n    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n      if (executor.isShutdown()) {\n        throw new RejectedExecutionException(\"executor has been shutdown\");\n      }\n      try {\n        PooledExecutorWithDMStats pool = (PooledExecutorWithDMStats) executor;\n        pool.blockingWorkQueue.put(r);\n      } catch (InterruptedException ie) {\n        Thread.currentThread().interrupt();\n        throw new RejectedExecutionException(\"interrupted\", ie);\n      }\n    }\n  }\n  private static SynchronousQueue<Runnable> getSynchronousQueue(BlockingQueue<Runnable> q) {\n    if (q instanceof SynchronousQueue) {\n      return (SynchronousQueue<Runnable>) q;\n    }\n    return new SynchronousQueue<>();\n  }\n  private static RejectedExecutionHandler newRejectedExecutionHandler(BlockingQueue<Runnable> q) {\n    if (q instanceof SynchronousQueue) {\n      return new CallerRunsPolicy();\n    }\n    // create a thread that takes from bufferQueue and puts into result\n    return new BufferHandler();\n  }\n"]], "pred": {"ppl": 1.8674497604370117, "ppl_lower": 2.0600481033325195, "ppl/lowercase_ppl": -1.1571561409675875, "ppl/zlib": 0.0004364596335577974, "Min_5.0% Prob": 6.423014500561883, "Min_10.0% Prob": 4.680503291242263, "Min_20.0% Prob": 2.952227537538491, "Min_30.0% Prob": 2.0626268655889564, "Min_40.0% Prob": 1.5567755835736512, "Min_50.0% Prob": 1.2491923564782552, "Min_60.0% Prob": 1.0420657889727583}}
{"hexsha": "bb29224afaba7312d962acf2a9b29cd78269411e", "ext": "java", "lang": "Java", "content": "class DiscoveryServerControllerTests {\n\n\tprivate static final KubernetesServiceInstance serviceAInstance1 = new KubernetesServiceInstance(\"serviceAInstance1\",\n\t\t\"serviceAInstance1\", \"2.2.2.2\", 8080, new HashMap<>(), false, \"namespace1\", null);\n\n\tprivate static final KubernetesServiceInstance serviceAInstance2 = new KubernetesServiceInstance(\"serviceAInstance2\",\n\t\t\"serviceAInstance2\", \"2.2.2.2\", 8080, new HashMap<>(), false, \"namespace1\", null);\n\n\tprivate static final KubernetesServiceInstance serviceAInstance3 = new KubernetesServiceInstance(\"serviceAInstance3\",\n\t\t\"serviceAInstance3\", \"2.2.2.2\", 8080, new HashMap<>(), false, \"namespace2\", null);\n\n\tprivate static final KubernetesServiceInstance serviceBInstance1 = new KubernetesServiceInstance(\"serviceBInstance1\",\n\t\t\"serviceBInstance1\", \"2.2.2.2\", 8080, new HashMap<>(), false, \"namespace1\", null);\n\n\tprivate static final KubernetesServiceInstance serviceCInstance1 = new KubernetesServiceInstance(\"serviceCInstance1\",\n\t\t\"serviceCInstance1\", \"2.2.2.2\", 8080, new HashMap<>(), false, \"namespace2\", null);\n\n\tprivate static DiscoveryServerController.Service serviceA = new DiscoveryServerController.Service();\n\tprivate static DiscoveryServerController.Service serviceB = new DiscoveryServerController.Service();\n\tprivate static DiscoveryServerController.Service serviceC = new DiscoveryServerController.Service();\n\n\tprivate static KubernetesInformerReactiveDiscoveryClient discoveryClient;\n\n\t@BeforeAll\n\tstatic void beforeAll() {\n\t\tFlux<String> services = Flux.just(\"serviceA\", \"serviceB\", \"serviceC\");\n\n\t\tList<ServiceInstance> serviceAInstanceList = new ArrayList<>();\n\t\tserviceAInstanceList.add(serviceAInstance1);\n\t\tserviceAInstanceList.add(serviceAInstance2);\n\t\tserviceAInstanceList.add(serviceAInstance3);\n\n\t\tFlux<ServiceInstance> serviceAInstances = Flux.fromIterable(serviceAInstanceList);\n\n\t\tList<ServiceInstance> serviceBInstanceList = Collections.singletonList(serviceBInstance1);\n\t\tFlux<ServiceInstance> serviceBInstances = Flux.fromIterable(serviceBInstanceList);\n\n\t\tList<ServiceInstance> serviceCInstanceList = Collections.singletonList(serviceCInstance1);\n\t\tFlux<ServiceInstance> serviceCInstances = Flux.fromIterable(serviceCInstanceList);\n\n\t\tdiscoveryClient = mock(KubernetesInformerReactiveDiscoveryClient.class);\n\t\twhen(discoveryClient.getServices()).thenReturn(services);\n\t\twhen(discoveryClient.getInstances(eq(\"serviceA\"))).thenReturn(serviceAInstances);\n\t\twhen(discoveryClient.getInstances(eq(\"serviceB\"))).thenReturn(serviceBInstances);\n\t\twhen(discoveryClient.getInstances(eq(\"serviceC\"))).thenReturn(serviceCInstances);\n\t\twhen(discoveryClient.getInstances(eq(\"serviceD\"))).thenReturn(Flux.empty());\n\n\t\tserviceA.setName(\"serviceA\");\n\t\tserviceA.setServiceInstances(serviceAInstanceList);\n\n\t\tserviceB.setName(\"serviceB\");\n\t\tserviceB.setServiceInstances(serviceBInstanceList);\n\n\t\tserviceC.setName(\"serviceC\");\n\t\tserviceC.setServiceInstances(serviceCInstanceList);\n\t}\n\n\n\n\t@Test\n\tvoid apps() {\n\t\tDiscoveryServerController controller = new DiscoveryServerController(discoveryClient);\n\t\tStepVerifier.create(controller.apps()).expectNext(serviceA, serviceB, serviceC).verifyComplete();\n\t}\n\n\t@Test\n\tvoid appInstances() {\n\t\tDiscoveryServerController controller = new DiscoveryServerController(discoveryClient);\n\t\tStepVerifier.create(controller.appInstances(\"serviceA\")).expectNext(serviceAInstance1, serviceAInstance2, serviceAInstance3).verifyComplete();\n\t\tStepVerifier.create(controller.appInstances(\"serviceB\")).expectNext(serviceBInstance1).verifyComplete();\n\t\tStepVerifier.create(controller.appInstances(\"serviceC\")).expectNext(serviceCInstance1).verifyComplete();\n\t\tStepVerifier.create(controller.appInstances(\"serviceD\")).expectNextCount(0).verifyComplete();\n\t}\n\n\t@Test\n\tvoid appInstance() {\n\t\tDiscoveryServerController controller = new DiscoveryServerController(discoveryClient);\n\t\tStepVerifier.create(controller.appInstance(\"serviceA\", \"serviceAInstance2\")).expectNext(serviceAInstance2).verifyComplete();\n\t\tStepVerifier.create(controller.appInstance(\"serviceB\", \"doesnotexist\")).expectNextCount(0).verifyComplete();\n\t}\n}", "item_id": 0, "repo": "isikerhan/spring-cloud-kubernetes", "file": "spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-discoveryserver/src/main/test/java/org/springframewok/cloud/kubernetes/discoveryserver/DiscoveryServerControllerTests.java", "last_update_at": "2022-03-31T02:54:57+00:00", "question_id": "bb29224afaba7312d962acf2a9b29cd78269411e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class DiscoveryServerControllerTests {\n\tprivate static final KubernetesServiceInstance serviceAInstance1 = new KubernetesServiceInstance(\"serviceAInstance1\",\n\t\t\"serviceAInstance1\", \"2.2.2.2\", 8080, new HashMap<>(), false, \"namespace1\", null);\n\tprivate static final KubernetesServiceInstance serviceAInstance2 = new KubernetesServiceInstance(\"serviceAInstance2\",\n\t\t\"serviceAInstance2\", \"2.2.2.2\", 8080, new HashMap<>(), false, \"namespace1\", null);\n\tprivate static final KubernetesServiceInstance serviceAInstance3 = new KubernetesServiceInstance(\"serviceAInstance3\",\n\t\t\"serviceAInstance3\", \"2.2.2.2\", 8080, new HashMap<>(), false, \"namespace2\", null);\n\tprivate static final KubernetesServiceInstance serviceBInstance1 = new KubernetesServiceInstance(\"serviceBInstance1\",\n\t\t\"serviceBInstance1\", \"2.2.2.2\", 8080, new HashMap<>(), false, \"namespace1\", null);\n\tprivate static final KubernetesServiceInstance serviceCInstance1 = new KubernetesServiceInstance(\"serviceCInstance1\",\n\t\t\"serviceCInstance1\", \"2.2.2.2\", 8080, new HashMap<>(), false, \"namespace2\", null);\n\tprivate static DiscoveryServerController.Service serviceA = new DiscoveryServerController.Service();\n\tprivate static DiscoveryServerController.Service serviceB = new DiscoveryServerController.Service();\n\tprivate static DiscoveryServerController.Service serviceC = new DiscoveryServerController.Service();\n\tprivate static KubernetesInformerReactiveDiscoveryClient discoveryClient;\n\t@BeforeAll\n\tstatic void beforeAll() {\n\t\tFlux<String> services = Flux.just(\"serviceA\", \"serviceB\", \"serviceC\");\n\t\tList<ServiceInstance> serviceAInstanceList = new ArrayList<>();\n\t\tserviceAInstanceList.add(serviceAInstance1);\n\t\tserviceAInstanceList.add(serviceAInstance2);\n\t\tserviceAInstanceList.add(serviceAInstance3);\n\t\tFlux<ServiceInstance> serviceAInstances = Flux.fromIterable(serviceAInstanceList);\n\t\tList<ServiceInstance> serviceBInstanceList = Collections.singletonList(serviceBInstance1);\n\t\tFlux<ServiceInstance> serviceBInstances = Flux.fromIterable(serviceBInstanceList);\n\t\tList<ServiceInstance> serviceCInstanceList = Collections.singletonList(serviceCInstance1);\n\t\tFlux<ServiceInstance> serviceCInstances = Flux.fromIterable(serviceCInstanceList);\n\t\tdiscoveryClient = mock(KubernetesInformerReactiveDiscoveryClient.class);\n\t\twhen(discoveryClient.getServices()).thenReturn(services);\n\t\twhen(discoveryClient.getInstances(eq(\"serviceA\"))).thenReturn(serviceAInstances);\n\t\twhen(discoveryClient.getInstances(eq(\"serviceB\"))).thenReturn(serviceBInstances);\n\t\twhen(discoveryClient.getInstances(eq(\"serviceC\"))).thenReturn(serviceCInstances);\n\t\twhen(discoveryClient.getInstances(eq(\"serviceD\"))).thenReturn(Flux.empty());\n\t\tserviceA.setName(\"serviceA\");\n\t\tserviceA.setServiceInstances(serviceAInstanceList);\n\t\tserviceB.setName(\"serviceB\");\n\t\tserviceB.setServiceInstances(serviceBInstanceList);\n\t\tserviceC.setName(\"serviceC\");\n\t\tserviceC.setServiceInstances(serviceCInstanceList);\n\t}\n\t@Test\n\tvoid apps() {\n\t\tDiscoveryServerController controller = new DiscoveryServerController(discoveryClient);\n\t\tStepVerifier.create(controller.apps()).expectNext(serviceA, serviceB, serviceC).verifyComplete();\n\t}\n\t@Test\n\tvoid appInstances() {\n\t\tDiscoveryServerController controller = new DiscoveryServerController(discoveryClient);\n\t\tStepVerifier.create(controller.appInstances(\"serviceA\")).expectNext(serviceAInstance1, serviceAInstance2, serviceAInstance3).verifyComplete();\n\t\tStepVerifier.create(controller.appInstances(\"serviceB\")).expectNext(serviceBInstance1).verifyComplete();\n\t\tStepVerifier.create(controller.appInstances(\"serviceC\")).expectNext(serviceCInstance1).verifyComplete();\n\t\tStepVerifier.create(controller.appInstances(\"serviceD\")).expectNextCount(0).verifyComplete();\n\t}\n\t@Test\n\tvoid appInstance() {\n\t\tDiscoveryServerController controller = new DiscoveryServerController(discoveryClient);\n\t\tStepVerifier.create(controller.appInstance(\"serviceA\", \"serviceAInstance2\")).expectNext(serviceAInstance2).verifyComplete();\n\t\tStepVerifier.create(controller.appInstance(\"serviceB\", \"doesnotexist\")).expectNextCount(0).verifyComplete();\n\t}\n"]], "pred": {"ppl": 1.3523813486099243, "ppl_lower": 1.4908004999160767, "ppl/lowercase_ppl": -1.3228117793211098, "ppl/zlib": 0.00041752005591964885, "Min_5.0% Prob": 4.357470138400209, "Min_10.0% Prob": 2.722068682020786, "Min_20.0% Prob": 1.4835394834186517, "Min_30.0% Prob": 1.0041238535926038, "Min_40.0% Prob": 0.7537596645698972, "Min_50.0% Prob": 0.60395667934608, "Min_60.0% Prob": 0.5036636081570341}}
{"hexsha": "7c43dd937fac5c40d6836f13b06aafc9cd02960e", "ext": "java", "lang": "Java", "content": "public class YearAddFunction\n        extends BaseFEELFunction {\n\n    public YearAddFunction() {\n        super( \"yearAdd\" );\n    }\n\n    public FEELFnResult<TemporalAccessor> invoke(@ParameterName(\"datestring\") String datetime, @ParameterName( \"years to add\" ) BigDecimal years) {\n        if ( datetime == null ) {\n            return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, \"datestring\", \"cannot be null\" ) );\n        }\n        if ( years == null ) {\n            return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, \"years to add\", \"cannot be null\" ) );\n        }\n\n        try {\n            Object r = null;\n            if( datetime.contains( \"T\" ) ) {\n                r = BuiltInFunctions.getFunction( DateAndTimeFunction.class ).invoke( datetime ).cata( BuiltInType.justNull(), Function.identity() );\n            } else {\n                r = BuiltInFunctions.getFunction( DateFunction.class ).invoke( datetime ).cata( BuiltInType.justNull(), Function.identity() );\n            }\n\n            if ( r != null && r instanceof TemporalAccessor ) {\n                return invoke( (TemporalAccessor) r, years );\n            } else {\n                return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, \"datestring\", \"date-parsing exception\" ) );\n            }\n        } catch ( DateTimeException e ) {\n            return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, \"datestring\", \"date-parsing exception\", e ) );\n        }\n    }\n\n    public FEELFnResult<TemporalAccessor> invoke(@ParameterName(\"datetime\") TemporalAccessor datetime, @ParameterName( \"years to add\" ) BigDecimal years) {\n        if ( datetime == null ) {\n            return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, \"datetime\", \"cannot be null\" ) );\n        }\n        if ( years == null ) {\n            return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, \"years to add\", \"cannot be null\" ) );\n        }\n\n        try {\n            if( datetime instanceof Temporal ) {\n                return FEELFnResult.ofResult( ((Temporal) datetime).plus( years.longValue(), ChronoUnit.YEARS ) );\n            } else {\n                return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, \"datetime\", \"invalid 'date' or 'date and time' parameter\" ) );\n            }\n        } catch ( DateTimeException e ) {\n            return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, \"datetime\", \"invalid 'date' or 'date and time' parameter\", e ) );\n        }\n    }\n\n}", "item_id": 0, "repo": "AnilKumarBejjanki/drools", "file": "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/YearAddFunction.java", "last_update_at": "2022-03-31T19:59:10+00:00", "question_id": "7c43dd937fac5c40d6836f13b06aafc9cd02960e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class YearAddFunction\n        extends BaseFEELFunction {\n    public YearAddFunction() {\n        super( \"yearAdd\" );\n    }\n    public FEELFnResult<TemporalAccessor> invoke(@ParameterName(\"datestring\") String datetime, @ParameterName( \"years to add\" ) BigDecimal years) {\n        if ( datetime == null ) {\n            return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, \"datestring\", \"cannot be null\" ) );\n        }\n        if ( years == null ) {\n            return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, \"years to add\", \"cannot be null\" ) );\n        }\n        try {\n            Object r = null;\n            if( datetime.contains( \"T\" ) ) {\n                r = BuiltInFunctions.getFunction( DateAndTimeFunction.class ).invoke( datetime ).cata( BuiltInType.justNull(), Function.identity() );\n            } else {\n                r = BuiltInFunctions.getFunction( DateFunction.class ).invoke( datetime ).cata( BuiltInType.justNull(), Function.identity() );\n            }\n            if ( r != null && r instanceof TemporalAccessor ) {\n                return invoke( (TemporalAccessor) r, years );\n            } else {\n                return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, \"datestring\", \"date-parsing exception\" ) );\n            }\n        } catch ( DateTimeException e ) {\n            return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, \"datestring\", \"date-parsing exception\", e ) );\n        }\n    }\n    public FEELFnResult<TemporalAccessor> invoke(@ParameterName(\"datetime\") TemporalAccessor datetime, @ParameterName( \"years to add\" ) BigDecimal years) {\n        if ( datetime == null ) {\n            return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, \"datetime\", \"cannot be null\" ) );\n        }\n        if ( years == null ) {\n            return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, \"years to add\", \"cannot be null\" ) );\n        }\n        try {\n            if( datetime instanceof Temporal ) {\n                return FEELFnResult.ofResult( ((Temporal) datetime).plus( years.longValue(), ChronoUnit.YEARS ) );\n            } else {\n                return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, \"datetime\", \"invalid 'date' or 'date and time' parameter\" ) );\n            }\n        } catch ( DateTimeException e ) {\n            return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, \"datetime\", \"invalid 'date' or 'date and time' parameter\", e ) );\n        }\n    }\n"]], "pred": {"ppl": 1.5175611972808838, "ppl_lower": 1.9752706289291382, "ppl/lowercase_ppl": -1.631977839292291, "ppl/zlib": 0.0007241398799233138, "Min_5.0% Prob": 5.761913864953177, "Min_10.0% Prob": 3.692407840490341, "Min_20.0% Prob": 2.0384284415354967, "Min_30.0% Prob": 1.3853429676437716, "Min_40.0% Prob": 1.0428233879253057, "Min_50.0% Prob": 0.8348201311332842, "Min_60.0% Prob": 0.6956895314304925}}
{"hexsha": "7590fff966aa492c3b2ff625b697edc9f74370b3", "ext": "java", "lang": "Java", "content": "public class ScLabelRangesObj extends TestCase {\n    static XSpreadsheetDocument xSheetDoc = null;\n\n    /**\n    * Creates Spreadsheet document.\n    */\n    protected void initialize( TestParameters tParam, PrintWriter log ) {\n        // get a soffice factory object\n        SOfficeFactory SOF = SOfficeFactory.getFactory( (XMultiServiceFactory)tParam.getMSF());\n\n        try {\n            log.println( \"creating a sheetdocument\" );\n            xSheetDoc = SOF.createCalcDoc(null);\n        } catch (com.sun.star.uno.Exception e) {\n            // Some exception occured.FAILED\n            e.printStackTrace( log );\n            throw new StatusException( \"Couldn't create document\", e );\n        }\n    }\n\n    /**\n    * Disposes Spreadsheet document.\n    */\n    protected void cleanup( TestParameters tParam, PrintWriter log ) {\n        log.println( \"    disposing xSheetDoc \" );\n        XComponent oComp = (XComponent)\n            UnoRuntime.queryInterface (XComponent.class, xSheetDoc) ;\n        util.DesktopTools.closeDoc(oComp);\n    }\n\n    /**\n    * Creating a Testenvironment for the interfaces to be tested.\n    * Obtains the value of the property <code>'ColumnLabelRanges'</code>\n    * from the document. The property value is the collection of label ranges.\n    * Adds new label range to the collection using the interface\n    * <code>XLabelRanges</code> that was queried from the property value.\n    * This collection is the instance of the service\n    * <code>com.sun.star.sheet.LabelRanges</code>.\n    * @see com.sun.star.sheet.LabelRanges\n    * @see com.sun.star.sheet.XLabelRanges\n    */\n    public synchronized TestEnvironment createTestEnvironment(\n        TestParameters Param, PrintWriter log) throws StatusException {\n\n        XInterface oObj = null;\n\n        // creation of testobject here\n        // first we write what we are intend to do to log file\n        log.println( \"Creating a test environment\" );\n\n        try {\n            log.println(\"Getting test object \") ;\n            XPropertySet docProps = (XPropertySet)\n                UnoRuntime.queryInterface(XPropertySet.class, xSheetDoc);\n            Object ranges = docProps.getPropertyValue(\"ColumnLabelRanges\");\n            XLabelRanges lRanges = (XLabelRanges)\n                UnoRuntime.queryInterface(XLabelRanges.class, ranges);\n\n            log.println(\"Adding at least one element for ElementAccess interface\");\n            CellRangeAddress aRange2 = new CellRangeAddress((short)0, 0, 1, 0, 6);\n            CellRangeAddress aRange1 = new CellRangeAddress((short)0, 0, 0, 0, 1);\n            lRanges.addNew(aRange1, aRange2);\n\n            oObj = lRanges;\n        } catch (com.sun.star.lang.WrappedTargetException e) {\n            e.printStackTrace(log) ;\n            throw new StatusException(\n                \"Error getting test object from spreadsheet document\",e);\n        } catch (com.sun.star.beans.UnknownPropertyException e) {\n            e.printStackTrace(log) ;\n            throw new StatusException(\n                \"Error getting test object from spreadsheet document\",e);\n        }\n\n        log.println(\"creating a new environment for object\");\n        TestEnvironment tEnv = new TestEnvironment(oObj);\n\n        log.println(\"testing...\");\n\n        return tEnv;\n    } // finish method getTestEnvironment\n\n}", "item_id": 0, "repo": "Grosskopf/openoffice", "file": "main/qadevOOo/java/OOoRunner/src/main/java/mod/_sc/ScLabelRangesObj.java", "last_update_at": "2022-03-30T01:06:03+00:00", "question_id": "7590fff966aa492c3b2ff625b697edc9f74370b3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ScLabelRangesObj extends TestCase {\n    static XSpreadsheetDocument xSheetDoc = null;\n    /**\n    * Creates Spreadsheet document.\n    */\n    protected void initialize( TestParameters tParam, PrintWriter log ) {\n        // get a soffice factory object\n        SOfficeFactory SOF = SOfficeFactory.getFactory( (XMultiServiceFactory)tParam.getMSF());\n        try {\n            log.println( \"creating a sheetdocument\" );\n            xSheetDoc = SOF.createCalcDoc(null);\n        } catch (com.sun.star.uno.Exception e) {\n            // Some exception occured.FAILED\n            e.printStackTrace( log );\n            throw new StatusException( \"Couldn't create document\", e );\n        }\n    }\n    /**\n    * Disposes Spreadsheet document.\n    */\n    protected void cleanup( TestParameters tParam, PrintWriter log ) {\n        log.println( \"    disposing xSheetDoc \" );\n        XComponent oComp = (XComponent)\n            UnoRuntime.queryInterface (XComponent.class, xSheetDoc) ;\n        util.DesktopTools.closeDoc(oComp);\n    }\n    /**\n    * Creating a Testenvironment for the interfaces to be tested.\n    * Obtains the value of the property <code>'ColumnLabelRanges'</code>\n    * from the document. The property value is the collection of label ranges.\n    * Adds new label range to the collection using the interface\n    * <code>XLabelRanges</code> that was queried from the property value.\n    * This collection is the instance of the service\n    * <code>com.sun.star.sheet.LabelRanges</code>.\n    * @see com.sun.star.sheet.LabelRanges\n    * @see com.sun.star.sheet.XLabelRanges\n    */\n    public synchronized TestEnvironment createTestEnvironment(\n        TestParameters Param, PrintWriter log) throws StatusException {\n        XInterface oObj = null;\n        // creation of testobject here\n        // first we write what we are intend to do to log file\n        log.println( \"Creating a test environment\" );\n        try {\n            log.println(\"Getting test object \") ;\n            XPropertySet docProps = (XPropertySet)\n                UnoRuntime.queryInterface(XPropertySet.class, xSheetDoc);\n            Object ranges = docProps.getPropertyValue(\"ColumnLabelRanges\");\n            XLabelRanges lRanges = (XLabelRanges)\n                UnoRuntime.queryInterface(XLabelRanges.class, ranges);\n            log.println(\"Adding at least one element for ElementAccess interface\");\n            CellRangeAddress aRange2 = new CellRangeAddress((short)0, 0, 1, 0, 6);\n            CellRangeAddress aRange1 = new CellRangeAddress((short)0, 0, 0, 0, 1);\n            lRanges.addNew(aRange1, aRange2);\n            oObj = lRanges;\n        } catch (com.sun.star.lang.WrappedTargetException e) {\n            e.printStackTrace(log) ;\n            throw new StatusException(\n                \"Error getting test object from spreadsheet document\",e);\n        } catch (com.sun.star.beans.UnknownPropertyException e) {\n            e.printStackTrace(log) ;\n            throw new StatusException(\n                \"Error getting test object from spreadsheet document\",e);\n        }\n        log.println(\"creating a new environment for object\");\n        TestEnvironment tEnv = new TestEnvironment(oObj);\n        log.println(\"testing...\");\n        return tEnv;\n    } // finish method getTestEnvironment\n"]], "pred": {"ppl": 1.5690221786499023, "ppl_lower": 2.36580753326416, "ppl/lowercase_ppl": -1.911675940608876, "ppl/zlib": 0.00041516369509964394, "Min_5.0% Prob": 5.237487841736186, "Min_10.0% Prob": 3.627748437903144, "Min_20.0% Prob": 2.1541860025714743, "Min_30.0% Prob": 1.4883986732386278, "Min_40.0% Prob": 1.1244348664529917, "Min_50.0% Prob": 0.9012215823400765, "Min_60.0% Prob": 0.7514104967492379}}
{"hexsha": "61412ed9ea68eb3c1dc72df816617296bd698e49", "ext": "java", "lang": "Java", "content": "public class DaskTable implements TranslatableTable {\n\t// List of columns (name, column type)\n\tprivate final ArrayList<Pair<String, SqlTypeName>> tableColumns;\n\t// Name of this table\n\tprivate final String name;\n\t// Any statistics information we have\n\tprivate final DaskStatistics statistics;\n\n\t/// Construct a new table with the given name and estimated row count\n\tpublic DaskTable(final String name, final Double rowCount) {\n\t\tthis.name = name;\n\t\tthis.tableColumns = new ArrayList<Pair<String, SqlTypeName>>();\n\t\tthis.statistics = new DaskStatistics(rowCount);\n\t}\n\n\t/// Construct a new table with the given name\n\tpublic DaskTable(final String name) {\n\t\tthis(name, null);\n\t}\n\n\t/// Add a column with the given type\n\tpublic void addColumn(final String columnName, final SqlTypeName columnType) {\n\t\tthis.tableColumns.add(new Pair<>(columnName, columnType));\n\t}\n\n\t/// return the table name\n\tpublic String getTableName() {\n\t\treturn this.name;\n\t}\n\n\t/// calcite method: Get the type of a row of this table (using the type factory)\n\t@Override\n\tpublic RelDataType getRowType(final RelDataTypeFactory relDataTypeFactory) {\n\t\tfinal RelDataTypeFactory.Builder builder = new RelDataTypeFactory.Builder(relDataTypeFactory);\n\t\tfor (final Pair<String, SqlTypeName> column : tableColumns) {\n\t\t\tfinal String name = column.getKey();\n\t\t\tfinal SqlTypeName type = column.getValue();\n\t\t\tbuilder.add(name, relDataTypeFactory.createSqlType(type));\n\t\t\tbuilder.nullable(true);\n\t\t}\n\t\treturn builder.build();\n\t}\n\n\t/// calcite method: statistics of this table (not implemented)\n\t@Override\n\tpublic Statistic getStatistic() {\n\t\treturn this.statistics;\n\t}\n\n\t/// calcite method: the type -> it is a table\n\t@Override\n\tpublic Schema.TableType getJdbcTableType() {\n\t\treturn Schema.TableType.TABLE;\n\t}\n\n\t/// calcite method: it is not rolled up (I think?)\n\t@Override\n\tpublic boolean isRolledUp(final String string) {\n\t\treturn false;\n\t}\n\n\t/// calcite method: no need to implement this, as it is not rolled up\n\t@Override\n\tpublic boolean rolledUpColumnValidInsideAgg(final String string, final SqlCall sc, final SqlNode sn,\n\t\t\tfinal CalciteConnectionConfig ccc) {\n\t\tthrow new AssertionError(\"This should not be called!\");\n\t}\n\n\t@Override\n\tpublic RelNode toRel(ToRelContext context, RelOptTable relOptTable) {\n\t\tRelTraitSet traitSet = context.getCluster().traitSet();\n\t\treturn new LogicalTableScan(context.getCluster(), traitSet, context.getTableHints(), relOptTable);\n\t}\n\n\tprivate final class DaskStatistics implements Statistic {\n\t\tprivate final Double rowCount;\n\n\t\tpublic DaskStatistics(final Double rowCount) {\n\t\t\tthis.rowCount = rowCount;\n\t\t}\n\n\t\t@Override\n\t\tpublic Double getRowCount() {\n\t\t\treturn this.rowCount;\n\t\t}\n\t}\n}", "item_id": 0, "repo": "rjzamora/dask-sql", "file": "planner/src/main/java/com/dask/sql/schema/DaskTable.java", "last_update_at": "2022-03-29T11:28:51+00:00", "question_id": "61412ed9ea68eb3c1dc72df816617296bd698e49_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DaskTable implements TranslatableTable {\n\t// List of columns (name, column type)\n\tprivate final ArrayList<Pair<String, SqlTypeName>> tableColumns;\n\t// Name of this table\n\tprivate final String name;\n\t// Any statistics information we have\n\tprivate final DaskStatistics statistics;\n\t/// Construct a new table with the given name and estimated row count\n\tpublic DaskTable(final String name, final Double rowCount) {\n\t\tthis.name = name;\n\t\tthis.tableColumns = new ArrayList<Pair<String, SqlTypeName>>();\n\t\tthis.statistics = new DaskStatistics(rowCount);\n\t}\n\t/// Construct a new table with the given name\n\tpublic DaskTable(final String name) {\n\t\tthis(name, null);\n\t}\n\t/// Add a column with the given type\n\tpublic void addColumn(final String columnName, final SqlTypeName columnType) {\n\t\tthis.tableColumns.add(new Pair<>(columnName, columnType));\n\t}\n\t/// return the table name\n\tpublic String getTableName() {\n\t\treturn this.name;\n\t}\n\t/// calcite method: Get the type of a row of this table (using the type factory)\n\t@Override\n\tpublic RelDataType getRowType(final RelDataTypeFactory relDataTypeFactory) {\n\t\tfinal RelDataTypeFactory.Builder builder = new RelDataTypeFactory.Builder(relDataTypeFactory);\n\t\tfor (final Pair<String, SqlTypeName> column : tableColumns) {\n\t\t\tfinal String name = column.getKey();\n\t\t\tfinal SqlTypeName type = column.getValue();\n\t\t\tbuilder.add(name, relDataTypeFactory.createSqlType(type));\n\t\t\tbuilder.nullable(true);\n\t\t}\n\t\treturn builder.build();\n\t}\n\t/// calcite method: statistics of this table (not implemented)\n\t@Override\n\tpublic Statistic getStatistic() {\n\t\treturn this.statistics;\n\t}\n\t/// calcite method: the type -> it is a table\n\t@Override\n\tpublic Schema.TableType getJdbcTableType() {\n\t\treturn Schema.TableType.TABLE;\n\t}\n\t/// calcite method: it is not rolled up (I think?)\n\t@Override\n\tpublic boolean isRolledUp(final String string) {\n\t\treturn false;\n\t}\n\t/// calcite method: no need to implement this, as it is not rolled up\n\t@Override\n\tpublic boolean rolledUpColumnValidInsideAgg(final String string, final SqlCall sc, final SqlNode sn,\n\t\t\tfinal CalciteConnectionConfig ccc) {\n\t\tthrow new AssertionError(\"This should not be called!\");\n\t}\n\t@Override\n\tpublic RelNode toRel(ToRelContext context, RelOptTable relOptTable) {\n\t\tRelTraitSet traitSet = context.getCluster().traitSet();\n\t\treturn new LogicalTableScan(context.getCluster(), traitSet, context.getTableHints(), relOptTable);\n\t}\n\tprivate final class DaskStatistics implements Statistic {\n\t\tprivate final Double rowCount;\n\t\tpublic DaskStatistics(final Double rowCount) {\n\t\t\tthis.rowCount = rowCount;\n\t\t}\n\t\t@Override\n\t\tpublic Double getRowCount() {\n\t\t\treturn this.rowCount;\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.8399271965026855, "ppl_lower": 2.457298755645752, "ppl/lowercase_ppl": -1.4745355689789985, "ppl/zlib": 0.0006620260626709984, "Min_5.0% Prob": 6.297145622532542, "Min_10.0% Prob": 4.580240916056805, "Min_20.0% Prob": 2.8427664016384675, "Min_30.0% Prob": 1.9961608294622009, "Min_40.0% Prob": 1.516567351206778, "Min_50.0% Prob": 1.2172905267945615, "Min_60.0% Prob": 1.0155772339322615}}
{"hexsha": "585aac20027ec786ff5d7aaa11c6a7026b2e5a64", "ext": "java", "lang": "Java", "content": "public class JSONLDExtractor extends BaseRDFExtractor {\n\n    private static final ObjectMapper OBJECT_MAPPER = JsonMapper.builder()\n            .enable(JsonReadFeature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER).disable(JsonReadFeature.ALLOW_JAVA_COMMENTS)\n            .disable(JsonReadFeature.ALLOW_MISSING_VALUES).enable(JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS)\n            .enable(JsonReadFeature.ALLOW_LEADING_ZEROS_FOR_NUMBERS).disable(JsonReadFeature.ALLOW_SINGLE_QUOTES)\n            .disable(JsonReadFeature.ALLOW_TRAILING_COMMA).enable(JsonReadFeature.ALLOW_UNESCAPED_CONTROL_CHARS)\n            .enable(JsonReadFeature.ALLOW_UNQUOTED_FIELD_NAMES).disable(JsonReadFeature.ALLOW_YAML_COMMENTS)\n            .enable(StreamReadFeature.IGNORE_UNDEFINED).enable(StreamReadFeature.INCLUDE_SOURCE_IN_LOCATION)\n            .disable(StreamReadFeature.STRICT_DUPLICATE_DETECTION).build();\n\n    /**\n     * @deprecated since 2.4. This extractor has never supported these settings. Use {@link #JSONLDExtractor()} instead.\n     * \n     * @param verifyDataType\n     *            has no effect\n     * @param stopAtFirstError\n     *            has no effect\n     */\n    @Deprecated\n    public JSONLDExtractor(boolean verifyDataType, boolean stopAtFirstError) {\n        super(verifyDataType, stopAtFirstError);\n    }\n\n    public JSONLDExtractor() {\n        super(false, false);\n    }\n\n    @Override\n    public ExtractorDescription getDescription() {\n        return JSONLDExtractorFactory.getDescriptionInstance();\n    }\n\n    @Override\n    public void run(ExtractionParameters extractionParameters, ExtractionContext extractionContext, InputStream in,\n            ExtractionResult extractionResult) throws IOException, ExtractionException {\n        JSONLDJavaSink handler = new JSONLDJavaSink(extractionResult, new Any23ValueFactoryWrapper(\n                SimpleValueFactory.getInstance(), extractionResult, extractionContext.getDefaultLanguage()));\n\n        JsonLdOptions options = new JsonLdOptions(extractionContext.getDocumentIRI().stringValue());\n        options.useNamespaces = true;\n\n        try {\n            Object json = JsonUtils\n                    .fromJsonParser(OBJECT_MAPPER.getFactory().createParser(new JsonCleaningInputStream(in)));\n            JsonLdProcessor.toRDF(json, handler, options);\n        } catch (JsonProcessingException e) {\n            JsonLocation loc = e.getLocation();\n            if (loc == null) {\n                extractionResult.notifyIssue(IssueReport.IssueLevel.FATAL, e.getOriginalMessage(), -1L, -1L);\n            } else {\n                extractionResult.notifyIssue(IssueReport.IssueLevel.FATAL, e.getOriginalMessage(), loc.getLineNr(),\n                        loc.getColumnNr());\n            }\n        } catch (Exception e) {\n            // ANY23-420: jsonld-java can sometimes throw IllegalArgumentException\n            extractionResult.notifyIssue(IssueReport.IssueLevel.FATAL, toString(e), -1, -1);\n        }\n    }\n\n    /* DEPRECATED METHODS */\n\n    /**\n     * @deprecated since 2.4. This extractor has never supported this setting. Do not use.\n     * \n     * @param stopAtFirstError\n     *            has no effect\n     */\n    @Deprecated\n    @Override\n    public void setStopAtFirstError(boolean stopAtFirstError) {\n        super.setStopAtFirstError(stopAtFirstError);\n    }\n\n    /**\n     * @deprecated since 2.4. This extractor has never supported this setting. Do not use.\n     * \n     * @param verifyDataType\n     *            has no effect\n     */\n    @Deprecated\n    @Override\n    public void setVerifyDataType(boolean verifyDataType) {\n        super.setVerifyDataType(verifyDataType);\n    }\n\n    /**\n     * @deprecated since 2.4. This extractor no longer wraps an RDF4J {@link RDFParser}. Do not use this method.\n     * \n     * @param extractionContext\n     *            the extraction context\n     * @param extractionResult\n     *            the extraction result\n     * \n     * @return a {@link RDFParser}\n     */\n    @Deprecated\n    @Override\n    protected RDFParser getParser(ExtractionContext extractionContext, ExtractionResult extractionResult) {\n        return RDFParserFactory.getInstance().getJSONLDParser(isVerifyDataType(), isStopAtFirstError(),\n                extractionContext, extractionResult);\n    }\n\n}", "item_id": 0, "repo": "tjroamer/any23", "file": "core/src/main/java/org/apache/any23/extractor/rdf/JSONLDExtractor.java", "last_update_at": "2022-03-17T04:23:04+00:00", "question_id": "585aac20027ec786ff5d7aaa11c6a7026b2e5a64_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JSONLDExtractor extends BaseRDFExtractor {\n    private static final ObjectMapper OBJECT_MAPPER = JsonMapper.builder()\n            .enable(JsonReadFeature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER).disable(JsonReadFeature.ALLOW_JAVA_COMMENTS)\n            .disable(JsonReadFeature.ALLOW_MISSING_VALUES).enable(JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS)\n            .enable(JsonReadFeature.ALLOW_LEADING_ZEROS_FOR_NUMBERS).disable(JsonReadFeature.ALLOW_SINGLE_QUOTES)\n            .disable(JsonReadFeature.ALLOW_TRAILING_COMMA).enable(JsonReadFeature.ALLOW_UNESCAPED_CONTROL_CHARS)\n            .enable(JsonReadFeature.ALLOW_UNQUOTED_FIELD_NAMES).disable(JsonReadFeature.ALLOW_YAML_COMMENTS)\n            .enable(StreamReadFeature.IGNORE_UNDEFINED).enable(StreamReadFeature.INCLUDE_SOURCE_IN_LOCATION)\n            .disable(StreamReadFeature.STRICT_DUPLICATE_DETECTION).build();\n    /**\n     * @deprecated since 2.4. This extractor has never supported these settings. Use {@link #JSONLDExtractor()} instead.\n     * \n     * @param verifyDataType\n     *            has no effect\n     * @param stopAtFirstError\n     *            has no effect\n     */\n    @Deprecated\n    public JSONLDExtractor(boolean verifyDataType, boolean stopAtFirstError) {\n        super(verifyDataType, stopAtFirstError);\n    }\n    public JSONLDExtractor() {\n        super(false, false);\n    }\n    @Override\n    public ExtractorDescription getDescription() {\n        return JSONLDExtractorFactory.getDescriptionInstance();\n    }\n    @Override\n    public void run(ExtractionParameters extractionParameters, ExtractionContext extractionContext, InputStream in,\n            ExtractionResult extractionResult) throws IOException, ExtractionException {\n        JSONLDJavaSink handler = new JSONLDJavaSink(extractionResult, new Any23ValueFactoryWrapper(\n                SimpleValueFactory.getInstance(), extractionResult, extractionContext.getDefaultLanguage()));\n        JsonLdOptions options = new JsonLdOptions(extractionContext.getDocumentIRI().stringValue());\n        options.useNamespaces = true;\n        try {\n            Object json = JsonUtils\n                    .fromJsonParser(OBJECT_MAPPER.getFactory().createParser(new JsonCleaningInputStream(in)));\n            JsonLdProcessor.toRDF(json, handler, options);\n        } catch (JsonProcessingException e) {\n            JsonLocation loc = e.getLocation();\n            if (loc == null) {\n                extractionResult.notifyIssue(IssueReport.IssueLevel.FATAL, e.getOriginalMessage(), -1L, -1L);\n            } else {\n                extractionResult.notifyIssue(IssueReport.IssueLevel.FATAL, e.getOriginalMessage(), loc.getLineNr(),\n                        loc.getColumnNr());\n            }\n        } catch (Exception e) {\n            // ANY23-420: jsonld-java can sometimes throw IllegalArgumentException\n            extractionResult.notifyIssue(IssueReport.IssueLevel.FATAL, toString(e), -1, -1);\n        }\n    }\n    /* DEPRECATED METHODS */\n    /**\n     * @deprecated since 2.4. This extractor has never supported this setting. Do not use.\n     * \n     * @param stopAtFirstError\n     *            has no effect\n     */\n    @Deprecated\n    @Override\n    public void setStopAtFirstError(boolean stopAtFirstError) {\n        super.setStopAtFirstError(stopAtFirstError);\n    }\n    /**\n     * @deprecated since 2.4. This extractor has never supported this setting. Do not use.\n     * \n     * @param verifyDataType\n     *            has no effect\n     */\n    @Deprecated\n    @Override\n    public void setVerifyDataType(boolean verifyDataType) {\n        super.setVerifyDataType(verifyDataType);\n    }\n    /**\n     * @deprecated since 2.4. This extractor no longer wraps an RDF4J {@link RDFParser}. Do not use this method.\n     * \n     * @param extractionContext\n     *            the extraction context\n     * @param extractionResult\n     *            the extraction result\n     * \n     * @return a {@link RDFParser}\n     */\n    @Deprecated\n    @Override\n    protected RDFParser getParser(ExtractionContext extractionContext, ExtractionResult extractionResult) {\n        return RDFParserFactory.getInstance().getJSONLDParser(isVerifyDataType(), isStopAtFirstError(),\n                extractionContext, extractionResult);\n    }\n"]], "pred": {"ppl": 1.7803236246109009, "ppl_lower": 2.4211819171905518, "ppl/lowercase_ppl": -1.5330499955316779, "ppl/zlib": 0.0004433475475460641, "Min_5.0% Prob": 5.94556736946106, "Min_10.0% Prob": 4.361391691600575, "Min_20.0% Prob": 2.7092064981367074, "Min_30.0% Prob": 1.8975928763256353, "Min_40.0% Prob": 1.4365792366058947, "Min_50.0% Prob": 1.1533363785306738, "Min_60.0% Prob": 0.9622801267576129}}
{"hexsha": "78e8d20e9ccc772ee9791869c2caceeffb8f94fe", "ext": "java", "lang": "Java", "content": "@ThreadSafe\nclass BroadcastOutputBufferManager\n    implements OutputBufferManager {\n    private final Consumer<OutputBuffers> outputBufferTarget;\n    private final Map<Integer, Boolean> outputNoMoreBuffers;\n\n    @GuardedBy(\"this\")\n    private OutputBuffers outputBuffers =\n        OutputBuffers.createInitialEmptyOutputBuffers(OutputBuffers.BufferType.BROADCAST);\n\n    public BroadcastOutputBufferManager(Map<Integer, Boolean> outputNoMoreBuffers,\n                                        Consumer<OutputBuffers> outputBufferTarget) {\n        this.outputBufferTarget = requireNonNull(outputBufferTarget, \"outputBufferTarget is null\");\n        this.outputNoMoreBuffers = requireNonNull(outputNoMoreBuffers, \"outputNoMoreBuffers is null\");\n        outputBufferTarget.accept(outputBuffers);\n    }\n\n    @Override\n    public void addOutputBuffers(StageId stageId, List<OutputBuffers.OutputBufferId> newBuffers,\n                                 boolean noMoreBuffers) {\n        OutputBuffers newOutputBuffers;\n        synchronized (this) {\n            if (outputBuffers.isNoMoreBufferIds()) {\n                // a stage can move to a final state (e.g., failed) while scheduling, so ignore\n                // the new buffers\n                return;\n            }\n\n            OutputBuffers originalOutputBuffers = outputBuffers;\n\n            // Note: it does not matter which partition id the task is using, in broadcast all tasks read from the same partition\n            for (OutputBuffers.OutputBufferId newBuffer : newBuffers) {\n                outputBuffers = outputBuffers.withBuffer(newBuffer, OutputBuffers.BROADCAST_PARTITION_ID);\n            }\n\n            Boolean stageNoMoreBuffersFlag = outputNoMoreBuffers.get(stageId.getId());\n            checkArgument(stageNoMoreBuffersFlag != null, \"noMoreBuffersFlag for stage:%s is null\", stageId.getId());\n            if (noMoreBuffers && stageNoMoreBuffersFlag.equals(false)) {\n                outputNoMoreBuffers.put(stageId.getId(), true);\n            }\n\n            // only set no more buffers flag\n            boolean notFinish = false;\n            for (Boolean isNoMoreBuffers : outputNoMoreBuffers.values()) {\n                if (!isNoMoreBuffers) {\n                    notFinish = true;\n                    break;\n                }\n            }\n            if (!notFinish) {\n                outputBuffers = outputBuffers.withNoMoreBufferIds();\n            }\n\n            // don't update if nothing changed\n            if (outputBuffers == originalOutputBuffers) {\n                return;\n            }\n            newOutputBuffers = this.outputBuffers;\n        }\n        outputBufferTarget.accept(newOutputBuffers);\n    }\n}", "item_id": 0, "repo": "weicao/galaxysql", "file": "polardbx-executor/src/main/java/com/alibaba/polardbx/executor/mpp/execution/scheduler/BroadcastOutputBufferManager.java", "last_update_at": "2022-03-28T05:54:49+00:00", "question_id": "78e8d20e9ccc772ee9791869c2caceeffb8f94fe_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ThreadSafe\nclass BroadcastOutputBufferManager\n    implements OutputBufferManager {\n    private final Consumer<OutputBuffers> outputBufferTarget;\n    private final Map<Integer, Boolean> outputNoMoreBuffers;\n    @GuardedBy(\"this\")\n    private OutputBuffers outputBuffers =\n        OutputBuffers.createInitialEmptyOutputBuffers(OutputBuffers.BufferType.BROADCAST);\n    public BroadcastOutputBufferManager(Map<Integer, Boolean> outputNoMoreBuffers,\n                                        Consumer<OutputBuffers> outputBufferTarget) {\n        this.outputBufferTarget = requireNonNull(outputBufferTarget, \"outputBufferTarget is null\");\n        this.outputNoMoreBuffers = requireNonNull(outputNoMoreBuffers, \"outputNoMoreBuffers is null\");\n        outputBufferTarget.accept(outputBuffers);\n    }\n    @Override\n    public void addOutputBuffers(StageId stageId, List<OutputBuffers.OutputBufferId> newBuffers,\n                                 boolean noMoreBuffers) {\n        OutputBuffers newOutputBuffers;\n        synchronized (this) {\n            if (outputBuffers.isNoMoreBufferIds()) {\n                // a stage can move to a final state (e.g., failed) while scheduling, so ignore\n                // the new buffers\n                return;\n            }\n            OutputBuffers originalOutputBuffers = outputBuffers;\n            // Note: it does not matter which partition id the task is using, in broadcast all tasks read from the same partition\n            for (OutputBuffers.OutputBufferId newBuffer : newBuffers) {\n                outputBuffers = outputBuffers.withBuffer(newBuffer, OutputBuffers.BROADCAST_PARTITION_ID);\n            }\n            Boolean stageNoMoreBuffersFlag = outputNoMoreBuffers.get(stageId.getId());\n            checkArgument(stageNoMoreBuffersFlag != null, \"noMoreBuffersFlag for stage:%s is null\", stageId.getId());\n            if (noMoreBuffers && stageNoMoreBuffersFlag.equals(false)) {\n                outputNoMoreBuffers.put(stageId.getId(), true);\n            }\n            // only set no more buffers flag\n            boolean notFinish = false;\n            for (Boolean isNoMoreBuffers : outputNoMoreBuffers.values()) {\n                if (!isNoMoreBuffers) {\n                    notFinish = true;\n                    break;\n                }\n            }\n            if (!notFinish) {\n                outputBuffers = outputBuffers.withNoMoreBufferIds();\n            }\n            // don't update if nothing changed\n            if (outputBuffers == originalOutputBuffers) {\n                return;\n            }\n            newOutputBuffers = this.outputBuffers;\n        }\n        outputBufferTarget.accept(newOutputBuffers);\n    }\n"]], "pred": {"ppl": 1.998002290725708, "ppl_lower": 2.714772939682007, "ppl/lowercase_ppl": -1.442911874485795, "ppl/zlib": 0.0008503044554484864, "Min_5.0% Prob": 6.633149501255581, "Min_10.0% Prob": 4.897641699079057, "Min_20.0% Prob": 3.2006272461030867, "Min_30.0% Prob": 2.272560208065565, "Min_40.0% Prob": 1.7297506280165245, "Min_50.0% Prob": 1.385404155965551, "Min_60.0% Prob": 1.153981564098666}}
{"hexsha": "7ed1f75cb68c24db36b4704e2940d8df35499052", "ext": "java", "lang": "Java", "content": "public class DiscoverResponse {\n    private List<GGGroup> GGGroups;\n\n    public List<GGGroup> getGGGroups() {\n        return GGGroups;\n    }\n\n    public void setGGGroups(List<GGGroup> GGGroups) {\n        this.GGGroups = GGGroups;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        DiscoverResponse that = (DiscoverResponse) o;\n        return Objects.equals(GGGroups, that.GGGroups);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(GGGroups);\n    }\n}", "item_id": 0, "repo": "webermaster/aws-iot-device-sdk-java-v2", "file": "sdk/src/main/java/software/amazon/awssdk/iot/discovery/model/DiscoverResponse.java", "last_update_at": "2022-03-27T18:49:16+00:00", "question_id": "7ed1f75cb68c24db36b4704e2940d8df35499052_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DiscoverResponse {\n    private List<GGGroup> GGGroups;\n    public List<GGGroup> getGGGroups() {\n        return GGGroups;\n    }\n    public void setGGGroups(List<GGGroup> GGGroups) {\n        this.GGGroups = GGGroups;\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        DiscoverResponse that = (DiscoverResponse) o;\n        return Objects.equals(GGGroups, that.GGGroups);\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(GGGroups);\n    }\n"]], "pred": {"ppl": 1.4242727756500244, "ppl_lower": 1.6524935960769653, "ppl/lowercase_ppl": -1.4202440176729443, "ppl/zlib": 0.0014376477665824987, "Min_5.0% Prob": 5.6616769499248925, "Min_10.0% Prob": 3.3574639360109964, "Min_20.0% Prob": 1.7813083015175328, "Min_30.0% Prob": 1.1956256786016402, "Min_40.0% Prob": 0.8858296903526436, "Min_50.0% Prob": 0.7109328656442013, "Min_60.0% Prob": 0.5936658390911954}}
{"hexsha": "5270960ef06915ee2e89e878943c28b57eaafe22", "ext": "java", "lang": "Java", "content": "@Configuration\n@EnableWebSecurity\npublic class SecurityConfiguration\n    extends WebSecurityConfigurerAdapter {\n\n    @Value(\"${spring.security.oauth2.client.provider.oidc.issuer-uri}\")\n    private String issuerUri;\n\n    @Value(\"${oidc.issuer}\")\n    private String issuerOverride;\n\n    private final ServiceAuthFilter serviceAuthFilter;\n    private final JwtAuthenticationConverter jwtAuthenticationConverter;\n\n    @Inject\n    public SecurityConfiguration(final ServiceAuthFilter serviceAuthFilter,\n                                 final JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter) {\n        this.serviceAuthFilter = serviceAuthFilter;\n        jwtAuthenticationConverter = new JwtAuthenticationConverter();\n        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);\n    }\n\n    @Override\n    public void configure(WebSecurity web) throws Exception {\n        web.ignoring().antMatchers(\"/swagger-resources/**\",\n            \"/swagger-ui/**\",\n            \"/webjars/**\",\n            \"/v2/**\",\n            \"/health\",\n            \"/health/liveness\",\n            \"/health/readiness\",\n            \"/\",\n            \"/loggers/**\");\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .addFilterBefore(serviceAuthFilter, BearerTokenAuthenticationFilter.class)\n            .sessionManagement().sessionCreationPolicy(STATELESS).and()\n            .csrf().disable()\n            .formLogin().disable()\n            .logout().disable()\n            .authorizeRequests()\n            .antMatchers(ImportController.URI_IMPORT, ElasticsearchIndexController.ELASTIC_INDEX_URI)\n            .hasAuthority(\"ccd-import\")\n            .anyRequest()\n            .authenticated()\n            .and()\n            .oauth2ResourceServer()\n            .jwt()\n            .jwtAuthenticationConverter(jwtAuthenticationConverter)\n            .and()\n            .and()\n            .oauth2Client();\n    }\n\n    @Bean\n    JwtDecoder jwtDecoder() {\n        NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder) JwtDecoders.fromOidcIssuerLocation(issuerUri);\n\n        // We are using issuerOverride instead of issuerUri as SIDAM has the wrong issuer at the moment\n        OAuth2TokenValidator<Jwt> withTimestamp = new JwtTimestampValidator();\n        OAuth2TokenValidator<Jwt> withIssuer = new JwtIssuerValidator(issuerOverride);\n        // FIXME : enable `withIssuer` once idam migration is done RDM-8094\n        // OAuth2TokenValidator<Jwt> validator = new DelegatingOAuth2TokenValidator<>(withTimestamp, withIssuer);\n        OAuth2TokenValidator<Jwt> validator = new DelegatingOAuth2TokenValidator<>(withTimestamp);\n\n        jwtDecoder.setJwtValidator(validator);\n        return jwtDecoder;\n    }\n}", "item_id": 0, "repo": "banderous/ccd-definition-store-api", "file": "application/src/main/java/uk/gov/hmcts/ccd/definition/store/SecurityConfiguration.java", "last_update_at": "2022-01-07T12:43:56+00:00", "question_id": "5270960ef06915ee2e89e878943c28b57eaafe22_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Configuration\n@EnableWebSecurity\npublic class SecurityConfiguration\n    extends WebSecurityConfigurerAdapter {\n    @Value(\"${spring.security.oauth2.client.provider.oidc.issuer-uri}\")\n    private String issuerUri;\n    @Value(\"${oidc.issuer}\")\n    private String issuerOverride;\n    private final ServiceAuthFilter serviceAuthFilter;\n    private final JwtAuthenticationConverter jwtAuthenticationConverter;\n    @Inject\n    public SecurityConfiguration(final ServiceAuthFilter serviceAuthFilter,\n                                 final JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter) {\n        this.serviceAuthFilter = serviceAuthFilter;\n        jwtAuthenticationConverter = new JwtAuthenticationConverter();\n        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);\n    }\n    @Override\n    public void configure(WebSecurity web) throws Exception {\n        web.ignoring().antMatchers(\"/swagger-resources/**\",\n            \"/swagger-ui/**\",\n            \"/webjars/**\",\n            \"/v2/**\",\n            \"/health\",\n            \"/health/liveness\",\n            \"/health/readiness\",\n            \"/\",\n            \"/loggers/**\");\n    }\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .addFilterBefore(serviceAuthFilter, BearerTokenAuthenticationFilter.class)\n            .sessionManagement().sessionCreationPolicy(STATELESS).and()\n            .csrf().disable()\n            .formLogin().disable()\n            .logout().disable()\n            .authorizeRequests()\n            .antMatchers(ImportController.URI_IMPORT, ElasticsearchIndexController.ELASTIC_INDEX_URI)\n            .hasAuthority(\"ccd-import\")\n            .anyRequest()\n            .authenticated()\n            .and()\n            .oauth2ResourceServer()\n            .jwt()\n            .jwtAuthenticationConverter(jwtAuthenticationConverter)\n            .and()\n            .and()\n            .oauth2Client();\n    }\n    @Bean\n    JwtDecoder jwtDecoder() {\n        NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder) JwtDecoders.fromOidcIssuerLocation(issuerUri);\n        // We are using issuerOverride instead of issuerUri as SIDAM has the wrong issuer at the moment\n        OAuth2TokenValidator<Jwt> withTimestamp = new JwtTimestampValidator();\n        OAuth2TokenValidator<Jwt> withIssuer = new JwtIssuerValidator(issuerOverride);\n        // FIXME : enable `withIssuer` once idam migration is done RDM-8094\n        // OAuth2TokenValidator<Jwt> validator = new DelegatingOAuth2TokenValidator<>(withTimestamp, withIssuer);\n        OAuth2TokenValidator<Jwt> validator = new DelegatingOAuth2TokenValidator<>(withTimestamp);\n        jwtDecoder.setJwtValidator(validator);\n        return jwtDecoder;\n    }\n"]], "pred": {"ppl": 1.7005033493041992, "ppl_lower": 2.17736554145813, "ppl/lowercase_ppl": -1.465586875625202, "ppl/zlib": 0.0005847183866330619, "Min_5.0% Prob": 5.930256691243914, "Min_10.0% Prob": 4.083948600782107, "Min_20.0% Prob": 2.505270606603752, "Min_30.0% Prob": 1.7479080229658972, "Min_40.0% Prob": 1.3218198472595946, "Min_50.0% Prob": 1.0597683956957948, "Min_60.0% Prob": 0.8855250671731896}}
{"hexsha": "d16d165371c9cbdcbc0059c1d0464e5182d90ead", "ext": "java", "lang": "Java", "content": "class UDTParserTest {\n\n    @Test\n    void test_null_or_empty() {\n        Assertions.assertNull(UDTParser.parse(\"\"));\n        Assertions.assertNull(UDTParser.parse(null));\n    }\n\n    @Test\n    void test_invalid_with_strict() {\n        Assertions.assertThrows(IllegalArgumentException.class, () -> UDTParser.parse(\"abc\"));\n    }\n\n    @Test\n    void test_invalid_with_non_strict() {\n        final String[] udt = UDTParser.parse(\"abc\", false);\n        Assertions.assertNotNull(udt);\n        Assertions.assertEquals(1, udt.length);\n        Assertions.assertEquals(\"abc\", udt[0]);\n    }\n\n    @Test\n    void test_without_quote() {\n        final String[] udt = UDTParser.parse(\"(abc,123,xyz)\");\n        System.out.println(Arrays.toString(udt));\n        Assertions.assertEquals(3, udt.length);\n        Assertions.assertEquals(\"abc\", udt[0]);\n        Assertions.assertEquals(\"123\", udt[1]);\n        Assertions.assertEquals(\"xyz\", udt[2]);\n    }\n\n    @Test\n    void test_null_item_in_first() {\n        final String[] udt = UDTParser.parse(\"(,123,xyz)\");\n        System.out.println(Arrays.toString(udt));\n        Assertions.assertEquals(3, udt.length);\n        Assertions.assertEquals(\"\", udt[0]);\n        Assertions.assertEquals(\"123\", udt[1]);\n        Assertions.assertEquals(\"xyz\", udt[2]);\n    }\n\n    @Test\n    void test_null_item_in_last() {\n        final String[] udt = UDTParser.parse(\"(abc,123,)\");\n        System.out.println(Arrays.toString(udt));\n        Assertions.assertEquals(3, udt.length);\n        Assertions.assertEquals(\"abc\", udt[0]);\n        Assertions.assertEquals(\"123\", udt[1]);\n        Assertions.assertEquals(\"\", udt[2]);\n    }\n\n    @Test\n    void test_null_item_between() {\n        final String[] udt = UDTParser.parse(\"(abc,,xyz)\");\n        System.out.println(Arrays.toString(udt));\n        Assertions.assertEquals(3, udt.length);\n        Assertions.assertEquals(\"abc\", udt[0]);\n        Assertions.assertEquals(\"\", udt[1]);\n        Assertions.assertEquals(\"xyz\", udt[2]);\n    }\n\n    @Test\n    void test_quote_first() {\n        final String[] udt = UDTParser.parse(\"(\\\"s t h\\\",abc,t)\");\n        System.out.println(Arrays.toString(udt));\n        Assertions.assertEquals(3, udt.length);\n        Assertions.assertEquals(\"s t h\", udt[0]);\n        Assertions.assertEquals(\"abc\", udt[1]);\n        Assertions.assertEquals(\"t\", udt[2]);\n    }\n\n    @Test\n    void test_quote_between() {\n        final String[] udt = UDTParser.parse(\"(Anytown,\\\"Main St\\\",t)\");\n        System.out.println(Arrays.toString(udt));\n        Assertions.assertEquals(3, udt.length);\n        Assertions.assertEquals(\"Anytown\", udt[0]);\n        Assertions.assertEquals(\"Main St\", udt[1]);\n        Assertions.assertEquals(\"t\", udt[2]);\n    }\n\n    @Test\n    void test_quote_last() {\n        final String[] udt = UDTParser.parse(\"(abc,123,\\\"x y z\\\")\");\n        System.out.println(Arrays.toString(udt));\n        Assertions.assertEquals(3, udt.length);\n        Assertions.assertEquals(\"abc\", udt[0]);\n        Assertions.assertEquals(\"123\", udt[1]);\n        Assertions.assertEquals(\"x y z\", udt[2]);\n    }\n\n    @Test\n    void test_comma_in_quote() {\n        final String[] udt = UDTParser.parse(\"(\\\"Any,town\\\",xyz,f)\");\n        System.out.println(Arrays.toString(udt));\n        Assertions.assertEquals(3, udt.length);\n        Assertions.assertEquals(\"Any,town\", udt[0]);\n        Assertions.assertEquals(\"xyz\", udt[1]);\n        Assertions.assertEquals(\"f\", udt[2]);\n    }\n\n    @Test\n    void test_has_escaped_quote() {\n        final String[] udt = UDTParser.parse(\"(Anytown,\\\"Main \\\"\\\" St\\\",t)\");\n        System.out.println(Arrays.toString(udt));\n        Assertions.assertEquals(3, udt.length);\n        Assertions.assertEquals(\"Anytown\", udt[0]);\n        Assertions.assertEquals(\"Main \\\" St\", udt[1]);\n        Assertions.assertEquals(\"t\", udt[2]);\n    }\n\n}", "item_id": 0, "repo": "zero88/vertx-jooq-dsl", "file": "core/src/test/java/io/zero88/jooqx/datatype/basic/UDTParserTest.java", "last_update_at": "2022-02-28T08:04:21+00:00", "question_id": "d16d165371c9cbdcbc0059c1d0464e5182d90ead_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class UDTParserTest {\n    @Test\n    void test_null_or_empty() {\n        Assertions.assertNull(UDTParser.parse(\"\"));\n        Assertions.assertNull(UDTParser.parse(null));\n    }\n    @Test\n    void test_invalid_with_strict() {\n        Assertions.assertThrows(IllegalArgumentException.class, () -> UDTParser.parse(\"abc\"));\n    }\n    @Test\n    void test_invalid_with_non_strict() {\n        final String[] udt = UDTParser.parse(\"abc\", false);\n        Assertions.assertNotNull(udt);\n        Assertions.assertEquals(1, udt.length);\n        Assertions.assertEquals(\"abc\", udt[0]);\n    }\n    @Test\n    void test_without_quote() {\n        final String[] udt = UDTParser.parse(\"(abc,123,xyz)\");\n        System.out.println(Arrays.toString(udt));\n        Assertions.assertEquals(3, udt.length);\n        Assertions.assertEquals(\"abc\", udt[0]);\n        Assertions.assertEquals(\"123\", udt[1]);\n        Assertions.assertEquals(\"xyz\", udt[2]);\n    }\n    @Test\n    void test_null_item_in_first() {\n        final String[] udt = UDTParser.parse(\"(,123,xyz)\");\n        System.out.println(Arrays.toString(udt));\n        Assertions.assertEquals(3, udt.length);\n        Assertions.assertEquals(\"\", udt[0]);\n        Assertions.assertEquals(\"123\", udt[1]);\n        Assertions.assertEquals(\"xyz\", udt[2]);\n    }\n    @Test\n    void test_null_item_in_last() {\n        final String[] udt = UDTParser.parse(\"(abc,123,)\");\n        System.out.println(Arrays.toString(udt));\n        Assertions.assertEquals(3, udt.length);\n        Assertions.assertEquals(\"abc\", udt[0]);\n        Assertions.assertEquals(\"123\", udt[1]);\n        Assertions.assertEquals(\"\", udt[2]);\n    }\n    @Test\n    void test_null_item_between() {\n        final String[] udt = UDTParser.parse(\"(abc,,xyz)\");\n        System.out.println(Arrays.toString(udt));\n        Assertions.assertEquals(3, udt.length);\n        Assertions.assertEquals(\"abc\", udt[0]);\n        Assertions.assertEquals(\"\", udt[1]);\n        Assertions.assertEquals(\"xyz\", udt[2]);\n    }\n    @Test\n    void test_quote_first() {\n        final String[] udt = UDTParser.parse(\"(\\\"s t h\\\",abc,t)\");\n        System.out.println(Arrays.toString(udt));\n        Assertions.assertEquals(3, udt.length);\n        Assertions.assertEquals(\"s t h\", udt[0]);\n        Assertions.assertEquals(\"abc\", udt[1]);\n        Assertions.assertEquals(\"t\", udt[2]);\n    }\n    @Test\n    void test_quote_between() {\n        final String[] udt = UDTParser.parse(\"(Anytown,\\\"Main St\\\",t)\");\n        System.out.println(Arrays.toString(udt));\n        Assertions.assertEquals(3, udt.length);\n        Assertions.assertEquals(\"Anytown\", udt[0]);\n        Assertions.assertEquals(\"Main St\", udt[1]);\n        Assertions.assertEquals(\"t\", udt[2]);\n    }\n    @Test\n    void test_quote_last() {\n        final String[] udt = UDTParser.parse(\"(abc,123,\\\"x y z\\\")\");\n        System.out.println(Arrays.toString(udt));\n        Assertions.assertEquals(3, udt.length);\n        Assertions.assertEquals(\"abc\", udt[0]);\n        Assertions.assertEquals(\"123\", udt[1]);\n        Assertions.assertEquals(\"x y z\", udt[2]);\n    }\n    @Test\n    void test_comma_in_quote() {\n        final String[] udt = UDTParser.parse(\"(\\\"Any,town\\\",xyz,f)\");\n        System.out.println(Arrays.toString(udt));\n        Assertions.assertEquals(3, udt.length);\n        Assertions.assertEquals(\"Any,town\", udt[0]);\n        Assertions.assertEquals(\"xyz\", udt[1]);\n        Assertions.assertEquals(\"f\", udt[2]);\n    }\n    @Test\n    void test_has_escaped_quote() {\n        final String[] udt = UDTParser.parse(\"(Anytown,\\\"Main \\\"\\\" St\\\",t)\");\n        System.out.println(Arrays.toString(udt));\n        Assertions.assertEquals(3, udt.length);\n        Assertions.assertEquals(\"Anytown\", udt[0]);\n        Assertions.assertEquals(\"Main \\\" St\", udt[1]);\n        Assertions.assertEquals(\"t\", udt[2]);\n    }\n"]], "pred": {"ppl": 1.309562087059021, "ppl_lower": 1.387753963470459, "ppl/lowercase_ppl": -1.2150364811652934, "ppl/zlib": 0.0005351047552375177, "Min_5.0% Prob": 4.626554517184987, "Min_10.0% Prob": 2.630741956333319, "Min_20.0% Prob": 1.3479068532732188, "Min_30.0% Prob": 0.9009684192030417, "Min_40.0% Prob": 0.6744093865345171, "Min_50.0% Prob": 0.5398673224258621, "Min_60.0% Prob": 0.4500617850439764}}
{"hexsha": "74a486d9c1cc3db621e7ca7e8b915d6c21347da8", "ext": "java", "lang": "Java", "content": "public class LogPolicySupport {\n\t/**\n\t * Get the methods that should be mocked.\n\t * \n\t * @param fullyQualifiedClassName\n\t *            The fully-qualified name to the class that contains the\n\t *            method.\n\t * @param methodName\n\t *            The name of the method that should be mocked.\n\t * @param logFramework\n\t *            The log framework that should be printed if the class\n\t *            {@code fullyQualifiedClassName} cannot be found.\n\t * @return The array of {@link Method}'s that should be mocked.\n\t */\n\tpublic Method[] getLoggerMethods(String fullyQualifiedClassName, String methodName, String logFramework) {\n\t\ttry {\n\t\t\treturn Whitebox.getMethods(getType(fullyQualifiedClassName, logFramework), methodName);\n\t\t} catch (RuntimeException e) {\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Get the class type representing the fully-qualified name.\n\t * \n\t * @param name\n\t *            The fully-qualified name of a class to get.\n\t * @param logFramework\n\t *            The log framework that should be printed if the class cannot\n\t *            be found.\n\t * @return The class representing the fully-qualified name.\n\t * @throws Exception\n\t *             If something unexpected goes wrong, for example if the class\n\t *             cannot be found.\n\t */\n\tpublic Class<?> getType(String name, String logFramework) throws Exception {\n\t\tfinal Class<?> loggerType;\n\t\ttry {\n\t\t\tloggerType = Class.forName(name);\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tfinal String message = String.format(\"Cannot find %s in the classpath which the %s policy requires.\", logFramework, getClass()\n\t\t\t\t\t.getSimpleName());\n\t\t\tthrow new RuntimeException(message, e);\n\t\t}\n\t\treturn loggerType;\n\t}\n}", "item_id": 0, "repo": "pvdlageweg/powermock", "file": "powermock-core/src/main/java/org/powermock/mockpolicies/support/LogPolicySupport.java", "last_update_at": "2022-03-31T19:19:24+00:00", "question_id": "74a486d9c1cc3db621e7ca7e8b915d6c21347da8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LogPolicySupport {\n\t/**\n\t * Get the methods that should be mocked.\n\t * \n\t * @param fullyQualifiedClassName\n\t *            The fully-qualified name to the class that contains the\n\t *            method.\n\t * @param methodName\n\t *            The name of the method that should be mocked.\n\t * @param logFramework\n\t *            The log framework that should be printed if the class\n\t *            {@code fullyQualifiedClassName} cannot be found.\n\t * @return The array of {@link Method}'s that should be mocked.\n\t */\n\tpublic Method[] getLoggerMethods(String fullyQualifiedClassName, String methodName, String logFramework) {\n\t\ttry {\n\t\t\treturn Whitebox.getMethods(getType(fullyQualifiedClassName, logFramework), methodName);\n\t\t} catch (RuntimeException e) {\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\t/**\n\t * Get the class type representing the fully-qualified name.\n\t * \n\t * @param name\n\t *            The fully-qualified name of a class to get.\n\t * @param logFramework\n\t *            The log framework that should be printed if the class cannot\n\t *            be found.\n\t * @return The class representing the fully-qualified name.\n\t * @throws Exception\n\t *             If something unexpected goes wrong, for example if the class\n\t *             cannot be found.\n\t */\n\tpublic Class<?> getType(String name, String logFramework) throws Exception {\n\t\tfinal Class<?> loggerType;\n\t\ttry {\n\t\t\tloggerType = Class.forName(name);\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tfinal String message = String.format(\"Cannot find %s in the classpath which the %s policy requires.\", logFramework, getClass()\n\t\t\t\t\t.getSimpleName());\n\t\t\tthrow new RuntimeException(message, e);\n\t\t}\n\t\treturn loggerType;\n\t}\n"]], "pred": {"ppl": 2.0929958820343018, "ppl_lower": 2.3334240913391113, "ppl/lowercase_ppl": -1.1472255602207375, "ppl/zlib": 0.0012413386150715393, "Min_5.0% Prob": 7.149565418561299, "Min_10.0% Prob": 5.267528407427729, "Min_20.0% Prob": 3.363188267362361, "Min_30.0% Prob": 2.3923121948225967, "Min_40.0% Prob": 1.8315506423158305, "Min_50.0% Prob": 1.475658897508164, "Min_60.0% Prob": 1.2322261492328934}}
{"hexsha": "d7f21d38f3dbc9b1d4715a257c440a38a14eb58f", "ext": "java", "lang": "Java", "content": "@CheckReturnValue\npublic class ToInteger extends Function {\n\n  public ToInteger() {\n    super(eCategory.STRING_OPERATORS, \"TO_INTEGER\", \"TO_INTEGER(x) converts x to an integer.\");\n  }\n\n  @Override\n  public BoxedType<?> evaluate(List<BoxedType<?>> parameters) {\n\n    Preconditions.checkArgument(parameters.size() == 1, \"TO_INTEGER takes exactly one parameter.\");\n    Preconditions.checkArgument(parameters.get(0).isNumber(), \"%s should be a number\",\n        parameters.get(0));\n\n    return box(parameters.get(0).asBigInteger());\n  }\n}", "item_id": 0, "repo": "computablefacts/nona", "file": "src/com/computablefacts/nona/functions/stringoperators/ToInteger.java", "last_update_at": "2022-02-11T16:48:41+00:00", "question_id": "d7f21d38f3dbc9b1d4715a257c440a38a14eb58f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@CheckReturnValue\npublic class ToInteger extends Function {\n  public ToInteger() {\n    super(eCategory.STRING_OPERATORS, \"TO_INTEGER\", \"TO_INTEGER(x) converts x to an integer.\");\n  }\n  @Override\n  public BoxedType<?> evaluate(List<BoxedType<?>> parameters) {\n    Preconditions.checkArgument(parameters.size() == 1, \"TO_INTEGER takes exactly one parameter.\");\n    Preconditions.checkArgument(parameters.get(0).isNumber(), \"%s should be a number\",\n        parameters.get(0));\n    return box(parameters.get(0).asBigInteger());\n  }\n"]], "pred": {"ppl": 2.5167791843414307, "ppl_lower": 4.556124210357666, "ppl/lowercase_ppl": -1.6430175484029332, "ppl/zlib": 0.003026163877387691, "Min_5.0% Prob": 8.16836816072464, "Min_10.0% Prob": 5.95341469347477, "Min_20.0% Prob": 3.8424470894264453, "Min_30.0% Prob": 2.8639947521686553, "Min_40.0% Prob": 2.2763043066317383, "Min_50.0% Prob": 1.839130094342203, "Min_60.0% Prob": 1.5368368163704873}}
{"hexsha": "5096ebbeb2dd16a8c2746b0924aa06ed2bf0f702", "ext": "java", "lang": "Java", "content": "public class UncloakWorkingFolderTask extends WorkingFolderTask {\n    public UncloakWorkingFolderTask(final Shell shell, final TFSRepository repository, final String serverPath) {\n        super(shell, repository, serverPath, true);\n    }\n\n    @Override\n    public BaseDialog getDialog() {\n        final Workspace workspace = repository.getWorkspace();\n        final String localPath = getLocalPathHint(workspace, serverPath);\n\n        return new UncloakFolderMappingDialog(getShell(), workspace, serverPath, localPath);\n    }\n\n    @Override\n    public TFSCommand getCommand() {\n        final WorkingFolder workingFolder = repository.getWorkspace().getExactMappingForServerPath(serverPath);\n        return new DeleteWorkingFolderCommand(repository, workingFolder);\n    }\n\n    @Override\n    public void getLatest() {\n        final String title = Messages.getString(\"UncloakWorkingFolderTask.Uncloak\"); //$NON-NLS-1$\n        getLatestForServerPath(title);\n    }\n}", "item_id": 0, "repo": "kupci/team-explorer-everywhere", "file": "source/com.microsoft.tfs.client.common.ui/src/com/microsoft/tfs/client/common/ui/tasks/vc/UncloakWorkingFolderTask.java", "last_update_at": "2022-02-06T17:43:29+00:00", "question_id": "5096ebbeb2dd16a8c2746b0924aa06ed2bf0f702_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UncloakWorkingFolderTask extends WorkingFolderTask {\n    public UncloakWorkingFolderTask(final Shell shell, final TFSRepository repository, final String serverPath) {\n        super(shell, repository, serverPath, true);\n    }\n    @Override\n    public BaseDialog getDialog() {\n        final Workspace workspace = repository.getWorkspace();\n        final String localPath = getLocalPathHint(workspace, serverPath);\n        return new UncloakFolderMappingDialog(getShell(), workspace, serverPath, localPath);\n    }\n    @Override\n    public TFSCommand getCommand() {\n        final WorkingFolder workingFolder = repository.getWorkspace().getExactMappingForServerPath(serverPath);\n        return new DeleteWorkingFolderCommand(repository, workingFolder);\n    }\n    @Override\n    public void getLatest() {\n        final String title = Messages.getString(\"UncloakWorkingFolderTask.Uncloak\"); //$NON-NLS-1$\n        getLatestForServerPath(title);\n    }\n"]], "pred": {"ppl": 2.572514533996582, "ppl_lower": 3.960299015045166, "ppl/lowercase_ppl": -1.4566018331948734, "ppl/zlib": 0.0025746153636670975, "Min_5.0% Prob": 7.758929491043091, "Min_10.0% Prob": 5.87497880935669, "Min_20.0% Prob": 4.003173313140869, "Min_30.0% Prob": 2.9662371428807575, "Min_40.0% Prob": 2.3220006451010704, "Min_50.0% Prob": 1.878372604411746, "Min_60.0% Prob": 1.5749436416694067}}
{"hexsha": "e74d6907a55ef2f8af225b8dd516790681857636", "ext": "java", "lang": "Java", "content": "public class LifeComponent extends Component implements Life{\n\tInteger life = 3;\n\t\n    @Override\n    public void onUpdate(double ptf) {\n        entity.getViewComponent().clearChildren();\n        Text lifeText = new Text(\"Lives: \"  + life.toString());\n        lifeText.setFill(Color.RED);\n        lifeText.setFont(Font.font(\"Arial\", 20));\n        entity.getViewComponent().addChild(lifeText);\n    }\n\n\t@Override\n\tpublic int getLife() {\n\t\treturn life;\n\t}\n\n\t@Override\n\tpublic void setLife(int i) {\n\t\tlife = i;\n\t}\n\n\t@Override\n\tpublic int decreaseLife(int i) {\n\t\tlife -= i;\n\t\treturn life;\n\t}\n}", "item_id": 0, "repo": "jvondermarck/dinosaur-exploder", "file": "src/main/java/com/dinosaur/dinosaurexploder/model/LifeComponent.java", "last_update_at": "2022-03-27T17:38:20+00:00", "question_id": "e74d6907a55ef2f8af225b8dd516790681857636_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LifeComponent extends Component implements Life{\n\tInteger life = 3;\n\t\n    @Override\n    public void onUpdate(double ptf) {\n        entity.getViewComponent().clearChildren();\n        Text lifeText = new Text(\"Lives: \"  + life.toString());\n        lifeText.setFill(Color.RED);\n        lifeText.setFont(Font.font(\"Arial\", 20));\n        entity.getViewComponent().addChild(lifeText);\n    }\n\t@Override\n\tpublic int getLife() {\n\t\treturn life;\n\t}\n\t@Override\n\tpublic void setLife(int i) {\n\t\tlife = i;\n\t}\n\t@Override\n\tpublic int decreaseLife(int i) {\n\t\tlife -= i;\n\t\treturn life;\n\t}\n"]], "pred": {"ppl": 2.3914432525634766, "ppl_lower": 3.0356199741363525, "ppl/lowercase_ppl": -1.2735628272342718, "ppl/zlib": 0.002985948818671052, "Min_5.0% Prob": 7.982700665791829, "Min_10.0% Prob": 5.828641878931146, "Min_20.0% Prob": 3.7816330805802956, "Min_30.0% Prob": 2.76714723993992, "Min_40.0% Prob": 2.140246648245897, "Min_50.0% Prob": 1.7397518762070494, "Min_60.0% Prob": 1.4488373564986081}}
{"hexsha": "7c02e8b9a874b62a78d99846c5ab5f8d36c4ad3a", "ext": "java", "lang": "Java", "content": "public class AuthenticationRequestProcessing {\n\n\tpublic AuthenticationResponse processRequest(AuthenticationRequest request) {\n\t\tAuthenticationResponse response = new AuthenticationResponse();\n\t\tGson gson = new Gson();\n\t\tsetAppId(request, response);\n\t\tresponse.header = new OperationHeader();\n\t\tresponse.header.serverData = request.header.serverData;\n\t\tresponse.header.op = request.header.op;\n\t\tresponse.header.upv = request.header.upv;\n\n\t\tFinalChallengeParams fcParams = new FinalChallengeParams();\n\t\tfcParams.appID = Constants.APP_ID;\n\t\tfcParams.facetID = Constants.FACET_ID;\n\t\tfcParams.challenge = request.challenge;\n\t\tresponse.fcParams = Base64.encodeBase64URLSafeString(gson.toJson(\n\t\t\t\tfcParams).getBytes());\n\t\tsetAssertions(response);\n\t\treturn response;\n\t}\n\n\tprivate void setAssertions(AuthenticationResponse response) {\n\t\tAuthenticatorSignAssertion assertion = new AuthenticatorSignAssertion();\n\t\tassertion.assertionScheme = \"UAFV1TLV\";\n\t\t// Example from specs doc\n\t\tassertion.assertion = \"Aj7WAAQ-jgALLgkAQUJDRCNBQkNEDi4FAAABAQEADy4gAHwyJAEX8t1b2wOxbaKOC5ZL7ACqbLo_TtiQfK3DzDsHCi4gAFwCUz-dOuafXKXJLbkUrIzjAU6oDbP8B9iLQRmCf58fEC4AAAkuIABkwI-f3bIe_Uin6IKIFvqLgAOrpk6_nr0oVAK9hIl82A0uBAACAAAABi5AADwDOcBvPslX2bRNy4SvFhAwhEAoBSGUitgMUNChgUSMxss3K3ukekq1paG7Fv1v5mBmDCZVPt2NCTnjUxrjTp4\";\n\t\tAuthenticatorSignAssertion[] assertions = new AuthenticatorSignAssertion[1];\n\t\tassertions[0] = assertion;\n\t\tresponse.assertions = assertions;\n\t}\n\n\tprivate void setAppId(AuthenticationRequest request,\n\t\t\tAuthenticationResponse response) {\n\t\tif (request.header.appID == null && request.header.appID.isEmpty()) {\n\t\t\tresponse.header.appID = Constants.APP_ID;\n\t\t} else {\n\t\t\tsetAppID(request, response);\n\t\t}\n\t}\n\n\tprivate void setAppID(AuthenticationRequest request,\n\t\t\tAuthenticationResponse response) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n}", "item_id": 0, "repo": "hs14m2b/UAF", "file": "fido-uaf-core/src/main/java/org/ebayopensource/fido/uaf/ri/client/AuthenticationRequestProcessing.java", "last_update_at": "2022-02-21T10:54:14+00:00", "question_id": "7c02e8b9a874b62a78d99846c5ab5f8d36c4ad3a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AuthenticationRequestProcessing {\n\tpublic AuthenticationResponse processRequest(AuthenticationRequest request) {\n\t\tAuthenticationResponse response = new AuthenticationResponse();\n\t\tGson gson = new Gson();\n\t\tsetAppId(request, response);\n\t\tresponse.header = new OperationHeader();\n\t\tresponse.header.serverData = request.header.serverData;\n\t\tresponse.header.op = request.header.op;\n\t\tresponse.header.upv = request.header.upv;\n\t\tFinalChallengeParams fcParams = new FinalChallengeParams();\n\t\tfcParams.appID = Constants.APP_ID;\n\t\tfcParams.facetID = Constants.FACET_ID;\n\t\tfcParams.challenge = request.challenge;\n\t\tresponse.fcParams = Base64.encodeBase64URLSafeString(gson.toJson(\n\t\t\t\tfcParams).getBytes());\n\t\tsetAssertions(response);\n\t\treturn response;\n\t}\n\tprivate void setAssertions(AuthenticationResponse response) {\n\t\tAuthenticatorSignAssertion assertion = new AuthenticatorSignAssertion();\n\t\tassertion.assertionScheme = \"UAFV1TLV\";\n\t\t// Example from specs doc\n\t\tassertion.assertion = \"Aj7WAAQ-jgALLgkAQUJDRCNBQkNEDi4FAAABAQEADy4gAHwyJAEX8t1b2wOxbaKOC5ZL7ACqbLo_TtiQfK3DzDsHCi4gAFwCUz-dOuafXKXJLbkUrIzjAU6oDbP8B9iLQRmCf58fEC4AAAkuIABkwI-f3bIe_Uin6IKIFvqLgAOrpk6_nr0oVAK9hIl82A0uBAACAAAABi5AADwDOcBvPslX2bRNy4SvFhAwhEAoBSGUitgMUNChgUSMxss3K3ukekq1paG7Fv1v5mBmDCZVPt2NCTnjUxrjTp4\";\n\t\tAuthenticatorSignAssertion[] assertions = new AuthenticatorSignAssertion[1];\n\t\tassertions[0] = assertion;\n\t\tresponse.assertions = assertions;\n\t}\n\tprivate void setAppId(AuthenticationRequest request,\n\t\t\tAuthenticationResponse response) {\n\t\tif (request.header.appID == null && request.header.appID.isEmpty()) {\n\t\t\tresponse.header.appID = Constants.APP_ID;\n\t\t} else {\n\t\t\tsetAppID(request, response);\n\t\t}\n\t}\n\tprivate void setAppID(AuthenticationRequest request,\n\t\t\tAuthenticationResponse response) {\n\t\t// TODO Auto-generated method stub\n\t}\n"]], "pred": {"ppl": 8.666152000427246, "ppl_lower": 9.394529342651367, "ppl/lowercase_ppl": -1.037372299166625, "ppl/zlib": 0.00278635466196639, "Min_5.0% Prob": 9.075404087702433, "Min_10.0% Prob": 8.244545393519932, "Min_20.0% Prob": 6.409456564320458, "Min_30.0% Prob": 5.656047877338198, "Min_40.0% Prob": 5.089900813168949, "Min_50.0% Prob": 4.281780613710483, "Min_60.0% Prob": 3.596986426031907}}
{"hexsha": "983d088e30084240dbad481c840047566b62037b", "ext": "java", "lang": "Java", "content": "public class ANFTransformTests extends TestCase{\n\n\t@Test\n\tpublic void testgetPrimOrObj() {\n\t\tassertEquals(\"[I, D, I]\", \"\"+ANFTransform.getPrimOrObj(\"(IDI)V\"));\n\t\tassertEquals(\"[I, D, I, L, D]\", \"\"+ANFTransform.getPrimOrObj(\"(IDILString;D)V\"));\n\t\tassertEquals(\"[I, I, D, L, L, L, D, D]\", \"\"+ANFTransform.getPrimOrObj(\"(IIDLString;[D[LString;DD)LString;\"));\n\t\tassertEquals(\"[L, L, L, D, D]\", \"\"+ANFTransform.getPrimOrObj(\"(LD;LD;LD;DD)\"));//a class called D?\n\t\t//ANFTransform.getPrimOrObj(\"([I[I[Ljava/lang/String;)I\");\n\t}\n}", "item_id": 0, "repo": "michaeldesu/Concurnas", "file": "tests/com/concurnas/runtime/cps/analysis/ANFTransformTests.java", "last_update_at": "2022-03-20T12:17:23+00:00", "question_id": "983d088e30084240dbad481c840047566b62037b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ANFTransformTests extends TestCase{\n\t@Test\n\tpublic void testgetPrimOrObj() {\n\t\tassertEquals(\"[I, D, I]\", \"\"+ANFTransform.getPrimOrObj(\"(IDI)V\"));\n\t\tassertEquals(\"[I, D, I, L, D]\", \"\"+ANFTransform.getPrimOrObj(\"(IDILString;D)V\"));\n\t\tassertEquals(\"[I, I, D, L, L, L, D, D]\", \"\"+ANFTransform.getPrimOrObj(\"(IIDLString;[D[LString;DD)LString;\"));\n\t\tassertEquals(\"[L, L, L, D, D]\", \"\"+ANFTransform.getPrimOrObj(\"(LD;LD;LD;DD)\"));//a class called D?\n\t\t//ANFTransform.getPrimOrObj(\"([I[I[Ljava/lang/String;)I\");\n\t}\n"]], "pred": {"ppl": 3.7133240699768066, "ppl_lower": 4.915161609649658, "ppl/lowercase_ppl": -1.2137291833463093, "ppl/zlib": 0.00575406776845468, "Min_5.0% Prob": 8.502377943559127, "Min_10.0% Prob": 6.985510631041094, "Min_20.0% Prob": 5.037214612960815, "Min_30.0% Prob": 3.8739285148791414, "Min_40.0% Prob": 3.0913040373060436, "Min_50.0% Prob": 2.5545864239730665, "Min_60.0% Prob": 2.1764342929478047}}
{"hexsha": "e3ae0f2a22f26e9a4ff23fac0c789cb3335ba243", "ext": "java", "lang": "Java", "content": "public class C_RfQ_PublishResults extends JavaProcess implements IProcessPrecondition\n{\n\t// services\n\tprivate final transient IRfQConfiguration rfqConfiguration = Services.get(IRfQConfiguration.class);\n\tprivate final transient IRfqBL rfqBL = Services.get(IRfqBL.class);\n\tprivate final transient IRfqDAO rfqDAO = Services.get(IRfqDAO.class);\n\tprivate final transient IPMM_RfQ_BL pmmRfqBL = Services.get(IPMM_RfQ_BL.class);\n\n\n\t@Override\n\tpublic ProcessPreconditionsResolution checkPreconditionsApplicable(final IProcessPreconditionsContext context)\n\t{\n\t\tfinal I_C_RfQ rfq = context.getSelectedModel(I_C_RfQ.class);\n\t\treturn ProcessPreconditionsResolution.acceptIf(rfqBL.isClosed(rfq));\n\t}\n\n\t@Override\n\tprotected String doIt()\n\t{\n\t\tfinal I_C_RfQ rfq = getRecord(I_C_RfQ.class);\n\t\tfinal IRfQResponsePublisher rfQResponsePublisher = rfqConfiguration.getRfQResponsePublisher();\n\n\t\tfor (final I_C_RfQResponse rfqResponse : rfqDAO.retrieveAllResponses(rfq))\n\t\t{\n\t\t\tif (!rfqBL.isClosed(rfqResponse))\n\t\t\t{\n\t\t\t\taddLog(\"@Error@ @NotClosed@: {}\", rfqBL.getSummary(rfqResponse));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tpmmRfqBL.checkCompleteContractsForWinners(rfqResponse);\n\n\t\t\trfQResponsePublisher.publish(RfQResponsePublisherRequest.of(rfqResponse, PublishingType.Close));\n\t\t}\n\n\t\treturn MSG_OK;\n\t}\n}", "item_id": 0, "repo": "dram/metasfresh", "file": "backend/de.metas.procurement.base/src/main/java/de/metas/procurement/base/order/process/C_RfQ_PublishResults.java", "last_update_at": "2022-03-30T09:50:41+00:00", "question_id": "e3ae0f2a22f26e9a4ff23fac0c789cb3335ba243_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class C_RfQ_PublishResults extends JavaProcess implements IProcessPrecondition\n{\n\t// services\n\tprivate final transient IRfQConfiguration rfqConfiguration = Services.get(IRfQConfiguration.class);\n\tprivate final transient IRfqBL rfqBL = Services.get(IRfqBL.class);\n\tprivate final transient IRfqDAO rfqDAO = Services.get(IRfqDAO.class);\n\tprivate final transient IPMM_RfQ_BL pmmRfqBL = Services.get(IPMM_RfQ_BL.class);\n\t@Override\n\tpublic ProcessPreconditionsResolution checkPreconditionsApplicable(final IProcessPreconditionsContext context)\n\t{\n\t\tfinal I_C_RfQ rfq = context.getSelectedModel(I_C_RfQ.class);\n\t\treturn ProcessPreconditionsResolution.acceptIf(rfqBL.isClosed(rfq));\n\t}\n\t@Override\n\tprotected String doIt()\n\t{\n\t\tfinal I_C_RfQ rfq = getRecord(I_C_RfQ.class);\n\t\tfinal IRfQResponsePublisher rfQResponsePublisher = rfqConfiguration.getRfQResponsePublisher();\n\t\tfor (final I_C_RfQResponse rfqResponse : rfqDAO.retrieveAllResponses(rfq))\n\t\t{\n\t\t\tif (!rfqBL.isClosed(rfqResponse))\n\t\t\t{\n\t\t\t\taddLog(\"@Error@ @NotClosed@: {}\", rfqBL.getSummary(rfqResponse));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tpmmRfqBL.checkCompleteContractsForWinners(rfqResponse);\n\t\t\trfQResponsePublisher.publish(RfQResponsePublisherRequest.of(rfqResponse, PublishingType.Close));\n\t\t}\n\t\treturn MSG_OK;\n\t}\n"]], "pred": {"ppl": 1.756378412246704, "ppl_lower": 2.6425750255584717, "ppl/lowercase_ppl": -1.7252498592288725, "ppl/zlib": 0.001079030591418538, "Min_5.0% Prob": 6.085744400819142, "Min_10.0% Prob": 4.521904230117798, "Min_20.0% Prob": 2.7031881812244953, "Min_30.0% Prob": 1.8648339108932739, "Min_40.0% Prob": 1.407937543026766, "Min_50.0% Prob": 1.1278551580425515, "Min_60.0% Prob": 0.9398437825574331}}
{"hexsha": "4483e31236019de9aecf45fd88f1dfa7b37b5d8d", "ext": "java", "lang": "Java", "content": "public class Factory {\n\n    public static ChatImpl createChat(SkypeImpl client, String identity) throws ConnectionException, ChatNotFoundException {\n        Validate.notNull(client, \"Client must not be null\");\n        Validate.notEmpty(identity, \"Identity must not be null/empty\");\n\n        ChatImpl result = null;\n\n        if (identity.startsWith(\"19:\")) {\n            if (identity.endsWith(\"@thread.skype\")) {\n                result = new ChatGroup(client, identity);\n            } else if (identity.endsWith(\"@p2p.thread.skype\")) {\n                result = new ChatP2P(client, identity);\n            }\n        } else if (identity.startsWith(\"8:\")) {\n            result = new ChatIndividual(client, identity);\n        } else if (identity.startsWith(\"28:\")) {\n            result = new ChatBot(client, identity);\n        }\n\n        if (result != null) {\n            result.load();\n            return result;\n        }\n\n        throw new IllegalArgumentException(String.format(\"Unknown chat type with identity %s\", identity));\n    }\n\n    public static ParticipantImpl createParticipant(SkypeImpl client, ChatImpl chat, String id) throws ConnectionException {\n        Validate.notNull(client, \"Client must not be null\");\n        Validate.notNull(chat, \"Chat must not be null\");\n        Validate.notEmpty(id, \"Identity must not be null/empty\");\n\n        ParticipantImpl result = null;\n\n        if (id.startsWith(\"8:\")) {\n            result = new UserImpl(client, chat, id);\n        } else if (id.startsWith(\"28:\")) {\n            result = new BotImpl(client, chat, id);\n        }\n\n        if (result != null) {\n            return result;\n        }\n\n        throw new IllegalArgumentException(String.format(\"Unknown participant type with id %s\", id));\n    }\n\n    public static ChatMessageImpl createMessage(Chat chat, ParticipantImpl user, String id, String clientId, long time, Message message, SkypeImpl skype) throws ConnectionException {\n        Validate.notNull(chat, \"Chat must not be null\");\n        Validate.isTrue(chat instanceof ChatImpl, \"Chat must be instanceof ChatImpl\");\n        Validate.notNull(user, \"User must not be null\");\n\n        if ((\"8:\" + chat.getClient().getUsername()).equals(user.getId())) {\n            return new SentMessageImpl(chat, user, id, clientId, time, message, skype);\n        } else {\n            return new ReceivedMessageImpl(chat, user, id, clientId, time, message, skype);\n        }\n    }\n}", "item_id": 0, "repo": "leakzorpro/Skype4J", "file": "src/main/java/com/samczsun/skype4j/internal/Factory.java", "last_update_at": "2022-01-01T08:08:21+00:00", "question_id": "4483e31236019de9aecf45fd88f1dfa7b37b5d8d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Factory {\n    public static ChatImpl createChat(SkypeImpl client, String identity) throws ConnectionException, ChatNotFoundException {\n        Validate.notNull(client, \"Client must not be null\");\n        Validate.notEmpty(identity, \"Identity must not be null/empty\");\n        ChatImpl result = null;\n        if (identity.startsWith(\"19:\")) {\n            if (identity.endsWith(\"@thread.skype\")) {\n                result = new ChatGroup(client, identity);\n            } else if (identity.endsWith(\"@p2p.thread.skype\")) {\n                result = new ChatP2P(client, identity);\n            }\n        } else if (identity.startsWith(\"8:\")) {\n            result = new ChatIndividual(client, identity);\n        } else if (identity.startsWith(\"28:\")) {\n            result = new ChatBot(client, identity);\n        }\n        if (result != null) {\n            result.load();\n            return result;\n        }\n        throw new IllegalArgumentException(String.format(\"Unknown chat type with identity %s\", identity));\n    }\n    public static ParticipantImpl createParticipant(SkypeImpl client, ChatImpl chat, String id) throws ConnectionException {\n        Validate.notNull(client, \"Client must not be null\");\n        Validate.notNull(chat, \"Chat must not be null\");\n        Validate.notEmpty(id, \"Identity must not be null/empty\");\n        ParticipantImpl result = null;\n        if (id.startsWith(\"8:\")) {\n            result = new UserImpl(client, chat, id);\n        } else if (id.startsWith(\"28:\")) {\n            result = new BotImpl(client, chat, id);\n        }\n        if (result != null) {\n            return result;\n        }\n        throw new IllegalArgumentException(String.format(\"Unknown participant type with id %s\", id));\n    }\n    public static ChatMessageImpl createMessage(Chat chat, ParticipantImpl user, String id, String clientId, long time, Message message, SkypeImpl skype) throws ConnectionException {\n        Validate.notNull(chat, \"Chat must not be null\");\n        Validate.isTrue(chat instanceof ChatImpl, \"Chat must be instanceof ChatImpl\");\n        Validate.notNull(user, \"User must not be null\");\n        if ((\"8:\" + chat.getClient().getUsername()).equals(user.getId())) {\n            return new SentMessageImpl(chat, user, id, clientId, time, message, skype);\n        } else {\n            return new ReceivedMessageImpl(chat, user, id, clientId, time, message, skype);\n        }\n    }\n"]], "pred": {"ppl": 1.6835546493530273, "ppl_lower": 1.8681384325027466, "ppl/lowercase_ppl": -1.1997188356200694, "ppl/zlib": 0.0008268371759369539, "Min_5.0% Prob": 5.703329086303711, "Min_10.0% Prob": 4.0231333176294966, "Min_20.0% Prob": 2.4426015256939078, "Min_30.0% Prob": 1.700984089113772, "Min_40.0% Prob": 1.2928812409915058, "Min_50.0% Prob": 1.0385541645419634, "Min_60.0% Prob": 0.8688473280076869}}
{"hexsha": "85d09c0feb82a8da19c0a94321d5496929efa0b9", "ext": "java", "lang": "Java", "content": "public class WorkerController {\n    private static final Logger logger = LoggerFactory.getLogger(WorkerController.class);\n\n    private final Keeper keeper;\n    private final RestServer rest;\n\n    public WorkerController(Keeper keeper, RestServer rest) {\n        this.keeper = keeper;\n        this.rest = rest;\n    }\n\n    public void startup() {\n        keeper.start();\n        rest.start(keeper);\n\n        logger.info(\"Worker Controller started.\");\n    }\n\n    public void shutdown() {\n        rest.stop();\n        keeper.stop();\n\n        logger.info(\"Worker Controller stopped.\");\n    }\n}", "item_id": 0, "repo": "adamliheng/DataLink", "file": "dl-worker/dl-worker-core/src/main/java/com/ucar/datalink/worker/core/runtime/WorkerController.java", "last_update_at": "2022-03-28T17:26:44+00:00", "question_id": "85d09c0feb82a8da19c0a94321d5496929efa0b9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class WorkerController {\n    private static final Logger logger = LoggerFactory.getLogger(WorkerController.class);\n    private final Keeper keeper;\n    private final RestServer rest;\n    public WorkerController(Keeper keeper, RestServer rest) {\n        this.keeper = keeper;\n        this.rest = rest;\n    }\n    public void startup() {\n        keeper.start();\n        rest.start(keeper);\n        logger.info(\"Worker Controller started.\");\n    }\n    public void shutdown() {\n        rest.stop();\n        keeper.stop();\n        logger.info(\"Worker Controller stopped.\");\n    }\n"]], "pred": {"ppl": 1.7393288612365723, "ppl_lower": 1.9263370037078857, "ppl/lowercase_ppl": -1.1845005805533213, "ppl/zlib": 0.0023256274238968575, "Min_5.0% Prob": 5.924643686839512, "Min_10.0% Prob": 4.1778214772542315, "Min_20.0% Prob": 2.5636179697129036, "Min_30.0% Prob": 1.8081437628319923, "Min_40.0% Prob": 1.3752043929601472, "Min_50.0% Prob": 1.102975902065069, "Min_60.0% Prob": 0.9293661108339563}}
{"hexsha": "d4584644392e9448db7bdd0027ce488f8c1bb4bf", "ext": "java", "lang": "Java", "content": "public class ValueClamperTest\n    extends TestCase\n{\n    /**\n     * Creates a new test.\n     *\n     * @param   testName The test name.\n     */\n    public ValueClamperTest(\n        String testName)\n    {\n        super(testName);\n    }\n    \n    /**\n     * Test of constructors of class ValueClamper.\n     */\n    public void testConstructors()\n    {\n        Double minimum = null;\n        Double maximum = null;\n        ValueClamper<Double> instance = new ValueClamper<Double>();\n        assertSame(minimum, instance.getMinimum());\n        assertSame(maximum, instance.getMaximum());\n        \n        minimum = 10.01;\n        maximum = 20.02;\n        instance = new ValueClamper<Double>(minimum, maximum);\n        assertSame(minimum, instance.getMinimum());\n        assertSame(maximum, instance.getMaximum());\n    }\n\n    public void testClone()\n    {\n        System.out.println( \"Clone\" );\n\n        Double minimum = 10.0;\n        Double maximum = 20.0;\n        ValueClamper<Double> instance = new ValueClamper<Double>(minimum, maximum);\n        ValueClamper<Double> clone = instance.clone();\n        assertNotNull( clone );\n        assertNotSame( instance, clone );\n\n\n    }\n\n    /**\n     * Test of evaluate method, of class ValueClamper.\n     */\n    public void testEvaluate()\n    {\n        Double minimum = 10.01;\n        Double maximum = 20.02;\n        Double input = 0.0;\n        ValueClamper<Double> instance = new ValueClamper<Double>(\n            minimum, maximum);\n\n        assertNull( instance.evaluate(null) );\n\n        input = 15.51;\n        assertSame(input, instance.evaluate(input));\n        \n        input = 10.00;\n        assertSame(minimum, instance.evaluate(input));\n        \n        input = 20.03;\n        assertSame(maximum, instance.evaluate(input));\n        \n        input = 0.0;\n        instance.setMinimum(null);\n        assertSame(input, instance.evaluate(input));\n        \n        input = 40.00;\n        instance.setMaximum(null);\n        assertSame(input, instance.evaluate(input));\n    }\n\n    /**\n     * Test of getMinimum method, of class ValueClamper.\n     */\n    public void testGetMinimum()\n    {\n        this.testSetMinimum();\n    }\n\n    /**\n     * Test of setMinimum method, of class ValueClamper.\n     */\n    public void testSetMinimum()\n    {\n        Double minimum = null;\n        ValueClamper<Double> instance = new ValueClamper<Double>();\n        assertSame(minimum, instance.getMinimum());\n        \n        minimum = 20.08;\n        instance.setMinimum(minimum);\n        assertSame(minimum, instance.getMinimum());\n        \n        minimum = 10.03;\n        instance.setMinimum(minimum);\n        assertSame(minimum, instance.getMinimum());\n        \n        minimum = null;\n        instance.setMinimum(minimum);\n        assertSame(minimum, instance.getMinimum());\n    }\n\n    /**\n     * Test of getMaximum method, of class ValueClamper.\n     */\n    public void testGetMaximum()\n    {\n        this.testSetMaximum();\n    }\n\n    /**\n     * Test of setMaximum method, of class ValueClamper.\n     */\n    public void testSetMaximum()\n    {\n        Double maximum = null;\n        ValueClamper<Double> instance = new ValueClamper<Double>();\n        assertSame(maximum, instance.getMaximum());\n        \n        maximum = 20.08;\n        instance.setMaximum(maximum);\n        assertSame(maximum, instance.getMaximum());\n        \n        maximum = 10.03;\n        instance.setMaximum(maximum);\n        assertSame(maximum, instance.getMaximum());\n        \n        maximum = null;\n        instance.setMaximum(maximum);\n        assertSame(maximum, instance.getMaximum());\n    }\n\n}", "item_id": 0, "repo": "Markoy8/Foundry", "file": "Components/CommonCore/Test/gov/sandia/cognition/evaluator/ValueClamperTest.java", "last_update_at": "2022-02-25T20:22:22+00:00", "question_id": "d4584644392e9448db7bdd0027ce488f8c1bb4bf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ValueClamperTest\n    extends TestCase\n{\n    /**\n     * Creates a new test.\n     *\n     * @param   testName The test name.\n     */\n    public ValueClamperTest(\n        String testName)\n    {\n        super(testName);\n    }\n    /**\n     * Test of constructors of class ValueClamper.\n     */\n    public void testConstructors()\n    {\n        Double minimum = null;\n        Double maximum = null;\n        ValueClamper<Double> instance = new ValueClamper<Double>();\n        assertSame(minimum, instance.getMinimum());\n        assertSame(maximum, instance.getMaximum());\n        minimum = 10.01;\n        maximum = 20.02;\n        instance = new ValueClamper<Double>(minimum, maximum);\n        assertSame(minimum, instance.getMinimum());\n        assertSame(maximum, instance.getMaximum());\n    }\n    public void testClone()\n    {\n        System.out.println( \"Clone\" );\n        Double minimum = 10.0;\n        Double maximum = 20.0;\n        ValueClamper<Double> instance = new ValueClamper<Double>(minimum, maximum);\n        ValueClamper<Double> clone = instance.clone();\n        assertNotNull( clone );\n        assertNotSame( instance, clone );\n    }\n    /**\n     * Test of evaluate method, of class ValueClamper.\n     */\n    public void testEvaluate()\n    {\n        Double minimum = 10.01;\n        Double maximum = 20.02;\n        Double input = 0.0;\n        ValueClamper<Double> instance = new ValueClamper<Double>(\n            minimum, maximum);\n        assertNull( instance.evaluate(null) );\n        input = 15.51;\n        assertSame(input, instance.evaluate(input));\n        input = 10.00;\n        assertSame(minimum, instance.evaluate(input));\n        input = 20.03;\n        assertSame(maximum, instance.evaluate(input));\n        input = 0.0;\n        instance.setMinimum(null);\n        assertSame(input, instance.evaluate(input));\n        input = 40.00;\n        instance.setMaximum(null);\n        assertSame(input, instance.evaluate(input));\n    }\n    /**\n     * Test of getMinimum method, of class ValueClamper.\n     */\n    public void testGetMinimum()\n    {\n        this.testSetMinimum();\n    }\n    /**\n     * Test of setMinimum method, of class ValueClamper.\n     */\n    public void testSetMinimum()\n    {\n        Double minimum = null;\n        ValueClamper<Double> instance = new ValueClamper<Double>();\n        assertSame(minimum, instance.getMinimum());\n        minimum = 20.08;\n        instance.setMinimum(minimum);\n        assertSame(minimum, instance.getMinimum());\n        minimum = 10.03;\n        instance.setMinimum(minimum);\n        assertSame(minimum, instance.getMinimum());\n        minimum = null;\n        instance.setMinimum(minimum);\n        assertSame(minimum, instance.getMinimum());\n    }\n    /**\n     * Test of getMaximum method, of class ValueClamper.\n     */\n    public void testGetMaximum()\n    {\n        this.testSetMaximum();\n    }\n    /**\n     * Test of setMaximum method, of class ValueClamper.\n     */\n    public void testSetMaximum()\n    {\n        Double maximum = null;\n        ValueClamper<Double> instance = new ValueClamper<Double>();\n        assertSame(maximum, instance.getMaximum());\n        maximum = 20.08;\n        instance.setMaximum(maximum);\n        assertSame(maximum, instance.getMaximum());\n        maximum = 10.03;\n        instance.setMaximum(maximum);\n        assertSame(maximum, instance.getMaximum());\n        maximum = null;\n        instance.setMaximum(maximum);\n        assertSame(maximum, instance.getMaximum());\n    }\n"]], "pred": {"ppl": 1.3249940872192383, "ppl_lower": 1.4531762599945068, "ppl/lowercase_ppl": -1.328148769454001, "ppl/zlib": 0.00046745514443884064, "Min_5.0% Prob": 3.9414332403856167, "Min_10.0% Prob": 2.4972240591750428, "Min_20.0% Prob": 1.3810793738446983, "Min_30.0% Prob": 0.9353952877333059, "Min_40.0% Prob": 0.7024785141075772, "Min_50.0% Prob": 0.5629615408615364, "Min_60.0% Prob": 0.4695086965522938}}
{"hexsha": "bb46907fbd6e776d5797d55cee7cc9ad303026f8", "ext": "java", "lang": "Java", "content": "public final class SessionParameters {\n   private int cipherSuite;\n   private short compressionAlgorithm;\n   private Certificate localCertificate;\n   private TlsSecret masterSecret;\n   private ProtocolVersion negotiatedVersion;\n   private Certificate peerCertificate;\n   private byte[] pskIdentity;\n   private byte[] srpIdentity;\n   private byte[] encodedServerExtensions;\n\n   private SessionParameters(int var1, short var2, Certificate var3, TlsSecret var4, ProtocolVersion var5, Certificate var6, byte[] var7, byte[] var8, byte[] var9) {\n      this.pskIdentity = null;\n      this.srpIdentity = null;\n      this.cipherSuite = var1;\n      this.compressionAlgorithm = var2;\n      this.localCertificate = var3;\n      this.masterSecret = var4;\n      this.negotiatedVersion = var5;\n      this.peerCertificate = var6;\n      this.pskIdentity = Arrays.clone(var7);\n      this.srpIdentity = Arrays.clone(var8);\n      this.encodedServerExtensions = var9;\n   }\n\n   public void clear() {\n      if (this.masterSecret != null) {\n         this.masterSecret.destroy();\n      }\n\n   }\n\n   public SessionParameters copy() {\n      return new SessionParameters(this.cipherSuite, this.compressionAlgorithm, this.localCertificate, this.masterSecret, this.negotiatedVersion, this.peerCertificate, this.pskIdentity, this.srpIdentity, this.encodedServerExtensions);\n   }\n\n   public int getCipherSuite() {\n      return this.cipherSuite;\n   }\n\n   public short getCompressionAlgorithm() {\n      return this.compressionAlgorithm;\n   }\n\n   public Certificate getLocalCertificate() {\n      return this.localCertificate;\n   }\n\n   public TlsSecret getMasterSecret() {\n      return this.masterSecret;\n   }\n\n   public ProtocolVersion getNegotiatedVersion() {\n      return this.negotiatedVersion;\n   }\n\n   public Certificate getPeerCertificate() {\n      return this.peerCertificate;\n   }\n\n   /** @deprecated */\n   public byte[] getPskIdentity() {\n      return this.pskIdentity;\n   }\n\n   public byte[] getPSKIdentity() {\n      return this.pskIdentity;\n   }\n\n   public byte[] getSRPIdentity() {\n      return this.srpIdentity;\n   }\n\n   public Hashtable readServerExtensions() throws IOException {\n      if (this.encodedServerExtensions == null) {\n         return null;\n      } else {\n         ByteArrayInputStream var1 = new ByteArrayInputStream(this.encodedServerExtensions);\n         return TlsProtocol.readExtensions(var1);\n      }\n   }\n\n   // $FF: synthetic method\n   SessionParameters(int var1, short var2, Certificate var3, TlsSecret var4, ProtocolVersion var5, Certificate var6, byte[] var7, byte[] var8, byte[] var9, Object var10) {\n      this(var1, var2, var3, var4, var5, var6, var7, var8, var9);\n   }\n\n   public static final class Builder {\n      private int cipherSuite = -1;\n      private short compressionAlgorithm = -1;\n      private Certificate localCertificate = null;\n      private TlsSecret masterSecret = null;\n      private ProtocolVersion negotiatedVersion;\n      private Certificate peerCertificate = null;\n      private byte[] pskIdentity = null;\n      private byte[] srpIdentity = null;\n      private byte[] encodedServerExtensions = null;\n\n      public SessionParameters build() {\n         this.validate(this.cipherSuite >= 0, \"cipherSuite\");\n         this.validate(this.compressionAlgorithm >= 0, \"compressionAlgorithm\");\n         this.validate(this.masterSecret != null, \"masterSecret\");\n         return new SessionParameters(this.cipherSuite, this.compressionAlgorithm, this.localCertificate, this.masterSecret, this.negotiatedVersion, this.peerCertificate, this.pskIdentity, this.srpIdentity, this.encodedServerExtensions);\n      }\n\n      public SessionParameters.Builder setCipherSuite(int var1) {\n         this.cipherSuite = var1;\n         return this;\n      }\n\n      public SessionParameters.Builder setCompressionAlgorithm(short var1) {\n         this.compressionAlgorithm = var1;\n         return this;\n      }\n\n      public SessionParameters.Builder setLocalCertificate(Certificate var1) {\n         this.localCertificate = var1;\n         return this;\n      }\n\n      public SessionParameters.Builder setMasterSecret(TlsSecret var1) {\n         this.masterSecret = var1;\n         return this;\n      }\n\n      public SessionParameters.Builder setNegotiatedVersion(ProtocolVersion var1) {\n         this.negotiatedVersion = var1;\n         return this;\n      }\n\n      public SessionParameters.Builder setPeerCertificate(Certificate var1) {\n         this.peerCertificate = var1;\n         return this;\n      }\n\n      /** @deprecated */\n      public SessionParameters.Builder setPskIdentity(byte[] var1) {\n         this.pskIdentity = var1;\n         return this;\n      }\n\n      public SessionParameters.Builder setPSKIdentity(byte[] var1) {\n         this.pskIdentity = var1;\n         return this;\n      }\n\n      public SessionParameters.Builder setSRPIdentity(byte[] var1) {\n         this.srpIdentity = var1;\n         return this;\n      }\n\n      public SessionParameters.Builder setServerExtensions(Hashtable var1) throws IOException {\n         if (var1 == null) {\n            this.encodedServerExtensions = null;\n         } else {\n            ByteArrayOutputStream var2 = new ByteArrayOutputStream();\n            TlsProtocol.writeExtensions(var2, var1);\n            this.encodedServerExtensions = var2.toByteArray();\n         }\n\n         return this;\n      }\n\n      private void validate(boolean var1, String var2) {\n         if (!var1) {\n            throw new IllegalStateException(\"Required session parameter '\" + var2 + \"' not configured\");\n         }\n      }\n   }\n}", "item_id": 0, "repo": "EtherTyper/dummydroid-patched", "file": "org/bouncycastle/tls/SessionParameters.java", "last_update_at": "2022-01-31T22:02:36+00:00", "question_id": "bb46907fbd6e776d5797d55cee7cc9ad303026f8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class SessionParameters {\n   private int cipherSuite;\n   private short compressionAlgorithm;\n   private Certificate localCertificate;\n   private TlsSecret masterSecret;\n   private ProtocolVersion negotiatedVersion;\n   private Certificate peerCertificate;\n   private byte[] pskIdentity;\n   private byte[] srpIdentity;\n   private byte[] encodedServerExtensions;\n   private SessionParameters(int var1, short var2, Certificate var3, TlsSecret var4, ProtocolVersion var5, Certificate var6, byte[] var7, byte[] var8, byte[] var9) {\n      this.pskIdentity = null;\n      this.srpIdentity = null;\n      this.cipherSuite = var1;\n      this.compressionAlgorithm = var2;\n      this.localCertificate = var3;\n      this.masterSecret = var4;\n      this.negotiatedVersion = var5;\n      this.peerCertificate = var6;\n      this.pskIdentity = Arrays.clone(var7);\n      this.srpIdentity = Arrays.clone(var8);\n      this.encodedServerExtensions = var9;\n   }\n   public void clear() {\n      if (this.masterSecret != null) {\n         this.masterSecret.destroy();\n      }\n   }\n   public SessionParameters copy() {\n      return new SessionParameters(this.cipherSuite, this.compressionAlgorithm, this.localCertificate, this.masterSecret, this.negotiatedVersion, this.peerCertificate, this.pskIdentity, this.srpIdentity, this.encodedServerExtensions);\n   }\n   public int getCipherSuite() {\n      return this.cipherSuite;\n   }\n   public short getCompressionAlgorithm() {\n      return this.compressionAlgorithm;\n   }\n   public Certificate getLocalCertificate() {\n      return this.localCertificate;\n   }\n   public TlsSecret getMasterSecret() {\n      return this.masterSecret;\n   }\n   public ProtocolVersion getNegotiatedVersion() {\n      return this.negotiatedVersion;\n   }\n   public Certificate getPeerCertificate() {\n      return this.peerCertificate;\n   }\n   /** @deprecated */\n   public byte[] getPskIdentity() {\n      return this.pskIdentity;\n   }\n   public byte[] getPSKIdentity() {\n      return this.pskIdentity;\n   }\n   public byte[] getSRPIdentity() {\n      return this.srpIdentity;\n   }\n   public Hashtable readServerExtensions() throws IOException {\n      if (this.encodedServerExtensions == null) {\n         return null;\n      } else {\n         ByteArrayInputStream var1 = new ByteArrayInputStream(this.encodedServerExtensions);\n         return TlsProtocol.readExtensions(var1);\n      }\n   }\n   // $FF: synthetic method\n   SessionParameters(int var1, short var2, Certificate var3, TlsSecret var4, ProtocolVersion var5, Certificate var6, byte[] var7, byte[] var8, byte[] var9, Object var10) {\n      this(var1, var2, var3, var4, var5, var6, var7, var8, var9);\n   }\n   public static final class Builder {\n      private int cipherSuite = -1;\n      private short compressionAlgorithm = -1;\n      private Certificate localCertificate = null;\n      private TlsSecret masterSecret = null;\n      private ProtocolVersion negotiatedVersion;\n      private Certificate peerCertificate = null;\n      private byte[] pskIdentity = null;\n      private byte[] srpIdentity = null;\n      private byte[] encodedServerExtensions = null;\n      public SessionParameters build() {\n         this.validate(this.cipherSuite >= 0, \"cipherSuite\");\n         this.validate(this.compressionAlgorithm >= 0, \"compressionAlgorithm\");\n         this.validate(this.masterSecret != null, \"masterSecret\");\n         return new SessionParameters(this.cipherSuite, this.compressionAlgorithm, this.localCertificate, this.masterSecret, this.negotiatedVersion, this.peerCertificate, this.pskIdentity, this.srpIdentity, this.encodedServerExtensions);\n      }\n      public SessionParameters.Builder setCipherSuite(int var1) {\n         this.cipherSuite = var1;\n         return this;\n      }\n      public SessionParameters.Builder setCompressionAlgorithm(short var1) {\n         this.compressionAlgorithm = var1;\n         return this;\n      }\n      public SessionParameters.Builder setLocalCertificate(Certificate var1) {\n         this.localCertificate = var1;\n         return this;\n      }\n      public SessionParameters.Builder setMasterSecret(TlsSecret var1) {\n         this.masterSecret = var1;\n         return this;\n      }\n      public SessionParameters.Builder setNegotiatedVersion(ProtocolVersion var1) {\n         this.negotiatedVersion = var1;\n         return this;\n      }\n      public SessionParameters.Builder setPeerCertificate(Certificate var1) {\n         this.peerCertificate = var1;\n         return this;\n      }\n      /** @deprecated */\n      public SessionParameters.Builder setPskIdentity(byte[] var1) {\n         this.pskIdentity = var1;\n         return this;\n      }\n      public SessionParameters.Builder setPSKIdentity(byte[] var1) {\n         this.pskIdentity = var1;\n         return this;\n      }\n      public SessionParameters.Builder setSRPIdentity(byte[] var1) {\n         this.srpIdentity = var1;\n         return this;\n      }\n      public SessionParameters.Builder setServerExtensions(Hashtable var1) throws IOException {\n         if (var1 == null) {\n            this.encodedServerExtensions = null;\n         } else {\n            ByteArrayOutputStream var2 = new ByteArrayOutputStream();\n            TlsProtocol.writeExtensions(var2, var1);\n            this.encodedServerExtensions = var2.toByteArray();\n         }\n         return this;\n      }\n      private void validate(boolean var1, String var2) {\n         if (!var1) {\n            throw new IllegalStateException(\"Required session parameter '\" + var2 + \"' not configured\");\n         }\n      }\n   }\n"]], "pred": {"ppl": 1.2660648822784424, "ppl_lower": 1.4092706441879272, "ppl/lowercase_ppl": -1.4542287401439127, "ppl/zlib": 0.00021564311904364808, "Min_5.0% Prob": 3.892812506825316, "Min_10.0% Prob": 2.260227323601059, "Min_20.0% Prob": 1.1738780530023516, "Min_30.0% Prob": 0.7873060704829792, "Min_40.0% Prob": 0.5897765719983044, "Min_50.0% Prob": 0.4722144492106091, "Min_60.0% Prob": 0.39368418819686646}}
{"hexsha": "832205708c121ac9bd47d0e83924afa467bc1da3", "ext": "java", "lang": "Java", "content": "public class AssignmentBaseTest {\n\n    protected StringUtils utils = spy(StringUtils.class);\n\n    public void setUp() throws Exception {\n        // Prevent runtime GWT.create() error at DesignerEditorConstants.INSTANCE\n        GWTMockUtilities.disarm();\n        // MockDesignerEditorConstants replaces DesignerEditorConstants.INSTANCE\n        final Answer answer = invocation -> invocation.getMethod().getName();\n        final DesignerEditorConstants designerEditorConstants = mock(DesignerEditorConstants.class,\n                                                                     answer);\n        setFinalStaticField(DesignerEditorConstants.class.getDeclaredField(\"INSTANCE\"),\n                            designerEditorConstants);\n\n        // Mock StringUtils URL Encoding methods\n         Mockito.when(utils.urlDecode(Mockito.any())).thenAnswer(invocation -> {\n            Object[] args = invocation.getArguments();\n            return urlDecode((String) args[0]);\n        });\n        Mockito.when(utils.urlEncode(Mockito.any())).thenAnswer(invocation -> {\n            Object[] args = invocation.getArguments();\n            return urlEncode((String) args[0]);\n        });\n        Assignment.setStringUtils(utils);\n    }\n\n    public void tearDown() {\n        GWTMockUtilities.restore();\n    }\n\n    /**\n     * Implementation of urlEncode for PowerMocked StringUtils\n     * @param s\n     * @return\n     */\n    public String urlEncode(String s) {\n        if (s == null || s.isEmpty()) {\n            return s;\n        }\n\n        try {\n            return URLEncoder.encode(s,\n                                     \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            return s;\n        }\n    }\n\n    /**\n     * Implementation of urlDecode for PowerMocked StringUtils\n     * @param s\n     * @return\n     */\n    public String urlDecode(String s) {\n        if (s == null || s.isEmpty()) {\n            return s;\n        }\n        try {\n            return URLDecoder.decode(s,\n                                     \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            return s;\n        }\n    }\n\n    private void setFinalStaticField(Field field,\n                                     Object newValue) throws Exception {\n        field.setAccessible(true);\n        Field modifiersField = Field.class.getDeclaredField(\"modifiers\");\n        modifiersField.setAccessible(true);\n        modifiersField.setInt(field,\n                              field.getModifiers() & ~Modifier.FINAL);\n        field.set(null,\n                  newValue);\n    }\n}", "item_id": 0, "repo": "Micord/jbpm-designer", "file": "jbpm-designer-client/src/test/java/org/jbpm/designer/client/shared/AssignmentBaseTest.java", "last_update_at": "2022-02-03T15:34:56+00:00", "question_id": "832205708c121ac9bd47d0e83924afa467bc1da3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AssignmentBaseTest {\n    protected StringUtils utils = spy(StringUtils.class);\n    public void setUp() throws Exception {\n        // Prevent runtime GWT.create() error at DesignerEditorConstants.INSTANCE\n        GWTMockUtilities.disarm();\n        // MockDesignerEditorConstants replaces DesignerEditorConstants.INSTANCE\n        final Answer answer = invocation -> invocation.getMethod().getName();\n        final DesignerEditorConstants designerEditorConstants = mock(DesignerEditorConstants.class,\n                                                                     answer);\n        setFinalStaticField(DesignerEditorConstants.class.getDeclaredField(\"INSTANCE\"),\n                            designerEditorConstants);\n        // Mock StringUtils URL Encoding methods\n         Mockito.when(utils.urlDecode(Mockito.any())).thenAnswer(invocation -> {\n            Object[] args = invocation.getArguments();\n            return urlDecode((String) args[0]);\n        });\n        Mockito.when(utils.urlEncode(Mockito.any())).thenAnswer(invocation -> {\n            Object[] args = invocation.getArguments();\n            return urlEncode((String) args[0]);\n        });\n        Assignment.setStringUtils(utils);\n    }\n    public void tearDown() {\n        GWTMockUtilities.restore();\n    }\n    /**\n     * Implementation of urlEncode for PowerMocked StringUtils\n     * @param s\n     * @return\n     */\n    public String urlEncode(String s) {\n        if (s == null || s.isEmpty()) {\n            return s;\n        }\n        try {\n            return URLEncoder.encode(s,\n                                     \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            return s;\n        }\n    }\n    /**\n     * Implementation of urlDecode for PowerMocked StringUtils\n     * @param s\n     * @return\n     */\n    public String urlDecode(String s) {\n        if (s == null || s.isEmpty()) {\n            return s;\n        }\n        try {\n            return URLDecoder.decode(s,\n                                     \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            return s;\n        }\n    }\n    private void setFinalStaticField(Field field,\n                                     Object newValue) throws Exception {\n        field.setAccessible(true);\n        Field modifiersField = Field.class.getDeclaredField(\"modifiers\");\n        modifiersField.setAccessible(true);\n        modifiersField.setInt(field,\n                              field.getModifiers() & ~Modifier.FINAL);\n        field.set(null,\n                  newValue);\n    }\n"]], "pred": {"ppl": 1.7503362894058228, "ppl_lower": 2.1220390796661377, "ppl/lowercase_ppl": -1.343992125899828, "ppl/zlib": 0.0007710853097090606, "Min_5.0% Prob": 6.619772968870221, "Min_10.0% Prob": 4.573729999137647, "Min_20.0% Prob": 2.7120005192630217, "Min_30.0% Prob": 1.8605891766421723, "Min_40.0% Prob": 1.4013627463366103, "Min_50.0% Prob": 1.1189828616091446, "Min_60.0% Prob": 0.9332802789898645}}
{"hexsha": "e3312ea73716161dc23a3e1955fa1343fb8bc85b", "ext": "java", "lang": "Java", "content": "@Getter\npublic class QueryRunner {\n\n    static {\n        try {\n            Class.forName(\"com.aliyun.fastmodel.driver.client.FastModelEngineDriver\");\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private final Properties properties;\n\n    public QueryRunner(Properties properties) {\n        this.properties = properties;\n    }\n\n    public Connection getConnection() throws Exception {\n        String url = properties.getProperty(\"url\");\n        boolean prefix = url.startsWith(\"jdbc:fastmodel\");\n        if (prefix) {\n            return DriverManager.getConnection(url, properties);\n        }\n        return DriverManager.getConnection(\"jdbc:fastmodel://\" + url, properties);\n    }\n\n    public QueryResult execute(String statement) throws SQLException {\n        try (Connection connection = getConnection(); Statement statementObject = connection.createStatement()) {\n            if (!DriverUtil.isSelect(statement)) {\n                statementObject.executeUpdate(statement);\n                return QueryResult.EMPTY;\n            }\n            ResultSet resultSet = statementObject.executeQuery(statement);\n            if (resultSet == null) {\n                return QueryResult.EMPTY;\n            }\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            List<DriverColumnInfo> columnInfo = toDriverColumn(metaData);\n            List<DriverRow> rows = toRows(resultSet);\n            return new QueryResult(\n                columnInfo,\n                rows\n            );\n        } catch (Exception e) {\n            throw new SQLException(\"execute statement exception\", e);\n        }\n    }\n\n    private List<DriverRow> toRows(ResultSet resultSet) throws SQLException {\n        List<DriverRow> driverRows = new ArrayList<>();\n        while (resultSet.next()) {\n            int columnCount = resultSet.getMetaData().getColumnCount();\n            List<Object> list = new ArrayList<>();\n            for (int i = 1; i <= columnCount; i++) {\n                list.add(resultSet.getObject(i));\n            }\n            DriverRow driverRow = new DriverRow(list);\n            driverRows.add(driverRow);\n        }\n        return driverRows;\n    }\n\n    private List<DriverColumnInfo> toDriverColumn(ResultSetMetaData metaData) throws SQLException {\n        int columnCount = metaData.getColumnCount();\n        List<DriverColumnInfo> driverColumnInfo = new ArrayList<>();\n        for (int i = 1; i <= columnCount; i++) {\n            driverColumnInfo.add(\n                new DriverColumnInfo(metaData.getColumnName(i), new DriverDataType(metaData.getColumnType(i))));\n        }\n        return driverColumnInfo;\n    }\n}", "item_id": 0, "repo": "alibaba/fast-modeling-language", "file": "fastmodel-driver/fastmodel-driver-cli/src/main/java/com/aliyun/fastmodel/driver/cli/terminal/QueryRunner.java", "last_update_at": "2022-03-28T01:43:43+00:00", "question_id": "e3312ea73716161dc23a3e1955fa1343fb8bc85b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Getter\npublic class QueryRunner {\n    static {\n        try {\n            Class.forName(\"com.aliyun.fastmodel.driver.client.FastModelEngineDriver\");\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    private final Properties properties;\n    public QueryRunner(Properties properties) {\n        this.properties = properties;\n    }\n    public Connection getConnection() throws Exception {\n        String url = properties.getProperty(\"url\");\n        boolean prefix = url.startsWith(\"jdbc:fastmodel\");\n        if (prefix) {\n            return DriverManager.getConnection(url, properties);\n        }\n        return DriverManager.getConnection(\"jdbc:fastmodel://\" + url, properties);\n    }\n    public QueryResult execute(String statement) throws SQLException {\n        try (Connection connection = getConnection(); Statement statementObject = connection.createStatement()) {\n            if (!DriverUtil.isSelect(statement)) {\n                statementObject.executeUpdate(statement);\n                return QueryResult.EMPTY;\n            }\n            ResultSet resultSet = statementObject.executeQuery(statement);\n            if (resultSet == null) {\n                return QueryResult.EMPTY;\n            }\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            List<DriverColumnInfo> columnInfo = toDriverColumn(metaData);\n            List<DriverRow> rows = toRows(resultSet);\n            return new QueryResult(\n                columnInfo,\n                rows\n            );\n        } catch (Exception e) {\n            throw new SQLException(\"execute statement exception\", e);\n        }\n    }\n    private List<DriverRow> toRows(ResultSet resultSet) throws SQLException {\n        List<DriverRow> driverRows = new ArrayList<>();\n        while (resultSet.next()) {\n            int columnCount = resultSet.getMetaData().getColumnCount();\n            List<Object> list = new ArrayList<>();\n            for (int i = 1; i <= columnCount; i++) {\n                list.add(resultSet.getObject(i));\n            }\n            DriverRow driverRow = new DriverRow(list);\n            driverRows.add(driverRow);\n        }\n        return driverRows;\n    }\n    private List<DriverColumnInfo> toDriverColumn(ResultSetMetaData metaData) throws SQLException {\n        int columnCount = metaData.getColumnCount();\n        List<DriverColumnInfo> driverColumnInfo = new ArrayList<>();\n        for (int i = 1; i <= columnCount; i++) {\n            driverColumnInfo.add(\n                new DriverColumnInfo(metaData.getColumnName(i), new DriverDataType(metaData.getColumnType(i))));\n        }\n        return driverColumnInfo;\n    }\n"]], "pred": {"ppl": 1.5500459671020508, "ppl_lower": 1.8175621032714844, "ppl/lowercase_ppl": -1.363260579095743, "ppl/zlib": 0.0005692007619302474, "Min_5.0% Prob": 5.30093789100647, "Min_10.0% Prob": 3.5377127464000995, "Min_20.0% Prob": 2.078701808479906, "Min_30.0% Prob": 1.4437310242531252, "Min_40.0% Prob": 1.091951482047732, "Min_50.0% Prob": 0.8752922532957887, "Min_60.0% Prob": 0.7313059400719693}}
{"hexsha": "c5e46d9d212669c7df7565125f2693ef177bcf5a", "ext": "java", "lang": "Java", "content": "public class S2029StoneGameIX {\n    public boolean stoneGameIX(int[] stones) {\n        int[] cnt = new int[3];\n        for (int a: stones)\n            cnt[a % 3]++;\n        if (Math.min(cnt[1], cnt[2]) == 0)\n            return Math.max(cnt[1], cnt[2]) > 2 && cnt[0] % 2 > 0;\n        return Math.abs(cnt[1] - cnt[2]) > 2 || cnt[0] % 2 == 0;\n    }\n}", "item_id": 0, "repo": "camelcc/leetcode", "file": "src/S2029StoneGameIX.java", "last_update_at": "2022-01-04T04:01:32+00:00", "question_id": "c5e46d9d212669c7df7565125f2693ef177bcf5a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class S2029StoneGameIX {\n    public boolean stoneGameIX(int[] stones) {\n        int[] cnt = new int[3];\n        for (int a: stones)\n            cnt[a % 3]++;\n        if (Math.min(cnt[1], cnt[2]) == 0)\n            return Math.max(cnt[1], cnt[2]) > 2 && cnt[0] % 2 > 0;\n        return Math.abs(cnt[1] - cnt[2]) > 2 || cnt[0] % 2 == 0;\n    }\n"]], "pred": {"ppl": 2.084376811981201, "ppl_lower": 2.64176344871521, "ppl/lowercase_ppl": -1.3226500384186586, "ppl/zlib": 0.0038860842298295874, "Min_5.0% Prob": 5.427128451211112, "Min_10.0% Prob": 4.488351787839617, "Min_20.0% Prob": 3.2111413725491227, "Min_30.0% Prob": 2.3600452935153786, "Min_40.0% Prob": 1.8082253639980899, "Min_50.0% Prob": 1.4583833399354607, "Min_60.0% Prob": 1.231789589288052}}
{"hexsha": "8eaa37d9cc5cfaa3796e11223cb01e3f3e94329e", "ext": "java", "lang": "Java", "content": "@ChannelHandler.Sharable\npublic class ConnectionCounter extends ChannelInboundHandlerAdapter {\n    private final AtomicInteger connections;\n    private final AtomicLong totalConnections;\n\n    public ConnectionCounter(AtomicInteger connections, AtomicLong totalConnections) {\n        this.connections = connections;\n        this.totalConnections = totalConnections;\n    }\n\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        connections.incrementAndGet();\n        totalConnections.incrementAndGet();\n        ctx.channel().closeFuture().addListener(f -> connections.decrementAndGet());\n\n        super.channelActive(ctx);\n    }\n\n    public int getConnectionCount() {\n        return connections.get();\n    }\n\n    public long getTotalConnections() {\n        return totalConnections.get();\n    }\n}", "item_id": 0, "repo": "xformation/xformation-compliancemanager-service", "file": "compliancemanager-server/src/main/java/com/synectiks/process/server/plugin/inputs/util/ConnectionCounter.java", "last_update_at": "2022-01-09T12:50:05+00:00", "question_id": "8eaa37d9cc5cfaa3796e11223cb01e3f3e94329e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ChannelHandler.Sharable\npublic class ConnectionCounter extends ChannelInboundHandlerAdapter {\n    private final AtomicInteger connections;\n    private final AtomicLong totalConnections;\n    public ConnectionCounter(AtomicInteger connections, AtomicLong totalConnections) {\n        this.connections = connections;\n        this.totalConnections = totalConnections;\n    }\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        connections.incrementAndGet();\n        totalConnections.incrementAndGet();\n        ctx.channel().closeFuture().addListener(f -> connections.decrementAndGet());\n        super.channelActive(ctx);\n    }\n    public int getConnectionCount() {\n        return connections.get();\n    }\n    public long getTotalConnections() {\n        return totalConnections.get();\n    }\n"]], "pred": {"ppl": 1.5065380334854126, "ppl_lower": 2.0427451133728027, "ppl/lowercase_ppl": -1.7429711520753217, "ppl/zlib": 0.0012806697672688575, "Min_5.0% Prob": 5.146192479133606, "Min_10.0% Prob": 3.3855880439281463, "Min_20.0% Prob": 1.969548262283206, "Min_30.0% Prob": 1.3537882349143426, "Min_40.0% Prob": 1.0219490805291571, "Min_50.0% Prob": 0.8189699942013249, "Min_60.0% Prob": 0.6828693448289413}}
{"hexsha": "a3ea1f2b20b3e5f730f5c572016ffc7f969abaac", "ext": "java", "lang": "Java", "content": "public class PinboardUser implements Serializable {\n    public Long id;\n\n    public List<Pin> getPins() {\n        return pins;\n    }\n\n    public List<Pin> pins;\n\n    public String getState() {\n        return state;\n    }\n\n    public PinboardUser setState(String state) {\n        this.state = state;\n        return this;\n    }\n\n    public String state;\n\n    public PinboardUser(Long id) {\n        this.id = id;\n        this.pins = new ArrayList<>();\n        this.state = \"none\";\n    }\n\n    public void removePin(Pin p) {\n        pins.remove(p);\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public PinboardUser setId(Long id) {\n        this.id = id;\n        return this;\n    }\n\n    public List<Pin> getReadyPins() {\n        List<Pin> readyPins = new ArrayList<>();\n        for(Pin pin:pins) {\n            if(pin.checkMe()) {\n                readyPins.add(pin);\n            }\n        }\n        return readyPins;\n    }\n\n    public void removeExpiredPins() {\n        pins.removeIf(Pin::checkMe);\n    }\n\n    public Pin getPin(Integer id) {\n        return pins.get(id);\n    }\n\n    public void addPin(Pin pin) {\n        pins.add(pin);\n    }\n\n}", "item_id": 0, "repo": "s0m31-hub/pinboard", "file": "src/main/java/org/nwolfhub/pins/PinboardUser.java", "last_update_at": "2022-02-13T20:06:25+00:00", "question_id": "a3ea1f2b20b3e5f730f5c572016ffc7f969abaac_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PinboardUser implements Serializable {\n    public Long id;\n    public List<Pin> getPins() {\n        return pins;\n    }\n    public List<Pin> pins;\n    public String getState() {\n        return state;\n    }\n    public PinboardUser setState(String state) {\n        this.state = state;\n        return this;\n    }\n    public String state;\n    public PinboardUser(Long id) {\n        this.id = id;\n        this.pins = new ArrayList<>();\n        this.state = \"none\";\n    }\n    public void removePin(Pin p) {\n        pins.remove(p);\n    }\n    public Long getId() {\n        return id;\n    }\n    public PinboardUser setId(Long id) {\n        this.id = id;\n        return this;\n    }\n    public List<Pin> getReadyPins() {\n        List<Pin> readyPins = new ArrayList<>();\n        for(Pin pin:pins) {\n            if(pin.checkMe()) {\n                readyPins.add(pin);\n            }\n        }\n        return readyPins;\n    }\n    public void removeExpiredPins() {\n        pins.removeIf(Pin::checkMe);\n    }\n    public Pin getPin(Integer id) {\n        return pins.get(id);\n    }\n    public void addPin(Pin pin) {\n        pins.add(pin);\n    }\n"]], "pred": {"ppl": 1.6709043979644775, "ppl_lower": 1.8483304977416992, "ppl/lowercase_ppl": -1.196580903472014, "ppl/zlib": 0.0014181354572034986, "Min_5.0% Prob": 5.786455819481297, "Min_10.0% Prob": 4.099313161875072, "Min_20.0% Prob": 2.402289019603478, "Min_30.0% Prob": 1.6718860028082865, "Min_40.0% Prob": 1.272180065096013, "Min_50.0% Prob": 1.0234367969494902, "Min_60.0% Prob": 0.8544647192946031}}
{"hexsha": "ddeb8129068939c966b46e68d4be152042d45fc4", "ext": "java", "lang": "Java", "content": "public class CustomXsltComponent extends XsltComponent {\r\n\r\n    protected static final Log log = LogFactory.getLog(CustomXsltComponent.class);\r\n\r\n\r\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\r\n        Resource resource = resolveMandatoryResource(remaining);\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(this + \" using schema resource: \" + resource);\r\n        }\r\n        XsltBuilder xslt = getCamelContext().getInjector().newInstance(XsltBuilder.class);\r\n\r\n        // lets allow the converter to be configured\r\n        XmlConverter converter = resolveAndRemoveReferenceParameter(parameters, \"converter\", XmlConverter.class);\r\n        if (converter == null) {\r\n            converter = getXmlConverter();\r\n        }\r\n        if (converter != null) {\r\n            xslt.setConverter(converter);\r\n        }\r\n\r\n        String transformerFactoryClassName = getAndRemoveParameter(parameters, \"transformerFactoryClass\", String.class);\r\n        TransformerFactory factory = null;\r\n        if (transformerFactoryClassName != null) {\r\n            // provide the class loader of this component to work in OSGi environments\r\n            Class<?> factoryClass = getCamelContext().getClassResolver().resolveClass(transformerFactoryClassName, XsltComponent.class.getClassLoader());\r\n            if (factoryClass != null) {\r\n                factory = (TransformerFactory) getCamelContext().getInjector().newInstance(factoryClass);\r\n            } else {\r\n                log.warn(\"Cannot find the TransformerFactoryClass with the class name: \" + transformerFactoryClassName);\r\n            }\r\n        }\r\n\r\n        if (parameters.get(\"transformerFactory\") != null) {\r\n            factory = resolveAndRemoveReferenceParameter(parameters, \"transformerFactory\", TransformerFactory.class);\r\n        }\r\n\r\n        if (factory != null) {\r\n            xslt.getConverter().setTransformerFactory(factory);\r\n        }\r\n\r\n        log.info(\"Transformer factory  : \" + xslt.getConverter().getTransformerFactory().getClass().getName());\r\n        xslt.getConverter()\r\n                .getTransformerFactory()\r\n                .setURIResolver(new ClasspathURIResolver(getResourceLoader(),\r\n                remaining.substring(0, remaining.lastIndexOf('/') + 1) ));\r\n        xslt.setTransformerInputStream(resource.getInputStream());\r\n\r\n        configureXslt(xslt, uri, remaining, parameters);\r\n        return new ProcessorEndpoint(uri, this, xslt);\r\n    }\r\n\r\n\r\n}", "item_id": 0, "repo": "colorshifter/caaers", "file": "caAERS/software/jbi/caaers2adeers-sync/core-camel-su/src/main/java/gov/nih/nci/cabig/caaers2adeers/xslt/CustomXsltComponent.java", "last_update_at": "2022-02-01T01:03:15+00:00", "question_id": "ddeb8129068939c966b46e68d4be152042d45fc4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CustomXsltComponent extends XsltComponent {\r\n\r\n    protected static final Log log = LogFactory.getLog(CustomXsltComponent.class);\r\n\r\n\r\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\r\n        Resource resource = resolveMandatoryResource(remaining);\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(this + \" using schema resource: \" + resource);\r\n        }\r\n        XsltBuilder xslt = getCamelContext().getInjector().newInstance(XsltBuilder.class);\r\n\r\n        // lets allow the converter to be configured\r\n        XmlConverter converter = resolveAndRemoveReferenceParameter(parameters, \"converter\", XmlConverter.class);\r\n        if (converter == null) {\r\n            converter = getXmlConverter();\r\n        }\r\n        if (converter != null) {\r\n            xslt.setConverter(converter);\r\n        }\r\n\r\n        String transformerFactoryClassName = getAndRemoveParameter(parameters, \"transformerFactoryClass\", String.class);\r\n        TransformerFactory factory = null;\r\n        if (transformerFactoryClassName != null) {\r\n            // provide the class loader of this component to work in OSGi environments\r\n            Class<?> factoryClass = getCamelContext().getClassResolver().resolveClass(transformerFactoryClassName, XsltComponent.class.getClassLoader());\r\n            if (factoryClass != null) {\r\n                factory = (TransformerFactory) getCamelContext().getInjector().newInstance(factoryClass);\r\n            } else {\r\n                log.warn(\"Cannot find the TransformerFactoryClass with the class name: \" + transformerFactoryClassName);\r\n            }\r\n        }\r\n\r\n        if (parameters.get(\"transformerFactory\") != null) {\r\n            factory = resolveAndRemoveReferenceParameter(parameters, \"transformerFactory\", TransformerFactory.class);\r\n        }\r\n\r\n        if (factory != null) {\r\n            xslt.getConverter().setTransformerFactory(factory);\r\n        }\r\n\r\n        log.info(\"Transformer factory  : \" + xslt.getConverter().getTransformerFactory().getClass().getName());\r\n        xslt.getConverter()\r\n                .getTransformerFactory()\r\n                .setURIResolver(new ClasspathURIResolver(getResourceLoader(),\r\n                remaining.substring(0, remaining.lastIndexOf('/') + 1) ));\r\n        xslt.setTransformerInputStream(resource.getInputStream());\r\n\r\n        configureXslt(xslt, uri, remaining, parameters);\r\n        return new ProcessorEndpoint(uri, this, xslt);\r\n    }\r\n\r\n\r\n"]], "pred": {"ppl": 2.0127906799316406, "ppl_lower": 2.4394078254699707, "ppl/lowercase_ppl": -1.274806389335925, "ppl/zlib": 0.0008530758013580998, "Min_5.0% Prob": 6.354032707214356, "Min_10.0% Prob": 4.8179444392522175, "Min_20.0% Prob": 3.1784897806230656, "Min_30.0% Prob": 2.2731709567072627, "Min_40.0% Prob": 1.7397055178267475, "Min_50.0% Prob": 1.398363535163777, "Min_60.0% Prob": 1.166405217505175}}
{"hexsha": "489066975d59139b57dfd440f27f5e5586b2fca7", "ext": "java", "lang": "Java", "content": "@Test(groups = { \"UnitTests\" })\npublic class CellDeepJobConfigMongoDBTest {\n\n    @Test\n    public void createTest() {\n\n        MongoDeepJobConfig<Cells> cellDeepJobConfigMongoDB = new MongoDeepJobConfig(Cells.class);\n\n        assertNotNull(cellDeepJobConfigMongoDB);\n\n        assertEquals(cellDeepJobConfigMongoDB.getEntityClass(), Cells.class);\n\n    }\n\n}", "item_id": 0, "repo": "xsir/stratio-deep", "file": "deep-mongodb/src/test/java/com/stratio/deep/mongodb/config/CellDeepJobConfigMongoDBTest.java", "last_update_at": "2022-01-20T01:52:58+00:00", "question_id": "489066975d59139b57dfd440f27f5e5586b2fca7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Test(groups = { \"UnitTests\" })\npublic class CellDeepJobConfigMongoDBTest {\n    @Test\n    public void createTest() {\n        MongoDeepJobConfig<Cells> cellDeepJobConfigMongoDB = new MongoDeepJobConfig(Cells.class);\n        assertNotNull(cellDeepJobConfigMongoDB);\n        assertEquals(cellDeepJobConfigMongoDB.getEntityClass(), Cells.class);\n    }\n"]], "pred": {"ppl": 3.7121386528015137, "ppl_lower": 5.085073947906494, "ppl/lowercase_ppl": -1.239935533268022, "ppl/zlib": 0.00728671203784988, "Min_5.0% Prob": 8.240843200683594, "Min_10.0% Prob": 7.232508052479137, "Min_20.0% Prob": 5.420242506524791, "Min_30.0% Prob": 4.04919448670219, "Min_40.0% Prob": 3.1633861026038295, "Min_50.0% Prob": 2.6190342335847387, "Min_60.0% Prob": 2.181664613979882}}
{"hexsha": "cfc0e7d283fd37db786eeef8b0877feba002ecf5", "ext": "java", "lang": "Java", "content": "public class Contacts {\n    private static Scanner in = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        int queries = in.nextInt();\n        performQueries(queries);\n    }\n\n    private static void performQueries(int queries){\n        Trie contacts = new Trie();\n\n        while (queries-- > 0){\n            String operation = in.next();\n            String name = in.next();\n\n            if(operation.charAt(0) == 'a'){\n                contacts.addWord(name);\n            } else {\n                System.out.println(contacts.numberOfClosestEntries(name));\n            }\n        }\n\n        contacts.print();\n    }\n}", "item_id": 2, "repo": "anishLearnsToCode/hackerrank-data-structures", "file": "src/trie/Contacts.java", "last_update_at": "2022-03-08T03:16:10+00:00", "question_id": "cfc0e7d283fd37db786eeef8b0877feba002ecf5_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Contacts {\n    private static Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n        int queries = in.nextInt();\n        performQueries(queries);\n    }\n    private static void performQueries(int queries){\n        Trie contacts = new Trie();\n        while (queries-- > 0){\n            String operation = in.next();\n            String name = in.next();\n            if(operation.charAt(0) == 'a'){\n                contacts.addWord(name);\n            } else {\n                System.out.println(contacts.numberOfClosestEntries(name));\n            }\n        }\n        contacts.print();\n    }\n"]], "pred": {"ppl": 2.1508779525756836, "ppl_lower": 2.52213716506958, "ppl/lowercase_ppl": -1.2079063608663, "ppl/zlib": 0.0026139116342067848, "Min_5.0% Prob": 7.643399655818939, "Min_10.0% Prob": 5.723563783309039, "Min_20.0% Prob": 3.527250209876469, "Min_30.0% Prob": 2.4900673625041856, "Min_40.0% Prob": 1.9150984691189867, "Min_50.0% Prob": 1.5319364802403883, "Min_60.0% Prob": 1.2761927188005087}}
{"hexsha": "61c3c2959b3cdcafa1e3f989c8f8e35219894c70", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"serial\")\npublic class AckRemoteApplicationEvent extends RemoteApplicationEvent {\n\n\tprivate final String ackId;\n\n\tprivate final String ackDestinationService;\n\n\tprivate Class<? extends RemoteApplicationEvent> event;\n\n\t@SuppressWarnings(\"unused\")\n\tprivate AckRemoteApplicationEvent() {\n\t\tsuper();\n\t\tthis.ackDestinationService = null;\n\t\tthis.ackId = null;\n\t\tthis.event = null;\n\t}\n\n\tpublic AckRemoteApplicationEvent(Object source, String originService, Destination destination,\n\t\t\tString ackDestinationService, String ackId, Class<? extends RemoteApplicationEvent> type) {\n\t\tsuper(source, originService, destination);\n\t\tthis.ackDestinationService = ackDestinationService;\n\t\tthis.ackId = ackId;\n\t\tthis.event = type;\n\t}\n\n\tpublic String getAckId() {\n\t\treturn this.ackId;\n\t}\n\n\tpublic String getAckDestinationService() {\n\t\treturn this.ackDestinationService;\n\t}\n\n\tpublic Class<? extends RemoteApplicationEvent> getEvent() {\n\t\treturn this.event;\n\t}\n\n\t/**\n\t * Used by Jackson to set the remote class name of the event implementation. If the\n\t * implementing class is unknown to this app, set the event to\n\t * {@link UnknownRemoteApplicationEvent}.\n\t * @param eventName the fq class name of the event implementation, not null\n\t */\n\t@JsonProperty(\"event\")\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void setEventName(String eventName) {\n\t\ttry {\n\t\t\tthis.event = (Class<? extends RemoteApplicationEvent>) Class.forName(eventName);\n\t\t}\n\t\tcatch (ClassNotFoundException e) {\n\t\t\tthis.event = UnknownRemoteApplicationEvent.class;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = super.hashCode();\n\t\tresult = prime * result + ((this.ackDestinationService == null) ? 0 : this.ackDestinationService.hashCode());\n\t\tresult = prime * result + ((this.ackId == null) ? 0 : this.ackId.hashCode());\n\t\tresult = prime * result + ((this.event == null) ? 0 : this.event.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(obj)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (getClass() != obj.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tAckRemoteApplicationEvent other = (AckRemoteApplicationEvent) obj;\n\t\tif (this.ackDestinationService == null) {\n\t\t\tif (other.ackDestinationService != null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (!this.ackDestinationService.equals(other.ackDestinationService)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.ackId == null) {\n\t\t\tif (other.ackId != null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (!this.ackId.equals(other.ackId)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.event == null) {\n\t\t\tif (other.event != null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (!this.event.equals(other.event)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n}", "item_id": 0, "repo": "robertmcnees/spring-cloud-bus", "file": "spring-cloud-bus/src/main/java/org/springframework/cloud/bus/event/AckRemoteApplicationEvent.java", "last_update_at": "2022-03-09T07:24:15+00:00", "question_id": "61c3c2959b3cdcafa1e3f989c8f8e35219894c70_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"serial\")\npublic class AckRemoteApplicationEvent extends RemoteApplicationEvent {\n\tprivate final String ackId;\n\tprivate final String ackDestinationService;\n\tprivate Class<? extends RemoteApplicationEvent> event;\n\t@SuppressWarnings(\"unused\")\n\tprivate AckRemoteApplicationEvent() {\n\t\tsuper();\n\t\tthis.ackDestinationService = null;\n\t\tthis.ackId = null;\n\t\tthis.event = null;\n\t}\n\tpublic AckRemoteApplicationEvent(Object source, String originService, Destination destination,\n\t\t\tString ackDestinationService, String ackId, Class<? extends RemoteApplicationEvent> type) {\n\t\tsuper(source, originService, destination);\n\t\tthis.ackDestinationService = ackDestinationService;\n\t\tthis.ackId = ackId;\n\t\tthis.event = type;\n\t}\n\tpublic String getAckId() {\n\t\treturn this.ackId;\n\t}\n\tpublic String getAckDestinationService() {\n\t\treturn this.ackDestinationService;\n\t}\n\tpublic Class<? extends RemoteApplicationEvent> getEvent() {\n\t\treturn this.event;\n\t}\n\t/**\n\t * Used by Jackson to set the remote class name of the event implementation. If the\n\t * implementing class is unknown to this app, set the event to\n\t * {@link UnknownRemoteApplicationEvent}.\n\t * @param eventName the fq class name of the event implementation, not null\n\t */\n\t@JsonProperty(\"event\")\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void setEventName(String eventName) {\n\t\ttry {\n\t\t\tthis.event = (Class<? extends RemoteApplicationEvent>) Class.forName(eventName);\n\t\t}\n\t\tcatch (ClassNotFoundException e) {\n\t\t\tthis.event = UnknownRemoteApplicationEvent.class;\n\t\t}\n\t}\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = super.hashCode();\n\t\tresult = prime * result + ((this.ackDestinationService == null) ? 0 : this.ackDestinationService.hashCode());\n\t\tresult = prime * result + ((this.ackId == null) ? 0 : this.ackId.hashCode());\n\t\tresult = prime * result + ((this.event == null) ? 0 : this.event.hashCode());\n\t\treturn result;\n\t}\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(obj)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (getClass() != obj.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tAckRemoteApplicationEvent other = (AckRemoteApplicationEvent) obj;\n\t\tif (this.ackDestinationService == null) {\n\t\t\tif (other.ackDestinationService != null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (!this.ackDestinationService.equals(other.ackDestinationService)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.ackId == null) {\n\t\t\tif (other.ackId != null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (!this.ackId.equals(other.ackId)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.event == null) {\n\t\t\tif (other.event != null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (!this.event.equals(other.event)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n"]], "pred": {"ppl": 1.3337067365646362, "ppl_lower": 1.4744442701339722, "ppl/lowercase_ppl": -1.3483759568076228, "ppl/zlib": 0.00037740771385045614, "Min_5.0% Prob": 4.379840840684607, "Min_10.0% Prob": 2.6867368706363313, "Min_20.0% Prob": 1.4304999723320915, "Min_30.0% Prob": 0.9614464351627646, "Min_40.0% Prob": 0.7204856506989845, "Min_50.0% Prob": 0.5758844562846184, "Min_60.0% Prob": 0.4804344657021969}}
{"hexsha": "30478cddac65a94789f4ba4ae10d6f93c87e8f41", "ext": "java", "lang": "Java", "content": "@RequestScoped\n@PingInterceptorBinding\npublic class PingCDIBean {\n\n    private static int helloHitCount = 0;\n    private static int getBeanManagerHitCountJNDI = 0;\n    private static int getBeanManagerHitCountSPI = 0;\n\n    \n    public int hello() {\n        return ++helloHitCount;\n    }\n\n    public int getBeanMangerViaJNDI() throws Exception {\n        BeanManager beanManager = (BeanManager) new InitialContext().lookup(\"java:comp/BeanManager\");\n        Set<Bean<?>> beans = beanManager.getBeans(Object.class);\n        if (beans.size() > 0) {\n            return ++getBeanManagerHitCountJNDI;\n        }\n        return 0;\n\n    }\n    \n    public int getBeanMangerViaCDICurrent() throws Exception {\n        BeanManager beanManager = CDI.current().getBeanManager();\n        Set<Bean<?>> beans = beanManager.getBeans(Object.class);\n        \n        if (beans.size() > 0) {\n            return ++getBeanManagerHitCountSPI;\n        }\n        return 0;\n\n    }\n}", "item_id": 0, "repo": "tdalsing-pivotal/sample.daytrader7", "file": "daytrader-ee7-web/src/main/java/com/ibm/websphere/samples/daytrader/web/prims/PingCDIBean.java", "last_update_at": "2022-03-09T07:20:52+00:00", "question_id": "30478cddac65a94789f4ba4ae10d6f93c87e8f41_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RequestScoped\n@PingInterceptorBinding\npublic class PingCDIBean {\n    private static int helloHitCount = 0;\n    private static int getBeanManagerHitCountJNDI = 0;\n    private static int getBeanManagerHitCountSPI = 0;\n    public int hello() {\n        return ++helloHitCount;\n    }\n    public int getBeanMangerViaJNDI() throws Exception {\n        BeanManager beanManager = (BeanManager) new InitialContext().lookup(\"java:comp/BeanManager\");\n        Set<Bean<?>> beans = beanManager.getBeans(Object.class);\n        if (beans.size() > 0) {\n            return ++getBeanManagerHitCountJNDI;\n        }\n        return 0;\n    }\n    public int getBeanMangerViaCDICurrent() throws Exception {\n        BeanManager beanManager = CDI.current().getBeanManager();\n        Set<Bean<?>> beans = beanManager.getBeans(Object.class);\n        if (beans.size() > 0) {\n            return ++getBeanManagerHitCountSPI;\n        }\n        return 0;\n    }\n"]], "pred": {"ppl": 2.07266902923584, "ppl_lower": 2.70400071144104, "ppl/lowercase_ppl": -1.364821213857142, "ppl/zlib": 0.0022220645208449294, "Min_5.0% Prob": 8.126283713749476, "Min_10.0% Prob": 5.881443286764211, "Min_20.0% Prob": 3.511884959607289, "Min_30.0% Prob": 2.4024356992237945, "Min_40.0% Prob": 1.821489543837105, "Min_50.0% Prob": 1.4546228918139221, "Min_60.0% Prob": 1.2165550332045478}}
{"hexsha": "6de71c59202d774e3e87ef910384b8fb289cb435", "ext": "java", "lang": "Java", "content": "public class PermissionsDetailDialogFragment extends BasePermissionsDialogFragment\n{\n  @Nullable\n  public static DialogFragment show(@NonNull FragmentActivity activity, int requestCode)\n  {\n    DialogFragment dialog = BasePermissionsDialogFragment.show(activity, requestCode,\n                                       PermissionsDetailDialogFragment.class);\n    if (dialog != null)\n      dialog.setCancelable(true);\n    return dialog;\n  }\n\n  @Nullable\n  public static DialogFragment find(@NonNull FragmentActivity activity)\n  {\n    final FragmentManager fm = activity.getSupportFragmentManager();\n    if (fm.isDestroyed())\n      return null;\n\n    Fragment f = fm.findFragmentByTag(PermissionsDetailDialogFragment.class.getName());\n    return (DialogFragment) f;\n  }\n\n  @NonNull\n  @Override\n  public Dialog onCreateDialog(Bundle savedInstanceState)\n  {\n    Dialog res = super.onCreateDialog(savedInstanceState);\n    RecyclerView permissions = (RecyclerView) res.findViewById(R.id.rv__permissions);\n    permissions.setLayoutManager(new LinearLayoutManager(getContext(),\n                                                         LinearLayoutManager.VERTICAL, false));\n    permissions.setAdapter(new PermissionsAdapter());\n    TextView acceptBtn = res.findViewById(R.id.accept_btn);\n    acceptBtn.setText(R.string.continue_download);\n    TextView declineBtn = res.findViewById(R.id.decline_btn);\n    declineBtn.setText(R.string.back);\n    return res;\n  }\n\n  @LayoutRes\n  @Override\n  protected int getLayoutRes()\n  {\n    return R.layout.fragment_detail_permissions;\n  }\n\n  @IdRes\n  @Override\n  protected int getFirstActionButton()\n  {\n    return R.id.decline_btn;\n  }\n\n  @Override\n  protected void onFirstActionClick()\n  {\n    dismiss();\n  }\n\n  @IdRes\n  @Override\n  protected int getContinueActionButton()\n  {\n    return R.id.accept_btn;\n  }\n}", "item_id": 0, "repo": "vicpopov/omim", "file": "android/src/com/mapswithme/maps/permissions/PermissionsDetailDialogFragment.java", "last_update_at": "2022-03-31T18:43:03+00:00", "question_id": "6de71c59202d774e3e87ef910384b8fb289cb435_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PermissionsDetailDialogFragment extends BasePermissionsDialogFragment\n{\n  @Nullable\n  public static DialogFragment show(@NonNull FragmentActivity activity, int requestCode)\n  {\n    DialogFragment dialog = BasePermissionsDialogFragment.show(activity, requestCode,\n                                       PermissionsDetailDialogFragment.class);\n    if (dialog != null)\n      dialog.setCancelable(true);\n    return dialog;\n  }\n  @Nullable\n  public static DialogFragment find(@NonNull FragmentActivity activity)\n  {\n    final FragmentManager fm = activity.getSupportFragmentManager();\n    if (fm.isDestroyed())\n      return null;\n    Fragment f = fm.findFragmentByTag(PermissionsDetailDialogFragment.class.getName());\n    return (DialogFragment) f;\n  }\n  @NonNull\n  @Override\n  public Dialog onCreateDialog(Bundle savedInstanceState)\n  {\n    Dialog res = super.onCreateDialog(savedInstanceState);\n    RecyclerView permissions = (RecyclerView) res.findViewById(R.id.rv__permissions);\n    permissions.setLayoutManager(new LinearLayoutManager(getContext(),\n                                                         LinearLayoutManager.VERTICAL, false));\n    permissions.setAdapter(new PermissionsAdapter());\n    TextView acceptBtn = res.findViewById(R.id.accept_btn);\n    acceptBtn.setText(R.string.continue_download);\n    TextView declineBtn = res.findViewById(R.id.decline_btn);\n    declineBtn.setText(R.string.back);\n    return res;\n  }\n  @LayoutRes\n  @Override\n  protected int getLayoutRes()\n  {\n    return R.layout.fragment_detail_permissions;\n  }\n  @IdRes\n  @Override\n  protected int getFirstActionButton()\n  {\n    return R.id.decline_btn;\n  }\n  @Override\n  protected void onFirstActionClick()\n  {\n    dismiss();\n  }\n  @IdRes\n  @Override\n  protected int getContinueActionButton()\n  {\n    return R.id.accept_btn;\n  }\n"]], "pred": {"ppl": 1.7283824682235718, "ppl_lower": 2.066483736038208, "ppl/lowercase_ppl": -1.3265114768329793, "ppl/zlib": 0.0008868492409533945, "Min_5.0% Prob": 5.9972314453125, "Min_10.0% Prob": 4.299387769699097, "Min_20.0% Prob": 2.570264582881833, "Min_30.0% Prob": 1.8012492956211235, "Min_40.0% Prob": 1.362873056700619, "Min_50.0% Prob": 1.0954823149368167, "Min_60.0% Prob": 0.9117513057382366}}
{"hexsha": "3b7b2f703dc11a8c7580e54214320e6c33a6a3b9", "ext": "java", "lang": "Java", "content": "public final class HelloWorldPostServer {\n\tpublic static final int PORT = getFreePort();\n\tpublic static final String HELLO_WORLD = \"Hello, World!\";\n\n\tpublic static AsyncHttpServer helloWorldServer(Eventloop primaryEventloop, int port) {\n\t\treturn AsyncHttpServer.create(primaryEventloop,\n\t\t\t\trequest -> request.loadBody()\n\t\t\t\t\t\t.map(body -> HttpResponse.ok200()\n\t\t\t\t\t\t\t\t.withBody(encodeAscii(HELLO_WORLD + body.getString(UTF_8)))))\n\t\t\t\t.withListenPort(port);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tEventloop primaryEventloop = Eventloop.create().withFatalErrorHandler(rethrowOnAnyError()).withCurrentThread();\n\n\t\tAsyncHttpServer httpServerListener = helloWorldServer(primaryEventloop, PORT);\n\n\t\tSystem.out.println(\"Start HelloWorld HTTP Server on :\" + PORT);\n\t\thttpServerListener.listen();\n\n\t\tprimaryEventloop.run();\n\t}\n\n}", "item_id": 0, "repo": "PetroRavlinko/datakernel", "file": "core-http/src/test/java/io/datakernel/http/HelloWorldPostServer.java", "last_update_at": "2022-02-15T05:23:38+00:00", "question_id": "3b7b2f703dc11a8c7580e54214320e6c33a6a3b9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class HelloWorldPostServer {\n\tpublic static final int PORT = getFreePort();\n\tpublic static final String HELLO_WORLD = \"Hello, World!\";\n\tpublic static AsyncHttpServer helloWorldServer(Eventloop primaryEventloop, int port) {\n\t\treturn AsyncHttpServer.create(primaryEventloop,\n\t\t\t\trequest -> request.loadBody()\n\t\t\t\t\t\t.map(body -> HttpResponse.ok200()\n\t\t\t\t\t\t\t\t.withBody(encodeAscii(HELLO_WORLD + body.getString(UTF_8)))))\n\t\t\t\t.withListenPort(port);\n\t}\n\tpublic static void main(String[] args) throws Exception {\n\t\tEventloop primaryEventloop = Eventloop.create().withFatalErrorHandler(rethrowOnAnyError()).withCurrentThread();\n\t\tAsyncHttpServer httpServerListener = helloWorldServer(primaryEventloop, PORT);\n\t\tSystem.out.println(\"Start HelloWorld HTTP Server on :\" + PORT);\n\t\thttpServerListener.listen();\n\t\tprimaryEventloop.run();\n\t}\n"]], "pred": {"ppl": 2.138856887817383, "ppl_lower": 3.162587881088257, "ppl/lowercase_ppl": -1.5144466275813477, "ppl/zlib": 0.0017973322027085674, "Min_5.0% Prob": 7.517625221839318, "Min_10.0% Prob": 5.257204894666319, "Min_20.0% Prob": 3.3433970797944954, "Min_30.0% Prob": 2.436155945430567, "Min_40.0% Prob": 1.8818993991999715, "Min_50.0% Prob": 1.5192653573497579, "Min_60.0% Prob": 1.2699854640681068}}
{"hexsha": "7c39078e69295fbfefa032d8672d85f58334ba4b", "ext": "java", "lang": "Java", "content": "public class OpenfireX509TrustManager implements X509TrustManager\n{\n    private static final Logger Log = LoggerFactory.getLogger( OpenfireX509TrustManager.class );\n    \n    private SSLEngine engine;\n    \n    static\n    {\n    \tCryptoUtils.registerJCEProviders();\n    }\n\n    /**\n     * A boolean that indicates if this trust manager will allow self-signed certificates to be trusted.\n     */\n    protected final boolean acceptSelfSigned;\n\n    /**\n     * A boolean that indicates if this trust manager will check if all certificates in the chain (including the root\n     * certificates) are currently valid (notBefore/notAfter check).\n     */\n    private final boolean checkValidity;\n\n    protected TrustCircleManager circleManager;\n    \n    public OpenfireX509TrustManager( TrustCircleManager circleManager, boolean acceptSelfSigned, boolean checkValidity ) throws NoSuchAlgorithmException, KeyStoreException\n    {\n    \tthis.circleManager = circleManager;\n        this.acceptSelfSigned = acceptSelfSigned;\n        this.checkValidity = checkValidity;\n\n        Log.debug( \"Constructed trust manager. Accepts self-signed: {}, checks validity: {}\", acceptSelfSigned, checkValidity );\n    }\n\n    public void setSSLEngine(SSLEngine engine)\n    {\n    \tthis.engine = engine;\n    }\n    \n    @Override\n    public void checkClientTrusted( X509Certificate[] chain, String authType ) throws CertificateException\n    {\n        // Find and use the end entity as the selector for verification.\n        final X509Certificate endEntityCert = CertificateUtils.identifyEndEntityCertificate( Arrays.asList( chain ) );\n        final X509CertSelector selector = new X509CertSelector();\n        selector.setCertificate( endEntityCert );\n\n        try\n        {\n            checkChainTrusted( selector, chain );\n        }\n        catch ( InvalidAlgorithmParameterException | NoSuchAlgorithmException | CertPathBuilderException ex )\n        {\n            throw new CertificateException( ex );\n        }\n    }\n\n    @Override\n    public void checkServerTrusted( X509Certificate[] chain, String authType ) throws CertificateException\n    {\n        // Find and use the end entity as the selector for verification.\n        final X509Certificate endEntityCert = CertificateUtils.identifyEndEntityCertificate( Arrays.asList( chain ) );\n        final X509CertSelector selector = new X509CertSelector();\n        selector.setCertificate( endEntityCert );\n\n        try\n        {\n            checkChainTrusted( selector, chain );\n        }\n        catch ( InvalidAlgorithmParameterException | NoSuchAlgorithmException | CertPathBuilderException ex )\n        {\n            throw new CertificateException( ex );\n        }\n    }\n\n    @Override\n    public X509Certificate[] getAcceptedIssuers()\n    {\n    \tfinal Set<X509Certificate> result = new HashSet<>();\n    \t\n    \tCollection<TrustCircle> circles = null;\n    \t\n\t\t// make sure we have a reference id so we no what domain connection is being requested\n\t\tfinal String referenceId = getTopDomain(ReferenceIDUtil.getSessionReferenceId(engine.getSession()));\n\t\t\n\t\tLog.debug(\"Looking up trust anchors associated to domain \" + referenceId);\n\t\t\n    \ttry\n    \t{\n\t\t\tif (!StringUtils.isEmpty(referenceId))\n\t    \t{\n\t    \t\t\n\t    \t\tcircles = circleManager.getCirclesByDomain(referenceId, true, true);\n\t    \t}\n\t    \telse\n\t    \t{\n\t    \t\t// fall back \n\t    \t\tcircles = circleManager.getTrustCircles(true, true);\n\t\n\t    \t}\n    \t}\n    \tcatch (Exception e)\n    \t{\n    \t\tLog.warn(\"Could not get trust anchors for trust validation.\");\n    \t}\n    \t\n    \tif (circles == null || circles.isEmpty())\n    \t\treturn new X509Certificate[] {};\n    \t\n    \tfor (TrustCircle circle : circles)\n    \t{\n    \t\tfor (TrustBundle bundle : circle.getTrustBundles())\n    \t\t\tfor (TrustBundleAnchor anchor : bundle.getTrustBundleAnchors())\n    \t\t\t\tif (checkValidity)\n    \t\t\t\t\tresult.addAll(CertificateUtils.filterValid( anchor.asX509Certificate()));\n    \t\t\t\t\t\t\n\t\t\tfor (org.jivesoftware.openfire.trustanchor.TrustAnchor anchor : circle.getAnchors())\n\t\t\t\tif (checkValidity)\n\t\t\t\t\tresult.addAll(CertificateUtils.filterValid( anchor.asX509Certificate()));\t\n    \t\t\n    \t}\n    \t\n        return result.toArray( new X509Certificate[ result.size() ] );\n    }\n\n    /**\n     * Determine if the given partial or complete certificate chain can be trusted to represent the entity that is\n     * defined by the criteria specified by the 'selector' argument.\n     *\n     * A (valid) partial chain is a chain that, combined with certificates from the trust store in this manager, can be\n     * completed to a full chain.\n     *\n     * Chains provided to this method do not need to be in any particular order.\n     *\n     * This implementation uses the trust anchors as represented by {@link #getAcceptedIssuers()} to verify that the\n     * chain that is provided either includes a certificate from an accepted issuer, or is directly issued by one.\n     *\n     * Depending on the configuration of this class, other verification is done:\n     * <ul>\n     *     <li>{@link #acceptSelfSigned}: when {@code true}, any chain that has a length of one and is self-signed is\n     *                                    considered as a 'trust anchor' (but is still subject to other checks, such as\n     *                                    expiration checks).</li>\n     * </ul>\n     *\n     * This method will either return a value, which indicates that the chain is trusted, or will throw an exception.\n     *\n     * @param selector Characteristics of the entity to be represented by the chain (cannot be null).\n     * @param chain The certificate chain that is to be verified (cannot be null or empty).\n     * @return A trusted certificate path (never null).\n     *\n     * @throws InvalidAlgorithmParameterException if the algorithm is invalid\n     * @throws NoSuchAlgorithmException if the algorithm could not be found\n     * @throws CertPathBuilderException if there was a problem with the certificate path\n     */\n    protected CertPath checkChainTrusted( CertSelector selector, X509Certificate... chain ) throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, CertPathBuilderException\n    {\n        if ( selector == null )\n        {\n            throw new IllegalArgumentException( \"Argument 'selector' cannot be null\");\n        }\n\n        if ( chain == null || chain.length == 0 )\n        {\n            throw new IllegalArgumentException( \"Argument 'chain' cannot be null or an empty array.\");\n        }\n\n        Log.debug( \"Attempting to verify a chain of {} certificates.\", chain.length );\n\n        /*\n         * The certificate path validation process checks for valid dates in certificates,\n         * but we will choose to fail fast in anything in the chain is expired.  This will save\n         * time from having to lookup intermediate certificates (if necessary) if the given certificates\n         * are already not valid.\n         */\n        X509Certificate endEntityCert = null;\n\t\ttry\n\t\t{\n\t\t\tendEntityCert = CertificateUtils.identifyEndEntityCertificate( Arrays.asList( chain ) );\n\t\t} \n\t\tcatch (Exception e1)\n\t\t{\n\t\t\tthrow new IllegalArgumentException( \"Could not get end entity certificate from chain.\");\n\t\t}\n\t\t\n\t\tfinal Set<X509Certificate> acceptedServerCerts = CertificateUtils.filterValid( endEntityCert );\n        if (acceptedServerCerts.size() <= 0)\n        {\n        \t// the end entity certificate is invalid\n        \tLog.warn( \"TLS certificate chain has an expired certificate.  This is an invalid chain and the connection is rejected.\" );\n        \tthrow new CertPathBuilderException(\"The certificate chain contains an expired certificate\");\n        }\n        \n        /*\n         * Make sure the certificate isn't revoke.  The default cert path checker can do this work, but the revocation\n         * manager uses some optimizations in terms of caching so the CRL doesn't have to be downloaded every time.\n         */\n        try\n        {\n        \t\n        \tfinal CRLRevocationManager revManager = CRLRevocationManager.getInstance();\n        \t\n        \tif (revManager.isRevoked(endEntityCert))\n        \t{\n        \t\tLog.warn( \"TLS end enity certificate has been marked as revoked.  The connection is rejected.\" );\n        \t\tthrow new CertPathBuilderException(\"TLS end enity certificate has been marked as revoked.\");\n        \t}\n        }\n        catch (CertPathBuilderException e)\n        {\n        \tthrow e;\n        }\n        catch (Exception e)\n        {\n        \tthrow new IllegalArgumentException(\"Could not check revocation status of end entity certificate.\");\n        }\n        \n        \n        \n        // The set of trusted issuers (for this invocation), based on the issuers from the truststore.\n        final Set<X509Certificate> trustedIssuers = new HashSet<>();\n        trustedIssuers.addAll( Arrays.asList(getAcceptedIssuers() ));\n        \n        // When accepting self-signed certificates, and the chain is a self-signed certificate, add it to the collection\n        // of trusted issuers. Blindly accepting this issuer is undesirable, as that would circumvent other checks, such\n        // as expiration checking.\n        if ( acceptSelfSigned && chain.length == 1 )\n        {\n            Log.debug( \"Attempting to accept the self-signed certificate of this chain of length one, as instructed by configuration.\" );\n\n            final X509Certificate cert = chain[0];\n            if ( cert.getSubjectDN().equals( cert.getIssuerDN() ) )\n            {\n                Log.debug( \"Chain of one appears to be self-signed. Adding it to the set of trusted issuers.\" );\n                trustedIssuers.add( cert );\n            }\n            else\n            {\n                Log.debug( \"Chain of one is not self-signed. Not adding it to the set of trusted issuers.\" );\n            }\n        }\n\n        // Turn trusted into accepted issuers.\n        final Set<X509Certificate> acceptedIssuers;\n        if ( checkValidity )\n        {\n            // See what certificates are currently valid.\n            acceptedIssuers = CertificateUtils.filterValid( trustedIssuers );\n        }\n        else\n        {\n            acceptedIssuers = trustedIssuers;\n        }\n\n        Log.debug(\"Using the following trust anchors for checking trust of the TLS connection for certificate \" + endEntityCert.getSubjectDN());\n        for (X509Certificate anchor : acceptedIssuers)\n        \tLog.debug(\"\\tDN=\" + anchor.getIssuerDN());\n        \n        if (acceptedIssuers.isEmpty())\n        {\n        \tLog.warn(\"No accepted issuers were found for certificate DN: {}\", endEntityCert.getSubjectDN().toString());\n        }\n        \n        // Transform all accepted issuers into a set of unique trustAnchors.\n        final Set<TrustAnchor> trustAnchors = CertificateUtils.toTrustAnchors( acceptedIssuers );\n\n        // All certificates that are part of the (possibly incomplete) chain.\n        final CertStore certificates = CertStore.getInstance( \"Collection\", new CollectionCertStoreParameters( Arrays.asList( chain ) ) );\n\n        // Build the configuration for the path builder. It is based on the collection of accepted issuers / trust anchors\n        final PKIXBuilderParameters parameters = new PKIXBuilderParameters( trustAnchors, selector );\n\n        // Validity checks are enabled by default in the CertPathBuilder implementation.\n        if ( !checkValidity )\n        {\n            Log.debug( \"Attempting to ignore any validity (expiry) issues, as instructed by configuration.\" );\n\n            // There is no way to configure the pathBuilder to ignore date validity. When validity checks are to be\n            // ignored, try to find a point in time where all certificates in the chain are valid.\n            final Date validPointInTime = CertificateUtils.findValidPointInTime( chain );\n\n            // This strategy to 'disable' validity checks won't work if there's no overlap of validity periods of all\n            // certificates. TODO improve the implementation.\n            if ( validPointInTime == null )\n            {\n                Log.warn( \"The existing implementation is unable to fully ignore certificate validity periods for this chain, even though it is configured to do so. Certificate checks might fail because of expiration for end entity: \" + chain[0] );\n            }\n            else\n            {\n                parameters.setDate( validPointInTime );\n            }\n        }\n\n        // Add all certificates that are part of the chain to the configuration. Together with the trust anchors, the\n        // entire chain should now be in the store.\n        parameters.addCertStore( certificates );\n\n        // When true, validation will fail if no CRLs are provided!\n        parameters.setRevocationEnabled( false );\n\n        Log.debug( \"Validating chain with {} certificates, using {} trust anchors.\", chain.length, trustAnchors.size() );\n\n        // Try to use BouncyCastle - if that doesn't work, pick one.\n        CertPathBuilder pathBuilder;\n        try\n        {\n            pathBuilder = CertPathBuilder.getInstance( \"PKIX\", \"BC\" );\n        }\n        catch ( NoSuchProviderException e )\n        {\n            Log.warn( \"Unable to use the BC provider! Trying to use a fallback provider.\", e );\n            pathBuilder = CertPathBuilder.getInstance( \"PKIX\" );\n        }\n\n        try\n        {\n            // Finally, construct (and implicitly validate) the certificate path.\n            final CertPathBuilderResult result = pathBuilder.build( parameters );\n            return result.getCertPath();\n        }\n        catch ( CertPathBuilderException ex )\n        {\n            // This exception generally isn't very helpful. This block attempts to print more debug information.\n            try\n            {\n                Log.debug( \"** Accepted Issuers (trust anchors, \\\"root CA's\\\"):\" );\n                for ( X509Certificate acceptedIssuer : acceptedIssuers) {\n                    Log.debug( \"   - \" + acceptedIssuer.getSubjectDN() + \"/\" + acceptedIssuer.getIssuerDN() );\n                }\n                Log.debug( \"** Chain to be validated:\" );\n                Log.debug( \"   length: \" + chain.length );\n                for (int i=0; i<chain.length; i++) {\n                    Log.debug( \" Certificate[{}] (valid from {} to {}):\", i, chain[ i ].getNotBefore(), chain[ i ].getNotAfter() );\n                    Log.debug( \"   subjectDN: \" + chain[ i ].getSubjectDN() );\n                    Log.debug( \"   issuerDN: \" + chain[ i ].getIssuerDN() );\n\n                    for ( X509Certificate acceptedIssuer : acceptedIssuers) {\n                        if ( acceptedIssuer.getIssuerDN().equals( chain[i].getIssuerDN() ) ) {\n                            Log.debug( \"Found accepted issuer with same DN: \" + acceptedIssuer.getIssuerDN() );\n                        }\n                    }\n                }\n            }\n            finally\n            {\n                // rethrow the original exception.\n                throw ex;\n            }\n        }\n\n    }\n    \n    protected String getTopDomain(String domain)\n    {\n    \tif (StringUtils.isEmpty(domain))\n    \t\treturn \"\";\n    \t\n    \tString workDomain = domain.toLowerCase();\n    \tif (workDomain.startsWith(\"groupchat.\"))\n    \t\treturn workDomain.substring(\"groupchat.\".length());\n    \telse if (workDomain.startsWith(\"ftproxystream.\"))\n    \t\treturn workDomain.substring(\"ftproxystream.\".length());\n    \t\n    \treturn workDomain;\n    }\n}", "item_id": 0, "repo": "DirectStandards/timplus-server-core", "file": "src/main/java/org/jivesoftware/openfire/keystore/OpenfireX509TrustManager.java", "last_update_at": "2022-02-16T01:16:15+00:00", "question_id": "7c39078e69295fbfefa032d8672d85f58334ba4b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OpenfireX509TrustManager implements X509TrustManager\n{\n    private static final Logger Log = LoggerFactory.getLogger( OpenfireX509TrustManager.class );\n    private SSLEngine engine;\n    static\n    {\n    \tCryptoUtils.registerJCEProviders();\n    }\n    /**\n     * A boolean that indicates if this trust manager will allow self-signed certificates to be trusted.\n     */\n    protected final boolean acceptSelfSigned;\n    /**\n     * A boolean that indicates if this trust manager will check if all certificates in the chain (including the root\n     * certificates) are currently valid (notBefore/notAfter check).\n     */\n    private final boolean checkValidity;\n    protected TrustCircleManager circleManager;\n    public OpenfireX509TrustManager( TrustCircleManager circleManager, boolean acceptSelfSigned, boolean checkValidity ) throws NoSuchAlgorithmException, KeyStoreException\n    {\n    \tthis.circleManager = circleManager;\n        this.acceptSelfSigned = acceptSelfSigned;\n        this.checkValidity = checkValidity;\n        Log.debug( \"Constructed trust manager. Accepts self-signed: {}, checks validity: {}\", acceptSelfSigned, checkValidity );\n    }\n    public void setSSLEngine(SSLEngine engine)\n    {\n    \tthis.engine = engine;\n    }\n    @Override\n    public void checkClientTrusted( X509Certificate[] chain, String authType ) throws CertificateException\n    {\n        // Find and use the end entity as the selector for verification.\n        final X509Certificate endEntityCert = CertificateUtils.identifyEndEntityCertificate( Arrays.asList( chain ) );\n        final X509CertSelector selector = new X509CertSelector();\n        selector.setCertificate( endEntityCert );\n        try\n        {\n            checkChainTrusted( selector, chain );\n        }\n        catch ( InvalidAlgorithmParameterException | NoSuchAlgorithmException | CertPathBuilderException ex )\n        {\n            throw new CertificateException( ex );\n        }\n    }\n    @Override\n    public void checkServerTrusted( X509Certificate[] chain, String authType ) throws CertificateException\n    {\n        // Find and use the end entity as the selector for verification.\n        final X509Certificate endEntityCert = CertificateUtils.identifyEndEntityCertificate( Arrays.asList( chain ) );\n        final X509CertSelector selector = new X509CertSelector();\n        selector.setCertificate( endEntityCert );\n        try\n        {\n            checkChainTrusted( selector, chain );\n        }\n        catch ( InvalidAlgorithmParameterException | NoSuchAlgorithmException | CertPathBuilderException ex )\n        {\n            throw new CertificateException( ex );\n        }\n    }\n    @Override\n    public X509Certificate[] getAcceptedIssuers()\n    {\n    \tfinal Set<X509Certificate> result = new HashSet<>();\n    \t\n    \tCollection<TrustCircle> circles = null;\n    \t\n\t\t// make sure we have a reference id so we no what domain connection is being requested\n\t\tfinal String referenceId = getTopDomain(ReferenceIDUtil.getSessionReferenceId(engine.getSession()));\n\t\t\n\t\tLog.debug(\"Looking up trust anchors associated to domain \" + referenceId);\n\t\t\n    \ttry\n    \t{\n\t\t\tif (!StringUtils.isEmpty(referenceId))\n\t    \t{\n\t    \t\t\n\t    \t\tcircles = circleManager.getCirclesByDomain(referenceId, true, true);\n\t    \t}\n\t    \telse\n\t    \t{\n\t    \t\t// fall back \n\t    \t\tcircles = circleManager.getTrustCircles(true, true);\n\t\n\t    \t}\n    \t}\n    \tcatch (Exception e)\n    \t{\n    \t\tLog.warn(\"Could not get trust anchors for trust validation.\");\n    \t}\n    \t\n    \tif (circles == null || circles.isEmpty())\n    \t\treturn new X509Certificate[] {};\n    \t\n    \tfor (TrustCircle circle : circles)\n    \t{\n    \t\tfor (TrustBundle bundle : circle.getTrustBundles())\n    \t\t\tfor (TrustBundleAnchor anchor : bundle.getTrustBundleAnchors())\n    \t\t\t\tif (checkValidity)\n    \t\t\t\t\tresult.addAll(CertificateUtils.filterValid( anchor.asX509Certificate()));\n    \t\t\t\t\t\t\n\t\t\tfor (org.jivesoftware.openfire.trustanchor.TrustAnchor anchor : circle.getAnchors())\n\t\t\t\tif (checkValidity)\n\t\t\t\t\tresult.addAll(CertificateUtils.filterValid( anchor.asX509Certificate()));\t\n    \t\t\n    \t}\n    \t\n        return result.toArray( new X509Certificate[ result.size() ] );\n    }\n    /**\n     * Determine if the given partial or complete certificate chain can be trusted to represent the entity that is\n     * defined by the criteria specified by the 'selector' argument.\n     *\n     * A (valid) partial chain is a chain that, combined with certificates from the trust store in this manager, can be\n     * completed to a full chain.\n     *\n     * Chains provided to this method do not need to be in any particular order.\n     *\n     * This implementation uses the trust anchors as represented by {@link #getAcceptedIssuers()} to verify that the\n     * chain that is provided either includes a certificate from an accepted issuer, or is directly issued by one.\n     *\n     * Depending on the configuration of this class, other verification is done:\n     * <ul>\n     *     <li>{@link #acceptSelfSigned}: when {@code true}, any chain that has a length of one and is self-signed is\n     *                                    considered as a 'trust anchor' (but is still subject to other checks, such as\n     *                                    expiration checks).</li>\n     * </ul>\n     *\n     * This method will either return a value, which indicates that the chain is trusted, or will throw an exception.\n     *\n     * @param selector Characteristics of the entity to be represented by the chain (cannot be null).\n     * @param chain The certificate chain that is to be verified (cannot be null or empty).\n     * @return A trusted certificate path (never null).\n     *\n     * @throws InvalidAlgorithmParameterException if the algorithm is invalid\n     * @throws NoSuchAlgorithmException if the algorithm could not be found\n     * @throws CertPathBuilderException if there was a problem with the certificate path\n     */\n    protected CertPath checkChainTrusted( CertSelector selector, X509Certificate... chain ) throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, CertPathBuilderException\n    {\n        if ( selector == null )\n        {\n            throw new IllegalArgumentException( \"Argument 'selector' cannot be null\");\n        }\n        if ( chain == null || chain.length == 0 )\n        {\n            throw new IllegalArgumentException( \"Argument 'chain' cannot be null or an empty array.\");\n        }\n        Log.debug( \"Attempting to verify a chain of {} certificates.\", chain.length );\n        /*\n         * The certificate path validation process checks for valid dates in certificates,\n         * but we will choose to fail fast in anything in the chain is expired.  This will save\n         * time from having to lookup intermediate certificates (if necessary) if the given certificates\n         * are already not valid.\n         */\n        X509Certificate endEntityCert = null;\n\t\ttry\n\t\t{\n\t\t\tendEntityCert = CertificateUtils.identifyEndEntityCertificate( Arrays.asList( chain ) );\n\t\t} \n\t\tcatch (Exception e1)\n\t\t{\n\t\t\tthrow new IllegalArgumentException( \"Could not get end entity certificate from chain.\");\n\t\t}\n\t\t\n\t\tfinal Set<X509Certificate> acceptedServerCerts = CertificateUtils.filterValid( endEntityCert );\n        if (acceptedServerCerts.size() <= 0)\n        {\n        \t// the end entity certificate is invalid\n        \tLog.warn( \"TLS certificate chain has an expired certificate.  This is an invalid chain and the connection is rejected.\" );\n        \tthrow new CertPathBuilderException(\"The certificate chain contains an expired certificate\");\n        }\n        /*\n         * Make sure the certificate isn't revoke.  The default cert path checker can do this work, but the revocation\n         * manager uses some optimizations in terms of caching so the CRL doesn't have to be downloaded every time.\n         */\n        try\n        {\n        \t\n        \tfinal CRLRevocationManager revManager = CRLRevocationManager.getInstance();\n        \t\n        \tif (revManager.isRevoked(endEntityCert))\n        \t{\n        \t\tLog.warn( \"TLS end enity certificate has been marked as revoked.  The connection is rejected.\" );\n        \t\tthrow new CertPathBuilderException(\"TLS end enity certificate has been marked as revoked.\");\n        \t}\n        }\n        catch (CertPathBuilderException e)\n        {\n        \tthrow e;\n        }\n        catch (Exception e)\n        {\n        \tthrow new IllegalArgumentException(\"Could not check revocation status of end entity certificate.\");\n        }\n        // The set of trusted issuers (for this invocation), based on the issuers from the truststore.\n        final Set<X509Certificate> trustedIssuers = new HashSet<>();\n        trustedIssuers.addAll( Arrays.asList(getAcceptedIssuers() ));\n        // When accepting self-signed certificates, and the chain is a self-signed certificate, add it to the collection\n        // of trusted issuers. Blindly accepting this issuer is undesirable, as that would circumvent other checks, such\n        // as expiration checking.\n        if ( acceptSelfSigned && chain.length == 1 )\n        {\n            Log.debug( \"Attempting to accept the self-signed certificate of this chain of length one, as instructed by configuration.\" );\n            final X509Certificate cert = chain[0];\n            if ( cert.getSubjectDN().equals( cert.getIssuerDN() ) )\n            {\n                Log.debug( \"Chain of one appears to be self-signed. Adding it to the set of trusted issuers.\" );\n                trustedIssuers.add( cert );\n            }\n            else\n            {\n                Log.debug( \"Chain of one is not self-signed. Not adding it to the set of trusted issuers.\" );\n            }\n        }\n        // Turn trusted into accepted issuers.\n        final Set<X509Certificate> acceptedIssuers;\n        if ( checkValidity )\n        {\n            // See what certificates are currently valid.\n            acceptedIssuers = CertificateUtils.filterValid( trustedIssuers );\n        }\n        else\n        {\n            acceptedIssuers = trustedIssuers;\n        }\n        Log.debug(\"Using the following trust anchors for checking trust of the TLS connection for certificate \" + endEntityCert.getSubjectDN());\n        for (X509Certificate anchor : acceptedIssuers)\n        \tLog.debug(\"\\tDN=\" + anchor.getIssuerDN());\n        if (acceptedIssuers.isEmpty())\n        {\n        \tLog.warn(\"No accepted issuers were found for certificate DN: {}\", endEntityCert.getSubjectDN().toString());\n        }\n        // Transform all accepted issuers into a set of unique trustAnchors.\n        final Set<TrustAnchor> trustAnchors = CertificateUtils.toTrustAnchors( acceptedIssuers );\n        // All certificates that are part of the (possibly incomplete) chain.\n        final CertStore certificates = CertStore.getInstance( \"Collection\", new CollectionCertStoreParameters( Arrays.asList( chain ) ) );\n        // Build the configuration for the path builder. It is based on the collection of accepted issuers / trust anchors\n        final PKIXBuilderParameters parameters = new PKIXBuilderParameters( trustAnchors, selector );\n        // Validity checks are enabled by default in the CertPathBuilder implementation.\n        if ( !checkValidity )\n        {\n            Log.debug( \"Attempting to ignore any validity (expiry) issues, as instructed by configuration.\" );\n            // There is no way to configure the pathBuilder to ignore date validity. When validity checks are to be\n            // ignored, try to find a point in time where all certificates in the chain are valid.\n            final Date validPointInTime = CertificateUtils.findValidPointInTime( chain );\n            // This strategy to 'disable' validity checks won't work if there's no overlap of validity periods of all\n            // certificates. TODO improve the implementation.\n            if ( validPointInTime == null )\n            {\n                Log.warn( \"The existing implementation is unable to fully ignore certificate validity periods for this chain, even though it is configured to do so. Certificate checks might fail because of expiration for end entity: \" + chain[0] );\n            }\n            else\n            {\n                parameters.setDate( validPointInTime );\n            }\n        }\n        // Add all certificates that are part of the chain to the configuration. Together with the trust anchors, the\n        // entire chain should now be in the store.\n        parameters.addCertStore( certificates );\n        // When true, validation will fail if no CRLs are provided!\n        parameters.setRevocationEnabled( false );\n        Log.debug( \"Validating chain with {} certificates, using {} trust anchors.\", chain.length, trustAnchors.size() );\n        // Try to use BouncyCastle - if that doesn't work, pick one.\n        CertPathBuilder pathBuilder;\n        try\n        {\n            pathBuilder = CertPathBuilder.getInstance( \"PKIX\", \"BC\" );\n        }\n        catch ( NoSuchProviderException e )\n        {\n            Log.warn( \"Unable to use the BC provider! Trying to use a fallback provider.\", e );\n            pathBuilder = CertPathBuilder.getInstance( \"PKIX\" );\n        }\n        try\n        {\n            // Finally, construct (and implicitly validate) the certificate path.\n            final CertPathBuilderResult result = pathBuilder.build( parameters );\n            return result.getCertPath();\n        }\n        catch ( CertPathBuilderException ex )\n        {\n            // This exception generally isn't very helpful. This block attempts to print more debug information.\n            try\n            {\n                Log.debug( \"** Accepted Issuers (trust anchors, \\\"root CA's\\\"):\" );\n                for ( X509Certificate acceptedIssuer : acceptedIssuers) {\n                    Log.debug( \"   - \" + acceptedIssuer.getSubjectDN() + \"/\" + acceptedIssuer.getIssuerDN() );\n                }\n                Log.debug( \"** Chain to be validated:\" );\n                Log.debug( \"   length: \" + chain.length );\n                for (int i=0; i<chain.length; i++) {\n                    Log.debug( \" Certificate[{}] (valid from {} to {}):\", i, chain[ i ].getNotBefore(), chain[ i ].getNotAfter() );\n                    Log.debug( \"   subjectDN: \" + chain[ i ].getSubjectDN() );\n                    Log.debug( \"   issuerDN: \" + chain[ i ].getIssuerDN() );\n                    for ( X509Certificate acceptedIssuer : acceptedIssuers) {\n                        if ( acceptedIssuer.getIssuerDN().equals( chain[i].getIssuerDN() ) ) {\n                            Log.debug( \"Found accepted issuer with same DN: \" + acceptedIssuer.getIssuerDN() );\n                        }\n                    }\n                }\n            }\n            finally\n            {\n                // rethrow the original exception.\n                throw ex;\n            }\n        }\n    }\n    protected String getTopDomain(String domain)\n    {\n    \tif (StringUtils.isEmpty(domain))\n    \t\treturn \"\";\n    \t\n    \tString workDomain = domain.toLowerCase();\n    \tif (workDomain.startsWith(\"groupchat.\"))\n    \t\treturn workDomain.substring(\"groupchat.\".length());\n    \telse if (workDomain.startsWith(\"ftproxystream.\"))\n    \t\treturn workDomain.substring(\"ftproxystream.\".length());\n    \t\n    \treturn workDomain;\n    }\n"]], "pred": {"ppl": 1.9722082614898682, "ppl_lower": 2.1989383697509766, "ppl/lowercase_ppl": -1.1602300027146164, "ppl/zlib": 0.0001612043341749247, "Min_5.0% Prob": 6.509967645009358, "Min_10.0% Prob": 4.7989758229723165, "Min_20.0% Prob": 3.1034513820035783, "Min_30.0% Prob": 2.216316512304973, "Min_40.0% Prob": 1.6887099198669122, "Min_50.0% Prob": 1.3575155781636674, "Min_60.0% Prob": 1.1329260366462888}}
{"hexsha": "afc947e75177e90fcaafc651ac46d55f52c5a659", "ext": "java", "lang": "Java", "content": "public class MultiPropertyKey {\n\n\tprivate MultiPropertyKeyPart[] properties;\n\n\tpublic MultiPropertyKey(int filterSize) {\n\t\tproperties = new MultiPropertyKeyPart[0];\n\t}\n\n\t// Initial adding key values.\n\tpublic void add(String key, String value) {\n\t\tint newLength = properties.length + 1;\n\t\tMultiPropertyKeyPart[] tmpKeys = new MultiPropertyKeyPart[newLength];\n\t\t\n\t\tSystem.arraycopy(properties, 0, tmpKeys, 0, properties.length);\n\t\ttmpKeys[newLength-1] = new MultiPropertyKeyPart(key, value);\n\t\t\n\t\tthis.properties = tmpKeys;\n\t\tArrays.sort(properties);\n\t}\n\n\tpublic void append(MultiPropertyKey other) {\n\t\tint newLength = properties.length + other.properties.length;\n\t\tMultiPropertyKeyPart[] tmpKeys = new MultiPropertyKeyPart[newLength];\n\t\t\n\t\tSystem.arraycopy(properties, 0, tmpKeys, 0, properties.length);\n\t\tSystem.arraycopy(other.properties, 0, tmpKeys, properties.length, other.properties.length);\n\t\n\t\tthis.properties = tmpKeys;\n\t\tArrays.sort(properties);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Arrays.hashCode(properties);\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!(obj instanceof MultiPropertyKey)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tMultiPropertyKey other = (MultiPropertyKey) obj;\n\n\t\tif (properties.length != other.properties.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (int i = 0; i < properties.length; i++) {\n\t\t\tif (!(properties[i].equals(other.properties[i]))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder builder = new StringBuilder();\n\t\tfor (int i = 0; i < properties.length; i++) {\n\t\t\tbuilder.append(properties[i].key);\n\t\t\tbuilder.append('=');\n\t\t\tbuilder.append(properties[i].value);\n\t\t\tif (i < properties.length - 1) {\n\t\t\t\tbuilder.append(';');\n\t\t\t}\n\t\t}\n\t\treturn builder.toString();\n\t}\n\n\t// (key=value) part of a multi property index (&(key1=val1)(key2=val2) .. )\n\tprivate class MultiPropertyKeyPart implements Comparable<MultiPropertyKeyPart> {\n\t\t\n\t\tprivate final String key;\n\t\tprivate final String value;\n\n\t\tpublic MultiPropertyKeyPart(String key, String value) {\n\t\t\tthis.key = key;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tint h = 0;\n\t\t\th += 31 * key.hashCode();\n\t\t\th += value.hashCode();\n\t\t\treturn h;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (!(obj instanceof MultiPropertyKeyPart))\n\t\t\t\treturn false;\n\n\t\t\tMultiPropertyKeyPart object = (MultiPropertyKeyPart) obj;\n\n\t\t\tif (!(this.key.equals(object.key)))\n\t\t\t\treturn false;\n\t\t\tif (!(this.value.equals(object.value)))\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(MultiPropertyKeyPart o) {\n\t\t\tif (this.key.compareTo(o.key) == 0) {\n\t\t\t\treturn this.value.compareTo(o.value);\n\t\t\t}\n\t\t\treturn this.key.compareTo(o.key);\n\t\t}\n\t}\n}", "item_id": 0, "repo": "garydgregory/felix-dev", "file": "dependencymanager/org.apache.felix.dependencymanager/src/org/apache/felix/dm/impl/index/multiproperty/MultiPropertyKey.java", "last_update_at": "2022-03-31T14:40:18+00:00", "question_id": "afc947e75177e90fcaafc651ac46d55f52c5a659_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MultiPropertyKey {\n\tprivate MultiPropertyKeyPart[] properties;\n\tpublic MultiPropertyKey(int filterSize) {\n\t\tproperties = new MultiPropertyKeyPart[0];\n\t}\n\t// Initial adding key values.\n\tpublic void add(String key, String value) {\n\t\tint newLength = properties.length + 1;\n\t\tMultiPropertyKeyPart[] tmpKeys = new MultiPropertyKeyPart[newLength];\n\t\t\n\t\tSystem.arraycopy(properties, 0, tmpKeys, 0, properties.length);\n\t\ttmpKeys[newLength-1] = new MultiPropertyKeyPart(key, value);\n\t\t\n\t\tthis.properties = tmpKeys;\n\t\tArrays.sort(properties);\n\t}\n\tpublic void append(MultiPropertyKey other) {\n\t\tint newLength = properties.length + other.properties.length;\n\t\tMultiPropertyKeyPart[] tmpKeys = new MultiPropertyKeyPart[newLength];\n\t\t\n\t\tSystem.arraycopy(properties, 0, tmpKeys, 0, properties.length);\n\t\tSystem.arraycopy(other.properties, 0, tmpKeys, properties.length, other.properties.length);\n\t\n\t\tthis.properties = tmpKeys;\n\t\tArrays.sort(properties);\n\t}\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Arrays.hashCode(properties);\n\t}\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(obj instanceof MultiPropertyKey)) {\n\t\t\treturn false;\n\t\t}\n\t\tMultiPropertyKey other = (MultiPropertyKey) obj;\n\t\tif (properties.length != other.properties.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < properties.length; i++) {\n\t\t\tif (!(properties[i].equals(other.properties[i]))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder builder = new StringBuilder();\n\t\tfor (int i = 0; i < properties.length; i++) {\n\t\t\tbuilder.append(properties[i].key);\n\t\t\tbuilder.append('=');\n\t\t\tbuilder.append(properties[i].value);\n\t\t\tif (i < properties.length - 1) {\n\t\t\t\tbuilder.append(';');\n\t\t\t}\n\t\t}\n\t\treturn builder.toString();\n\t}\n\t// (key=value) part of a multi property index (&(key1=val1)(key2=val2) .. )\n\tprivate class MultiPropertyKeyPart implements Comparable<MultiPropertyKeyPart> {\n\t\t\n\t\tprivate final String key;\n\t\tprivate final String value;\n\t\tpublic MultiPropertyKeyPart(String key, String value) {\n\t\t\tthis.key = key;\n\t\t\tthis.value = value;\n\t\t}\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tint h = 0;\n\t\t\th += 31 * key.hashCode();\n\t\t\th += value.hashCode();\n\t\t\treturn h;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (!(obj instanceof MultiPropertyKeyPart))\n\t\t\t\treturn false;\n\t\t\tMultiPropertyKeyPart object = (MultiPropertyKeyPart) obj;\n\t\t\tif (!(this.key.equals(object.key)))\n\t\t\t\treturn false;\n\t\t\tif (!(this.value.equals(object.value)))\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(MultiPropertyKeyPart o) {\n\t\t\tif (this.key.compareTo(o.key) == 0) {\n\t\t\t\treturn this.value.compareTo(o.value);\n\t\t\t}\n\t\t\treturn this.key.compareTo(o.key);\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.389117956161499, "ppl_lower": 1.4843873977661133, "ppl/lowercase_ppl": -1.2018236652909184, "ppl/zlib": 0.00042518626365991723, "Min_5.0% Prob": 4.607880400676353, "Min_10.0% Prob": 2.887912377422931, "Min_20.0% Prob": 1.608972958380393, "Min_30.0% Prob": 1.0914449733042835, "Min_40.0% Prob": 0.819974810056944, "Min_50.0% Prob": 0.6572338942622441, "Min_60.0% Prob": 0.5482270923214486}}
{"hexsha": "1fc326900689a727dcb62b44559558f7f5a85d44", "ext": "java", "lang": "Java", "content": "public class BytePropertySet extends PropertySet {\n    private final static long serialVersionUID = 1;\n\t/**\n\t * Constructor for BytePropertySet.\n\t * @param name the name associated with this property set.\n\t */\n\tpublic BytePropertySet(String name) {\n\t\tsuper(name, null);\n\t}\n\n\t/**\n\t * @see PropertySet#getDataSize()\n\t */\n\t@Override\n    public int getDataSize() {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * Stores a byte value at the given index.  Any value currently at that\n\t * index will be replaced by the new value.\n\t * @param index the index at which to store the byte value.\n\t * @param value the byte value to store.\n\t */\n\tpublic void putByte(long index, byte value) {\n\t\tPropertyPage page = getOrCreatePage(getPageID(index));\n\t\tint n = page.getSize();\n\t\tpage.addByte(getPageOffset(index), value);\n\t\tnumProperties += page.getSize() - n;\n\t}\n\n\t/**\n\t * Retrieves the byte value stored at the given index.\n\t * @param index the index at which to retrieve the byte value.\n\t * @return byte the value stored at the given index.\n\t * @throws NoValueException if there is no byte value stored at the index.\n\t */\n\tpublic byte getByte(long index) throws NoValueException {\n\t\tPropertyPage page = getPage(getPageID(index));\n\t\tif (page != null) {\n\t\t\treturn page.getByte(getPageOffset(index));\n\t\t}\n\t\tthrow noValueException;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see ghidra.util.prop.PropertySet#moveIndex(long, long)\n\t */\n\t@Override\n    protected void moveIndex(long from, long to) {\n\t\ttry {\n\t\t\tbyte value = getByte(from);\n\t\t\tremove(from);\n\t\t\tputByte(to, value);\n\t\t}catch(NoValueException e) {}\n\t}\n\n\t/**\n\t * saves the property at the given index to the given output stream.\n\t */\n\t@Override\n    protected void saveProperty(ObjectOutputStream oos, long index) throws IOException {\n\t\ttry {\n\t\t\toos.writeByte(getByte(index));\n\t\t}\n        catch(NoValueException e) {\n            throw new AssertException(e.getMessage());\n        }\n\t}\n\t/**\n\t * restores the property from the input stream to the given index.\n\t */\n\t@Override\n    protected void restoreProperty(ObjectInputStream ois, long index) throws IOException{\n\t\tputByte(index, ois.readByte());\n\t}\n\n\t/**\n\t * \n\t * @see ghidra.util.prop.PropertySet#applyValue(PropertyVisitor, long)\n\t */\n\t@Override\n    public void applyValue(PropertyVisitor visitor, long addr) {\n\t\tthrow new NotYetImplementedException();\n//\t\ttry {\n//\t\t\tvisitor.visit(getLong(addr));\n//\t\t}\n//\t\tcatch(NoValueException e) {\n//\t\t}\n\t}\n\n}", "item_id": 0, "repo": "sigurasg/ghidra", "file": "Ghidra/Framework/Generic/src/main/java/ghidra/util/prop/BytePropertySet.java", "last_update_at": "2022-03-30T18:12:17+00:00", "question_id": "1fc326900689a727dcb62b44559558f7f5a85d44_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BytePropertySet extends PropertySet {\n    private final static long serialVersionUID = 1;\n\t/**\n\t * Constructor for BytePropertySet.\n\t * @param name the name associated with this property set.\n\t */\n\tpublic BytePropertySet(String name) {\n\t\tsuper(name, null);\n\t}\n\t/**\n\t * @see PropertySet#getDataSize()\n\t */\n\t@Override\n    public int getDataSize() {\n\t\treturn 1;\n\t}\n\t/**\n\t * Stores a byte value at the given index.  Any value currently at that\n\t * index will be replaced by the new value.\n\t * @param index the index at which to store the byte value.\n\t * @param value the byte value to store.\n\t */\n\tpublic void putByte(long index, byte value) {\n\t\tPropertyPage page = getOrCreatePage(getPageID(index));\n\t\tint n = page.getSize();\n\t\tpage.addByte(getPageOffset(index), value);\n\t\tnumProperties += page.getSize() - n;\n\t}\n\t/**\n\t * Retrieves the byte value stored at the given index.\n\t * @param index the index at which to retrieve the byte value.\n\t * @return byte the value stored at the given index.\n\t * @throws NoValueException if there is no byte value stored at the index.\n\t */\n\tpublic byte getByte(long index) throws NoValueException {\n\t\tPropertyPage page = getPage(getPageID(index));\n\t\tif (page != null) {\n\t\t\treturn page.getByte(getPageOffset(index));\n\t\t}\n\t\tthrow noValueException;\n\t}\n\t/* (non-Javadoc)\n\t * @see ghidra.util.prop.PropertySet#moveIndex(long, long)\n\t */\n\t@Override\n    protected void moveIndex(long from, long to) {\n\t\ttry {\n\t\t\tbyte value = getByte(from);\n\t\t\tremove(from);\n\t\t\tputByte(to, value);\n\t\t}catch(NoValueException e) {}\n\t}\n\t/**\n\t * saves the property at the given index to the given output stream.\n\t */\n\t@Override\n    protected void saveProperty(ObjectOutputStream oos, long index) throws IOException {\n\t\ttry {\n\t\t\toos.writeByte(getByte(index));\n\t\t}\n        catch(NoValueException e) {\n            throw new AssertException(e.getMessage());\n        }\n\t}\n\t/**\n\t * restores the property from the input stream to the given index.\n\t */\n\t@Override\n    protected void restoreProperty(ObjectInputStream ois, long index) throws IOException{\n\t\tputByte(index, ois.readByte());\n\t}\n\t/**\n\t * \n\t * @see ghidra.util.prop.PropertySet#applyValue(PropertyVisitor, long)\n\t */\n\t@Override\n    public void applyValue(PropertyVisitor visitor, long addr) {\n\t\tthrow new NotYetImplementedException();\n//\t\ttry {\n//\t\t\tvisitor.visit(getLong(addr));\n//\t\t}\n//\t\tcatch(NoValueException e) {\n//\t\t}\n\t}\n"]], "pred": {"ppl": 1.840423345565796, "ppl_lower": 2.0074069499969482, "ppl/lowercase_ppl": -1.1423751037812437, "ppl/zlib": 0.0007184871899512369, "Min_5.0% Prob": 5.855207516596868, "Min_10.0% Prob": 4.353038341571123, "Min_20.0% Prob": 2.749135643053966, "Min_30.0% Prob": 1.9622709344042109, "Min_40.0% Prob": 1.5041237710055653, "Min_50.0% Prob": 1.2146139481646598, "Min_60.0% Prob": 1.0143227629074847}}
{"hexsha": "289166cba6ee2d5a5cc69e03e720f78c269f9212", "ext": "java", "lang": "Java", "content": "public class GraphQlFieldsHelper {\n    public static String INPUT = \"input\";\n    public static String FILTER = \"filter\";\n\n    public static TypedValueMap getInputMap(DataFetchingEnvironment environment) {\n        return new TypedValueMap(environment.getArgument(INPUT));\n    }\n\n    public static TypedValueMap getFilterMap(DataFetchingEnvironment environment) {\n        Map<String, Object> filterMap = environment.getArgument(FILTER);\n\n        if (filterMap == null) {\n            return new TypedValueMap();\n        }\n\n        return new TypedValueMap(filterMap);\n    }\n}", "item_id": 0, "repo": "zakirarrayiq/spring-boot-starter-graphql", "file": "graphql-core/src/main/java/com/merapar/graphql/base/GraphQlFieldsHelper.java", "last_update_at": "2022-02-21T23:50:04+00:00", "question_id": "289166cba6ee2d5a5cc69e03e720f78c269f9212_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GraphQlFieldsHelper {\n    public static String INPUT = \"input\";\n    public static String FILTER = \"filter\";\n    public static TypedValueMap getInputMap(DataFetchingEnvironment environment) {\n        return new TypedValueMap(environment.getArgument(INPUT));\n    }\n    public static TypedValueMap getFilterMap(DataFetchingEnvironment environment) {\n        Map<String, Object> filterMap = environment.getArgument(FILTER);\n        if (filterMap == null) {\n            return new TypedValueMap();\n        }\n        return new TypedValueMap(filterMap);\n    }\n"]], "pred": {"ppl": 2.0406618118286133, "ppl_lower": 2.868772029876709, "ppl/lowercase_ppl": -1.4775301198828035, "ppl/zlib": 0.0029844107648835634, "Min_5.0% Prob": 7.260274342128208, "Min_10.0% Prob": 5.466158167521159, "Min_20.0% Prob": 3.3497572004795075, "Min_30.0% Prob": 2.3415080315536922, "Min_40.0% Prob": 1.7901183423896632, "Min_50.0% Prob": 1.4226331466220712, "Min_60.0% Prob": 1.1901195442283548}}
{"hexsha": "26aa466a9160fbc357adb29275d8a5b7e3d57c6b", "ext": "java", "lang": "Java", "content": "class Problem01_GrayCodeTest {\n\n    private final Problem01_GrayCode testObject = new Problem01_GrayCode();\n\n    @Test\n    void testGrayCode() {\n        int n = 2;\n        List<Integer> expected = Arrays.asList(0, 1, 3, 2);\n        assertEquals(expected, testObject.grayCode(n));\n\n        n = 1;\n        expected = Arrays.asList(0, 1);\n        assertEquals(expected, testObject.grayCode(n));\n    }\n}", "item_id": 0, "repo": "ani03sha/Leetcoding", "file": "july-2021-leetcoding-challenge/src/test/java/org/redquark/leetcode/challenge/Problem01_GrayCodeTest.java", "last_update_at": "2022-02-03T19:26:50+00:00", "question_id": "26aa466a9160fbc357adb29275d8a5b7e3d57c6b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Problem01_GrayCodeTest {\n    private final Problem01_GrayCode testObject = new Problem01_GrayCode();\n    @Test\n    void testGrayCode() {\n        int n = 2;\n        List<Integer> expected = Arrays.asList(0, 1, 3, 2);\n        assertEquals(expected, testObject.grayCode(n));\n        n = 1;\n        expected = Arrays.asList(0, 1);\n        assertEquals(expected, testObject.grayCode(n));\n    }\n"]], "pred": {"ppl": 1.5378862619400024, "ppl_lower": 2.5061123371124268, "ppl/lowercase_ppl": -2.134557737235685, "ppl/zlib": 0.0022417131063765523, "Min_5.0% Prob": 6.205625255902608, "Min_10.0% Prob": 3.8417972784775953, "Min_20.0% Prob": 2.1485774274225586, "Min_30.0% Prob": 1.4509913419804923, "Min_40.0% Prob": 1.0856796835125848, "Min_50.0% Prob": 0.8663401080133475, "Min_60.0% Prob": 0.720524843268837}}
{"hexsha": "3ac72c171a9ed59bb7665f2c369f7bf8ea09d788", "ext": "java", "lang": "Java", "content": "public class Solution {\n    public static void main(String[] args) {\n        System.out.println(find(23));\n        System.out.println(find(12));\n    }\n\n    public static boolean find(int num) {\n        int slow = num, fast = num;\n        do {\n            slow = findSquareSum(slow); // move one step\n            fast = findSquareSum(findSquareSum(fast)); // move two steps\n        } while (slow != fast); // found the cycle\n\n        return slow == 1; // see if the cycle is stuck on the number '1'\n    }\n\n    private static int findSquareSum(int num) {\n        int sum = 0, digit;\n        while (num > 0) {\n            digit = num % 10;\n            sum += digit * digit;\n            num /= 10;\n        }\n        return sum;\n    }\n}", "item_id": 0, "repo": "fossabot/learning-computer-science", "file": "src/EducativeIo/Courses/GrokkingTheCodingInterview/Ch04_FastAndSlowPointers/P3_HappyNumber/Java/Solution.java", "last_update_at": "2022-01-02T00:51:32+00:00", "question_id": "3ac72c171a9ed59bb7665f2c369f7bf8ea09d788_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Solution {\n    public static void main(String[] args) {\n        System.out.println(find(23));\n        System.out.println(find(12));\n    }\n    public static boolean find(int num) {\n        int slow = num, fast = num;\n        do {\n            slow = findSquareSum(slow); // move one step\n            fast = findSquareSum(findSquareSum(fast)); // move two steps\n        } while (slow != fast); // found the cycle\n        return slow == 1; // see if the cycle is stuck on the number '1'\n    }\n    private static int findSquareSum(int num) {\n        int sum = 0, digit;\n        while (num > 0) {\n            digit = num % 10;\n            sum += digit * digit;\n            num /= 10;\n        }\n        return sum;\n    }\n"]], "pred": {"ppl": 1.9039398431777954, "ppl_lower": 2.249176502227783, "ppl/lowercase_ppl": -1.2587859162042967, "ppl/zlib": 0.001999768139442226, "Min_5.0% Prob": 5.869527469981801, "Min_10.0% Prob": 4.349943052638661, "Min_20.0% Prob": 2.9199843989177183, "Min_30.0% Prob": 2.0836915730526955, "Min_40.0% Prob": 1.592330483889038, "Min_50.0% Prob": 1.2822043825279583, "Min_60.0% Prob": 1.0714592050450544}}
{"hexsha": "5fd4753c7195420601334cfc21de48ee9fe0b50f", "ext": "java", "lang": "Java", "content": "@Validated\n@javax.annotation.Generated(value = \"io.swagger.codegen.v3.generators.java.SpringCodegen\", date = \"2021-06-09T08:20:20.072Z[GMT]\")\n\n@Getter\n@Setter\npublic class ParallelDatasetParamsSchema extends DatasetCommonParamsSchema implements OneOfDatasetParamsSchemaParams {\n  @JsonProperty(\"collectionMethod\")\n  private ParallelDatasetCollectionMethod collectionMethod = null;\n  \n  \n\n\n\n  /**\n   * Get collectionMethod\n   * @return collectionMethod\n   **/\n  @Schema(description = \"\")\n  \n    @Valid\n    public ParallelDatasetCollectionMethod getCollectionMethod() {\n    return collectionMethod;\n  }\n\n  public void setCollectionMethod(ParallelDatasetCollectionMethod collectionMethod) {\n    this.collectionMethod = collectionMethod;\n  }\n\n\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ParallelDatasetParamsSchema parallelDatasetParamsSchema = (ParallelDatasetParamsSchema) o;\n    return Objects.equals(this.collectionMethod, parallelDatasetParamsSchema.collectionMethod) &&\n        super.equals(o);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(collectionMethod, super.hashCode());\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class ParallelDatasetParamsSchema {\\n\");\n    sb.append(\"    \").append(toIndentedString(super.toString())).append(\"\\n\");\n    sb.append(\"    collectionMethod: \").append(toIndentedString(collectionMethod)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n}", "item_id": 0, "repo": "agupta54/ulca", "file": "backend/dataset/ulca-dataset-ingest/src/main/java/io/swagger/model/ParallelDatasetParamsSchema.java", "last_update_at": "2022-02-23T18:54:33+00:00", "question_id": "5fd4753c7195420601334cfc21de48ee9fe0b50f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Validated\n@javax.annotation.Generated(value = \"io.swagger.codegen.v3.generators.java.SpringCodegen\", date = \"2021-06-09T08:20:20.072Z[GMT]\")\n@Getter\n@Setter\npublic class ParallelDatasetParamsSchema extends DatasetCommonParamsSchema implements OneOfDatasetParamsSchemaParams {\n  @JsonProperty(\"collectionMethod\")\n  private ParallelDatasetCollectionMethod collectionMethod = null;\n  /**\n   * Get collectionMethod\n   * @return collectionMethod\n   **/\n  @Schema(description = \"\")\n    @Valid\n    public ParallelDatasetCollectionMethod getCollectionMethod() {\n    return collectionMethod;\n  }\n  public void setCollectionMethod(ParallelDatasetCollectionMethod collectionMethod) {\n    this.collectionMethod = collectionMethod;\n  }\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ParallelDatasetParamsSchema parallelDatasetParamsSchema = (ParallelDatasetParamsSchema) o;\n    return Objects.equals(this.collectionMethod, parallelDatasetParamsSchema.collectionMethod) &&\n        super.equals(o);\n  }\n  @Override\n  public int hashCode() {\n    return Objects.hash(collectionMethod, super.hashCode());\n  }\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class ParallelDatasetParamsSchema {\\n\");\n    sb.append(\"    \").append(toIndentedString(super.toString())).append(\"\\n\");\n    sb.append(\"    collectionMethod: \").append(toIndentedString(collectionMethod)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n"]], "pred": {"ppl": 1.4905564785003662, "ppl_lower": 2.018462657928467, "ppl/lowercase_ppl": -1.7595816002348375, "ppl/zlib": 0.0005818506206069287, "Min_5.0% Prob": 5.685500596250806, "Min_10.0% Prob": 3.776599216674055, "Min_20.0% Prob": 1.9911800089201568, "Min_30.0% Prob": 1.3341368220494398, "Min_40.0% Prob": 0.9978183191778309, "Min_50.0% Prob": 0.7996995471482046, "Min_60.0% Prob": 0.6652448155221097}}
{"hexsha": "fdd9b844d4e81c7ddd19d89c8c85a1d6854ec32b", "ext": "java", "lang": "Java", "content": "public class Finder implements Iterable<Diagnostic<? extends JavaFileObject>> {\n\n    private final List<Diagnostic<? extends JavaFileObject>> diagnostics;\n    private final Results results;\n    \n    /**\n     * Creates a {@code Finder} for the given results.\n     * \n     * @param results the results of a compilation\n     */\n    public Finder(Results results) {\n        diagnostics = new ArrayList<>(results.diagnostics);\n        this.results = results;\n    }\n    \n    /**\n     * Returns an iterator over {@code Diagnostic<? extends JavaFileObject>}s.\n     * \n     * @return an iterator\n     */\n    @Override\n    public Iterator<Diagnostic<? extends JavaFileObject>> iterator() {\n        return diagnostics.iterator();\n    }\n    \n    \n    /**\n     * Removes all diagnostic messages which kind does not match the given kinds.\n     * \n     * @param kinds the kinds which all diagnostic messages should match\n     * @return {@code this}\n     */\n    public Finder kind(Kind... kinds) {\n        return kind(Set.of(kinds));\n    }\n    \n    /**\n     * Removes all diagnostic messages which kind does not match the given kinds.\n     * \n     * @param kinds the kinds which all diagnostic messages should match\n     * @return {@code this}\n     */\n    public Finder kind(Collection<Kind> kinds) {\n        diagnostics.removeIf(diagnostic -> !kinds.contains(diagnostic.getKind()));\n        return this;\n    }\n    \n    /**\n     * Retains only errors.\n     * \n     * @return {@code this}\n     */\n    public Finder errors() {\n        diagnostics.retainAll(results.errors);\n        return this;\n    }\n    \n    /**\n     * Retains only warnings.\n     * \n     * @return {@code this}\n     */\n    public Finder warnings() {\n        diagnostics.retainAll(results.warnings);\n        return this;\n    }\n    \n    /**\n     * Retains only notes.\n     * \n     * @return {@code this}\n     */\n    public Finder notes() {\n        diagnostics.retainAll(results.notes);\n        return this;\n    }\n    \n    \n    /**\n     * Retains only diagnostic messages in the given Java source file.\n     * \n     * @param file the Java source file\n     * @return {@code this}\n     */\n    public Finder in(JavaFileObject file) {\n        var path = file.toUri().getPath();\n        diagnostics.removeIf(diagnostic -> !diagnostic.getSource().toUri().getPath().equals(path));\n        return this;\n    }\n    \n    /**\n     * Retains only diagnostic messages that appear on the given line.\n     * \n     * @param line the line\n     * @return {@code this}\n     */\n    public Finder on(long line) {\n        diagnostics.removeIf(diagnostic -> diagnostic.getLineNumber() != line);\n        return this;\n    }\n    \n    /**\n     * Retains only diagnostic messages that appear at the given column.\n     * \n     * @param column the column\n     * @return {@code this}\n     */\n    public Finder at(long column) {\n        diagnostics.removeIf(diagnostic -> diagnostic.getColumnNumber() != column);\n        return this;\n    }\n    \n    /**\n     * Retains only diagnostic messages that satisfy the given predicate.\n     * \n     * @param condition the condition\n     * @return {@code this}\n     */\n    public Finder where(Predicate<Diagnostic<? extends JavaFileObject>> condition) {\n        diagnostics.removeIf(Predicate.not(condition));\n        return this;\n    }\n    \n    \n    /**\n     * Retains only diagnostic messages that exactly match the given message.\n     * \n     * @param message the message\n     * @return {@code this}\n     */\n    public Finder matches(String message) {\n        diagnostics.removeIf(diagnostic -> !diagnostic.getMessage(Locale.getDefault()).equals(message));\n        return this;\n    }\n    \n    /**\n     * Retain only diagnostic messages that match the given pattern.\n     * \n     * @param pattern the pattern\n     * @return {@code this}\n     */\n    public Finder matches(Pattern pattern) {\n        diagnostics.removeIf(diagnostic -> !pattern.matcher(diagnostic.getMessage(Locale.getDefault())).matches());\n        return this;\n    }\n    \n    /**\n     * Retain only diagnostic messages that contain the given substring.\n     * \n     * @param substring the substring\n     * @return {@code this}\n     */\n    public Finder contains(String substring) {\n        diagnostics.removeIf(diagnostic -> !diagnostic.getMessage(Locale.getDefault()).contains(substring));\n        return this;\n    }\n\n    /**\n     * Returns the full descriptions of the diagnostic messages.\n     * \n     * @return the full descriptions\n     */\n    public List<String> diagnostics() {\n        return diagnostics.stream().map(Diagnostic::toString).collect(toList());\n    }\n    \n    /**\n     * Returns only the message portions of the diagnostic messages.\n     * \n     * @return the message portions\n     */\n    public List<String> messages() {\n        return diagnostics.stream().map(diagnostic -> diagnostic.getMessage(Locale.getDefault())).collect(toList());\n    }\n    \n    /**\n     * Returns the line numbers of the diagnostic messages.\n     * \n     * @return the line numbers\n     */\n    public List<Long> lines() {\n        return diagnostics.stream().map(Diagnostic::getLineNumber).collect(toList());\n    }\n    \n    /**\n     * Returns the column numbers of the diagnostic messages.\n     * \n     * @return the column numbers\n     */\n    public List<Long> columns() {\n        return diagnostics.stream().map(Diagnostic::getColumnNumber).collect(toList());\n    }\n    \n    /**\n     * Return the positions of the diagnostic messages from the start of a source file.\n     * \n     * @return the positions\n     */\n    public List<Long> positions() {\n        return diagnostics.stream().map(Diagnostic::getPosition).collect(toList());\n    }\n    \n    /**\n     * Return the codes of the diagnostic messages.\n     * \n     * @return the codes\n     */\n    public List<String> codes() {\n        return diagnostics.stream().map(Diagnostic::getCode).collect(toList());\n    }\n    \n    \n    /**\n     * Returns the diagnostic message if this {@code Finder} contains exactly one\n     * diagnostic message. Otherwise returns {@code null}.\n     * \n     * @return the diagnostic message if this {@code Finder} matches exactly one diagnostic message\n     */\n    public @Nullable Diagnostic<? extends JavaFileObject> one() {\n        return diagnostics.size() == 1 ? diagnostics.get(0) : null;\n    }\n    \n    /**\n     * Returns the diagnostic messages.\n     * \n     * @return the diagnostic messages\n     */\n    public List<Diagnostic<? extends JavaFileObject>> list() {\n        return diagnostics;\n    }\n    \n    /**\n     * Returns a map of diagnostic messages and associated {@code Kind}s.\n     * \n     * @return the map\n     */\n    public Map<Kind, List<Diagnostic<? extends JavaFileObject>>> map() {\n        var map = new HashMap<Kind, List<Diagnostic<? extends JavaFileObject>>>();\n        for (var diagnostic : diagnostics) {\n            var list = map.get(diagnostic.getKind());\n            if (list == null) {\n                map.put(diagnostic.getKind(), list = new ArrayList<>());\n            }\n            \n            list.add(diagnostic);\n        }\n        \n        return map;\n    }\n    \n    \n    /**\n     * Returns the current count of diagnostic messages.\n     * \n     * @return the current count of diagnostic messages\n     */\n    public int count() {\n        return diagnostics.size();\n    }\n    \n}", "item_id": 0, "repo": "Pante/elementary", "file": "elementary/src/main/java/com/karuslabs/elementary/Finder.java", "last_update_at": "2022-03-08T19:22:39+00:00", "question_id": "fdd9b844d4e81c7ddd19d89c8c85a1d6854ec32b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Finder implements Iterable<Diagnostic<? extends JavaFileObject>> {\n    private final List<Diagnostic<? extends JavaFileObject>> diagnostics;\n    private final Results results;\n    /**\n     * Creates a {@code Finder} for the given results.\n     * \n     * @param results the results of a compilation\n     */\n    public Finder(Results results) {\n        diagnostics = new ArrayList<>(results.diagnostics);\n        this.results = results;\n    }\n    /**\n     * Returns an iterator over {@code Diagnostic<? extends JavaFileObject>}s.\n     * \n     * @return an iterator\n     */\n    @Override\n    public Iterator<Diagnostic<? extends JavaFileObject>> iterator() {\n        return diagnostics.iterator();\n    }\n    /**\n     * Removes all diagnostic messages which kind does not match the given kinds.\n     * \n     * @param kinds the kinds which all diagnostic messages should match\n     * @return {@code this}\n     */\n    public Finder kind(Kind... kinds) {\n        return kind(Set.of(kinds));\n    }\n    /**\n     * Removes all diagnostic messages which kind does not match the given kinds.\n     * \n     * @param kinds the kinds which all diagnostic messages should match\n     * @return {@code this}\n     */\n    public Finder kind(Collection<Kind> kinds) {\n        diagnostics.removeIf(diagnostic -> !kinds.contains(diagnostic.getKind()));\n        return this;\n    }\n    /**\n     * Retains only errors.\n     * \n     * @return {@code this}\n     */\n    public Finder errors() {\n        diagnostics.retainAll(results.errors);\n        return this;\n    }\n    /**\n     * Retains only warnings.\n     * \n     * @return {@code this}\n     */\n    public Finder warnings() {\n        diagnostics.retainAll(results.warnings);\n        return this;\n    }\n    /**\n     * Retains only notes.\n     * \n     * @return {@code this}\n     */\n    public Finder notes() {\n        diagnostics.retainAll(results.notes);\n        return this;\n    }\n    /**\n     * Retains only diagnostic messages in the given Java source file.\n     * \n     * @param file the Java source file\n     * @return {@code this}\n     */\n    public Finder in(JavaFileObject file) {\n        var path = file.toUri().getPath();\n        diagnostics.removeIf(diagnostic -> !diagnostic.getSource().toUri().getPath().equals(path));\n        return this;\n    }\n    /**\n     * Retains only diagnostic messages that appear on the given line.\n     * \n     * @param line the line\n     * @return {@code this}\n     */\n    public Finder on(long line) {\n        diagnostics.removeIf(diagnostic -> diagnostic.getLineNumber() != line);\n        return this;\n    }\n    /**\n     * Retains only diagnostic messages that appear at the given column.\n     * \n     * @param column the column\n     * @return {@code this}\n     */\n    public Finder at(long column) {\n        diagnostics.removeIf(diagnostic -> diagnostic.getColumnNumber() != column);\n        return this;\n    }\n    /**\n     * Retains only diagnostic messages that satisfy the given predicate.\n     * \n     * @param condition the condition\n     * @return {@code this}\n     */\n    public Finder where(Predicate<Diagnostic<? extends JavaFileObject>> condition) {\n        diagnostics.removeIf(Predicate.not(condition));\n        return this;\n    }\n    /**\n     * Retains only diagnostic messages that exactly match the given message.\n     * \n     * @param message the message\n     * @return {@code this}\n     */\n    public Finder matches(String message) {\n        diagnostics.removeIf(diagnostic -> !diagnostic.getMessage(Locale.getDefault()).equals(message));\n        return this;\n    }\n    /**\n     * Retain only diagnostic messages that match the given pattern.\n     * \n     * @param pattern the pattern\n     * @return {@code this}\n     */\n    public Finder matches(Pattern pattern) {\n        diagnostics.removeIf(diagnostic -> !pattern.matcher(diagnostic.getMessage(Locale.getDefault())).matches());\n        return this;\n    }\n    /**\n     * Retain only diagnostic messages that contain the given substring.\n     * \n     * @param substring the substring\n     * @return {@code this}\n     */\n    public Finder contains(String substring) {\n        diagnostics.removeIf(diagnostic -> !diagnostic.getMessage(Locale.getDefault()).contains(substring));\n        return this;\n    }\n    /**\n     * Returns the full descriptions of the diagnostic messages.\n     * \n     * @return the full descriptions\n     */\n    public List<String> diagnostics() {\n        return diagnostics.stream().map(Diagnostic::toString).collect(toList());\n    }\n    /**\n     * Returns only the message portions of the diagnostic messages.\n     * \n     * @return the message portions\n     */\n    public List<String> messages() {\n        return diagnostics.stream().map(diagnostic -> diagnostic.getMessage(Locale.getDefault())).collect(toList());\n    }\n    /**\n     * Returns the line numbers of the diagnostic messages.\n     * \n     * @return the line numbers\n     */\n    public List<Long> lines() {\n        return diagnostics.stream().map(Diagnostic::getLineNumber).collect(toList());\n    }\n    /**\n     * Returns the column numbers of the diagnostic messages.\n     * \n     * @return the column numbers\n     */\n    public List<Long> columns() {\n        return diagnostics.stream().map(Diagnostic::getColumnNumber).collect(toList());\n    }\n    /**\n     * Return the positions of the diagnostic messages from the start of a source file.\n     * \n     * @return the positions\n     */\n    public List<Long> positions() {\n        return diagnostics.stream().map(Diagnostic::getPosition).collect(toList());\n    }\n    /**\n     * Return the codes of the diagnostic messages.\n     * \n     * @return the codes\n     */\n    public List<String> codes() {\n        return diagnostics.stream().map(Diagnostic::getCode).collect(toList());\n    }\n    /**\n     * Returns the diagnostic message if this {@code Finder} contains exactly one\n     * diagnostic message. Otherwise returns {@code null}.\n     * \n     * @return the diagnostic message if this {@code Finder} matches exactly one diagnostic message\n     */\n    public @Nullable Diagnostic<? extends JavaFileObject> one() {\n        return diagnostics.size() == 1 ? diagnostics.get(0) : null;\n    }\n    /**\n     * Returns the diagnostic messages.\n     * \n     * @return the diagnostic messages\n     */\n    public List<Diagnostic<? extends JavaFileObject>> list() {\n        return diagnostics;\n    }\n    /**\n     * Returns a map of diagnostic messages and associated {@code Kind}s.\n     * \n     * @return the map\n     */\n    public Map<Kind, List<Diagnostic<? extends JavaFileObject>>> map() {\n        var map = new HashMap<Kind, List<Diagnostic<? extends JavaFileObject>>>();\n        for (var diagnostic : diagnostics) {\n            var list = map.get(diagnostic.getKind());\n            if (list == null) {\n                map.put(diagnostic.getKind(), list = new ArrayList<>());\n            }\n            list.add(diagnostic);\n        }\n        return map;\n    }\n    /**\n     * Returns the current count of diagnostic messages.\n     * \n     * @return the current count of diagnostic messages\n     */\n    public int count() {\n        return diagnostics.size();\n    }\n"]], "pred": {"ppl": 1.3833752870559692, "ppl_lower": 1.4862319231033325, "ppl/lowercase_ppl": -1.2209916944470018, "ppl/zlib": 0.00024400479180968412, "Min_5.0% Prob": 4.563211763606352, "Min_10.0% Prob": 2.851875097728243, "Min_20.0% Prob": 1.5849061992895954, "Min_30.0% Prob": 1.0777716362374086, "Min_40.0% Prob": 0.8101456526491545, "Min_50.0% Prob": 0.6492579306317257, "Min_60.0% Prob": 0.5414487520563431}}
{"hexsha": "c53ce38df7a8663c294ef37cb2b3a837ded1c9f8", "ext": "java", "lang": "Java", "content": "public class OutputBlacklistDao extends DatabaseObjectDao<OutputBlacklist> {\n    \n    private static final Logger logger = LoggerFactory.getLogger(OutputBlacklistDao.class.getName());\n    \n    private final String tableName_ = \"OUTPUT_BLACKLIST\";\n    \n    public OutputBlacklistDao(){}\n            \n    public OutputBlacklistDao(boolean closeConnectionAfterOperation) {\n        databaseInterface_.setCloseConnectionAfterOperation(closeConnectionAfterOperation);\n    }\n    \n    public OutputBlacklistDao(DatabaseInterface databaseInterface) {\n        super(databaseInterface);\n    }\n    \n    public boolean dropTable() {\n        return dropTable(OutputBlacklistSql.DropTable_OutputBlacklist);\n    }\n    \n    public boolean createTable() {\n        List<String> databaseCreationSqlStatements = new ArrayList<>();\n        \n        if (DatabaseConfiguration.getType() == DatabaseConfiguration.MYSQL) {\n            databaseCreationSqlStatements.add(OutputBlacklistSql.CreateTable_OutputBlacklist_MySQL);\n        }\n        else {\n            databaseCreationSqlStatements.add(OutputBlacklistSql.CreateTable_OutputBlacklist_Derby);\n            databaseCreationSqlStatements.add(OutputBlacklistSql.CreateIndex_OutputBlacklist_PrimaryKey);\n        }\n        \n        databaseCreationSqlStatements.add(OutputBlacklistSql.CreateIndex_OutputBlacklist_ForeignKey_MetricGroupId);\n\n        return createTable(databaseCreationSqlStatements);\n    }\n    \n    @Override\n    public OutputBlacklist getDatabaseObject(OutputBlacklist outputBlacklist) {\n        if (outputBlacklist == null) {\n            databaseInterface_.cleanupAutomatic();\n            return null;\n        }\n        \n        return getDatabaseObject(OutputBlacklistSql.Select_OutputBlacklist_ByPrimaryKey, outputBlacklist.getId()); \n    }\n    \n    @Override\n    public boolean insert(OutputBlacklist outputBlacklist) {\n        if (outputBlacklist == null) {\n            databaseInterface_.cleanupAutomatic();\n            return false;\n        }\n        \n        return insert(OutputBlacklistSql.Insert_OutputBlacklist, outputBlacklist.getMetricGroupId());\n    }\n    \n    @Override\n    public boolean update(OutputBlacklist outputBlacklist) {\n        if (outputBlacklist == null) {\n            databaseInterface_.cleanupAutomatic();\n            return false;\n        }\n        \n        return update(OutputBlacklistSql.Update_OutputBlacklist_ByPrimaryKey, outputBlacklist.getMetricGroupId(), outputBlacklist.getId());\n    }\n\n    @Override\n    public boolean delete(OutputBlacklist outputBlacklist) {\n        if (outputBlacklist == null) {\n            databaseInterface_.cleanupAutomatic();\n            return false;\n        }\n        \n        return delete(OutputBlacklistSql.Delete_OutputBlacklist_ByPrimaryKey, outputBlacklist.getId()); \n    }\n    \n    @Override\n    public OutputBlacklist processSingleResultAllColumns(ResultSet resultSet) {\n        \n        try {     \n            if ((resultSet == null) || resultSet.isClosed()) {\n                return null;\n            }\n\n            Integer id = resultSet.getInt(\"ID\");\n            if (resultSet.wasNull()) id = null;\n            \n            Integer mgId = resultSet.getInt(\"METRIC_GROUP_ID\");\n            if (resultSet.wasNull()) mgId = null;\n\n            OutputBlacklist outputBlacklist = new OutputBlacklist(id, mgId);\n            \n            return outputBlacklist;\n        }\n        catch (Exception e) {\n            logger.error(e.toString() + System.lineSeparator() + StackTrace.getStringFromStackTrace(e));\n            return null;\n        }\n    }\n    \n    @Override\n    public String getTableName() {\n        return tableName_;\n    }\n    \n    public static OutputBlacklist getSingleOutputBlacklistRow() {\n        \n        OutputBlacklist outputBlacklist = null;\n        \n        OutputBlacklistDao outputBlacklistDao = new OutputBlacklistDao();\n        List<OutputBlacklist> outputBlacklists = outputBlacklistDao.getAllDatabaseObjectsInTable();\n        \n        if ((outputBlacklists != null) && outputBlacklists.size() > 1) {\n            logger.warn(\"There should not be more than one output blacklist row in the database.\");\n        }\n        \n        if ((outputBlacklists != null) && !outputBlacklists.isEmpty()) {\n            for (OutputBlacklist outputBlacklistFromDb : outputBlacklists) {\n                outputBlacklist = outputBlacklistFromDb;\n                break;\n            }\n        }\n        \n        return outputBlacklist;\n    }\n\n}", "item_id": 0, "repo": "cthiel42/StatsAgg", "file": "src/main/java/com/pearson/statsagg/database_objects/output_blacklist/OutputBlacklistDao.java", "last_update_at": "2022-03-10T03:43:27+00:00", "question_id": "c53ce38df7a8663c294ef37cb2b3a837ded1c9f8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OutputBlacklistDao extends DatabaseObjectDao<OutputBlacklist> {\n    private static final Logger logger = LoggerFactory.getLogger(OutputBlacklistDao.class.getName());\n    private final String tableName_ = \"OUTPUT_BLACKLIST\";\n    public OutputBlacklistDao(){}\n    public OutputBlacklistDao(boolean closeConnectionAfterOperation) {\n        databaseInterface_.setCloseConnectionAfterOperation(closeConnectionAfterOperation);\n    }\n    public OutputBlacklistDao(DatabaseInterface databaseInterface) {\n        super(databaseInterface);\n    }\n    public boolean dropTable() {\n        return dropTable(OutputBlacklistSql.DropTable_OutputBlacklist);\n    }\n    public boolean createTable() {\n        List<String> databaseCreationSqlStatements = new ArrayList<>();\n        if (DatabaseConfiguration.getType() == DatabaseConfiguration.MYSQL) {\n            databaseCreationSqlStatements.add(OutputBlacklistSql.CreateTable_OutputBlacklist_MySQL);\n        }\n        else {\n            databaseCreationSqlStatements.add(OutputBlacklistSql.CreateTable_OutputBlacklist_Derby);\n            databaseCreationSqlStatements.add(OutputBlacklistSql.CreateIndex_OutputBlacklist_PrimaryKey);\n        }\n        databaseCreationSqlStatements.add(OutputBlacklistSql.CreateIndex_OutputBlacklist_ForeignKey_MetricGroupId);\n        return createTable(databaseCreationSqlStatements);\n    }\n    @Override\n    public OutputBlacklist getDatabaseObject(OutputBlacklist outputBlacklist) {\n        if (outputBlacklist == null) {\n            databaseInterface_.cleanupAutomatic();\n            return null;\n        }\n        return getDatabaseObject(OutputBlacklistSql.Select_OutputBlacklist_ByPrimaryKey, outputBlacklist.getId()); \n    }\n    @Override\n    public boolean insert(OutputBlacklist outputBlacklist) {\n        if (outputBlacklist == null) {\n            databaseInterface_.cleanupAutomatic();\n            return false;\n        }\n        return insert(OutputBlacklistSql.Insert_OutputBlacklist, outputBlacklist.getMetricGroupId());\n    }\n    @Override\n    public boolean update(OutputBlacklist outputBlacklist) {\n        if (outputBlacklist == null) {\n            databaseInterface_.cleanupAutomatic();\n            return false;\n        }\n        return update(OutputBlacklistSql.Update_OutputBlacklist_ByPrimaryKey, outputBlacklist.getMetricGroupId(), outputBlacklist.getId());\n    }\n    @Override\n    public boolean delete(OutputBlacklist outputBlacklist) {\n        if (outputBlacklist == null) {\n            databaseInterface_.cleanupAutomatic();\n            return false;\n        }\n        return delete(OutputBlacklistSql.Delete_OutputBlacklist_ByPrimaryKey, outputBlacklist.getId()); \n    }\n    @Override\n    public OutputBlacklist processSingleResultAllColumns(ResultSet resultSet) {\n        try {     \n            if ((resultSet == null) || resultSet.isClosed()) {\n                return null;\n            }\n            Integer id = resultSet.getInt(\"ID\");\n            if (resultSet.wasNull()) id = null;\n            Integer mgId = resultSet.getInt(\"METRIC_GROUP_ID\");\n            if (resultSet.wasNull()) mgId = null;\n            OutputBlacklist outputBlacklist = new OutputBlacklist(id, mgId);\n            return outputBlacklist;\n        }\n        catch (Exception e) {\n            logger.error(e.toString() + System.lineSeparator() + StackTrace.getStringFromStackTrace(e));\n            return null;\n        }\n    }\n    @Override\n    public String getTableName() {\n        return tableName_;\n    }\n    public static OutputBlacklist getSingleOutputBlacklistRow() {\n        OutputBlacklist outputBlacklist = null;\n        OutputBlacklistDao outputBlacklistDao = new OutputBlacklistDao();\n        List<OutputBlacklist> outputBlacklists = outputBlacklistDao.getAllDatabaseObjectsInTable();\n        if ((outputBlacklists != null) && outputBlacklists.size() > 1) {\n            logger.warn(\"There should not be more than one output blacklist row in the database.\");\n        }\n        if ((outputBlacklists != null) && !outputBlacklists.isEmpty()) {\n            for (OutputBlacklist outputBlacklistFromDb : outputBlacklists) {\n                outputBlacklist = outputBlacklistFromDb;\n                break;\n            }\n        }\n        return outputBlacklist;\n    }\n"]], "pred": {"ppl": 1.6276183128356934, "ppl_lower": 1.8785502910614014, "ppl/lowercase_ppl": -1.2943488668685206, "ppl/zlib": 0.00046883329019937884, "Min_5.0% Prob": 5.613107989816105, "Min_10.0% Prob": 3.8640981094509947, "Min_20.0% Prob": 2.2994656628545593, "Min_30.0% Prob": 1.5977997571668203, "Min_40.0% Prob": 1.2106719539343656, "Min_50.0% Prob": 0.9730735543528444, "Min_60.0% Prob": 0.8124394543570744}}
{"hexsha": "9839329bf34ca1dbc2e66e0539ab09221d896203", "ext": "java", "lang": "Java", "content": "final class DirectStatementRetriever extends AbstractStatementRetriever {\n\n    private static final long DO_NOT_CACHE_RESULT = 0L;\n    private static final int HTTP_CONNECTION_TIMEOUT_MILLIS = 5000;\n    private static final int HTTP_CONNECTION_BACKOFF_MILLIS = 3000;\n    private static final int HTTP_CONNECTION_RETRY = 3;\n    private static final long HTTP_CONTENT_SIZE_LIMIT_IN_BYTES = 1024 * 1024;\n    private static final int MAX_INCLUDE_LEVEL = 1;\n    private static final String WELL_KNOWN_STATEMENT_PATH = \"/.well-known/assetlinks.json\";\n\n    private final URLFetcher mUrlFetcher;\n    private final AndroidPackageInfoFetcher mAndroidFetcher;\n\n    /**\n     * An immutable value type representing the retrieved statements and the expiration date.\n     */\n    public static class Result implements AbstractStatementRetriever.Result {\n\n        private final List<Statement> mStatements;\n        private final Long mExpireMillis;\n\n        @Override\n        public List<Statement> getStatements() {\n            return mStatements;\n        }\n\n        @Override\n        public long getExpireMillis() {\n            return mExpireMillis;\n        }\n\n        private Result(List<Statement> statements, Long expireMillis) {\n            mStatements = statements;\n            mExpireMillis = expireMillis;\n        }\n\n        public static Result create(List<Statement> statements, Long expireMillis) {\n            return new Result(statements, expireMillis);\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder result = new StringBuilder();\n            result.append(\"Result: \");\n            result.append(mStatements.toString());\n            result.append(\", mExpireMillis=\");\n            result.append(mExpireMillis);\n            return result.toString();\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            Result result = (Result) o;\n\n            if (!mExpireMillis.equals(result.mExpireMillis)) {\n                return false;\n            }\n            if (!mStatements.equals(result.mStatements)) {\n                return false;\n            }\n\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = mStatements.hashCode();\n            result = 31 * result + mExpireMillis.hashCode();\n            return result;\n        }\n    }\n\n    public DirectStatementRetriever(URLFetcher urlFetcher,\n                                    AndroidPackageInfoFetcher androidFetcher) {\n        this.mUrlFetcher = urlFetcher;\n        this.mAndroidFetcher = androidFetcher;\n    }\n\n    @Override\n    public Result retrieveStatements(AbstractAsset source) throws AssociationServiceException {\n        if (source instanceof AndroidAppAsset) {\n            return retrieveFromAndroid((AndroidAppAsset) source);\n        } else if (source instanceof WebAsset) {\n            return retrieveFromWeb((WebAsset) source);\n        } else {\n            throw new AssociationServiceException(\"Namespace is not supported.\");\n        }\n    }\n\n    private String computeAssociationJsonUrl(WebAsset asset) {\n        try {\n            return new URL(asset.getScheme(), asset.getDomain(), asset.getPort(),\n                    WELL_KNOWN_STATEMENT_PATH)\n                    .toExternalForm();\n        } catch (MalformedURLException e) {\n            throw new AssertionError(\"Invalid domain name in database.\");\n        }\n    }\n\n    private Result retrieveStatementFromUrl(String urlString, int maxIncludeLevel,\n                                            AbstractAsset source)\n            throws AssociationServiceException {\n        List<Statement> statements = new ArrayList<Statement>();\n        if (maxIncludeLevel < 0) {\n            return Result.create(statements, DO_NOT_CACHE_RESULT);\n        }\n\n        WebContent webContent;\n        try {\n            URL url = new URL(urlString);\n            if (!source.followInsecureInclude()\n                    && !url.getProtocol().toLowerCase().equals(\"https\")) {\n                return Result.create(statements, DO_NOT_CACHE_RESULT);\n            }\n            webContent = mUrlFetcher.getWebContentFromUrlWithRetry(url,\n                    HTTP_CONTENT_SIZE_LIMIT_IN_BYTES, HTTP_CONNECTION_TIMEOUT_MILLIS,\n                    HTTP_CONNECTION_BACKOFF_MILLIS, HTTP_CONNECTION_RETRY);\n        } catch (IOException | InterruptedException e) {\n            return Result.create(statements, DO_NOT_CACHE_RESULT);\n        }\n\n        try {\n            ParsedStatement result = StatementParser\n                    .parseStatementList(webContent.getContent(), source);\n            statements.addAll(result.getStatements());\n            for (String delegate : result.getDelegates()) {\n                statements.addAll(\n                        retrieveStatementFromUrl(delegate, maxIncludeLevel - 1, source)\n                                .getStatements());\n            }\n            return Result.create(statements, webContent.getExpireTimeMillis());\n        } catch (JSONException | IOException e) {\n            return Result.create(statements, DO_NOT_CACHE_RESULT);\n        }\n    }\n\n    private Result retrieveFromWeb(WebAsset asset)\n            throws AssociationServiceException {\n        return retrieveStatementFromUrl(computeAssociationJsonUrl(asset), MAX_INCLUDE_LEVEL, asset);\n    }\n\n    private Result retrieveFromAndroid(AndroidAppAsset asset) throws AssociationServiceException {\n        try {\n            List<String> delegates = new ArrayList<String>();\n            List<Statement> statements = new ArrayList<Statement>();\n\n            List<String> certFps = mAndroidFetcher.getCertFingerprints(asset.getPackageName());\n            if (!Utils.hasCommonString(certFps, asset.getCertFingerprints())) {\n                throw new AssociationServiceException(\n                        \"Specified certs don't match the installed app.\");\n            }\n\n            AndroidAppAsset actualSource = AndroidAppAsset.create(asset.getPackageName(), certFps);\n            for (String statementJson : mAndroidFetcher.getStatements(asset.getPackageName())) {\n                ParsedStatement result =\n                        StatementParser.parseStatement(statementJson, actualSource);\n                statements.addAll(result.getStatements());\n                delegates.addAll(result.getDelegates());\n            }\n\n            for (String delegate : delegates) {\n                statements.addAll(retrieveStatementFromUrl(delegate, MAX_INCLUDE_LEVEL,\n                        actualSource).getStatements());\n            }\n\n            return Result.create(statements, DO_NOT_CACHE_RESULT);\n        } catch (JSONException | IOException | NameNotFoundException e) {\n            Log.w(DirectStatementRetriever.class.getSimpleName(), e);\n            return Result.create(Collections.<Statement>emptyList(), DO_NOT_CACHE_RESULT);\n        }\n    }\n}", "item_id": 0, "repo": "rio-31/android_frameworks_base-1", "file": "packages/StatementService/src/com/android/statementservice/retriever/DirectStatementRetriever.java", "last_update_at": "2022-03-31T08:39:18+00:00", "question_id": "9839329bf34ca1dbc2e66e0539ab09221d896203_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["final class DirectStatementRetriever extends AbstractStatementRetriever {\n    private static final long DO_NOT_CACHE_RESULT = 0L;\n    private static final int HTTP_CONNECTION_TIMEOUT_MILLIS = 5000;\n    private static final int HTTP_CONNECTION_BACKOFF_MILLIS = 3000;\n    private static final int HTTP_CONNECTION_RETRY = 3;\n    private static final long HTTP_CONTENT_SIZE_LIMIT_IN_BYTES = 1024 * 1024;\n    private static final int MAX_INCLUDE_LEVEL = 1;\n    private static final String WELL_KNOWN_STATEMENT_PATH = \"/.well-known/assetlinks.json\";\n    private final URLFetcher mUrlFetcher;\n    private final AndroidPackageInfoFetcher mAndroidFetcher;\n    /**\n     * An immutable value type representing the retrieved statements and the expiration date.\n     */\n    public static class Result implements AbstractStatementRetriever.Result {\n        private final List<Statement> mStatements;\n        private final Long mExpireMillis;\n        @Override\n        public List<Statement> getStatements() {\n            return mStatements;\n        }\n        @Override\n        public long getExpireMillis() {\n            return mExpireMillis;\n        }\n        private Result(List<Statement> statements, Long expireMillis) {\n            mStatements = statements;\n            mExpireMillis = expireMillis;\n        }\n        public static Result create(List<Statement> statements, Long expireMillis) {\n            return new Result(statements, expireMillis);\n        }\n        @Override\n        public String toString() {\n            StringBuilder result = new StringBuilder();\n            result.append(\"Result: \");\n            result.append(mStatements.toString());\n            result.append(\", mExpireMillis=\");\n            result.append(mExpireMillis);\n            return result.toString();\n        }\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n            Result result = (Result) o;\n            if (!mExpireMillis.equals(result.mExpireMillis)) {\n                return false;\n            }\n            if (!mStatements.equals(result.mStatements)) {\n                return false;\n            }\n            return true;\n        }\n        @Override\n        public int hashCode() {\n            int result = mStatements.hashCode();\n            result = 31 * result + mExpireMillis.hashCode();\n            return result;\n        }\n    }\n    public DirectStatementRetriever(URLFetcher urlFetcher,\n                                    AndroidPackageInfoFetcher androidFetcher) {\n        this.mUrlFetcher = urlFetcher;\n        this.mAndroidFetcher = androidFetcher;\n    }\n    @Override\n    public Result retrieveStatements(AbstractAsset source) throws AssociationServiceException {\n        if (source instanceof AndroidAppAsset) {\n            return retrieveFromAndroid((AndroidAppAsset) source);\n        } else if (source instanceof WebAsset) {\n            return retrieveFromWeb((WebAsset) source);\n        } else {\n            throw new AssociationServiceException(\"Namespace is not supported.\");\n        }\n    }\n    private String computeAssociationJsonUrl(WebAsset asset) {\n        try {\n            return new URL(asset.getScheme(), asset.getDomain(), asset.getPort(),\n                    WELL_KNOWN_STATEMENT_PATH)\n                    .toExternalForm();\n        } catch (MalformedURLException e) {\n            throw new AssertionError(\"Invalid domain name in database.\");\n        }\n    }\n    private Result retrieveStatementFromUrl(String urlString, int maxIncludeLevel,\n                                            AbstractAsset source)\n            throws AssociationServiceException {\n        List<Statement> statements = new ArrayList<Statement>();\n        if (maxIncludeLevel < 0) {\n            return Result.create(statements, DO_NOT_CACHE_RESULT);\n        }\n        WebContent webContent;\n        try {\n            URL url = new URL(urlString);\n            if (!source.followInsecureInclude()\n                    && !url.getProtocol().toLowerCase().equals(\"https\")) {\n                return Result.create(statements, DO_NOT_CACHE_RESULT);\n            }\n            webContent = mUrlFetcher.getWebContentFromUrlWithRetry(url,\n                    HTTP_CONTENT_SIZE_LIMIT_IN_BYTES, HTTP_CONNECTION_TIMEOUT_MILLIS,\n                    HTTP_CONNECTION_BACKOFF_MILLIS, HTTP_CONNECTION_RETRY);\n        } catch (IOException | InterruptedException e) {\n            return Result.create(statements, DO_NOT_CACHE_RESULT);\n        }\n        try {\n            ParsedStatement result = StatementParser\n                    .parseStatementList(webContent.getContent(), source);\n            statements.addAll(result.getStatements());\n            for (String delegate : result.getDelegates()) {\n                statements.addAll(\n                        retrieveStatementFromUrl(delegate, maxIncludeLevel - 1, source)\n                                .getStatements());\n            }\n            return Result.create(statements, webContent.getExpireTimeMillis());\n        } catch (JSONException | IOException e) {\n            return Result.create(statements, DO_NOT_CACHE_RESULT);\n        }\n    }\n    private Result retrieveFromWeb(WebAsset asset)\n            throws AssociationServiceException {\n        return retrieveStatementFromUrl(computeAssociationJsonUrl(asset), MAX_INCLUDE_LEVEL, asset);\n    }\n    private Result retrieveFromAndroid(AndroidAppAsset asset) throws AssociationServiceException {\n        try {\n            List<String> delegates = new ArrayList<String>();\n            List<Statement> statements = new ArrayList<Statement>();\n            List<String> certFps = mAndroidFetcher.getCertFingerprints(asset.getPackageName());\n            if (!Utils.hasCommonString(certFps, asset.getCertFingerprints())) {\n                throw new AssociationServiceException(\n                        \"Specified certs don't match the installed app.\");\n            }\n            AndroidAppAsset actualSource = AndroidAppAsset.create(asset.getPackageName(), certFps);\n            for (String statementJson : mAndroidFetcher.getStatements(asset.getPackageName())) {\n                ParsedStatement result =\n                        StatementParser.parseStatement(statementJson, actualSource);\n                statements.addAll(result.getStatements());\n                delegates.addAll(result.getDelegates());\n            }\n            for (String delegate : delegates) {\n                statements.addAll(retrieveStatementFromUrl(delegate, MAX_INCLUDE_LEVEL,\n                        actualSource).getStatements());\n            }\n            return Result.create(statements, DO_NOT_CACHE_RESULT);\n        } catch (JSONException | IOException | NameNotFoundException e) {\n            Log.w(DirectStatementRetriever.class.getSimpleName(), e);\n            return Result.create(Collections.<Statement>emptyList(), DO_NOT_CACHE_RESULT);\n        }\n    }\n"]], "pred": {"ppl": 1.7712370157241821, "ppl_lower": 1.9309145212173462, "ppl/lowercase_ppl": -1.1509862668524145, "ppl/zlib": 0.0003276092730222306, "Min_5.0% Prob": 5.812693563162112, "Min_10.0% Prob": 4.221791131823671, "Min_20.0% Prob": 2.65144590799715, "Min_30.0% Prob": 1.8703314425314175, "Min_40.0% Prob": 1.4220452222034954, "Min_50.0% Prob": 1.14286526608957, "Min_60.0% Prob": 0.953712239089311}}
{"hexsha": "80e314fc843a0e143ee24bde6d195b484f3b6a2d", "ext": "java", "lang": "Java", "content": "public class DMLCallStatement implements DMLStatement {\n\n    private static final long serialVersionUID = -3180767340174107586L;\n    private long parseInfo;\n    private Identifier name;\n    private final List<Expression> params;\n\n    public DMLCallStatement(Identifier name, List<Expression> params) {\n        this.name = name;\n        this.params = params;\n    }\n\n    public Identifier getName() {\n        return name;\n    }\n\n    public List<Expression> getParams() {\n        return params;\n    }\n\n    @Override\n    public void accept(Visitor visitor) {\n        visitor.visit(this);\n    }\n\n    @Override\n    public int getSQLType() {\n        return SQLType.CALL;\n    }\n\n    @Override\n    public void setParseInfo(long parseInfo) {\n        this.parseInfo = parseInfo;\n    }\n\n    @Override\n    public long getParseInfo() {\n        return parseInfo;\n    }\n\n    @Override\n    public boolean replace(AST from, AST to) {\n        boolean result = false;\n        if (name != null) {\n            if (name.equals(from)) {\n                name = (Identifier) to;\n                result = true;\n            } else {\n                result |= name.replace(from, to);\n            }\n        }\n        if (params != null) {\n            Iterator<Expression> iter = params.iterator();\n            int i = 0;\n            while (iter.hasNext()) {\n                Expression exp = iter.next();\n                if (exp != null) {\n                    if (exp.equals(to)) {\n                        params.set(i, (Expression) to);\n                        result = true;\n                    } else {\n                        result |= exp.replace(from, to);\n                    }\n                }\n                i++;\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public boolean removeSchema(byte[] schema) {\n        boolean removed = false;\n        if (name != null) {\n            removed |= name.removeSchema(schema);\n        }\n        if (params != null) {\n            Iterator<Expression> iter = params.iterator();\n            while (iter.hasNext()) {\n                Expression exp = iter.next();\n                if (exp != null) {\n                    removed |= exp.removeSchema(schema);\n                }\n            }\n        }\n        return removed;\n    }\n\n    @Override\n    public void setCachedTableName(byte[] affectedTable) {}\n\n    @Override\n    public byte[] getCachedTableName() {\n        return null;\n    }\n\n    @Override\n    public boolean maybeMoreThanTwoTable() {\n        return false;\n    }\n}", "item_id": 0, "repo": "Dagon0577/DagonParser", "file": "src/main/java/parser/ast/stmt/dml/DMLCallStatement.java", "last_update_at": "2022-01-28T09:49:23+00:00", "question_id": "80e314fc843a0e143ee24bde6d195b484f3b6a2d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DMLCallStatement implements DMLStatement {\n    private static final long serialVersionUID = -3180767340174107586L;\n    private long parseInfo;\n    private Identifier name;\n    private final List<Expression> params;\n    public DMLCallStatement(Identifier name, List<Expression> params) {\n        this.name = name;\n        this.params = params;\n    }\n    public Identifier getName() {\n        return name;\n    }\n    public List<Expression> getParams() {\n        return params;\n    }\n    @Override\n    public void accept(Visitor visitor) {\n        visitor.visit(this);\n    }\n    @Override\n    public int getSQLType() {\n        return SQLType.CALL;\n    }\n    @Override\n    public void setParseInfo(long parseInfo) {\n        this.parseInfo = parseInfo;\n    }\n    @Override\n    public long getParseInfo() {\n        return parseInfo;\n    }\n    @Override\n    public boolean replace(AST from, AST to) {\n        boolean result = false;\n        if (name != null) {\n            if (name.equals(from)) {\n                name = (Identifier) to;\n                result = true;\n            } else {\n                result |= name.replace(from, to);\n            }\n        }\n        if (params != null) {\n            Iterator<Expression> iter = params.iterator();\n            int i = 0;\n            while (iter.hasNext()) {\n                Expression exp = iter.next();\n                if (exp != null) {\n                    if (exp.equals(to)) {\n                        params.set(i, (Expression) to);\n                        result = true;\n                    } else {\n                        result |= exp.replace(from, to);\n                    }\n                }\n                i++;\n            }\n        }\n        return result;\n    }\n    @Override\n    public boolean removeSchema(byte[] schema) {\n        boolean removed = false;\n        if (name != null) {\n            removed |= name.removeSchema(schema);\n        }\n        if (params != null) {\n            Iterator<Expression> iter = params.iterator();\n            while (iter.hasNext()) {\n                Expression exp = iter.next();\n                if (exp != null) {\n                    removed |= exp.removeSchema(schema);\n                }\n            }\n        }\n        return removed;\n    }\n    @Override\n    public void setCachedTableName(byte[] affectedTable) {}\n    @Override\n    public byte[] getCachedTableName() {\n        return null;\n    }\n    @Override\n    public boolean maybeMoreThanTwoTable() {\n        return false;\n    }\n"]], "pred": {"ppl": 1.4610962867736816, "ppl_lower": 1.6865555047988892, "ppl/lowercase_ppl": -1.378444507728826, "ppl/zlib": 0.0005710648122013878, "Min_5.0% Prob": 4.441119013410626, "Min_10.0% Prob": 3.143509181577768, "Min_20.0% Prob": 1.8337529607450784, "Min_30.0% Prob": 1.2552679808282141, "Min_40.0% Prob": 0.9478102300364747, "Min_50.0% Prob": 0.7575807387842187, "Min_60.0% Prob": 0.6320497446497625}}
{"hexsha": "632d53786d2948c3d5c78c1a9615b0daf5edf8df", "ext": "java", "lang": "Java", "content": "public class EventuateSTOMPClientTest {\n\n  private Logger logger = LoggerFactory.getLogger(getClass());\n\n  private EventuateSTOMPClient client;\n  private TrackingStompServer server;\n  private EventuateCredentials credentials = new EventuateCredentials(\"x\", \"y\", \"default\");\n  private static Vertx vertx;\n  private static int port;\n  private BlockingQueue<Int128> ids;\n  private String mySubId = \"MySubId\";\n  private String subId;\n\n  @Before\n  public void setUp() {\n    ids = new LinkedBlockingDeque<>();\n  }\n\n  @BeforeClass\n  public static void beforeClass() throws IOException {\n    port = PortUtil.findPort();\n    vertx = Vertx.vertx();\n  }\n\n  @AfterClass\n  public static void afterClass() {\n    if (vertx != null) vertx.close();\n  }\n\n  @After\n  public void tearDown() throws ExecutionException, InterruptedException {\n    if (server != null)\n      server.close();\n  }\n\n  private void makeClientAndSubscribeSync() throws URISyntaxException, ExecutionException, InterruptedException {\n    makeClient();\n    subscribeSync();\n  }\n\n  private void makeClient() throws URISyntaxException {\n    client = new EventuateSTOMPClient(vertx, credentials, new URI(\"stomp://localhost:\" + port));\n  }\n\n  private void subscribeSync() throws InterruptedException, ExecutionException {\n    subId = subscribeAsync(mySubId).get();\n  }\n\n  private CompletableFuture<String> subscribeAsync(String subscribeId) {\n    return (CompletableFuture<String>) client.subscribe(subscribeId,\n            Collections.singletonMap(\"MyEntityType\",\n                    Collections.singleton(\"MyEvent\")),\n            null, se -> {\n              ids.add(se.getId());\n              return CompletableFuture.completedFuture(\"x\");\n            });\n  }\n\n  private void makeServer() {\n    server = new TrackingStompServer(vertx, port);\n    try {\n      server.getListenFuture().get(5, TimeUnit.SECONDS);\n    } catch (InterruptedException | TimeoutException | ExecutionException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  private void assertDisconnected() throws InterruptedException, ExecutionException {\n    for (int i = 0; i < 2000; i++) {\n      if (!client.isConnected()) break;\n      TimeUnit.MILLISECONDS.sleep(50);\n    }\n\n    assertFalse(client.isConnected());\n  }\n\n  private void assertConnected() throws InterruptedException, ExecutionException {\n    for (int i = 0; i < 50; i++) {\n      if (client.isConnected()) break;\n      TimeUnit.MILLISECONDS.sleep(100);\n    }\n\n    assertTrue(client.isConnected());\n  }\n\n\n  @Test\n  public void shouldConnect() throws InterruptedException, URISyntaxException, IOException, ExecutionException {\n\n    makeServer();\n\n    makeClientAndSubscribeSync();\n\n    assertConnected();\n\n    server.assertSubscribed();\n\n    List<Int128> receivedIds = new ArrayList<>();\n\n    logger.debug(\"Sending message\");\n    for (int i = 0; i < 500; i++) {\n      server.sendMessage(subId, \"0-\" + i);\n    }\n\n    while (receivedIds.size() != 500) {\n      Int128 x = ids.poll(20, TimeUnit.SECONDS);\n      assertNotNull(x);\n      receivedIds.add(x);\n    }\n\n    List<Int128> sorted = new ArrayList<>(receivedIds);\n    sorted.sort((o1, o2) -> o1.asString().compareTo(o2.asString()));\n\n    assertEquals(sorted, receivedIds);\n    server.close();\n\n\n    assertDisconnected();\n\n\n    makeServer();\n    assertConnected();\n\n    server.assertSubscribed();\n\n    client.close();\n\n\n\n  }\n\n  @Test\n  public void shouldRepeatedlyAttemptToConnect() throws InterruptedException, URISyntaxException, IOException, ExecutionException, TimeoutException {\n\n    makeClient();\n    subscribeAsync(mySubId);\n\n    TimeUnit.SECONDS.sleep(5);\n\n    makeServer();\n\n    assertConnected();\n\n    server.assertSubscribed();\n\n    server.close();\n    client.close();\n\n  }\n\n  @Test\n  public void trySubscribing() throws InterruptedException, URISyntaxException, IOException, ExecutionException, TimeoutException {\n\n    makeServer();\n    makeClientAndSubscribeSync();\n\n    assertConnected();\n\n    // server.assertSubscribed();\n\n    client.subscribe(\"MySubId2\",\n            Collections.singletonMap(\"MyEntityType2\",\n                    Collections.singleton(\"MyEvent\")),\n            null, se -> {\n              System.out.print(\"Y\");\n              return CompletableFuture.completedFuture(\"x\");\n            }).get(5, TimeUnit.SECONDS);\n\n    client.close();\n\n    server.close();\n\n  }\n\n\n  @Test\n  public void shouldClose() throws Exception {\n\n    makeServer();\n\n    makeClientAndSubscribeSync();\n\n    assertConnected();\n\n    server.assertSubscribed();\n\n    client.close();\n\n    server.assertClientIsDisconnected();\n  }\n\n\n  @Test\n  public void shouldProcessTwoSubscriptions() throws Exception {\n\n    makeServer();\n\n    makeClient();\n\n    CompletableFuture sub1cf = new CompletableFuture();\n\n    String subId1 = ((CompletableFuture<String>) client.subscribe(\"mySubscribeId1\",\n            Collections.singletonMap(\"MyEntityType\",\n                    Collections.singleton(\"MyEvent\")),\n            null, se -> {\n              ids.add(se.getId());\n              return sub1cf;\n            })).get(4, TimeUnit.SECONDS);\n\n    assertConnected();\n\n    CompletableFuture sub2cf = new CompletableFuture();\n\n    String subId2 = ((CompletableFuture<String>) client.subscribe(\"mySubscribeId2\",\n            Collections.singletonMap(\"MyEntityType\",\n                    Collections.singleton(\"MyEvent\")),\n            null, se -> {\n              ids.add(se.getId());\n              return sub2cf;\n            })).get(4, TimeUnit.SECONDS);\n\n\n    server.assertSubscribed();\n\n    List<Int128> receivedIds = new ArrayList<>();\n\n    server.sendMessage(subId1, \"1-2\");\n\n    while (receivedIds.size() != 1) {\n      Int128 x = ids.poll(20, TimeUnit.SECONDS);\n      assertNotNull(x);\n      receivedIds.add(x);\n    }\n\n    server.sendMessage(subId2, \"3-4\");\n\n    while (receivedIds.size() != 2) {\n      Int128 x = ids.poll(20, TimeUnit.SECONDS);\n      assertNotNull(x);\n      receivedIds.add(x);\n    }\n\n    sub2cf.complete(null);\n\n    server.assertAcked(1);\n\n    sub1cf.complete(null);\n\n    server.assertAcked(2);\n\n    server.close();\n\n\n    assertDisconnected();\n\n\n    makeServer();\n    assertConnected();\n\n    server.assertSubscribed();\n\n    client.close();\n\n\n\n  }\n\n  }", "item_id": 0, "repo": "dialtahi/eventuate-client-java", "file": "eventuate-client-java-http-stomp/src/test/java/io/eventuate/javaclient/stompclient/EventuateSTOMPClientTest.java", "last_update_at": "2022-03-10T07:52:00+00:00", "question_id": "632d53786d2948c3d5c78c1a9615b0daf5edf8df_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EventuateSTOMPClientTest {\n  private Logger logger = LoggerFactory.getLogger(getClass());\n  private EventuateSTOMPClient client;\n  private TrackingStompServer server;\n  private EventuateCredentials credentials = new EventuateCredentials(\"x\", \"y\", \"default\");\n  private static Vertx vertx;\n  private static int port;\n  private BlockingQueue<Int128> ids;\n  private String mySubId = \"MySubId\";\n  private String subId;\n  @Before\n  public void setUp() {\n    ids = new LinkedBlockingDeque<>();\n  }\n  @BeforeClass\n  public static void beforeClass() throws IOException {\n    port = PortUtil.findPort();\n    vertx = Vertx.vertx();\n  }\n  @AfterClass\n  public static void afterClass() {\n    if (vertx != null) vertx.close();\n  }\n  @After\n  public void tearDown() throws ExecutionException, InterruptedException {\n    if (server != null)\n      server.close();\n  }\n  private void makeClientAndSubscribeSync() throws URISyntaxException, ExecutionException, InterruptedException {\n    makeClient();\n    subscribeSync();\n  }\n  private void makeClient() throws URISyntaxException {\n    client = new EventuateSTOMPClient(vertx, credentials, new URI(\"stomp://localhost:\" + port));\n  }\n  private void subscribeSync() throws InterruptedException, ExecutionException {\n    subId = subscribeAsync(mySubId).get();\n  }\n  private CompletableFuture<String> subscribeAsync(String subscribeId) {\n    return (CompletableFuture<String>) client.subscribe(subscribeId,\n            Collections.singletonMap(\"MyEntityType\",\n                    Collections.singleton(\"MyEvent\")),\n            null, se -> {\n              ids.add(se.getId());\n              return CompletableFuture.completedFuture(\"x\");\n            });\n  }\n  private void makeServer() {\n    server = new TrackingStompServer(vertx, port);\n    try {\n      server.getListenFuture().get(5, TimeUnit.SECONDS);\n    } catch (InterruptedException | TimeoutException | ExecutionException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  private void assertDisconnected() throws InterruptedException, ExecutionException {\n    for (int i = 0; i < 2000; i++) {\n      if (!client.isConnected()) break;\n      TimeUnit.MILLISECONDS.sleep(50);\n    }\n    assertFalse(client.isConnected());\n  }\n  private void assertConnected() throws InterruptedException, ExecutionException {\n    for (int i = 0; i < 50; i++) {\n      if (client.isConnected()) break;\n      TimeUnit.MILLISECONDS.sleep(100);\n    }\n    assertTrue(client.isConnected());\n  }\n  @Test\n  public void shouldConnect() throws InterruptedException, URISyntaxException, IOException, ExecutionException {\n    makeServer();\n    makeClientAndSubscribeSync();\n    assertConnected();\n    server.assertSubscribed();\n    List<Int128> receivedIds = new ArrayList<>();\n    logger.debug(\"Sending message\");\n    for (int i = 0; i < 500; i++) {\n      server.sendMessage(subId, \"0-\" + i);\n    }\n    while (receivedIds.size() != 500) {\n      Int128 x = ids.poll(20, TimeUnit.SECONDS);\n      assertNotNull(x);\n      receivedIds.add(x);\n    }\n    List<Int128> sorted = new ArrayList<>(receivedIds);\n    sorted.sort((o1, o2) -> o1.asString().compareTo(o2.asString()));\n    assertEquals(sorted, receivedIds);\n    server.close();\n    assertDisconnected();\n    makeServer();\n    assertConnected();\n    server.assertSubscribed();\n    client.close();\n  }\n  @Test\n  public void shouldRepeatedlyAttemptToConnect() throws InterruptedException, URISyntaxException, IOException, ExecutionException, TimeoutException {\n    makeClient();\n    subscribeAsync(mySubId);\n    TimeUnit.SECONDS.sleep(5);\n    makeServer();\n    assertConnected();\n    server.assertSubscribed();\n    server.close();\n    client.close();\n  }\n  @Test\n  public void trySubscribing() throws InterruptedException, URISyntaxException, IOException, ExecutionException, TimeoutException {\n    makeServer();\n    makeClientAndSubscribeSync();\n    assertConnected();\n    // server.assertSubscribed();\n    client.subscribe(\"MySubId2\",\n            Collections.singletonMap(\"MyEntityType2\",\n                    Collections.singleton(\"MyEvent\")),\n            null, se -> {\n              System.out.print(\"Y\");\n              return CompletableFuture.completedFuture(\"x\");\n            }).get(5, TimeUnit.SECONDS);\n    client.close();\n    server.close();\n  }\n  @Test\n  public void shouldClose() throws Exception {\n    makeServer();\n    makeClientAndSubscribeSync();\n    assertConnected();\n    server.assertSubscribed();\n    client.close();\n    server.assertClientIsDisconnected();\n  }\n  @Test\n  public void shouldProcessTwoSubscriptions() throws Exception {\n    makeServer();\n    makeClient();\n    CompletableFuture sub1cf = new CompletableFuture();\n    String subId1 = ((CompletableFuture<String>) client.subscribe(\"mySubscribeId1\",\n            Collections.singletonMap(\"MyEntityType\",\n                    Collections.singleton(\"MyEvent\")),\n            null, se -> {\n              ids.add(se.getId());\n              return sub1cf;\n            })).get(4, TimeUnit.SECONDS);\n    assertConnected();\n    CompletableFuture sub2cf = new CompletableFuture();\n    String subId2 = ((CompletableFuture<String>) client.subscribe(\"mySubscribeId2\",\n            Collections.singletonMap(\"MyEntityType\",\n                    Collections.singleton(\"MyEvent\")),\n            null, se -> {\n              ids.add(se.getId());\n              return sub2cf;\n            })).get(4, TimeUnit.SECONDS);\n    server.assertSubscribed();\n    List<Int128> receivedIds = new ArrayList<>();\n    server.sendMessage(subId1, \"1-2\");\n    while (receivedIds.size() != 1) {\n      Int128 x = ids.poll(20, TimeUnit.SECONDS);\n      assertNotNull(x);\n      receivedIds.add(x);\n    }\n    server.sendMessage(subId2, \"3-4\");\n    while (receivedIds.size() != 2) {\n      Int128 x = ids.poll(20, TimeUnit.SECONDS);\n      assertNotNull(x);\n      receivedIds.add(x);\n    }\n    sub2cf.complete(null);\n    server.assertAcked(1);\n    sub1cf.complete(null);\n    server.assertAcked(2);\n    server.close();\n    assertDisconnected();\n    makeServer();\n    assertConnected();\n    server.assertSubscribed();\n    client.close();\n  }\n"]], "pred": {"ppl": 1.9118754863739014, "ppl_lower": 2.151655912399292, "ppl/lowercase_ppl": -1.1823111222241482, "ppl/zlib": 0.0004672564457961684, "Min_5.0% Prob": 5.88795571233712, "Min_10.0% Prob": 4.3470158717211556, "Min_20.0% Prob": 2.8827630161654714, "Min_30.0% Prob": 2.0923859321214016, "Min_40.0% Prob": 1.604292814262339, "Min_50.0% Prob": 1.2935773375063202, "Min_60.0% Prob": 1.0807705014628064}}
{"hexsha": "1824bf17d53722495c9a51156d627a24a8f9432f", "ext": "java", "lang": "Java", "content": "public class MailDateFormatTest extends TestCase {\n    public void testMailDateFormat() throws ParseException {\n        MailDateFormat mdf = new MailDateFormat();\n        Date date = mdf.parse(\"Wed, 27 Aug 2003 13:43:38 +0100 (BST)\");\n        // don't we just love the Date class?\n        Calendar cal = Calendar.getInstance(new SimpleTimeZone(+1 * 60 * 60 * 1000, \"BST\"), Locale.getDefault());\n        cal.setTime(date);\n        assertEquals(2003, cal.get(Calendar.YEAR));\n        assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));\n        assertEquals(27, cal.get(Calendar.DAY_OF_MONTH));\n        assertEquals(Calendar.WEDNESDAY, cal.get(Calendar.DAY_OF_WEEK));\n        assertEquals(13, cal.get(Calendar.HOUR_OF_DAY));\n        assertEquals(43, cal.get(Calendar.MINUTE));\n        assertEquals(38, cal.get(Calendar.SECOND));\n        \n        date = mdf.parse(\"Wed, 27-Aug-2003 13:43:38 +0100\");\n        // don't we just love the Date class?\n        cal = Calendar.getInstance(new SimpleTimeZone(+1 * 60 * 60 * 1000, \"BST\"), Locale.getDefault());\n        cal.setTime(date);\n        assertEquals(2003, cal.get(Calendar.YEAR));\n        assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));\n        assertEquals(27, cal.get(Calendar.DAY_OF_MONTH));\n        assertEquals(Calendar.WEDNESDAY, cal.get(Calendar.DAY_OF_WEEK));\n        assertEquals(13, cal.get(Calendar.HOUR_OF_DAY));\n        assertEquals(43, cal.get(Calendar.MINUTE));\n        assertEquals(38, cal.get(Calendar.SECOND));\n        \n        date = mdf.parse(\"27-Aug-2003 13:43:38 EST\");\n        // don't we just love the Date class?\n        cal = Calendar.getInstance(new SimpleTimeZone(-5 * 60 * 60 * 1000, \"EST\"), Locale.getDefault());\n        cal.setTime(date);\n        assertEquals(2003, cal.get(Calendar.YEAR));\n        assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));\n        assertEquals(27, cal.get(Calendar.DAY_OF_MONTH));\n        assertEquals(Calendar.WEDNESDAY, cal.get(Calendar.DAY_OF_WEEK));\n        assertEquals(13, cal.get(Calendar.HOUR_OF_DAY));\n        assertEquals(43, cal.get(Calendar.MINUTE));\n        assertEquals(38, cal.get(Calendar.SECOND));\n        \n        date = mdf.parse(\"27 Aug 2003 13:43 EST\");\n        // don't we just love the Date class?\n        cal = Calendar.getInstance(new SimpleTimeZone(-5 * 60 * 60 * 1000, \"EST\"), Locale.getDefault());\n        cal.setTime(date);\n        assertEquals(2003, cal.get(Calendar.YEAR));\n        assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));\n        assertEquals(27, cal.get(Calendar.DAY_OF_MONTH));\n        assertEquals(Calendar.WEDNESDAY, cal.get(Calendar.DAY_OF_WEEK));\n        assertEquals(13, cal.get(Calendar.HOUR_OF_DAY));\n        assertEquals(43, cal.get(Calendar.MINUTE));\n        assertEquals(00, cal.get(Calendar.SECOND));\n        \n        date = mdf.parse(\"27 Aug 03 13:43 EST\");\n        // don't we just love the Date class?\n        cal = Calendar.getInstance(new SimpleTimeZone(-5 * 60 * 60 * 1000, \"EST\"), Locale.getDefault());\n        cal.setTime(date);\n        assertEquals(2003, cal.get(Calendar.YEAR));\n        assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));\n        assertEquals(27, cal.get(Calendar.DAY_OF_MONTH));\n        assertEquals(Calendar.WEDNESDAY, cal.get(Calendar.DAY_OF_WEEK));\n        assertEquals(13, cal.get(Calendar.HOUR_OF_DAY));\n        assertEquals(43, cal.get(Calendar.MINUTE));\n        assertEquals(00, cal.get(Calendar.SECOND));\n    }\n}", "item_id": 0, "repo": "CyberFlameGO/appengine-java-standard", "file": "third_party/geronimo_javamail/src/test/java/javax/mail/internet/MailDateFormatTest.java", "last_update_at": "2022-03-29T17:56:28+00:00", "question_id": "1824bf17d53722495c9a51156d627a24a8f9432f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MailDateFormatTest extends TestCase {\n    public void testMailDateFormat() throws ParseException {\n        MailDateFormat mdf = new MailDateFormat();\n        Date date = mdf.parse(\"Wed, 27 Aug 2003 13:43:38 +0100 (BST)\");\n        // don't we just love the Date class?\n        Calendar cal = Calendar.getInstance(new SimpleTimeZone(+1 * 60 * 60 * 1000, \"BST\"), Locale.getDefault());\n        cal.setTime(date);\n        assertEquals(2003, cal.get(Calendar.YEAR));\n        assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));\n        assertEquals(27, cal.get(Calendar.DAY_OF_MONTH));\n        assertEquals(Calendar.WEDNESDAY, cal.get(Calendar.DAY_OF_WEEK));\n        assertEquals(13, cal.get(Calendar.HOUR_OF_DAY));\n        assertEquals(43, cal.get(Calendar.MINUTE));\n        assertEquals(38, cal.get(Calendar.SECOND));\n        date = mdf.parse(\"Wed, 27-Aug-2003 13:43:38 +0100\");\n        // don't we just love the Date class?\n        cal = Calendar.getInstance(new SimpleTimeZone(+1 * 60 * 60 * 1000, \"BST\"), Locale.getDefault());\n        cal.setTime(date);\n        assertEquals(2003, cal.get(Calendar.YEAR));\n        assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));\n        assertEquals(27, cal.get(Calendar.DAY_OF_MONTH));\n        assertEquals(Calendar.WEDNESDAY, cal.get(Calendar.DAY_OF_WEEK));\n        assertEquals(13, cal.get(Calendar.HOUR_OF_DAY));\n        assertEquals(43, cal.get(Calendar.MINUTE));\n        assertEquals(38, cal.get(Calendar.SECOND));\n        date = mdf.parse(\"27-Aug-2003 13:43:38 EST\");\n        // don't we just love the Date class?\n        cal = Calendar.getInstance(new SimpleTimeZone(-5 * 60 * 60 * 1000, \"EST\"), Locale.getDefault());\n        cal.setTime(date);\n        assertEquals(2003, cal.get(Calendar.YEAR));\n        assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));\n        assertEquals(27, cal.get(Calendar.DAY_OF_MONTH));\n        assertEquals(Calendar.WEDNESDAY, cal.get(Calendar.DAY_OF_WEEK));\n        assertEquals(13, cal.get(Calendar.HOUR_OF_DAY));\n        assertEquals(43, cal.get(Calendar.MINUTE));\n        assertEquals(38, cal.get(Calendar.SECOND));\n        date = mdf.parse(\"27 Aug 2003 13:43 EST\");\n        // don't we just love the Date class?\n        cal = Calendar.getInstance(new SimpleTimeZone(-5 * 60 * 60 * 1000, \"EST\"), Locale.getDefault());\n        cal.setTime(date);\n        assertEquals(2003, cal.get(Calendar.YEAR));\n        assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));\n        assertEquals(27, cal.get(Calendar.DAY_OF_MONTH));\n        assertEquals(Calendar.WEDNESDAY, cal.get(Calendar.DAY_OF_WEEK));\n        assertEquals(13, cal.get(Calendar.HOUR_OF_DAY));\n        assertEquals(43, cal.get(Calendar.MINUTE));\n        assertEquals(00, cal.get(Calendar.SECOND));\n        date = mdf.parse(\"27 Aug 03 13:43 EST\");\n        // don't we just love the Date class?\n        cal = Calendar.getInstance(new SimpleTimeZone(-5 * 60 * 60 * 1000, \"EST\"), Locale.getDefault());\n        cal.setTime(date);\n        assertEquals(2003, cal.get(Calendar.YEAR));\n        assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));\n        assertEquals(27, cal.get(Calendar.DAY_OF_MONTH));\n        assertEquals(Calendar.WEDNESDAY, cal.get(Calendar.DAY_OF_WEEK));\n        assertEquals(13, cal.get(Calendar.HOUR_OF_DAY));\n        assertEquals(43, cal.get(Calendar.MINUTE));\n        assertEquals(00, cal.get(Calendar.SECOND));\n    }\n"]], "pred": {"ppl": 1.2004023790359497, "ppl_lower": 1.2945598363876343, "ppl/lowercase_ppl": -1.4134196998964719, "ppl/zlib": 0.00040771610815054925, "Min_5.0% Prob": 3.13780321560654, "Min_10.0% Prob": 1.7706277065125167, "Min_20.0% Prob": 0.9125959918395999, "Min_30.0% Prob": 0.6101121590236883, "Min_40.0% Prob": 0.45675530235401485, "Min_50.0% Prob": 0.36564357650514445, "Min_60.0% Prob": 0.30481863214844473}}
{"hexsha": "4c09433dc97e494c0262c338c2595e368a50d56d", "ext": "java", "lang": "Java", "content": "@RunWith(MockitoJUnitRunner.class)\npublic class PaywallCredentialPopulatorTest {\n\n    @Mock\n    private ClouderaManagerLicenseProvider clouderaManagerLicenseProvider;\n\n    @InjectMocks\n    private PaywallCredentialPopulator underTest;\n\n    @Test\n    public void testPopulateWebTargetShouldAddCredentialsWhenTheUrlIsPointsToArchive() {\n        String baseUrl = \"http://archive.cloudera.com/parcel1/\";\n        WebTarget webTarget = createWebTarget(baseUrl);\n        JsonCMLicense license = mock(JsonCMLicense.class);\n\n        when(clouderaManagerLicenseProvider.getLicense(any())).thenReturn(license);\n        when(license.getPaywallUsername()).thenReturn(\"user\");\n        when(license.getPaywallPassword()).thenReturn(\"pw\");\n\n        underTest.populateWebTarget(baseUrl, webTarget);\n\n        assertFalse(webTarget.getConfiguration().getInstances().isEmpty());\n        verify(clouderaManagerLicenseProvider).getLicense(any());\n        verify(license).getPaywallUsername();\n        verify(license).getPaywallPassword();\n    }\n\n    @Test\n    public void testPopulateWebTargetShouldNotAddCredentialsWhenTheUrlIsNotPointsToArchive() {\n        String baseUrl = \"http://random.cloudera.com/parcel1/\";\n        WebTarget webTarget = createWebTarget(baseUrl);\n\n        underTest.populateWebTarget(baseUrl, webTarget);\n\n        assertTrue(webTarget.getConfiguration().getInstances().isEmpty());\n        verifyNoInteractions(clouderaManagerLicenseProvider);\n    }\n\n    private WebTarget createWebTarget(String baseUrl) {\n        return RestClientUtil.get().target(StringUtils.stripEnd(baseUrl, \"/\") + \"/manifest.json\");\n    }\n\n}", "item_id": 0, "repo": "smolnar82/cloudbreak", "file": "auth-connector/src/test/java/com/sequenceiq/cloudbreak/auth/PaywallCredentialPopulatorTest.java", "last_update_at": "2022-03-25T05:03:18+00:00", "question_id": "4c09433dc97e494c0262c338c2595e368a50d56d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(MockitoJUnitRunner.class)\npublic class PaywallCredentialPopulatorTest {\n    @Mock\n    private ClouderaManagerLicenseProvider clouderaManagerLicenseProvider;\n    @InjectMocks\n    private PaywallCredentialPopulator underTest;\n    @Test\n    public void testPopulateWebTargetShouldAddCredentialsWhenTheUrlIsPointsToArchive() {\n        String baseUrl = \"http://archive.cloudera.com/parcel1/\";\n        WebTarget webTarget = createWebTarget(baseUrl);\n        JsonCMLicense license = mock(JsonCMLicense.class);\n        when(clouderaManagerLicenseProvider.getLicense(any())).thenReturn(license);\n        when(license.getPaywallUsername()).thenReturn(\"user\");\n        when(license.getPaywallPassword()).thenReturn(\"pw\");\n        underTest.populateWebTarget(baseUrl, webTarget);\n        assertFalse(webTarget.getConfiguration().getInstances().isEmpty());\n        verify(clouderaManagerLicenseProvider).getLicense(any());\n        verify(license).getPaywallUsername();\n        verify(license).getPaywallPassword();\n    }\n    @Test\n    public void testPopulateWebTargetShouldNotAddCredentialsWhenTheUrlIsNotPointsToArchive() {\n        String baseUrl = \"http://random.cloudera.com/parcel1/\";\n        WebTarget webTarget = createWebTarget(baseUrl);\n        underTest.populateWebTarget(baseUrl, webTarget);\n        assertTrue(webTarget.getConfiguration().getInstances().isEmpty());\n        verifyNoInteractions(clouderaManagerLicenseProvider);\n    }\n    private WebTarget createWebTarget(String baseUrl) {\n        return RestClientUtil.get().target(StringUtils.stripEnd(baseUrl, \"/\") + \"/manifest.json\");\n    }\n"]], "pred": {"ppl": 1.866431713104248, "ppl_lower": 2.617765188217163, "ppl/lowercase_ppl": -1.542110777373604, "ppl/zlib": 0.0011796378698886347, "Min_5.0% Prob": 7.2498151530390205, "Min_10.0% Prob": 5.063404321670532, "Min_20.0% Prob": 3.012856427094211, "Min_30.0% Prob": 2.0630095720076733, "Min_40.0% Prob": 1.5614415181549015, "Min_50.0% Prob": 1.247322120191931, "Min_60.0% Prob": 1.0413874903691283}}
{"hexsha": "d1556e3cc448e5e27b330b7cced5cebb52f46ffb", "ext": "java", "lang": "Java", "content": "public class RestMultiActionController extends AbstractMultiActionController {\n    \n    /**\n     * custom MethodNameResolver is configured that checks the value of an expected\n     * paramter called \"method\" in the request and formats the value that may be\n     * in the form of  \"namespace.subnamespace.action\" into \"namespaceSubnamespaceAction\"\n     * or more like a java method name\n     */\n    public RestMultiActionController() {\n        setMethodNameResolver(new MethodNameResolver() {\n            public String getHandlerMethodName(HttpServletRequest request) throws NoSuchRequestHandlingMethodException {\n                String temp = request.getParameter(\"method\");\n                if (temp == null) {\n                    return null;\n                }\n                StringBuffer sb = new StringBuffer();\n                for(int i = 0; i < temp.length(); i++) {\n                    char c = temp.charAt(i);\n                    if (c == '.') {\n                        i++;\n                        c = temp.charAt(i);\n                        sb.append(Character.toUpperCase(c));\n                    } else {\n                        sb.append(c);\n                    }\n                }\n                return sb.toString();\n            }\n        });\n    }\n    \n    /**\n     * override Spring template method as a crude interceptor\n     * here we are doing HTTP basic authentication TODO better security\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        if(!authenticate(request)) {\n            String title = \"Basic realm=\\\"JTrac Remote API\\\"\";\n            response.setHeader(\"WWW-Authenticate\", title);\n            response.setStatus(401);\n            return null;\n        } else {\n            return super.handleRequestInternal(request, response);\n        }\n    }\n    \n    private boolean authenticate(HttpServletRequest request) {\n        String authHeader = request.getHeader(\"Authorization\");\n        logger.debug(\"auth header: \" + authHeader);\n        if (authHeader == null) {\n            return false;\n        }\n        StringTokenizer st = new StringTokenizer(authHeader);\n        if (st.hasMoreTokens()) {\n            String basic = st.nextToken();\n            if (basic.equalsIgnoreCase(\"Basic\")) {\n                String credentials = st.nextToken();\n                Base64 decoder = new Base64();\n                String userPass = new String(decoder.decode(credentials.getBytes()));                \n                int p = userPass.indexOf(\":\");\n                if (p == -1) {\n                    return false;\n                }\n                String loginName = userPass.substring(0, p);\n                String password = userPass.substring(p + 1);\n                User user = jtrac.loadUser(loginName);\n                if(user == null) {\n                    return false;\n                }\n                String encoded = jtrac.encodeClearText(password);\n                if(user.getPassword().equals(encoded)) {\n                    request.setAttribute(\"user\", user);\n                    return true;\n                }                \n            }\n        }\n        return false;\n    }\n    \n    private void writeXml(Document document, HttpServletResponse response) throws Exception {\n        writeXml(document.getRootElement(), response);\n    }    \n    \n    private void writeXml(Element element, HttpServletResponse response) throws Exception {\n        initXmlResponse(response);\n        element.write(response.getWriter());\n    }\n    \n    private void initXmlResponse(HttpServletResponse response) {\n        applyCacheSeconds(response, 0, true);\n        response.setContentType(\"text/xml\");         \n    }\n    \n    private String getContent(HttpServletRequest request) throws Exception {\n        InputStream is = request.getInputStream();        \n        int ch;\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        while ((ch = is.read()) != -1) {\n            baos.write((byte) ch);\n        }\n        return new String(baos.toByteArray());\n    }\n    \n    //============================ REQUEST HANDLERS ============================\n        \n    public void versionGet(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        Document d = XmlUtils.getNewDocument(\"version\");\n        Element root = d.getRootElement();\n        root.addAttribute(\"number\", jtrac.getReleaseVersion());\n        root.addAttribute(\"timestamp\", jtrac.getReleaseTimestamp());\n        writeXml(d, response);\n    }\n    \n    public void itemGet(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String refId = request.getParameter(\"refId\");\n        Item item = null;\n        try {\n            item = jtrac.loadItemByRefId(refId);\n        } catch (InvalidRefIdException e) {\n            // TODO\n        }\n        // TODO if item == null\n        if (item == null) {\n            return;\n        }\n        Element e = ItemUtils.getAsXml(item);\n        writeXml(e, response);\n    }\n    \n    public void itemPut(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        logger.debug(getContent(request));\n        Document d = XmlUtils.getNewDocument(\"success\");\n        Element root = d.getRootElement();\n        root.addElement(\"refId\").addText(\"FOOBAR-123\");\n        writeXml(d, response);      \n    }\n    \n    public void spaceUsersGet(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String prefixCode = request.getParameter(\"prefixCode\");\n        Space space = jtrac.loadSpace(prefixCode);\n        Document d = XmlUtils.getNewDocument(\"users\");\n        Element root = d.getRootElement();\n        root.addAttribute(\"prefixCode\", prefixCode);\n        List<User> users = jtrac.findUsersForSpace(space.getId());\n        for(User user : users) {\n            root.addElement(\"user\").addAttribute(\"loginName\", user.getLoginName()).addText(user.getName());\n        }\n        writeXml(d, response);\n    }\n    \n    public void itemSearchGet(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String queryString = request.getQueryString();\n        logger.debug(\"parsing queryString: \" + queryString);\n        ValueMap map = new ValueMap();\n        RequestUtils.decodeParameters(queryString, map);\n        logger.debug(\"decoded: \" + map);\n        User user = (User) request.getAttribute(\"user\");\n        PageParameters params = new PageParameters(map);\n        ItemSearch itemSearch = ItemUtils.getItemSearch(user, params, jtrac);        \n        initXmlResponse(response);\n        ItemUtils.writeAsXml(itemSearch, jtrac, response.getWriter());\n    }\n    \n    public void itemAllGet(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        // GOD mode!\n        User user = (User) request.getAttribute(\"user\");\n        if(!user.isSuperUser()) {\n            // TODO error code\n            return;\n        }\n        initXmlResponse(response);\n        ItemUtils.writeAsXml(jtrac, response.getWriter());\n    }\n    \n}", "item_id": 0, "repo": "StephenTunAung/jTracker", "file": "src/main/java/info/jtrac/web/RestMultiActionController.java", "last_update_at": "2022-01-14T17:22:46+00:00", "question_id": "d1556e3cc448e5e27b330b7cced5cebb52f46ffb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RestMultiActionController extends AbstractMultiActionController {\n    /**\n     * custom MethodNameResolver is configured that checks the value of an expected\n     * paramter called \"method\" in the request and formats the value that may be\n     * in the form of  \"namespace.subnamespace.action\" into \"namespaceSubnamespaceAction\"\n     * or more like a java method name\n     */\n    public RestMultiActionController() {\n        setMethodNameResolver(new MethodNameResolver() {\n            public String getHandlerMethodName(HttpServletRequest request) throws NoSuchRequestHandlingMethodException {\n                String temp = request.getParameter(\"method\");\n                if (temp == null) {\n                    return null;\n                }\n                StringBuffer sb = new StringBuffer();\n                for(int i = 0; i < temp.length(); i++) {\n                    char c = temp.charAt(i);\n                    if (c == '.') {\n                        i++;\n                        c = temp.charAt(i);\n                        sb.append(Character.toUpperCase(c));\n                    } else {\n                        sb.append(c);\n                    }\n                }\n                return sb.toString();\n            }\n        });\n    }\n    /**\n     * override Spring template method as a crude interceptor\n     * here we are doing HTTP basic authentication TODO better security\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        if(!authenticate(request)) {\n            String title = \"Basic realm=\\\"JTrac Remote API\\\"\";\n            response.setHeader(\"WWW-Authenticate\", title);\n            response.setStatus(401);\n            return null;\n        } else {\n            return super.handleRequestInternal(request, response);\n        }\n    }\n    private boolean authenticate(HttpServletRequest request) {\n        String authHeader = request.getHeader(\"Authorization\");\n        logger.debug(\"auth header: \" + authHeader);\n        if (authHeader == null) {\n            return false;\n        }\n        StringTokenizer st = new StringTokenizer(authHeader);\n        if (st.hasMoreTokens()) {\n            String basic = st.nextToken();\n            if (basic.equalsIgnoreCase(\"Basic\")) {\n                String credentials = st.nextToken();\n                Base64 decoder = new Base64();\n                String userPass = new String(decoder.decode(credentials.getBytes()));                \n                int p = userPass.indexOf(\":\");\n                if (p == -1) {\n                    return false;\n                }\n                String loginName = userPass.substring(0, p);\n                String password = userPass.substring(p + 1);\n                User user = jtrac.loadUser(loginName);\n                if(user == null) {\n                    return false;\n                }\n                String encoded = jtrac.encodeClearText(password);\n                if(user.getPassword().equals(encoded)) {\n                    request.setAttribute(\"user\", user);\n                    return true;\n                }                \n            }\n        }\n        return false;\n    }\n    private void writeXml(Document document, HttpServletResponse response) throws Exception {\n        writeXml(document.getRootElement(), response);\n    }    \n    private void writeXml(Element element, HttpServletResponse response) throws Exception {\n        initXmlResponse(response);\n        element.write(response.getWriter());\n    }\n    private void initXmlResponse(HttpServletResponse response) {\n        applyCacheSeconds(response, 0, true);\n        response.setContentType(\"text/xml\");         \n    }\n    private String getContent(HttpServletRequest request) throws Exception {\n        InputStream is = request.getInputStream();        \n        int ch;\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        while ((ch = is.read()) != -1) {\n            baos.write((byte) ch);\n        }\n        return new String(baos.toByteArray());\n    }\n    //============================ REQUEST HANDLERS ============================\n    public void versionGet(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        Document d = XmlUtils.getNewDocument(\"version\");\n        Element root = d.getRootElement();\n        root.addAttribute(\"number\", jtrac.getReleaseVersion());\n        root.addAttribute(\"timestamp\", jtrac.getReleaseTimestamp());\n        writeXml(d, response);\n    }\n    public void itemGet(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String refId = request.getParameter(\"refId\");\n        Item item = null;\n        try {\n            item = jtrac.loadItemByRefId(refId);\n        } catch (InvalidRefIdException e) {\n            // TODO\n        }\n        // TODO if item == null\n        if (item == null) {\n            return;\n        }\n        Element e = ItemUtils.getAsXml(item);\n        writeXml(e, response);\n    }\n    public void itemPut(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        logger.debug(getContent(request));\n        Document d = XmlUtils.getNewDocument(\"success\");\n        Element root = d.getRootElement();\n        root.addElement(\"refId\").addText(\"FOOBAR-123\");\n        writeXml(d, response);      \n    }\n    public void spaceUsersGet(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String prefixCode = request.getParameter(\"prefixCode\");\n        Space space = jtrac.loadSpace(prefixCode);\n        Document d = XmlUtils.getNewDocument(\"users\");\n        Element root = d.getRootElement();\n        root.addAttribute(\"prefixCode\", prefixCode);\n        List<User> users = jtrac.findUsersForSpace(space.getId());\n        for(User user : users) {\n            root.addElement(\"user\").addAttribute(\"loginName\", user.getLoginName()).addText(user.getName());\n        }\n        writeXml(d, response);\n    }\n    public void itemSearchGet(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String queryString = request.getQueryString();\n        logger.debug(\"parsing queryString: \" + queryString);\n        ValueMap map = new ValueMap();\n        RequestUtils.decodeParameters(queryString, map);\n        logger.debug(\"decoded: \" + map);\n        User user = (User) request.getAttribute(\"user\");\n        PageParameters params = new PageParameters(map);\n        ItemSearch itemSearch = ItemUtils.getItemSearch(user, params, jtrac);        \n        initXmlResponse(response);\n        ItemUtils.writeAsXml(itemSearch, jtrac, response.getWriter());\n    }\n    public void itemAllGet(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        // GOD mode!\n        User user = (User) request.getAttribute(\"user\");\n        if(!user.isSuperUser()) {\n            // TODO error code\n            return;\n        }\n        initXmlResponse(response);\n        ItemUtils.writeAsXml(jtrac, response.getWriter());\n    }\n"]], "pred": {"ppl": 2.066962242126465, "ppl_lower": 2.338768720626831, "ppl/lowercase_ppl": -1.170152858188835, "ppl/zlib": 0.0003765975173964053, "Min_5.0% Prob": 6.6476321968377805, "Min_10.0% Prob": 5.07599084517535, "Min_20.0% Prob": 3.282031589863347, "Min_30.0% Prob": 2.346662388615359, "Min_40.0% Prob": 1.795884362897838, "Min_50.0% Prob": 1.447663644798931, "Min_60.0% Prob": 1.2097268119700508}}
{"hexsha": "94fd864833873e122a5f05aae0924bc43c743bce", "ext": "java", "lang": "Java", "content": "public class FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES{\nstatic int f_gold ( int arr [ ] , int arr_size ) {\n  int i ;\n  for ( i = 0 ;\n  i < arr_size ;\n  i ++ ) {\n    int count = 0 ;\n    for ( int j = 0 ;\n    j < arr_size ;\n    j ++ ) {\n      if ( arr [ i ] == arr [ j ] ) count ++ ;\n    }\n    if ( count % 2 != 0 ) return arr [ i ] ;\n  }\n  return - 1 ;\n}\n\n\n//TOFILL\n\npublic static void main(String args[]) {\n    int n_success = 0;\n    List<int [ ]> param0 = new ArrayList<>();\n    param0.add(new int[]{1,5,5,8,14,15,17,17,18,23,23,25,26,35,36,39,51,53,56,56,60,62,64,64,65,66,67,68,71,75,80,82,83,88,89,91,91,92,93,95,99});\n    param0.add(new int[]{-56,98,44,30,-88,18,60,86,4,16,10,64,-22,-86,-66,-16,70,-44,98,78,-96,-66,92,10,40,-16});\n    param0.add(new int[]{0,0,0,0,0,1,1,1});\n    param0.add(new int[]{36,11,83,41,42,14,46,89,91,96,57,42,74,73,9,26,79,40,31,69,44,39,14,92,34,20,52,47,14});\n    param0.add(new int[]{-84,-84,-84,-78,-66,-62,-62,-36,-24,-10,-10,-8,-4,-2,12,14,20,22,36,42,46,66,84,96,96,98});\n    param0.add(new int[]{1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,1,0,0,1,1,1,0,1,1,1,1,1,1});\n    param0.add(new int[]{11,12,14,28,42,48,50,58,67,74,86,89,95});\n    param0.add(new int[]{52,-56,-6,74,10,68,74,10,16,-80,82,-32,6,-6,82,20});\n    param0.add(new int[]{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1});\n    param0.add(new int[]{4,80,92});\n    List<Integer> param1 = new ArrayList<>();\n    param1.add(31);\n    param1.add(19);\n    param1.add(6);\n    param1.add(25);\n    param1.add(23);\n    param1.add(19);\n    param1.add(7);\n    param1.add(11);\n    param1.add(31);\n    param1.add(1);\n    for(int i = 0; i < param0.size(); ++i)\n    {\n        if(f_filled(param0.get(i),param1.get(i)) == f_gold(param0.get(i),param1.get(i)))\n        {\n            n_success+=1;\n        }\n    }\n    System.out.println(\"#Results:\" + n_success + \", \" + param0.size());\n}\n}", "item_id": 0, "repo": "mxl1n/CodeGen", "file": "data/transcoder_evaluation_gfg/java/FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES.java", "last_update_at": "2022-03-31T02:39:08+00:00", "question_id": "94fd864833873e122a5f05aae0924bc43c743bce_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES{\nstatic int f_gold ( int arr [ ] , int arr_size ) {\n  int i ;\n  for ( i = 0 ;\n  i < arr_size ;\n  i ++ ) {\n    int count = 0 ;\n    for ( int j = 0 ;\n    j < arr_size ;\n    j ++ ) {\n      if ( arr [ i ] == arr [ j ] ) count ++ ;\n    }\n    if ( count % 2 != 0 ) return arr [ i ] ;\n  }\n  return - 1 ;\n}\n//TOFILL\npublic static void main(String args[]) {\n    int n_success = 0;\n    List<int [ ]> param0 = new ArrayList<>();\n    param0.add(new int[]{1,5,5,8,14,15,17,17,18,23,23,25,26,35,36,39,51,53,56,56,60,62,64,64,65,66,67,68,71,75,80,82,83,88,89,91,91,92,93,95,99});\n    param0.add(new int[]{-56,98,44,30,-88,18,60,86,4,16,10,64,-22,-86,-66,-16,70,-44,98,78,-96,-66,92,10,40,-16});\n    param0.add(new int[]{0,0,0,0,0,1,1,1});\n    param0.add(new int[]{36,11,83,41,42,14,46,89,91,96,57,42,74,73,9,26,79,40,31,69,44,39,14,92,34,20,52,47,14});\n    param0.add(new int[]{-84,-84,-84,-78,-66,-62,-62,-36,-24,-10,-10,-8,-4,-2,12,14,20,22,36,42,46,66,84,96,96,98});\n    param0.add(new int[]{1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,1,0,0,1,1,1,0,1,1,1,1,1,1});\n    param0.add(new int[]{11,12,14,28,42,48,50,58,67,74,86,89,95});\n    param0.add(new int[]{52,-56,-6,74,10,68,74,10,16,-80,82,-32,6,-6,82,20});\n    param0.add(new int[]{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1});\n    param0.add(new int[]{4,80,92});\n    List<Integer> param1 = new ArrayList<>();\n    param1.add(31);\n    param1.add(19);\n    param1.add(6);\n    param1.add(25);\n    param1.add(23);\n    param1.add(19);\n    param1.add(7);\n    param1.add(11);\n    param1.add(31);\n    param1.add(1);\n    for(int i = 0; i < param0.size(); ++i)\n    {\n        if(f_filled(param0.get(i),param1.get(i)) == f_gold(param0.get(i),param1.get(i)))\n        {\n            n_success+=1;\n        }\n    }\n    System.out.println(\"#Results:\" + n_success + \", \" + param0.size());\n}\n"]], "pred": {"ppl": 2.3216655254364014, "ppl_lower": 2.549978494644165, "ppl/lowercase_ppl": -1.1113638708038105, "ppl/zlib": 0.0011097296798512136, "Min_5.0% Prob": 4.027397777519974, "Min_10.0% Prob": 3.2606050383810903, "Min_20.0% Prob": 2.7552205744911644, "Min_30.0% Prob": 2.4285503177860983, "Min_40.0% Prob": 2.016778271690849, "Min_50.0% Prob": 1.6648675390973016, "Min_60.0% Prob": 1.3998579388426626}}
{"hexsha": "cc1b9f17dc00f6ae1e71a893edde91d03189a496", "ext": "java", "lang": "Java", "content": "public class ModelMapperUtil {\n\n\n    /**\n     * Get modelMapper instance with MatchingStrategies=STANDARD and\n     * FieldMatchingEnabled=true<br>\n     * <br>\n     * Note: enable \"FieldMatchingEnabled=true\" can help to successfully match\n     * obsolete fields in A against A1 class, which A1 have\n     * setter & getter while another don't\n     *\n     * @return\n     */\n    // TODO If A has getter but no setter, and setFieldMatchingEnabled = false, can it work?\n    public static ModelMapper getModelMapperWithFieldMatching() {\n        ModelMapper modelMapper = new ModelMapper();\n        modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STANDARD).setFieldMatchingEnabled(true).setFieldAccessLevel(Configuration.AccessLevel.PRIVATE);\n        return modelMapper;\n    }\n\n\n}", "item_id": 0, "repo": "HaiHuangCHN/order-center", "file": "order-center-common/src/main/java/com/nice/order/center/common/util/ModelMapperUtil.java", "last_update_at": "2022-03-08T12:34:49+00:00", "question_id": "cc1b9f17dc00f6ae1e71a893edde91d03189a496_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ModelMapperUtil {\n    /**\n     * Get modelMapper instance with MatchingStrategies=STANDARD and\n     * FieldMatchingEnabled=true<br>\n     * <br>\n     * Note: enable \"FieldMatchingEnabled=true\" can help to successfully match\n     * obsolete fields in A against A1 class, which A1 have\n     * setter & getter while another don't\n     *\n     * @return\n     */\n    // TODO If A has getter but no setter, and setFieldMatchingEnabled = false, can it work?\n    public static ModelMapper getModelMapperWithFieldMatching() {\n        ModelMapper modelMapper = new ModelMapper();\n        modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STANDARD).setFieldMatchingEnabled(true).setFieldAccessLevel(Configuration.AccessLevel.PRIVATE);\n        return modelMapper;\n    }\n"]], "pred": {"ppl": 4.203529357910156, "ppl_lower": 5.409915447235107, "ppl/lowercase_ppl": -1.1757118628332086, "ppl/zlib": 0.003749150119392433, "Min_5.0% Prob": 8.806423091888428, "Min_10.0% Prob": 7.344805308750698, "Min_20.0% Prob": 5.492093296938164, "Min_30.0% Prob": 4.412536909030034, "Min_40.0% Prob": 3.519636204873008, "Min_50.0% Prob": 2.865262093347147, "Min_60.0% Prob": 2.3968148063726096}}
{"hexsha": "c74136467b4366bb3bcce2faafdd1712def913a2", "ext": "java", "lang": "Java", "content": "public class PartFactoryProvider extends GridStoreFactoryProvider\nimplements GridStoreFactoryProvider.ChainProvidable,\nExtensibles.AsFactoryProvidable {\n\n\t@Override\n\tpublic GridStoreFactory getFactory() {\n\t\treturn getFactory(\n\t\t\t\tCollections.<Class<?>>emptySet(),\n\t\t\t\tCollections.<Class<?>>emptySet());\n\t}\n\n\t@Override\n\tpublic GridStoreFactory getFactory(\n\t\t\tSet<Class<?>> chainProviderClasses,\n\t\t\tSet<Class<?>> visitedProviderClasses) {\n\t\tfinal Class<?> thisClass = PartFactoryProvider.class;\n\n\t\tfinal Set<Class<?>> exclusiveClasses = new HashSet<Class<?>>();\n\t\texclusiveClasses.add(thisClass);\n\t\texclusiveClasses.addAll(chainProviderClasses);\n\t\texclusiveClasses.addAll(visitedProviderClasses);\n\n\t\tfinal List<ChainProvidable> providerList = ServiceProviderUtils.load(\n\t\t\t\tGridStoreFactoryProvider.class,\n\t\t\t\tChainProvidable.class,\n\t\t\t\tServiceProviderUtils.listClassLoaders(thisClass),\n\t\t\t\texclusiveClasses);\n\n\t\tif (!providerList.isEmpty()) {\n\t\t\tfinal Set<Class<?>> nextVisitedClasses = new HashSet<Class<?>>();\n\t\t\tnextVisitedClasses.add(thisClass);\n\t\t\tnextVisitedClasses.addAll(visitedProviderClasses);\n\n\t\t\treturn providerList.get(0).getFactory(\n\t\t\t\t\tchainProviderClasses, nextVisitedClasses);\n\t\t}\n\n\t\treturn new PartFactory(\n\t\t\t\tServiceProviderUtils.mergeChainClasses(\n\t\t\t\t\t\tchainProviderClasses, PartFactoryProvider.class),\n\t\t\t\tvisitedProviderClasses,\n\t\t\t\tgetBaseProvider());\n\t}\n\n\t@Override\n\tpublic Extensibles.AsStoreFactory getExtensibleFactory(\n\t\t\tSet<Class<?>> chainProviderClasses,\n\t\t\tSet<Class<?>> visitedProviderClasses) {\n\t\tfinal PartFactory base = new PartFactory(\n\t\t\t\tServiceProviderUtils.mergeChainClasses(\n\t\t\t\t\t\tchainProviderClasses, PartFactoryProvider.class),\n\t\t\t\tvisitedProviderClasses,\n\t\t\t\tgetBaseProvider());\n\t\treturn new PartFactory.ExtensibleFactory(base);\n\t}\n\n\tprivate static Extensibles.AsFactoryProvidable getBaseProvider() {\n\t\treturn new SubnetGridStoreFactoryProvider();\n\t}\n\n}", "item_id": 0, "repo": "Amine-El-Ghaoual/griddb", "file": "java_client/src/com/toshiba/mwcloud/gs/partitioned/PartFactoryProvider.java", "last_update_at": "2022-03-30T19:24:55+00:00", "question_id": "c74136467b4366bb3bcce2faafdd1712def913a2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PartFactoryProvider extends GridStoreFactoryProvider\nimplements GridStoreFactoryProvider.ChainProvidable,\nExtensibles.AsFactoryProvidable {\n\t@Override\n\tpublic GridStoreFactory getFactory() {\n\t\treturn getFactory(\n\t\t\t\tCollections.<Class<?>>emptySet(),\n\t\t\t\tCollections.<Class<?>>emptySet());\n\t}\n\t@Override\n\tpublic GridStoreFactory getFactory(\n\t\t\tSet<Class<?>> chainProviderClasses,\n\t\t\tSet<Class<?>> visitedProviderClasses) {\n\t\tfinal Class<?> thisClass = PartFactoryProvider.class;\n\t\tfinal Set<Class<?>> exclusiveClasses = new HashSet<Class<?>>();\n\t\texclusiveClasses.add(thisClass);\n\t\texclusiveClasses.addAll(chainProviderClasses);\n\t\texclusiveClasses.addAll(visitedProviderClasses);\n\t\tfinal List<ChainProvidable> providerList = ServiceProviderUtils.load(\n\t\t\t\tGridStoreFactoryProvider.class,\n\t\t\t\tChainProvidable.class,\n\t\t\t\tServiceProviderUtils.listClassLoaders(thisClass),\n\t\t\t\texclusiveClasses);\n\t\tif (!providerList.isEmpty()) {\n\t\t\tfinal Set<Class<?>> nextVisitedClasses = new HashSet<Class<?>>();\n\t\t\tnextVisitedClasses.add(thisClass);\n\t\t\tnextVisitedClasses.addAll(visitedProviderClasses);\n\t\t\treturn providerList.get(0).getFactory(\n\t\t\t\t\tchainProviderClasses, nextVisitedClasses);\n\t\t}\n\t\treturn new PartFactory(\n\t\t\t\tServiceProviderUtils.mergeChainClasses(\n\t\t\t\t\t\tchainProviderClasses, PartFactoryProvider.class),\n\t\t\t\tvisitedProviderClasses,\n\t\t\t\tgetBaseProvider());\n\t}\n\t@Override\n\tpublic Extensibles.AsStoreFactory getExtensibleFactory(\n\t\t\tSet<Class<?>> chainProviderClasses,\n\t\t\tSet<Class<?>> visitedProviderClasses) {\n\t\tfinal PartFactory base = new PartFactory(\n\t\t\t\tServiceProviderUtils.mergeChainClasses(\n\t\t\t\t\t\tchainProviderClasses, PartFactoryProvider.class),\n\t\t\t\tvisitedProviderClasses,\n\t\t\t\tgetBaseProvider());\n\t\treturn new PartFactory.ExtensibleFactory(base);\n\t}\n\tprivate static Extensibles.AsFactoryProvidable getBaseProvider() {\n\t\treturn new SubnetGridStoreFactoryProvider();\n\t}\n"]], "pred": {"ppl": 2.060062885284424, "ppl_lower": 2.2682583332061768, "ppl/lowercase_ppl": -1.1332100599796846, "ppl/zlib": 0.001471968450453471, "Min_5.0% Prob": 6.839921347300211, "Min_10.0% Prob": 4.958262872695923, "Min_20.0% Prob": 3.2938158216555258, "Min_30.0% Prob": 2.3583443415922356, "Min_40.0% Prob": 1.7967028041670392, "Min_50.0% Prob": 1.4457495876199362, "Min_60.0% Prob": 1.2040994641199174}}
{"hexsha": "2e09fec0ce4c0e909a45949f158d511c15647c0c", "ext": "java", "lang": "Java", "content": "@SpringBootTest(\n        classes = {\n            HSQLDBTestProfileJPAConfiguration.class,\n            TailormapHealthIndicator.class,\n            VersionController.class\n        })\n@AutoConfigureMockMvc\n@EnableAutoConfiguration\n@TestPropertySource(properties = {\"management.health.tailormap.enabled=true\"})\n@ActiveProfiles(\"test\")\n@AutoConfigureMetrics\nclass TailormapHealthIndicatorEnabledIntegrationTest {\n    @Autowired private MockMvc mockMvc;\n\n    @SuppressWarnings(\"PMD.JUnitTestsShouldIncludeAssert\")\n    @Test\n    void when_enabled_health_should_have_status_and_response_data() throws Exception {\n        String projectVersion = System.getProperty(\"project.version\");\n        assumeFalse(\n                null == projectVersion,\n                \"Project version unknown, should be set as system property\");\n        String databaseVersion = System.getenv(\"DATABASE_VERSION\");\n        assumeFalse(\n                null == databaseVersion,\n                \"Database version unknown, should be set in system environment\");\n        String apiVersion = System.getenv(\"API_VERSION\");\n        assumeFalse(null == apiVersion, \"API version unknown, should be set in system environment\");\n\n        mockMvc.perform(get(\"/actuator/health/tailormap\"))\n                .andExpect(status().isOk())\n                .andExpect(\n                        content()\n                                .contentType(\n                                        MediaType.parseMediaType(\n                                                \"application/vnd.spring-boot.actuator.v3+json\")))\n                .andExpect(jsonPath(\"$.details.version\").value(projectVersion))\n                .andExpect(jsonPath(\"$.details.apiVersion\").value(apiVersion))\n                .andExpect(jsonPath(\"$.details.databaseversion\").value(databaseVersion));\n    }\n}", "item_id": 0, "repo": "B3Partners/tailormap-api", "file": "src/test/java/nl/b3p/tailormap/api/health/TailormapHealthIndicatorEnabledIntegrationTest.java", "last_update_at": "2022-03-31T04:32:20+00:00", "question_id": "2e09fec0ce4c0e909a45949f158d511c15647c0c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SpringBootTest(\n        classes = {\n            HSQLDBTestProfileJPAConfiguration.class,\n            TailormapHealthIndicator.class,\n            VersionController.class\n        })\n@AutoConfigureMockMvc\n@EnableAutoConfiguration\n@TestPropertySource(properties = {\"management.health.tailormap.enabled=true\"})\n@ActiveProfiles(\"test\")\n@AutoConfigureMetrics\nclass TailormapHealthIndicatorEnabledIntegrationTest {\n    @Autowired private MockMvc mockMvc;\n    @SuppressWarnings(\"PMD.JUnitTestsShouldIncludeAssert\")\n    @Test\n    void when_enabled_health_should_have_status_and_response_data() throws Exception {\n        String projectVersion = System.getProperty(\"project.version\");\n        assumeFalse(\n                null == projectVersion,\n                \"Project version unknown, should be set as system property\");\n        String databaseVersion = System.getenv(\"DATABASE_VERSION\");\n        assumeFalse(\n                null == databaseVersion,\n                \"Database version unknown, should be set in system environment\");\n        String apiVersion = System.getenv(\"API_VERSION\");\n        assumeFalse(null == apiVersion, \"API version unknown, should be set in system environment\");\n        mockMvc.perform(get(\"/actuator/health/tailormap\"))\n                .andExpect(status().isOk())\n                .andExpect(\n                        content()\n                                .contentType(\n                                        MediaType.parseMediaType(\n                                                \"application/vnd.spring-boot.actuator.v3+json\")))\n                .andExpect(jsonPath(\"$.details.version\").value(projectVersion))\n                .andExpect(jsonPath(\"$.details.apiVersion\").value(apiVersion))\n                .andExpect(jsonPath(\"$.details.databaseversion\").value(databaseVersion));\n    }\n"]], "pred": {"ppl": 2.1651132106781006, "ppl_lower": 2.9267220497131348, "ppl/lowercase_ppl": -1.3901890771857062, "ppl/zlib": 0.0011546676403491666, "Min_5.0% Prob": 6.689535769549283, "Min_10.0% Prob": 5.126423304731196, "Min_20.0% Prob": 3.443485610864379, "Min_30.0% Prob": 2.5027605152942916, "Min_40.0% Prob": 1.9219968390481716, "Min_50.0% Prob": 1.541627950115104, "Min_60.0% Prob": 1.2875465785188354}}
{"hexsha": "13e11f1140617faf33692a297bbf2caf0f5080d1", "ext": "java", "lang": "Java", "content": "public class NamedEntity {\n\n\t/**\n\t * Type of Named Entity\n\t */\n\tpublic enum Type {\n\t\tOrganisation,\n\t\tPerson,\n\t\tLocation\n\t}\n\n\t/**\n\t * Type of Named Entity\n\t */\n\tpublic Type type;\n\t/**\n\t * Unique root name of entity\n\t */\n\tpublic String rootName;\n\t/**\n\t * The string that resulted in a match\n\t */\n\tpublic String stringMatched;\n\t/**\n\t * Start token of the match\n\t */\n\tpublic int startToken;\n\t/**\n\t * Stop token of the match\n\t */\n\tpublic int stopToken;\n\t/**\n\t * Start char of the match\n\t */\n\tpublic int startChar;\n\t/**\n\t * Stop char of the match\n\t */\n\tpublic int stopChar;\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"NamedEntity [type=\" + type + \", rootName=\" + rootName\n\t\t\t\t+ \", startToken=\" + startToken + \", stopToken=\" + stopToken\n\t\t\t\t+ \"]\";\n\t}\n\n\tpublic NamedEntity() {\n\n\t}\n\n\tpublic NamedEntity(String rootName, Type type) {\n\t\tthis.rootName = rootName;\n\t\tthis.type = type;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result\n\t\t\t\t+ ((rootName == null) ? 0 : rootName.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tfinal NamedEntity other = (NamedEntity) obj;\n\t\tif (rootName == null) {\n\t\t\tif (other.rootName != null)\n\t\t\t\treturn false;\n\t\t} else if (!rootName.equals(other.rootName))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n}", "item_id": 0, "repo": "Celebrate-future/openimaj", "file": "text/nlp/src/main/java/org/openimaj/text/nlp/namedentity/NamedEntity.java", "last_update_at": "2022-03-31T08:21:10+00:00", "question_id": "13e11f1140617faf33692a297bbf2caf0f5080d1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NamedEntity {\n\t/**\n\t * Type of Named Entity\n\t */\n\tpublic enum Type {\n\t\tOrganisation,\n\t\tPerson,\n\t\tLocation\n\t}\n\t/**\n\t * Type of Named Entity\n\t */\n\tpublic Type type;\n\t/**\n\t * Unique root name of entity\n\t */\n\tpublic String rootName;\n\t/**\n\t * The string that resulted in a match\n\t */\n\tpublic String stringMatched;\n\t/**\n\t * Start token of the match\n\t */\n\tpublic int startToken;\n\t/**\n\t * Stop token of the match\n\t */\n\tpublic int stopToken;\n\t/**\n\t * Start char of the match\n\t */\n\tpublic int startChar;\n\t/**\n\t * Stop char of the match\n\t */\n\tpublic int stopChar;\n\t@Override\n\tpublic String toString() {\n\t\treturn \"NamedEntity [type=\" + type + \", rootName=\" + rootName\n\t\t\t\t+ \", startToken=\" + startToken + \", stopToken=\" + stopToken\n\t\t\t\t+ \"]\";\n\t}\n\tpublic NamedEntity() {\n\t}\n\tpublic NamedEntity(String rootName, Type type) {\n\t\tthis.rootName = rootName;\n\t\tthis.type = type;\n\t}\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result\n\t\t\t\t+ ((rootName == null) ? 0 : rootName.hashCode());\n\t\treturn result;\n\t}\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tfinal NamedEntity other = (NamedEntity) obj;\n\t\tif (rootName == null) {\n\t\t\tif (other.rootName != null)\n\t\t\t\treturn false;\n\t\t} else if (!rootName.equals(other.rootName))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n"]], "pred": {"ppl": 1.3883392810821533, "ppl_lower": 1.4937963485717773, "ppl/lowercase_ppl": -1.2231351659736835, "ppl/zlib": 0.000643349551047661, "Min_5.0% Prob": 4.294104154293354, "Min_10.0% Prob": 2.8553308304750695, "Min_20.0% Prob": 1.6115344130547247, "Min_30.0% Prob": 1.0950464423745871, "Min_40.0% Prob": 0.8208425637567416, "Min_50.0% Prob": 0.6559323835392559, "Min_60.0% Prob": 0.5477937708729936}}
{"hexsha": "ebda8f1ae9f5fc231c8017bce332c38520783f1c", "ext": "java", "lang": "Java", "content": "public static class SingletonFactory {\n        private Map<Vertex, String> typeNames = new HashMap<>();\n        private Map<String, IRType> typeObjs = new HashMap<>();\n        private Map<String, GenType> customTypes = new HashMap<>();\n        private GraphTraversalSource g;\n        public SingletonFactory(GraphTraversalSource g) {\n            this.g = g;\n        }\n\n        public GenType create(String name, int size, Expression origin){\n            if(customTypes.containsKey(name)){\n                GenType type = customTypes.get(name);\n                if(type.getSize() != size)\n                    throw new IllegalStateException(\"Type already stored, but it has a different size.\");\n\n                return type;\n            }\n            GenType type = new GenType(name, size, origin);\n            customTypes.put(name, type);\n            return type;\n        }\n        \n        public IRType create(Vertex v){\n            if(typeNames.containsKey(v))\n                return  typeObjs.get(typeNames.get(v));\n\n            String typeType = (String) g.V(v).values(Dom.Syn.V.CLASS).next();\n\n            switch(typeType){\n                case \"StructTypeDeclarationContext\": // intentional fallthrough\n                case \"HeaderTypeDeclarationContext\": \n                    return handleStructAndHeader(v, typeType);\n                case \"TypedefDeclarationContext\": \n                    return handleTypedef(v, typeType);\n                case \"BaseTypeContext\": \n                    return handleBaseType(v, typeType);\n                case \"ExternDeclarationContext\": \n                    return handleExternDataType(v, typeType);\n                default: \n                    throw new IllegalArgumentException(\n                        String.format(\"Type initialized with vertex %s of unknown class %s.\", v, typeType));\n            }\n        }\n\n        private IRType handleStructAndHeader(Vertex v, String typeType) {\n            String typeName = (String)\n                g.V(v).outE(Dom.SYMBOL)\n                    .has(Dom.Symbol.ROLE, Dom.Symbol.Role.DECLARES_NAME).inV()\n                    .values(\"value\")\n                    .next();\n\n            if(typeObjs.containsKey(typeName)){\n                IRType typeObj2 = typeObjs.get(typeName);\n                typeNames.put(v, typeName);\n                return typeObj2;\n            }\n            IRType typeObj = new Struct(g,v, typeType, this);\n            registerTypeObjToVertex(v, typeObj);\n            return typeObj;\n        }\n\n        private IRType handleTypedef(Vertex v, String typeType){\n            String typeName = (String)\n                g.V(v).outE(Dom.SYMBOL)\n                    .has(Dom.Symbol.ROLE, Dom.Symbol.Role.DECLARES_NAME)\n                    .inV()\n                    .values(\"value\")\n                    .next();\n\n            if(typeObjs.containsKey(typeName)){\n                IRType typeObj2 = typeObjs.get(typeName);\n                typeNames.put(v, typeName);\n                return typeObj2;\n            }\n\n            IRType typeObj = new TypeSynonym(g, v, typeType, this);\n            registerTypeObjToVertex(v, typeObj);\n            return typeObj;\n\n        }\n\n        // note: this is the same as handleStructAndHeader except for the initialization\n        private IRType handleExternDataType(Vertex v, String typeType) {\n            String typeName = (String)\n                g.V(v).outE(Dom.SYMBOL)\n                    .has(Dom.Symbol.ROLE, Dom.Symbol.Role.DECLARES_NAME)\n                    .inV()\n                    .values(\"value\")\n                    .next();\n\n            if(typeObjs.containsKey(typeName)){\n                IRType typeObj2 = typeObjs.get(typeName);\n                typeNames.put(v, typeName);\n                return typeObj2;\n            }\n\n            IRType typeObj = new ExternDataType(g, v, typeType);\n            registerTypeObjToVertex(v, typeObj);\n            return typeObj;\n\n        }\n\n        private IRType handleBaseType(Vertex v, String typeType){\n            List<Object> subterms = \n                g.V(v).outE(Dom.SYN)\n                      .order().by(Dom.Syn.E.ORD, Order.asc)\n                      .inV()\n                      .values(\"value\").toList();\n\n            String term = subterms.stream().map(o -> (String) o).collect(Collectors.joining(\"\"));\n            if(typeObjs.containsKey(term)){\n                IRType typeObj2 = typeObjs.get(term);\n                typeNames.put(v, term);\n                return typeObj2;\n            }\n\n            IRType typeObj = new BaseType(g,v, typeType);\n            registerTypeObjToVertex(v, typeObj);\n            return typeObj;\n        }\n\n        private void registerTypeObjToVertex(Vertex v, IRType typeObj) {\n            typeNames.put(v, typeObj.getName());\n            \n            if(typeObjs.containsKey(typeObj.getName()))\n                return;\n\n            typeObjs.put(typeObj.getName(), typeObj);\n        }\n    }", "item_id": 0, "repo": "P4ELTE/P4Query", "file": "experts-smc/src/main/java/p4query/applications/smc/hir/typing/IRType.java", "last_update_at": "2022-02-25T17:21:28+00:00", "question_id": "ebda8f1ae9f5fc231c8017bce332c38520783f1c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public static class SingletonFactory {\n        private Map<Vertex, String> typeNames = new HashMap<>();\n        private Map<String, IRType> typeObjs = new HashMap<>();\n        private Map<String, GenType> customTypes = new HashMap<>();\n        private GraphTraversalSource g;\n        public SingletonFactory(GraphTraversalSource g) {\n            this.g = g;\n        }\n        public GenType create(String name, int size, Expression origin){\n            if(customTypes.containsKey(name)){\n                GenType type = customTypes.get(name);\n                if(type.getSize() != size)\n                    throw new IllegalStateException(\"Type already stored, but it has a different size.\");\n                return type;\n            }\n            GenType type = new GenType(name, size, origin);\n            customTypes.put(name, type);\n            return type;\n        }\n        public IRType create(Vertex v){\n            if(typeNames.containsKey(v))\n                return  typeObjs.get(typeNames.get(v));\n            String typeType = (String) g.V(v).values(Dom.Syn.V.CLASS).next();\n            switch(typeType){\n                case \"StructTypeDeclarationContext\": // intentional fallthrough\n                case \"HeaderTypeDeclarationContext\": \n                    return handleStructAndHeader(v, typeType);\n                case \"TypedefDeclarationContext\": \n                    return handleTypedef(v, typeType);\n                case \"BaseTypeContext\": \n                    return handleBaseType(v, typeType);\n                case \"ExternDeclarationContext\": \n                    return handleExternDataType(v, typeType);\n                default: \n                    throw new IllegalArgumentException(\n                        String.format(\"Type initialized with vertex %s of unknown class %s.\", v, typeType));\n            }\n        }\n        private IRType handleStructAndHeader(Vertex v, String typeType) {\n            String typeName = (String)\n                g.V(v).outE(Dom.SYMBOL)\n                    .has(Dom.Symbol.ROLE, Dom.Symbol.Role.DECLARES_NAME).inV()\n                    .values(\"value\")\n                    .next();\n            if(typeObjs.containsKey(typeName)){\n                IRType typeObj2 = typeObjs.get(typeName);\n                typeNames.put(v, typeName);\n                return typeObj2;\n            }\n            IRType typeObj = new Struct(g,v, typeType, this);\n            registerTypeObjToVertex(v, typeObj);\n            return typeObj;\n        }\n        private IRType handleTypedef(Vertex v, String typeType){\n            String typeName = (String)\n                g.V(v).outE(Dom.SYMBOL)\n                    .has(Dom.Symbol.ROLE, Dom.Symbol.Role.DECLARES_NAME)\n                    .inV()\n                    .values(\"value\")\n                    .next();\n            if(typeObjs.containsKey(typeName)){\n                IRType typeObj2 = typeObjs.get(typeName);\n                typeNames.put(v, typeName);\n                return typeObj2;\n            }\n            IRType typeObj = new TypeSynonym(g, v, typeType, this);\n            registerTypeObjToVertex(v, typeObj);\n            return typeObj;\n        }\n        // note: this is the same as handleStructAndHeader except for the initialization\n        private IRType handleExternDataType(Vertex v, String typeType) {\n            String typeName = (String)\n                g.V(v).outE(Dom.SYMBOL)\n                    .has(Dom.Symbol.ROLE, Dom.Symbol.Role.DECLARES_NAME)\n                    .inV()\n                    .values(\"value\")\n                    .next();\n            if(typeObjs.containsKey(typeName)){\n                IRType typeObj2 = typeObjs.get(typeName);\n                typeNames.put(v, typeName);\n                return typeObj2;\n            }\n            IRType typeObj = new ExternDataType(g, v, typeType);\n            registerTypeObjToVertex(v, typeObj);\n            return typeObj;\n        }\n        private IRType handleBaseType(Vertex v, String typeType){\n            List<Object> subterms = \n                g.V(v).outE(Dom.SYN)\n                      .order().by(Dom.Syn.E.ORD, Order.asc)\n                      .inV()\n                      .values(\"value\").toList();\n            String term = subterms.stream().map(o -> (String) o).collect(Collectors.joining(\"\"));\n            if(typeObjs.containsKey(term)){\n                IRType typeObj2 = typeObjs.get(term);\n                typeNames.put(v, term);\n                return typeObj2;\n            }\n            IRType typeObj = new BaseType(g,v, typeType);\n            registerTypeObjToVertex(v, typeObj);\n            return typeObj;\n        }\n        private void registerTypeObjToVertex(Vertex v, IRType typeObj) {\n            typeNames.put(v, typeObj.getName());\n            if(typeObjs.containsKey(typeObj.getName()))\n                return;\n            typeObjs.put(typeObj.getName(), typeObj);\n        }\n"]], "pred": {"ppl": 1.9214720726013184, "ppl_lower": 2.112874746322632, "ppl/lowercase_ppl": -1.1453974648365075, "ppl/zlib": 0.0006069624505128341, "Min_5.0% Prob": 6.833069642384847, "Min_10.0% Prob": 4.828640396688499, "Min_20.0% Prob": 3.0140332947759068, "Min_30.0% Prob": 2.1324065288200096, "Min_40.0% Prob": 1.6201177204806532, "Min_50.0% Prob": 1.3035663675786582, "Min_60.0% Prob": 1.0887275908999205}}
{"hexsha": "26826cb79211c3de49ccd044750b79bf2b9162aa", "ext": "java", "lang": "Java", "content": "public class msg_hil_controls extends MAVLinkMessage {\n\n    public static final int MAVLINK_MSG_ID_HIL_CONTROLS = 91;\n    public static final int MAVLINK_MSG_LENGTH = 42;\n    private static final long serialVersionUID = MAVLINK_MSG_ID_HIL_CONTROLS;\n\n\n    /**\n     * Timestamp (microseconds since UNIX epoch or microseconds since system boot)\n     */\n    public long time_usec;\n\n    /**\n     * Control output -1 .. 1\n     */\n    public float roll_ailerons;\n\n    /**\n     * Control output -1 .. 1\n     */\n    public float pitch_elevator;\n\n    /**\n     * Control output -1 .. 1\n     */\n    public float yaw_rudder;\n\n    /**\n     * Throttle 0 .. 1\n     */\n    public float throttle;\n\n    /**\n     * Aux 1, -1 .. 1\n     */\n    public float aux1;\n\n    /**\n     * Aux 2, -1 .. 1\n     */\n    public float aux2;\n\n    /**\n     * Aux 3, -1 .. 1\n     */\n    public float aux3;\n\n    /**\n     * Aux 4, -1 .. 1\n     */\n    public float aux4;\n\n    /**\n     * System mode (MAV_MODE)\n     */\n    public short mode;\n\n    /**\n     * Navigation mode (MAV_NAV_MODE)\n     */\n    public short nav_mode;\n\n\n    /**\n     * Constructor for a new message, just initializes the msgid\n     */\n    public msg_hil_controls() {\n        msgid = MAVLINK_MSG_ID_HIL_CONTROLS;\n    }\n\n    /**\n     * Constructor for a new message, initializes the message with the payload\n     * from a mavlink packet\n     */\n    public msg_hil_controls(MAVLinkPacket mavLinkPacket) {\n        this.sysid = mavLinkPacket.sysid;\n        this.compid = mavLinkPacket.compid;\n        this.msgid = MAVLINK_MSG_ID_HIL_CONTROLS;\n        unpack(mavLinkPacket.payload);\n    }\n\n    /**\n     * Generates the payload for a mavlink message for a message of this type\n     *\n     * @return\n     */\n    public MAVLinkPacket pack() {\n        MAVLinkPacket packet = new MAVLinkPacket(MAVLINK_MSG_LENGTH);\n        packet.sysid = 255;\n        packet.compid = 190;\n        packet.msgid = MAVLINK_MSG_ID_HIL_CONTROLS;\n\n        packet.payload.putUnsignedLong(time_usec);\n\n        packet.payload.putFloat(roll_ailerons);\n\n        packet.payload.putFloat(pitch_elevator);\n\n        packet.payload.putFloat(yaw_rudder);\n\n        packet.payload.putFloat(throttle);\n\n        packet.payload.putFloat(aux1);\n\n        packet.payload.putFloat(aux2);\n\n        packet.payload.putFloat(aux3);\n\n        packet.payload.putFloat(aux4);\n\n        packet.payload.putUnsignedByte(mode);\n\n        packet.payload.putUnsignedByte(nav_mode);\n\n        return packet;\n    }\n\n    /**\n     * Decode a hil_controls message into this class fields\n     *\n     * @param payload The message to decode\n     */\n    public void unpack(MAVLinkPayload payload) {\n        payload.resetIndex();\n\n        this.time_usec = payload.getUnsignedLong();\n\n        this.roll_ailerons = payload.getFloat();\n\n        this.pitch_elevator = payload.getFloat();\n\n        this.yaw_rudder = payload.getFloat();\n\n        this.throttle = payload.getFloat();\n\n        this.aux1 = payload.getFloat();\n\n        this.aux2 = payload.getFloat();\n\n        this.aux3 = payload.getFloat();\n\n        this.aux4 = payload.getFloat();\n\n        this.mode = payload.getUnsignedByte();\n\n        this.nav_mode = payload.getUnsignedByte();\n\n    }\n\n    /**\n     * Returns a string with the MSG name and data\n     */\n    public String toString() {\n        return \"MAVLINK_MSG_ID_HIL_CONTROLS - sysid:\" + sysid + \" compid:\" + compid + \" time_usec:\" + time_usec + \" roll_ailerons:\" + roll_ailerons + \" pitch_elevator:\" + pitch_elevator + \" yaw_rudder:\" + yaw_rudder + \" throttle:\" + throttle + \" aux1:\" + aux1 + \" aux2:\" + aux2 + \" aux3:\" + aux3 + \" aux4:\" + aux4 + \" mode:\" + mode + \" nav_mode:\" + nav_mode + \"\";\n    }\n}", "item_id": 0, "repo": "pierotofy/rosettadrone", "file": "app/src/main/java/com/MAVLink/common/msg_hil_controls.java", "last_update_at": "2022-03-09T04:34:28+00:00", "question_id": "26826cb79211c3de49ccd044750b79bf2b9162aa_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class msg_hil_controls extends MAVLinkMessage {\n    public static final int MAVLINK_MSG_ID_HIL_CONTROLS = 91;\n    public static final int MAVLINK_MSG_LENGTH = 42;\n    private static final long serialVersionUID = MAVLINK_MSG_ID_HIL_CONTROLS;\n    /**\n     * Timestamp (microseconds since UNIX epoch or microseconds since system boot)\n     */\n    public long time_usec;\n    /**\n     * Control output -1 .. 1\n     */\n    public float roll_ailerons;\n    /**\n     * Control output -1 .. 1\n     */\n    public float pitch_elevator;\n    /**\n     * Control output -1 .. 1\n     */\n    public float yaw_rudder;\n    /**\n     * Throttle 0 .. 1\n     */\n    public float throttle;\n    /**\n     * Aux 1, -1 .. 1\n     */\n    public float aux1;\n    /**\n     * Aux 2, -1 .. 1\n     */\n    public float aux2;\n    /**\n     * Aux 3, -1 .. 1\n     */\n    public float aux3;\n    /**\n     * Aux 4, -1 .. 1\n     */\n    public float aux4;\n    /**\n     * System mode (MAV_MODE)\n     */\n    public short mode;\n    /**\n     * Navigation mode (MAV_NAV_MODE)\n     */\n    public short nav_mode;\n    /**\n     * Constructor for a new message, just initializes the msgid\n     */\n    public msg_hil_controls() {\n        msgid = MAVLINK_MSG_ID_HIL_CONTROLS;\n    }\n    /**\n     * Constructor for a new message, initializes the message with the payload\n     * from a mavlink packet\n     */\n    public msg_hil_controls(MAVLinkPacket mavLinkPacket) {\n        this.sysid = mavLinkPacket.sysid;\n        this.compid = mavLinkPacket.compid;\n        this.msgid = MAVLINK_MSG_ID_HIL_CONTROLS;\n        unpack(mavLinkPacket.payload);\n    }\n    /**\n     * Generates the payload for a mavlink message for a message of this type\n     *\n     * @return\n     */\n    public MAVLinkPacket pack() {\n        MAVLinkPacket packet = new MAVLinkPacket(MAVLINK_MSG_LENGTH);\n        packet.sysid = 255;\n        packet.compid = 190;\n        packet.msgid = MAVLINK_MSG_ID_HIL_CONTROLS;\n        packet.payload.putUnsignedLong(time_usec);\n        packet.payload.putFloat(roll_ailerons);\n        packet.payload.putFloat(pitch_elevator);\n        packet.payload.putFloat(yaw_rudder);\n        packet.payload.putFloat(throttle);\n        packet.payload.putFloat(aux1);\n        packet.payload.putFloat(aux2);\n        packet.payload.putFloat(aux3);\n        packet.payload.putFloat(aux4);\n        packet.payload.putUnsignedByte(mode);\n        packet.payload.putUnsignedByte(nav_mode);\n        return packet;\n    }\n    /**\n     * Decode a hil_controls message into this class fields\n     *\n     * @param payload The message to decode\n     */\n    public void unpack(MAVLinkPayload payload) {\n        payload.resetIndex();\n        this.time_usec = payload.getUnsignedLong();\n        this.roll_ailerons = payload.getFloat();\n        this.pitch_elevator = payload.getFloat();\n        this.yaw_rudder = payload.getFloat();\n        this.throttle = payload.getFloat();\n        this.aux1 = payload.getFloat();\n        this.aux2 = payload.getFloat();\n        this.aux3 = payload.getFloat();\n        this.aux4 = payload.getFloat();\n        this.mode = payload.getUnsignedByte();\n        this.nav_mode = payload.getUnsignedByte();\n    }\n    /**\n     * Returns a string with the MSG name and data\n     */\n    public String toString() {\n        return \"MAVLINK_MSG_ID_HIL_CONTROLS - sysid:\" + sysid + \" compid:\" + compid + \" time_usec:\" + time_usec + \" roll_ailerons:\" + roll_ailerons + \" pitch_elevator:\" + pitch_elevator + \" yaw_rudder:\" + yaw_rudder + \" throttle:\" + throttle + \" aux1:\" + aux1 + \" aux2:\" + aux2 + \" aux3:\" + aux3 + \" aux4:\" + aux4 + \" mode:\" + mode + \" nav_mode:\" + nav_mode + \"\";\n    }\n"]], "pred": {"ppl": 1.170823335647583, "ppl_lower": 1.361263632774353, "ppl/lowercase_ppl": -1.9556075842232974, "ppl/zlib": 0.00016583302524354773, "Min_5.0% Prob": 2.9344465744261647, "Min_10.0% Prob": 1.5679007828345193, "Min_20.0% Prob": 0.7897798674222192, "Min_30.0% Prob": 0.5270360517446819, "Min_40.0% Prob": 0.3944143027888425, "Min_50.0% Prob": 0.3157112473002896, "Min_60.0% Prob": 0.2631850825074025}}
{"hexsha": "6ab2417f171d4242db1b03f6d94cfa2645c9dac2", "ext": "java", "lang": "Java", "content": "public class SimilarityDisambiguator extends Disambiguator {\n\n    public static final int DEFAULT_NUM_CANDIDATES = 5;\n    protected final PhraseAnalyzer phraseAnalyzer;\n    private int numCandidates = DEFAULT_NUM_CANDIDATES;\n    private Language language;\n\n    /**\n     * Algorithms for disambiguating similar phrases\n     */\n    public static enum Criteria {\n        SUM,         // select senses with highest sum of popularity + similarity\n        PRODUCT,     // select senses with highest sum of popularity * similarity\n        POPULARITY,  // select most popular senses\n        SIMILARITY   // select most similar senses\n    }\n\n    // Method for disambiguating similar phrases\n    private Criteria criteria = Criteria.SUM;\n\n    private final SRMetric metric;\n\n    public SimilarityDisambiguator(PhraseAnalyzer phraseAnalyzer, SRMetric metric) {\n        this.phraseAnalyzer = phraseAnalyzer;\n        this.metric = metric;\n        this.language = metric.getLanguage();\n    }\n\n    @Override\n    public List<LinkedHashMap<LocalId, Float>> disambiguate(List<LocalString> phrases, Set<LocalString> context) throws DaoException {\n        List<LinkedHashMap<LocalId, Float>> results = new ArrayList<LinkedHashMap<LocalId, Float>>();\n\n        List<LocalString> allPhrases = new ArrayList<LocalString>(\n                (context == null) ? phrases : CollectionUtils.union(phrases, context));\n\n        // Step 0: calculate most frequent candidate senses for each phrase\n        Map<LocalString, LinkedHashMap<LocalId, Float>> candidates = Maps.newHashMap();\n        for (LocalString s : allPhrases) {\n            candidates.put(s, phraseAnalyzer.resolve(s.getLanguage(), s.getString(), numCandidates));\n        }\n\n        // Skip using the sr metric at all!\n        if (criteria == Criteria.POPULARITY) {\n            for (LocalString phrase : phrases) {\n                LinkedHashMap<LocalId, Float> m = new LinkedHashMap<LocalId, Float>();\n                for (LocalId li : candidates.get(phrase).keySet()) {\n                    m.put(li, candidates.get(phrase).get(li));\n                }\n                results.add(m);\n            }\n            return results;\n        }\n\n        // Step 2: calculate the sum of cosimilarities for each page\n        Map<LocalId, Float> pageSims = getCosimilaritySums(candidates);\n\n        // Step 3: multiply background probability by sim sums, choose best product\n        List<LinkedHashMap<LocalId, Float>> result = new ArrayList<LinkedHashMap<LocalId, Float>>();\n        for (LocalString ls : phrases) {\n            Map<LocalId, Float> phraseCands = candidates.get(ls);\n            LinkedHashMap<LocalId, Float> pageResult = selectFinalPhraseSenses(pageSims, phraseCands);\n            result.add(pageResult);\n        }\n        return result;\n    }\n\n    private LinkedHashMap<LocalId, Float> selectFinalPhraseSenses(Map<LocalId, Float> pageSims, Map<LocalId, Float> phrasePops) {\n        if (phrasePops == null || phrasePops.isEmpty()) {\n            return null;\n        }\n        double sum = 0.0;\n        for (LocalId lp : phrasePops.keySet()) {\n            float pop = phrasePops.get(lp);\n            float sim =  pageSims.get(lp);\n\n            float score;\n            switch (criteria) {\n                case POPULARITY:\n                    score = pop;\n                    break;\n                case SIMILARITY:\n                    score = sim;\n                    break;\n                case SUM:\n                    score = pop + sim;\n                    break;\n                case PRODUCT:\n                    score = pop * sim;\n                    break;\n                default:\n                    throw new IllegalStateException();\n            }\n\n            phrasePops.put(lp, score);\n            sum += score;\n        }\n        LinkedHashMap<LocalId, Float> pageResult = new LinkedHashMap<LocalId, Float>();\n        for (LocalId key : WpCollectionUtils.sortMapKeys(phrasePops, true)) {\n            pageResult.put(key, (float)(phrasePops.get(key) / sum));\n        }\n        return pageResult;\n    }\n\n    /**\n     * Return the sum of cosimilarity scores for all unique pages among the candidates.\n     * @param candidates\n     * @return\n     * @throws DaoException\n     */\n    private Map<LocalId, Float> getCosimilaritySums(Map<LocalString, LinkedHashMap<LocalId, Float>> candidates) throws DaoException {\n    \t\n        // Step 1: compute the page cosimilarity matrix\n        Set<LocalId> uniques = new HashSet<LocalId>();\n        for (LinkedHashMap<LocalId, Float> prob : candidates.values()) {\n            uniques.addAll(prob.keySet());\n        }\n        List<LocalId> pages = new ArrayList<LocalId>(uniques);\n        double[][] cosim;\n\n        if (pages.isEmpty()){\n            cosim = new double[0][0];\n        } else {\n            if (!pages.get(0).getLanguage().equals(language)) {\n                throw new DaoException(\"Expected language \" + language + \", found \" +  pages.get(0).getLanguage());\n            }\n            int[] pageIds = new int[pages.size()];\n            for (int i=0; i<pages.size(); i++){\n                pageIds[i] = pages.get(i).getId();\n            }\n            cosim = metric.cosimilarity(pageIds);\n        }\n\n        // Step 2: calculate the sum of cosimilarities for each page\n        Map<LocalId, Float> pageSims = new HashMap<LocalId, Float>();\n        for (int i = 0; i < pages.size(); i++) {\n            double sum = 0.0;\n            for (int j = 0; j < pages.size(); j++) {\n                if (i != j && WbMathUtils.isReal(cosim[i][j])) {\n                    sum += Math.max(0, cosim[i][j]);    // Hack: no negative numbers\n                }\n            }\n            // add 0.0001 to give every candidate a tiny chance and avoid divide by zero errors when there are no good options\n            pageSims.put(pages.get(i), (float)(sum + 0.0001));\n        }\n        return pageSims;\n    }\n\n    public Criteria getCriteria() {\n        return criteria;\n    }\n\n    public void setCriteria(Criteria criteria) {\n        this.criteria = criteria;\n    }\n\n    public int getNumCandidates() {\n        return numCandidates;\n    }\n\n    public void setNumCandidates(int numCandidates) {\n        this.numCandidates = numCandidates;\n    }\n\n    public static class Provider extends org.wikibrain.conf.Provider<Disambiguator>{\n        public Provider(Configurator configurator, Configuration config) throws ConfigurationException {\n            super(configurator,config);\n        }\n\n        @Override\n        public Class getType(){\n            return Disambiguator.class;\n        }\n\n        @Override\n        public String getPath(){\n            return \"sr.disambig\";\n        }\n\n        @Override\n        public Disambiguator get(String name, Config config, Map<String, String> runtimeParams) throws ConfigurationException{\n            if (!config.getString(\"type\").equals(\"similarity\")){\n                return null;\n            }\n\n            if (runtimeParams == null || !runtimeParams.containsKey(\"language\")){\n                throw new IllegalArgumentException(\"SimpleMilneWitten requires 'language' runtime parameter.\");\n            }\n            Language lang = Language.getByLangCode(runtimeParams.get(\"language\"));\n\n            PhraseAnalyzer pa = getConfigurator().get(PhraseAnalyzer.class, config.getString(\"phraseAnalyzer\"));\n\n            // Create override config for sr metric and load it.\n            String srName = config.getString(\"metric\");\n            Config newConfig = getConfig().get().getConfig(\"sr.metric.local.\" + srName)\n                    .withValue(\"disambiguator\", ConfigValueFactory.fromAnyRef(\"topResult\"));\n            Map<String, String> srRuntimeParams = new HashMap<String, String>();\n            srRuntimeParams.put(\"language\", lang.getLangCode());\n            SRMetric sr = getConfigurator().construct(SRMetric.class, srName, newConfig, srRuntimeParams);\n\n            SimilarityDisambiguator dab = new SimilarityDisambiguator(pa, sr);\n            if (config.hasPath(\"criteria\")) {\n                dab.setCriteria(Criteria.valueOf(config.getString(\"criteria\").toUpperCase()));\n            }\n            return dab;\n        }\n    }\n}", "item_id": 0, "repo": "shilad/wikibrain", "file": "wikibrain-sr/src/main/java/org/wikibrain/sr/disambig/SimilarityDisambiguator.java", "last_update_at": "2022-03-01T01:23:56+00:00", "question_id": "6ab2417f171d4242db1b03f6d94cfa2645c9dac2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SimilarityDisambiguator extends Disambiguator {\n    public static final int DEFAULT_NUM_CANDIDATES = 5;\n    protected final PhraseAnalyzer phraseAnalyzer;\n    private int numCandidates = DEFAULT_NUM_CANDIDATES;\n    private Language language;\n    /**\n     * Algorithms for disambiguating similar phrases\n     */\n    public static enum Criteria {\n        SUM,         // select senses with highest sum of popularity + similarity\n        PRODUCT,     // select senses with highest sum of popularity * similarity\n        POPULARITY,  // select most popular senses\n        SIMILARITY   // select most similar senses\n    }\n    // Method for disambiguating similar phrases\n    private Criteria criteria = Criteria.SUM;\n    private final SRMetric metric;\n    public SimilarityDisambiguator(PhraseAnalyzer phraseAnalyzer, SRMetric metric) {\n        this.phraseAnalyzer = phraseAnalyzer;\n        this.metric = metric;\n        this.language = metric.getLanguage();\n    }\n    @Override\n    public List<LinkedHashMap<LocalId, Float>> disambiguate(List<LocalString> phrases, Set<LocalString> context) throws DaoException {\n        List<LinkedHashMap<LocalId, Float>> results = new ArrayList<LinkedHashMap<LocalId, Float>>();\n        List<LocalString> allPhrases = new ArrayList<LocalString>(\n                (context == null) ? phrases : CollectionUtils.union(phrases, context));\n        // Step 0: calculate most frequent candidate senses for each phrase\n        Map<LocalString, LinkedHashMap<LocalId, Float>> candidates = Maps.newHashMap();\n        for (LocalString s : allPhrases) {\n            candidates.put(s, phraseAnalyzer.resolve(s.getLanguage(), s.getString(), numCandidates));\n        }\n        // Skip using the sr metric at all!\n        if (criteria == Criteria.POPULARITY) {\n            for (LocalString phrase : phrases) {\n                LinkedHashMap<LocalId, Float> m = new LinkedHashMap<LocalId, Float>();\n                for (LocalId li : candidates.get(phrase).keySet()) {\n                    m.put(li, candidates.get(phrase).get(li));\n                }\n                results.add(m);\n            }\n            return results;\n        }\n        // Step 2: calculate the sum of cosimilarities for each page\n        Map<LocalId, Float> pageSims = getCosimilaritySums(candidates);\n        // Step 3: multiply background probability by sim sums, choose best product\n        List<LinkedHashMap<LocalId, Float>> result = new ArrayList<LinkedHashMap<LocalId, Float>>();\n        for (LocalString ls : phrases) {\n            Map<LocalId, Float> phraseCands = candidates.get(ls);\n            LinkedHashMap<LocalId, Float> pageResult = selectFinalPhraseSenses(pageSims, phraseCands);\n            result.add(pageResult);\n        }\n        return result;\n    }\n    private LinkedHashMap<LocalId, Float> selectFinalPhraseSenses(Map<LocalId, Float> pageSims, Map<LocalId, Float> phrasePops) {\n        if (phrasePops == null || phrasePops.isEmpty()) {\n            return null;\n        }\n        double sum = 0.0;\n        for (LocalId lp : phrasePops.keySet()) {\n            float pop = phrasePops.get(lp);\n            float sim =  pageSims.get(lp);\n            float score;\n            switch (criteria) {\n                case POPULARITY:\n                    score = pop;\n                    break;\n                case SIMILARITY:\n                    score = sim;\n                    break;\n                case SUM:\n                    score = pop + sim;\n                    break;\n                case PRODUCT:\n                    score = pop * sim;\n                    break;\n                default:\n                    throw new IllegalStateException();\n            }\n            phrasePops.put(lp, score);\n            sum += score;\n        }\n        LinkedHashMap<LocalId, Float> pageResult = new LinkedHashMap<LocalId, Float>();\n        for (LocalId key : WpCollectionUtils.sortMapKeys(phrasePops, true)) {\n            pageResult.put(key, (float)(phrasePops.get(key) / sum));\n        }\n        return pageResult;\n    }\n    /**\n     * Return the sum of cosimilarity scores for all unique pages among the candidates.\n     * @param candidates\n     * @return\n     * @throws DaoException\n     */\n    private Map<LocalId, Float> getCosimilaritySums(Map<LocalString, LinkedHashMap<LocalId, Float>> candidates) throws DaoException {\n    \t\n        // Step 1: compute the page cosimilarity matrix\n        Set<LocalId> uniques = new HashSet<LocalId>();\n        for (LinkedHashMap<LocalId, Float> prob : candidates.values()) {\n            uniques.addAll(prob.keySet());\n        }\n        List<LocalId> pages = new ArrayList<LocalId>(uniques);\n        double[][] cosim;\n        if (pages.isEmpty()){\n            cosim = new double[0][0];\n        } else {\n            if (!pages.get(0).getLanguage().equals(language)) {\n                throw new DaoException(\"Expected language \" + language + \", found \" +  pages.get(0).getLanguage());\n            }\n            int[] pageIds = new int[pages.size()];\n            for (int i=0; i<pages.size(); i++){\n                pageIds[i] = pages.get(i).getId();\n            }\n            cosim = metric.cosimilarity(pageIds);\n        }\n        // Step 2: calculate the sum of cosimilarities for each page\n        Map<LocalId, Float> pageSims = new HashMap<LocalId, Float>();\n        for (int i = 0; i < pages.size(); i++) {\n            double sum = 0.0;\n            for (int j = 0; j < pages.size(); j++) {\n                if (i != j && WbMathUtils.isReal(cosim[i][j])) {\n                    sum += Math.max(0, cosim[i][j]);    // Hack: no negative numbers\n                }\n            }\n            // add 0.0001 to give every candidate a tiny chance and avoid divide by zero errors when there are no good options\n            pageSims.put(pages.get(i), (float)(sum + 0.0001));\n        }\n        return pageSims;\n    }\n    public Criteria getCriteria() {\n        return criteria;\n    }\n    public void setCriteria(Criteria criteria) {\n        this.criteria = criteria;\n    }\n    public int getNumCandidates() {\n        return numCandidates;\n    }\n    public void setNumCandidates(int numCandidates) {\n        this.numCandidates = numCandidates;\n    }\n    public static class Provider extends org.wikibrain.conf.Provider<Disambiguator>{\n        public Provider(Configurator configurator, Configuration config) throws ConfigurationException {\n            super(configurator,config);\n        }\n        @Override\n        public Class getType(){\n            return Disambiguator.class;\n        }\n        @Override\n        public String getPath(){\n            return \"sr.disambig\";\n        }\n        @Override\n        public Disambiguator get(String name, Config config, Map<String, String> runtimeParams) throws ConfigurationException{\n            if (!config.getString(\"type\").equals(\"similarity\")){\n                return null;\n            }\n            if (runtimeParams == null || !runtimeParams.containsKey(\"language\")){\n                throw new IllegalArgumentException(\"SimpleMilneWitten requires 'language' runtime parameter.\");\n            }\n            Language lang = Language.getByLangCode(runtimeParams.get(\"language\"));\n            PhraseAnalyzer pa = getConfigurator().get(PhraseAnalyzer.class, config.getString(\"phraseAnalyzer\"));\n            // Create override config for sr metric and load it.\n            String srName = config.getString(\"metric\");\n            Config newConfig = getConfig().get().getConfig(\"sr.metric.local.\" + srName)\n                    .withValue(\"disambiguator\", ConfigValueFactory.fromAnyRef(\"topResult\"));\n            Map<String, String> srRuntimeParams = new HashMap<String, String>();\n            srRuntimeParams.put(\"language\", lang.getLangCode());\n            SRMetric sr = getConfigurator().construct(SRMetric.class, srName, newConfig, srRuntimeParams);\n            SimilarityDisambiguator dab = new SimilarityDisambiguator(pa, sr);\n            if (config.hasPath(\"criteria\")) {\n                dab.setCriteria(Criteria.valueOf(config.getString(\"criteria\").toUpperCase()));\n            }\n            return dab;\n        }\n    }\n"]], "pred": {"ppl": 2.103893756866455, "ppl_lower": 2.4459404945373535, "ppl/lowercase_ppl": -1.2025302201435057, "ppl/zlib": 0.0003233868686150448, "Min_5.0% Prob": 7.1962920263701795, "Min_10.0% Prob": 5.346281799615598, "Min_20.0% Prob": 3.420316407201337, "Min_30.0% Prob": 2.4259490744740355, "Min_40.0% Prob": 1.8461669027659595, "Min_50.0% Prob": 1.4852404675779978, "Min_60.0% Prob": 1.2403324761953611}}
{"hexsha": "2371fd7a216767cecabc030d1c52e9bf8c0ee50a", "ext": "java", "lang": "Java", "content": "public class ModStatistics\n{\n\tpublic static final Identifier INTERACT_WITH_ALLOY_KILN = Alloygery.identifier(\"interact_with_alloy_kiln\");\n\tpublic static final Identifier INTERACT_WITH_BLAST_ALLOY_KILN = Alloygery.identifier(\"interact_with_blast_alloy_kiln\");\n\n\tpublic static void register()\n\t{\n\t\tRegistry.register(Registry.CUSTOM_STAT, \"interact_with_alloy_kiln\", INTERACT_WITH_ALLOY_KILN);\n\t\tRegistry.register(Registry.CUSTOM_STAT, \"interact_with_blast_alloy_kiln\", INTERACT_WITH_BLAST_ALLOY_KILN);\n\n\t\tStats.CUSTOM.getOrCreateStat(INTERACT_WITH_ALLOY_KILN, StatFormatter.DEFAULT);\n\t\tStats.CUSTOM.getOrCreateStat(INTERACT_WITH_BLAST_ALLOY_KILN, StatFormatter.DEFAULT);\n\t}\n}", "item_id": 0, "repo": "brotazoa/Alloygery", "file": "src/main/java/amorphia/alloygery/registry/ModStatistics.java", "last_update_at": "2022-03-29T04:35:47+00:00", "question_id": "2371fd7a216767cecabc030d1c52e9bf8c0ee50a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ModStatistics\n{\n\tpublic static final Identifier INTERACT_WITH_ALLOY_KILN = Alloygery.identifier(\"interact_with_alloy_kiln\");\n\tpublic static final Identifier INTERACT_WITH_BLAST_ALLOY_KILN = Alloygery.identifier(\"interact_with_blast_alloy_kiln\");\n\tpublic static void register()\n\t{\n\t\tRegistry.register(Registry.CUSTOM_STAT, \"interact_with_alloy_kiln\", INTERACT_WITH_ALLOY_KILN);\n\t\tRegistry.register(Registry.CUSTOM_STAT, \"interact_with_blast_alloy_kiln\", INTERACT_WITH_BLAST_ALLOY_KILN);\n\t\tStats.CUSTOM.getOrCreateStat(INTERACT_WITH_ALLOY_KILN, StatFormatter.DEFAULT);\n\t\tStats.CUSTOM.getOrCreateStat(INTERACT_WITH_BLAST_ALLOY_KILN, StatFormatter.DEFAULT);\n\t}\n"]], "pred": {"ppl": 1.6181626319885254, "ppl_lower": 2.544813394546509, "ppl/lowercase_ppl": -1.940731675384093, "ppl/zlib": 0.0019174953298528841, "Min_5.0% Prob": 6.420874650661762, "Min_10.0% Prob": 4.314644015752352, "Min_20.0% Prob": 2.393431820678261, "Min_30.0% Prob": 1.6070164534496143, "Min_40.0% Prob": 1.2045004062667908, "Min_50.0% Prob": 0.9623577609543563, "Min_60.0% Prob": 0.8061033218524244}}
{"hexsha": "f76378487ccb1b66b32fe495cdb9ba4a9289af0a", "ext": "java", "lang": "Java", "content": "public class TestVectorBetweenIn {\n\n  @Test\n  public void testTinyInt() throws Exception {\n    Random random = new Random(5371);\n\n    doBetweenIn(random, \"tinyint\");\n  }\n\n  @Test\n  public void testSmallInt() throws Exception {\n    Random random = new Random(2772);\n\n    doBetweenIn(random, \"smallint\");\n  }\n\n  @Test\n  public void testInt() throws Exception {\n    Random random = new Random(12882);\n\n    doBetweenIn(random, \"int\");\n  }\n\n  @Test\n  public void testBigInt() throws Exception {\n    Random random = new Random(12882);\n\n    doBetweenIn(random, \"bigint\");\n  }\n\n  @Test\n  public void testString() throws Exception {\n    Random random = new Random(12882);\n\n    doBetweenIn(random, \"string\");\n  }\n\n  @Test\n  public void testTimestamp() throws Exception {\n    Random random = new Random(12882);\n\n    doBetweenIn(random, \"timestamp\");\n  }\n\n  @Test\n  public void testDate() throws Exception {\n    Random random = new Random(12882);\n\n    doBetweenIn(random, \"date\");\n  }\n\n  @Test\n  public void testFloat() throws Exception {\n    Random random = new Random(7322);\n\n    doBetweenIn(random, \"float\");\n  }\n\n  @Test\n  public void testDouble() throws Exception {\n    Random random = new Random(12882);\n\n    doBetweenIn(random, \"double\");\n  }\n\n  @Test\n  public void testChar() throws Exception {\n    Random random = new Random(12882);\n\n    doBetweenIn(random, \"char(10)\");\n  }\n\n  @Test\n  public void testVarchar() throws Exception {\n    Random random = new Random(12882);\n\n    doBetweenIn(random, \"varchar(15)\");\n  }\n\n  @Test\n  public void testDecimal() throws Exception {\n    Random random = new Random(9300);\n\n    doDecimalTests(random, /* tryDecimal64 */ false);\n  }\n\n  @Test\n  public void testDecimal64() throws Exception {\n    Random random = new Random(9300);\n\n    doDecimalTests(random, /* tryDecimal64 */ true);\n  }\n\n  @Test\n  public void testStruct() throws Exception {\n    Random random = new Random(9300);\n\n    doStructTests(random);\n  }\n\n  public enum BetweenInTestMode {\n    ROW_MODE,\n    ADAPTOR,\n    VECTOR_EXPRESSION;\n\n    static final int count = values().length;\n  }\n\n  public enum BetweenInVariation {\n    FILTER_BETWEEN,\n    FILTER_NOT_BETWEEN,\n    PROJECTION_BETWEEN,\n    PROJECTION_NOT_BETWEEN,\n    FILTER_IN,\n    PROJECTION_IN;\n\n    static final int count = values().length;\n\n    final boolean isFilter;\n    BetweenInVariation() {\n      isFilter = name().startsWith(\"FILTER\");\n    }\n  }\n\n  private static TypeInfo[] decimalTypeInfos = new TypeInfo[] {\n    new DecimalTypeInfo(38, 18),\n    new DecimalTypeInfo(25, 2),\n    new DecimalTypeInfo(19, 4),\n    new DecimalTypeInfo(18, 10),\n    new DecimalTypeInfo(17, 3),\n    new DecimalTypeInfo(12, 2),\n    new DecimalTypeInfo(7, 1)\n  };\n\n  private void doDecimalTests(Random random, boolean tryDecimal64)\n      throws Exception {\n    for (TypeInfo typeInfo : decimalTypeInfos) {\n      doBetweenIn(\n          random, typeInfo.getTypeName(), tryDecimal64);\n    }\n  }\n\n  private void doBetweenIn(Random random, String typeName)\n      throws Exception {\n    doBetweenIn(random, typeName, /* tryDecimal64 */ false);\n  }\n\n  private static final BetweenInVariation[] structInVarations =\n      new BetweenInVariation[] { BetweenInVariation.FILTER_IN, BetweenInVariation.PROJECTION_IN };\n\n  private void doStructTests(Random random) throws Exception {\n\n    String typeName = \"struct\";\n\n    // These are the only type supported for STRUCT IN by the VectorizationContext class.\n    Set<String> allowedTypeNameSet = new HashSet<String>();\n    allowedTypeNameSet.add(\"int\");\n    allowedTypeNameSet.add(\"bigint\");\n    allowedTypeNameSet.add(\"double\");\n    allowedTypeNameSet.add(\"string\");\n\n    // Only STRUCT type IN currently supported.\n    for (BetweenInVariation betweenInVariation : structInVarations) {\n\n      for (int i = 0; i < 4; i++) {\n        typeName =\n            VectorRandomRowSource.getDecoratedTypeName(\n                random, typeName, SupportedTypes.ALL, allowedTypeNameSet,\n                /* depth */ 0, /* maxDepth */ 1);\n\n         doBetweenStructInVariation(\n              random, typeName, betweenInVariation);\n      }\n    }\n  }\n\n  private void doBetweenIn(Random random, String typeName, boolean tryDecimal64)\n          throws Exception {\n\n    int subVariation;\n    for (BetweenInVariation betweenInVariation : BetweenInVariation.values()) {\n      subVariation = 0;\n      while (true) {\n        if (!doBetweenInVariation(\n            random, typeName, tryDecimal64, betweenInVariation, subVariation)) {\n          break;\n        }\n        subVariation++;\n      }\n    }\n  }\n\n  private boolean checkDecimal64(boolean tryDecimal64, TypeInfo typeInfo) {\n    if (!tryDecimal64 || !(typeInfo instanceof DecimalTypeInfo)) {\n      return false;\n    }\n    DecimalTypeInfo decimalTypeInfo = (DecimalTypeInfo) typeInfo;\n    boolean result = HiveDecimalWritable.isPrecisionDecimal64(decimalTypeInfo.getPrecision());\n    return result;\n  }\n\n  private void removeValue(List<Object> valueList, Object value) {\n    valueList.remove(value);\n  }\n\n  private boolean needsValidDataTypeData(TypeInfo typeInfo) {\n    if (!(typeInfo instanceof PrimitiveTypeInfo)) {\n      return false;\n    }\n    PrimitiveCategory primitiveCategory = ((PrimitiveTypeInfo) typeInfo).getPrimitiveCategory();\n    if (primitiveCategory == PrimitiveCategory.STRING ||\n        primitiveCategory == PrimitiveCategory.CHAR ||\n        primitiveCategory == PrimitiveCategory.VARCHAR ||\n        primitiveCategory == PrimitiveCategory.BINARY) {\n      return false;\n    }\n    return true;\n  }\n\n  private boolean doBetweenInVariation(Random random, String typeName,\n      boolean tryDecimal64, BetweenInVariation betweenInVariation, int subVariation)\n          throws Exception {\n\n    TypeInfo typeInfo = TypeInfoUtils.getTypeInfoFromTypeString(typeName);\n\n    boolean isDecimal64 = checkDecimal64(tryDecimal64, typeInfo);\n    DataTypePhysicalVariation dataTypePhysicalVariation =\n        (isDecimal64 ? DataTypePhysicalVariation.DECIMAL_64 : DataTypePhysicalVariation.NONE);\n    final int decimal64Scale =\n        (isDecimal64 ? ((DecimalTypeInfo) typeInfo).getScale() : 0);\n\n    //----------------------------------------------------------------------------------------------\n\n    ObjectInspector objectInspector =\n        TypeInfoUtils.getStandardWritableObjectInspectorFromTypeInfo(\n            typeInfo);\n\n    final int valueCount = 10 + random.nextInt(10);\n    List<Object> valueList = new ArrayList<Object>(valueCount);\n    for (int i = 0; i < valueCount; i++) {\n      valueList.add(\n          VectorRandomRowSource.randomWritable(\n              random, typeInfo, objectInspector, dataTypePhysicalVariation, /* allowNull */ false));\n    }\n\n    final boolean isBetween =\n        (betweenInVariation == BetweenInVariation.FILTER_BETWEEN ||\n        betweenInVariation == BetweenInVariation.FILTER_NOT_BETWEEN ||\n        betweenInVariation == BetweenInVariation.PROJECTION_BETWEEN ||\n        betweenInVariation == BetweenInVariation.PROJECTION_NOT_BETWEEN);\n\n    List<Object> compareList = new ArrayList<Object>();\n\n    List<Object> sortedList = new ArrayList<Object>(valueCount);\n    sortedList.addAll(valueList);\n\n    Object exampleObject = valueList.get(0);\n    WritableComparator writableComparator =\n        WritableComparator.get((Class<? extends WritableComparable>) exampleObject.getClass());\n    sortedList.sort(writableComparator);\n\n    final boolean isInvert;\n    if (isBetween) {\n\n      // FILTER_BETWEEN\n      // FILTER_NOT_BETWEEN\n      // PROJECTION_BETWEEN\n      // PROJECTION_NOT_BETWEEN\n      isInvert =\n          (betweenInVariation == BetweenInVariation.FILTER_NOT_BETWEEN ||\n           betweenInVariation == BetweenInVariation.PROJECTION_NOT_BETWEEN);\n      switch (subVariation) {\n      case 0:\n        // Range covers all values exactly.\n        compareList.add(sortedList.get(0));\n        compareList.add(sortedList.get(valueCount - 1));\n        break;\n      case 1:\n        // Exclude the first and last sorted.\n        compareList.add(sortedList.get(1));\n        compareList.add(sortedList.get(valueCount - 2));\n        break;\n      case 2:\n        // Only last 2 sorted.\n        compareList.add(sortedList.get(valueCount - 2));\n        compareList.add(sortedList.get(valueCount - 1));\n        break;\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n        {\n          // Choose 2 adjacent in the middle.\n          Object min = sortedList.get(5);\n          Object max = sortedList.get(6);\n          compareList.add(min);\n          compareList.add(max);\n          if (subVariation == 4) {\n            removeValue(valueList, min);\n          } else if (subVariation == 5) {\n            removeValue(valueList, max);\n          } else if (subVariation == 6) {\n            removeValue(valueList, min);\n            removeValue(valueList, max);\n          }\n        }\n        break;\n      default:\n        return false;\n      }\n    } else {\n\n      // FILTER_IN.\n      // PROJECTION_IN.\n      isInvert = false;\n      switch (subVariation) {\n      case 0:\n        // All values.\n        compareList.addAll(valueList);\n        break;\n      case 1:\n        // Don't include the first and last sorted.\n        for (int i = 1; i < valueCount - 1; i++) {\n          compareList.add(valueList.get(i));\n        }\n        break;\n      case 2:\n        // The even ones.\n        for (int i = 2; i < valueCount; i += 2) {\n          compareList.add(valueList.get(i));\n        }\n        break;\n      case 3:\n        {\n          // Choose 2 adjacent in the middle.\n          Object min = sortedList.get(5);\n          Object max = sortedList.get(6);\n          compareList.add(min);\n          compareList.add(max);\n          if (subVariation == 4) {\n            removeValue(valueList, min);\n          } else if (subVariation == 5) {\n            removeValue(valueList, max);\n          } else if (subVariation == 6) {\n            removeValue(valueList, min);\n            removeValue(valueList, max);\n          }\n        }\n        break;\n      default:\n        return false;\n      }\n    }\n\n    //----------------------------------------------------------------------------------------------\n\n    GenerationSpec generationSpec = GenerationSpec.createValueList(typeInfo, valueList);\n\n    List<GenerationSpec> generationSpecList = new ArrayList<GenerationSpec>();\n    List<DataTypePhysicalVariation> explicitDataTypePhysicalVariationList =\n        new ArrayList<DataTypePhysicalVariation>();\n    generationSpecList.add(generationSpec);\n    explicitDataTypePhysicalVariationList.add(dataTypePhysicalVariation);\n\n    VectorRandomRowSource rowSource = new VectorRandomRowSource();\n\n    rowSource.initGenerationSpecSchema(\n        random, generationSpecList, /* maxComplexDepth */ 0,\n        /* allowNull */ true, /* isUnicodeOk */ true,\n        explicitDataTypePhysicalVariationList);\n\n    List<String> columns = new ArrayList<String>();\n    String col1Name = rowSource.columnNames().get(0);\n    columns.add(col1Name);\n    final ExprNodeDesc col1Expr = new ExprNodeColumnDesc(typeInfo, col1Name, \"table\", false);\n\n    List<ExprNodeDesc> children = new ArrayList<ExprNodeDesc>();\n    if (isBetween) {\n      children.add(new ExprNodeConstantDesc(Boolean.valueOf(isInvert)));\n    }\n    children.add(col1Expr);\n    for (Object compareObject : compareList) {\n      ExprNodeConstantDesc constDesc =\n          new ExprNodeConstantDesc(\n              typeInfo,\n              VectorRandomRowSource.getNonWritableObject(\n                  compareObject, typeInfo, objectInspector));\n      children.add(constDesc);\n    }\n\n    String[] columnNames = columns.toArray(new String[0]);\n\n    Object[][] randomRows = rowSource.randomRows(100000);\n\n    VectorRandomBatchSource batchSource =\n        VectorRandomBatchSource.createInterestingBatches(\n            random,\n            rowSource,\n            randomRows,\n            null);\n\n    final GenericUDF udf;\n    final ObjectInspector outputObjectInspector;\n    if (isBetween) {\n\n      udf = new GenericUDFBetween();\n\n      // First argument is boolean invert. Arguments 1..3 are inspectors for range limits...\n      ObjectInspector[] argumentOIs = new ObjectInspector[4];\n      argumentOIs[0] = PrimitiveObjectInspectorFactory.writableBooleanObjectInspector;\n      argumentOIs[1] = objectInspector;\n      argumentOIs[2] = objectInspector;\n      argumentOIs[3] = objectInspector;\n      outputObjectInspector = udf.initialize(argumentOIs);\n    } else {\n      final int compareCount = compareList.size();\n      udf = new GenericUDFIn();\n      ObjectInspector[] argumentOIs = new ObjectInspector[compareCount];\n      ConstantObjectInspector constantObjectInspector =\n          (ConstantObjectInspector) children.get(1).getWritableObjectInspector();\n      for (int i = 0; i < compareCount; i++) {\n        argumentOIs[i] = constantObjectInspector;\n      }\n      outputObjectInspector = udf.initialize(argumentOIs);\n    }\n\n    TypeInfo outputTypeInfo = TypeInfoUtils.getTypeInfoFromObjectInspector(outputObjectInspector);\n\n    ExprNodeGenericFuncDesc exprDesc =\n        new ExprNodeGenericFuncDesc(\n            TypeInfoFactory.booleanTypeInfo, udf, children);\n\n    return executeTestModesAndVerify(\n        typeInfo, betweenInVariation, compareList, columns, columnNames, children,\n        udf, exprDesc,\n        randomRows, rowSource, batchSource, outputTypeInfo,\n        /* skipAdaptor */ false);\n  }\n\n  private boolean doBetweenStructInVariation(Random random, String structTypeName,\n      BetweenInVariation betweenInVariation)\n          throws Exception {\n\n    StructTypeInfo structTypeInfo =\n        (StructTypeInfo) TypeInfoUtils.getTypeInfoFromTypeString(structTypeName);\n\n    ObjectInspector structObjectInspector =\n        TypeInfoUtils.getStandardWritableObjectInspectorFromTypeInfo(\n            structTypeInfo);\n\n    final int valueCount = 10 + random.nextInt(10);\n    List<Object> valueList = new ArrayList<Object>(valueCount);\n    for (int i = 0; i < valueCount; i++) {\n      valueList.add(\n          VectorRandomRowSource.randomWritable(\n              random, structTypeInfo, structObjectInspector, DataTypePhysicalVariation.NONE,\n              /* allowNull */ false));\n    }\n\n    final boolean isInvert = false;\n \n    // No convenient WritableComparator / WritableComparable available for STRUCT.\n    List<Object> compareList = new ArrayList<Object>();\n\n    Set<Integer> includedSet = new HashSet<Integer>();\n    final int chooseLimit = 4 + random.nextInt(valueCount/2);\n    int chooseCount = 0;\n    while (chooseCount < chooseLimit) {\n      final int index = random.nextInt(valueCount);\n      if (includedSet.contains(index)) {\n        continue;\n      }\n      includedSet.add(index);\n      compareList.add(valueList.get(index));\n      chooseCount++;\n    }\n\n    //----------------------------------------------------------------------------------------------\n\n    GenerationSpec structGenerationSpec = GenerationSpec.createValueList(structTypeInfo, valueList);\n\n    List<GenerationSpec> structGenerationSpecList = new ArrayList<GenerationSpec>();\n    List<DataTypePhysicalVariation> structExplicitDataTypePhysicalVariationList =\n        new ArrayList<DataTypePhysicalVariation>();\n    structGenerationSpecList.add(structGenerationSpec);\n    structExplicitDataTypePhysicalVariationList.add(DataTypePhysicalVariation.NONE);\n\n    VectorRandomRowSource structRowSource = new VectorRandomRowSource();\n\n    structRowSource.initGenerationSpecSchema(\n        random, structGenerationSpecList, /* maxComplexDepth */ 0,\n        /* allowNull */ true, /* isUnicodeOk */ true,\n        structExplicitDataTypePhysicalVariationList);\n\n    Object[][] structRandomRows = structRowSource.randomRows(100000);\n\n    // ---------------------------------------------------------------------------------------------\n\n    List<GenerationSpec> generationSpecList = new ArrayList<GenerationSpec>();\n    List<DataTypePhysicalVariation> explicitDataTypePhysicalVariationList =\n        new ArrayList<DataTypePhysicalVariation>();\n\n    List<TypeInfo> fieldTypeInfoList = structTypeInfo.getAllStructFieldTypeInfos();\n    final int fieldCount = fieldTypeInfoList.size();\n    for (int i = 0; i < fieldCount; i++) {\n      GenerationSpec generationSpec = GenerationSpec.createOmitGeneration(fieldTypeInfoList.get(i));\n      generationSpecList.add(generationSpec);\n      explicitDataTypePhysicalVariationList.add(DataTypePhysicalVariation.NONE);\n    }\n\n    VectorRandomRowSource rowSource = new VectorRandomRowSource();\n\n    rowSource.initGenerationSpecSchema(\n        random, generationSpecList, /* maxComplexDepth */ 0,\n        /* allowNull */ true, /* isUnicodeOk */ true,\n        explicitDataTypePhysicalVariationList);\n\n    Object[][] randomRows = rowSource.randomRows(100000);\n\n    final int rowCount = randomRows.length;\n    for (int r = 0; r < rowCount; r++) {\n      List<Object> fieldValueList = (ArrayList) structRandomRows[r][0]; \n      for (int f = 0; f < fieldCount; f++) {\n        randomRows[r][f] = fieldValueList.get(f);\n      }\n    }\n\n    // ---------------------------------------------------------------------------------------------\n\n    // Currently, STRUCT IN vectorization assumes a GenericUDFStruct.\n\n    List<ObjectInspector> structUdfObjectInspectorList = new ArrayList<ObjectInspector>();\n    List<ExprNodeDesc> structUdfChildren = new ArrayList<ExprNodeDesc>(fieldCount);\n    List<String> rowColumnNameList = rowSource.columnNames();\n    for (int i = 0; i < fieldCount; i++) {\n      TypeInfo fieldTypeInfo = fieldTypeInfoList.get(i);\n      ExprNodeColumnDesc fieldExpr =\n          new ExprNodeColumnDesc(\n              fieldTypeInfo, rowColumnNameList.get(i), \"table\", false);\n      structUdfChildren.add(fieldExpr);\n      ObjectInspector fieldObjectInspector =\n          VectorRandomRowSource.getObjectInspector(fieldTypeInfo, DataTypePhysicalVariation.NONE);\n      structUdfObjectInspectorList.add(fieldObjectInspector);\n    }\n    StandardStructObjectInspector structUdfObjectInspector =\n        ObjectInspectorFactory.\n            getStandardStructObjectInspector(rowColumnNameList, structUdfObjectInspectorList);\n    String structUdfTypeName = structUdfObjectInspector.getTypeName();\n    TypeInfo structUdfTypeInfo = TypeInfoUtils.getTypeInfoFromTypeString(structUdfTypeName);\n\n    String structFuncText = \"struct\";\n    FunctionInfo fi = FunctionRegistry.getFunctionInfo(structFuncText);\n    GenericUDF genericUDF = fi.getGenericUDF();\n    ExprNodeDesc col1Expr =\n        new ExprNodeGenericFuncDesc(\n            structUdfObjectInspector, genericUDF, structFuncText, structUdfChildren);\n\n    // ---------------------------------------------------------------------------------------------\n\n    List<String> columns = new ArrayList<String>();\n\n    List<ExprNodeDesc> children = new ArrayList<ExprNodeDesc>();\n    children.add(col1Expr);\n    for (int i = 0; i < compareList.size(); i++) {\n      Object compareObject = compareList.get(i);\n      ExprNodeConstantDesc constDesc =\n          new ExprNodeConstantDesc(\n              structUdfTypeInfo,\n              VectorRandomRowSource.getNonWritableObject(\n                  compareObject, structUdfTypeInfo, structUdfObjectInspector));\n      children.add(constDesc);\n    }\n\n    for (int i = 0; i < fieldCount; i++) {\n      columns.add(rowColumnNameList.get(i));\n    }\n\n    String[] columnNames = columns.toArray(new String[0]);\n\n    VectorRandomBatchSource batchSource =\n        VectorRandomBatchSource.createInterestingBatches(\n            random,\n            rowSource,\n            randomRows,\n            null);\n\n    // ---------------------------------------------------------------------------------------------\n\n    final GenericUDF udf = new GenericUDFIn();\n    final int compareCount = compareList.size();\n    ObjectInspector[] argumentOIs = new ObjectInspector[compareCount];\n    for (int i = 0; i < compareCount; i++) {\n      argumentOIs[i] = structUdfObjectInspector;\n    }\n    final ObjectInspector outputObjectInspector = udf.initialize(argumentOIs);\n\n    TypeInfo outputTypeInfo = TypeInfoUtils.getTypeInfoFromObjectInspector(outputObjectInspector);\n\n    ExprNodeGenericFuncDesc exprDesc =\n        new ExprNodeGenericFuncDesc(\n            TypeInfoFactory.booleanTypeInfo, udf, children);\n\n    return executeTestModesAndVerify(\n        structUdfTypeInfo, betweenInVariation, compareList, columns, columnNames, children,\n        udf, exprDesc,\n        randomRows, rowSource, batchSource, outputTypeInfo,\n        /* skipAdaptor */ true);\n  }\n\n  private boolean executeTestModesAndVerify(TypeInfo typeInfo,\n      BetweenInVariation betweenInVariation, List<Object> compareList,\n      List<String> columns, String[] columnNames, List<ExprNodeDesc> children,\n      GenericUDF udf, ExprNodeGenericFuncDesc exprDesc,\n      Object[][] randomRows,\n      VectorRandomRowSource rowSource, VectorRandomBatchSource batchSource,\n      TypeInfo outputTypeInfo, boolean skipAdaptor)\n          throws Exception {\n\n    final int rowCount = randomRows.length;\n    Object[][] resultObjectsArray = new Object[BetweenInTestMode.count][];\n    for (int i = 0; i < BetweenInTestMode.count; i++) {\n\n      Object[] resultObjects = new Object[rowCount];\n      resultObjectsArray[i] = resultObjects;\n\n      BetweenInTestMode betweenInTestMode = BetweenInTestMode.values()[i];\n      switch (betweenInTestMode) {\n      case ROW_MODE:\n        if (!doRowCastTest(\n              typeInfo,\n              betweenInVariation,\n              compareList,\n              columns,\n              children,\n              udf, exprDesc,\n              randomRows,\n              rowSource.rowStructObjectInspector(),\n              resultObjects)) {\n          return false;\n        }\n        break;\n      case ADAPTOR:\n         if (skipAdaptor) {\n           continue;\n         }\n      case VECTOR_EXPRESSION:\n        if (!doVectorBetweenInTest(\n              typeInfo,\n              betweenInVariation,\n              compareList,\n              columns,\n              columnNames,\n              rowSource.typeInfos(),\n              rowSource.dataTypePhysicalVariations(),\n              children,\n              udf, exprDesc,\n              betweenInTestMode,\n              batchSource,\n              exprDesc.getWritableObjectInspector(),\n              outputTypeInfo,\n              resultObjects)) {\n          return false;\n        }\n        break;\n      default:\n        throw new RuntimeException(\"Unexpected IF statement test mode \" + betweenInTestMode);\n      }\n    }\n\n    for (int i = 0; i < rowCount; i++) {\n      // Row-mode is the expected value.\n      Object expectedResult = resultObjectsArray[0][i];\n\n      for (int v = 1; v < BetweenInTestMode.count; v++) {\n        BetweenInTestMode betweenInTestMode = BetweenInTestMode.values()[v];\n        if (skipAdaptor) {\n          continue;\n        }\n        Object vectorResult = resultObjectsArray[v][i];\n        if (betweenInVariation.isFilter &&\n            expectedResult == null &&\n            vectorResult != null) {\n          // This is OK.\n          boolean vectorBoolean = ((BooleanWritable) vectorResult).get();\n          if (vectorBoolean) {\n            Assert.fail(\n                \"Row \" + i +\n                \" typeName \" + typeInfo.getTypeName() +\n                \" outputTypeName \" + outputTypeInfo.getTypeName() +\n                \" \" + betweenInVariation +\n                \" \" + betweenInTestMode +\n                \" result is NOT NULL and true\" +\n                \" does not match row-mode expected result is NULL which means false here\" +\n                \" row values \" + Arrays.toString(randomRows[i]) +\n                \" exprDesc \" + exprDesc.toString());\n          }\n        } else if (expectedResult == null || vectorResult == null) {\n          if (expectedResult != null || vectorResult != null) {\n            Assert.fail(\n                \"Row \" + i +\n                \" sourceTypeName \" + typeInfo.getTypeName() +\n                \" \" + betweenInVariation +\n                \" \" + betweenInTestMode +\n                \" result is NULL \" + (vectorResult == null ? \"YES\" : \"NO result \" + vectorResult.toString()) +\n                \" does not match row-mode expected result is NULL \" +\n                (expectedResult == null ? \"YES\" : \"NO result \" + expectedResult.toString()) +\n                \" row values \" + Arrays.toString(randomRows[i]) +\n                \" exprDesc \" + exprDesc.toString());\n          }\n        } else {\n\n          if (!expectedResult.equals(vectorResult)) {\n            Assert.fail(\n                \"Row \" + i +\n                \" sourceTypeName \" + typeInfo.getTypeName() +\n                \" \" + betweenInVariation +\n                \" \" + betweenInTestMode +\n                \" result \" + vectorResult.toString() +\n                \" (\" + vectorResult.getClass().getSimpleName() + \")\" +\n                \" does not match row-mode expected result \" + expectedResult.toString() +\n                \" (\" + expectedResult.getClass().getSimpleName() + \")\" +\n                \" row values \" + Arrays.toString(randomRows[i]) +\n                \" exprDesc \" + exprDesc.toString());\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  private boolean doRowCastTest(TypeInfo typeInfo,\n      BetweenInVariation betweenInVariation, List<Object> compareList,\n      List<String> columns, List<ExprNodeDesc> children,\n      GenericUDF udf, ExprNodeGenericFuncDesc exprDesc,\n      Object[][] randomRows,\n      ObjectInspector rowInspector, Object[] resultObjects)\n          throws Exception {\n\n    /*\n    System.out.println(\n        \"*DEBUG* typeInfo \" + typeInfo.toString() +\n        \" targetTypeInfo \" + targetTypeInfo +\n        \" betweenInTestMode ROW_MODE\" +\n        \" exprDesc \" + exprDesc.toString());\n    */\n\n    HiveConf hiveConf = new HiveConf();\n    ExprNodeEvaluator evaluator =\n        ExprNodeEvaluatorFactory.get(exprDesc, hiveConf);\n\n    evaluator.initialize(rowInspector);\n\n    final int rowCount = randomRows.length;\n    for (int i = 0; i < rowCount; i++) {\n      Object[] row = randomRows[i];\n      Object result = evaluator.evaluate(row);\n      Object copyResult =\n          ObjectInspectorUtils.copyToStandardObject(\n              result, PrimitiveObjectInspectorFactory.writableBooleanObjectInspector,\n              ObjectInspectorCopyOption.WRITABLE);\n      resultObjects[i] = copyResult;\n    }\n\n    return true;\n  }\n\n  private void extractResultObjects(VectorizedRowBatch batch, int rowIndex,\n      VectorExtractRow resultVectorExtractRow, Object[] scrqtchRow,\n      ObjectInspector objectInspector, Object[] resultObjects) {\n\n    boolean selectedInUse = batch.selectedInUse;\n    int[] selected = batch.selected;\n    for (int logicalIndex = 0; logicalIndex < batch.size; logicalIndex++) {\n      final int batchIndex = (selectedInUse ? selected[logicalIndex] : logicalIndex);\n      resultVectorExtractRow.extractRow(batch, batchIndex, scrqtchRow);\n\n      Object copyResult =\n          ObjectInspectorUtils.copyToStandardObject(\n              scrqtchRow[0], objectInspector, ObjectInspectorCopyOption.WRITABLE);\n      resultObjects[rowIndex++] = copyResult;\n    }\n  }\n\n  private boolean doVectorBetweenInTest(TypeInfo typeInfo,\n      BetweenInVariation betweenInVariation, List<Object> compareList,\n      List<String> columns, String[] columnNames,\n      TypeInfo[] typeInfos, DataTypePhysicalVariation[] dataTypePhysicalVariations,\n      List<ExprNodeDesc> children,\n      GenericUDF udf, ExprNodeGenericFuncDesc exprDesc,\n      BetweenInTestMode betweenInTestMode,\n      VectorRandomBatchSource batchSource,\n      ObjectInspector objectInspector,\n      TypeInfo outputTypeInfo, Object[] resultObjects)\n          throws Exception {\n\n    HiveConf hiveConf = new HiveConf();\n    if (betweenInTestMode == BetweenInTestMode.ADAPTOR) {\n      hiveConf.setBoolVar(HiveConf.ConfVars.HIVE_TEST_VECTOR_ADAPTOR_OVERRIDE, true);\n    }\n\n    final boolean isFilter = betweenInVariation.isFilter;\n\n    VectorizationContext vectorizationContext =\n        new VectorizationContext(\n            \"name\",\n            columns,\n            Arrays.asList(typeInfos),\n            Arrays.asList(dataTypePhysicalVariations),\n            hiveConf);\n    VectorExpression vectorExpression =\n        vectorizationContext.getVectorExpression(exprDesc,\n            (isFilter ?\n                VectorExpressionDescriptor.Mode.FILTER :\n                VectorExpressionDescriptor.Mode.PROJECTION));\n    vectorExpression.transientInit(hiveConf);\n\n    if (betweenInTestMode == BetweenInTestMode.VECTOR_EXPRESSION) {\n      String vecExprString = vectorExpression.toString();\n      if (vectorExpression instanceof VectorUDFAdaptor) {\n        System.out.println(\n            \"*NO NATIVE VECTOR EXPRESSION* typeInfo \" + typeInfo.toString() +\n            \" betweenInTestMode \" + betweenInTestMode +\n            \" betweenInVariation \" + betweenInVariation +\n            \" vectorExpression \" + vecExprString);\n      } else if (dataTypePhysicalVariations[0] == DataTypePhysicalVariation.DECIMAL_64) {\n        final String nameToCheck = vectorExpression.getClass().getSimpleName();\n        if (!nameToCheck.contains(\"Decimal64\")) {\n          System.out.println(\n              \"*EXPECTED DECIMAL_64 VECTOR EXPRESSION* typeInfo \" + typeInfo.toString() +\n              \" betweenInTestMode \" + betweenInTestMode +\n              \" betweenInVariation \" + betweenInVariation +\n              \" vectorExpression \" + vecExprString);\n        }\n      }\n    }\n\n    // System.out.println(\"*VECTOR EXPRESSION* \" + vectorExpression.getClass().getSimpleName());\n\n    /*\n    System.out.println(\n        \"*DEBUG* typeInfo \" + typeInfo.toString() +\n        \" betweenInTestMode \" + betweenInTestMode +\n        \" betweenInVariation \" + betweenInVariation +\n        \" vectorExpression \" + vectorExpression.toString());\n    */\n\n    VectorRandomRowSource rowSource = batchSource.getRowSource();\n    VectorizedRowBatchCtx batchContext =\n        new VectorizedRowBatchCtx(\n            columnNames,\n            rowSource.typeInfos(),\n            rowSource.dataTypePhysicalVariations(),\n            /* dataColumnNums */ null,\n            /* partitionColumnCount */ 0,\n            /* virtualColumnCount */ 0,\n            /* neededVirtualColumns */ null,\n            vectorizationContext.getScratchColumnTypeNames(),\n            vectorizationContext.getScratchDataTypePhysicalVariations());\n\n    VectorizedRowBatch batch = batchContext.createVectorizedRowBatch();\n\n    VectorExtractRow resultVectorExtractRow = null;\n    Object[] scrqtchRow = null;\n    if (!isFilter) {\n      resultVectorExtractRow = new VectorExtractRow();\n      final int outputColumnNum = vectorExpression.getOutputColumnNum();\n      resultVectorExtractRow.init(\n          new TypeInfo[] { outputTypeInfo }, new int[] { outputColumnNum });\n      scrqtchRow = new Object[1];\n    }\n\n    boolean copySelectedInUse = false;\n    int[] copySelected = new int[VectorizedRowBatch.DEFAULT_SIZE];\n\n    batchSource.resetBatchIteration();\n    int rowIndex = 0;\n    while (true) {\n      if (!batchSource.fillNextBatch(batch)) {\n        break;\n      }\n      final int originalBatchSize = batch.size;\n      if (isFilter) {\n        copySelectedInUse = batch.selectedInUse;\n        if (batch.selectedInUse) {\n          System.arraycopy(batch.selected, 0, copySelected, 0, originalBatchSize);\n        }\n      }\n\n      // In filter mode, the batch size can be made smaller.\n      vectorExpression.evaluate(batch);\n\n      if (!isFilter) {\n        extractResultObjects(batch, rowIndex, resultVectorExtractRow, scrqtchRow,\n            objectInspector, resultObjects);\n      } else {\n        final int currentBatchSize = batch.size;\n        if (copySelectedInUse && batch.selectedInUse) {\n          int selectIndex = 0;\n          for (int i = 0; i < originalBatchSize; i++) {\n            final int originalBatchIndex = copySelected[i];\n            final boolean booleanResult;\n            if (selectIndex < currentBatchSize && batch.selected[selectIndex] == originalBatchIndex) {\n              booleanResult = true;\n              selectIndex++;\n            } else {\n              booleanResult = false;\n            }\n            resultObjects[rowIndex + i] = new BooleanWritable(booleanResult);\n          }\n        } else if (batch.selectedInUse) {\n          int selectIndex = 0;\n          for (int i = 0; i < originalBatchSize; i++) {\n            final boolean booleanResult;\n            if (selectIndex < currentBatchSize && batch.selected[selectIndex] == i) {\n              booleanResult = true;\n              selectIndex++;\n            } else {\n              booleanResult = false;\n            }\n            resultObjects[rowIndex + i] = new BooleanWritable(booleanResult);\n          }\n        } else if (currentBatchSize == 0) {\n          // Whole batch got zapped.\n          for (int i = 0; i < originalBatchSize; i++) {\n            resultObjects[rowIndex + i] = new BooleanWritable(false);\n          }\n        } else {\n          // Every row kept.\n          for (int i = 0; i < originalBatchSize; i++) {\n            resultObjects[rowIndex + i] = new BooleanWritable(true);\n          }\n        }\n      }\n\n      rowIndex += originalBatchSize;\n    }\n\n    return true;\n  }\n}", "item_id": 0, "repo": "FANsZL/hive", "file": "ql/src/test/org/apache/hadoop/hive/ql/exec/vector/expressions/TestVectorBetweenIn.java", "last_update_at": "2022-03-31T06:26:22+00:00", "question_id": "f76378487ccb1b66b32fe495cdb9ba4a9289af0a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestVectorBetweenIn {\n  @Test\n  public void testTinyInt() throws Exception {\n    Random random = new Random(5371);\n    doBetweenIn(random, \"tinyint\");\n  }\n  @Test\n  public void testSmallInt() throws Exception {\n    Random random = new Random(2772);\n    doBetweenIn(random, \"smallint\");\n  }\n  @Test\n  public void testInt() throws Exception {\n    Random random = new Random(12882);\n    doBetweenIn(random, \"int\");\n  }\n  @Test\n  public void testBigInt() throws Exception {\n    Random random = new Random(12882);\n    doBetweenIn(random, \"bigint\");\n  }\n  @Test\n  public void testString() throws Exception {\n    Random random = new Random(12882);\n    doBetweenIn(random, \"string\");\n  }\n  @Test\n  public void testTimestamp() throws Exception {\n    Random random = new Random(12882);\n    doBetweenIn(random, \"timestamp\");\n  }\n  @Test\n  public void testDate() throws Exception {\n    Random random = new Random(12882);\n    doBetweenIn(random, \"date\");\n  }\n  @Test\n  public void testFloat() throws Exception {\n    Random random = new Random(7322);\n    doBetweenIn(random, \"float\");\n  }\n  @Test\n  public void testDouble() throws Exception {\n    Random random = new Random(12882);\n    doBetweenIn(random, \"double\");\n  }\n  @Test\n  public void testChar() throws Exception {\n    Random random = new Random(12882);\n    doBetweenIn(random, \"char(10)\");\n  }\n  @Test\n  public void testVarchar() throws Exception {\n    Random random = new Random(12882);\n    doBetweenIn(random, \"varchar(15)\");\n  }\n  @Test\n  public void testDecimal() throws Exception {\n    Random random = new Random(9300);\n    doDecimalTests(random, /* tryDecimal64 */ false);\n  }\n  @Test\n  public void testDecimal64() throws Exception {\n    Random random = new Random(9300);\n    doDecimalTests(random, /* tryDecimal64 */ true);\n  }\n  @Test\n  public void testStruct() throws Exception {\n    Random random = new Random(9300);\n    doStructTests(random);\n  }\n  public enum BetweenInTestMode {\n    ROW_MODE,\n    ADAPTOR,\n    VECTOR_EXPRESSION;\n    static final int count = values().length;\n  }\n  public enum BetweenInVariation {\n    FILTER_BETWEEN,\n    FILTER_NOT_BETWEEN,\n    PROJECTION_BETWEEN,\n    PROJECTION_NOT_BETWEEN,\n    FILTER_IN,\n    PROJECTION_IN;\n    static final int count = values().length;\n    final boolean isFilter;\n    BetweenInVariation() {\n      isFilter = name().startsWith(\"FILTER\");\n    }\n  }\n  private static TypeInfo[] decimalTypeInfos = new TypeInfo[] {\n    new DecimalTypeInfo(38, 18),\n    new DecimalTypeInfo(25, 2),\n    new DecimalTypeInfo(19, 4),\n    new DecimalTypeInfo(18, 10),\n    new DecimalTypeInfo(17, 3),\n    new DecimalTypeInfo(12, 2),\n    new DecimalTypeInfo(7, 1)\n  };\n  private void doDecimalTests(Random random, boolean tryDecimal64)\n      throws Exception {\n    for (TypeInfo typeInfo : decimalTypeInfos) {\n      doBetweenIn(\n          random, typeInfo.getTypeName(), tryDecimal64);\n    }\n  }\n  private void doBetweenIn(Random random, String typeName)\n      throws Exception {\n    doBetweenIn(random, typeName, /* tryDecimal64 */ false);\n  }\n  private static final BetweenInVariation[] structInVarations =\n      new BetweenInVariation[] { BetweenInVariation.FILTER_IN, BetweenInVariation.PROJECTION_IN };\n  private void doStructTests(Random random) throws Exception {\n    String typeName = \"struct\";\n    // These are the only type supported for STRUCT IN by the VectorizationContext class.\n    Set<String> allowedTypeNameSet = new HashSet<String>();\n    allowedTypeNameSet.add(\"int\");\n    allowedTypeNameSet.add(\"bigint\");\n    allowedTypeNameSet.add(\"double\");\n    allowedTypeNameSet.add(\"string\");\n    // Only STRUCT type IN currently supported.\n    for (BetweenInVariation betweenInVariation : structInVarations) {\n      for (int i = 0; i < 4; i++) {\n        typeName =\n            VectorRandomRowSource.getDecoratedTypeName(\n                random, typeName, SupportedTypes.ALL, allowedTypeNameSet,\n                /* depth */ 0, /* maxDepth */ 1);\n         doBetweenStructInVariation(\n              random, typeName, betweenInVariation);\n      }\n    }\n  }\n  private void doBetweenIn(Random random, String typeName, boolean tryDecimal64)\n          throws Exception {\n    int subVariation;\n    for (BetweenInVariation betweenInVariation : BetweenInVariation.values()) {\n      subVariation = 0;\n      while (true) {\n        if (!doBetweenInVariation(\n            random, typeName, tryDecimal64, betweenInVariation, subVariation)) {\n          break;\n        }\n        subVariation++;\n      }\n    }\n  }\n  private boolean checkDecimal64(boolean tryDecimal64, TypeInfo typeInfo) {\n    if (!tryDecimal64 || !(typeInfo instanceof DecimalTypeInfo)) {\n      return false;\n    }\n    DecimalTypeInfo decimalTypeInfo = (DecimalTypeInfo) typeInfo;\n    boolean result = HiveDecimalWritable.isPrecisionDecimal64(decimalTypeInfo.getPrecision());\n    return result;\n  }\n  private void removeValue(List<Object> valueList, Object value) {\n    valueList.remove(value);\n  }\n  private boolean needsValidDataTypeData(TypeInfo typeInfo) {\n    if (!(typeInfo instanceof PrimitiveTypeInfo)) {\n      return false;\n    }\n    PrimitiveCategory primitiveCategory = ((PrimitiveTypeInfo) typeInfo).getPrimitiveCategory();\n    if (primitiveCategory == PrimitiveCategory.STRING ||\n        primitiveCategory == PrimitiveCategory.CHAR ||\n        primitiveCategory == PrimitiveCategory.VARCHAR ||\n        primitiveCategory == PrimitiveCategory.BINARY) {\n      return false;\n    }\n    return true;\n  }\n  private boolean doBetweenInVariation(Random random, String typeName,\n      boolean tryDecimal64, BetweenInVariation betweenInVariation, int subVariation)\n          throws Exception {\n    TypeInfo typeInfo = TypeInfoUtils.getTypeInfoFromTypeString(typeName);\n    boolean isDecimal64 = checkDecimal64(tryDecimal64, typeInfo);\n    DataTypePhysicalVariation dataTypePhysicalVariation =\n        (isDecimal64 ? DataTypePhysicalVariation.DECIMAL_64 : DataTypePhysicalVariation.NONE);\n    final int decimal64Scale =\n        (isDecimal64 ? ((DecimalTypeInfo) typeInfo).getScale() : 0);\n    //----------------------------------------------------------------------------------------------\n    ObjectInspector objectInspector =\n        TypeInfoUtils.getStandardWritableObjectInspectorFromTypeInfo(\n            typeInfo);\n    final int valueCount = 10 + random.nextInt(10);\n    List<Object> valueList = new ArrayList<Object>(valueCount);\n    for (int i = 0; i < valueCount; i++) {\n      valueList.add(\n          VectorRandomRowSource.randomWritable(\n              random, typeInfo, objectInspector, dataTypePhysicalVariation, /* allowNull */ false));\n    }\n    final boolean isBetween =\n        (betweenInVariation == BetweenInVariation.FILTER_BETWEEN ||\n        betweenInVariation == BetweenInVariation.FILTER_NOT_BETWEEN ||\n        betweenInVariation == BetweenInVariation.PROJECTION_BETWEEN ||\n        betweenInVariation == BetweenInVariation.PROJECTION_NOT_BETWEEN);\n    List<Object> compareList = new ArrayList<Object>();\n    List<Object> sortedList = new ArrayList<Object>(valueCount);\n    sortedList.addAll(valueList);\n    Object exampleObject = valueList.get(0);\n    WritableComparator writableComparator =\n        WritableComparator.get((Class<? extends WritableComparable>) exampleObject.getClass());\n    sortedList.sort(writableComparator);\n    final boolean isInvert;\n    if (isBetween) {\n      // FILTER_BETWEEN\n      // FILTER_NOT_BETWEEN\n      // PROJECTION_BETWEEN\n      // PROJECTION_NOT_BETWEEN\n      isInvert =\n          (betweenInVariation == BetweenInVariation.FILTER_NOT_BETWEEN ||\n           betweenInVariation == BetweenInVariation.PROJECTION_NOT_BETWEEN);\n      switch (subVariation) {\n      case 0:\n        // Range covers all values exactly.\n        compareList.add(sortedList.get(0));\n        compareList.add(sortedList.get(valueCount - 1));\n        break;\n      case 1:\n        // Exclude the first and last sorted.\n        compareList.add(sortedList.get(1));\n        compareList.add(sortedList.get(valueCount - 2));\n        break;\n      case 2:\n        // Only last 2 sorted.\n        compareList.add(sortedList.get(valueCount - 2));\n        compareList.add(sortedList.get(valueCount - 1));\n        break;\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n        {\n          // Choose 2 adjacent in the middle.\n          Object min = sortedList.get(5);\n          Object max = sortedList.get(6);\n          compareList.add(min);\n          compareList.add(max);\n          if (subVariation == 4) {\n            removeValue(valueList, min);\n          } else if (subVariation == 5) {\n            removeValue(valueList, max);\n          } else if (subVariation == 6) {\n            removeValue(valueList, min);\n            removeValue(valueList, max);\n          }\n        }\n        break;\n      default:\n        return false;\n      }\n    } else {\n      // FILTER_IN.\n      // PROJECTION_IN.\n      isInvert = false;\n      switch (subVariation) {\n      case 0:\n        // All values.\n        compareList.addAll(valueList);\n        break;\n      case 1:\n        // Don't include the first and last sorted.\n        for (int i = 1; i < valueCount - 1; i++) {\n          compareList.add(valueList.get(i));\n        }\n        break;\n      case 2:\n        // The even ones.\n        for (int i = 2; i < valueCount; i += 2) {\n          compareList.add(valueList.get(i));\n        }\n        break;\n      case 3:\n        {\n          // Choose 2 adjacent in the middle.\n          Object min = sortedList.get(5);\n          Object max = sortedList.get(6);\n          compareList.add(min);\n          compareList.add(max);\n          if (subVariation == 4) {\n            removeValue(valueList, min);\n          } else if (subVariation == 5) {\n            removeValue(valueList, max);\n          } else if (subVariation == 6) {\n            removeValue(valueList, min);\n            removeValue(valueList, max);\n          }\n        }\n        break;\n      default:\n        return false;\n      }\n    }\n    //----------------------------------------------------------------------------------------------\n    GenerationSpec generationSpec = GenerationSpec.createValueList(typeInfo, valueList);\n    List<GenerationSpec> generationSpecList = new ArrayList<GenerationSpec>();\n    List<DataTypePhysicalVariation> explicitDataTypePhysicalVariationList =\n        new ArrayList<DataTypePhysicalVariation>();\n    generationSpecList.add(generationSpec);\n    explicitDataTypePhysicalVariationList.add(dataTypePhysicalVariation);\n    VectorRandomRowSource rowSource = new VectorRandomRowSource();\n    rowSource.initGenerationSpecSchema(\n        random, generationSpecList, /* maxComplexDepth */ 0,\n        /* allowNull */ true, /* isUnicodeOk */ true,\n        explicitDataTypePhysicalVariationList);\n    List<String> columns = new ArrayList<String>();\n    String col1Name = rowSource.columnNames().get(0);\n    columns.add(col1Name);\n    final ExprNodeDesc col1Expr = new ExprNodeColumnDesc(typeInfo, col1Name, \"table\", false);\n    List<ExprNodeDesc> children = new ArrayList<ExprNodeDesc>();\n    if (isBetween) {\n      children.add(new ExprNodeConstantDesc(Boolean.valueOf(isInvert)));\n    }\n    children.add(col1Expr);\n    for (Object compareObject : compareList) {\n      ExprNodeConstantDesc constDesc =\n          new ExprNodeConstantDesc(\n              typeInfo,\n              VectorRandomRowSource.getNonWritableObject(\n                  compareObject, typeInfo, objectInspector));\n      children.add(constDesc);\n    }\n    String[] columnNames = columns.toArray(new String[0]);\n    Object[][] randomRows = rowSource.randomRows(100000);\n    VectorRandomBatchSource batchSource =\n        VectorRandomBatchSource.createInterestingBatches(\n            random,\n            rowSource,\n            randomRows,\n            null);\n    final GenericUDF udf;\n    final ObjectInspector outputObjectInspector;\n    if (isBetween) {\n      udf = new GenericUDFBetween();\n      // First argument is boolean invert. Arguments 1..3 are inspectors for range limits...\n      ObjectInspector[] argumentOIs = new ObjectInspector[4];\n      argumentOIs[0] = PrimitiveObjectInspectorFactory.writableBooleanObjectInspector;\n      argumentOIs[1] = objectInspector;\n      argumentOIs[2] = objectInspector;\n      argumentOIs[3] = objectInspector;\n      outputObjectInspector = udf.initialize(argumentOIs);\n    } else {\n      final int compareCount = compareList.size();\n      udf = new GenericUDFIn();\n      ObjectInspector[] argumentOIs = new ObjectInspector[compareCount];\n      ConstantObjectInspector constantObjectInspector =\n          (ConstantObjectInspector) children.get(1).getWritableObjectInspector();\n      for (int i = 0; i < compareCount; i++) {\n        argumentOIs[i] = constantObjectInspector;\n      }\n      outputObjectInspector = udf.initialize(argumentOIs);\n    }\n    TypeInfo outputTypeInfo = TypeInfoUtils.getTypeInfoFromObjectInspector(outputObjectInspector);\n    ExprNodeGenericFuncDesc exprDesc =\n        new ExprNodeGenericFuncDesc(\n            TypeInfoFactory.booleanTypeInfo, udf, children);\n    return executeTestModesAndVerify(\n        typeInfo, betweenInVariation, compareList, columns, columnNames, children,\n        udf, exprDesc,\n        randomRows, rowSource, batchSource, outputTypeInfo,\n        /* skipAdaptor */ false);\n  }\n  private boolean doBetweenStructInVariation(Random random, String structTypeName,\n      BetweenInVariation betweenInVariation)\n          throws Exception {\n    StructTypeInfo structTypeInfo =\n        (StructTypeInfo) TypeInfoUtils.getTypeInfoFromTypeString(structTypeName);\n    ObjectInspector structObjectInspector =\n        TypeInfoUtils.getStandardWritableObjectInspectorFromTypeInfo(\n            structTypeInfo);\n    final int valueCount = 10 + random.nextInt(10);\n    List<Object> valueList = new ArrayList<Object>(valueCount);\n    for (int i = 0; i < valueCount; i++) {\n      valueList.add(\n          VectorRandomRowSource.randomWritable(\n              random, structTypeInfo, structObjectInspector, DataTypePhysicalVariation.NONE,\n              /* allowNull */ false));\n    }\n    final boolean isInvert = false;\n    // No convenient WritableComparator / WritableComparable available for STRUCT.\n    List<Object> compareList = new ArrayList<Object>();\n    Set<Integer> includedSet = new HashSet<Integer>();\n    final int chooseLimit = 4 + random.nextInt(valueCount/2);\n    int chooseCount = 0;\n    while (chooseCount < chooseLimit) {\n      final int index = random.nextInt(valueCount);\n      if (includedSet.contains(index)) {\n        continue;\n      }\n      includedSet.add(index);\n      compareList.add(valueList.get(index));\n      chooseCount++;\n    }\n    //----------------------------------------------------------------------------------------------\n    GenerationSpec structGenerationSpec = GenerationSpec.createValueList(structTypeInfo, valueList);\n    List<GenerationSpec> structGenerationSpecList = new ArrayList<GenerationSpec>();\n    List<DataTypePhysicalVariation> structExplicitDataTypePhysicalVariationList =\n        new ArrayList<DataTypePhysicalVariation>();\n    structGenerationSpecList.add(structGenerationSpec);\n    structExplicitDataTypePhysicalVariationList.add(DataTypePhysicalVariation.NONE);\n    VectorRandomRowSource structRowSource = new VectorRandomRowSource();\n    structRowSource.initGenerationSpecSchema(\n        random, structGenerationSpecList, /* maxComplexDepth */ 0,\n        /* allowNull */ true, /* isUnicodeOk */ true,\n        structExplicitDataTypePhysicalVariationList);\n    Object[][] structRandomRows = structRowSource.randomRows(100000);\n    // ---------------------------------------------------------------------------------------------\n    List<GenerationSpec> generationSpecList = new ArrayList<GenerationSpec>();\n    List<DataTypePhysicalVariation> explicitDataTypePhysicalVariationList =\n        new ArrayList<DataTypePhysicalVariation>();\n    List<TypeInfo> fieldTypeInfoList = structTypeInfo.getAllStructFieldTypeInfos();\n    final int fieldCount = fieldTypeInfoList.size();\n    for (int i = 0; i < fieldCount; i++) {\n      GenerationSpec generationSpec = GenerationSpec.createOmitGeneration(fieldTypeInfoList.get(i));\n      generationSpecList.add(generationSpec);\n      explicitDataTypePhysicalVariationList.add(DataTypePhysicalVariation.NONE);\n    }\n    VectorRandomRowSource rowSource = new VectorRandomRowSource();\n    rowSource.initGenerationSpecSchema(\n        random, generationSpecList, /* maxComplexDepth */ 0,\n        /* allowNull */ true, /* isUnicodeOk */ true,\n        explicitDataTypePhysicalVariationList);\n    Object[][] randomRows = rowSource.randomRows(100000);\n    final int rowCount = randomRows.length;\n    for (int r = 0; r < rowCount; r++) {\n      List<Object> fieldValueList = (ArrayList) structRandomRows[r][0]; \n      for (int f = 0; f < fieldCount; f++) {\n        randomRows[r][f] = fieldValueList.get(f);\n      }\n    }\n    // ---------------------------------------------------------------------------------------------\n    // Currently, STRUCT IN vectorization assumes a GenericUDFStruct.\n    List<ObjectInspector> structUdfObjectInspectorList = new ArrayList<ObjectInspector>();\n    List<ExprNodeDesc> structUdfChildren = new ArrayList<ExprNodeDesc>(fieldCount);\n    List<String> rowColumnNameList = rowSource.columnNames();\n    for (int i = 0; i < fieldCount; i++) {\n      TypeInfo fieldTypeInfo = fieldTypeInfoList.get(i);\n      ExprNodeColumnDesc fieldExpr =\n          new ExprNodeColumnDesc(\n              fieldTypeInfo, rowColumnNameList.get(i), \"table\", false);\n      structUdfChildren.add(fieldExpr);\n      ObjectInspector fieldObjectInspector =\n          VectorRandomRowSource.getObjectInspector(fieldTypeInfo, DataTypePhysicalVariation.NONE);\n      structUdfObjectInspectorList.add(fieldObjectInspector);\n    }\n    StandardStructObjectInspector structUdfObjectInspector =\n        ObjectInspectorFactory.\n            getStandardStructObjectInspector(rowColumnNameList, structUdfObjectInspectorList);\n    String structUdfTypeName = structUdfObjectInspector.getTypeName();\n    TypeInfo structUdfTypeInfo = TypeInfoUtils.getTypeInfoFromTypeString(structUdfTypeName);\n    String structFuncText = \"struct\";\n    FunctionInfo fi = FunctionRegistry.getFunctionInfo(structFuncText);\n    GenericUDF genericUDF = fi.getGenericUDF();\n    ExprNodeDesc col1Expr =\n        new ExprNodeGenericFuncDesc(\n            structUdfObjectInspector, genericUDF, structFuncText, structUdfChildren);\n    // ---------------------------------------------------------------------------------------------\n    List<String> columns = new ArrayList<String>();\n    List<ExprNodeDesc> children = new ArrayList<ExprNodeDesc>();\n    children.add(col1Expr);\n    for (int i = 0; i < compareList.size(); i++) {\n      Object compareObject = compareList.get(i);\n      ExprNodeConstantDesc constDesc =\n          new ExprNodeConstantDesc(\n              structUdfTypeInfo,\n              VectorRandomRowSource.getNonWritableObject(\n                  compareObject, structUdfTypeInfo, structUdfObjectInspector));\n      children.add(constDesc);\n    }\n    for (int i = 0; i < fieldCount; i++) {\n      columns.add(rowColumnNameList.get(i));\n    }\n    String[] columnNames = columns.toArray(new String[0]);\n    VectorRandomBatchSource batchSource =\n        VectorRandomBatchSource.createInterestingBatches(\n            random,\n            rowSource,\n            randomRows,\n            null);\n    // ---------------------------------------------------------------------------------------------\n    final GenericUDF udf = new GenericUDFIn();\n    final int compareCount = compareList.size();\n    ObjectInspector[] argumentOIs = new ObjectInspector[compareCount];\n    for (int i = 0; i < compareCount; i++) {\n      argumentOIs[i] = structUdfObjectInspector;\n    }\n    final ObjectInspector outputObjectInspector = udf.initialize(argumentOIs);\n    TypeInfo outputTypeInfo = TypeInfoUtils.getTypeInfoFromObjectInspector(outputObjectInspector);\n    ExprNodeGenericFuncDesc exprDesc =\n        new ExprNodeGenericFuncDesc(\n            TypeInfoFactory.booleanTypeInfo, udf, children);\n    return executeTestModesAndVerify(\n        structUdfTypeInfo, betweenInVariation, compareList, columns, columnNames, children,\n        udf, exprDesc,\n        randomRows, rowSource, batchSource, outputTypeInfo,\n        /* skipAdaptor */ true);\n  }\n  private boolean executeTestModesAndVerify(TypeInfo typeInfo,\n      BetweenInVariation betweenInVariation, List<Object> compareList,\n      List<String> columns, String[] columnNames, List<ExprNodeDesc> children,\n      GenericUDF udf, ExprNodeGenericFuncDesc exprDesc,\n      Object[][] randomRows,\n      VectorRandomRowSource rowSource, VectorRandomBatchSource batchSource,\n      TypeInfo outputTypeInfo, boolean skipAdaptor)\n          throws Exception {\n    final int rowCount = randomRows.length;\n    Object[][] resultObjectsArray = new Object[BetweenInTestMode.count][];\n    for (int i = 0; i < BetweenInTestMode.count; i++) {\n      Object[] resultObjects = new Object[rowCount];\n      resultObjectsArray[i] = resultObjects;\n      BetweenInTestMode betweenInTestMode = BetweenInTestMode.values()[i];\n      switch (betweenInTestMode) {\n      case ROW_MODE:\n        if (!doRowCastTest(\n              typeInfo,\n              betweenInVariation,\n              compareList,\n              columns,\n              children,\n              udf, exprDesc,\n              randomRows,\n              rowSource.rowStructObjectInspector(),\n              resultObjects)) {\n          return false;\n        }\n        break;\n      case ADAPTOR:\n         if (skipAdaptor) {\n           continue;\n         }\n      case VECTOR_EXPRESSION:\n        if (!doVectorBetweenInTest(\n              typeInfo,\n              betweenInVariation,\n              compareList,\n              columns,\n              columnNames,\n              rowSource.typeInfos(),\n              rowSource.dataTypePhysicalVariations(),\n              children,\n              udf, exprDesc,\n              betweenInTestMode,\n              batchSource,\n              exprDesc.getWritableObjectInspector(),\n              outputTypeInfo,\n              resultObjects)) {\n          return false;\n        }\n        break;\n      default:\n        throw new RuntimeException(\"Unexpected IF statement test mode \" + betweenInTestMode);\n      }\n    }\n    for (int i = 0; i < rowCount; i++) {\n      // Row-mode is the expected value.\n      Object expectedResult = resultObjectsArray[0][i];\n      for (int v = 1; v < BetweenInTestMode.count; v++) {\n        BetweenInTestMode betweenInTestMode = BetweenInTestMode.values()[v];\n        if (skipAdaptor) {\n          continue;\n        }\n        Object vectorResult = resultObjectsArray[v][i];\n        if (betweenInVariation.isFilter &&\n            expectedResult == null &&\n            vectorResult != null) {\n          // This is OK.\n          boolean vectorBoolean = ((BooleanWritable) vectorResult).get();\n          if (vectorBoolean) {\n            Assert.fail(\n                \"Row \" + i +\n                \" typeName \" + typeInfo.getTypeName() +\n                \" outputTypeName \" + outputTypeInfo.getTypeName() +\n                \" \" + betweenInVariation +\n                \" \" + betweenInTestMode +\n                \" result is NOT NULL and true\" +\n                \" does not match row-mode expected result is NULL which means false here\" +\n                \" row values \" + Arrays.toString(randomRows[i]) +\n                \" exprDesc \" + exprDesc.toString());\n          }\n        } else if (expectedResult == null || vectorResult == null) {\n          if (expectedResult != null || vectorResult != null) {\n            Assert.fail(\n                \"Row \" + i +\n                \" sourceTypeName \" + typeInfo.getTypeName() +\n                \" \" + betweenInVariation +\n                \" \" + betweenInTestMode +\n                \" result is NULL \" + (vectorResult == null ? \"YES\" : \"NO result \" + vectorResult.toString()) +\n                \" does not match row-mode expected result is NULL \" +\n                (expectedResult == null ? \"YES\" : \"NO result \" + expectedResult.toString()) +\n                \" row values \" + Arrays.toString(randomRows[i]) +\n                \" exprDesc \" + exprDesc.toString());\n          }\n        } else {\n          if (!expectedResult.equals(vectorResult)) {\n            Assert.fail(\n                \"Row \" + i +\n                \" sourceTypeName \" + typeInfo.getTypeName() +\n                \" \" + betweenInVariation +\n                \" \" + betweenInTestMode +\n                \" result \" + vectorResult.toString() +\n                \" (\" + vectorResult.getClass().getSimpleName() + \")\" +\n                \" does not match row-mode expected result \" + expectedResult.toString() +\n                \" (\" + expectedResult.getClass().getSimpleName() + \")\" +\n                \" row values \" + Arrays.toString(randomRows[i]) +\n                \" exprDesc \" + exprDesc.toString());\n          }\n        }\n      }\n    }\n    return true;\n  }\n  private boolean doRowCastTest(TypeInfo typeInfo,\n      BetweenInVariation betweenInVariation, List<Object> compareList,\n      List<String> columns, List<ExprNodeDesc> children,\n      GenericUDF udf, ExprNodeGenericFuncDesc exprDesc,\n      Object[][] randomRows,\n      ObjectInspector rowInspector, Object[] resultObjects)\n          throws Exception {\n    /*\n    System.out.println(\n        \"*DEBUG* typeInfo \" + typeInfo.toString() +\n        \" targetTypeInfo \" + targetTypeInfo +\n        \" betweenInTestMode ROW_MODE\" +\n        \" exprDesc \" + exprDesc.toString());\n    */\n    HiveConf hiveConf = new HiveConf();\n    ExprNodeEvaluator evaluator =\n        ExprNodeEvaluatorFactory.get(exprDesc, hiveConf);\n    evaluator.initialize(rowInspector);\n    final int rowCount = randomRows.length;\n    for (int i = 0; i < rowCount; i++) {\n      Object[] row = randomRows[i];\n      Object result = evaluator.evaluate(row);\n      Object copyResult =\n          ObjectInspectorUtils.copyToStandardObject(\n              result, PrimitiveObjectInspectorFactory.writableBooleanObjectInspector,\n              ObjectInspectorCopyOption.WRITABLE);\n      resultObjects[i] = copyResult;\n    }\n    return true;\n  }\n  private void extractResultObjects(VectorizedRowBatch batch, int rowIndex,\n      VectorExtractRow resultVectorExtractRow, Object[] scrqtchRow,\n      ObjectInspector objectInspector, Object[] resultObjects) {\n    boolean selectedInUse = batch.selectedInUse;\n    int[] selected = batch.selected;\n    for (int logicalIndex = 0; logicalIndex < batch.size; logicalIndex++) {\n      final int batchIndex = (selectedInUse ? selected[logicalIndex] : logicalIndex);\n      resultVectorExtractRow.extractRow(batch, batchIndex, scrqtchRow);\n      Object copyResult =\n          ObjectInspectorUtils.copyToStandardObject(\n              scrqtchRow[0], objectInspector, ObjectInspectorCopyOption.WRITABLE);\n      resultObjects[rowIndex++] = copyResult;\n    }\n  }\n  private boolean doVectorBetweenInTest(TypeInfo typeInfo,\n      BetweenInVariation betweenInVariation, List<Object> compareList,\n      List<String> columns, String[] columnNames,\n      TypeInfo[] typeInfos, DataTypePhysicalVariation[] dataTypePhysicalVariations,\n      List<ExprNodeDesc> children,\n      GenericUDF udf, ExprNodeGenericFuncDesc exprDesc,\n      BetweenInTestMode betweenInTestMode,\n      VectorRandomBatchSource batchSource,\n      ObjectInspector objectInspector,\n      TypeInfo outputTypeInfo, Object[] resultObjects)\n          throws Exception {\n    HiveConf hiveConf = new HiveConf();\n    if (betweenInTestMode == BetweenInTestMode.ADAPTOR) {\n      hiveConf.setBoolVar(HiveConf.ConfVars.HIVE_TEST_VECTOR_ADAPTOR_OVERRIDE, true);\n    }\n    final boolean isFilter = betweenInVariation.isFilter;\n    VectorizationContext vectorizationContext =\n        new VectorizationContext(\n            \"name\",\n            columns,\n            Arrays.asList(typeInfos),\n            Arrays.asList(dataTypePhysicalVariations),\n            hiveConf);\n    VectorExpression vectorExpression =\n        vectorizationContext.getVectorExpression(exprDesc,\n            (isFilter ?\n                VectorExpressionDescriptor.Mode.FILTER :\n                VectorExpressionDescriptor.Mode.PROJECTION));\n    vectorExpression.transientInit(hiveConf);\n    if (betweenInTestMode == BetweenInTestMode.VECTOR_EXPRESSION) {\n      String vecExprString = vectorExpression.toString();\n      if (vectorExpression instanceof VectorUDFAdaptor) {\n        System.out.println(\n            \"*NO NATIVE VECTOR EXPRESSION* typeInfo \" + typeInfo.toString() +\n            \" betweenInTestMode \" + betweenInTestMode +\n            \" betweenInVariation \" + betweenInVariation +\n            \" vectorExpression \" + vecExprString);\n      } else if (dataTypePhysicalVariations[0] == DataTypePhysicalVariation.DECIMAL_64) {\n        final String nameToCheck = vectorExpression.getClass().getSimpleName();\n        if (!nameToCheck.contains(\"Decimal64\")) {\n          System.out.println(\n              \"*EXPECTED DECIMAL_64 VECTOR EXPRESSION* typeInfo \" + typeInfo.toString() +\n              \" betweenInTestMode \" + betweenInTestMode +\n              \" betweenInVariation \" + betweenInVariation +\n              \" vectorExpression \" + vecExprString);\n        }\n      }\n    }\n    // System.out.println(\"*VECTOR EXPRESSION* \" + vectorExpression.getClass().getSimpleName());\n    /*\n    System.out.println(\n        \"*DEBUG* typeInfo \" + typeInfo.toString() +\n        \" betweenInTestMode \" + betweenInTestMode +\n        \" betweenInVariation \" + betweenInVariation +\n        \" vectorExpression \" + vectorExpression.toString());\n    */\n    VectorRandomRowSource rowSource = batchSource.getRowSource();\n    VectorizedRowBatchCtx batchContext =\n        new VectorizedRowBatchCtx(\n            columnNames,\n            rowSource.typeInfos(),\n            rowSource.dataTypePhysicalVariations(),\n            /* dataColumnNums */ null,\n            /* partitionColumnCount */ 0,\n            /* virtualColumnCount */ 0,\n            /* neededVirtualColumns */ null,\n            vectorizationContext.getScratchColumnTypeNames(),\n            vectorizationContext.getScratchDataTypePhysicalVariations());\n    VectorizedRowBatch batch = batchContext.createVectorizedRowBatch();\n    VectorExtractRow resultVectorExtractRow = null;\n    Object[] scrqtchRow = null;\n    if (!isFilter) {\n      resultVectorExtractRow = new VectorExtractRow();\n      final int outputColumnNum = vectorExpression.getOutputColumnNum();\n      resultVectorExtractRow.init(\n          new TypeInfo[] { outputTypeInfo }, new int[] { outputColumnNum });\n      scrqtchRow = new Object[1];\n    }\n    boolean copySelectedInUse = false;\n    int[] copySelected = new int[VectorizedRowBatch.DEFAULT_SIZE];\n    batchSource.resetBatchIteration();\n    int rowIndex = 0;\n    while (true) {\n      if (!batchSource.fillNextBatch(batch)) {\n        break;\n      }\n      final int originalBatchSize = batch.size;\n      if (isFilter) {\n        copySelectedInUse = batch.selectedInUse;\n        if (batch.selectedInUse) {\n          System.arraycopy(batch.selected, 0, copySelected, 0, originalBatchSize);\n        }\n      }\n      // In filter mode, the batch size can be made smaller.\n      vectorExpression.evaluate(batch);\n      if (!isFilter) {\n        extractResultObjects(batch, rowIndex, resultVectorExtractRow, scrqtchRow,\n            objectInspector, resultObjects);\n      } else {\n        final int currentBatchSize = batch.size;\n        if (copySelectedInUse && batch.selectedInUse) {\n          int selectIndex = 0;\n          for (int i = 0; i < originalBatchSize; i++) {\n            final int originalBatchIndex = copySelected[i];\n            final boolean booleanResult;\n            if (selectIndex < currentBatchSize && batch.selected[selectIndex] == originalBatchIndex) {\n              booleanResult = true;\n              selectIndex++;\n            } else {\n              booleanResult = false;\n            }\n            resultObjects[rowIndex + i] = new BooleanWritable(booleanResult);\n          }\n        } else if (batch.selectedInUse) {\n          int selectIndex = 0;\n          for (int i = 0; i < originalBatchSize; i++) {\n            final boolean booleanResult;\n            if (selectIndex < currentBatchSize && batch.selected[selectIndex] == i) {\n              booleanResult = true;\n              selectIndex++;\n            } else {\n              booleanResult = false;\n            }\n            resultObjects[rowIndex + i] = new BooleanWritable(booleanResult);\n          }\n        } else if (currentBatchSize == 0) {\n          // Whole batch got zapped.\n          for (int i = 0; i < originalBatchSize; i++) {\n            resultObjects[rowIndex + i] = new BooleanWritable(false);\n          }\n        } else {\n          // Every row kept.\n          for (int i = 0; i < originalBatchSize; i++) {\n            resultObjects[rowIndex + i] = new BooleanWritable(true);\n          }\n        }\n      }\n      rowIndex += originalBatchSize;\n    }\n    return true;\n  }\n"]], "pred": {"ppl": 1.5561834573745728, "ppl_lower": 1.7058380842208862, "ppl/lowercase_ppl": -1.2076270274347707, "ppl/zlib": 7.529990158406103e-05, "Min_5.0% Prob": 4.9698766680324775, "Min_10.0% Prob": 3.5370905703189326, "Min_20.0% Prob": 2.1558377419908843, "Min_30.0% Prob": 1.4700055631498496, "Min_40.0% Prob": 1.1039128749765692, "Min_50.0% Prob": 0.8846242251138908, "Min_60.0% Prob": 0.73780656897529}}
{"hexsha": "3029540e11c24534ecc057af01ba0fd4a2da95fd", "ext": "java", "lang": "Java", "content": "@SpringBootApplication\n@CommonsLog\npublic class EventServer {\n\n\tpublic static void main(String[] args) {\n\t\tnew SpringApplicationBuilder(EventServer.class).web(WebApplicationType.NONE).build().run(args);\n\t}\n\n\t@Bean\n\tpublic ApplicationRunner runner(CustomerRepository customerRepository, OrderRepository orderRepository,\n\t\t\tProductRepository productRepository, OrderProductSummaryRepository orderProductSummaryRepository,\n\t\t\t@Qualifier(\"Products\") Region<Long, Product> products) {\n\t\treturn args -> {\n\t\t\tcreateCustomerData(customerRepository);\n\n\t\t\tcreateProducts(productRepository);\n\n\t\t\tcreateOrders(productRepository, orderRepository);\n\n\t\t\tlog.info(\"Completed creating orders \");\n\n\t\t\tvar allForProductID = orderProductSummaryRepository.findAllForProductID(3L);\n\t\t\tallForProductID.forEach(orderProductSummary -> log.info(\"orderProductSummary = \" + orderProductSummary));\n\t\t};\n\t}\n\n\tprivate void createOrders(ProductRepository productRepository, OrderRepository orderRepository) {\n\t\tvar random = new Random(System.nanoTime());\n\t\tvar address = new Address(\"it\", \"doesn't\", \"matter\");\n\t\tLongStream.rangeClosed(1, 10).forEach((orderId) -> LongStream.rangeClosed(1, 300).forEach((customerId) -> {\n\t\t\tvar order = new Order(orderId, customerId, address);\n\t\t\tIntStream.rangeClosed(0, random.nextInt(3) + 1).forEach((lineItemCount) -> {\n\t\t\t\tvar quantity = random.nextInt(3) + 1;\n\t\t\t\tlong productId = random.nextInt(3) + 1;\n\t\t\t\torder.add(new LineItem(productRepository.findById(productId).get(), quantity));\n\t\t\t});\n\t\t\torderRepository.save(order);\n\t\t}));\n\t}\n\n\tprivate void createProducts(ProductRepository productRepository) {\n\t\tproductRepository.save(new Product(1L, \"Apple iPod\", new BigDecimal(\"99.99\"), \"An Apple portable music player\"));\n\t\tproductRepository.save(new Product(2L, \"Apple iPad\", new BigDecimal(\"499.99\"), \"An Apple tablet device\"));\n\t\tvar macbook = new Product(3L, \"Apple macBook\", new BigDecimal(\"899.99\"), \"An Apple notebook computer\");\n\t\tmacbook.addAttribute(\"warranty\", \"included\");\n\t\tproductRepository.save(macbook);\n\t}\n\n\tprivate void createCustomerData(CustomerRepository customerRepository) {\n\t\tLongStream.rangeClosed(0, 300).parallel().forEach(customerId -> customerRepository.save(\n\t\t\t\tnew Customer(customerId, new EmailAddress(customerId + \"@2.com\"), \"John\" + customerId, \"Smith\" + customerId)));\n\t}\n}", "item_id": 0, "repo": "Balkerm/spring-data-examples", "file": "geode/events/src/main/java/example/springdata/geode/server/events/EventServer.java", "last_update_at": "2022-03-30T13:37:02+00:00", "question_id": "3029540e11c24534ecc057af01ba0fd4a2da95fd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SpringBootApplication\n@CommonsLog\npublic class EventServer {\n\tpublic static void main(String[] args) {\n\t\tnew SpringApplicationBuilder(EventServer.class).web(WebApplicationType.NONE).build().run(args);\n\t}\n\t@Bean\n\tpublic ApplicationRunner runner(CustomerRepository customerRepository, OrderRepository orderRepository,\n\t\t\tProductRepository productRepository, OrderProductSummaryRepository orderProductSummaryRepository,\n\t\t\t@Qualifier(\"Products\") Region<Long, Product> products) {\n\t\treturn args -> {\n\t\t\tcreateCustomerData(customerRepository);\n\t\t\tcreateProducts(productRepository);\n\t\t\tcreateOrders(productRepository, orderRepository);\n\t\t\tlog.info(\"Completed creating orders \");\n\t\t\tvar allForProductID = orderProductSummaryRepository.findAllForProductID(3L);\n\t\t\tallForProductID.forEach(orderProductSummary -> log.info(\"orderProductSummary = \" + orderProductSummary));\n\t\t};\n\t}\n\tprivate void createOrders(ProductRepository productRepository, OrderRepository orderRepository) {\n\t\tvar random = new Random(System.nanoTime());\n\t\tvar address = new Address(\"it\", \"doesn't\", \"matter\");\n\t\tLongStream.rangeClosed(1, 10).forEach((orderId) -> LongStream.rangeClosed(1, 300).forEach((customerId) -> {\n\t\t\tvar order = new Order(orderId, customerId, address);\n\t\t\tIntStream.rangeClosed(0, random.nextInt(3) + 1).forEach((lineItemCount) -> {\n\t\t\t\tvar quantity = random.nextInt(3) + 1;\n\t\t\t\tlong productId = random.nextInt(3) + 1;\n\t\t\t\torder.add(new LineItem(productRepository.findById(productId).get(), quantity));\n\t\t\t});\n\t\t\torderRepository.save(order);\n\t\t}));\n\t}\n\tprivate void createProducts(ProductRepository productRepository) {\n\t\tproductRepository.save(new Product(1L, \"Apple iPod\", new BigDecimal(\"99.99\"), \"An Apple portable music player\"));\n\t\tproductRepository.save(new Product(2L, \"Apple iPad\", new BigDecimal(\"499.99\"), \"An Apple tablet device\"));\n\t\tvar macbook = new Product(3L, \"Apple macBook\", new BigDecimal(\"899.99\"), \"An Apple notebook computer\");\n\t\tmacbook.addAttribute(\"warranty\", \"included\");\n\t\tproductRepository.save(macbook);\n\t}\n\tprivate void createCustomerData(CustomerRepository customerRepository) {\n\t\tLongStream.rangeClosed(0, 300).parallel().forEach(customerId -> customerRepository.save(\n\t\t\t\tnew Customer(customerId, new EmailAddress(customerId + \"@2.com\"), \"John\" + customerId, \"Smith\" + customerId)));\n\t}\n"]], "pred": {"ppl": 2.116544246673584, "ppl_lower": 2.3576066493988037, "ppl/lowercase_ppl": -1.143857681364895, "ppl/zlib": 0.0008738749258120136, "Min_5.0% Prob": 7.217816720690046, "Min_10.0% Prob": 5.192117731336137, "Min_20.0% Prob": 3.3392496446629503, "Min_30.0% Prob": 2.400965562809345, "Min_40.0% Prob": 1.8498385759907732, "Min_50.0% Prob": 1.4938853302436121, "Min_60.0% Prob": 1.249026033346673}}
{"hexsha": "dc861f96f26b009c1a139b0cb1b2c0f2ffc06848", "ext": "java", "lang": "Java", "content": "public class RoboportRendering extends EntityRendererFactory {\r\n\t@Override\r\n\tpublic void createRenderers(Consumer<Renderer> register, WorldMap map, DataTable dataTable, BlueprintEntity entity,\r\n\t\t\tEntityPrototype prototype) {\r\n\t\tregister.accept(RenderUtils.spriteRenderer(RenderUtils.getSpritesFromAnimation(prototype.lua().get(\"base\")),\r\n\t\t\t\tentity, prototype));\r\n\t\tregister.accept(RenderUtils.spriteRenderer(\r\n\t\t\t\tRenderUtils.getSpriteFromAnimation(prototype.lua().get(\"door_animation_down\")), entity, prototype));\r\n\t\tregister.accept(RenderUtils.spriteRenderer(\r\n\t\t\t\tRenderUtils.getSpriteFromAnimation(prototype.lua().get(\"door_animation_up\")), entity, prototype));\r\n\t}\r\n}", "item_id": 0, "repo": "acid1103/Factorio-FBSR", "file": "FactorioBlueprintStringRenderer/src/com/demod/fbsr/entity/RoboportRendering.java", "last_update_at": "2022-03-26T08:15:23+00:00", "question_id": "dc861f96f26b009c1a139b0cb1b2c0f2ffc06848_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RoboportRendering extends EntityRendererFactory {\r\n\t@Override\r\n\tpublic void createRenderers(Consumer<Renderer> register, WorldMap map, DataTable dataTable, BlueprintEntity entity,\r\n\t\t\tEntityPrototype prototype) {\r\n\t\tregister.accept(RenderUtils.spriteRenderer(RenderUtils.getSpritesFromAnimation(prototype.lua().get(\"base\")),\r\n\t\t\t\tentity, prototype));\r\n\t\tregister.accept(RenderUtils.spriteRenderer(\r\n\t\t\t\tRenderUtils.getSpriteFromAnimation(prototype.lua().get(\"door_animation_down\")), entity, prototype));\r\n\t\tregister.accept(RenderUtils.spriteRenderer(\r\n\t\t\t\tRenderUtils.getSpriteFromAnimation(prototype.lua().get(\"door_animation_up\")), entity, prototype));\r\n\t}\r\n"]], "pred": {"ppl": 2.9042551517486572, "ppl_lower": 3.8437552452087402, "ppl/lowercase_ppl": -1.2628764957982466, "ppl/zlib": 0.004069377691890449, "Min_5.0% Prob": 7.602754783630371, "Min_10.0% Prob": 6.0747571110725405, "Min_20.0% Prob": 4.46574818789959, "Min_30.0% Prob": 3.365428392092387, "Min_40.0% Prob": 2.6278841754421594, "Min_50.0% Prob": 2.1256383945047856, "Min_60.0% Prob": 1.7758099236991256}}
{"hexsha": "d5e047a7c49ab7607e2670476d0df4ef99587ae1", "ext": "java", "lang": "Java", "content": "public class ClojureMonoidAggregator extends BaseOperation<Tuple> implements Aggregator<Tuple> {\n  private final CombinerSpec combinerSpec;\n  private transient IFn prepareFn;\n  private transient IFn combineFn;\n  private transient IFn presentFn;\n\n  public ClojureMonoidAggregator(Fields fields, CombinerSpec combinerSpec) {\n    super(fields);\n    this.combinerSpec = combinerSpec;\n  }\n\n  @Override\n  public void prepare(FlowProcess flowProcess, OperationCall<Tuple> operationCall) {\n    prepareFn = combinerSpec.getPrepareFn();\n    combineFn = combinerSpec.getCombineFn();\n    presentFn = combinerSpec.getPresentFn();\n  }\n\n  public void start(FlowProcess fp, AggregatorCall<Tuple> call) {\n    call.setContext(null);\n  }\n\n  public void aggregate(FlowProcess fp, AggregatorCall<Tuple> call) {\n    ISeq fnArgs = RT.seq(Util.tupleToList(call.getArguments()));\n    if (null != prepareFn) {\n      fnArgs = RT.seq(Util.coerceToList(prepareFn.applyTo(fnArgs)));\n    }\n    Tuple context = call.getContext();\n\n    if (null == context) {\n      Tuple newContext = Tuple.size(1);\n      newContext.set(0, fnArgs);\n      call.setContext(newContext);\n    } else {\n      ISeq acc = (ISeq) context.getObject(0);\n      ISeq ret = RT.seq(Util.coerceToList(combineFn.applyTo(Util.cat(acc, fnArgs))));\n      context.set(0, ret);\n    }\n  }\n\n  public void complete(FlowProcess flowProcess, AggregatorCall<Tuple> call) {\n    Tuple context = call.getContext();\n\n    if (null == context) {\n      throw new RuntimeException(\"ClojureMonoidAggregator completed with any aggregate calls\");\n    } else {\n      ISeq finalValue = (ISeq) context.getObject(0);\n      call.setContext(null);\n      if (null != presentFn) {\n        call.getOutputCollector().add(\n            Util.coerceToTuple(presentFn.applyTo(finalValue)));\n      } else {\n        call.getOutputCollector().add(\n            Util.coerceToTuple(finalValue));\n      }\n    }\n  }\n}", "item_id": 0, "repo": "nightlord/cascalog", "file": "cascalog-core/src/java/cascalog/aggregator/ClojureMonoidAggregator.java", "last_update_at": "2022-03-27T13:50:30+00:00", "question_id": "d5e047a7c49ab7607e2670476d0df4ef99587ae1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ClojureMonoidAggregator extends BaseOperation<Tuple> implements Aggregator<Tuple> {\n  private final CombinerSpec combinerSpec;\n  private transient IFn prepareFn;\n  private transient IFn combineFn;\n  private transient IFn presentFn;\n  public ClojureMonoidAggregator(Fields fields, CombinerSpec combinerSpec) {\n    super(fields);\n    this.combinerSpec = combinerSpec;\n  }\n  @Override\n  public void prepare(FlowProcess flowProcess, OperationCall<Tuple> operationCall) {\n    prepareFn = combinerSpec.getPrepareFn();\n    combineFn = combinerSpec.getCombineFn();\n    presentFn = combinerSpec.getPresentFn();\n  }\n  public void start(FlowProcess fp, AggregatorCall<Tuple> call) {\n    call.setContext(null);\n  }\n  public void aggregate(FlowProcess fp, AggregatorCall<Tuple> call) {\n    ISeq fnArgs = RT.seq(Util.tupleToList(call.getArguments()));\n    if (null != prepareFn) {\n      fnArgs = RT.seq(Util.coerceToList(prepareFn.applyTo(fnArgs)));\n    }\n    Tuple context = call.getContext();\n    if (null == context) {\n      Tuple newContext = Tuple.size(1);\n      newContext.set(0, fnArgs);\n      call.setContext(newContext);\n    } else {\n      ISeq acc = (ISeq) context.getObject(0);\n      ISeq ret = RT.seq(Util.coerceToList(combineFn.applyTo(Util.cat(acc, fnArgs))));\n      context.set(0, ret);\n    }\n  }\n  public void complete(FlowProcess flowProcess, AggregatorCall<Tuple> call) {\n    Tuple context = call.getContext();\n    if (null == context) {\n      throw new RuntimeException(\"ClojureMonoidAggregator completed with any aggregate calls\");\n    } else {\n      ISeq finalValue = (ISeq) context.getObject(0);\n      call.setContext(null);\n      if (null != presentFn) {\n        call.getOutputCollector().add(\n            Util.coerceToTuple(presentFn.applyTo(finalValue)));\n      } else {\n        call.getOutputCollector().add(\n            Util.coerceToTuple(finalValue));\n      }\n    }\n  }\n"]], "pred": {"ppl": 1.716052532196045, "ppl_lower": 2.10011887550354, "ppl/lowercase_ppl": -1.3739951543067666, "ppl/zlib": 0.0008955665236568083, "Min_5.0% Prob": 6.08616730372111, "Min_10.0% Prob": 4.264301081172755, "Min_20.0% Prob": 2.5513339330994986, "Min_30.0% Prob": 1.7763646158754178, "Min_40.0% Prob": 1.3440725850471393, "Min_50.0% Prob": 1.0777534426782618, "Min_60.0% Prob": 0.9008283610417833}}
{"hexsha": "86f2ef044808995e336c2728739bcfbb46364372", "ext": "java", "lang": "Java", "content": "public class IP {\n    public static void main(String[] args) throws IOException {\n\n        isInSameSubnet();\n    }\n\n    public static void isInSameSubnet() throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String str;\n        while ((str = reader.readLine()) != null) {\n            String[] mask = str.split(\"\\\\.\");\n            String[] ip1 = reader.readLine().split(\"\\\\.\");\n            String[] ip2 = reader.readLine().split(\"\\\\.\");\n            int result = 0;\n            for (int i = 0; i < 4; i++) {\n                int maskSec = Integer.valueOf(mask[i]);\n                int ip1Sec = Integer.valueOf(ip1[i]);\n                int ip2Sec = Integer.valueOf(ip2[i]);\n                if (maskSec < 0 || maskSec > 255 || ip1Sec < 0 || ip1Sec > 255 || ip2Sec < 0 || ip2Sec > 255) {\n                    result = 1;\n                    break;\n                }\n                if ((maskSec & ip1Sec) != (maskSec & ip2Sec)) {\n                    result = 2;\n                }\n            }\n            System.out.println(result);\n        }\n    }\n}", "item_id": 0, "repo": "fcmfcm01/algorithmsInJava", "file": "src/main/java/org/fcm/alg/example/pkg/IP.java", "last_update_at": "2022-03-31T20:51:46+00:00", "question_id": "86f2ef044808995e336c2728739bcfbb46364372_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IP {\n    public static void main(String[] args) throws IOException {\n        isInSameSubnet();\n    }\n    public static void isInSameSubnet() throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String str;\n        while ((str = reader.readLine()) != null) {\n            String[] mask = str.split(\"\\\\.\");\n            String[] ip1 = reader.readLine().split(\"\\\\.\");\n            String[] ip2 = reader.readLine().split(\"\\\\.\");\n            int result = 0;\n            for (int i = 0; i < 4; i++) {\n                int maskSec = Integer.valueOf(mask[i]);\n                int ip1Sec = Integer.valueOf(ip1[i]);\n                int ip2Sec = Integer.valueOf(ip2[i]);\n                if (maskSec < 0 || maskSec > 255 || ip1Sec < 0 || ip1Sec > 255 || ip2Sec < 0 || ip2Sec > 255) {\n                    result = 1;\n                    break;\n                }\n                if ((maskSec & ip1Sec) != (maskSec & ip2Sec)) {\n                    result = 2;\n                }\n            }\n            System.out.println(result);\n        }\n    }\n"]], "pred": {"ppl": 1.543293833732605, "ppl_lower": 1.7895928621292114, "ppl/lowercase_ppl": -1.341236871922113, "ppl/zlib": 0.0011154729702023969, "Min_5.0% Prob": 5.183936685323715, "Min_10.0% Prob": 3.4470114409923553, "Min_20.0% Prob": 2.0575225222855806, "Min_30.0% Prob": 1.424475992952163, "Min_40.0% Prob": 1.0836616208107444, "Min_50.0% Prob": 0.8656028962133001, "Min_60.0% Prob": 0.7232044676627597}}
{"hexsha": "8253a791e88172fbfca883a7bf801c25f6ddac85", "ext": "java", "lang": "Java", "content": "public class TextComponentCaretModel implements CaretModel {\n  private final JTextComponent myTextComponent;\n  private final TextComponentEditor myEditor;\n  private final Caret myCaret;\n  private final EventDispatcher<CaretActionListener> myCaretActionListeners = EventDispatcher.create(CaretActionListener.class);\n\n  public TextComponentCaretModel(@Nonnull JTextComponent textComponent, @Nonnull TextComponentEditor editor) {\n    myTextComponent = textComponent;\n    myEditor = editor;\n    myCaret = new TextComponentCaret(editor);\n  }\n\n  @Override\n  public void moveCaretRelatively(final int columnShift, final int lineShift, final boolean withSelection, final boolean blockSelection, final boolean scrollToCaret) {\n    if (lineShift == 0 && !withSelection && !blockSelection && !scrollToCaret) {\n      moveToOffset(getOffset() + columnShift);\n      return;\n    }\n    throw new UnsupportedOperationException(\"Not implemented\");\n  }\n\n  @Override\n  public void moveToLogicalPosition(@Nonnull final LogicalPosition pos) {\n    moveToOffset(myEditor.logicalPositionToOffset(pos), false);\n  }\n\n  @Override\n  public void moveToVisualPosition(@Nonnull final VisualPosition pos) {\n    moveToLogicalPosition(myEditor.visualToLogicalPosition(pos));\n  }\n\n  @Override\n  public void moveToOffset(int offset) {\n    moveToOffset(offset, false);\n  }\n\n  @Override\n  public void moveToOffset(final int offset, boolean locateBeforeSoftWrap) {\n    int targetOffset = Math.min(offset, myTextComponent.getText().length());\n    int currentPosition = myTextComponent.getCaretPosition();\n    // We try to preserve selection, to match EditorImpl behaviour.\n    // It's only possible though, if target offset is located at either end of existing selection.\n    if (targetOffset != currentPosition) {\n      if (targetOffset == myTextComponent.getCaret().getMark()) {\n        myTextComponent.setCaretPosition(currentPosition);\n        myTextComponent.moveCaretPosition(targetOffset);\n      }\n      else {\n        myTextComponent.setCaretPosition(targetOffset);\n      }\n    }\n  }\n\n  @Override\n  public boolean isUpToDate() {\n    return true;\n  }\n\n  @Override\n  @Nonnull\n  public LogicalPosition getLogicalPosition() {\n    int caretPos = myTextComponent.getCaretPosition();\n    int line;\n    int lineStart;\n    if (myTextComponent instanceof JTextArea) {\n      final JTextArea textArea = (JTextArea)myTextComponent;\n      try {\n        line = textArea.getLineOfOffset(caretPos);\n        lineStart = textArea.getLineStartOffset(line);\n      }\n      catch (BadLocationException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    else {\n      line = 0;\n      lineStart = 0;\n    }\n    return new LogicalPosition(line, caretPos - lineStart);\n  }\n\n  @Override\n  @Nonnull\n  public VisualPosition getVisualPosition() {\n    LogicalPosition pos = getLogicalPosition();\n    return new VisualPosition(pos.line, pos.column);\n  }\n\n  @Override\n  public int getOffset() {\n    return myTextComponent.getCaretPosition();\n  }\n\n  @Override\n  public void addCaretListener(@Nonnull final CaretListener listener) {\n    throw new UnsupportedOperationException(\"Not implemented\");\n  }\n\n  @Override\n  public void removeCaretListener(@Nonnull final CaretListener listener) {\n    throw new UnsupportedOperationException(\"Not implemented\");\n  }\n\n  @Override\n  public int getVisualLineStart() {\n    return 0;\n  }\n\n  @Override\n  public int getVisualLineEnd() {\n    return 0;\n  }\n\n  @Override\n  public TextAttributes getTextAttributes() {\n    return null;\n  }\n\n  @Override\n  public boolean supportsMultipleCarets() {\n    return false;\n  }\n\n  @Nonnull\n  @Override\n  public Caret getCurrentCaret() {\n    return myCaret;\n  }\n\n  @Nonnull\n  @Override\n  public Caret getPrimaryCaret() {\n    return myCaret;\n  }\n\n  @Override\n  public int getCaretCount() {\n    return 1;\n  }\n\n  @Nonnull\n  @Override\n  public List<Caret> getAllCarets() {\n    return Collections.singletonList(myCaret);\n  }\n\n  @Nullable\n  @Override\n  public Caret getCaretAt(@Nonnull VisualPosition pos) {\n    return myCaret.getVisualPosition().equals(pos) ? myCaret : null;\n  }\n\n  @Nullable\n  @Override\n  public Caret addCaret(@Nonnull VisualPosition pos) {\n    return null;\n  }\n\n  @Nullable\n  @Override\n  public Caret addCaret(@Nonnull VisualPosition pos, boolean makePrimary) {\n    return null;\n  }\n\n  @Override\n  public boolean removeCaret(@Nonnull Caret caret) {\n    return false;\n  }\n\n  @Override\n  public void removeSecondaryCarets() {\n  }\n\n  @Override\n  public void setCaretsAndSelections(@Nonnull List<? extends CaretState> caretStates) {\n    if (caretStates.size() != 1) throw new IllegalArgumentException(\"Exactly one CaretState object must be passed\");\n    CaretState state = caretStates.get(0);\n    if (state != null) {\n      if (state.getCaretPosition() != null) moveToLogicalPosition(state.getCaretPosition());\n      if (state.getSelectionStart() != null && state.getSelectionEnd() != null) {\n        myEditor.getSelectionModel().setSelection(myEditor.logicalPositionToOffset(state.getSelectionStart()), myEditor.logicalPositionToOffset(state.getSelectionEnd()));\n      }\n    }\n  }\n\n  @Override\n  public void setCaretsAndSelections(@Nonnull List<? extends CaretState> caretStates, boolean updateSystemSelection) {\n    setCaretsAndSelections(caretStates);\n  }\n\n  @Nonnull\n  @Override\n  public List<CaretState> getCaretsAndSelections() {\n    return Collections.singletonList(new CaretState(getLogicalPosition(), myEditor.offsetToLogicalPosition(myEditor.getSelectionModel().getSelectionStart()),\n                                                    myEditor.offsetToLogicalPosition(myEditor.getSelectionModel().getSelectionEnd())));\n  }\n\n  @Override\n  public void runForEachCaret(@Nonnull CaretAction action) {\n    myCaretActionListeners.getMulticaster().beforeAllCaretsAction();\n    action.perform(myCaret);\n    myCaretActionListeners.getMulticaster().afterAllCaretsAction();\n  }\n\n  @Override\n  public void runForEachCaret(@Nonnull CaretAction action, boolean reverseOrder) {\n    runForEachCaret(action);\n  }\n\n  @Override\n  public void addCaretActionListener(@Nonnull CaretActionListener listener, @Nonnull Disposable disposable) {\n    myCaretActionListeners.addListener(listener, disposable);\n  }\n\n  @Override\n  public void runBatchCaretOperation(@Nonnull Runnable runnable) {\n    runnable.run();\n  }\n}", "item_id": 0, "repo": "halotroop2288/consulo", "file": "modules/base/platform-impl/src/main/java/com/intellij/openapi/editor/textarea/TextComponentCaretModel.java", "last_update_at": "2022-03-22T11:42:50+00:00", "question_id": "8253a791e88172fbfca883a7bf801c25f6ddac85_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TextComponentCaretModel implements CaretModel {\n  private final JTextComponent myTextComponent;\n  private final TextComponentEditor myEditor;\n  private final Caret myCaret;\n  private final EventDispatcher<CaretActionListener> myCaretActionListeners = EventDispatcher.create(CaretActionListener.class);\n  public TextComponentCaretModel(@Nonnull JTextComponent textComponent, @Nonnull TextComponentEditor editor) {\n    myTextComponent = textComponent;\n    myEditor = editor;\n    myCaret = new TextComponentCaret(editor);\n  }\n  @Override\n  public void moveCaretRelatively(final int columnShift, final int lineShift, final boolean withSelection, final boolean blockSelection, final boolean scrollToCaret) {\n    if (lineShift == 0 && !withSelection && !blockSelection && !scrollToCaret) {\n      moveToOffset(getOffset() + columnShift);\n      return;\n    }\n    throw new UnsupportedOperationException(\"Not implemented\");\n  }\n  @Override\n  public void moveToLogicalPosition(@Nonnull final LogicalPosition pos) {\n    moveToOffset(myEditor.logicalPositionToOffset(pos), false);\n  }\n  @Override\n  public void moveToVisualPosition(@Nonnull final VisualPosition pos) {\n    moveToLogicalPosition(myEditor.visualToLogicalPosition(pos));\n  }\n  @Override\n  public void moveToOffset(int offset) {\n    moveToOffset(offset, false);\n  }\n  @Override\n  public void moveToOffset(final int offset, boolean locateBeforeSoftWrap) {\n    int targetOffset = Math.min(offset, myTextComponent.getText().length());\n    int currentPosition = myTextComponent.getCaretPosition();\n    // We try to preserve selection, to match EditorImpl behaviour.\n    // It's only possible though, if target offset is located at either end of existing selection.\n    if (targetOffset != currentPosition) {\n      if (targetOffset == myTextComponent.getCaret().getMark()) {\n        myTextComponent.setCaretPosition(currentPosition);\n        myTextComponent.moveCaretPosition(targetOffset);\n      }\n      else {\n        myTextComponent.setCaretPosition(targetOffset);\n      }\n    }\n  }\n  @Override\n  public boolean isUpToDate() {\n    return true;\n  }\n  @Override\n  @Nonnull\n  public LogicalPosition getLogicalPosition() {\n    int caretPos = myTextComponent.getCaretPosition();\n    int line;\n    int lineStart;\n    if (myTextComponent instanceof JTextArea) {\n      final JTextArea textArea = (JTextArea)myTextComponent;\n      try {\n        line = textArea.getLineOfOffset(caretPos);\n        lineStart = textArea.getLineStartOffset(line);\n      }\n      catch (BadLocationException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    else {\n      line = 0;\n      lineStart = 0;\n    }\n    return new LogicalPosition(line, caretPos - lineStart);\n  }\n  @Override\n  @Nonnull\n  public VisualPosition getVisualPosition() {\n    LogicalPosition pos = getLogicalPosition();\n    return new VisualPosition(pos.line, pos.column);\n  }\n  @Override\n  public int getOffset() {\n    return myTextComponent.getCaretPosition();\n  }\n  @Override\n  public void addCaretListener(@Nonnull final CaretListener listener) {\n    throw new UnsupportedOperationException(\"Not implemented\");\n  }\n  @Override\n  public void removeCaretListener(@Nonnull final CaretListener listener) {\n    throw new UnsupportedOperationException(\"Not implemented\");\n  }\n  @Override\n  public int getVisualLineStart() {\n    return 0;\n  }\n  @Override\n  public int getVisualLineEnd() {\n    return 0;\n  }\n  @Override\n  public TextAttributes getTextAttributes() {\n    return null;\n  }\n  @Override\n  public boolean supportsMultipleCarets() {\n    return false;\n  }\n  @Nonnull\n  @Override\n  public Caret getCurrentCaret() {\n    return myCaret;\n  }\n  @Nonnull\n  @Override\n  public Caret getPrimaryCaret() {\n    return myCaret;\n  }\n  @Override\n  public int getCaretCount() {\n    return 1;\n  }\n  @Nonnull\n  @Override\n  public List<Caret> getAllCarets() {\n    return Collections.singletonList(myCaret);\n  }\n  @Nullable\n  @Override\n  public Caret getCaretAt(@Nonnull VisualPosition pos) {\n    return myCaret.getVisualPosition().equals(pos) ? myCaret : null;\n  }\n  @Nullable\n  @Override\n  public Caret addCaret(@Nonnull VisualPosition pos) {\n    return null;\n  }\n  @Nullable\n  @Override\n  public Caret addCaret(@Nonnull VisualPosition pos, boolean makePrimary) {\n    return null;\n  }\n  @Override\n  public boolean removeCaret(@Nonnull Caret caret) {\n    return false;\n  }\n  @Override\n  public void removeSecondaryCarets() {\n  }\n  @Override\n  public void setCaretsAndSelections(@Nonnull List<? extends CaretState> caretStates) {\n    if (caretStates.size() != 1) throw new IllegalArgumentException(\"Exactly one CaretState object must be passed\");\n    CaretState state = caretStates.get(0);\n    if (state != null) {\n      if (state.getCaretPosition() != null) moveToLogicalPosition(state.getCaretPosition());\n      if (state.getSelectionStart() != null && state.getSelectionEnd() != null) {\n        myEditor.getSelectionModel().setSelection(myEditor.logicalPositionToOffset(state.getSelectionStart()), myEditor.logicalPositionToOffset(state.getSelectionEnd()));\n      }\n    }\n  }\n  @Override\n  public void setCaretsAndSelections(@Nonnull List<? extends CaretState> caretStates, boolean updateSystemSelection) {\n    setCaretsAndSelections(caretStates);\n  }\n  @Nonnull\n  @Override\n  public List<CaretState> getCaretsAndSelections() {\n    return Collections.singletonList(new CaretState(getLogicalPosition(), myEditor.offsetToLogicalPosition(myEditor.getSelectionModel().getSelectionStart()),\n                                                    myEditor.offsetToLogicalPosition(myEditor.getSelectionModel().getSelectionEnd())));\n  }\n  @Override\n  public void runForEachCaret(@Nonnull CaretAction action) {\n    myCaretActionListeners.getMulticaster().beforeAllCaretsAction();\n    action.perform(myCaret);\n    myCaretActionListeners.getMulticaster().afterAllCaretsAction();\n  }\n  @Override\n  public void runForEachCaret(@Nonnull CaretAction action, boolean reverseOrder) {\n    runForEachCaret(action);\n  }\n  @Override\n  public void addCaretActionListener(@Nonnull CaretActionListener listener, @Nonnull Disposable disposable) {\n    myCaretActionListeners.addListener(listener, disposable);\n  }\n  @Override\n  public void runBatchCaretOperation(@Nonnull Runnable runnable) {\n    runnable.run();\n  }\n"]], "pred": {"ppl": 1.4561758041381836, "ppl_lower": 1.862637996673584, "ppl/lowercase_ppl": -1.6550588285480232, "ppl/zlib": 0.0002459513658938825, "Min_5.0% Prob": 4.047310604768641, "Min_10.0% Prob": 2.9386901797032823, "Min_20.0% Prob": 1.787513878853882, "Min_30.0% Prob": 1.2396667847422018, "Min_40.0% Prob": 0.9367783841947982, "Min_50.0% Prob": 0.7516357026549526, "Min_60.0% Prob": 0.626990572757545}}
{"hexsha": "fe2a5eda25f17d67f54f1f53386c5d5251cc2005", "ext": "java", "lang": "Java", "content": "public class TestEnumToKernelConstantMappings {\n\n    @Test\n    public void testConnectionRetainModes() {\n        assertEquals(ConnectionRetainModes.CONN_RETAIN_ALWAYS,\n            ConnectionRetainMode.ALWAYS.toKernelConstant());\n        assertEquals(ConnectionRetainMode.ALWAYS,\n            ConnectionRetainMode.fromKernelConstant(\n                ConnectionRetainModes.CONN_RETAIN_ALWAYS));\n        assertEquals(ConnectionRetainMode.ALWAYS.toKernelConstant(),\n            ConnectionRetainMode.ALWAYS.ordinal());\n\n        assertEquals(ConnectionRetainModes.CONN_RETAIN_DEMAND,\n            ConnectionRetainMode.ON_DEMAND.toKernelConstant());\n        assertEquals(ConnectionRetainMode.ON_DEMAND,\n            ConnectionRetainMode.fromKernelConstant(\n                ConnectionRetainModes.CONN_RETAIN_DEMAND));\n        assertEquals(ConnectionRetainMode.ON_DEMAND.toKernelConstant(),\n            ConnectionRetainMode.ON_DEMAND.ordinal());\n\n        assertEquals(ConnectionRetainModes.CONN_RETAIN_TRANS,\n            ConnectionRetainMode.TRANSACTION.toKernelConstant());\n        assertEquals(ConnectionRetainMode.TRANSACTION,\n            ConnectionRetainMode.fromKernelConstant(\n                ConnectionRetainModes.CONN_RETAIN_TRANS));\n        assertEquals(ConnectionRetainMode.TRANSACTION.toKernelConstant(),\n            ConnectionRetainMode.TRANSACTION.ordinal());\n\n        assertEquals(getConstantCount(ConnectionRetainModes.class),\n            ConnectionRetainMode.values().length);\n    }\n\n    @Test\n    public void testDetachState() {\n        assertEquals(DetachState.DETACH_ALL,\n            DetachStateType.ALL.toKernelConstant());\n        assertEquals(DetachStateType.ALL,\n            DetachStateType.fromKernelConstant(DetachState.DETACH_ALL));\n        assertEquals(DetachStateType.ALL.toKernelConstant(),\n            DetachStateType.ALL.ordinal());\n\n        assertEquals(DetachState.DETACH_FETCH_GROUPS,\n            DetachStateType.FETCH_GROUPS.toKernelConstant());\n        assertEquals(DetachStateType.FETCH_GROUPS,\n            DetachStateType.fromKernelConstant(\n                DetachState.DETACH_FETCH_GROUPS));\n        assertEquals(DetachStateType.FETCH_GROUPS.toKernelConstant(),\n            DetachStateType.FETCH_GROUPS.ordinal());\n\n        assertEquals(DetachState.DETACH_LOADED,\n            DetachStateType.LOADED.toKernelConstant());\n        assertEquals(DetachStateType.LOADED,\n            DetachStateType.fromKernelConstant(DetachState.DETACH_LOADED));\n        assertEquals(DetachStateType.LOADED.toKernelConstant(),\n            DetachStateType.LOADED.ordinal());\n\n        // subtract 1 for DetachState.DETACH_FGS, which is deprecated\n        assertEquals(getConstantCount(DetachState.class) - 1,\n            DetachStateType.values().length);\n    }\n\n    @Test\n    public void testRestoreState() {\n        assertEquals(RestoreState.RESTORE_ALL,\n            RestoreStateType.ALL.toKernelConstant());\n        assertEquals(RestoreStateType.ALL,\n            RestoreStateType.fromKernelConstant(RestoreState.RESTORE_ALL));\n        assertEquals(RestoreStateType.ALL.toKernelConstant(),\n            RestoreStateType.ALL.ordinal());\n\n        assertEquals(RestoreState.RESTORE_IMMUTABLE,\n            RestoreStateType.IMMUTABLE.toKernelConstant());\n        assertEquals(RestoreStateType.IMMUTABLE,\n            RestoreStateType.fromKernelConstant(\n                RestoreState.RESTORE_IMMUTABLE));\n        assertEquals(RestoreStateType.IMMUTABLE.toKernelConstant(),\n            RestoreStateType.IMMUTABLE.ordinal());\n\n        assertEquals(RestoreState.RESTORE_NONE,\n            RestoreStateType.NONE.toKernelConstant());\n        assertEquals(RestoreStateType.NONE,\n            RestoreStateType.fromKernelConstant(RestoreState.RESTORE_NONE));\n        assertEquals(RestoreStateType.NONE.toKernelConstant(),\n            RestoreStateType.NONE.ordinal());\n\n        assertEquals(getConstantCount(RestoreState.class),\n            RestoreStateType.values().length);\n    }\n\n    @Test\n    public void testAutoClear() {\n        assertEquals(AutoClear.CLEAR_ALL, AutoClearType.ALL.toKernelConstant());\n        assertEquals(AutoClearType.ALL,\n            AutoClearType.fromKernelConstant(AutoClear.CLEAR_ALL));\n        assertEquals(AutoClearType.ALL.toKernelConstant(),\n            AutoClearType.ALL.ordinal());\n\n        assertEquals(AutoClear.CLEAR_DATASTORE,\n            AutoClearType.DATASTORE.toKernelConstant());\n        assertEquals(AutoClearType.DATASTORE,\n            AutoClearType.fromKernelConstant(AutoClear.CLEAR_DATASTORE));\n        assertEquals(AutoClearType.DATASTORE.toKernelConstant(),\n            AutoClearType.DATASTORE.ordinal());\n\n        assertEquals(getConstantCount(AutoClear.class),\n            AutoClearType.values().length);\n    }\n\n    @Test\n    public void testAutoDetach() {\n        // Commenting out constant count test for now. Subtracting 2 is brittle.\n        // assertEquals(getConstantCount(AutoDetach.class) - 2,\n        //    AutoDetachType.values().length);\n\n        assertEquals(EnumSet.of(AutoDetachType.CLOSE),\n            AutoDetachType.toEnumSet(AutoDetach.DETACH_CLOSE));\n        assertEquals(AutoDetach.DETACH_CLOSE,\n            AutoDetachType.fromEnumSet(EnumSet.of(AutoDetachType.CLOSE)));\n\n        assertEquals(EnumSet.of(AutoDetachType.COMMIT),\n            AutoDetachType.toEnumSet(AutoDetach.DETACH_COMMIT));\n        assertEquals(AutoDetach.DETACH_COMMIT,\n            AutoDetachType.fromEnumSet(EnumSet.of(AutoDetachType.COMMIT)));\n\n        assertEquals(EnumSet.of(AutoDetachType.NON_TRANSACTIONAL_READ),\n            AutoDetachType.toEnumSet(AutoDetach.DETACH_NONTXREAD));\n        assertEquals(AutoDetach.DETACH_NONTXREAD,\n            AutoDetachType.fromEnumSet(\n                EnumSet.of(AutoDetachType.NON_TRANSACTIONAL_READ)));\n\n        assertEquals(EnumSet.of(AutoDetachType.ROLLBACK),\n            AutoDetachType.toEnumSet(AutoDetach.DETACH_ROLLBACK));\n        assertEquals(AutoDetach.DETACH_ROLLBACK,\n            AutoDetachType.fromEnumSet(EnumSet.of(AutoDetachType.ROLLBACK)));\n\n\n        assertEquals(EnumSet.of(AutoDetachType.CLOSE, AutoDetachType.COMMIT),\n            AutoDetachType.toEnumSet(\n                AutoDetach.DETACH_CLOSE | AutoDetach.DETACH_COMMIT));\n        assertEquals(AutoDetach.DETACH_ROLLBACK | AutoDetach.DETACH_CLOSE,\n            AutoDetachType.fromEnumSet(\n                EnumSet.of(AutoDetachType.ROLLBACK, AutoDetachType.CLOSE)));\n\n\n        assertEquals(EnumSet.allOf(AutoDetachType.class),\n            AutoDetachType.toEnumSet(\n                    AutoDetach.DETACH_NONE\n                    | AutoDetach.DETACH_CLOSE\n                    | AutoDetach.DETACH_COMMIT\n                    | AutoDetach.DETACH_NONTXREAD\n                    | AutoDetach.DETACH_ROLLBACK));\n        assertEquals( AutoDetach.DETACH_NONE\n                    | AutoDetach.DETACH_CLOSE\n                    | AutoDetach.DETACH_COMMIT\n                    | AutoDetach.DETACH_NONTXREAD\n                    | AutoDetach.DETACH_ROLLBACK,\n            AutoDetachType.fromEnumSet(EnumSet.allOf(AutoDetachType.class)));\n    }\n\n    @Test\n    public void testCallbackMode() {\n        assertEquals(getConstantCount(CallbackModes.class),\n            CallbackMode.values().length);\n\n        assertEquals(EnumSet.of(CallbackMode.FAIL_FAST),\n            CallbackMode.toEnumSet(CallbackModes.CALLBACK_FAIL_FAST));\n        assertEquals(CallbackModes.CALLBACK_FAIL_FAST,\n            CallbackMode.fromEnumSet(EnumSet.of(CallbackMode.FAIL_FAST)));\n\n        assertEquals(EnumSet.of(CallbackMode.IGNORE),\n            CallbackMode.toEnumSet(CallbackModes.CALLBACK_IGNORE));\n        assertEquals(CallbackModes.CALLBACK_IGNORE,\n            CallbackMode.fromEnumSet(EnumSet.of(CallbackMode.IGNORE)));\n\n        assertEquals(EnumSet.of(CallbackMode.LOG),\n            CallbackMode.toEnumSet(CallbackModes.CALLBACK_LOG));\n        assertEquals(CallbackModes.CALLBACK_LOG,\n            CallbackMode.fromEnumSet(EnumSet.of(CallbackMode.LOG)));\n\n        assertEquals(EnumSet.of(CallbackMode.RETHROW),\n            CallbackMode.toEnumSet(CallbackModes.CALLBACK_RETHROW));\n        assertEquals(CallbackModes.CALLBACK_RETHROW,\n            CallbackMode.fromEnumSet(EnumSet.of(CallbackMode.RETHROW)));\n\n        assertEquals(EnumSet.of(CallbackMode.ROLLBACK),\n            CallbackMode.toEnumSet(CallbackModes.CALLBACK_ROLLBACK));\n        assertEquals(CallbackModes.CALLBACK_ROLLBACK,\n            CallbackMode.fromEnumSet(EnumSet.of(CallbackMode.ROLLBACK)));\n\n\n        assertEquals(EnumSet.of(CallbackMode.ROLLBACK, CallbackMode.IGNORE),\n            CallbackMode.toEnumSet(CallbackModes.CALLBACK_ROLLBACK\n                | CallbackModes.CALLBACK_IGNORE));\n        assertEquals(\n            CallbackModes.CALLBACK_ROLLBACK | CallbackModes.CALLBACK_IGNORE,\n            CallbackMode.fromEnumSet(\n                EnumSet.of(CallbackMode.ROLLBACK, CallbackMode.IGNORE)));\n\n\n        assertEquals(EnumSet.allOf(CallbackMode.class),\n            CallbackMode.toEnumSet(\n                CallbackModes.CALLBACK_FAIL_FAST\n                    | CallbackModes.CALLBACK_IGNORE\n                    | CallbackModes.CALLBACK_LOG\n                    | CallbackModes.CALLBACK_RETHROW\n                    | CallbackModes.CALLBACK_ROLLBACK));\n        assertEquals(CallbackModes.CALLBACK_FAIL_FAST\n                    | CallbackModes.CALLBACK_IGNORE\n                    | CallbackModes.CALLBACK_LOG\n                    | CallbackModes.CALLBACK_RETHROW\n                    | CallbackModes.CALLBACK_ROLLBACK,\n            CallbackMode.fromEnumSet(EnumSet.allOf(CallbackMode.class)));\n    }\n\n    @Test\n    public void testQueryOperationTypes() {\n        assertEquals(QueryOperations.OP_SELECT,\n            QueryOperationType.SELECT.toKernelConstant());\n        assertEquals(QueryOperationType.SELECT,\n            QueryOperationType.fromKernelConstant(\n                QueryOperations.OP_SELECT));\n        assertEquals(QueryOperationType.SELECT.toKernelConstant(),\n            QueryOperationType.SELECT.ordinal() + 1);\n\n        assertEquals(QueryOperations.OP_UPDATE,\n            QueryOperationType.UPDATE.toKernelConstant());\n        assertEquals(QueryOperationType.UPDATE,\n            QueryOperationType.fromKernelConstant(\n                QueryOperations.OP_UPDATE));\n        assertEquals(QueryOperationType.UPDATE.toKernelConstant(),\n            QueryOperationType.UPDATE.ordinal() + 1);\n\n        assertEquals(QueryOperations.OP_DELETE,\n            QueryOperationType.DELETE.toKernelConstant());\n        assertEquals(QueryOperationType.DELETE,\n            QueryOperationType.fromKernelConstant(\n                QueryOperations.OP_DELETE));\n        assertEquals(QueryOperationType.DELETE.toKernelConstant(),\n            QueryOperationType.DELETE.ordinal() + 1);\n\n        assertEquals(getConstantCount(QueryOperations.class),\n            QueryOperationType.values().length);\n    }\n\n    private int getConstantCount(Class cls) {\n        return cls.getDeclaredFields().length;\n    }\n}", "item_id": 0, "repo": "trettstadtnlb/openjpa", "file": "openjpa-persistence/src/test/java/org/apache/openjpa/persistence/TestEnumToKernelConstantMappings.java", "last_update_at": "2022-03-20T05:28:58+00:00", "question_id": "fe2a5eda25f17d67f54f1f53386c5d5251cc2005_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestEnumToKernelConstantMappings {\n    @Test\n    public void testConnectionRetainModes() {\n        assertEquals(ConnectionRetainModes.CONN_RETAIN_ALWAYS,\n            ConnectionRetainMode.ALWAYS.toKernelConstant());\n        assertEquals(ConnectionRetainMode.ALWAYS,\n            ConnectionRetainMode.fromKernelConstant(\n                ConnectionRetainModes.CONN_RETAIN_ALWAYS));\n        assertEquals(ConnectionRetainMode.ALWAYS.toKernelConstant(),\n            ConnectionRetainMode.ALWAYS.ordinal());\n        assertEquals(ConnectionRetainModes.CONN_RETAIN_DEMAND,\n            ConnectionRetainMode.ON_DEMAND.toKernelConstant());\n        assertEquals(ConnectionRetainMode.ON_DEMAND,\n            ConnectionRetainMode.fromKernelConstant(\n                ConnectionRetainModes.CONN_RETAIN_DEMAND));\n        assertEquals(ConnectionRetainMode.ON_DEMAND.toKernelConstant(),\n            ConnectionRetainMode.ON_DEMAND.ordinal());\n        assertEquals(ConnectionRetainModes.CONN_RETAIN_TRANS,\n            ConnectionRetainMode.TRANSACTION.toKernelConstant());\n        assertEquals(ConnectionRetainMode.TRANSACTION,\n            ConnectionRetainMode.fromKernelConstant(\n                ConnectionRetainModes.CONN_RETAIN_TRANS));\n        assertEquals(ConnectionRetainMode.TRANSACTION.toKernelConstant(),\n            ConnectionRetainMode.TRANSACTION.ordinal());\n        assertEquals(getConstantCount(ConnectionRetainModes.class),\n            ConnectionRetainMode.values().length);\n    }\n    @Test\n    public void testDetachState() {\n        assertEquals(DetachState.DETACH_ALL,\n            DetachStateType.ALL.toKernelConstant());\n        assertEquals(DetachStateType.ALL,\n            DetachStateType.fromKernelConstant(DetachState.DETACH_ALL));\n        assertEquals(DetachStateType.ALL.toKernelConstant(),\n            DetachStateType.ALL.ordinal());\n        assertEquals(DetachState.DETACH_FETCH_GROUPS,\n            DetachStateType.FETCH_GROUPS.toKernelConstant());\n        assertEquals(DetachStateType.FETCH_GROUPS,\n            DetachStateType.fromKernelConstant(\n                DetachState.DETACH_FETCH_GROUPS));\n        assertEquals(DetachStateType.FETCH_GROUPS.toKernelConstant(),\n            DetachStateType.FETCH_GROUPS.ordinal());\n        assertEquals(DetachState.DETACH_LOADED,\n            DetachStateType.LOADED.toKernelConstant());\n        assertEquals(DetachStateType.LOADED,\n            DetachStateType.fromKernelConstant(DetachState.DETACH_LOADED));\n        assertEquals(DetachStateType.LOADED.toKernelConstant(),\n            DetachStateType.LOADED.ordinal());\n        // subtract 1 for DetachState.DETACH_FGS, which is deprecated\n        assertEquals(getConstantCount(DetachState.class) - 1,\n            DetachStateType.values().length);\n    }\n    @Test\n    public void testRestoreState() {\n        assertEquals(RestoreState.RESTORE_ALL,\n            RestoreStateType.ALL.toKernelConstant());\n        assertEquals(RestoreStateType.ALL,\n            RestoreStateType.fromKernelConstant(RestoreState.RESTORE_ALL));\n        assertEquals(RestoreStateType.ALL.toKernelConstant(),\n            RestoreStateType.ALL.ordinal());\n        assertEquals(RestoreState.RESTORE_IMMUTABLE,\n            RestoreStateType.IMMUTABLE.toKernelConstant());\n        assertEquals(RestoreStateType.IMMUTABLE,\n            RestoreStateType.fromKernelConstant(\n                RestoreState.RESTORE_IMMUTABLE));\n        assertEquals(RestoreStateType.IMMUTABLE.toKernelConstant(),\n            RestoreStateType.IMMUTABLE.ordinal());\n        assertEquals(RestoreState.RESTORE_NONE,\n            RestoreStateType.NONE.toKernelConstant());\n        assertEquals(RestoreStateType.NONE,\n            RestoreStateType.fromKernelConstant(RestoreState.RESTORE_NONE));\n        assertEquals(RestoreStateType.NONE.toKernelConstant(),\n            RestoreStateType.NONE.ordinal());\n        assertEquals(getConstantCount(RestoreState.class),\n            RestoreStateType.values().length);\n    }\n    @Test\n    public void testAutoClear() {\n        assertEquals(AutoClear.CLEAR_ALL, AutoClearType.ALL.toKernelConstant());\n        assertEquals(AutoClearType.ALL,\n            AutoClearType.fromKernelConstant(AutoClear.CLEAR_ALL));\n        assertEquals(AutoClearType.ALL.toKernelConstant(),\n            AutoClearType.ALL.ordinal());\n        assertEquals(AutoClear.CLEAR_DATASTORE,\n            AutoClearType.DATASTORE.toKernelConstant());\n        assertEquals(AutoClearType.DATASTORE,\n            AutoClearType.fromKernelConstant(AutoClear.CLEAR_DATASTORE));\n        assertEquals(AutoClearType.DATASTORE.toKernelConstant(),\n            AutoClearType.DATASTORE.ordinal());\n        assertEquals(getConstantCount(AutoClear.class),\n            AutoClearType.values().length);\n    }\n    @Test\n    public void testAutoDetach() {\n        // Commenting out constant count test for now. Subtracting 2 is brittle.\n        // assertEquals(getConstantCount(AutoDetach.class) - 2,\n        //    AutoDetachType.values().length);\n        assertEquals(EnumSet.of(AutoDetachType.CLOSE),\n            AutoDetachType.toEnumSet(AutoDetach.DETACH_CLOSE));\n        assertEquals(AutoDetach.DETACH_CLOSE,\n            AutoDetachType.fromEnumSet(EnumSet.of(AutoDetachType.CLOSE)));\n        assertEquals(EnumSet.of(AutoDetachType.COMMIT),\n            AutoDetachType.toEnumSet(AutoDetach.DETACH_COMMIT));\n        assertEquals(AutoDetach.DETACH_COMMIT,\n            AutoDetachType.fromEnumSet(EnumSet.of(AutoDetachType.COMMIT)));\n        assertEquals(EnumSet.of(AutoDetachType.NON_TRANSACTIONAL_READ),\n            AutoDetachType.toEnumSet(AutoDetach.DETACH_NONTXREAD));\n        assertEquals(AutoDetach.DETACH_NONTXREAD,\n            AutoDetachType.fromEnumSet(\n                EnumSet.of(AutoDetachType.NON_TRANSACTIONAL_READ)));\n        assertEquals(EnumSet.of(AutoDetachType.ROLLBACK),\n            AutoDetachType.toEnumSet(AutoDetach.DETACH_ROLLBACK));\n        assertEquals(AutoDetach.DETACH_ROLLBACK,\n            AutoDetachType.fromEnumSet(EnumSet.of(AutoDetachType.ROLLBACK)));\n        assertEquals(EnumSet.of(AutoDetachType.CLOSE, AutoDetachType.COMMIT),\n            AutoDetachType.toEnumSet(\n                AutoDetach.DETACH_CLOSE | AutoDetach.DETACH_COMMIT));\n        assertEquals(AutoDetach.DETACH_ROLLBACK | AutoDetach.DETACH_CLOSE,\n            AutoDetachType.fromEnumSet(\n                EnumSet.of(AutoDetachType.ROLLBACK, AutoDetachType.CLOSE)));\n        assertEquals(EnumSet.allOf(AutoDetachType.class),\n            AutoDetachType.toEnumSet(\n                    AutoDetach.DETACH_NONE\n                    | AutoDetach.DETACH_CLOSE\n                    | AutoDetach.DETACH_COMMIT\n                    | AutoDetach.DETACH_NONTXREAD\n                    | AutoDetach.DETACH_ROLLBACK));\n        assertEquals( AutoDetach.DETACH_NONE\n                    | AutoDetach.DETACH_CLOSE\n                    | AutoDetach.DETACH_COMMIT\n                    | AutoDetach.DETACH_NONTXREAD\n                    | AutoDetach.DETACH_ROLLBACK,\n            AutoDetachType.fromEnumSet(EnumSet.allOf(AutoDetachType.class)));\n    }\n    @Test\n    public void testCallbackMode() {\n        assertEquals(getConstantCount(CallbackModes.class),\n            CallbackMode.values().length);\n        assertEquals(EnumSet.of(CallbackMode.FAIL_FAST),\n            CallbackMode.toEnumSet(CallbackModes.CALLBACK_FAIL_FAST));\n        assertEquals(CallbackModes.CALLBACK_FAIL_FAST,\n            CallbackMode.fromEnumSet(EnumSet.of(CallbackMode.FAIL_FAST)));\n        assertEquals(EnumSet.of(CallbackMode.IGNORE),\n            CallbackMode.toEnumSet(CallbackModes.CALLBACK_IGNORE));\n        assertEquals(CallbackModes.CALLBACK_IGNORE,\n            CallbackMode.fromEnumSet(EnumSet.of(CallbackMode.IGNORE)));\n        assertEquals(EnumSet.of(CallbackMode.LOG),\n            CallbackMode.toEnumSet(CallbackModes.CALLBACK_LOG));\n        assertEquals(CallbackModes.CALLBACK_LOG,\n            CallbackMode.fromEnumSet(EnumSet.of(CallbackMode.LOG)));\n        assertEquals(EnumSet.of(CallbackMode.RETHROW),\n            CallbackMode.toEnumSet(CallbackModes.CALLBACK_RETHROW));\n        assertEquals(CallbackModes.CALLBACK_RETHROW,\n            CallbackMode.fromEnumSet(EnumSet.of(CallbackMode.RETHROW)));\n        assertEquals(EnumSet.of(CallbackMode.ROLLBACK),\n            CallbackMode.toEnumSet(CallbackModes.CALLBACK_ROLLBACK));\n        assertEquals(CallbackModes.CALLBACK_ROLLBACK,\n            CallbackMode.fromEnumSet(EnumSet.of(CallbackMode.ROLLBACK)));\n        assertEquals(EnumSet.of(CallbackMode.ROLLBACK, CallbackMode.IGNORE),\n            CallbackMode.toEnumSet(CallbackModes.CALLBACK_ROLLBACK\n                | CallbackModes.CALLBACK_IGNORE));\n        assertEquals(\n            CallbackModes.CALLBACK_ROLLBACK | CallbackModes.CALLBACK_IGNORE,\n            CallbackMode.fromEnumSet(\n                EnumSet.of(CallbackMode.ROLLBACK, CallbackMode.IGNORE)));\n        assertEquals(EnumSet.allOf(CallbackMode.class),\n            CallbackMode.toEnumSet(\n                CallbackModes.CALLBACK_FAIL_FAST\n                    | CallbackModes.CALLBACK_IGNORE\n                    | CallbackModes.CALLBACK_LOG\n                    | CallbackModes.CALLBACK_RETHROW\n                    | CallbackModes.CALLBACK_ROLLBACK));\n        assertEquals(CallbackModes.CALLBACK_FAIL_FAST\n                    | CallbackModes.CALLBACK_IGNORE\n                    | CallbackModes.CALLBACK_LOG\n                    | CallbackModes.CALLBACK_RETHROW\n                    | CallbackModes.CALLBACK_ROLLBACK,\n            CallbackMode.fromEnumSet(EnumSet.allOf(CallbackMode.class)));\n    }\n    @Test\n    public void testQueryOperationTypes() {\n        assertEquals(QueryOperations.OP_SELECT,\n            QueryOperationType.SELECT.toKernelConstant());\n        assertEquals(QueryOperationType.SELECT,\n            QueryOperationType.fromKernelConstant(\n                QueryOperations.OP_SELECT));\n        assertEquals(QueryOperationType.SELECT.toKernelConstant(),\n            QueryOperationType.SELECT.ordinal() + 1);\n        assertEquals(QueryOperations.OP_UPDATE,\n            QueryOperationType.UPDATE.toKernelConstant());\n        assertEquals(QueryOperationType.UPDATE,\n            QueryOperationType.fromKernelConstant(\n                QueryOperations.OP_UPDATE));\n        assertEquals(QueryOperationType.UPDATE.toKernelConstant(),\n            QueryOperationType.UPDATE.ordinal() + 1);\n        assertEquals(QueryOperations.OP_DELETE,\n            QueryOperationType.DELETE.toKernelConstant());\n        assertEquals(QueryOperationType.DELETE,\n            QueryOperationType.fromKernelConstant(\n                QueryOperations.OP_DELETE));\n        assertEquals(QueryOperationType.DELETE.toKernelConstant(),\n            QueryOperationType.DELETE.ordinal() + 1);\n        assertEquals(getConstantCount(QueryOperations.class),\n            QueryOperationType.values().length);\n    }\n    private int getConstantCount(Class cls) {\n        return cls.getDeclaredFields().length;\n    }\n"]], "pred": {"ppl": 1.385820746421814, "ppl_lower": 1.445288062095642, "ppl/lowercase_ppl": -1.1287681573399089, "ppl/zlib": 0.00025471706543143475, "Min_5.0% Prob": 5.342390125873042, "Min_10.0% Prob": 3.154014087190815, "Min_20.0% Prob": 1.6290732709161353, "Min_30.0% Prob": 1.0896665786265158, "Min_40.0% Prob": 0.8158636856639148, "Min_50.0% Prob": 0.6531512997739214, "Min_60.0% Prob": 0.5445096422560871}}
{"hexsha": "ccadec7e2109772ac9b069ee2ee27eab1548818c", "ext": "java", "lang": "Java", "content": "public class LogEntry implements Comparable<LogEntry>\n{\n    // Where the data values extracted from a single\n    // log line are stored.\n    private int[] dataValues;\n    // At which index in dataValues the different fields\n    // from a log line are stored.\n    private static final int YEAR = 0, MONTH = 1, DAY = 2,\n                             HOUR = 3, MINUTE = 4;\n                      \n    /**\n     * Decompose a log line so that the individual fields\n     * are available.\n     * @param logline A single line from the log.\n     */\n    public LogEntry(String logline)\n    {\n        // The array to store the data for a single line.\n        dataValues = new int[5];\n        // Break up the log line.\n        LoglineTokenizer tokenizer = new LoglineTokenizer();\n        tokenizer.tokenize(logline,dataValues);\n    }\n    \n    /**\n     * @return The hour field from the log line.\n     */\n    public int getHour()\n    {\n        return dataValues[HOUR];\n    }\n\n    /**\n     * @return The minute field from the log line.\n     */\n    public int getMinute()\n    {\n        return dataValues[MINUTE];\n    }\n    \n    /**\n     * Create a string representation of the data.\n     * This is not necessarily identical with the\n     * text of the original log line.\n     * @return A string representing the data of this entry.\n     */\n    public String toString()\n    {\n        StringBuffer buffer = new StringBuffer();\n        for(int value : dataValues) {\n           // Prefix a leading zero on single digit numbers.\n            if(value < 10) {\n                buffer.append('0');\n            }\n            buffer.append(value);\n            buffer.append(' ');\n        }\n        // Drop any trailing space.\n        return buffer.toString().trim();\n    }\n    \n    /**\n     * Compare the date/time combination of this log entry\n     * with another.\n     * @param otherEntry The other entry to compare against.\n     * @return A negative value if this entry comes before the other.\n     *         A positive value if this entry comes after the other.\n     *         Zero if the entries are the same.\n     */\n    public int compareTo(LogEntry otherEntry)\n    {\n        if(otherEntry == this) {\n            // They are the same object.\n            return 0;\n        }\n        else {\n            // Compare corresponding fields.\n            for(int i = 0; i < dataValues.length; i++) {\n                int difference = dataValues[i] - otherEntry.dataValues[i];\n                if(difference != 0) {\n                    return difference;\n                }\n            }\n            // No value is different, so the two entries represent\n            // identical times.\n            return 0;\n        }\n    }\n}", "item_id": 0, "repo": "Samuellucas97/LaboratoriesOfProgramingLanguage-II", "file": "ExamplesBlueJ/chapter04/weblog-analyzer/LogEntry.java", "last_update_at": "2022-01-11T18:50:54+00:00", "question_id": "ccadec7e2109772ac9b069ee2ee27eab1548818c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LogEntry implements Comparable<LogEntry>\n{\n    // Where the data values extracted from a single\n    // log line are stored.\n    private int[] dataValues;\n    // At which index in dataValues the different fields\n    // from a log line are stored.\n    private static final int YEAR = 0, MONTH = 1, DAY = 2,\n                             HOUR = 3, MINUTE = 4;\n    /**\n     * Decompose a log line so that the individual fields\n     * are available.\n     * @param logline A single line from the log.\n     */\n    public LogEntry(String logline)\n    {\n        // The array to store the data for a single line.\n        dataValues = new int[5];\n        // Break up the log line.\n        LoglineTokenizer tokenizer = new LoglineTokenizer();\n        tokenizer.tokenize(logline,dataValues);\n    }\n    /**\n     * @return The hour field from the log line.\n     */\n    public int getHour()\n    {\n        return dataValues[HOUR];\n    }\n    /**\n     * @return The minute field from the log line.\n     */\n    public int getMinute()\n    {\n        return dataValues[MINUTE];\n    }\n    /**\n     * Create a string representation of the data.\n     * This is not necessarily identical with the\n     * text of the original log line.\n     * @return A string representing the data of this entry.\n     */\n    public String toString()\n    {\n        StringBuffer buffer = new StringBuffer();\n        for(int value : dataValues) {\n           // Prefix a leading zero on single digit numbers.\n            if(value < 10) {\n                buffer.append('0');\n            }\n            buffer.append(value);\n            buffer.append(' ');\n        }\n        // Drop any trailing space.\n        return buffer.toString().trim();\n    }\n    /**\n     * Compare the date/time combination of this log entry\n     * with another.\n     * @param otherEntry The other entry to compare against.\n     * @return A negative value if this entry comes before the other.\n     *         A positive value if this entry comes after the other.\n     *         Zero if the entries are the same.\n     */\n    public int compareTo(LogEntry otherEntry)\n    {\n        if(otherEntry == this) {\n            // They are the same object.\n            return 0;\n        }\n        else {\n            // Compare corresponding fields.\n            for(int i = 0; i < dataValues.length; i++) {\n                int difference = dataValues[i] - otherEntry.dataValues[i];\n                if(difference != 0) {\n                    return difference;\n                }\n            }\n            // No value is different, so the two entries represent\n            // identical times.\n            return 0;\n        }\n    }\n"]], "pred": {"ppl": 2.0990054607391357, "ppl_lower": 2.2244937419891357, "ppl/lowercase_ppl": -1.0783122897607642, "ppl/zlib": 0.0007796673421934111, "Min_5.0% Prob": 5.943902621950422, "Min_10.0% Prob": 4.565496850013733, "Min_20.0% Prob": 3.126502757413047, "Min_30.0% Prob": 2.3321768789064317, "Min_40.0% Prob": 1.816842647686972, "Min_50.0% Prob": 1.4749510672866788, "Min_60.0% Prob": 1.2350737551656372}}
{"hexsha": "57ba7d72efdcffb8f098ab8b148e3b6b750b8ee8", "ext": "java", "lang": "Java", "content": "public class TestPropertyQueryString {\r\n    @Test\r\n    public void testBuildResponseKeys() {\r\n        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();\r\n        String properties = arp.buildResponseKeyExpression(createResponseKeys());\r\n        Assert.assertEquals(\r\n                \"<response-keys = address-fqdn:0000000000000:ipaddress-v4 , key2:value2:field2>\",\r\n                properties);\r\n    }\r\n\r\n    @Test\r\n    public void testBuildRequestKeys() {\r\n        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();\r\n        String properties = arp.buildRequestKeyExpression(createRequestKeys());\r\n        Assert.assertEquals(\r\n                \"<request-keys = class-type:interface-ip-address , address_fqdn:00000000000000 , address_type:v4>\",\r\n                properties);\r\n    }\r\n\r\n    @Test\r\n    public void testEncoding() {\r\n        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();\r\n\r\n        String expected1 = \"&lt;class-type&gt;\";\r\n        String encoded1 = arp.encode(\"<class-type>\");\r\n        Assert.assertEquals(expected1, encoded1);\r\n\r\n        String expected2 = \"&lt;&lt;&lt;metallica&lt;&gt;iron_maiden&gt;&gt;&gt;\";\r\n        String encoded2 = arp.encode(\"<<<metallica<>iron_maiden>>>\");\r\n        Assert.assertEquals(expected2, encoded2);\r\n\r\n        String expected3 = \"band-list&colon;metallica&comma;ironmaiden\";\r\n        String encoded3 = arp.encode(\"band-list:metallica,ironmaiden\");\r\n        Assert.assertEquals(expected3, encoded3);\r\n\r\n        String expected4 = \"motorhead&equals;lemmy\";\r\n        String encoded4 = arp.encode(\"motorhead=lemmy\");\r\n        Assert.assertEquals(expected4, encoded4);\r\n\r\n        String expected5 = \"DreamTheater\";\r\n        String encoded5 = arp.encode(\"  DreamTheater  \");\r\n        Assert.assertEquals(expected5, encoded5);\r\n    }\r\n\r\n    @Test\r\n    public void testBuildRuleType() {\r\n        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();\r\n        String input = \"IPV4\";\r\n        String expected = \"<rule-type = IPV4>\";\r\n        Assert.assertEquals(expected, arp.buildRuleType(input));\r\n    }\r\n\r\n    @Test\r\n    public void testRuleTypeSetNull() {\r\n        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();\r\n        String expected = \"<rule-type = >\";\r\n        Assert.assertEquals(expected, arp.buildRuleType(null));\r\n    }\r\n\r\n    @Test\r\n    public void testBuildRequestKeysWithKeyNull() {\r\n        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();\r\n        List<RequestKey> requestKeyList = new ArrayList<RequestKey>();\r\n        requestKeyList.add(null);\r\n        String properties = arp.buildRequestKeyExpression(requestKeyList);\r\n        Assert.assertEquals(\"<request-keys = >\", properties);\r\n    }\r\n\r\n    @Test\r\n    public void testBuildResponseKeysWithKeyNull() {\r\n        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();\r\n        List<ResponseKey> responseKeyList = new ArrayList<ResponseKey>();\r\n        responseKeyList.add(null);\r\n        String properties = arp.buildResponseKeyExpression(responseKeyList);\r\n        Assert.assertEquals(\"<response-keys = >\", properties);\r\n    }\r\n\r\n    @Test\r\n    public void testBuildSourceSystem() {\r\n        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();\r\n        Assert.assertEquals(\"<source-system = source>\", arp.buildSourceSystem(\"source\"));\r\n    }\r\n\r\n    // @Test\r\n    private List<RequestKey> createRequestKeys() {\r\n        // Create RequestKey object 1\r\n        RequestKey requestKey1 = new RequestKey();\r\n        requestKey1.setKeyName(\"class-type\");\r\n        requestKey1.setKeyValue(\"interface-ip-address\");\r\n\r\n        // Create RequestKey object 2\r\n        RequestKey requestKey2 = new RequestKey();\r\n        requestKey2.setKeyName(\"address_fqdn\");\r\n        requestKey2.setKeyValue(\"00000000000000\");\r\n\r\n        // Create RequestKey object 3\r\n        RequestKey requestKey3 = new RequestKey();\r\n        requestKey3.setKeyName(\"address_type\");\r\n        requestKey3.setKeyValue(\"v4\");\r\n\r\n        // Add the RequestKey Objects to the List\r\n        List<RequestKey> requestKeyList = new ArrayList<RequestKey>();\r\n        requestKeyList.add(requestKey1);\r\n        requestKeyList.add(requestKey2);\r\n        requestKeyList.add(requestKey3);\r\n        return requestKeyList;\r\n    }\r\n\r\n    // @Test\r\n    private List<ResponseKey> createResponseKeys() {\r\n        // Create RequestKey object 1\r\n        ResponseKey responseKey1 = new ResponseKey();\r\n\r\n        responseKey1.setUniqueKeyName(\"address-fqdn\");\r\n        responseKey1.setUniqueKeyValue(\"0000000000000\");\r\n        responseKey1.setFieldKeyName(\"ipaddress-v4\");\r\n\r\n        ResponseKey responseKey2 = new ResponseKey();\r\n        responseKey2.setUniqueKeyName(\"key2\");\r\n        responseKey2.setUniqueKeyValue(\"value2\");\r\n        responseKey2.setFieldKeyName(\"field2\");\r\n\r\n        // Add the RequestKey Objects to the List\r\n        List<ResponseKey> responseKeyList = new ArrayList<ResponseKey>();\r\n        responseKeyList.add(responseKey1);\r\n        responseKeyList.add(responseKey2);\r\n\r\n        return responseKeyList;\r\n    }\r\n}", "item_id": 0, "repo": "onap/appc", "file": "appc-config/appc-config-params/provider/src/test/java/org/onap/sdnc/config/params/transformer/tosca/TestPropertyQueryString.java", "last_update_at": "2022-03-07T11:45:34+00:00", "question_id": "57ba7d72efdcffb8f098ab8b148e3b6b750b8ee8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestPropertyQueryString {\r\n    @Test\r\n    public void testBuildResponseKeys() {\r\n        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();\r\n        String properties = arp.buildResponseKeyExpression(createResponseKeys());\r\n        Assert.assertEquals(\r\n                \"<response-keys = address-fqdn:0000000000000:ipaddress-v4 , key2:value2:field2>\",\r\n                properties);\r\n    }\r\n\r\n    @Test\r\n    public void testBuildRequestKeys() {\r\n        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();\r\n        String properties = arp.buildRequestKeyExpression(createRequestKeys());\r\n        Assert.assertEquals(\r\n                \"<request-keys = class-type:interface-ip-address , address_fqdn:00000000000000 , address_type:v4>\",\r\n                properties);\r\n    }\r\n\r\n    @Test\r\n    public void testEncoding() {\r\n        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();\r\n\r\n        String expected1 = \"&lt;class-type&gt;\";\r\n        String encoded1 = arp.encode(\"<class-type>\");\r\n        Assert.assertEquals(expected1, encoded1);\r\n\r\n        String expected2 = \"&lt;&lt;&lt;metallica&lt;&gt;iron_maiden&gt;&gt;&gt;\";\r\n        String encoded2 = arp.encode(\"<<<metallica<>iron_maiden>>>\");\r\n        Assert.assertEquals(expected2, encoded2);\r\n\r\n        String expected3 = \"band-list&colon;metallica&comma;ironmaiden\";\r\n        String encoded3 = arp.encode(\"band-list:metallica,ironmaiden\");\r\n        Assert.assertEquals(expected3, encoded3);\r\n\r\n        String expected4 = \"motorhead&equals;lemmy\";\r\n        String encoded4 = arp.encode(\"motorhead=lemmy\");\r\n        Assert.assertEquals(expected4, encoded4);\r\n\r\n        String expected5 = \"DreamTheater\";\r\n        String encoded5 = arp.encode(\"  DreamTheater  \");\r\n        Assert.assertEquals(expected5, encoded5);\r\n    }\r\n\r\n    @Test\r\n    public void testBuildRuleType() {\r\n        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();\r\n        String input = \"IPV4\";\r\n        String expected = \"<rule-type = IPV4>\";\r\n        Assert.assertEquals(expected, arp.buildRuleType(input));\r\n    }\r\n\r\n    @Test\r\n    public void testRuleTypeSetNull() {\r\n        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();\r\n        String expected = \"<rule-type = >\";\r\n        Assert.assertEquals(expected, arp.buildRuleType(null));\r\n    }\r\n\r\n    @Test\r\n    public void testBuildRequestKeysWithKeyNull() {\r\n        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();\r\n        List<RequestKey> requestKeyList = new ArrayList<RequestKey>();\r\n        requestKeyList.add(null);\r\n        String properties = arp.buildRequestKeyExpression(requestKeyList);\r\n        Assert.assertEquals(\"<request-keys = >\", properties);\r\n    }\r\n\r\n    @Test\r\n    public void testBuildResponseKeysWithKeyNull() {\r\n        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();\r\n        List<ResponseKey> responseKeyList = new ArrayList<ResponseKey>();\r\n        responseKeyList.add(null);\r\n        String properties = arp.buildResponseKeyExpression(responseKeyList);\r\n        Assert.assertEquals(\"<response-keys = >\", properties);\r\n    }\r\n\r\n    @Test\r\n    public void testBuildSourceSystem() {\r\n        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();\r\n        Assert.assertEquals(\"<source-system = source>\", arp.buildSourceSystem(\"source\"));\r\n    }\r\n\r\n    // @Test\r\n    private List<RequestKey> createRequestKeys() {\r\n        // Create RequestKey object 1\r\n        RequestKey requestKey1 = new RequestKey();\r\n        requestKey1.setKeyName(\"class-type\");\r\n        requestKey1.setKeyValue(\"interface-ip-address\");\r\n\r\n        // Create RequestKey object 2\r\n        RequestKey requestKey2 = new RequestKey();\r\n        requestKey2.setKeyName(\"address_fqdn\");\r\n        requestKey2.setKeyValue(\"00000000000000\");\r\n\r\n        // Create RequestKey object 3\r\n        RequestKey requestKey3 = new RequestKey();\r\n        requestKey3.setKeyName(\"address_type\");\r\n        requestKey3.setKeyValue(\"v4\");\r\n\r\n        // Add the RequestKey Objects to the List\r\n        List<RequestKey> requestKeyList = new ArrayList<RequestKey>();\r\n        requestKeyList.add(requestKey1);\r\n        requestKeyList.add(requestKey2);\r\n        requestKeyList.add(requestKey3);\r\n        return requestKeyList;\r\n    }\r\n\r\n    // @Test\r\n    private List<ResponseKey> createResponseKeys() {\r\n        // Create RequestKey object 1\r\n        ResponseKey responseKey1 = new ResponseKey();\r\n\r\n        responseKey1.setUniqueKeyName(\"address-fqdn\");\r\n        responseKey1.setUniqueKeyValue(\"0000000000000\");\r\n        responseKey1.setFieldKeyName(\"ipaddress-v4\");\r\n\r\n        ResponseKey responseKey2 = new ResponseKey();\r\n        responseKey2.setUniqueKeyName(\"key2\");\r\n        responseKey2.setUniqueKeyValue(\"value2\");\r\n        responseKey2.setFieldKeyName(\"field2\");\r\n\r\n        // Add the RequestKey Objects to the List\r\n        List<ResponseKey> responseKeyList = new ArrayList<ResponseKey>();\r\n        responseKeyList.add(responseKey1);\r\n        responseKeyList.add(responseKey2);\r\n\r\n        return responseKeyList;\r\n    }\r\n"]], "pred": {"ppl": 1.9289429187774658, "ppl_lower": 2.0111265182495117, "ppl/lowercase_ppl": -1.0635078366821071, "ppl/zlib": 0.000687209353965086, "Min_5.0% Prob": 6.9953362894993205, "Min_10.0% Prob": 5.231815604602589, "Min_20.0% Prob": 3.1627163141965866, "Min_30.0% Prob": 2.174008957822533, "Min_40.0% Prob": 1.6379524289486898, "Min_50.0% Prob": 1.3139015135834624, "Min_60.0% Prob": 1.0960562785557162}}
{"hexsha": "678045a3f505e6fae08a6134241817945240b01d", "ext": "java", "lang": "Java", "content": "@Component\r\n@EnableBinding(Sink.class)\r\npublic class MessageListener {\r\n\r\n  @Autowired\r\n  private SimpMessagingTemplate simpMessageTemplate;\r\n  \r\n  @Autowired\r\n  private ObjectMapper objectMapper;\r\n\r\n  @StreamListener(target = Sink.INPUT)\r\n  @Transactional\r\n  public void messageReceived(byte[] messageJsonBytes) throws Exception {\r\n\tString messageJson = new String(messageJsonBytes, \"UTF-8\");  \r\n    Message<JsonNode> message = objectMapper.readValue( //\r\n        messageJson, //\r\n        new TypeReference<Message<JsonNode>>() {});\r\n    \r\n    String type = \"Event\";\r\n    if (message.getType().endsWith(\"Command\")) {\r\n      type = \"Command\";\r\n    }\r\n    \r\n    PastEvent event = new PastEvent( //\r\n        type, //\r\n        message.getType(), //\r\n        message.getTraceid(), //\r\n        message.getSource(), //\r\n        message.getData().toString());\r\n    event.setSourceJson(messageJson);\r\n    \r\n    // save\r\n    LogRepository.instance.addEvent(event);\r\n    \r\n    // and probably send to connected websocket (TODO: Not a good place for the code here!)\r\n    simpMessageTemplate.convertAndSend(\"/topic/events\", event);\r\n  }\r\n\r\n}", "item_id": 0, "repo": "robert0714/flowing-retail", "file": "kafka/java/monitor/src/main/java/io/flowing/retail/monitor/messages/MessageListener.java", "last_update_at": "2022-03-25T09:23:43+00:00", "question_id": "678045a3f505e6fae08a6134241817945240b01d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\r\n@EnableBinding(Sink.class)\r\npublic class MessageListener {\r\n\r\n  @Autowired\r\n  private SimpMessagingTemplate simpMessageTemplate;\r\n  \r\n  @Autowired\r\n  private ObjectMapper objectMapper;\r\n\r\n  @StreamListener(target = Sink.INPUT)\r\n  @Transactional\r\n  public void messageReceived(byte[] messageJsonBytes) throws Exception {\r\n\tString messageJson = new String(messageJsonBytes, \"UTF-8\");  \r\n    Message<JsonNode> message = objectMapper.readValue( //\r\n        messageJson, //\r\n        new TypeReference<Message<JsonNode>>() {});\r\n    \r\n    String type = \"Event\";\r\n    if (message.getType().endsWith(\"Command\")) {\r\n      type = \"Command\";\r\n    }\r\n    \r\n    PastEvent event = new PastEvent( //\r\n        type, //\r\n        message.getType(), //\r\n        message.getTraceid(), //\r\n        message.getSource(), //\r\n        message.getData().toString());\r\n    event.setSourceJson(messageJson);\r\n    \r\n    // save\r\n    LogRepository.instance.addEvent(event);\r\n    \r\n    // and probably send to connected websocket (TODO: Not a good place for the code here!)\r\n    simpMessageTemplate.convertAndSend(\"/topic/events\", event);\r\n  }\r\n\r\n"]], "pred": {"ppl": 2.7940216064453125, "ppl_lower": 3.862844467163086, "ppl/lowercase_ppl": -1.3152579107214526, "ppl/zlib": 0.001902744433265806, "Min_5.0% Prob": 7.8594591319561005, "Min_10.0% Prob": 6.172595143318176, "Min_20.0% Prob": 4.308706135016221, "Min_30.0% Prob": 3.2303162691544514, "Min_40.0% Prob": 2.5164490436552134, "Min_50.0% Prob": 2.041520830970712, "Min_60.0% Prob": 1.7108446173937188}}
{"hexsha": "65bbe3bf9bb6e4d5b37af73b5ce9aac0cdfbd19b", "ext": "java", "lang": "Java", "content": "public class AbstractVsThreadVisualizerTest {\n\n    public AbstractVsThreadVisualizerTest() {\n    }\n\n    @BeforeClass\n    public static void setUpClass() throws Exception\n    {\n        TestJMeterUtils.createJmeterEnv();\n    }\n\n    @AfterClass\n    public static void tearDownClass() throws Exception\n    {\n    }\n\n    @Before\n    public void setUp() {\n    }\n\n    @After\n    public void tearDown() {\n    }\n\n    /**\n     * Test of getCurrentThreadCount method, of class AbstractVsThreadVisualizer.\n     */\n    @Test\n    public void testGetCurrentThreadCount()\n    {\n        System.out.println(\"getCurrentThreadCount\");\n        long now = System.currentTimeMillis();\n        SampleResult sample = new SampleResult();\n        sample.setGroupThreads(3);\n        sample.setThreadName(\"test_tg\");\n        sample.setStampAndTime(now, 300);\n        AbstractVsThreadVisualizer instance = new AbstractVsThreadVisualizerImpl();\n        instance.add(sample);\n        int expResult = 3;\n        int result = instance.getCurrentThreadCount(sample);\n        assertEquals(expResult, result);\n    }\n\n    /**\n     * Test of add method, of class AbstractVsThreadVisualizer.\n     */\n    @Test\n    public void testAdd()\n    {\n        System.out.println(\"add\");\n        SampleResult sample = new SampleResult();\n        AbstractVsThreadVisualizer instance = new AbstractVsThreadVisualizerImpl();\n    }\n\n    /**\n     * Test of clearData method, of class AbstractVsThreadVisualizer.\n     */\n    @Test\n    public void testClearData()\n    {\n        System.out.println(\"clearData\");\n        AbstractVsThreadVisualizer instance = new AbstractVsThreadVisualizerImpl();\n        SampleResult sample = new SampleResult();\n        instance.clearData();\n    }\n\n    public class AbstractVsThreadVisualizerImpl extends AbstractVsThreadVisualizer\n    {\n        @Override\n        protected JSettingsPanel createSettingsPanel()\n        {\n            return new JSettingsPanel(this, JSettingsPanel.GRADIENT_OPTION);\n        }\n\n        @Override\n        public String getLabelResource()\n        {\n            return \"\";\n        }\n\n        @Override\n        public String getStaticLabel()\n        {\n            return \"TEST\";\n        }\n\n        @Override\n        public String getWikiPage() {\n           return \"\";\n        }\n    }\n\n   /**\n    * Test of setExtraChartSettings method, of class AbstractVsThreadVisualizer.\n    */\n   @Test\n   public void testSetExtraChartSettings() {\n      System.out.println(\"setExtraChartSettings\");\n      AbstractVsThreadVisualizer instance = new AbstractVsThreadVisualizerImpl();\n      instance.setExtraChartSettings();\n      assertTrue(instance.getGraphPanelChart().getChartSettings().isDrawCurrentX());\n   }\n\n}", "item_id": 0, "repo": "haiut/jmeter-plugins", "file": "common/test/kg/apc/jmeter/graphs/AbstractVsThreadVisualizerTest.java", "last_update_at": "2022-02-25T04:00:13+00:00", "question_id": "65bbe3bf9bb6e4d5b37af73b5ce9aac0cdfbd19b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AbstractVsThreadVisualizerTest {\n    public AbstractVsThreadVisualizerTest() {\n    }\n    @BeforeClass\n    public static void setUpClass() throws Exception\n    {\n        TestJMeterUtils.createJmeterEnv();\n    }\n    @AfterClass\n    public static void tearDownClass() throws Exception\n    {\n    }\n    @Before\n    public void setUp() {\n    }\n    @After\n    public void tearDown() {\n    }\n    /**\n     * Test of getCurrentThreadCount method, of class AbstractVsThreadVisualizer.\n     */\n    @Test\n    public void testGetCurrentThreadCount()\n    {\n        System.out.println(\"getCurrentThreadCount\");\n        long now = System.currentTimeMillis();\n        SampleResult sample = new SampleResult();\n        sample.setGroupThreads(3);\n        sample.setThreadName(\"test_tg\");\n        sample.setStampAndTime(now, 300);\n        AbstractVsThreadVisualizer instance = new AbstractVsThreadVisualizerImpl();\n        instance.add(sample);\n        int expResult = 3;\n        int result = instance.getCurrentThreadCount(sample);\n        assertEquals(expResult, result);\n    }\n    /**\n     * Test of add method, of class AbstractVsThreadVisualizer.\n     */\n    @Test\n    public void testAdd()\n    {\n        System.out.println(\"add\");\n        SampleResult sample = new SampleResult();\n        AbstractVsThreadVisualizer instance = new AbstractVsThreadVisualizerImpl();\n    }\n    /**\n     * Test of clearData method, of class AbstractVsThreadVisualizer.\n     */\n    @Test\n    public void testClearData()\n    {\n        System.out.println(\"clearData\");\n        AbstractVsThreadVisualizer instance = new AbstractVsThreadVisualizerImpl();\n        SampleResult sample = new SampleResult();\n        instance.clearData();\n    }\n    public class AbstractVsThreadVisualizerImpl extends AbstractVsThreadVisualizer\n    {\n        @Override\n        protected JSettingsPanel createSettingsPanel()\n        {\n            return new JSettingsPanel(this, JSettingsPanel.GRADIENT_OPTION);\n        }\n        @Override\n        public String getLabelResource()\n        {\n            return \"\";\n        }\n        @Override\n        public String getStaticLabel()\n        {\n            return \"TEST\";\n        }\n        @Override\n        public String getWikiPage() {\n           return \"\";\n        }\n    }\n   /**\n    * Test of setExtraChartSettings method, of class AbstractVsThreadVisualizer.\n    */\n   @Test\n   public void testSetExtraChartSettings() {\n      System.out.println(\"setExtraChartSettings\");\n      AbstractVsThreadVisualizer instance = new AbstractVsThreadVisualizerImpl();\n      instance.setExtraChartSettings();\n      assertTrue(instance.getGraphPanelChart().getChartSettings().isDrawCurrentX());\n   }\n"]], "pred": {"ppl": 1.5897797346115112, "ppl_lower": 2.062469482421875, "ppl/lowercase_ppl": -1.5614993714116994, "ppl/zlib": 0.0006777711622000961, "Min_5.0% Prob": 5.480849259240287, "Min_10.0% Prob": 3.794503514195832, "Min_20.0% Prob": 2.2380745869416456, "Min_30.0% Prob": 1.5314169521248617, "Min_40.0% Prob": 1.1569024983546876, "Min_50.0% Prob": 0.9271175255596866, "Min_60.0% Prob": 0.7729094560180301}}
{"hexsha": "27b424150d3bd895974c0c7600095874e1077bf9", "ext": "java", "lang": "Java", "content": "class PurgeTask extends BukkitRunnable {\n\n    //how many players we should check for each tick\n    private static final int INTERVAL_CHECK = 5;\n\n    private final PurgeService purgeService;\n    private final PermissionsManager permissionsManager;\n    private final UUID sender;\n    private final Set<String> toPurge;\n\n    private final OfflinePlayer[] offlinePlayers;\n    private final int totalPurgeCount;\n\n    private int currentPage = 0;\n\n    /**\n     * Constructor.\n     *\n     * @param service the purge service\n     * @param permissionsManager the permissions manager\n     * @param sender the sender who initiated the purge, or null\n     * @param toPurge lowercase names to purge\n     * @param offlinePlayers offline players to map to the names\n     */\n    PurgeTask(PurgeService service, PermissionsManager permissionsManager, CommandSender sender,\n              Set<String> toPurge, OfflinePlayer[] offlinePlayers) {\n        this.purgeService = service;\n        this.permissionsManager = permissionsManager;\n\n        if (sender instanceof Player) {\n            this.sender = ((Player) sender).getUniqueId();\n        } else {\n            this.sender = null;\n        }\n\n        this.toPurge = toPurge;\n        this.totalPurgeCount = toPurge.size();\n        this.offlinePlayers = offlinePlayers;\n    }\n\n    @Override\n    public void run() {\n        if (toPurge.isEmpty()) {\n            //everything was removed\n            finish();\n            return;\n        }\n\n        Set<OfflinePlayer> playerPortion = new HashSet<>(INTERVAL_CHECK);\n        Set<String> namePortion = new HashSet<>(INTERVAL_CHECK);\n        for (int i = 0; i < INTERVAL_CHECK; i++) {\n            int nextPosition = (currentPage * INTERVAL_CHECK) + i;\n            if (offlinePlayers.length <= nextPosition) {\n                //no more offline players on this page\n                break;\n            }\n\n            OfflinePlayer offlinePlayer = offlinePlayers[nextPosition];\n            if (offlinePlayer.getName() != null && toPurge.remove(offlinePlayer.getName().toLowerCase())) {\n                try {\n                    permissionsManager.loadUserData(offlinePlayer.getUniqueId());\n                } catch (NoSuchMethodError e) {\n                    permissionsManager.loadUserData(offlinePlayer.getName());\n                }\n                if (!permissionsManager.hasPermissionOffline(offlinePlayer, PlayerStatePermission.BYPASS_PURGE)) {\n                    playerPortion.add(offlinePlayer);\n                    namePortion.add(offlinePlayer.getName());\n                }\n            }\n        }\n\n        if (!toPurge.isEmpty() && playerPortion.isEmpty()) {\n            ConsoleLogger.info(\"Finished lookup of offlinePlayers. Begin looking purging player names only\");\n\n            //we went through all offlineplayers but there are still names remaining\n            for (String name : toPurge) {\n                if (!permissionsManager.hasPermissionOffline(name, PlayerStatePermission.BYPASS_PURGE)) {\n                    namePortion.add(name);\n                }\n            }\n            toPurge.clear();\n        }\n\n        currentPage++;\n        purgeService.executePurge(playerPortion, namePortion);\n        if (currentPage % 20 == 0) {\n            int completed = totalPurgeCount - toPurge.size();\n            sendMessage(\"[AuthMe] Purge progress \" + completed + '/' + totalPurgeCount);\n        }\n    }\n\n    private void finish() {\n        cancel();\n\n        // Show a status message\n        sendMessage(ChatColor.GREEN + \"[AuthMe] Database has been purged successfully\");\n\n        ConsoleLogger.info(\"Purge finished!\");\n        purgeService.setPurging(false);\n    }\n\n    private void sendMessage(String message) {\n        if (sender == null) {\n            Bukkit.getConsoleSender().sendMessage(message);\n        } else {\n            Player player = Bukkit.getPlayer(sender);\n            if (player != null) {\n                player.sendMessage(message);\n            }\n        }\n    }\n}", "item_id": 0, "repo": "RuiDTLima/diffuzz", "file": "evaluation/github_authmreloaded_unsafe/src/main/java/fr/xephi/authme/task/purge/PurgeTask.java", "last_update_at": "2022-02-03T20:04:11+00:00", "question_id": "27b424150d3bd895974c0c7600095874e1077bf9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class PurgeTask extends BukkitRunnable {\n    //how many players we should check for each tick\n    private static final int INTERVAL_CHECK = 5;\n    private final PurgeService purgeService;\n    private final PermissionsManager permissionsManager;\n    private final UUID sender;\n    private final Set<String> toPurge;\n    private final OfflinePlayer[] offlinePlayers;\n    private final int totalPurgeCount;\n    private int currentPage = 0;\n    /**\n     * Constructor.\n     *\n     * @param service the purge service\n     * @param permissionsManager the permissions manager\n     * @param sender the sender who initiated the purge, or null\n     * @param toPurge lowercase names to purge\n     * @param offlinePlayers offline players to map to the names\n     */\n    PurgeTask(PurgeService service, PermissionsManager permissionsManager, CommandSender sender,\n              Set<String> toPurge, OfflinePlayer[] offlinePlayers) {\n        this.purgeService = service;\n        this.permissionsManager = permissionsManager;\n        if (sender instanceof Player) {\n            this.sender = ((Player) sender).getUniqueId();\n        } else {\n            this.sender = null;\n        }\n        this.toPurge = toPurge;\n        this.totalPurgeCount = toPurge.size();\n        this.offlinePlayers = offlinePlayers;\n    }\n    @Override\n    public void run() {\n        if (toPurge.isEmpty()) {\n            //everything was removed\n            finish();\n            return;\n        }\n        Set<OfflinePlayer> playerPortion = new HashSet<>(INTERVAL_CHECK);\n        Set<String> namePortion = new HashSet<>(INTERVAL_CHECK);\n        for (int i = 0; i < INTERVAL_CHECK; i++) {\n            int nextPosition = (currentPage * INTERVAL_CHECK) + i;\n            if (offlinePlayers.length <= nextPosition) {\n                //no more offline players on this page\n                break;\n            }\n            OfflinePlayer offlinePlayer = offlinePlayers[nextPosition];\n            if (offlinePlayer.getName() != null && toPurge.remove(offlinePlayer.getName().toLowerCase())) {\n                try {\n                    permissionsManager.loadUserData(offlinePlayer.getUniqueId());\n                } catch (NoSuchMethodError e) {\n                    permissionsManager.loadUserData(offlinePlayer.getName());\n                }\n                if (!permissionsManager.hasPermissionOffline(offlinePlayer, PlayerStatePermission.BYPASS_PURGE)) {\n                    playerPortion.add(offlinePlayer);\n                    namePortion.add(offlinePlayer.getName());\n                }\n            }\n        }\n        if (!toPurge.isEmpty() && playerPortion.isEmpty()) {\n            ConsoleLogger.info(\"Finished lookup of offlinePlayers. Begin looking purging player names only\");\n            //we went through all offlineplayers but there are still names remaining\n            for (String name : toPurge) {\n                if (!permissionsManager.hasPermissionOffline(name, PlayerStatePermission.BYPASS_PURGE)) {\n                    namePortion.add(name);\n                }\n            }\n            toPurge.clear();\n        }\n        currentPage++;\n        purgeService.executePurge(playerPortion, namePortion);\n        if (currentPage % 20 == 0) {\n            int completed = totalPurgeCount - toPurge.size();\n            sendMessage(\"[AuthMe] Purge progress \" + completed + '/' + totalPurgeCount);\n        }\n    }\n    private void finish() {\n        cancel();\n        // Show a status message\n        sendMessage(ChatColor.GREEN + \"[AuthMe] Database has been purged successfully\");\n        ConsoleLogger.info(\"Purge finished!\");\n        purgeService.setPurging(false);\n    }\n    private void sendMessage(String message) {\n        if (sender == null) {\n            Bukkit.getConsoleSender().sendMessage(message);\n        } else {\n            Player player = Bukkit.getPlayer(sender);\n            if (player != null) {\n                player.sendMessage(message);\n            }\n        }\n    }\n"]], "pred": {"ppl": 2.0021204948425293, "ppl_lower": 2.273435115814209, "ppl/lowercase_ppl": -1.1830651559179381, "ppl/zlib": 0.0005496491419761524, "Min_5.0% Prob": 6.433140483557009, "Min_10.0% Prob": 4.735671031708811, "Min_20.0% Prob": 3.124779773401279, "Min_30.0% Prob": 2.259539022554759, "Min_40.0% Prob": 1.7254477331464915, "Min_50.0% Prob": 1.3876513834794848, "Min_60.0% Prob": 1.1581010848058153}}
{"hexsha": "175c69ffe0252f291b4f82da237fc1965ab13420", "ext": "java", "lang": "Java", "content": "public class UserFactory {\n\n    private UserRepository userRepository;\n\n    public UserFactory(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    public com.taotao.cloud.stock.biz.domain.model.user.User createUser(Mobile mobile, Email email, Password password, UserName userName, List<RoleId> roleIdList, TenantId currentTenantId) {\n        List<com.taotao.cloud.stock.biz.domain.model.user.User> users = userRepository.find(mobile);\n        com.taotao.cloud.stock.biz.domain.model.user.Account account;\n        if (users != null && !users.isEmpty()) {\n            for (com.taotao.cloud.stock.biz.domain.model.user.User user : users) {\n                if (user.getTenantId().sameValueAs(currentTenantId)) {\n                    throw new RuntimeException(\"\u79df\u6237\u5185\u8d26\u53f7\u5df2\u5b58\u5728\");\n                }\n            }\n            account = users.get(0).getAccount();\n        } else {\n            account = new Account(mobile, email, password);\n        }\n        if (roleIdList == null || roleIdList.isEmpty()) {\n            throw new RuntimeException(\"\u89d2\u8272\u672a\u5206\u914d\");\n        }\n        return new User(userName, account, roleIdList);\n    }\n\n}", "item_id": 0, "repo": "shuigedeng/taotao-cloud-paren", "file": "taotao-cloud-microservice/taotao-cloud-stock/taotao-cloud-stock-biz/src/main/java/com/taotao/cloud/stock/biz/domain/user/model/factory/UserFactory.java", "last_update_at": "2022-03-31T10:30:30+00:00", "question_id": "175c69ffe0252f291b4f82da237fc1965ab13420_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UserFactory {\n    private UserRepository userRepository;\n    public UserFactory(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n    public com.taotao.cloud.stock.biz.domain.model.user.User createUser(Mobile mobile, Email email, Password password, UserName userName, List<RoleId> roleIdList, TenantId currentTenantId) {\n        List<com.taotao.cloud.stock.biz.domain.model.user.User> users = userRepository.find(mobile);\n        com.taotao.cloud.stock.biz.domain.model.user.Account account;\n        if (users != null && !users.isEmpty()) {\n            for (com.taotao.cloud.stock.biz.domain.model.user.User user : users) {\n                if (user.getTenantId().sameValueAs(currentTenantId)) {\n                    throw new RuntimeException(\"\u79df\u6237\u5185\u8d26\u53f7\u5df2\u5b58\u5728\");\n                }\n            }\n            account = users.get(0).getAccount();\n        } else {\n            account = new Account(mobile, email, password);\n        }\n        if (roleIdList == null || roleIdList.isEmpty()) {\n            throw new RuntimeException(\"\u89d2\u8272\u672a\u5206\u914d\");\n        }\n        return new User(userName, account, roleIdList);\n    }\n"]], "pred": {"ppl": 1.8391304016113281, "ppl_lower": 2.101034164428711, "ppl/lowercase_ppl": -1.2185104096006218, "ppl/zlib": 0.0012773435054228275, "Min_5.0% Prob": 6.126311019062996, "Min_10.0% Prob": 4.4348178993571885, "Min_20.0% Prob": 2.7859648848647502, "Min_30.0% Prob": 1.9838037699460984, "Min_40.0% Prob": 1.5155815746802002, "Min_50.0% Prob": 1.2160862737246567, "Min_60.0% Prob": 1.0179443907627457}}
{"hexsha": "4cfefbd5de1e08a28d1a68f0a47c019b22ef9ab3", "ext": "java", "lang": "Java", "content": "public class Physics {\n\n    public static double momentOfInertia(Rigidbody rigidbody){\n        Vector2 c = rigidbody.collider.getCentroid();\n        double totArea = rigidbody.collider.getArea();\n        Vector2 vertices[] = rigidbody.gameObject.collider.getPolygon().getVertices();\n        Matrix_2x2 m = rigidbody.collider.getTransform().getMatrix();\n\n        double iSum = 0;\n        double massDiameterSum = 0;\n\n        for(int i = 0; i < vertices.length; i++){\n            Vector2 v1 = vertices[i].multiply(m);\n            Vector2 v2 = vertices[(i+1)%vertices.length].multiply(m);\n\n            Vector2 bEdge = v2.difference(c);\n            double b = bEdge.magnitude();\n            Vector2 nh = bEdge.leftNormal();\n            double hMin = c.dotProduct(nh);\n            double hMax = v1.dotProduct(nh);\n            double h = Math.abs(hMax - hMin);\n\n            Vector2 na = bEdge.normalize();\n            double aMin = c.dotProduct(na);\n            double aMax = v1.dotProduct(na);\n            double a = Math.abs(aMax-aMin);\n\n            double I = (b*b*b*h-b*b*h*a+b*h*a*a+b*h*h*h)/36;\n\n            iSum += I;\n\n            Polygon p = new Polygon(new Vector2[]{v1,v2,c});\n            PolygonGeometry pg = PolygonGeometry.getPolygonGeometry(p);\n            double triArea = pg.getArea();\n            Vector2 cT = pg.getCentroid();\n\n            double d2 = cT.difference(c).nonSqrtMagnitude();\n\n            massDiameterSum += (triArea/totArea)*d2;\n        }\n        return iSum+massDiameterSum*rigidbody.getMass();\n    }\n\n    /**\n     * Resolves overlap based on velocity. Such that each collider is moved as much as they contributed to the overlap.\n     * For example if v1=5 and v2=15 then p1 is responsible for 25% of the overlap and p2 75%\n     *\n     * This overlap resolver is very simple. It only resolves overlap on a one collision at a time basis.\n     *\n     * @param collisionClips    Collision clips\n     *\n     * @return  Resolved collision. With adjusted contact information.\n     */\n    public static ArrayList<Collision> resolveOverlap(Collection<CollisionClip> collisionClips){\n        ArrayList<Collision> resolvedCollision = new ArrayList<>();\n\n        for(CollisionClip collisionClip : collisionClips){\n            if(!collisionClip.isCollision()){\n                resolvedCollision.add(new Collision(collisionClip,new ArrayList<>()));\n                continue;\n            }\n            Rigidbody rig1 = collisionClip.getC1().gameObject.rigidbody;\n            Rigidbody rig2 = collisionClip.getC2().gameObject.rigidbody;\n            Vector2 mtv = collisionClip.getMTV();\n            if ((!rig1.isKinematic && !rig2.isKinematic))\n                continue;\n            if(mtv.magnitude() == 0){\n                continue;\n            }\n\n            double m;\n\n            double d1 = rig1.getVelocity().dotProduct(mtv);\n            double d2 = rig2.getVelocity().dotProduct(mtv);\n\n            //Calculate percentage of overlap contribution.\n            if(!rig1.isKinematic || !rig2.isKinematic){\n                m = 0.5;\n                if(rig1.isKinematic) {\n                    m += 0.5;\n                } else if(rig2.isKinematic) {\n                    m -= 0.5;\n                }\n            }\n            else if(d1*d2 < 0){\n                m = Math.abs(d1) / (Math.abs(d1) + Math.abs(d2));\n            } else {\n                if(Math.abs(d1) > Math.abs(d2)){\n                    m = 1.0;\n                } else if(Math.abs(d2) > Math.abs(d1)){\n                    m = 0.0;\n                } else{\n                    m = 0.5;\n                }\n            }\n\n            rig1.gameObject.transform.translate(mtv.multiply(m));\n            rig2.gameObject.transform.translate(mtv.inverse().multiply(1 - m));\n\n            resolvedCollision.add(new Collision(collisionClip,collisionClip.getCollisionManifold(m)));\n        }\n\n        return resolvedCollision;\n    }\n\n    public static void resolveCollisions(Collection<Collision> collisions){\n        for (Collision collision : collisions) {\n            resolveCollision(collision);\n        }\n    }\n\n    /**\n     * Resolve collision between two rigidbodies.\n     * Utilizes an Impulse-based reaction model.\n     * Computes reactionary forces for the two bodies involved in the collision.\n     * Computes angular and linear forces.\n     *\n     * @param collision Collision information.\n     */\n    public static void resolveCollision(Collision collision){\n        if(!collision.isCollision())\n            return;\n        Rigidbody rig1 = collision.getC1().gameObject.rigidbody;\n        Rigidbody rig2 = collision.getC2().gameObject.rigidbody;\n\n        Vector2 n = collision.getContactNormal();\n\n\n        ArrayList<Vector2> collisionManifold = collision.getContactManifold();\n\n        int size = collisionManifold.size();\n        Edge e1 = collision.getE1();\n        Edge e2 = collision.getE2();\n        boolean closeParalell = false;\n\n        if(size == 2){\n            Vector2 v1 = collisionManifold.get(0);\n            Vector2 v2 = collisionManifold.get(1);\n            Vector2 p = n.leftNormal();\n            double d1 = v1.dotProduct(p);\n            double d2 = v2.dotProduct(p);\n            double c1 = rig1.collider.getWorldCentroid().dotProduct(p);\n            double c2 = rig2.collider.getWorldCentroid().dotProduct(p);\n            double c1d1 = d1-c1;\n            double c1d2 = d2-c1;\n            double c2d1 = d1-c2;\n            double c2d2 = d2-c2;\n\n            boolean diffSides1 = c1d1*c1d2 <= 0;\n            boolean diffSides2 = c2d1*c2d2 <= 0;\n\n\n            if(e1 != null && e2 != null) {\n                Vector2 en1 = e1.getR().leftNormal();\n                Vector2 en2 = e2.getR().leftNormal();\n\n                //This also uses the fact that in collision clip when two clip points are 0.01 units apart they count as\n                // being the same depth\n                closeParalell = en1.dotProduct(en2) < -0.9995 && size == 2;\n\n\n                //This is to fix rocking which arises when using constant forces such as gravity\n                if (closeParalell && Math.abs(rig1.getAngularVelocity()) < 0.2 && Math.abs(rig2.getAngularVelocity()) < 0.2\n                        && (!rig1.isKinematic || !rig2.isKinematic)) {\n                    if (collision.isFlip() && rig1.isKinematic && rig1.isRotatable && diffSides1) {\n                        rig1.gameObject.transform.align(en1, en2.inverse());\n                        rig1.setAngMomentum(0);\n                    } else if (rig2.isKinematic && rig2.isRotatable && diffSides2) {\n                        rig2.gameObject.transform.align(en2, en1.inverse());\n                        rig2.setAngMomentum(0);\n                    } else{\n                        closeParalell = false;\n                    }\n\n\n                } else {\n                    closeParalell = false;\n                }\n            }\n\n\n            double jr1 = getJr(rig1,rig2,v1,n);\n            double jr2 = getJr(rig1,rig2,v2,n);\n            Vector2 middle = v1.add(v2.difference(v1).multiply(0.5));\n            double jrMiddle = getJr(rig1,rig2,middle,n);\n\n            if(rig1.isKinematic) {\n                if (diffSides1) {\n                    if(!closeParalell) {\n                        rig1.addReactionForceAngular(jr1, n.inverse(), v1);\n                        rig1.addReactionForceAngular(jr2, n.inverse(), v2);;\n                    }\n                    rig1.addReactionForceLinear(jrMiddle, n.inverse(), middle);\n                } else {\n                    if(!closeParalell) {\n                        rig1.addReactionForceAngular(jrMiddle, n.inverse(), middle);\n                    }\n                    rig1.addReactionForceLinear(jrMiddle, n.inverse(), middle);\n                }\n            }\n\n            if(rig2.isKinematic) {\n                if (diffSides2) {\n                    if(!closeParalell) {\n                        rig2.addReactionForceAngular(jr1, n, v1);\n                        rig2.addReactionForceAngular(jr2, n, v2);\n                    }\n                    rig2.addReactionForceLinear(jrMiddle, n, middle);\n                } else {\n                    if(!closeParalell) {\n                        rig2.addReactionForceAngular(jrMiddle, n, middle);\n                    }\n                    rig2.addReactionForceLinear(jrMiddle, n, middle);\n                }\n            }\n            collision.setReactionImpulse(jrMiddle);\n        }\n        else if(size == 1){\n            Vector2 cPoint = collisionManifold.get(0);\n            double jr = getJr(rig1,rig2, cPoint,n);\n            if (rig1.isKinematic) {\n                if(!closeParalell) {\n                    rig1.addReactionForceAngular(jr, n.inverse(), cPoint);\n                }\n                rig1.addReactionForceLinear(jr, n.inverse(), cPoint);\n            }\n            if (rig2.isKinematic) {\n                if(!closeParalell) {\n                    rig2.addReactionForceAngular(jr, n, cPoint);\n                }\n                rig2.addReactionForceLinear(jr, n, cPoint);\n            }\n            collision.setReactionImpulse(jr);\n        }\n\n    }\n\n    /**\n     * Calculate reaction impulse magnitude.\n     *\n     * @param rig1      rig1\n     * @param rig2      rig2\n     * @param cPoint    contact point\n     * @param n         contact normal\n     * @return          reaction impuluse magnitude.\n     */\n    private static double getJr(Rigidbody rig1, Rigidbody rig2, Vector2 cPoint, Vector2 n){\n        Vector2 r1 = cPoint.difference(rig1.collider.getWorldCentroid()).multiply(1.0);\n        Vector2 r2 = cPoint.difference(rig2.collider.getWorldCentroid()).multiply(1.0);\n        Vector2 r1n = r1.rightNormal();\n        Vector2 r2n = r2.rightNormal();\n        double r1Mag = r1.magnitude();\n        double r2Mag = r2.magnitude();\n        double oneDivI1;\n        if(rig1.isKinematic)\n            oneDivI1 = 1/rig1.getMomentOfInertia();\n        else\n            oneDivI1 = 0;\n        double oneDivI2;\n        if(rig2.isKinematic)\n            oneDivI2 = 1/rig2.getMomentOfInertia();\n        else\n            oneDivI2 = 0;\n        double oneDivm1;\n        if(rig1.isKinematic)\n            oneDivm1 =  1/rig1.getMass();\n        else\n            oneDivm1 = 0;\n        double oneDivm2;\n        if(rig2.isKinematic)\n            oneDivm2 =  1/rig2.getMass();\n        else\n            oneDivm2 = 0;\n\n        Vector2 vp1 = rig1.getVelocity().add(rig1.getCrossRadialVelocity(cPoint));\n        Vector2 vp2 = rig2.getVelocity().add(rig2.getCrossRadialVelocity(cPoint));\n        Vector2 vr = vp2.difference(vp1);\n\n        double K = oneDivm2 + oneDivm1 + (r2n.multiply((oneDivI2)*(r2n.dotProduct(n))*r2Mag).add(r1n.multiply(\n                (oneDivI1)*(r1n.dotProduct(n))*r1Mag))).dotProduct(n);\n\n\n        double e = (rig1.elasticity+rig2.elasticity)/2;\n\n        double jr = (-1-e)*(vr.dotProduct(n))/K;\n        return jr;\n    }\n\n    public static void resolveFrictions(ArrayList<Collision> collisions){\n        for (Collision collision:collisions) {\n            resolveFriction(collision);\n        }\n    }\n\n    /**\n     * Computes and applies frictional forces induced from collision between two rigid bodies.\n     * Impulse-based friction model.\n     *\n     * @param collision\n     */\n    public static void resolveFriction(Collision collision){\n        if(!collision.isCollision())\n            return;\n        Rigidbody rig1 = collision.getC1().gameObject.rigidbody;\n        Rigidbody rig2 = collision.getC2().gameObject.rigidbody;\n\n        Vector2 n = collision.getContactNormal();\n        Vector2 cPoint;\n        ArrayList<Vector2> contactManifold = collision.getContactManifold();\n        if(contactManifold.size() == 2){\n            cPoint = contactManifold.get(0).add(contactManifold.get(1).difference(contactManifold.get(0)).multiply(0.5));\n        } else if (contactManifold.size() == 1){\n            cPoint = contactManifold.get(0);\n        }\n        else{\n            return;\n        }\n        Vector2 vp1 = rig1.getVelocity().add(rig1.getCrossRadialVelocity(cPoint));\n        Vector2 vp2 = rig2.getVelocity().add(rig2.getCrossRadialVelocity(cPoint));\n        Vector2 vr1 = vp2.difference(vp1);\n        Vector2 vr2 = vp1.difference(vp2);\n        Vector2 fe1 = rig1.getMomentumForce();\n        Vector2 fe2 = rig2.getMomentumForce();\n\n        Vector2 t1, t2;\n        double vr1nDot = vr1.dotProduct(n);\n        double vr2nDot = vr2.dotProduct(n);\n        double fe1Dot = fe1.dotProduct(n);\n        double fe2Dot = fe2.dotProduct(n);\n\n        if(vr1nDot != 0){\n            t1 = vr1.difference(n.multiply(vr1nDot)).normalize();\n        }\n        else if(fe1Dot != 0){\n            t1 = fe1.difference(n.multiply(fe1Dot)).normalize();\n        }\n        else{\n            t1 = new Vector2();\n        }\n\n        if(vr2nDot != 0){\n            t2 = vr2.difference(n.multiply(vr2nDot));\n            t2 = t2.normalize();\n        }\n        else if(fe2Dot != 0){\n            t2 = fe2.difference(n.multiply(fe2Dot)).normalize();\n        }\n        else{\n            t2 = new Vector2();\n        }\n\n        double us = (rig1.staticFriction+rig2.staticFriction)/2;\n        double ud = (rig1.dynamicFriction+rig2.dynamicFriction)/2;\n        //ud = 0;\n        //us = 0;\n        double jr = collision.getReactionImpulse();\n        double js = jr*us;\n        double jd = jr*ud;\n        double vrt1Dot = vr1.dotProduct(t1);\n        double vrt2Dot = vr2.dotProduct(t2);\n        double m1 = rig1.getMass();\n        double m2 = rig2.getMass();\n\n        double jf1;\n        if(vrt1Dot == 0 && vrt1Dot*m1 <= js){\n            jf1 = -(m1*vrt1Dot);\n        }\n        else{\n            jf1 = -jd;\n        }\n\n        double jf2;\n        if(vrt2Dot == 0 && vrt2Dot*m2 <= js){\n            jf2 = -(m2*vrt2Dot);\n        }\n        else{\n            jf2 = -jd;\n        }\n\n        if(jf2 == 0.0 && jf1 == 0)\n            return;\n\n\n        boolean z1 = false, z2 = false;\n        if(contactManifold.size() == 2 ){\n            Vector2 rn = n.rightNormal();\n            double dot1 = rn.dotProduct(rig1.getVelocity());\n            double dot2 = rn.dotProduct(rig2.getVelocity());\n\n            //This is to fix micro sliding when parallel to a surface\n            if(rig1.isKinematic && Math.abs(dot1) < 0.2){\n                rig1.addReactionForceLinear(dot1*rig1.getMass(), rn.inverse(), rig1.collider\n                        .getWorldCentroid());\n                z1 = true;\n            }\n            if(rig2.isKinematic && Math.abs(dot2) < 0.2){\n                rig2.addReactionForceLinear(dot2*rig2.getMass(), rn.inverse(), rig2.collider\n                        .getWorldCentroid());\n                z2 = true;\n            }\n        }\n        if(rig1.isKinematic && !z1) {\n            rig1.addReactionForce(jf1, t1.inverse(), rig1.collider.getWorldCentroid());\n            rig1.addReactionForce(jf2, t2, rig1.collider.getWorldCentroid());\n        }\n        if(rig2.isKinematic && !z2) {\n            rig2.addReactionForce(jf2, t2.inverse(), rig2.collider.getWorldCentroid());\n            rig2.addReactionForce(jf1, t1, rig2.collider.getWorldCentroid());\n        }\n    }\n}", "item_id": 0, "repo": "eJatte/Simple-2D-physics-engine", "file": "src/main/java/Andromeda/Physics/Physics.java", "last_update_at": "2022-01-23T08:51:20+00:00", "question_id": "4cfefbd5de1e08a28d1a68f0a47c019b22ef9ab3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Physics {\n    public static double momentOfInertia(Rigidbody rigidbody){\n        Vector2 c = rigidbody.collider.getCentroid();\n        double totArea = rigidbody.collider.getArea();\n        Vector2 vertices[] = rigidbody.gameObject.collider.getPolygon().getVertices();\n        Matrix_2x2 m = rigidbody.collider.getTransform().getMatrix();\n        double iSum = 0;\n        double massDiameterSum = 0;\n        for(int i = 0; i < vertices.length; i++){\n            Vector2 v1 = vertices[i].multiply(m);\n            Vector2 v2 = vertices[(i+1)%vertices.length].multiply(m);\n            Vector2 bEdge = v2.difference(c);\n            double b = bEdge.magnitude();\n            Vector2 nh = bEdge.leftNormal();\n            double hMin = c.dotProduct(nh);\n            double hMax = v1.dotProduct(nh);\n            double h = Math.abs(hMax - hMin);\n            Vector2 na = bEdge.normalize();\n            double aMin = c.dotProduct(na);\n            double aMax = v1.dotProduct(na);\n            double a = Math.abs(aMax-aMin);\n            double I = (b*b*b*h-b*b*h*a+b*h*a*a+b*h*h*h)/36;\n            iSum += I;\n            Polygon p = new Polygon(new Vector2[]{v1,v2,c});\n            PolygonGeometry pg = PolygonGeometry.getPolygonGeometry(p);\n            double triArea = pg.getArea();\n            Vector2 cT = pg.getCentroid();\n            double d2 = cT.difference(c).nonSqrtMagnitude();\n            massDiameterSum += (triArea/totArea)*d2;\n        }\n        return iSum+massDiameterSum*rigidbody.getMass();\n    }\n    /**\n     * Resolves overlap based on velocity. Such that each collider is moved as much as they contributed to the overlap.\n     * For example if v1=5 and v2=15 then p1 is responsible for 25% of the overlap and p2 75%\n     *\n     * This overlap resolver is very simple. It only resolves overlap on a one collision at a time basis.\n     *\n     * @param collisionClips    Collision clips\n     *\n     * @return  Resolved collision. With adjusted contact information.\n     */\n    public static ArrayList<Collision> resolveOverlap(Collection<CollisionClip> collisionClips){\n        ArrayList<Collision> resolvedCollision = new ArrayList<>();\n        for(CollisionClip collisionClip : collisionClips){\n            if(!collisionClip.isCollision()){\n                resolvedCollision.add(new Collision(collisionClip,new ArrayList<>()));\n                continue;\n            }\n            Rigidbody rig1 = collisionClip.getC1().gameObject.rigidbody;\n            Rigidbody rig2 = collisionClip.getC2().gameObject.rigidbody;\n            Vector2 mtv = collisionClip.getMTV();\n            if ((!rig1.isKinematic && !rig2.isKinematic))\n                continue;\n            if(mtv.magnitude() == 0){\n                continue;\n            }\n            double m;\n            double d1 = rig1.getVelocity().dotProduct(mtv);\n            double d2 = rig2.getVelocity().dotProduct(mtv);\n            //Calculate percentage of overlap contribution.\n            if(!rig1.isKinematic || !rig2.isKinematic){\n                m = 0.5;\n                if(rig1.isKinematic) {\n                    m += 0.5;\n                } else if(rig2.isKinematic) {\n                    m -= 0.5;\n                }\n            }\n            else if(d1*d2 < 0){\n                m = Math.abs(d1) / (Math.abs(d1) + Math.abs(d2));\n            } else {\n                if(Math.abs(d1) > Math.abs(d2)){\n                    m = 1.0;\n                } else if(Math.abs(d2) > Math.abs(d1)){\n                    m = 0.0;\n                } else{\n                    m = 0.5;\n                }\n            }\n            rig1.gameObject.transform.translate(mtv.multiply(m));\n            rig2.gameObject.transform.translate(mtv.inverse().multiply(1 - m));\n            resolvedCollision.add(new Collision(collisionClip,collisionClip.getCollisionManifold(m)));\n        }\n        return resolvedCollision;\n    }\n    public static void resolveCollisions(Collection<Collision> collisions){\n        for (Collision collision : collisions) {\n            resolveCollision(collision);\n        }\n    }\n    /**\n     * Resolve collision between two rigidbodies.\n     * Utilizes an Impulse-based reaction model.\n     * Computes reactionary forces for the two bodies involved in the collision.\n     * Computes angular and linear forces.\n     *\n     * @param collision Collision information.\n     */\n    public static void resolveCollision(Collision collision){\n        if(!collision.isCollision())\n            return;\n        Rigidbody rig1 = collision.getC1().gameObject.rigidbody;\n        Rigidbody rig2 = collision.getC2().gameObject.rigidbody;\n        Vector2 n = collision.getContactNormal();\n        ArrayList<Vector2> collisionManifold = collision.getContactManifold();\n        int size = collisionManifold.size();\n        Edge e1 = collision.getE1();\n        Edge e2 = collision.getE2();\n        boolean closeParalell = false;\n        if(size == 2){\n            Vector2 v1 = collisionManifold.get(0);\n            Vector2 v2 = collisionManifold.get(1);\n            Vector2 p = n.leftNormal();\n            double d1 = v1.dotProduct(p);\n            double d2 = v2.dotProduct(p);\n            double c1 = rig1.collider.getWorldCentroid().dotProduct(p);\n            double c2 = rig2.collider.getWorldCentroid().dotProduct(p);\n            double c1d1 = d1-c1;\n            double c1d2 = d2-c1;\n            double c2d1 = d1-c2;\n            double c2d2 = d2-c2;\n            boolean diffSides1 = c1d1*c1d2 <= 0;\n            boolean diffSides2 = c2d1*c2d2 <= 0;\n            if(e1 != null && e2 != null) {\n                Vector2 en1 = e1.getR().leftNormal();\n                Vector2 en2 = e2.getR().leftNormal();\n                //This also uses the fact that in collision clip when two clip points are 0.01 units apart they count as\n                // being the same depth\n                closeParalell = en1.dotProduct(en2) < -0.9995 && size == 2;\n                //This is to fix rocking which arises when using constant forces such as gravity\n                if (closeParalell && Math.abs(rig1.getAngularVelocity()) < 0.2 && Math.abs(rig2.getAngularVelocity()) < 0.2\n                        && (!rig1.isKinematic || !rig2.isKinematic)) {\n                    if (collision.isFlip() && rig1.isKinematic && rig1.isRotatable && diffSides1) {\n                        rig1.gameObject.transform.align(en1, en2.inverse());\n                        rig1.setAngMomentum(0);\n                    } else if (rig2.isKinematic && rig2.isRotatable && diffSides2) {\n                        rig2.gameObject.transform.align(en2, en1.inverse());\n                        rig2.setAngMomentum(0);\n                    } else{\n                        closeParalell = false;\n                    }\n                } else {\n                    closeParalell = false;\n                }\n            }\n            double jr1 = getJr(rig1,rig2,v1,n);\n            double jr2 = getJr(rig1,rig2,v2,n);\n            Vector2 middle = v1.add(v2.difference(v1).multiply(0.5));\n            double jrMiddle = getJr(rig1,rig2,middle,n);\n            if(rig1.isKinematic) {\n                if (diffSides1) {\n                    if(!closeParalell) {\n                        rig1.addReactionForceAngular(jr1, n.inverse(), v1);\n                        rig1.addReactionForceAngular(jr2, n.inverse(), v2);;\n                    }\n                    rig1.addReactionForceLinear(jrMiddle, n.inverse(), middle);\n                } else {\n                    if(!closeParalell) {\n                        rig1.addReactionForceAngular(jrMiddle, n.inverse(), middle);\n                    }\n                    rig1.addReactionForceLinear(jrMiddle, n.inverse(), middle);\n                }\n            }\n            if(rig2.isKinematic) {\n                if (diffSides2) {\n                    if(!closeParalell) {\n                        rig2.addReactionForceAngular(jr1, n, v1);\n                        rig2.addReactionForceAngular(jr2, n, v2);\n                    }\n                    rig2.addReactionForceLinear(jrMiddle, n, middle);\n                } else {\n                    if(!closeParalell) {\n                        rig2.addReactionForceAngular(jrMiddle, n, middle);\n                    }\n                    rig2.addReactionForceLinear(jrMiddle, n, middle);\n                }\n            }\n            collision.setReactionImpulse(jrMiddle);\n        }\n        else if(size == 1){\n            Vector2 cPoint = collisionManifold.get(0);\n            double jr = getJr(rig1,rig2, cPoint,n);\n            if (rig1.isKinematic) {\n                if(!closeParalell) {\n                    rig1.addReactionForceAngular(jr, n.inverse(), cPoint);\n                }\n                rig1.addReactionForceLinear(jr, n.inverse(), cPoint);\n            }\n            if (rig2.isKinematic) {\n                if(!closeParalell) {\n                    rig2.addReactionForceAngular(jr, n, cPoint);\n                }\n                rig2.addReactionForceLinear(jr, n, cPoint);\n            }\n            collision.setReactionImpulse(jr);\n        }\n    }\n    /**\n     * Calculate reaction impulse magnitude.\n     *\n     * @param rig1      rig1\n     * @param rig2      rig2\n     * @param cPoint    contact point\n     * @param n         contact normal\n     * @return          reaction impuluse magnitude.\n     */\n    private static double getJr(Rigidbody rig1, Rigidbody rig2, Vector2 cPoint, Vector2 n){\n        Vector2 r1 = cPoint.difference(rig1.collider.getWorldCentroid()).multiply(1.0);\n        Vector2 r2 = cPoint.difference(rig2.collider.getWorldCentroid()).multiply(1.0);\n        Vector2 r1n = r1.rightNormal();\n        Vector2 r2n = r2.rightNormal();\n        double r1Mag = r1.magnitude();\n        double r2Mag = r2.magnitude();\n        double oneDivI1;\n        if(rig1.isKinematic)\n            oneDivI1 = 1/rig1.getMomentOfInertia();\n        else\n            oneDivI1 = 0;\n        double oneDivI2;\n        if(rig2.isKinematic)\n            oneDivI2 = 1/rig2.getMomentOfInertia();\n        else\n            oneDivI2 = 0;\n        double oneDivm1;\n        if(rig1.isKinematic)\n            oneDivm1 =  1/rig1.getMass();\n        else\n            oneDivm1 = 0;\n        double oneDivm2;\n        if(rig2.isKinematic)\n            oneDivm2 =  1/rig2.getMass();\n        else\n            oneDivm2 = 0;\n        Vector2 vp1 = rig1.getVelocity().add(rig1.getCrossRadialVelocity(cPoint));\n        Vector2 vp2 = rig2.getVelocity().add(rig2.getCrossRadialVelocity(cPoint));\n        Vector2 vr = vp2.difference(vp1);\n        double K = oneDivm2 + oneDivm1 + (r2n.multiply((oneDivI2)*(r2n.dotProduct(n))*r2Mag).add(r1n.multiply(\n                (oneDivI1)*(r1n.dotProduct(n))*r1Mag))).dotProduct(n);\n        double e = (rig1.elasticity+rig2.elasticity)/2;\n        double jr = (-1-e)*(vr.dotProduct(n))/K;\n        return jr;\n    }\n    public static void resolveFrictions(ArrayList<Collision> collisions){\n        for (Collision collision:collisions) {\n            resolveFriction(collision);\n        }\n    }\n    /**\n     * Computes and applies frictional forces induced from collision between two rigid bodies.\n     * Impulse-based friction model.\n     *\n     * @param collision\n     */\n    public static void resolveFriction(Collision collision){\n        if(!collision.isCollision())\n            return;\n        Rigidbody rig1 = collision.getC1().gameObject.rigidbody;\n        Rigidbody rig2 = collision.getC2().gameObject.rigidbody;\n        Vector2 n = collision.getContactNormal();\n        Vector2 cPoint;\n        ArrayList<Vector2> contactManifold = collision.getContactManifold();\n        if(contactManifold.size() == 2){\n            cPoint = contactManifold.get(0).add(contactManifold.get(1).difference(contactManifold.get(0)).multiply(0.5));\n        } else if (contactManifold.size() == 1){\n            cPoint = contactManifold.get(0);\n        }\n        else{\n            return;\n        }\n        Vector2 vp1 = rig1.getVelocity().add(rig1.getCrossRadialVelocity(cPoint));\n        Vector2 vp2 = rig2.getVelocity().add(rig2.getCrossRadialVelocity(cPoint));\n        Vector2 vr1 = vp2.difference(vp1);\n        Vector2 vr2 = vp1.difference(vp2);\n        Vector2 fe1 = rig1.getMomentumForce();\n        Vector2 fe2 = rig2.getMomentumForce();\n        Vector2 t1, t2;\n        double vr1nDot = vr1.dotProduct(n);\n        double vr2nDot = vr2.dotProduct(n);\n        double fe1Dot = fe1.dotProduct(n);\n        double fe2Dot = fe2.dotProduct(n);\n        if(vr1nDot != 0){\n            t1 = vr1.difference(n.multiply(vr1nDot)).normalize();\n        }\n        else if(fe1Dot != 0){\n            t1 = fe1.difference(n.multiply(fe1Dot)).normalize();\n        }\n        else{\n            t1 = new Vector2();\n        }\n        if(vr2nDot != 0){\n            t2 = vr2.difference(n.multiply(vr2nDot));\n            t2 = t2.normalize();\n        }\n        else if(fe2Dot != 0){\n            t2 = fe2.difference(n.multiply(fe2Dot)).normalize();\n        }\n        else{\n            t2 = new Vector2();\n        }\n        double us = (rig1.staticFriction+rig2.staticFriction)/2;\n        double ud = (rig1.dynamicFriction+rig2.dynamicFriction)/2;\n        //ud = 0;\n        //us = 0;\n        double jr = collision.getReactionImpulse();\n        double js = jr*us;\n        double jd = jr*ud;\n        double vrt1Dot = vr1.dotProduct(t1);\n        double vrt2Dot = vr2.dotProduct(t2);\n        double m1 = rig1.getMass();\n        double m2 = rig2.getMass();\n        double jf1;\n        if(vrt1Dot == 0 && vrt1Dot*m1 <= js){\n            jf1 = -(m1*vrt1Dot);\n        }\n        else{\n            jf1 = -jd;\n        }\n        double jf2;\n        if(vrt2Dot == 0 && vrt2Dot*m2 <= js){\n            jf2 = -(m2*vrt2Dot);\n        }\n        else{\n            jf2 = -jd;\n        }\n        if(jf2 == 0.0 && jf1 == 0)\n            return;\n        boolean z1 = false, z2 = false;\n        if(contactManifold.size() == 2 ){\n            Vector2 rn = n.rightNormal();\n            double dot1 = rn.dotProduct(rig1.getVelocity());\n            double dot2 = rn.dotProduct(rig2.getVelocity());\n            //This is to fix micro sliding when parallel to a surface\n            if(rig1.isKinematic && Math.abs(dot1) < 0.2){\n                rig1.addReactionForceLinear(dot1*rig1.getMass(), rn.inverse(), rig1.collider\n                        .getWorldCentroid());\n                z1 = true;\n            }\n            if(rig2.isKinematic && Math.abs(dot2) < 0.2){\n                rig2.addReactionForceLinear(dot2*rig2.getMass(), rn.inverse(), rig2.collider\n                        .getWorldCentroid());\n                z2 = true;\n            }\n        }\n        if(rig1.isKinematic && !z1) {\n            rig1.addReactionForce(jf1, t1.inverse(), rig1.collider.getWorldCentroid());\n            rig1.addReactionForce(jf2, t2, rig1.collider.getWorldCentroid());\n        }\n        if(rig2.isKinematic && !z2) {\n            rig2.addReactionForce(jf2, t2.inverse(), rig2.collider.getWorldCentroid());\n            rig2.addReactionForce(jf1, t1, rig2.collider.getWorldCentroid());\n        }\n    }\n"]], "pred": {"ppl": 2.4461145401000977, "ppl_lower": 2.632589817047119, "ppl/lowercase_ppl": -1.0821320831317507, "ppl/zlib": 0.00027762286271972557, "Min_5.0% Prob": 6.954530669193642, "Min_10.0% Prob": 5.297616846421185, "Min_20.0% Prob": 3.684981920555526, "Min_30.0% Prob": 2.7695243198887196, "Min_40.0% Prob": 2.177501744410811, "Min_50.0% Prob": 1.7758359756400908, "Min_60.0% Prob": 1.4890459077204858}}
{"hexsha": "c9e5258a78fe8b1cf3cefd85165a8d79d7b38649", "ext": "java", "lang": "Java", "content": "public class RMManagerConfigurationTest {\n\n    private Bus bus;\n\n    @After\n    public void tearDown() {\n        bus.shutdown(true);\n        BusFactory.setDefaultBus(null);\n    }\n\n    @Test\n    public void testManagerBean() {\n        SpringBusFactory factory = new SpringBusFactory();\n        bus = factory.createBus(\"org/apache/cxf/ws/rm/manager-bean.xml\", false);\n        RMManager manager = bus.getExtension(RMManager.class);\n        verifyManager(manager);\n    }\n\n    @Test\n    public void testExactlyOnce() {\n        SpringBusFactory factory = new SpringBusFactory();\n        bus = factory.createBus(\"org/apache/cxf/ws/rm/exactly-once.xml\", false);\n        RMManager manager = bus.getExtension(RMManager.class);\n        RMConfiguration cfg = manager.getConfiguration();\n        DeliveryAssurance da = cfg.getDeliveryAssurance();\n        assertEquals(da, DeliveryAssurance.EXACTLY_ONCE);\n        assertFalse(cfg.isInOrder());\n    }\n\n    @Test\n    public void testFeature() {\n        SpringBusFactory factory = new SpringBusFactory();\n        bus = factory.createBus(\"org/apache/cxf/ws/rm/feature.xml\");\n        RMManager manager = bus.getExtension(RMManager.class);\n        verifyManager(manager);\n    }\n\n    private void verifyManager(RMManager manager) {\n        assertNotNull(manager);\n        assertTrue(manager.getSourcePolicy().getSequenceTerminationPolicy().isTerminateOnShutdown());\n        assertEquals(0L, manager.getDestinationPolicy().getAcksPolicy().getIntraMessageThreshold());\n        assertEquals(2000L, manager.getDestinationPolicy().getAcksPolicy().getImmediaAcksTimeout());\n        assertEquals(10000L, manager.getConfiguration().getBaseRetransmissionInterval().longValue());\n        assertEquals(10000L, manager.getConfiguration().getAcknowledgementInterval().longValue());\n        assertEquals(\"http://www.w3.org/2005/08/addressing\", manager.getConfiguration().getRM10AddressingNamespace());\n        TestStore store = (TestStore)manager.getStore();\n        assertEquals(\"here\", store.getLocation());\n        assertTrue(manager.getConfiguration().isInOrder());\n    }\n\n    static class TestStore implements RMStore {\n\n        private String location;\n\n        TestStore() {\n            // this(null);\n        }\n\n        public String getLocation() {\n            return location;\n        }\n\n        public void setLocation(String location) {\n            this.location = location;\n        }\n\n\n\n        public void createDestinationSequence(DestinationSequence seq) {\n    \n        }\n\n        public void createSourceSequence(SourceSequence seq) {\n    \n        }\n\n        public Collection<DestinationSequence> getDestinationSequences(String endpointIdentifier) {\n            return null;\n        }\n\n        public Collection<RMMessage> getMessages(Identifier sid, boolean outbound) {\n            return null;\n        }\n\n        public Collection<SourceSequence> getSourceSequences(String endpointIdentifier) {\n            return null;\n        }\n\n        public void persistIncoming(DestinationSequence seq, RMMessage msg) {\n    \n        }\n\n        public void persistOutgoing(SourceSequence seq, RMMessage msg) {\n    \n        }\n\n        public void removeDestinationSequence(Identifier seq) {\n    \n        }\n\n        public void removeMessages(Identifier sid, Collection<Long> messageNrs, boolean outbound) {\n    \n        }\n\n        public void removeSourceSequence(Identifier seq) {\n    \n        }\n\n        public SourceSequence getSourceSequence(Identifier seq) {\n            return null;\n        }\n\n        public DestinationSequence getDestinationSequence(Identifier seq) {\n            return null;\n        }\n\n    }\n}", "item_id": 0, "repo": "AnEmortalKid/cxf", "file": "rt/ws/rm/src/test/java/org/apache/cxf/ws/rm/RMManagerConfigurationTest.java", "last_update_at": "2022-03-31T02:40:34+00:00", "question_id": "c9e5258a78fe8b1cf3cefd85165a8d79d7b38649_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RMManagerConfigurationTest {\n    private Bus bus;\n    @After\n    public void tearDown() {\n        bus.shutdown(true);\n        BusFactory.setDefaultBus(null);\n    }\n    @Test\n    public void testManagerBean() {\n        SpringBusFactory factory = new SpringBusFactory();\n        bus = factory.createBus(\"org/apache/cxf/ws/rm/manager-bean.xml\", false);\n        RMManager manager = bus.getExtension(RMManager.class);\n        verifyManager(manager);\n    }\n    @Test\n    public void testExactlyOnce() {\n        SpringBusFactory factory = new SpringBusFactory();\n        bus = factory.createBus(\"org/apache/cxf/ws/rm/exactly-once.xml\", false);\n        RMManager manager = bus.getExtension(RMManager.class);\n        RMConfiguration cfg = manager.getConfiguration();\n        DeliveryAssurance da = cfg.getDeliveryAssurance();\n        assertEquals(da, DeliveryAssurance.EXACTLY_ONCE);\n        assertFalse(cfg.isInOrder());\n    }\n    @Test\n    public void testFeature() {\n        SpringBusFactory factory = new SpringBusFactory();\n        bus = factory.createBus(\"org/apache/cxf/ws/rm/feature.xml\");\n        RMManager manager = bus.getExtension(RMManager.class);\n        verifyManager(manager);\n    }\n    private void verifyManager(RMManager manager) {\n        assertNotNull(manager);\n        assertTrue(manager.getSourcePolicy().getSequenceTerminationPolicy().isTerminateOnShutdown());\n        assertEquals(0L, manager.getDestinationPolicy().getAcksPolicy().getIntraMessageThreshold());\n        assertEquals(2000L, manager.getDestinationPolicy().getAcksPolicy().getImmediaAcksTimeout());\n        assertEquals(10000L, manager.getConfiguration().getBaseRetransmissionInterval().longValue());\n        assertEquals(10000L, manager.getConfiguration().getAcknowledgementInterval().longValue());\n        assertEquals(\"http://www.w3.org/2005/08/addressing\", manager.getConfiguration().getRM10AddressingNamespace());\n        TestStore store = (TestStore)manager.getStore();\n        assertEquals(\"here\", store.getLocation());\n        assertTrue(manager.getConfiguration().isInOrder());\n    }\n    static class TestStore implements RMStore {\n        private String location;\n        TestStore() {\n            // this(null);\n        }\n        public String getLocation() {\n            return location;\n        }\n        public void setLocation(String location) {\n            this.location = location;\n        }\n        public void createDestinationSequence(DestinationSequence seq) {\n        }\n        public void createSourceSequence(SourceSequence seq) {\n        }\n        public Collection<DestinationSequence> getDestinationSequences(String endpointIdentifier) {\n            return null;\n        }\n        public Collection<RMMessage> getMessages(Identifier sid, boolean outbound) {\n            return null;\n        }\n        public Collection<SourceSequence> getSourceSequences(String endpointIdentifier) {\n            return null;\n        }\n        public void persistIncoming(DestinationSequence seq, RMMessage msg) {\n        }\n        public void persistOutgoing(SourceSequence seq, RMMessage msg) {\n        }\n        public void removeDestinationSequence(Identifier seq) {\n        }\n        public void removeMessages(Identifier sid, Collection<Long> messageNrs, boolean outbound) {\n        }\n        public void removeSourceSequence(Identifier seq) {\n        }\n        public SourceSequence getSourceSequence(Identifier seq) {\n            return null;\n        }\n        public DestinationSequence getDestinationSequence(Identifier seq) {\n            return null;\n        }\n    }\n"]], "pred": {"ppl": 1.8261710405349731, "ppl_lower": 2.16811203956604, "ppl/lowercase_ppl": -1.285003655177771, "ppl/zlib": 0.0006545885296754141, "Min_5.0% Prob": 6.344810043772061, "Min_10.0% Prob": 4.589488215744495, "Min_20.0% Prob": 2.8145870468579233, "Min_30.0% Prob": 1.9718461501826015, "Min_40.0% Prob": 1.4996772956122488, "Min_50.0% Prob": 1.2022869156445077, "Min_60.0% Prob": 1.0035027268252286}}
{"hexsha": "c959354b1f0ae950f1191e59c6ff6ced48071446", "ext": "java", "lang": "Java", "content": "public class DefaultDistributionParameter<ParameterType,ConditionalType extends ClosedFormDistribution<?>>\n    extends AbstractNamed\n    implements DistributionParameter<ParameterType,ConditionalType>\n{\n\n    /**\n     * Distribution from which to pull the parameters.\n     */\n    protected ConditionalType conditionalDistribution;\n\n    /**\n     * Setter for the parameter, the read method.\n     */\n    transient protected Method parameterSetter;\n\n    /**\n     * Getter for the parameter, the write method.\n     */\n    transient protected Method parameterGetter;\n\n    /**\n     * Name of the mean property, {@value}.\n     */\n    public static final String MEAN_NAME = \"mean\";\n\n    /**\n     * Setter for the mean, {@value}.\n     */\n    public static final String MEAN_SETTER = \"setMean\";\n\n    /**\n     * Getter for the mean, {@value}.\n     */\n    public static final String MEAN_GETTER = \"getMean\";\n\n    /** \n     * Creates a new instance of DefaultDistributionParameter \n     * @param conditionalDistribution\n     * Distribution from which to pull the parameters.\n     * @param parameterName\n     * Name of the parameter\n     */\n    public DefaultDistributionParameter(\n        final ConditionalType conditionalDistribution,\n        final String parameterName )\n    {\n        super( parameterName );\n        this.setConditionalDistribution(conditionalDistribution);\n    }\n\n    /**\n     * Creates a new instance of DefaultDistributionParameter\n     * @param conditionalDistribution\n     * Distribution from which to pull the parameters.\n     * @param descriptor\n     * PropertyDescriptor from the Introspector that has a setter and a getter.\n     */\n    public DefaultDistributionParameter(\n        final ConditionalType conditionalDistribution,\n        final PropertyDescriptor descriptor )\n    {\n        this( conditionalDistribution, descriptor.getName() );\n        this.parameterGetter = descriptor.getReadMethod();\n        this.parameterSetter = descriptor.getWriteMethod();\n    }\n\n    @Override\n    public DefaultDistributionParameter<ParameterType,ConditionalType> clone()\n    {\n        @SuppressWarnings(\"unchecked\")\n        DefaultDistributionParameter<ParameterType,ConditionalType> clone =\n            (DefaultDistributionParameter<ParameterType,ConditionalType>) super.clone();\n        clone.setConditionalDistribution(\n            ObjectUtil.cloneSafe(this.getConditionalDistribution() ) );\n        return clone;\n    }\n\n    /**\n     * Assigns the getter and setter from the given conditionalDistribution and parameter\n     * name.\n     * @param conditionalDistribution\n     * Distribution from which to pull the parameters.\n     * @param parameterName\n     * Name of the parameter\n     */\n    protected void assignParameterMethods(\n        final Distribution<?> conditionalDistribution,\n        final String parameterName )\n    {\n\n        this.parameterGetter = null;\n        this.parameterSetter = null;\n\n        // Mean is a special case...\n        // Note: We can't use BeanInfo and Introspection on PropertyDescriptor\n        // because the signature of the getters and setters could be\n        // inconsistent.  For example, a class could have a method of\n        // \"Double getMean()\", but the setter might be \"void setMean(double)\".\n        // Because the getter returns Double, but the setter takes a double,\n        // the Bean Introspection is too clever and doesn't consider them\n        // as getters and setters for the same property.  Thus, we have to\n        // include our little hack below.\n        if( parameterName.equals( MEAN_NAME ) )\n        {\n            for( Method method : conditionalDistribution.getClass().getMethods() )\n            {\n                String methodString = method.getName();\n                if( methodString.contains( MEAN_GETTER ) )\n                {\n                    this.parameterGetter = method;\n                }\n                else if( methodString.contains( MEAN_SETTER ) )\n                {\n                    this.parameterSetter = method;\n                }\n            }\n        }\n        else\n        {\n            try\n            {\n                BeanInfo beaninfo =\n                    Introspector.getBeanInfo(conditionalDistribution.getClass());\n                for (PropertyDescriptor descriptor : beaninfo.getPropertyDescriptors())\n                {\n                    String propertyName = descriptor.getName();\n                    if (propertyName.equals(parameterName))\n                    {\n                        this.parameterGetter = descriptor.getReadMethod();\n                        this.parameterSetter = descriptor.getWriteMethod();\n                        break;\n                    }\n                }\n            }\n            catch (IntrospectionException ex)\n            {\n                throw new RuntimeException( ex );\n            }\n\n        }\n\n        if( this.parameterGetter == null )\n        {\n            throw new IllegalArgumentException(\n                \"Could not find getter: \" + parameterName + \" in class \" + this.getConditionalDistribution() );\n        }\n        if( this.parameterSetter == null )\n        {\n            throw new IllegalArgumentException(\n                \"Could not find setter: \" + parameterName + \" in class \" + this.getConditionalDistribution() );\n        }\n\n    }\n\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public ParameterType getValue()\n    {\n        ParameterType retval = null;\n        try\n        {\n            if( this.parameterGetter == null )\n            {\n                this.assignParameterMethods(\n                    this.getConditionalDistribution(), this.getName() );\n            }\n            retval = (ParameterType) this.parameterGetter.invoke(\n                this.getConditionalDistribution());\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n\n        return retval;\n    }\n\n    @Override\n    public void setValue(\n        final ParameterType value )\n    {\n        try\n        {\n            if( this.parameterGetter == null )\n            {\n                this.assignParameterMethods(\n                    this.getConditionalDistribution(), this.getName() );\n            }\n            this.parameterSetter.invoke( this.getConditionalDistribution(), value );\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException( e );\n        }\n    }\n\n\n    @Override\n    public ConditionalType getConditionalDistribution()\n    {\n        return this.conditionalDistribution;\n    }\n\n    /**\n     * Setter for conditionalDistribution\n     * @param conditionalDistribution\n     * Conditional conditionalDistribution associated with the parameter.\n     */\n    protected void setConditionalDistribution(\n        final ConditionalType conditionalDistribution)\n    {\n        this.conditionalDistribution = conditionalDistribution;\n    }\n\n    @Override\n    public void setName(\n        final String name)\n    {\n        this.parameterGetter = null;\n        this.parameterSetter = null;\n        super.setName(name);\n    }\n    \n}", "item_id": 0, "repo": "Markoy8/Foundry", "file": "Components/LearningCore/Source/gov/sandia/cognition/statistics/DefaultDistributionParameter.java", "last_update_at": "2022-02-25T20:22:22+00:00", "question_id": "c959354b1f0ae950f1191e59c6ff6ced48071446_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DefaultDistributionParameter<ParameterType,ConditionalType extends ClosedFormDistribution<?>>\n    extends AbstractNamed\n    implements DistributionParameter<ParameterType,ConditionalType>\n{\n    /**\n     * Distribution from which to pull the parameters.\n     */\n    protected ConditionalType conditionalDistribution;\n    /**\n     * Setter for the parameter, the read method.\n     */\n    transient protected Method parameterSetter;\n    /**\n     * Getter for the parameter, the write method.\n     */\n    transient protected Method parameterGetter;\n    /**\n     * Name of the mean property, {@value}.\n     */\n    public static final String MEAN_NAME = \"mean\";\n    /**\n     * Setter for the mean, {@value}.\n     */\n    public static final String MEAN_SETTER = \"setMean\";\n    /**\n     * Getter for the mean, {@value}.\n     */\n    public static final String MEAN_GETTER = \"getMean\";\n    /** \n     * Creates a new instance of DefaultDistributionParameter \n     * @param conditionalDistribution\n     * Distribution from which to pull the parameters.\n     * @param parameterName\n     * Name of the parameter\n     */\n    public DefaultDistributionParameter(\n        final ConditionalType conditionalDistribution,\n        final String parameterName )\n    {\n        super( parameterName );\n        this.setConditionalDistribution(conditionalDistribution);\n    }\n    /**\n     * Creates a new instance of DefaultDistributionParameter\n     * @param conditionalDistribution\n     * Distribution from which to pull the parameters.\n     * @param descriptor\n     * PropertyDescriptor from the Introspector that has a setter and a getter.\n     */\n    public DefaultDistributionParameter(\n        final ConditionalType conditionalDistribution,\n        final PropertyDescriptor descriptor )\n    {\n        this( conditionalDistribution, descriptor.getName() );\n        this.parameterGetter = descriptor.getReadMethod();\n        this.parameterSetter = descriptor.getWriteMethod();\n    }\n    @Override\n    public DefaultDistributionParameter<ParameterType,ConditionalType> clone()\n    {\n        @SuppressWarnings(\"unchecked\")\n        DefaultDistributionParameter<ParameterType,ConditionalType> clone =\n            (DefaultDistributionParameter<ParameterType,ConditionalType>) super.clone();\n        clone.setConditionalDistribution(\n            ObjectUtil.cloneSafe(this.getConditionalDistribution() ) );\n        return clone;\n    }\n    /**\n     * Assigns the getter and setter from the given conditionalDistribution and parameter\n     * name.\n     * @param conditionalDistribution\n     * Distribution from which to pull the parameters.\n     * @param parameterName\n     * Name of the parameter\n     */\n    protected void assignParameterMethods(\n        final Distribution<?> conditionalDistribution,\n        final String parameterName )\n    {\n        this.parameterGetter = null;\n        this.parameterSetter = null;\n        // Mean is a special case...\n        // Note: We can't use BeanInfo and Introspection on PropertyDescriptor\n        // because the signature of the getters and setters could be\n        // inconsistent.  For example, a class could have a method of\n        // \"Double getMean()\", but the setter might be \"void setMean(double)\".\n        // Because the getter returns Double, but the setter takes a double,\n        // the Bean Introspection is too clever and doesn't consider them\n        // as getters and setters for the same property.  Thus, we have to\n        // include our little hack below.\n        if( parameterName.equals( MEAN_NAME ) )\n        {\n            for( Method method : conditionalDistribution.getClass().getMethods() )\n            {\n                String methodString = method.getName();\n                if( methodString.contains( MEAN_GETTER ) )\n                {\n                    this.parameterGetter = method;\n                }\n                else if( methodString.contains( MEAN_SETTER ) )\n                {\n                    this.parameterSetter = method;\n                }\n            }\n        }\n        else\n        {\n            try\n            {\n                BeanInfo beaninfo =\n                    Introspector.getBeanInfo(conditionalDistribution.getClass());\n                for (PropertyDescriptor descriptor : beaninfo.getPropertyDescriptors())\n                {\n                    String propertyName = descriptor.getName();\n                    if (propertyName.equals(parameterName))\n                    {\n                        this.parameterGetter = descriptor.getReadMethod();\n                        this.parameterSetter = descriptor.getWriteMethod();\n                        break;\n                    }\n                }\n            }\n            catch (IntrospectionException ex)\n            {\n                throw new RuntimeException( ex );\n            }\n        }\n        if( this.parameterGetter == null )\n        {\n            throw new IllegalArgumentException(\n                \"Could not find getter: \" + parameterName + \" in class \" + this.getConditionalDistribution() );\n        }\n        if( this.parameterSetter == null )\n        {\n            throw new IllegalArgumentException(\n                \"Could not find setter: \" + parameterName + \" in class \" + this.getConditionalDistribution() );\n        }\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public ParameterType getValue()\n    {\n        ParameterType retval = null;\n        try\n        {\n            if( this.parameterGetter == null )\n            {\n                this.assignParameterMethods(\n                    this.getConditionalDistribution(), this.getName() );\n            }\n            retval = (ParameterType) this.parameterGetter.invoke(\n                this.getConditionalDistribution());\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n        return retval;\n    }\n    @Override\n    public void setValue(\n        final ParameterType value )\n    {\n        try\n        {\n            if( this.parameterGetter == null )\n            {\n                this.assignParameterMethods(\n                    this.getConditionalDistribution(), this.getName() );\n            }\n            this.parameterSetter.invoke( this.getConditionalDistribution(), value );\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException( e );\n        }\n    }\n    @Override\n    public ConditionalType getConditionalDistribution()\n    {\n        return this.conditionalDistribution;\n    }\n    /**\n     * Setter for conditionalDistribution\n     * @param conditionalDistribution\n     * Conditional conditionalDistribution associated with the parameter.\n     */\n    protected void setConditionalDistribution(\n        final ConditionalType conditionalDistribution)\n    {\n        this.conditionalDistribution = conditionalDistribution;\n    }\n    @Override\n    public void setName(\n        final String name)\n    {\n        this.parameterGetter = null;\n        this.parameterSetter = null;\n        super.setName(name);\n    }\n"]], "pred": {"ppl": 1.9807450771331787, "ppl_lower": 2.1822962760925293, "ppl/lowercase_ppl": -1.141782592548319, "ppl/zlib": 0.0004574786315295674, "Min_5.0% Prob": 6.346879136328604, "Min_10.0% Prob": 4.788361166037765, "Min_20.0% Prob": 3.1230480232659508, "Min_30.0% Prob": 2.2272131669462896, "Min_40.0% Prob": 1.697059917275072, "Min_50.0% Prob": 1.365373689404264, "Min_60.0% Prob": 1.1399004148314806}}
{"hexsha": "4d6f6dcadfe12e2893b02064cebdad5f0a21dfba", "ext": "java", "lang": "Java", "content": "class SampleTest {\n  @Test\n  void sample() {\n    assertEquals(11, Kata.houseNumbersSum(new int[] {5, 1, 2, 3, 0, 1, 5, 0, 2}));\n    assertEquals(13, Kata.houseNumbersSum(new int[] {4, 2, 1, 6, 0}));\n    assertEquals(10, Kata.houseNumbersSum(new int[] {4, 1, 2, 3, 0, 10, 2}));\n    assertEquals(0, Kata.houseNumbersSum(new int[] {0, 1, 2, 3, 4, 5}));\n  }\n}", "item_id": 0, "repo": "Sophia-Okito/codewars-handbook", "file": "kata/7-kyu/simple-fun-number-37-house-numbers-sum/test/SampleTest.java", "last_update_at": "2022-03-15T06:59:04+00:00", "question_id": "4d6f6dcadfe12e2893b02064cebdad5f0a21dfba_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class SampleTest {\n  @Test\n  void sample() {\n    assertEquals(11, Kata.houseNumbersSum(new int[] {5, 1, 2, 3, 0, 1, 5, 0, 2}));\n    assertEquals(13, Kata.houseNumbersSum(new int[] {4, 2, 1, 6, 0}));\n    assertEquals(10, Kata.houseNumbersSum(new int[] {4, 1, 2, 3, 0, 10, 2}));\n    assertEquals(0, Kata.houseNumbersSum(new int[] {0, 1, 2, 3, 4, 5}));\n  }\n"]], "pred": {"ppl": 2.1439762115478516, "ppl_lower": 2.444700241088867, "ppl/lowercase_ppl": -1.1721081441148455, "ppl/zlib": 0.004920400953463598, "Min_5.0% Prob": 6.036002576351166, "Min_10.0% Prob": 4.341281484155094, "Min_20.0% Prob": 3.0623516832079205, "Min_30.0% Prob": 2.3546512516645284, "Min_40.0% Prob": 1.8634113413946969, "Min_50.0% Prob": 1.5138711464506658, "Min_60.0% Prob": 1.2754618935641788}}
{"hexsha": "180a19ee9b6867319cc9e76670c69f2efbe859e4", "ext": "java", "lang": "Java", "content": "public class GistSyncFavorite extends SyncFavorite {\n  private String owner;\n  private String id;\n\n  public GistSyncFavorite() {\n    super(Type.GIST);\n  }\n\n  public GistSyncFavorite(String owner, String id) {\n    super(Type.GIST);\n    this.owner = owner;\n    this.id = id;\n  }\n\n  public GistSyncFavorite(Map<String, Object> map) {\n    super(map);\n    if (map != null) {\n      if (map.containsKey(\"id\") && map.get(\"id\") != null) {\n        this.id = (String) map.get(\"id\");\n      }\n      if (map.containsKey(\"owner\") && map.get(\"owner\") != null) {\n        this.owner = (String) map.get(\"owner\");\n      }\n    }\n  }\n\n  public String getOwner() {\n    return owner;\n  }\n\n  public String getId() {\n    return id;\n  }\n\n  @Override\n  public Map<String, Object> toMap() {\n    Map<String, Object> map = new HashMap<>();\n    map.put(\"owner\", owner);\n    map.put(\"id\", id);\n    return map;\n  }\n}", "item_id": 0, "repo": "PlexPt/Gitskarios", "file": "app/src/main/java/com/alorma/github/bean/sync/GistSyncFavorite.java", "last_update_at": "2022-02-12T14:18:25+00:00", "question_id": "180a19ee9b6867319cc9e76670c69f2efbe859e4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GistSyncFavorite extends SyncFavorite {\n  private String owner;\n  private String id;\n  public GistSyncFavorite() {\n    super(Type.GIST);\n  }\n  public GistSyncFavorite(String owner, String id) {\n    super(Type.GIST);\n    this.owner = owner;\n    this.id = id;\n  }\n  public GistSyncFavorite(Map<String, Object> map) {\n    super(map);\n    if (map != null) {\n      if (map.containsKey(\"id\") && map.get(\"id\") != null) {\n        this.id = (String) map.get(\"id\");\n      }\n      if (map.containsKey(\"owner\") && map.get(\"owner\") != null) {\n        this.owner = (String) map.get(\"owner\");\n      }\n    }\n  }\n  public String getOwner() {\n    return owner;\n  }\n  public String getId() {\n    return id;\n  }\n  @Override\n  public Map<String, Object> toMap() {\n    Map<String, Object> map = new HashMap<>();\n    map.put(\"owner\", owner);\n    map.put(\"id\", id);\n    return map;\n  }\n"]], "pred": {"ppl": 1.4283913373947144, "ppl_lower": 1.675919771194458, "ppl/lowercase_ppl": -1.448222591641352, "ppl/zlib": 0.0011501576521558735, "Min_5.0% Prob": 4.525270700454712, "Min_10.0% Prob": 3.0059854868919618, "Min_20.0% Prob": 1.721250902741186, "Min_30.0% Prob": 1.1859789125781546, "Min_40.0% Prob": 0.8897761107087135, "Min_50.0% Prob": 0.7145777870184526, "Min_60.0% Prob": 0.5965718028034745}}
{"hexsha": "7124b9148d4f342734f761ba76dcf05a467ac969", "ext": "java", "lang": "Java", "content": "@APICommand(name = \"stopVirtualMachine\", group = APICommandGroup.VirtualMachineService, responseObject = UserVmResponse.class, description = \"Stops a virtual machine.\", responseView = ResponseView\n        .Full, entityType =\n        {VirtualMachine.class},\n        requestHasSensitiveInfo = false, responseHasSensitiveInfo = true)\npublic class StopVMCmdByAdmin extends StopVMCmd {\n    public static final Logger s_logger = LoggerFactory.getLogger(StopVMCmdByAdmin.class.getName());\n\n    @Override\n    public void execute() throws ServerApiException, ConcurrentOperationException {\n        CallContext.current().setEventDetails(\"Vm Id: \" + getId());\n        final UserVm result;\n\n        result = _userVmService.stopVirtualMachine(getId(), isForced());\n\n        if (result != null) {\n            final UserVmResponse response = _responseGenerator.createUserVmResponse(ResponseView.Full, \"virtualmachine\", result).get(0);\n            response.setResponseName(getCommandName());\n            setResponseObject(response);\n        } else {\n            throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, \"Failed to stop vm\");\n        }\n    }\n}", "item_id": 0, "repo": "sanderv32/cosmic", "file": "cosmic-core/api/src/main/java/com/cloud/api/command/admin/vm/StopVMCmdByAdmin.java", "last_update_at": "2022-02-21T02:13:25+00:00", "question_id": "7124b9148d4f342734f761ba76dcf05a467ac969_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@APICommand(name = \"stopVirtualMachine\", group = APICommandGroup.VirtualMachineService, responseObject = UserVmResponse.class, description = \"Stops a virtual machine.\", responseView = ResponseView\n        .Full, entityType =\n        {VirtualMachine.class},\n        requestHasSensitiveInfo = false, responseHasSensitiveInfo = true)\npublic class StopVMCmdByAdmin extends StopVMCmd {\n    public static final Logger s_logger = LoggerFactory.getLogger(StopVMCmdByAdmin.class.getName());\n    @Override\n    public void execute() throws ServerApiException, ConcurrentOperationException {\n        CallContext.current().setEventDetails(\"Vm Id: \" + getId());\n        final UserVm result;\n        result = _userVmService.stopVirtualMachine(getId(), isForced());\n        if (result != null) {\n            final UserVmResponse response = _responseGenerator.createUserVmResponse(ResponseView.Full, \"virtualmachine\", result).get(0);\n            response.setResponseName(getCommandName());\n            setResponseObject(response);\n        } else {\n            throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, \"Failed to stop vm\");\n        }\n    }\n"]], "pred": {"ppl": 2.426217555999756, "ppl_lower": 4.5361409187316895, "ppl/lowercase_ppl": -1.7059906469883606, "ppl/zlib": 0.0016262999694226165, "Min_5.0% Prob": 9.003512689045497, "Min_10.0% Prob": 6.781537483478415, "Min_20.0% Prob": 4.177673898894211, "Min_30.0% Prob": 2.9176226905707656, "Min_40.0% Prob": 2.2162671714764217, "Min_50.0% Prob": 1.7685426809021259, "Min_60.0% Prob": 1.4778663356442536}}
{"hexsha": "ebb77db81a764e6c17ae08f275ea0becccb2aaf9", "ext": "java", "lang": "Java", "content": "public class ZeroCommandSimple extends CommandBase {\n    private Timer endTimer;\n\n    private boolean hoodDone;\n    private boolean turretDone;\n    private boolean turretBackedOff;\n    private boolean ready;\n\n    private Shooter shooter;\n    public ZeroCommandSimple(Shooter shooter)\n    {\n        this.shooter = shooter;\n\n        this.endTimer = new Timer();\n\n        hoodDone = false;\n        turretDone = false;\n        turretBackedOff = false;\n\n        this.addRequirements(shooter);\n    }\n\n    public void initialize() {\n        shooter.setZeroPoint(EDeviceType.Hood);\n        shooter.setZeroPoint(EDeviceType.Turret);\n        endTimer.reset();\n        hoodDone = false;\n        turretDone = false;\n        turretBackedOff = false;\n        ready = false;\n    }\n\n    public void execute() {\n        if(ready) {\n            if(!hoodDone) {\n                this.shooter.move(EDeviceType.Hood, -0.3);\n            } else {\n                shooter.move(EDeviceType.Hood, 0);\n            }\n\n            if(!turretBackedOff) {\n                shooter.move(EDeviceType.Turret, -0.1);\n            } else if(!turretDone) {\n                shooter.move(EDeviceType.Turret, 0.1); //0.25\n            } else {\n                shooter.move(EDeviceType.Turret, 0);\n            }\n\n            if(!turretBackedOff && shooter.getTurretPosition() < -20.0) {\n                turretBackedOff = true;\n            }\n        } else if(Math.abs(shooter.getAngle(EDeviceType.Turret) + 90) < 1) {\n            ready = true;\n        }\n    }\n\n    public void end(boolean isInterrupted){\n        while(Math.abs(shooter.getAngle(EDeviceType.Turret) + 90) > 1) {\n            States.zeroed = true;\n            shooter.setZeroPoint(EDeviceType.Hood);\n            shooter.setZeroPoint(EDeviceType.Turret);\n            shooter.setHoodAngle(Constants.BASE_HOOD_ANGLE);\n            shooter.move(EDeviceType.Hood, 0);\n            shooter.move(EDeviceType.Turret, 0);\n        }\n    }\n\n    // Checking when things are finished by checking the velocity because\n    //  the stop switch never reports true :(\n    public boolean isFinished(){\n        endTimer.start();\n        if(!this.shooter.atZeroPoint(EDeviceType.Hood)) {\n            endTimer.reset();\n        }\n        hoodDone = endTimer.hasElapsed(1);\n        turretDone = this.shooter.atZeroPoint(EDeviceType.Turret);\n        return hoodDone && turretDone;\n    }\n}", "item_id": 0, "repo": "619Code/Robot2022", "file": "src/main/java/frc/robot/commands/ZeroCommandSimple.java", "last_update_at": "2022-03-01T00:24:19+00:00", "question_id": "ebb77db81a764e6c17ae08f275ea0becccb2aaf9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ZeroCommandSimple extends CommandBase {\n    private Timer endTimer;\n    private boolean hoodDone;\n    private boolean turretDone;\n    private boolean turretBackedOff;\n    private boolean ready;\n    private Shooter shooter;\n    public ZeroCommandSimple(Shooter shooter)\n    {\n        this.shooter = shooter;\n        this.endTimer = new Timer();\n        hoodDone = false;\n        turretDone = false;\n        turretBackedOff = false;\n        this.addRequirements(shooter);\n    }\n    public void initialize() {\n        shooter.setZeroPoint(EDeviceType.Hood);\n        shooter.setZeroPoint(EDeviceType.Turret);\n        endTimer.reset();\n        hoodDone = false;\n        turretDone = false;\n        turretBackedOff = false;\n        ready = false;\n    }\n    public void execute() {\n        if(ready) {\n            if(!hoodDone) {\n                this.shooter.move(EDeviceType.Hood, -0.3);\n            } else {\n                shooter.move(EDeviceType.Hood, 0);\n            }\n            if(!turretBackedOff) {\n                shooter.move(EDeviceType.Turret, -0.1);\n            } else if(!turretDone) {\n                shooter.move(EDeviceType.Turret, 0.1); //0.25\n            } else {\n                shooter.move(EDeviceType.Turret, 0);\n            }\n            if(!turretBackedOff && shooter.getTurretPosition() < -20.0) {\n                turretBackedOff = true;\n            }\n        } else if(Math.abs(shooter.getAngle(EDeviceType.Turret) + 90) < 1) {\n            ready = true;\n        }\n    }\n    public void end(boolean isInterrupted){\n        while(Math.abs(shooter.getAngle(EDeviceType.Turret) + 90) > 1) {\n            States.zeroed = true;\n            shooter.setZeroPoint(EDeviceType.Hood);\n            shooter.setZeroPoint(EDeviceType.Turret);\n            shooter.setHoodAngle(Constants.BASE_HOOD_ANGLE);\n            shooter.move(EDeviceType.Hood, 0);\n            shooter.move(EDeviceType.Turret, 0);\n        }\n    }\n    // Checking when things are finished by checking the velocity because\n    //  the stop switch never reports true :(\n    public boolean isFinished(){\n        endTimer.start();\n        if(!this.shooter.atZeroPoint(EDeviceType.Hood)) {\n            endTimer.reset();\n        }\n        hoodDone = endTimer.hasElapsed(1);\n        turretDone = this.shooter.atZeroPoint(EDeviceType.Turret);\n        return hoodDone && turretDone;\n    }\n"]], "pred": {"ppl": 2.051175832748413, "ppl_lower": 2.266209363937378, "ppl/lowercase_ppl": -1.1387715948152888, "ppl/zlib": 0.0010819475988981576, "Min_5.0% Prob": 6.835685575330579, "Min_10.0% Prob": 5.022757809956868, "Min_20.0% Prob": 3.2516062458356223, "Min_30.0% Prob": 2.331585669148285, "Min_40.0% Prob": 1.7857883313169511, "Min_50.0% Prob": 1.4333879946624806, "Min_60.0% Prob": 1.1975093757233013}}
{"hexsha": "8307ea1d8657843c9dd331881e650e76d039063e", "ext": "java", "lang": "Java", "content": "public class LoadBalancerModule extends AbstractModule {\n    @Override\n    protected void configure() {\n        bind(LoadBalancerServiceGrpc.LoadBalancerServiceImplBase.class).to(DefaultLoadBalancerServiceGrpc.class);\n        bind(LoadBalancerService.class).to(DefaultLoadBalancerService.class);\n        bind(LoadBalancerJobValidator.class).to(DefaultLoadBalancerJobValidator.class);\n        bind(LoadBalancerConnector.class).to(NoOpLoadBalancerConnector.class);\n    }\n\n    @Provides\n    @Singleton\n    public LoadBalancerConfiguration getLoadBalancerConfiguration(ConfigProxyFactory factory) {\n        return factory.newProxy(LoadBalancerConfiguration.class);\n    }\n\n    @Provides\n    @Singleton\n    public LoadBalancerValidationConfiguration getLoadBalancerValidationConfiguration(ConfigProxyFactory factory) {\n        return factory.newProxy(LoadBalancerValidationConfiguration.class);\n    }\n}", "item_id": 0, "repo": "gridgentoo/titus-control-plane", "file": "titus-server-master/src/main/java/com/netflix/titus/master/loadbalancer/LoadBalancerModule.java", "last_update_at": "2022-03-11T02:07:48+00:00", "question_id": "8307ea1d8657843c9dd331881e650e76d039063e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LoadBalancerModule extends AbstractModule {\n    @Override\n    protected void configure() {\n        bind(LoadBalancerServiceGrpc.LoadBalancerServiceImplBase.class).to(DefaultLoadBalancerServiceGrpc.class);\n        bind(LoadBalancerService.class).to(DefaultLoadBalancerService.class);\n        bind(LoadBalancerJobValidator.class).to(DefaultLoadBalancerJobValidator.class);\n        bind(LoadBalancerConnector.class).to(NoOpLoadBalancerConnector.class);\n    }\n    @Provides\n    @Singleton\n    public LoadBalancerConfiguration getLoadBalancerConfiguration(ConfigProxyFactory factory) {\n        return factory.newProxy(LoadBalancerConfiguration.class);\n    }\n    @Provides\n    @Singleton\n    public LoadBalancerValidationConfiguration getLoadBalancerValidationConfiguration(ConfigProxyFactory factory) {\n        return factory.newProxy(LoadBalancerValidationConfiguration.class);\n    }\n"]], "pred": {"ppl": 1.6661473512649536, "ppl_lower": 2.2246246337890625, "ppl/lowercase_ppl": -1.5662415123658726, "ppl/zlib": 0.0019120374006402587, "Min_5.0% Prob": 6.762159564278343, "Min_10.0% Prob": 4.3235355832360005, "Min_20.0% Prob": 2.421920665105184, "Min_30.0% Prob": 1.6692794862696354, "Min_40.0% Prob": 1.277156221245726, "Min_50.0% Prob": 1.0227068897452107, "Min_60.0% Prob": 0.8512249554863528}}
{"hexsha": "0284c04136aa1d742418b895fd9ff3c44cf11fb7", "ext": "java", "lang": "Java", "content": "public class DedicatedStatelessManualByonDeployTest extends AbstractFromXenToByonGSMTest {\n\t\n\t@BeforeMethod\n    public void beforeTest() {\n\t\tsuper.beforeTestInit();\n\t}\n\t\n\t@BeforeClass\n\tprotected void bootstrap() throws Exception {\n\t\tsuper.bootstrapBeforeClass();\n\t}\n\t\n\t@AfterMethod\n    public void afterTest() {\n\t\tsuper.afterTest();\n\t}\n\t\n\t@AfterClass(alwaysRun = true)\n\tprotected void teardownAfterClass() throws Exception {\n\t\tsuper.teardownAfterClass();\n\t}\n\t\n\t@Test(timeOut = DEFAULT_TEST_TIMEOUT)\n\tpublic void test() {\n\t    File archive = DeploymentUtils.getArchive(\"simpleStatelessPu.jar\");\n\t // make sure no gscs yet created\n\t    repetitiveAssertNumberOfGSCsAdded(0, OPERATION_TIMEOUT);\n\t    repetitiveAssertNumberOfGSAsAdded(1, OPERATION_TIMEOUT);\t    \n\t\tfinal ProcessingUnit pu = super.deploy(\n\t\t\t\tnew ElasticStatelessProcessingUnitDeployment(archive)\n\t            .memoryCapacityPerContainer(1, MemoryUnit.GIGABYTES)\n\t            .dedicatedMachineProvisioning(getMachineProvisioningConfig())\n\t            .scale(new ManualCapacityScaleConfigurer()\n\t            \t  .memoryCapacity(2, MemoryUnit.GIGABYTES)\n                      .create())\n\t    );\n\t    \n\t    pu.waitFor(2);\n\t    \n\t    //TODO check why expected number of GSA's added was 2 before\n\t    repetitiveAssertNumberOfGSAsAdded(1, OPERATION_TIMEOUT);\n\t    repetitiveAssertNumberOfGSAsRemoved(0, OPERATION_TIMEOUT);\n\t    repetitiveAssertNumberOfGSCsAdded(2, OPERATION_TIMEOUT);\n\t    \n\t    \n\t    assertUndeployAndWait(pu);\n\t}\n}", "item_id": 0, "repo": "CloudifySource/Cloudify-iTests", "file": "src/main/java/org/cloudifysource/quality/iTests/test/esm/stateless/manual/memory/DedicatedStatelessManualByonDeployTest.java", "last_update_at": "2022-02-01T01:04:32+00:00", "question_id": "0284c04136aa1d742418b895fd9ff3c44cf11fb7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DedicatedStatelessManualByonDeployTest extends AbstractFromXenToByonGSMTest {\n\t\n\t@BeforeMethod\n    public void beforeTest() {\n\t\tsuper.beforeTestInit();\n\t}\n\t\n\t@BeforeClass\n\tprotected void bootstrap() throws Exception {\n\t\tsuper.bootstrapBeforeClass();\n\t}\n\t\n\t@AfterMethod\n    public void afterTest() {\n\t\tsuper.afterTest();\n\t}\n\t\n\t@AfterClass(alwaysRun = true)\n\tprotected void teardownAfterClass() throws Exception {\n\t\tsuper.teardownAfterClass();\n\t}\n\t\n\t@Test(timeOut = DEFAULT_TEST_TIMEOUT)\n\tpublic void test() {\n\t    File archive = DeploymentUtils.getArchive(\"simpleStatelessPu.jar\");\n\t // make sure no gscs yet created\n\t    repetitiveAssertNumberOfGSCsAdded(0, OPERATION_TIMEOUT);\n\t    repetitiveAssertNumberOfGSAsAdded(1, OPERATION_TIMEOUT);\t    \n\t\tfinal ProcessingUnit pu = super.deploy(\n\t\t\t\tnew ElasticStatelessProcessingUnitDeployment(archive)\n\t            .memoryCapacityPerContainer(1, MemoryUnit.GIGABYTES)\n\t            .dedicatedMachineProvisioning(getMachineProvisioningConfig())\n\t            .scale(new ManualCapacityScaleConfigurer()\n\t            \t  .memoryCapacity(2, MemoryUnit.GIGABYTES)\n                      .create())\n\t    );\n\t    \n\t    pu.waitFor(2);\n\t    \n\t    //TODO check why expected number of GSA's added was 2 before\n\t    repetitiveAssertNumberOfGSAsAdded(1, OPERATION_TIMEOUT);\n\t    repetitiveAssertNumberOfGSAsRemoved(0, OPERATION_TIMEOUT);\n\t    repetitiveAssertNumberOfGSCsAdded(2, OPERATION_TIMEOUT);\n\t    \n\t    \n\t    assertUndeployAndWait(pu);\n\t}\n"]], "pred": {"ppl": 2.3034322261810303, "ppl_lower": 4.029761791229248, "ppl/lowercase_ppl": -1.6703101544562655, "ppl/zlib": 0.0013545459137271941, "Min_5.0% Prob": 7.172512809435527, "Min_10.0% Prob": 5.678583407888607, "Min_20.0% Prob": 3.773411552713375, "Min_30.0% Prob": 2.6991241272236848, "Min_40.0% Prob": 2.061779203137966, "Min_50.0% Prob": 1.6601898477022206, "Min_60.0% Prob": 1.3911925271053105}}
{"hexsha": "1ad862fc89b4b1fa463566d8b67a997a46f58a86", "ext": "java", "lang": "Java", "content": "@Stateless\n@LocalBean\n@Loggable\npublic class ItemService extends AbstractService<Item> implements Serializable\n{\n\n\n   // ======================================\n   // =            Constructors            =\n   // ======================================\n\n   public ItemService()\n   {\n      super(Item.class);\n   }\n\n   // ======================================\n   // =         Protected methods          =\n   // ======================================\n\n   @Override\n   protected Predicate[] getSearchPredicates(Root<Item> root, Item example)\n   {\n      CriteriaBuilder builder = this.entityManager.getCriteriaBuilder();\n      List<Predicate> predicatesList = new ArrayList<Predicate>();\n\n      String name = example.getName();\n      if (name != null && !\"\".equals(name))\n      {\n         predicatesList.add(builder.like(builder.lower(root.<String> get(\"name\")), '%' + name.toLowerCase() + '%'));\n      }\n      String description = example.getDescription();\n      if (description != null && !\"\".equals(description))\n      {\n         predicatesList.add(builder.like(builder.lower(root.<String> get(\"description\")), '%' + description.toLowerCase() + '%'));\n      }\n      String imagePath = example.getImagePath();\n      if (imagePath != null && !\"\".equals(imagePath))\n      {\n         predicatesList.add(builder.like(builder.lower(root.<String> get(\"imagePath\")), '%' + imagePath.toLowerCase() + '%'));\n      }\n      Product product = example.getProduct();\n      if (product != null)\n      {\n         predicatesList.add(builder.equal(root.get(\"product\"), product));\n      }\n\n      return predicatesList.toArray(new Predicate[predicatesList.size()]);\n   }\n}", "item_id": 0, "repo": "andxu/wildfly-petstore-quickstart", "file": "src/main/java/org/agoncal/application/petstore/service/ItemService.java", "last_update_at": "2022-03-10T05:36:27+00:00", "question_id": "1ad862fc89b4b1fa463566d8b67a997a46f58a86_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Stateless\n@LocalBean\n@Loggable\npublic class ItemService extends AbstractService<Item> implements Serializable\n{\n   // ======================================\n   // =            Constructors            =\n   // ======================================\n   public ItemService()\n   {\n      super(Item.class);\n   }\n   // ======================================\n   // =         Protected methods          =\n   // ======================================\n   @Override\n   protected Predicate[] getSearchPredicates(Root<Item> root, Item example)\n   {\n      CriteriaBuilder builder = this.entityManager.getCriteriaBuilder();\n      List<Predicate> predicatesList = new ArrayList<Predicate>();\n      String name = example.getName();\n      if (name != null && !\"\".equals(name))\n      {\n         predicatesList.add(builder.like(builder.lower(root.<String> get(\"name\")), '%' + name.toLowerCase() + '%'));\n      }\n      String description = example.getDescription();\n      if (description != null && !\"\".equals(description))\n      {\n         predicatesList.add(builder.like(builder.lower(root.<String> get(\"description\")), '%' + description.toLowerCase() + '%'));\n      }\n      String imagePath = example.getImagePath();\n      if (imagePath != null && !\"\".equals(imagePath))\n      {\n         predicatesList.add(builder.like(builder.lower(root.<String> get(\"imagePath\")), '%' + imagePath.toLowerCase() + '%'));\n      }\n      Product product = example.getProduct();\n      if (product != null)\n      {\n         predicatesList.add(builder.equal(root.get(\"product\"), product));\n      }\n      return predicatesList.toArray(new Predicate[predicatesList.size()]);\n   }\n"]], "pred": {"ppl": 1.412488579750061, "ppl_lower": 1.7071809768676758, "ppl/lowercase_ppl": -1.5486858533022554, "ppl/zlib": 0.0006628658327698156, "Min_5.0% Prob": 4.502896547317505, "Min_10.0% Prob": 3.0130886342790393, "Min_20.0% Prob": 1.6893317691981793, "Min_30.0% Prob": 1.144302493540777, "Min_40.0% Prob": 0.861743262795628, "Min_50.0% Prob": 0.6901528996405089, "Min_60.0% Prob": 0.5754191037495966}}
{"hexsha": "1f719598508a3bd9d105c081fae0ea33cff69a79", "ext": "java", "lang": "Java", "content": "public class WildFlyProperties {\n\n    /**\n     * Java platform property which is used as a java platform ID\n     */\n    public static final String PLAT_PROP_ANT_NAME = \"platform.ant.name\"; //NOI18N\n\n    // properties\n    public static final String PROP_PROXY_ENABLED = \"proxy_enabled\";   // NOI18N\n    private static final String PROP_JAVA_PLATFORM = \"java_platform\";   // NOI18N\n    private static final String PROP_SOURCES = \"sources\";         // NOI18N\n    private static final String PROP_JAVADOCS = \"javadocs\";        // NOI18N\n\n    private static final FilenameFilter CP_FILENAME_FILTER = new FilenameFilter() {\n\n        @Override\n        public boolean accept(File dir, String name) {\n            return name.endsWith(\".jar\") || new File(dir, name).isDirectory(); // NOI18N\n        }\n    };\n\n    // default values\n    private static final String DEF_VALUE_JAVA_OPTS = \"\"; // NOI18N\n    private static final boolean DEF_VALUE_PROXY_ENABLED = true;\n\n    private final InstanceProperties ip;\n    private final WildflyDeploymentManager manager;\n\n    // credentials initialized with default values\n    private String username = \"admin\"; // NOI18N\n    private String password = \"admin\"; // NOI18N\n\n    /**\n     * timestamp of the jmx-console-users.properties file when it was parsed for\n     * the last time\n     */\n    private long updateCredentialsTimestamp;\n\n    private static final Logger LOGGER = Logger.getLogger(WildFlyProperties.class.getName());\n\n    private final Version version;\n\n    private final boolean wildfly;\n\n    private final boolean servletOnly;\n\n    /**\n     * Creates a new instance of JBProperties\n     */\n    public WildFlyProperties(WildflyDeploymentManager manager) {\n        this.manager = manager;\n        ip = manager.getInstanceProperties();\n        File serverPath = new File(ip.getProperty(WildflyPluginProperties.PROPERTY_ROOT_DIR));\n        version = manager.getServerVersion();\n        wildfly = manager.isWildfly();\n        servletOnly = WildflyPluginUtils.isWildFlyServlet(serverPath);\n    }\n\n    public boolean isWildfly() {\n         return wildfly;\n    }\n\n    public String getServerProfile() {\n        if (this.ip.getProperty(WildflyPluginProperties.PROPERTY_CONFIG_FILE) == null) {\n            return getDefaultConfigurationFile(ip.getProperty(WildflyPluginProperties.PROPERTY_ROOT_DIR));\n        }\n        return this.ip.getProperty(WildflyPluginProperties.PROPERTY_CONFIG_FILE);\n    }\n\n    public InstanceProperties getInstanceProperties() {\n        return this.ip;\n    }\n\n    public Version getServerVersion() {\n        return version;\n    }\n\n    public boolean isServletOnly() {\n        return servletOnly;\n    }\n\n    public boolean isVersion(Version targetVersion) {\n        return (version != null && version.compareToIgnoreUpdate(targetVersion) >= 0); // NOI18N\n    }\n\n    public File getServerDir() {\n        return new File(ip.getProperty(WildflyPluginProperties.PROPERTY_SERVER_DIR));\n    }\n\n    public File getRootDir() {\n        return new File(ip.getProperty(WildflyPluginProperties.PROPERTY_ROOT_DIR));\n    }\n\n    public File getDeployDir() {\n        return new File(ip.getProperty(WildflyPluginProperties.PROPERTY_DEPLOY_DIR));\n    }\n\n    public File getLibsDir() {\n        return new File(getServerDir(), \"lib\"); // NOI18N\n    }\n\n    public boolean getProxyEnabled() {\n        String val = ip.getProperty(PROP_PROXY_ENABLED);\n        return val != null ? Boolean.valueOf(val)\n                : DEF_VALUE_PROXY_ENABLED;\n    }\n\n    public void setProxyEnabled(boolean enabled) {\n        ip.setProperty(PROP_PROXY_ENABLED, Boolean.toString(enabled));\n    }\n\n    public JavaPlatform getJavaPlatform() {\n        String currentJvm = ip.getProperty(PROP_JAVA_PLATFORM);\n        JavaPlatformManager jpm = JavaPlatformManager.getDefault();\n        JavaPlatform[] installedPlatforms = jpm.getPlatforms(null, new Specification(\"J2SE\", null)); // NOI18N\n        for (int i = 0; i < installedPlatforms.length; i++) {\n            String platformName = (String) installedPlatforms[i].getProperties().get(PLAT_PROP_ANT_NAME);\n            if (platformName != null && platformName.equals(currentJvm)) {\n                return installedPlatforms[i];\n            }\n        }\n        // return default platform if none was set\n        return jpm.getDefaultPlatform();\n    }\n\n    public void setJavaPlatform(JavaPlatform javaPlatform) {\n        ip.setProperty(PROP_JAVA_PLATFORM, (String) javaPlatform.getProperties().get(PLAT_PROP_ANT_NAME));\n    }\n\n    public String getJavaOpts() {\n        String val = ip.getProperty(WildflyPluginProperties.PROPERTY_JAVA_OPTS);\n        return val != null ? val : DEF_VALUE_JAVA_OPTS;\n    }\n\n    public void setJavaOpts(String javaOpts) {\n        ip.setProperty(WildflyPluginProperties.PROPERTY_JAVA_OPTS, javaOpts);\n    }\n\n    public String getModulePath(String module) {\n        return getRootDir().getAbsolutePath() + (\"/modules/system/layers/base/\" + module).replace('/', File.separatorChar);\n    }\n\n    private static void addFileToList(List<URL> list, File f) {\n        URL u = FileUtil.urlForArchiveOrDir(f);\n        if (u != null) {\n            list.add(u);\n        }\n    }\n\n    private List<URL> selectJars(FileObject file) {\n        if (file == null) {\n            return Collections.EMPTY_LIST;\n        }\n        if (file.isData()) {\n            if (file.isValid() && FileUtil.isArchiveFile(file)) {\n                URL url = URLMapper.findURL(file, URLMapper.EXTERNAL);\n                if (url != null) {\n                    return Collections.singletonList(FileUtil.getArchiveRoot(url));\n                }\n            }\n            return Collections.EMPTY_LIST;\n        }\n        List<URL> result = new ArrayList<URL>();\n        for (FileObject child : file.getChildren()) {\n            result.addAll(selectJars(child));\n        }\n        return result;\n    }\n\n    public List<URL> getClasses() {\n        List<URL> list = selectJars(FileUtil.toFileObject(new File(getModulePath(\"javax\"))));\n        File glassfish = new File(getModulePath(\"org/glassfish/javax\"));\n        if(glassfish.exists()) {\n            list.addAll(selectJars(FileUtil.toFileObject(glassfish)));\n        }\n        return list;\n    }\n\n    public List<URL> getSources() {\n        String path = ip.getProperty(PROP_SOURCES);\n        if (path == null) {\n            return new ArrayList<URL>();\n        }\n        return CustomizerSupport.tokenizePath(path);\n    }\n\n    public void setSources(List<URL> path) {\n        ip.setProperty(PROP_SOURCES, CustomizerSupport.buildPath(path));\n        // XXX WILDFLY IMPLEMENT\n        //manager.getJBPlatform().notifyLibrariesChanged();\n    }\n\n    public List<URL> getJavadocs() {\n        String path = ip.getProperty(PROP_JAVADOCS);\n        if (path == null) {\n            ArrayList<URL> list = new ArrayList<URL>();\n            File j2eeDoc = InstalledFileLocator.getDefault().locate(\"docs/javaee-doc-api.jar\", null, false); // NOI18N\n            if (j2eeDoc != null) {\n                addFileToList(list, j2eeDoc);\n            }\n            return list;\n        }\n        return CustomizerSupport.tokenizePath(path);\n    }\n\n    public void setJavadocs(List<URL> path) {\n        ip.setProperty(PROP_JAVADOCS, CustomizerSupport.buildPath(path));\n        // XXX WILDFLY IMPLEMENT\n        //manager.getJBPlatform().notifyLibrariesChanged();\n    }\n\n    public synchronized String getUsername() {\n        updateCredentials();\n        return username;\n    }\n\n    public synchronized String getPassword() {\n        updateCredentials();\n        return password;\n    }\n\n    // private helper methods -------------------------------------------------\n    private synchronized void updateCredentials() {\n        File usersPropFile = new File(getServerDir(), \"/conf/props/jmx-console-users.properties\");\n        long lastModified = usersPropFile.lastModified();\n        if (lastModified == updateCredentialsTimestamp) {\n            LOGGER.log(Level.FINER, \"Credentials are up-to-date.\");\n            return;\n        }\n        Properties usersProps = new Properties();\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(usersPropFile));\n            try {\n                usersProps.load(is);\n            } finally {\n                is.close();\n            }\n        } catch (FileNotFoundException e) {\n            LOGGER.log(Level.WARNING, usersPropFile + \" not found.\", e);\n            return;\n        } catch (IOException e) {\n            LOGGER.log(Level.WARNING, \"Error while reading \" + usersPropFile, e);\n            return;\n        }\n\n        Enumeration<String> names = NbCollections.checkedEnumerationByFilter(usersProps.propertyNames(), String.class, false);\n        if (names.hasMoreElements()) {\n            username = names.nextElement();\n            password = usersProps.getProperty(username);\n        }\n\n        updateCredentialsTimestamp = lastModified;\n    }\n}", "item_id": 0, "repo": "timfel/netbeans", "file": "enterprise/javaee.wildfly/src/org/netbeans/modules/javaee/wildfly/util/WildFlyProperties.java", "last_update_at": "2022-03-30T04:46:14+00:00", "question_id": "1f719598508a3bd9d105c081fae0ea33cff69a79_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class WildFlyProperties {\n    /**\n     * Java platform property which is used as a java platform ID\n     */\n    public static final String PLAT_PROP_ANT_NAME = \"platform.ant.name\"; //NOI18N\n    // properties\n    public static final String PROP_PROXY_ENABLED = \"proxy_enabled\";   // NOI18N\n    private static final String PROP_JAVA_PLATFORM = \"java_platform\";   // NOI18N\n    private static final String PROP_SOURCES = \"sources\";         // NOI18N\n    private static final String PROP_JAVADOCS = \"javadocs\";        // NOI18N\n    private static final FilenameFilter CP_FILENAME_FILTER = new FilenameFilter() {\n        @Override\n        public boolean accept(File dir, String name) {\n            return name.endsWith(\".jar\") || new File(dir, name).isDirectory(); // NOI18N\n        }\n    };\n    // default values\n    private static final String DEF_VALUE_JAVA_OPTS = \"\"; // NOI18N\n    private static final boolean DEF_VALUE_PROXY_ENABLED = true;\n    private final InstanceProperties ip;\n    private final WildflyDeploymentManager manager;\n    // credentials initialized with default values\n    private String username = \"admin\"; // NOI18N\n    private String password = \"admin\"; // NOI18N\n    /**\n     * timestamp of the jmx-console-users.properties file when it was parsed for\n     * the last time\n     */\n    private long updateCredentialsTimestamp;\n    private static final Logger LOGGER = Logger.getLogger(WildFlyProperties.class.getName());\n    private final Version version;\n    private final boolean wildfly;\n    private final boolean servletOnly;\n    /**\n     * Creates a new instance of JBProperties\n     */\n    public WildFlyProperties(WildflyDeploymentManager manager) {\n        this.manager = manager;\n        ip = manager.getInstanceProperties();\n        File serverPath = new File(ip.getProperty(WildflyPluginProperties.PROPERTY_ROOT_DIR));\n        version = manager.getServerVersion();\n        wildfly = manager.isWildfly();\n        servletOnly = WildflyPluginUtils.isWildFlyServlet(serverPath);\n    }\n    public boolean isWildfly() {\n         return wildfly;\n    }\n    public String getServerProfile() {\n        if (this.ip.getProperty(WildflyPluginProperties.PROPERTY_CONFIG_FILE) == null) {\n            return getDefaultConfigurationFile(ip.getProperty(WildflyPluginProperties.PROPERTY_ROOT_DIR));\n        }\n        return this.ip.getProperty(WildflyPluginProperties.PROPERTY_CONFIG_FILE);\n    }\n    public InstanceProperties getInstanceProperties() {\n        return this.ip;\n    }\n    public Version getServerVersion() {\n        return version;\n    }\n    public boolean isServletOnly() {\n        return servletOnly;\n    }\n    public boolean isVersion(Version targetVersion) {\n        return (version != null && version.compareToIgnoreUpdate(targetVersion) >= 0); // NOI18N\n    }\n    public File getServerDir() {\n        return new File(ip.getProperty(WildflyPluginProperties.PROPERTY_SERVER_DIR));\n    }\n    public File getRootDir() {\n        return new File(ip.getProperty(WildflyPluginProperties.PROPERTY_ROOT_DIR));\n    }\n    public File getDeployDir() {\n        return new File(ip.getProperty(WildflyPluginProperties.PROPERTY_DEPLOY_DIR));\n    }\n    public File getLibsDir() {\n        return new File(getServerDir(), \"lib\"); // NOI18N\n    }\n    public boolean getProxyEnabled() {\n        String val = ip.getProperty(PROP_PROXY_ENABLED);\n        return val != null ? Boolean.valueOf(val)\n                : DEF_VALUE_PROXY_ENABLED;\n    }\n    public void setProxyEnabled(boolean enabled) {\n        ip.setProperty(PROP_PROXY_ENABLED, Boolean.toString(enabled));\n    }\n    public JavaPlatform getJavaPlatform() {\n        String currentJvm = ip.getProperty(PROP_JAVA_PLATFORM);\n        JavaPlatformManager jpm = JavaPlatformManager.getDefault();\n        JavaPlatform[] installedPlatforms = jpm.getPlatforms(null, new Specification(\"J2SE\", null)); // NOI18N\n        for (int i = 0; i < installedPlatforms.length; i++) {\n            String platformName = (String) installedPlatforms[i].getProperties().get(PLAT_PROP_ANT_NAME);\n            if (platformName != null && platformName.equals(currentJvm)) {\n                return installedPlatforms[i];\n            }\n        }\n        // return default platform if none was set\n        return jpm.getDefaultPlatform();\n    }\n    public void setJavaPlatform(JavaPlatform javaPlatform) {\n        ip.setProperty(PROP_JAVA_PLATFORM, (String) javaPlatform.getProperties().get(PLAT_PROP_ANT_NAME));\n    }\n    public String getJavaOpts() {\n        String val = ip.getProperty(WildflyPluginProperties.PROPERTY_JAVA_OPTS);\n        return val != null ? val : DEF_VALUE_JAVA_OPTS;\n    }\n    public void setJavaOpts(String javaOpts) {\n        ip.setProperty(WildflyPluginProperties.PROPERTY_JAVA_OPTS, javaOpts);\n    }\n    public String getModulePath(String module) {\n        return getRootDir().getAbsolutePath() + (\"/modules/system/layers/base/\" + module).replace('/', File.separatorChar);\n    }\n    private static void addFileToList(List<URL> list, File f) {\n        URL u = FileUtil.urlForArchiveOrDir(f);\n        if (u != null) {\n            list.add(u);\n        }\n    }\n    private List<URL> selectJars(FileObject file) {\n        if (file == null) {\n            return Collections.EMPTY_LIST;\n        }\n        if (file.isData()) {\n            if (file.isValid() && FileUtil.isArchiveFile(file)) {\n                URL url = URLMapper.findURL(file, URLMapper.EXTERNAL);\n                if (url != null) {\n                    return Collections.singletonList(FileUtil.getArchiveRoot(url));\n                }\n            }\n            return Collections.EMPTY_LIST;\n        }\n        List<URL> result = new ArrayList<URL>();\n        for (FileObject child : file.getChildren()) {\n            result.addAll(selectJars(child));\n        }\n        return result;\n    }\n    public List<URL> getClasses() {\n        List<URL> list = selectJars(FileUtil.toFileObject(new File(getModulePath(\"javax\"))));\n        File glassfish = new File(getModulePath(\"org/glassfish/javax\"));\n        if(glassfish.exists()) {\n            list.addAll(selectJars(FileUtil.toFileObject(glassfish)));\n        }\n        return list;\n    }\n    public List<URL> getSources() {\n        String path = ip.getProperty(PROP_SOURCES);\n        if (path == null) {\n            return new ArrayList<URL>();\n        }\n        return CustomizerSupport.tokenizePath(path);\n    }\n    public void setSources(List<URL> path) {\n        ip.setProperty(PROP_SOURCES, CustomizerSupport.buildPath(path));\n        // XXX WILDFLY IMPLEMENT\n        //manager.getJBPlatform().notifyLibrariesChanged();\n    }\n    public List<URL> getJavadocs() {\n        String path = ip.getProperty(PROP_JAVADOCS);\n        if (path == null) {\n            ArrayList<URL> list = new ArrayList<URL>();\n            File j2eeDoc = InstalledFileLocator.getDefault().locate(\"docs/javaee-doc-api.jar\", null, false); // NOI18N\n            if (j2eeDoc != null) {\n                addFileToList(list, j2eeDoc);\n            }\n            return list;\n        }\n        return CustomizerSupport.tokenizePath(path);\n    }\n    public void setJavadocs(List<URL> path) {\n        ip.setProperty(PROP_JAVADOCS, CustomizerSupport.buildPath(path));\n        // XXX WILDFLY IMPLEMENT\n        //manager.getJBPlatform().notifyLibrariesChanged();\n    }\n    public synchronized String getUsername() {\n        updateCredentials();\n        return username;\n    }\n    public synchronized String getPassword() {\n        updateCredentials();\n        return password;\n    }\n    // private helper methods -------------------------------------------------\n    private synchronized void updateCredentials() {\n        File usersPropFile = new File(getServerDir(), \"/conf/props/jmx-console-users.properties\");\n        long lastModified = usersPropFile.lastModified();\n        if (lastModified == updateCredentialsTimestamp) {\n            LOGGER.log(Level.FINER, \"Credentials are up-to-date.\");\n            return;\n        }\n        Properties usersProps = new Properties();\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(usersPropFile));\n            try {\n                usersProps.load(is);\n            } finally {\n                is.close();\n            }\n        } catch (FileNotFoundException e) {\n            LOGGER.log(Level.WARNING, usersPropFile + \" not found.\", e);\n            return;\n        } catch (IOException e) {\n            LOGGER.log(Level.WARNING, \"Error while reading \" + usersPropFile, e);\n            return;\n        }\n        Enumeration<String> names = NbCollections.checkedEnumerationByFilter(usersProps.propertyNames(), String.class, false);\n        if (names.hasMoreElements()) {\n            username = names.nextElement();\n            password = usersProps.getProperty(username);\n        }\n        updateCredentialsTimestamp = lastModified;\n    }\n"]], "pred": {"ppl": 1.9447011947631836, "ppl_lower": 2.3105990886688232, "ppl/lowercase_ppl": -1.2592036348560687, "ppl/zlib": 0.0002711407818578893, "Min_5.0% Prob": 6.336546977361043, "Min_10.0% Prob": 4.615412625611997, "Min_20.0% Prob": 3.0050417231578455, "Min_30.0% Prob": 2.157968942392496, "Min_40.0% Prob": 1.6485166263318003, "Min_50.0% Prob": 1.3273046435150382, "Min_60.0% Prob": 1.108858018537731}}
{"hexsha": "037b850646ff7ace3595871c7f5744336230612d", "ext": "java", "lang": "Java", "content": "public class CredentialArray {\n    private StoredCredential[] creds;\n    private boolean[] slotStatus;\n    private short size;\n    private short counter;\n\n    /**\n     * Constructor for a CredentialArray.\n     * @param initialSize Initial sizing for the CredentialArray.\n     */\n    public CredentialArray(short initialSize) {\n        creds = new StoredCredential[initialSize];\n        slotStatus = new boolean[initialSize];\n        size = initialSize;\n    }\n    /**\n     * Adds a new credential to the first free slot, or overwrites if a matching rp and user id matches.\n     * @param in the StoredCredential object to be stored.\n     */\n    public void addCredential(StoredCredential in) throws UserException{\n        try {\n            short slot = alreadyExists(in);\n            creds[slot] = in;\n            slotStatus[slot] = true;\n        } catch (Exception e) {\n            UserException.throwIt(CTAP2.CTAP2_ERR_KEY_STORE_FULL);\n        }\n    }\n    /**\n     * Finds and returns a StoredCredential given the rpId and userId, returns null if not present.\n     * @param rpId\n     * @param off\n     * @param len\n     * @return\n     */\n    public StoredCredential getCredential(byte[] rpId, short rpOff, short rpLen, byte[] userId, short userOff, short userLen) {\n        for(counter = 0; counter < size; counter++) {\n            // Check the slot status, if the RP matches, and then if the user matches. If so, return the credential.\n            if(slotStatus[counter] && creds[counter].rp.checkId(rpId, rpOff, rpLen) && creds[counter].user.checkId(userId, userOff, userLen)) {\n                return creds[counter];\n            }\n        }\n        return null;\n    }\n    \n    \n    \n    /**\n     * Confirms there is no already existing discoverable credential - if it finds one, it returns its location for overwriting.\n     * @return the location of a discoverable credential already matching the RP and User IDs, or the first free slot otherwise.\n     */\n    public short alreadyExists(StoredCredential cred) {\n        for(counter = 0; counter < size; counter++) {\n            // Check the slot status, if the RP matches, and then if the user matches. If so, return the slot to use.\n            if(slotStatus[counter] && creds[counter].rp.checkId(cred.rp) && creds[counter].user.checkId(cred.user)) {\n                return counter;\n            }\n        }\n        // Find the first free slot\n        for(counter = 0; counter < size; counter++) {\n            if(!slotStatus[counter]) {\n                return counter;\n            } \n        }\n        // No free slots\n\n        // Add more\n\n        StoredCredential[] tmp = new StoredCredential[size];\n        boolean[] tmpStatus = new boolean[size];\n        for(counter = 0; counter < size; counter++) {\n            // SonarLint throws an error here, but JavaCard can only copy byte arrays\n            tmp[counter] = creds[counter];\n            tmpStatus[counter] = slotStatus[counter];\n        }\n        creds = new StoredCredential[(short) (size*2)];\n        slotStatus = new boolean[(short) (size*2)];\n        for(counter = 0; counter < size; counter++) {\n            creds[counter] = tmp[counter];\n            slotStatus[counter] = tmpStatus[counter];\n        }\n        // Actually double the size....\n        size *= (short) 2;\n        // Delete objects we used to copy\n        JCSystem.requestObjectDeletion();\n        // Return the first free slot in the new array, which is going to be the counter plus 1\n        return (short) (counter + (short) 1);\n    }\n    /**\n     * Get the size of the array.\n     * @return the array size\n     */\n    public short getLength() {\n        return size;\n    }\n    /**\n     * Returns the credential at position, or null if none.\n     * @param position the position to get.\n     * @return the credential, or null.\n     */\n    public StoredCredential getCred(short position) {\n        return creds[position];\n    }\n    \n}", "item_id": 0, "repo": "VivoKey/vk-u2f", "file": "src/main/java/com/vivokey/u2f/CredentialArray.java", "last_update_at": "2022-03-22T22:10:23+00:00", "question_id": "037b850646ff7ace3595871c7f5744336230612d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CredentialArray {\n    private StoredCredential[] creds;\n    private boolean[] slotStatus;\n    private short size;\n    private short counter;\n    /**\n     * Constructor for a CredentialArray.\n     * @param initialSize Initial sizing for the CredentialArray.\n     */\n    public CredentialArray(short initialSize) {\n        creds = new StoredCredential[initialSize];\n        slotStatus = new boolean[initialSize];\n        size = initialSize;\n    }\n    /**\n     * Adds a new credential to the first free slot, or overwrites if a matching rp and user id matches.\n     * @param in the StoredCredential object to be stored.\n     */\n    public void addCredential(StoredCredential in) throws UserException{\n        try {\n            short slot = alreadyExists(in);\n            creds[slot] = in;\n            slotStatus[slot] = true;\n        } catch (Exception e) {\n            UserException.throwIt(CTAP2.CTAP2_ERR_KEY_STORE_FULL);\n        }\n    }\n    /**\n     * Finds and returns a StoredCredential given the rpId and userId, returns null if not present.\n     * @param rpId\n     * @param off\n     * @param len\n     * @return\n     */\n    public StoredCredential getCredential(byte[] rpId, short rpOff, short rpLen, byte[] userId, short userOff, short userLen) {\n        for(counter = 0; counter < size; counter++) {\n            // Check the slot status, if the RP matches, and then if the user matches. If so, return the credential.\n            if(slotStatus[counter] && creds[counter].rp.checkId(rpId, rpOff, rpLen) && creds[counter].user.checkId(userId, userOff, userLen)) {\n                return creds[counter];\n            }\n        }\n        return null;\n    }\n    /**\n     * Confirms there is no already existing discoverable credential - if it finds one, it returns its location for overwriting.\n     * @return the location of a discoverable credential already matching the RP and User IDs, or the first free slot otherwise.\n     */\n    public short alreadyExists(StoredCredential cred) {\n        for(counter = 0; counter < size; counter++) {\n            // Check the slot status, if the RP matches, and then if the user matches. If so, return the slot to use.\n            if(slotStatus[counter] && creds[counter].rp.checkId(cred.rp) && creds[counter].user.checkId(cred.user)) {\n                return counter;\n            }\n        }\n        // Find the first free slot\n        for(counter = 0; counter < size; counter++) {\n            if(!slotStatus[counter]) {\n                return counter;\n            } \n        }\n        // No free slots\n        // Add more\n        StoredCredential[] tmp = new StoredCredential[size];\n        boolean[] tmpStatus = new boolean[size];\n        for(counter = 0; counter < size; counter++) {\n            // SonarLint throws an error here, but JavaCard can only copy byte arrays\n            tmp[counter] = creds[counter];\n            tmpStatus[counter] = slotStatus[counter];\n        }\n        creds = new StoredCredential[(short) (size*2)];\n        slotStatus = new boolean[(short) (size*2)];\n        for(counter = 0; counter < size; counter++) {\n            creds[counter] = tmp[counter];\n            slotStatus[counter] = tmpStatus[counter];\n        }\n        // Actually double the size....\n        size *= (short) 2;\n        // Delete objects we used to copy\n        JCSystem.requestObjectDeletion();\n        // Return the first free slot in the new array, which is going to be the counter plus 1\n        return (short) (counter + (short) 1);\n    }\n    /**\n     * Get the size of the array.\n     * @return the array size\n     */\n    public short getLength() {\n        return size;\n    }\n    /**\n     * Returns the credential at position, or null if none.\n     * @param position the position to get.\n     * @return the credential, or null.\n     */\n    public StoredCredential getCred(short position) {\n        return creds[position];\n    }\n"]], "pred": {"ppl": 2.247864246368408, "ppl_lower": 2.4750866889953613, "ppl/lowercase_ppl": -1.1188854234622638, "ppl/zlib": 0.0007024983014586515, "Min_5.0% Prob": 7.069244880302279, "Min_10.0% Prob": 5.352845423361835, "Min_20.0% Prob": 3.603481761380738, "Min_30.0% Prob": 2.610974246575162, "Min_40.0% Prob": 1.9999740834377506, "Min_50.0% Prob": 1.6143680928373407, "Min_60.0% Prob": 1.3494991586827727}}
{"hexsha": "aee9a2c6a47dc82a9164df2b3a6c67a9177cc928", "ext": "java", "lang": "Java", "content": "public class TensorIOTest {\n\n    @Test\n    public void testIntoTable() {\n        Tensor tensor1 = Tensor.fromLongData(new long[]{1, 2, 3});\n        Tensor tensor2 = Tensor.fromStringData(new String[]{\"1\", \"2\", \"3\"});\n\n        Table table = new TensorIO(Map.of(\"col1\", tensor1, \"col2\", tensor2)).intoTable();\n        assertEquals(2, table.columnCount());\n        assertEquals(3, table.rowCount());\n\n        assertEquals(1L, table.column(\"col1\").get(0));\n        assertEquals(2L, table.column(\"col1\").get(1));\n        assertEquals(3L, table.column(\"col1\").get(2));\n        assertEquals(\"1\", table.column(\"col2\").get(0));\n        assertEquals(\"2\", table.column(\"col2\").get(1));\n        assertEquals(\"3\", table.column(\"col2\").get(2));\n    }\n\n}", "item_id": 0, "repo": "Valeriabonilla01/serving-runtime", "file": "commons/src/test/java/com/ovh/mls/serving/runtime/core/io/TensorIOTest.java", "last_update_at": "2022-02-25T14:26:51+00:00", "question_id": "aee9a2c6a47dc82a9164df2b3a6c67a9177cc928_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TensorIOTest {\n    @Test\n    public void testIntoTable() {\n        Tensor tensor1 = Tensor.fromLongData(new long[]{1, 2, 3});\n        Tensor tensor2 = Tensor.fromStringData(new String[]{\"1\", \"2\", \"3\"});\n        Table table = new TensorIO(Map.of(\"col1\", tensor1, \"col2\", tensor2)).intoTable();\n        assertEquals(2, table.columnCount());\n        assertEquals(3, table.rowCount());\n        assertEquals(1L, table.column(\"col1\").get(0));\n        assertEquals(2L, table.column(\"col1\").get(1));\n        assertEquals(3L, table.column(\"col1\").get(2));\n        assertEquals(\"1\", table.column(\"col2\").get(0));\n        assertEquals(\"2\", table.column(\"col2\").get(1));\n        assertEquals(\"3\", table.column(\"col2\").get(2));\n    }\n"]], "pred": {"ppl": 1.698148488998413, "ppl_lower": 2.0408201217651367, "ppl/lowercase_ppl": -1.3471196192987906, "ppl/zlib": 0.001954016728475751, "Min_5.0% Prob": 5.978127360343933, "Min_10.0% Prob": 4.115583389997482, "Min_20.0% Prob": 2.461038822422222, "Min_30.0% Prob": 1.729558845025462, "Min_40.0% Prob": 1.3177823755852502, "Min_50.0% Prob": 1.0575584915932268, "Min_60.0% Prob": 0.8870452937301928}}
{"hexsha": "880c46024fdd0c17c2a0a2b6f868a0d9d3201711", "ext": "java", "lang": "Java", "content": "public final class HiveTestUtils\n{\n    private HiveTestUtils()\n    {\n    }\n\n    public static final ConnectorSession SESSION = new TestingConnectorSession(\n            new HiveSessionProperties(new HiveClientConfig(), new OrcFileWriterConfig(), new ParquetFileWriterConfig()).getSessionProperties());\n\n    public static final TypeRegistry TYPE_MANAGER = new TypeRegistry();\n\n    public static final MetadataManager METADATA = MetadataManager.createTestMetadataManager();\n\n    public static final StandardFunctionResolution FUNCTION_RESOLUTION = new FunctionResolution(METADATA.getFunctionManager());\n\n    public static final RowExpressionService ROW_EXPRESSION_SERVICE = new RowExpressionService()\n    {\n        @Override\n        public DomainTranslator getDomainTranslator()\n        {\n            return new RowExpressionDomainTranslator(METADATA);\n        }\n\n        @Override\n        public ExpressionOptimizer getExpressionOptimizer()\n        {\n            return new RowExpressionOptimizer(METADATA);\n        }\n\n        @Override\n        public PredicateCompiler getPredicateCompiler()\n        {\n            return new RowExpressionPredicateCompiler(METADATA);\n        }\n\n        @Override\n        public DeterminismEvaluator getDeterminismEvaluator()\n        {\n            return new RowExpressionDeterminismEvaluator(METADATA);\n        }\n\n        @Override\n        public String formatRowExpression(ConnectorSession session, RowExpression expression)\n        {\n            return new RowExpressionFormatter(METADATA.getFunctionManager()).formatRowExpression(session, expression);\n        }\n    };\n\n    public static final FilterStatsCalculatorService FILTER_STATS_CALCULATOR_SERVICE = new ConnectorFilterStatsCalculatorService(\n            new FilterStatsCalculator(METADATA, new ScalarStatsCalculator(METADATA), new StatsNormalizer()));\n\n    static {\n        // associate TYPE_MANAGER with a function manager\n        new FunctionManager(TYPE_MANAGER, new BlockEncodingManager(TYPE_MANAGER), new FeaturesConfig());\n    }\n\n    public static final HiveClientConfig HIVE_CLIENT_CONFIG = new HiveClientConfig();\n    public static final MetastoreClientConfig METASTORE_CLIENT_CONFIG = new MetastoreClientConfig();\n\n    public static final HdfsEnvironment HDFS_ENVIRONMENT = createTestHdfsEnvironment(HIVE_CLIENT_CONFIG, METASTORE_CLIENT_CONFIG);\n\n    public static final PageSorter PAGE_SORTER = new PagesIndexPageSorter(new PagesIndex.TestingFactory(false));\n\n    public static Set<HiveBatchPageSourceFactory> getDefaultHiveBatchPageSourceFactories(HiveClientConfig hiveClientConfig, MetastoreClientConfig metastoreClientConfig)\n    {\n        FileFormatDataSourceStats stats = new FileFormatDataSourceStats();\n        HdfsEnvironment testHdfsEnvironment = createTestHdfsEnvironment(hiveClientConfig, metastoreClientConfig);\n        return ImmutableSet.<HiveBatchPageSourceFactory>builder()\n                .add(new RcFilePageSourceFactory(TYPE_MANAGER, testHdfsEnvironment, stats))\n                .add(new OrcBatchPageSourceFactory(TYPE_MANAGER, hiveClientConfig, testHdfsEnvironment, stats, new StorageOrcFileTailSource(), new StorageStripeMetadataSource()))\n                .add(new DwrfBatchPageSourceFactory(TYPE_MANAGER, hiveClientConfig, testHdfsEnvironment, stats, new StorageOrcFileTailSource(), new StorageStripeMetadataSource()))\n                .add(new ParquetPageSourceFactory(TYPE_MANAGER, testHdfsEnvironment, stats))\n                .add(new PageFilePageSourceFactory(testHdfsEnvironment, new BlockEncodingManager(TYPE_MANAGER)))\n                .build();\n    }\n\n    public static Set<HiveSelectivePageSourceFactory> getDefaultHiveSelectivePageSourceFactories(HiveClientConfig hiveClientConfig, MetastoreClientConfig metastoreClientConfig)\n    {\n        FileFormatDataSourceStats stats = new FileFormatDataSourceStats();\n        HdfsEnvironment testHdfsEnvironment = createTestHdfsEnvironment(hiveClientConfig, metastoreClientConfig);\n        return ImmutableSet.<HiveSelectivePageSourceFactory>builder()\n                .add(new OrcSelectivePageSourceFactory(TYPE_MANAGER, FUNCTION_RESOLUTION, ROW_EXPRESSION_SERVICE, hiveClientConfig, testHdfsEnvironment, stats, new StorageOrcFileTailSource(), new StorageStripeMetadataSource(), new TupleDomainFilterCache()))\n                .add(new DwrfSelectivePageSourceFactory(TYPE_MANAGER, FUNCTION_RESOLUTION, ROW_EXPRESSION_SERVICE, hiveClientConfig, testHdfsEnvironment, stats, new StorageOrcFileTailSource(), new StorageStripeMetadataSource(), new TupleDomainFilterCache()))\n                .build();\n    }\n\n    public static Set<HiveRecordCursorProvider> getDefaultHiveRecordCursorProvider(HiveClientConfig hiveClientConfig, MetastoreClientConfig metastoreClientConfig)\n    {\n        HdfsEnvironment testHdfsEnvironment = createTestHdfsEnvironment(hiveClientConfig, metastoreClientConfig);\n        return ImmutableSet.<HiveRecordCursorProvider>builder()\n                .add(new GenericHiveRecordCursorProvider(testHdfsEnvironment))\n                .build();\n    }\n\n    public static Set<HiveFileWriterFactory> getDefaultHiveFileWriterFactories(HiveClientConfig hiveClientConfig, MetastoreClientConfig metastoreClientConfig)\n    {\n        HdfsEnvironment testHdfsEnvironment = createTestHdfsEnvironment(hiveClientConfig, metastoreClientConfig);\n        return ImmutableSet.<HiveFileWriterFactory>builder()\n                .add(new RcFileFileWriterFactory(testHdfsEnvironment, TYPE_MANAGER, new NodeVersion(\"test_version\"), hiveClientConfig, new FileFormatDataSourceStats()))\n                .add(new PageFileWriterFactory(testHdfsEnvironment, new BlockEncodingManager(TYPE_MANAGER)))\n                .add(getDefaultOrcFileWriterFactory(hiveClientConfig, metastoreClientConfig))\n                .build();\n    }\n\n    public static OrcFileWriterFactory getDefaultOrcFileWriterFactory(HiveClientConfig hiveClientConfig, MetastoreClientConfig metastoreClientConfig)\n    {\n        HdfsEnvironment testHdfsEnvironment = createTestHdfsEnvironment(hiveClientConfig, metastoreClientConfig);\n        return new OrcFileWriterFactory(\n                testHdfsEnvironment,\n                TYPE_MANAGER,\n                new NodeVersion(\"test_version\"),\n                hiveClientConfig,\n                new FileFormatDataSourceStats(),\n                new OrcFileWriterConfig());\n    }\n\n    public static List<Type> getTypes(List<? extends ColumnHandle> columnHandles)\n    {\n        ImmutableList.Builder<Type> types = ImmutableList.builder();\n        for (ColumnHandle columnHandle : columnHandles) {\n            types.add(TYPE_MANAGER.getType(((HiveColumnHandle) columnHandle).getTypeSignature()));\n        }\n        return types.build();\n    }\n\n    public static HdfsEnvironment createTestHdfsEnvironment(HiveClientConfig config, MetastoreClientConfig metastoreClientConfig)\n    {\n        HdfsConfiguration hdfsConfig = new HiveHdfsConfiguration(\n                new HdfsConfigurationInitializer(\n                        config,\n                        metastoreClientConfig,\n                        new PrestoS3ConfigurationUpdater(new HiveS3Config()),\n                        new HiveGcsConfigurationInitializer(new HiveGcsConfig())),\n                ImmutableSet.of());\n        return new HdfsEnvironment(hdfsConfig, metastoreClientConfig, new NoHdfsAuthentication());\n    }\n\n    public static MapType mapType(Type keyType, Type valueType)\n    {\n        return (MapType) TYPE_MANAGER.getParameterizedType(StandardTypes.MAP, ImmutableList.of(\n                TypeSignatureParameter.of(keyType.getTypeSignature()),\n                TypeSignatureParameter.of(valueType.getTypeSignature())));\n    }\n\n    public static ArrayType arrayType(Type elementType)\n    {\n        return (ArrayType) TYPE_MANAGER.getParameterizedType(\n                StandardTypes.ARRAY,\n                ImmutableList.of(TypeSignatureParameter.of(elementType.getTypeSignature())));\n    }\n\n    public static RowType rowType(List<NamedTypeSignature> elementTypeSignatures)\n    {\n        return (RowType) TYPE_MANAGER.getParameterizedType(\n                StandardTypes.ROW,\n                ImmutableList.copyOf(elementTypeSignatures.stream()\n                        .map(TypeSignatureParameter::of)\n                        .collect(toList())));\n    }\n\n    public static Long shortDecimal(String value)\n    {\n        return new BigDecimal(value).unscaledValue().longValueExact();\n    }\n\n    public static Slice longDecimal(String value)\n    {\n        return encodeScaledValue(new BigDecimal(value));\n    }\n}", "item_id": 0, "repo": "itssundeep/presto", "file": "presto-hive/src/test/java/com/facebook/presto/hive/HiveTestUtils.java", "last_update_at": "2022-02-16T01:11:02+00:00", "question_id": "880c46024fdd0c17c2a0a2b6f868a0d9d3201711_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class HiveTestUtils\n{\n    private HiveTestUtils()\n    {\n    }\n    public static final ConnectorSession SESSION = new TestingConnectorSession(\n            new HiveSessionProperties(new HiveClientConfig(), new OrcFileWriterConfig(), new ParquetFileWriterConfig()).getSessionProperties());\n    public static final TypeRegistry TYPE_MANAGER = new TypeRegistry();\n    public static final MetadataManager METADATA = MetadataManager.createTestMetadataManager();\n    public static final StandardFunctionResolution FUNCTION_RESOLUTION = new FunctionResolution(METADATA.getFunctionManager());\n    public static final RowExpressionService ROW_EXPRESSION_SERVICE = new RowExpressionService()\n    {\n        @Override\n        public DomainTranslator getDomainTranslator()\n        {\n            return new RowExpressionDomainTranslator(METADATA);\n        }\n        @Override\n        public ExpressionOptimizer getExpressionOptimizer()\n        {\n            return new RowExpressionOptimizer(METADATA);\n        }\n        @Override\n        public PredicateCompiler getPredicateCompiler()\n        {\n            return new RowExpressionPredicateCompiler(METADATA);\n        }\n        @Override\n        public DeterminismEvaluator getDeterminismEvaluator()\n        {\n            return new RowExpressionDeterminismEvaluator(METADATA);\n        }\n        @Override\n        public String formatRowExpression(ConnectorSession session, RowExpression expression)\n        {\n            return new RowExpressionFormatter(METADATA.getFunctionManager()).formatRowExpression(session, expression);\n        }\n    };\n    public static final FilterStatsCalculatorService FILTER_STATS_CALCULATOR_SERVICE = new ConnectorFilterStatsCalculatorService(\n            new FilterStatsCalculator(METADATA, new ScalarStatsCalculator(METADATA), new StatsNormalizer()));\n    static {\n        // associate TYPE_MANAGER with a function manager\n        new FunctionManager(TYPE_MANAGER, new BlockEncodingManager(TYPE_MANAGER), new FeaturesConfig());\n    }\n    public static final HiveClientConfig HIVE_CLIENT_CONFIG = new HiveClientConfig();\n    public static final MetastoreClientConfig METASTORE_CLIENT_CONFIG = new MetastoreClientConfig();\n    public static final HdfsEnvironment HDFS_ENVIRONMENT = createTestHdfsEnvironment(HIVE_CLIENT_CONFIG, METASTORE_CLIENT_CONFIG);\n    public static final PageSorter PAGE_SORTER = new PagesIndexPageSorter(new PagesIndex.TestingFactory(false));\n    public static Set<HiveBatchPageSourceFactory> getDefaultHiveBatchPageSourceFactories(HiveClientConfig hiveClientConfig, MetastoreClientConfig metastoreClientConfig)\n    {\n        FileFormatDataSourceStats stats = new FileFormatDataSourceStats();\n        HdfsEnvironment testHdfsEnvironment = createTestHdfsEnvironment(hiveClientConfig, metastoreClientConfig);\n        return ImmutableSet.<HiveBatchPageSourceFactory>builder()\n                .add(new RcFilePageSourceFactory(TYPE_MANAGER, testHdfsEnvironment, stats))\n                .add(new OrcBatchPageSourceFactory(TYPE_MANAGER, hiveClientConfig, testHdfsEnvironment, stats, new StorageOrcFileTailSource(), new StorageStripeMetadataSource()))\n                .add(new DwrfBatchPageSourceFactory(TYPE_MANAGER, hiveClientConfig, testHdfsEnvironment, stats, new StorageOrcFileTailSource(), new StorageStripeMetadataSource()))\n                .add(new ParquetPageSourceFactory(TYPE_MANAGER, testHdfsEnvironment, stats))\n                .add(new PageFilePageSourceFactory(testHdfsEnvironment, new BlockEncodingManager(TYPE_MANAGER)))\n                .build();\n    }\n    public static Set<HiveSelectivePageSourceFactory> getDefaultHiveSelectivePageSourceFactories(HiveClientConfig hiveClientConfig, MetastoreClientConfig metastoreClientConfig)\n    {\n        FileFormatDataSourceStats stats = new FileFormatDataSourceStats();\n        HdfsEnvironment testHdfsEnvironment = createTestHdfsEnvironment(hiveClientConfig, metastoreClientConfig);\n        return ImmutableSet.<HiveSelectivePageSourceFactory>builder()\n                .add(new OrcSelectivePageSourceFactory(TYPE_MANAGER, FUNCTION_RESOLUTION, ROW_EXPRESSION_SERVICE, hiveClientConfig, testHdfsEnvironment, stats, new StorageOrcFileTailSource(), new StorageStripeMetadataSource(), new TupleDomainFilterCache()))\n                .add(new DwrfSelectivePageSourceFactory(TYPE_MANAGER, FUNCTION_RESOLUTION, ROW_EXPRESSION_SERVICE, hiveClientConfig, testHdfsEnvironment, stats, new StorageOrcFileTailSource(), new StorageStripeMetadataSource(), new TupleDomainFilterCache()))\n                .build();\n    }\n    public static Set<HiveRecordCursorProvider> getDefaultHiveRecordCursorProvider(HiveClientConfig hiveClientConfig, MetastoreClientConfig metastoreClientConfig)\n    {\n        HdfsEnvironment testHdfsEnvironment = createTestHdfsEnvironment(hiveClientConfig, metastoreClientConfig);\n        return ImmutableSet.<HiveRecordCursorProvider>builder()\n                .add(new GenericHiveRecordCursorProvider(testHdfsEnvironment))\n                .build();\n    }\n    public static Set<HiveFileWriterFactory> getDefaultHiveFileWriterFactories(HiveClientConfig hiveClientConfig, MetastoreClientConfig metastoreClientConfig)\n    {\n        HdfsEnvironment testHdfsEnvironment = createTestHdfsEnvironment(hiveClientConfig, metastoreClientConfig);\n        return ImmutableSet.<HiveFileWriterFactory>builder()\n                .add(new RcFileFileWriterFactory(testHdfsEnvironment, TYPE_MANAGER, new NodeVersion(\"test_version\"), hiveClientConfig, new FileFormatDataSourceStats()))\n                .add(new PageFileWriterFactory(testHdfsEnvironment, new BlockEncodingManager(TYPE_MANAGER)))\n                .add(getDefaultOrcFileWriterFactory(hiveClientConfig, metastoreClientConfig))\n                .build();\n    }\n    public static OrcFileWriterFactory getDefaultOrcFileWriterFactory(HiveClientConfig hiveClientConfig, MetastoreClientConfig metastoreClientConfig)\n    {\n        HdfsEnvironment testHdfsEnvironment = createTestHdfsEnvironment(hiveClientConfig, metastoreClientConfig);\n        return new OrcFileWriterFactory(\n                testHdfsEnvironment,\n                TYPE_MANAGER,\n                new NodeVersion(\"test_version\"),\n                hiveClientConfig,\n                new FileFormatDataSourceStats(),\n                new OrcFileWriterConfig());\n    }\n    public static List<Type> getTypes(List<? extends ColumnHandle> columnHandles)\n    {\n        ImmutableList.Builder<Type> types = ImmutableList.builder();\n        for (ColumnHandle columnHandle : columnHandles) {\n            types.add(TYPE_MANAGER.getType(((HiveColumnHandle) columnHandle).getTypeSignature()));\n        }\n        return types.build();\n    }\n    public static HdfsEnvironment createTestHdfsEnvironment(HiveClientConfig config, MetastoreClientConfig metastoreClientConfig)\n    {\n        HdfsConfiguration hdfsConfig = new HiveHdfsConfiguration(\n                new HdfsConfigurationInitializer(\n                        config,\n                        metastoreClientConfig,\n                        new PrestoS3ConfigurationUpdater(new HiveS3Config()),\n                        new HiveGcsConfigurationInitializer(new HiveGcsConfig())),\n                ImmutableSet.of());\n        return new HdfsEnvironment(hdfsConfig, metastoreClientConfig, new NoHdfsAuthentication());\n    }\n    public static MapType mapType(Type keyType, Type valueType)\n    {\n        return (MapType) TYPE_MANAGER.getParameterizedType(StandardTypes.MAP, ImmutableList.of(\n                TypeSignatureParameter.of(keyType.getTypeSignature()),\n                TypeSignatureParameter.of(valueType.getTypeSignature())));\n    }\n    public static ArrayType arrayType(Type elementType)\n    {\n        return (ArrayType) TYPE_MANAGER.getParameterizedType(\n                StandardTypes.ARRAY,\n                ImmutableList.of(TypeSignatureParameter.of(elementType.getTypeSignature())));\n    }\n    public static RowType rowType(List<NamedTypeSignature> elementTypeSignatures)\n    {\n        return (RowType) TYPE_MANAGER.getParameterizedType(\n                StandardTypes.ROW,\n                ImmutableList.copyOf(elementTypeSignatures.stream()\n                        .map(TypeSignatureParameter::of)\n                        .collect(toList())));\n    }\n    public static Long shortDecimal(String value)\n    {\n        return new BigDecimal(value).unscaledValue().longValueExact();\n    }\n    public static Slice longDecimal(String value)\n    {\n        return encodeScaledValue(new BigDecimal(value));\n    }\n"]], "pred": {"ppl": 1.4245636463165283, "ppl_lower": 2.3440630435943604, "ppl/lowercase_ppl": -2.407371268938821, "ppl/zlib": 0.00021330051459710541, "Min_5.0% Prob": 4.450642225789089, "Min_10.0% Prob": 2.9560439323677734, "Min_20.0% Prob": 1.7076363184434526, "Min_30.0% Prob": 1.173565823268267, "Min_40.0% Prob": 0.8836726458255921, "Min_50.0% Prob": 0.7081332425165415, "Min_60.0% Prob": 0.5904842462353819}}
{"hexsha": "4b2f466a2efbfb403ac3a41f85d58dc900a7f8d6", "ext": "java", "lang": "Java", "content": "public class ModifierTracker {\n\t/**\n\t * Add KeyListeners to everything in an applet.\n\t * <P>\n\t * Unsigned applets can't simply add an event listener to the toolkit for\n\t * security reasons, so this method provides an alternative approach.\n\t * <P>\n\t * This alternative should work in controlled environments where components\n\t * are not added to an applet after this method is called, but in other\n\t * cases it might fail.\n\t * \n\t * @param applet\n\t *            the applet to track\n\t */\n\tpublic static void track(JApplet applet) {\n\t\tif (isActive() == false) {\n\t\t\ttrack(applet.getContentPane());\n\t\t}\n\t}\n\n\tprivate static KeyListener keyListener = new KeyListener() {\n\t\tpublic void keyTyped(KeyEvent e) {\n\t\t}\n\n\t\tpublic void keyPressed(KeyEvent e) {\n\t\t\tkey(e.getKeyCode(), true);\n\t\t}\n\n\t\tpublic void keyReleased(KeyEvent e) {\n\t\t\tkey(e.getKeyCode(), false);\n\t\t}\n\n\t\tprivate void key(int code, boolean pressed) {\n\t\t\tif (code == KeyEvent.VK_ALT) {\n\t\t\t\tif (alt != pressed) {\n\t\t\t\t\talt = pressed;\n\t\t\t\t\tfireAltChangeListeners();\n\t\t\t\t}\n\t\t\t} else if (code == KeyEvent.VK_ALT_GRAPH) {\n\t\t\t\tif (altGraph != pressed) {\n\t\t\t\t\taltGraph = pressed;\n\t\t\t\t\tfireAltGraphChangeListeners();\n\t\t\t\t}\n\t\t\t} else if (code == KeyEvent.VK_CONTROL) {\n\t\t\t\tif (ctrl != pressed) {\n\t\t\t\t\tctrl = pressed;\n\t\t\t\t\tfireControlChangeListeners();\n\t\t\t\t}\n\t\t\t} else if (code == KeyEvent.VK_META) {\n\t\t\t\tif (meta != pressed) {\n\t\t\t\t\tmeta = pressed;\n\t\t\t\t\tfireMetaChangeListeners();\n\t\t\t\t}\n\t\t\t} else if (code == KeyEvent.VK_SHIFT) {\n\t\t\t\tif (shift != pressed) {\n\t\t\t\t\tshift = pressed;\n\t\t\t\t\tfireShiftChangeListeners();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tprivate static void track(Component c) {\n\t\tc.addKeyListener(keyListener);\n\n\t\tif (c instanceof Container) {\n\t\t\tContainer container = (Container) c;\n\t\t\tfor (int a = 0; a < container.getComponentCount(); a++) {\n\t\t\t\ttrack(container.getComponent(a));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static boolean alt = false;\n\tprivate static boolean altGraph = false;\n\tprivate static boolean meta = false;\n\tprivate static boolean shift = false;\n\tprivate static boolean ctrl = false;\n\n\tprivate static boolean securityProblem = false;\n\tstatic {\n\t\ttry {\n\t\t\tToolkit.getDefaultToolkit().addAWTEventListener(\n\t\t\t\t\tnew AWTEventListener() {\n\t\t\t\t\t\tpublic void eventDispatched(AWTEvent e) {\n\t\t\t\t\t\t\tif (e instanceof KeyEvent) {\n\t\t\t\t\t\t\t\tKeyEvent k = (KeyEvent) e;\n\t\t\t\t\t\t\t\tboolean pressed = k.getID() == KeyEvent.KEY_PRESSED;\n\t\t\t\t\t\t\t\tint code = k.getKeyCode();\n\t\t\t\t\t\t\t\tswitch (code) {\n\t\t\t\t\t\t\t\tcase KeyEvent.VK_ALT:\n\t\t\t\t\t\t\t\t\tif (alt != pressed) {\n\t\t\t\t\t\t\t\t\t\talt = pressed;\n\t\t\t\t\t\t\t\t\t\tfireAltChangeListeners();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase KeyEvent.VK_ALT_GRAPH:\n\t\t\t\t\t\t\t\t\tif (altGraph != pressed) {\n\t\t\t\t\t\t\t\t\t\taltGraph = pressed;\n\t\t\t\t\t\t\t\t\t\tfireAltGraphChangeListeners();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase KeyEvent.VK_META:\n\t\t\t\t\t\t\t\t\tif (meta != pressed) {\n\t\t\t\t\t\t\t\t\t\tmeta = pressed;\n\t\t\t\t\t\t\t\t\t\tfireMetaChangeListeners();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase KeyEvent.VK_SHIFT:\n\t\t\t\t\t\t\t\t\tif (shift != pressed) {\n\t\t\t\t\t\t\t\t\t\tshift = pressed;\n\t\t\t\t\t\t\t\t\t\tfireShiftChangeListeners();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase KeyEvent.VK_CONTROL:\n\t\t\t\t\t\t\t\t\tif (ctrl != pressed) {\n\t\t\t\t\t\t\t\t\t\tctrl = pressed;\n\t\t\t\t\t\t\t\t\t\tfireControlChangeListeners();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, AWTEvent.KEY_EVENT_MASK);\n\t\t} catch (SecurityException e) {\n\t\t\tSystem.err\n\t\t\t\t\t.println(\"the following exception means the ModifierTracker cannot globally listen to modifiers.\");\n\t\t\te.printStackTrace();\n\t\t\tsecurityProblem = true;\n\t\t}\n\t}\n\n\tpublic static boolean isActive() {\n\t\treturn !securityProblem;\n\t}\n\n\tprivate static List<ChangeListener> altListeners;\n\tprivate static List<ChangeListener> altGraphListeners;\n\tprivate static List<ChangeListener> metaListeners;\n\tprivate static List<ChangeListener> shiftListeners;\n\tprivate static List<ChangeListener> ctrlListeners;\n\n\tpublic static int getModifiers() {\n\t\treturn (alt ? InputEvent.ALT_MASK : 0)\n\t\t\t\t+ (altGraph ? InputEvent.ALT_GRAPH_MASK : 0)\n\t\t\t\t+ (shift ? InputEvent.SHIFT_MASK : 0)\n\t\t\t\t+ (ctrl ? InputEvent.CTRL_MASK : 0)\n\t\t\t\t+ (meta ? InputEvent.META_MASK : 0);\n\n\t}\n\n\tpublic static void addAltChangeListener(ChangeListener l) {\n\t\tif (altListeners == null)\n\t\t\taltListeners = new ArrayList<>();\n\t\tif (altListeners.contains(l))\n\t\t\treturn;\n\t\taltListeners.add(l);\n\t}\n\n\tpublic static void addAltGraphChangeListener(ChangeListener l) {\n\t\tif (altGraphListeners == null)\n\t\t\taltGraphListeners = new ArrayList<>();\n\t\tif (altGraphListeners.contains(l))\n\t\t\treturn;\n\t\taltGraphListeners.add(l);\n\t}\n\n\tpublic static void addMetaChangeListener(ChangeListener l) {\n\t\tif (metaListeners == null)\n\t\t\tmetaListeners = new ArrayList<>();\n\t\tif (metaListeners.contains(l))\n\t\t\treturn;\n\t\tmetaListeners.add(l);\n\t}\n\n\tpublic static void addShiftChangeListener(ChangeListener l) {\n\t\tif (shiftListeners == null)\n\t\t\tshiftListeners = new ArrayList<>();\n\t\tif (shiftListeners.contains(l))\n\t\t\treturn;\n\t\tshiftListeners.add(l);\n\t}\n\n\tpublic static void addControlChangeListener(ChangeListener l) {\n\t\tif (ctrlListeners == null)\n\t\t\tctrlListeners = new ArrayList<>();\n\t\tif (ctrlListeners.contains(l))\n\t\t\treturn;\n\t\tctrlListeners.add(l);\n\t}\n\n\tpublic static boolean isAltDown() {\n\t\treturn alt;\n\t}\n\n\tpublic static boolean isAltGraphyDown() {\n\t\treturn altGraph;\n\t}\n\n\tpublic static boolean isShiftDown() {\n\t\treturn shift;\n\t}\n\n\tpublic static boolean isMetaDown() {\n\t\treturn meta;\n\t}\n\n\tpublic static boolean isControlDown() {\n\t\treturn ctrl;\n\t}\n\n\tpublic static void removeAltChangeListener(ChangeListener l) {\n\t\tif (altListeners == null)\n\t\t\treturn;\n\t\taltListeners.remove(l);\n\t}\n\n\tpublic static void removeAltGraphChangeListener(ChangeListener l) {\n\t\tif (altGraphListeners == null)\n\t\t\treturn;\n\t\taltGraphListeners.remove(l);\n\t}\n\n\tpublic static void removeMetaChangeListener(ChangeListener l) {\n\t\tif (metaListeners == null)\n\t\t\treturn;\n\t\tmetaListeners.remove(l);\n\t}\n\n\tpublic static void removeShiftChangeListener(ChangeListener l) {\n\t\tif (shiftListeners == null)\n\t\t\treturn;\n\t\tshiftListeners.remove(l);\n\t}\n\n\tpublic static void removeControlChangeListener(ChangeListener l) {\n\t\tif (ctrlListeners == null)\n\t\t\treturn;\n\t\tctrlListeners.remove(l);\n\t}\n\n\tprivate static void fireAltGraphChangeListeners() {\n\t\tif (altGraphListeners == null)\n\t\t\treturn;\n\t\tfor (int a = 0; a < altGraphListeners.size(); a++) {\n\t\t\tChangeListener l = altGraphListeners.get(a);\n\t\t\ttry {\n\t\t\t\tl.stateChanged(new ChangeEvent(ModifierTracker.class));\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void fireAltChangeListeners() {\n\t\tif (altListeners == null)\n\t\t\treturn;\n\t\tfor (int a = 0; a < altListeners.size(); a++) {\n\t\t\tChangeListener l = altListeners.get(a);\n\t\t\ttry {\n\t\t\t\tl.stateChanged(new ChangeEvent(ModifierTracker.class));\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void fireControlChangeListeners() {\n\t\tif (ctrlListeners == null)\n\t\t\treturn;\n\t\tfor (int a = 0; a < ctrlListeners.size(); a++) {\n\t\t\tChangeListener l = ctrlListeners.get(a);\n\t\t\ttry {\n\t\t\t\tl.stateChanged(new ChangeEvent(ModifierTracker.class));\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void fireMetaChangeListeners() {\n\t\tif (metaListeners == null)\n\t\t\treturn;\n\t\tfor (int a = 0; a < metaListeners.size(); a++) {\n\t\t\tChangeListener l = metaListeners.get(a);\n\t\t\ttry {\n\t\t\t\tl.stateChanged(new ChangeEvent(ModifierTracker.class));\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void fireShiftChangeListeners() {\n\t\tif (shiftListeners == null)\n\t\t\treturn;\n\t\tfor (int a = 0; a < shiftListeners.size(); a++) {\n\t\t\tChangeListener l = shiftListeners.get(a);\n\t\t\ttry {\n\t\t\t\tl.stateChanged(new ChangeEvent(ModifierTracker.class));\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}", "item_id": 0, "repo": "timboudreau/pumpernickel", "file": "src/main/java/com/pump/awt/ModifierTracker.java", "last_update_at": "2022-03-30T07:17:58+00:00", "question_id": "4b2f466a2efbfb403ac3a41f85d58dc900a7f8d6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ModifierTracker {\n\t/**\n\t * Add KeyListeners to everything in an applet.\n\t * <P>\n\t * Unsigned applets can't simply add an event listener to the toolkit for\n\t * security reasons, so this method provides an alternative approach.\n\t * <P>\n\t * This alternative should work in controlled environments where components\n\t * are not added to an applet after this method is called, but in other\n\t * cases it might fail.\n\t * \n\t * @param applet\n\t *            the applet to track\n\t */\n\tpublic static void track(JApplet applet) {\n\t\tif (isActive() == false) {\n\t\t\ttrack(applet.getContentPane());\n\t\t}\n\t}\n\tprivate static KeyListener keyListener = new KeyListener() {\n\t\tpublic void keyTyped(KeyEvent e) {\n\t\t}\n\t\tpublic void keyPressed(KeyEvent e) {\n\t\t\tkey(e.getKeyCode(), true);\n\t\t}\n\t\tpublic void keyReleased(KeyEvent e) {\n\t\t\tkey(e.getKeyCode(), false);\n\t\t}\n\t\tprivate void key(int code, boolean pressed) {\n\t\t\tif (code == KeyEvent.VK_ALT) {\n\t\t\t\tif (alt != pressed) {\n\t\t\t\t\talt = pressed;\n\t\t\t\t\tfireAltChangeListeners();\n\t\t\t\t}\n\t\t\t} else if (code == KeyEvent.VK_ALT_GRAPH) {\n\t\t\t\tif (altGraph != pressed) {\n\t\t\t\t\taltGraph = pressed;\n\t\t\t\t\tfireAltGraphChangeListeners();\n\t\t\t\t}\n\t\t\t} else if (code == KeyEvent.VK_CONTROL) {\n\t\t\t\tif (ctrl != pressed) {\n\t\t\t\t\tctrl = pressed;\n\t\t\t\t\tfireControlChangeListeners();\n\t\t\t\t}\n\t\t\t} else if (code == KeyEvent.VK_META) {\n\t\t\t\tif (meta != pressed) {\n\t\t\t\t\tmeta = pressed;\n\t\t\t\t\tfireMetaChangeListeners();\n\t\t\t\t}\n\t\t\t} else if (code == KeyEvent.VK_SHIFT) {\n\t\t\t\tif (shift != pressed) {\n\t\t\t\t\tshift = pressed;\n\t\t\t\t\tfireShiftChangeListeners();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tprivate static void track(Component c) {\n\t\tc.addKeyListener(keyListener);\n\t\tif (c instanceof Container) {\n\t\t\tContainer container = (Container) c;\n\t\t\tfor (int a = 0; a < container.getComponentCount(); a++) {\n\t\t\t\ttrack(container.getComponent(a));\n\t\t\t}\n\t\t}\n\t}\n\tprivate static boolean alt = false;\n\tprivate static boolean altGraph = false;\n\tprivate static boolean meta = false;\n\tprivate static boolean shift = false;\n\tprivate static boolean ctrl = false;\n\tprivate static boolean securityProblem = false;\n\tstatic {\n\t\ttry {\n\t\t\tToolkit.getDefaultToolkit().addAWTEventListener(\n\t\t\t\t\tnew AWTEventListener() {\n\t\t\t\t\t\tpublic void eventDispatched(AWTEvent e) {\n\t\t\t\t\t\t\tif (e instanceof KeyEvent) {\n\t\t\t\t\t\t\t\tKeyEvent k = (KeyEvent) e;\n\t\t\t\t\t\t\t\tboolean pressed = k.getID() == KeyEvent.KEY_PRESSED;\n\t\t\t\t\t\t\t\tint code = k.getKeyCode();\n\t\t\t\t\t\t\t\tswitch (code) {\n\t\t\t\t\t\t\t\tcase KeyEvent.VK_ALT:\n\t\t\t\t\t\t\t\t\tif (alt != pressed) {\n\t\t\t\t\t\t\t\t\t\talt = pressed;\n\t\t\t\t\t\t\t\t\t\tfireAltChangeListeners();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase KeyEvent.VK_ALT_GRAPH:\n\t\t\t\t\t\t\t\t\tif (altGraph != pressed) {\n\t\t\t\t\t\t\t\t\t\taltGraph = pressed;\n\t\t\t\t\t\t\t\t\t\tfireAltGraphChangeListeners();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase KeyEvent.VK_META:\n\t\t\t\t\t\t\t\t\tif (meta != pressed) {\n\t\t\t\t\t\t\t\t\t\tmeta = pressed;\n\t\t\t\t\t\t\t\t\t\tfireMetaChangeListeners();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase KeyEvent.VK_SHIFT:\n\t\t\t\t\t\t\t\t\tif (shift != pressed) {\n\t\t\t\t\t\t\t\t\t\tshift = pressed;\n\t\t\t\t\t\t\t\t\t\tfireShiftChangeListeners();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase KeyEvent.VK_CONTROL:\n\t\t\t\t\t\t\t\t\tif (ctrl != pressed) {\n\t\t\t\t\t\t\t\t\t\tctrl = pressed;\n\t\t\t\t\t\t\t\t\t\tfireControlChangeListeners();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, AWTEvent.KEY_EVENT_MASK);\n\t\t} catch (SecurityException e) {\n\t\t\tSystem.err\n\t\t\t\t\t.println(\"the following exception means the ModifierTracker cannot globally listen to modifiers.\");\n\t\t\te.printStackTrace();\n\t\t\tsecurityProblem = true;\n\t\t}\n\t}\n\tpublic static boolean isActive() {\n\t\treturn !securityProblem;\n\t}\n\tprivate static List<ChangeListener> altListeners;\n\tprivate static List<ChangeListener> altGraphListeners;\n\tprivate static List<ChangeListener> metaListeners;\n\tprivate static List<ChangeListener> shiftListeners;\n\tprivate static List<ChangeListener> ctrlListeners;\n\tpublic static int getModifiers() {\n\t\treturn (alt ? InputEvent.ALT_MASK : 0)\n\t\t\t\t+ (altGraph ? InputEvent.ALT_GRAPH_MASK : 0)\n\t\t\t\t+ (shift ? InputEvent.SHIFT_MASK : 0)\n\t\t\t\t+ (ctrl ? InputEvent.CTRL_MASK : 0)\n\t\t\t\t+ (meta ? InputEvent.META_MASK : 0);\n\t}\n\tpublic static void addAltChangeListener(ChangeListener l) {\n\t\tif (altListeners == null)\n\t\t\taltListeners = new ArrayList<>();\n\t\tif (altListeners.contains(l))\n\t\t\treturn;\n\t\taltListeners.add(l);\n\t}\n\tpublic static void addAltGraphChangeListener(ChangeListener l) {\n\t\tif (altGraphListeners == null)\n\t\t\taltGraphListeners = new ArrayList<>();\n\t\tif (altGraphListeners.contains(l))\n\t\t\treturn;\n\t\taltGraphListeners.add(l);\n\t}\n\tpublic static void addMetaChangeListener(ChangeListener l) {\n\t\tif (metaListeners == null)\n\t\t\tmetaListeners = new ArrayList<>();\n\t\tif (metaListeners.contains(l))\n\t\t\treturn;\n\t\tmetaListeners.add(l);\n\t}\n\tpublic static void addShiftChangeListener(ChangeListener l) {\n\t\tif (shiftListeners == null)\n\t\t\tshiftListeners = new ArrayList<>();\n\t\tif (shiftListeners.contains(l))\n\t\t\treturn;\n\t\tshiftListeners.add(l);\n\t}\n\tpublic static void addControlChangeListener(ChangeListener l) {\n\t\tif (ctrlListeners == null)\n\t\t\tctrlListeners = new ArrayList<>();\n\t\tif (ctrlListeners.contains(l))\n\t\t\treturn;\n\t\tctrlListeners.add(l);\n\t}\n\tpublic static boolean isAltDown() {\n\t\treturn alt;\n\t}\n\tpublic static boolean isAltGraphyDown() {\n\t\treturn altGraph;\n\t}\n\tpublic static boolean isShiftDown() {\n\t\treturn shift;\n\t}\n\tpublic static boolean isMetaDown() {\n\t\treturn meta;\n\t}\n\tpublic static boolean isControlDown() {\n\t\treturn ctrl;\n\t}\n\tpublic static void removeAltChangeListener(ChangeListener l) {\n\t\tif (altListeners == null)\n\t\t\treturn;\n\t\taltListeners.remove(l);\n\t}\n\tpublic static void removeAltGraphChangeListener(ChangeListener l) {\n\t\tif (altGraphListeners == null)\n\t\t\treturn;\n\t\taltGraphListeners.remove(l);\n\t}\n\tpublic static void removeMetaChangeListener(ChangeListener l) {\n\t\tif (metaListeners == null)\n\t\t\treturn;\n\t\tmetaListeners.remove(l);\n\t}\n\tpublic static void removeShiftChangeListener(ChangeListener l) {\n\t\tif (shiftListeners == null)\n\t\t\treturn;\n\t\tshiftListeners.remove(l);\n\t}\n\tpublic static void removeControlChangeListener(ChangeListener l) {\n\t\tif (ctrlListeners == null)\n\t\t\treturn;\n\t\tctrlListeners.remove(l);\n\t}\n\tprivate static void fireAltGraphChangeListeners() {\n\t\tif (altGraphListeners == null)\n\t\t\treturn;\n\t\tfor (int a = 0; a < altGraphListeners.size(); a++) {\n\t\t\tChangeListener l = altGraphListeners.get(a);\n\t\t\ttry {\n\t\t\t\tl.stateChanged(new ChangeEvent(ModifierTracker.class));\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\tprivate static void fireAltChangeListeners() {\n\t\tif (altListeners == null)\n\t\t\treturn;\n\t\tfor (int a = 0; a < altListeners.size(); a++) {\n\t\t\tChangeListener l = altListeners.get(a);\n\t\t\ttry {\n\t\t\t\tl.stateChanged(new ChangeEvent(ModifierTracker.class));\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\tprivate static void fireControlChangeListeners() {\n\t\tif (ctrlListeners == null)\n\t\t\treturn;\n\t\tfor (int a = 0; a < ctrlListeners.size(); a++) {\n\t\t\tChangeListener l = ctrlListeners.get(a);\n\t\t\ttry {\n\t\t\t\tl.stateChanged(new ChangeEvent(ModifierTracker.class));\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\tprivate static void fireMetaChangeListeners() {\n\t\tif (metaListeners == null)\n\t\t\treturn;\n\t\tfor (int a = 0; a < metaListeners.size(); a++) {\n\t\t\tChangeListener l = metaListeners.get(a);\n\t\t\ttry {\n\t\t\t\tl.stateChanged(new ChangeEvent(ModifierTracker.class));\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\tprivate static void fireShiftChangeListeners() {\n\t\tif (shiftListeners == null)\n\t\t\treturn;\n\t\tfor (int a = 0; a < shiftListeners.size(); a++) {\n\t\t\tChangeListener l = shiftListeners.get(a);\n\t\t\ttry {\n\t\t\t\tl.stateChanged(new ChangeEvent(ModifierTracker.class));\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.485823392868042, "ppl_lower": 1.5924025774002075, "ppl/lowercase_ppl": -1.1749501166117582, "ppl/zlib": 0.00024732610362457704, "Min_5.0% Prob": 5.149702642478195, "Min_10.0% Prob": 3.4290159216114118, "Min_20.0% Prob": 1.9483185938614256, "Min_30.0% Prob": 1.320057728333898, "Min_40.0% Prob": 0.9896832951242082, "Min_50.0% Prob": 0.7925256884610371, "Min_60.0% Prob": 0.6607616784647001}}
{"hexsha": "dfb32e9c49a19af0e3aea7c6d0ab514b6801562c", "ext": "java", "lang": "Java", "content": "public class PropertiesUtil {\n    \n    /**\n     * \n     * @param file\n     * @return the properties if the file exists, or null if the file does not exist\n     * @throws IOException if there is an error reading the file\n     */\n    public static Properties load(File file) throws IOException {\n        if( !file.exists() ) { return null; }\n        try(FileInputStream in = new FileInputStream(file)) {\n            Properties properties = new Properties();\n            properties.load(in);\n            return properties;\n        }\n    }\n    \n    /**\n     * \n     * @param file\n     * @return the properties loaded from file; never null\n     * @throws FileNotFoundException if the file is not found\n     * @throws IOException if there is an error reading the file\n     */\n    public static Properties loadExisting(File file) throws FileNotFoundException, IOException {\n        try(FileInputStream in = new FileInputStream(file)) {\n            Properties properties = new Properties();\n            properties.load(in);\n            return properties;\n        }\n    }\n    \n    public static Properties replacePrefix(Properties properties, String prefix, String replace) {\n        Properties copy = new Properties();\n        Enumeration names = properties.propertyNames();\n        while(names.hasMoreElements()) {\n            String key = (String)names.nextElement();\n            copy.setProperty(key.replace(prefix, replace), properties.getProperty(key));\n        }\n        return copy;\n    }\n\n    public static Properties removePrefix(Properties properties, String prefix) {\n        return replacePrefix(properties, prefix, \"\");\n    }\n\n    public static Properties addPrefix(Properties properties, String prefix) {\n        Properties copy = new Properties();\n        Enumeration names = properties.propertyNames();\n        while(names.hasMoreElements()) {\n            String key = (String)names.nextElement();\n            copy.setProperty(prefix+key, properties.getProperty(key));\n        }\n        return copy;\n    }    \n    \n}", "item_id": 0, "repo": "intel-secl/common_java", "file": "util/mtwilson-util-io/src/main/java/com/intel/dcsg/cpg/io/PropertiesUtil.java", "last_update_at": "2022-03-05T03:31:34+00:00", "question_id": "dfb32e9c49a19af0e3aea7c6d0ab514b6801562c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PropertiesUtil {\n    /**\n     * \n     * @param file\n     * @return the properties if the file exists, or null if the file does not exist\n     * @throws IOException if there is an error reading the file\n     */\n    public static Properties load(File file) throws IOException {\n        if( !file.exists() ) { return null; }\n        try(FileInputStream in = new FileInputStream(file)) {\n            Properties properties = new Properties();\n            properties.load(in);\n            return properties;\n        }\n    }\n    /**\n     * \n     * @param file\n     * @return the properties loaded from file; never null\n     * @throws FileNotFoundException if the file is not found\n     * @throws IOException if there is an error reading the file\n     */\n    public static Properties loadExisting(File file) throws FileNotFoundException, IOException {\n        try(FileInputStream in = new FileInputStream(file)) {\n            Properties properties = new Properties();\n            properties.load(in);\n            return properties;\n        }\n    }\n    public static Properties replacePrefix(Properties properties, String prefix, String replace) {\n        Properties copy = new Properties();\n        Enumeration names = properties.propertyNames();\n        while(names.hasMoreElements()) {\n            String key = (String)names.nextElement();\n            copy.setProperty(key.replace(prefix, replace), properties.getProperty(key));\n        }\n        return copy;\n    }\n    public static Properties removePrefix(Properties properties, String prefix) {\n        return replacePrefix(properties, prefix, \"\");\n    }\n    public static Properties addPrefix(Properties properties, String prefix) {\n        Properties copy = new Properties();\n        Enumeration names = properties.propertyNames();\n        while(names.hasMoreElements()) {\n            String key = (String)names.nextElement();\n            copy.setProperty(prefix+key, properties.getProperty(key));\n        }\n        return copy;\n    }    \n"]], "pred": {"ppl": 1.5068070888519287, "ppl_lower": 1.6595039367675781, "ppl/lowercase_ppl": -1.2354329128834023, "ppl/zlib": 0.000843606793001166, "Min_5.0% Prob": 4.677711704502935, "Min_10.0% Prob": 3.277912309829225, "Min_20.0% Prob": 1.9531193813110919, "Min_30.0% Prob": 1.352063019964712, "Min_40.0% Prob": 1.0245204210439895, "Min_50.0% Prob": 0.8184726273944855, "Min_60.0% Prob": 0.6832823402481977}}
{"hexsha": "6eb84c666362d423699cccf93c2cf2217f39e5a7", "ext": "java", "lang": "Java", "content": "public class ComputeGrayCodeTest {\n\n  private List<Integer> expected;\n  private int numBits;\n\n  @Test\n  public void grayCode1() throws Exception {\n    expected = Arrays.asList(0, 1, 2, 3);\n    numBits = 2;\n\n    test(expected, numBits);\n  }\n\n  @Test\n  public void grayCode2() throws Exception {\n    expected = Arrays.asList(0, 1, 3, 2, 6, 7, 5, 4);\n    numBits = 3;\n\n    test(expected, numBits);\n  }\n\n  private void test(List<Integer> expected, int numBits) {\n    AssertUtils.assertSameContentsInt(expected, ComputeGrayCode.grayCode(numBits));\n  }\n\n}", "item_id": 0, "repo": "varunu28/elements-of-programming-interviews", "file": "recursion/src/test/java/ComputeGrayCodeTest.java", "last_update_at": "2022-03-12T02:39:57+00:00", "question_id": "6eb84c666362d423699cccf93c2cf2217f39e5a7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ComputeGrayCodeTest {\n  private List<Integer> expected;\n  private int numBits;\n  @Test\n  public void grayCode1() throws Exception {\n    expected = Arrays.asList(0, 1, 2, 3);\n    numBits = 2;\n    test(expected, numBits);\n  }\n  @Test\n  public void grayCode2() throws Exception {\n    expected = Arrays.asList(0, 1, 3, 2, 6, 7, 5, 4);\n    numBits = 3;\n    test(expected, numBits);\n  }\n  private void test(List<Integer> expected, int numBits) {\n    AssertUtils.assertSameContentsInt(expected, ComputeGrayCode.grayCode(numBits));\n  }\n"]], "pred": {"ppl": 1.635733723640442, "ppl_lower": 2.3117098808288574, "ppl/lowercase_ppl": -1.7029099661772802, "ppl/zlib": 0.0020003718061895642, "Min_5.0% Prob": 5.677301120758057, "Min_10.0% Prob": 4.020055555161976, "Min_20.0% Prob": 2.3815158229498636, "Min_30.0% Prob": 1.6264546352128189, "Min_40.0% Prob": 1.2259790987729848, "Min_50.0% Prob": 0.9828742538401414, "Min_60.0% Prob": 0.8198197153803434}}
{"hexsha": "8bea51c7a9477acd7f8c3cb187c06671128097f1", "ext": "java", "lang": "Java", "content": "public class NormGrammar implements INormGrammar, Serializable {\n\n    private static final long serialVersionUID = -13739894962185282L;\n\n    // all files used in this grammar\n    private final Set<File> filesRead;\n\n    // factory to create all symbols in the grammar\n    private final GrammarFactory gf;\n\n    private IProduction initialProduction;\n\n    // all symbols in this grammar\n    private final Set<ISymbol> symbols;\n\n    // to handle Sort.Cons in priorities\n    private final Map<ProductionReference, Production> sortConsProductionMapping;\n\n    // merging same productions with different attributes\n    private final SetMultimap<IProduction, IAttribute> productionAttributesMapping;\n\n    // constructor attributes\n    private final Map<IProduction, ConstructorAttribute> constructors;\n\n    // necessary for calculating deep priority conflicts\n    private final Map<UniqueProduction, Production> uniqueProductionMapping;\n    private final BiMap<Production, ContextualProduction> prodContextualProdMapping;\n    private final Set<ContextualProduction> derivedContextualProds;\n    private final Set<ContextualSymbol> contextualSymbols;\n    private final SetMultimap<ISymbol, ISymbol> leftRecursiveSymbolsMapping;\n    private final SetMultimap<ISymbol, ISymbol> rightRecursiveSymbolsMapping;\n    private final SetMultimap<Symbol, Production> longestMatchProdsFront;\n    private final SetMultimap<Symbol, Production> shortestMatchProdsFront;\n    private final SetMultimap<Symbol, Production> longestMatchProdsBack;\n    private final SetMultimap<Symbol, Production> shortestMatchProdsBack;\n\n    // priorities\n    private final Set<Priority> transitivePriorities;\n    private final Set<Priority> nonTransitivePriorities;\n    private final SetMultimap<Priority, Integer> priorities;\n    private final SetMultimap<Priority, Integer> indexedPriorities;\n\n    // extra collections to calculate the transitive closure\n    private final Set<Production> productionsOnPriorities;\n    private final SetMultimap<Priority, Integer> transitivePriorityArgs;\n    private final SetMultimap<Priority, Integer> nonTransitivePriorityArgs;\n    private final SetMultimap<Production, Priority> higherPriorityProductions;\n\n    private final HashMap<String, Symbol> cacheSymbolsRead; // caching symbols read\n    private final HashMap<String, Production> cacheProductionsRead; // caching productions read\n\n    // get all productions for a certain symbol\n    private final SetMultimap<ISymbol, IProduction> symbolProductionsMapping;\n\n    // get all productions that contain a particular literal\n    private final SetMultimap<ISymbol, IProduction> literalProductionsMapping;\n\n    // expression grammars per non-terminal\n    private final SetMultimap<ISymbol, IProduction> expressionGrammars;\n\n    // expression grammars collapsed\n    private final Set<Set<IProduction>> combinedExpressionGrammars;\n\n    // left and right derivable symbols from a symbol\n    private final SetMultimap<ISymbol, ISymbol> leftDerivable;\n    private final SetMultimap<ISymbol, ISymbol> rightDerivable;\n\n    public NormGrammar() {\n        this.filesRead = Sets.newHashSet();\n        this.gf = new GrammarFactory();\n        this.uniqueProductionMapping = Maps.newLinkedHashMap();\n        this.sortConsProductionMapping = Maps.newHashMap();\n        this.prodContextualProdMapping = HashBiMap.create();\n        this.leftRecursiveSymbolsMapping = HashMultimap.create();\n        this.rightRecursiveSymbolsMapping = HashMultimap.create();\n        this.derivedContextualProds = Sets.newHashSet();\n        this.contextualSymbols = Sets.newHashSet();\n        this.longestMatchProdsFront = LinkedHashMultimap.create();\n        this.longestMatchProdsBack = LinkedHashMultimap.create();\n        this.shortestMatchProdsFront = LinkedHashMultimap.create();\n        this.shortestMatchProdsBack = LinkedHashMultimap.create();\n        this.productionAttributesMapping = HashMultimap.create();\n        this.priorities = HashMultimap.create();\n        this.indexedPriorities = HashMultimap.create();\n        this.constructors = Maps.newHashMap();\n        this.transitivePriorities = Sets.newHashSet();\n        this.nonTransitivePriorities = Sets.newHashSet();\n        this.productionsOnPriorities = Sets.newHashSet();\n        this.transitivePriorityArgs = HashMultimap.create();\n        this.nonTransitivePriorityArgs = HashMultimap.create();\n        this.higherPriorityProductions = HashMultimap.create();\n        this.symbolProductionsMapping = HashMultimap.create();\n        this.cacheSymbolsRead = Maps.newHashMap();\n        this.cacheProductionsRead = Maps.newHashMap();\n        this.symbols = Sets.newHashSet();\n        this.literalProductionsMapping = HashMultimap.create();\n        this.expressionGrammars = HashMultimap.create();\n        this.combinedExpressionGrammars = Sets.newHashSet();\n        this.leftDerivable = HashMultimap.create();\n        this.rightDerivable = HashMultimap.create();\n    }\n\n    public Map<UniqueProduction, Production> syntax() {\n        return getUniqueProductionMapping();\n    }\n\n    public void priorityTransitiveClosure() {\n\n        // Floyd Warshall Algorithm to calculate the transitive closure\n        for(Production intermediate_prod : getProductionsOnPriorities()) {\n            for(Production first_prod : getProductionsOnPriorities()) {\n                for(Production second_prod : getProductionsOnPriorities()) {\n                    Priority first_sec = gf.createPriority(first_prod, second_prod, true);\n                    Priority first_k = gf.createPriority(first_prod, intermediate_prod, true);\n                    Priority k_second = gf.createPriority(intermediate_prod, second_prod, true);\n                    // if there is no priority first_prod > second_prod\n                    if(!getTransitivePriorities().contains(first_sec)) {\n                        // if there are priorities first_prod > intermediate_prod and\n                        // intermediate_prod > second_prod\n                        // add priority first_prod > second_prod\n                        if(getTransitivePriorities().contains(first_k)\n                            && getTransitivePriorities().contains(k_second)) {\n                            getTransitivePriorities().add(first_sec);\n                            getTransitivePriorityArgs().putAll(first_sec, getTransitivePriorityArgs().get(first_k));\n                        }\n                    } else {\n                        if(getTransitivePriorities().contains(first_k)\n                            && getTransitivePriorities().contains(k_second)) {\n                            getTransitivePriorityArgs().putAll(first_sec, getTransitivePriorityArgs().get(first_k));\n                        }\n                    }\n                }\n            }\n        }\n\n        priorities.putAll(getNonTransitivePriorityArgs());\n        priorities.putAll(getTransitivePriorityArgs());\n    }\n\n\n    public IProduction getInitialProduction() {\n        return initialProduction;\n    }\n\n    public SetMultimap<Priority, Integer> priorities() {\n        return priorities;\n    }\n\n    public Set<File> getFilesRead() {\n        return filesRead;\n    }\n\n    public Set<ISymbol> getSymbols() {\n        return symbols;\n    }\n\n    public Map<ProductionReference, Production> getSortConsProductionMapping() {\n        return sortConsProductionMapping;\n    }\n\n    public SetMultimap<IProduction, IAttribute> getProductionAttributesMapping() {\n        return productionAttributesMapping;\n    }\n\n    public Map<UniqueProduction, Production> getUniqueProductionMapping() {\n        return uniqueProductionMapping;\n    }\n\n    public BiMap<Production, ContextualProduction> getProdContextualProdMapping() {\n        return prodContextualProdMapping;\n    }\n\n    public Set<ContextualProduction> getDerivedContextualProds() {\n        return derivedContextualProds;\n    }\n\n    public Set<ContextualSymbol> getContextualSymbols() {\n        return contextualSymbols;\n    }\n\n    public SetMultimap<ISymbol, ISymbol> getLeftRecursiveSymbolsMapping() {\n        return leftRecursiveSymbolsMapping;\n    }\n\n    public SetMultimap<ISymbol, ISymbol> getRightRecursiveSymbolsMapping() {\n        return rightRecursiveSymbolsMapping;\n    }\n\n    public SetMultimap<Symbol, Production> getLongestMatchProdsFront() {\n        return longestMatchProdsFront;\n    }\n\n    public SetMultimap<Symbol, Production> getLongestMatchProdsBack() {\n        return longestMatchProdsBack;\n    }\n\n    public SetMultimap<Symbol, Production> getShortestMatchProdsFront() {\n        return shortestMatchProdsFront;\n    }\n\n    public SetMultimap<Symbol, Production> getShortestMatchProdsBack() {\n        return shortestMatchProdsBack;\n    }\n\n    public Set<Priority> getTransitivePriorities() {\n        return transitivePriorities;\n    }\n\n    public Set<Priority> getNonTransitivePriorities() {\n        return nonTransitivePriorities;\n    }\n\n    public Set<Production> getProductionsOnPriorities() {\n        return productionsOnPriorities;\n    }\n\n    public SetMultimap<Priority, Integer> getTransitivePriorityArgs() {\n        return transitivePriorityArgs;\n    }\n\n    public SetMultimap<Priority, Integer> getNonTransitivePriorityArgs() {\n        return nonTransitivePriorityArgs;\n    }\n\n    public HashMap<String, Symbol> getCacheSymbolsRead() {\n        return cacheSymbolsRead;\n    }\n\n    public HashMap<String, Production> getCacheProductionsRead() {\n        return cacheProductionsRead;\n    }\n\n    public SetMultimap<ISymbol, IProduction> getSymbolProductionsMapping() {\n        return symbolProductionsMapping;\n    }\n\n    public SetMultimap<Production, Priority> getHigherPriorityProductions() {\n        return higherPriorityProductions;\n    }\n\n    public void normalizeFollowRestrictionLookahead() {\n        for(ISymbol s : symbols) {\n            s.normalizeFollowRestrictionLookahead();\n        }\n    }\n\n    public Map<IProduction, ConstructorAttribute> getConstructors() {\n        return constructors;\n    }\n\n    public SetMultimap<ISymbol, IProduction> getLiteralProductionsMapping() {\n        return literalProductionsMapping;\n    }\n\n    public SetMultimap<ISymbol, IProduction> getExpressionGrammars() {\n        return expressionGrammars;\n    }\n\n    public Set<Set<IProduction>> getCombinedExpressionGrammars() {\n        return combinedExpressionGrammars;\n    }\n\n    public void setInitialProduction(Production prod) {\n        this.initialProduction = prod;\n    }\n\n    public SetMultimap<Priority, Integer> getIndexedPriorities() {\n        return indexedPriorities;\n    }\n\n    public GrammarFactory getGrammarFactory() {\n        return gf;\n    }\n\n    public void cleanupGrammar() {\n        this.cacheProductionsRead.clear();\n        this.cacheSymbolsRead.clear();\n        this.combinedExpressionGrammars.clear();\n        this.contextualSymbols.clear();\n        this.derivedContextualProds.clear();\n        this.expressionGrammars.clear();\n        this.leftRecursiveSymbolsMapping.clear();\n        this.rightRecursiveSymbolsMapping.clear();\n        this.literalProductionsMapping.clear();\n        this.longestMatchProdsBack.clear();\n        this.longestMatchProdsFront.clear();\n        this.nonTransitivePriorities.clear();\n        this.nonTransitivePriorityArgs.clear();\n        this.productionsOnPriorities.clear();\n        this.symbolProductionsMapping.clear();\n        this.transitivePriorities.clear();\n        this.transitivePriorityArgs.clear();\n        this.filesRead.clear();\n    }\n\n    public SetMultimap<ISymbol, ISymbol> getLeftDerivable() {\n        return leftDerivable;\n    }\n\n    public SetMultimap<ISymbol, ISymbol> getRightDerivable() {\n        return rightDerivable;\n    }\n\n}", "item_id": 0, "repo": "mpsijm/sdf", "file": "org.metaborg.sdf2table/src/main/java/org/metaborg/sdf2table/grammar/NormGrammar.java", "last_update_at": "2022-03-09T19:08:32+00:00", "question_id": "8bea51c7a9477acd7f8c3cb187c06671128097f1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NormGrammar implements INormGrammar, Serializable {\n    private static final long serialVersionUID = -13739894962185282L;\n    // all files used in this grammar\n    private final Set<File> filesRead;\n    // factory to create all symbols in the grammar\n    private final GrammarFactory gf;\n    private IProduction initialProduction;\n    // all symbols in this grammar\n    private final Set<ISymbol> symbols;\n    // to handle Sort.Cons in priorities\n    private final Map<ProductionReference, Production> sortConsProductionMapping;\n    // merging same productions with different attributes\n    private final SetMultimap<IProduction, IAttribute> productionAttributesMapping;\n    // constructor attributes\n    private final Map<IProduction, ConstructorAttribute> constructors;\n    // necessary for calculating deep priority conflicts\n    private final Map<UniqueProduction, Production> uniqueProductionMapping;\n    private final BiMap<Production, ContextualProduction> prodContextualProdMapping;\n    private final Set<ContextualProduction> derivedContextualProds;\n    private final Set<ContextualSymbol> contextualSymbols;\n    private final SetMultimap<ISymbol, ISymbol> leftRecursiveSymbolsMapping;\n    private final SetMultimap<ISymbol, ISymbol> rightRecursiveSymbolsMapping;\n    private final SetMultimap<Symbol, Production> longestMatchProdsFront;\n    private final SetMultimap<Symbol, Production> shortestMatchProdsFront;\n    private final SetMultimap<Symbol, Production> longestMatchProdsBack;\n    private final SetMultimap<Symbol, Production> shortestMatchProdsBack;\n    // priorities\n    private final Set<Priority> transitivePriorities;\n    private final Set<Priority> nonTransitivePriorities;\n    private final SetMultimap<Priority, Integer> priorities;\n    private final SetMultimap<Priority, Integer> indexedPriorities;\n    // extra collections to calculate the transitive closure\n    private final Set<Production> productionsOnPriorities;\n    private final SetMultimap<Priority, Integer> transitivePriorityArgs;\n    private final SetMultimap<Priority, Integer> nonTransitivePriorityArgs;\n    private final SetMultimap<Production, Priority> higherPriorityProductions;\n    private final HashMap<String, Symbol> cacheSymbolsRead; // caching symbols read\n    private final HashMap<String, Production> cacheProductionsRead; // caching productions read\n    // get all productions for a certain symbol\n    private final SetMultimap<ISymbol, IProduction> symbolProductionsMapping;\n    // get all productions that contain a particular literal\n    private final SetMultimap<ISymbol, IProduction> literalProductionsMapping;\n    // expression grammars per non-terminal\n    private final SetMultimap<ISymbol, IProduction> expressionGrammars;\n    // expression grammars collapsed\n    private final Set<Set<IProduction>> combinedExpressionGrammars;\n    // left and right derivable symbols from a symbol\n    private final SetMultimap<ISymbol, ISymbol> leftDerivable;\n    private final SetMultimap<ISymbol, ISymbol> rightDerivable;\n    public NormGrammar() {\n        this.filesRead = Sets.newHashSet();\n        this.gf = new GrammarFactory();\n        this.uniqueProductionMapping = Maps.newLinkedHashMap();\n        this.sortConsProductionMapping = Maps.newHashMap();\n        this.prodContextualProdMapping = HashBiMap.create();\n        this.leftRecursiveSymbolsMapping = HashMultimap.create();\n        this.rightRecursiveSymbolsMapping = HashMultimap.create();\n        this.derivedContextualProds = Sets.newHashSet();\n        this.contextualSymbols = Sets.newHashSet();\n        this.longestMatchProdsFront = LinkedHashMultimap.create();\n        this.longestMatchProdsBack = LinkedHashMultimap.create();\n        this.shortestMatchProdsFront = LinkedHashMultimap.create();\n        this.shortestMatchProdsBack = LinkedHashMultimap.create();\n        this.productionAttributesMapping = HashMultimap.create();\n        this.priorities = HashMultimap.create();\n        this.indexedPriorities = HashMultimap.create();\n        this.constructors = Maps.newHashMap();\n        this.transitivePriorities = Sets.newHashSet();\n        this.nonTransitivePriorities = Sets.newHashSet();\n        this.productionsOnPriorities = Sets.newHashSet();\n        this.transitivePriorityArgs = HashMultimap.create();\n        this.nonTransitivePriorityArgs = HashMultimap.create();\n        this.higherPriorityProductions = HashMultimap.create();\n        this.symbolProductionsMapping = HashMultimap.create();\n        this.cacheSymbolsRead = Maps.newHashMap();\n        this.cacheProductionsRead = Maps.newHashMap();\n        this.symbols = Sets.newHashSet();\n        this.literalProductionsMapping = HashMultimap.create();\n        this.expressionGrammars = HashMultimap.create();\n        this.combinedExpressionGrammars = Sets.newHashSet();\n        this.leftDerivable = HashMultimap.create();\n        this.rightDerivable = HashMultimap.create();\n    }\n    public Map<UniqueProduction, Production> syntax() {\n        return getUniqueProductionMapping();\n    }\n    public void priorityTransitiveClosure() {\n        // Floyd Warshall Algorithm to calculate the transitive closure\n        for(Production intermediate_prod : getProductionsOnPriorities()) {\n            for(Production first_prod : getProductionsOnPriorities()) {\n                for(Production second_prod : getProductionsOnPriorities()) {\n                    Priority first_sec = gf.createPriority(first_prod, second_prod, true);\n                    Priority first_k = gf.createPriority(first_prod, intermediate_prod, true);\n                    Priority k_second = gf.createPriority(intermediate_prod, second_prod, true);\n                    // if there is no priority first_prod > second_prod\n                    if(!getTransitivePriorities().contains(first_sec)) {\n                        // if there are priorities first_prod > intermediate_prod and\n                        // intermediate_prod > second_prod\n                        // add priority first_prod > second_prod\n                        if(getTransitivePriorities().contains(first_k)\n                            && getTransitivePriorities().contains(k_second)) {\n                            getTransitivePriorities().add(first_sec);\n                            getTransitivePriorityArgs().putAll(first_sec, getTransitivePriorityArgs().get(first_k));\n                        }\n                    } else {\n                        if(getTransitivePriorities().contains(first_k)\n                            && getTransitivePriorities().contains(k_second)) {\n                            getTransitivePriorityArgs().putAll(first_sec, getTransitivePriorityArgs().get(first_k));\n                        }\n                    }\n                }\n            }\n        }\n        priorities.putAll(getNonTransitivePriorityArgs());\n        priorities.putAll(getTransitivePriorityArgs());\n    }\n    public IProduction getInitialProduction() {\n        return initialProduction;\n    }\n    public SetMultimap<Priority, Integer> priorities() {\n        return priorities;\n    }\n    public Set<File> getFilesRead() {\n        return filesRead;\n    }\n    public Set<ISymbol> getSymbols() {\n        return symbols;\n    }\n    public Map<ProductionReference, Production> getSortConsProductionMapping() {\n        return sortConsProductionMapping;\n    }\n    public SetMultimap<IProduction, IAttribute> getProductionAttributesMapping() {\n        return productionAttributesMapping;\n    }\n    public Map<UniqueProduction, Production> getUniqueProductionMapping() {\n        return uniqueProductionMapping;\n    }\n    public BiMap<Production, ContextualProduction> getProdContextualProdMapping() {\n        return prodContextualProdMapping;\n    }\n    public Set<ContextualProduction> getDerivedContextualProds() {\n        return derivedContextualProds;\n    }\n    public Set<ContextualSymbol> getContextualSymbols() {\n        return contextualSymbols;\n    }\n    public SetMultimap<ISymbol, ISymbol> getLeftRecursiveSymbolsMapping() {\n        return leftRecursiveSymbolsMapping;\n    }\n    public SetMultimap<ISymbol, ISymbol> getRightRecursiveSymbolsMapping() {\n        return rightRecursiveSymbolsMapping;\n    }\n    public SetMultimap<Symbol, Production> getLongestMatchProdsFront() {\n        return longestMatchProdsFront;\n    }\n    public SetMultimap<Symbol, Production> getLongestMatchProdsBack() {\n        return longestMatchProdsBack;\n    }\n    public SetMultimap<Symbol, Production> getShortestMatchProdsFront() {\n        return shortestMatchProdsFront;\n    }\n    public SetMultimap<Symbol, Production> getShortestMatchProdsBack() {\n        return shortestMatchProdsBack;\n    }\n    public Set<Priority> getTransitivePriorities() {\n        return transitivePriorities;\n    }\n    public Set<Priority> getNonTransitivePriorities() {\n        return nonTransitivePriorities;\n    }\n    public Set<Production> getProductionsOnPriorities() {\n        return productionsOnPriorities;\n    }\n    public SetMultimap<Priority, Integer> getTransitivePriorityArgs() {\n        return transitivePriorityArgs;\n    }\n    public SetMultimap<Priority, Integer> getNonTransitivePriorityArgs() {\n        return nonTransitivePriorityArgs;\n    }\n    public HashMap<String, Symbol> getCacheSymbolsRead() {\n        return cacheSymbolsRead;\n    }\n    public HashMap<String, Production> getCacheProductionsRead() {\n        return cacheProductionsRead;\n    }\n    public SetMultimap<ISymbol, IProduction> getSymbolProductionsMapping() {\n        return symbolProductionsMapping;\n    }\n    public SetMultimap<Production, Priority> getHigherPriorityProductions() {\n        return higherPriorityProductions;\n    }\n    public void normalizeFollowRestrictionLookahead() {\n        for(ISymbol s : symbols) {\n            s.normalizeFollowRestrictionLookahead();\n        }\n    }\n    public Map<IProduction, ConstructorAttribute> getConstructors() {\n        return constructors;\n    }\n    public SetMultimap<ISymbol, IProduction> getLiteralProductionsMapping() {\n        return literalProductionsMapping;\n    }\n    public SetMultimap<ISymbol, IProduction> getExpressionGrammars() {\n        return expressionGrammars;\n    }\n    public Set<Set<IProduction>> getCombinedExpressionGrammars() {\n        return combinedExpressionGrammars;\n    }\n    public void setInitialProduction(Production prod) {\n        this.initialProduction = prod;\n    }\n    public SetMultimap<Priority, Integer> getIndexedPriorities() {\n        return indexedPriorities;\n    }\n    public GrammarFactory getGrammarFactory() {\n        return gf;\n    }\n    public void cleanupGrammar() {\n        this.cacheProductionsRead.clear();\n        this.cacheSymbolsRead.clear();\n        this.combinedExpressionGrammars.clear();\n        this.contextualSymbols.clear();\n        this.derivedContextualProds.clear();\n        this.expressionGrammars.clear();\n        this.leftRecursiveSymbolsMapping.clear();\n        this.rightRecursiveSymbolsMapping.clear();\n        this.literalProductionsMapping.clear();\n        this.longestMatchProdsBack.clear();\n        this.longestMatchProdsFront.clear();\n        this.nonTransitivePriorities.clear();\n        this.nonTransitivePriorityArgs.clear();\n        this.productionsOnPriorities.clear();\n        this.symbolProductionsMapping.clear();\n        this.transitivePriorities.clear();\n        this.transitivePriorityArgs.clear();\n        this.filesRead.clear();\n    }\n    public SetMultimap<ISymbol, ISymbol> getLeftDerivable() {\n        return leftDerivable;\n    }\n    public SetMultimap<ISymbol, ISymbol> getRightDerivable() {\n        return rightDerivable;\n    }\n"]], "pred": {"ppl": 2.482793092727661, "ppl_lower": 2.7483174800872803, "ppl/lowercase_ppl": -1.1117291552574111, "ppl/zlib": 0.0004685132269469629, "Min_5.0% Prob": 7.919006899291394, "Min_10.0% Prob": 5.967871577131982, "Min_20.0% Prob": 3.990015698414223, "Min_30.0% Prob": 2.916316961248716, "Min_40.0% Prob": 2.2492357252716726, "Min_50.0% Prob": 1.81493878365292, "Min_60.0% Prob": 1.516338116654953}}
{"hexsha": "a547c2a8ce0337531a5f785e3dbc687b38f67450", "ext": "java", "lang": "Java", "content": "public class TestUtil {\n\n  private static final Logger logger = LoggerFactory.getLogger(TestUtil.class);\n\n  // private on purpose\n  private TestUtil() {}\n\n  public static Properties loadProperties(String filePath)\n      throws IOException {\n    Properties properties = new Properties();\n    InputStream inputStream = TestUtil.class.getClassLoader().getResourceAsStream(filePath);\n    if (inputStream == null) {\n      logger.info(\"Configuation file not present in classpath. File:  \" + filePath);\n      throw new RuntimeException(\"Unable to read \" + filePath);\n    }\n    properties.load(inputStream);\n    logger.info(\"Configuation file loaded. File: \" + filePath);\n    return properties;\n  }\n\n}", "item_id": 0, "repo": "AsadAliZaidi/dr-elephant", "file": "test/common/TestUtil.java", "last_update_at": "2022-03-29T03:07:45+00:00", "question_id": "a547c2a8ce0337531a5f785e3dbc687b38f67450_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestUtil {\n  private static final Logger logger = LoggerFactory.getLogger(TestUtil.class);\n  // private on purpose\n  private TestUtil() {}\n  public static Properties loadProperties(String filePath)\n      throws IOException {\n    Properties properties = new Properties();\n    InputStream inputStream = TestUtil.class.getClassLoader().getResourceAsStream(filePath);\n    if (inputStream == null) {\n      logger.info(\"Configuation file not present in classpath. File:  \" + filePath);\n      throw new RuntimeException(\"Unable to read \" + filePath);\n    }\n    properties.load(inputStream);\n    logger.info(\"Configuation file loaded. File: \" + filePath);\n    return properties;\n  }\n"]], "pred": {"ppl": 2.176039457321167, "ppl_lower": 2.66003680229187, "ppl/lowercase_ppl": -1.25830460096032, "ppl/zlib": 0.002341886933100576, "Min_5.0% Prob": 6.27309152815077, "Min_10.0% Prob": 4.798736876911587, "Min_20.0% Prob": 3.302556875679228, "Min_30.0% Prob": 2.453873331899996, "Min_40.0% Prob": 1.9095274557669957, "Min_50.0% Prob": 1.5473852671682835, "Min_60.0% Prob": 1.2939245128245265}}
{"hexsha": "73bd4b62de5e6b5357c7d248eb40132d32a4a3a1", "ext": "java", "lang": "Java", "content": "public class MaestroBackendClient extends AbstractBackendListenerClient {\n    // Logger instance used for logging\n    private static final Logger log = LoggerFactory.getLogger(MaestroBackendClient.class);\n\n    // Maestro Backend Listener Parameters\n    private String maestroUrl;\n    private String maestroAuthToken;\n    private String maestroRunId;\n\n    public MaestroHttpMetricsSender maestroHttpSender = new MaestroHttpMetricsSender();\n\n    public MaestroBackendClient() {\n        super();\n    }\n\n    public MaestroBackendClient(String url, String runId) {\n        super();\n        maestroUrl = url;\n        maestroRunId = runId;\n    }\n\n    private static final Map<String, String> DEFAULT_ARGS = new LinkedHashMap<>();\n    static {\n        DEFAULT_ARGS.put(\"maestroUrl\", \"${__P(maestro.api.host)}\");\n        DEFAULT_ARGS.put(\"maestroAuthToken\", \"${__P(maestro.api.token)}\");\n        DEFAULT_ARGS.put(\"maestroRunId\", \"${__P(maestro.run.id)}\");\n    }\n\n    @Override\n    public Arguments getDefaultParameters() {\n        Arguments arguments = new Arguments();\n        DEFAULT_ARGS.forEach(arguments::addArgument);\n        return arguments;\n    }\n\n    public String getTestMaestroUrl(){\n        if (maestroUrl.endsWith(\"/\")) {\n            return maestroUrl + maestroRunId;\n        }\n        return maestroUrl + \"/\" + maestroRunId;\n    }\n\n    // Do initialization required by this client.\n    @Override\n    public void setupTest(BackendListenerContext context) throws Exception {\n        maestroUrl = context.getParameter(\"maestroUrl\", \"\");\n        maestroAuthToken = context.getParameter(\"maestroAuthToken\", \"\");\n        maestroRunId = context.getParameter(\"maestroRunId\", \"\");\n\n        maestroHttpSender.setup(getTestMaestroUrl(), maestroAuthToken);\n    }\n\n    // Converts JMeter Sample Result to JSON Object\n    private JSONObject sampleToJSON(SampleResult sr) {\n        // Doc: https://jmeter.apache.org/api/org/apache/jmeter/visualizers/backend/SamplerMetric.html\n        JSONObject srObj = new JSONObject();\n        srObj.put(\"timeStamp\", Long.toString(sr.getTimeStamp()));\n        srObj.put(\"elapsed\", Long.toString(sr.getTime()));\n        srObj.put(\"label\", sr.getSampleLabel());\n        srObj.put(\"responseCode\", sr.getResponseCode());\n        srObj.put(\"responseMessage\", sr.getResponseMessage());\n        srObj.put(\"threadName\", sr.getThreadName());\n        srObj.put(\"dataType\", sr.getDataType());\n        srObj.put(\"success\", Boolean.toString(sr.isSuccessful()));\n        srObj.put(\"failureMessage\", Optional.ofNullable(sr.getFirstAssertionFailureMessage()).orElse(\"\"));\n        srObj.put(\"bytes\", Long.toString((sr.getBytesAsLong())));\n        srObj.put(\"sentBytes\", Long.toString(sr.getSentBytes()));\n        srObj.put(\"grpThreads\", Integer.toString(sr.getGroupThreads()));\n        srObj.put(\"allThreads\", Integer.toString(sr.getAllThreads()));\n        srObj.put(\"URL\", sr.getUrlAsString());\n        srObj.put(\"Latency\", Long.toString(sr.getLatency()));\n        srObj.put(\"IdleTime\", Long.toString(sr.getIdleTime()));\n        srObj.put(\"Connect\", Long.toString(sr.getConnectTime()));\n        return srObj;\n    }\n\n    public String processSampleResults(List<SampleResult> results){\n        JSONArray allSamplesResults = new JSONArray();\n\n        // Adds all JMeter test sample and subsamples results to allow us to\n        // recreate the csv file.\n        for (SampleResult sr : results) {\n            allSamplesResults.add(sampleToJSON(sr));\n            SampleResult[] sampleResults = sr.getSubResults();\n            for (SampleResult sampleResult : sampleResults) {\n                allSamplesResults.add(sampleToJSON(sampleResult));\n            }\n        }\n\n        // Format request body accordingly to the Maestro API Interface\n        JSONObject request_body = new JSONObject();\n        request_body.put(\"metrics\", allSamplesResults);\n        return request_body.toJSONString();\n    }\n\n    // Handle sampleResults, send them to maestro API\n    @Override\n    public void handleSampleResults(List<SampleResult> results, BackendListenerContext context) {\n        maestroHttpSender.writeAndSendMetrics(processSampleResults(results));\n    }\n\n    // Do any clean-up required at the end of a test run.\n    @Override\n    public void teardownTest(BackendListenerContext context) throws Exception {\n        log.info(\"Sending final metrics.\");\n        maestroHttpSender.destroy();\n        super.teardownTest(context);\n    }\n\n}", "item_id": 0, "repo": "Farfetch/maestro", "file": "jmeter/plugins/jmeter-backendlistener-maestro/src/main/java/com/farfetch/jmeter/backendlistener/maestro/MaestroBackendClient.java", "last_update_at": "2022-02-06T02:44:16+00:00", "question_id": "73bd4b62de5e6b5357c7d248eb40132d32a4a3a1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MaestroBackendClient extends AbstractBackendListenerClient {\n    // Logger instance used for logging\n    private static final Logger log = LoggerFactory.getLogger(MaestroBackendClient.class);\n    // Maestro Backend Listener Parameters\n    private String maestroUrl;\n    private String maestroAuthToken;\n    private String maestroRunId;\n    public MaestroHttpMetricsSender maestroHttpSender = new MaestroHttpMetricsSender();\n    public MaestroBackendClient() {\n        super();\n    }\n    public MaestroBackendClient(String url, String runId) {\n        super();\n        maestroUrl = url;\n        maestroRunId = runId;\n    }\n    private static final Map<String, String> DEFAULT_ARGS = new LinkedHashMap<>();\n    static {\n        DEFAULT_ARGS.put(\"maestroUrl\", \"${__P(maestro.api.host)}\");\n        DEFAULT_ARGS.put(\"maestroAuthToken\", \"${__P(maestro.api.token)}\");\n        DEFAULT_ARGS.put(\"maestroRunId\", \"${__P(maestro.run.id)}\");\n    }\n    @Override\n    public Arguments getDefaultParameters() {\n        Arguments arguments = new Arguments();\n        DEFAULT_ARGS.forEach(arguments::addArgument);\n        return arguments;\n    }\n    public String getTestMaestroUrl(){\n        if (maestroUrl.endsWith(\"/\")) {\n            return maestroUrl + maestroRunId;\n        }\n        return maestroUrl + \"/\" + maestroRunId;\n    }\n    // Do initialization required by this client.\n    @Override\n    public void setupTest(BackendListenerContext context) throws Exception {\n        maestroUrl = context.getParameter(\"maestroUrl\", \"\");\n        maestroAuthToken = context.getParameter(\"maestroAuthToken\", \"\");\n        maestroRunId = context.getParameter(\"maestroRunId\", \"\");\n        maestroHttpSender.setup(getTestMaestroUrl(), maestroAuthToken);\n    }\n    // Converts JMeter Sample Result to JSON Object\n    private JSONObject sampleToJSON(SampleResult sr) {\n        // Doc: https://jmeter.apache.org/api/org/apache/jmeter/visualizers/backend/SamplerMetric.html\n        JSONObject srObj = new JSONObject();\n        srObj.put(\"timeStamp\", Long.toString(sr.getTimeStamp()));\n        srObj.put(\"elapsed\", Long.toString(sr.getTime()));\n        srObj.put(\"label\", sr.getSampleLabel());\n        srObj.put(\"responseCode\", sr.getResponseCode());\n        srObj.put(\"responseMessage\", sr.getResponseMessage());\n        srObj.put(\"threadName\", sr.getThreadName());\n        srObj.put(\"dataType\", sr.getDataType());\n        srObj.put(\"success\", Boolean.toString(sr.isSuccessful()));\n        srObj.put(\"failureMessage\", Optional.ofNullable(sr.getFirstAssertionFailureMessage()).orElse(\"\"));\n        srObj.put(\"bytes\", Long.toString((sr.getBytesAsLong())));\n        srObj.put(\"sentBytes\", Long.toString(sr.getSentBytes()));\n        srObj.put(\"grpThreads\", Integer.toString(sr.getGroupThreads()));\n        srObj.put(\"allThreads\", Integer.toString(sr.getAllThreads()));\n        srObj.put(\"URL\", sr.getUrlAsString());\n        srObj.put(\"Latency\", Long.toString(sr.getLatency()));\n        srObj.put(\"IdleTime\", Long.toString(sr.getIdleTime()));\n        srObj.put(\"Connect\", Long.toString(sr.getConnectTime()));\n        return srObj;\n    }\n    public String processSampleResults(List<SampleResult> results){\n        JSONArray allSamplesResults = new JSONArray();\n        // Adds all JMeter test sample and subsamples results to allow us to\n        // recreate the csv file.\n        for (SampleResult sr : results) {\n            allSamplesResults.add(sampleToJSON(sr));\n            SampleResult[] sampleResults = sr.getSubResults();\n            for (SampleResult sampleResult : sampleResults) {\n                allSamplesResults.add(sampleToJSON(sampleResult));\n            }\n        }\n        // Format request body accordingly to the Maestro API Interface\n        JSONObject request_body = new JSONObject();\n        request_body.put(\"metrics\", allSamplesResults);\n        return request_body.toJSONString();\n    }\n    // Handle sampleResults, send them to maestro API\n    @Override\n    public void handleSampleResults(List<SampleResult> results, BackendListenerContext context) {\n        maestroHttpSender.writeAndSendMetrics(processSampleResults(results));\n    }\n    // Do any clean-up required at the end of a test run.\n    @Override\n    public void teardownTest(BackendListenerContext context) throws Exception {\n        log.info(\"Sending final metrics.\");\n        maestroHttpSender.destroy();\n        super.teardownTest(context);\n    }\n"]], "pred": {"ppl": 1.8421217203140259, "ppl_lower": 2.154566526412964, "ppl/lowercase_ppl": -1.2564526420443594, "ppl/zlib": 0.0004505295104482472, "Min_5.0% Prob": 6.397297503901463, "Min_10.0% Prob": 4.544450154491499, "Min_20.0% Prob": 2.846231984157188, "Min_30.0% Prob": 1.9999435509926353, "Min_40.0% Prob": 1.5182891506929415, "Min_50.0% Prob": 1.220566818512495, "Min_60.0% Prob": 1.0189310890101322}}
{"hexsha": "4365f154534fa25cfd1b30eb34d382ab0be9b254", "ext": "java", "lang": "Java", "content": "public class AssignImportTest extends TestBase {\n    public AssignImportTest() {\n        super(AssignImportTest.class);\n    }\n\n    @Test\n    public void testImportAsync() throws Exception {\n        ArrayList<ServerName> serverNameList;\n        List<HRegionInfo> regionInfoList;\n        ServerName rs1, rs2;\n        List<String> assignmentList;\n\n        String expFileName = \"export_test.exp\";\n\n        splitTable(\"a\".getBytes());\n        splitTable(\"b\".getBytes());\n\n        serverNameList = getServerNameList();\n        rs1 = serverNameList.get(0);\n        rs2 = serverNameList.get(1);\n\n        // move all regions to rs1\n        regionInfoList = getRegionInfoList(tableName);\n        for (HRegionInfo hRegionInfo : regionInfoList)\n            move(hRegionInfo, rs1);\n        assertEquals(regionInfoList.size(), getRegionInfoList(rs1, tableName).size());\n\n        boolean balancerRunning = false;\n        try {\n            String[] argsParam;\n            Args args;\n            Assign command;\n\n            // export\n            balancerRunning = admin.setBalancerRunning(false, true);\n            argsParam = new String[]{\"zookeeper\", \"export\", expFileName};\n            args = new ManagerArgs(argsParam);\n            command = new Assign(admin, args);\n            command.run();\n\n            assignmentList = AssignTest.readExportFile(expFileName);\n            assertEquals(AssignAction.getProcessedCount(), assignmentList.size());\n\n            // remember region count of rs1\n            int regionCountRS1 = getRegionInfoList(rs1, tableName).size();\n\n            // move all regions to rs2\n            regionInfoList = getRegionInfoList(tableName);\n            for (HRegionInfo hRegionInfo : regionInfoList)\n                move(hRegionInfo, rs2);\n            assertEquals(0, getRegionInfoList(rs1, tableName).size());\n            assertEquals(regionInfoList.size(), getRegionInfoList(rs2, tableName).size());\n\n            // import\n            balancerRunning = admin.setBalancerRunning(false, true);\n            argsParam = new String[]{\"zookeeper\", \"import\", expFileName, \"--force-proceed\", \"--move-async\"};\n            args = new ManagerArgs(argsParam);\n            command = new Assign(admin, args);\n            command.run();\n\n            // verify\n            assertEquals(regionCountRS1, getRegionInfoList(rs1, tableName).size());\n            assertEquals(regionInfoList.size(), getRegionInfoList(tableName).size());\n        } finally {\n            if (balancerRunning)\n                admin.setBalancerRunning(true, true);\n            Files.delete(Paths.get(expFileName));\n        }\n    }\n\n    @Test\n    public void testImportWithRS() throws Exception {\n        ArrayList<ServerName> serverNameList;\n        List<HRegionInfo> regionInfoList;\n        ServerName rs1, rs2;\n\n        String expFileName = \"export_test.exp\";\n\n        splitTable(\"a\".getBytes());\n        splitTable(\"b\".getBytes());\n\n        serverNameList = getServerNameList();\n        rs1 = serverNameList.get(0);\n        rs2 = serverNameList.get(1);\n\n        // move all regions to rs1 except 1\n        regionInfoList = getRegionInfoList(tableName);\n        for (HRegionInfo hRegionInfo : regionInfoList)\n            move(hRegionInfo, rs1);\n        HRegionInfo region1 = regionInfoList.get(0);\n        HRegionInfo region2 = regionInfoList.get(1);\n        HRegionInfo region3 = regionInfoList.get(2);\n        move(region1, rs2);\n        assertEquals(region1, getRegionInfoList(rs2, tableName).get(0));\n        assertEquals(region2, getRegionInfoList(rs1, tableName).get(0));\n        assertEquals(region3, getRegionInfoList(rs1, tableName).get(1));\n\n        boolean balancerRunning = false;\n        try {\n            String[] argsParam;\n            Args args;\n            Assign command;\n\n            balancerRunning = admin.setBalancerRunning(false, true);\n\n            // export all RSs\n            argsParam = new String[]{\"zookeeper\", \"export\", expFileName};\n            args = new ManagerArgs(argsParam);\n            command = new Assign(admin, args);\n            command.run();\n\n            // move regions\n            move(region1, rs1);\n            move(region2, rs2);\n            move(region3, rs1);\n            assertEquals(region1, getRegionInfoList(rs1, tableName).get(0));\n            assertEquals(region2, getRegionInfoList(rs2, tableName).get(0));\n            assertEquals(region3, getRegionInfoList(rs1, tableName).get(1));\n\n            // import rs2\n            String serverNameModified = rs2.getServerName().substring(0,\n                rs2.getServerName().lastIndexOf(\",\")) + \",\" + System.currentTimeMillis();\n            argsParam = new String[]{\"zookeeper\", \"import\", expFileName,\n                \"--force-proceed\", \"--rs=\" + serverNameModified};\n            args = new ManagerArgs(argsParam);\n            command = new Assign(admin, args);\n            command.run();\n\n            // check\n            assertEquals(region1, getRegionInfoList(rs2, tableName).get(0));\n            assertEquals(region2, getRegionInfoList(rs2, tableName).get(1));\n            assertEquals(region3, getRegionInfoList(rs1, tableName).get(0));\n        } finally {\n            if (balancerRunning)\n                admin.setBalancerRunning(true, true);\n            Files.delete(Paths.get(expFileName));\n        }\n    }\n}", "item_id": 0, "repo": "NickBondarenko/hbase-tools", "file": "hbase0.98/hbase-manager-0.98/src/test/java/com/kakao/hbase/manager/command/AssignImportTest.java", "last_update_at": "2022-02-22T00:50:25+00:00", "question_id": "4365f154534fa25cfd1b30eb34d382ab0be9b254_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AssignImportTest extends TestBase {\n    public AssignImportTest() {\n        super(AssignImportTest.class);\n    }\n    @Test\n    public void testImportAsync() throws Exception {\n        ArrayList<ServerName> serverNameList;\n        List<HRegionInfo> regionInfoList;\n        ServerName rs1, rs2;\n        List<String> assignmentList;\n        String expFileName = \"export_test.exp\";\n        splitTable(\"a\".getBytes());\n        splitTable(\"b\".getBytes());\n        serverNameList = getServerNameList();\n        rs1 = serverNameList.get(0);\n        rs2 = serverNameList.get(1);\n        // move all regions to rs1\n        regionInfoList = getRegionInfoList(tableName);\n        for (HRegionInfo hRegionInfo : regionInfoList)\n            move(hRegionInfo, rs1);\n        assertEquals(regionInfoList.size(), getRegionInfoList(rs1, tableName).size());\n        boolean balancerRunning = false;\n        try {\n            String[] argsParam;\n            Args args;\n            Assign command;\n            // export\n            balancerRunning = admin.setBalancerRunning(false, true);\n            argsParam = new String[]{\"zookeeper\", \"export\", expFileName};\n            args = new ManagerArgs(argsParam);\n            command = new Assign(admin, args);\n            command.run();\n            assignmentList = AssignTest.readExportFile(expFileName);\n            assertEquals(AssignAction.getProcessedCount(), assignmentList.size());\n            // remember region count of rs1\n            int regionCountRS1 = getRegionInfoList(rs1, tableName).size();\n            // move all regions to rs2\n            regionInfoList = getRegionInfoList(tableName);\n            for (HRegionInfo hRegionInfo : regionInfoList)\n                move(hRegionInfo, rs2);\n            assertEquals(0, getRegionInfoList(rs1, tableName).size());\n            assertEquals(regionInfoList.size(), getRegionInfoList(rs2, tableName).size());\n            // import\n            balancerRunning = admin.setBalancerRunning(false, true);\n            argsParam = new String[]{\"zookeeper\", \"import\", expFileName, \"--force-proceed\", \"--move-async\"};\n            args = new ManagerArgs(argsParam);\n            command = new Assign(admin, args);\n            command.run();\n            // verify\n            assertEquals(regionCountRS1, getRegionInfoList(rs1, tableName).size());\n            assertEquals(regionInfoList.size(), getRegionInfoList(tableName).size());\n        } finally {\n            if (balancerRunning)\n                admin.setBalancerRunning(true, true);\n            Files.delete(Paths.get(expFileName));\n        }\n    }\n    @Test\n    public void testImportWithRS() throws Exception {\n        ArrayList<ServerName> serverNameList;\n        List<HRegionInfo> regionInfoList;\n        ServerName rs1, rs2;\n        String expFileName = \"export_test.exp\";\n        splitTable(\"a\".getBytes());\n        splitTable(\"b\".getBytes());\n        serverNameList = getServerNameList();\n        rs1 = serverNameList.get(0);\n        rs2 = serverNameList.get(1);\n        // move all regions to rs1 except 1\n        regionInfoList = getRegionInfoList(tableName);\n        for (HRegionInfo hRegionInfo : regionInfoList)\n            move(hRegionInfo, rs1);\n        HRegionInfo region1 = regionInfoList.get(0);\n        HRegionInfo region2 = regionInfoList.get(1);\n        HRegionInfo region3 = regionInfoList.get(2);\n        move(region1, rs2);\n        assertEquals(region1, getRegionInfoList(rs2, tableName).get(0));\n        assertEquals(region2, getRegionInfoList(rs1, tableName).get(0));\n        assertEquals(region3, getRegionInfoList(rs1, tableName).get(1));\n        boolean balancerRunning = false;\n        try {\n            String[] argsParam;\n            Args args;\n            Assign command;\n            balancerRunning = admin.setBalancerRunning(false, true);\n            // export all RSs\n            argsParam = new String[]{\"zookeeper\", \"export\", expFileName};\n            args = new ManagerArgs(argsParam);\n            command = new Assign(admin, args);\n            command.run();\n            // move regions\n            move(region1, rs1);\n            move(region2, rs2);\n            move(region3, rs1);\n            assertEquals(region1, getRegionInfoList(rs1, tableName).get(0));\n            assertEquals(region2, getRegionInfoList(rs2, tableName).get(0));\n            assertEquals(region3, getRegionInfoList(rs1, tableName).get(1));\n            // import rs2\n            String serverNameModified = rs2.getServerName().substring(0,\n                rs2.getServerName().lastIndexOf(\",\")) + \",\" + System.currentTimeMillis();\n            argsParam = new String[]{\"zookeeper\", \"import\", expFileName,\n                \"--force-proceed\", \"--rs=\" + serverNameModified};\n            args = new ManagerArgs(argsParam);\n            command = new Assign(admin, args);\n            command.run();\n            // check\n            assertEquals(region1, getRegionInfoList(rs2, tableName).get(0));\n            assertEquals(region2, getRegionInfoList(rs2, tableName).get(1));\n            assertEquals(region3, getRegionInfoList(rs1, tableName).get(0));\n        } finally {\n            if (balancerRunning)\n                admin.setBalancerRunning(true, true);\n            Files.delete(Paths.get(expFileName));\n        }\n    }\n"]], "pred": {"ppl": 1.6940139532089233, "ppl_lower": 1.940744400024414, "ppl/lowercase_ppl": -1.2579597095476107, "ppl/zlib": 0.0005389579069908989, "Min_5.0% Prob": 6.131280852299111, "Min_10.0% Prob": 4.174263374478209, "Min_20.0% Prob": 2.5054418570270727, "Min_30.0% Prob": 1.7389893434893071, "Min_40.0% Prob": 1.3132743686118817, "Min_50.0% Prob": 1.053840653504265, "Min_60.0% Prob": 0.8792614598749403}}
{"hexsha": "b7d595b6444fec4db981cd5cca2360fc40b3f76d", "ext": "java", "lang": "Java", "content": "public class Euler extends Base {\n\n    public Euler() {\n        this.espaciado = 0;\n        this.decimales = 5;\n    }\n\n    public double evaluar(Funcion funcion, double x0, double x1, double y, int n) {\n\n        System.out.println(\"x0: \" + x0);\n        System.out.println(\"x1: \" + x1);\n        System.out.println(\" y: \" + y);\n        System.out.println(\" n: \" + n);\n        System.out.println();\n\n        double resultado = 0;\n        double f, h;\n        double X[] = new double[n + 1];\n        double Y[] = new double[n + 1];\n        h = (x1 - x0) / n;\n\n        System.out.println(\"h: \" + h);\n        X[0] = x0;\n        System.out.println(\"Y\" + 0 + \": \" + Y[0]);\n        Y[0] = y;\n        System.out.println(\"X\" + 0 + \": \" + Y[0]);\n        System.out.println(\"---------------------------------\");\n        for (int i = 0; i < n; i++) {\n            f = funcion.evaluar(X[i], Y[i]);\n            System.out.println(\"f x\" + (i) + \"y\" + (i) + \" : \" + f);\n            Y[i + 1] = Y[i] + (h * f);\n            System.out.println(\"Y\" + (i + 1) + \": \" + Y[i + 1]);\n            X[i + 1] = X[i] + h;\n            System.out.println(\"X\" + (i + 1) + \": \" + X[i + 1]);\n            System.out.println(\"---------------------------------\");\n        }\n        resultado = Y[n];\n\n        this.reportarcoordenadas(X, Y);\n\n\n        System.out.println(\"\");\n        System.out.println(\"Resultado:\");\n        System.out.println(this.redondear(resultado));\n\n        return resultado;\n    }\n\n    public void consola() {\n\n        Consola consola = new Consola();\n        String funcion_cadena = consola.getCadena(\"Ingresa la Funcion\");\n        double a = consola.getNumero(\"Ingresa el Valor para a\");\n        double b = consola.getNumero(\"Ingresa el Valor para b\");\n        double y = consola.getNumero(\"Ingresa el Valor para y\");\n        int n = consola.getEntero(\"Ingresa el Numero de Iteraciones\", 4);\n\n\n        boolean fraccion = consola.getBoolean(\"Quieres usar Fraccciones?\");\n        int decimales = consola.getEntero(\"cuantos decimales queres usar para el reporte?\", 6);\n\n        this.fraccion = fraccion;\n        this.decimales = decimales;\n\n        consola.limpiarPantalla();\n        Funcion funcion = new Funcion(funcion_cadena);\n        this.evaluar(funcion, a, b, y, n);\n\n    }\n}", "item_id": 0, "repo": "BaronNuts/MetodosNumericosParaIng", "file": "src/metodos/Euler.java", "last_update_at": "2022-03-30T22:38:57+00:00", "question_id": "b7d595b6444fec4db981cd5cca2360fc40b3f76d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Euler extends Base {\n    public Euler() {\n        this.espaciado = 0;\n        this.decimales = 5;\n    }\n    public double evaluar(Funcion funcion, double x0, double x1, double y, int n) {\n        System.out.println(\"x0: \" + x0);\n        System.out.println(\"x1: \" + x1);\n        System.out.println(\" y: \" + y);\n        System.out.println(\" n: \" + n);\n        System.out.println();\n        double resultado = 0;\n        double f, h;\n        double X[] = new double[n + 1];\n        double Y[] = new double[n + 1];\n        h = (x1 - x0) / n;\n        System.out.println(\"h: \" + h);\n        X[0] = x0;\n        System.out.println(\"Y\" + 0 + \": \" + Y[0]);\n        Y[0] = y;\n        System.out.println(\"X\" + 0 + \": \" + Y[0]);\n        System.out.println(\"---------------------------------\");\n        for (int i = 0; i < n; i++) {\n            f = funcion.evaluar(X[i], Y[i]);\n            System.out.println(\"f x\" + (i) + \"y\" + (i) + \" : \" + f);\n            Y[i + 1] = Y[i] + (h * f);\n            System.out.println(\"Y\" + (i + 1) + \": \" + Y[i + 1]);\n            X[i + 1] = X[i] + h;\n            System.out.println(\"X\" + (i + 1) + \": \" + X[i + 1]);\n            System.out.println(\"---------------------------------\");\n        }\n        resultado = Y[n];\n        this.reportarcoordenadas(X, Y);\n        System.out.println(\"\");\n        System.out.println(\"Resultado:\");\n        System.out.println(this.redondear(resultado));\n        return resultado;\n    }\n    public void consola() {\n        Consola consola = new Consola();\n        String funcion_cadena = consola.getCadena(\"Ingresa la Funcion\");\n        double a = consola.getNumero(\"Ingresa el Valor para a\");\n        double b = consola.getNumero(\"Ingresa el Valor para b\");\n        double y = consola.getNumero(\"Ingresa el Valor para y\");\n        int n = consola.getEntero(\"Ingresa el Numero de Iteraciones\", 4);\n        boolean fraccion = consola.getBoolean(\"Quieres usar Fraccciones?\");\n        int decimales = consola.getEntero(\"cuantos decimales queres usar para el reporte?\", 6);\n        this.fraccion = fraccion;\n        this.decimales = decimales;\n        consola.limpiarPantalla();\n        Funcion funcion = new Funcion(funcion_cadena);\n        this.evaluar(funcion, a, b, y, n);\n    }\n"]], "pred": {"ppl": 1.8314632177352905, "ppl_lower": 1.9145135879516602, "ppl/lowercase_ppl": -1.073289132288292, "ppl/zlib": 0.0008911858908666401, "Min_5.0% Prob": 5.863178748350877, "Min_10.0% Prob": 4.32452171361899, "Min_20.0% Prob": 2.729670945953273, "Min_30.0% Prob": 1.9523174680080735, "Min_40.0% Prob": 1.49667121868276, "Min_50.0% Prob": 1.2077172172985389, "Min_60.0% Prob": 1.007533297650477}}
{"hexsha": "51bff49a942c9d459e11636bd060b4ceea922d06", "ext": "java", "lang": "Java", "content": "class WorkItemParamsTest extends AbstractCodegenTest {\n\n\t@Test\n\tvoid testBasicServiceProcessTask() throws Exception {\n\t\tApplication app = generateCodeProcessesOnly(\"servicetask/WorkItemParams.bpmn\");\n\t\tassertThat(app).isNotNull();\n\n\t\tProcess<? extends Model> p = app.processes().processById(\"WorkItemParamsTest_1_0\");\n\n\t\tProcessInstance<?> processInstance = p.createInstance(p.createModel());\n\t\tprocessInstance.start();\n\n\t\tassertThat(processInstance.startDate()).isNotNull();\n\t\tassertThat(processInstance.status()).isEqualTo(ProcessInstance.STATE_COMPLETED);\n\t\tModel result = (Model) processInstance.variables();\n\t\tMap<String, Object> data = result.toMap();\n\t\tassertThat(data).hasSize(4).containsKeys(\"boolValue\", \"intValue\", \"floatValue\", \"stringValue\");\n\t\tassertThat(data.get(\"boolValue\")).isNotNull().isEqualTo(Boolean.FALSE);\n\t\tassertThat(data.get(\"intValue\")).isNotNull().isEqualTo(101);\n\t\tassertThat(data.get(\"floatValue\")).isNotNull().isEqualTo(2.1f);\n\t\tassertThat(data.get(\"stringValue\")).isNotNull().isEqualTo(\"foofoo\");\n\t}\n\n}", "item_id": 0, "repo": "automatiko-io/automatiko-engine", "file": "codegen/src/test/java/io/automatiko/engine/codegen/tests/WorkItemParamsTest.java", "last_update_at": "2022-03-07T00:03:18+00:00", "question_id": "51bff49a942c9d459e11636bd060b4ceea922d06_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class WorkItemParamsTest extends AbstractCodegenTest {\n\t@Test\n\tvoid testBasicServiceProcessTask() throws Exception {\n\t\tApplication app = generateCodeProcessesOnly(\"servicetask/WorkItemParams.bpmn\");\n\t\tassertThat(app).isNotNull();\n\t\tProcess<? extends Model> p = app.processes().processById(\"WorkItemParamsTest_1_0\");\n\t\tProcessInstance<?> processInstance = p.createInstance(p.createModel());\n\t\tprocessInstance.start();\n\t\tassertThat(processInstance.startDate()).isNotNull();\n\t\tassertThat(processInstance.status()).isEqualTo(ProcessInstance.STATE_COMPLETED);\n\t\tModel result = (Model) processInstance.variables();\n\t\tMap<String, Object> data = result.toMap();\n\t\tassertThat(data).hasSize(4).containsKeys(\"boolValue\", \"intValue\", \"floatValue\", \"stringValue\");\n\t\tassertThat(data.get(\"boolValue\")).isNotNull().isEqualTo(Boolean.FALSE);\n\t\tassertThat(data.get(\"intValue\")).isNotNull().isEqualTo(101);\n\t\tassertThat(data.get(\"floatValue\")).isNotNull().isEqualTo(2.1f);\n\t\tassertThat(data.get(\"stringValue\")).isNotNull().isEqualTo(\"foofoo\");\n\t}\n"]], "pred": {"ppl": 2.801961660385132, "ppl_lower": 3.6551902294158936, "ppl/lowercase_ppl": -1.2580057011293668, "ppl/zlib": 0.0022845227602552995, "Min_5.0% Prob": 7.826614558696747, "Min_10.0% Prob": 6.212201942097057, "Min_20.0% Prob": 4.458198271580597, "Min_30.0% Prob": 3.3377650517225264, "Min_40.0% Prob": 2.5567772266135287, "Min_50.0% Prob": 2.0530234134889076, "Min_60.0% Prob": 1.7198206908973073}}
{"hexsha": "148ead072a61a8c02f9891a8b10c2aad0f63b751", "ext": "java", "lang": "Java", "content": "@Service\n@Transactional\npublic class GroupEmailTemplateServiceImpl extends\n\t\tBaseJpaServiceImpl<GroupEmailTemplate, Long> implements\n\t\tGroupEmailTemplateService {\n\n\tprivate @Autowired GroupEmailTemplateRepository groupEmailTemplateRepository;\n\n\t@PostConstruct\n\tpublic void setupService() {\n\t\tthis.baseJpaRepository = groupEmailTemplateRepository;\n\t\tthis.entityClass = GroupEmailTemplate.class;\n\t\tthis.baseJpaRepository.setupEntityClass(GroupEmailTemplate.class);\n\n\t}\n\n\tpublic GroupEmailTemplate findbyTemplateName(String templateName) {\n\t\treturn groupEmailTemplateRepository.findbyTemplateName(templateName);\n\t}\n\n\tpublic List<GroupEmailTemplate> findbyGroupCode(String groupCode) {\n\n\t\treturn groupEmailTemplateRepository.findbyGroupCode(groupCode);\n\t}\n\n\tpublic List<GroupEmailTemplate> findbyGroupCodeAndGroupEventCode(\n\t\t\tString groupCode, String groupEventCode) {\n\t\treturn groupEmailTemplateRepository.findbyGroupCodeAndGroupEventCode(\n\t\t\t\tgroupCode, groupEventCode);\n\t}\n\n}", "item_id": 0, "repo": "mevroy/reminders", "file": "yourwebproject/src/main/java/com/yourpackagename/yourwebproject/service/impl/GroupEmailTemplateServiceImpl.java", "last_update_at": "2022-02-01T01:04:15+00:00", "question_id": "148ead072a61a8c02f9891a8b10c2aad0f63b751_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\n@Transactional\npublic class GroupEmailTemplateServiceImpl extends\n\t\tBaseJpaServiceImpl<GroupEmailTemplate, Long> implements\n\t\tGroupEmailTemplateService {\n\tprivate @Autowired GroupEmailTemplateRepository groupEmailTemplateRepository;\n\t@PostConstruct\n\tpublic void setupService() {\n\t\tthis.baseJpaRepository = groupEmailTemplateRepository;\n\t\tthis.entityClass = GroupEmailTemplate.class;\n\t\tthis.baseJpaRepository.setupEntityClass(GroupEmailTemplate.class);\n\t}\n\tpublic GroupEmailTemplate findbyTemplateName(String templateName) {\n\t\treturn groupEmailTemplateRepository.findbyTemplateName(templateName);\n\t}\n\tpublic List<GroupEmailTemplate> findbyGroupCode(String groupCode) {\n\t\treturn groupEmailTemplateRepository.findbyGroupCode(groupCode);\n\t}\n\tpublic List<GroupEmailTemplate> findbyGroupCodeAndGroupEventCode(\n\t\t\tString groupCode, String groupEventCode) {\n\t\treturn groupEmailTemplateRepository.findbyGroupCodeAndGroupEventCode(\n\t\t\t\tgroupCode, groupEventCode);\n\t}\n"]], "pred": {"ppl": 1.8319542407989502, "ppl_lower": 2.0588459968566895, "ppl/lowercase_ppl": -1.1928734145728912, "ppl/zlib": 0.0019037210321074189, "Min_5.0% Prob": 5.664943951826829, "Min_10.0% Prob": 4.229872385660808, "Min_20.0% Prob": 2.7134100607147924, "Min_30.0% Prob": 1.951364079007396, "Min_40.0% Prob": 1.4963554915178705, "Min_50.0% Prob": 1.20615365345169, "Min_60.0% Prob": 1.0077755001609294}}
{"hexsha": "4bef3ba75e60119493cec367a9336d7ef97f9ec4", "ext": "java", "lang": "Java", "content": "public class DigraphUtilsTest extends TestCase {\n\n    public void testPostOrder() {\n        Digraph<Integer> digraph = new DigraphImpl<Integer>();\n        // 1 -> 2 -> 3;\n        digraph.addEdge(1, 2);\n        digraph.addEdge(2, 3);\n        List<Integer> post = DigraphUtils.topologicalOrder(digraph);\n        assertTrue(post.get(0) == 1);\n        assertTrue(post.get(1) == 2);\n        assertTrue(post.get(2) == 3);\n        digraph.addEdge(2, 4);\n        digraph.addEdge(4, 1);\n    }\n}", "item_id": 0, "repo": "fanruan/swift-http", "file": "swift-base/swift-base-structure/src/test/java/com/fr/swift/cloud/structure/graph/DigraphUtilsTest.java", "last_update_at": "2022-03-10T03:36:32+00:00", "question_id": "4bef3ba75e60119493cec367a9336d7ef97f9ec4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DigraphUtilsTest extends TestCase {\n    public void testPostOrder() {\n        Digraph<Integer> digraph = new DigraphImpl<Integer>();\n        // 1 -> 2 -> 3;\n        digraph.addEdge(1, 2);\n        digraph.addEdge(2, 3);\n        List<Integer> post = DigraphUtils.topologicalOrder(digraph);\n        assertTrue(post.get(0) == 1);\n        assertTrue(post.get(1) == 2);\n        assertTrue(post.get(2) == 3);\n        digraph.addEdge(2, 4);\n        digraph.addEdge(4, 1);\n    }\n"]], "pred": {"ppl": 1.942937970161438, "ppl_lower": 2.4396090507507324, "ppl/lowercase_ppl": -1.3427222666789993, "ppl/zlib": 0.002952005533823632, "Min_5.0% Prob": 6.547012627124786, "Min_10.0% Prob": 4.3919057004591995, "Min_20.0% Prob": 2.893323260195115, "Min_30.0% Prob": 2.113320745089475, "Min_40.0% Prob": 1.637293310068986, "Min_50.0% Prob": 1.3237627994926537, "Min_60.0% Prob": 1.1057226368883515}}
{"hexsha": "f9b181b9be7f023d288befd01d54469a8174de8f", "ext": "java", "lang": "Java", "content": "public class ZadBuilder extends UGraphicNo {\n\n\t@Override\n\tpublic UGraphic apply(UChange change) {\n\t\treturn new ZadBuilder(this, change);\n\t}\n\n\tprivate final Context context;\n\n\tstatic class Context {\n\t\tprivate final Zad zad = new Zad();\n\t}\n\n\tpublic ZadBuilder(StringBounder stringBounder) {\n\t\tsuper(stringBounder);\n\t\tthis.context = new Context();\n\t}\n\n\tprivate ZadBuilder(ZadBuilder other, UChange change) {\n\t\tsuper(other, change);\n\t\tif (!instanceOfAny(change,\n\t\t\t\tUBackground.class,\n\t\t\t\tHColor.class,\n\t\t\t\tUStroke.class,\n\t\t\t\tUTranslate.class\n\t\t)) {\n\t\t\tthrow new UnsupportedOperationException(change.getClass().toString());\n\t\t}\n\t\tthis.context = other.context;\n\t}\n\n\tpublic void draw(UShape shape) {\n\t\tif (shape instanceof URectangle) {\n\t\t\tdrawRectangle((URectangle) shape);\n\t\t}\n\t}\n\n\tprivate void drawRectangle(URectangle shape) {\n\t\tfinal MinMax area = shape.getMinMax().translate(getTranslate());\n\t\t// System.err.println(\"ZadBuilder \" + shape + \" \" + area);\n\t\tcontext.zad.add(area);\n\t}\n\n\tpublic Zad getZad() {\n\t\treturn context.zad;\n\t}\n\n}", "item_id": 0, "repo": "SandraBSofiaH/Final-UMldoclet", "file": "src/plantuml-asl/src/net/sourceforge/plantuml/activitydiagram3/ftile/ZadBuilder.java", "last_update_at": "2022-03-18T09:28:05+00:00", "question_id": "f9b181b9be7f023d288befd01d54469a8174de8f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ZadBuilder extends UGraphicNo {\n\t@Override\n\tpublic UGraphic apply(UChange change) {\n\t\treturn new ZadBuilder(this, change);\n\t}\n\tprivate final Context context;\n\tstatic class Context {\n\t\tprivate final Zad zad = new Zad();\n\t}\n\tpublic ZadBuilder(StringBounder stringBounder) {\n\t\tsuper(stringBounder);\n\t\tthis.context = new Context();\n\t}\n\tprivate ZadBuilder(ZadBuilder other, UChange change) {\n\t\tsuper(other, change);\n\t\tif (!instanceOfAny(change,\n\t\t\t\tUBackground.class,\n\t\t\t\tHColor.class,\n\t\t\t\tUStroke.class,\n\t\t\t\tUTranslate.class\n\t\t)) {\n\t\t\tthrow new UnsupportedOperationException(change.getClass().toString());\n\t\t}\n\t\tthis.context = other.context;\n\t}\n\tpublic void draw(UShape shape) {\n\t\tif (shape instanceof URectangle) {\n\t\t\tdrawRectangle((URectangle) shape);\n\t\t}\n\t}\n\tprivate void drawRectangle(URectangle shape) {\n\t\tfinal MinMax area = shape.getMinMax().translate(getTranslate());\n\t\t// System.err.println(\"ZadBuilder \" + shape + \" \" + area);\n\t\tcontext.zad.add(area);\n\t}\n\tpublic Zad getZad() {\n\t\treturn context.zad;\n\t}\n"]], "pred": {"ppl": 1.8989356756210327, "ppl_lower": 2.4676196575164795, "ppl/lowercase_ppl": -1.408487536806474, "ppl/zlib": 0.0013791259322416874, "Min_5.0% Prob": 6.911908785502116, "Min_10.0% Prob": 4.919013851397747, "Min_20.0% Prob": 2.993734359741211, "Min_30.0% Prob": 2.0969103776511893, "Min_40.0% Prob": 1.5956937818239068, "Min_50.0% Prob": 1.2805198282545442, "Min_60.0% Prob": 1.072046689397606}}
{"hexsha": "cc796e610bc57d084c97b5d05ead33dd1711c3c7", "ext": "java", "lang": "Java", "content": "public class NewZenUmlBufferAction extends DumbAwareAction {\n\n    private static int nextBufferIndex() {\n        try {\n            Method method = ScratchFileActions.class.getDeclaredMethod(\"nextBufferIndex\");\n            method.setAccessible(true);\n            return (int) method.invoke(null);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"No such method: ScratchFileActions.nextBufferIndex\", e);\n        } catch (IllegalAccessException | InvocationTargetException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    static ScratchFileCreationHelper.Context createContext(@NotNull AnActionEvent event, @NotNull Project project) {\n        try {\n            Method method = ScratchFileActions.class.getDeclaredMethod(\"createContext\", AnActionEvent.class);\n            method.setAccessible(true);\n            return (ScratchFileCreationHelper.Context) method.invoke(null, event);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"No such method: ScratchFileActions.createContext\", e);\n        } catch (IllegalAccessException | InvocationTargetException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    static void doCreateNewScratch(@NotNull Project project, @NotNull ScratchFileCreationHelper.Context context) {\n        try {\n            Method method = ScratchFileActions.class.getDeclaredMethod(\"doCreateNewScratch\", Project.class, ScratchFileCreationHelper.Context.class);\n            method.setAccessible(true);\n            method.invoke(null, project, context);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"No such method: ScratchFileActions.doCreateNewScratch\", e);\n        } catch (IllegalAccessException | InvocationTargetException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n        @Override\n    public void update(@NotNull AnActionEvent e) {\n        boolean enabled = e.getProject() != null && Registry.intValue(\"ide.scratch.buffers\") > 0;\n        e.getPresentation().setEnabledAndVisible(enabled);\n    }\n\n    @Override\n    public void actionPerformed(@NotNull AnActionEvent e) {\n        Project project = e.getProject();\n        if (project == null) return;\n        ScratchFileCreationHelper.Context context = createContext(e, project);\n        context.text = e.getDataContext().getData(\"predefined.text.value\").toString();\n        context.filePrefix = \"zenuml\";\n        context.createOption = ScratchFileService.Option.create_if_missing;\n        context.fileCounter = NewZenUmlBufferAction::nextBufferIndex;\n        context.language = getLanguage();\n        doCreateNewScratch(project, context);\n    }\n\n    private Language getLanguage() {\n        Language zenUML = Language.findLanguageByID(\"ZenUML\");\n        return zenUML != null ? zenUML : StdLanguages.TEXT;\n    }\n}", "item_id": 0, "repo": "ZenUml/jetbrains-zenuml", "file": "src/com/intellij/ide/scratch/NewZenUmlBufferAction.java", "last_update_at": "2022-02-02T07:49:34+00:00", "question_id": "cc796e610bc57d084c97b5d05ead33dd1711c3c7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NewZenUmlBufferAction extends DumbAwareAction {\n    private static int nextBufferIndex() {\n        try {\n            Method method = ScratchFileActions.class.getDeclaredMethod(\"nextBufferIndex\");\n            method.setAccessible(true);\n            return (int) method.invoke(null);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"No such method: ScratchFileActions.nextBufferIndex\", e);\n        } catch (IllegalAccessException | InvocationTargetException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    static ScratchFileCreationHelper.Context createContext(@NotNull AnActionEvent event, @NotNull Project project) {\n        try {\n            Method method = ScratchFileActions.class.getDeclaredMethod(\"createContext\", AnActionEvent.class);\n            method.setAccessible(true);\n            return (ScratchFileCreationHelper.Context) method.invoke(null, event);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"No such method: ScratchFileActions.createContext\", e);\n        } catch (IllegalAccessException | InvocationTargetException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    static void doCreateNewScratch(@NotNull Project project, @NotNull ScratchFileCreationHelper.Context context) {\n        try {\n            Method method = ScratchFileActions.class.getDeclaredMethod(\"doCreateNewScratch\", Project.class, ScratchFileCreationHelper.Context.class);\n            method.setAccessible(true);\n            method.invoke(null, project, context);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"No such method: ScratchFileActions.doCreateNewScratch\", e);\n        } catch (IllegalAccessException | InvocationTargetException e) {\n            throw new RuntimeException(e);\n        }\n    }\n        @Override\n    public void update(@NotNull AnActionEvent e) {\n        boolean enabled = e.getProject() != null && Registry.intValue(\"ide.scratch.buffers\") > 0;\n        e.getPresentation().setEnabledAndVisible(enabled);\n    }\n    @Override\n    public void actionPerformed(@NotNull AnActionEvent e) {\n        Project project = e.getProject();\n        if (project == null) return;\n        ScratchFileCreationHelper.Context context = createContext(e, project);\n        context.text = e.getDataContext().getData(\"predefined.text.value\").toString();\n        context.filePrefix = \"zenuml\";\n        context.createOption = ScratchFileService.Option.create_if_missing;\n        context.fileCounter = NewZenUmlBufferAction::nextBufferIndex;\n        context.language = getLanguage();\n        doCreateNewScratch(project, context);\n    }\n    private Language getLanguage() {\n        Language zenUML = Language.findLanguageByID(\"ZenUML\");\n        return zenUML != null ? zenUML : StdLanguages.TEXT;\n    }\n"]], "pred": {"ppl": 1.635420322418213, "ppl_lower": 1.9412168264389038, "ppl/lowercase_ppl": -1.3484757264999407, "ppl/zlib": 0.0006576201193074548, "Min_5.0% Prob": 5.907813956863002, "Min_10.0% Prob": 4.0821407092245, "Min_20.0% Prob": 2.4049239762519536, "Min_30.0% Prob": 1.6329284695450936, "Min_40.0% Prob": 1.230543563804148, "Min_50.0% Prob": 0.9832612199096493, "Min_60.0% Prob": 0.820049458194684}}
{"hexsha": "721a6c092b33922d5f067d8f07d4bb106361fb10", "ext": "java", "lang": "Java", "content": "public class ComponentDiagramParser {\n\n    /**\n     * Create a UML component diagram from the model and relationship elements given as JSON arrays. It parses the JSON objects to corresponding Java objects and creates a\n     * component diagram containing these UML model elements.\n     *\n     * @param modelElements the model elements as JSON array\n     * @param relationships the relationship elements as JSON array\n     * @param modelSubmissionId the ID of the corresponding modeling submission\n     * @return a UML component diagram containing the parsed model elements and relationships\n     * @throws IOException when no corresponding model elements could be found for the source and target IDs in the relationship JSON objects\n     */\n    protected static UMLComponentDiagram buildComponentDiagramFromJSON(JsonArray modelElements, JsonArray relationships, long modelSubmissionId) throws IOException {\n        Map<String, UMLComponent> umlComponentMap = new HashMap<>();\n        Map<String, UMLComponentInterface> umlComponentInterfaceMap = new HashMap<>();\n        Map<String, UMLElement> allUmlElementsMap = new HashMap<>();\n        List<UMLComponentRelationship> umlComponentRelationshipList = new ArrayList<>();\n\n        // owners might not yet be available, therefore we need to store them in a map first before we can resolve them\n        Map<UMLElement, String> ownerRelationships = new HashMap<>();\n\n        // loop over all JSON elements and create the UML objects\n        for (JsonElement jsonElement : modelElements) {\n            JsonObject jsonObject = jsonElement.getAsJsonObject();\n            UMLElement umlElement = null;\n            String elementType = jsonObject.get(ELEMENT_TYPE).getAsString();\n            if (UMLComponent.UML_COMPONENT_TYPE.equals(elementType)) {\n                UMLComponent umlComponent = parseComponent(jsonObject);\n                umlComponentMap.put(umlComponent.getJSONElementID(), umlComponent);\n                umlElement = umlComponent;\n            }\n            else if (UMLComponentInterface.UML_COMPONENT_INTERFACE_TYPE.equals(elementType)) {\n                UMLComponentInterface umlComponentInterface = parseComponentInterface(jsonObject);\n                umlComponentInterfaceMap.put(umlComponentInterface.getJSONElementID(), umlComponentInterface);\n                umlElement = umlComponentInterface;\n            }\n            if (umlElement != null) {\n                allUmlElementsMap.put(umlElement.getJSONElementID(), umlElement);\n                findOwner(ownerRelationships, jsonObject, umlElement);\n            }\n        }\n\n        // now we can resolve the owners: for this diagram type, only uml components can be the actual owner\n        resolveParentComponent(allUmlElementsMap, ownerRelationships);\n\n        // loop over all JSON control flow elements and create UML communication links\n        for (JsonElement rel : relationships) {\n            Optional<UMLComponentRelationship> componentRelationship = parseComponentRelationship(rel.getAsJsonObject(), allUmlElementsMap);\n            componentRelationship.ifPresent(umlComponentRelationshipList::add);\n        }\n\n        return new UMLComponentDiagram(modelSubmissionId, new ArrayList<>(umlComponentMap.values()), new ArrayList<>(umlComponentInterfaceMap.values()),\n                umlComponentRelationshipList);\n    }\n\n    /**\n     * Parses the given JSON representation of a UML component interface to a UMLComponentInterface Java object.\n     *\n     * @param relationshipJson the JSON object containing the component interface\n     * @param allUmlElementsMap the JSON object containing the component interface\n     * @return the UMLComponentInterface object parsed from the JSON object\n     */\n    protected static Optional<UMLComponentRelationship> parseComponentRelationship(JsonObject relationshipJson, Map<String, UMLElement> allUmlElementsMap) throws IOException {\n\n        String relationshipType = relationshipJson.get(RELATIONSHIP_TYPE).getAsString();\n        relationshipType = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, relationshipType);\n\n        if (!EnumUtils.isValidEnum(UMLComponentRelationship.UMLComponentRelationshipType.class, relationshipType)) {\n            return Optional.empty();\n        }\n\n        UMLElement source = UMLModelParser.findElement(relationshipJson, allUmlElementsMap, RELATIONSHIP_SOURCE);\n        UMLElement target = UMLModelParser.findElement(relationshipJson, allUmlElementsMap, RELATIONSHIP_TARGET);\n\n        if (source != null && target != null) {\n            UMLComponentRelationship newComponentRelationship = new UMLComponentRelationship(source, target,\n                    UMLComponentRelationship.UMLComponentRelationshipType.valueOf(relationshipType), relationshipJson.get(ELEMENT_ID).getAsString());\n            return Optional.of(newComponentRelationship);\n        }\n        else {\n            throw new IOException(\"Relationship source or target not part of model!\");\n        }\n    }\n\n    /**\n     * Parses the given JSON representation of a UML component interface to a UMLComponentInterface Java object.\n     *\n     * @param componentInterfaceJson the JSON object containing the component interface\n     * @return the UMLComponentInterface object parsed from the JSON object\n     */\n    protected static UMLComponentInterface parseComponentInterface(JsonObject componentInterfaceJson) {\n        String componentInterfaceName = componentInterfaceJson.get(ELEMENT_NAME).getAsString();\n        return new UMLComponentInterface(componentInterfaceName, componentInterfaceJson.get(ELEMENT_ID).getAsString());\n    }\n\n    /**\n     * Parses the given JSON representation of a UML component to a UMLComponent Java object.\n     *\n     * @param componentJson the JSON object containing the component\n     * @return the UMLComponent object parsed from the JSON object\n     */\n    protected static UMLComponent parseComponent(JsonObject componentJson) {\n        String componentName = componentJson.get(ELEMENT_NAME).getAsString();\n        return new UMLComponent(componentName, componentJson.get(ELEMENT_ID).getAsString());\n    }\n\n    /**\n     * Finds the owner element of relationship and sets parent of relationship to that element\n     *\n     * @param allUmlElementsMap map of uml elements and ids to find owner element\n     * @param ownerRelationships map of uml elements and ids of their owners\n     * @return the UMLComponent object parsed from the JSON object\n     */\n    protected static void resolveParentComponent(Map<String, UMLElement> allUmlElementsMap, Map<UMLElement, String> ownerRelationships) {\n        for (var ownerEntry : ownerRelationships.entrySet()) {\n            String ownerId = ownerEntry.getValue();\n            UMLElement umlElement = ownerEntry.getKey();\n            UMLElement parentComponent = allUmlElementsMap.get(ownerId);\n            umlElement.setParentElement(parentComponent);\n        }\n    }\n\n    /**\n     * Gets the owner id from element's json object and puts it into a relationship map\n     *\n     * @param ownerRelationships map of uml relationship elements and their ids\n     * @param jsonObject json representation of element\n     * @param umlElement uml element\n     * @return the UMLComponent object parsed from the JSON object\n     */\n    protected static void findOwner(Map<UMLElement, String> ownerRelationships, JsonObject jsonObject, UMLElement umlElement) {\n        if (jsonObject.has(ELEMENT_OWNER) && !jsonObject.get(ELEMENT_OWNER).isJsonNull()) {\n            String ownerId = jsonObject.get(ELEMENT_OWNER).getAsString();\n            ownerRelationships.put(umlElement, ownerId);\n        }\n    }\n\n}", "item_id": 0, "repo": "AutoscanForJavaFork/Artemis", "file": "src/main/java/de/tum/in/www1/artemis/service/compass/umlmodel/parsers/ComponentDiagramParser.java", "last_update_at": "2022-03-29T14:49:53+00:00", "question_id": "721a6c092b33922d5f067d8f07d4bb106361fb10_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ComponentDiagramParser {\n    /**\n     * Create a UML component diagram from the model and relationship elements given as JSON arrays. It parses the JSON objects to corresponding Java objects and creates a\n     * component diagram containing these UML model elements.\n     *\n     * @param modelElements the model elements as JSON array\n     * @param relationships the relationship elements as JSON array\n     * @param modelSubmissionId the ID of the corresponding modeling submission\n     * @return a UML component diagram containing the parsed model elements and relationships\n     * @throws IOException when no corresponding model elements could be found for the source and target IDs in the relationship JSON objects\n     */\n    protected static UMLComponentDiagram buildComponentDiagramFromJSON(JsonArray modelElements, JsonArray relationships, long modelSubmissionId) throws IOException {\n        Map<String, UMLComponent> umlComponentMap = new HashMap<>();\n        Map<String, UMLComponentInterface> umlComponentInterfaceMap = new HashMap<>();\n        Map<String, UMLElement> allUmlElementsMap = new HashMap<>();\n        List<UMLComponentRelationship> umlComponentRelationshipList = new ArrayList<>();\n        // owners might not yet be available, therefore we need to store them in a map first before we can resolve them\n        Map<UMLElement, String> ownerRelationships = new HashMap<>();\n        // loop over all JSON elements and create the UML objects\n        for (JsonElement jsonElement : modelElements) {\n            JsonObject jsonObject = jsonElement.getAsJsonObject();\n            UMLElement umlElement = null;\n            String elementType = jsonObject.get(ELEMENT_TYPE).getAsString();\n            if (UMLComponent.UML_COMPONENT_TYPE.equals(elementType)) {\n                UMLComponent umlComponent = parseComponent(jsonObject);\n                umlComponentMap.put(umlComponent.getJSONElementID(), umlComponent);\n                umlElement = umlComponent;\n            }\n            else if (UMLComponentInterface.UML_COMPONENT_INTERFACE_TYPE.equals(elementType)) {\n                UMLComponentInterface umlComponentInterface = parseComponentInterface(jsonObject);\n                umlComponentInterfaceMap.put(umlComponentInterface.getJSONElementID(), umlComponentInterface);\n                umlElement = umlComponentInterface;\n            }\n            if (umlElement != null) {\n                allUmlElementsMap.put(umlElement.getJSONElementID(), umlElement);\n                findOwner(ownerRelationships, jsonObject, umlElement);\n            }\n        }\n        // now we can resolve the owners: for this diagram type, only uml components can be the actual owner\n        resolveParentComponent(allUmlElementsMap, ownerRelationships);\n        // loop over all JSON control flow elements and create UML communication links\n        for (JsonElement rel : relationships) {\n            Optional<UMLComponentRelationship> componentRelationship = parseComponentRelationship(rel.getAsJsonObject(), allUmlElementsMap);\n            componentRelationship.ifPresent(umlComponentRelationshipList::add);\n        }\n        return new UMLComponentDiagram(modelSubmissionId, new ArrayList<>(umlComponentMap.values()), new ArrayList<>(umlComponentInterfaceMap.values()),\n                umlComponentRelationshipList);\n    }\n    /**\n     * Parses the given JSON representation of a UML component interface to a UMLComponentInterface Java object.\n     *\n     * @param relationshipJson the JSON object containing the component interface\n     * @param allUmlElementsMap the JSON object containing the component interface\n     * @return the UMLComponentInterface object parsed from the JSON object\n     */\n    protected static Optional<UMLComponentRelationship> parseComponentRelationship(JsonObject relationshipJson, Map<String, UMLElement> allUmlElementsMap) throws IOException {\n        String relationshipType = relationshipJson.get(RELATIONSHIP_TYPE).getAsString();\n        relationshipType = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, relationshipType);\n        if (!EnumUtils.isValidEnum(UMLComponentRelationship.UMLComponentRelationshipType.class, relationshipType)) {\n            return Optional.empty();\n        }\n        UMLElement source = UMLModelParser.findElement(relationshipJson, allUmlElementsMap, RELATIONSHIP_SOURCE);\n        UMLElement target = UMLModelParser.findElement(relationshipJson, allUmlElementsMap, RELATIONSHIP_TARGET);\n        if (source != null && target != null) {\n            UMLComponentRelationship newComponentRelationship = new UMLComponentRelationship(source, target,\n                    UMLComponentRelationship.UMLComponentRelationshipType.valueOf(relationshipType), relationshipJson.get(ELEMENT_ID).getAsString());\n            return Optional.of(newComponentRelationship);\n        }\n        else {\n            throw new IOException(\"Relationship source or target not part of model!\");\n        }\n    }\n    /**\n     * Parses the given JSON representation of a UML component interface to a UMLComponentInterface Java object.\n     *\n     * @param componentInterfaceJson the JSON object containing the component interface\n     * @return the UMLComponentInterface object parsed from the JSON object\n     */\n    protected static UMLComponentInterface parseComponentInterface(JsonObject componentInterfaceJson) {\n        String componentInterfaceName = componentInterfaceJson.get(ELEMENT_NAME).getAsString();\n        return new UMLComponentInterface(componentInterfaceName, componentInterfaceJson.get(ELEMENT_ID).getAsString());\n    }\n    /**\n     * Parses the given JSON representation of a UML component to a UMLComponent Java object.\n     *\n     * @param componentJson the JSON object containing the component\n     * @return the UMLComponent object parsed from the JSON object\n     */\n    protected static UMLComponent parseComponent(JsonObject componentJson) {\n        String componentName = componentJson.get(ELEMENT_NAME).getAsString();\n        return new UMLComponent(componentName, componentJson.get(ELEMENT_ID).getAsString());\n    }\n    /**\n     * Finds the owner element of relationship and sets parent of relationship to that element\n     *\n     * @param allUmlElementsMap map of uml elements and ids to find owner element\n     * @param ownerRelationships map of uml elements and ids of their owners\n     * @return the UMLComponent object parsed from the JSON object\n     */\n    protected static void resolveParentComponent(Map<String, UMLElement> allUmlElementsMap, Map<UMLElement, String> ownerRelationships) {\n        for (var ownerEntry : ownerRelationships.entrySet()) {\n            String ownerId = ownerEntry.getValue();\n            UMLElement umlElement = ownerEntry.getKey();\n            UMLElement parentComponent = allUmlElementsMap.get(ownerId);\n            umlElement.setParentElement(parentComponent);\n        }\n    }\n    /**\n     * Gets the owner id from element's json object and puts it into a relationship map\n     *\n     * @param ownerRelationships map of uml relationship elements and their ids\n     * @param jsonObject json representation of element\n     * @param umlElement uml element\n     * @return the UMLComponent object parsed from the JSON object\n     */\n    protected static void findOwner(Map<UMLElement, String> ownerRelationships, JsonObject jsonObject, UMLElement umlElement) {\n        if (jsonObject.has(ELEMENT_OWNER) && !jsonObject.get(ELEMENT_OWNER).isJsonNull()) {\n            String ownerId = jsonObject.get(ELEMENT_OWNER).getAsString();\n            ownerRelationships.put(umlElement, ownerId);\n        }\n    }\n"]], "pred": {"ppl": 1.963765025138855, "ppl_lower": 2.170567274093628, "ppl/lowercase_ppl": -1.1483633046466815, "ppl/zlib": 0.00038674129616431303, "Min_5.0% Prob": 6.209748006334491, "Min_10.0% Prob": 4.517933997453428, "Min_20.0% Prob": 2.9812661873943664, "Min_30.0% Prob": 2.1757009313776603, "Min_40.0% Prob": 1.6744203729085934, "Min_50.0% Prob": 1.34863270497325, "Min_60.0% Prob": 1.125715622836405}}
{"hexsha": "268727d4258eb44915280346d7d83aa32e8b49d4", "ext": "java", "lang": "Java", "content": "public class Operators {\n\n  public static int operators() {\n    int x1 = -4;\n    int x2 =  x1--;\n    int x3 = ++x2; // !!!-3\n    if (x2 > x3) {\n      --x3;\n    } else {\n      x1++;\n    }\n    return x1 + x2 + x3;\n  }\n\n  public static void main(String[] args) {\n    System.out.println(operators());\n  }\n}", "item_id": 0, "repo": "andrej59/app-work", "file": "common/src/main/java/ru/ajana/work/common/test/Operators.java", "last_update_at": "2022-01-21T23:22:47+00:00", "question_id": "268727d4258eb44915280346d7d83aa32e8b49d4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Operators {\n  public static int operators() {\n    int x1 = -4;\n    int x2 =  x1--;\n    int x3 = ++x2; // !!!-3\n    if (x2 > x3) {\n      --x3;\n    } else {\n      x1++;\n    }\n    return x1 + x2 + x3;\n  }\n  public static void main(String[] args) {\n    System.out.println(operators());\n  }\n"]], "pred": {"ppl": 2.720067024230957, "ppl_lower": 3.1945393085479736, "ppl/lowercase_ppl": -1.1606808743784196, "ppl/zlib": 0.005408954169003764, "Min_5.0% Prob": 7.959951480229695, "Min_10.0% Prob": 6.223342001438141, "Min_20.0% Prob": 4.154811799526215, "Min_30.0% Prob": 3.074859278069602, "Min_40.0% Prob": 2.3966022413604113, "Min_50.0% Prob": 1.9730064961753908, "Min_60.0% Prob": 1.6676212307320881}}
{"hexsha": "c153f8e62848c842c2c292edb1b038207498f4a6", "ext": "java", "lang": "Java", "content": "public class WonAssemblerTest {\n    private static final String RESOURCE_FILE = \"/won-signed-messages/create-atom-msg.trig\";\n    private static final String ATOM_CORE_DATA_URI = \"http://localhost:8080/won/resource/atom/3144709509622353000/core/#data\";\n    private static final String ATOM_CORE_DATA_SIG_URI = \"http://localhost:8080/won/resource/atom/3144709509622353000/core/#data-sig\";\n\n    @Test\n    public void testAssembleOneGraphSignature() throws Exception {\n        // The Signingframework reader cannot reproduce the correct graph\n        // structure, it has problems with blank nodes [] parts.\n        // GraphCollection gc = TriGPlusReader.readFile(inFile);\n        // create dataset that contains atom core data graph\n        Dataset testDataset = TestSigningUtils.prepareTestDatasetFromNamedGraphs(RESOURCE_FILE,\n                        new String[] { ATOM_CORE_DATA_URI });\n        // convert to graph collection\n        GraphCollection gc = ModelConverter.modelToGraphCollection(ATOM_CORE_DATA_URI, testDataset);\n        // create mock signature\n        SignatureData mockSigData = createMockSignature();\n        gc.setSignature(mockSigData);\n        // test assemble()\n        WonAssembler.assemble(gc, testDataset, ATOM_CORE_DATA_SIG_URI);\n        // use for debugging output\n        // TestSigningUtils.writeToTempFile(testDataset);\n        // extract names of the named graphs\n        List<String> namesList = RdfUtils.getModelNames(testDataset);\n        // do some checks to make sure there is 1 signed names graph\n        Assert.assertEquals(\"should be one named graph with data and one named graph with signature\", 2,\n                        namesList.size());\n        Assert.assertTrue(\"should be some triples in signature graph\",\n                        testDataset.getNamedModel(ATOM_CORE_DATA_SIG_URI).listStatements().hasNext());\n        Assert.assertFalse(testDataset.getDefaultModel().listStatements().hasNext());\n        int triplesCounter = TestSigningUtils\n                        .countTriples(testDataset.getNamedModel(ATOM_CORE_DATA_SIG_URI).listStatements());\n        Set<String> subjs = TestSigningUtils.getSubjects(testDataset.getNamedModel(ATOM_CORE_DATA_SIG_URI));\n        Set<String> objs = TestSigningUtils.getUriResourceObjects(testDataset.getNamedModel(ATOM_CORE_DATA_SIG_URI));\n        Assert.assertEquals(\"signature graph should contain 11 triples\", 11, triplesCounter);\n        Assert.assertTrue(\"signed graph name should be an object in signature triples\",\n                        objs.contains(ATOM_CORE_DATA_URI));\n        Assert.assertTrue(\"signature graph name should be a subject in signature triples\",\n                        subjs.contains(ATOM_CORE_DATA_SIG_URI));\n    }\n\n    private SignatureData createMockSignature() throws NoSuchAlgorithmException {\n        SignatureData mockSigData = new SignatureData();\n        mockSigData.setHash(new BigInteger(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 }));\n        mockSigData.setSignature(\"\\\"blahblahSignature\\\"\");\n        mockSigData.setDigestGen(MessageDigest.getInstance(\"sha-256\"));\n        mockSigData.setCanonicalizationMethod(\"blahblahCanonicalizationMethod\");\n        mockSigData.setGraphDigestMethod(\"blahblahGraphDigestMethod\");\n        mockSigData.setSerializationMethod(\"blahblahSerializationmethod\");\n        mockSigData.setSignatureMethod(\"blahblahSigMathod\");\n        // mockSigData.setVerificationCertificateUri(\"\\\"blahblahVerificationCertificate\\\"\");\n        mockSigData.setVerificationCertificate(\"<http://localhost:8080/blahblah/certificate>\");\n        return mockSigData;\n    }\n}", "item_id": 0, "repo": "fkleedorfer/webofneeds", "file": "webofneeds/won-cryptography/src/test/java/won/cryptography/rdfsign/WonAssemblerTest.java", "last_update_at": "2022-03-19T14:52:36+00:00", "question_id": "c153f8e62848c842c2c292edb1b038207498f4a6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class WonAssemblerTest {\n    private static final String RESOURCE_FILE = \"/won-signed-messages/create-atom-msg.trig\";\n    private static final String ATOM_CORE_DATA_URI = \"http://localhost:8080/won/resource/atom/3144709509622353000/core/#data\";\n    private static final String ATOM_CORE_DATA_SIG_URI = \"http://localhost:8080/won/resource/atom/3144709509622353000/core/#data-sig\";\n    @Test\n    public void testAssembleOneGraphSignature() throws Exception {\n        // The Signingframework reader cannot reproduce the correct graph\n        // structure, it has problems with blank nodes [] parts.\n        // GraphCollection gc = TriGPlusReader.readFile(inFile);\n        // create dataset that contains atom core data graph\n        Dataset testDataset = TestSigningUtils.prepareTestDatasetFromNamedGraphs(RESOURCE_FILE,\n                        new String[] { ATOM_CORE_DATA_URI });\n        // convert to graph collection\n        GraphCollection gc = ModelConverter.modelToGraphCollection(ATOM_CORE_DATA_URI, testDataset);\n        // create mock signature\n        SignatureData mockSigData = createMockSignature();\n        gc.setSignature(mockSigData);\n        // test assemble()\n        WonAssembler.assemble(gc, testDataset, ATOM_CORE_DATA_SIG_URI);\n        // use for debugging output\n        // TestSigningUtils.writeToTempFile(testDataset);\n        // extract names of the named graphs\n        List<String> namesList = RdfUtils.getModelNames(testDataset);\n        // do some checks to make sure there is 1 signed names graph\n        Assert.assertEquals(\"should be one named graph with data and one named graph with signature\", 2,\n                        namesList.size());\n        Assert.assertTrue(\"should be some triples in signature graph\",\n                        testDataset.getNamedModel(ATOM_CORE_DATA_SIG_URI).listStatements().hasNext());\n        Assert.assertFalse(testDataset.getDefaultModel().listStatements().hasNext());\n        int triplesCounter = TestSigningUtils\n                        .countTriples(testDataset.getNamedModel(ATOM_CORE_DATA_SIG_URI).listStatements());\n        Set<String> subjs = TestSigningUtils.getSubjects(testDataset.getNamedModel(ATOM_CORE_DATA_SIG_URI));\n        Set<String> objs = TestSigningUtils.getUriResourceObjects(testDataset.getNamedModel(ATOM_CORE_DATA_SIG_URI));\n        Assert.assertEquals(\"signature graph should contain 11 triples\", 11, triplesCounter);\n        Assert.assertTrue(\"signed graph name should be an object in signature triples\",\n                        objs.contains(ATOM_CORE_DATA_URI));\n        Assert.assertTrue(\"signature graph name should be a subject in signature triples\",\n                        subjs.contains(ATOM_CORE_DATA_SIG_URI));\n    }\n    private SignatureData createMockSignature() throws NoSuchAlgorithmException {\n        SignatureData mockSigData = new SignatureData();\n        mockSigData.setHash(new BigInteger(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 }));\n        mockSigData.setSignature(\"\\\"blahblahSignature\\\"\");\n        mockSigData.setDigestGen(MessageDigest.getInstance(\"sha-256\"));\n        mockSigData.setCanonicalizationMethod(\"blahblahCanonicalizationMethod\");\n        mockSigData.setGraphDigestMethod(\"blahblahGraphDigestMethod\");\n        mockSigData.setSerializationMethod(\"blahblahSerializationmethod\");\n        mockSigData.setSignatureMethod(\"blahblahSigMathod\");\n        // mockSigData.setVerificationCertificateUri(\"\\\"blahblahVerificationCertificate\\\"\");\n        mockSigData.setVerificationCertificate(\"<http://localhost:8080/blahblah/certificate>\");\n        return mockSigData;\n    }\n"]], "pred": {"ppl": 2.765545129776001, "ppl_lower": 3.2155537605285645, "ppl/lowercase_ppl": -1.1482070574216212, "ppl/zlib": 0.0008716690395613678, "Min_5.0% Prob": 7.987738815008425, "Min_10.0% Prob": 6.2470265042548085, "Min_20.0% Prob": 4.326151196863137, "Min_30.0% Prob": 3.209544589706496, "Min_40.0% Prob": 2.501169011871214, "Min_50.0% Prob": 2.0289964966927956, "Min_60.0% Prob": 1.6963352813517605}}
{"hexsha": "31acfac9146e92236bf377117dcbd65c1fff71af", "ext": "java", "lang": "Java", "content": "public class FoldedFigureRotate extends JPanel {\n    private JButton foldedFigureRotateAntiClockwiseButton;\n    private JPanel panel1;\n    private JTextField foldedFigureRotateTextField;\n    private JButton foldedFigureRotateClockwiseButton;\n    private JButton foldedFigureRotateSetButton;\n\n    public FoldedFigureRotate(ButtonService buttonService, FoldedFigureModel foldedFigureModel, MeasuresModel measuresModel) {\n        add($$$getRootComponent$$$());\n\n        buttonService.registerButton(foldedFigureRotateAntiClockwiseButton, \"foldedFigureRotateAntiClockwiseAction\");\n        buttonService.registerButton(foldedFigureRotateSetButton, \"foldedFigureRotateSetAction\");\n        buttonService.registerButton(foldedFigureRotateClockwiseButton, \"foldedFigureRotateClockwiseAction\");\n\n        foldedFigureRotateAntiClockwiseButton.addActionListener(e -> foldedFigureModel.setRotation(OritaCalc.angle_between_m180_180(foldedFigureModel.getRotation() + 11.25)));\n        foldedFigureRotateSetButton.addActionListener(e -> foldedFigureModel.setRotation(OritaCalc.angle_between_m180_180(measuresModel.string2double(foldedFigureRotateTextField.getText(), foldedFigureModel.getRotation()))));\n        foldedFigureRotateClockwiseButton.addActionListener(e -> foldedFigureModel.setRotation(OritaCalc.angle_between_m180_180(foldedFigureModel.getRotation() - 11.25)));\n        foldedFigureRotateTextField.addActionListener(e -> foldedFigureRotateSetButton.doClick());\n    }\n\n    public void setText(String text) {\n        foldedFigureRotateTextField.setText(text);\n        foldedFigureRotateTextField.setCaretPosition(0);\n    }\n\n    public String getText() {\n        return foldedFigureRotateTextField.getText();\n    }\n\n    {\n// GUI initializer generated by IntelliJ IDEA GUI Designer\n// >>> IMPORTANT!! <<<\n// DO NOT EDIT OR ADD ANY CODE HERE!\n        $$$setupUI$$$();\n    }\n\n    /**\n     * Method generated by IntelliJ IDEA GUI Designer\n     * >>> IMPORTANT!! <<<\n     * DO NOT edit this method OR call it in your code!\n     *\n     * @noinspection ALL\n     */\n    private void $$$setupUI$$$() {\n        panel1 = new JPanel();\n        panel1.setLayout(new GridLayoutManager(1, 4, new Insets(0, 0, 0, 0), -1, -1));\n        foldedFigureRotateAntiClockwiseButton = new JButton();\n        foldedFigureRotateAntiClockwiseButton.setIcon(new ImageIcon(getClass().getResource(\"/ppp/oriagari_p_kaiten.png\")));\n        panel1.add(foldedFigureRotateAntiClockwiseButton, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n        foldedFigureRotateTextField = new JTextField();\n        foldedFigureRotateTextField.setColumns(2);\n        panel1.add(foldedFigureRotateTextField, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, new Dimension(30, -1), null, null, 0, false));\n        foldedFigureRotateSetButton = new JButton();\n        foldedFigureRotateSetButton.setText(\"S\");\n        panel1.add(foldedFigureRotateSetButton, new GridConstraints(0, 2, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n        foldedFigureRotateClockwiseButton = new JButton();\n        foldedFigureRotateClockwiseButton.setIcon(new ImageIcon(getClass().getResource(\"/ppp/oriagari_m_kaiten.png\")));\n        panel1.add(foldedFigureRotateClockwiseButton, new GridConstraints(0, 3, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n    }\n\n    /**\n     * @noinspection ALL\n     */\n    public JComponent $$$getRootComponent$$$() {\n        return panel1;\n    }\n\n}", "item_id": 0, "repo": "MuTsunTsai/oriedita", "file": "oriedita/src/main/java/oriedita/editor/swing/component/FoldedFigureRotate.java", "last_update_at": "2022-03-21T14:22:24+00:00", "question_id": "31acfac9146e92236bf377117dcbd65c1fff71af_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FoldedFigureRotate extends JPanel {\n    private JButton foldedFigureRotateAntiClockwiseButton;\n    private JPanel panel1;\n    private JTextField foldedFigureRotateTextField;\n    private JButton foldedFigureRotateClockwiseButton;\n    private JButton foldedFigureRotateSetButton;\n    public FoldedFigureRotate(ButtonService buttonService, FoldedFigureModel foldedFigureModel, MeasuresModel measuresModel) {\n        add($$$getRootComponent$$$());\n        buttonService.registerButton(foldedFigureRotateAntiClockwiseButton, \"foldedFigureRotateAntiClockwiseAction\");\n        buttonService.registerButton(foldedFigureRotateSetButton, \"foldedFigureRotateSetAction\");\n        buttonService.registerButton(foldedFigureRotateClockwiseButton, \"foldedFigureRotateClockwiseAction\");\n        foldedFigureRotateAntiClockwiseButton.addActionListener(e -> foldedFigureModel.setRotation(OritaCalc.angle_between_m180_180(foldedFigureModel.getRotation() + 11.25)));\n        foldedFigureRotateSetButton.addActionListener(e -> foldedFigureModel.setRotation(OritaCalc.angle_between_m180_180(measuresModel.string2double(foldedFigureRotateTextField.getText(), foldedFigureModel.getRotation()))));\n        foldedFigureRotateClockwiseButton.addActionListener(e -> foldedFigureModel.setRotation(OritaCalc.angle_between_m180_180(foldedFigureModel.getRotation() - 11.25)));\n        foldedFigureRotateTextField.addActionListener(e -> foldedFigureRotateSetButton.doClick());\n    }\n    public void setText(String text) {\n        foldedFigureRotateTextField.setText(text);\n        foldedFigureRotateTextField.setCaretPosition(0);\n    }\n    public String getText() {\n        return foldedFigureRotateTextField.getText();\n    }\n    {\n// GUI initializer generated by IntelliJ IDEA GUI Designer\n// >>> IMPORTANT!! <<<\n// DO NOT EDIT OR ADD ANY CODE HERE!\n        $$$setupUI$$$();\n    }\n    /**\n     * Method generated by IntelliJ IDEA GUI Designer\n     * >>> IMPORTANT!! <<<\n     * DO NOT edit this method OR call it in your code!\n     *\n     * @noinspection ALL\n     */\n    private void $$$setupUI$$$() {\n        panel1 = new JPanel();\n        panel1.setLayout(new GridLayoutManager(1, 4, new Insets(0, 0, 0, 0), -1, -1));\n        foldedFigureRotateAntiClockwiseButton = new JButton();\n        foldedFigureRotateAntiClockwiseButton.setIcon(new ImageIcon(getClass().getResource(\"/ppp/oriagari_p_kaiten.png\")));\n        panel1.add(foldedFigureRotateAntiClockwiseButton, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n        foldedFigureRotateTextField = new JTextField();\n        foldedFigureRotateTextField.setColumns(2);\n        panel1.add(foldedFigureRotateTextField, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, new Dimension(30, -1), null, null, 0, false));\n        foldedFigureRotateSetButton = new JButton();\n        foldedFigureRotateSetButton.setText(\"S\");\n        panel1.add(foldedFigureRotateSetButton, new GridConstraints(0, 2, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n        foldedFigureRotateClockwiseButton = new JButton();\n        foldedFigureRotateClockwiseButton.setIcon(new ImageIcon(getClass().getResource(\"/ppp/oriagari_m_kaiten.png\")));\n        panel1.add(foldedFigureRotateClockwiseButton, new GridConstraints(0, 3, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n    }\n    /**\n     * @noinspection ALL\n     */\n    public JComponent $$$getRootComponent$$$() {\n        return panel1;\n    }\n"]], "pred": {"ppl": 1.4561306238174438, "ppl_lower": 1.771607756614685, "ppl/lowercase_ppl": -1.5218569997443017, "ppl/zlib": 0.0004010487298940789, "Min_5.0% Prob": 5.226530682806875, "Min_10.0% Prob": 3.395241830863205, "Min_20.0% Prob": 1.8688082875428247, "Min_30.0% Prob": 1.2548462906213222, "Min_40.0% Prob": 0.9396952432816539, "Min_50.0% Prob": 0.7522561125468792, "Min_60.0% Prob": 0.6271126842365466}}
{"hexsha": "2f2a41b33dd9ba8e7c9ecdbb5190b5fc9a0c5d5f", "ext": "java", "lang": "Java", "content": "public class SecretKeyFactoryTest extends TestCase {\n\n    public static final String srvSecretKeyFactory = \"SecretKeyFactory\";\n\n    private static String defaultAlgorithm1 = \"DESede\";\n    private static String defaultAlgorithm2 = \"DES\";\n\n    public static String defaultAlgorithm = null;\n\n    private static String defaultProviderName = null;\n\n    private static Provider defaultProvider = null;\n\n    private static final String[] invalidValues = SpiEngUtils.invalidValues;\n\n    public static final String[] validValues = new String[2];\n    private static boolean DEFSupported = false;\n\n    private static final String NotSupportMsg = \"Default algorithm is not supported\";\n\n    static {\n        defaultProvider = SpiEngUtils.isSupport(defaultAlgorithm1,\n                srvSecretKeyFactory);\n        DEFSupported = (defaultProvider != null);\n        if (DEFSupported) {\n            defaultAlgorithm = defaultAlgorithm1;\n            validValues[0] = defaultAlgorithm.toUpperCase();\n            validValues[1] = defaultAlgorithm.toLowerCase();\n            defaultProviderName = defaultProvider.getName();\n        } else {\n            defaultProvider = SpiEngUtils.isSupport(defaultAlgorithm2,\n                    srvSecretKeyFactory);\n            DEFSupported = (defaultProvider != null);\n            if (DEFSupported) {\n                defaultAlgorithm = defaultAlgorithm2;\n                validValues[0] = defaultAlgorithm.toUpperCase();\n                validValues[2] = defaultAlgorithm.toLowerCase();\n                defaultProviderName = defaultProvider.getName();\n            } else {\n                defaultAlgorithm = null;\n                defaultProviderName = null;\n                defaultProvider = null;\n            }\n        }\n    }\n\n    protected SecretKeyFactory[] createSKFac() {\n        if (!DEFSupported) {\n            fail(defaultAlgorithm + \" algorithm is not supported\");\n            return null;\n        }\n        SecretKeyFactory[] skF = new SecretKeyFactory[3];\n        try {\n            skF[0] = SecretKeyFactory.getInstance(defaultAlgorithm);\n            skF[1] = SecretKeyFactory.getInstance(defaultAlgorithm,\n                    defaultProvider);\n            skF[2] = SecretKeyFactory.getInstance(defaultAlgorithm,\n                    defaultProviderName);\n            return skF;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * Test for <code>SecretKeyFactory</code> constructor\n     * Assertion: returns SecretKeyFactory object\n     */\n    public void testSecretKeyFactory01() throws NoSuchAlgorithmException,\n            InvalidKeySpecException, InvalidKeyException {\n        if (!DEFSupported) {\n            fail(NotSupportMsg);\n            return;\n        }\n        SecretKeyFactorySpi spi = new MySecretKeyFactorySpi();\n        SecretKeyFactory secKF = new mySecretKeyFactory(spi, defaultProvider,\n                defaultAlgorithm);\n        assertEquals(\"Incorrect algorithm\", secKF.getAlgorithm(),\n                defaultAlgorithm);\n        assertEquals(\"Incorrect provider\", secKF.getProvider(), defaultProvider);\n        assertNull(\"Incorrect result\", secKF.generateSecret(null));\n        assertNull(\"Incorrect result\", secKF.getKeySpec(null, null));\n        assertNull(\"Incorrect result\", secKF.translateKey(null));\n        secKF = new mySecretKeyFactory(null, null, null);\n        assertNull(\"Algorithm must be null\", secKF.getAlgorithm());\n        assertNull(\"Provider must be null\", secKF.getProvider());\n        try {\n            secKF.translateKey(null);\n            fail(\"NullPointerException must be thrown\");\n        } catch (NullPointerException e) {\n        }\n    }\n\n    /**\n     * Test for <code>getInstance(String algorithm)</code> method\n     * Assertions:\n     * throws NullPointerException when algorithm is null;\n     * throws NoSuchAlgorithmException when algorithm has invalid value\n     */\n    public void testSecretKeyFactory02() throws NoSuchAlgorithmException {\n        try {\n            SecretKeyFactory.getInstance(null);\n            fail(\"NullPointerException or NoSuchAlgorithmException should be thrown if algorithm is null\");\n        } catch (NullPointerException e) {\n        } catch (NoSuchAlgorithmException e) {\n        }\n        for (int i = 0; i < invalidValues.length; i++) {\n            try {\n                SecretKeyFactory.getInstance(invalidValues[i]);\n                fail(\"NoSuchAlgorithmException was not thrown as expected\");\n            } catch (NoSuchAlgorithmException e) {\n            }\n        }\n    }\n\n    /**\n     * Test for <code>getInstance(String algorithm)</code> method\n     * Assertion: returns SecretKeyObject\n     */\n    public void testSecretKeyFactory03() throws NoSuchAlgorithmException {\n        if (!DEFSupported) {\n            fail(NotSupportMsg);\n            return;\n        }\n        for (int i = 0; i < validValues.length; i++) {\n            SecretKeyFactory secKF = SecretKeyFactory\n                    .getInstance(validValues[i]);\n            assertEquals(\"Incorrect algorithm\", secKF.getAlgorithm(),\n                    validValues[i]);\n        }\n    }\n\n    /**\n     * Test for <code>getInstance(String algorithm, String provider)</code>\n     * method\n     * Assertion:\n     * throws NullPointerException when algorithm is null;\n     * throws NoSuchAlgorithmException when algorithm is invalid\n     */\n    public void testSecretKeyFactory04() throws NoSuchAlgorithmException,\n            NoSuchProviderException {\n        if (!DEFSupported) {\n            fail(NotSupportMsg);\n            return;\n        }\n        try {\n            SecretKeyFactory.getInstance(null, defaultProviderName);\n            fail(\"NullPointerException or NoSuchAlgorithmException should be thrown if algorithm is null\");\n        } catch (NullPointerException e) {\n        } catch (NoSuchAlgorithmException e) {\n        }\n        for (int i = 0; i < invalidValues.length; i++) {\n            try {\n                SecretKeyFactory.getInstance(invalidValues[i],\n                        defaultProviderName);\n                fail(\"NoSuchAlgorithmException was not thrown as expected (algorithm: \"\n                        .concat(invalidValues[i]).concat(\")\"));\n            } catch (NoSuchAlgorithmException e) {\n            }\n        }\n    }\n\n    /**\n     * Test for <code>getInstance(String algorithm, String provider)</code>\n     * method\n     * Assertion:\n     * throws IllegalArgumentException when provider is null or empty;\n     * throws NoSuchProviderException when provider has invalid value\n     */\n    public void testSecretKeyFactory05() throws NoSuchAlgorithmException,\n            NoSuchProviderException {\n        if (!DEFSupported) {\n            fail(NotSupportMsg);\n            return;\n        }\n        String prov = null;\n        for (int i = 0; i < validValues.length; i++) {\n            try {\n                SecretKeyFactory.getInstance(validValues[i], prov);\n                fail(\"IllegalArgumentException was not thrown as expected (algorithm: \"\n                        .concat(validValues[i]).concat(\" provider: null\"));\n            } catch (IllegalArgumentException e) {\n            }\n            try {\n                SecretKeyFactory.getInstance(validValues[i], \"\");\n                fail(\"IllegalArgumentException was not thrown as expected (algorithm: \"\n                        .concat(validValues[i]).concat(\" provider: empty\"));\n            } catch (IllegalArgumentException e) {\n            }\n            for (int j = 1; j < invalidValues.length; j++) {\n                try {\n                    SecretKeyFactory.getInstance(validValues[i],\n                            invalidValues[j]);\n                    fail(\"NoSuchProviderException was not thrown as expected (algorithm: \"\n                            .concat(validValues[i]).concat(\" provider: \")\n                            .concat(invalidValues[j]).concat(\")\"));\n                } catch (NoSuchProviderException e) {\n                }\n            }\n        }\n    }\n\n    /**\n     * Test for <code>getInstance(String algorithm, String provider)</code>\n     * method\n     * Assertion: returns SecretKeyFactory object\n     */\n    public void testSecretKeyFactory06() throws NoSuchProviderException,\n            NoSuchAlgorithmException {\n        if (!DEFSupported) {\n            fail(NotSupportMsg);\n            return;\n        }\n        for (int i = 0; i < validValues.length; i++) {\n            SecretKeyFactory secKF = SecretKeyFactory.getInstance(\n                    validValues[i], defaultProviderName);\n            assertEquals(\"Incorrect algorithm\", secKF.getAlgorithm(),\n                    validValues[i]);\n            assertEquals(\"Incorrect provider\", secKF.getProvider().getName(),\n                    defaultProviderName);\n        }\n    }\n\n    /**\n     * Test for <code>getInstance(String algorithm, Provider provider)</code>\n     * method\n     * Assertion: throws NullPointerException when algorithm is null;\n     * throws NoSuchAlgorithmException when algorithm is invalid\n     */\n    public void testSecretKeyFactory07() throws NoSuchAlgorithmException {\n        if (!DEFSupported) {\n            fail(NotSupportMsg);\n            return;\n        }\n        try {\n            SecretKeyFactory.getInstance(null, defaultProvider);\n            fail(\"NullPointerException or NoSuchAlgorithmException should be thrown if algorithm is null\");\n        } catch (NullPointerException e) {\n        } catch (NoSuchAlgorithmException e) {\n        }\n        for (int i = 0; i < invalidValues.length; i++) {\n            try {\n                SecretKeyFactory.getInstance(invalidValues[i], defaultProvider);\n                fail(\"NoSuchAlgorithmException was not thrown as expected (algorithm: \"\n                        .concat(invalidValues[i]).concat(\")\"));\n            } catch (NoSuchAlgorithmException e) {\n            }\n        }\n    }\n\n    /**\n     * Test for <code>getInstance(String algorithm, Provider provider)</code>\n     * method\n     * Assertion: throws IllegalArgumentException when provider is null\n     */\n    public void testSecretKeyFactory08() throws NoSuchAlgorithmException {\n        if (!DEFSupported) {\n            fail(NotSupportMsg);\n            return;\n        }\n        Provider prov = null;\n        for (int i = 0; i < validValues.length; i++) {\n            try {\n                SecretKeyFactory.getInstance(validValues[i], prov);\n                fail(\"IllegalArgumentException was not thrown as expected (provider is null, algorithm: \"\n                        .concat(validValues[i]).concat(\")\"));\n            } catch (IllegalArgumentException e) {\n            }\n        }\n    }\n\n    /**\n     * Test for <code>getInstance(String algorithm, Provider provider)</code>\n     * method\n     * Assertion: returns SecretKeyFactory object\n     */\n    public void testSecretKeyFactory09() throws NoSuchAlgorithmException {\n        if (!DEFSupported) {\n            fail(NotSupportMsg);\n            return;\n        }\n        for (int i = 0; i < validValues.length; i++) {\n            SecretKeyFactory secKF = SecretKeyFactory.getInstance(\n                    validValues[i], defaultProvider);\n            assertEquals(\"Incorrect algorithm\", secKF.getAlgorithm(),\n                    validValues[i]);\n            assertEquals(\"Incorrect provider\", secKF.getProvider(),\n                    defaultProvider);\n        }\n    }\n\n    /**\n     * Test for <code>generateSecret(KeySpec keySpec)</code> and\n     * <code>getKeySpec(SecretKey key, Class keySpec)\n     * methods\n     * Assertion:\n     * throw InvalidKeySpecException if parameter is inappropriate\n     */\n    public void testSecretKeyFactory10() throws InvalidKeyException,\n            InvalidKeySpecException {\n        if (!DEFSupported) {\n            fail(NotSupportMsg);\n            return;\n        }\n        byte[] bb = new byte[24];\n        KeySpec ks = (defaultAlgorithm.equals(defaultAlgorithm2) ? (KeySpec)new DESKeySpec(bb) :\n            (KeySpec)new DESedeKeySpec(bb));\n        KeySpec rks = null;\n        SecretKeySpec secKeySpec = new SecretKeySpec(bb, defaultAlgorithm);\n        SecretKey secKey = null;\n        SecretKeyFactory[] skF = createSKFac();\n        assertNotNull(\"SecretKeyFactory object were not created\", skF);\n        for (int i = 0; i < skF.length; i++) {\n            // This both serves to ensure that we're testing the default provider and forces\n            // the implementation to lock in the provider, even if later calls fail\n            assertEquals(defaultProvider, skF[i].getProvider());\n            try {\n                skF[i].generateSecret(null);\n                fail(\"generateSecret(null): InvalidKeySpecException must be thrown\");\n            } catch (InvalidKeySpecException e) {\n            }\n\n            secKey = skF[i].generateSecret(ks);\n            try {\n                skF[i].getKeySpec(null, null);\n                fail(\"getKeySpec(null,null): InvalidKeySpecException must be thrown\");\n            } catch (InvalidKeySpecException e) {\n            }\n            try {\n                skF[i].getKeySpec(null, ks.getClass());\n                fail(\"getKeySpec(null, Class): InvalidKeySpecException must be thrown\");\n            } catch (InvalidKeySpecException e) {\n            }\n            try {\n                skF[i].getKeySpec(secKey, null);\n                fail(\"getKeySpec(secKey, null): NullPointerException or InvalidKeySpecException must be thrown\");\n            } catch (InvalidKeySpecException e) {\n                // Expected\n            } catch (NullPointerException e) {\n                // Expected\n            }\n\n            try {\n                Class c;\n                if (defaultAlgorithm.equals(defaultAlgorithm2)) {\n                    c = DESedeKeySpec.class;\n                } else {\n                    c = DESKeySpec.class;\n                }\n                skF[i].getKeySpec(secKeySpec, c);\n                fail(\"getKeySpec(secKey, Class): InvalidKeySpecException must be thrown\");\n            } catch (InvalidKeySpecException e) {\n            }\n            rks = skF[i].getKeySpec(secKeySpec, ks.getClass());\n            if (defaultAlgorithm.equals(defaultAlgorithm1)) {\n                assertTrue(\"Incorrect getKeySpec() result 1\",\n                        rks instanceof DESedeKeySpec);\n            } else {\n                assertTrue(\"Incorrect getKeySpec() result 1\",\n                        rks instanceof DESKeySpec);\n            }\n\n            rks = skF[i].getKeySpec(secKey, ks.getClass());\n            if (defaultAlgorithm.equals(defaultAlgorithm1)) {\n                assertTrue(\"Incorrect getKeySpec() result 2\",\n                        rks instanceof DESedeKeySpec);\n            } else {\n                assertTrue(\"Incorrect getKeySpec() result 2\",\n                        rks instanceof DESKeySpec);\n            }\n        }\n    }\n\n    public void test_getAlgorithm() throws NoSuchAlgorithmException {\n        for (int i = 0; i < validValues.length; i++) {\n            SecretKeyFactory secKF = SecretKeyFactory\n                    .getInstance(validValues[i]);\n            assertEquals(\"Incorrect algorithm\", secKF.getAlgorithm(),\n                    validValues[i]);\n        }\n\n        Mock_SecretKeyFactory msf = new Mock_SecretKeyFactory(null, null, null);\n        assertNull(msf.getAlgorithm());\n    }\n\n    class Mock_SecretKeyFactory extends SecretKeyFactory{\n        protected Mock_SecretKeyFactory(SecretKeyFactorySpi arg0, Provider arg1, String arg2) {\n            super(arg0, arg1, arg2);\n        }\n    }\n\n    public void test_getProvider() throws NoSuchAlgorithmException {\n        for (int i = 0; i < validValues.length; i++) {\n            SecretKeyFactory secKF = SecretKeyFactory\n                    .getInstance(validValues[i]);\n            assertNotNull(secKF.getProvider());\n        }\n\n        Mock_SecretKeyFactory msf = new Mock_SecretKeyFactory(null, null, null);\n        assertNull(msf.getProvider());\n    }\n\n    public void test_translateKeyLjavax_crypto_SecretKey()\n            throws NoSuchAlgorithmException, InvalidKeyException {\n        KeyGenerator kg = null;\n        Key key = null;\n        SecretKeyFactory secKF = null;\n\n        for (int i = 0; i < validValues.length; i++) {\n            secKF = SecretKeyFactory\n                    .getInstance(validValues[i]);\n            assertNotNull(secKF.getProvider());\n            kg = KeyGenerator.getInstance(secKF.getAlgorithm());\n            kg.init(new SecureRandom());\n            key = kg.generateKey();\n\n            secKF.translateKey((SecretKey) key);\n        }\n        try {\n            secKF.translateKey(null);\n            fail(\"InvalidKeyException expected\");\n        } catch (InvalidKeyException e) {\n            //expected\n        }\n    }\n}", "item_id": 0, "repo": "lulululbj/android_9.0.0_r45", "file": "libcore/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/SecretKeyFactoryTest.java", "last_update_at": "2022-02-21T01:03:03+00:00", "question_id": "2f2a41b33dd9ba8e7c9ecdbb5190b5fc9a0c5d5f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SecretKeyFactoryTest extends TestCase {\n    public static final String srvSecretKeyFactory = \"SecretKeyFactory\";\n    private static String defaultAlgorithm1 = \"DESede\";\n    private static String defaultAlgorithm2 = \"DES\";\n    public static String defaultAlgorithm = null;\n    private static String defaultProviderName = null;\n    private static Provider defaultProvider = null;\n    private static final String[] invalidValues = SpiEngUtils.invalidValues;\n    public static final String[] validValues = new String[2];\n    private static boolean DEFSupported = false;\n    private static final String NotSupportMsg = \"Default algorithm is not supported\";\n    static {\n        defaultProvider = SpiEngUtils.isSupport(defaultAlgorithm1,\n                srvSecretKeyFactory);\n        DEFSupported = (defaultProvider != null);\n        if (DEFSupported) {\n            defaultAlgorithm = defaultAlgorithm1;\n            validValues[0] = defaultAlgorithm.toUpperCase();\n            validValues[1] = defaultAlgorithm.toLowerCase();\n            defaultProviderName = defaultProvider.getName();\n        } else {\n            defaultProvider = SpiEngUtils.isSupport(defaultAlgorithm2,\n                    srvSecretKeyFactory);\n            DEFSupported = (defaultProvider != null);\n            if (DEFSupported) {\n                defaultAlgorithm = defaultAlgorithm2;\n                validValues[0] = defaultAlgorithm.toUpperCase();\n                validValues[2] = defaultAlgorithm.toLowerCase();\n                defaultProviderName = defaultProvider.getName();\n            } else {\n                defaultAlgorithm = null;\n                defaultProviderName = null;\n                defaultProvider = null;\n            }\n        }\n    }\n    protected SecretKeyFactory[] createSKFac() {\n        if (!DEFSupported) {\n            fail(defaultAlgorithm + \" algorithm is not supported\");\n            return null;\n        }\n        SecretKeyFactory[] skF = new SecretKeyFactory[3];\n        try {\n            skF[0] = SecretKeyFactory.getInstance(defaultAlgorithm);\n            skF[1] = SecretKeyFactory.getInstance(defaultAlgorithm,\n                    defaultProvider);\n            skF[2] = SecretKeyFactory.getInstance(defaultAlgorithm,\n                    defaultProviderName);\n            return skF;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n    /**\n     * Test for <code>SecretKeyFactory</code> constructor\n     * Assertion: returns SecretKeyFactory object\n     */\n    public void testSecretKeyFactory01() throws NoSuchAlgorithmException,\n            InvalidKeySpecException, InvalidKeyException {\n        if (!DEFSupported) {\n            fail(NotSupportMsg);\n            return;\n        }\n        SecretKeyFactorySpi spi = new MySecretKeyFactorySpi();\n        SecretKeyFactory secKF = new mySecretKeyFactory(spi, defaultProvider,\n                defaultAlgorithm);\n        assertEquals(\"Incorrect algorithm\", secKF.getAlgorithm(),\n                defaultAlgorithm);\n        assertEquals(\"Incorrect provider\", secKF.getProvider(), defaultProvider);\n        assertNull(\"Incorrect result\", secKF.generateSecret(null));\n        assertNull(\"Incorrect result\", secKF.getKeySpec(null, null));\n        assertNull(\"Incorrect result\", secKF.translateKey(null));\n        secKF = new mySecretKeyFactory(null, null, null);\n        assertNull(\"Algorithm must be null\", secKF.getAlgorithm());\n        assertNull(\"Provider must be null\", secKF.getProvider());\n        try {\n            secKF.translateKey(null);\n            fail(\"NullPointerException must be thrown\");\n        } catch (NullPointerException e) {\n        }\n    }\n    /**\n     * Test for <code>getInstance(String algorithm)</code> method\n     * Assertions:\n     * throws NullPointerException when algorithm is null;\n     * throws NoSuchAlgorithmException when algorithm has invalid value\n     */\n    public void testSecretKeyFactory02() throws NoSuchAlgorithmException {\n        try {\n            SecretKeyFactory.getInstance(null);\n            fail(\"NullPointerException or NoSuchAlgorithmException should be thrown if algorithm is null\");\n        } catch (NullPointerException e) {\n        } catch (NoSuchAlgorithmException e) {\n        }\n        for (int i = 0; i < invalidValues.length; i++) {\n            try {\n                SecretKeyFactory.getInstance(invalidValues[i]);\n                fail(\"NoSuchAlgorithmException was not thrown as expected\");\n            } catch (NoSuchAlgorithmException e) {\n            }\n        }\n    }\n    /**\n     * Test for <code>getInstance(String algorithm)</code> method\n     * Assertion: returns SecretKeyObject\n     */\n    public void testSecretKeyFactory03() throws NoSuchAlgorithmException {\n        if (!DEFSupported) {\n            fail(NotSupportMsg);\n            return;\n        }\n        for (int i = 0; i < validValues.length; i++) {\n            SecretKeyFactory secKF = SecretKeyFactory\n                    .getInstance(validValues[i]);\n            assertEquals(\"Incorrect algorithm\", secKF.getAlgorithm(),\n                    validValues[i]);\n        }\n    }\n    /**\n     * Test for <code>getInstance(String algorithm, String provider)</code>\n     * method\n     * Assertion:\n     * throws NullPointerException when algorithm is null;\n     * throws NoSuchAlgorithmException when algorithm is invalid\n     */\n    public void testSecretKeyFactory04() throws NoSuchAlgorithmException,\n            NoSuchProviderException {\n        if (!DEFSupported) {\n            fail(NotSupportMsg);\n            return;\n        }\n        try {\n            SecretKeyFactory.getInstance(null, defaultProviderName);\n            fail(\"NullPointerException or NoSuchAlgorithmException should be thrown if algorithm is null\");\n        } catch (NullPointerException e) {\n        } catch (NoSuchAlgorithmException e) {\n        }\n        for (int i = 0; i < invalidValues.length; i++) {\n            try {\n                SecretKeyFactory.getInstance(invalidValues[i],\n                        defaultProviderName);\n                fail(\"NoSuchAlgorithmException was not thrown as expected (algorithm: \"\n                        .concat(invalidValues[i]).concat(\")\"));\n            } catch (NoSuchAlgorithmException e) {\n            }\n        }\n    }\n    /**\n     * Test for <code>getInstance(String algorithm, String provider)</code>\n     * method\n     * Assertion:\n     * throws IllegalArgumentException when provider is null or empty;\n     * throws NoSuchProviderException when provider has invalid value\n     */\n    public void testSecretKeyFactory05() throws NoSuchAlgorithmException,\n            NoSuchProviderException {\n        if (!DEFSupported) {\n            fail(NotSupportMsg);\n            return;\n        }\n        String prov = null;\n        for (int i = 0; i < validValues.length; i++) {\n            try {\n                SecretKeyFactory.getInstance(validValues[i], prov);\n                fail(\"IllegalArgumentException was not thrown as expected (algorithm: \"\n                        .concat(validValues[i]).concat(\" provider: null\"));\n            } catch (IllegalArgumentException e) {\n            }\n            try {\n                SecretKeyFactory.getInstance(validValues[i], \"\");\n                fail(\"IllegalArgumentException was not thrown as expected (algorithm: \"\n                        .concat(validValues[i]).concat(\" provider: empty\"));\n            } catch (IllegalArgumentException e) {\n            }\n            for (int j = 1; j < invalidValues.length; j++) {\n                try {\n                    SecretKeyFactory.getInstance(validValues[i],\n                            invalidValues[j]);\n                    fail(\"NoSuchProviderException was not thrown as expected (algorithm: \"\n                            .concat(validValues[i]).concat(\" provider: \")\n                            .concat(invalidValues[j]).concat(\")\"));\n                } catch (NoSuchProviderException e) {\n                }\n            }\n        }\n    }\n    /**\n     * Test for <code>getInstance(String algorithm, String provider)</code>\n     * method\n     * Assertion: returns SecretKeyFactory object\n     */\n    public void testSecretKeyFactory06() throws NoSuchProviderException,\n            NoSuchAlgorithmException {\n        if (!DEFSupported) {\n            fail(NotSupportMsg);\n            return;\n        }\n        for (int i = 0; i < validValues.length; i++) {\n            SecretKeyFactory secKF = SecretKeyFactory.getInstance(\n                    validValues[i], defaultProviderName);\n            assertEquals(\"Incorrect algorithm\", secKF.getAlgorithm(),\n                    validValues[i]);\n            assertEquals(\"Incorrect provider\", secKF.getProvider().getName(),\n                    defaultProviderName);\n        }\n    }\n    /**\n     * Test for <code>getInstance(String algorithm, Provider provider)</code>\n     * method\n     * Assertion: throws NullPointerException when algorithm is null;\n     * throws NoSuchAlgorithmException when algorithm is invalid\n     */\n    public void testSecretKeyFactory07() throws NoSuchAlgorithmException {\n        if (!DEFSupported) {\n            fail(NotSupportMsg);\n            return;\n        }\n        try {\n            SecretKeyFactory.getInstance(null, defaultProvider);\n            fail(\"NullPointerException or NoSuchAlgorithmException should be thrown if algorithm is null\");\n        } catch (NullPointerException e) {\n        } catch (NoSuchAlgorithmException e) {\n        }\n        for (int i = 0; i < invalidValues.length; i++) {\n            try {\n                SecretKeyFactory.getInstance(invalidValues[i], defaultProvider);\n                fail(\"NoSuchAlgorithmException was not thrown as expected (algorithm: \"\n                        .concat(invalidValues[i]).concat(\")\"));\n            } catch (NoSuchAlgorithmException e) {\n            }\n        }\n    }\n    /**\n     * Test for <code>getInstance(String algorithm, Provider provider)</code>\n     * method\n     * Assertion: throws IllegalArgumentException when provider is null\n     */\n    public void testSecretKeyFactory08() throws NoSuchAlgorithmException {\n        if (!DEFSupported) {\n            fail(NotSupportMsg);\n            return;\n        }\n        Provider prov = null;\n        for (int i = 0; i < validValues.length; i++) {\n            try {\n                SecretKeyFactory.getInstance(validValues[i], prov);\n                fail(\"IllegalArgumentException was not thrown as expected (provider is null, algorithm: \"\n                        .concat(validValues[i]).concat(\")\"));\n            } catch (IllegalArgumentException e) {\n            }\n        }\n    }\n    /**\n     * Test for <code>getInstance(String algorithm, Provider provider)</code>\n     * method\n     * Assertion: returns SecretKeyFactory object\n     */\n    public void testSecretKeyFactory09() throws NoSuchAlgorithmException {\n        if (!DEFSupported) {\n            fail(NotSupportMsg);\n            return;\n        }\n        for (int i = 0; i < validValues.length; i++) {\n            SecretKeyFactory secKF = SecretKeyFactory.getInstance(\n                    validValues[i], defaultProvider);\n            assertEquals(\"Incorrect algorithm\", secKF.getAlgorithm(),\n                    validValues[i]);\n            assertEquals(\"Incorrect provider\", secKF.getProvider(),\n                    defaultProvider);\n        }\n    }\n    /**\n     * Test for <code>generateSecret(KeySpec keySpec)</code> and\n     * <code>getKeySpec(SecretKey key, Class keySpec)\n     * methods\n     * Assertion:\n     * throw InvalidKeySpecException if parameter is inappropriate\n     */\n    public void testSecretKeyFactory10() throws InvalidKeyException,\n            InvalidKeySpecException {\n        if (!DEFSupported) {\n            fail(NotSupportMsg);\n            return;\n        }\n        byte[] bb = new byte[24];\n        KeySpec ks = (defaultAlgorithm.equals(defaultAlgorithm2) ? (KeySpec)new DESKeySpec(bb) :\n            (KeySpec)new DESedeKeySpec(bb));\n        KeySpec rks = null;\n        SecretKeySpec secKeySpec = new SecretKeySpec(bb, defaultAlgorithm);\n        SecretKey secKey = null;\n        SecretKeyFactory[] skF = createSKFac();\n        assertNotNull(\"SecretKeyFactory object were not created\", skF);\n        for (int i = 0; i < skF.length; i++) {\n            // This both serves to ensure that we're testing the default provider and forces\n            // the implementation to lock in the provider, even if later calls fail\n            assertEquals(defaultProvider, skF[i].getProvider());\n            try {\n                skF[i].generateSecret(null);\n                fail(\"generateSecret(null): InvalidKeySpecException must be thrown\");\n            } catch (InvalidKeySpecException e) {\n            }\n            secKey = skF[i].generateSecret(ks);\n            try {\n                skF[i].getKeySpec(null, null);\n                fail(\"getKeySpec(null,null): InvalidKeySpecException must be thrown\");\n            } catch (InvalidKeySpecException e) {\n            }\n            try {\n                skF[i].getKeySpec(null, ks.getClass());\n                fail(\"getKeySpec(null, Class): InvalidKeySpecException must be thrown\");\n            } catch (InvalidKeySpecException e) {\n            }\n            try {\n                skF[i].getKeySpec(secKey, null);\n                fail(\"getKeySpec(secKey, null): NullPointerException or InvalidKeySpecException must be thrown\");\n            } catch (InvalidKeySpecException e) {\n                // Expected\n            } catch (NullPointerException e) {\n                // Expected\n            }\n            try {\n                Class c;\n                if (defaultAlgorithm.equals(defaultAlgorithm2)) {\n                    c = DESedeKeySpec.class;\n                } else {\n                    c = DESKeySpec.class;\n                }\n                skF[i].getKeySpec(secKeySpec, c);\n                fail(\"getKeySpec(secKey, Class): InvalidKeySpecException must be thrown\");\n            } catch (InvalidKeySpecException e) {\n            }\n            rks = skF[i].getKeySpec(secKeySpec, ks.getClass());\n            if (defaultAlgorithm.equals(defaultAlgorithm1)) {\n                assertTrue(\"Incorrect getKeySpec() result 1\",\n                        rks instanceof DESedeKeySpec);\n            } else {\n                assertTrue(\"Incorrect getKeySpec() result 1\",\n                        rks instanceof DESKeySpec);\n            }\n            rks = skF[i].getKeySpec(secKey, ks.getClass());\n            if (defaultAlgorithm.equals(defaultAlgorithm1)) {\n                assertTrue(\"Incorrect getKeySpec() result 2\",\n                        rks instanceof DESedeKeySpec);\n            } else {\n                assertTrue(\"Incorrect getKeySpec() result 2\",\n                        rks instanceof DESKeySpec);\n            }\n        }\n    }\n    public void test_getAlgorithm() throws NoSuchAlgorithmException {\n        for (int i = 0; i < validValues.length; i++) {\n            SecretKeyFactory secKF = SecretKeyFactory\n                    .getInstance(validValues[i]);\n            assertEquals(\"Incorrect algorithm\", secKF.getAlgorithm(),\n                    validValues[i]);\n        }\n        Mock_SecretKeyFactory msf = new Mock_SecretKeyFactory(null, null, null);\n        assertNull(msf.getAlgorithm());\n    }\n    class Mock_SecretKeyFactory extends SecretKeyFactory{\n        protected Mock_SecretKeyFactory(SecretKeyFactorySpi arg0, Provider arg1, String arg2) {\n            super(arg0, arg1, arg2);\n        }\n    }\n    public void test_getProvider() throws NoSuchAlgorithmException {\n        for (int i = 0; i < validValues.length; i++) {\n            SecretKeyFactory secKF = SecretKeyFactory\n                    .getInstance(validValues[i]);\n            assertNotNull(secKF.getProvider());\n        }\n        Mock_SecretKeyFactory msf = new Mock_SecretKeyFactory(null, null, null);\n        assertNull(msf.getProvider());\n    }\n    public void test_translateKeyLjavax_crypto_SecretKey()\n            throws NoSuchAlgorithmException, InvalidKeyException {\n        KeyGenerator kg = null;\n        Key key = null;\n        SecretKeyFactory secKF = null;\n        for (int i = 0; i < validValues.length; i++) {\n            secKF = SecretKeyFactory\n                    .getInstance(validValues[i]);\n            assertNotNull(secKF.getProvider());\n            kg = KeyGenerator.getInstance(secKF.getAlgorithm());\n            kg.init(new SecureRandom());\n            key = kg.generateKey();\n            secKF.translateKey((SecretKey) key);\n        }\n        try {\n            secKF.translateKey(null);\n            fail(\"InvalidKeyException expected\");\n        } catch (InvalidKeyException e) {\n            //expected\n        }\n    }\n"]], "pred": {"ppl": 1.5599186420440674, "ppl_lower": 1.9243841171264648, "ppl/lowercase_ppl": -1.4722366420691286, "ppl/zlib": 0.0002037734497550874, "Min_5.0% Prob": 5.011865405475392, "Min_10.0% Prob": 3.382607905303731, "Min_20.0% Prob": 2.0718333144106116, "Min_30.0% Prob": 1.456692136751086, "Min_40.0% Prob": 1.1049413736317588, "Min_50.0% Prob": 0.8883579260507442, "Min_60.0% Prob": 0.7415747025436121}}
{"hexsha": "d9fde3935e0f4cf0e79cbc41426ba6d918af0902", "ext": "java", "lang": "Java", "content": "public class GraphSparqlStep extends BaseStep implements StepInterface {\n\n\tprivate static int MAX_ATTEMPTS = 4;\n\n\tpublic GraphSparqlStep(StepMeta stepMeta, StepDataInterface stepDataInterface, int copyNr, TransMeta transMeta,\n\t\t\tTrans trans) {\n\t\tsuper(stepMeta, stepDataInterface, copyNr, transMeta, trans);\n\t}\n\n\t/**\n\t * Metodo chamado para cada linha que entra no step.\n\t */\n\t// Rogers(Nov/2012): Correcao de bug na ordenacao dos campos da consulta\n\t// SPARQL\n\tpublic boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {\n\t\tGraphSparqlStepMeta meta = (GraphSparqlStepMeta) smi;\n\t\tGraphSparqlStepData data = (GraphSparqlStepData) sdi;\n\n\t\t// Obtem linha do fluxo de entrada\n\t\tfinal Object[] row = getRow();\n\n\t\tif (first) {\n\t\t\t// Executa apenas uma vez. Variavel first definida na superclasse\n\t\t\tfirst = false;\n\n\t\t\t// Obtem todas as colunas ate o step anterior.\n\t\t\t// Chamar apenas apos chamar getRow()\n\t\t\tRowMetaInterface rowMeta = getInputRowMeta(row != null);\n\t\t\tdata.outputRowMeta = rowMeta.clone();\n\n\t\t\t// Adiciona os metadados do step atual\n\t\t\tmeta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n\n\t\t\tdata.inputRowSize = rowMeta.size();\n\n\t\t\t// Obtem string de consulta e constroi o objeto consulta\n\t\t\tString queryStr = GraphSparqlStepUtils.toFullQueryString(meta.getPrefixes(), meta.getQueryString());\n\t\t\ttry {\n\t\t\t\tdata.originalQuery = QueryFactory.create(queryStr);\n\t\t\t} catch (QueryException e) {\n\t\t\t\t// Se consulta for invalida nao pode continuar\n\t\t\t\tthrow new KettleException(e);\n\t\t\t}\n\n\t\t\t// Se nao usar SAX o execSelect() nao funciona\n\t\t\tARQ.set(ARQ.useSAX, true);\n\n\t\t\t// Offset e Limit para Construct/select/describe quando limit nao\n\t\t\t// especificado\n\t\t\tif (!data.originalQuery.hasLimit() && (data.originalQuery.getQueryType() != Query.QueryTypeAsk)\n\t\t\t\t\t&& (data.originalQuery.getQueryType() != Query.QueryTypeDescribe)) {\n\t\t\t\t// Consulta eh quebrada em varias usando OFFSET e LIMIT\n\t\t\t\tdata.offset = data.originalQuery.hasOffset() ? data.originalQuery.getOffset() : 0;\n\t\t\t\tdata.limit = 1000;\n\t\t\t\tdata.runAtOnce = false;\n\t\t\t} else {\n\t\t\t\tdata.runAtOnce = true;\n\t\t\t}\n\n\t\t\tdata.remainingTries = MAX_ATTEMPTS;\n\n\t\t\treturn true;\n\t\t}\n\n\t\tQuery query = null;\n\t\tif (data.runAtOnce) {\n\t\t\t// Roda consulta num unico HTTP Request\n\t\t\tquery = data.originalQuery;\n\n\t\t\twhile (data.remainingTries > 0) {\n\t\t\t\t// Tenta executar consulta ate MAX_ATTEMPTS vezes\n\t\t\t\ttry {\n\t\t\t\t\trunQueryAndPutResults(query, meta, data, row);\n\n\t\t\t\t\tsetOutputDone();\n\t\t\t\t\treturn false; // Nao ha mais resultados, ie, processRow()\n\t\t\t\t\t\t\t\t\t// nao sera' chamado novamente\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\thandleError(e, MAX_ATTEMPTS - data.remainingTries + 1);\n\t\t\t\t}\n\n\t\t\t\tdata.remainingTries--;\n\t\t\t}\n\t\t} else {\n\t\t\t// Cria consulta que representa o bloco atual\n\t\t\tquery = data.originalQuery.cloneQuery();\n\t\t\tquery.setOffset(data.offset);\n\t\t\tquery.setLimit(data.limit);\n\n\t\t\twhile (data.remainingTries > 0) { // Tenta executar este bloco ate'\n\t\t\t\t\t\t\t\t\t\t\t\t// MAX_ATTEMPTS vezes\n\t\t\t\ttry {\n\t\t\t\t\tint numRows = runQueryAndPutResults(query, meta, data, row);\n\n\t\t\t\t\tif (numRows > 0) { // Este bloco de consulta rodou\n\t\t\t\t\t\tdata.offset += data.limit;\n\t\t\t\t\t\tdata.remainingTries = MAX_ATTEMPTS;\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else { // Nao ha mais resultados, ie, processRow() nao\n\t\t\t\t\t\t\t\t// sera'\n\t\t\t\t\t\t\t\t// chamado novamente\n\t\t\t\t\t\tsetOutputDone();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\thandleError(e, MAX_ATTEMPTS - data.remainingTries + 1);\n\t\t\t\t}\n\n\t\t\t\tdata.remainingTries--;\n\t\t\t}\n\t\t}\n\n\t\t// Nao funfou!\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"Todas as tentativas de executar a consulta falharam. \");\n\t\tsb.append(\"Verifique conex\u00e3o de rede e o SPARQL Endpoint.\\n\");\n\t\tsb.append(\"Endpoint: \");\n\t\tsb.append(meta.getEndpointUri());\n\t\tsb.append('\\n');\n\t\tsb.append(\"Grafo padr\u00e3o: \");\n\t\tsb.append(meta.getDefaultGraph());\n\t\tsb.append('\\n');\n\t\tsb.append(\"Consulta:\\n\");\n\t\tsb.append(query.toString());\n\t\tsb.append('\\n');\n\n\t\tthrow new KettleException(sb.toString());\n\t}\n\n\tprivate RowMetaInterface getInputRowMeta(boolean hasInputRow) {\n\n\t\tRowMetaInterface rowMeta = null;\n\t\tif (hasInputRow)\n\t\t\trowMeta = getInputRowMeta();\n\t\telse\n\t\t\trowMeta = new RowMeta();\n\n\t\treturn rowMeta;\n\t}\n\n\tprivate void handleError(Throwable e, int attempts) {\n\n\t\ttry {\n\t\t\tString msg = String.format(\"Falha ao executar consulta (tentativa %d de %d): \", attempts, MAX_ATTEMPTS);\n\n\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\t\tbaos.write(msg.getBytes());\n\n\t\t\te.printStackTrace(new PrintWriter(baos, true));\n\n\t\t\tlong sleepTime = (long) (500 * Math.pow(2, attempts));\n\t\t\tmsg = String.format(\"Tentando novamente em %d milissegundos...\", sleepTime);\n\t\t\tbaos.write(msg.getBytes());\n\n\t\t\tlog.logBasic(baos.toString());\n\n\t\t\tThread.sleep(sleepTime);\n\n\t\t} catch (IOException e1) {\n\t\t\te1.printStackTrace();\n\t\t} catch (InterruptedException e2) {\n\t\t\te2.printStackTrace();\n\t\t}\n\t}\n\n\t// Rogers(Nov/2012): Correcao de bug na ordenacao dos campos da consulta\n\t// SPARQL\n\tprivate int runQueryAndPutResults(Query query, GraphSparqlStepMeta meta, GraphSparqlStepData data, Object[] row)\n\t\t\tthrows KettleStepException {\n\t\tint numPutRows = 0;\n\t\tQueryExecution qexec = GraphSparqlStepUtils.createQueryExecution(query, meta.getEndpointUri(),\n\t\t\t\tmeta.getDefaultGraph());\n\n\t\ttry {\n\t\t\tModel model = null;\n\t\t\tswitch (query.getQueryType()) {\n\t\t\tcase Query.QueryTypeAsk:\n\t\t\t\tBoolean result = qexec.execAsk();\n\t\t\t\tincrementLinesInput();\n\t\t\t\tputRow(data.outputRowMeta, RowDataUtil.addValueData(row, data.inputRowSize, result));\n\t\t\t\tbreak;\n\n\t\t\tcase Query.QueryTypeConstruct:\n\t\t\t\tmodel = qexec.execConstruct();\n\t\t\t\tResIterator resourceSet = model.listSubjects();\n\t\t\t\tint count = 0;\n\t\t\t\twhile (resourceSet.hasNext()) {\n\t\t\t\t\tResource resource = resourceSet.nextResource();\n\t\t\t\t\t// gets a subgraph\n\t\t\t\t\tModel subjectItemGraph = createSubjectItemGraph(resource, model);\n\n\t\t\t\t\t// send a subGraph to the next step\n\t\t\t\t\tincrementLinesInput();\n\t\t\t\t\tputRow(data.outputRowMeta, RowDataUtil.addValueData(row, data.inputRowSize, subjectItemGraph));\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tif (count == 0) {\n\t\t\t\t\tincrementLinesInput();\n\t\t\t\t\tputRow(data.outputRowMeta, RowDataUtil.addValueData(row, data.inputRowSize, model));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase Query.QueryTypeDescribe:\n\t\t\t\tmodel = qexec.execDescribe();\n\t\t\t\tResIterator resourceSetD = model.listSubjects();\n\t\t\t\tint countD = 0;\n\t\t\t\twhile (resourceSetD.hasNext()) {\n\t\t\t\t\tResource resource = resourceSetD.nextResource();\n\t\t\t\t\t// gets a subgraph\n\t\t\t\t\tModel subjectItemGraph = createSubjectItemGraph(resource, model);\n\n\t\t\t\t\t// send a subGraph to the next step\n\t\t\t\t\tincrementLinesInput();\n\t\t\t\t\tputRow(data.outputRowMeta, RowDataUtil.addValueData(row, data.inputRowSize, subjectItemGraph));\n\t\t\t\t\tcountD++;\n\t\t\t\t}\n\t\t\t\tif (countD == 0) {\n\t\t\t\t\tincrementLinesInput();\n\t\t\t\t\tputRow(data.outputRowMeta, RowDataUtil.addValueData(row, data.inputRowSize, model));\n\t\t\t\t}\n\n\t\t\t\t// incrementLinesInput();\n\t\t\t\t// putRow(data.outputRowMeta, RowDataUtil.addValueData(row,\n\t\t\t\t// data.inputRowSize, model));\n\t\t\t\tbreak;\n\n\t\t\tcase Query.QueryTypeSelect:\n\t\t\t\tResultSet resultSet = qexec.execSelect();\n\t\t\t\tmodel = resultSet.getResourceModel();\n\n\t\t\t\tObject extra = (model != null) ? model : resultSet;\n\t\t\t\tincrementLinesInput();\n\t\t\t\tputRow(data.outputRowMeta, RowDataUtil.addValueData(row, data.inputRowSize, extra));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} finally {\n\t\t\tqexec.close();\n\t\t}\n\n\t\treturn numPutRows;\n\t}\n\n\t// Creates a subGraph with a Resource and its Properties\n\tprivate Model createSubjectItemGraph(Resource resource, Model model) {\n\t\tModel subjectItemGraph = null;\n\t\tSelector s = new SimpleSelector(resource, (Property) null, (RDFNode) null);\n\t\tsubjectItemGraph = model.query(s);\n\t\t// StmtIterator i = model.listStatements(s);\n\n\t\treturn subjectItemGraph;\n\t}\n}", "item_id": 0, "repo": "Grupo-GRECO/ETL4FAIR", "file": "plugins/GraphSparqlEndpoint/src/main/java/br/ufrj/ppgi/greco/kettle/GraphSparqlStep.java", "last_update_at": "2022-02-28T08:28:32+00:00", "question_id": "d9fde3935e0f4cf0e79cbc41426ba6d918af0902_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GraphSparqlStep extends BaseStep implements StepInterface {\n\tprivate static int MAX_ATTEMPTS = 4;\n\tpublic GraphSparqlStep(StepMeta stepMeta, StepDataInterface stepDataInterface, int copyNr, TransMeta transMeta,\n\t\t\tTrans trans) {\n\t\tsuper(stepMeta, stepDataInterface, copyNr, transMeta, trans);\n\t}\n\t/**\n\t * Metodo chamado para cada linha que entra no step.\n\t */\n\t// Rogers(Nov/2012): Correcao de bug na ordenacao dos campos da consulta\n\t// SPARQL\n\tpublic boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {\n\t\tGraphSparqlStepMeta meta = (GraphSparqlStepMeta) smi;\n\t\tGraphSparqlStepData data = (GraphSparqlStepData) sdi;\n\t\t// Obtem linha do fluxo de entrada\n\t\tfinal Object[] row = getRow();\n\t\tif (first) {\n\t\t\t// Executa apenas uma vez. Variavel first definida na superclasse\n\t\t\tfirst = false;\n\t\t\t// Obtem todas as colunas ate o step anterior.\n\t\t\t// Chamar apenas apos chamar getRow()\n\t\t\tRowMetaInterface rowMeta = getInputRowMeta(row != null);\n\t\t\tdata.outputRowMeta = rowMeta.clone();\n\t\t\t// Adiciona os metadados do step atual\n\t\t\tmeta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n\t\t\tdata.inputRowSize = rowMeta.size();\n\t\t\t// Obtem string de consulta e constroi o objeto consulta\n\t\t\tString queryStr = GraphSparqlStepUtils.toFullQueryString(meta.getPrefixes(), meta.getQueryString());\n\t\t\ttry {\n\t\t\t\tdata.originalQuery = QueryFactory.create(queryStr);\n\t\t\t} catch (QueryException e) {\n\t\t\t\t// Se consulta for invalida nao pode continuar\n\t\t\t\tthrow new KettleException(e);\n\t\t\t}\n\t\t\t// Se nao usar SAX o execSelect() nao funciona\n\t\t\tARQ.set(ARQ.useSAX, true);\n\t\t\t// Offset e Limit para Construct/select/describe quando limit nao\n\t\t\t// especificado\n\t\t\tif (!data.originalQuery.hasLimit() && (data.originalQuery.getQueryType() != Query.QueryTypeAsk)\n\t\t\t\t\t&& (data.originalQuery.getQueryType() != Query.QueryTypeDescribe)) {\n\t\t\t\t// Consulta eh quebrada em varias usando OFFSET e LIMIT\n\t\t\t\tdata.offset = data.originalQuery.hasOffset() ? data.originalQuery.getOffset() : 0;\n\t\t\t\tdata.limit = 1000;\n\t\t\t\tdata.runAtOnce = false;\n\t\t\t} else {\n\t\t\t\tdata.runAtOnce = true;\n\t\t\t}\n\t\t\tdata.remainingTries = MAX_ATTEMPTS;\n\t\t\treturn true;\n\t\t}\n\t\tQuery query = null;\n\t\tif (data.runAtOnce) {\n\t\t\t// Roda consulta num unico HTTP Request\n\t\t\tquery = data.originalQuery;\n\t\t\twhile (data.remainingTries > 0) {\n\t\t\t\t// Tenta executar consulta ate MAX_ATTEMPTS vezes\n\t\t\t\ttry {\n\t\t\t\t\trunQueryAndPutResults(query, meta, data, row);\n\t\t\t\t\tsetOutputDone();\n\t\t\t\t\treturn false; // Nao ha mais resultados, ie, processRow()\n\t\t\t\t\t\t\t\t\t// nao sera' chamado novamente\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\thandleError(e, MAX_ATTEMPTS - data.remainingTries + 1);\n\t\t\t\t}\n\t\t\t\tdata.remainingTries--;\n\t\t\t}\n\t\t} else {\n\t\t\t// Cria consulta que representa o bloco atual\n\t\t\tquery = data.originalQuery.cloneQuery();\n\t\t\tquery.setOffset(data.offset);\n\t\t\tquery.setLimit(data.limit);\n\t\t\twhile (data.remainingTries > 0) { // Tenta executar este bloco ate'\n\t\t\t\t\t\t\t\t\t\t\t\t// MAX_ATTEMPTS vezes\n\t\t\t\ttry {\n\t\t\t\t\tint numRows = runQueryAndPutResults(query, meta, data, row);\n\t\t\t\t\tif (numRows > 0) { // Este bloco de consulta rodou\n\t\t\t\t\t\tdata.offset += data.limit;\n\t\t\t\t\t\tdata.remainingTries = MAX_ATTEMPTS;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else { // Nao ha mais resultados, ie, processRow() nao\n\t\t\t\t\t\t\t\t// sera'\n\t\t\t\t\t\t\t\t// chamado novamente\n\t\t\t\t\t\tsetOutputDone();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\thandleError(e, MAX_ATTEMPTS - data.remainingTries + 1);\n\t\t\t\t}\n\t\t\t\tdata.remainingTries--;\n\t\t\t}\n\t\t}\n\t\t// Nao funfou!\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"Todas as tentativas de executar a consulta falharam. \");\n\t\tsb.append(\"Verifique conex\u00e3o de rede e o SPARQL Endpoint.\\n\");\n\t\tsb.append(\"Endpoint: \");\n\t\tsb.append(meta.getEndpointUri());\n\t\tsb.append('\\n');\n\t\tsb.append(\"Grafo padr\u00e3o: \");\n\t\tsb.append(meta.getDefaultGraph());\n\t\tsb.append('\\n');\n\t\tsb.append(\"Consulta:\\n\");\n\t\tsb.append(query.toString());\n\t\tsb.append('\\n');\n\t\tthrow new KettleException(sb.toString());\n\t}\n\tprivate RowMetaInterface getInputRowMeta(boolean hasInputRow) {\n\t\tRowMetaInterface rowMeta = null;\n\t\tif (hasInputRow)\n\t\t\trowMeta = getInputRowMeta();\n\t\telse\n\t\t\trowMeta = new RowMeta();\n\t\treturn rowMeta;\n\t}\n\tprivate void handleError(Throwable e, int attempts) {\n\t\ttry {\n\t\t\tString msg = String.format(\"Falha ao executar consulta (tentativa %d de %d): \", attempts, MAX_ATTEMPTS);\n\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\t\tbaos.write(msg.getBytes());\n\t\t\te.printStackTrace(new PrintWriter(baos, true));\n\t\t\tlong sleepTime = (long) (500 * Math.pow(2, attempts));\n\t\t\tmsg = String.format(\"Tentando novamente em %d milissegundos...\", sleepTime);\n\t\t\tbaos.write(msg.getBytes());\n\t\t\tlog.logBasic(baos.toString());\n\t\t\tThread.sleep(sleepTime);\n\t\t} catch (IOException e1) {\n\t\t\te1.printStackTrace();\n\t\t} catch (InterruptedException e2) {\n\t\t\te2.printStackTrace();\n\t\t}\n\t}\n\t// Rogers(Nov/2012): Correcao de bug na ordenacao dos campos da consulta\n\t// SPARQL\n\tprivate int runQueryAndPutResults(Query query, GraphSparqlStepMeta meta, GraphSparqlStepData data, Object[] row)\n\t\t\tthrows KettleStepException {\n\t\tint numPutRows = 0;\n\t\tQueryExecution qexec = GraphSparqlStepUtils.createQueryExecution(query, meta.getEndpointUri(),\n\t\t\t\tmeta.getDefaultGraph());\n\t\ttry {\n\t\t\tModel model = null;\n\t\t\tswitch (query.getQueryType()) {\n\t\t\tcase Query.QueryTypeAsk:\n\t\t\t\tBoolean result = qexec.execAsk();\n\t\t\t\tincrementLinesInput();\n\t\t\t\tputRow(data.outputRowMeta, RowDataUtil.addValueData(row, data.inputRowSize, result));\n\t\t\t\tbreak;\n\t\t\tcase Query.QueryTypeConstruct:\n\t\t\t\tmodel = qexec.execConstruct();\n\t\t\t\tResIterator resourceSet = model.listSubjects();\n\t\t\t\tint count = 0;\n\t\t\t\twhile (resourceSet.hasNext()) {\n\t\t\t\t\tResource resource = resourceSet.nextResource();\n\t\t\t\t\t// gets a subgraph\n\t\t\t\t\tModel subjectItemGraph = createSubjectItemGraph(resource, model);\n\t\t\t\t\t// send a subGraph to the next step\n\t\t\t\t\tincrementLinesInput();\n\t\t\t\t\tputRow(data.outputRowMeta, RowDataUtil.addValueData(row, data.inputRowSize, subjectItemGraph));\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tif (count == 0) {\n\t\t\t\t\tincrementLinesInput();\n\t\t\t\t\tputRow(data.outputRowMeta, RowDataUtil.addValueData(row, data.inputRowSize, model));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase Query.QueryTypeDescribe:\n\t\t\t\tmodel = qexec.execDescribe();\n\t\t\t\tResIterator resourceSetD = model.listSubjects();\n\t\t\t\tint countD = 0;\n\t\t\t\twhile (resourceSetD.hasNext()) {\n\t\t\t\t\tResource resource = resourceSetD.nextResource();\n\t\t\t\t\t// gets a subgraph\n\t\t\t\t\tModel subjectItemGraph = createSubjectItemGraph(resource, model);\n\t\t\t\t\t// send a subGraph to the next step\n\t\t\t\t\tincrementLinesInput();\n\t\t\t\t\tputRow(data.outputRowMeta, RowDataUtil.addValueData(row, data.inputRowSize, subjectItemGraph));\n\t\t\t\t\tcountD++;\n\t\t\t\t}\n\t\t\t\tif (countD == 0) {\n\t\t\t\t\tincrementLinesInput();\n\t\t\t\t\tputRow(data.outputRowMeta, RowDataUtil.addValueData(row, data.inputRowSize, model));\n\t\t\t\t}\n\t\t\t\t// incrementLinesInput();\n\t\t\t\t// putRow(data.outputRowMeta, RowDataUtil.addValueData(row,\n\t\t\t\t// data.inputRowSize, model));\n\t\t\t\tbreak;\n\t\t\tcase Query.QueryTypeSelect:\n\t\t\t\tResultSet resultSet = qexec.execSelect();\n\t\t\t\tmodel = resultSet.getResourceModel();\n\t\t\t\tObject extra = (model != null) ? model : resultSet;\n\t\t\t\tincrementLinesInput();\n\t\t\t\tputRow(data.outputRowMeta, RowDataUtil.addValueData(row, data.inputRowSize, extra));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} finally {\n\t\t\tqexec.close();\n\t\t}\n\t\treturn numPutRows;\n\t}\n\t// Creates a subGraph with a Resource and its Properties\n\tprivate Model createSubjectItemGraph(Resource resource, Model model) {\n\t\tModel subjectItemGraph = null;\n\t\tSelector s = new SimpleSelector(resource, (Property) null, (RDFNode) null);\n\t\tsubjectItemGraph = model.query(s);\n\t\t// StmtIterator i = model.listStatements(s);\n\t\treturn subjectItemGraph;\n\t}\n"]], "pred": {"ppl": 2.371856689453125, "ppl_lower": 3.0278706550598145, "ppl/lowercase_ppl": -1.282730314841833, "ppl/zlib": 0.0003571848890448302, "Min_5.0% Prob": 7.188437452503279, "Min_10.0% Prob": 5.546301385935615, "Min_20.0% Prob": 3.8084835994477366, "Min_30.0% Prob": 2.781738989493426, "Min_40.0% Prob": 2.1409894270244028, "Min_50.0% Prob": 1.7250895873514056, "Min_60.0% Prob": 1.4405041883097958}}
{"hexsha": "c898f2f8fa136058c0edc90363a3298bad61e7b9", "ext": "java", "lang": "Java", "content": "public class FireRisk {\n\n    /**\n     * Enum to choose input variable\n     */\n    public enum From {\n        tpac_T_uw_d, L_d_theta, a_b_theta\n    };\n\n    /**\n     * Enum to choose objective function.\n     */\n    public enum To {\n        F, Fv, Fh, Fsqr\n    }\n\n    /**\n     * Create optimization problem minimizing Fv on (l,d,theta) inputs.\n     *\n     * @return OptimizationProblem\n     */\n    public static OptimizationProblem createOptimizationProblemLdMinFv() {\n        return createOptimizationProblem(From.L_d_theta, To.Fv, false);\n    }\n\n    /**\n     * Create optimization problem maximizing Fv on (tpac,T,uw,d) inputs.\n     *\n     * @return OptimizationProblem\n     */\n    public static OptimizationProblem createOptimizationProblemTempMaxFv() {\n        return createOptimizationProblem(From.tpac_T_uw_d, To.Fv, true);\n    }\n\n    /**\n     * Create optimization problem\n     *\n     * @param from choose input variables\n     * @param to choose objective function\n     * @param neg true to negate objective function\n     * @return OptimizationProblem\n     */\n    public static OptimizationProblem createOptimizationProblem(From from, To to, boolean neg) {\n        String[] box;\n        switch (from) {\n            case tpac_T_uw_d:\n                box = new String[]{\n                    \"[50.0,170.0]\", // tpac\n                    \"[254.0,299.0]\", // T\n                    \"[2.3,9.0]\", // uw\n                    \"[15.2,34.8]\" // d\n                };\n                break;\n            case L_d_theta:\n                box = new String[]{\n                    \"[19.1,55.2]\", // L\n                    \"[15.2,34.8]\", // d\n                    \"[0,1.18]\" // theta\n                };\n                break;\n            case a_b_theta:\n                box = new String[]{\n                    \"[382/348,1104/152]\", // a = 2*L/d\n                    \"[2000/348,2000/152]\", // b = 2*X/d\n                    \"[0,1.18]\" // theta\n                };\n                break;\n            default:\n                throw new AssertionError();\n        }\n        return new OptimizationProblem(createObjective(from, to, neg), box);\n    }\n\n    /**\n     * Create objective function\n     *\n     * @param from choose input variables\n     * @param to choose objective function\n     * @param neg true to negate objective function\n     * @return objective function\n     */\n    public static Expression createObjective(From from, To to, boolean neg) {\n        Subclass fr = new Subclass(from);\n        Expression objective;\n        switch (to) {\n            case F:\n                objective = fr.F;\n                break;\n            case Fv:\n                objective = fr.Fv();\n                break;\n            case Fh:\n                objective = fr.Fh();\n                break;\n            case Fsqr:\n                objective = fr.Fsqr();\n                break;\n            default:\n                throw new AssertionError();\n        }\n        return neg ? objective.neg().name(\"neg_\" + objective.name()) : objective;\n    }\n\n    final CodeList cl;\n    final From from;\n\n    FireRisk(From from) {\n        this.from = from;\n        switch (from) {\n            case tpac_T_uw_d:\n                cl = CodeList.create(\"tpac\", \"T\", \"uw\", \"d\");\n                break;\n            case L_d_theta:\n                cl = CodeList.create(\"L\", \"d\", \"theta\");\n                break;\n            case a_b_theta:\n                cl = CodeList.create(\"a\", \"b\", \"theta\");\n                break;\n            default:\n                throw new AssertionError();\n        }\n    }\n\n    boolean from(From from) {\n        return this.from.ordinal() <= from.ordinal();\n    }\n\n    Expression n(String literal) {\n        return cl.lit(literal);\n    }\n\n    public static class Subclass extends FireRisk {\n\n        Subclass(From from) {\n            super(from);\n        }\n\n        // Constants\n        public Expression m_prime = n(\"0.06\").name(\"m_prime\");\n        public Expression g = n(\"9.81\").name(\"g\");\n        public Expression Tnom = n(\"288.15\").name(\"Tnom\");\n        public Expression ro_v_nom = n(\"1.225\").name(\"ro_v_nom\");\n        public Expression X = n(\"100\").name(\"X\");\n        public Expression V_mu = n(\"22.413\").name(\"V_mu\");\n        public Expression k_factor = n(\"1.216\").div(n(\"0.67668\")).name(\"k_factor\");\n        public Expression c1Pi = cl.pi().recip().name(\"c1Pi\");\n\n        public Expression tpac = from(From.tpac_T_uw_d) ? cl.getInp(0) : null;\n        public Expression T = from(From.tpac_T_uw_d) ? cl.getInp(1) : null;\n        public Expression uw = from(From.tpac_T_uw_d) ? cl.getInp(2) : null;\n        public Expression d = from(From.tpac_T_uw_d)\n                ? cl.getInp(3)\n                : from(From.L_d_theta)\n                ? cl.getInp(1)\n                : null;\n\n        /*0*/\n        public Expression k = from(From.tpac_T_uw_d)\n                ? k_factor.mul(tpac.rootn(3)).name(\"k\")\n                : null;\n\n        public Expression mu0 = from(From.tpac_T_uw_d)\n                ? n(\"7\").mul(k).sub(n(\"21.5\")).name(\"mu0\")\n                : null;\n        public Expression mu1 = from(From.tpac_T_uw_d)\n                ? n(\"0.76\").sub(n(\"0.04\").mul(k)).name(\"mu1\")\n                : null;\n        public Expression mu2 = from(From.tpac_T_uw_d)\n                ? n(\"0.0003\").mul(k).sub(n(\"0.00245\")).name(\"mu2\")\n                : null;\n        /*1*/\n        public Expression mu = from(From.tpac_T_uw_d)\n                ? mu0.add(mu1.mul(tpac)).add(mu2.mul(tpac.sqr())).name(\"mu\")\n                : null;\n\n        /*2*/\n        public Expression ro_p = from(From.tpac_T_uw_d)\n                ? mu.div(V_mu.mul(n(\"1\").add(n(\"0.00367\").mul(tpac)))).name(\"ro_p\")\n                : null;\n\n        public Expression u_star_arg = from(From.tpac_T_uw_d)\n                ? ro_p.div(m_prime.mul(g).mul(d))\n                : null;\n        /*3*/\n        public Expression u_star = from(From.tpac_T_uw_d)\n                ? uw.mul(u_star_arg.rootn(3)).max(n(\"1\")).name(\"u_star\")\n                : null;\n\n        /*4*/\n        public Expression ro_v = from(From.tpac_T_uw_d)\n                ? Tnom.mul(ro_v_nom).div(T).name(\"ro_v\")\n                : null;\n\n        /*5*/\n        public Expression L = from(From.tpac_T_uw_d)\n                ? n(\"55\")\n                .mul(m_prime.pow(n(\"0.67\")))\n                .div(g.pow(n(\"0.335\")))\n                .mul(d.pow(n(\"0.665\")))\n                .mul(u_star.pow(n(\"0.21\")))\n                .div(ro_v.pow(n(\"0.67\")))\n                .name(\"L\")\n                : from(From.L_d_theta)\n                ? cl.getInp(0)\n                : null;\n\n        /*6*/\n        public Expression theta = from(From.tpac_T_uw_d)\n                ? u_star.sqrt().recip().acos().name(\"theta\")\n                : from(From.L_d_theta)\n                ? cl.getInp(2)\n                : from(From.a_b_theta)\n                ? cl.getInp(2)\n                : null;\n\n        /*7*/\n        public Expression a = from(From.L_d_theta)\n                ? L.mul(n(\"2\")).div(d).name(\"a\")\n                : from(From.a_b_theta)\n                ? cl.getInp(0)\n                : null;\n\n        /*8*/\n        public Expression b = from(From.L_d_theta)\n                ? n(\"2\").mul(X).div(d).name(\"b\")\n                : from(From.a_b_theta)\n                ? cl.getInp(1)\n                : null;\n\n        public Expression bp1 = b.add(n(\"1\")).name(\"bp1\");\n        public Expression bm1 = b.sub(n(\"1\")).name(\"bm1\");\n\n        public Expression sinth = theta.sin().name(\"sinth\");\n        public Expression costh = theta.cos().name(\"costh\");\n\n        public Expression A_arg = a.sqr()\n                .add(bp1.sqr())\n                .sub(n(\"2\").mul(a.mul(bp1).mul(sinth)))\n                .name(\"A_arg\");\n        /*9*/\n        public Expression A = A_arg.sqrt().name(\"A\");\n\n        public Expression B_arg = a.sqr()\n                .add(bm1.sqr())\n                .sub(n(\"2\").mul(a.mul(bm1).mul(sinth)))\n                .name(\"B_arg\");\n        /*10*/\n        public Expression B = B_arg.sqrt().name(\"B\");\n\n        public Expression C_arg = n(\"1\").add((b.sqr().sub(n(\"1\"))).mul(costh.sqr())).name(\"C_arg\");\n        /*11*/\n        public Expression C = C_arg.sqrt().name(\"C\");\n\n        public Expression D_arg = from(From.L_d_theta)\n                ? n(\"2\").mul(X).sub(d)\n                .div(n(\"2\").mul(X).add(d))\n                .name(\"D_arg\")\n                : from(From.a_b_theta)\n                ? bm1.div(bp1).sqrt()\n                : null;\n        /*12*/\n        public Expression D = D_arg.sqrt().name(\"D\");\n\n        /*13*/\n        public Expression E = from(From.L_d_theta)\n                ? L.mul(costh)\n                .div(X.sub(L.mul(sinth)))\n                .name(\"E\")\n                : from(From.a_b_theta)\n                ? a.mul(costh).div(b.sub(a.mul(sinth)))\n                : null;\n\n        /*14*/\n        public Expression F_arg = b.sqr().sub(n(\"1\")).name(\"F_arg\");\n        public Expression F = F_arg.sqrt().name(\"F\");\n\n        public Expression ab = a.mul(b).name(\"ab\");\n        public Expression AB = A.mul(B).name(\"AB\");\n\n        public Expression S1arg = ab.sub(F.sqr().mul(sinth))\n                .div(F.mul(C)).name(\"S1arg\");\n        public Expression S1 = S1arg.atan().name(\"S1\");\n        public Expression S2arg = F.mul(sinth).div(C).name(\"S2arg\");\n        public Expression S2 = S2arg.atan().name(\"S2\");\n        public Expression S = S1.add(S2).name(\"S\");\n\n        public Expression ADB = A.mul(D).div(B).name(\"ADB\");\n        public Expression atanADB = ADB.atan().name(\"atanADB\");\n\n        public Expression Fv() {\n            Expression abFv = a.sqr()\n                    .add(b.add(n(\"1\")).sqr())\n                    .sub(n(\"2\").mul(b).mul(n(\"1\").add(a.mul(sinth))))\n                    .name(\"abFv\");\n            Expression Fv1 = E.neg().mul(D.atan()).name(\"Fv1\");\n            Expression Fv2 = E.mul(abFv).div(AB).mul(atanADB).name(\"Fv2\");\n            Expression Fv3 = costh.div(C).mul(S).name(\"Fv3\");\n            Expression Fv = cl.pi().recip().mul(Fv1.add(Fv2.add(Fv3))).name(\"Fv\");\n            return Fv;\n        }\n\n        public Expression Fh() {\n            Expression abFh = a.sqr()\n                    .add(b.add(n(\"1\")).sqr())\n                    .sub(n(\"2\").mul(b.add(n(\"1\")).add(ab.mul(sinth))))\n                    .name(\"abFh\");\n            Expression Fh1 = D.recip().atan().name(\"Fh1\");\n            Expression Fh2 = sinth.div(C).mul(S).name(\"Fh2\");\n            Expression Fh3 = abFh.div(AB).mul(atanADB).name(\"Fh3\");\n            Expression Fh = c1Pi.mul(Fh1.add(Fh2).sub(Fh3)).name(\"Fh\");\n            return Fh;\n        }\n\n        public Expression Fsqr() {\n            return Fv().sqr()\n                    .add(Fh().sqr())\n                    .name(\"Fsqr\");\n        }\n\n    }\n}", "item_id": 0, "repo": "DmitryGerasimenko/jinterval", "file": "jinterval-expression/src/main/java/net/java/jinterval/expression/example/FireRisk.java", "last_update_at": "2022-02-01T12:23:49+00:00", "question_id": "c898f2f8fa136058c0edc90363a3298bad61e7b9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FireRisk {\n    /**\n     * Enum to choose input variable\n     */\n    public enum From {\n        tpac_T_uw_d, L_d_theta, a_b_theta\n    };\n    /**\n     * Enum to choose objective function.\n     */\n    public enum To {\n        F, Fv, Fh, Fsqr\n    }\n    /**\n     * Create optimization problem minimizing Fv on (l,d,theta) inputs.\n     *\n     * @return OptimizationProblem\n     */\n    public static OptimizationProblem createOptimizationProblemLdMinFv() {\n        return createOptimizationProblem(From.L_d_theta, To.Fv, false);\n    }\n    /**\n     * Create optimization problem maximizing Fv on (tpac,T,uw,d) inputs.\n     *\n     * @return OptimizationProblem\n     */\n    public static OptimizationProblem createOptimizationProblemTempMaxFv() {\n        return createOptimizationProblem(From.tpac_T_uw_d, To.Fv, true);\n    }\n    /**\n     * Create optimization problem\n     *\n     * @param from choose input variables\n     * @param to choose objective function\n     * @param neg true to negate objective function\n     * @return OptimizationProblem\n     */\n    public static OptimizationProblem createOptimizationProblem(From from, To to, boolean neg) {\n        String[] box;\n        switch (from) {\n            case tpac_T_uw_d:\n                box = new String[]{\n                    \"[50.0,170.0]\", // tpac\n                    \"[254.0,299.0]\", // T\n                    \"[2.3,9.0]\", // uw\n                    \"[15.2,34.8]\" // d\n                };\n                break;\n            case L_d_theta:\n                box = new String[]{\n                    \"[19.1,55.2]\", // L\n                    \"[15.2,34.8]\", // d\n                    \"[0,1.18]\" // theta\n                };\n                break;\n            case a_b_theta:\n                box = new String[]{\n                    \"[382/348,1104/152]\", // a = 2*L/d\n                    \"[2000/348,2000/152]\", // b = 2*X/d\n                    \"[0,1.18]\" // theta\n                };\n                break;\n            default:\n                throw new AssertionError();\n        }\n        return new OptimizationProblem(createObjective(from, to, neg), box);\n    }\n    /**\n     * Create objective function\n     *\n     * @param from choose input variables\n     * @param to choose objective function\n     * @param neg true to negate objective function\n     * @return objective function\n     */\n    public static Expression createObjective(From from, To to, boolean neg) {\n        Subclass fr = new Subclass(from);\n        Expression objective;\n        switch (to) {\n            case F:\n                objective = fr.F;\n                break;\n            case Fv:\n                objective = fr.Fv();\n                break;\n            case Fh:\n                objective = fr.Fh();\n                break;\n            case Fsqr:\n                objective = fr.Fsqr();\n                break;\n            default:\n                throw new AssertionError();\n        }\n        return neg ? objective.neg().name(\"neg_\" + objective.name()) : objective;\n    }\n    final CodeList cl;\n    final From from;\n    FireRisk(From from) {\n        this.from = from;\n        switch (from) {\n            case tpac_T_uw_d:\n                cl = CodeList.create(\"tpac\", \"T\", \"uw\", \"d\");\n                break;\n            case L_d_theta:\n                cl = CodeList.create(\"L\", \"d\", \"theta\");\n                break;\n            case a_b_theta:\n                cl = CodeList.create(\"a\", \"b\", \"theta\");\n                break;\n            default:\n                throw new AssertionError();\n        }\n    }\n    boolean from(From from) {\n        return this.from.ordinal() <= from.ordinal();\n    }\n    Expression n(String literal) {\n        return cl.lit(literal);\n    }\n    public static class Subclass extends FireRisk {\n        Subclass(From from) {\n            super(from);\n        }\n        // Constants\n        public Expression m_prime = n(\"0.06\").name(\"m_prime\");\n        public Expression g = n(\"9.81\").name(\"g\");\n        public Expression Tnom = n(\"288.15\").name(\"Tnom\");\n        public Expression ro_v_nom = n(\"1.225\").name(\"ro_v_nom\");\n        public Expression X = n(\"100\").name(\"X\");\n        public Expression V_mu = n(\"22.413\").name(\"V_mu\");\n        public Expression k_factor = n(\"1.216\").div(n(\"0.67668\")).name(\"k_factor\");\n        public Expression c1Pi = cl.pi().recip().name(\"c1Pi\");\n        public Expression tpac = from(From.tpac_T_uw_d) ? cl.getInp(0) : null;\n        public Expression T = from(From.tpac_T_uw_d) ? cl.getInp(1) : null;\n        public Expression uw = from(From.tpac_T_uw_d) ? cl.getInp(2) : null;\n        public Expression d = from(From.tpac_T_uw_d)\n                ? cl.getInp(3)\n                : from(From.L_d_theta)\n                ? cl.getInp(1)\n                : null;\n        /*0*/\n        public Expression k = from(From.tpac_T_uw_d)\n                ? k_factor.mul(tpac.rootn(3)).name(\"k\")\n                : null;\n        public Expression mu0 = from(From.tpac_T_uw_d)\n                ? n(\"7\").mul(k).sub(n(\"21.5\")).name(\"mu0\")\n                : null;\n        public Expression mu1 = from(From.tpac_T_uw_d)\n                ? n(\"0.76\").sub(n(\"0.04\").mul(k)).name(\"mu1\")\n                : null;\n        public Expression mu2 = from(From.tpac_T_uw_d)\n                ? n(\"0.0003\").mul(k).sub(n(\"0.00245\")).name(\"mu2\")\n                : null;\n        /*1*/\n        public Expression mu = from(From.tpac_T_uw_d)\n                ? mu0.add(mu1.mul(tpac)).add(mu2.mul(tpac.sqr())).name(\"mu\")\n                : null;\n        /*2*/\n        public Expression ro_p = from(From.tpac_T_uw_d)\n                ? mu.div(V_mu.mul(n(\"1\").add(n(\"0.00367\").mul(tpac)))).name(\"ro_p\")\n                : null;\n        public Expression u_star_arg = from(From.tpac_T_uw_d)\n                ? ro_p.div(m_prime.mul(g).mul(d))\n                : null;\n        /*3*/\n        public Expression u_star = from(From.tpac_T_uw_d)\n                ? uw.mul(u_star_arg.rootn(3)).max(n(\"1\")).name(\"u_star\")\n                : null;\n        /*4*/\n        public Expression ro_v = from(From.tpac_T_uw_d)\n                ? Tnom.mul(ro_v_nom).div(T).name(\"ro_v\")\n                : null;\n        /*5*/\n        public Expression L = from(From.tpac_T_uw_d)\n                ? n(\"55\")\n                .mul(m_prime.pow(n(\"0.67\")))\n                .div(g.pow(n(\"0.335\")))\n                .mul(d.pow(n(\"0.665\")))\n                .mul(u_star.pow(n(\"0.21\")))\n                .div(ro_v.pow(n(\"0.67\")))\n                .name(\"L\")\n                : from(From.L_d_theta)\n                ? cl.getInp(0)\n                : null;\n        /*6*/\n        public Expression theta = from(From.tpac_T_uw_d)\n                ? u_star.sqrt().recip().acos().name(\"theta\")\n                : from(From.L_d_theta)\n                ? cl.getInp(2)\n                : from(From.a_b_theta)\n                ? cl.getInp(2)\n                : null;\n        /*7*/\n        public Expression a = from(From.L_d_theta)\n                ? L.mul(n(\"2\")).div(d).name(\"a\")\n                : from(From.a_b_theta)\n                ? cl.getInp(0)\n                : null;\n        /*8*/\n        public Expression b = from(From.L_d_theta)\n                ? n(\"2\").mul(X).div(d).name(\"b\")\n                : from(From.a_b_theta)\n                ? cl.getInp(1)\n                : null;\n        public Expression bp1 = b.add(n(\"1\")).name(\"bp1\");\n        public Expression bm1 = b.sub(n(\"1\")).name(\"bm1\");\n        public Expression sinth = theta.sin().name(\"sinth\");\n        public Expression costh = theta.cos().name(\"costh\");\n        public Expression A_arg = a.sqr()\n                .add(bp1.sqr())\n                .sub(n(\"2\").mul(a.mul(bp1).mul(sinth)))\n                .name(\"A_arg\");\n        /*9*/\n        public Expression A = A_arg.sqrt().name(\"A\");\n        public Expression B_arg = a.sqr()\n                .add(bm1.sqr())\n                .sub(n(\"2\").mul(a.mul(bm1).mul(sinth)))\n                .name(\"B_arg\");\n        /*10*/\n        public Expression B = B_arg.sqrt().name(\"B\");\n        public Expression C_arg = n(\"1\").add((b.sqr().sub(n(\"1\"))).mul(costh.sqr())).name(\"C_arg\");\n        /*11*/\n        public Expression C = C_arg.sqrt().name(\"C\");\n        public Expression D_arg = from(From.L_d_theta)\n                ? n(\"2\").mul(X).sub(d)\n                .div(n(\"2\").mul(X).add(d))\n                .name(\"D_arg\")\n                : from(From.a_b_theta)\n                ? bm1.div(bp1).sqrt()\n                : null;\n        /*12*/\n        public Expression D = D_arg.sqrt().name(\"D\");\n        /*13*/\n        public Expression E = from(From.L_d_theta)\n                ? L.mul(costh)\n                .div(X.sub(L.mul(sinth)))\n                .name(\"E\")\n                : from(From.a_b_theta)\n                ? a.mul(costh).div(b.sub(a.mul(sinth)))\n                : null;\n        /*14*/\n        public Expression F_arg = b.sqr().sub(n(\"1\")).name(\"F_arg\");\n        public Expression F = F_arg.sqrt().name(\"F\");\n        public Expression ab = a.mul(b).name(\"ab\");\n        public Expression AB = A.mul(B).name(\"AB\");\n        public Expression S1arg = ab.sub(F.sqr().mul(sinth))\n                .div(F.mul(C)).name(\"S1arg\");\n        public Expression S1 = S1arg.atan().name(\"S1\");\n        public Expression S2arg = F.mul(sinth).div(C).name(\"S2arg\");\n        public Expression S2 = S2arg.atan().name(\"S2\");\n        public Expression S = S1.add(S2).name(\"S\");\n        public Expression ADB = A.mul(D).div(B).name(\"ADB\");\n        public Expression atanADB = ADB.atan().name(\"atanADB\");\n        public Expression Fv() {\n            Expression abFv = a.sqr()\n                    .add(b.add(n(\"1\")).sqr())\n                    .sub(n(\"2\").mul(b).mul(n(\"1\").add(a.mul(sinth))))\n                    .name(\"abFv\");\n            Expression Fv1 = E.neg().mul(D.atan()).name(\"Fv1\");\n            Expression Fv2 = E.mul(abFv).div(AB).mul(atanADB).name(\"Fv2\");\n            Expression Fv3 = costh.div(C).mul(S).name(\"Fv3\");\n            Expression Fv = cl.pi().recip().mul(Fv1.add(Fv2.add(Fv3))).name(\"Fv\");\n            return Fv;\n        }\n        public Expression Fh() {\n            Expression abFh = a.sqr()\n                    .add(b.add(n(\"1\")).sqr())\n                    .sub(n(\"2\").mul(b.add(n(\"1\")).add(ab.mul(sinth))))\n                    .name(\"abFh\");\n            Expression Fh1 = D.recip().atan().name(\"Fh1\");\n            Expression Fh2 = sinth.div(C).mul(S).name(\"Fh2\");\n            Expression Fh3 = abFh.div(AB).mul(atanADB).name(\"Fh3\");\n            Expression Fh = c1Pi.mul(Fh1.add(Fh2).sub(Fh3)).name(\"Fh\");\n            return Fh;\n        }\n        public Expression Fsqr() {\n            return Fv().sqr()\n                    .add(Fh().sqr())\n                    .name(\"Fsqr\");\n        }\n    }\n"]], "pred": {"ppl": 2.0409979820251465, "ppl_lower": 2.1163344383239746, "ppl/lowercase_ppl": -1.0508055543160073, "ppl/zlib": 0.0003386041267719627, "Min_5.0% Prob": 7.206235913669362, "Min_10.0% Prob": 5.179939622972526, "Min_20.0% Prob": 3.336855307805772, "Min_30.0% Prob": 2.3497583484824967, "Min_40.0% Prob": 1.7766083244753497, "Min_50.0% Prob": 1.425983389434924, "Min_60.0% Prob": 1.1900174917651685}}
{"hexsha": "4e5f33b9e9cb24ff6bd84bceab4e3030a436a5a6", "ext": "java", "lang": "Java", "content": "final class BackupRequestExecutor<R> extends PolicyExecutor<BackupRequest<R>> {\n\n    BackupRequestExecutor(final BackupRequest<R> policy, final AbstractExecution execution) {\n        super(policy, execution);\n    }\n\n    @Override\n    protected Supplier<CompletableFuture<ExecutionResult>> supplyAsync(\n            final Supplier<CompletableFuture<ExecutionResult>> supplier,\n            final Scheduler scheduler,\n            final FailsafeFuture<Object> future) {\n\n        return () -> {\n            final CompletableFuture<ExecutionResult> original = supplier.get();\n            final CompletableFuture<ExecutionResult> backup = new CompletableFuture<>();\n\n            final Future<?> scheduledBackup = delay(scheduler, backup(supplier, backup));\n\n            original.whenComplete(cancel(scheduledBackup));\n            backup.whenComplete(cancel(original));\n\n            return anyOf(original, backup);\n        };\n    }\n\n    private Callable<CompletableFuture<ExecutionResult>> backup(\n            final Supplier<CompletableFuture<ExecutionResult>> supplier,\n            final CompletableFuture<ExecutionResult> target) {\n\n        return () -> supplier.get().whenComplete(forwardTo(target));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private <T> ScheduledFuture<T> delay(\n            final Scheduler scheduler,\n            final Callable<T> callable) {\n\n        final long delay = policy.getDelay();\n        final TimeUnit unit = policy.getUnit();\n        return (ScheduledFuture<T>) scheduler.schedule(callable, delay, unit);\n    }\n\n    private <T> BiConsumer<T, Throwable> cancel(final Future<?> future) {\n        return (result, throwable) -> future.cancel(true);\n    }\n\n    @SafeVarargs\n    private final <T> CompletableFuture<T> anyOf(final CompletableFuture<? extends T>... futures) {\n        final CompletableFuture<T> any = new CompletableFuture<>();\n\n        for (final CompletableFuture<? extends T> future : futures) {\n            future.whenComplete(forwardTo(any));\n        }\n\n        return any;\n    }\n\n}", "item_id": 0, "repo": "abelph/riptide", "file": "riptide-failsafe/src/main/java/org/zalando/riptide/failsafe/BackupRequestExecutor.java", "last_update_at": "2022-03-04T00:29:49+00:00", "question_id": "4e5f33b9e9cb24ff6bd84bceab4e3030a436a5a6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["final class BackupRequestExecutor<R> extends PolicyExecutor<BackupRequest<R>> {\n    BackupRequestExecutor(final BackupRequest<R> policy, final AbstractExecution execution) {\n        super(policy, execution);\n    }\n    @Override\n    protected Supplier<CompletableFuture<ExecutionResult>> supplyAsync(\n            final Supplier<CompletableFuture<ExecutionResult>> supplier,\n            final Scheduler scheduler,\n            final FailsafeFuture<Object> future) {\n        return () -> {\n            final CompletableFuture<ExecutionResult> original = supplier.get();\n            final CompletableFuture<ExecutionResult> backup = new CompletableFuture<>();\n            final Future<?> scheduledBackup = delay(scheduler, backup(supplier, backup));\n            original.whenComplete(cancel(scheduledBackup));\n            backup.whenComplete(cancel(original));\n            return anyOf(original, backup);\n        };\n    }\n    private Callable<CompletableFuture<ExecutionResult>> backup(\n            final Supplier<CompletableFuture<ExecutionResult>> supplier,\n            final CompletableFuture<ExecutionResult> target) {\n        return () -> supplier.get().whenComplete(forwardTo(target));\n    }\n    @SuppressWarnings(\"unchecked\")\n    private <T> ScheduledFuture<T> delay(\n            final Scheduler scheduler,\n            final Callable<T> callable) {\n        final long delay = policy.getDelay();\n        final TimeUnit unit = policy.getUnit();\n        return (ScheduledFuture<T>) scheduler.schedule(callable, delay, unit);\n    }\n    private <T> BiConsumer<T, Throwable> cancel(final Future<?> future) {\n        return (result, throwable) -> future.cancel(true);\n    }\n    @SafeVarargs\n    private final <T> CompletableFuture<T> anyOf(final CompletableFuture<? extends T>... futures) {\n        final CompletableFuture<T> any = new CompletableFuture<>();\n        for (final CompletableFuture<? extends T> future : futures) {\n            future.whenComplete(forwardTo(any));\n        }\n        return any;\n    }\n"]], "pred": {"ppl": 1.8841629028320312, "ppl_lower": 2.144991636276245, "ppl/lowercase_ppl": -1.2046651347470252, "ppl/zlib": 0.0010522984034676338, "Min_5.0% Prob": 5.964737938000606, "Min_10.0% Prob": 4.348057013291579, "Min_20.0% Prob": 2.8295043315206256, "Min_30.0% Prob": 2.040444098695924, "Min_40.0% Prob": 1.5682778832330524, "Min_50.0% Prob": 1.2629800463645635, "Min_60.0% Prob": 1.0575320502371774}}
{"hexsha": "de9ea4d9a00e1739e43cde4f77164ce2cd2a48c6", "ext": "java", "lang": "Java", "content": "@Service\n@Named(\"isis.runtimeservices.InteractionServiceDefault\")\n@Priority(PriorityPrecedence.MIDPOINT)\n@Qualifier(\"Default\")\n@Log4j2\npublic class InteractionServiceDefault\nimplements\n    InteractionService,\n    InteractionLayerTracker {\n\n    @Inject AuthenticationManager authenticationManager;\n    @Inject MetamodelEventService runtimeEventService;\n    @Inject SpecificationLoader specificationLoader;\n    @Inject ServiceInjector serviceInjector;\n\n    @Inject InteractionAwareTransactionalBoundaryHandler txBoundaryHandler;\n    @Inject ClockService clockService;\n    @Inject CommandPublisher commandPublisher;\n    @Inject List<TransactionBoundaryAware> transactionBoundaryAwareBeans;\n    @Inject ConfigurableBeanFactory beanFactory;\n\n    private InteractionScopeLifecycleHandler interactionScopeLifecycleHandler;\n\n    public InteractionServiceDefault() {\n    }\n\n    @PostConstruct\n    public void initIsisInteractionScopeSupport() {\n        this.interactionScopeLifecycleHandler = InteractionScopeBeanFactoryPostProcessor.lookupScope(beanFactory);\n    }\n\n    //@PostConstruct .. too early, needs services to be provisioned first\n    @EventListener\n    public void init(final ContextRefreshedEvent event) {\n\n        requires(authenticationManager, \"authenticationManager\");\n\n        log.info(\"Initialising Isis System\");\n        log.info(\"working directory: {}\", new File(\".\").getAbsolutePath());\n\n        runtimeEventService.fireBeforeMetamodelLoading();\n\n        val taskList = _ConcurrentTaskList.named(\"IsisInteractionFactoryDefault Init\")\n                .addRunnable(\"SpecificationLoader::createMetaModel\", specificationLoader::createMetaModel)\n                .addRunnable(\"ChangesDtoUtils::init\", ChangesDtoUtils::init)\n                .addRunnable(\"InteractionDtoUtils::init\", InteractionDtoUtils::init)\n                .addRunnable(\"CommandDtoUtils::init\", CommandDtoUtils::init)\n                ;\n\n        taskList.submit(_ConcurrentContext.forkJoin());\n        taskList.await();\n\n        { // log any validation failures, experimental code however, not sure how to best propagate failures\n            val validationResult = specificationLoader.getOrAssessValidationResult();\n            if(validationResult.getNumberOfFailures()==0) {\n                log.info(\"Validation PASSED\");\n            } else {\n                log.error(\"### Validation FAILED, failure count: {}\", validationResult.getNumberOfFailures());\n                validationResult.forEach(failure->{\n                    log.error(\"# \" + failure.getMessage());\n                });\n                //throw _Exceptions.unrecoverable(\"Validation FAILED\");\n            }\n        }\n\n        runtimeEventService.fireAfterMetamodelLoaded();\n\n    }\n\n    private final ThreadLocal<Stack<InteractionLayer>> interactionLayerStack =\n            ThreadLocal.withInitial(Stack::new);\n\n    @Override\n    public int getInteractionLayerCount() {\n        return interactionLayerStack.get().size();\n    }\n\n    @Override\n    public InteractionLayer openInteraction() {\n        return currentInteractionLayer()\n                // or else create an anonymous authentication layer\n                .orElseGet(()->openInteraction(InteractionContextFactory.anonymous()));\n    }\n\n    @Override\n    public InteractionLayer openInteraction(\n            final @NonNull InteractionContext interactionContextToUse) {\n\n        val isisInteraction = getOrCreateIsisInteraction();\n\n        // check whether we should reuse any current authenticationLayer,\n        // that is, if current authentication and authToUse are equal\n\n        val reuseCurrentLayer = currentInteractionContext()\n                .map(currentInteractionContext -> Objects.equals(currentInteractionContext, interactionContextToUse))\n                .orElse(false);\n\n        if(reuseCurrentLayer) {\n            // we are done, just return the stack's top\n            return interactionLayerStack.get().peek();\n        }\n\n        val interactionLayer = new InteractionLayer(isisInteraction, interactionContextToUse);\n\n        interactionLayerStack.get().push(interactionLayer);\n\n        if(isAtTopLevel()) {\n        \tpostInteractionOpened(isisInteraction);\n        }\n\n        if(log.isDebugEnabled()) {\n            log.debug(\"new interaction layer created (conversation-id={}, total-layers-on-stack={}, {})\",\n                    interactionId.get(),\n                    interactionLayerStack.get().size(),\n                    _Probe.currentThreadId());\n        }\n\n        if(XrayUi.isXrayEnabled()) {\n            _Xray.newInteractionLayer(interactionLayerStack.get());\n        }\n\n        return interactionLayer;\n    }\n\n    private IsisInteraction getOrCreateIsisInteraction() {\n\n        final Stack<InteractionLayer> interactionLayers = interactionLayerStack.get();\n        return interactionLayers.isEmpty()\n    \t\t\t? new IsisInteraction(UUID.randomUUID())\n\t\t\t\t: _Casts.uncheckedCast(interactionLayers.firstElement().getInteraction());\n    }\n\n    @Override\n    public void closeInteractionLayers() {\n        log.debug(\"about to close the interaction stack (conversation-id={}, total-layers-on-stack={}, {})\",\n                interactionId.get(),\n                interactionLayerStack.get().size(),\n                _Probe.currentThreadId());\n\n        closeInteractionLayerStackDownToStackSize(0);\n    }\n\n\t@Override\n    public Optional<InteractionLayer> currentInteractionLayer() {\n    \tval stack = interactionLayerStack.get();\n    \treturn stack.isEmpty()\n    \t        ? Optional.empty()\n                : Optional.of(stack.lastElement());\n    }\n\n    @Override\n    public boolean isInInteraction() {\n        return !interactionLayerStack.get().isEmpty();\n    }\n\n    // -- AUTHENTICATED EXECUTION\n\n    @Override\n    @SneakyThrows\n    public <R> R call(\n            final @NonNull InteractionContext interactionContext,\n            final @NonNull Callable<R> callable) {\n\n        final int stackSizeWhenEntering = interactionLayerStack.get().size();\n        openInteraction(interactionContext);\n\n        try {\n            serviceInjector.injectServicesInto(callable);\n            return callable.call();\n        } finally {\n            closeInteractionLayerStackDownToStackSize(stackSizeWhenEntering);\n        }\n    }\n\n    @Override\n    @SneakyThrows\n    public void run(\n            final @NonNull InteractionContext interactionContext,\n            final @NonNull ThrowingRunnable runnable) {\n\n        final int stackSizeWhenEntering = interactionLayerStack.get().size();\n        openInteraction(interactionContext);\n\n        try {\n            serviceInjector.injectServicesInto(runnable);\n            runnable.run();\n        } finally {\n            closeInteractionLayerStackDownToStackSize(stackSizeWhenEntering);\n        }\n\n    }\n\n    // -- ANONYMOUS EXECUTION\n\n    @Override\n    @SneakyThrows\n    public <R> R callAnonymous(@NonNull final Callable<R> callable) {\n        if(isInInteraction()) {\n            serviceInjector.injectServicesInto(callable);\n            return callable.call(); // reuse existing session\n        }\n        return call(InteractionContextFactory.anonymous(), callable);\n    }\n\n    /**\n     * Variant of {@link #callAnonymous(Callable)} that takes a runnable.\n     * @param runnable\n     */\n    @Override\n    @SneakyThrows\n    public void runAnonymous(@NonNull final ThrowingRunnable runnable) {\n        if(isInInteraction()) {\n            serviceInjector.injectServicesInto(runnable);\n            runnable.run(); // reuse existing session\n            return;\n        }\n        run(InteractionContextFactory.anonymous(), runnable);\n    }\n\n    // -- CONVERSATION ID\n\n    private final ThreadLocal<UUID> interactionId = ThreadLocal.withInitial(()->null);\n\n    @Override\n    public Optional<UUID> getInteractionId() {\n        return Optional.ofNullable(interactionId.get());\n    }\n\n    // -- HELPER\n\n    private boolean isAtTopLevel() {\n    \treturn interactionLayerStack.get().size()==1;\n    }\n\n    private void postInteractionOpened(final IsisInteraction interaction) {\n        interactionId.set(interaction.getInteractionId());\n        transactionBoundaryAwareBeans.forEach(bean->bean.beforeEnteringTransactionalBoundary(interaction));\n        txBoundaryHandler.onOpen(interaction);\n        val isSynchronizationActive = TransactionSynchronizationManager.isSynchronizationActive();\n        transactionBoundaryAwareBeans.forEach(bean->bean.afterEnteringTransactionalBoundary(interaction, isSynchronizationActive));\n        interactionScopeLifecycleHandler.onTopLevelInteractionOpened();\n    }\n\n    private void preInteractionClosed(final IsisInteraction interaction) {\n        completeAndPublishCurrentCommand();\n        val isSynchronizationActive = TransactionSynchronizationManager.isSynchronizationActive();\n        transactionBoundaryAwareBeans.forEach(bean->bean.beforeLeavingTransactionalBoundary(interaction, isSynchronizationActive));\n        txBoundaryHandler.onClose(interaction);\n        transactionBoundaryAwareBeans.forEach(bean->bean.afterLeavingTransactionalBoundary(interaction));\n        interactionScopeLifecycleHandler.onTopLevelInteractionPreDestroy(); // cleanup the InteractionScope (Spring scope)\n        interactionScopeLifecycleHandler.onTopLevelInteractionClosed(); // cleanup the InteractionScope (Spring scope)\n        interaction.close(); // do this last\n    }\n\n    private void closeInteractionLayerStackDownToStackSize(final int downToStackSize) {\n\n        log.debug(\"about to close authenication stack down to size {} (conversation-id={}, total-sessions-on-stack={}, {})\",\n                downToStackSize,\n                interactionId.get(),\n                interactionLayerStack.get().size(),\n                _Probe.currentThreadId());\n\n        val stack = interactionLayerStack.get();\n        while(stack.size()>downToStackSize) {\n        \tif(isAtTopLevel()) {\n        \t\t// keep the stack unmodified yet, to allow for callbacks to properly operate\n        \t\tpreInteractionClosed(_Casts.uncheckedCast(stack.peek().getInteraction()));\n        \t}\n        \t_Xray.closeInteractionLayer(stack);\n            stack.pop();\n        }\n        if(downToStackSize == 0) {\n            // cleanup thread-local\n            interactionLayerStack.remove();\n            interactionId.remove();\n        }\n    }\n\n    private IsisInteraction getInternalInteractionElseFail() {\n        val interaction = currentInteractionElseFail();\n        if(interaction instanceof IsisInteraction) {\n            return (IsisInteraction) interaction;\n        }\n        throw _Exceptions.unrecoverableFormatted(\"the framework does not recognice \"\n                + \"this implementation of an Interaction: %s\", interaction.getClass().getName());\n    }\n\n    // -- HELPER - COMMAND COMPLETION\n\n    private void completeAndPublishCurrentCommand() {\n\n        val interaction = getInternalInteractionElseFail();\n        val command = interaction.getCommand();\n\n        if(command.getStartedAt() != null && command.getCompletedAt() == null) {\n            // the guard is in case we're here as the result of a redirect following a previous exception;just ignore.\n\n            val priorInteractionExecution = interaction.getPriorExecution();\n            final Timestamp completedAt =\n                    priorInteractionExecution != null\n                    ?\n                        // copy over from the most recent (which will be the top-level) interaction\n                        priorInteractionExecution.getCompletedAt()\n                    :\n                        // this could arise as the result of calling SessionManagementService#nextSession within an action\n                        // the best we can do is to use the current time\n\n                        // REVIEW: as for the interaction object, it is left somewhat high-n-dry.\n                         clockService.getClock().nowAsJavaSqlTimestamp();\n\n            command.updater().setCompletedAt(completedAt);\n        }\n\n        commandPublisher.complete(command);\n\n        interaction.clear();\n    }\n\n}", "item_id": 0, "repo": "mwhesse/isis", "file": "core/runtimeservices/src/main/java/org/apache/isis/core/runtimeservices/session/InteractionServiceDefault.java", "last_update_at": "2022-03-31T13:45:59+00:00", "question_id": "de9ea4d9a00e1739e43cde4f77164ce2cd2a48c6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\n@Named(\"isis.runtimeservices.InteractionServiceDefault\")\n@Priority(PriorityPrecedence.MIDPOINT)\n@Qualifier(\"Default\")\n@Log4j2\npublic class InteractionServiceDefault\nimplements\n    InteractionService,\n    InteractionLayerTracker {\n    @Inject AuthenticationManager authenticationManager;\n    @Inject MetamodelEventService runtimeEventService;\n    @Inject SpecificationLoader specificationLoader;\n    @Inject ServiceInjector serviceInjector;\n    @Inject InteractionAwareTransactionalBoundaryHandler txBoundaryHandler;\n    @Inject ClockService clockService;\n    @Inject CommandPublisher commandPublisher;\n    @Inject List<TransactionBoundaryAware> transactionBoundaryAwareBeans;\n    @Inject ConfigurableBeanFactory beanFactory;\n    private InteractionScopeLifecycleHandler interactionScopeLifecycleHandler;\n    public InteractionServiceDefault() {\n    }\n    @PostConstruct\n    public void initIsisInteractionScopeSupport() {\n        this.interactionScopeLifecycleHandler = InteractionScopeBeanFactoryPostProcessor.lookupScope(beanFactory);\n    }\n    //@PostConstruct .. too early, needs services to be provisioned first\n    @EventListener\n    public void init(final ContextRefreshedEvent event) {\n        requires(authenticationManager, \"authenticationManager\");\n        log.info(\"Initialising Isis System\");\n        log.info(\"working directory: {}\", new File(\".\").getAbsolutePath());\n        runtimeEventService.fireBeforeMetamodelLoading();\n        val taskList = _ConcurrentTaskList.named(\"IsisInteractionFactoryDefault Init\")\n                .addRunnable(\"SpecificationLoader::createMetaModel\", specificationLoader::createMetaModel)\n                .addRunnable(\"ChangesDtoUtils::init\", ChangesDtoUtils::init)\n                .addRunnable(\"InteractionDtoUtils::init\", InteractionDtoUtils::init)\n                .addRunnable(\"CommandDtoUtils::init\", CommandDtoUtils::init)\n                ;\n        taskList.submit(_ConcurrentContext.forkJoin());\n        taskList.await();\n        { // log any validation failures, experimental code however, not sure how to best propagate failures\n            val validationResult = specificationLoader.getOrAssessValidationResult();\n            if(validationResult.getNumberOfFailures()==0) {\n                log.info(\"Validation PASSED\");\n            } else {\n                log.error(\"### Validation FAILED, failure count: {}\", validationResult.getNumberOfFailures());\n                validationResult.forEach(failure->{\n                    log.error(\"# \" + failure.getMessage());\n                });\n                //throw _Exceptions.unrecoverable(\"Validation FAILED\");\n            }\n        }\n        runtimeEventService.fireAfterMetamodelLoaded();\n    }\n    private final ThreadLocal<Stack<InteractionLayer>> interactionLayerStack =\n            ThreadLocal.withInitial(Stack::new);\n    @Override\n    public int getInteractionLayerCount() {\n        return interactionLayerStack.get().size();\n    }\n    @Override\n    public InteractionLayer openInteraction() {\n        return currentInteractionLayer()\n                // or else create an anonymous authentication layer\n                .orElseGet(()->openInteraction(InteractionContextFactory.anonymous()));\n    }\n    @Override\n    public InteractionLayer openInteraction(\n            final @NonNull InteractionContext interactionContextToUse) {\n        val isisInteraction = getOrCreateIsisInteraction();\n        // check whether we should reuse any current authenticationLayer,\n        // that is, if current authentication and authToUse are equal\n        val reuseCurrentLayer = currentInteractionContext()\n                .map(currentInteractionContext -> Objects.equals(currentInteractionContext, interactionContextToUse))\n                .orElse(false);\n        if(reuseCurrentLayer) {\n            // we are done, just return the stack's top\n            return interactionLayerStack.get().peek();\n        }\n        val interactionLayer = new InteractionLayer(isisInteraction, interactionContextToUse);\n        interactionLayerStack.get().push(interactionLayer);\n        if(isAtTopLevel()) {\n        \tpostInteractionOpened(isisInteraction);\n        }\n        if(log.isDebugEnabled()) {\n            log.debug(\"new interaction layer created (conversation-id={}, total-layers-on-stack={}, {})\",\n                    interactionId.get(),\n                    interactionLayerStack.get().size(),\n                    _Probe.currentThreadId());\n        }\n        if(XrayUi.isXrayEnabled()) {\n            _Xray.newInteractionLayer(interactionLayerStack.get());\n        }\n        return interactionLayer;\n    }\n    private IsisInteraction getOrCreateIsisInteraction() {\n        final Stack<InteractionLayer> interactionLayers = interactionLayerStack.get();\n        return interactionLayers.isEmpty()\n    \t\t\t? new IsisInteraction(UUID.randomUUID())\n\t\t\t\t: _Casts.uncheckedCast(interactionLayers.firstElement().getInteraction());\n    }\n    @Override\n    public void closeInteractionLayers() {\n        log.debug(\"about to close the interaction stack (conversation-id={}, total-layers-on-stack={}, {})\",\n                interactionId.get(),\n                interactionLayerStack.get().size(),\n                _Probe.currentThreadId());\n        closeInteractionLayerStackDownToStackSize(0);\n    }\n\t@Override\n    public Optional<InteractionLayer> currentInteractionLayer() {\n    \tval stack = interactionLayerStack.get();\n    \treturn stack.isEmpty()\n    \t        ? Optional.empty()\n                : Optional.of(stack.lastElement());\n    }\n    @Override\n    public boolean isInInteraction() {\n        return !interactionLayerStack.get().isEmpty();\n    }\n    // -- AUTHENTICATED EXECUTION\n    @Override\n    @SneakyThrows\n    public <R> R call(\n            final @NonNull InteractionContext interactionContext,\n            final @NonNull Callable<R> callable) {\n        final int stackSizeWhenEntering = interactionLayerStack.get().size();\n        openInteraction(interactionContext);\n        try {\n            serviceInjector.injectServicesInto(callable);\n            return callable.call();\n        } finally {\n            closeInteractionLayerStackDownToStackSize(stackSizeWhenEntering);\n        }\n    }\n    @Override\n    @SneakyThrows\n    public void run(\n            final @NonNull InteractionContext interactionContext,\n            final @NonNull ThrowingRunnable runnable) {\n        final int stackSizeWhenEntering = interactionLayerStack.get().size();\n        openInteraction(interactionContext);\n        try {\n            serviceInjector.injectServicesInto(runnable);\n            runnable.run();\n        } finally {\n            closeInteractionLayerStackDownToStackSize(stackSizeWhenEntering);\n        }\n    }\n    // -- ANONYMOUS EXECUTION\n    @Override\n    @SneakyThrows\n    public <R> R callAnonymous(@NonNull final Callable<R> callable) {\n        if(isInInteraction()) {\n            serviceInjector.injectServicesInto(callable);\n            return callable.call(); // reuse existing session\n        }\n        return call(InteractionContextFactory.anonymous(), callable);\n    }\n    /**\n     * Variant of {@link #callAnonymous(Callable)} that takes a runnable.\n     * @param runnable\n     */\n    @Override\n    @SneakyThrows\n    public void runAnonymous(@NonNull final ThrowingRunnable runnable) {\n        if(isInInteraction()) {\n            serviceInjector.injectServicesInto(runnable);\n            runnable.run(); // reuse existing session\n            return;\n        }\n        run(InteractionContextFactory.anonymous(), runnable);\n    }\n    // -- CONVERSATION ID\n    private final ThreadLocal<UUID> interactionId = ThreadLocal.withInitial(()->null);\n    @Override\n    public Optional<UUID> getInteractionId() {\n        return Optional.ofNullable(interactionId.get());\n    }\n    // -- HELPER\n    private boolean isAtTopLevel() {\n    \treturn interactionLayerStack.get().size()==1;\n    }\n    private void postInteractionOpened(final IsisInteraction interaction) {\n        interactionId.set(interaction.getInteractionId());\n        transactionBoundaryAwareBeans.forEach(bean->bean.beforeEnteringTransactionalBoundary(interaction));\n        txBoundaryHandler.onOpen(interaction);\n        val isSynchronizationActive = TransactionSynchronizationManager.isSynchronizationActive();\n        transactionBoundaryAwareBeans.forEach(bean->bean.afterEnteringTransactionalBoundary(interaction, isSynchronizationActive));\n        interactionScopeLifecycleHandler.onTopLevelInteractionOpened();\n    }\n    private void preInteractionClosed(final IsisInteraction interaction) {\n        completeAndPublishCurrentCommand();\n        val isSynchronizationActive = TransactionSynchronizationManager.isSynchronizationActive();\n        transactionBoundaryAwareBeans.forEach(bean->bean.beforeLeavingTransactionalBoundary(interaction, isSynchronizationActive));\n        txBoundaryHandler.onClose(interaction);\n        transactionBoundaryAwareBeans.forEach(bean->bean.afterLeavingTransactionalBoundary(interaction));\n        interactionScopeLifecycleHandler.onTopLevelInteractionPreDestroy(); // cleanup the InteractionScope (Spring scope)\n        interactionScopeLifecycleHandler.onTopLevelInteractionClosed(); // cleanup the InteractionScope (Spring scope)\n        interaction.close(); // do this last\n    }\n    private void closeInteractionLayerStackDownToStackSize(final int downToStackSize) {\n        log.debug(\"about to close authenication stack down to size {} (conversation-id={}, total-sessions-on-stack={}, {})\",\n                downToStackSize,\n                interactionId.get(),\n                interactionLayerStack.get().size(),\n                _Probe.currentThreadId());\n        val stack = interactionLayerStack.get();\n        while(stack.size()>downToStackSize) {\n        \tif(isAtTopLevel()) {\n        \t\t// keep the stack unmodified yet, to allow for callbacks to properly operate\n        \t\tpreInteractionClosed(_Casts.uncheckedCast(stack.peek().getInteraction()));\n        \t}\n        \t_Xray.closeInteractionLayer(stack);\n            stack.pop();\n        }\n        if(downToStackSize == 0) {\n            // cleanup thread-local\n            interactionLayerStack.remove();\n            interactionId.remove();\n        }\n    }\n    private IsisInteraction getInternalInteractionElseFail() {\n        val interaction = currentInteractionElseFail();\n        if(interaction instanceof IsisInteraction) {\n            return (IsisInteraction) interaction;\n        }\n        throw _Exceptions.unrecoverableFormatted(\"the framework does not recognice \"\n                + \"this implementation of an Interaction: %s\", interaction.getClass().getName());\n    }\n    // -- HELPER - COMMAND COMPLETION\n    private void completeAndPublishCurrentCommand() {\n        val interaction = getInternalInteractionElseFail();\n        val command = interaction.getCommand();\n        if(command.getStartedAt() != null && command.getCompletedAt() == null) {\n            // the guard is in case we're here as the result of a redirect following a previous exception;just ignore.\n            val priorInteractionExecution = interaction.getPriorExecution();\n            final Timestamp completedAt =\n                    priorInteractionExecution != null\n                    ?\n                        // copy over from the most recent (which will be the top-level) interaction\n                        priorInteractionExecution.getCompletedAt()\n                    :\n                        // this could arise as the result of calling SessionManagementService#nextSession within an action\n                        // the best we can do is to use the current time\n                        // REVIEW: as for the interaction object, it is left somewhat high-n-dry.\n                         clockService.getClock().nowAsJavaSqlTimestamp();\n            command.updater().setCompletedAt(completedAt);\n        }\n        commandPublisher.complete(command);\n        interaction.clear();\n    }\n"]], "pred": {"ppl": 3.0140345096588135, "ppl_lower": 4.6948957443237305, "ppl/lowercase_ppl": -1.4017081226925028, "ppl/zlib": 0.0003565867970025919, "Min_5.0% Prob": 7.8995454638612035, "Min_10.0% Prob": 6.31887952486674, "Min_20.0% Prob": 4.574814751452091, "Min_30.0% Prob": 3.455917582208035, "Min_40.0% Prob": 2.704152251441205, "Min_50.0% Prob": 2.1950035799302, "Min_60.0% Prob": 1.8372418339080123}}
{"hexsha": "7e71c047d72e04130a8cd57e4327853615945323", "ext": "java", "lang": "Java", "content": "public class AbstractWindowedCursorTest extends InstrumentationTestCase {\n    private static final String TEST_STRING = \"TESTSTRING\";\n    private static final int COLUMN_INDEX0 = 0;\n    private static final int COLUMN_INDEX1 = 1;\n    private static final int ROW_INDEX0 = 0;\n    private static final int TEST_COLUMN_COUNT = 7;\n    private MockAbstractWindowedCursor mCursor;\n    private CursorWindow mWindow;\n\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n\n        mCursor = new MockAbstractWindowedCursor();\n        mWindow = new CursorWindow(false);\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n        mCursor.close();\n        mWindow.close();\n        super.tearDown();\n    }\n    \n    public void testIsNull() {\n        mCursor.setWindow(mWindow);\n\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        mCursor.moveToFirst();\n        assertTrue(mCursor.isNull(COLUMN_INDEX0));\n        assertTrue(mWindow.allocRow());\n\n        String str = \"abcdefg\";\n        assertTrue(mWindow.putString(str, ROW_INDEX0, COLUMN_INDEX0));\n        assertFalse(mCursor.isNull(COLUMN_INDEX0));\n    }\n\n    public void testIsBlob() {\n        mCursor.setWindow(mWindow);\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        assertTrue(mWindow.allocRow());\n\n        mCursor.moveToFirst();\n        assertFalse(mCursor.isBlob(COLUMN_INDEX0));\n\n        String str = \"abcdefg\";\n        assertTrue(mWindow.putString(str, ROW_INDEX0, COLUMN_INDEX0));\n        assertTrue(mWindow.putBlob(new byte[10], ROW_INDEX0, COLUMN_INDEX1));\n        assertTrue(mCursor.isBlob(COLUMN_INDEX1));\n    }\n\n    public void testHasWindow() {\n        assertFalse(mCursor.hasWindow());\n        assertNull(mCursor.getWindow());\n\n        mCursor.setWindow(mWindow);\n        assertTrue(mCursor.hasWindow());\n        assertSame(mWindow, mCursor.getWindow());\n\n        mCursor.setWindow(null);\n        assertFalse(mCursor.hasWindow());\n        assertNull(mCursor.getWindow());\n    }\n\n    public void testGetString() {\n        mCursor.setWindow(mWindow);\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        assertTrue(mWindow.allocRow());\n\n        mCursor.moveToFirst();\n        String str = \"abcdefg\";\n        assertTrue(mWindow.putString(str, ROW_INDEX0, COLUMN_INDEX0));\n        assertEquals(str, mCursor.getString(COLUMN_INDEX0));\n    }\n\n    public void testGetShort() {\n        mCursor.setWindow(mWindow);\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        assertTrue(mWindow.allocRow());\n\n        mCursor.moveToFirst();\n        short shortNumber = 10;\n        assertTrue(mWindow.putLong((long) shortNumber, ROW_INDEX0, COLUMN_INDEX0));\n        assertEquals(shortNumber, mCursor.getShort(COLUMN_INDEX0));\n    }\n\n    public void testGetLong() {\n        mCursor.setWindow(mWindow);\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        assertTrue(mWindow.allocRow());\n\n        mCursor.moveToFirst();\n        long longNumber = 10;\n        assertTrue(mWindow.putLong(longNumber, ROW_INDEX0, COLUMN_INDEX0));\n        assertEquals(longNumber, mCursor.getLong(COLUMN_INDEX0));\n    }\n\n    public void testGetInt() {\n        mCursor.setWindow(mWindow);\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        assertTrue(mWindow.allocRow());\n\n        mCursor.moveToFirst();\n        int intNumber = 10;\n        assertTrue(mWindow.putLong((long) intNumber, ROW_INDEX0, COLUMN_INDEX0));\n        assertEquals(intNumber, mCursor.getInt(COLUMN_INDEX0));\n    }\n\n    public void testGetFloat() {\n        mCursor.setWindow(mWindow);\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        assertTrue(mWindow.allocRow());\n\n        mCursor.moveToFirst();\n        float f1oatNumber = 1.26f;\n        assertTrue(mWindow.putDouble((double) f1oatNumber, ROW_INDEX0, COLUMN_INDEX0));\n        assertEquals(f1oatNumber, mCursor.getFloat(COLUMN_INDEX0));\n    }\n\n    public void testGetDouble() {\n        mCursor.setWindow(mWindow);\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        assertTrue(mWindow.allocRow());\n\n        double db1 = 1.26;\n        assertTrue(mWindow.putDouble(db1, ROW_INDEX0, COLUMN_INDEX0));\n\n        double db2 = mWindow.getDouble(ROW_INDEX0, COLUMN_INDEX0);\n        assertEquals(db1, db2);\n\n        mCursor.moveToFirst();\n        double cd = mCursor.getDouble(COLUMN_INDEX0);\n        assertEquals(db1, cd);\n    }\n\n    public void testGetBlob() {\n        byte TEST_VALUE = 3;\n        byte BLOB_SIZE = 100;\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        assertTrue(mWindow.allocRow());\n        assertTrue(mWindow.putString(\"\", ROW_INDEX0, COLUMN_INDEX0));\n\n        byte[] blob = new byte[BLOB_SIZE];\n        Arrays.fill(blob, TEST_VALUE);\n        assertTrue(mWindow.putBlob(blob, ROW_INDEX0, COLUMN_INDEX1));\n\n        mCursor.setWindow(mWindow);\n        mCursor.moveToFirst();\n\n        byte[] targetBuffer = mCursor.getBlob(COLUMN_INDEX1);\n        assertEquals(BLOB_SIZE, targetBuffer.length);\n        assertTrue(Arrays.equals(blob, targetBuffer));\n    }\n\n    public void testCopyStringToBuffer() {\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        assertTrue(mWindow.allocRow());\n        assertTrue(mWindow.putString(TEST_STRING, ROW_INDEX0, COLUMN_INDEX0));\n        assertTrue(mWindow.putString(\"\", ROW_INDEX0, COLUMN_INDEX1));\n\n        mCursor.setWindow(mWindow);\n        mCursor.moveToFirst();\n\n        CharArrayBuffer charArrayBuffer = new CharArrayBuffer(TEST_STRING.length());\n\n        mCursor.copyStringToBuffer(COLUMN_INDEX0, charArrayBuffer);\n        assertEquals(TEST_STRING.length(), charArrayBuffer.sizeCopied);\n        assertTrue(Arrays.equals(TEST_STRING.toCharArray(), charArrayBuffer.data));\n\n        Arrays.fill(charArrayBuffer.data, '\\0');\n        mCursor.copyStringToBuffer(COLUMN_INDEX1, charArrayBuffer);\n        assertEquals(0, charArrayBuffer.sizeCopied);\n    }\n\n    public void testCheckPosition() {\n        try {\n            mCursor.checkPosition();\n            fail(\"testCheckPosition failed\");\n        } catch (CursorIndexOutOfBoundsException e) {\n            // expected\n        }\n\n        try {\n            assertTrue(mCursor.moveToPosition(mCursor.getCount() - 1));\n            mCursor.checkPosition();\n            fail(\"testCheckPosition failed\");\n        } catch (StaleDataException e) {\n            // expected\n        }\n\n        assertTrue(mCursor.moveToPosition(mCursor.getCount() - 1));\n        mCursor.setWindow(mWindow);\n        mCursor.checkPosition();\n    }\n\n    private class MockAbstractWindowedCursor extends AbstractWindowedCursor {\n\n        public MockAbstractWindowedCursor() {\n        }\n\n        @Override\n        public String[] getColumnNames() {\n            return new String[] {\n                    \"col1\", \"col2\", \"col3\"\n            };\n        }\n\n        @Override\n        public int getCount() {\n            return 1;\n        }\n\n        @Override\n        protected void checkPosition() {\n            super.checkPosition();\n        }\n    }\n}", "item_id": 0, "repo": "HelixOS/cts", "file": "tests/tests/database/src/android/database/cts/AbstractWindowedCursorTest.java", "last_update_at": "2022-01-07T01:53:19+00:00", "question_id": "7e71c047d72e04130a8cd57e4327853615945323_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AbstractWindowedCursorTest extends InstrumentationTestCase {\n    private static final String TEST_STRING = \"TESTSTRING\";\n    private static final int COLUMN_INDEX0 = 0;\n    private static final int COLUMN_INDEX1 = 1;\n    private static final int ROW_INDEX0 = 0;\n    private static final int TEST_COLUMN_COUNT = 7;\n    private MockAbstractWindowedCursor mCursor;\n    private CursorWindow mWindow;\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        mCursor = new MockAbstractWindowedCursor();\n        mWindow = new CursorWindow(false);\n    }\n    @Override\n    protected void tearDown() throws Exception {\n        mCursor.close();\n        mWindow.close();\n        super.tearDown();\n    }\n    public void testIsNull() {\n        mCursor.setWindow(mWindow);\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        mCursor.moveToFirst();\n        assertTrue(mCursor.isNull(COLUMN_INDEX0));\n        assertTrue(mWindow.allocRow());\n        String str = \"abcdefg\";\n        assertTrue(mWindow.putString(str, ROW_INDEX0, COLUMN_INDEX0));\n        assertFalse(mCursor.isNull(COLUMN_INDEX0));\n    }\n    public void testIsBlob() {\n        mCursor.setWindow(mWindow);\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        assertTrue(mWindow.allocRow());\n        mCursor.moveToFirst();\n        assertFalse(mCursor.isBlob(COLUMN_INDEX0));\n        String str = \"abcdefg\";\n        assertTrue(mWindow.putString(str, ROW_INDEX0, COLUMN_INDEX0));\n        assertTrue(mWindow.putBlob(new byte[10], ROW_INDEX0, COLUMN_INDEX1));\n        assertTrue(mCursor.isBlob(COLUMN_INDEX1));\n    }\n    public void testHasWindow() {\n        assertFalse(mCursor.hasWindow());\n        assertNull(mCursor.getWindow());\n        mCursor.setWindow(mWindow);\n        assertTrue(mCursor.hasWindow());\n        assertSame(mWindow, mCursor.getWindow());\n        mCursor.setWindow(null);\n        assertFalse(mCursor.hasWindow());\n        assertNull(mCursor.getWindow());\n    }\n    public void testGetString() {\n        mCursor.setWindow(mWindow);\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        assertTrue(mWindow.allocRow());\n        mCursor.moveToFirst();\n        String str = \"abcdefg\";\n        assertTrue(mWindow.putString(str, ROW_INDEX0, COLUMN_INDEX0));\n        assertEquals(str, mCursor.getString(COLUMN_INDEX0));\n    }\n    public void testGetShort() {\n        mCursor.setWindow(mWindow);\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        assertTrue(mWindow.allocRow());\n        mCursor.moveToFirst();\n        short shortNumber = 10;\n        assertTrue(mWindow.putLong((long) shortNumber, ROW_INDEX0, COLUMN_INDEX0));\n        assertEquals(shortNumber, mCursor.getShort(COLUMN_INDEX0));\n    }\n    public void testGetLong() {\n        mCursor.setWindow(mWindow);\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        assertTrue(mWindow.allocRow());\n        mCursor.moveToFirst();\n        long longNumber = 10;\n        assertTrue(mWindow.putLong(longNumber, ROW_INDEX0, COLUMN_INDEX0));\n        assertEquals(longNumber, mCursor.getLong(COLUMN_INDEX0));\n    }\n    public void testGetInt() {\n        mCursor.setWindow(mWindow);\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        assertTrue(mWindow.allocRow());\n        mCursor.moveToFirst();\n        int intNumber = 10;\n        assertTrue(mWindow.putLong((long) intNumber, ROW_INDEX0, COLUMN_INDEX0));\n        assertEquals(intNumber, mCursor.getInt(COLUMN_INDEX0));\n    }\n    public void testGetFloat() {\n        mCursor.setWindow(mWindow);\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        assertTrue(mWindow.allocRow());\n        mCursor.moveToFirst();\n        float f1oatNumber = 1.26f;\n        assertTrue(mWindow.putDouble((double) f1oatNumber, ROW_INDEX0, COLUMN_INDEX0));\n        assertEquals(f1oatNumber, mCursor.getFloat(COLUMN_INDEX0));\n    }\n    public void testGetDouble() {\n        mCursor.setWindow(mWindow);\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        assertTrue(mWindow.allocRow());\n        double db1 = 1.26;\n        assertTrue(mWindow.putDouble(db1, ROW_INDEX0, COLUMN_INDEX0));\n        double db2 = mWindow.getDouble(ROW_INDEX0, COLUMN_INDEX0);\n        assertEquals(db1, db2);\n        mCursor.moveToFirst();\n        double cd = mCursor.getDouble(COLUMN_INDEX0);\n        assertEquals(db1, cd);\n    }\n    public void testGetBlob() {\n        byte TEST_VALUE = 3;\n        byte BLOB_SIZE = 100;\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        assertTrue(mWindow.allocRow());\n        assertTrue(mWindow.putString(\"\", ROW_INDEX0, COLUMN_INDEX0));\n        byte[] blob = new byte[BLOB_SIZE];\n        Arrays.fill(blob, TEST_VALUE);\n        assertTrue(mWindow.putBlob(blob, ROW_INDEX0, COLUMN_INDEX1));\n        mCursor.setWindow(mWindow);\n        mCursor.moveToFirst();\n        byte[] targetBuffer = mCursor.getBlob(COLUMN_INDEX1);\n        assertEquals(BLOB_SIZE, targetBuffer.length);\n        assertTrue(Arrays.equals(blob, targetBuffer));\n    }\n    public void testCopyStringToBuffer() {\n        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));\n        assertTrue(mWindow.allocRow());\n        assertTrue(mWindow.putString(TEST_STRING, ROW_INDEX0, COLUMN_INDEX0));\n        assertTrue(mWindow.putString(\"\", ROW_INDEX0, COLUMN_INDEX1));\n        mCursor.setWindow(mWindow);\n        mCursor.moveToFirst();\n        CharArrayBuffer charArrayBuffer = new CharArrayBuffer(TEST_STRING.length());\n        mCursor.copyStringToBuffer(COLUMN_INDEX0, charArrayBuffer);\n        assertEquals(TEST_STRING.length(), charArrayBuffer.sizeCopied);\n        assertTrue(Arrays.equals(TEST_STRING.toCharArray(), charArrayBuffer.data));\n        Arrays.fill(charArrayBuffer.data, '\\0');\n        mCursor.copyStringToBuffer(COLUMN_INDEX1, charArrayBuffer);\n        assertEquals(0, charArrayBuffer.sizeCopied);\n    }\n    public void testCheckPosition() {\n        try {\n            mCursor.checkPosition();\n            fail(\"testCheckPosition failed\");\n        } catch (CursorIndexOutOfBoundsException e) {\n            // expected\n        }\n        try {\n            assertTrue(mCursor.moveToPosition(mCursor.getCount() - 1));\n            mCursor.checkPosition();\n            fail(\"testCheckPosition failed\");\n        } catch (StaleDataException e) {\n            // expected\n        }\n        assertTrue(mCursor.moveToPosition(mCursor.getCount() - 1));\n        mCursor.setWindow(mWindow);\n        mCursor.checkPosition();\n    }\n    private class MockAbstractWindowedCursor extends AbstractWindowedCursor {\n        public MockAbstractWindowedCursor() {\n        }\n        @Override\n        public String[] getColumnNames() {\n            return new String[] {\n                    \"col1\", \"col2\", \"col3\"\n            };\n        }\n        @Override\n        public int getCount() {\n            return 1;\n        }\n        @Override\n        protected void checkPosition() {\n            super.checkPosition();\n        }\n    }\n"]], "pred": {"ppl": 1.3246358633041382, "ppl_lower": 1.479392170906067, "ppl/lowercase_ppl": -1.3930235797912547, "ppl/zlib": 0.00023428133460032363, "Min_5.0% Prob": 3.6973852386661603, "Min_10.0% Prob": 2.4208218928645637, "Min_20.0% Prob": 1.3721251228787736, "Min_30.0% Prob": 0.9329306556617999, "Min_40.0% Prob": 0.7015732836813955, "Min_50.0% Prob": 0.5623620261106487, "Min_60.0% Prob": 0.4690516570516137}}
{"hexsha": "69b06d04cc9b13c4a7071acecbe0b42bd767287b", "ext": "java", "lang": "Java", "content": "public final class GitNewBranchNameValidator implements InputValidatorEx {\n\n  private final Collection<GitRepository> myRepositories;\n  private String myErrorText;\n\n  private GitNewBranchNameValidator(@NotNull Collection<GitRepository> repositories) {\n    myRepositories = repositories;\n  }\n\n  public static GitNewBranchNameValidator newInstance(@NotNull Collection<GitRepository> repositories) {\n    return new GitNewBranchNameValidator(repositories);\n  }\n\n  @Override\n  public boolean checkInput(String inputString) {\n    if (!GitRefNameValidator.getInstance().checkInput(inputString)){\n      myErrorText = \"Invalid name for branch\";\n      return false;\n    }\n    return checkBranchConflict(inputString);\n  }\n\n  private boolean checkBranchConflict(String inputString) {\n    if (isNotPermitted(inputString) || conflictsWithLocalBranch(inputString) || conflictsWithRemoteBranch(inputString)) {\n      return false;\n    }\n    myErrorText = null;\n    return true;\n  }\n\n  private boolean isNotPermitted(@NotNull String inputString) {\n    if (inputString.equalsIgnoreCase(\"head\")) {\n      myErrorText = \"Branch name \" + inputString + \" is not valid\";\n      return true;\n    }\n    return false;\n  }\n\n  private boolean conflictsWithLocalBranch(String inputString) {\n    return conflictsWithLocalOrRemote(inputString, true, \" already exists\");\n  }\n\n  private boolean conflictsWithRemoteBranch(String inputString) {\n    return conflictsWithLocalOrRemote(inputString, false, \" clashes with remote branch with the same name\");\n  }\n\n  private boolean conflictsWithLocalOrRemote(String inputString, boolean local, String message) {\n    for (GitRepository repository : myRepositories) {\n      GitBranchesCollection branchesCollection = repository.getBranches();\n      Collection<? extends GitBranch> branches = local ? branchesCollection.getLocalBranches() : branchesCollection.getRemoteBranches();\n      for (GitBranch branch : branches) {\n        if (branch.getName().equals(inputString)) {\n          myErrorText = \"Branch name \" + inputString + message;\n          if (myRepositories.size() > 1 && !allReposHaveBranch(inputString, local)) {\n            myErrorText += \" in repository \" + repository.getPresentableUrl();\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  private boolean allReposHaveBranch(String inputString, boolean local) {\n    for (GitRepository repository : myRepositories) {\n      GitBranchesCollection branchesCollection = repository.getBranches();\n      Collection<? extends GitBranch> branches = local ? branchesCollection.getLocalBranches() : branchesCollection.getRemoteBranches();\n      if (!GitBranchUtil.convertBranchesToNames(branches).contains(inputString)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public boolean canClose(String inputString) {\n    return checkInput(inputString);\n  }\n\n  @Override\n  public String getErrorText(String inputString) {\n    return myErrorText;\n  }\n}", "item_id": 0, "repo": "liveqmock/platform-tools-idea", "file": "plugins/git4idea/src/git4idea/validators/GitNewBranchNameValidator.java", "last_update_at": "2022-03-09T05:47:53+00:00", "question_id": "69b06d04cc9b13c4a7071acecbe0b42bd767287b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class GitNewBranchNameValidator implements InputValidatorEx {\n  private final Collection<GitRepository> myRepositories;\n  private String myErrorText;\n  private GitNewBranchNameValidator(@NotNull Collection<GitRepository> repositories) {\n    myRepositories = repositories;\n  }\n  public static GitNewBranchNameValidator newInstance(@NotNull Collection<GitRepository> repositories) {\n    return new GitNewBranchNameValidator(repositories);\n  }\n  @Override\n  public boolean checkInput(String inputString) {\n    if (!GitRefNameValidator.getInstance().checkInput(inputString)){\n      myErrorText = \"Invalid name for branch\";\n      return false;\n    }\n    return checkBranchConflict(inputString);\n  }\n  private boolean checkBranchConflict(String inputString) {\n    if (isNotPermitted(inputString) || conflictsWithLocalBranch(inputString) || conflictsWithRemoteBranch(inputString)) {\n      return false;\n    }\n    myErrorText = null;\n    return true;\n  }\n  private boolean isNotPermitted(@NotNull String inputString) {\n    if (inputString.equalsIgnoreCase(\"head\")) {\n      myErrorText = \"Branch name \" + inputString + \" is not valid\";\n      return true;\n    }\n    return false;\n  }\n  private boolean conflictsWithLocalBranch(String inputString) {\n    return conflictsWithLocalOrRemote(inputString, true, \" already exists\");\n  }\n  private boolean conflictsWithRemoteBranch(String inputString) {\n    return conflictsWithLocalOrRemote(inputString, false, \" clashes with remote branch with the same name\");\n  }\n  private boolean conflictsWithLocalOrRemote(String inputString, boolean local, String message) {\n    for (GitRepository repository : myRepositories) {\n      GitBranchesCollection branchesCollection = repository.getBranches();\n      Collection<? extends GitBranch> branches = local ? branchesCollection.getLocalBranches() : branchesCollection.getRemoteBranches();\n      for (GitBranch branch : branches) {\n        if (branch.getName().equals(inputString)) {\n          myErrorText = \"Branch name \" + inputString + message;\n          if (myRepositories.size() > 1 && !allReposHaveBranch(inputString, local)) {\n            myErrorText += \" in repository \" + repository.getPresentableUrl();\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  private boolean allReposHaveBranch(String inputString, boolean local) {\n    for (GitRepository repository : myRepositories) {\n      GitBranchesCollection branchesCollection = repository.getBranches();\n      Collection<? extends GitBranch> branches = local ? branchesCollection.getLocalBranches() : branchesCollection.getRemoteBranches();\n      if (!GitBranchUtil.convertBranchesToNames(branches).contains(inputString)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  @Override\n  public boolean canClose(String inputString) {\n    return checkInput(inputString);\n  }\n  @Override\n  public String getErrorText(String inputString) {\n    return myErrorText;\n  }\n"]], "pred": {"ppl": 1.496865153312683, "ppl_lower": 1.7314814329147339, "ppl/lowercase_ppl": -1.3609669704959653, "ppl/zlib": 0.0005321543844759761, "Min_5.0% Prob": 4.947555205760858, "Min_10.0% Prob": 3.3345254140022473, "Min_20.0% Prob": 1.9299052741665106, "Min_30.0% Prob": 1.3334651665491426, "Min_40.0% Prob": 1.005504024551271, "Min_50.0% Prob": 0.8068688094301526, "Min_60.0% Prob": 0.6731804287766537}}
{"hexsha": "82a600a9acb2bacf38a48673e2be55462680427e", "ext": "java", "lang": "Java", "content": "@Generated(value = \"io.vrap.rmf.codegen.rendring.CoreCodeGenerator\", comments = \"https://github.com/vrapio/rmf-codegen\")\npublic class TransactionDraftBuilder implements Builder<TransactionDraft> {\n\n    @Nullable\n    private java.time.ZonedDateTime timestamp;\n\n    private com.commercetools.api.models.payment.TransactionType type;\n\n    private com.commercetools.api.models.common.Money amount;\n\n    @Nullable\n    private String interactionId;\n\n    @Nullable\n    private com.commercetools.api.models.payment.TransactionState state;\n\n    public TransactionDraftBuilder timestamp(@Nullable final java.time.ZonedDateTime timestamp) {\n        this.timestamp = timestamp;\n        return this;\n    }\n\n    public TransactionDraftBuilder type(final com.commercetools.api.models.payment.TransactionType type) {\n        this.type = type;\n        return this;\n    }\n\n    public TransactionDraftBuilder amount(\n            Function<com.commercetools.api.models.common.MoneyBuilder, com.commercetools.api.models.common.MoneyBuilder> builder) {\n        this.amount = builder.apply(com.commercetools.api.models.common.MoneyBuilder.of()).build();\n        return this;\n    }\n\n    public TransactionDraftBuilder amount(final com.commercetools.api.models.common.Money amount) {\n        this.amount = amount;\n        return this;\n    }\n\n    public TransactionDraftBuilder interactionId(@Nullable final String interactionId) {\n        this.interactionId = interactionId;\n        return this;\n    }\n\n    public TransactionDraftBuilder state(@Nullable final com.commercetools.api.models.payment.TransactionState state) {\n        this.state = state;\n        return this;\n    }\n\n    @Nullable\n    public java.time.ZonedDateTime getTimestamp() {\n        return this.timestamp;\n    }\n\n    public com.commercetools.api.models.payment.TransactionType getType() {\n        return this.type;\n    }\n\n    public com.commercetools.api.models.common.Money getAmount() {\n        return this.amount;\n    }\n\n    @Nullable\n    public String getInteractionId() {\n        return this.interactionId;\n    }\n\n    @Nullable\n    public com.commercetools.api.models.payment.TransactionState getState() {\n        return this.state;\n    }\n\n    public TransactionDraft build() {\n        Objects.requireNonNull(type, TransactionDraft.class + \": type is missing\");\n        Objects.requireNonNull(amount, TransactionDraft.class + \": amount is missing\");\n        return new TransactionDraftImpl(timestamp, type, amount, interactionId, state);\n    }\n\n    /**\n     * builds TransactionDraft without checking for non null required values\n     */\n    public TransactionDraft buildUnchecked() {\n        return new TransactionDraftImpl(timestamp, type, amount, interactionId, state);\n    }\n\n    public static TransactionDraftBuilder of() {\n        return new TransactionDraftBuilder();\n    }\n\n    public static TransactionDraftBuilder of(final TransactionDraft template) {\n        TransactionDraftBuilder builder = new TransactionDraftBuilder();\n        builder.timestamp = template.getTimestamp();\n        builder.type = template.getType();\n        builder.amount = template.getAmount();\n        builder.interactionId = template.getInteractionId();\n        builder.state = template.getState();\n        return builder;\n    }\n\n}", "item_id": 0, "repo": "pintomau/commercetools-sdk-java-v2", "file": "commercetools/commercetools-sdk-java-api/src/main/java-generated/com/commercetools/api/models/payment/TransactionDraftBuilder.java", "last_update_at": "2022-03-21T05:58:32+00:00", "question_id": "82a600a9acb2bacf38a48673e2be55462680427e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Generated(value = \"io.vrap.rmf.codegen.rendring.CoreCodeGenerator\", comments = \"https://github.com/vrapio/rmf-codegen\")\npublic class TransactionDraftBuilder implements Builder<TransactionDraft> {\n    @Nullable\n    private java.time.ZonedDateTime timestamp;\n    private com.commercetools.api.models.payment.TransactionType type;\n    private com.commercetools.api.models.common.Money amount;\n    @Nullable\n    private String interactionId;\n    @Nullable\n    private com.commercetools.api.models.payment.TransactionState state;\n    public TransactionDraftBuilder timestamp(@Nullable final java.time.ZonedDateTime timestamp) {\n        this.timestamp = timestamp;\n        return this;\n    }\n    public TransactionDraftBuilder type(final com.commercetools.api.models.payment.TransactionType type) {\n        this.type = type;\n        return this;\n    }\n    public TransactionDraftBuilder amount(\n            Function<com.commercetools.api.models.common.MoneyBuilder, com.commercetools.api.models.common.MoneyBuilder> builder) {\n        this.amount = builder.apply(com.commercetools.api.models.common.MoneyBuilder.of()).build();\n        return this;\n    }\n    public TransactionDraftBuilder amount(final com.commercetools.api.models.common.Money amount) {\n        this.amount = amount;\n        return this;\n    }\n    public TransactionDraftBuilder interactionId(@Nullable final String interactionId) {\n        this.interactionId = interactionId;\n        return this;\n    }\n    public TransactionDraftBuilder state(@Nullable final com.commercetools.api.models.payment.TransactionState state) {\n        this.state = state;\n        return this;\n    }\n    @Nullable\n    public java.time.ZonedDateTime getTimestamp() {\n        return this.timestamp;\n    }\n    public com.commercetools.api.models.payment.TransactionType getType() {\n        return this.type;\n    }\n    public com.commercetools.api.models.common.Money getAmount() {\n        return this.amount;\n    }\n    @Nullable\n    public String getInteractionId() {\n        return this.interactionId;\n    }\n    @Nullable\n    public com.commercetools.api.models.payment.TransactionState getState() {\n        return this.state;\n    }\n    public TransactionDraft build() {\n        Objects.requireNonNull(type, TransactionDraft.class + \": type is missing\");\n        Objects.requireNonNull(amount, TransactionDraft.class + \": amount is missing\");\n        return new TransactionDraftImpl(timestamp, type, amount, interactionId, state);\n    }\n    /**\n     * builds TransactionDraft without checking for non null required values\n     */\n    public TransactionDraft buildUnchecked() {\n        return new TransactionDraftImpl(timestamp, type, amount, interactionId, state);\n    }\n    public static TransactionDraftBuilder of() {\n        return new TransactionDraftBuilder();\n    }\n    public static TransactionDraftBuilder of(final TransactionDraft template) {\n        TransactionDraftBuilder builder = new TransactionDraftBuilder();\n        builder.timestamp = template.getTimestamp();\n        builder.type = template.getType();\n        builder.amount = template.getAmount();\n        builder.interactionId = template.getInteractionId();\n        builder.state = template.getState();\n        return builder;\n    }\n"]], "pred": {"ppl": 1.4990681409835815, "ppl_lower": 1.6396995782852173, "ppl/lowercase_ppl": -1.2214913329456465, "ppl/zlib": 0.0005478263541471809, "Min_5.0% Prob": 6.31361558702257, "Min_10.0% Prob": 3.835305923943991, "Min_20.0% Prob": 2.024290930049924, "Min_30.0% Prob": 1.3493417344722272, "Min_40.0% Prob": 1.013537092261616, "Min_50.0% Prob": 0.8096285383402996, "Min_60.0% Prob": 0.6752149808552046}}
{"hexsha": "85ab45013cab63ee5fd9760e7afb076956e6ee28", "ext": "java", "lang": "Java", "content": "public class BasicTileType extends BasicType\n\t\timplements TileType, Json.Serializable {\n\tprivate boolean solid = true;\n\tprivate SpriteSheet sheet;\n\tprivate String drop;\n\n\tpublic BasicTileType() {\n\t}\n\n\t@Override\n\tpublic void read(Json json, JsonValue jsonData) {\n\t\tsuper.read(json, jsonData);\n\n\t\tsolid = jsonData.getBoolean(\"solid\", true);\n\t\tsheet = new SpriteSheet(Assets.getTexture(jsonData.getString(\"sheet\", \"null.png\")), getGrid());\n\t\tdrop = jsonData.getString(\"drop\", null);\n\t}\n\n\t/**\n\t * Gets the sprite grid used by the textures for this tile type;\n\t * can be overriden by subclasses.\n\t */\n\tprotected SpriteGrid getGrid() {\n\t\treturn Assets.tileGrid;\n\t}\n\n\t@Override\n\tpublic boolean isSolid() {\n\t\treturn solid;\n\t}\n\n\tpublic void setSolid(boolean solid) {\n\t\tthis.solid = solid;\n\t}\n\n\tpublic SpriteSheet getSheet() {\n\t\treturn sheet;\n\t}\n\n\tpublic void setSheet(SpriteSheet sheet) {\n\t\tthis.sheet = sheet;\n\t}\n\n\tpublic String getDrop() {\n\t\treturn drop;\n\t}\n\n\tpublic void setDrop(String drop) {\n\t\tthis.drop = drop;\n\t}\n\n\t@Override\n\tpublic Sprite getTexture(WorldView worldView, int x, int y) {\n\t\tWorld world = worldView.getWorld();\n\t\tBlockFrame frame = BlockFrame.findFrame(\n\t\t\t\ty == 0 || world.getTileType(x, y + 1).isSolid(),\n\t\t\t\tx + 1 == world.getWidth() || world.getTileType(x + 1, y).isSolid(),\n\t\t\t\ty + 1 == world.getHeight() || world.getTileType(x, y - 1).isSolid(),\n\t\t\t\tx == 0 || world.getTileType(x - 1, y).isSolid());\n\t\treturn sheet.getSprite(frame.getX(), frame.getY());\n\t}\n\n\t@Override\n\tpublic void placed(World world, int x, int y) {\n\t}\n\n\t@Override\n\tpublic void destroyed(World world, int x, int y) {\n\t\tif (getDrop() != null)\n\t\t\tworld.dropItem(new Item(GameRegistry.getItem(getDrop()), 1), x, y);\n\t}\n}", "item_id": 0, "repo": "Antag99/aquarria", "file": "aquarria/src/com/github/antag99/aquarria/BasicTileType.java", "last_update_at": "2022-03-04T02:43:11+00:00", "question_id": "85ab45013cab63ee5fd9760e7afb076956e6ee28_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BasicTileType extends BasicType\n\t\timplements TileType, Json.Serializable {\n\tprivate boolean solid = true;\n\tprivate SpriteSheet sheet;\n\tprivate String drop;\n\tpublic BasicTileType() {\n\t}\n\t@Override\n\tpublic void read(Json json, JsonValue jsonData) {\n\t\tsuper.read(json, jsonData);\n\t\tsolid = jsonData.getBoolean(\"solid\", true);\n\t\tsheet = new SpriteSheet(Assets.getTexture(jsonData.getString(\"sheet\", \"null.png\")), getGrid());\n\t\tdrop = jsonData.getString(\"drop\", null);\n\t}\n\t/**\n\t * Gets the sprite grid used by the textures for this tile type;\n\t * can be overriden by subclasses.\n\t */\n\tprotected SpriteGrid getGrid() {\n\t\treturn Assets.tileGrid;\n\t}\n\t@Override\n\tpublic boolean isSolid() {\n\t\treturn solid;\n\t}\n\tpublic void setSolid(boolean solid) {\n\t\tthis.solid = solid;\n\t}\n\tpublic SpriteSheet getSheet() {\n\t\treturn sheet;\n\t}\n\tpublic void setSheet(SpriteSheet sheet) {\n\t\tthis.sheet = sheet;\n\t}\n\tpublic String getDrop() {\n\t\treturn drop;\n\t}\n\tpublic void setDrop(String drop) {\n\t\tthis.drop = drop;\n\t}\n\t@Override\n\tpublic Sprite getTexture(WorldView worldView, int x, int y) {\n\t\tWorld world = worldView.getWorld();\n\t\tBlockFrame frame = BlockFrame.findFrame(\n\t\t\t\ty == 0 || world.getTileType(x, y + 1).isSolid(),\n\t\t\t\tx + 1 == world.getWidth() || world.getTileType(x + 1, y).isSolid(),\n\t\t\t\ty + 1 == world.getHeight() || world.getTileType(x, y - 1).isSolid(),\n\t\t\t\tx == 0 || world.getTileType(x - 1, y).isSolid());\n\t\treturn sheet.getSprite(frame.getX(), frame.getY());\n\t}\n\t@Override\n\tpublic void placed(World world, int x, int y) {\n\t}\n\t@Override\n\tpublic void destroyed(World world, int x, int y) {\n\t\tif (getDrop() != null)\n\t\t\tworld.dropItem(new Item(GameRegistry.getItem(getDrop()), 1), x, y);\n\t}\n"]], "pred": {"ppl": 1.778059959411621, "ppl_lower": 2.0918619632720947, "ppl/lowercase_ppl": -1.282407029943428, "ppl/zlib": 0.0008746548016364354, "Min_5.0% Prob": 5.801506325602531, "Min_10.0% Prob": 4.276287853717804, "Min_20.0% Prob": 2.7004946172237396, "Min_30.0% Prob": 1.8925671220446627, "Min_40.0% Prob": 1.4372406881593633, "Min_50.0% Prob": 1.1495687945650142, "Min_60.0% Prob": 0.9592928146217744}}
{"hexsha": "575cee43e70841a2a31858b937857ef756f6a1ad", "ext": "java", "lang": "Java", "content": "public final class  HexBin {\n    static private final int  BASELENGTH   = 255;\n    static private final int  LOOKUPLENGTH = 16;\n    static final private byte [] hexNumberTable    = new byte[BASELENGTH];\n    static final private char [] lookUpHexAlphabet = new char[LOOKUPLENGTH];\n\n\n    static {\n        for (int i = 0; i<BASELENGTH; i++ ) {\n            hexNumberTable[i] = -1;\n        }\n        for ( int i = '9'; i >= '0'; i--) {\n            hexNumberTable[i] = (byte) (i-'0');\n        }\n        for ( int i = 'F'; i>= 'A'; i--) {\n            hexNumberTable[i] = (byte) ( i-'A' + 10 );\n        }\n        for ( int i = 'f'; i>= 'a'; i--) {\n           hexNumberTable[i] = (byte) ( i-'a' + 10 );\n        }\n\n        for(int i = 0; i<10; i++ )\n            lookUpHexAlphabet[i] = (char)('0'+i);\n        for(int i = 10; i<=15; i++ )\n            lookUpHexAlphabet[i] = (char)('A'+i -10);\n    }\n\n    /**\n     * Encode a byte array to hex string\n     *\n     * @param binaryData  array of byte to encode\n     * @return return     encoded string\n     */\n    static public String encode(byte[] binaryData) {\n        if (binaryData == null)\n            return null;\n        int lengthData   = binaryData.length;\n        int lengthEncode = lengthData * 2;\n        char[] encodedData = new char[lengthEncode];\n        int temp;\n        for (int i = 0; i < lengthData; i++) {\n            temp = binaryData[i];\n            if (temp < 0)\n                temp += 256;\n            encodedData[i*2] = lookUpHexAlphabet[temp >> 4];\n            encodedData[i*2+1] = lookUpHexAlphabet[temp & 0xf];\n        }\n        return new String(encodedData);\n    }\n\n    /**\n     * Decode hex string to a byte array\n     *\n     * @param binaryData  encoded string\n     * @return return     array of byte to encode\n     */\n    static public byte[] decode(String encoded) {\n        if (encoded == null)\n            return null;\n        int lengthData = encoded.length();\n        if (lengthData % 2 != 0)\n            return null;\n\n        char[] binaryData = encoded.toCharArray();\n        int lengthDecode = lengthData / 2;\n        byte[] decodedData = new byte[lengthDecode];\n        byte temp1, temp2;\n        for( int i = 0; i<lengthDecode; i++ ){\n            temp1 = hexNumberTable[binaryData[i*2]];\n            if (temp1 == -1)\n                return null;\n            temp2 = hexNumberTable[binaryData[i*2+1]];\n            if (temp2 == -1)\n                return null;\n            decodedData[i] = (byte)((temp1 << 4) | temp2);\n        }\n        return decodedData;\n    }\n}", "item_id": 0, "repo": "timtyler/texturegarden", "file": "xerces/xerces-2_6_1/src/org/apache/xerces/impl/dv/util/HexBin.java", "last_update_at": "2022-02-19T21:02:06+00:00", "question_id": "575cee43e70841a2a31858b937857ef756f6a1ad_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class  HexBin {\n    static private final int  BASELENGTH   = 255;\n    static private final int  LOOKUPLENGTH = 16;\n    static final private byte [] hexNumberTable    = new byte[BASELENGTH];\n    static final private char [] lookUpHexAlphabet = new char[LOOKUPLENGTH];\n    static {\n        for (int i = 0; i<BASELENGTH; i++ ) {\n            hexNumberTable[i] = -1;\n        }\n        for ( int i = '9'; i >= '0'; i--) {\n            hexNumberTable[i] = (byte) (i-'0');\n        }\n        for ( int i = 'F'; i>= 'A'; i--) {\n            hexNumberTable[i] = (byte) ( i-'A' + 10 );\n        }\n        for ( int i = 'f'; i>= 'a'; i--) {\n           hexNumberTable[i] = (byte) ( i-'a' + 10 );\n        }\n        for(int i = 0; i<10; i++ )\n            lookUpHexAlphabet[i] = (char)('0'+i);\n        for(int i = 10; i<=15; i++ )\n            lookUpHexAlphabet[i] = (char)('A'+i -10);\n    }\n    /**\n     * Encode a byte array to hex string\n     *\n     * @param binaryData  array of byte to encode\n     * @return return     encoded string\n     */\n    static public String encode(byte[] binaryData) {\n        if (binaryData == null)\n            return null;\n        int lengthData   = binaryData.length;\n        int lengthEncode = lengthData * 2;\n        char[] encodedData = new char[lengthEncode];\n        int temp;\n        for (int i = 0; i < lengthData; i++) {\n            temp = binaryData[i];\n            if (temp < 0)\n                temp += 256;\n            encodedData[i*2] = lookUpHexAlphabet[temp >> 4];\n            encodedData[i*2+1] = lookUpHexAlphabet[temp & 0xf];\n        }\n        return new String(encodedData);\n    }\n    /**\n     * Decode hex string to a byte array\n     *\n     * @param binaryData  encoded string\n     * @return return     array of byte to encode\n     */\n    static public byte[] decode(String encoded) {\n        if (encoded == null)\n            return null;\n        int lengthData = encoded.length();\n        if (lengthData % 2 != 0)\n            return null;\n        char[] binaryData = encoded.toCharArray();\n        int lengthDecode = lengthData / 2;\n        byte[] decodedData = new byte[lengthDecode];\n        byte temp1, temp2;\n        for( int i = 0; i<lengthDecode; i++ ){\n            temp1 = hexNumberTable[binaryData[i*2]];\n            if (temp1 == -1)\n                return null;\n            temp2 = hexNumberTable[binaryData[i*2+1]];\n            if (temp2 == -1)\n                return null;\n            decodedData[i] = (byte)((temp1 << 4) | temp2);\n        }\n        return decodedData;\n    }\n"]], "pred": {"ppl": 1.410548210144043, "ppl_lower": 1.711580514907837, "ppl/lowercase_ppl": -1.5623573280881409, "ppl/zlib": 0.0004858452406030355, "Min_5.0% Prob": 4.09298833986608, "Min_10.0% Prob": 2.7629005058509546, "Min_20.0% Prob": 1.5971337592963017, "Min_30.0% Prob": 1.1143798793737705, "Min_40.0% Prob": 0.8495329941425359, "Min_50.0% Prob": 0.6854670299669203, "Min_60.0% Prob": 0.572323147272409}}
{"hexsha": "25a167e4e5d0f3d0036d35d07ab5219669453238", "ext": "java", "lang": "Java", "content": "@Dependent\n@Default\npublic class DefaultSSHKeyStore implements SSHKeyStore {\n\n    public static final String USER_DIR = \"user.dir\";\n\n    public static final String SSH_KEYS_PATH_PARAM = \"appformer.ssh.keys.storage.folder\";\n\n    public static final String SSH_KEYS_FOLDER = \".security/pkeys\";\n\n    private final Map<String, UserSSHKeyStore> userKeyStores = new HashMap<>();\n\n    private final Path sshStoragePath;\n\n    public DefaultSSHKeyStore() {\n\n        String customStorage = System.getProperty(SSH_KEYS_PATH_PARAM, null);\n\n        if (customStorage != null) {\n            sshStoragePath = Paths.get(customStorage);\n        } else {\n            sshStoragePath = Paths.get(System.getProperty(USER_DIR)).resolve(SSH_KEYS_FOLDER);\n        }\n    }\n\n    @PostConstruct\n    public void init() {\n        File keysFolder = sshStoragePath.toFile();\n\n        if (keysFolder.exists()) {\n            Stream.of(keysFolder.list())\n                    .map(this::getUserKeyStore)\n                    .forEach(userSSHKeyStore -> userKeyStores.put(userSSHKeyStore.getUser(), userSSHKeyStore));\n        } else {\n            keysFolder.mkdirs();\n        }\n    }\n\n    public UserSSHKeyStore getUserKeyStore(String userName) {\n        UserSSHKeyStore userStore = userKeyStores.get(userName);\n\n        if (userStore == null) {\n            userStore = new UserSSHKeyStore(userName, sshStoragePath);\n            userKeyStores.put(userName, userStore);\n        }\n\n        return userStore;\n    }\n\n    @Override\n    public void addUserKey(final String userName, final SSHPublicKey key) {\n        getUserKeyStore(userName).addUserKey(key);\n    }\n\n    @Override\n    public void removeUserKey(String userName, SSHPublicKey key) {\n        getUserKeyStore(userName).removeUserKey(key);\n    }\n\n    @Override\n    public void updateUserKey(String userName, SSHPublicKey key) {\n        addUserKey(userName, key);\n    }\n\n    @Override\n    public Collection<SSHPublicKey> getUserKeys(String userName) {\n        return getUserKeyStore(userName).getUserKeys();\n    }\n}", "item_id": 0, "repo": "jstastny-cz/appformer", "file": "uberfire-ssh/uberfire-ssh-backend/src/main/java/org/uberfire/ssh/service/backend/keystore/impl/storage/DefaultSSHKeyStore.java", "last_update_at": "2022-03-11T06:48:15+00:00", "question_id": "25a167e4e5d0f3d0036d35d07ab5219669453238_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Dependent\n@Default\npublic class DefaultSSHKeyStore implements SSHKeyStore {\n    public static final String USER_DIR = \"user.dir\";\n    public static final String SSH_KEYS_PATH_PARAM = \"appformer.ssh.keys.storage.folder\";\n    public static final String SSH_KEYS_FOLDER = \".security/pkeys\";\n    private final Map<String, UserSSHKeyStore> userKeyStores = new HashMap<>();\n    private final Path sshStoragePath;\n    public DefaultSSHKeyStore() {\n        String customStorage = System.getProperty(SSH_KEYS_PATH_PARAM, null);\n        if (customStorage != null) {\n            sshStoragePath = Paths.get(customStorage);\n        } else {\n            sshStoragePath = Paths.get(System.getProperty(USER_DIR)).resolve(SSH_KEYS_FOLDER);\n        }\n    }\n    @PostConstruct\n    public void init() {\n        File keysFolder = sshStoragePath.toFile();\n        if (keysFolder.exists()) {\n            Stream.of(keysFolder.list())\n                    .map(this::getUserKeyStore)\n                    .forEach(userSSHKeyStore -> userKeyStores.put(userSSHKeyStore.getUser(), userSSHKeyStore));\n        } else {\n            keysFolder.mkdirs();\n        }\n    }\n    public UserSSHKeyStore getUserKeyStore(String userName) {\n        UserSSHKeyStore userStore = userKeyStores.get(userName);\n        if (userStore == null) {\n            userStore = new UserSSHKeyStore(userName, sshStoragePath);\n            userKeyStores.put(userName, userStore);\n        }\n        return userStore;\n    }\n    @Override\n    public void addUserKey(final String userName, final SSHPublicKey key) {\n        getUserKeyStore(userName).addUserKey(key);\n    }\n    @Override\n    public void removeUserKey(String userName, SSHPublicKey key) {\n        getUserKeyStore(userName).removeUserKey(key);\n    }\n    @Override\n    public void updateUserKey(String userName, SSHPublicKey key) {\n        addUserKey(userName, key);\n    }\n    @Override\n    public Collection<SSHPublicKey> getUserKeys(String userName) {\n        return getUserKeyStore(userName).getUserKeys();\n    }\n"]], "pred": {"ppl": 1.6012831926345825, "ppl_lower": 1.967240810394287, "ppl/lowercase_ppl": -1.4371799818415854, "ppl/zlib": 0.0007605901505910906, "Min_5.0% Prob": 5.212866862614949, "Min_10.0% Prob": 3.689294133583705, "Min_20.0% Prob": 2.214810048006783, "Min_30.0% Prob": 1.5412888802014864, "Min_40.0% Prob": 1.175145945142308, "Min_50.0% Prob": 0.9418838195097033, "Min_60.0% Prob": 0.7848516905956625}}
{"hexsha": "874c0230b0504decf6f215d5f14e8258bf671828", "ext": "java", "lang": "Java", "content": "public class Image {\n\n  private String url;\n  private Integer w;\n  private Integer h;\n  private Integer type;\n  private String ext;\n\n  public String getUrl() {\n    return url;\n  }\n\n  public void setUrl(String url) {\n    this.url = url;\n  }\n\n  public Integer getW() {\n    return w;\n  }\n\n  public void setW(Integer w) {\n    this.w = w;\n  }\n\n  public Integer getH() {\n    return h;\n  }\n\n  public void setH(Integer h) {\n    this.h = h;\n  }\n\n  public Integer getType() {\n    return type;\n  }\n\n  public void setType(Integer type) {\n    this.type = type;\n  }\n\n  public String getExt() {\n    return ext;\n  }\n\n  public void setExt(String ext) {\n    this.ext = ext;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Image image = (Image) o;\n    return Objects.equals(getUrl(), image.getUrl())\n        && Objects.equals(getW(), image.getW())\n        && Objects.equals(getH(), image.getH())\n        && Objects.equals(getType(), image.getType())\n        && Objects.equals(getExt(), image.getExt());\n  }\n\n  @Override\n  public int hashCode() {\n\n    return Objects.hash(getUrl(), getW(), getH(), getType(), getExt());\n  }\n}", "item_id": 0, "repo": "media-net/openrtb-pojo", "file": "src/main/java/net/media/openrtb3/Image.java", "last_update_at": "2022-03-31T03:53:53+00:00", "question_id": "874c0230b0504decf6f215d5f14e8258bf671828_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Image {\n  private String url;\n  private Integer w;\n  private Integer h;\n  private Integer type;\n  private String ext;\n  public String getUrl() {\n    return url;\n  }\n  public void setUrl(String url) {\n    this.url = url;\n  }\n  public Integer getW() {\n    return w;\n  }\n  public void setW(Integer w) {\n    this.w = w;\n  }\n  public Integer getH() {\n    return h;\n  }\n  public void setH(Integer h) {\n    this.h = h;\n  }\n  public Integer getType() {\n    return type;\n  }\n  public void setType(Integer type) {\n    this.type = type;\n  }\n  public String getExt() {\n    return ext;\n  }\n  public void setExt(String ext) {\n    this.ext = ext;\n  }\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Image image = (Image) o;\n    return Objects.equals(getUrl(), image.getUrl())\n        && Objects.equals(getW(), image.getW())\n        && Objects.equals(getH(), image.getH())\n        && Objects.equals(getType(), image.getType())\n        && Objects.equals(getExt(), image.getExt());\n  }\n  @Override\n  public int hashCode() {\n    return Objects.hash(getUrl(), getW(), getH(), getType(), getExt());\n  }\n"]], "pred": {"ppl": 1.1827309131622314, "ppl_lower": 1.3112622499465942, "ppl/lowercase_ppl": -1.614708478321076, "ppl/zlib": 0.00045114542398294556, "Min_5.0% Prob": 3.077776437997818, "Min_10.0% Prob": 1.680847520962721, "Min_20.0% Prob": 0.8395927292968045, "Min_30.0% Prob": 0.5626662246612532, "Min_40.0% Prob": 0.4204462226499531, "Min_50.0% Prob": 0.3356016731206462, "Min_60.0% Prob": 0.2803640843595352}}
{"hexsha": "ee4a2733fb085d2ed19f2bd7c0153b0a71ce2b2c", "ext": "java", "lang": "Java", "content": "public class SummarizeUMIBaseQualitiesTest {\n\n\t@Test(enabled=true)\n\tpublic void test1() {\n\n\t\tchar [] b = {'A', 'A', 'A'};\n\t\tbyte [] bases = getBases(b);\n\t\tbyte [] qualities = {10,20,30};\n\n\t\tSummarizeUMIBaseQualities s = new SummarizeUMIBaseQualities(bases, qualities);\n\t\tbyte r = s.getMostCommonBase();\n\t\tAssert.assertEquals(r, (byte) 'A');\n\n\t\tint score = s.getSummarizedPhredScore();\n\t\tAssert.assertEquals(14, score);\n\t}\n\n\t@Test\n\tpublic void test2() {\n\n\t\tchar [] b = {'A', 'A', 'A', 'A', 'A'};\n\t\tbyte [] bases = getBases(b);\n\t\tbyte [] qualities = {30,30,30,30,30};\n\n\t\tSummarizeUMIBaseQualities s = new SummarizeUMIBaseQualities(bases, qualities);\n\t\tbyte r = s.getMostCommonBase();\n\t\tAssert.assertEquals(r, (byte) 'A');\n\n\t\tint score = s.getSummarizedPhredScore();\n\t\tAssert.assertEquals(30, score);\n\t}\n\n\t@Test\n\tpublic void test3() {\n\n\t\tchar [] b = {'A', 'A', 'T'};\n\t\tbyte [] bases = getBases(b);\n\t\tbyte [] qualities = {30, 30, 10};\n\n\t\tSummarizeUMIBaseQualities s = new SummarizeUMIBaseQualities(bases, qualities);\n\t\tbyte r = s.getMostCommonBase();\n\t\tAssert.assertEquals(r, (byte) 'A');\n\n\t\tint score = s.getSummarizedPhredScore();\n\t\tAssert.assertEquals(5, score);\n\t}\n\n\t@Test\n\tpublic void testMode () {\n\t\tchar [] b = {'A', 'A', 'T', 'A', 'A', 'A', 'A'};\n\t\tbyte [] bases = getBases(b);\n\t\tbyte [] qualities = {20, 30, 10, 20, 25, 25, 25};\n\n\t\tSummarizeUMIBaseQualities s = new SummarizeUMIBaseQualities(bases, qualities);\n\t\tint value = s.getSummarizedPhreadScoreByMode();\n\t\tAssert.assertSame(25, value);\n\t}\n\n\n\n\n\tprivate byte [] getBases (final char [] bases) {\n\t\tbyte [] result = new byte [bases.length];\n\t\tStringUtil.charsToBytes(bases, 0, bases.length, result, 0);\n\t\treturn (result);\n\t}\n}", "item_id": 0, "repo": "caramirezal/Drop-seq", "file": "src/tests/java/org/broadinstitute/dropseqrna/barnyard/digitalallelecounts/SummarizeUMIBaseQualitiesTest.java", "last_update_at": "2022-03-20T23:10:07+00:00", "question_id": "ee4a2733fb085d2ed19f2bd7c0153b0a71ce2b2c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SummarizeUMIBaseQualitiesTest {\n\t@Test(enabled=true)\n\tpublic void test1() {\n\t\tchar [] b = {'A', 'A', 'A'};\n\t\tbyte [] bases = getBases(b);\n\t\tbyte [] qualities = {10,20,30};\n\t\tSummarizeUMIBaseQualities s = new SummarizeUMIBaseQualities(bases, qualities);\n\t\tbyte r = s.getMostCommonBase();\n\t\tAssert.assertEquals(r, (byte) 'A');\n\t\tint score = s.getSummarizedPhredScore();\n\t\tAssert.assertEquals(14, score);\n\t}\n\t@Test\n\tpublic void test2() {\n\t\tchar [] b = {'A', 'A', 'A', 'A', 'A'};\n\t\tbyte [] bases = getBases(b);\n\t\tbyte [] qualities = {30,30,30,30,30};\n\t\tSummarizeUMIBaseQualities s = new SummarizeUMIBaseQualities(bases, qualities);\n\t\tbyte r = s.getMostCommonBase();\n\t\tAssert.assertEquals(r, (byte) 'A');\n\t\tint score = s.getSummarizedPhredScore();\n\t\tAssert.assertEquals(30, score);\n\t}\n\t@Test\n\tpublic void test3() {\n\t\tchar [] b = {'A', 'A', 'T'};\n\t\tbyte [] bases = getBases(b);\n\t\tbyte [] qualities = {30, 30, 10};\n\t\tSummarizeUMIBaseQualities s = new SummarizeUMIBaseQualities(bases, qualities);\n\t\tbyte r = s.getMostCommonBase();\n\t\tAssert.assertEquals(r, (byte) 'A');\n\t\tint score = s.getSummarizedPhredScore();\n\t\tAssert.assertEquals(5, score);\n\t}\n\t@Test\n\tpublic void testMode () {\n\t\tchar [] b = {'A', 'A', 'T', 'A', 'A', 'A', 'A'};\n\t\tbyte [] bases = getBases(b);\n\t\tbyte [] qualities = {20, 30, 10, 20, 25, 25, 25};\n\t\tSummarizeUMIBaseQualities s = new SummarizeUMIBaseQualities(bases, qualities);\n\t\tint value = s.getSummarizedPhreadScoreByMode();\n\t\tAssert.assertSame(25, value);\n\t}\n\tprivate byte [] getBases (final char [] bases) {\n\t\tbyte [] result = new byte [bases.length];\n\t\tStringUtil.charsToBytes(bases, 0, bases.length, result, 0);\n\t\treturn (result);\n\t}\n"]], "pred": {"ppl": 1.6280715465545654, "ppl_lower": 1.7840853929519653, "ppl/lowercase_ppl": -1.1877521454497846, "ppl/zlib": 0.001194598564043564, "Min_5.0% Prob": 5.909549918439653, "Min_10.0% Prob": 3.9728957133160696, "Min_20.0% Prob": 2.336434507328603, "Min_30.0% Prob": 1.6126090428550486, "Min_40.0% Prob": 1.2146428828820535, "Min_50.0% Prob": 0.9745629184164747, "Min_60.0% Prob": 0.8133342440211049}}
{"hexsha": "25ee476c4ae2e1a62d1abeb6d999e51d820bf6c2", "ext": "java", "lang": "Java", "content": "public class MainActivity extends BaseActivity {\n\n    final String TAG = getClass().getSimpleName();\n    ProductFileLoader _productFileLoader;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        ProductDataService.getInstance(this);\n        _productFileLoader = ProductFileLoader.getInstance(this);\n        _productFileLoader.loadDataFromExternalFile();\n\n    }\n\n    public void onStartScanner(View v) {\n        startActivity(new Intent(this, ScannerActivity.class));\n    }\n}", "item_id": 0, "repo": "BlueFletch/inventory-ar", "file": "source/app/src/main/java/com/bluefletch/visioninventory/ui/MainActivity.java", "last_update_at": "2022-02-23T19:17:04+00:00", "question_id": "25ee476c4ae2e1a62d1abeb6d999e51d820bf6c2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MainActivity extends BaseActivity {\n    final String TAG = getClass().getSimpleName();\n    ProductFileLoader _productFileLoader;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        ProductDataService.getInstance(this);\n        _productFileLoader = ProductFileLoader.getInstance(this);\n        _productFileLoader.loadDataFromExternalFile();\n    }\n    public void onStartScanner(View v) {\n        startActivity(new Intent(this, ScannerActivity.class));\n    }\n"]], "pred": {"ppl": 2.362201452255249, "ppl_lower": 3.059190511703491, "ppl/lowercase_ppl": -1.3007889054906203, "ppl/zlib": 0.0028463377582275025, "Min_5.0% Prob": 6.8283450944083075, "Min_10.0% Prob": 5.623069064957755, "Min_20.0% Prob": 3.6584037665663094, "Min_30.0% Prob": 2.7379067651061124, "Min_40.0% Prob": 2.1198492304518304, "Min_50.0% Prob": 1.7083169073887068, "Min_60.0% Prob": 1.439017450351311}}
{"hexsha": "c7d84f5823ba3388e4323fdca618fb765ba83be2", "ext": "java", "lang": "Java", "content": "@SpringBootApplication\n@RestController\npublic class Application implements CommandLineRunner {\n\n    @Autowired\n    private ConfigurableEnvironment environment;\n\n\n    @Value(\"${spring.cosmos.db.key:local}\")\n    private String cosmosDBkey;\n\n    private static ObjectMapper mapper = new ObjectMapper();\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @GetMapping(\"hello\")\n    public String hello() {\n        try {\n            return mapper.writeValueAsString(System.getenv());\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n            return \"Some error happens\";\n        }\n    }\n\n    @GetMapping(\"get\")\n    public String get() {\n        return cosmosDBkey;\n    }\n\n    @GetMapping(\"env/{key}\")\n    public String env(@PathVariable String key) {\n        final String property = environment.getProperty(key);\n        return property;\n    }\n\n    @GetMapping(\"list\")\n    public String list() {\n        final List list = new ArrayList();\n        final MutablePropertySources propertySources = this.environment.getPropertySources();\n        final Iterator<PropertySource<?>> iterator = propertySources.iterator();\n        while (iterator.hasNext()) {\n            final PropertySource<?> next = iterator.next();\n            list.add(next.getName());\n        }\n        return JSON.toJSONString(list);\n    }\n\n    @GetMapping(\"getSpecificProperty/{ps}/{key}\")\n    public String getSpecificProperty(@PathVariable String ps, @PathVariable String key) {\n        final MutablePropertySources propertySources = this.environment.getPropertySources();\n        final PropertySource<?> propertySource = propertySources.get(ps);\n        if (propertySource != null) {\n            final Object property = propertySource.getProperty(key);\n            return property == null ? null : property.toString();\n        } else {\n            return null;\n        }\n    }\n\n    public void run(String... varl) throws Exception {\n        System.out.println(\"property your-property-name value is: \" + cosmosDBkey);\n    }\n\n}", "item_id": 0, "repo": "Manny27nyc/azure-sdk-for-java", "file": "sdk/spring/azure-spring-boot-test-application/src/main/java/com/azure/test/Application.java", "last_update_at": "2022-03-29T21:00:37+00:00", "question_id": "c7d84f5823ba3388e4323fdca618fb765ba83be2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SpringBootApplication\n@RestController\npublic class Application implements CommandLineRunner {\n    @Autowired\n    private ConfigurableEnvironment environment;\n    @Value(\"${spring.cosmos.db.key:local}\")\n    private String cosmosDBkey;\n    private static ObjectMapper mapper = new ObjectMapper();\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n    @GetMapping(\"hello\")\n    public String hello() {\n        try {\n            return mapper.writeValueAsString(System.getenv());\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n            return \"Some error happens\";\n        }\n    }\n    @GetMapping(\"get\")\n    public String get() {\n        return cosmosDBkey;\n    }\n    @GetMapping(\"env/{key}\")\n    public String env(@PathVariable String key) {\n        final String property = environment.getProperty(key);\n        return property;\n    }\n    @GetMapping(\"list\")\n    public String list() {\n        final List list = new ArrayList();\n        final MutablePropertySources propertySources = this.environment.getPropertySources();\n        final Iterator<PropertySource<?>> iterator = propertySources.iterator();\n        while (iterator.hasNext()) {\n            final PropertySource<?> next = iterator.next();\n            list.add(next.getName());\n        }\n        return JSON.toJSONString(list);\n    }\n    @GetMapping(\"getSpecificProperty/{ps}/{key}\")\n    public String getSpecificProperty(@PathVariable String ps, @PathVariable String key) {\n        final MutablePropertySources propertySources = this.environment.getPropertySources();\n        final PropertySource<?> propertySource = propertySources.get(ps);\n        if (propertySource != null) {\n            final Object property = propertySource.getProperty(key);\n            return property == null ? null : property.toString();\n        } else {\n            return null;\n        }\n    }\n    public void run(String... varl) throws Exception {\n        System.out.println(\"property your-property-name value is: \" + cosmosDBkey);\n    }\n"]], "pred": {"ppl": 1.780084252357483, "ppl_lower": 2.0076253414154053, "ppl/lowercase_ppl": -1.208600839856451, "ppl/zlib": 0.0007877878360231361, "Min_5.0% Prob": 5.93754137479342, "Min_10.0% Prob": 4.237421586828412, "Min_20.0% Prob": 2.6351009573576585, "Min_30.0% Prob": 1.8682994850963917, "Min_40.0% Prob": 1.4268559186526064, "Min_50.0% Prob": 1.1494186712956092, "Min_60.0% Prob": 0.9600721438555926}}
{"hexsha": "4f9bb5e5d74727a6b76a10657eaea95f97d27788", "ext": "java", "lang": "Java", "content": "public class GenericHandlerTest {\n\n  private GenericHandler gh;\n  private final ContextStore store = new ContextStore();\n\n  @Test(expected = NullPointerException.class)\n  public void testNullContext() {\n    gh = new MockGenericHandler(null);\n  }\n\n  @Test\n  @SuppressWarnings(\"PMD.JUnitTestsShouldIncludeAssert\")\n  public void testNoClaim() {\n    gh = new MockGenericHandler();\n    gh = new MockGenericHandler(\"testNoClaim\");\n    gh = new MockGenericHandler(\"testNoClaim\", false);\n    // An exception will be thrown if something went wrong\n  }\n\n  @Test(expected = IllegalArgumentException.class)\n  public void testClaim() {\n    String context = \"testClaim\";\n    gh = new MockGenericHandler(context, true);\n    assertTrue(\"Context should have been claimed\", store.contains(context));\n    gh = new MockGenericHandler(context, true); // Should throw IllegalArgumentException\n  }\n\n  @Test\n  public void testGetContext() {\n    String context = \"testGetContext\";\n    gh = new MockGenericHandler(context);\n    assertEquals(\"Context was wrong\", context, gh.getContext());\n  }\n\n  @After\n  public void tearDown() {\n    if (gh != null) {\n      gh.releaseContext();\n    }\n  }\n\n  private class MockGenericHandler extends GenericHandler {\n\n    MockGenericHandler() {\n      super();\n    }\n\n    MockGenericHandler(String context) {\n      super(store, context);\n    }\n\n    MockGenericHandler(String context, boolean doClaim) {\n      super(store, context, doClaim);\n    }\n\n    @Override\n    public void handle(String target,\n                       Request baseRequest,\n                       HttpServletRequest request,\n                       HttpServletResponse response) throws IOException, ServletException {\n      // Do nothing, this class is only used for testing automatic claims\n    }\n  }\n\n}", "item_id": 0, "repo": "TheTripleV/GRIP", "file": "core/src/test/java/edu/wpi/grip/core/http/GenericHandlerTest.java", "last_update_at": "2022-03-21T13:49:56+00:00", "question_id": "4f9bb5e5d74727a6b76a10657eaea95f97d27788_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GenericHandlerTest {\n  private GenericHandler gh;\n  private final ContextStore store = new ContextStore();\n  @Test(expected = NullPointerException.class)\n  public void testNullContext() {\n    gh = new MockGenericHandler(null);\n  }\n  @Test\n  @SuppressWarnings(\"PMD.JUnitTestsShouldIncludeAssert\")\n  public void testNoClaim() {\n    gh = new MockGenericHandler();\n    gh = new MockGenericHandler(\"testNoClaim\");\n    gh = new MockGenericHandler(\"testNoClaim\", false);\n    // An exception will be thrown if something went wrong\n  }\n  @Test(expected = IllegalArgumentException.class)\n  public void testClaim() {\n    String context = \"testClaim\";\n    gh = new MockGenericHandler(context, true);\n    assertTrue(\"Context should have been claimed\", store.contains(context));\n    gh = new MockGenericHandler(context, true); // Should throw IllegalArgumentException\n  }\n  @Test\n  public void testGetContext() {\n    String context = \"testGetContext\";\n    gh = new MockGenericHandler(context);\n    assertEquals(\"Context was wrong\", context, gh.getContext());\n  }\n  @After\n  public void tearDown() {\n    if (gh != null) {\n      gh.releaseContext();\n    }\n  }\n  private class MockGenericHandler extends GenericHandler {\n    MockGenericHandler() {\n      super();\n    }\n    MockGenericHandler(String context) {\n      super(store, context);\n    }\n    MockGenericHandler(String context, boolean doClaim) {\n      super(store, context, doClaim);\n    }\n    @Override\n    public void handle(String target,\n                       Request baseRequest,\n                       HttpServletRequest request,\n                       HttpServletResponse response) throws IOException, ServletException {\n      // Do nothing, this class is only used for testing automatic claims\n    }\n  }\n"]], "pred": {"ppl": 1.9227843284606934, "ppl_lower": 2.258415937423706, "ppl/lowercase_ppl": -1.2460931037265626, "ppl/zlib": 0.0010735210289496892, "Min_5.0% Prob": 5.737553161123524, "Min_10.0% Prob": 4.3487827372043695, "Min_20.0% Prob": 2.87566682100296, "Min_30.0% Prob": 2.079349340467186, "Min_40.0% Prob": 1.6120486433437358, "Min_50.0% Prob": 1.302875582518438, "Min_60.0% Prob": 1.0891382768101185}}
{"hexsha": "ffc0f4bff0919baaeb33a8f2ded0d3b6c4233a46", "ext": "java", "lang": "Java", "content": "public abstract class AbstractMySqlHibernateConfiguration extends AbstractHibernateConfiguration {\n\n  public static final String DRIVER_CLASS_MYSQL = \"com.mysql.jdbc.Driver\";\n  public static final String DIALECT_MYSQL = \"org.hibernate.dialect.MySQL5InnoDBDialect\";\n\n  @Bean\n  @Override\n  public DataSource dataSource() {\n    return buildDataSource(DRIVER_CLASS_MYSQL,\n        \"jdbc:mysql://localhost/\" + getDatabaseName(),\n        \"root\",\n        \"root\");\n  }\n\n  @Override\n  public Properties hibernateProperties() {\n    Properties props = super.hibernateProperties();\n    props.put(Environment.DIALECT, DIALECT_MYSQL);\n    return props;\n  }\n\n}", "item_id": 0, "repo": "Rabbitsoft/hibernate-redis", "file": "hibernate-examples/src/main/java/org/hibernate/examples/hibernate/config/AbstractMySqlHibernateConfiguration.java", "last_update_at": "2022-03-30T08:01:24+00:00", "question_id": "ffc0f4bff0919baaeb33a8f2ded0d3b6c4233a46_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class AbstractMySqlHibernateConfiguration extends AbstractHibernateConfiguration {\n  public static final String DRIVER_CLASS_MYSQL = \"com.mysql.jdbc.Driver\";\n  public static final String DIALECT_MYSQL = \"org.hibernate.dialect.MySQL5InnoDBDialect\";\n  @Bean\n  @Override\n  public DataSource dataSource() {\n    return buildDataSource(DRIVER_CLASS_MYSQL,\n        \"jdbc:mysql://localhost/\" + getDatabaseName(),\n        \"root\",\n        \"root\");\n  }\n  @Override\n  public Properties hibernateProperties() {\n    Properties props = super.hibernateProperties();\n    props.put(Environment.DIALECT, DIALECT_MYSQL);\n    return props;\n  }\n"]], "pred": {"ppl": 1.8062024116516113, "ppl_lower": 2.8685531616210938, "ppl/lowercase_ppl": -1.7824095018936221, "ppl/zlib": 0.0017915955334577968, "Min_5.0% Prob": 5.45038808716668, "Min_10.0% Prob": 3.9658923149108887, "Min_20.0% Prob": 2.519685471380079, "Min_30.0% Prob": 1.883886308561672, "Min_40.0% Prob": 1.4622523314445406, "Min_50.0% Prob": 1.1786884066638768, "Min_60.0% Prob": 0.9900802709246138}}
{"hexsha": "88189a64409a4a3ed2c071fdfdc63cb42f0e429f", "ext": "java", "lang": "Java", "content": "@ExtendWith(WorkDirExtension.class)\npublic class MessageInputStreamTest\n{\n    public WorkDir testdir;\n\n    public ByteBufferPool bufferPool = new MappedByteBufferPool();\n\n    @Test\n    public void testBasicAppendRead() throws IOException\n    {\n        StreamTestSession session = new StreamTestSession();\n        MessageInputStream stream = new MessageInputStream(session);\n        session.setMessageInputStream(stream);\n\n        // Append a single message (simple, short)\n        ByteBuffer payload = BufferUtil.toBuffer(\"Hello World!\", StandardCharsets.UTF_8);\n        session.addContent(payload, true);\n        session.provideContent();\n\n        // Read entire message it from the stream.\n        byte[] buf = new byte[32];\n        int len = stream.read(buf);\n        String message = new String(buf, 0, len, StandardCharsets.UTF_8);\n\n        // Test it\n        assertThat(\"Message\", message, is(\"Hello World!\"));\n    }\n\n    @Test\n    public void testBlockOnRead() throws Exception\n    {\n        StreamTestSession session = new StreamTestSession();\n        MessageInputStream stream = new MessageInputStream(session);\n        session.setMessageInputStream(stream);\n        new Thread(session::provideContent).start();\n\n        final AtomicBoolean hadError = new AtomicBoolean(false);\n        final CountDownLatch startLatch = new CountDownLatch(1);\n\n        // This thread fills the stream (from the \"worker\" thread)\n        // But slowly (intentionally).\n        new Thread(() ->\n        {\n            try\n            {\n                startLatch.countDown();\n                TimeUnit.MILLISECONDS.sleep(200);\n                session.addContent(\"Saved\", false);\n                TimeUnit.MILLISECONDS.sleep(200);\n                session.addContent(\" by \", false);\n                TimeUnit.MILLISECONDS.sleep(200);\n                session.addContent(\"Zero\", false);\n                TimeUnit.MILLISECONDS.sleep(200);\n                session.addContent(\"\", true);\n            }\n            catch (Throwable t)\n            {\n                hadError.set(true);\n                t.printStackTrace(System.err);\n            }\n        }).start();\n\n        Assertions.assertTimeoutPreemptively(ofSeconds(5), () ->\n        {\n            // wait for thread to start\n            startLatch.await();\n\n            // Read it from the stream.\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            IO.copy(stream, out);\n            byte[] bytes = out.toByteArray();\n            String message = new String(bytes, 0, bytes.length, StandardCharsets.UTF_8);\n\n            // Test it\n            assertThat(\"Error when appending\", hadError.get(), is(false));\n            assertThat(\"Message\", message, is(\"Saved by Zero\"));\n        });\n    }\n\n    @Test\n    public void testBlockOnReadInitial() throws IOException\n    {\n        StreamTestSession session = new StreamTestSession();\n        MessageInputStream stream = new MessageInputStream(session);\n        session.setMessageInputStream(stream);\n        session.addContent(\"I will conquer\", true);\n\n        AtomicReference<Throwable> error = new AtomicReference<>();\n        new Thread(() ->\n        {\n            try\n            {\n                // wait for a little bit before initiating write to stream\n                TimeUnit.MILLISECONDS.sleep(1000);\n                session.provideContent();\n            }\n            catch (Throwable t)\n            {\n                error.set(t);\n                t.printStackTrace(System.err);\n            }\n        }).start();\n\n        Assertions.assertTimeoutPreemptively(ofSeconds(10), () ->\n        {\n            // Read byte from stream, block until byte received.\n            int b = stream.read();\n            assertThat(\"Initial byte\", b, is((int)'I'));\n\n            // No error occurred.\n            assertNull(error.get());\n        });\n    }\n\n    @Test\n    public void testReadByteNoBuffersClosed() throws IOException\n    {\n        try (MessageInputStream stream = new MessageInputStream(new EmptySession()))\n        {\n            final AtomicBoolean hadError = new AtomicBoolean(false);\n\n            new Thread(() ->\n            {\n                try\n                {\n                    // wait for a little bit before sending input closed\n                    TimeUnit.MILLISECONDS.sleep(1000);\n                    stream.appendFrame(null, true);\n                    stream.messageComplete();\n                }\n                catch (InterruptedException | IOException e)\n                {\n                    hadError.set(true);\n                    e.printStackTrace(System.err);\n                }\n            }).start();\n\n            Assertions.assertTimeoutPreemptively(ofSeconds(10), () ->\n            {\n                // Read byte from stream. Should be a -1, indicating the end of the stream.\n                int b = stream.read();\n                assertThat(\"Initial byte\", b, is(-1));\n\n                // No error occurred.\n                assertThat(\"Error when appending\", hadError.get(), is(false));\n            });\n        }\n    }\n\n    @Test\n    public void testSplitMessageWithEmptyPayloads() throws IOException\n    {\n        StreamTestSession session = new StreamTestSession();\n        MessageInputStream stream = new MessageInputStream(session);\n        session.setMessageInputStream(stream);\n\n        session.addContent(\"\", false);\n        session.addContent(\"Hello\", false);\n        session.addContent(\"\", false);\n        session.addContent(\" World\", false);\n        session.addContent(\"!\", false);\n        session.addContent(\"\", true);\n        session.provideContent();\n\n        // Read entire message it from the stream.\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        IO.copy(stream, out);\n        byte[] bytes = out.toByteArray();\n        String message = new String(bytes, 0, bytes.length, StandardCharsets.UTF_8);\n\n        // Test it\n        assertThat(\"Message\", message, is(\"Hello World!\"));\n    }\n\n    @Test\n    public void testReadBeforeFirstAppend() throws IOException\n    {\n        StreamTestSession session = new StreamTestSession();\n        MessageInputStream stream = new MessageInputStream(session);\n        session.setMessageInputStream(stream);\n\n        // Append a single message (simple, short)\n        session.addContent(BufferUtil.EMPTY_BUFFER, false);\n        session.addContent(\"Hello World\", true);\n\n        new Thread(() ->\n        {\n            try\n            {\n                Thread.sleep(2000);\n                session.provideContent();\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e);\n            }\n        }).start();\n\n        // Read entire message it from the stream.\n        byte[] buf = new byte[32];\n        int len = stream.read(buf);\n        String message = new String(buf, 0, len, StandardCharsets.UTF_8);\n\n        // Test it\n        assertThat(\"Message\", message, is(\"Hello World\"));\n    }\n\n    public static class StreamTestSession extends EmptySession\n    {\n        private static final ByteBuffer EOF = BufferUtil.allocate(0);\n        private final AtomicBoolean suspended = new AtomicBoolean(false);\n        private BlockingArrayQueue<ByteBuffer> contentQueue = new BlockingArrayQueue<>();\n        private MessageInputStream stream;\n\n        public void setMessageInputStream(MessageInputStream stream)\n        {\n            this.stream = stream;\n        }\n\n        public void addContent(String content, boolean last)\n        {\n            addContent(BufferUtil.toBuffer(content, StandardCharsets.UTF_8), last);\n        }\n\n        public void addContent(ByteBuffer content, boolean last)\n        {\n            contentQueue.add(content);\n            if (last)\n                contentQueue.add(EOF);\n        }\n\n        public void provideContent()\n        {\n            pollAndAppendFrame();\n        }\n\n        @Override\n        public void resume()\n        {\n            if (!suspended.compareAndSet(true, false))\n                throw new IllegalStateException();\n            pollAndAppendFrame();\n        }\n\n        @Override\n        public SuspendToken suspend()\n        {\n            if (!suspended.compareAndSet(false, true))\n                throw new IllegalStateException();\n            return super.suspend();\n        }\n\n        private void pollAndAppendFrame()\n        {\n            try\n            {\n                while (true)\n                {\n                    ByteBuffer content = contentQueue.poll(10, TimeUnit.SECONDS);\n                    assertNotNull(content);\n\n                    boolean eof = (content == EOF);\n                    stream.appendFrame(content, eof);\n                    if (eof)\n                    {\n                        stream.messageComplete();\n                        break;\n                    }\n\n                    if (suspended.get())\n                        break;\n                }\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}", "item_id": 0, "repo": "nkedel/jetty.project", "file": "jetty-websocket/websocket-common/src/test/java/org/eclipse/jetty/websocket/common/message/MessageInputStreamTest.java", "last_update_at": "2022-03-21T14:22:01+00:00", "question_id": "88189a64409a4a3ed2c071fdfdc63cb42f0e429f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ExtendWith(WorkDirExtension.class)\npublic class MessageInputStreamTest\n{\n    public WorkDir testdir;\n    public ByteBufferPool bufferPool = new MappedByteBufferPool();\n    @Test\n    public void testBasicAppendRead() throws IOException\n    {\n        StreamTestSession session = new StreamTestSession();\n        MessageInputStream stream = new MessageInputStream(session);\n        session.setMessageInputStream(stream);\n        // Append a single message (simple, short)\n        ByteBuffer payload = BufferUtil.toBuffer(\"Hello World!\", StandardCharsets.UTF_8);\n        session.addContent(payload, true);\n        session.provideContent();\n        // Read entire message it from the stream.\n        byte[] buf = new byte[32];\n        int len = stream.read(buf);\n        String message = new String(buf, 0, len, StandardCharsets.UTF_8);\n        // Test it\n        assertThat(\"Message\", message, is(\"Hello World!\"));\n    }\n    @Test\n    public void testBlockOnRead() throws Exception\n    {\n        StreamTestSession session = new StreamTestSession();\n        MessageInputStream stream = new MessageInputStream(session);\n        session.setMessageInputStream(stream);\n        new Thread(session::provideContent).start();\n        final AtomicBoolean hadError = new AtomicBoolean(false);\n        final CountDownLatch startLatch = new CountDownLatch(1);\n        // This thread fills the stream (from the \"worker\" thread)\n        // But slowly (intentionally).\n        new Thread(() ->\n        {\n            try\n            {\n                startLatch.countDown();\n                TimeUnit.MILLISECONDS.sleep(200);\n                session.addContent(\"Saved\", false);\n                TimeUnit.MILLISECONDS.sleep(200);\n                session.addContent(\" by \", false);\n                TimeUnit.MILLISECONDS.sleep(200);\n                session.addContent(\"Zero\", false);\n                TimeUnit.MILLISECONDS.sleep(200);\n                session.addContent(\"\", true);\n            }\n            catch (Throwable t)\n            {\n                hadError.set(true);\n                t.printStackTrace(System.err);\n            }\n        }).start();\n        Assertions.assertTimeoutPreemptively(ofSeconds(5), () ->\n        {\n            // wait for thread to start\n            startLatch.await();\n            // Read it from the stream.\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            IO.copy(stream, out);\n            byte[] bytes = out.toByteArray();\n            String message = new String(bytes, 0, bytes.length, StandardCharsets.UTF_8);\n            // Test it\n            assertThat(\"Error when appending\", hadError.get(), is(false));\n            assertThat(\"Message\", message, is(\"Saved by Zero\"));\n        });\n    }\n    @Test\n    public void testBlockOnReadInitial() throws IOException\n    {\n        StreamTestSession session = new StreamTestSession();\n        MessageInputStream stream = new MessageInputStream(session);\n        session.setMessageInputStream(stream);\n        session.addContent(\"I will conquer\", true);\n        AtomicReference<Throwable> error = new AtomicReference<>();\n        new Thread(() ->\n        {\n            try\n            {\n                // wait for a little bit before initiating write to stream\n                TimeUnit.MILLISECONDS.sleep(1000);\n                session.provideContent();\n            }\n            catch (Throwable t)\n            {\n                error.set(t);\n                t.printStackTrace(System.err);\n            }\n        }).start();\n        Assertions.assertTimeoutPreemptively(ofSeconds(10), () ->\n        {\n            // Read byte from stream, block until byte received.\n            int b = stream.read();\n            assertThat(\"Initial byte\", b, is((int)'I'));\n            // No error occurred.\n            assertNull(error.get());\n        });\n    }\n    @Test\n    public void testReadByteNoBuffersClosed() throws IOException\n    {\n        try (MessageInputStream stream = new MessageInputStream(new EmptySession()))\n        {\n            final AtomicBoolean hadError = new AtomicBoolean(false);\n            new Thread(() ->\n            {\n                try\n                {\n                    // wait for a little bit before sending input closed\n                    TimeUnit.MILLISECONDS.sleep(1000);\n                    stream.appendFrame(null, true);\n                    stream.messageComplete();\n                }\n                catch (InterruptedException | IOException e)\n                {\n                    hadError.set(true);\n                    e.printStackTrace(System.err);\n                }\n            }).start();\n            Assertions.assertTimeoutPreemptively(ofSeconds(10), () ->\n            {\n                // Read byte from stream. Should be a -1, indicating the end of the stream.\n                int b = stream.read();\n                assertThat(\"Initial byte\", b, is(-1));\n                // No error occurred.\n                assertThat(\"Error when appending\", hadError.get(), is(false));\n            });\n        }\n    }\n    @Test\n    public void testSplitMessageWithEmptyPayloads() throws IOException\n    {\n        StreamTestSession session = new StreamTestSession();\n        MessageInputStream stream = new MessageInputStream(session);\n        session.setMessageInputStream(stream);\n        session.addContent(\"\", false);\n        session.addContent(\"Hello\", false);\n        session.addContent(\"\", false);\n        session.addContent(\" World\", false);\n        session.addContent(\"!\", false);\n        session.addContent(\"\", true);\n        session.provideContent();\n        // Read entire message it from the stream.\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        IO.copy(stream, out);\n        byte[] bytes = out.toByteArray();\n        String message = new String(bytes, 0, bytes.length, StandardCharsets.UTF_8);\n        // Test it\n        assertThat(\"Message\", message, is(\"Hello World!\"));\n    }\n    @Test\n    public void testReadBeforeFirstAppend() throws IOException\n    {\n        StreamTestSession session = new StreamTestSession();\n        MessageInputStream stream = new MessageInputStream(session);\n        session.setMessageInputStream(stream);\n        // Append a single message (simple, short)\n        session.addContent(BufferUtil.EMPTY_BUFFER, false);\n        session.addContent(\"Hello World\", true);\n        new Thread(() ->\n        {\n            try\n            {\n                Thread.sleep(2000);\n                session.provideContent();\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e);\n            }\n        }).start();\n        // Read entire message it from the stream.\n        byte[] buf = new byte[32];\n        int len = stream.read(buf);\n        String message = new String(buf, 0, len, StandardCharsets.UTF_8);\n        // Test it\n        assertThat(\"Message\", message, is(\"Hello World\"));\n    }\n    public static class StreamTestSession extends EmptySession\n    {\n        private static final ByteBuffer EOF = BufferUtil.allocate(0);\n        private final AtomicBoolean suspended = new AtomicBoolean(false);\n        private BlockingArrayQueue<ByteBuffer> contentQueue = new BlockingArrayQueue<>();\n        private MessageInputStream stream;\n        public void setMessageInputStream(MessageInputStream stream)\n        {\n            this.stream = stream;\n        }\n        public void addContent(String content, boolean last)\n        {\n            addContent(BufferUtil.toBuffer(content, StandardCharsets.UTF_8), last);\n        }\n        public void addContent(ByteBuffer content, boolean last)\n        {\n            contentQueue.add(content);\n            if (last)\n                contentQueue.add(EOF);\n        }\n        public void provideContent()\n        {\n            pollAndAppendFrame();\n        }\n        @Override\n        public void resume()\n        {\n            if (!suspended.compareAndSet(true, false))\n                throw new IllegalStateException();\n            pollAndAppendFrame();\n        }\n        @Override\n        public SuspendToken suspend()\n        {\n            if (!suspended.compareAndSet(false, true))\n                throw new IllegalStateException();\n            return super.suspend();\n        }\n        private void pollAndAppendFrame()\n        {\n            try\n            {\n                while (true)\n                {\n                    ByteBuffer content = contentQueue.poll(10, TimeUnit.SECONDS);\n                    assertNotNull(content);\n                    boolean eof = (content == EOF);\n                    stream.appendFrame(content, eof);\n                    if (eof)\n                    {\n                        stream.messageComplete();\n                        break;\n                    }\n                    if (suspended.get())\n                        break;\n                }\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n"]], "pred": {"ppl": 2.0323545932769775, "ppl_lower": 2.487595558166504, "ppl/lowercase_ppl": -1.2850014173353308, "ppl/zlib": 0.0003929058277327017, "Min_5.0% Prob": 6.749002727807737, "Min_10.0% Prob": 5.020097861102983, "Min_20.0% Prob": 3.2807603387856017, "Min_30.0% Prob": 2.327505277944546, "Min_40.0% Prob": 1.765970083541057, "Min_50.0% Prob": 1.4183372782667234, "Min_60.0% Prob": 1.1833023464563188}}
{"hexsha": "7390a4df502c2c4e797ae780d36cb491a985a38f", "ext": "java", "lang": "Java", "content": "class ConstructorAPI implements Comparable {\n    /** \n     * The type of the constructor, being all the parameter types\n     * separated by commas.\n     */\n    public String type_ = null;\n    \n    /** \n     * The exceptions thrown by this constructor, being all the exception types\n     * separated by commas. \"no exceptions\" if no exceptions are thrown.\n     */\n    public String exceptions_ = \"no exceptions\";\n    \n    /** Modifiers for this class. */\n    public Modifiers modifiers_;\n\n    /** The doc block, default is null. */\n    public String doc_ = null;\n\n    /** Constructor. */\n    public ConstructorAPI(String type, Modifiers modifiers) {\n        type_ = type;\n        modifiers_ = modifiers;\n    }\n\n    /** Compare two ConstructorAPI objects by type and modifiers. */\n    public int compareTo(Object o) {\n        ConstructorAPI constructorAPI = (ConstructorAPI)o;\n        int comp = type_.compareTo(constructorAPI.type_);\n        if (comp != 0)\n            return comp;\n        comp = exceptions_.compareTo(constructorAPI.exceptions_);\n        if (comp != 0)\n            return comp;\n        comp = modifiers_.compareTo(constructorAPI.modifiers_);\n        if (comp != 0)\n            return comp;\n        if (APIComparator.docChanged(doc_, constructorAPI.doc_))\n            return -1;\n        return 0;\n    }\n\n    /** \n     * Tests two constructors, using just the type, used by indexOf(). \n     */\n    public boolean equals(Object o) {\n        if (type_.compareTo(((ConstructorAPI)o).type_) == 0)\n            return true;\n        return false;\n    }\n}", "item_id": 0, "repo": "ljmf00/autopsy", "file": "thirdparty/jdiff/v-custom/src/jdiff/ConstructorAPI.java", "last_update_at": "2022-03-30T09:45:34+00:00", "question_id": "7390a4df502c2c4e797ae780d36cb491a985a38f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class ConstructorAPI implements Comparable {\n    /** \n     * The type of the constructor, being all the parameter types\n     * separated by commas.\n     */\n    public String type_ = null;\n    /** \n     * The exceptions thrown by this constructor, being all the exception types\n     * separated by commas. \"no exceptions\" if no exceptions are thrown.\n     */\n    public String exceptions_ = \"no exceptions\";\n    /** Modifiers for this class. */\n    public Modifiers modifiers_;\n    /** The doc block, default is null. */\n    public String doc_ = null;\n    /** Constructor. */\n    public ConstructorAPI(String type, Modifiers modifiers) {\n        type_ = type;\n        modifiers_ = modifiers;\n    }\n    /** Compare two ConstructorAPI objects by type and modifiers. */\n    public int compareTo(Object o) {\n        ConstructorAPI constructorAPI = (ConstructorAPI)o;\n        int comp = type_.compareTo(constructorAPI.type_);\n        if (comp != 0)\n            return comp;\n        comp = exceptions_.compareTo(constructorAPI.exceptions_);\n        if (comp != 0)\n            return comp;\n        comp = modifiers_.compareTo(constructorAPI.modifiers_);\n        if (comp != 0)\n            return comp;\n        if (APIComparator.docChanged(doc_, constructorAPI.doc_))\n            return -1;\n        return 0;\n    }\n    /** \n     * Tests two constructors, using just the type, used by indexOf(). \n     */\n    public boolean equals(Object o) {\n        if (type_.compareTo(((ConstructorAPI)o).type_) == 0)\n            return true;\n        return false;\n    }\n"]], "pred": {"ppl": 2.5145771503448486, "ppl_lower": 2.6630287170410156, "ppl/lowercase_ppl": -1.0622049044350266, "ppl/zlib": 0.0018516157798001644, "Min_5.0% Prob": 8.029644625527519, "Min_10.0% Prob": 6.160921096801758, "Min_20.0% Prob": 4.077181894638959, "Min_30.0% Prob": 2.9784013943409358, "Min_40.0% Prob": 2.280329003141207, "Min_50.0% Prob": 1.8353298200128223, "Min_60.0% Prob": 1.5378626273652793}}
{"hexsha": "d8377ec8ea407a5942f9f6a2b9ea8f9371b1e0aa", "ext": "java", "lang": "Java", "content": "public class UntaggedWithSchemaDeserializationTests {\n    private static final int SIMPLE_VERSION = 2;\n    private RecordV1 recordIn;\n    private SchemaDef recordV1Schema;\n    private SimpleBinaryReader reader;\n\n    /*\n     * These tests all begin with serialized data containing the schema for\n     * RecordV1 and a real RecordV1. The actual tests vary the type they\n     * attempt to deserialize into.\n     */\n    @Before\n    public void setup() throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final SimpleBinaryWriter writer = new SimpleBinaryWriter(baos, SIMPLE_VERSION);\n        final Serializer<SchemaDef> schemaSerializer = new Serializer<SchemaDef>();\n        final Serializer<RecordV1> recordSerializer = new Serializer<RecordV1>();\n        recordIn = new RecordV1();\n        recordIn.name = \"event\";\n        recordIn.tstamp = 800;\n\n        schemaSerializer.serialize(RecordV1.BOND_TYPE.buildSchemaDef(), writer);\n        recordSerializer.serialize(recordIn, writer);\n\n        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        reader = new SimpleBinaryReader(bais, SIMPLE_VERSION);\n        final Deserializer<SchemaDef> schemaDeserializer = new Deserializer<SchemaDef>(SchemaDef.BOND_TYPE);\n        recordV1Schema = schemaDeserializer.deserialize(reader);\n    }\n\n    @Test\n    public void sameTypeAsSchema() throws IOException {\n        final Deserializer<RecordV1> recordV1Deserializer = new Deserializer<RecordV1>(RecordV1.BOND_TYPE);\n        final RecordV1 recordOut = recordV1Deserializer.deserialize(reader, recordV1Schema);\n\n        Assert.assertEquals(recordIn, recordOut);\n    }\n\n    @Test\n    public void fieldAdded() throws IOException {\n        final Deserializer<RecordV2> recordV2Deserializer = new Deserializer<RecordV2>(RecordV2.BOND_TYPE);\n        final RecordV2 recordOut = recordV2Deserializer.deserialize(reader, recordV1Schema);\n\n        Assert.assertEquals(recordIn.name, recordOut.name);\n        Assert.assertEquals(recordIn.tstamp, recordOut.tstamp);\n        Assert.assertEquals(\"\", recordOut.location);\n    }\n\n    @Test\n    public void fieldRemoved() throws IOException {\n        final Deserializer<FieldRemovedRecord> fieldRemovedRecordDeserializer =\n            new Deserializer<FieldRemovedRecord>(FieldRemovedRecord.BOND_TYPE);\n        final FieldRemovedRecord recordOut = fieldRemovedRecordDeserializer.deserialize(reader, recordV1Schema);\n\n        Assert.assertEquals(recordIn.tstamp, recordOut.tstamp);\n    }\n}", "item_id": 0, "repo": "glenfe/microsoft.bond", "file": "java/core/src/test/java/org/bondlib/UntaggedWithSchemaDeserializationTests.java", "last_update_at": "2022-03-26T22:47:59+00:00", "question_id": "d8377ec8ea407a5942f9f6a2b9ea8f9371b1e0aa_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UntaggedWithSchemaDeserializationTests {\n    private static final int SIMPLE_VERSION = 2;\n    private RecordV1 recordIn;\n    private SchemaDef recordV1Schema;\n    private SimpleBinaryReader reader;\n    /*\n     * These tests all begin with serialized data containing the schema for\n     * RecordV1 and a real RecordV1. The actual tests vary the type they\n     * attempt to deserialize into.\n     */\n    @Before\n    public void setup() throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final SimpleBinaryWriter writer = new SimpleBinaryWriter(baos, SIMPLE_VERSION);\n        final Serializer<SchemaDef> schemaSerializer = new Serializer<SchemaDef>();\n        final Serializer<RecordV1> recordSerializer = new Serializer<RecordV1>();\n        recordIn = new RecordV1();\n        recordIn.name = \"event\";\n        recordIn.tstamp = 800;\n        schemaSerializer.serialize(RecordV1.BOND_TYPE.buildSchemaDef(), writer);\n        recordSerializer.serialize(recordIn, writer);\n        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        reader = new SimpleBinaryReader(bais, SIMPLE_VERSION);\n        final Deserializer<SchemaDef> schemaDeserializer = new Deserializer<SchemaDef>(SchemaDef.BOND_TYPE);\n        recordV1Schema = schemaDeserializer.deserialize(reader);\n    }\n    @Test\n    public void sameTypeAsSchema() throws IOException {\n        final Deserializer<RecordV1> recordV1Deserializer = new Deserializer<RecordV1>(RecordV1.BOND_TYPE);\n        final RecordV1 recordOut = recordV1Deserializer.deserialize(reader, recordV1Schema);\n        Assert.assertEquals(recordIn, recordOut);\n    }\n    @Test\n    public void fieldAdded() throws IOException {\n        final Deserializer<RecordV2> recordV2Deserializer = new Deserializer<RecordV2>(RecordV2.BOND_TYPE);\n        final RecordV2 recordOut = recordV2Deserializer.deserialize(reader, recordV1Schema);\n        Assert.assertEquals(recordIn.name, recordOut.name);\n        Assert.assertEquals(recordIn.tstamp, recordOut.tstamp);\n        Assert.assertEquals(\"\", recordOut.location);\n    }\n    @Test\n    public void fieldRemoved() throws IOException {\n        final Deserializer<FieldRemovedRecord> fieldRemovedRecordDeserializer =\n            new Deserializer<FieldRemovedRecord>(FieldRemovedRecord.BOND_TYPE);\n        final FieldRemovedRecord recordOut = fieldRemovedRecordDeserializer.deserialize(reader, recordV1Schema);\n        Assert.assertEquals(recordIn.tstamp, recordOut.tstamp);\n    }\n"]], "pred": {"ppl": 1.8546172380447388, "ppl_lower": 2.096883773803711, "ppl/lowercase_ppl": -1.1987668735159425, "ppl/zlib": 0.0008938904979617098, "Min_5.0% Prob": 6.3612509568532305, "Min_10.0% Prob": 4.671385417381923, "Min_20.0% Prob": 2.9152198791503907, "Min_30.0% Prob": 2.038505167078038, "Min_40.0% Prob": 1.5397097158406314, "Min_50.0% Prob": 1.2336353950982415, "Min_60.0% Prob": 1.0304492329092076}}
{"hexsha": "7a080dc263b61a87e167758217177a0cd3c56480", "ext": "java", "lang": "Java", "content": "@WebServlet(description = \"Login servlet\", urlPatterns = { \"/login\" })\npublic class Login extends HttpServlet {\n\tprivate static final long serialVersionUID = 4815162342L;\n\tprivate static Logger logger = Logger.getLogger(Login.class.getName());\n\n\t/**\n\t * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n\t */\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\tRequestDispatcher dispatcher = getServletContext().getRequestDispatcher(\"/WEB-INF/jsps/login.jsp\");\n        dispatcher.forward(request, response);\n\t}\n\n\t/**\n\t * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n\t */\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\tboolean success = false;\n\t\tString id = request.getParameter(\"id\");\n\t\tString password = request.getParameter(\"password\");\n\n\t\ttry {\n\t\t\tif (request.getUserPrincipal() != null) request.logout(); //in case there's a left over auth cookie but we ended up here\n\n\t\t\trequest.login(id, password);\n\n\t\t\tCookie cookie = new Cookie(\"user\", id); //clear text user id that can be used in Istio routing rules\n\t\t\tresponse.addCookie(cookie);\n\n\t\t\tsuccess = true;\n\t\t\tlogger.info(\"Successfully logged in user: \"+id);\n\t\t} catch (Throwable t) {\n\t\t\tlogException(t);\n\t\t}\n\n\t\tString url = \"error\";\n\t\tif (success) url = \"summary\";\n\n\t\tresponse.sendRedirect(url);\n\t}\n\n\tprivate void logException(Throwable t) {\n\t\tlogger.warning(t.getClass().getName()+\": \"+t.getMessage());\n\n\t\t//only log the stack trace if the level has been set to at least FINE\n\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\tStringWriter writer = new StringWriter();\n\t\t\tt.printStackTrace(new PrintWriter(writer));\n\t\t\tlogger.fine(writer.toString());\n\t\t}\n\t}\n}", "item_id": 0, "repo": "rtclauss/trader", "file": "src/main/java/com/ibm/hybrid/cloud/sample/stocktrader/trader/Login.java", "last_update_at": "2022-03-08T04:10:15+00:00", "question_id": "7a080dc263b61a87e167758217177a0cd3c56480_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@WebServlet(description = \"Login servlet\", urlPatterns = { \"/login\" })\npublic class Login extends HttpServlet {\n\tprivate static final long serialVersionUID = 4815162342L;\n\tprivate static Logger logger = Logger.getLogger(Login.class.getName());\n\t/**\n\t * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n\t */\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\tRequestDispatcher dispatcher = getServletContext().getRequestDispatcher(\"/WEB-INF/jsps/login.jsp\");\n        dispatcher.forward(request, response);\n\t}\n\t/**\n\t * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n\t */\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\tboolean success = false;\n\t\tString id = request.getParameter(\"id\");\n\t\tString password = request.getParameter(\"password\");\n\t\ttry {\n\t\t\tif (request.getUserPrincipal() != null) request.logout(); //in case there's a left over auth cookie but we ended up here\n\t\t\trequest.login(id, password);\n\t\t\tCookie cookie = new Cookie(\"user\", id); //clear text user id that can be used in Istio routing rules\n\t\t\tresponse.addCookie(cookie);\n\t\t\tsuccess = true;\n\t\t\tlogger.info(\"Successfully logged in user: \"+id);\n\t\t} catch (Throwable t) {\n\t\t\tlogException(t);\n\t\t}\n\t\tString url = \"error\";\n\t\tif (success) url = \"summary\";\n\t\tresponse.sendRedirect(url);\n\t}\n\tprivate void logException(Throwable t) {\n\t\tlogger.warning(t.getClass().getName()+\": \"+t.getMessage());\n\t\t//only log the stack trace if the level has been set to at least FINE\n\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\tStringWriter writer = new StringWriter();\n\t\t\tt.printStackTrace(new PrintWriter(writer));\n\t\t\tlogger.fine(writer.toString());\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.7795960903167725, "ppl_lower": 2.25555157661438, "ppl/lowercase_ppl": -1.4111965726229538, "ppl/zlib": 0.0007168985360726238, "Min_5.0% Prob": 6.0768299014480025, "Min_10.0% Prob": 4.322265304218639, "Min_20.0% Prob": 2.6897547759793023, "Min_30.0% Prob": 1.8864913353865798, "Min_40.0% Prob": 1.4324128386141224, "Min_50.0% Prob": 1.151216854534366, "Min_60.0% Prob": 0.9613493657050033}}
{"hexsha": "5c8c53208954b68f74dc57980015e9310165dec1", "ext": "java", "lang": "Java", "content": "class SudokuBacktracking {\n    // Driver code\n    public static void main(String[] args) {\n        int[][] grid = {{ 0, 7, 0, 0, 0, 0, 0, 0, 9 },\n                        { 5, 1, 0, 4, 2, 0, 6, 0, 0 },\n                        { 0, 8, 0, 3, 0, 0, 7, 0, 0 },\n                        { 0, 0, 8, 0, 0, 1, 3, 7, 0 },\n                        { 0, 2, 3, 0, 8, 0, 0, 4, 0 },\n                        { 4, 0, 0, 9, 0, 0, 1, 0, 0 },\n                        { 9, 6, 2, 8, 0, 0, 0, 3, 0 },\n                        { 0, 0, 0, 0, 1, 0, 4, 0, 0 },\n                        { 7, 0, 0, 2, 0, 3, 0, 9, 6 }};\n        sudokuSolver(grid,0,0);\n    }\n\n    // This function is used to print the answer grid.\n    public static void display(int[][] grid) {\n        for(int a=0;a<grid.length;a++) {\n            for(int b=0;b<grid[0].length;b++) {\n                System.out.print(grid[a][b] + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    /* This function checks if a particular value from 1 to 9 can \n        be placed in the particular cell. If the value can be placed\n        then it checks for the next column in the specific row */\n    public static void sudokuSolver(int[][] grid, int row, int col) {\n        // This is base condition, when all the cells of the grid are filled successfully.\n        if(row == grid.length-1 && col == grid[0].length) {\n            display(grid);\n            System.out.println();\n            return;\n        }\n        /* If all the columns of a particular row are filled successfully\n            then the row is incremented and column is set to 0. */\n        if(col == grid[0].length) {\n            row = row + 1;\n            col = 0;\n        }\n        if(grid[row][col] != 0) sudokuSolver(grid,row,col+1);\n        else {\n            for (int val=1;val<=9;val++) {\n                if(isSafeForSudoku(grid,row,col,val)) {\n                    grid[row][col] = val;\n                    sudokuSolver(grid,row,col+1);\n                    grid[row][col] = 0;\n                }\n            }\n        }\n    }\n\n    /* This function checks if a particular value from 1 to 9 can be placed \n        in grid[row][col]. It checks for entire row, entire column and \n        the corresponding 3x3 box */\n    public static boolean isSafeForSudoku(int[][] grid, int row, int col, int val) {\n        // checking entire column\n        for (int k=0;k<grid.length;k++) {\n            if (grid[k][col] == val) return false;\n        }\n        // checking entire row\n        for (int k=0;k<grid[0].length;k++) {\n            if(grid[row][k] == val) return false;\n        }\n        // checking 3x3 box\n        row = row - (row % 3);    // gives the starting index of row of particular 3x3 box\n        col = col - (col % 3);    // gives the starting index of col of particular 3x3 box\n        for(int k=0;k<3;k++) {\n            for(int l=0;l<3;l++) {\n                if(grid[row+k][col+l] == val) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n}", "item_id": 0, "repo": "abdzitter/Daily-Coding-DS-ALGO-Practice", "file": "Algorithms/Backtracking/Java/SudokuBacktracking.java", "last_update_at": "2022-03-28T23:13:25+00:00", "question_id": "5c8c53208954b68f74dc57980015e9310165dec1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class SudokuBacktracking {\n    // Driver code\n    public static void main(String[] args) {\n        int[][] grid = {{ 0, 7, 0, 0, 0, 0, 0, 0, 9 },\n                        { 5, 1, 0, 4, 2, 0, 6, 0, 0 },\n                        { 0, 8, 0, 3, 0, 0, 7, 0, 0 },\n                        { 0, 0, 8, 0, 0, 1, 3, 7, 0 },\n                        { 0, 2, 3, 0, 8, 0, 0, 4, 0 },\n                        { 4, 0, 0, 9, 0, 0, 1, 0, 0 },\n                        { 9, 6, 2, 8, 0, 0, 0, 3, 0 },\n                        { 0, 0, 0, 0, 1, 0, 4, 0, 0 },\n                        { 7, 0, 0, 2, 0, 3, 0, 9, 6 }};\n        sudokuSolver(grid,0,0);\n    }\n    // This function is used to print the answer grid.\n    public static void display(int[][] grid) {\n        for(int a=0;a<grid.length;a++) {\n            for(int b=0;b<grid[0].length;b++) {\n                System.out.print(grid[a][b] + \" \");\n            }\n            System.out.println();\n        }\n    }\n    /* This function checks if a particular value from 1 to 9 can \n        be placed in the particular cell. If the value can be placed\n        then it checks for the next column in the specific row */\n    public static void sudokuSolver(int[][] grid, int row, int col) {\n        // This is base condition, when all the cells of the grid are filled successfully.\n        if(row == grid.length-1 && col == grid[0].length) {\n            display(grid);\n            System.out.println();\n            return;\n        }\n        /* If all the columns of a particular row are filled successfully\n            then the row is incremented and column is set to 0. */\n        if(col == grid[0].length) {\n            row = row + 1;\n            col = 0;\n        }\n        if(grid[row][col] != 0) sudokuSolver(grid,row,col+1);\n        else {\n            for (int val=1;val<=9;val++) {\n                if(isSafeForSudoku(grid,row,col,val)) {\n                    grid[row][col] = val;\n                    sudokuSolver(grid,row,col+1);\n                    grid[row][col] = 0;\n                }\n            }\n        }\n    }\n    /* This function checks if a particular value from 1 to 9 can be placed \n        in grid[row][col]. It checks for entire row, entire column and \n        the corresponding 3x3 box */\n    public static boolean isSafeForSudoku(int[][] grid, int row, int col, int val) {\n        // checking entire column\n        for (int k=0;k<grid.length;k++) {\n            if (grid[k][col] == val) return false;\n        }\n        // checking entire row\n        for (int k=0;k<grid[0].length;k++) {\n            if(grid[row][k] == val) return false;\n        }\n        // checking 3x3 box\n        row = row - (row % 3);    // gives the starting index of row of particular 3x3 box\n        col = col - (col % 3);    // gives the starting index of col of particular 3x3 box\n        for(int k=0;k<3;k++) {\n            for(int l=0;l<3;l++) {\n                if(grid[row+k][col+l] == val) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n"]], "pred": {"ppl": 1.7099334001541138, "ppl_lower": 1.7569875717163086, "ppl/lowercase_ppl": -1.0506032050116818, "ppl/zlib": 0.0005901588806136496, "Min_5.0% Prob": 4.905236576117721, "Min_10.0% Prob": 3.7624795062869203, "Min_20.0% Prob": 2.4144752478482676, "Min_30.0% Prob": 1.738219510398659, "Min_40.0% Prob": 1.3305378692602616, "Min_50.0% Prob": 1.0708592819148373, "Min_60.0% Prob": 0.894493328262315}}
{"hexsha": "01ce4c2352ebab86846c3b1a6363425811555a6b", "ext": "java", "lang": "Java", "content": "@PublishTestModule(\n\ttestName = \"fapi1-advanced-final-par-attempt-invalid-redirect_uri\",\n\tdisplayName = \"PAR : try to use an invalid redirect_uri \",\n\tsummary = \"This test tries to provide an invalid redirect_uri and expects authorization server to return an error\",\n\tprofile = \"FAPI1-Advanced-Final\",\n\tconfigurationFields = {\n\t\t\"server.discoveryUrl\",\n\t\t\"client.client_id\",\n\t\t\"client.scope\",\n\t\t\"client.jwks\",\n\t\t\"mtls.key\",\n\t\t\"mtls.cert\",\n\t\t\"mtls.ca\",\n\t\t\"client2.client_id\",\n\t\t\"client2.scope\",\n\t\t\"client2.jwks\",\n\t\t\"mtls2.key\",\n\t\t\"mtls2.cert\",\n\t\t\"mtls2.ca\",\n\t\t\"resource.resourceUrl\"\n\t}\n)\n@VariantNotApplicable(parameter = FAPIAuthRequestMethod.class, values = {\n\t\"by_value\"\n})\npublic class FAPI1AdvancedFinalPARRejectInvalidRedirectUri extends AbstractFAPI1AdvancedFinalExpectingAuthorizationEndpointPlaceholderOrCallback {\n\n\t@Override\n\tprotected void createPlaceholder() {\n\t\tcallAndStopOnFailure(ExpectRedirectUriErrorPage.class, \"FAPI1-BASE-5.2.2-9\", \"PAR-2.3\");\n\n\t\tenv.putString(\"error_callback_placeholder\", env.getString(\"redirect_uri_missing_error\"));\n\t}\n\n\t@Override\n\tprotected ConditionSequence makeCreateAuthorizationRequestObjectSteps() {\n\t\treturn super.makeCreateAuthorizationRequestObjectSteps().\n\t\t\tbutFirst(condition(AddBadRedirectUriToRequestParameters.class));\n\t}\n\n\t@Override\n\tprotected void performParAuthorizationRequestFlow() {\n\t\tcallAndStopOnFailure(CallPAREndpoint.class);\n\n\t\tcallAndContinueOnFailure(EnsurePARInvalidRequestOrInvalidRequestObjectError.class, Condition.ConditionResult.FAILURE, \"PAR-2.3\");\n\n\t\tfireTestFinished();\n\t}\n}", "item_id": 0, "repo": "openid-certification/-conformance-suite", "file": "src/main/java/net/openid/conformance/fapi1advancedfinal/FAPI1AdvancedFinalPARRejectInvalidRedirectUri.java", "last_update_at": "2022-01-24T14:56:44+00:00", "question_id": "01ce4c2352ebab86846c3b1a6363425811555a6b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@PublishTestModule(\n\ttestName = \"fapi1-advanced-final-par-attempt-invalid-redirect_uri\",\n\tdisplayName = \"PAR : try to use an invalid redirect_uri \",\n\tsummary = \"This test tries to provide an invalid redirect_uri and expects authorization server to return an error\",\n\tprofile = \"FAPI1-Advanced-Final\",\n\tconfigurationFields = {\n\t\t\"server.discoveryUrl\",\n\t\t\"client.client_id\",\n\t\t\"client.scope\",\n\t\t\"client.jwks\",\n\t\t\"mtls.key\",\n\t\t\"mtls.cert\",\n\t\t\"mtls.ca\",\n\t\t\"client2.client_id\",\n\t\t\"client2.scope\",\n\t\t\"client2.jwks\",\n\t\t\"mtls2.key\",\n\t\t\"mtls2.cert\",\n\t\t\"mtls2.ca\",\n\t\t\"resource.resourceUrl\"\n\t}\n)\n@VariantNotApplicable(parameter = FAPIAuthRequestMethod.class, values = {\n\t\"by_value\"\n})\npublic class FAPI1AdvancedFinalPARRejectInvalidRedirectUri extends AbstractFAPI1AdvancedFinalExpectingAuthorizationEndpointPlaceholderOrCallback {\n\t@Override\n\tprotected void createPlaceholder() {\n\t\tcallAndStopOnFailure(ExpectRedirectUriErrorPage.class, \"FAPI1-BASE-5.2.2-9\", \"PAR-2.3\");\n\t\tenv.putString(\"error_callback_placeholder\", env.getString(\"redirect_uri_missing_error\"));\n\t}\n\t@Override\n\tprotected ConditionSequence makeCreateAuthorizationRequestObjectSteps() {\n\t\treturn super.makeCreateAuthorizationRequestObjectSteps().\n\t\t\tbutFirst(condition(AddBadRedirectUriToRequestParameters.class));\n\t}\n\t@Override\n\tprotected void performParAuthorizationRequestFlow() {\n\t\tcallAndStopOnFailure(CallPAREndpoint.class);\n\t\tcallAndContinueOnFailure(EnsurePARInvalidRequestOrInvalidRequestObjectError.class, Condition.ConditionResult.FAILURE, \"PAR-2.3\");\n\t\tfireTestFinished();\n\t}\n"]], "pred": {"ppl": 1.8504658937454224, "ppl_lower": 3.4963018894195557, "ppl/lowercase_ppl": -2.033847344625399, "ppl/zlib": 0.0008547742247808951, "Min_5.0% Prob": 6.286933733866765, "Min_10.0% Prob": 4.586603370996622, "Min_20.0% Prob": 2.860212991351173, "Min_30.0% Prob": 2.012580645895457, "Min_40.0% Prob": 1.5341878323505322, "Min_50.0% Prob": 1.230976043573577, "Min_60.0% Prob": 1.0259344686482903}}
{"hexsha": "57ab2cf796f1e9e3cceff028ee71776a2ac2d440", "ext": "java", "lang": "Java", "content": "@RestController\n@RequestMapping(\"/clientes\")\npublic class ControleCliente {\n\n    private final DaoCliente dao;\n\n    public ControleCliente(DaoCliente dao) {\n        this.dao = dao;\n    }\n\n    @GetMapping\n    public List<Cliente> getClientes() {\n        return dao.findAll();\n    }\n\n    @GetMapping(\"/{id}\")\n    public Cliente getCliente(@PathVariable Long id) {\n        return dao.findById(id).orElseThrow(RuntimeException::new);\n    }\n\n    @PostMapping\n    public ResponseEntity createCliente(@RequestBody Cliente client) throws URISyntaxException {\n        Cliente savedClient = dao.save(client);\n        return ResponseEntity.created(new URI(\"/clients/\" + savedClient.getId())).body(savedClient);\n    }\n\n    @PutMapping(\"/{id}\")\n    public ResponseEntity updateCliente(@PathVariable Long id, @RequestBody Cliente client) {\n        Cliente currentClient = dao.findById(id).orElseThrow(RuntimeException::new);\n        currentClient.setName(client.getName());\n        currentClient.setEmail(client.getEmail());\n        currentClient = dao.save(client);\n\n        return ResponseEntity.ok(currentClient);\n    }\n\n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity deleteCliente(@PathVariable Long id) {\n        dao.deleteById(id);\n        return ResponseEntity.ok().build();\n    }\n}", "item_id": 0, "repo": "profoswaldo/Java-Web_04-02_18-02", "file": "2022-02-16/exemplo14/backend/src/main/java/recolde/controles/ControleCliente.java", "last_update_at": "2022-03-17T19:29:12+00:00", "question_id": "57ab2cf796f1e9e3cceff028ee71776a2ac2d440_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RestController\n@RequestMapping(\"/clientes\")\npublic class ControleCliente {\n    private final DaoCliente dao;\n    public ControleCliente(DaoCliente dao) {\n        this.dao = dao;\n    }\n    @GetMapping\n    public List<Cliente> getClientes() {\n        return dao.findAll();\n    }\n    @GetMapping(\"/{id}\")\n    public Cliente getCliente(@PathVariable Long id) {\n        return dao.findById(id).orElseThrow(RuntimeException::new);\n    }\n    @PostMapping\n    public ResponseEntity createCliente(@RequestBody Cliente client) throws URISyntaxException {\n        Cliente savedClient = dao.save(client);\n        return ResponseEntity.created(new URI(\"/clients/\" + savedClient.getId())).body(savedClient);\n    }\n    @PutMapping(\"/{id}\")\n    public ResponseEntity updateCliente(@PathVariable Long id, @RequestBody Cliente client) {\n        Cliente currentClient = dao.findById(id).orElseThrow(RuntimeException::new);\n        currentClient.setName(client.getName());\n        currentClient.setEmail(client.getEmail());\n        currentClient = dao.save(client);\n        return ResponseEntity.ok(currentClient);\n    }\n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity deleteCliente(@PathVariable Long id) {\n        dao.deleteById(id);\n        return ResponseEntity.ok().build();\n    }\n"]], "pred": {"ppl": 1.3973393440246582, "ppl_lower": 1.6297920942306519, "ppl/lowercase_ppl": -1.45994116536522, "ppl/zlib": 0.0007744674997355183, "Min_5.0% Prob": 4.602546281284756, "Min_10.0% Prob": 2.8406355622652413, "Min_20.0% Prob": 1.5854675520110775, "Min_30.0% Prob": 1.093180840650389, "Min_40.0% Prob": 0.8296097453960495, "Min_50.0% Prob": 0.6669466673874774, "Min_60.0% Prob": 0.5569655215157917}}
{"hexsha": "70c6601e007d9db9c21e9df59dd84045c38a8d37", "ext": "java", "lang": "Java", "content": "public class DBConnection {\n\t\n\tpublic static Connection CreateConnection() {\n\t\tConnection con = null;\n\t\ttry {\n\t\t\tClass.forName(\"org.mariadb.jdbc.Driver\");\n\t\t\t\n\t\t\tcon = DriverManager.getConnection(\"jdbc:mariadb://localhost:3306/java?user=root&password=password\");\n\t\t\tStatement st=con.createStatement();\n\t\t\tSystem.out.println(\"connection succeded\");\n\t\t} catch (ClassNotFoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\t catch (SQLException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\tSystem.out.println(\"connection failed\");\n\n\t\t}\n\t\treturn con;\n\t}\n\t\n\n}", "item_id": 0, "repo": "SarampatiSaiKumar/Individual-Assignments", "file": "SaiKumarSarampati/Spring/BookSystem/src/com/book/model/DBConnection.java", "last_update_at": "2022-03-31T20:20:01+00:00", "question_id": "70c6601e007d9db9c21e9df59dd84045c38a8d37_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DBConnection {\n\t\n\tpublic static Connection CreateConnection() {\n\t\tConnection con = null;\n\t\ttry {\n\t\t\tClass.forName(\"org.mariadb.jdbc.Driver\");\n\t\t\t\n\t\t\tcon = DriverManager.getConnection(\"jdbc:mariadb://localhost:3306/java?user=root&password=password\");\n\t\t\tStatement st=con.createStatement();\n\t\t\tSystem.out.println(\"connection succeded\");\n\t\t} catch (ClassNotFoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\t catch (SQLException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\tSystem.out.println(\"connection failed\");\n\t\t}\n\t\treturn con;\n\t}\n\t\n"]], "pred": {"ppl": 1.7761359214782715, "ppl_lower": 2.172192335128784, "ppl/lowercase_ppl": -1.3504225249902935, "ppl/zlib": 0.0018352721214230608, "Min_5.0% Prob": 5.457123851776123, "Min_10.0% Prob": 4.277762333552043, "Min_20.0% Prob": 2.644120732943217, "Min_30.0% Prob": 1.8682086827263, "Min_40.0% Prob": 1.423183480366355, "Min_50.0% Prob": 1.1468838374884356, "Min_60.0% Prob": 0.959508258760685}}
{"hexsha": "217eb679fc2ba5fd5115e9475ec1bbdb88bb5afc", "ext": "java", "lang": "Java", "content": "@Service\n@ConditionalOnProperty(prefix = \"zk\", value = \"enabled\", havingValue = \"true\", matchIfMissing = false)\n@Slf4j\npublic class ZkDiscoveryService\n    implements DiscoveryService, PathChildrenCacheListener, ApplicationListener<ApplicationReadyEvent> {\n\n  @Value(\"${zk.url}\")\n  private String zkUrl;\n  @Value(\"${zk.retry_interval_ms}\")\n  private Integer zkRetryInterval;\n  @Value(\"${zk.connection_timeout_ms}\")\n  private Integer zkConnectionTimeout;\n  @Value(\"${zk.session_timeout_ms}\")\n  private Integer zkSessionTimeout;\n  @Value(\"${zk.zk_dir}\")\n  private String zkDir;\n\n  private String zkNodesDir;\n\n  @Autowired\n  private ServerInstanceService serverInstance;\n\n  private final List<DiscoveryServiceListener> listeners = new CopyOnWriteArrayList<>();\n\n  private CuratorFramework client;\n  private PathChildrenCache cache;\n  private String nodePath;\n\n  @PostConstruct\n  public void init() {\n    log.info(\"Initializing...\");\n    Assert.hasLength(zkUrl, MiscUtils.missingProperty(\"zk.url\"));\n    Assert.notNull(zkRetryInterval, MiscUtils.missingProperty(\"zk.retry_interval_ms\"));\n    Assert.notNull(zkConnectionTimeout, MiscUtils.missingProperty(\"zk.connection_timeout_ms\"));\n    Assert.notNull(zkSessionTimeout, MiscUtils.missingProperty(\"zk.session_timeout_ms\"));\n\n    log.info(\"Initializing discovery service using ZK connect string: {}\", zkUrl);\n\n    zkNodesDir = zkDir + \"/nodes\";\n    try {\n      client = CuratorFrameworkFactory.newClient(zkUrl, zkSessionTimeout, zkConnectionTimeout,\n          new RetryForever(zkRetryInterval));\n      client.start();\n      client.blockUntilConnected();\n      cache = new PathChildrenCache(client, zkNodesDir, true);\n      cache.getListenable().addListener(this);\n      cache.start();\n    } catch (Exception e) {\n      log.error(\"Failed to connect to ZK: {}\", e.getMessage(), e);\n      CloseableUtils.closeQuietly(client);\n      throw new RuntimeException(e);\n    }\n  }\n\n  @PreDestroy\n  public void destroy() {\n    unpublishCurrentServer();\n    CloseableUtils.closeQuietly(client);\n    log.info(\"Stopped discovery service\");\n  }\n\n  @Override\n  public void publishCurrentServer() {\n    try {\n      ServerInstance self = this.serverInstance.getSelf();\n      log.info(\"[{}:{}] Creating ZK node for current instance\", self.getHost(), self.getPort());\n      nodePath = client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL_SEQUENTIAL)\n          .forPath(zkNodesDir + \"/\", self.getServerInfo().toByteArray());\n      log.info(\"[{}:{}] Created ZK node for current instance: {}\", self.getHost(), self.getPort(), nodePath);\n    } catch (Exception e) {\n      log.error(\"Failed to create ZK node\", e);\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void unpublishCurrentServer() {\n    try {\n      if (nodePath != null) {\n        client.delete().forPath(nodePath);\n      }\n    } catch (Exception e) {\n      log.error(\"Failed to delete ZK node {}\", nodePath, e);\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public ServerInstance getCurrentServer() {\n    return serverInstance.getSelf();\n  }\n\n  @Override\n  public List<ServerInstance> getOtherServers() {\n    return cache.getCurrentData().stream().filter(cd -> !cd.getPath().equals(nodePath)).map(cd -> {\n      try {\n        return new ServerInstance(ServerInfo.parseFrom(cd.getData()));\n      } catch (InvalidProtocolBufferException e) {\n        log.error(\"Failed to decode ZK node\", e);\n        throw new RuntimeException(e);\n      }\n    }).collect(Collectors.toList());\n  }\n\n  @Override\n  public boolean addListener(DiscoveryServiceListener listener) {\n    return listeners.add(listener);\n  }\n\n  @Override\n  public boolean removeListener(DiscoveryServiceListener listener) {\n    return listeners.remove(listener);\n  }\n\n  @Override\n  public void onApplicationEvent(ApplicationReadyEvent applicationReadyEvent) {\n    publishCurrentServer();\n    getOtherServers().forEach(server -> log.info(\"Found active server: [{}:{}]\", server.getHost(), server.getPort()));\n  }\n\n  @Override\n  public void childEvent(CuratorFramework curatorFramework, PathChildrenCacheEvent pathChildrenCacheEvent)\n      throws Exception {\n    ChildData data = pathChildrenCacheEvent.getData();\n    if (data == null) {\n      log.debug(\"Ignoring {} due to empty child data\", pathChildrenCacheEvent);\n      return;\n    } else if (data.getData() == null) {\n      log.debug(\"Ignoring {} due to empty child's data\", pathChildrenCacheEvent);\n      return;\n    } else if (nodePath != null && nodePath.equals(data.getPath())) {\n      log.debug(\"Ignoring event about current server {}\", pathChildrenCacheEvent);\n      return;\n    }\n    ServerInstance instance;\n    try {\n      instance = new ServerInstance(ServerInfo.parseFrom(data.getData()));\n    } catch (IOException e) {\n      log.error(\"Failed to decode server instance for node {}\", data.getPath(), e);\n      throw e;\n    }\n    log.info(\"Processing [{}] event for [{}:{}]\", pathChildrenCacheEvent.getType(), instance.getHost(),\n        instance.getPort());\n    switch (pathChildrenCacheEvent.getType()) {\n    case CHILD_ADDED:\n      listeners.forEach(listener -> listener.onServerAdded(instance));\n      break;\n    case CHILD_UPDATED:\n      listeners.forEach(listener -> listener.onServerUpdated(instance));\n      break;\n    case CHILD_REMOVED:\n      listeners.forEach(listener -> listener.onServerRemoved(instance));\n      break;\n    }\n  }\n}", "item_id": 0, "repo": "soncd19/iotplatform", "file": "iotplatform/src/main/java/org/iotp/server/service/cluster/discovery/ZkDiscoveryService.java", "last_update_at": "2022-03-15T10:00:39+00:00", "question_id": "217eb679fc2ba5fd5115e9475ec1bbdb88bb5afc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\n@ConditionalOnProperty(prefix = \"zk\", value = \"enabled\", havingValue = \"true\", matchIfMissing = false)\n@Slf4j\npublic class ZkDiscoveryService\n    implements DiscoveryService, PathChildrenCacheListener, ApplicationListener<ApplicationReadyEvent> {\n  @Value(\"${zk.url}\")\n  private String zkUrl;\n  @Value(\"${zk.retry_interval_ms}\")\n  private Integer zkRetryInterval;\n  @Value(\"${zk.connection_timeout_ms}\")\n  private Integer zkConnectionTimeout;\n  @Value(\"${zk.session_timeout_ms}\")\n  private Integer zkSessionTimeout;\n  @Value(\"${zk.zk_dir}\")\n  private String zkDir;\n  private String zkNodesDir;\n  @Autowired\n  private ServerInstanceService serverInstance;\n  private final List<DiscoveryServiceListener> listeners = new CopyOnWriteArrayList<>();\n  private CuratorFramework client;\n  private PathChildrenCache cache;\n  private String nodePath;\n  @PostConstruct\n  public void init() {\n    log.info(\"Initializing...\");\n    Assert.hasLength(zkUrl, MiscUtils.missingProperty(\"zk.url\"));\n    Assert.notNull(zkRetryInterval, MiscUtils.missingProperty(\"zk.retry_interval_ms\"));\n    Assert.notNull(zkConnectionTimeout, MiscUtils.missingProperty(\"zk.connection_timeout_ms\"));\n    Assert.notNull(zkSessionTimeout, MiscUtils.missingProperty(\"zk.session_timeout_ms\"));\n    log.info(\"Initializing discovery service using ZK connect string: {}\", zkUrl);\n    zkNodesDir = zkDir + \"/nodes\";\n    try {\n      client = CuratorFrameworkFactory.newClient(zkUrl, zkSessionTimeout, zkConnectionTimeout,\n          new RetryForever(zkRetryInterval));\n      client.start();\n      client.blockUntilConnected();\n      cache = new PathChildrenCache(client, zkNodesDir, true);\n      cache.getListenable().addListener(this);\n      cache.start();\n    } catch (Exception e) {\n      log.error(\"Failed to connect to ZK: {}\", e.getMessage(), e);\n      CloseableUtils.closeQuietly(client);\n      throw new RuntimeException(e);\n    }\n  }\n  @PreDestroy\n  public void destroy() {\n    unpublishCurrentServer();\n    CloseableUtils.closeQuietly(client);\n    log.info(\"Stopped discovery service\");\n  }\n  @Override\n  public void publishCurrentServer() {\n    try {\n      ServerInstance self = this.serverInstance.getSelf();\n      log.info(\"[{}:{}] Creating ZK node for current instance\", self.getHost(), self.getPort());\n      nodePath = client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL_SEQUENTIAL)\n          .forPath(zkNodesDir + \"/\", self.getServerInfo().toByteArray());\n      log.info(\"[{}:{}] Created ZK node for current instance: {}\", self.getHost(), self.getPort(), nodePath);\n    } catch (Exception e) {\n      log.error(\"Failed to create ZK node\", e);\n      throw new RuntimeException(e);\n    }\n  }\n  @Override\n  public void unpublishCurrentServer() {\n    try {\n      if (nodePath != null) {\n        client.delete().forPath(nodePath);\n      }\n    } catch (Exception e) {\n      log.error(\"Failed to delete ZK node {}\", nodePath, e);\n      throw new RuntimeException(e);\n    }\n  }\n  @Override\n  public ServerInstance getCurrentServer() {\n    return serverInstance.getSelf();\n  }\n  @Override\n  public List<ServerInstance> getOtherServers() {\n    return cache.getCurrentData().stream().filter(cd -> !cd.getPath().equals(nodePath)).map(cd -> {\n      try {\n        return new ServerInstance(ServerInfo.parseFrom(cd.getData()));\n      } catch (InvalidProtocolBufferException e) {\n        log.error(\"Failed to decode ZK node\", e);\n        throw new RuntimeException(e);\n      }\n    }).collect(Collectors.toList());\n  }\n  @Override\n  public boolean addListener(DiscoveryServiceListener listener) {\n    return listeners.add(listener);\n  }\n  @Override\n  public boolean removeListener(DiscoveryServiceListener listener) {\n    return listeners.remove(listener);\n  }\n  @Override\n  public void onApplicationEvent(ApplicationReadyEvent applicationReadyEvent) {\n    publishCurrentServer();\n    getOtherServers().forEach(server -> log.info(\"Found active server: [{}:{}]\", server.getHost(), server.getPort()));\n  }\n  @Override\n  public void childEvent(CuratorFramework curatorFramework, PathChildrenCacheEvent pathChildrenCacheEvent)\n      throws Exception {\n    ChildData data = pathChildrenCacheEvent.getData();\n    if (data == null) {\n      log.debug(\"Ignoring {} due to empty child data\", pathChildrenCacheEvent);\n      return;\n    } else if (data.getData() == null) {\n      log.debug(\"Ignoring {} due to empty child's data\", pathChildrenCacheEvent);\n      return;\n    } else if (nodePath != null && nodePath.equals(data.getPath())) {\n      log.debug(\"Ignoring event about current server {}\", pathChildrenCacheEvent);\n      return;\n    }\n    ServerInstance instance;\n    try {\n      instance = new ServerInstance(ServerInfo.parseFrom(data.getData()));\n    } catch (IOException e) {\n      log.error(\"Failed to decode server instance for node {}\", data.getPath(), e);\n      throw e;\n    }\n    log.info(\"Processing [{}] event for [{}:{}]\", pathChildrenCacheEvent.getType(), instance.getHost(),\n        instance.getPort());\n    switch (pathChildrenCacheEvent.getType()) {\n    case CHILD_ADDED:\n      listeners.forEach(listener -> listener.onServerAdded(instance));\n      break;\n    case CHILD_UPDATED:\n      listeners.forEach(listener -> listener.onServerUpdated(instance));\n      break;\n    case CHILD_REMOVED:\n      listeners.forEach(listener -> listener.onServerRemoved(instance));\n      break;\n    }\n  }\n"]], "pred": {"ppl": 1.566991925239563, "ppl_lower": 1.9163308143615723, "ppl/lowercase_ppl": -1.4480708305706096, "ppl/zlib": 0.00027777230077587173, "Min_5.0% Prob": 4.780828667621987, "Min_10.0% Prob": 3.3747748755941203, "Min_20.0% Prob": 2.0864826120874462, "Min_30.0% Prob": 1.4684202457759894, "Min_40.0% Prob": 1.115679054641709, "Min_50.0% Prob": 0.8976704584427339, "Min_60.0% Prob": 0.7492211503185617}}
{"hexsha": "b6569873dcf589dd2f8992a4cd7e6cf1abf7e023", "ext": "java", "lang": "Java", "content": "public class TestRobot extends AbstractAnalysis {\n    \n    Color darkred = new Color(160,0,0,0.5f);\n    //Color green = new Color(34,139,34);\n\n    public TestRobot() {\n        super(new ChartFactory());\n    }\n    \n    public static void main(String[] args) throws Exception {\n        TestRobot d = new TestRobot();\n        AnalysisLauncher.open(d);\n    }\n    \n    @Override\n    public void init() {\n      \n        Quality q = Quality.Advanced(); \n        q.setDepthActivated(true);\n        q.setAlphaActivated(true);\n        q.setAnimated(false); \n        q.setHiDPIEnabled(true); \n        \n        // Create a chart Quality.Advanced()\n        chart = new SwingChartFactory().newChart(q);\n        chart.getView().setSquared(false);\n\n\n        // die letzten Werte f\u00fcr alpha, a bzw. den korrespondierenden delta-Werte ist 0,\n        // da das letzte Koordinatensystem einfach nur in Achsenrichtung um d verschoben ist\n\n        // added zero values at the beginning to represent the basis coordinate system, needed to calculate mDH values\n        // Werkskalibration UR5e\n        double[] delta_theta_rad = new double[]{0d, -8.27430119976213518e-08, 0.732984551101984239, 5.46919521494736127, 0.0810043775014757245, -3.53724730506321805e-07, -9.97447025669062626e-08};\n        double[] delta_a_m = new double[]{0d, 0.000156734465764371306, 0.109039760794650886, 0.00135049423466820917, 6.30167176077633267e-05, 8.98147062591837358e-05, 0};\n        double[] delta_d_m = new double[]{0d, -7.63582045015809285e-05, 136.026368377065324, -143.146527922606964, 7.12049886607637639, -6.13561334270734671e-05, -0.000218168195914358876};\n        double[] delta_alpha_rad= new double[]{0d, -0.000849612070594307767, 0.00209120614311242205, 0.0044565542371754396, -0.000376815598678081898, 0.000480742313784698894, 0};\n\n        // Stuttgarter Werte bestimmt aus 20221115A\n        /*double[] delta_theta_rad = new double[]{0, -6.0717e-04,  7.3364e-01,  5.4693e+00,  8.1761e-02, -1.7036e-04, 3.6291e-04};\n        double[] delta_a_m = new double[]{0, 4.1994e-04,  1.0786e-01, -7.8398e-05,  9.4018e-04,  2.4728e-04, 1.0543e-04};\n        double[] delta_d_m = new double[]{0, 8.0152e-04,  1.3603e+02, -1.4315e+02,  7.1207e+00,  2.0997e-04, -1.0959e-03};\n        double[] delta_alpha_rad = new double[]{0, 0.0010,  0.0021,  0.0044, -0.0005,  0.0008,  0.0000};\n        */\n        double[] d_n_m_ = new double[]{0d, 0.1625, 0d, 0d, 0.1333, 0.0997, 0.0996};\n\n        // Die zu bestimmenden Werte auf NaN gesetzt. Das sind die, bei denen\n        // die nachfolgende Achse nahezu senkrecht steht.\n        // Achtung: L\u00e4nge des Arrays ist um 1 kleiner als die anderen, da der erste Wert d1,\n        // Es gibt keinen d0-Wert\n        double[] d_n_m = new double[]{Double.NaN, 0d, 0d, Double.NaN, Double.NaN, 0.0996-0.000218168195914358876};\n\n        // use the signs of the nominal values to define the directions of a --> theta, a, alpha\n        double[] a_n_m = new double[]{0d, 0d,  -0.425, -0.3922, 0d, 0d, 0d};\n        // a0-a6\n        // Vorzeichen von a1 ist auf UR-Seite nicht zu erkennen, aber a2-4 negativ, a5-6 positiv\n        // DH4 ist damit seltsamerweise falsch\n        //boolean[] sign_r = new boolean[]{false, true, true, true, true, true, true};\n        boolean[] sign_r = new boolean[]{false, true, true, false, false, false, false};\n\n        double[] alpha_n_rad = new double[]{0d, PI/2d, 0d, 0d, PI/2d, -PI/2d, 0d};\n\n        // DH-Parameter inclusive manufacturer calibration offsets\n        double[] d_m = new double[7];\n        double[] a_m = new double[7];\n        double[] alpha_rad = new double[7];\n        double[] theta_rad = new double[7];\n        for (int i=0;i<7;i++){\n            d_m[i] = d_n_m_[i] + delta_d_m[i];\n            a_m[i] = a_n_m[i]  + delta_a_m[i];\n            alpha_rad[i] = alpha_n_rad[i] + delta_alpha_rad[i];\n            theta_rad[i] = delta_theta_rad[i];\n        }\n\n        // geht so nicht, da auch bei den Positionen an denen die nominallen r-Werte\n        // 0 sind k\u00f6nnte das Vorzeichen geflippt werden m\u00fcssen\n        /*for (int i=0;i<6;i++){\n            sign_r[i] = a_n_m[i] < 0;\n        }*/\n\n        DHAxes axes = determineDHAxesFromDH(theta_rad, alpha_rad, d_m, a_m);\n        float radius = (float) 0.01;\n        float length = 0.4f;\n        for (int i=0;i<axes.z.length;i++){\n            Arrow arrow = new Arrow();\n            //pos, dir, length\n            double x = axes.c[i].x;\n            double y = axes.c[i].y;\n            double z = axes.c[i].z;\n            double dx = axes.z[i].x;\n            double dy = axes.z[i].y;\n            double dz = axes.z[i].z;\n            if (Math.abs(axes.c[i].y) > 1){\n                System.out.println(\"Axis[\"+String.valueOf(i)+\"] moved to o(y=0)!\");\n                // oder Ursprung so verschieben, dass y=0 wird\n                double t = -y/dy;\n                x +=t*dx;\n                y = 0;\n                z +=t*dz;\n            }\n            arrow.setData(Utils2.createVector3d(new Coord3d(x,y,z), \n                    new Coord3d(dx,dy,dz), length),radius,10,0, darkred);\n                arrow.setWireframeDisplayed(false);\n            chart.add(arrow);\n            \n            // x-axes\n            arrow = new Arrow();\n            float xlength = 0.1f;\n            arrow.setData(Utils2.createVector3d(new Coord3d(x,y,z), \n                    new Coord3d(axes.x[i].x,axes.x[i].y,axes.x[i].z), xlength),radius,10,0, Color.BLUE);\n                arrow.setWireframeDisplayed(false);\n            chart.add(arrow);\n        }\n\n        /*double radius = 2;\n        Sphere sphere = new Sphere(new Coord3d(0,0,0),(float)radius,15,darkred);\n        sphere.setWireframeColor(darkred);\n        \n        // hat alles nichts gebracht\n        sphere.setFaceDisplayed(true);\n        sphere.setWireframeColor(Color.CYAN);\n        sphere.setWireframeDisplayed(true);\n        sphere.setWireframeWidth(2);\n        sphere.setReflectLight(true);\n        chart.add(sphere);*/\n        \n        // This addition keeps the aspect ratio of the X and Y data\n        // but makes X and Z square\n        //chart.getView().setSquarifier(new XZSquarifier());\n        //chart.getView().setSquared(true);\n        \n       \n    }\n    \n    public record DHAxes(Vector3d[] z, Vector3d[] x, Point3d[] c){}\n    \n    /**\n     * Determine DH-axes from DH parameters.\n     * \n     * @param theta with 0 as first value in [\u00b0] (7 values for UR5e)\n     * @param alpha with 0 as first value in [\u00b0] (7 values for UR5e)\n     * @param d with 0 as first value in [m]\n     * @param r with 0 as first value in [m]\n     * @return axes of all of the DH frames.\n     */\n    public static DHAxes determineDHAxesFromDH(double[] theta, double[] alpha, double[] d, \n                                       /*double[] dn,*/ double[] r/*, boolean[] signR*/){\n        \n        Vector3d[] z = new Vector3d[alpha.length];\n        Vector3d[] x = new Vector3d[alpha.length]; // reale Ausrichtung der x-Achsen\n        Point3d[]  c = new Point3d[alpha.length];\n        \n        System.out.println(\"Denavit Hartenberg:\");\n        System.out.println(\"------------------\");\n        \n        //  Basis-Koordinatensystem\n        \n        z[0] = new Vector3d(0d,0d,1d); // Ausrichtung er ersten Drehachse\n        // x[0] zeigt von der vorherigen Achse, also dem Basis-System auf die erste\n        // Achse also Globe2Base - um keine unn\u00f6tigen delta-thetas zu erzeugen, sollte\n        // x[0] in Richtung von z[2] in der neutral-pose zeigen, die die nach z[1] folgenden zweite joint-axis\n        // sollte ja in der neutral-pose gerade die Ausgangs-x-Richtung definieren\n        x[0] = new Vector3d(1d,0d,0d);\n        c[0] = new Point3d(0d,0d,0d);\n        System.out.println(\"o0= (\"+String.valueOf(c[0].x)+\",\"+String.valueOf(c[0].y)+\",\"+String.valueOf(c[0].z)+\")\");\n        System.out.println(\"z0= (\"+String.valueOf(z[0].x)+\",\"+String.valueOf(z[0].y)+\",\"+String.valueOf(z[0].z)+\")\");\n        \n        Matrix4d dhm = new Matrix4d();\n        dhm.setIdentity();\n        \n        //TODO\n        // unklar, wie ich das Vorzeichen im Modell von a2-a4 ber\u00fccksichten muss, \n        // au\u00dferdem unklar, warum a5-a6 kein Vorzeichen definiert\n        // vermutlich muss ich beim Erstellen der matrix die Vorzeichen gar nicht ber\u00fccksichtigen!!!!\n        \n        // \n        for (int i=1;i<alpha.length;i++){\n            System.out.println(\"Input(\"+String.valueOf(i)+\"): alpha=\"+String.valueOf(alpha[i]*180d/PI)+\n                    \"\u00b0, theta=\"+String.valueOf(theta[i]*180d/PI)+\n                    \"\u00b0, d=\"+String.valueOf(d[i]*1000d)+\"mm, r=\"+String.valueOf(r[i]*1000)+\"mm\");\n            \n            // origin in lokalen Koordinaten\n            Point3d cc = new Point3d(0d,0d,0d);\n            // z-Richtung in lokalen Koordinaten\n            Vector3d zz = new Vector3d(0d,0d,1d);\n            // x-Richtung in lokalen Koordinaten\n            Vector3d xx = new Vector3d(1d,0d,0d);\n        \n            dhm.mul(new DH(theta[i], alpha[i], d[i], r[i]).toMatrix4d());\n            \n            dhm.transform(cc);\n            System.out.println(\"o\"+String.valueOf(i)+\"= (\"+String.valueOf(cc.x)+\",\"+String.valueOf(cc.y)+\",\"+String.valueOf(cc.z)+\")\");\n            c[i] = new Point3d(cc.x,cc.y,cc.z);\n            \n            dhm.transform(zz);\n            System.out.println(\"z\"+String.valueOf(i)+\"= (\"+String.valueOf(zz.x)+\",\"+String.valueOf(zz.y)+\",\"+String.valueOf(zz.z)+\")\");\n            z[i] = new Vector3d(zz);\n            \n            dhm.transform(xx);\n            System.out.println(\"x\"+String.valueOf(i)+\"= (\"+String.valueOf(xx.x)+\",\"+String.valueOf(xx.y)+\",\"+String.valueOf(xx.z)+\")\");\n            x[i] = new Vector3d(xx);\n        }\n        \n        return new DHAxes(z,x,c);\n    }\n}", "item_id": 0, "repo": "orat/EuclidView3d", "file": "src/main/java/de/orat/math/view/euclidview3d/test/robot/TestRobot.java", "last_update_at": "2022-03-29T09:29:59+00:00", "question_id": "b6569873dcf589dd2f8992a4cd7e6cf1abf7e023_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestRobot extends AbstractAnalysis {\n    Color darkred = new Color(160,0,0,0.5f);\n    //Color green = new Color(34,139,34);\n    public TestRobot() {\n        super(new ChartFactory());\n    }\n    public static void main(String[] args) throws Exception {\n        TestRobot d = new TestRobot();\n        AnalysisLauncher.open(d);\n    }\n    @Override\n    public void init() {\n        Quality q = Quality.Advanced(); \n        q.setDepthActivated(true);\n        q.setAlphaActivated(true);\n        q.setAnimated(false); \n        q.setHiDPIEnabled(true); \n        // Create a chart Quality.Advanced()\n        chart = new SwingChartFactory().newChart(q);\n        chart.getView().setSquared(false);\n        // die letzten Werte f\u00fcr alpha, a bzw. den korrespondierenden delta-Werte ist 0,\n        // da das letzte Koordinatensystem einfach nur in Achsenrichtung um d verschoben ist\n        // added zero values at the beginning to represent the basis coordinate system, needed to calculate mDH values\n        // Werkskalibration UR5e\n        double[] delta_theta_rad = new double[]{0d, -8.27430119976213518e-08, 0.732984551101984239, 5.46919521494736127, 0.0810043775014757245, -3.53724730506321805e-07, -9.97447025669062626e-08};\n        double[] delta_a_m = new double[]{0d, 0.000156734465764371306, 0.109039760794650886, 0.00135049423466820917, 6.30167176077633267e-05, 8.98147062591837358e-05, 0};\n        double[] delta_d_m = new double[]{0d, -7.63582045015809285e-05, 136.026368377065324, -143.146527922606964, 7.12049886607637639, -6.13561334270734671e-05, -0.000218168195914358876};\n        double[] delta_alpha_rad= new double[]{0d, -0.000849612070594307767, 0.00209120614311242205, 0.0044565542371754396, -0.000376815598678081898, 0.000480742313784698894, 0};\n        // Stuttgarter Werte bestimmt aus 20221115A\n        /*double[] delta_theta_rad = new double[]{0, -6.0717e-04,  7.3364e-01,  5.4693e+00,  8.1761e-02, -1.7036e-04, 3.6291e-04};\n        double[] delta_a_m = new double[]{0, 4.1994e-04,  1.0786e-01, -7.8398e-05,  9.4018e-04,  2.4728e-04, 1.0543e-04};\n        double[] delta_d_m = new double[]{0, 8.0152e-04,  1.3603e+02, -1.4315e+02,  7.1207e+00,  2.0997e-04, -1.0959e-03};\n        double[] delta_alpha_rad = new double[]{0, 0.0010,  0.0021,  0.0044, -0.0005,  0.0008,  0.0000};\n        */\n        double[] d_n_m_ = new double[]{0d, 0.1625, 0d, 0d, 0.1333, 0.0997, 0.0996};\n        // Die zu bestimmenden Werte auf NaN gesetzt. Das sind die, bei denen\n        // die nachfolgende Achse nahezu senkrecht steht.\n        // Achtung: L\u00e4nge des Arrays ist um 1 kleiner als die anderen, da der erste Wert d1,\n        // Es gibt keinen d0-Wert\n        double[] d_n_m = new double[]{Double.NaN, 0d, 0d, Double.NaN, Double.NaN, 0.0996-0.000218168195914358876};\n        // use the signs of the nominal values to define the directions of a --> theta, a, alpha\n        double[] a_n_m = new double[]{0d, 0d,  -0.425, -0.3922, 0d, 0d, 0d};\n        // a0-a6\n        // Vorzeichen von a1 ist auf UR-Seite nicht zu erkennen, aber a2-4 negativ, a5-6 positiv\n        // DH4 ist damit seltsamerweise falsch\n        //boolean[] sign_r = new boolean[]{false, true, true, true, true, true, true};\n        boolean[] sign_r = new boolean[]{false, true, true, false, false, false, false};\n        double[] alpha_n_rad = new double[]{0d, PI/2d, 0d, 0d, PI/2d, -PI/2d, 0d};\n        // DH-Parameter inclusive manufacturer calibration offsets\n        double[] d_m = new double[7];\n        double[] a_m = new double[7];\n        double[] alpha_rad = new double[7];\n        double[] theta_rad = new double[7];\n        for (int i=0;i<7;i++){\n            d_m[i] = d_n_m_[i] + delta_d_m[i];\n            a_m[i] = a_n_m[i]  + delta_a_m[i];\n            alpha_rad[i] = alpha_n_rad[i] + delta_alpha_rad[i];\n            theta_rad[i] = delta_theta_rad[i];\n        }\n        // geht so nicht, da auch bei den Positionen an denen die nominallen r-Werte\n        // 0 sind k\u00f6nnte das Vorzeichen geflippt werden m\u00fcssen\n        /*for (int i=0;i<6;i++){\n            sign_r[i] = a_n_m[i] < 0;\n        }*/\n        DHAxes axes = determineDHAxesFromDH(theta_rad, alpha_rad, d_m, a_m);\n        float radius = (float) 0.01;\n        float length = 0.4f;\n        for (int i=0;i<axes.z.length;i++){\n            Arrow arrow = new Arrow();\n            //pos, dir, length\n            double x = axes.c[i].x;\n            double y = axes.c[i].y;\n            double z = axes.c[i].z;\n            double dx = axes.z[i].x;\n            double dy = axes.z[i].y;\n            double dz = axes.z[i].z;\n            if (Math.abs(axes.c[i].y) > 1){\n                System.out.println(\"Axis[\"+String.valueOf(i)+\"] moved to o(y=0)!\");\n                // oder Ursprung so verschieben, dass y=0 wird\n                double t = -y/dy;\n                x +=t*dx;\n                y = 0;\n                z +=t*dz;\n            }\n            arrow.setData(Utils2.createVector3d(new Coord3d(x,y,z), \n                    new Coord3d(dx,dy,dz), length),radius,10,0, darkred);\n                arrow.setWireframeDisplayed(false);\n            chart.add(arrow);\n            // x-axes\n            arrow = new Arrow();\n            float xlength = 0.1f;\n            arrow.setData(Utils2.createVector3d(new Coord3d(x,y,z), \n                    new Coord3d(axes.x[i].x,axes.x[i].y,axes.x[i].z), xlength),radius,10,0, Color.BLUE);\n                arrow.setWireframeDisplayed(false);\n            chart.add(arrow);\n        }\n        /*double radius = 2;\n        Sphere sphere = new Sphere(new Coord3d(0,0,0),(float)radius,15,darkred);\n        sphere.setWireframeColor(darkred);\n        // hat alles nichts gebracht\n        sphere.setFaceDisplayed(true);\n        sphere.setWireframeColor(Color.CYAN);\n        sphere.setWireframeDisplayed(true);\n        sphere.setWireframeWidth(2);\n        sphere.setReflectLight(true);\n        chart.add(sphere);*/\n        // This addition keeps the aspect ratio of the X and Y data\n        // but makes X and Z square\n        //chart.getView().setSquarifier(new XZSquarifier());\n        //chart.getView().setSquared(true);\n    }\n    public record DHAxes(Vector3d[] z, Vector3d[] x, Point3d[] c){}\n    /**\n     * Determine DH-axes from DH parameters.\n     * \n     * @param theta with 0 as first value in [\u00b0] (7 values for UR5e)\n     * @param alpha with 0 as first value in [\u00b0] (7 values for UR5e)\n     * @param d with 0 as first value in [m]\n     * @param r with 0 as first value in [m]\n     * @return axes of all of the DH frames.\n     */\n    public static DHAxes determineDHAxesFromDH(double[] theta, double[] alpha, double[] d, \n                                       /*double[] dn,*/ double[] r/*, boolean[] signR*/){\n        Vector3d[] z = new Vector3d[alpha.length];\n        Vector3d[] x = new Vector3d[alpha.length]; // reale Ausrichtung der x-Achsen\n        Point3d[]  c = new Point3d[alpha.length];\n        System.out.println(\"Denavit Hartenberg:\");\n        System.out.println(\"------------------\");\n        //  Basis-Koordinatensystem\n        z[0] = new Vector3d(0d,0d,1d); // Ausrichtung er ersten Drehachse\n        // x[0] zeigt von der vorherigen Achse, also dem Basis-System auf die erste\n        // Achse also Globe2Base - um keine unn\u00f6tigen delta-thetas zu erzeugen, sollte\n        // x[0] in Richtung von z[2] in der neutral-pose zeigen, die die nach z[1] folgenden zweite joint-axis\n        // sollte ja in der neutral-pose gerade die Ausgangs-x-Richtung definieren\n        x[0] = new Vector3d(1d,0d,0d);\n        c[0] = new Point3d(0d,0d,0d);\n        System.out.println(\"o0= (\"+String.valueOf(c[0].x)+\",\"+String.valueOf(c[0].y)+\",\"+String.valueOf(c[0].z)+\")\");\n        System.out.println(\"z0= (\"+String.valueOf(z[0].x)+\",\"+String.valueOf(z[0].y)+\",\"+String.valueOf(z[0].z)+\")\");\n        Matrix4d dhm = new Matrix4d();\n        dhm.setIdentity();\n        //TODO\n        // unklar, wie ich das Vorzeichen im Modell von a2-a4 ber\u00fccksichten muss, \n        // au\u00dferdem unklar, warum a5-a6 kein Vorzeichen definiert\n        // vermutlich muss ich beim Erstellen der matrix die Vorzeichen gar nicht ber\u00fccksichtigen!!!!\n        // \n        for (int i=1;i<alpha.length;i++){\n            System.out.println(\"Input(\"+String.valueOf(i)+\"): alpha=\"+String.valueOf(alpha[i]*180d/PI)+\n                    \"\u00b0, theta=\"+String.valueOf(theta[i]*180d/PI)+\n                    \"\u00b0, d=\"+String.valueOf(d[i]*1000d)+\"mm, r=\"+String.valueOf(r[i]*1000)+\"mm\");\n            // origin in lokalen Koordinaten\n            Point3d cc = new Point3d(0d,0d,0d);\n            // z-Richtung in lokalen Koordinaten\n            Vector3d zz = new Vector3d(0d,0d,1d);\n            // x-Richtung in lokalen Koordinaten\n            Vector3d xx = new Vector3d(1d,0d,0d);\n            dhm.mul(new DH(theta[i], alpha[i], d[i], r[i]).toMatrix4d());\n            dhm.transform(cc);\n            System.out.println(\"o\"+String.valueOf(i)+\"= (\"+String.valueOf(cc.x)+\",\"+String.valueOf(cc.y)+\",\"+String.valueOf(cc.z)+\")\");\n            c[i] = new Point3d(cc.x,cc.y,cc.z);\n            dhm.transform(zz);\n            System.out.println(\"z\"+String.valueOf(i)+\"= (\"+String.valueOf(zz.x)+\",\"+String.valueOf(zz.y)+\",\"+String.valueOf(zz.z)+\")\");\n            z[i] = new Vector3d(zz);\n            dhm.transform(xx);\n            System.out.println(\"x\"+String.valueOf(i)+\"= (\"+String.valueOf(xx.x)+\",\"+String.valueOf(xx.y)+\",\"+String.valueOf(xx.z)+\")\");\n            x[i] = new Vector3d(xx);\n        }\n        return new DHAxes(z,x,c);\n    }\n"]], "pred": {"ppl": 6.167099952697754, "ppl_lower": 6.421656608581543, "ppl/lowercase_ppl": -1.0222332791413717, "ppl/zlib": 0.0005450056032197437, "Min_5.0% Prob": 7.7983961198844165, "Min_10.0% Prob": 5.984383697603263, "Min_20.0% Prob": 4.31270727223041, "Min_30.0% Prob": 3.6600337207706923, "Min_40.0% Prob": 3.318415893610649, "Min_50.0% Prob": 3.1043206628288074, "Min_60.0% Prob": 2.8705564081960557}}
{"hexsha": "d2768d5c81a1e0425c84c472160e7d0f47c07717", "ext": "java", "lang": "Java", "content": "public class OrderDiffTransformer\n    implements Transformer<String, Order, KeyValue<String, DLQRecord>> {\n  private ProcessorContext context;\n  private final String storeName;\n  private WindowStore<String, Order> ordersWindowStore;\n  private final long leftDurationMs;\n  private final long rightDurationMs;\n\n  public OrderDiffTransformer(\n      final String storeName, final long leftDurationMs, final long rightDurationMs) {\n    this.storeName = storeName;\n    this.leftDurationMs = leftDurationMs;\n    this.rightDurationMs = rightDurationMs;\n  }\n\n  @Override\n  public void init(final ProcessorContext context) {\n    this.context = context;\n    ordersWindowStore = this.context.getStateStore(storeName);\n  }\n\n  public OrderWithState newOrder(Order order) {\n    return OrderWithState.newBuilder()\n        .setState(OrderState.Created)\n        .setId(order.getId())\n        .setOrderTimestamp(order.getOrderTimestamp())\n        .setCustomer(\n            CustomerOrderWithState.newBuilder()\n                .setState(OrderState.Created)\n                .setName(order.getCustomer().getName())\n                .setAddress(order.getCustomer().getAddress())\n                .build())\n        .setOrderedItems(\n            order.getOrderedItems().stream()\n                .map(\n                    orderedItem -> {\n                      if (orderedItem.getItemType() == OrderedItemType.book) {\n                        BookOrder book = (BookOrder) orderedItem.getDetails();\n                        return OrderedItem.newBuilder()\n                            .setItemType(\n                                ps.hassany.consistent.graph.orders.internal.OrderedItemType.book)\n                            .setPrice(orderedItem.getPrice())\n                            .setDetails(\n                                BookOrderWithState.newBuilder()\n                                    .setState(OrderState.Created)\n                                    .setId(book.getId())\n                                    .setIsbn(book.getIsbn())\n                                    .setName(book.getName())\n                                    .build())\n                            .build();\n                      } else if (orderedItem.getItemType() == OrderedItemType.laptop) {\n                        LaptopOrder laptop = (LaptopOrder) orderedItem.getDetails();\n                        return OrderedItem.newBuilder()\n                            .setItemType(\n                                ps.hassany.consistent.graph.orders.internal.OrderedItemType.laptop)\n                            .setPrice(orderedItem.getPrice())\n                            .setDetails(\n                                LaptopOrderWithState.newBuilder()\n                                    .setState(OrderState.Created)\n                                    .setId(laptop.getId())\n                                    .setName(laptop.getName())\n                                    .build())\n                            .build();\n                      }\n                      return null;\n                    })\n                .collect(Collectors.toList()))\n        .build();\n  }\n\n  private BookOrderWithState bookToBookWithState(BookOrder book, OrderState state) {\n    return BookOrderWithState.newBuilder()\n        .setState(state)\n        .setId(book.getId())\n        .setIsbn(book.getIsbn())\n        .setName(book.getName())\n        .build();\n  }\n\n  private LaptopOrderWithState laptopToLaptopWithState(LaptopOrder laptop, OrderState state) {\n    return LaptopOrderWithState.newBuilder()\n        .setState(state)\n        .setId(laptop.getId())\n        .setName(laptop.getName())\n        .build();\n  }\n\n  private OrderedItem orderedItemToOrderedItemWithState(\n      ps.hassany.consistent.graph.orders.OrderedItem orderedItem, OrderState state) {\n    if (orderedItem.getItemType() == OrderedItemType.book) {\n      BookOrder book = (BookOrder) orderedItem.getDetails();\n      return OrderedItem.newBuilder()\n          .setItemType(ps.hassany.consistent.graph.orders.internal.OrderedItemType.book)\n          .setPrice(orderedItem.getPrice())\n          .setDetails(bookToBookWithState(book, state))\n          .build();\n    } else if (orderedItem.getItemType() == OrderedItemType.laptop) {\n      LaptopOrder laptop = (LaptopOrder) orderedItem.getDetails();\n      return OrderedItem.newBuilder()\n          .setItemType(ps.hassany.consistent.graph.orders.internal.OrderedItemType.laptop)\n          .setPrice(orderedItem.getPrice())\n          .setDetails(laptopToLaptopWithState(laptop, state))\n          .build();\n    }\n    return null;\n  }\n\n  private String extractOrderedItemId(ps.hassany.consistent.graph.orders.OrderedItem orderedItem) {\n    if (orderedItem.getItemType() == OrderedItemType.book) {\n      BookOrder book = (BookOrder) orderedItem.getDetails();\n      return book.getId();\n    } else if (orderedItem.getItemType() == OrderedItemType.laptop) {\n      LaptopOrder laptop = (LaptopOrder) orderedItem.getDetails();\n      return laptop.getId();\n    }\n    return null;\n  }\n\n  private OrderWithState deleteOrder(Order oldOrder) {\n    var orderWithSateBuilder =\n        OrderWithState.newBuilder()\n            .setState(OrderState.Deleted)\n            .setId(oldOrder.getId())\n            .setOrderTimestamp(System.currentTimeMillis())\n            .setCustomer(\n                CustomerOrderWithState.newBuilder()\n                    .setState(OrderState.Deleted)\n                    .setName(oldOrder.getCustomer().getName())\n                    .setAddress(oldOrder.getCustomer().getAddress())\n                    .build());\n    orderWithSateBuilder.setOrderedItems(\n        oldOrder.getOrderedItems().stream()\n            .map(orderedItem -> orderedItemToOrderedItemWithState(orderedItem, OrderState.Deleted))\n            .collect(Collectors.toList()));\n    return orderWithSateBuilder.build();\n  }\n\n  private OrderWithState orderDiff(Order oldOrder, Order newOrder) {\n    if (newOrder == null) {\n      return deleteOrder(oldOrder);\n    }\n    var orderWithSateBuilder =\n        OrderWithState.newBuilder()\n            .setState(OrderState.Updated)\n            .setId(oldOrder.getId())\n            .setOrderTimestamp(newOrder.getOrderTimestamp())\n            .setCustomer(\n                CustomerOrderWithState.newBuilder()\n                    .setState(OrderState.Updated)\n                    .setName(newOrder.getCustomer().getName())\n                    .setAddress(newOrder.getCustomer().getAddress())\n                    .build());\n\n    var orderedItemsWithState =\n        Stream.concat(\n                // Assume all items in the old order are deleted\n                oldOrder.getOrderedItems().stream()\n                    .map(\n                        orderedItem ->\n                            Tuple.of(\n                                extractOrderedItemId(orderedItem), OrderState.Deleted, orderedItem))\n                    .collect(Collectors.toList())\n                    .stream(),\n                // Assume all items in the new order are Created\n                newOrder.getOrderedItems().stream()\n                    .map(\n                        orderedItem ->\n                            Tuple.of(\n                                extractOrderedItemId(orderedItem), OrderState.Created, orderedItem))\n                    .collect(Collectors.toList())\n                    .stream())\n            .collect(\n                Collectors.toMap(\n                    Tuple3::_1,\n                    v -> Tuple.of(v._2(), v._3()),\n                    // When there's two versions of the same item, take the new one with state\n                    // 'Created' and update state to 'Updated'\n                    (oldValue, newValue) ->\n                        newValue._1() == OrderState.Created\n                            ? Tuple.of(OrderState.Updated, newValue._2())\n                            : Tuple.of(OrderState.Updated, oldValue._2())))\n            .values()\n            .stream()\n            .map(value -> orderedItemToOrderedItemWithState(value._2(), value._1()))\n            .collect(Collectors.toList());\n\n    orderWithSateBuilder.setOrderedItems(orderedItemsWithState);\n    return orderWithSateBuilder.build();\n  }\n\n  @Override\n  public KeyValue<String, DLQRecord> transform(String key, Order order) {\n    final long eventTimestamp = OrderTimestampExtractor.getOrderTimestamp(order);\n    final var timeIterator =\n        ordersWindowStore.fetch(\n            key, eventTimestamp - leftDurationMs, eventTimestamp + rightDurationMs);\n    OrderWithState orderWithState;\n    boolean isError = false;\n    String error = null;\n    if (timeIterator.hasNext()) {\n      orderWithState = orderDiff(timeIterator.next().value, order);\n    } else if (order != null) {\n      orderWithState = newOrder(order);\n    } else {\n      isError = true;\n      error = \"Deleting an order that didn't exists in the WindowedStore.\";\n      orderWithState =\n          OrderWithState.newBuilder()\n              .setState(OrderState.Deleted)\n              .setId(key)\n              .setOrderTimestamp(Clock.systemUTC().millis())\n              .setOrderedItems(List.of())\n              .build();\n    }\n    ordersWindowStore.put(key, order, eventTimestamp);\n    return new KeyValue<>(\n        key,\n        DLQRecord.newBuilder()\n            .setIsError(isError)\n            .setError(error)\n            .setTimestamp(Clock.systemUTC().millis())\n            .setOrderWithState(orderWithState)\n            .build());\n  }\n\n  @Override\n  public void close() {}\n}", "item_id": 0, "repo": "ahassany/tutorials", "file": "consistent-graph/orders-to-graph-stream/src/main/java/ps/hassany/consistent/graph/orders/stream/mapping/OrderDiffTransformer.java", "last_update_at": "2022-02-07T23:05:08+00:00", "question_id": "d2768d5c81a1e0425c84c472160e7d0f47c07717_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OrderDiffTransformer\n    implements Transformer<String, Order, KeyValue<String, DLQRecord>> {\n  private ProcessorContext context;\n  private final String storeName;\n  private WindowStore<String, Order> ordersWindowStore;\n  private final long leftDurationMs;\n  private final long rightDurationMs;\n  public OrderDiffTransformer(\n      final String storeName, final long leftDurationMs, final long rightDurationMs) {\n    this.storeName = storeName;\n    this.leftDurationMs = leftDurationMs;\n    this.rightDurationMs = rightDurationMs;\n  }\n  @Override\n  public void init(final ProcessorContext context) {\n    this.context = context;\n    ordersWindowStore = this.context.getStateStore(storeName);\n  }\n  public OrderWithState newOrder(Order order) {\n    return OrderWithState.newBuilder()\n        .setState(OrderState.Created)\n        .setId(order.getId())\n        .setOrderTimestamp(order.getOrderTimestamp())\n        .setCustomer(\n            CustomerOrderWithState.newBuilder()\n                .setState(OrderState.Created)\n                .setName(order.getCustomer().getName())\n                .setAddress(order.getCustomer().getAddress())\n                .build())\n        .setOrderedItems(\n            order.getOrderedItems().stream()\n                .map(\n                    orderedItem -> {\n                      if (orderedItem.getItemType() == OrderedItemType.book) {\n                        BookOrder book = (BookOrder) orderedItem.getDetails();\n                        return OrderedItem.newBuilder()\n                            .setItemType(\n                                ps.hassany.consistent.graph.orders.internal.OrderedItemType.book)\n                            .setPrice(orderedItem.getPrice())\n                            .setDetails(\n                                BookOrderWithState.newBuilder()\n                                    .setState(OrderState.Created)\n                                    .setId(book.getId())\n                                    .setIsbn(book.getIsbn())\n                                    .setName(book.getName())\n                                    .build())\n                            .build();\n                      } else if (orderedItem.getItemType() == OrderedItemType.laptop) {\n                        LaptopOrder laptop = (LaptopOrder) orderedItem.getDetails();\n                        return OrderedItem.newBuilder()\n                            .setItemType(\n                                ps.hassany.consistent.graph.orders.internal.OrderedItemType.laptop)\n                            .setPrice(orderedItem.getPrice())\n                            .setDetails(\n                                LaptopOrderWithState.newBuilder()\n                                    .setState(OrderState.Created)\n                                    .setId(laptop.getId())\n                                    .setName(laptop.getName())\n                                    .build())\n                            .build();\n                      }\n                      return null;\n                    })\n                .collect(Collectors.toList()))\n        .build();\n  }\n  private BookOrderWithState bookToBookWithState(BookOrder book, OrderState state) {\n    return BookOrderWithState.newBuilder()\n        .setState(state)\n        .setId(book.getId())\n        .setIsbn(book.getIsbn())\n        .setName(book.getName())\n        .build();\n  }\n  private LaptopOrderWithState laptopToLaptopWithState(LaptopOrder laptop, OrderState state) {\n    return LaptopOrderWithState.newBuilder()\n        .setState(state)\n        .setId(laptop.getId())\n        .setName(laptop.getName())\n        .build();\n  }\n  private OrderedItem orderedItemToOrderedItemWithState(\n      ps.hassany.consistent.graph.orders.OrderedItem orderedItem, OrderState state) {\n    if (orderedItem.getItemType() == OrderedItemType.book) {\n      BookOrder book = (BookOrder) orderedItem.getDetails();\n      return OrderedItem.newBuilder()\n          .setItemType(ps.hassany.consistent.graph.orders.internal.OrderedItemType.book)\n          .setPrice(orderedItem.getPrice())\n          .setDetails(bookToBookWithState(book, state))\n          .build();\n    } else if (orderedItem.getItemType() == OrderedItemType.laptop) {\n      LaptopOrder laptop = (LaptopOrder) orderedItem.getDetails();\n      return OrderedItem.newBuilder()\n          .setItemType(ps.hassany.consistent.graph.orders.internal.OrderedItemType.laptop)\n          .setPrice(orderedItem.getPrice())\n          .setDetails(laptopToLaptopWithState(laptop, state))\n          .build();\n    }\n    return null;\n  }\n  private String extractOrderedItemId(ps.hassany.consistent.graph.orders.OrderedItem orderedItem) {\n    if (orderedItem.getItemType() == OrderedItemType.book) {\n      BookOrder book = (BookOrder) orderedItem.getDetails();\n      return book.getId();\n    } else if (orderedItem.getItemType() == OrderedItemType.laptop) {\n      LaptopOrder laptop = (LaptopOrder) orderedItem.getDetails();\n      return laptop.getId();\n    }\n    return null;\n  }\n  private OrderWithState deleteOrder(Order oldOrder) {\n    var orderWithSateBuilder =\n        OrderWithState.newBuilder()\n            .setState(OrderState.Deleted)\n            .setId(oldOrder.getId())\n            .setOrderTimestamp(System.currentTimeMillis())\n            .setCustomer(\n                CustomerOrderWithState.newBuilder()\n                    .setState(OrderState.Deleted)\n                    .setName(oldOrder.getCustomer().getName())\n                    .setAddress(oldOrder.getCustomer().getAddress())\n                    .build());\n    orderWithSateBuilder.setOrderedItems(\n        oldOrder.getOrderedItems().stream()\n            .map(orderedItem -> orderedItemToOrderedItemWithState(orderedItem, OrderState.Deleted))\n            .collect(Collectors.toList()));\n    return orderWithSateBuilder.build();\n  }\n  private OrderWithState orderDiff(Order oldOrder, Order newOrder) {\n    if (newOrder == null) {\n      return deleteOrder(oldOrder);\n    }\n    var orderWithSateBuilder =\n        OrderWithState.newBuilder()\n            .setState(OrderState.Updated)\n            .setId(oldOrder.getId())\n            .setOrderTimestamp(newOrder.getOrderTimestamp())\n            .setCustomer(\n                CustomerOrderWithState.newBuilder()\n                    .setState(OrderState.Updated)\n                    .setName(newOrder.getCustomer().getName())\n                    .setAddress(newOrder.getCustomer().getAddress())\n                    .build());\n    var orderedItemsWithState =\n        Stream.concat(\n                // Assume all items in the old order are deleted\n                oldOrder.getOrderedItems().stream()\n                    .map(\n                        orderedItem ->\n                            Tuple.of(\n                                extractOrderedItemId(orderedItem), OrderState.Deleted, orderedItem))\n                    .collect(Collectors.toList())\n                    .stream(),\n                // Assume all items in the new order are Created\n                newOrder.getOrderedItems().stream()\n                    .map(\n                        orderedItem ->\n                            Tuple.of(\n                                extractOrderedItemId(orderedItem), OrderState.Created, orderedItem))\n                    .collect(Collectors.toList())\n                    .stream())\n            .collect(\n                Collectors.toMap(\n                    Tuple3::_1,\n                    v -> Tuple.of(v._2(), v._3()),\n                    // When there's two versions of the same item, take the new one with state\n                    // 'Created' and update state to 'Updated'\n                    (oldValue, newValue) ->\n                        newValue._1() == OrderState.Created\n                            ? Tuple.of(OrderState.Updated, newValue._2())\n                            : Tuple.of(OrderState.Updated, oldValue._2())))\n            .values()\n            .stream()\n            .map(value -> orderedItemToOrderedItemWithState(value._2(), value._1()))\n            .collect(Collectors.toList());\n    orderWithSateBuilder.setOrderedItems(orderedItemsWithState);\n    return orderWithSateBuilder.build();\n  }\n  @Override\n  public KeyValue<String, DLQRecord> transform(String key, Order order) {\n    final long eventTimestamp = OrderTimestampExtractor.getOrderTimestamp(order);\n    final var timeIterator =\n        ordersWindowStore.fetch(\n            key, eventTimestamp - leftDurationMs, eventTimestamp + rightDurationMs);\n    OrderWithState orderWithState;\n    boolean isError = false;\n    String error = null;\n    if (timeIterator.hasNext()) {\n      orderWithState = orderDiff(timeIterator.next().value, order);\n    } else if (order != null) {\n      orderWithState = newOrder(order);\n    } else {\n      isError = true;\n      error = \"Deleting an order that didn't exists in the WindowedStore.\";\n      orderWithState =\n          OrderWithState.newBuilder()\n              .setState(OrderState.Deleted)\n              .setId(key)\n              .setOrderTimestamp(Clock.systemUTC().millis())\n              .setOrderedItems(List.of())\n              .build();\n    }\n    ordersWindowStore.put(key, order, eventTimestamp);\n    return new KeyValue<>(\n        key,\n        DLQRecord.newBuilder()\n            .setIsError(isError)\n            .setError(error)\n            .setTimestamp(Clock.systemUTC().millis())\n            .setOrderWithState(orderWithState)\n            .build());\n  }\n  @Override\n  public void close() {}\n"]], "pred": {"ppl": 1.4817665815353394, "ppl_lower": 1.6532831192016602, "ppl/lowercase_ppl": -1.278530814008649, "ppl/zlib": 0.00023090722967191528, "Min_5.0% Prob": 5.090690201404048, "Min_10.0% Prob": 3.436281575876124, "Min_20.0% Prob": 1.9343222565948963, "Min_30.0% Prob": 1.3091852328453968, "Min_40.0% Prob": 0.9824389464615828, "Min_50.0% Prob": 0.7869874868446728, "Min_60.0% Prob": 0.6561806778384367}}
{"hexsha": "e146128b3182403def38213884871f2e8aab7bd5", "ext": "java", "lang": "Java", "content": "public class ImageCompressorOptions {\n    public static ImageCompressorOptions fromMap(ReadableMap map) {\n        final ImageCompressorOptions options = new ImageCompressorOptions();\n        final ReadableMapKeySetIterator iterator = map.keySetIterator();\n\n        while (iterator.hasNextKey()) {\n            final String key = iterator.nextKey();\n\n            switch (key) {\n                case \"compressionMethod\":\n                     options.compressionMethod = CompressionMethod.valueOf(map.getString(key));\n                      break;\n                case \"maxWidth\":\n                    options.maxWidth = map.getInt(key);\n                    break;\n                case \"maxHeight\":\n                    options.maxHeight = map.getInt(key);\n                    break;\n                case \"quality\":\n                    options.quality = (float) map.getDouble(key);\n                    break;\n                case \"input\":\n                    options.input = InputType.valueOf(map.getString(key));\n                    break;\n                case \"output\":\n                    options.output = OutputType.valueOf(map.getString(key));\n                    break;\n              case \"returnableOutputType\":\n                options.returnableOutputType = ReturnableOutputType.valueOf(map.getString(key));\n                break;\n            }\n        }\n\n        return options;\n    }\n\n    public enum InputType {\n        base64, uri\n    }\n\n    public enum OutputType {\n        png, jpg\n    }\n\n  public enum ReturnableOutputType {\n    base64, uri\n  }\n\n  public enum CompressionMethod {\n    auto, manual\n  }\n\n    public CompressionMethod compressionMethod = CompressionMethod.manual;\n    public int maxWidth = 1280;\n    public int maxHeight = 1280;\n    public float quality = 0.8f;\n    public InputType input = InputType.uri;\n    public OutputType output = OutputType.jpg;\n    public ReturnableOutputType returnableOutputType = ReturnableOutputType.uri;\n}", "item_id": 0, "repo": "ravinhwg/react-native-compressor", "file": "android/src/main/java/com/reactnativecompressor/Image/utils/ImageCompressorOptions.java", "last_update_at": "2022-03-30T12:00:07+00:00", "question_id": "e146128b3182403def38213884871f2e8aab7bd5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ImageCompressorOptions {\n    public static ImageCompressorOptions fromMap(ReadableMap map) {\n        final ImageCompressorOptions options = new ImageCompressorOptions();\n        final ReadableMapKeySetIterator iterator = map.keySetIterator();\n        while (iterator.hasNextKey()) {\n            final String key = iterator.nextKey();\n            switch (key) {\n                case \"compressionMethod\":\n                     options.compressionMethod = CompressionMethod.valueOf(map.getString(key));\n                      break;\n                case \"maxWidth\":\n                    options.maxWidth = map.getInt(key);\n                    break;\n                case \"maxHeight\":\n                    options.maxHeight = map.getInt(key);\n                    break;\n                case \"quality\":\n                    options.quality = (float) map.getDouble(key);\n                    break;\n                case \"input\":\n                    options.input = InputType.valueOf(map.getString(key));\n                    break;\n                case \"output\":\n                    options.output = OutputType.valueOf(map.getString(key));\n                    break;\n              case \"returnableOutputType\":\n                options.returnableOutputType = ReturnableOutputType.valueOf(map.getString(key));\n                break;\n            }\n        }\n        return options;\n    }\n    public enum InputType {\n        base64, uri\n    }\n    public enum OutputType {\n        png, jpg\n    }\n  public enum ReturnableOutputType {\n    base64, uri\n  }\n  public enum CompressionMethod {\n    auto, manual\n  }\n    public CompressionMethod compressionMethod = CompressionMethod.manual;\n    public int maxWidth = 1280;\n    public int maxHeight = 1280;\n    public float quality = 0.8f;\n    public InputType input = InputType.uri;\n    public OutputType output = OutputType.jpg;\n    public ReturnableOutputType returnableOutputType = ReturnableOutputType.uri;\n"]], "pred": {"ppl": 1.5262867212295532, "ppl_lower": 1.691841959953308, "ppl/lowercase_ppl": -1.243545031139985, "ppl/zlib": 0.0008456756118540174, "Min_5.0% Prob": 5.41640258828799, "Min_10.0% Prob": 3.645577890177568, "Min_20.0% Prob": 2.0548161687617448, "Min_30.0% Prob": 1.3936946840369946, "Min_40.0% Prob": 1.0564480168245656, "Min_50.0% Prob": 0.8457785419805489, "Min_60.0% Prob": 0.7046803448824467}}
{"hexsha": "e1c55e7a2cd83c8a168e344efd31b3994f31fe8e", "ext": "java", "lang": "Java", "content": "public class SignatureKeyPair {\n    SignaturePrivateKey priv;\n    SignaturePublicKey pub;\n    \n    /**\n     * Constructs a new key pair.\n     * @param priv a private key\n     * @param pub a public key\n     */\n    public SignatureKeyPair(SignaturePrivateKey priv, SignaturePublicKey pub) {\n        this.priv = priv;\n        this.pub = pub;\n    }\n    \n    /**\n     * Constructs a new key pair from a byte array\n     * @param b an encoded key pair\n     */\n    public SignatureKeyPair(byte[] b) {\n        this(new ByteArrayInputStream(b));\n    }\n    \n    /**\n     * Constructs a new key pair from an input stream\n     * @param is an input stream\n     * @throws NtruException if an {@link IOException} occurs\n     */\n    public SignatureKeyPair(InputStream is) {\n        pub = new SignaturePublicKey(is);\n        priv = new SignaturePrivateKey(is);\n    }\n    \n    /**\n     * Returns the private key\n     * @return the private key\n     */\n    public SignaturePrivateKey getPrivate() {\n        return priv;\n    }\n    \n    /**\n     * Returns the public key (verification key)\n     * @return the public key\n     */\n    public SignaturePublicKey getPublic() {\n        return pub;\n    }\n\n    /**\n     * Tests if the key pair is valid.\n     * @return <code>true</code> if the key pair is valid, <code>false</code> otherwise\n     */\n    public boolean isValid() {\n        if (priv.N != pub.h.coeffs.length)\n            return false;\n        if (priv.q != pub.q)\n            return false;\n        \n        int B = priv.getNumBases() - 1;\n        for (int i=0; i<=B; i++) {\n            Basis basis = priv.getBasis(i);\n            if (!basis.isValid(i==0 ? pub.h : basis.h))\n                return false;\n        }\n        \n        return true;\n    }\n    \n    /**\n     * Converts the key pair to a byte array\n     * @return the encoded key pair\n     */\n    public byte[] getEncoded() {\n        byte[] pubArr = pub.getEncoded();\n        byte[] privArr = priv.getEncoded();\n        byte[] kpArr = Arrays.copyOf(pubArr, pubArr.length+privArr.length);\n        System.arraycopy(privArr, 0, kpArr, pubArr.length, privArr.length);\n        return kpArr;\n    }\n    \n    /**\n     * Writes the key pair to an output stream\n     * @param os an output stream\n     * @throws IOException\n     */\n    public void writeTo(OutputStream os) throws IOException {\n        os.write(getEncoded());\n    }\n    \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((priv == null) ? 0 : priv.hashCode());\n        result = prime * result + ((pub == null) ? 0 : pub.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        SignatureKeyPair other = (SignatureKeyPair) obj;\n        if (priv == null) {\n            if (other.priv != null)\n                return false;\n        } else if (!priv.equals(other.priv))\n            return false;\n        if (pub == null) {\n            if (other.pub != null)\n                return false;\n        } else if (!pub.equals(other.pub))\n            return false;\n        return true;\n    }\n}", "item_id": 0, "repo": "REduard/NTRU", "file": "src/main/java/net/sf/ntru/sign/SignatureKeyPair.java", "last_update_at": "2022-02-25T09:19:37+00:00", "question_id": "e1c55e7a2cd83c8a168e344efd31b3994f31fe8e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SignatureKeyPair {\n    SignaturePrivateKey priv;\n    SignaturePublicKey pub;\n    /**\n     * Constructs a new key pair.\n     * @param priv a private key\n     * @param pub a public key\n     */\n    public SignatureKeyPair(SignaturePrivateKey priv, SignaturePublicKey pub) {\n        this.priv = priv;\n        this.pub = pub;\n    }\n    /**\n     * Constructs a new key pair from a byte array\n     * @param b an encoded key pair\n     */\n    public SignatureKeyPair(byte[] b) {\n        this(new ByteArrayInputStream(b));\n    }\n    /**\n     * Constructs a new key pair from an input stream\n     * @param is an input stream\n     * @throws NtruException if an {@link IOException} occurs\n     */\n    public SignatureKeyPair(InputStream is) {\n        pub = new SignaturePublicKey(is);\n        priv = new SignaturePrivateKey(is);\n    }\n    /**\n     * Returns the private key\n     * @return the private key\n     */\n    public SignaturePrivateKey getPrivate() {\n        return priv;\n    }\n    /**\n     * Returns the public key (verification key)\n     * @return the public key\n     */\n    public SignaturePublicKey getPublic() {\n        return pub;\n    }\n    /**\n     * Tests if the key pair is valid.\n     * @return <code>true</code> if the key pair is valid, <code>false</code> otherwise\n     */\n    public boolean isValid() {\n        if (priv.N != pub.h.coeffs.length)\n            return false;\n        if (priv.q != pub.q)\n            return false;\n        int B = priv.getNumBases() - 1;\n        for (int i=0; i<=B; i++) {\n            Basis basis = priv.getBasis(i);\n            if (!basis.isValid(i==0 ? pub.h : basis.h))\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Converts the key pair to a byte array\n     * @return the encoded key pair\n     */\n    public byte[] getEncoded() {\n        byte[] pubArr = pub.getEncoded();\n        byte[] privArr = priv.getEncoded();\n        byte[] kpArr = Arrays.copyOf(pubArr, pubArr.length+privArr.length);\n        System.arraycopy(privArr, 0, kpArr, pubArr.length, privArr.length);\n        return kpArr;\n    }\n    /**\n     * Writes the key pair to an output stream\n     * @param os an output stream\n     * @throws IOException\n     */\n    public void writeTo(OutputStream os) throws IOException {\n        os.write(getEncoded());\n    }\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((priv == null) ? 0 : priv.hashCode());\n        result = prime * result + ((pub == null) ? 0 : pub.hashCode());\n        return result;\n    }\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        SignatureKeyPair other = (SignatureKeyPair) obj;\n        if (priv == null) {\n            if (other.priv != null)\n                return false;\n        } else if (!priv.equals(other.priv))\n            return false;\n        if (pub == null) {\n            if (other.pub != null)\n                return false;\n        } else if (!pub.equals(other.pub))\n            return false;\n        return true;\n    }\n"]], "pred": {"ppl": 1.4146653413772583, "ppl_lower": 1.570552945137024, "ppl/lowercase_ppl": -1.301345826738034, "ppl/zlib": 0.0003791180276089743, "Min_5.0% Prob": 4.533320854107539, "Min_10.0% Prob": 2.9658566558112702, "Min_20.0% Prob": 1.6899668892535071, "Min_30.0% Prob": 1.148578490417412, "Min_40.0% Prob": 0.8664639336190053, "Min_50.0% Prob": 0.6931582171111503, "Min_60.0% Prob": 0.578373988421036}}
{"hexsha": "a8c2ca609a64cd64453fc698fbaf869f4eb244c0", "ext": "java", "lang": "Java", "content": "public class HarryPotterMagicMarshaller implements MessageMarshaller<HPMagic> {\n\n   @Override\n   public HPMagic readFrom(ProtoStreamReader reader) throws IOException {\n      String id = reader.readString(\"id\");\n      String caster = reader.readString(\"caster\");\n      String spell = reader.readString(\"spell\");\n      boolean h = reader.readBoolean(\"hogwarts\");\n      return new HPMagic(id, caster, spell, h);\n   }\n\n   @Override\n   public void writeTo(ProtoStreamWriter writer, HPMagic magic) throws IOException {\n      writer.writeString(\"id\", magic.getId());\n      writer.writeString(\"caster\", magic.getCaster());\n      writer.writeString(\"spell\", magic.getSpell());\n      writer.writeBoolean(\"hogwarts\", magic.isHogwarts());\n   }\n\n   @Override\n   public Class<? extends HPMagic> getJavaClass() {\n      return HPMagic.class;\n   }\n\n   @Override\n   public String getTypeName() {\n      return \"quickstart.HPMagic\";\n   }\n}", "item_id": 0, "repo": "tnscorcoran/harry-potter-quarkus", "file": "src/main/java/org/infinispan/hp/model/HarryPotterMagicMarshaller.java", "last_update_at": "2022-03-01T12:36:43+00:00", "question_id": "a8c2ca609a64cd64453fc698fbaf869f4eb244c0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HarryPotterMagicMarshaller implements MessageMarshaller<HPMagic> {\n   @Override\n   public HPMagic readFrom(ProtoStreamReader reader) throws IOException {\n      String id = reader.readString(\"id\");\n      String caster = reader.readString(\"caster\");\n      String spell = reader.readString(\"spell\");\n      boolean h = reader.readBoolean(\"hogwarts\");\n      return new HPMagic(id, caster, spell, h);\n   }\n   @Override\n   public void writeTo(ProtoStreamWriter writer, HPMagic magic) throws IOException {\n      writer.writeString(\"id\", magic.getId());\n      writer.writeString(\"caster\", magic.getCaster());\n      writer.writeString(\"spell\", magic.getSpell());\n      writer.writeBoolean(\"hogwarts\", magic.isHogwarts());\n   }\n   @Override\n   public Class<? extends HPMagic> getJavaClass() {\n      return HPMagic.class;\n   }\n   @Override\n   public String getTypeName() {\n      return \"quickstart.HPMagic\";\n   }\n"]], "pred": {"ppl": 1.5695843696594238, "ppl_lower": 1.9249674081802368, "ppl/lowercase_ppl": -1.452735741475894, "ppl/zlib": 0.001248783522469046, "Min_5.0% Prob": 6.7187498807907104, "Min_10.0% Prob": 4.218521769557681, "Min_20.0% Prob": 2.2360062663709477, "Min_30.0% Prob": 1.5011681888385542, "Min_40.0% Prob": 1.1286001800534515, "Min_50.0% Prob": 0.9039344631019048, "Min_60.0% Prob": 0.7537187138728941}}
{"hexsha": "9bfe59bbf92baf826e82f2d63c52bb51cc6a3390", "ext": "java", "lang": "Java", "content": "public class MissionsViewModel extends AndroidViewModel\n        implements MissionsAdapter.OnAcceptClickListener {\n    private static final long TIME_BASE = 1800000; // 30 minutes\n    public final ObservableField<Mission.Type> typeSelected = new ObservableField<>();\n    public final ObservableField<Mission.Rank> rankSelected = new ObservableField<>();\n    private MutableLiveData<List<Mission>> mMissions = new MutableLiveData<>();\n\n    private SingleLiveEvent<Void> mShowWarningDialogEvent = new SingleLiveEvent<>();\n    private SingleLiveEvent<Boolean> mShowProgressBarEvent = new SingleLiveEvent<>();\n\n    public MissionsViewModel(@NonNull Application application) {\n        super(application);\n        typeSelected.set(Mission.Type.TIME);\n        rankSelected.set(Mission.Rank.RANK_D);\n        filterMissions();\n    }\n\n    public void onTypeSelected(Mission.Type type) {\n        if (type == typeSelected.get()) {\n            return;\n        }\n        typeSelected.set(type);\n        filterMissions();\n    }\n\n    public void onRankSelected(Mission.Rank rank) {\n        if (rank == rankSelected.get()) {\n            return;\n        }\n        rankSelected.set(rank);\n        filterMissions();\n    }\n\n    @Override\n    public synchronized void onAcceptClick(Mission mission) {\n        mShowProgressBarEvent.setValue(true);\n\n        if (mission instanceof SpecialMission) {\n            MissionRepository.getInstance().acceptMission(mission, Mission.Type.SPECIAL);\n            CharOn.character.setSpecialMission(true);\n            mShowProgressBarEvent.setValue(false);\n        } else if (mission instanceof TimeMission && CharOn.character.getTotalDailyMissions() <= 3) {\n            FirebaseFunctionsUtils.getServerTime(currentTimestamp -> {\n                TimeMission timeMission = (TimeMission) mission;\n                timeMission.setInitialTimestamp(currentTimestamp);\n                MissionRepository.getInstance().acceptMission(timeMission, Mission.Type.TIME);\n                NotificationsUtils.setAlarm(getApplication(),\n                        currentTimestamp + timeMission.getDurationMillis());\n                CharOn.character.setTimeMission(true);\n                mShowProgressBarEvent.setValue(false);\n            });\n        } else {\n            mShowProgressBarEvent.setValue(false);\n            mShowWarningDialogEvent.call();\n        }\n    }\n\n    private void filterMissions() {\n        List<Mission> missions = new ArrayList<>();\n\n        if (typeSelected.get() == Mission.Type.TIME) {\n            if (rankSelected.get() == Mission.Rank.RANK_D) {\n                for (MissionInfo missionInfo : EnumSet.range(MissionInfo.MISSION1, MissionInfo.MISSION91)) {\n                    missions.add(new TimeMission(missionInfo.name(), TIME_BASE));\n                }\n            } else if (rankSelected.get() == Mission.Rank.RANK_C) {\n                for (MissionInfo missionInfo : EnumSet.range(MissionInfo.MISSION92, MissionInfo.MISSION167)) {\n                    missions.add(new TimeMission(missionInfo.name(), TIME_BASE));\n                }\n            } else if (rankSelected.get() == Mission.Rank.RANK_B) {\n                for (MissionInfo missionInfo : EnumSet.range(MissionInfo.MISSION168, MissionInfo.MISSION238)) {\n                    missions.add(new TimeMission(missionInfo.name(), TIME_BASE));\n                }\n            } else if (rankSelected.get() == Mission.Rank.RANK_A) {\n                for (MissionInfo missionInfo : EnumSet.range(MissionInfo.MISSION239, MissionInfo.MISSION297)) {\n                    missions.add(new TimeMission(missionInfo.name(), TIME_BASE));\n                }\n            } else { // Rank S\n                for (MissionInfo missionInfo : EnumSet.range(MissionInfo.MISSION298, MissionInfo.MISSION371)) {\n                    missions.add(new TimeMission(missionInfo.name(), TIME_BASE));\n                }\n            }\n        } else { // Type == SPECIAL\n            if (rankSelected.get() == Mission.Rank.RANK_D) {\n                missions.add(new SpecialMission(MissionInfo.MISSION372.name(), 5));\n                missions.add(new SpecialMission(MissionInfo.MISSION373.name(), 10));\n                missions.add(new SpecialMission(MissionInfo.MISSION374.name(), 10));\n                missions.add(new SpecialMission(MissionInfo.MISSION375.name(), 10));\n                missions.add(new SpecialMission(MissionInfo.MISSION376.name(), 10));\n                missions.add(new SpecialMission(MissionInfo.MISSION377.name(), 10));\n                missions.add(new SpecialMission(MissionInfo.MISSION378.name(), 20));\n                missions.add(new SpecialMission(MissionInfo.MISSION379.name(), 20));\n                missions.add(new SpecialMission(MissionInfo.MISSION380.name(), 20));\n                missions.add(new SpecialMission(MissionInfo.MISSION381.name(), 20));\n            } else if (rankSelected.get() == Mission.Rank.RANK_C) {\n                missions.add(new SpecialMission(MissionInfo.MISSION382.name(), 15));\n                missions.add(new SpecialMission(MissionInfo.MISSION383.name(), 20));\n                missions.add(new SpecialMission(MissionInfo.MISSION384.name(), 30));\n                missions.add(new SpecialMission(MissionInfo.MISSION385.name(), 30));\n                missions.add(new SpecialMission(MissionInfo.MISSION386.name(), 30));\n                missions.add(new SpecialMission(MissionInfo.MISSION387.name(), 30));\n                missions.add(new SpecialMission(MissionInfo.MISSION388.name(), 40));\n                missions.add(new SpecialMission(MissionInfo.MISSION389.name(), 40));\n                missions.add(new SpecialMission(MissionInfo.MISSION390.name(), 40));\n                missions.add(new SpecialMission(MissionInfo.MISSION391.name(), 40));\n            } else if (rankSelected.get() == Mission.Rank.RANK_B) {\n                missions.add(new SpecialMission(MissionInfo.MISSION392.name(), 25));\n            }\n        }\n\n        if (missions.size() > 0) {\n            Collections.sort(CharOn.character.getMissionsFinishedId());\n            removeRepeatedMissions(CharOn.character.getMissionsFinishedId(), missions);\n        }\n\n        mMissions.postValue(missions);\n    }\n\n    private void removeRepeatedMissions(Collection<Integer> missionIds, Collection<Mission> missions) {\n        for (int missionId : missionIds) {\n            Iterator<Mission> missionIterator = missions.iterator();\n\n            while (missionIterator.hasNext()) {\n                Mission mission = missionIterator.next();\n                MissionInfo missionInfo = mission.missionInfo();\n\n                if (missionId == missionInfo.ordinal()) {\n                    missionIterator.remove();\n                    break;\n                }\n            }\n        }\n    }\n\n\n    LiveData<List<Mission>> getMissions() {\n        return mMissions;\n    }\n\n    LiveData<Void> getShowWarningDialogEvent() {\n        return mShowWarningDialogEvent;\n    }\n\n    LiveData<Boolean> getShowProgressBarEvent() {\n        return mShowProgressBarEvent;\n    }\n}", "item_id": 0, "repo": "guto-alves/naruto-game", "file": "app/src/main/java/com/gutotech/narutogame/ui/playing/currentvillage/MissionsViewModel.java", "last_update_at": "2022-03-25T05:55:41+00:00", "question_id": "9bfe59bbf92baf826e82f2d63c52bb51cc6a3390_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MissionsViewModel extends AndroidViewModel\n        implements MissionsAdapter.OnAcceptClickListener {\n    private static final long TIME_BASE = 1800000; // 30 minutes\n    public final ObservableField<Mission.Type> typeSelected = new ObservableField<>();\n    public final ObservableField<Mission.Rank> rankSelected = new ObservableField<>();\n    private MutableLiveData<List<Mission>> mMissions = new MutableLiveData<>();\n    private SingleLiveEvent<Void> mShowWarningDialogEvent = new SingleLiveEvent<>();\n    private SingleLiveEvent<Boolean> mShowProgressBarEvent = new SingleLiveEvent<>();\n    public MissionsViewModel(@NonNull Application application) {\n        super(application);\n        typeSelected.set(Mission.Type.TIME);\n        rankSelected.set(Mission.Rank.RANK_D);\n        filterMissions();\n    }\n    public void onTypeSelected(Mission.Type type) {\n        if (type == typeSelected.get()) {\n            return;\n        }\n        typeSelected.set(type);\n        filterMissions();\n    }\n    public void onRankSelected(Mission.Rank rank) {\n        if (rank == rankSelected.get()) {\n            return;\n        }\n        rankSelected.set(rank);\n        filterMissions();\n    }\n    @Override\n    public synchronized void onAcceptClick(Mission mission) {\n        mShowProgressBarEvent.setValue(true);\n        if (mission instanceof SpecialMission) {\n            MissionRepository.getInstance().acceptMission(mission, Mission.Type.SPECIAL);\n            CharOn.character.setSpecialMission(true);\n            mShowProgressBarEvent.setValue(false);\n        } else if (mission instanceof TimeMission && CharOn.character.getTotalDailyMissions() <= 3) {\n            FirebaseFunctionsUtils.getServerTime(currentTimestamp -> {\n                TimeMission timeMission = (TimeMission) mission;\n                timeMission.setInitialTimestamp(currentTimestamp);\n                MissionRepository.getInstance().acceptMission(timeMission, Mission.Type.TIME);\n                NotificationsUtils.setAlarm(getApplication(),\n                        currentTimestamp + timeMission.getDurationMillis());\n                CharOn.character.setTimeMission(true);\n                mShowProgressBarEvent.setValue(false);\n            });\n        } else {\n            mShowProgressBarEvent.setValue(false);\n            mShowWarningDialogEvent.call();\n        }\n    }\n    private void filterMissions() {\n        List<Mission> missions = new ArrayList<>();\n        if (typeSelected.get() == Mission.Type.TIME) {\n            if (rankSelected.get() == Mission.Rank.RANK_D) {\n                for (MissionInfo missionInfo : EnumSet.range(MissionInfo.MISSION1, MissionInfo.MISSION91)) {\n                    missions.add(new TimeMission(missionInfo.name(), TIME_BASE));\n                }\n            } else if (rankSelected.get() == Mission.Rank.RANK_C) {\n                for (MissionInfo missionInfo : EnumSet.range(MissionInfo.MISSION92, MissionInfo.MISSION167)) {\n                    missions.add(new TimeMission(missionInfo.name(), TIME_BASE));\n                }\n            } else if (rankSelected.get() == Mission.Rank.RANK_B) {\n                for (MissionInfo missionInfo : EnumSet.range(MissionInfo.MISSION168, MissionInfo.MISSION238)) {\n                    missions.add(new TimeMission(missionInfo.name(), TIME_BASE));\n                }\n            } else if (rankSelected.get() == Mission.Rank.RANK_A) {\n                for (MissionInfo missionInfo : EnumSet.range(MissionInfo.MISSION239, MissionInfo.MISSION297)) {\n                    missions.add(new TimeMission(missionInfo.name(), TIME_BASE));\n                }\n            } else { // Rank S\n                for (MissionInfo missionInfo : EnumSet.range(MissionInfo.MISSION298, MissionInfo.MISSION371)) {\n                    missions.add(new TimeMission(missionInfo.name(), TIME_BASE));\n                }\n            }\n        } else { // Type == SPECIAL\n            if (rankSelected.get() == Mission.Rank.RANK_D) {\n                missions.add(new SpecialMission(MissionInfo.MISSION372.name(), 5));\n                missions.add(new SpecialMission(MissionInfo.MISSION373.name(), 10));\n                missions.add(new SpecialMission(MissionInfo.MISSION374.name(), 10));\n                missions.add(new SpecialMission(MissionInfo.MISSION375.name(), 10));\n                missions.add(new SpecialMission(MissionInfo.MISSION376.name(), 10));\n                missions.add(new SpecialMission(MissionInfo.MISSION377.name(), 10));\n                missions.add(new SpecialMission(MissionInfo.MISSION378.name(), 20));\n                missions.add(new SpecialMission(MissionInfo.MISSION379.name(), 20));\n                missions.add(new SpecialMission(MissionInfo.MISSION380.name(), 20));\n                missions.add(new SpecialMission(MissionInfo.MISSION381.name(), 20));\n            } else if (rankSelected.get() == Mission.Rank.RANK_C) {\n                missions.add(new SpecialMission(MissionInfo.MISSION382.name(), 15));\n                missions.add(new SpecialMission(MissionInfo.MISSION383.name(), 20));\n                missions.add(new SpecialMission(MissionInfo.MISSION384.name(), 30));\n                missions.add(new SpecialMission(MissionInfo.MISSION385.name(), 30));\n                missions.add(new SpecialMission(MissionInfo.MISSION386.name(), 30));\n                missions.add(new SpecialMission(MissionInfo.MISSION387.name(), 30));\n                missions.add(new SpecialMission(MissionInfo.MISSION388.name(), 40));\n                missions.add(new SpecialMission(MissionInfo.MISSION389.name(), 40));\n                missions.add(new SpecialMission(MissionInfo.MISSION390.name(), 40));\n                missions.add(new SpecialMission(MissionInfo.MISSION391.name(), 40));\n            } else if (rankSelected.get() == Mission.Rank.RANK_B) {\n                missions.add(new SpecialMission(MissionInfo.MISSION392.name(), 25));\n            }\n        }\n        if (missions.size() > 0) {\n            Collections.sort(CharOn.character.getMissionsFinishedId());\n            removeRepeatedMissions(CharOn.character.getMissionsFinishedId(), missions);\n        }\n        mMissions.postValue(missions);\n    }\n    private void removeRepeatedMissions(Collection<Integer> missionIds, Collection<Mission> missions) {\n        for (int missionId : missionIds) {\n            Iterator<Mission> missionIterator = missions.iterator();\n            while (missionIterator.hasNext()) {\n                Mission mission = missionIterator.next();\n                MissionInfo missionInfo = mission.missionInfo();\n                if (missionId == missionInfo.ordinal()) {\n                    missionIterator.remove();\n                    break;\n                }\n            }\n        }\n    }\n    LiveData<List<Mission>> getMissions() {\n        return mMissions;\n    }\n    LiveData<Void> getShowWarningDialogEvent() {\n        return mShowWarningDialogEvent;\n    }\n    LiveData<Boolean> getShowProgressBarEvent() {\n        return mShowProgressBarEvent;\n    }\n"]], "pred": {"ppl": 1.6229509115219116, "ppl_lower": 1.899724006652832, "ppl/lowercase_ppl": -1.3251705942256073, "ppl/zlib": 0.0003638212190500272, "Min_5.0% Prob": 5.407851798861635, "Min_10.0% Prob": 3.763910831189623, "Min_20.0% Prob": 2.310792843500773, "Min_30.0% Prob": 1.6018545191515894, "Min_40.0% Prob": 1.2087230129932534, "Min_50.0% Prob": 0.9688902807389176, "Min_60.0% Prob": 0.8079954485035218}}
{"hexsha": "1104846c58988fcda1603b26d6518a77a20f63c9", "ext": "java", "lang": "Java", "content": "public class DoUnlessAttachedControllerPaysEffect extends OneShotEffect {\n\n    protected Effects executingEffects = new Effects();\n    private final Cost cost;\n    private String chooseUseText;\n\n    public DoUnlessAttachedControllerPaysEffect(Effect effect, Cost cost) {\n        this(effect, cost, null);\n    }\n\n    public DoUnlessAttachedControllerPaysEffect(Effect effect, Cost cost, String chooseUseText) {\n        super(Outcome.Neutral);\n        this.executingEffects.add(effect);\n        this.cost = cost;\n        this.chooseUseText = chooseUseText;\n    }\n\n    public DoUnlessAttachedControllerPaysEffect(final DoUnlessAttachedControllerPaysEffect effect) {\n        super(effect);\n        this.executingEffects = effect.executingEffects.copy();\n        this.cost = effect.cost.copy();\n        this.chooseUseText = effect.chooseUseText;\n    }\n\n    public void addEffect(Effect effect) {\n        executingEffects.add(effect);\n    }\n\n    @Override\n    public boolean apply(Game game, Ability source) {\n        Permanent aura = game.getPermanentOrLKIBattlefield(source.getSourceId());\n        if (aura == null) {\n            return false;\n        }\n        Permanent attachedTo = game.getPermanentOrLKIBattlefield(aura.getAttachedTo());\n        if (attachedTo == null) {\n            return false;\n        }\n        Player controllerOfAttachedTo = game.getPlayer(attachedTo.getControllerId());\n        if (controllerOfAttachedTo != null) {\n            String message;\n            if (chooseUseText == null) {\n                String effectText = executingEffects.getText(source.getModes().getMode());\n                message = \"Pay \" + cost.getText() + \" to prevent (\" + effectText.substring(0, effectText.length() - 1) + \")?\";\n            } else {\n                message = chooseUseText;\n            }\n            message = CardUtil.replaceSourceName(message, aura.getName());\n            boolean result = true;\n            boolean doEffect = true;\n\n            // check if controller is willing to pay\n            if (cost.canPay(source, source, controllerOfAttachedTo.getId(), game)\n                    && controllerOfAttachedTo.chooseUse(Outcome.Neutral, message, source, game)) {\n                cost.clearPaid();\n                if (cost.pay(source, game, source, controllerOfAttachedTo.getId(), false, null)) {\n                    if (!game.isSimulation()) {\n                        game.informPlayers(controllerOfAttachedTo.getLogName() + \" pays the cost to prevent the effect\");\n                    }\n                    doEffect = false;\n                }\n            }\n\n            // do the effects if not paid\n            if (doEffect) {\n                for (Effect effect : executingEffects) {\n                    effect.setTargetPointer(this.targetPointer);\n                    if (effect instanceof OneShotEffect) {\n                        result &= effect.apply(game, source);\n                    } else {\n                        game.addEffect((ContinuousEffect) effect, source);\n                    }\n                }\n            }\n            return result;\n        }\n        return false;\n    }\n\n    @Override\n    public String getText(Mode mode) {\n        if (!staticText.isEmpty()) {\n            return staticText;\n        }\n        String effectsText = executingEffects.getText(mode);\n        return effectsText.substring(0, effectsText.length() - 1) + \" unless controller pays \" + cost.getText();\n    }\n\n    @Override\n    public DoUnlessAttachedControllerPaysEffect copy() {\n        return new DoUnlessAttachedControllerPaysEffect(this);\n    }\n}", "item_id": 0, "repo": "GabrielSturtevant/mage", "file": "Mage/src/main/java/mage/abilities/effects/common/DoUnlessAttachedControllerPaysEffect.java", "last_update_at": "2022-03-31T13:57:18+00:00", "question_id": "1104846c58988fcda1603b26d6518a77a20f63c9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DoUnlessAttachedControllerPaysEffect extends OneShotEffect {\n    protected Effects executingEffects = new Effects();\n    private final Cost cost;\n    private String chooseUseText;\n    public DoUnlessAttachedControllerPaysEffect(Effect effect, Cost cost) {\n        this(effect, cost, null);\n    }\n    public DoUnlessAttachedControllerPaysEffect(Effect effect, Cost cost, String chooseUseText) {\n        super(Outcome.Neutral);\n        this.executingEffects.add(effect);\n        this.cost = cost;\n        this.chooseUseText = chooseUseText;\n    }\n    public DoUnlessAttachedControllerPaysEffect(final DoUnlessAttachedControllerPaysEffect effect) {\n        super(effect);\n        this.executingEffects = effect.executingEffects.copy();\n        this.cost = effect.cost.copy();\n        this.chooseUseText = effect.chooseUseText;\n    }\n    public void addEffect(Effect effect) {\n        executingEffects.add(effect);\n    }\n    @Override\n    public boolean apply(Game game, Ability source) {\n        Permanent aura = game.getPermanentOrLKIBattlefield(source.getSourceId());\n        if (aura == null) {\n            return false;\n        }\n        Permanent attachedTo = game.getPermanentOrLKIBattlefield(aura.getAttachedTo());\n        if (attachedTo == null) {\n            return false;\n        }\n        Player controllerOfAttachedTo = game.getPlayer(attachedTo.getControllerId());\n        if (controllerOfAttachedTo != null) {\n            String message;\n            if (chooseUseText == null) {\n                String effectText = executingEffects.getText(source.getModes().getMode());\n                message = \"Pay \" + cost.getText() + \" to prevent (\" + effectText.substring(0, effectText.length() - 1) + \")?\";\n            } else {\n                message = chooseUseText;\n            }\n            message = CardUtil.replaceSourceName(message, aura.getName());\n            boolean result = true;\n            boolean doEffect = true;\n            // check if controller is willing to pay\n            if (cost.canPay(source, source, controllerOfAttachedTo.getId(), game)\n                    && controllerOfAttachedTo.chooseUse(Outcome.Neutral, message, source, game)) {\n                cost.clearPaid();\n                if (cost.pay(source, game, source, controllerOfAttachedTo.getId(), false, null)) {\n                    if (!game.isSimulation()) {\n                        game.informPlayers(controllerOfAttachedTo.getLogName() + \" pays the cost to prevent the effect\");\n                    }\n                    doEffect = false;\n                }\n            }\n            // do the effects if not paid\n            if (doEffect) {\n                for (Effect effect : executingEffects) {\n                    effect.setTargetPointer(this.targetPointer);\n                    if (effect instanceof OneShotEffect) {\n                        result &= effect.apply(game, source);\n                    } else {\n                        game.addEffect((ContinuousEffect) effect, source);\n                    }\n                }\n            }\n            return result;\n        }\n        return false;\n    }\n    @Override\n    public String getText(Mode mode) {\n        if (!staticText.isEmpty()) {\n            return staticText;\n        }\n        String effectsText = executingEffects.getText(mode);\n        return effectsText.substring(0, effectsText.length() - 1) + \" unless controller pays \" + cost.getText();\n    }\n    @Override\n    public DoUnlessAttachedControllerPaysEffect copy() {\n        return new DoUnlessAttachedControllerPaysEffect(this);\n    }\n"]], "pred": {"ppl": 1.5196672677993774, "ppl_lower": 1.9578102827072144, "ppl/lowercase_ppl": -1.605353498187294, "ppl/zlib": 0.0004350222537753748, "Min_5.0% Prob": 5.07674068989961, "Min_10.0% Prob": 3.439769914616709, "Min_20.0% Prob": 2.0213698519242778, "Min_30.0% Prob": 1.38505267279504, "Min_40.0% Prob": 1.0451211787765278, "Min_50.0% Prob": 0.8372510956386546, "Min_60.0% Prob": 0.6978510908234473}}
{"hexsha": "86a3a1bfa8fb25de9c5d752e4bd6da9fa5b872fe", "ext": "java", "lang": "Java", "content": "class WordPublisher extends Handler<WordEnvelope> {\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n    private final String topic;\n    private final SendProducer<String, String> sendProducer;\n\n    public WordPublisher(String topic, SendProducer<String, String> sendProducer) {\n      this.topic = topic;\n      this.sendProducer = sendProducer;\n    }\n\n    @Override\n    public CompletionStage<Done> process(WordEnvelope envelope) {\n      String word = envelope.word;\n      // using the word as the key and `DefaultPartitioner` will select partition based on the key\n      // so that same word always ends up in same partition\n      String key = word;\n      ProducerRecord<String, String> producerRecord = new ProducerRecord<>(topic, key, word);\n      CompletionStage<RecordMetadata> result = sendProducer.send(producerRecord);\n      CompletionStage<Done> done =\n          result.thenApply(\n              recordMetadata -> {\n                logger.info(\n                    \"Published word [{}] to topic/partition {}/{}\",\n                    word,\n                    topic,\n                    recordMetadata.partition());\n                return Done.getInstance();\n              });\n      return done;\n    }\n  }", "item_id": 1, "repo": "claudio-scandura/akka-projection", "file": "examples/src/test/java/jdocs/kafka/KafkaDocExample.java", "last_update_at": "2022-03-15T05:40:39+00:00", "question_id": "86a3a1bfa8fb25de9c5d752e4bd6da9fa5b872fe_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class WordPublisher extends Handler<WordEnvelope> {\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n    private final String topic;\n    private final SendProducer<String, String> sendProducer;\n    public WordPublisher(String topic, SendProducer<String, String> sendProducer) {\n      this.topic = topic;\n      this.sendProducer = sendProducer;\n    }\n    @Override\n    public CompletionStage<Done> process(WordEnvelope envelope) {\n      String word = envelope.word;\n      // using the word as the key and `DefaultPartitioner` will select partition based on the key\n      // so that same word always ends up in same partition\n      String key = word;\n      ProducerRecord<String, String> producerRecord = new ProducerRecord<>(topic, key, word);\n      CompletionStage<RecordMetadata> result = sendProducer.send(producerRecord);\n      CompletionStage<Done> done =\n          result.thenApply(\n              recordMetadata -> {\n                logger.info(\n                    \"Published word [{}] to topic/partition {}/{}\",\n                    word,\n                    topic,\n                    recordMetadata.partition());\n                return Done.getInstance();\n              });\n      return done;\n    }\n"]], "pred": {"ppl": 2.058936834335327, "ppl_lower": 2.6348965167999268, "ppl/lowercase_ppl": -1.3415364992520382, "ppl/zlib": 0.001498318982860806, "Min_5.0% Prob": 6.727537441253662, "Min_10.0% Prob": 4.943311619758606, "Min_20.0% Prob": 3.2280918408612735, "Min_30.0% Prob": 2.330471114943857, "Min_40.0% Prob": 1.786726241795028, "Min_50.0% Prob": 1.4418313743232132, "Min_60.0% Prob": 1.2044823963748845}}
{"hexsha": "05201697c799520ed8fa317811217360130a5685", "ext": "java", "lang": "Java", "content": "public class DummyEntitySelectionModelListener implements EntitySelectionModelListener {\n\n\tpublic boolean isOwlPropertyChanged() {\n\t\treturn owlPropertyChanged;\n\t}\n\n\n\tpublic boolean isValidationTypeChanged() {\n\t\treturn validationTypeChanged;\n\t}\n\n\n\tpublic boolean isSelectedEntityChanged() {\n\t\treturn selectedEntityChanged;\n\t}\n\n\n\tpublic OWLPropertyItem getSelectedProperty() {\n\t\treturn selectedProperty;\n\t}\n\n\n\tpublic OWLEntity getSelectedEntity() {\n\t\treturn selectedEntity;\n\t}\n\n\n\tpublic ValidationType getSelectedValidationType() {\n\t\treturn selectedValidationType;\n\t}\n\n\n\tpublic DummyEntitySelectionModelListener() {\n\t\treset();\n\t}\n\n\tprivate boolean owlPropertyChanged;\n\tprivate boolean validationTypeChanged;\n\tprivate boolean selectedEntityChanged;\n\t\n\tprivate OWLPropertyItem selectedProperty;\n\tprivate OWLEntity selectedEntity;\n\tprivate ValidationType selectedValidationType;\n\t\n\tpublic void reset() {\n\t\towlPropertyChanged=false;\n\t\tvalidationTypeChanged=false;\n\t\tselectedEntityChanged=false;\n\t\tselectedProperty=null;\n\t\tselectedEntity=null;\n\t\tselectedValidationType=null;\n\t}\n\t\n\t\n\t@Override\n\tpublic void owlPropertyChanged(OWLPropertyItem item) {\n\t\tselectedProperty=item;\n\t\towlPropertyChanged=true;\n\t}\n\n\t@Override\n\tpublic void validationTypeChanged(ValidationType type) {\n\t\tselectedValidationType=type;\n\t\tvalidationTypeChanged=true;\t\t\t\t\n\t}\n\n\t@Override\n\tpublic void selectedEntityChanged(OWLEntity entity) {\n\t\tselectedEntity=entity;\n\t\tselectedEntityChanged=true;\t\t\n\t}\n\n}", "item_id": 0, "repo": "weidemas/RightField", "file": "src/test/java/uk/ac/manchester/cs/owl/semspreadsheets/DummyEntitySelectionModelListener.java", "last_update_at": "2022-03-05T09:52:59+00:00", "question_id": "05201697c799520ed8fa317811217360130a5685_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DummyEntitySelectionModelListener implements EntitySelectionModelListener {\n\tpublic boolean isOwlPropertyChanged() {\n\t\treturn owlPropertyChanged;\n\t}\n\tpublic boolean isValidationTypeChanged() {\n\t\treturn validationTypeChanged;\n\t}\n\tpublic boolean isSelectedEntityChanged() {\n\t\treturn selectedEntityChanged;\n\t}\n\tpublic OWLPropertyItem getSelectedProperty() {\n\t\treturn selectedProperty;\n\t}\n\tpublic OWLEntity getSelectedEntity() {\n\t\treturn selectedEntity;\n\t}\n\tpublic ValidationType getSelectedValidationType() {\n\t\treturn selectedValidationType;\n\t}\n\tpublic DummyEntitySelectionModelListener() {\n\t\treset();\n\t}\n\tprivate boolean owlPropertyChanged;\n\tprivate boolean validationTypeChanged;\n\tprivate boolean selectedEntityChanged;\n\t\n\tprivate OWLPropertyItem selectedProperty;\n\tprivate OWLEntity selectedEntity;\n\tprivate ValidationType selectedValidationType;\n\t\n\tpublic void reset() {\n\t\towlPropertyChanged=false;\n\t\tvalidationTypeChanged=false;\n\t\tselectedEntityChanged=false;\n\t\tselectedProperty=null;\n\t\tselectedEntity=null;\n\t\tselectedValidationType=null;\n\t}\n\t\n\t\n\t@Override\n\tpublic void owlPropertyChanged(OWLPropertyItem item) {\n\t\tselectedProperty=item;\n\t\towlPropertyChanged=true;\n\t}\n\t@Override\n\tpublic void validationTypeChanged(ValidationType type) {\n\t\tselectedValidationType=type;\n\t\tvalidationTypeChanged=true;\t\t\t\t\n\t}\n\t@Override\n\tpublic void selectedEntityChanged(OWLEntity entity) {\n\t\tselectedEntity=entity;\n\t\tselectedEntityChanged=true;\t\t\n\t}\n"]], "pred": {"ppl": 1.523324966430664, "ppl_lower": 1.6460148096084595, "ppl/lowercase_ppl": -1.184040194910901, "ppl/zlib": 0.0011659153011818228, "Min_5.0% Prob": 5.411481164750599, "Min_10.0% Prob": 3.563177078269249, "Min_20.0% Prob": 2.0397230960255444, "Min_30.0% Prob": 1.396032790631749, "Min_40.0% Prob": 1.0489073958936972, "Min_50.0% Prob": 0.8423005005418047, "Min_60.0% Prob": 0.7031813684174913}}
