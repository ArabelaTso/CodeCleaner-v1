{"hexsha": "25f8048433302668dcb5b989a761ed830bd01c31", "ext": "rs", "lang": "Rust", "content": "fn run() -> Result<(), Error> {\n    let opt = Opt::from_args();\n\n    if let Some(path) = &opt.log_dir {\n        if !path.is_dir() {\n            eprintln!(\"Expect a directory for logging graphs\");\n            return Err(Error::from(ErrorKind::InvalidInput));\n        }\n    }\n\n    env_logger::init();\n\n    let (log_tx, log_rx) = sync::channel(1000);\n    let (graph_tx, graph_rx) = sync::channel(10);\n    let (_stream_tx, stream_rx) = sync::channel(10);\n\n    let secrets_pat = [r\".*\\.secret$\", r\".*\\.kvmi$\"];\n    let secrets = RegexSet::new(&secrets_pat).unwrap();\n    let constructor = task::spawn(graph::construct(log_rx, graph_tx, secrets));\n\n    let consumer = task::spawn(consume::consume(graph_rx, opt.log_dir.clone(), stream_rx));\n\n    task::block_on(async {\n        let mut subscribe = Box::pin(rpc::subscribe(&opt.addr, log_tx)).fuse();\n        let mut consumer = consumer.fuse();\n        loop {\n            select! {\n                res = consumer => {\n                    if let Err(e) = res {\n                        break Err(e);\n                    }\n                }\n                res = subscribe => {\n                    if let Err(e) = res {\n                        break Err(e);\n                    }\n                }\n                complete => break Ok(()),\n            }\n        }\n    })?;\n    task::block_on(async { constructor.await });\n    Ok(())\n}", "item_id": 0, "repo": "kylerky/kvmi-rs", "file": "observer/src/bin/observer.rs", "last_update_at": "2021-09-09T09:20:03+00:00", "question_id": "25f8048433302668dcb5b989a761ed830bd01c31_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn run() -> Result<(), Error> {\n    let opt = Opt::from_args();\n    if let Some(path) = &opt.log_dir {\n        if !path.is_dir() {\n            eprintln!(\"Expect a directory for logging graphs\");\n            return Err(Error::from(ErrorKind::InvalidInput));\n        }\n    }\n    env_logger::init();\n    let (log_tx, log_rx) = sync::channel(1000);\n    let (graph_tx, graph_rx) = sync::channel(10);\n    let (_stream_tx, stream_rx) = sync::channel(10);\n    let secrets_pat = [r\".*\\.secret$\", r\".*\\.kvmi$\"];\n    let secrets = RegexSet::new(&secrets_pat).unwrap();\n    let constructor = task::spawn(graph::construct(log_rx, graph_tx, secrets));\n    let consumer = task::spawn(consume::consume(graph_rx, opt.log_dir.clone(), stream_rx));\n    task::block_on(async {\n        let mut subscribe = Box::pin(rpc::subscribe(&opt.addr, log_tx)).fuse();\n        let mut consumer = consumer.fuse();\n        loop {\n            select! {\n                res = consumer => {\n                    if let Err(e) = res {\n                        break Err(e);\n                    }\n                }\n                res = subscribe => {\n                    if let Err(e) = res {\n                        break Err(e);\n                    }\n                }\n                complete => break Ok(()),\n            }\n        }\n    })?;\n    task::block_on(async { constructor.await });\n    Ok(())\n"]], "pred": {"ppl": 2.4422075748443604, "ppl_lower": 2.830397844314575, "ppl/lowercase_ppl": -1.165208328514026, "ppl/zlib": 0.001681548727042969, "Min_5.0% Prob": 7.9427871477036245, "Min_10.0% Prob": 5.723534748667762, "Min_20.0% Prob": 3.8102880276384807, "Min_30.0% Prob": 2.805932087926414, "Min_40.0% Prob": 2.191694552993633, "Min_50.0% Prob": 1.773330064701303, "Min_60.0% Prob": 1.487913537044518}}
{"hexsha": "a47906b3d37d872c524b954dcaeccf0bee6abf46", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn make_module(vm: &VirtualMachine) -> PyObjectRef {\n    use crate::signal::NSIG;\n    use _signal::{SIG_DFL, SIG_ERR, SIG_IGN};\n\n    let module = _signal::make_module(vm);\n\n    let sig_dfl = vm.new_pyobj(SIG_DFL as u8);\n    let sig_ign = vm.new_pyobj(SIG_IGN as u8);\n\n    for signum in 1..NSIG {\n        let handler = unsafe { libc::signal(signum as i32, SIG_IGN) };\n        if handler != SIG_ERR {\n            unsafe { libc::signal(signum as i32, handler) };\n        }\n        let py_handler = if handler == SIG_DFL {\n            Some(sig_dfl.clone())\n        } else if handler == SIG_IGN {\n            Some(sig_ign.clone())\n        } else {\n            None\n        };\n        vm.signal_handlers.as_deref().unwrap().borrow_mut()[signum] = py_handler;\n    }\n\n    let int_handler = module\n        .clone()\n        .get_attr(\"default_int_handler\", vm)\n        .expect(\"_signal does not have this attr?\");\n    _signal::signal(libc::SIGINT, int_handler, vm).expect(\"Failed to set sigint handler\");\n\n    module\n}", "item_id": 0, "repo": "matthieugouel/RustPython", "file": "vm/src/stdlib/signal.rs", "last_update_at": "2021-09-03T16:09:45+00:00", "question_id": "a47906b3d37d872c524b954dcaeccf0bee6abf46_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn make_module(vm: &VirtualMachine) -> PyObjectRef {\n    use crate::signal::NSIG;\n    use _signal::{SIG_DFL, SIG_ERR, SIG_IGN};\n    let module = _signal::make_module(vm);\n    let sig_dfl = vm.new_pyobj(SIG_DFL as u8);\n    let sig_ign = vm.new_pyobj(SIG_IGN as u8);\n    for signum in 1..NSIG {\n        let handler = unsafe { libc::signal(signum as i32, SIG_IGN) };\n        if handler != SIG_ERR {\n            unsafe { libc::signal(signum as i32, handler) };\n        }\n        let py_handler = if handler == SIG_DFL {\n            Some(sig_dfl.clone())\n        } else if handler == SIG_IGN {\n            Some(sig_ign.clone())\n        } else {\n            None\n        };\n        vm.signal_handlers.as_deref().unwrap().borrow_mut()[signum] = py_handler;\n    }\n    let int_handler = module\n        .clone()\n        .get_attr(\"default_int_handler\", vm)\n        .expect(\"_signal does not have this attr?\");\n    _signal::signal(libc::SIGINT, int_handler, vm).expect(\"Failed to set sigint handler\");\n    module\n"]], "pred": {"ppl": 2.1808745861053467, "ppl_lower": 2.607598066329956, "ppl/lowercase_ppl": -1.2291876093168899, "ppl/zlib": 0.001748264535054154, "Min_5.0% Prob": 7.64357463051291, "Min_10.0% Prob": 5.669694410051618, "Min_20.0% Prob": 3.535655790651348, "Min_30.0% Prob": 2.534464319175649, "Min_40.0% Prob": 1.9420222369107334, "Min_50.0% Prob": 1.5611304845660925, "Min_60.0% Prob": 1.3014960335156078}}
{"hexsha": "7d20cd547842c8e4548e1de1262f93f13c5abd53", "ext": "rs", "lang": "Rust", "content": "fn it_adds_junit_test_for_java_files() {\n  let examples_path = helper::get_examples_path().join(\"java/junit\");\n  let sample_path = Path::new(\"src/main/java/com/example/FooBar.java\");\n\n  unit::run(&examples_path, &sample_path, \"junit\").unwrap();\n\n  let generated_path = examples_path.join(\"src/test/java/com/example/FooBarTest.java\");\n  let expected_path = examples_path.join(\"src/test.expected/java/com/example/FooBarTest.java\");\n\n  compare_files(&generated_path, &expected_path);\n\n  let generated_pom_xml = examples_path.join(\"pom.xml\");\n  let expected_pom_xml = examples_path.join(\"pom.expected.xml\");\n\n  compare_files(&generated_pom_xml, &expected_pom_xml);\n}", "item_id": 0, "repo": "rogeriochaves/un", "file": "tests/java_test.rs", "last_update_at": "2021-01-02T23:31:26+00:00", "question_id": "7d20cd547842c8e4548e1de1262f93f13c5abd53_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn it_adds_junit_test_for_java_files() {\n  let examples_path = helper::get_examples_path().join(\"java/junit\");\n  let sample_path = Path::new(\"src/main/java/com/example/FooBar.java\");\n  unit::run(&examples_path, &sample_path, \"junit\").unwrap();\n  let generated_path = examples_path.join(\"src/test/java/com/example/FooBarTest.java\");\n  let expected_path = examples_path.join(\"src/test.expected/java/com/example/FooBarTest.java\");\n  compare_files(&generated_path, &expected_path);\n  let generated_pom_xml = examples_path.join(\"pom.xml\");\n  let expected_pom_xml = examples_path.join(\"pom.expected.xml\");\n  compare_files(&generated_pom_xml, &expected_pom_xml);\n"]], "pred": {"ppl": 2.3165364265441895, "ppl_lower": 2.5849788188934326, "ppl/lowercase_ppl": -1.1305174000982627, "ppl/zlib": 0.003320447235455943, "Min_5.0% Prob": 8.176473704251377, "Min_10.0% Prob": 6.034623514522206, "Min_20.0% Prob": 3.7725828091303506, "Min_30.0% Prob": 2.72336450575003, "Min_40.0% Prob": 2.078088396622075, "Min_50.0% Prob": 1.6827407011629216, "Min_60.0% Prob": 1.399050050518579}}
{"hexsha": "d6d4374dfb1e4e0d8327fa35114f450e9b1e0bb2", "ext": "rs", "lang": "Rust", "content": "fn extract_first_name_owned<'a>(\n    entity: StrEntity,\n    expected_last_name: impl Into<BooStr<'a>>,\n) -> Str {\n    assert_eq!(entity.last_name.deref(), expected_last_name.into().deref());\n    // Convert a Boo (BooStr in this case) into owned (`NewStr` is the implementation used to\n    // convert \"&str\" to \"Str\" if `first_name` is borrowed).\n    entity.first_name.into_owned_with::<NewStr>()\n}", "item_id": 1, "repo": "cronosun/abin", "file": "abin/tests/usage_5_boo.rs", "last_update_at": "2021-04-28T12:02:04+00:00", "question_id": "d6d4374dfb1e4e0d8327fa35114f450e9b1e0bb2_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn extract_first_name_owned<'a>(\n    entity: StrEntity,\n    expected_last_name: impl Into<BooStr<'a>>,\n) -> Str {\n    assert_eq!(entity.last_name.deref(), expected_last_name.into().deref());\n    // Convert a Boo (BooStr in this case) into owned (`NewStr` is the implementation used to\n    // convert \"&str\" to \"Str\" if `first_name` is borrowed).\n    entity.first_name.into_owned_with::<NewStr>()\n"]], "pred": {"ppl": 7.513724327087402, "ppl_lower": 9.428468704223633, "ppl/lowercase_ppl": -1.1125595878804049, "ppl/zlib": 0.008198094547050817, "Min_5.0% Prob": 9.568271160125732, "Min_10.0% Prob": 8.416965924776518, "Min_20.0% Prob": 6.875074121687147, "Min_30.0% Prob": 5.772255932412496, "Min_40.0% Prob": 4.784014745192095, "Min_50.0% Prob": 3.959771510483562, "Min_60.0% Prob": 3.365219519450897}}
{"hexsha": "4e62a8d5e22b8d2ac16ea49e74ef2668cc132869", "ext": "rs", "lang": "Rust", "content": "fn verify_disk_state(disk: &Box<Disk>, files: &Vec<RandomFile>) -> io::Result<()> {\n    // Validate disk image\n    disk.validate().unwrap();\n    // Confirm blocks free\n    let total_data_blocks = disk.disk_format()?.total_data_blocks();\n    let blocks_written: usize = files.iter().map(|f| f.blocks()).sum();\n    let expected_blocks_free = total_data_blocks - blocks_written;\n    assert_eq!(disk.blocks_free().unwrap(), expected_blocks_free);\n    Ok(())\n}", "item_id": 3, "repo": "vschwaberow/cbm", "file": "tests/integration_test.rs", "last_update_at": "2021-09-24T14:48:12+00:00", "question_id": "4e62a8d5e22b8d2ac16ea49e74ef2668cc132869_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn verify_disk_state(disk: &Box<Disk>, files: &Vec<RandomFile>) -> io::Result<()> {\n    // Validate disk image\n    disk.validate().unwrap();\n    // Confirm blocks free\n    let total_data_blocks = disk.disk_format()?.total_data_blocks();\n    let blocks_written: usize = files.iter().map(|f| f.blocks()).sum();\n    let expected_blocks_free = total_data_blocks - blocks_written;\n    assert_eq!(disk.blocks_free().unwrap(), expected_blocks_free);\n    Ok(())\n"]], "pred": {"ppl": 3.397040605545044, "ppl_lower": 4.279363632202148, "ppl/lowercase_ppl": -1.1888124911751203, "ppl/zlib": 0.004776971259615037, "Min_5.0% Prob": 8.386352675301689, "Min_10.0% Prob": 6.987382539113363, "Min_20.0% Prob": 4.943241973718007, "Min_30.0% Prob": 3.7788306024339464, "Min_40.0% Prob": 3.0104840661088628, "Min_50.0% Prob": 2.4224491712490193, "Min_60.0% Prob": 2.036484228426611}}
{"hexsha": "53efe21788eeaf56062fb222670962e5a54f5467", "ext": "rs", "lang": "Rust", "content": "fn factory_valid_config_all() {\n        let factory = CaptureBytesFactory::new(&logger());\n        let mut map = Mapping::new();\n        map.insert(\n            Value::String(\"strategy\".into()),\n            Value::String(\"SUFFIX\".into()),\n        );\n        map.insert(\n            Value::String(\"metadataKey\".into()),\n            Value::String(TOKEN_KEY.into()),\n        );\n        map.insert(Value::String(\"size\".into()), Value::Number(3.into()));\n        map.insert(Value::String(\"remove\".into()), Value::Bool(true));\n\n        let filter = factory\n            .create_filter(CreateFilterArgs::fixed(\n                Registry::default(),\n                Some(&Value::Mapping(map)),\n            ))\n            .unwrap();\n        assert_end_strategy(filter.as_ref(), TOKEN_KEY, true);\n    }", "item_id": 0, "repo": "CyberFlameGO/quilkin", "file": "src/filters/extensions/capture_bytes.rs", "last_update_at": "2021-09-20T05:41:37+00:00", "question_id": "53efe21788eeaf56062fb222670962e5a54f5467_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn factory_valid_config_all() {\n        let factory = CaptureBytesFactory::new(&logger());\n        let mut map = Mapping::new();\n        map.insert(\n            Value::String(\"strategy\".into()),\n            Value::String(\"SUFFIX\".into()),\n        );\n        map.insert(\n            Value::String(\"metadataKey\".into()),\n            Value::String(TOKEN_KEY.into()),\n        );\n        map.insert(Value::String(\"size\".into()), Value::Number(3.into()));\n        map.insert(Value::String(\"remove\".into()), Value::Bool(true));\n        let filter = factory\n            .create_filter(CreateFilterArgs::fixed(\n                Registry::default(),\n                Some(&Value::Mapping(map)),\n            ))\n            .unwrap();\n        assert_end_strategy(filter.as_ref(), TOKEN_KEY, true);\n"]], "pred": {"ppl": 3.5675208568573, "ppl_lower": 4.852766036987305, "ppl/lowercase_ppl": -1.2419097241251054, "ppl/zlib": 0.003962214693778177, "Min_5.0% Prob": 9.173051500320435, "Min_10.0% Prob": 7.722482476915632, "Min_20.0% Prob": 5.400275395030067, "Min_30.0% Prob": 3.95963516831398, "Min_40.0% Prob": 3.1191857523777906, "Min_50.0% Prob": 2.527915508251324, "Min_60.0% Prob": 2.124203612009296}}
{"hexsha": "046dd0113b44fa2be30ea213dbd7e7a01b05830f", "ext": "rs", "lang": "Rust", "content": "fn test_world_gen_default() {\n    let config = WorldConfig::default();\n    let world = World::generate(config).unwrap();\n    // Default config uses a random seed each time, so we want to log the\n    // config to make sure we can reproduce the failure\n    assert_eq!(\n        world.tiles().len(),\n        30301,\n        \"Default config failed: {:?}\",\n        config\n    );\n}", "item_id": 0, "repo": "LucasPickering/terra-rs", "file": "crates/core/tests/test_world_gen.rs", "last_update_at": "2021-07-10T13:42:36+00:00", "question_id": "046dd0113b44fa2be30ea213dbd7e7a01b05830f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_world_gen_default() {\n    let config = WorldConfig::default();\n    let world = World::generate(config).unwrap();\n    // Default config uses a random seed each time, so we want to log the\n    // config to make sure we can reproduce the failure\n    assert_eq!(\n        world.tiles().len(),\n        30301,\n        \"Default config failed: {:?}\",\n        config\n    );\n"]], "pred": {"ppl": 4.595024108886719, "ppl_lower": 5.279290199279785, "ppl/lowercase_ppl": -1.09102952177192, "ppl/zlib": 0.006931700011632828, "Min_5.0% Prob": 7.714208984375, "Min_10.0% Prob": 6.290420198440552, "Min_20.0% Prob": 4.975923764705658, "Min_30.0% Prob": 3.981508501114384, "Min_40.0% Prob": 3.365204171436589, "Min_50.0% Prob": 2.8538528279616284, "Min_60.0% Prob": 2.480462998151779}}
{"hexsha": "c359822c4208f26f9df6d2291b14c60a51e29691", "ext": "rs", "lang": "Rust", "content": "fn inet_ip() {\n        let mut p = ProviderInfo::new()\n            .name(\"inet-ip.info\")\n            .ptype(ProviderInfoType::IPv4)\n            .protocol(ProviderInfoProtocol::HttpPlane)\n            .url(\"http://inet-ip.info/ip\")\n            .create();\n        p.set_timeout(2000);\n        let addr = p.get_addr().unwrap();\n        assert!(addr.v4addr.is_some());\n        assert!(!addr.v4addr.unwrap().is_private());\n    }", "item_id": 0, "repo": "dalance/gip", "file": "src/lib.rs", "last_update_at": "2021-11-23T10:07:37+00:00", "question_id": "c359822c4208f26f9df6d2291b14c60a51e29691_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn inet_ip() {\n        let mut p = ProviderInfo::new()\n            .name(\"inet-ip.info\")\n            .ptype(ProviderInfoType::IPv4)\n            .protocol(ProviderInfoProtocol::HttpPlane)\n            .url(\"http://inet-ip.info/ip\")\n            .create();\n        p.set_timeout(2000);\n        let addr = p.get_addr().unwrap();\n        assert!(addr.v4addr.is_some());\n        assert!(!addr.v4addr.unwrap().is_private());\n"]], "pred": {"ppl": 4.032042026519775, "ppl_lower": 4.499828815460205, "ppl/lowercase_ppl": -1.0787266229137253, "ppl/zlib": 0.00636654316876136, "Min_5.0% Prob": 9.690322875976562, "Min_10.0% Prob": 7.541651799128606, "Min_20.0% Prob": 5.399714213830453, "Min_30.0% Prob": 4.127502191357497, "Min_40.0% Prob": 3.348763902982076, "Min_50.0% Prob": 2.742194279590074, "Min_60.0% Prob": 2.3048645663188725}}
{"hexsha": "551cc919ab7fddba8b8585d311fcc7c20c0777e7", "ext": "rs", "lang": "Rust", "content": "fn unpack_files(directory: &Path, replace_path: &str) {\n    use tar::{Builder, Header, Archive};\n\n    let mut builder = Builder::new(Vec::new());\n    for &(name, data) in FILES {\n        let data = data.replace(\"PATH\", replace_path);\n        let mut header = Header::new_gnu();\n        header.set_path(name).unwrap();\n        header.set_size(data.len() as u64);\n        header.set_cksum();\n        builder.append(&header, data.as_bytes()).unwrap();\n    }\n\n    let archive: &[u8] = &builder.into_inner().unwrap();\n    Archive::new(archive).unpack(directory)\n        .expect(\"Can't unpack test crate\");\n}", "item_id": 0, "repo": "krdln/fomat-macros", "file": "tests/capturing.rs", "last_update_at": "2021-12-11T06:20:52+00:00", "question_id": "551cc919ab7fddba8b8585d311fcc7c20c0777e7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn unpack_files(directory: &Path, replace_path: &str) {\n    use tar::{Builder, Header, Archive};\n    let mut builder = Builder::new(Vec::new());\n    for &(name, data) in FILES {\n        let data = data.replace(\"PATH\", replace_path);\n        let mut header = Header::new_gnu();\n        header.set_path(name).unwrap();\n        header.set_size(data.len() as u64);\n        header.set_cksum();\n        builder.append(&header, data.as_bytes()).unwrap();\n    }\n    let archive: &[u8] = &builder.into_inner().unwrap();\n    Archive::new(archive).unpack(directory)\n        .expect(\"Can't unpack test crate\");\n"]], "pred": {"ppl": 2.2028727531433105, "ppl_lower": 2.7227447032928467, "ppl/lowercase_ppl": -1.2682809077174546, "ppl/zlib": 0.0024835292623782727, "Min_5.0% Prob": 6.763644960191515, "Min_10.0% Prob": 5.181897866098504, "Min_20.0% Prob": 3.5043525664429915, "Min_30.0% Prob": 2.5248235587416024, "Min_40.0% Prob": 1.9558689019509725, "Min_50.0% Prob": 1.5703747608919734, "Min_60.0% Prob": 1.3185390283449971}}
{"hexsha": "0ce8a819ffd6928eda270bc23f40636abe313de7", "ext": "rs", "lang": "Rust", "content": "fn should_get_valid_state_with_endpoint_correctly() {\n        let expected_endpoint = WORKING_ENDPOINT;\n        let expected_tx_hash = get_valid_tx_hash_h256().unwrap();\n        let result = get_valid_state_with_endpoint().unwrap();\n        assert!(result.tx_hash == expected_tx_hash);\n        match State::get_endpoint_from_state(&result) {\n            Ok(endpoint) => assert!(endpoint == expected_endpoint),\n            _ => panic!(\"Intial w/ endpoint should have endpoint set!\"),\n        }\n        match State::get_block_from_state(&result) {\n            Err(AppError::Custom(e)) => assert!(e == get_not_in_state_err(\"block\")),\n            _ => panic!(\"Intial state should not have endpoint set!\"),\n        }\n    }", "item_id": 16, "repo": "gskapka/rusty-receipt-proof-maker", "file": "src/test_utils.rs", "last_update_at": "2021-11-11T06:09:13+00:00", "question_id": "0ce8a819ffd6928eda270bc23f40636abe313de7_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn should_get_valid_state_with_endpoint_correctly() {\n        let expected_endpoint = WORKING_ENDPOINT;\n        let expected_tx_hash = get_valid_tx_hash_h256().unwrap();\n        let result = get_valid_state_with_endpoint().unwrap();\n        assert!(result.tx_hash == expected_tx_hash);\n        match State::get_endpoint_from_state(&result) {\n            Ok(endpoint) => assert!(endpoint == expected_endpoint),\n            _ => panic!(\"Intial w/ endpoint should have endpoint set!\"),\n        }\n        match State::get_block_from_state(&result) {\n            Err(AppError::Custom(e)) => assert!(e == get_not_in_state_err(\"block\")),\n            _ => panic!(\"Intial state should not have endpoint set!\"),\n        }\n"]], "pred": {"ppl": 3.9028351306915283, "ppl_lower": 4.605647087097168, "ppl/lowercase_ppl": -1.1215976631625166, "ppl/zlib": 0.004600348802764255, "Min_5.0% Prob": 9.096050119400024, "Min_10.0% Prob": 7.368515173594157, "Min_20.0% Prob": 5.468921195893061, "Min_30.0% Prob": 4.2046704434213185, "Min_40.0% Prob": 3.307299453587759, "Min_50.0% Prob": 2.7028201416844415, "Min_60.0% Prob": 2.271343432366848}}
{"hexsha": "d09f675f991e64158fc6e8bfbe83af84a12bb44d", "ext": "rs", "lang": "Rust", "content": "fn counter_generate_workloads() {\n        let path = PathBuf::from_str(\"tests/data\").unwrap();\n        let counter = Counter::new(path.clone());\n\n        let result = counter.generate_workloads(1, 3);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), vec![3]);\n\n        let result = counter.generate_workloads(3, 3);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), vec![1, 1, 1]);\n\n        let result = counter.generate_workloads(2, 3);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), vec![2, 1]);\n    }", "item_id": 5, "repo": "Jonxslays/xloc", "file": "src/lib/counter.rs", "last_update_at": "2021-11-05T22:26:18+00:00", "question_id": "d09f675f991e64158fc6e8bfbe83af84a12bb44d_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn counter_generate_workloads() {\n        let path = PathBuf::from_str(\"tests/data\").unwrap();\n        let counter = Counter::new(path.clone());\n        let result = counter.generate_workloads(1, 3);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), vec![3]);\n        let result = counter.generate_workloads(3, 3);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), vec![1, 1, 1]);\n        let result = counter.generate_workloads(2, 3);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), vec![2, 1]);\n"]], "pred": {"ppl": 1.9549697637557983, "ppl_lower": 2.1361746788024902, "ppl/lowercase_ppl": -1.132227492198063, "ppl/zlib": 0.0034734441824257074, "Min_5.0% Prob": 6.260370996263292, "Min_10.0% Prob": 4.423876378271315, "Min_20.0% Prob": 2.8602342158555984, "Min_30.0% Prob": 2.1396323889493942, "Min_40.0% Prob": 1.656487261152102, "Min_50.0% Prob": 1.336676002914707, "Min_60.0% Prob": 1.1162660745300215}}
{"hexsha": "2c11d78663f532c49fe25cdcfe77a27a391aa51d", "ext": "rs", "lang": "Rust", "content": "fn test_next_simplest_language() {\n        let mut rng = thread_rng();\n        let raw = raw::Language {\n            entries: vec![\n                prod_symbols(\"A\", &[\"hello\", \"space\", \"world\"]),\n                prod_literals(\"hello\", &[\"hello\"]),\n                prod_literals(\"space\", &[\" \"]),\n                prod_literals(\"world\", &[\"world\"]),\n            ],\n        };\n        let language = Language::from_raw(&raw).unwrap();\n        let a = language.token_by_name(\"A\").unwrap();\n        let r = language.expand(&[a], &mut rng).unwrap();\n        assert_eq!(\"hello world\", r);\n    }", "item_id": 6, "repo": "mikeando/markovian", "file": "markovian-core/src/language/compiled.rs", "last_update_at": "2021-10-12T01:20:36+00:00", "question_id": "2c11d78663f532c49fe25cdcfe77a27a391aa51d_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_next_simplest_language() {\n        let mut rng = thread_rng();\n        let raw = raw::Language {\n            entries: vec![\n                prod_symbols(\"A\", &[\"hello\", \"space\", \"world\"]),\n                prod_literals(\"hello\", &[\"hello\"]),\n                prod_literals(\"space\", &[\" \"]),\n                prod_literals(\"world\", &[\"world\"]),\n            ],\n        };\n        let language = Language::from_raw(&raw).unwrap();\n        let a = language.token_by_name(\"A\").unwrap();\n        let r = language.expand(&[a], &mut rng).unwrap();\n        assert_eq!(\"hello world\", r);\n"]], "pred": {"ppl": 3.5860953330993652, "ppl_lower": 3.7545247077941895, "ppl/lowercase_ppl": -1.0359400493661197, "ppl/zlib": 0.00502781086469056, "Min_5.0% Prob": 9.72962749004364, "Min_10.0% Prob": 7.967354522031896, "Min_20.0% Prob": 5.287961006164551, "Min_30.0% Prob": 3.8974088745958664, "Min_40.0% Prob": 3.065437679343364, "Min_50.0% Prob": 2.51591415440335, "Min_60.0% Prob": 2.12616933443967}}
{"hexsha": "c42663ce2baad22a3e42592fea65be13c225c596", "ext": "rs", "lang": "Rust", "content": "fn page_param_parsing() {\n        let assert_error =\n            |query, msg| assert_pagination_error(PaginationOptions::builder(), query, msg);\n\n        assert_error(\"page=\", \"cannot parse integer from empty string\");\n        assert_error(\"page=not_a_number\", \"invalid digit found in string\");\n        assert_error(\"page=1.0\", \"invalid digit found in string\");\n        assert_error(\"page=0\", \"page indexing starts from 1, page 0 is invalid\");\n\n        let pagination = PaginationOptions::builder()\n            .gather(&mut mock(\"page=5\"))\n            .unwrap();\n        assert_eq!(Page::Numeric(5), pagination.page);\n    }", "item_id": 1, "repo": "Unbinilium/crates.io", "file": "src/controllers/helpers/pagination.rs", "last_update_at": "2021-07-24T13:12:17+00:00", "question_id": "c42663ce2baad22a3e42592fea65be13c225c596_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn page_param_parsing() {\n        let assert_error =\n            |query, msg| assert_pagination_error(PaginationOptions::builder(), query, msg);\n        assert_error(\"page=\", \"cannot parse integer from empty string\");\n        assert_error(\"page=not_a_number\", \"invalid digit found in string\");\n        assert_error(\"page=1.0\", \"invalid digit found in string\");\n        assert_error(\"page=0\", \"page indexing starts from 1, page 0 is invalid\");\n        let pagination = PaginationOptions::builder()\n            .gather(&mut mock(\"page=5\"))\n            .unwrap();\n        assert_eq!(Page::Numeric(5), pagination.page);\n"]], "pred": {"ppl": 3.4379396438598633, "ppl_lower": 3.9477434158325195, "ppl/lowercase_ppl": -1.111972526706586, "ppl/zlib": 0.004474175185544346, "Min_5.0% Prob": 8.822126686573029, "Min_10.0% Prob": 7.068380944869098, "Min_20.0% Prob": 5.089387304442269, "Min_30.0% Prob": 3.7822049080200917, "Min_40.0% Prob": 3.0170006534882954, "Min_50.0% Prob": 2.4530431872064415, "Min_60.0% Prob": 2.053576349228058}}
{"hexsha": "d7b5ce6bf507c784ac5ea5fdf736c7677069e7ec", "ext": "rs", "lang": "Rust", "content": "fn check() {\n        let mut pool: SyncPool<[u8; 32]> = SyncPool::with_size(12);\n\n        for _ in 0..32 {\n            let ary = pool.get();\n            assert_eq!(ary.len(), 32);\n            pool.put(ary);\n        }\n\n        assert!(pool.len() > 0);\n    }", "item_id": 0, "repo": "Chopinsky/byte_buffer", "file": "syncpool/src/lib.rs", "last_update_at": "2021-09-01T09:31:25+00:00", "question_id": "d7b5ce6bf507c784ac5ea5fdf736c7677069e7ec_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn check() {\n        let mut pool: SyncPool<[u8; 32]> = SyncPool::with_size(12);\n        for _ in 0..32 {\n            let ary = pool.get();\n            assert_eq!(ary.len(), 32);\n            pool.put(ary);\n        }\n        assert!(pool.len() > 0);\n"]], "pred": {"ppl": 2.8142924308776855, "ppl_lower": 3.304520845413208, "ppl/lowercase_ppl": -1.155193701884377, "ppl/zlib": 0.006426775610509725, "Min_5.0% Prob": 6.954768419265747, "Min_10.0% Prob": 5.430359813902113, "Min_20.0% Prob": 3.9445178006824695, "Min_30.0% Prob": 3.05499424605534, "Min_40.0% Prob": 2.4525046241589084, "Min_50.0% Prob": 2.0232790988318774, "Min_60.0% Prob": 1.7324473291378597}}
{"hexsha": "0ad7f8a2323bb4a25eb0e8fbfaffa23a29e7588b", "ext": "rs", "lang": "Rust", "content": "fn rrule_and_exrule() {\n    let mut set = RRuleSet::default();\n\n    let properties1 = RRuleProperties {\n        freq: Frequency::Yearly,\n        count: Some(6),\n        dt_start: UTC.ymd(1997, 9, 2).and_hms(9, 0, 0),\n        by_weekday: vec![NWeekday::Every(Weekday::Tue), NWeekday::Every(Weekday::Thu)],\n        by_hour: vec![9],\n        by_minute: vec![0],\n        by_second: vec![0],\n        ..Default::default()\n    };\n    let rrule = RRule::new(properties1).unwrap();\n    set.rrule(rrule);\n    let properties2 = RRuleProperties {\n        freq: Frequency::Yearly,\n        count: Some(3),\n        dt_start: UTC.ymd(1997, 9, 2).and_hms(9, 0, 0),\n        by_weekday: vec![NWeekday::Every(Weekday::Thu)],\n        by_hour: vec![9],\n        by_minute: vec![0],\n        by_second: vec![0],\n        ..Default::default()\n    };\n    let exrule = RRule::new(properties2).unwrap();\n    set.exrule(exrule);\n\n    test_recurring_rrule_set(\n        set,\n        &[\n            ymd_hms(1997, 9, 2, 9, 0, 0),\n            ymd_hms(1997, 9, 9, 9, 0, 0),\n            ymd_hms(1997, 9, 16, 9, 0, 0),\n        ],\n    );\n}", "item_id": 0, "repo": "fmeringdal/rust_rrule", "file": "rrule/tests/rrule_set.rs", "last_update_at": "2021-09-16T22:00:57+00:00", "question_id": "0ad7f8a2323bb4a25eb0e8fbfaffa23a29e7588b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn rrule_and_exrule() {\n    let mut set = RRuleSet::default();\n    let properties1 = RRuleProperties {\n        freq: Frequency::Yearly,\n        count: Some(6),\n        dt_start: UTC.ymd(1997, 9, 2).and_hms(9, 0, 0),\n        by_weekday: vec![NWeekday::Every(Weekday::Tue), NWeekday::Every(Weekday::Thu)],\n        by_hour: vec![9],\n        by_minute: vec![0],\n        by_second: vec![0],\n        ..Default::default()\n    };\n    let rrule = RRule::new(properties1).unwrap();\n    set.rrule(rrule);\n    let properties2 = RRuleProperties {\n        freq: Frequency::Yearly,\n        count: Some(3),\n        dt_start: UTC.ymd(1997, 9, 2).and_hms(9, 0, 0),\n        by_weekday: vec![NWeekday::Every(Weekday::Thu)],\n        by_hour: vec![9],\n        by_minute: vec![0],\n        by_second: vec![0],\n        ..Default::default()\n    };\n    let exrule = RRule::new(properties2).unwrap();\n    set.exrule(exrule);\n    test_recurring_rrule_set(\n        set,\n        &[\n            ymd_hms(1997, 9, 2, 9, 0, 0),\n            ymd_hms(1997, 9, 9, 9, 0, 0),\n            ymd_hms(1997, 9, 16, 9, 0, 0),\n        ],\n    );\n"]], "pred": {"ppl": 1.4029721021652222, "ppl_lower": 1.6195228099822998, "ppl/lowercase_ppl": -1.4239268472789293, "ppl/zlib": 0.0009701802765250616, "Min_5.0% Prob": 4.536326202479276, "Min_10.0% Prob": 2.9405859735276962, "Min_20.0% Prob": 1.655735483781977, "Min_30.0% Prob": 1.1277051950147485, "Min_40.0% Prob": 0.8467872102519722, "Min_50.0% Prob": 0.6768709698542871, "Min_60.0% Prob": 0.5654870505069873}}
{"hexsha": "bca57f521e6c4f57941ddb223bcba60dfbb799e0", "ext": "rs", "lang": "Rust", "content": "async fn test_get_by_id(db: &Db) {\n        assert_eq!(db.get_by_id(1).await.unwrap().text, \"one\".to_string());\n        assert_eq!(db.get_by_id(2).await.unwrap().text, \"two\".to_string());\n        assert_eq!(db.get_by_id(3).await.unwrap().text, \"three\".to_string());\n    }", "item_id": 0, "repo": "wa7sa34cx/udp-server-cli", "file": "src/db.rs", "last_update_at": "2021-12-06T10:55:01+00:00", "question_id": "bca57f521e6c4f57941ddb223bcba60dfbb799e0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn test_get_by_id(db: &Db) {\n        assert_eq!(db.get_by_id(1).await.unwrap().text, \"one\".to_string());\n        assert_eq!(db.get_by_id(2).await.unwrap().text, \"two\".to_string());\n        assert_eq!(db.get_by_id(3).await.unwrap().text, \"three\".to_string());\n"]], "pred": {"ppl": 1.9523063898086548, "ppl_lower": 2.0587356090545654, "ppl/lowercase_ppl": -1.0793418044798408, "ppl/zlib": 0.0053952535295628615, "Min_5.0% Prob": 7.024722576141357, "Min_10.0% Prob": 5.184947419166565, "Min_20.0% Prob": 3.1514848612603688, "Min_30.0% Prob": 2.2312066766523544, "Min_40.0% Prob": 1.6788934944641023, "Min_50.0% Prob": 1.3365476769307312, "Min_60.0% Prob": 1.1251979551485016}}
{"hexsha": "74fcd7fafc603ce8fb8012fc53f0eee8d41b3d80", "ext": "rs", "lang": "Rust", "content": "fn best_asteroids_example_three() {\n        let input = \"\\\n#.#...#.#.\n.###....#.\n.#....#...\n##.#.#.#.#\n....#.#.#.\n.##..###.#\n..#...##..\n..##....##\n......#...\n.####.###.\";\n\n        let map = Map::parse_map(input);\n        assert_eq!(map.find_best_asteroid(), Some((Point(1, 2), 35)))\n    }", "item_id": 2, "repo": "tillrohrmann/rust-challenges", "file": "aoc_2019_10/src/lib.rs", "last_update_at": "2021-12-27T12:36:24+00:00", "question_id": "74fcd7fafc603ce8fb8012fc53f0eee8d41b3d80_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn best_asteroids_example_three() {\n        let input = \"\\\n#.#...#.#.\n.###....#.\n.#....#...\n##.#.#.#.#\n....#.#.#.\n.##..###.#\n..#...##..\n..##....##\n......#...\n.####.###.\";\n        let map = Map::parse_map(input);\n        assert_eq!(map.find_best_asteroid(), Some((Point(1, 2), 35)))\n"]], "pred": {"ppl": 2.4613163471221924, "ppl_lower": 2.6423332691192627, "ppl/lowercase_ppl": -1.0787901904622237, "ppl/zlib": 0.005003868373806944, "Min_5.0% Prob": 8.070914427439371, "Min_10.0% Prob": 5.778470644584069, "Min_20.0% Prob": 3.8843699958589344, "Min_30.0% Prob": 2.9123903684318067, "Min_40.0% Prob": 2.2219129938770226, "Min_50.0% Prob": 1.8076357068632967, "Min_60.0% Prob": 1.4991463747013498}}
{"hexsha": "49278ae5fa082a0b1a4df4b0ae9866d15f63d8eb", "ext": "rs", "lang": "Rust", "content": "fn output(path: &str) {\n    let input = fs::read_to_string(&path).unwrap();\n\n    let (part_1, part_2) = solve(&input);\n\n    println!(\"File: {}\", path);\n    println!(\"  Part 1: {}\", part_1);\n    println!(\"  Part 2: {}\", part_2);\n}", "item_id": 5, "repo": "mohamed-abdelnour/AdventOfCode", "file": "2020/21/Rust/src/main.rs", "last_update_at": "2021-11-30T22:05:14+00:00", "question_id": "49278ae5fa082a0b1a4df4b0ae9866d15f63d8eb_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn output(path: &str) {\n    let input = fs::read_to_string(&path).unwrap();\n    let (part_1, part_2) = solve(&input);\n    println!(\"File: {}\", path);\n    println!(\"  Part 1: {}\", part_1);\n    println!(\"  Part 2: {}\", part_2);\n"]], "pred": {"ppl": 1.8883583545684814, "ppl_lower": 1.984212875366211, "ppl/lowercase_ppl": -1.0778886756255621, "ppl/zlib": 0.004384192111431137, "Min_5.0% Prob": 6.753076791763306, "Min_10.0% Prob": 5.140283286571503, "Min_20.0% Prob": 3.00418154632344, "Min_30.0% Prob": 2.0810959671552363, "Min_40.0% Prob": 1.6186127595822601, "Min_50.0% Prob": 1.2852791829013028, "Min_60.0% Prob": 1.0633928622477329}}
{"hexsha": "9651cd5dfbaf8dca11f6c123dfa4ce82d53b80bf", "ext": "rs", "lang": "Rust", "content": "fn get_combination(numbers: &Vec<u32>, length: usize) -> u32 {\n    for combination in numbers.iter().combinations(length) {\n        if combination.iter().map(|number| *number).sum::<u32>() == 2020 {\n            return combination.iter().fold(1, |acc, &number| acc * (*number));\n        }\n    };\n    panic!(\"Numbers not found\");\n}", "item_id": 0, "repo": "Bigsby/aoc", "file": "2020/01/rs/src/main.rs", "last_update_at": "2021-06-11T17:24:05+00:00", "question_id": "9651cd5dfbaf8dca11f6c123dfa4ce82d53b80bf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_combination(numbers: &Vec<u32>, length: usize) -> u32 {\n    for combination in numbers.iter().combinations(length) {\n        if combination.iter().map(|number| *number).sum::<u32>() == 2020 {\n            return combination.iter().fold(1, |acc, &number| acc * (*number));\n        }\n    };\n    panic!(\"Numbers not found\");\n"]], "pred": {"ppl": 2.575594902038574, "ppl_lower": 2.8099937438964844, "ppl/lowercase_ppl": -1.0920658613964043, "ppl/zlib": 0.004901971696115495, "Min_5.0% Prob": 7.1968893051147464, "Min_10.0% Prob": 5.900169610977173, "Min_20.0% Prob": 4.169542738369533, "Min_30.0% Prob": 3.0307827312499285, "Min_40.0% Prob": 2.3427279750968135, "Min_50.0% Prob": 1.8918246472323383, "Min_60.0% Prob": 1.5817693118292553}}
{"hexsha": "762aa01f3ef3d031f4c0a13efa036e7f3a6d910b", "ext": "rs", "lang": "Rust", "content": "pub fn view_headers(tab: &Tab, col_span: usize) -> Vec<Node<Msg>> {\n    let tuple_toggle = th![\n        el_key(&format!(\"tuple-toggle\")),\n        attrs![At::Scope => \"row\"],\n        style![St::TextAlign => \"center\", St::VerticalAlign => \"middle\"],\n        \"(1 2 3)\"\n    ];\n    let select_all = th![\n        el_key(&format!(\"select-all-rows\")),\n        attrs![At::Scope => \"row\"],\n        style![St::TextAlign => \"center\", St::VerticalAlign => \"middle\"],\n        \"[ ]\"\n    ];\n    let add_column = td![\n        el_key(&format!(\"add-column\")),\n        attrs![At::Scope => \"row\", At::RowSpan => 2],\n        style![St::TextAlign => \"center\", St::VerticalAlign => \"middle\"],\n        \"+\"\n    ];\n    let empty = th![\n        el_key(&format!(\"empty\")),\n        attrs![At::Scope => \"column\", At::ColSpan => col_span.to_string() ],\n        \"\u2800\"\n    ];\n\n    if tab.columns().len() == 0 {\n        return vec![\n            tr![tuple_toggle.clone(), empty.clone(), add_column.clone(),],\n            tr![select_all.clone(), empty],\n        ];\n    }\n\n    vec![\n        tr![\n            el_key(&format!(\"column-names\")),\n            tuple_toggle,\n            tab.columns().iter().enumerate().map(|(index, column_id)| {\n                th![\n                    el_key(&format!(\"column-name-{}\", column_id)),\n                    attrs![At::Scope => \"column\"],\n                    match tab.headers().get(column_id) {\n                        Some(header) => match header.name() {\n                            Some(name) => name.to_owned(),\n                            None => nameless(index),\n                        },\n                        None => \"ERROR\".to_owned(),\n                    }\n                ]\n            }),\n            add_column,\n        ],\n        tr![\n            el_key(&format!(\"column-data-types\")),\n            select_all,\n            tab.columns().iter().map(|column_id| {\n                th![\n                    el_key(&format!(\"column-data-type-{}\", column_id)),\n                    attrs![At::Scope => \"column\"],\n                    match tab.headers().get(column_id) {\n                        Some(header) => header.data_type().to_html(),\n                        None => DataType::Text.to_html(),\n                    }\n                ]\n            }),\n        ],\n    ]\n}", "item_id": 4, "repo": "tableflow/tableflow", "file": "src/pages/home.rs", "last_update_at": "2021-01-31T22:17:21+00:00", "question_id": "762aa01f3ef3d031f4c0a13efa036e7f3a6d910b_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn view_headers(tab: &Tab, col_span: usize) -> Vec<Node<Msg>> {\n    let tuple_toggle = th![\n        el_key(&format!(\"tuple-toggle\")),\n        attrs![At::Scope => \"row\"],\n        style![St::TextAlign => \"center\", St::VerticalAlign => \"middle\"],\n        \"(1 2 3)\"\n    ];\n    let select_all = th![\n        el_key(&format!(\"select-all-rows\")),\n        attrs![At::Scope => \"row\"],\n        style![St::TextAlign => \"center\", St::VerticalAlign => \"middle\"],\n        \"[ ]\"\n    ];\n    let add_column = td![\n        el_key(&format!(\"add-column\")),\n        attrs![At::Scope => \"row\", At::RowSpan => 2],\n        style![St::TextAlign => \"center\", St::VerticalAlign => \"middle\"],\n        \"+\"\n    ];\n    let empty = th![\n        el_key(&format!(\"empty\")),\n        attrs![At::Scope => \"column\", At::ColSpan => col_span.to_string() ],\n        \"\u2800\"\n    ];\n    if tab.columns().len() == 0 {\n        return vec![\n            tr![tuple_toggle.clone(), empty.clone(), add_column.clone(),],\n            tr![select_all.clone(), empty],\n        ];\n    }\n    vec![\n        tr![\n            el_key(&format!(\"column-names\")),\n            tuple_toggle,\n            tab.columns().iter().enumerate().map(|(index, column_id)| {\n                th![\n                    el_key(&format!(\"column-name-{}\", column_id)),\n                    attrs![At::Scope => \"column\"],\n                    match tab.headers().get(column_id) {\n                        Some(header) => match header.name() {\n                            Some(name) => name.to_owned(),\n                            None => nameless(index),\n                        },\n                        None => \"ERROR\".to_owned(),\n                    }\n                ]\n            }),\n            add_column,\n        ],\n        tr![\n            el_key(&format!(\"column-data-types\")),\n            select_all,\n            tab.columns().iter().map(|column_id| {\n                th![\n                    el_key(&format!(\"column-data-type-{}\", column_id)),\n                    attrs![At::Scope => \"column\"],\n                    match tab.headers().get(column_id) {\n                        Some(header) => header.data_type().to_html(),\n                        None => DataType::Text.to_html(),\n                    }\n                ]\n            }),\n        ],\n    ]\n"]], "pred": {"ppl": 1.9679070711135864, "ppl_lower": 2.124758243560791, "ppl/lowercase_ppl": -1.11328033028102, "ppl/zlib": 0.001090129754512972, "Min_5.0% Prob": 7.006447225809097, "Min_10.0% Prob": 5.042795162934524, "Min_20.0% Prob": 3.118136864582091, "Min_30.0% Prob": 2.1960219353588704, "Min_40.0% Prob": 1.6793607105377055, "Min_50.0% Prob": 1.3502500276548342, "Min_60.0% Prob": 1.1294029465897792}}
{"hexsha": "c23cb8d2c2cb35a845ab5abacffa70c1c9f7ca1d", "ext": "rs", "lang": "Rust", "content": "fn pack_unpack_valid() {\n    let message = MessageBuilder::<Miner>::new()\n        .with_network_id(0)\n        .with_parents(rand_parents())\n        .finish()\n        .unwrap();\n    let packed_message = message.pack_new();\n\n    assert_eq!(packed_message.len(), message.packed_len());\n    assert_eq!(message, Packable::unpack(&mut packed_message.as_slice()).unwrap());\n}", "item_id": 2, "repo": "TeeVeeEss/bee", "file": "bee-message/tests/message.rs", "last_update_at": "2021-01-29T12:02:57+00:00", "question_id": "c23cb8d2c2cb35a845ab5abacffa70c1c9f7ca1d_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn pack_unpack_valid() {\n    let message = MessageBuilder::<Miner>::new()\n        .with_network_id(0)\n        .with_parents(rand_parents())\n        .finish()\n        .unwrap();\n    let packed_message = message.pack_new();\n    assert_eq!(packed_message.len(), message.packed_len());\n    assert_eq!(message, Packable::unpack(&mut packed_message.as_slice()).unwrap());\n"]], "pred": {"ppl": 2.9063901901245117, "ppl_lower": 3.9215753078460693, "ppl/lowercase_ppl": -1.2807932231950885, "ppl/zlib": 0.0053613659630770754, "Min_5.0% Prob": 7.919680277506511, "Min_10.0% Prob": 6.415229280789693, "Min_20.0% Prob": 4.3609774361054106, "Min_30.0% Prob": 3.2941189027494855, "Min_40.0% Prob": 2.603763329486052, "Min_50.0% Prob": 2.123874177535375, "Min_60.0% Prob": 1.7853864799253643}}
{"hexsha": "a7a5442331ae2d8bbe663446be1feef4bf49b590", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn recipe_count_until_this_score_appears<T: AsRef<str>>(score: T) -> usize {\n    let digits = score\n        .as_ref()\n        .chars()\n        .filter(|c| c.is_numeric())\n        .map(|c| c.to_digit(10).unwrap() as usize)\n        .collect::<Vec<usize>>();\n    let mut list = vec![3, 7];\n    let mut first = 0;\n    let mut second = 1;\n\n    let mut matched_digits = 0;\n    loop {\n        let sum = list[first] + list[second];\n        if sum < 10 {\n            list.push(sum);\n        } else {\n            list.push(sum / 10);\n            if sum / 10 == digits[matched_digits] {\n                matched_digits += 1;\n                // Stop if we reached the goal with only the first of 2 new digits\n                if matched_digits == digits.len() {\n                    break;\n                }\n            } else if matched_digits > 0 {\n                matched_digits = 0;\n            }\n            list.push(sum % 10);\n        }\n        // This also works for the sum < 10 part\n        if sum % 10 == digits[matched_digits] {\n            matched_digits += 1;\n        } else if matched_digits > 0 {\n            matched_digits = 0;\n            // The following is when only the second of 2 new digits matches\n            if sum % 10 == digits[matched_digits] {\n                matched_digits += 1;\n            } else {\n                matched_digits = 0;\n            }\n        }\n        if matched_digits == digits.len() {\n            break;\n        }\n        first = (first + 1 + list[first]) % list.len();\n        second = (second + 1 + list[second]) % list.len();\n    }\n    list.len() - digits.len()\n}", "item_id": 1, "repo": "shrugalic/advent_of_code", "file": "2018/src/day14.rs", "last_update_at": "2021-12-17T18:26:17+00:00", "question_id": "a7a5442331ae2d8bbe663446be1feef4bf49b590_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn recipe_count_until_this_score_appears<T: AsRef<str>>(score: T) -> usize {\n    let digits = score\n        .as_ref()\n        .chars()\n        .filter(|c| c.is_numeric())\n        .map(|c| c.to_digit(10).unwrap() as usize)\n        .collect::<Vec<usize>>();\n    let mut list = vec![3, 7];\n    let mut first = 0;\n    let mut second = 1;\n    let mut matched_digits = 0;\n    loop {\n        let sum = list[first] + list[second];\n        if sum < 10 {\n            list.push(sum);\n        } else {\n            list.push(sum / 10);\n            if sum / 10 == digits[matched_digits] {\n                matched_digits += 1;\n                // Stop if we reached the goal with only the first of 2 new digits\n                if matched_digits == digits.len() {\n                    break;\n                }\n            } else if matched_digits > 0 {\n                matched_digits = 0;\n            }\n            list.push(sum % 10);\n        }\n        // This also works for the sum < 10 part\n        if sum % 10 == digits[matched_digits] {\n            matched_digits += 1;\n        } else if matched_digits > 0 {\n            matched_digits = 0;\n            // The following is when only the second of 2 new digits matches\n            if sum % 10 == digits[matched_digits] {\n                matched_digits += 1;\n            } else {\n                matched_digits = 0;\n            }\n        }\n        if matched_digits == digits.len() {\n            break;\n        }\n        first = (first + 1 + list[first]) % list.len();\n        second = (second + 1 + list[second]) % list.len();\n    }\n    list.len() - digits.len()\n"]], "pred": {"ppl": 2.0321497917175293, "ppl_lower": 2.137701988220215, "ppl/lowercase_ppl": -1.0714110597470294, "ppl/zlib": 0.0013455298736161998, "Min_5.0% Prob": 6.918599796295166, "Min_10.0% Prob": 5.068882301741955, "Min_20.0% Prob": 3.2056733574353014, "Min_30.0% Prob": 2.300154363213022, "Min_40.0% Prob": 1.7614486321587772, "Min_50.0% Prob": 1.415657531776849, "Min_60.0% Prob": 1.1813292832500333}}
{"hexsha": "876d93c097493fe92d439172028103d6eb585a4d", "ext": "rs", "lang": "Rust", "content": "pub fn is_multiple_of(a: &Float, b: &Float) -> bool {\n    if a.is_infinite() || b.is_infinite() { return false; }\n    let c = Float::with_val(a.prec(),a).remainder(b);\n    if c == 0 {\n        let d = Float::with_val(a.prec(), a/b);\n        return d.is_integer();\n    }\n    return false;\n}", "item_id": 0, "repo": "cilvento/b2dp", "file": "b2dp/src/utilities/discretesampling.rs", "last_update_at": "2021-05-27T07:26:01+00:00", "question_id": "876d93c097493fe92d439172028103d6eb585a4d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn is_multiple_of(a: &Float, b: &Float) -> bool {\n    if a.is_infinite() || b.is_infinite() { return false; }\n    let c = Float::with_val(a.prec(),a).remainder(b);\n    if c == 0 {\n        let d = Float::with_val(a.prec(), a/b);\n        return d.is_integer();\n    }\n    return false;\n"]], "pred": {"ppl": 2.9596569538116455, "ppl_lower": 3.1888492107391357, "ppl/lowercase_ppl": -1.0687388865250784, "ppl/zlib": 0.006420552471225978, "Min_5.0% Prob": 7.810472583770752, "Min_10.0% Prob": 6.019918138330633, "Min_20.0% Prob": 4.35676628893072, "Min_30.0% Prob": 3.3756895209803726, "Min_40.0% Prob": 2.605783818827735, "Min_50.0% Prob": 2.145135736359017, "Min_60.0% Prob": 1.814866808368199}}
{"hexsha": "7f4f6473047865375c547654cd910ddac3edf87b", "ext": "rs", "lang": "Rust", "content": "fn get_test_data_dir() -> String {\n\n        let path_to_current_dir = file_system::get_current_dir()\n            .ok()\n            .expect(\"Failed read current directory.\");\n        let path = Path::new(&path_to_current_dir)\n                                    .parent().unwrap() // libs\n                                    .parent().unwrap() // conf_robber\n                                    .join(\"test_data\");\n\n        return file_system::path_to_str(path.as_path());\n    }", "item_id": 3, "repo": "khevse/conf_robber_rust", "file": "libs/information_base_v8/src/lib.rs", "last_update_at": "2021-03-27T15:13:30+00:00", "question_id": "7f4f6473047865375c547654cd910ddac3edf87b_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_test_data_dir() -> String {\n        let path_to_current_dir = file_system::get_current_dir()\n            .ok()\n            .expect(\"Failed read current directory.\");\n        let path = Path::new(&path_to_current_dir)\n                                    .parent().unwrap() // libs\n                                    .parent().unwrap() // conf_robber\n                                    .join(\"test_data\");\n        return file_system::path_to_str(path.as_path());\n"]], "pred": {"ppl": 3.8956470489501953, "ppl_lower": 4.514394760131836, "ppl/lowercase_ppl": -1.1084018659332229, "ppl/zlib": 0.006444833120811422, "Min_5.0% Prob": 8.73186961809794, "Min_10.0% Prob": 6.813177903493245, "Min_20.0% Prob": 4.949354209899902, "Min_30.0% Prob": 3.9600035499882056, "Min_40.0% Prob": 3.2464397346973417, "Min_50.0% Prob": 2.67554999580459, "Min_60.0% Prob": 2.273647897640864}}
{"hexsha": "9d9eaca1de084d626b979fb0d78977e95bb2968d", "ext": "rs", "lang": "Rust", "content": "fn get_first_child_name_ns(node: &libxml::tree::Node, name: &str, ns: &str) -> Option<libxml::tree::Node> {\n    let mut found_node = None;\n    for child in node.get_child_elements() {\n        if let Some(child_ns) = child.get_namespace() {\n            if child_ns.get_href() != ns {\n                continue;\n            }\n        } else {\n            continue;\n        }\n\n        if child.get_name() == name {\n            found_node = Some(child.clone());\n            break;\n        }\n    }\n    found_node\n}", "item_id": 5, "repo": "nick96/sidre", "file": "samael/src/crypto.rs", "last_update_at": "2021-05-03T22:52:26+00:00", "question_id": "9d9eaca1de084d626b979fb0d78977e95bb2968d_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_first_child_name_ns(node: &libxml::tree::Node, name: &str, ns: &str) -> Option<libxml::tree::Node> {\n    let mut found_node = None;\n    for child in node.get_child_elements() {\n        if let Some(child_ns) = child.get_namespace() {\n            if child_ns.get_href() != ns {\n                continue;\n            }\n        } else {\n            continue;\n        }\n        if child.get_name() == name {\n            found_node = Some(child.clone());\n            break;\n        }\n    }\n    found_node\n"]], "pred": {"ppl": 1.926412582397461, "ppl_lower": 2.2507379055023193, "ppl/lowercase_ppl": -1.2373161846342755, "ppl/zlib": 0.002743345220381498, "Min_5.0% Prob": 6.160208327429635, "Min_10.0% Prob": 4.485038630167643, "Min_20.0% Prob": 2.9082695687970808, "Min_30.0% Prob": 2.1011558980383773, "Min_40.0% Prob": 1.6210394868301967, "Min_50.0% Prob": 1.3100385845556288, "Min_60.0% Prob": 1.0947001255264408}}
{"hexsha": "68b79f81bf936e0d4cf9d1c85e1d5feadc5e37c8", "ext": "rs", "lang": "Rust", "content": "fn one_time_password_build_request() {\n        let base_url = Url::parse(\"https://YOUR_DOMAIN\").unwrap();\n        let authentication = AuthenicationMethod::OAuth2Token(String::from(\"some_awesome_token\"));\n        let mfa = Api::init(base_url, authentication);\n        let parameters = mfa::one_time_password::RequestParameters {\n            grant_type: String::from(\"some_awesome_grant_type\"),\n            client_id: String::from(\"some_awesome_client_id\"),\n            client_secret: None,\n            mfa_token: String::from(\"some_awesome_mfa_token\"),\n            otp: String::from(\"some_awesome_otp\"),\n        };\n        let request = mfa.verify_with_otp(parameters).build().unwrap();\n        let test_url = String::from(\"https://your_domain/oauth/token\");\n        let test_body = String::from(\n            \"grant_type=some_awesome_grant_type&\\\n            client_id=some_awesome_client_id&\\\n            mfa_token=some_awesome_mfa_token&\\\n            otp=some_awesome_otp\",\n        );\n        assert_eq!(request.method().as_str(), reqwest::Method::POST);\n        assert_eq!(request.url().as_str(), test_url);\n        assert_eq!(request.headers().len(), 1);\n        assert_eq!(\n            request.body().unwrap().as_bytes().unwrap(),\n            test_body.as_bytes(),\n        );\n    }", "item_id": 1, "repo": "davisvansant/auth0", "file": "src/authentication/mfa.rs", "last_update_at": "2021-06-16T18:21:38+00:00", "question_id": "68b79f81bf936e0d4cf9d1c85e1d5feadc5e37c8_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn one_time_password_build_request() {\n        let base_url = Url::parse(\"https://YOUR_DOMAIN\").unwrap();\n        let authentication = AuthenicationMethod::OAuth2Token(String::from(\"some_awesome_token\"));\n        let mfa = Api::init(base_url, authentication);\n        let parameters = mfa::one_time_password::RequestParameters {\n            grant_type: String::from(\"some_awesome_grant_type\"),\n            client_id: String::from(\"some_awesome_client_id\"),\n            client_secret: None,\n            mfa_token: String::from(\"some_awesome_mfa_token\"),\n            otp: String::from(\"some_awesome_otp\"),\n        };\n        let request = mfa.verify_with_otp(parameters).build().unwrap();\n        let test_url = String::from(\"https://your_domain/oauth/token\");\n        let test_body = String::from(\n            \"grant_type=some_awesome_grant_type&\\\n            client_id=some_awesome_client_id&\\\n            mfa_token=some_awesome_mfa_token&\\\n            otp=some_awesome_otp\",\n        );\n        assert_eq!(request.method().as_str(), reqwest::Method::POST);\n        assert_eq!(request.url().as_str(), test_url);\n        assert_eq!(request.headers().len(), 1);\n        assert_eq!(\n            request.body().unwrap().as_bytes().unwrap(),\n            test_body.as_bytes(),\n        );\n"]], "pred": {"ppl": 1.8815205097198486, "ppl_lower": 2.329540967941284, "ppl/lowercase_ppl": -1.3379175558144112, "ppl/zlib": 0.001407751072873061, "Min_5.0% Prob": 6.516547579514353, "Min_10.0% Prob": 4.720233917236328, "Min_20.0% Prob": 2.951798874598283, "Min_30.0% Prob": 2.058475406251402, "Min_40.0% Prob": 1.5706036886773431, "Min_50.0% Prob": 1.2641951801398625, "Min_60.0% Prob": 1.0553170901834645}}
{"hexsha": "f8f03feb0bd0074061944d3854948d0c07e30df0", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn create(agent: &Agent) -> HashMap<String, Value> {\n    let mut module = HashMap::new();\n    module.insert(\n        \"createTimeout\".to_string(),\n        Value::new_builtin_function(agent, create_timeout, false),\n    );\n    module.insert(\n        \"createInterval\".to_string(),\n        Value::new_builtin_function(agent, create_interval, false),\n    );\n\n    module\n}", "item_id": 3, "repo": "devsnek/slither", "file": "src/builtins/timers.rs", "last_update_at": "2021-08-10T22:51:07+00:00", "question_id": "f8f03feb0bd0074061944d3854948d0c07e30df0_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn create(agent: &Agent) -> HashMap<String, Value> {\n    let mut module = HashMap::new();\n    module.insert(\n        \"createTimeout\".to_string(),\n        Value::new_builtin_function(agent, create_timeout, false),\n    );\n    module.insert(\n        \"createInterval\".to_string(),\n        Value::new_builtin_function(agent, create_interval, false),\n    );\n    module\n"]], "pred": {"ppl": 2.2551217079162598, "ppl_lower": 2.83829927444458, "ppl/lowercase_ppl": -1.282833209929589, "ppl/zlib": 0.004348684192334696, "Min_5.0% Prob": 8.675672721862792, "Min_10.0% Prob": 6.14725847677751, "Min_20.0% Prob": 3.7337794574824246, "Min_30.0% Prob": 2.654103288144776, "Min_40.0% Prob": 2.0221532973978253, "Min_50.0% Prob": 1.6388286456598766, "Min_60.0% Prob": 1.3712902515049357}}
{"hexsha": "f248a70c67031bad228df7a3994e529f4513a8c0", "ext": "rs", "lang": "Rust", "content": "fn playback_to_plughw_mmap() {\n    use crate::pcm::*;\n    use crate::{ValueOr, Direction};\n    use std::ffi::CString;\n\n    let pcm = PCM::open(&*CString::new(\"plughw:1\").unwrap(), Direction::Playback, false).unwrap();\n    let hwp = HwParams::any(&pcm).unwrap();\n    hwp.set_channels(2).unwrap();\n    hwp.set_rate(44100, ValueOr::Nearest).unwrap();\n    hwp.set_format(Format::s16()).unwrap();\n    hwp.set_access(Access::MMapInterleaved).unwrap();\n    pcm.hw_params(&hwp).unwrap();\n    let mut m = pcm.direct_mmap_playback::<i16>().unwrap();\n\n    assert_eq!(m.status().state(), State::Prepared);\n    assert_eq!(m.appl_ptr(), 0);\n    assert_eq!(m.hw_ptr(), 0);\n\n    println!(\"{:?}\", m);\n    let mut i = (0..(m.buffer_size() * 2)).map(|i|\n        (((i / 2) as f32 * 2.0 * ::std::f32::consts::PI / 128.0).sin() * 8192.0) as i16);\n    m.write(&mut i);\n    assert_eq!(m.appl_ptr(), m.buffer_size());\n\n    pcm.start().unwrap();\n    pcm.drain().unwrap();\n    assert_eq!(m.appl_ptr(), m.buffer_size());\n    assert!(m.hw_ptr() >= m.buffer_size());\n}", "item_id": 3, "repo": "ritikmishra/babycat", "file": "vendor/alsa-0.5.0/src/direct/pcm.rs", "last_update_at": "2021-07-11T09:06:13+00:00", "question_id": "f248a70c67031bad228df7a3994e529f4513a8c0_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn playback_to_plughw_mmap() {\n    use crate::pcm::*;\n    use crate::{ValueOr, Direction};\n    use std::ffi::CString;\n    let pcm = PCM::open(&*CString::new(\"plughw:1\").unwrap(), Direction::Playback, false).unwrap();\n    let hwp = HwParams::any(&pcm).unwrap();\n    hwp.set_channels(2).unwrap();\n    hwp.set_rate(44100, ValueOr::Nearest).unwrap();\n    hwp.set_format(Format::s16()).unwrap();\n    hwp.set_access(Access::MMapInterleaved).unwrap();\n    pcm.hw_params(&hwp).unwrap();\n    let mut m = pcm.direct_mmap_playback::<i16>().unwrap();\n    assert_eq!(m.status().state(), State::Prepared);\n    assert_eq!(m.appl_ptr(), 0);\n    assert_eq!(m.hw_ptr(), 0);\n    println!(\"{:?}\", m);\n    let mut i = (0..(m.buffer_size() * 2)).map(|i|\n        (((i / 2) as f32 * 2.0 * ::std::f32::consts::PI / 128.0).sin() * 8192.0) as i16);\n    m.write(&mut i);\n    assert_eq!(m.appl_ptr(), m.buffer_size());\n    pcm.start().unwrap();\n    pcm.drain().unwrap();\n    assert_eq!(m.appl_ptr(), m.buffer_size());\n    assert!(m.hw_ptr() >= m.buffer_size());\n"]], "pred": {"ppl": 2.108696937561035, "ppl_lower": 2.509735107421875, "ppl/lowercase_ppl": -1.2333654702584584, "ppl/zlib": 0.0015608163003747468, "Min_5.0% Prob": 6.618148985363188, "Min_10.0% Prob": 4.836014498111814, "Min_20.0% Prob": 3.2290890216827393, "Min_30.0% Prob": 2.357406799347346, "Min_40.0% Prob": 1.8345866543906075, "Min_50.0% Prob": 1.4867531900128272, "Min_60.0% Prob": 1.2434424817625844}}
{"hexsha": "2a798cf0d656cd1e1f597e3f89a802b00d9fcb21", "ext": "rs", "lang": "Rust", "content": "fn write_u8s() {\n        let mut a = AdapterU8::new(MockDevice::new());\n        a.set_dcx_data_mode();\n        let mut seq = mockall::Sequence::new();\n        a.w.mock().expect_write_data()\n            .with(eq(0x34))\n            .times(1)\n            .in_sequence(&mut seq);\n        a.w.mock().expect_write_data()\n            .with(eq(0x56))\n            .times(1)\n            .in_sequence(&mut seq);\n        a.w.mock().expect_write_data()\n            .with(eq(0x12))\n            .times(1)\n            .in_sequence(&mut seq);\n        block_on(a.write_u8s(&[0x34, 0x56, 0x12]));\n    }", "item_id": 1, "repo": "jeru/st7735-async-low", "file": "st7735_async_low/src/adapters.rs", "last_update_at": "2021-05-27T15:16:39+00:00", "question_id": "2a798cf0d656cd1e1f597e3f89a802b00d9fcb21_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn write_u8s() {\n        let mut a = AdapterU8::new(MockDevice::new());\n        a.set_dcx_data_mode();\n        let mut seq = mockall::Sequence::new();\n        a.w.mock().expect_write_data()\n            .with(eq(0x34))\n            .times(1)\n            .in_sequence(&mut seq);\n        a.w.mock().expect_write_data()\n            .with(eq(0x56))\n            .times(1)\n            .in_sequence(&mut seq);\n        a.w.mock().expect_write_data()\n            .with(eq(0x12))\n            .times(1)\n            .in_sequence(&mut seq);\n        block_on(a.write_u8s(&[0x34, 0x56, 0x12]));\n"]], "pred": {"ppl": 2.388091564178467, "ppl_lower": 2.738569498062134, "ppl/lowercase_ppl": -1.1573142148486912, "ppl/zlib": 0.004106106312516903, "Min_5.0% Prob": 7.692465591430664, "Min_10.0% Prob": 6.075971728279477, "Min_20.0% Prob": 3.97740589602049, "Min_30.0% Prob": 2.823808141855093, "Min_40.0% Prob": 2.1773567373842693, "Min_50.0% Prob": 1.7453147839513365, "Min_60.0% Prob": 1.4520208488791608}}
{"hexsha": "f0a57e604081ba64b0a61c5d811dc6e7584082eb", "ext": "rs", "lang": "Rust", "content": "pub fn include_template<P: AsRef<Path>>(path: P, map: &BTreeMap<String, String>) -> String {\n    let mut lines = Vec::new();\n    for (key, value) in map.iter() {\n        lines.push(format!(\"#define ${} {}\\n\", key, value));\n    }\n    lines.push(format!(\"#include <{}>\\n\", path.as_ref()));\n    for (key, _) in map.iter() {\n        lines.push(format!(\"#undef ${}\\n\", key));\n    }\n    lines.join(\"\")\n}", "item_id": 0, "repo": "nthend/hypertrace", "file": "types/src/source.rs", "last_update_at": "2021-07-08T05:29:41+00:00", "question_id": "f0a57e604081ba64b0a61c5d811dc6e7584082eb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn include_template<P: AsRef<Path>>(path: P, map: &BTreeMap<String, String>) -> String {\n    let mut lines = Vec::new();\n    for (key, value) in map.iter() {\n        lines.push(format!(\"#define ${} {}\\n\", key, value));\n    }\n    lines.push(format!(\"#include <{}>\\n\", path.as_ref()));\n    for (key, _) in map.iter() {\n        lines.push(format!(\"#undef ${}\\n\", key));\n    }\n    lines.join(\"\")\n"]], "pred": {"ppl": 2.1256611347198486, "ppl_lower": 2.8517346382141113, "ppl/lowercase_ppl": -1.3896714634165532, "ppl/zlib": 0.003351479449817793, "Min_5.0% Prob": 7.506706305912563, "Min_10.0% Prob": 5.633331860814776, "Min_20.0% Prob": 3.4709108833755766, "Min_30.0% Prob": 2.4542326756886075, "Min_40.0% Prob": 1.88320423476398, "Min_50.0% Prob": 1.5004174779103676, "Min_60.0% Prob": 1.2580033211914055}}
{"hexsha": "82dd60367204e367a7d25fdd1f3bb8fcc86b01f0", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    println!(\"cargo:rerun-if-changed=templates/dashboard.html\");\n    let mut f = File::create(PathBuf::from(std::env::var(\"OUT_DIR\").unwrap()).join(\"dashboard.rs\"))\n        .unwrap();\n    f.write_all(\n        format!(\n            r#\"\n#[derive(Template)]\n#[template(escape = \"html\", source = {:?}, ext = \"html\")]\nstruct Dashboard<'a> {{\n    subnet_type: ic_registry_subnet_type::SubnetType,\n    http_config: &'a ic_config::http_handler::Config,\n\n    height: Height,\n    replicated_state: &'a ic_replicated_state::replicated_state::ReplicatedState,\n    canisters: &'a Vec<&'a ic_replicated_state::CanisterState>,\n    cow_memory_manager_enabled: bool,\n}}\n    \"#,\n            std::fs::read_to_string(\"templates/dashboard.html\").unwrap()\n        )\n        .as_bytes(),\n    )\n    .unwrap();\n}", "item_id": 0, "repo": "bigturlte/ic", "file": "rs/http_handler/build.rs", "last_update_at": "2021-07-20T21:44:44+00:00", "question_id": "82dd60367204e367a7d25fdd1f3bb8fcc86b01f0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    println!(\"cargo:rerun-if-changed=templates/dashboard.html\");\n    let mut f = File::create(PathBuf::from(std::env::var(\"OUT_DIR\").unwrap()).join(\"dashboard.rs\"))\n        .unwrap();\n    f.write_all(\n        format!(\n            r#\"\n#[derive(Template)]\n#[template(escape = \"html\", source = {:?}, ext = \"html\")]\nstruct Dashboard<'a> {{\n    subnet_type: ic_registry_subnet_type::SubnetType,\n    http_config: &'a ic_config::http_handler::Config,\n    height: Height,\n    replicated_state: &'a ic_replicated_state::replicated_state::ReplicatedState,\n    canisters: &'a Vec<&'a ic_replicated_state::CanisterState>,\n    cow_memory_manager_enabled: bool,\n}}\n    \"#,\n            std::fs::read_to_string(\"templates/dashboard.html\").unwrap()\n        )\n        .as_bytes(),\n    )\n    .unwrap();\n"]], "pred": {"ppl": 2.3811185359954834, "ppl_lower": 3.504391670227051, "ppl/lowercase_ppl": -1.445435455810024, "ppl/zlib": 0.002022308509062839, "Min_5.0% Prob": 8.370559068826529, "Min_10.0% Prob": 5.992542593567459, "Min_20.0% Prob": 3.8687000166286123, "Min_30.0% Prob": 2.8217793950220433, "Min_40.0% Prob": 2.1534441188655116, "Min_50.0% Prob": 1.7287834902982349, "Min_60.0% Prob": 1.4495073139103074}}
{"hexsha": "a0144a5298eba24b3d2cc94f0e6d562473c00d08", "ext": "rs", "lang": "Rust", "content": "fn extract_html_tag(\n    tags: &mut Vec<(String, Range<usize>)>,\n    text: &str,\n    range: &Range<usize>,\n    start_pos: usize,\n    iter: &mut Peekable<CharIndices<'_>>,\n    f: &impl Fn(&str, &Range<usize>),\n) {\n    let mut tag_name = String::new();\n    let mut is_closing = false;\n    let mut prev_pos = start_pos;\n\n    loop {\n        let (pos, c) = match iter.peek() {\n            Some((pos, c)) => (*pos, *c),\n            // In case we reached the of the doc comment, we want to check that it's an\n            // unclosed HTML tag. For example \"/// <h3\".\n            None => (prev_pos, '\\0'),\n        };\n        prev_pos = pos;\n        // Checking if this is a closing tag (like `</a>` for `<a>`).\n        if c == '/' && tag_name.is_empty() {\n            is_closing = true;\n        } else if c.is_ascii_alphanumeric() {\n            tag_name.push(c);\n        } else {\n            if !tag_name.is_empty() {\n                let mut r = Range { start: range.start + start_pos, end: range.start + pos };\n                if c == '>' {\n                    // In case we have a tag without attribute, we can consider the span to\n                    // refer to it fully.\n                    r.end += 1;\n                }\n                if is_closing {\n                    // In case we have \"</div >\" or even \"</div         >\".\n                    if c != '>' {\n                        if !c.is_whitespace() {\n                            // It seems like it's not a valid HTML tag.\n                            break;\n                        }\n                        let mut found = false;\n                        for (new_pos, c) in text[pos..].char_indices() {\n                            if !c.is_whitespace() {\n                                if c == '>' {\n                                    r.end = range.start + new_pos + 1;\n                                    found = true;\n                                }\n                                break;\n                            }\n                        }\n                        if !found {\n                            break;\n                        }\n                    }\n                    drop_tag(tags, tag_name, r, f);\n                } else {\n                    tags.push((tag_name, r));\n                }\n            }\n            break;\n        }\n        iter.next();\n    }\n}", "item_id": 0, "repo": "mbc-git/rust", "file": "src/librustdoc/passes/html_tags.rs", "last_update_at": "2021-12-12T20:16:20+00:00", "question_id": "a0144a5298eba24b3d2cc94f0e6d562473c00d08_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn extract_html_tag(\n    tags: &mut Vec<(String, Range<usize>)>,\n    text: &str,\n    range: &Range<usize>,\n    start_pos: usize,\n    iter: &mut Peekable<CharIndices<'_>>,\n    f: &impl Fn(&str, &Range<usize>),\n) {\n    let mut tag_name = String::new();\n    let mut is_closing = false;\n    let mut prev_pos = start_pos;\n    loop {\n        let (pos, c) = match iter.peek() {\n            Some((pos, c)) => (*pos, *c),\n            // In case we reached the of the doc comment, we want to check that it's an\n            // unclosed HTML tag. For example \"/// <h3\".\n            None => (prev_pos, '\\0'),\n        };\n        prev_pos = pos;\n        // Checking if this is a closing tag (like `</a>` for `<a>`).\n        if c == '/' && tag_name.is_empty() {\n            is_closing = true;\n        } else if c.is_ascii_alphanumeric() {\n            tag_name.push(c);\n        } else {\n            if !tag_name.is_empty() {\n                let mut r = Range { start: range.start + start_pos, end: range.start + pos };\n                if c == '>' {\n                    // In case we have a tag without attribute, we can consider the span to\n                    // refer to it fully.\n                    r.end += 1;\n                }\n                if is_closing {\n                    // In case we have \"</div >\" or even \"</div         >\".\n                    if c != '>' {\n                        if !c.is_whitespace() {\n                            // It seems like it's not a valid HTML tag.\n                            break;\n                        }\n                        let mut found = false;\n                        for (new_pos, c) in text[pos..].char_indices() {\n                            if !c.is_whitespace() {\n                                if c == '>' {\n                                    r.end = range.start + new_pos + 1;\n                                    found = true;\n                                }\n                                break;\n                            }\n                        }\n                        if !found {\n                            break;\n                        }\n                    }\n                    drop_tag(tags, tag_name, r, f);\n                } else {\n                    tags.push((tag_name, r));\n                }\n            }\n            break;\n        }\n        iter.next();\n    }\n"]], "pred": {"ppl": 2.2978715896606445, "ppl_lower": 2.5374557971954346, "ppl/lowercase_ppl": -1.1192074718990752, "ppl/zlib": 0.0010639172617549248, "Min_5.0% Prob": 6.08233106136322, "Min_10.0% Prob": 4.741701476275921, "Min_20.0% Prob": 3.3742106799036264, "Min_30.0% Prob": 2.5683742305263877, "Min_40.0% Prob": 2.0349751538597047, "Min_50.0% Prob": 1.6573642118601128, "Min_60.0% Prob": 1.3879721606669289}}
{"hexsha": "3935794c13e3dc1d875fc5619ca9a9e4a97e31b4", "ext": "rs", "lang": "Rust", "content": "fn imaginary_units() {\n    type Qi = Quaternion<i32>;\n    assert_eq!(Qi::i() * Qi::i(), -Qi::one());\n    assert_eq!(Qi::j() * Qi::j(), -Qi::one());\n    assert_eq!(Qi::k() * Qi::k(), -Qi::one());\n    assert_eq!(Qi::i() * Qi::j() * Qi::k(), -Qi::one());\n\n    assert_eq!(Qi::i() * Qi::j(), Qi::k());\n    assert_eq!(Qi::j() * Qi::k(), Qi::i());\n    assert_eq!(Qi::k() * Qi::i(), Qi::j());\n\n    assert_eq!(Qi::j() * Qi::i(), -Qi::k());\n    assert_eq!(Qi::k() * Qi::j(), -Qi::i());\n    assert_eq!(Qi::i() * Qi::k(), -Qi::j());\n}", "item_id": 0, "repo": "nthend/linalg-rs", "file": "src/complex/tests/quaternion/advanced.rs", "last_update_at": "2021-05-10T07:44:08+00:00", "question_id": "3935794c13e3dc1d875fc5619ca9a9e4a97e31b4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn imaginary_units() {\n    type Qi = Quaternion<i32>;\n    assert_eq!(Qi::i() * Qi::i(), -Qi::one());\n    assert_eq!(Qi::j() * Qi::j(), -Qi::one());\n    assert_eq!(Qi::k() * Qi::k(), -Qi::one());\n    assert_eq!(Qi::i() * Qi::j() * Qi::k(), -Qi::one());\n    assert_eq!(Qi::i() * Qi::j(), Qi::k());\n    assert_eq!(Qi::j() * Qi::k(), Qi::i());\n    assert_eq!(Qi::k() * Qi::i(), Qi::j());\n    assert_eq!(Qi::j() * Qi::i(), -Qi::k());\n    assert_eq!(Qi::k() * Qi::j(), -Qi::i());\n    assert_eq!(Qi::i() * Qi::k(), -Qi::j());\n"]], "pred": {"ppl": 1.3860664367675781, "ppl_lower": 1.4766764640808105, "ppl/lowercase_ppl": -1.193966148890231, "ppl/zlib": 0.0021199339856795285, "Min_5.0% Prob": 4.639107803503673, "Min_10.0% Prob": 2.8534496235847473, "Min_20.0% Prob": 1.595557893315951, "Min_30.0% Prob": 1.0890756148796576, "Min_40.0% Prob": 0.8191514173432172, "Min_50.0% Prob": 0.6551384189574033, "Min_60.0% Prob": 0.5454541007826675}}
{"hexsha": "6db7056050c55aa14331f1f251ee136d62c93889", "ext": "rs", "lang": "Rust", "content": "pub fn iso3_to_gd(iso: &na::Isometry3<f64>) -> Transform {\n    let origin = Vector3::new(\n        iso.translation.x as f32,\n        iso.translation.y as f32,\n        iso.translation.z as f32,\n    );\n    let r = iso.rotation.to_rotation_matrix();\n    let basis = Basis::from_elements([\n        Vector3::new(r[(0, 0)] as f32, r[(0, 1)] as f32, r[(0, 2)] as f32),\n        Vector3::new(r[(1, 0)] as f32, r[(1, 1)] as f32, r[(1, 2)] as f32),\n        Vector3::new(r[(2, 0)] as f32, r[(2, 1)] as f32, r[(2, 2)] as f32),\n    ]);\n    Transform { origin, basis }\n}", "item_id": 0, "repo": "azazdeaz/good-bug", "file": "mirrors/src/utils.rs", "last_update_at": "2021-08-03T21:30:35+00:00", "question_id": "6db7056050c55aa14331f1f251ee136d62c93889_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn iso3_to_gd(iso: &na::Isometry3<f64>) -> Transform {\n    let origin = Vector3::new(\n        iso.translation.x as f32,\n        iso.translation.y as f32,\n        iso.translation.z as f32,\n    );\n    let r = iso.rotation.to_rotation_matrix();\n    let basis = Basis::from_elements([\n        Vector3::new(r[(0, 0)] as f32, r[(0, 1)] as f32, r[(0, 2)] as f32),\n        Vector3::new(r[(1, 0)] as f32, r[(1, 1)] as f32, r[(1, 2)] as f32),\n        Vector3::new(r[(2, 0)] as f32, r[(2, 1)] as f32, r[(2, 2)] as f32),\n    ]);\n    Transform { origin, basis }\n"]], "pred": {"ppl": 1.5469127893447876, "ppl_lower": 1.7645145654678345, "ppl/lowercase_ppl": -1.3016872096271257, "ppl/zlib": 0.0018564306210720916, "Min_5.0% Prob": 5.804329911867778, "Min_10.0% Prob": 3.8510156154632567, "Min_20.0% Prob": 2.159144061453202, "Min_30.0% Prob": 1.4536416479084011, "Min_40.0% Prob": 1.0989490906678268, "Min_50.0% Prob": 0.8758745222655762, "Min_60.0% Prob": 0.7280342704116147}}
{"hexsha": "0420284c693ed7d9ea54f69af006283ff3017923", "ext": "rs", "lang": "Rust", "content": "fn decode_one() {\n    let input = \":foo!bar@baz PRIVMSG #test :this is a test\\r\\n:local.host PING :1234\\r\\n\";\n    let (next, _msg) = super::decode_one(input).unwrap();\n    assert!(next > 0);\n\n    // this should be the last message\n    let (next, _msg) = super::decode_one(&input[next..]).unwrap();\n    assert_eq!(next, 0);\n\n    // try with a bad element at the end\n    let input = \":foo!bar@baz PRIVMSG #test :this is a test\\r\\n:local.host PING :1234\\r\\nfoo\";\n    {\n        let (next, _msg) = super::decode_one(input).unwrap();\n        assert!(next > 0);\n\n        let input = &input[next..];\n        let (next, _msg) = super::decode_one(&input).unwrap();\n        assert!(next > 0);\n\n        // last one should be an error\n        let input = &input[next..];\n        super::decode_one(&input).unwrap_err();\n    }\n}", "item_id": 1, "repo": "Chronophylos/twitchchat", "file": "src/decode/tests.rs", "last_update_at": "2021-10-09T01:13:21+00:00", "question_id": "0420284c693ed7d9ea54f69af006283ff3017923_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn decode_one() {\n    let input = \":foo!bar@baz PRIVMSG #test :this is a test\\r\\n:local.host PING :1234\\r\\n\";\n    let (next, _msg) = super::decode_one(input).unwrap();\n    assert!(next > 0);\n    // this should be the last message\n    let (next, _msg) = super::decode_one(&input[next..]).unwrap();\n    assert_eq!(next, 0);\n    // try with a bad element at the end\n    let input = \":foo!bar@baz PRIVMSG #test :this is a test\\r\\n:local.host PING :1234\\r\\nfoo\";\n    {\n        let (next, _msg) = super::decode_one(input).unwrap();\n        assert!(next > 0);\n        let input = &input[next..];\n        let (next, _msg) = super::decode_one(&input).unwrap();\n        assert!(next > 0);\n        // last one should be an error\n        let input = &input[next..];\n        super::decode_one(&input).unwrap_err();\n    }\n"]], "pred": {"ppl": 2.183685064315796, "ppl_lower": 2.3516151905059814, "ppl/lowercase_ppl": -1.0948620326924867, "ppl/zlib": 0.00275976624086234, "Min_5.0% Prob": 6.805371284484863, "Min_10.0% Prob": 5.162495185588968, "Min_20.0% Prob": 3.4794157250174162, "Min_30.0% Prob": 2.5042962473014305, "Min_40.0% Prob": 1.9295041770513714, "Min_50.0% Prob": 1.5596395275459207, "Min_60.0% Prob": 1.3035884174764498}}
{"hexsha": "f9cff1da0060b096947f20d7571f5d66435ec14d", "ext": "rs", "lang": "Rust", "content": "pub fn flip_vertical<T: Pixel>(src: &Image<T>) -> Image<T> {\n    let mut dst = Image::new(src.width(), src.height());\n    for h in 0..src.height() {\n        for (a, b) in dst.row_mut(src.height() - h - 1).iter_mut().zip(src.row(h)) {\n            *a = *b;\n        }\n    }\n    dst\n}", "item_id": 3, "repo": "pickfire/imageproc", "file": "src/transform.rs", "last_update_at": "2021-12-17T07:25:53+00:00", "question_id": "f9cff1da0060b096947f20d7571f5d66435ec14d_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn flip_vertical<T: Pixel>(src: &Image<T>) -> Image<T> {\n    let mut dst = Image::new(src.width(), src.height());\n    for h in 0..src.height() {\n        for (a, b) in dst.row_mut(src.height() - h - 1).iter_mut().zip(src.row(h)) {\n            *a = *b;\n        }\n    }\n    dst\n"]], "pred": {"ppl": 2.0184361934661865, "ppl_lower": 2.3431029319763184, "ppl/lowercase_ppl": -1.2123709884346634, "ppl/zlib": 0.0039017947219157326, "Min_5.0% Prob": 7.694963645935059, "Min_10.0% Prob": 5.364232648502696, "Min_20.0% Prob": 3.221936572681774, "Min_30.0% Prob": 2.3060451113816463, "Min_40.0% Prob": 1.7352489219771492, "Min_50.0% Prob": 1.4069894407875836, "Min_60.0% Prob": 1.181023915506788}}
{"hexsha": "c4001d92813efe98b1ad1f35333b7754bae617b4", "ext": "rs", "lang": "Rust", "content": "async fn test_download_file() {\n        let mut client = TgClient::new(&Config {\n            max_download_queue_size: 1,\n            log_download_state_secs_interval: 100,\n            log_verbosity_level: 0,\n            encryption_key: \"\",\n            database_directory: \"\",\n            api_id: 0,\n            api_hash: \"\",\n            phone_number: \"\",\n        });\n        client.api = Box::new(MockedApi);\n\n        client.download_file(1).await;\n        assert_eq!(client.download_queue.lock().unwrap().queue().len(), 0);\n        assert_eq!(\n            client.download_queue.lock().unwrap().in_progress(),\n            &vec![1]\n        );\n\n        client.download_file(1).await;\n        assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![1]);\n        assert_eq!(\n            client.download_queue.lock().unwrap().in_progress(),\n            &vec![1]\n        );\n\n        client.download_file(2).await;\n        assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![1, 2]);\n        assert_eq!(\n            client.download_queue.lock().unwrap().in_progress(),\n            &vec![1]\n        );\n\n        let (sender, receiver) = mpsc::channel(1);\n        let chann = Arc::new(AsyncMutex::new(sender));\n        let download_finished_handler =\n            get_update_file_handler(chann, client.download_queue.clone());\n        let eapi = EventApi::new(Api::default());\n\n        download_finished_handler((\n            &eapi,\n            &UpdateFile::builder()\n                .file(\n                    File::builder()\n                        .local(LocalFile::builder().is_downloading_completed(false).build()),\n                )\n                .build(),\n        ));\n\n        // no changes\n        assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![1, 2]);\n        assert_eq!(\n            client.download_queue.lock().unwrap().in_progress(),\n            &vec![1]\n        );\n\n        download_finished_handler((\n            &eapi,\n            &UpdateFile::builder()\n                .file(\n                    File::builder()\n                        .id(10)\n                        .local(LocalFile::builder().is_downloading_completed(true).build()),\n                )\n                .build(),\n        ));\n\n        // no changes: file not in progress\n        assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![1, 2]);\n        assert_eq!(\n            client.download_queue.lock().unwrap().in_progress(),\n            &vec![1]\n        );\n\n        download_finished_handler((\n            &eapi,\n            &UpdateFile::builder()\n                .file(\n                    File::builder()\n                        .id(1)\n                        .local(LocalFile::builder().is_downloading_completed(true).build()),\n                )\n                .build(),\n        ));\n        assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![2]);\n        assert_eq!(\n            client.download_queue.lock().unwrap().in_progress(),\n            &vec![1]\n        );\n\n        download_finished_handler((\n            &eapi,\n            &UpdateFile::builder()\n                .file(\n                    File::builder()\n                        .id(1)\n                        .local(LocalFile::builder().is_downloading_completed(true).build()),\n                )\n                .build(),\n        ));\n        assert_eq!(client.download_queue.lock().unwrap().queue().len(), 0);\n        assert_eq!(\n            client.download_queue.lock().unwrap().in_progress(),\n            &vec![2]\n        );\n\n        client.download_file(3).await;\n        client.download_file(4).await;\n        client.download_file(5).await;\n\n        download_finished_handler((\n            &eapi,\n            &UpdateFile::builder()\n                .file(\n                    File::builder()\n                        .id(2)\n                        .local(LocalFile::builder().is_downloading_completed(true).build()),\n                )\n                .build(),\n        ));\n\n        assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![4, 5]);\n        assert_eq!(\n            client.download_queue.lock().unwrap().in_progress(),\n            &vec![3]\n        );\n    }", "item_id": 0, "repo": "aCLr/feeder", "file": "tg-collector/src/tg_client.rs", "last_update_at": "2021-05-13T07:10:57+00:00", "question_id": "c4001d92813efe98b1ad1f35333b7754bae617b4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn test_download_file() {\n        let mut client = TgClient::new(&Config {\n            max_download_queue_size: 1,\n            log_download_state_secs_interval: 100,\n            log_verbosity_level: 0,\n            encryption_key: \"\",\n            database_directory: \"\",\n            api_id: 0,\n            api_hash: \"\",\n            phone_number: \"\",\n        });\n        client.api = Box::new(MockedApi);\n        client.download_file(1).await;\n        assert_eq!(client.download_queue.lock().unwrap().queue().len(), 0);\n        assert_eq!(\n            client.download_queue.lock().unwrap().in_progress(),\n            &vec![1]\n        );\n        client.download_file(1).await;\n        assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![1]);\n        assert_eq!(\n            client.download_queue.lock().unwrap().in_progress(),\n            &vec![1]\n        );\n        client.download_file(2).await;\n        assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![1, 2]);\n        assert_eq!(\n            client.download_queue.lock().unwrap().in_progress(),\n            &vec![1]\n        );\n        let (sender, receiver) = mpsc::channel(1);\n        let chann = Arc::new(AsyncMutex::new(sender));\n        let download_finished_handler =\n            get_update_file_handler(chann, client.download_queue.clone());\n        let eapi = EventApi::new(Api::default());\n        download_finished_handler((\n            &eapi,\n            &UpdateFile::builder()\n                .file(\n                    File::builder()\n                        .local(LocalFile::builder().is_downloading_completed(false).build()),\n                )\n                .build(),\n        ));\n        // no changes\n        assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![1, 2]);\n        assert_eq!(\n            client.download_queue.lock().unwrap().in_progress(),\n            &vec![1]\n        );\n        download_finished_handler((\n            &eapi,\n            &UpdateFile::builder()\n                .file(\n                    File::builder()\n                        .id(10)\n                        .local(LocalFile::builder().is_downloading_completed(true).build()),\n                )\n                .build(),\n        ));\n        // no changes: file not in progress\n        assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![1, 2]);\n        assert_eq!(\n            client.download_queue.lock().unwrap().in_progress(),\n            &vec![1]\n        );\n        download_finished_handler((\n            &eapi,\n            &UpdateFile::builder()\n                .file(\n                    File::builder()\n                        .id(1)\n                        .local(LocalFile::builder().is_downloading_completed(true).build()),\n                )\n                .build(),\n        ));\n        assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![2]);\n        assert_eq!(\n            client.download_queue.lock().unwrap().in_progress(),\n            &vec![1]\n        );\n        download_finished_handler((\n            &eapi,\n            &UpdateFile::builder()\n                .file(\n                    File::builder()\n                        .id(1)\n                        .local(LocalFile::builder().is_downloading_completed(true).build()),\n                )\n                .build(),\n        ));\n        assert_eq!(client.download_queue.lock().unwrap().queue().len(), 0);\n        assert_eq!(\n            client.download_queue.lock().unwrap().in_progress(),\n            &vec![2]\n        );\n        client.download_file(3).await;\n        client.download_file(4).await;\n        client.download_file(5).await;\n        download_finished_handler((\n            &eapi,\n            &UpdateFile::builder()\n                .file(\n                    File::builder()\n                        .id(2)\n                        .local(LocalFile::builder().is_downloading_completed(true).build()),\n                )\n                .build(),\n        ));\n        assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![4, 5]);\n        assert_eq!(\n            client.download_queue.lock().unwrap().in_progress(),\n            &vec![3]\n        );\n"]], "pred": {"ppl": 1.6224606037139893, "ppl_lower": 1.7279887199401855, "ppl/lowercase_ppl": -1.1302098363536577, "ppl/zlib": 0.0007894680066513389, "Min_5.0% Prob": 5.637378234489291, "Min_10.0% Prob": 3.9635801490615394, "Min_20.0% Prob": 2.3391669781184663, "Min_30.0% Prob": 1.60935724530296, "Min_40.0% Prob": 1.2090704744251348, "Min_50.0% Prob": 0.9685941035374033, "Min_60.0% Prob": 0.8075610984443059}}
{"hexsha": "2966d50cd5041c46dd20ba88abe999dae708056f", "ext": "rs", "lang": "Rust", "content": "fn consume_value(input: &[u8]) -> IResult<&[u8], String> {\n    // use many1(consume_line) because many0 always returns true and causes a separated list error.\n    let (input, chars) = separated_list0(many1(consume_line), many0(one_char_in_value))(input)?;\n    Ok((input, chars.into_iter().flatten().collect::<String>()))\n}", "item_id": 4, "repo": "ZacBlanco/props-rs", "file": "src/parser.rs", "last_update_at": "2021-07-02T00:55:31+00:00", "question_id": "2966d50cd5041c46dd20ba88abe999dae708056f_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn consume_value(input: &[u8]) -> IResult<&[u8], String> {\n    // use many1(consume_line) because many0 always returns true and causes a separated list error.\n    let (input, chars) = separated_list0(many1(consume_line), many0(one_char_in_value))(input)?;\n    Ok((input, chars.into_iter().flatten().collect::<String>()))\n"]], "pred": {"ppl": 4.362627983093262, "ppl_lower": 5.570051670074463, "ppl/lowercase_ppl": -1.1658637669676208, "ppl/zlib": 0.00691584330608903, "Min_5.0% Prob": 8.244675636291504, "Min_10.0% Prob": 6.865496826171875, "Min_20.0% Prob": 5.373189687728882, "Min_30.0% Prob": 4.451139248907566, "Min_40.0% Prob": 3.58201751598092, "Min_50.0% Prob": 2.934819808160817, "Min_60.0% Prob": 2.4642105911213616}}
{"hexsha": "51f6f71058bc121f2553e2b39179a7c152781fee", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn build_bundle() -> Bundle {\n        let bundle_value = json!({\n          \"SignedEntryTimestamp\": \"MEUCIDBGJijj2FqU25yRWzlEWHqE64XKwUvychBs1bSM1PaKAiEAwcR2u81c42TLBk3lWJqhtB7SnM7Lh0OYEl6Bfa7ZA4s=\",\n          \"Payload\": {\n            \"body\": \"eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoicmVrb3JkIiwic3BlYyI6eyJkYXRhIjp7Imhhc2giOnsiYWxnb3JpdGhtIjoic2hhMjU2IiwidmFsdWUiOiJlNzgwMWRlOTM1NTEyZTIyYjIzN2M3YjU3ZTQyY2E0ZDIwZTIxMzRiZGYxYjk4Zjk3NmM4ZjU1ZDljZmU0MDY3In19LCJzaWduYXR1cmUiOnsiY29udGVudCI6Ik1FVUNJR3FXU2N6N3M5YVAyc0dYTkZLZXFpdnczQjZrUFJzNTZBSVRJSG52ZDVpZ0FpRUExa3piYVYyWTV5UEU4MUVOOTJOVUZPbDMxTExKU3Z3c2pGUTA3bTJYcWFBPSIsImZvcm1hdCI6Ing1MDkiLCJwdWJsaWNLZXkiOnsiY29udGVudCI6IkxTMHRMUzFDUlVkSlRpQkRSVkpVU1VaSlEwRlVSUzB0TFMwdENrMUpTVU5rZWtORFFXWjVaMEYzU1VKQlowbFVRU3RRYzJGTGFtRkZXbkZ1TjBsWk9UUmlNV1V2YWtwdWFYcEJTMEpuWjNGb2EycFBVRkZSUkVGNlFYRUtUVkpWZDBWM1dVUldVVkZMUlhkNGVtRlhaSHBrUnpsNVdsTTFhMXBZV1hoRlZFRlFRbWRPVmtKQlRWUkRTRTV3V2pOT01HSXpTbXhOUWpSWVJGUkplQXBOVkVGNVRVUkJNMDFxVlhoT2JHOVlSRlJKZUUxVVFYbE5SRUV6VGtSVmVFNVdiM2RCUkVKYVRVSk5SMEo1Y1VkVFRUUTVRV2RGUjBORGNVZFRUVFE1Q2tGM1JVaEJNRWxCUWtsT1pYZFJRbE14WmpSQmJVNUpSVTVrVEN0VkwwaEtiM1JOVTAwM1drNXVhMVJ1V1dWbWVIZFdPVlJGY25CMmJrRmFNQ3RFZWt3S2VXWkJRVlpoWlVwMFMycEdkbUpQVkdJNFJqRjVhRXBHVlRCWVdTdFNhV3BuWjBWd1RVbEpRa3BVUVU5Q1owNVdTRkU0UWtGbU9FVkNRVTFEUWpSQmR3cEZkMWxFVmxJd2JFSkJkM2REWjFsSlMzZFpRa0pSVlVoQmQwMTNSRUZaUkZaU01GUkJVVWd2UWtGSmQwRkVRV1JDWjA1V1NGRTBSVVpuVVZWTlpqRlNDazFOYzNGT1JrSnlWMko0T0cxU1RtUjRUMnRGUlZsemQwaDNXVVJXVWpCcVFrSm5kMFp2UVZWNVRWVmtRVVZIWVVwRGEzbFZVMVJ5UkdFMVN6ZFZiMGNLTUN0M2QyZFpNRWREUTNOSFFWRlZSa0ozUlVKQ1NVZEJUVWcwZDJaQldVbExkMWxDUWxGVlNFMUJTMGRqUjJnd1pFaEJOa3g1T1hkamJXd3lXVmhTYkFwWk1rVjBXVEk1ZFdSSFZuVmtRekF5VFVST2JWcFVaR3hPZVRCM1RVUkJkMHhVU1hsTmFtTjBXVzFaTTA1VE1XMU9SMWt4V2xSbmQxcEVTVFZPVkZGMUNtTXpVblpqYlVadVdsTTFibUl5T1c1aVIxWm9ZMGRzZWt4dFRuWmlVemxxV1ZSTk1sbFVSbXhQVkZsNVRrUkthVTlYV21wWmFrVXdUbWs1YWxsVE5Xb0tZMjVSZDBsQldVUldVakJTUVZGSUwwSkNXWGRHU1VWVFdtMTRhR1J0YkhaUlIwNW9Zek5TYkdKSGVIQk1iVEZzVFVGdlIwTkRjVWRUVFRRNVFrRk5SQXBCTW10QlRVZFpRMDFSUXpOWk1uVnNVRlJ6VUcxT1V6UmplbUZMWldwbE1FSnVUMUZJZWpWbE5rNUNXREJDY1hnNVdHTmhLM1F5YTA5cE1UZHpiM0JqQ2k5MkwzaElNWGhNZFZCdlEwMVJSRXRPUkRSWGFraG1TM0ZZV0U5bFZYWmFPVUU1TmtSeGNrVjNSMkZ4UjAxMGJrbDFUalJLZWxwWllWVk1Xbko0T1djS2IxaHhjVzh2UXpsUmJrOUlWSFJ2UFFvdExTMHRMVVZPUkNCRFJWSlVTVVpKUTBGVVJTMHRMUzB0Q2c9PSJ9fX19\",\n            \"integratedTime\": 1634714717,\n            \"logIndex\": 783607,\n            \"logID\": \"c0d23d6ad406973f9559f3ba2d1ca01f84147d8ffc5b8445c224f98b9591801d\"\n          }\n        });\n        let bundle: Bundle = serde_json::from_value(bundle_value).expect(\"Cannot parse bundle\");\n        bundle\n    }", "item_id": 2, "repo": "jvanz/sigstore-rs", "file": "src/cosign/signature_layers.rs", "last_update_at": "2021-10-15T20:50:55+00:00", "question_id": "51f6f71058bc121f2553e2b39179a7c152781fee_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn build_bundle() -> Bundle {\n        let bundle_value = json!({\n          \"SignedEntryTimestamp\": \"MEUCIDBGJijj2FqU25yRWzlEWHqE64XKwUvychBs1bSM1PaKAiEAwcR2u81c42TLBk3lWJqhtB7SnM7Lh0OYEl6Bfa7ZA4s=\",\n          \"Payload\": {\n            \"body\": \"eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoicmVrb3JkIiwic3BlYyI6eyJkYXRhIjp7Imhhc2giOnsiYWxnb3JpdGhtIjoic2hhMjU2IiwidmFsdWUiOiJlNzgwMWRlOTM1NTEyZTIyYjIzN2M3YjU3ZTQyY2E0ZDIwZTIxMzRiZGYxYjk4Zjk3NmM4ZjU1ZDljZmU0MDY3In19LCJzaWduYXR1cmUiOnsiY29udGVudCI6Ik1FVUNJR3FXU2N6N3M5YVAyc0dYTkZLZXFpdnczQjZrUFJzNTZBSVRJSG52ZDVpZ0FpRUExa3piYVYyWTV5UEU4MUVOOTJOVUZPbDMxTExKU3Z3c2pGUTA3bTJYcWFBPSIsImZvcm1hdCI6Ing1MDkiLCJwdWJsaWNLZXkiOnsiY29udGVudCI6IkxTMHRMUzFDUlVkSlRpQkRSVkpVU1VaSlEwRlVSUzB0TFMwdENrMUpTVU5rZWtORFFXWjVaMEYzU1VKQlowbFVRU3RRYzJGTGFtRkZXbkZ1TjBsWk9UUmlNV1V2YWtwdWFYcEJTMEpuWjNGb2EycFBVRkZSUkVGNlFYRUtUVkpWZDBWM1dVUldVVkZMUlhkNGVtRlhaSHBrUnpsNVdsTTFhMXBZV1hoRlZFRlFRbWRPVmtKQlRWUkRTRTV3V2pOT01HSXpTbXhOUWpSWVJGUkplQXBOVkVGNVRVUkJNMDFxVlhoT2JHOVlSRlJKZUUxVVFYbE5SRUV6VGtSVmVFNVdiM2RCUkVKYVRVSk5SMEo1Y1VkVFRUUTVRV2RGUjBORGNVZFRUVFE1Q2tGM1JVaEJNRWxCUWtsT1pYZFJRbE14WmpSQmJVNUpSVTVrVEN0VkwwaEtiM1JOVTAwM1drNXVhMVJ1V1dWbWVIZFdPVlJGY25CMmJrRmFNQ3RFZWt3S2VXWkJRVlpoWlVwMFMycEdkbUpQVkdJNFJqRjVhRXBHVlRCWVdTdFNhV3BuWjBWd1RVbEpRa3BVUVU5Q1owNVdTRkU0UWtGbU9FVkNRVTFEUWpSQmR3cEZkMWxFVmxJd2JFSkJkM2REWjFsSlMzZFpRa0pSVlVoQmQwMTNSRUZaUkZaU01GUkJVVWd2UWtGSmQwRkVRV1JDWjA1V1NGRTBSVVpuVVZWTlpqRlNDazFOYzNGT1JrSnlWMko0T0cxU1RtUjRUMnRGUlZsemQwaDNXVVJXVWpCcVFrSm5kMFp2UVZWNVRWVmtRVVZIWVVwRGEzbFZVMVJ5UkdFMVN6ZFZiMGNLTUN0M2QyZFpNRWREUTNOSFFWRlZSa0ozUlVKQ1NVZEJUVWcwZDJaQldVbExkMWxDUWxGVlNFMUJTMGRqUjJnd1pFaEJOa3g1T1hkamJXd3lXVmhTYkFwWk1rVjBXVEk1ZFdSSFZuVmtRekF5VFVST2JWcFVaR3hPZVRCM1RVUkJkMHhVU1hsTmFtTjBXVzFaTTA1VE1XMU9SMWt4V2xSbmQxcEVTVFZPVkZGMUNtTXpVblpqYlVadVdsTTFibUl5T1c1aVIxWm9ZMGRzZWt4dFRuWmlVemxxV1ZSTk1sbFVSbXhQVkZsNVRrUkthVTlYV21wWmFrVXdUbWs1YWxsVE5Xb0tZMjVSZDBsQldVUldVakJTUVZGSUwwSkNXWGRHU1VWVFdtMTRhR1J0YkhaUlIwNW9Zek5TYkdKSGVIQk1iVEZzVFVGdlIwTkRjVWRUVFRRNVFrRk5SQXBCTW10QlRVZFpRMDFSUXpOWk1uVnNVRlJ6VUcxT1V6UmplbUZMWldwbE1FSnVUMUZJZWpWbE5rNUNXREJDY1hnNVdHTmhLM1F5YTA5cE1UZHpiM0JqQ2k5MkwzaElNWGhNZFZCdlEwMVJSRXRPUkRSWGFraG1TM0ZZV0U5bFZYWmFPVUU1TmtSeGNrVjNSMkZ4UjAxMGJrbDFUalJLZWxwWllWVk1Xbko0T1djS2IxaHhjVzh2UXpsUmJrOUlWSFJ2UFFvdExTMHRMVVZPUkNCRFJWSlVTVVpKUTBGVVJTMHRMUzB0Q2c9PSJ9fX19\",\n            \"integratedTime\": 1634714717,\n            \"logIndex\": 783607,\n            \"logID\": \"c0d23d6ad406973f9559f3ba2d1ca01f84147d8ffc5b8445c224f98b9591801d\"\n          }\n        });\n        let bundle: Bundle = serde_json::from_value(bundle_value).expect(\"Cannot parse bundle\");\n        bundle\n"]], "pred": {"ppl": 24.258705139160156, "ppl_lower": 140.52467346191406, "ppl/lowercase_ppl": -1.5508721269666101, "ppl/zlib": 0.001735860385290244, "Min_5.0% Prob": 8.0993893847746, "Min_10.0% Prob": 7.247737108492384, "Min_20.0% Prob": 6.157833583214703, "Min_30.0% Prob": 5.51969339255414, "Min_40.0% Prob": 5.052007419847334, "Min_50.0% Prob": 4.655863165155549, "Min_60.0% Prob": 4.331709429646005}}
{"hexsha": "7deeef71cc89b58cf4e426c3c9041064e054a51b", "ext": "rs", "lang": "Rust", "content": "fn fmt_menu(xml: &roxmltree::Document, id: u32) -> String {\n    let mut pretty  = String::new();\n    let node = xml.get_node(roxmltree::NodeId::from(id)).unwrap();\n    let mut descr:Vec<&str> = Vec::new();\n    pretty.push_str(node.attribute(\"title\").unwrap());\n    pretty.push(':'); \n    for child in node.children(){\n      if child.tag_name().name().to_lowercase() == \"category\" {\n        let title = child.attributes()[0].value();\n        if title.to_lowercase().contains(\"sex:\"){ \n            //add Gender to the name\n          pretty.push_str(title.trim_start_matches(\"Sex:\"));\n        }\n        else if title.to_lowercase().contains(\"all\"){\n            //do nothing\n        }\n        else {\n         descr.push(title);\n          }\n    }\n    }\n    for item in descr {\n        pretty.push('\\t');\n        pretty.push_str(\"     \");\n        pretty.push_str(item);\n    }\n    pretty\n}", "item_id": 3, "repo": "mpkingsley/namegen-rs", "file": "src/main.rs", "last_update_at": "2021-01-08T21:04:49+00:00", "question_id": "7deeef71cc89b58cf4e426c3c9041064e054a51b_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn fmt_menu(xml: &roxmltree::Document, id: u32) -> String {\n    let mut pretty  = String::new();\n    let node = xml.get_node(roxmltree::NodeId::from(id)).unwrap();\n    let mut descr:Vec<&str> = Vec::new();\n    pretty.push_str(node.attribute(\"title\").unwrap());\n    pretty.push(':'); \n    for child in node.children(){\n      if child.tag_name().name().to_lowercase() == \"category\" {\n        let title = child.attributes()[0].value();\n        if title.to_lowercase().contains(\"sex:\"){ \n            //add Gender to the name\n          pretty.push_str(title.trim_start_matches(\"Sex:\"));\n        }\n        else if title.to_lowercase().contains(\"all\"){\n            //do nothing\n        }\n        else {\n         descr.push(title);\n          }\n    }\n    }\n    for item in descr {\n        pretty.push('\\t');\n        pretty.push_str(\"     \");\n        pretty.push_str(item);\n    }\n    pretty\n"]], "pred": {"ppl": 3.2141528129577637, "ppl_lower": 3.7035624980926514, "ppl/lowercase_ppl": -1.121390694057228, "ppl/zlib": 0.0028900094361892083, "Min_5.0% Prob": 7.700021369116647, "Min_10.0% Prob": 6.188796843801226, "Min_20.0% Prob": 4.552015896354403, "Min_30.0% Prob": 3.492093081985201, "Min_40.0% Prob": 2.7869951804127315, "Min_50.0% Prob": 2.293037716695603, "Min_60.0% Prob": 1.9384205395124368}}
{"hexsha": "ec16a4034ffdcd26392de50e60e497bab5c9d470", "ext": "rs", "lang": "Rust", "content": "fn unrecognized_message() {\n            let buffer = [];\n            let mut decoder = MessageDecoder::default();\n\n            decoder.next_stage(None).expect(\"proceed to the next stage\");\n            decoder.next_stage(Some(&[b'A'])).expect(\"proceed to the next stage\");\n            decoder\n                .next_stage(Some(&LEN.to_be_bytes()))\n                .expect(\"proceed to the next stage\");\n\n            assert_eq!(\n                decoder.next_stage(Some(&buffer)),\n                Err(MessageFormatError::from(\n                    MessageFormatErrorKind::UnsupportedFrontendMessage('A')\n                ))\n            );\n        }", "item_id": 18, "repo": "alex-dukhno/pg_wire", "file": "src/message_decoder.rs", "last_update_at": "2021-07-31T13:12:33+00:00", "question_id": "ec16a4034ffdcd26392de50e60e497bab5c9d470_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn unrecognized_message() {\n            let buffer = [];\n            let mut decoder = MessageDecoder::default();\n            decoder.next_stage(None).expect(\"proceed to the next stage\");\n            decoder.next_stage(Some(&[b'A'])).expect(\"proceed to the next stage\");\n            decoder\n                .next_stage(Some(&LEN.to_be_bytes()))\n                .expect(\"proceed to the next stage\");\n            assert_eq!(\n                decoder.next_stage(Some(&buffer)),\n                Err(MessageFormatError::from(\n                    MessageFormatErrorKind::UnsupportedFrontendMessage('A')\n                ))\n            );\n"]], "pred": {"ppl": 3.0306031703948975, "ppl_lower": 4.2056660652160645, "ppl/lowercase_ppl": -1.2955288079610616, "ppl/zlib": 0.004417377154769615, "Min_5.0% Prob": 8.316424369812012, "Min_10.0% Prob": 6.854554086923599, "Min_20.0% Prob": 4.711277282599247, "Min_30.0% Prob": 3.5255820556562774, "Min_40.0% Prob": 2.7093791735894754, "Min_50.0% Prob": 2.2117582077115046, "Min_60.0% Prob": 1.842698977300615}}
{"hexsha": "3034f6791edee6c5f8a62aa256066c1f6d0411b6", "ext": "rs", "lang": "Rust", "content": "fn ion_hash_string() {\n    let value = IonValue::String(\"Hola\".to_string());\n\n    let hash = IonHash::digest::<Sha256>(&value);\n\n    println!(\"Resulting hash: {:X?}\", hash);\n\n    assert_eq!(b\"\\x39\\xc4\\xf3\\x56\\x39\\xf5\\xf2\\xa5\\x83\\xc5\\xe4\\x39\\x43\\xc2\\x06\\x79\\x92\\xe5\\x5e\\xd2\\xaa\\x31\\x90\\x34\\x28\\x76\\x56\\x6c\\xbf\\xf6\\x2e\\xe0\", &hash[..]);\n}", "item_id": 0, "repo": "juchiast/ion-binary-rs", "file": "src/tests/ion_hash/string.rs", "last_update_at": "2021-07-29T01:12:37+00:00", "question_id": "3034f6791edee6c5f8a62aa256066c1f6d0411b6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn ion_hash_string() {\n    let value = IonValue::String(\"Hola\".to_string());\n    let hash = IonHash::digest::<Sha256>(&value);\n    println!(\"Resulting hash: {:X?}\", hash);\n    assert_eq!(b\"\\x39\\xc4\\xf3\\x56\\x39\\xf5\\xf2\\xa5\\x83\\xc5\\xe4\\x39\\x43\\xc2\\x06\\x79\\x92\\xe5\\x5e\\xd2\\xaa\\x31\\x90\\x34\\x28\\x76\\x56\\x6c\\xbf\\xf6\\x2e\\xe0\", &hash[..]);\n"]], "pred": {"ppl": 4.489700794219971, "ppl_lower": 4.958593368530273, "ppl/lowercase_ppl": -1.0661452697876532, "ppl/zlib": 0.006417889150749475, "Min_5.0% Prob": 7.048818588256836, "Min_10.0% Prob": 5.261721058895714, "Min_20.0% Prob": 4.123164482605763, "Min_30.0% Prob": 3.660957591287021, "Min_40.0% Prob": 3.337038272466415, "Min_50.0% Prob": 2.902831438275957, "Min_60.0% Prob": 2.457103031950119}}
{"hexsha": "cfeb560bafebf06ebe74ada56ea1d989e5186467", "ext": "rs", "lang": "Rust", "content": "fn eval_cons(x: Object, xs: Object, env: &mut Env, backtrace: &mut Backtrace) -> Result<Object> {\n    use Object::*;\n    let xs = evaluate(xs, env, backtrace)?;\n    match xs {\n        List(xs) => Ok(List(vec![Cons(\"::\".into()), evaluate(x, env, backtrace)?, List(xs)])),\n        _ => Err(EvalError::new(format!(\"Cons error: {:?}\", xs), backtrace.clone()))\n    }\n}", "item_id": 6, "repo": "ireina7/abyss.rs", "file": "src/abyss/eval/strict.rs", "last_update_at": "2021-06-09T02:08:30+00:00", "question_id": "cfeb560bafebf06ebe74ada56ea1d989e5186467_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn eval_cons(x: Object, xs: Object, env: &mut Env, backtrace: &mut Backtrace) -> Result<Object> {\n    use Object::*;\n    let xs = evaluate(xs, env, backtrace)?;\n    match xs {\n        List(xs) => Ok(List(vec![Cons(\"::\".into()), evaluate(x, env, backtrace)?, List(xs)])),\n        _ => Err(EvalError::new(format!(\"Cons error: {:?}\", xs), backtrace.clone()))\n    }\n"]], "pred": {"ppl": 3.0158674716949463, "ppl_lower": 3.7715768814086914, "ppl/lowercase_ppl": -1.2025620146973452, "ppl/zlib": 0.004950168194773701, "Min_5.0% Prob": 7.904322544733684, "Min_10.0% Prob": 6.6166839599609375, "Min_20.0% Prob": 4.6212783908844, "Min_30.0% Prob": 3.414136223102871, "Min_40.0% Prob": 2.67306789931129, "Min_50.0% Prob": 2.1790701730642468, "Min_60.0% Prob": 1.8492621472105384}}
{"hexsha": "f8b2bf043358764b4e30c185e1999f58b9e1ae30", "ext": "rs", "lang": "Rust", "content": "async fn test_list_typefaces() {\n    test_list_typefaces_empty_request_gets_all().await.unwrap();\n    test_list_typefaces_no_results_after_last_page().await.unwrap();\n    test_list_typefaces_paginates().await.unwrap();\n    test_list_typefaces_no_results_found().await.unwrap();\n    test_list_typefaces_by_name().await.unwrap();\n    test_list_typefaces_by_alias().await.unwrap();\n    test_list_typefaces_by_name_ignores_case().await.unwrap();\n    test_list_typefaces_by_name_substring().await.unwrap();\n    test_list_typefaces_by_slant_range().await.unwrap();\n    test_list_typefaces_by_slant_range_is_inclusive().await.unwrap();\n    test_list_typefaces_by_weight_range().await.unwrap();\n    test_list_typefaces_by_weight_range_is_inclusive().await.unwrap();\n    test_list_typefaces_by_width_range().await.unwrap();\n    test_list_typefaces_by_width_range_is_inclusive().await.unwrap();\n    test_list_typefaces_by_language().await.unwrap();\n    test_list_typefaces_by_code_point().await.unwrap();\n    test_list_typefaces_by_generic_family().await.unwrap();\n}", "item_id": 0, "repo": "EnderNightLord-ChromeBook/zircon-rpi", "file": "src/fonts/tests/integration/src/experimental_api/list_typefaces.rs", "last_update_at": "2021-09-20T02:46:20+00:00", "question_id": "f8b2bf043358764b4e30c185e1999f58b9e1ae30_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn test_list_typefaces() {\n    test_list_typefaces_empty_request_gets_all().await.unwrap();\n    test_list_typefaces_no_results_after_last_page().await.unwrap();\n    test_list_typefaces_paginates().await.unwrap();\n    test_list_typefaces_no_results_found().await.unwrap();\n    test_list_typefaces_by_name().await.unwrap();\n    test_list_typefaces_by_alias().await.unwrap();\n    test_list_typefaces_by_name_ignores_case().await.unwrap();\n    test_list_typefaces_by_name_substring().await.unwrap();\n    test_list_typefaces_by_slant_range().await.unwrap();\n    test_list_typefaces_by_slant_range_is_inclusive().await.unwrap();\n    test_list_typefaces_by_weight_range().await.unwrap();\n    test_list_typefaces_by_weight_range_is_inclusive().await.unwrap();\n    test_list_typefaces_by_width_range().await.unwrap();\n    test_list_typefaces_by_width_range_is_inclusive().await.unwrap();\n    test_list_typefaces_by_language().await.unwrap();\n    test_list_typefaces_by_code_point().await.unwrap();\n    test_list_typefaces_by_generic_family().await.unwrap();\n"]], "pred": {"ppl": 1.887402892112732, "ppl_lower": 1.887402892112732, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.002861269157343515, "Min_5.0% Prob": 7.284593974842744, "Min_10.0% Prob": 5.414333547864642, "Min_20.0% Prob": 3.142581665941647, "Min_30.0% Prob": 2.115006469119832, "Min_40.0% Prob": 1.593415236103857, "Min_50.0% Prob": 1.270143443064785, "Min_60.0% Prob": 1.060612791921435}}
{"hexsha": "817780f800b9c164339cc9b59c20b35eb047b77d", "ext": "rs", "lang": "Rust", "content": "fn with_less_arguments() {\n            let (output, _) = execute();\n            let stderr = output.stderr.str();\n\n            assert_in!(\n                stderr,\n                \"\n                  |\n                4 | #[rstest(a, b, case(42), case(1, 2), case(43))]\n                  |                     ^^\n                \"\n                .unindent()\n            );\n\n            assert_in!(\n                stderr,\n                \"\n                  |\n                4 | #[rstest(a, b, case(42), case(1, 2), case(43))]\n                  |                                           ^^\n                \"\n                .unindent()\n            );\n        }", "item_id": 16, "repo": "Nukesor/rstest", "file": "tests/rstest/mod.rs", "last_update_at": "2021-07-08T13:33:15+00:00", "question_id": "817780f800b9c164339cc9b59c20b35eb047b77d_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn with_less_arguments() {\n            let (output, _) = execute();\n            let stderr = output.stderr.str();\n            assert_in!(\n                stderr,\n                \"\n                  |\n                4 | #[rstest(a, b, case(42), case(1, 2), case(43))]\n                  |                     ^^\n                \"\n                .unindent()\n            );\n            assert_in!(\n                stderr,\n                \"\n                  |\n                4 | #[rstest(a, b, case(42), case(1, 2), case(43))]\n                  |                                           ^^\n                \"\n                .unindent()\n            );\n"]], "pred": {"ppl": 2.9723000526428223, "ppl_lower": 2.9723000526428223, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0061544411389765725, "Min_5.0% Prob": 7.729721784591675, "Min_10.0% Prob": 6.175229605506448, "Min_20.0% Prob": 4.496144371874192, "Min_30.0% Prob": 3.4343219726693395, "Min_40.0% Prob": 2.6819518659857735, "Min_50.0% Prob": 2.1761824884560217, "Min_60.0% Prob": 1.8253229760284562}}
{"hexsha": "bf2d8cdac64eb055d052bdea920faeebf5f0011b", "ext": "rs", "lang": "Rust", "content": "fn sub() {\n        assert_relative_eq!(\n            Vector::new(3.0, 2.0, 1.0) - Vector::new(5.0, 6.0, 7.0),\n            Vector::new(-2.0, -4.0, -6.0)\n        );\n\n        assert_relative_eq!(\n            Vector::new(0.0, 0.0, 0.0) - Vector::new(1.0, -2.0, 3.0),\n            Vector::new(-1.0, 2.0, -3.0)\n        );\n\n        assert_relative_eq!(\n            Vector::new(0.5, 1.5, 2.8) - &Vector::new(1.0, 1.0, 0.0),\n            Vector::new(-0.5, 0.5, 2.8)\n        );\n\n        assert_relative_eq!(\n            &Vector::new(-4.1, 0.21, 8.5) - Vector::new(1.2, 0.01, 2.0),\n            Vector::new(-5.3, 0.2, 6.5)\n        );\n\n        assert_relative_eq!(\n            &Vector::new(1.0, 2.0, 3.0) - &Vector::new(2.0, 1.0, 0.0),\n            Vector::new(-1.0, 1.0, 3.0)\n        );\n    }", "item_id": 10, "repo": "mpycroft/raytracer", "file": "src/math/vector.rs", "last_update_at": "2021-04-07T08:55:44+00:00", "question_id": "bf2d8cdac64eb055d052bdea920faeebf5f0011b_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn sub() {\n        assert_relative_eq!(\n            Vector::new(3.0, 2.0, 1.0) - Vector::new(5.0, 6.0, 7.0),\n            Vector::new(-2.0, -4.0, -6.0)\n        );\n        assert_relative_eq!(\n            Vector::new(0.0, 0.0, 0.0) - Vector::new(1.0, -2.0, 3.0),\n            Vector::new(-1.0, 2.0, -3.0)\n        );\n        assert_relative_eq!(\n            Vector::new(0.5, 1.5, 2.8) - &Vector::new(1.0, 1.0, 0.0),\n            Vector::new(-0.5, 0.5, 2.8)\n        );\n        assert_relative_eq!(\n            &Vector::new(-4.1, 0.21, 8.5) - Vector::new(1.2, 0.01, 2.0),\n            Vector::new(-5.3, 0.2, 6.5)\n        );\n        assert_relative_eq!(\n            &Vector::new(1.0, 2.0, 3.0) - &Vector::new(2.0, 1.0, 0.0),\n            Vector::new(-1.0, 1.0, 3.0)\n        );\n"]], "pred": {"ppl": 1.6214978694915771, "ppl_lower": 1.658982753753662, "ppl/lowercase_ppl": -1.0472830598867973, "ppl/zlib": 0.0023693643767269687, "Min_5.0% Prob": 5.15282956759135, "Min_10.0% Prob": 3.7069978382852344, "Min_20.0% Prob": 2.2869096867842216, "Min_30.0% Prob": 1.5836955012245613, "Min_40.0% Prob": 1.2079781966717684, "Min_50.0% Prob": 0.9673159109947623, "Min_60.0% Prob": 0.8056547034150836}}
{"hexsha": "da68d7029c23d0b5673233c79d3b20e9295990c0", "ext": "rs", "lang": "Rust", "content": "pub fn run<'a>(args: &ArgMatches<'a>, interfaces: &Interfaces) -> Result<()> {\n    let command = args.subcommand_matches(super::COMMAND).unwrap();\n    let command = command.subcommand_matches(COMMAND).unwrap();\n    let name = command.value_of(\"election\").unwrap();\n    if !command.is_present(\"take-responsibility\") {\n        return Err(ErrorKind::TakeResponsibility.into());\n    }\n\n    let logger = interfaces.logger();\n    let admin = coordinator_admin(args, logger.clone())?;\n    let election = admin\n        .election(name)\n        .with_context(|_| ErrorKind::CoordinatorElectionLookup(name.to_string()))?;\n    let stepped_down = election\n        .step_down()\n        .with_context(|_| ErrorKind::CoordinatorElectionStepDown(name.to_string()))?;\n    if stepped_down {\n        info!(logger, \"Stepped down election\"; \"election\" => name);\n    } else {\n        info!(logger, \"No need to step down election\"; \"election\" => name);\n    }\n\n    Ok(())\n}", "item_id": 0, "repo": "replicante-io/replicante", "file": "bin/repliadm/src/commands/coordinator/step_down_election.rs", "last_update_at": "2021-11-03T11:36:42+00:00", "question_id": "da68d7029c23d0b5673233c79d3b20e9295990c0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn run<'a>(args: &ArgMatches<'a>, interfaces: &Interfaces) -> Result<()> {\n    let command = args.subcommand_matches(super::COMMAND).unwrap();\n    let command = command.subcommand_matches(COMMAND).unwrap();\n    let name = command.value_of(\"election\").unwrap();\n    if !command.is_present(\"take-responsibility\") {\n        return Err(ErrorKind::TakeResponsibility.into());\n    }\n    let logger = interfaces.logger();\n    let admin = coordinator_admin(args, logger.clone())?;\n    let election = admin\n        .election(name)\n        .with_context(|_| ErrorKind::CoordinatorElectionLookup(name.to_string()))?;\n    let stepped_down = election\n        .step_down()\n        .with_context(|_| ErrorKind::CoordinatorElectionStepDown(name.to_string()))?;\n    if stepped_down {\n        info!(logger, \"Stepped down election\"; \"election\" => name);\n    } else {\n        info!(logger, \"No need to step down election\"; \"election\" => name);\n    }\n    Ok(())\n"]], "pred": {"ppl": 2.3396215438842773, "ppl_lower": 3.0530965328216553, "ppl/lowercase_ppl": -1.313141807806229, "ppl/zlib": 0.0020782131611407546, "Min_5.0% Prob": 8.607740981238228, "Min_10.0% Prob": 5.8475277506071945, "Min_20.0% Prob": 3.6559047339291406, "Min_30.0% Prob": 2.68241652949103, "Min_40.0% Prob": 2.0954098949401545, "Min_50.0% Prob": 1.690814928572676, "Min_60.0% Prob": 1.416174824791295}}
{"hexsha": "2ab7e515eb92df9e8370278f8feae066968e7db9", "ext": "rs", "lang": "Rust", "content": "pub async fn get_current_status_for_polling(\n    simulator: SharedSimulator,\n    config: SharedConfig,\n) -> Result<impl warp::Reply, Infallible> {\n    let simulator = simulator.lock().await;\n    let config = config.lock().await;\n    let slot = if simulator.beacon_chain.slot == 0 {\n        None\n    } else {\n        Some(simulator.beacon_chain.slot - 1)\n    };\n    Ok(warp::reply::json(&CurrentStatusForPolling {\n        slot,\n        config: config.config.clone(),\n    }))\n}", "item_id": 0, "repo": "ethereum-mousse/mousse", "file": "http_api/src/endpoints/utils.rs", "last_update_at": "2021-06-14T08:02:29+00:00", "question_id": "2ab7e515eb92df9e8370278f8feae066968e7db9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn get_current_status_for_polling(\n    simulator: SharedSimulator,\n    config: SharedConfig,\n) -> Result<impl warp::Reply, Infallible> {\n    let simulator = simulator.lock().await;\n    let config = config.lock().await;\n    let slot = if simulator.beacon_chain.slot == 0 {\n        None\n    } else {\n        Some(simulator.beacon_chain.slot - 1)\n    };\n    Ok(warp::reply::json(&CurrentStatusForPolling {\n        slot,\n        config: config.config.clone(),\n    }))\n"]], "pred": {"ppl": 2.5902087688446045, "ppl_lower": 3.8922672271728516, "ppl/lowercase_ppl": -1.4279046752160907, "ppl/zlib": 0.003703262561068041, "Min_5.0% Prob": 8.940905911581856, "Min_10.0% Prob": 6.444276666641235, "Min_20.0% Prob": 4.13611029424975, "Min_30.0% Prob": 3.02813495220022, "Min_40.0% Prob": 2.3549031258102446, "Min_50.0% Prob": 1.9045187274489221, "Min_60.0% Prob": 1.5903167189540048}}
{"hexsha": "b0de9a620a833c48304e5ef6e6069bc9b3d0a515", "ext": "rs", "lang": "Rust", "content": "fn cancel_pledge(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    contract_info: ContractInfo,\n    id: String,\n) -> Result<Response<ProvenanceMsg>, ContractError> {\n    // locate the pledge\n    let mut pledge = load_pledge(deps.storage, id.as_bytes())?;\n\n    // only pledges that are in the \"PROPOSED\" or \"ACCEPTED\" states can be cancelled\n    let remove_assets_from_escrow = true;\n    let mut remove_advance_from_escrow = false;\n    match pledge.state {\n        PledgeState::Proposed => {}\n        PledgeState::Accepted => {\n            remove_advance_from_escrow = true;\n        }\n        _ => {\n            return Err(ContractError::StateError {\n                error:\n                    \"Unable to cancel pledge: Pledge is not in the 'proposed' or 'accepted' state.\"\n                        .into(),\n            })\n        }\n    }\n\n    // ensure the contract has privs on the escrow marker\n    let querier = ProvenanceQuerier::new(&deps.querier);\n    let escrow_marker =\n        querier.get_marker_by_address(contract_info.facility.escrow_marker.clone())?;\n    if !marker_has_grant(\n        escrow_marker.clone(),\n        AccessGrant {\n            address: env.contract.address,\n            permissions: vec![MarkerAccess::Transfer, MarkerAccess::Withdraw],\n        },\n    ) {\n        return Err(ContractError::MissingEscrowMarkerGrant {});\n    }\n\n    // messages to include in transaction\n    let mut messages = Vec::new();\n\n    // remove the advance from escrow back to the warehouse account\n    if remove_advance_from_escrow {\n        // withdraw advance funds from the escrow marker account to the warehouse\n        messages.push(withdraw_coins(\n            escrow_marker.denom,\n            pledge.total_advance.into(),\n            contract_info.facility.stablecoin_denom.clone(),\n            contract_info.facility.warehouse,\n        )?);\n    }\n\n    // remove the assets (asset marker) from escrow\n    if remove_assets_from_escrow {\n        let asset_marker = querier.get_marker_by_denom(pledge.asset_marker_denom.clone())?;\n\n        // transfer the asset marker back to the marker supply\n        messages.push(transfer_marker_coins(\n            1,\n            pledge.asset_marker_denom.clone(),\n            asset_marker.address,\n            contract_info.facility.originator,\n        )?);\n\n        // cancel the asset marker\n        messages.push(cancel_marker(pledge.asset_marker_denom.clone())?);\n\n        // destroy the asset marker\n        messages.push(destroy_marker(pledge.asset_marker_denom.clone())?);\n    }\n\n    // update the pledge\n    pledge.state = PledgeState::Cancelled;\n    save_pledge(deps.storage, &pledge.id.as_bytes(), &pledge)?;\n\n    // remove the assets from the inventory\n    remove_assets(deps.storage, &pledge.assets)?;\n\n    Ok(Response::new()\n        .add_messages(messages)\n        .add_attribute(\"action\", \"cancel_pledge\")\n        .set_data(to_binary(&pledge)?))\n}", "item_id": 5, "repo": "provenance-io/warehouse-facility", "file": "src/contract.rs", "last_update_at": "2021-07-15T20:15:41+00:00", "question_id": "b0de9a620a833c48304e5ef6e6069bc9b3d0a515_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn cancel_pledge(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    contract_info: ContractInfo,\n    id: String,\n) -> Result<Response<ProvenanceMsg>, ContractError> {\n    // locate the pledge\n    let mut pledge = load_pledge(deps.storage, id.as_bytes())?;\n    // only pledges that are in the \"PROPOSED\" or \"ACCEPTED\" states can be cancelled\n    let remove_assets_from_escrow = true;\n    let mut remove_advance_from_escrow = false;\n    match pledge.state {\n        PledgeState::Proposed => {}\n        PledgeState::Accepted => {\n            remove_advance_from_escrow = true;\n        }\n        _ => {\n            return Err(ContractError::StateError {\n                error:\n                    \"Unable to cancel pledge: Pledge is not in the 'proposed' or 'accepted' state.\"\n                        .into(),\n            })\n        }\n    }\n    // ensure the contract has privs on the escrow marker\n    let querier = ProvenanceQuerier::new(&deps.querier);\n    let escrow_marker =\n        querier.get_marker_by_address(contract_info.facility.escrow_marker.clone())?;\n    if !marker_has_grant(\n        escrow_marker.clone(),\n        AccessGrant {\n            address: env.contract.address,\n            permissions: vec![MarkerAccess::Transfer, MarkerAccess::Withdraw],\n        },\n    ) {\n        return Err(ContractError::MissingEscrowMarkerGrant {});\n    }\n    // messages to include in transaction\n    let mut messages = Vec::new();\n    // remove the advance from escrow back to the warehouse account\n    if remove_advance_from_escrow {\n        // withdraw advance funds from the escrow marker account to the warehouse\n        messages.push(withdraw_coins(\n            escrow_marker.denom,\n            pledge.total_advance.into(),\n            contract_info.facility.stablecoin_denom.clone(),\n            contract_info.facility.warehouse,\n        )?);\n    }\n    // remove the assets (asset marker) from escrow\n    if remove_assets_from_escrow {\n        let asset_marker = querier.get_marker_by_denom(pledge.asset_marker_denom.clone())?;\n        // transfer the asset marker back to the marker supply\n        messages.push(transfer_marker_coins(\n            1,\n            pledge.asset_marker_denom.clone(),\n            asset_marker.address,\n            contract_info.facility.originator,\n        )?);\n        // cancel the asset marker\n        messages.push(cancel_marker(pledge.asset_marker_denom.clone())?);\n        // destroy the asset marker\n        messages.push(destroy_marker(pledge.asset_marker_denom.clone())?);\n    }\n    // update the pledge\n    pledge.state = PledgeState::Cancelled;\n    save_pledge(deps.storage, &pledge.id.as_bytes(), &pledge)?;\n    // remove the assets from the inventory\n    remove_assets(deps.storage, &pledge.assets)?;\n    Ok(Response::new()\n        .add_messages(messages)\n        .add_attribute(\"action\", \"cancel_pledge\")\n        .set_data(to_binary(&pledge)?))\n"]], "pred": {"ppl": 2.124083995819092, "ppl_lower": 2.3977291584014893, "ppl/lowercase_ppl": -1.1608587788336775, "ppl/zlib": 0.0007663689202970032, "Min_5.0% Prob": 7.095703255046498, "Min_10.0% Prob": 5.121829552596875, "Min_20.0% Prob": 3.2933013782154914, "Min_30.0% Prob": 2.4039939808756556, "Min_40.0% Prob": 1.8582313062425433, "Min_50.0% Prob": 1.5037098839562344, "Min_60.0% Prob": 1.2546297565962794}}
{"hexsha": "724e611de9e88635228c56c6186dfa0e2e2d1560", "ext": "rs", "lang": "Rust", "content": "fn read_bytes_size<R: Read>(reader: &mut R, size: &usize) -> Result<Vec<u8>> {\n    let mut data = vec![0; *size];\n    reader.read(&mut data)?;\n    Ok(data)\n}", "item_id": 8, "repo": "Ghosty141/rust-kpdb", "file": "src/format/kdb2_reader.rs", "last_update_at": "2021-02-25T06:44:26+00:00", "question_id": "724e611de9e88635228c56c6186dfa0e2e2d1560_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn read_bytes_size<R: Read>(reader: &mut R, size: &usize) -> Result<Vec<u8>> {\n    let mut data = vec![0; *size];\n    reader.read(&mut data)?;\n    Ok(data)\n"]], "pred": {"ppl": 2.2998673915863037, "ppl_lower": 4.5478515625, "ppl/lowercase_ppl": -1.8186375365036855, "ppl/zlib": 0.0065578855546527615, "Min_5.0% Prob": 7.444540500640869, "Min_10.0% Prob": 5.612832307815552, "Min_20.0% Prob": 3.7706160147984824, "Min_30.0% Prob": 2.736461748679479, "Min_40.0% Prob": 2.0549543154239656, "Min_50.0% Prob": 1.677969976538612, "Min_60.0% Prob": 1.4142421228257385}}
{"hexsha": "632a7b7123a5f5b5b6a80f8cccc5257a0dceb4b9", "ext": "rs", "lang": "Rust", "content": "pub fn app(app: &App) -> parse::Result<()> {\n    // in single-core context no static should use the `#[global]` attribute\n    if app.cores == 1 {\n        let main = &app.mains[0];\n        for (name, static_) in main\n            .init\n            .iter()\n            .flat_map(|init| &init.statics)\n            .chain(main.idle.iter().flat_map(|idle| &idle.statics))\n            .chain(app.tasks.values().flat_map(|task| &task.statics))\n        {\n            if static_.global {\n                return Err(parse::Error::new(\n                    name.span(),\n                    \"statics can NOT be marked as `#[global]` in single-core applications\",\n                ));\n            }\n        }\n    }\n\n    for (name, static_) in app.tasks.values().flat_map(|task| &task.statics) {\n        if static_.global {\n            return Err(parse::Error::new(\n                name.span(),\n                \"statics within a `#[task]` can NOT be marked as `#[global]`\",\n            ));\n        }\n    }\n\n    // Check that all referenced resources have been declared and that `static mut` resources are\n    // *not* shared between cores\n    let mut mut_resources = HashMap::new();\n    for (core, name) in\n        app.mains\n            .iter()\n            .zip(0..)\n            .flat_map(move |(main, core)| {\n                main.init\n                    .iter()\n                    .flat_map(move |init| init.args.resources.iter().map(move |res| (core, res)))\n                    .chain(main.idle.iter().flat_map(move |idle| {\n                        idle.args.resources.iter().map(move |res| (core, res))\n                    }))\n            })\n            .chain(app.interrupts.values().flat_map(|interrupt| {\n                let core = interrupt.args.core;\n                interrupt.args.resources.iter().map(move |res| (core, res))\n            }))\n            .chain(app.tasks.values().flat_map(|task| {\n                let core = task.args.core;\n                task.args.resources.iter().map(move |res| (core, res))\n            }))\n    {\n        let span = name.span();\n        if let Some(res) = app.resources.get(name) {\n            if res.mutability.is_some() {\n                match mut_resources.entry(name) {\n                    Entry::Occupied(entry) => {\n                        if *entry.get() != core {\n                            return Err(parse::Error::new(\n                                span,\n                                \"`static mut` resources can NOT be accessed from different cores\",\n                            ));\n                        }\n                    }\n                    Entry::Vacant(entry) => {\n                        entry.insert(core);\n                    }\n                }\n            }\n        } else {\n            return Err(parse::Error::new(\n                span,\n                \"this resource has NOT been declared\",\n            ));\n        }\n    }\n\n    for init in app.mains.iter().filter_map(|main| main.init.as_ref()) {\n        // Check that late resources have not been assigned to `init`\n        for res in &init.args.resources {\n            if app.resources.get(res).unwrap().expr.is_none() {\n                return Err(parse::Error::new(\n                    res.span(),\n                    \"late resources can NOT be assigned to `init`\",\n                ));\n            }\n        }\n    }\n\n    // Check that all late resources are covered by `init::LateResources`\n    let mut late_resources = app\n        .resources\n        .iter()\n        .filter_map(|(name, res)| if res.expr.is_none() { Some(name) } else { None })\n        .collect::<HashSet<_>>();\n    if !late_resources.is_empty() {\n        if app.cores == 1 {\n            // the only core will initialize all late resources\n        } else {\n            // this core will initialize the \"rest\" of late resources\n            let mut rest = None;\n\n            let mut initialized = HashMap::new();\n            for (core, init) in app.mains.iter().enumerate().filter_map(|(i, main)| {\n                if let Some(init) = main.init.as_ref() {\n                    if init.returns_late_resources {\n                        Some((i, init))\n                    } else {\n                        None\n                    }\n                } else {\n                    None\n                }\n            }) {\n                if !init.args.late.is_empty() {\n                    for res in &init.args.late {\n                        if !late_resources.contains(&res) {\n                            return Err(parse::Error::new(\n                                res.span(),\n                                \"this is not a late resource\",\n                            ));\n                        }\n\n                        if let Some(other) = initialized.get(res) {\n                            return Err(parse::Error::new(\n                                res.span(),\n                                &format!(\"this resource will be initialized by core {}\", other),\n                            ));\n                        } else {\n                            late_resources.remove(res);\n                            initialized.insert(res, core);\n                        }\n                    }\n                } else if let Some(rest) = rest {\n                    return Err(parse::Error::new(\n                        Span::call_site(),\n                        &format!(\n                            \"unclear how initialization of late resources is split between \\\n                             cores {} and {}\",\n                            rest, core,\n                        ),\n                    ));\n                } else {\n                    rest = Some(core);\n                }\n            }\n\n            if let Some(res) = late_resources.iter().next() {\n                if rest.is_none() {\n                    return Err(parse::Error::new(\n                        res.span(),\n                        \"this resource is not being initialized\",\n                    ));\n                }\n            }\n        }\n    }\n\n    // Check that all referenced tasks have been declared\n    for task in app\n        .mains\n        .iter()\n        .flat_map(|main| {\n            main.init\n                .iter()\n                .flat_map(|init| &init.args.spawn)\n                .chain(main.idle.iter().flat_map(|idle| &idle.args.spawn))\n        })\n        .chain(\n            app.interrupts\n                .values()\n                .flat_map(|interrupt| &interrupt.args.spawn),\n        )\n        .chain(app.tasks.values().flat_map(|task| &task.args.spawn))\n    {\n        if !app.tasks.contains_key(task) {\n            return Err(parse::Error::new(\n                task.span(),\n                \"this task has NOT been declared\",\n            ));\n        }\n    }\n\n    // Check that there are enough dispatchers to handle all priority levels\n    for core in 0..app.cores {\n        let ndispatchers = app\n            .tasks\n            .values()\n            .filter_map(|task| {\n                if task.args.core == core {\n                    Some(task.args.priority)\n                } else {\n                    None\n                }\n            })\n            .collect::<HashSet<_>>()\n            .len();\n\n        let used_sgis = app\n            .interrupts\n            .keys()\n            .filter(|name| {\n                let name = name.to_string();\n\n                name.starts_with(\"SG\")\n                    && name[2..].parse::<u8>().map(|n| n < NSGIS).unwrap_or(false)\n            })\n            .count();\n\n        if ndispatchers + usize::from(used_sgis) > usize::from(NSGIS) {\n            return Err(parse::Error::new(\n                Span::call_site(),\n                \"Not enough free Software-Generated Interrupts (SGI) to \\\n                 dispatch all task priorities\",\n            ));\n        }\n    }\n\n    Ok(())\n}", "item_id": 0, "repo": "japaric/ultrascale-plus", "file": "firmware/zup-rtfm/macros/src/check.rs", "last_update_at": "2021-12-31T13:50:22+00:00", "question_id": "632a7b7123a5f5b5b6a80f8cccc5257a0dceb4b9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn app(app: &App) -> parse::Result<()> {\n    // in single-core context no static should use the `#[global]` attribute\n    if app.cores == 1 {\n        let main = &app.mains[0];\n        for (name, static_) in main\n            .init\n            .iter()\n            .flat_map(|init| &init.statics)\n            .chain(main.idle.iter().flat_map(|idle| &idle.statics))\n            .chain(app.tasks.values().flat_map(|task| &task.statics))\n        {\n            if static_.global {\n                return Err(parse::Error::new(\n                    name.span(),\n                    \"statics can NOT be marked as `#[global]` in single-core applications\",\n                ));\n            }\n        }\n    }\n    for (name, static_) in app.tasks.values().flat_map(|task| &task.statics) {\n        if static_.global {\n            return Err(parse::Error::new(\n                name.span(),\n                \"statics within a `#[task]` can NOT be marked as `#[global]`\",\n            ));\n        }\n    }\n    // Check that all referenced resources have been declared and that `static mut` resources are\n    // *not* shared between cores\n    let mut mut_resources = HashMap::new();\n    for (core, name) in\n        app.mains\n            .iter()\n            .zip(0..)\n            .flat_map(move |(main, core)| {\n                main.init\n                    .iter()\n                    .flat_map(move |init| init.args.resources.iter().map(move |res| (core, res)))\n                    .chain(main.idle.iter().flat_map(move |idle| {\n                        idle.args.resources.iter().map(move |res| (core, res))\n                    }))\n            })\n            .chain(app.interrupts.values().flat_map(|interrupt| {\n                let core = interrupt.args.core;\n                interrupt.args.resources.iter().map(move |res| (core, res))\n            }))\n            .chain(app.tasks.values().flat_map(|task| {\n                let core = task.args.core;\n                task.args.resources.iter().map(move |res| (core, res))\n            }))\n    {\n        let span = name.span();\n        if let Some(res) = app.resources.get(name) {\n            if res.mutability.is_some() {\n                match mut_resources.entry(name) {\n                    Entry::Occupied(entry) => {\n                        if *entry.get() != core {\n                            return Err(parse::Error::new(\n                                span,\n                                \"`static mut` resources can NOT be accessed from different cores\",\n                            ));\n                        }\n                    }\n                    Entry::Vacant(entry) => {\n                        entry.insert(core);\n                    }\n                }\n            }\n        } else {\n            return Err(parse::Error::new(\n                span,\n                \"this resource has NOT been declared\",\n            ));\n        }\n    }\n    for init in app.mains.iter().filter_map(|main| main.init.as_ref()) {\n        // Check that late resources have not been assigned to `init`\n        for res in &init.args.resources {\n            if app.resources.get(res).unwrap().expr.is_none() {\n                return Err(parse::Error::new(\n                    res.span(),\n                    \"late resources can NOT be assigned to `init`\",\n                ));\n            }\n        }\n    }\n    // Check that all late resources are covered by `init::LateResources`\n    let mut late_resources = app\n        .resources\n        .iter()\n        .filter_map(|(name, res)| if res.expr.is_none() { Some(name) } else { None })\n        .collect::<HashSet<_>>();\n    if !late_resources.is_empty() {\n        if app.cores == 1 {\n            // the only core will initialize all late resources\n        } else {\n            // this core will initialize the \"rest\" of late resources\n            let mut rest = None;\n            let mut initialized = HashMap::new();\n            for (core, init) in app.mains.iter().enumerate().filter_map(|(i, main)| {\n                if let Some(init) = main.init.as_ref() {\n                    if init.returns_late_resources {\n                        Some((i, init))\n                    } else {\n                        None\n                    }\n                } else {\n                    None\n                }\n            }) {\n                if !init.args.late.is_empty() {\n                    for res in &init.args.late {\n                        if !late_resources.contains(&res) {\n                            return Err(parse::Error::new(\n                                res.span(),\n                                \"this is not a late resource\",\n                            ));\n                        }\n                        if let Some(other) = initialized.get(res) {\n                            return Err(parse::Error::new(\n                                res.span(),\n                                &format!(\"this resource will be initialized by core {}\", other),\n                            ));\n                        } else {\n                            late_resources.remove(res);\n                            initialized.insert(res, core);\n                        }\n                    }\n                } else if let Some(rest) = rest {\n                    return Err(parse::Error::new(\n                        Span::call_site(),\n                        &format!(\n                            \"unclear how initialization of late resources is split between \\\n                             cores {} and {}\",\n                            rest, core,\n                        ),\n                    ));\n                } else {\n                    rest = Some(core);\n                }\n            }\n            if let Some(res) = late_resources.iter().next() {\n                if rest.is_none() {\n                    return Err(parse::Error::new(\n                        res.span(),\n                        \"this resource is not being initialized\",\n                    ));\n                }\n            }\n        }\n    }\n    // Check that all referenced tasks have been declared\n    for task in app\n        .mains\n        .iter()\n        .flat_map(|main| {\n            main.init\n                .iter()\n                .flat_map(|init| &init.args.spawn)\n                .chain(main.idle.iter().flat_map(|idle| &idle.args.spawn))\n        })\n        .chain(\n            app.interrupts\n                .values()\n                .flat_map(|interrupt| &interrupt.args.spawn),\n        )\n        .chain(app.tasks.values().flat_map(|task| &task.args.spawn))\n    {\n        if !app.tasks.contains_key(task) {\n            return Err(parse::Error::new(\n                task.span(),\n                \"this task has NOT been declared\",\n            ));\n        }\n    }\n    // Check that there are enough dispatchers to handle all priority levels\n    for core in 0..app.cores {\n        let ndispatchers = app\n            .tasks\n            .values()\n            .filter_map(|task| {\n                if task.args.core == core {\n                    Some(task.args.priority)\n                } else {\n                    None\n                }\n            })\n            .collect::<HashSet<_>>()\n            .len();\n        let used_sgis = app\n            .interrupts\n            .keys()\n            .filter(|name| {\n                let name = name.to_string();\n                name.starts_with(\"SG\")\n                    && name[2..].parse::<u8>().map(|n| n < NSGIS).unwrap_or(false)\n            })\n            .count();\n        if ndispatchers + usize::from(used_sgis) > usize::from(NSGIS) {\n            return Err(parse::Error::new(\n                Span::call_site(),\n                \"Not enough free Software-Generated Interrupts (SGI) to \\\n                 dispatch all task priorities\",\n            ));\n        }\n    }\n    Ok(())\n"]], "pred": {"ppl": 1.8494594097137451, "ppl_lower": 1.9788832664489746, "ppl/lowercase_ppl": -1.1100016603391367, "ppl/zlib": 0.0003365590505871632, "Min_5.0% Prob": 6.444807220907772, "Min_10.0% Prob": 4.550226267646341, "Min_20.0% Prob": 2.845223421559614, "Min_30.0% Prob": 2.0084265725188004, "Min_40.0% Prob": 1.52834169632211, "Min_50.0% Prob": 1.2289544197561224, "Min_60.0% Prob": 1.0257678525754041}}
{"hexsha": "204423cefd0862560f3654e60e0bb8c5b60d4e02", "ext": "rs", "lang": "Rust", "content": "fn test_sin_cos() -> Result<()> {\n    let mut g = Graph::new();\n    let x0: f32 = 1.234;\n    let x = g.scalar(\"x\", x0)?;\n    let s = g.sin(x);\n    let ss = g.square(s);\n    let c = g.cos(x);\n    let cc = g.square(c);\n    let z = g.add(ss, cc);\n    abs_diff_eq!(g.eval_value(z)?.as_scalar()?, 1.0);\n    g.eval_deriv(z)?;\n    abs_diff_eq!(g.get_deriv(x)?.as_scalar()?, 0.0);\n    Ok(())\n}", "item_id": 5, "repo": "termoshtt/cagra", "file": "cagra/tests/math.rs", "last_update_at": "2021-09-18T21:13:26+00:00", "question_id": "204423cefd0862560f3654e60e0bb8c5b60d4e02_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_sin_cos() -> Result<()> {\n    let mut g = Graph::new();\n    let x0: f32 = 1.234;\n    let x = g.scalar(\"x\", x0)?;\n    let s = g.sin(x);\n    let ss = g.square(s);\n    let c = g.cos(x);\n    let cc = g.square(c);\n    let z = g.add(ss, cc);\n    abs_diff_eq!(g.eval_value(z)?.as_scalar()?, 1.0);\n    g.eval_deriv(z)?;\n    abs_diff_eq!(g.get_deriv(x)?.as_scalar()?, 0.0);\n    Ok(())\n"]], "pred": {"ppl": 2.2314810752868652, "ppl_lower": 2.5073249340057373, "ppl/lowercase_ppl": -1.1452048127128722, "ppl/zlib": 0.003840504901135388, "Min_5.0% Prob": 6.724445872836643, "Min_10.0% Prob": 4.946388125419617, "Min_20.0% Prob": 3.3029187885490625, "Min_30.0% Prob": 2.4593332186341286, "Min_40.0% Prob": 1.943898210922877, "Min_50.0% Prob": 1.586208611092669, "Min_60.0% Prob": 1.3346583276195865}}
{"hexsha": "5a0f3405fa55b1352b084e2eb9f6b11d7be30d7b", "ext": "rs", "lang": "Rust", "content": "fn remove_should_remove_empty_value_nested_in_table() {\n        let mut inner = toml::value::Table::new();\n        inner.insert(\n            String::from(\"key\"),\n            toml::Value::Table(toml::value::Table::new()),\n        );\n\n        let mut outer = toml::value::Table::new();\n        outer.insert(String::from(\"inner\"), toml::Value::Table(inner));\n\n        let mut value = toml::Value::Table(outer);\n        remove(&mut value);\n\n        let empty_table = toml::Value::Table(toml::value::Table::new());\n        assert_eq!(value, empty_table);\n    }", "item_id": 4, "repo": "hannobraun/my-boss", "file": "src/util/toml/empty_values.rs", "last_update_at": "2021-06-11T23:56:01+00:00", "question_id": "5a0f3405fa55b1352b084e2eb9f6b11d7be30d7b_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn remove_should_remove_empty_value_nested_in_table() {\n        let mut inner = toml::value::Table::new();\n        inner.insert(\n            String::from(\"key\"),\n            toml::Value::Table(toml::value::Table::new()),\n        );\n        let mut outer = toml::value::Table::new();\n        outer.insert(String::from(\"inner\"), toml::Value::Table(inner));\n        let mut value = toml::Value::Table(outer);\n        remove(&mut value);\n        let empty_table = toml::Value::Table(toml::value::Table::new());\n        assert_eq!(value, empty_table);\n"]], "pred": {"ppl": 1.9681483507156372, "ppl_lower": 2.351732015609741, "ppl/lowercase_ppl": -1.2629754859978275, "ppl/zlib": 0.0032396802739244972, "Min_5.0% Prob": 7.199440598487854, "Min_10.0% Prob": 5.296807289123535, "Min_20.0% Prob": 3.161854023283178, "Min_30.0% Prob": 2.213638253211975, "Min_40.0% Prob": 1.702715719457377, "Min_50.0% Prob": 1.3599816968395229, "Min_60.0% Prob": 1.1302085178019479}}
{"hexsha": "f5e40706ee9a570e9d2c950b70d658b4e594819c", "ext": "rs", "lang": "Rust", "content": "fn unique_directive() {\n    let dml = r#\"\n        model Test {\n            id Int @id\n            unique String @unique\n        }\n    \"#;\n\n    let schema = parse(dml);\n    let test_model = schema.assert_has_model(\"Test\");\n\n    test_model\n        .assert_has_field(\"id\")\n        .assert_base_type(&PrismaType::Int)\n        .assert_is_unique(false)\n        .assert_is_id(true);\n    test_model\n        .assert_has_field(\"unique\")\n        .assert_base_type(&PrismaType::String)\n        .assert_is_unique(true);\n}", "item_id": 1, "repo": "williamluke4/prisma-engine", "file": "libs/datamodel/tests/directives/builtin_directives.rs", "last_update_at": "2021-01-29T11:00:35+00:00", "question_id": "f5e40706ee9a570e9d2c950b70d658b4e594819c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn unique_directive() {\n    let dml = r#\"\n        model Test {\n            id Int @id\n            unique String @unique\n        }\n    \"#;\n    let schema = parse(dml);\n    let test_model = schema.assert_has_model(\"Test\");\n    test_model\n        .assert_has_field(\"id\")\n        .assert_base_type(&PrismaType::Int)\n        .assert_is_unique(false)\n        .assert_is_id(true);\n    test_model\n        .assert_has_field(\"unique\")\n        .assert_base_type(&PrismaType::String)\n        .assert_is_unique(true);\n"]], "pred": {"ppl": 1.6464807987213135, "ppl_lower": 2.044804573059082, "ppl/lowercase_ppl": -1.4345058375457909, "ppl/zlib": 0.002341033619203621, "Min_5.0% Prob": 5.588661372661591, "Min_10.0% Prob": 3.9094904214143753, "Min_20.0% Prob": 2.3718624277548357, "Min_30.0% Prob": 1.6459987360239028, "Min_40.0% Prob": 1.2445865802244465, "Min_50.0% Prob": 0.9964860378143688, "Min_60.0% Prob": 0.8375888640567427}}
{"hexsha": "c7ede2142c618cfc3b5701899ed3a38cef74804b", "ext": "rs", "lang": "Rust", "content": "fn get_boolean() {\r\n        let jvm = JVM.lock().unwrap();\r\n        let env = jvm.attach_current_thread().unwrap();\r\n\r\n        let boolean = Object::new_boolean_object(&env, true).unwrap();\r\n        let value = boolean.get_boolean().unwrap();\r\n\r\n        assert_eq!(true, value);\r\n    }", "item_id": 21, "repo": "TheDutchMC/eJNI", "file": "src/object.rs", "last_update_at": "2021-12-05T23:23:42+00:00", "question_id": "c7ede2142c618cfc3b5701899ed3a38cef74804b_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_boolean() {\r\n        let jvm = JVM.lock().unwrap();\r\n        let env = jvm.attach_current_thread().unwrap();\r\n\r\n        let boolean = Object::new_boolean_object(&env, true).unwrap();\r\n        let value = boolean.get_boolean().unwrap();\r\n\r\n        assert_eq!(true, value);\r\n"]], "pred": {"ppl": 2.9799914360046387, "ppl_lower": 3.2092294692993164, "ppl/lowercase_ppl": -1.0678716499024445, "ppl/zlib": 0.006867424067227904, "Min_5.0% Prob": 8.349577069282532, "Min_10.0% Prob": 6.692018568515778, "Min_20.0% Prob": 4.49149864166975, "Min_30.0% Prob": 3.369637578725815, "Min_40.0% Prob": 2.62056784918814, "Min_50.0% Prob": 2.1736085956416478, "Min_60.0% Prob": 1.8411245572627808}}
{"hexsha": "a1ee9c5339e44a345a945f02fc233658c7c9a685", "ext": "rs", "lang": "Rust", "content": "pub fn parse_binary(input: &[u8]) -> Result<Module, ParseError> {\n    let mut builder = Module::builder();\n\n    let (input, _) = tuple((tag(PREAMBLE), tag(VERSION)))(input)?;\n\n    let (input, custom_sections) =\n        parse_custom_section(input).map_err(|_| ParseError::InvalidBinary)?;\n    builder.set_custom_sections(ModuleSection::Custom, custom_sections);\n\n    let (input, types) = parse_type_section(input)?;\n    builder.set_function_types(types);\n\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Type, custom_sections);\n\n    let (input, imports) = parse_import_section(input)?;\n    builder.set_imports(imports);\n\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Import, custom_sections);\n\n    let (input, signatures) = parse_function_section(input)?;\n\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Function, custom_sections);\n\n    let (input, tables) = parse_table_section(input)?;\n    builder.set_tables(tables);\n\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Table, custom_sections);\n\n    let (input, memories) = parse_memory_section(input)?;\n    builder.set_memories(memories);\n\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Memory, custom_sections);\n\n    let (input, globals) = parse_global_section(input)?;\n    builder.set_globals(globals);\n\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Global, custom_sections);\n\n    let (input, exports) = parse_export_section(input)?;\n    builder.set_exports(exports);\n\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Export, custom_sections);\n\n    let (input, start) = parse_start_section(input)?;\n    builder.set_start(start);\n\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Start, custom_sections);\n\n    let (input, elements) = parse_element_section(input)?;\n    builder.set_elements(elements);\n\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Element, custom_sections);\n\n    let (input, data_count) = parse_data_count_section(input)?;\n    builder.set_data_count(data_count);\n\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::DataCount, custom_sections);\n\n    let (input, codes) = parse_code_section(input)?;\n\n    validate_function_counts(codes.as_ref(), signatures.as_ref())?;\n\n    builder.set_functions(zip_functions(signatures, codes));\n\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Code, custom_sections);\n\n    let (input, data) = parse_data_section(input)?;\n    builder.set_data(data);\n\n    let (_, custom_sections) = all_consuming(parse_custom_section)(input)?;\n    builder.set_custom_sections(ModuleSection::Data, custom_sections);\n\n    Ok(builder.build())\n}", "item_id": 0, "repo": "al3xfischer/wasm-ast", "file": "src/parser/mod.rs", "last_update_at": "2021-12-21T17:33:18+00:00", "question_id": "a1ee9c5339e44a345a945f02fc233658c7c9a685_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn parse_binary(input: &[u8]) -> Result<Module, ParseError> {\n    let mut builder = Module::builder();\n    let (input, _) = tuple((tag(PREAMBLE), tag(VERSION)))(input)?;\n    let (input, custom_sections) =\n        parse_custom_section(input).map_err(|_| ParseError::InvalidBinary)?;\n    builder.set_custom_sections(ModuleSection::Custom, custom_sections);\n    let (input, types) = parse_type_section(input)?;\n    builder.set_function_types(types);\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Type, custom_sections);\n    let (input, imports) = parse_import_section(input)?;\n    builder.set_imports(imports);\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Import, custom_sections);\n    let (input, signatures) = parse_function_section(input)?;\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Function, custom_sections);\n    let (input, tables) = parse_table_section(input)?;\n    builder.set_tables(tables);\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Table, custom_sections);\n    let (input, memories) = parse_memory_section(input)?;\n    builder.set_memories(memories);\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Memory, custom_sections);\n    let (input, globals) = parse_global_section(input)?;\n    builder.set_globals(globals);\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Global, custom_sections);\n    let (input, exports) = parse_export_section(input)?;\n    builder.set_exports(exports);\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Export, custom_sections);\n    let (input, start) = parse_start_section(input)?;\n    builder.set_start(start);\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Start, custom_sections);\n    let (input, elements) = parse_element_section(input)?;\n    builder.set_elements(elements);\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Element, custom_sections);\n    let (input, data_count) = parse_data_count_section(input)?;\n    builder.set_data_count(data_count);\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::DataCount, custom_sections);\n    let (input, codes) = parse_code_section(input)?;\n    validate_function_counts(codes.as_ref(), signatures.as_ref())?;\n    builder.set_functions(zip_functions(signatures, codes));\n    let (input, custom_sections) = parse_custom_section(input)?;\n    builder.set_custom_sections(ModuleSection::Code, custom_sections);\n    let (input, data) = parse_data_section(input)?;\n    builder.set_data(data);\n    let (_, custom_sections) = all_consuming(parse_custom_section)(input)?;\n    builder.set_custom_sections(ModuleSection::Data, custom_sections);\n    Ok(builder.build())\n"]], "pred": {"ppl": 1.2943522930145264, "ppl_lower": 1.35445237159729, "ppl/lowercase_ppl": -1.1759107650224991, "ppl/zlib": 0.000468258457705093, "Min_5.0% Prob": 4.089389051709857, "Min_10.0% Prob": 2.4103261623719727, "Min_20.0% Prob": 1.280095006297132, "Min_30.0% Prob": 0.8582634398757315, "Min_40.0% Prob": 0.6446496114761505, "Min_50.0% Prob": 0.5158649181789869, "Min_60.0% Prob": 0.4305534104537842}}
{"hexsha": "12c68000f059d750bdc7054c06e8fb0224a2c7a4", "ext": "rs", "lang": "Rust", "content": "fn degrees_to_radian() { \n        let deg = 80_f32; \n        let rad = to_radian(deg); \n       \n        assert_eq!(1.3962634, rad);\n    }", "item_id": 2, "repo": "DrAirRock/gl-matrix", "file": "src/common.rs", "last_update_at": "2021-05-30T21:20:41+00:00", "question_id": "12c68000f059d750bdc7054c06e8fb0224a2c7a4_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn degrees_to_radian() { \n        let deg = 80_f32; \n        let rad = to_radian(deg); \n        assert_eq!(1.3962634, rad);\n"]], "pred": {"ppl": 5.110781669616699, "ppl_lower": 5.110781669616699, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.017354812352456842, "Min_5.0% Prob": 9.537266731262207, "Min_10.0% Prob": 7.47876501083374, "Min_20.0% Prob": 5.64597749710083, "Min_30.0% Prob": 4.568051430914137, "Min_40.0% Prob": 3.7327459305524826, "Min_50.0% Prob": 3.1162453373273213, "Min_60.0% Prob": 2.6500430934958987}}
{"hexsha": "978be39012e1ca76564e01a7765b90975267bed7", "ext": "rs", "lang": "Rust", "content": "fn main () {\n    // Use clap for command-line argument parsing.\n    let matches = App::new(\"owl\")\n        .author(\"Alex Eubanks <endeavor@rainbowsandpwnies.com>\")\n        .about(\"ROP Gadget Finder\")\n        .arg(Arg::with_name(\"filter\")\n            .short(\"f\")\n            .value_name(\"filter\")\n            .help(\"Filter rop gadgets by substring\"))\n        .arg(Arg::with_name(\"program\")\n            .required(true)\n            .index(1))\n        .get_matches();\n\n    // Read in our program.\n    let filename = matches.value_of(\"program\").unwrap();\n    let path = Path::new(&filename);\n    let mut fd = File::open(path).unwrap();\n\n    let mut data = Vec::new();\n    fd.read_to_end(&mut data).unwrap();\n    \n    // Parse the file with Elf.\n    match goblin::Object::parse(&data).unwrap() {\n        goblin::Object::Elf(elf) => {\n            do_elf(&data, &elf, matches.value_of(\"filter\"));\n        },\n        _ => println!(\"Unsupported file format\")\n    }\n}", "item_id": 1, "repo": "falconre/owl", "file": "src/main.rs", "last_update_at": "2021-07-01T02:59:19+00:00", "question_id": "978be39012e1ca76564e01a7765b90975267bed7_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main () {\n    // Use clap for command-line argument parsing.\n    let matches = App::new(\"owl\")\n        .author(\"Alex Eubanks <endeavor@rainbowsandpwnies.com>\")\n        .about(\"ROP Gadget Finder\")\n        .arg(Arg::with_name(\"filter\")\n            .short(\"f\")\n            .value_name(\"filter\")\n            .help(\"Filter rop gadgets by substring\"))\n        .arg(Arg::with_name(\"program\")\n            .required(true)\n            .index(1))\n        .get_matches();\n    // Read in our program.\n    let filename = matches.value_of(\"program\").unwrap();\n    let path = Path::new(&filename);\n    let mut fd = File::open(path).unwrap();\n    let mut data = Vec::new();\n    fd.read_to_end(&mut data).unwrap();\n    // Parse the file with Elf.\n    match goblin::Object::parse(&data).unwrap() {\n        goblin::Object::Elf(elf) => {\n            do_elf(&data, &elf, matches.value_of(\"filter\"));\n        },\n        _ => println!(\"Unsupported file format\")\n    }\n"]], "pred": {"ppl": 2.48078989982605, "ppl_lower": 3.1172313690185547, "ppl/lowercase_ppl": -1.2513471112452301, "ppl/zlib": 0.0019751674292573097, "Min_5.0% Prob": 7.778766727447509, "Min_10.0% Prob": 5.886961770057678, "Min_20.0% Prob": 4.004289857546488, "Min_30.0% Prob": 2.925125954548518, "Min_40.0% Prob": 2.2569925198952356, "Min_50.0% Prob": 1.8088963421320678, "Min_60.0% Prob": 1.5138525893006123}}
{"hexsha": "613ded8caed4064aaef38bcdcec40e2873e708e6", "ext": "rs", "lang": "Rust", "content": "fn jacobson_rank(b: &mut Bencher) {\n        let (v, mut rng) = test_vector();\n        let mut bv: BitVector<u64> = BitVector::new();\n        let mut last_v = 0;\n        for val  in v {\n            for _ in  last_v..val {\n                bv.push_bit(false);\n            }\n            bv.push_bit(true);\n            last_v = val;\n        }\n        let r = JacobsonRank::new(bv);\n        b.iter(|| {\n            for _ in 0..super::TRIALS {\n                black_box(r.rank1(rng.gen_range(0, SIZE)));\n            }\n        })\n    }", "item_id": 13, "repo": "zommiommy/elias_fano_rust", "file": "benches/bench_all.rs", "last_update_at": "2021-08-22T07:18:05+00:00", "question_id": "613ded8caed4064aaef38bcdcec40e2873e708e6_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn jacobson_rank(b: &mut Bencher) {\n        let (v, mut rng) = test_vector();\n        let mut bv: BitVector<u64> = BitVector::new();\n        let mut last_v = 0;\n        for val  in v {\n            for _ in  last_v..val {\n                bv.push_bit(false);\n            }\n            bv.push_bit(true);\n            last_v = val;\n        }\n        let r = JacobsonRank::new(bv);\n        b.iter(|| {\n            for _ in 0..super::TRIALS {\n                black_box(r.rank1(rng.gen_range(0, SIZE)));\n            }\n        })\n"]], "pred": {"ppl": 2.6413772106170654, "ppl_lower": 3.2281911373138428, "ppl/lowercase_ppl": -1.2065493831052125, "ppl/zlib": 0.00376473043342503, "Min_5.0% Prob": 7.412299897935656, "Min_10.0% Prob": 5.732109626134236, "Min_20.0% Prob": 3.995826276572975, "Min_30.0% Prob": 2.967826148228986, "Min_40.0% Prob": 2.339472260872523, "Min_50.0% Prob": 1.9102260739879404, "Min_60.0% Prob": 1.6190806703109826}}
{"hexsha": "64bf087a54cd3678f6105ed1daa8342f1a3c3a92", "ext": "rs", "lang": "Rust", "content": "fn load_and_execute(prog: &[Command]) -> VirtualMachine {\n        let mut vm = VirtualMachine::new();\n        vm.load(prog);\n\n        for _ in 0..100 {\n            vm.tick();\n        }\n\n        vm\n    }", "item_id": 1, "repo": "jcon/jackvm-rs", "file": "vm/src/vm.rs", "last_update_at": "2021-07-06T20:36:42+00:00", "question_id": "64bf087a54cd3678f6105ed1daa8342f1a3c3a92_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn load_and_execute(prog: &[Command]) -> VirtualMachine {\n        let mut vm = VirtualMachine::new();\n        vm.load(prog);\n        for _ in 0..100 {\n            vm.tick();\n        }\n        vm\n"]], "pred": {"ppl": 2.780078887939453, "ppl_lower": 3.4385862350463867, "ppl/lowercase_ppl": -1.207907488772536, "ppl/zlib": 0.007573920772270854, "Min_5.0% Prob": 8.045807520548502, "Min_10.0% Prob": 6.408001184463501, "Min_20.0% Prob": 4.31433079792903, "Min_30.0% Prob": 3.2383861384893717, "Min_40.0% Prob": 2.458589247786082, "Min_50.0% Prob": 2.03617563797161, "Min_60.0% Prob": 1.6935223595072062}}
{"hexsha": "5e8f70c197e68ac52808a5518905c713dba8e4b8", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let total_time_start = time::Instant::now();\n    let stdout = std::io::stdout();\n    let mut stdout_handle = stdout.lock();\n    writeln!(stdout_handle, \"AoC 2021 Day 1\").unwrap();\n    writeln!(stdout_handle, \"----------------------------------\\n\").unwrap();\n\n    // Read all lines of input.txt\n    let read_time_start = time::Instant::now();\n    //let input = fs::read_to_string(\"example.txt\").expect(\"Unable to read file\");\n    let input = fs::read_to_string(\"input.txt\").expect(\"Unable to read file\");\n    let read_time = read_time_start.elapsed();\n    let convert_time_start = time::Instant::now();\n    let lines = input\n        .lines()\n        .map(|line| line.trim().parse::<usize>().unwrap())\n        .collect::<Vec<usize>>();\n    let convert_time = convert_time_start.elapsed();\n\n    let part1_time_start = time::Instant::now();\n    let part1_answer = part1(&lines);\n    let part1_time = part1_time_start.elapsed();\n    writeln!(stdout_handle, \"Part 1 Answer: {}\", part1_answer).unwrap();\n\n    writeln!(stdout_handle, \"\\n----------------------------------\\n\").unwrap();\n\n    let part2_time = time::Instant::now();\n    let part2_answer = part2(&lines);\n    let part2_time = part2_time.elapsed();\n    writeln!(stdout_handle, \"Part 2 Answer: {}\", part2_answer).unwrap();\n\n    writeln!(stdout_handle, \"\\n----------------------------------\\n\").unwrap();\n\n    writeln!(stdout_handle, \"Read time: {:?}\", read_time).unwrap();\n    writeln!(stdout_handle, \"Convert time: {:?}\", convert_time).unwrap();\n    writeln!(stdout_handle, \"Part 1 time: {:?}\", part1_time).unwrap();\n    writeln!(stdout_handle, \"Part 2 time: {:?}\", part2_time).unwrap();\n\n    let total_time = total_time_start.elapsed();\n    writeln!(stdout_handle, \"Total time: {:?}\", total_time).unwrap();\n}", "item_id": 2, "repo": "dclamage/aoc2021-rust", "file": "Day1/src/main.rs", "last_update_at": "2021-12-06T18:58:19+00:00", "question_id": "5e8f70c197e68ac52808a5518905c713dba8e4b8_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let total_time_start = time::Instant::now();\n    let stdout = std::io::stdout();\n    let mut stdout_handle = stdout.lock();\n    writeln!(stdout_handle, \"AoC 2021 Day 1\").unwrap();\n    writeln!(stdout_handle, \"----------------------------------\\n\").unwrap();\n    // Read all lines of input.txt\n    let read_time_start = time::Instant::now();\n    //let input = fs::read_to_string(\"example.txt\").expect(\"Unable to read file\");\n    let input = fs::read_to_string(\"input.txt\").expect(\"Unable to read file\");\n    let read_time = read_time_start.elapsed();\n    let convert_time_start = time::Instant::now();\n    let lines = input\n        .lines()\n        .map(|line| line.trim().parse::<usize>().unwrap())\n        .collect::<Vec<usize>>();\n    let convert_time = convert_time_start.elapsed();\n    let part1_time_start = time::Instant::now();\n    let part1_answer = part1(&lines);\n    let part1_time = part1_time_start.elapsed();\n    writeln!(stdout_handle, \"Part 1 Answer: {}\", part1_answer).unwrap();\n    writeln!(stdout_handle, \"\\n----------------------------------\\n\").unwrap();\n    let part2_time = time::Instant::now();\n    let part2_answer = part2(&lines);\n    let part2_time = part2_time.elapsed();\n    writeln!(stdout_handle, \"Part 2 Answer: {}\", part2_answer).unwrap();\n    writeln!(stdout_handle, \"\\n----------------------------------\\n\").unwrap();\n    writeln!(stdout_handle, \"Read time: {:?}\", read_time).unwrap();\n    writeln!(stdout_handle, \"Convert time: {:?}\", convert_time).unwrap();\n    writeln!(stdout_handle, \"Part 1 time: {:?}\", part1_time).unwrap();\n    writeln!(stdout_handle, \"Part 2 time: {:?}\", part2_time).unwrap();\n    let total_time = total_time_start.elapsed();\n    writeln!(stdout_handle, \"Total time: {:?}\", total_time).unwrap();\n"]], "pred": {"ppl": 1.363045573234558, "ppl_lower": 1.4637103080749512, "ppl/lowercase_ppl": -1.2300547768077994, "ppl/zlib": 0.0006548025119046307, "Min_5.0% Prob": 4.068445656980787, "Min_10.0% Prob": 2.6414891732366463, "Min_20.0% Prob": 1.5049453032644171, "Min_30.0% Prob": 1.0277688186833558, "Min_40.0% Prob": 0.7749207073397804, "Min_50.0% Prob": 0.6188999467539126, "Min_60.0% Prob": 0.516365499080243}}
{"hexsha": "62f0337902ca1df73aa81d261548ac7a673c2c73", "ext": "rs", "lang": "Rust", "content": "fn init_mod(py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyQStore>()?;\n    m.add_class::<PyQStoreNode>()?;\n//    #[pyfn(m, \"sum_as_string\")]\n//    // pyo3 aware function. All of our python interface could be declared in a separate module.\n//    // Note that the `#[pyfn()]` annotation automatically converts the arguments from\n//    // Python objects to Rust values; and the Rust return value back into a Python object.\n//    fn sum_as_string_py(a:i64, b:i64) -> PyResult<String> {\n//        let out = sum_as_string(a, b);\n//        Ok(out)\n//    }\n\n    Ok(())\n}", "item_id": 0, "repo": "Rust-Linked-Data/qstore", "file": "src/python/mod.rs", "last_update_at": "2021-10-06T20:29:45+00:00", "question_id": "62f0337902ca1df73aa81d261548ac7a673c2c73_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn init_mod(py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyQStore>()?;\n    m.add_class::<PyQStoreNode>()?;\n//    #[pyfn(m, \"sum_as_string\")]\n//    // pyo3 aware function. All of our python interface could be declared in a separate module.\n//    // Note that the `#[pyfn()]` annotation automatically converts the arguments from\n//    // Python objects to Rust values; and the Rust return value back into a Python object.\n//    fn sum_as_string_py(a:i64, b:i64) -> PyResult<String> {\n//        let out = sum_as_string(a, b);\n//        Ok(out)\n//    }\n    Ok(())\n"]], "pred": {"ppl": 2.821495771408081, "ppl_lower": 3.9785587787628174, "ppl/lowercase_ppl": -1.3313056572593482, "ppl/zlib": 0.0030507857638895205, "Min_5.0% Prob": 8.095877027511596, "Min_10.0% Prob": 6.689209699630737, "Min_20.0% Prob": 4.5195598870515825, "Min_30.0% Prob": 3.312359343965848, "Min_40.0% Prob": 2.5545912008732556, "Min_50.0% Prob": 2.065063644498587, "Min_60.0% Prob": 1.726156811059142}}
{"hexsha": "18f412fe2747ac45608388c89bcffd58268ebd8a", "ext": "rs", "lang": "Rust", "content": "pub fn reduce_lower(value: f64, min: f64, y: f64, control: f64) -> f64 {\n\tlet divisor = control - 1.0;\n\tlet factor = (control - y.min(control)) / divisor;\n\n\tmath::lerp_precise(value, min, factor)\n}", "item_id": 1, "repo": "coderbot16/flashcube", "file": "i73/i73-shape/src/volume.rs", "last_update_at": "2021-11-01T11:34:23+00:00", "question_id": "18f412fe2747ac45608388c89bcffd58268ebd8a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn reduce_lower(value: f64, min: f64, y: f64, control: f64) -> f64 {\n\tlet divisor = control - 1.0;\n\tlet factor = (control - y.min(control)) / divisor;\n\tmath::lerp_precise(value, min, factor)\n"]], "pred": {"ppl": 5.249025344848633, "ppl_lower": 5.249025344848633, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.01184316007691741, "Min_5.0% Prob": 9.669677972793579, "Min_10.0% Prob": 8.909967541694641, "Min_20.0% Prob": 6.518577912274529, "Min_30.0% Prob": 5.088180961608887, "Min_40.0% Prob": 4.00133088055779, "Min_50.0% Prob": 3.3056765851520358, "Min_60.0% Prob": 2.7486866827981147}}
{"hexsha": "c9ad3df0013ccf4e8849203fdec35bc95055d7d3", "ext": "rs", "lang": "Rust", "content": "pub fn parser(tokens: TokenStream) -> TokenStream {\n    use std::io::Read;\n    use std::str::FromStr;\n    let mut file = format(proc_macro2::TokenStream::from(tokens));\n    let _ = file.pop();\n    let root = env!(\"CARGO_MANIFEST_DIR\");\n    let file = format!(\"{}/../src/{}\", root, &file[1..]);\n    println!(\"{}\", file);\n    let mut file = std::fs::File::open(&file).expect(\"Unable to open file\");\n    let mut src = String::new();\n    file.read_to_string(&mut src).expect(\"Unable to read file\");\n    let syntax = TokenStream::from_str(&src).expect(\"Unable to parse file\");\n    parse(syntax)\n}", "item_id": 0, "repo": "12101111/rcc", "file": "parser/lib.rs", "last_update_at": "2021-03-11T13:25:29+00:00", "question_id": "c9ad3df0013ccf4e8849203fdec35bc95055d7d3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn parser(tokens: TokenStream) -> TokenStream {\n    use std::io::Read;\n    use std::str::FromStr;\n    let mut file = format(proc_macro2::TokenStream::from(tokens));\n    let _ = file.pop();\n    let root = env!(\"CARGO_MANIFEST_DIR\");\n    let file = format!(\"{}/../src/{}\", root, &file[1..]);\n    println!(\"{}\", file);\n    let mut file = std::fs::File::open(&file).expect(\"Unable to open file\");\n    let mut src = String::new();\n    file.read_to_string(&mut src).expect(\"Unable to read file\");\n    let syntax = TokenStream::from_str(&src).expect(\"Unable to parse file\");\n    parse(syntax)\n"]], "pred": {"ppl": 2.5669071674346924, "ppl_lower": 3.826479434967041, "ppl/lowercase_ppl": -1.4235098118979645, "ppl/zlib": 0.0030807246320252945, "Min_5.0% Prob": 8.330679734547934, "Min_10.0% Prob": 6.134607515837017, "Min_20.0% Prob": 4.120539399293753, "Min_30.0% Prob": 3.0002908434333473, "Min_40.0% Prob": 2.305065369949891, "Min_50.0% Prob": 1.864189286317144, "Min_60.0% Prob": 1.5722874908302076}}
{"hexsha": "1dc16dd0389b1d1542151b952581da3beaef42d5", "ext": "rs", "lang": "Rust", "content": "fn fdcan1_tx_isr() {\n    let fdcan = &sync::acquire_hw(&SHARED_DEVICE).fdcan;\n    let get_idx = fdcan.txefs.read().efgi().bits();\n    // Safety: Upstream: not restricted to enum or range in stm32-rs. But since we're using the\n    // value retrieved from the get index it's fine.\n    fdcan.txefa.modify(|_, w| unsafe { w.efai().bits(get_idx) });\n\n    // TODO(blakely): Actually check for Tx errors\n    // Ack the Tx interrupts\n    fdcan.ir.modify(|_, w| w.tfe().set_bit().tefn().set_bit());\n}", "item_id": 1, "repo": "timblakely/pino-rs", "file": "bldc/src/comms/fdcan.rs", "last_update_at": "2021-12-19T18:17:58+00:00", "question_id": "1dc16dd0389b1d1542151b952581da3beaef42d5_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn fdcan1_tx_isr() {\n    let fdcan = &sync::acquire_hw(&SHARED_DEVICE).fdcan;\n    let get_idx = fdcan.txefs.read().efgi().bits();\n    // Safety: Upstream: not restricted to enum or range in stm32-rs. But since we're using the\n    // value retrieved from the get index it's fine.\n    fdcan.txefa.modify(|_, w| unsafe { w.efai().bits(get_idx) });\n    // TODO(blakely): Actually check for Tx errors\n    // Ack the Tx interrupts\n    fdcan.ir.modify(|_, w| w.tfe().set_bit().tefn().set_bit());\n"]], "pred": {"ppl": 7.782027721405029, "ppl_lower": 8.24671459197998, "ppl/lowercase_ppl": -1.0282666313515294, "ppl/zlib": 0.00649309157216099, "Min_5.0% Prob": 10.534884558783638, "Min_10.0% Prob": 8.876151235480057, "Min_20.0% Prob": 6.862483539079365, "Min_30.0% Prob": 5.569625511504056, "Min_40.0% Prob": 4.6773546008687275, "Min_50.0% Prob": 3.9685721918156274, "Min_60.0% Prob": 3.3822062159316584}}
{"hexsha": "a95cf80310f651db51e693f6d74328b88baa4781", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn is_each_value_valid(date: &str) -> bool {\n\n    let max_day_number = 31;\n    let max_month_number = 12;\n    let min_year_number = 1000;\n    let max_year_number = 9999;\n\n\n    let string_parts = date.split('-');\n\n    if string_parts.count() != 3 { return false; }\n\n    let string_parts = date.split('-');\n\n    let mut count_numbers = 0;\n\n    for part in string_parts {\n        let parsed_value = part.parse::<u16>();\n\n        if part.parse::<u16>().is_err() { return false; }\n        \n        count_numbers += 1;\n\n        let value = parsed_value.unwrap();\n\n        if count_numbers == 1 && value > max_day_number { return false; }\n        if count_numbers == 2 && value > max_month_number { return false; }\n        if count_numbers == 3 && (value < min_year_number || value > max_year_number) { return false; }\n    }\n\n    \n    true\n}", "item_id": 0, "repo": "asari555/tcmb_evds", "file": "src/date/date_validation_basics.rs", "last_update_at": "2021-11-20T11:32:50+00:00", "question_id": "a95cf80310f651db51e693f6d74328b88baa4781_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn is_each_value_valid(date: &str) -> bool {\n    let max_day_number = 31;\n    let max_month_number = 12;\n    let min_year_number = 1000;\n    let max_year_number = 9999;\n    let string_parts = date.split('-');\n    if string_parts.count() != 3 { return false; }\n    let string_parts = date.split('-');\n    let mut count_numbers = 0;\n    for part in string_parts {\n        let parsed_value = part.parse::<u16>();\n        if part.parse::<u16>().is_err() { return false; }\n        count_numbers += 1;\n        let value = parsed_value.unwrap();\n        if count_numbers == 1 && value > max_day_number { return false; }\n        if count_numbers == 2 && value > max_month_number { return false; }\n        if count_numbers == 3 && (value < min_year_number || value > max_year_number) { return false; }\n    }\n    true\n"]], "pred": {"ppl": 1.9419525861740112, "ppl_lower": 1.9419525861740112, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0021548505020280596, "Min_5.0% Prob": 6.492724895477295, "Min_10.0% Prob": 4.713395439345261, "Min_20.0% Prob": 2.9577715639340676, "Min_30.0% Prob": 2.1143381411439917, "Min_40.0% Prob": 1.62880037555925, "Min_50.0% Prob": 1.3164480961109168, "Min_60.0% Prob": 1.1072327229351309}}
{"hexsha": "4afeb688cb231288408e9ae9d2d4728cb9cabc02", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn load_ssl() -> Result<SslAcceptorBuilder> {\n    let mut builder = SslAcceptor::mozilla_intermediate(SslMethod::tls())?;\n    builder.set_private_key_file(\"ssl_keys/server.pem\", SslFiletype::PEM)?;\n    builder.set_certificate_chain_file(\"ssl_keys/crt.pem\")?;\n    Ok(builder)\n}", "item_id": 0, "repo": "Dengjianping/yt-chain", "file": "src/utils/utils.rs", "last_update_at": "2021-11-17T11:28:23+00:00", "question_id": "4afeb688cb231288408e9ae9d2d4728cb9cabc02_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn load_ssl() -> Result<SslAcceptorBuilder> {\n    let mut builder = SslAcceptor::mozilla_intermediate(SslMethod::tls())?;\n    builder.set_private_key_file(\"ssl_keys/server.pem\", SslFiletype::PEM)?;\n    builder.set_certificate_chain_file(\"ssl_keys/crt.pem\")?;\n    Ok(builder)\n"]], "pred": {"ppl": 2.158641815185547, "ppl_lower": 3.853017568588257, "ppl/lowercase_ppl": -1.752947402079802, "ppl/zlib": 0.0039663878075218775, "Min_5.0% Prob": 7.530964946746826, "Min_10.0% Prob": 5.7206604957580565, "Min_20.0% Prob": 3.59512905563627, "Min_30.0% Prob": 2.5347003578208387, "Min_40.0% Prob": 1.9210572289519532, "Min_50.0% Prob": 1.5365318058541528, "Min_60.0% Prob": 1.2976552894106135}}
{"hexsha": "2d290308d0196d9f5c61c976a3e2e3711bbb74c1", "ext": "rs", "lang": "Rust", "content": "fn test_readreader_new() {\n    let mut sample: [u8; 10] = [0; 10];\n    fill_sample(&mut sample);\n    let mut mem_reader = std::io::Cursor::new(&sample);\n    let mut reader = ReadReader::new(&mut mem_reader);\n    match reader.read() {\n        Ok(v) => assert_eq!(v, 0),\n        _ => panic!(\"Unexpected error!\"),\n    }\n}", "item_id": 8, "repo": "interlockledger/rust-il2-iltags", "file": "src/io/std_io/tests.rs", "last_update_at": "2021-08-05T06:36:56+00:00", "question_id": "2d290308d0196d9f5c61c976a3e2e3711bbb74c1_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_readreader_new() {\n    let mut sample: [u8; 10] = [0; 10];\n    fill_sample(&mut sample);\n    let mut mem_reader = std::io::Cursor::new(&sample);\n    let mut reader = ReadReader::new(&mut mem_reader);\n    match reader.read() {\n        Ok(v) => assert_eq!(v, 0),\n        _ => panic!(\"Unexpected error!\"),\n    }\n"]], "pred": {"ppl": 2.6145501136779785, "ppl_lower": 3.4287354946136475, "ppl/lowercase_ppl": -1.282074430774897, "ppl/zlib": 0.005005687719050405, "Min_5.0% Prob": 8.798500156402588, "Min_10.0% Prob": 6.422969297929243, "Min_20.0% Prob": 3.9772322644358096, "Min_30.0% Prob": 2.9795503072878895, "Min_40.0% Prob": 2.3291191335605537, "Min_50.0% Prob": 1.8943525581010456, "Min_60.0% Prob": 1.6093180616372738}}
{"hexsha": "a08cf8345499a40e511d31aba13072a0c198e2fa", "ext": "rs", "lang": "Rust", "content": "fn token_option_cannot_be_empty() {\n            let matches = SupRun::clap().get_matches_from_safe(vec![\"run\",\n                                                                    \"--event-stream-application\",\n                                                                    \"MY_APP\",\n                                                                    \"--event-stream-environment\",\n                                                                    \"MY_ENV\",\n                                                                    \"--event-stream-token\",\n                                                                    \"\",\n                                                                    \"--event-stream-url\",\n                                                                    \"127.0.0.1:4222\",]);\n            assert!(matches.is_err());\n            let error = matches.unwrap_err();\n            assert_eq!(error.kind, clap::ErrorKind::ValueValidation);\n        }", "item_id": 14, "repo": "biome-sh/biome", "file": "components/bio/src/cli.rs", "last_update_at": "2021-09-08T18:11:12+00:00", "question_id": "a08cf8345499a40e511d31aba13072a0c198e2fa_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn token_option_cannot_be_empty() {\n            let matches = SupRun::clap().get_matches_from_safe(vec![\"run\",\n                                                                    \"--event-stream-application\",\n                                                                    \"MY_APP\",\n                                                                    \"--event-stream-environment\",\n                                                                    \"MY_ENV\",\n                                                                    \"--event-stream-token\",\n                                                                    \"\",\n                                                                    \"--event-stream-url\",\n                                                                    \"127.0.0.1:4222\",]);\n            assert!(matches.is_err());\n            let error = matches.unwrap_err();\n            assert_eq!(error.kind, clap::ErrorKind::ValueValidation);\n"]], "pred": {"ppl": 2.152754068374634, "ppl_lower": 2.8513376712799072, "ppl/lowercase_ppl": -1.3665353724695206, "ppl/zlib": 0.0029265190245892107, "Min_5.0% Prob": 8.55033286412557, "Min_10.0% Prob": 6.2420039309395685, "Min_20.0% Prob": 3.596525190649806, "Min_30.0% Prob": 2.5010181425937583, "Min_40.0% Prob": 1.9029233276844024, "Min_50.0% Prob": 1.5290372007070703, "Min_60.0% Prob": 1.2858450079802424}}
{"hexsha": "cd3f80bae1ccaf9711897ca2602de8a69cf92ea7", "ext": "rs", "lang": "Rust", "content": "pub fn spawn_handle<F>(fut: F) -> FutureHandle\nwhere\n    F: Future<Output = ()> + 'static\n{\n    let (fut, handle) = abortable(fut);\n\n    spawn_local(async move {\n        let _ = fut.await;\n    });\n\n    FutureHandle { inner: handle }\n}", "item_id": 0, "repo": "dakom/awsm-web", "file": "crate/src/loaders/helpers.rs", "last_update_at": "2021-12-13T18:46:30+00:00", "question_id": "cd3f80bae1ccaf9711897ca2602de8a69cf92ea7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn spawn_handle<F>(fut: F) -> FutureHandle\nwhere\n    F: Future<Output = ()> + 'static\n{\n    let (fut, handle) = abortable(fut);\n    spawn_local(async move {\n        let _ = fut.await;\n    });\n    FutureHandle { inner: handle }\n"]], "pred": {"ppl": 2.9154257774353027, "ppl_lower": 4.431058406829834, "ppl/lowercase_ppl": -1.3912302709680016, "ppl/zlib": 0.006605036255780123, "Min_5.0% Prob": 8.257821917533875, "Min_10.0% Prob": 6.822331786155701, "Min_20.0% Prob": 4.548621095716953, "Min_30.0% Prob": 3.3901949897408485, "Min_40.0% Prob": 2.623767703771591, "Min_50.0% Prob": 2.142689692901402, "Min_60.0% Prob": 1.8054688535630703}}
{"hexsha": "38409800021e145a5e47388004182a1a04ab3ee4", "ext": "rs", "lang": "Rust", "content": "pub fn get_version(path: impl AsRef<Path>) -> Result<Version, Error> {\n    let cargo_toml_content = fs::read_to_string(path.as_ref())?;\n    let doc = cargo_toml_content.parse::<Document>()?;\n    let item: &Item = &doc[\"package\"][\"version\"];\n\n    // This should be the case for valid Cargo.toml files.\n    if let Some(s) = item.as_str() {\n        Ok(Version::parse(s)?)\n    } else {\n        Err(Error::InvalidFieldType {\n            field: \"version\".to_string(),\n            ty: \"string\".to_string(),\n        })\n    }\n}", "item_id": 0, "repo": "conventional-commits-rs/cargo-next", "file": "src/lib.rs", "last_update_at": "2021-12-16T20:49:35+00:00", "question_id": "38409800021e145a5e47388004182a1a04ab3ee4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_version(path: impl AsRef<Path>) -> Result<Version, Error> {\n    let cargo_toml_content = fs::read_to_string(path.as_ref())?;\n    let doc = cargo_toml_content.parse::<Document>()?;\n    let item: &Item = &doc[\"package\"][\"version\"];\n    // This should be the case for valid Cargo.toml files.\n    if let Some(s) = item.as_str() {\n        Ok(Version::parse(s)?)\n    } else {\n        Err(Error::InvalidFieldType {\n            field: \"version\".to_string(),\n            ty: \"string\".to_string(),\n        })\n    }\n"]], "pred": {"ppl": 2.212447166442871, "ppl_lower": 3.443308115005493, "ppl/lowercase_ppl": -1.5570254226849893, "ppl/zlib": 0.00259509548379406, "Min_5.0% Prob": 6.624759554862976, "Min_10.0% Prob": 4.923324290443869, "Min_20.0% Prob": 3.3209501154282512, "Min_30.0% Prob": 2.499442832142699, "Min_40.0% Prob": 1.9372792265553405, "Min_50.0% Prob": 1.5817917002321675, "Min_60.0% Prob": 1.3298850597687137}}
{"hexsha": "3356c633d3d77bd0502bb673e8b4615208c04dc3", "ext": "rs", "lang": "Rust", "content": "fn find_test_2() {\n    let string = ByteStr::from_slice(b\"0123456789 0123456789\");\n    assert_eq!(string.find(b'5'), Some(5));\n    assert_eq!(string.rfind(b'5'), Some(17));\n}", "item_id": 1, "repo": "yuulive/rb", "file": "src/tests.rs", "last_update_at": "2021-03-23T18:45:54+00:00", "question_id": "3356c633d3d77bd0502bb673e8b4615208c04dc3_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn find_test_2() {\n    let string = ByteStr::from_slice(b\"0123456789 0123456789\");\n    assert_eq!(string.find(b'5'), Some(5));\n    assert_eq!(string.rfind(b'5'), Some(17));\n"]], "pred": {"ppl": 2.813171148300171, "ppl_lower": 3.117159128189087, "ppl/lowercase_ppl": -1.0992056990173749, "ppl/zlib": 0.008341228786851092, "Min_5.0% Prob": 9.154187679290771, "Min_10.0% Prob": 7.054637253284454, "Min_20.0% Prob": 4.794402725994587, "Min_30.0% Prob": 3.2988903403282164, "Min_40.0% Prob": 2.568688654989907, "Min_50.0% Prob": 2.046084689952078, "Min_60.0% Prob": 1.7287740161269902}}
{"hexsha": "05cd2d9a8f302abc8a302a14422d323b64dc8939", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_DhKey() {\n    assert_eq!(\n        ::std::mem::size_of::<DhKey>(),\n        56usize,\n        concat!(\"Size of: \", stringify!(DhKey))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<DhKey>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(DhKey))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<DhKey>())).p as *const _ as usize },\n        0usize,\n        concat!(\"Offset of field: \", stringify!(DhKey), \"::\", stringify!(p))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<DhKey>())).g as *const _ as usize },\n        24usize,\n        concat!(\"Offset of field: \", stringify!(DhKey), \"::\", stringify!(g))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<DhKey>())).heap as *const _ as usize },\n        48usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(DhKey),\n            \"::\",\n            stringify!(heap)\n        )\n    );\n}", "item_id": 95, "repo": "donald100-git/inclavare-containers", "file": "inclavared/stub-enclave.wolfssl/src/ratls/generated.rs", "last_update_at": "2021-04-22T06:43:43+00:00", "question_id": "05cd2d9a8f302abc8a302a14422d323b64dc8939_95", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout_DhKey() {\n    assert_eq!(\n        ::std::mem::size_of::<DhKey>(),\n        56usize,\n        concat!(\"Size of: \", stringify!(DhKey))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<DhKey>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(DhKey))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<DhKey>())).p as *const _ as usize },\n        0usize,\n        concat!(\"Offset of field: \", stringify!(DhKey), \"::\", stringify!(p))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<DhKey>())).g as *const _ as usize },\n        24usize,\n        concat!(\"Offset of field: \", stringify!(DhKey), \"::\", stringify!(g))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<DhKey>())).heap as *const _ as usize },\n        48usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(DhKey),\n            \"::\",\n            stringify!(heap)\n        )\n    );\n"]], "pred": {"ppl": 1.27763032913208, "ppl_lower": 1.3184868097305298, "ppl/lowercase_ppl": -1.1284765687804088, "ppl/zlib": 0.0009210791608354573, "Min_5.0% Prob": 4.6689606457948685, "Min_10.0% Prob": 2.4817913795510926, "Min_20.0% Prob": 1.2321415483732638, "Min_30.0% Prob": 0.8174585008404176, "Min_40.0% Prob": 0.6161644056806129, "Min_50.0% Prob": 0.49146911554189066, "Min_60.0% Prob": 0.40874821521445504}}
{"hexsha": "e2bcfc9ebe017c50971403200ef32ade67ce5c25", "ext": "rs", "lang": "Rust", "content": "fn output_human(json: &str) -> Result<()> {\n    let result: CollectionsResult = serde_json::from_str(json).chain_err(|| \"JSON parsing failed\")?;\n    msgln(format!(\"Found {} collection(s) matching the search parameters:\", result.collections.len()));\n\n    let mut tw = TabWriter::new(vec![]);\n    for c in result.collections {\n        let visibility = if c.public {\n            \"public\"\n        } else {\n            \"private\"\n        };\n        let _ = write!(&mut tw, \"* {}:\\t'{}'\\t[{}]\\n\", c.id, c.name, visibility);\n    }\n    tw.flush().unwrap();//.chain_err(\"|| Failed to create output table\");\n    let written = String::from_utf8(tw.into_inner().unwrap()).unwrap();\n    msgln(written);\n\n    Ok(())\n}", "item_id": 1, "repo": "scanbots/rat", "file": "src/modules/centerdevice/collections.rs", "last_update_at": "2021-08-02T20:38:05+00:00", "question_id": "e2bcfc9ebe017c50971403200ef32ade67ce5c25_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn output_human(json: &str) -> Result<()> {\n    let result: CollectionsResult = serde_json::from_str(json).chain_err(|| \"JSON parsing failed\")?;\n    msgln(format!(\"Found {} collection(s) matching the search parameters:\", result.collections.len()));\n    let mut tw = TabWriter::new(vec![]);\n    for c in result.collections {\n        let visibility = if c.public {\n            \"public\"\n        } else {\n            \"private\"\n        };\n        let _ = write!(&mut tw, \"* {}:\\t'{}'\\t[{}]\\n\", c.id, c.name, visibility);\n    }\n    tw.flush().unwrap();//.chain_err(\"|| Failed to create output table\");\n    let written = String::from_utf8(tw.into_inner().unwrap()).unwrap();\n    msgln(written);\n    Ok(())\n"]], "pred": {"ppl": 3.2034146785736084, "ppl_lower": 4.023255348205566, "ppl/lowercase_ppl": -1.1957315267921145, "ppl/zlib": 0.0028888767442363295, "Min_5.0% Prob": 9.248882163654674, "Min_10.0% Prob": 7.1012572266838765, "Min_20.0% Prob": 4.814453664151105, "Min_30.0% Prob": 3.6246752377712363, "Min_40.0% Prob": 2.8434631953185256, "Min_50.0% Prob": 2.3167401653799145, "Min_60.0% Prob": 1.9459115457015508}}
{"hexsha": "4740afff127d4d61ddf21744fc6fd03f091510bc", "ext": "rs", "lang": "Rust", "content": "fn parse_paint_1() {\n    let doc = Document::from_str(\n\"<svg xmlns='http://www.w3.org/2000/svg'>\n    <radialGradient id='rg1'/>\n    <rect fill='url(#rg1)'/>\n</svg>\").unwrap();\n\n    let child = doc.root().first_child().unwrap();\n    let rg = child.children().nth(0).unwrap();\n    let rect = child.children().nth(1).unwrap();\n\n    assert_eq!(rg.is_used(), true);\n    assert_eq!(rect.attributes().get_value(AId::Fill).unwrap(), &AttributeValue::Paint(rg, None));\n}", "item_id": 5, "repo": "RazrFalcon/svgdom", "file": "tests/parser.rs", "last_update_at": "2021-03-07T15:04:23+00:00", "question_id": "4740afff127d4d61ddf21744fc6fd03f091510bc_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_paint_1() {\n    let doc = Document::from_str(\n\"<svg xmlns='http://www.w3.org/2000/svg'>\n    <radialGradient id='rg1'/>\n    <rect fill='url(#rg1)'/>\n</svg>\").unwrap();\n    let child = doc.root().first_child().unwrap();\n    let rg = child.children().nth(0).unwrap();\n    let rect = child.children().nth(1).unwrap();\n    assert_eq!(rg.is_used(), true);\n    assert_eq!(rect.attributes().get_value(AId::Fill).unwrap(), &AttributeValue::Paint(rg, None));\n"]], "pred": {"ppl": 3.076371431350708, "ppl_lower": 3.7674105167388916, "ppl/lowercase_ppl": -1.1803221006546791, "ppl/zlib": 0.003956868999182876, "Min_5.0% Prob": 7.965900421142578, "Min_10.0% Prob": 6.6522409319877625, "Min_20.0% Prob": 4.670610279747934, "Min_30.0% Prob": 3.477415714263916, "Min_40.0% Prob": 2.732816560054893, "Min_50.0% Prob": 2.231758430245377, "Min_60.0% Prob": 1.8736196290148366}}
{"hexsha": "0fc960e37e0993078e0d7aa34f598bc9c55ac668", "ext": "rs", "lang": "Rust", "content": "fn test_garbling(b: &Bundler, inp: &[u128], should_be: &[u128]) {\n        let c = b.borrow_builder().borrow_circ();\n        let (gb, ev) = garble(&c);\n        println!(\"number of ciphertexts: {}\", ev.size());\n        let enc_inp = b.encode(inp);\n        assert_eq!(b.decode(&c.eval(&enc_inp)), should_be);\n        let xs = gb.encode(&enc_inp);\n        let ys = ev.eval(c, &xs);\n        assert_eq!(b.decode(&gb.decode(&ys)), should_be);\n    }", "item_id": 0, "repo": "bradyjoestar/rust-sgx-sdk", "file": "third_party/fancy-garbling/src/high_level.rs", "last_update_at": "2021-04-06T05:53:44+00:00", "question_id": "0fc960e37e0993078e0d7aa34f598bc9c55ac668_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_garbling(b: &Bundler, inp: &[u128], should_be: &[u128]) {\n        let c = b.borrow_builder().borrow_circ();\n        let (gb, ev) = garble(&c);\n        println!(\"number of ciphertexts: {}\", ev.size());\n        let enc_inp = b.encode(inp);\n        assert_eq!(b.decode(&c.eval(&enc_inp)), should_be);\n        let xs = gb.encode(&enc_inp);\n        let ys = ev.eval(c, &xs);\n        assert_eq!(b.decode(&gb.decode(&ys)), should_be);\n"]], "pred": {"ppl": 3.8495032787323, "ppl_lower": 4.05674934387207, "ppl/lowercase_ppl": -1.0389021150062012, "ppl/zlib": 0.005810103971831887, "Min_5.0% Prob": 8.505635023117065, "Min_10.0% Prob": 6.821444707758286, "Min_20.0% Prob": 5.194902763647192, "Min_30.0% Prob": 3.9804733235102434, "Min_40.0% Prob": 3.202688537646031, "Min_50.0% Prob": 2.6291095515092215, "Min_60.0% Prob": 2.2340077644643874}}
{"hexsha": "fb964d18883a9093e4e56394c0e78f018cbc0cac", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let lena = get_lena().expect(\"Couldn't load lena\");\n\n    // Create transformation matrix\n    let x = 0.5 * (lena.cols() as f64) - 0.5;\n    let y = 0.5 * (lena.rows() as f64) - 0.5;\n    let trans = rotate_around_centre(FRAC_PI_4, (x, y)).dot(&scale(0.7, 0.7));\n\n    let transformed = lena\n        .transform(trans.view(), None)\n        .expect(\"Transform failed\");\n\n    // save\n    let path = Path::new(\"transformed_lena.png\");\n    let file = File::create(path).expect(\"Couldn't create output file\");\n    let ref mut w = BufWriter::new(file);\n\n    let mut encoder = png::Encoder::new(w, transformed.cols() as u32, transformed.rows() as u32);\n    encoder.set_color(png::ColorType::RGB);\n    encoder.set_depth(png::BitDepth::Eight);\n\n    println!(\n        \"Writing image with resolution {}x{}\",\n        transformed.cols(),\n        transformed.rows()\n    );\n\n    let mut writer = encoder.write_header().expect(\"Failed to write file header\");\n    if let Some(data) = transformed.data.view().to_slice() {\n        writer\n            .write_image_data(data)\n            .expect(\"Failed to write image data\");\n    } else {\n        println!(\"Failed to get image slice\");\n    }\n}", "item_id": 0, "repo": "xd009642/ndarray-vision", "file": "examples/transforms.rs", "last_update_at": "2021-07-22T10:56:50+00:00", "question_id": "fb964d18883a9093e4e56394c0e78f018cbc0cac_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let lena = get_lena().expect(\"Couldn't load lena\");\n    // Create transformation matrix\n    let x = 0.5 * (lena.cols() as f64) - 0.5;\n    let y = 0.5 * (lena.rows() as f64) - 0.5;\n    let trans = rotate_around_centre(FRAC_PI_4, (x, y)).dot(&scale(0.7, 0.7));\n    let transformed = lena\n        .transform(trans.view(), None)\n        .expect(\"Transform failed\");\n    // save\n    let path = Path::new(\"transformed_lena.png\");\n    let file = File::create(path).expect(\"Couldn't create output file\");\n    let ref mut w = BufWriter::new(file);\n    let mut encoder = png::Encoder::new(w, transformed.cols() as u32, transformed.rows() as u32);\n    encoder.set_color(png::ColorType::RGB);\n    encoder.set_depth(png::BitDepth::Eight);\n    println!(\n        \"Writing image with resolution {}x{}\",\n        transformed.cols(),\n        transformed.rows()\n    );\n    let mut writer = encoder.write_header().expect(\"Failed to write file header\");\n    if let Some(data) = transformed.data.view().to_slice() {\n        writer\n            .write_image_data(data)\n            .expect(\"Failed to write image data\");\n    } else {\n        println!(\"Failed to get image slice\");\n    }\n"]], "pred": {"ppl": 2.043084144592285, "ppl_lower": 2.4390687942504883, "ppl/lowercase_ppl": -1.2479574763821815, "ppl/zlib": 0.0013505869598633225, "Min_5.0% Prob": 6.752208810103567, "Min_10.0% Prob": 4.719013819327722, "Min_20.0% Prob": 3.1180872585200055, "Min_30.0% Prob": 2.307068152587955, "Min_40.0% Prob": 1.7711130263483, "Min_50.0% Prob": 1.4249344078926884, "Min_60.0% Prob": 1.1939541801512867}}
{"hexsha": "e86f7b57e357b4740b074e035d192a2456380471", "ext": "rs", "lang": "Rust", "content": "fn it_can_decode_binary_literal_16_rsub_operation() {\n        let raw_opcode: &[u8] = &[0xd1, 0x2f, 0xFF, 0x00];\n        let mut d: ByteCodeDecoder<_, LittleEndian> = ByteCodeDecoder::new(raw_opcode);\n\n        let opcode = d.nth(0).unwrap();\n\n        assert_eq!(\"rsub-int v15, v2, #255\", opcode.to_string());\n        assert!(matches!(\n            opcode,\n            ByteCode::BinaryLit16(_, dest, src, lit) if dest == 15 &&  src == 2 && lit == 255));\n    }", "item_id": 61, "repo": "SUPERAndroidAnalyzer/dalvik-rs", "file": "src/bytecode.rs", "last_update_at": "2021-06-14T15:05:26+00:00", "question_id": "e86f7b57e357b4740b074e035d192a2456380471_61", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn it_can_decode_binary_literal_16_rsub_operation() {\n        let raw_opcode: &[u8] = &[0xd1, 0x2f, 0xFF, 0x00];\n        let mut d: ByteCodeDecoder<_, LittleEndian> = ByteCodeDecoder::new(raw_opcode);\n        let opcode = d.nth(0).unwrap();\n        assert_eq!(\"rsub-int v15, v2, #255\", opcode.to_string());\n        assert!(matches!(\n            opcode,\n            ByteCode::BinaryLit16(_, dest, src, lit) if dest == 15 &&  src == 2 && lit == 255));\n"]], "pred": {"ppl": 4.324643611907959, "ppl_lower": 5.0301127433776855, "ppl/lowercase_ppl": -1.1031957893835158, "ppl/zlib": 0.005211137847393701, "Min_5.0% Prob": 9.21473667356703, "Min_10.0% Prob": 7.434395869572957, "Min_20.0% Prob": 5.5747102402352, "Min_30.0% Prob": 4.389334971254522, "Min_40.0% Prob": 3.4970223943929413, "Min_50.0% Prob": 2.886984075541082, "Min_60.0% Prob": 2.4244571912798794}}
{"hexsha": "b07023b71a56934605aaa17a851b26f9e189f423", "ext": "rs", "lang": "Rust", "content": "fn build_sample_flags(is_sync: bool) -> SampleFlags {\n    let mut flags = SampleFlags::default();\n    if is_sync {\n        flags.sample_depends_on = 2;\n    } else {\n        flags.sample_is_non_sync_sample = true;\n    }\n    flags\n}", "item_id": 3, "repo": "miquels/mp4", "file": "mp4lib/src/fragment.rs", "last_update_at": "2021-03-03T05:57:33+00:00", "question_id": "b07023b71a56934605aaa17a851b26f9e189f423_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn build_sample_flags(is_sync: bool) -> SampleFlags {\n    let mut flags = SampleFlags::default();\n    if is_sync {\n        flags.sample_depends_on = 2;\n    } else {\n        flags.sample_is_non_sync_sample = true;\n    }\n    flags\n"]], "pred": {"ppl": 2.5550854206085205, "ppl_lower": 3.0503103733062744, "ppl/lowercase_ppl": -1.1888502294670482, "ppl/zlib": 0.006700611827287844, "Min_5.0% Prob": 8.528773625691732, "Min_10.0% Prob": 6.768015997750418, "Min_20.0% Prob": 4.225213130315145, "Min_30.0% Prob": 3.0363374741181084, "Min_40.0% Prob": 2.3299969915420777, "Min_50.0% Prob": 1.866733910659185, "Min_60.0% Prob": 1.5870263005161416}}
{"hexsha": "9128872d4c1280936f110d8ef9d339fad5aa240e", "ext": "rs", "lang": "Rust", "content": "fn parse_object_name() -> Result<(), ParserError> {\n        let dialect = crate::ansi::AnsiDialect::default();\n        let name = Parser::new_with_sql(&dialect, \"foo.bar\")?.parse_object_name()?;\n        assert_eq!(name, ObjectName(vec![Ident::new(\"foo\"), Ident::new(\"bar\")]));\n        Ok(())\n    }", "item_id": 1, "repo": "koushiro/usql", "file": "usql/src/parser/types.rs", "last_update_at": "2021-12-08T03:35:05+00:00", "question_id": "9128872d4c1280936f110d8ef9d339fad5aa240e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_object_name() -> Result<(), ParserError> {\n        let dialect = crate::ansi::AnsiDialect::default();\n        let name = Parser::new_with_sql(&dialect, \"foo.bar\")?.parse_object_name()?;\n        assert_eq!(name, ObjectName(vec![Ident::new(\"foo\"), Ident::new(\"bar\")]));\n        Ok(())\n"]], "pred": {"ppl": 2.653846263885498, "ppl_lower": 5.453921794891357, "ppl/lowercase_ppl": -1.7380302776712195, "ppl/zlib": 0.004979642898162638, "Min_5.0% Prob": 8.097085571289062, "Min_10.0% Prob": 6.170313143730164, "Min_20.0% Prob": 4.320421242713929, "Min_30.0% Prob": 3.156778458754222, "Min_40.0% Prob": 2.4206896480172873, "Min_50.0% Prob": 1.9581154629588127, "Min_60.0% Prob": 1.6399261799020073}}
{"hexsha": "84101b5d04fcf51b77186f65bc58668bbf6c2c4e", "ext": "rs", "lang": "Rust", "content": "fn chunk_response_iterator_across_pages() {\n        let config = helper_create_config(5);\n        let page_creator = PageCreator::new();\n        let db = util::database::temp().unwrap();\n        assert!(create_page_template(&config).is_ok());\n\n        let request = Request::new(\n            \"p1\", // package_id\n            vec![Channel::new(\n                // channels\n                \"cache_c1_r2\",\n                1e6,\n            )],\n            10,    // start\n            19,    // end\n            10,    // chunk_size\n            false, // use_cache\n        );\n\n        let response = request.get_response(&config);\n\n        let page = Page {\n            path: path!(&*TEMP_DIR, \"p1\", \"cache_c1_r2\", \"5\", \"2\"; extension => \"bin\"),\n            start: 0,\n            end: 0,\n            size: 5,\n            id: 2,\n        };\n        let key = page_key(\n            request.package_id(),\n            request.channels[0].id(),\n            config.page_size(),\n            page.id,\n        );\n        db.upsert_page(&database::PageRecord::new(\n            key,\n            false,\n            true,\n            config.page_size() as i64,\n        ))\n        .unwrap();\n        let page2 = Page {\n            path: path!(&*TEMP_DIR, \"p1\", \"cache_c1_r2\", \"5\", \"3\"; extension => \"bin\"),\n            start: 0,\n            end: 0,\n            size: 5,\n            id: 3,\n        };\n        let key = page_key(\n            request.package_id(),\n            request.channels[0].id(),\n            config.page_size(),\n            page2.id,\n        );\n        db.upsert_page(&database::PageRecord::new(\n            key,\n            false,\n            true,\n            config.page_size() as i64,\n        ))\n        .unwrap();\n\n        let data: [f64; 10] = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0];\n\n        assert!(page.write(&page_creator, &config, 0, &data[0..5]).is_ok());\n        assert!(page2.write(&page_creator, &config, 0, &data[5..10]).is_ok());\n\n        let mut iter = response.owned_chunk_response_iter(db);\n\n        let mut chunk = ChunkResponse::new();\n        chunk.set_channels(RepeatedField::from_vec(Vec::new()));\n        chunk.channels.push(proto::create_channel_chunk(\n            String::from(\"cache_c1_r2\"),\n            vec![\n                proto::create_datum(10, 0.0),\n                proto::create_datum(11, 1.0),\n                proto::create_datum(12, 2.0),\n                proto::create_datum(13, 3.0),\n                proto::create_datum(14, 4.0),\n                proto::create_datum(15, 5.0),\n                proto::create_datum(16, 6.0),\n                proto::create_datum(17, 7.0),\n                proto::create_datum(18, 8.0),\n                proto::create_datum(19, 9.0),\n            ],\n        ));\n\n        assert_eq!(helper_convert_chunk(&iter.next().unwrap().unwrap()), chunk);\n        assert!(iter.next().is_none());\n    }", "item_id": 36, "repo": "Pennsieve/agent", "file": "src/ps/agent/cache/mod.rs", "last_update_at": "2021-03-29T14:57:55+00:00", "question_id": "84101b5d04fcf51b77186f65bc58668bbf6c2c4e_36", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn chunk_response_iterator_across_pages() {\n        let config = helper_create_config(5);\n        let page_creator = PageCreator::new();\n        let db = util::database::temp().unwrap();\n        assert!(create_page_template(&config).is_ok());\n        let request = Request::new(\n            \"p1\", // package_id\n            vec![Channel::new(\n                // channels\n                \"cache_c1_r2\",\n                1e6,\n            )],\n            10,    // start\n            19,    // end\n            10,    // chunk_size\n            false, // use_cache\n        );\n        let response = request.get_response(&config);\n        let page = Page {\n            path: path!(&*TEMP_DIR, \"p1\", \"cache_c1_r2\", \"5\", \"2\"; extension => \"bin\"),\n            start: 0,\n            end: 0,\n            size: 5,\n            id: 2,\n        };\n        let key = page_key(\n            request.package_id(),\n            request.channels[0].id(),\n            config.page_size(),\n            page.id,\n        );\n        db.upsert_page(&database::PageRecord::new(\n            key,\n            false,\n            true,\n            config.page_size() as i64,\n        ))\n        .unwrap();\n        let page2 = Page {\n            path: path!(&*TEMP_DIR, \"p1\", \"cache_c1_r2\", \"5\", \"3\"; extension => \"bin\"),\n            start: 0,\n            end: 0,\n            size: 5,\n            id: 3,\n        };\n        let key = page_key(\n            request.package_id(),\n            request.channels[0].id(),\n            config.page_size(),\n            page2.id,\n        );\n        db.upsert_page(&database::PageRecord::new(\n            key,\n            false,\n            true,\n            config.page_size() as i64,\n        ))\n        .unwrap();\n        let data: [f64; 10] = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0];\n        assert!(page.write(&page_creator, &config, 0, &data[0..5]).is_ok());\n        assert!(page2.write(&page_creator, &config, 0, &data[5..10]).is_ok());\n        let mut iter = response.owned_chunk_response_iter(db);\n        let mut chunk = ChunkResponse::new();\n        chunk.set_channels(RepeatedField::from_vec(Vec::new()));\n        chunk.channels.push(proto::create_channel_chunk(\n            String::from(\"cache_c1_r2\"),\n            vec![\n                proto::create_datum(10, 0.0),\n                proto::create_datum(11, 1.0),\n                proto::create_datum(12, 2.0),\n                proto::create_datum(13, 3.0),\n                proto::create_datum(14, 4.0),\n                proto::create_datum(15, 5.0),\n                proto::create_datum(16, 6.0),\n                proto::create_datum(17, 7.0),\n                proto::create_datum(18, 8.0),\n                proto::create_datum(19, 9.0),\n            ],\n        ));\n        assert_eq!(helper_convert_chunk(&iter.next().unwrap().unwrap()), chunk);\n        assert!(iter.next().is_none());\n"]], "pred": {"ppl": 2.1566224098205566, "ppl_lower": 2.2908387184143066, "ppl/lowercase_ppl": -1.0785573233317838, "ppl/zlib": 0.0009753087546769095, "Min_5.0% Prob": 6.9847796115469425, "Min_10.0% Prob": 5.317810555721851, "Min_20.0% Prob": 3.461986002783296, "Min_30.0% Prob": 2.4943426911469917, "Min_40.0% Prob": 1.9133771705446105, "Min_50.0% Prob": 1.5366129162534283, "Min_60.0% Prob": 1.281008848710999}}
{"hexsha": "82b7a8c3841632f4e510c79b3dbea6edeab19146", "ext": "rs", "lang": "Rust", "content": "fn sign_and_recover_public_works_with_zeroed_messages() {\n\t\tlet keypair = Random.generate();\n\t\tlet signature = sign(keypair.secret(), &Message::zero()).unwrap();\n\t\tlet zero_message = Message::zero();\n\t\tassert_eq!(keypair.public(), &recover(&signature, &zero_message).unwrap());\n\t}", "item_id": 7, "repo": "gilescope/tetsy-common", "file": "tetsy-crypto/src/publickey/ecdsa_signature.rs", "last_update_at": "2021-03-05T07:49:42+00:00", "question_id": "82b7a8c3841632f4e510c79b3dbea6edeab19146_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn sign_and_recover_public_works_with_zeroed_messages() {\n\t\tlet keypair = Random.generate();\n\t\tlet signature = sign(keypair.secret(), &Message::zero()).unwrap();\n\t\tlet zero_message = Message::zero();\n\t\tassert_eq!(keypair.public(), &recover(&signature, &zero_message).unwrap());\n"]], "pred": {"ppl": 4.320279598236084, "ppl_lower": 4.701408386230469, "ppl/lowercase_ppl": -1.0577740968825133, "ppl/zlib": 0.008458497814887635, "Min_5.0% Prob": 10.126769542694092, "Min_10.0% Prob": 8.09122371673584, "Min_20.0% Prob": 5.853133016162449, "Min_30.0% Prob": 4.426066317728588, "Min_40.0% Prob": 3.582307317772427, "Min_50.0% Prob": 2.8843819235867643, "Min_60.0% Prob": 2.442356511817447}}
{"hexsha": "8e1925c4296709eba228d33141458c50add3fc60", "ext": "rs", "lang": "Rust", "content": "async fn main() -> anyhow::Result<()> {\n    init_tracing();\n\n    let polling_period = CliArgs::from_args().period.into();\n\n    let rest_url = format!(\"https://{}\", CliArgs::from_args().rest);\n    let rest_cli = rest_client::ActixRestClient::new(&rest_url)?;\n\n    let kube_client = kube::Client::try_default().await?;\n    let namespace = \"mayastor\";\n\n    // Validate that our \"CRD\" is up to date?\n\n    // Manage the MayastorNode CR\n    let nodes_api: Api<MayastorNode> =\n        Api::namespaced(kube_client.clone(), namespace);\n\n    loop {\n        // Poll for kubernetes nodes and rest nodes\n        // Reconcile from rest into kubernetes\n        if let Err(error) = polling_work(&nodes_api, rest_cli.v0()).await {\n            error!(\"Error while polling: {}\", error);\n        }\n\n        // Sleep till the next poll\n        tokio::time::delay_for(polling_period).await;\n    }\n}", "item_id": 0, "repo": "mtzaurus/Mayastor", "file": "operators/node/src/main.rs", "last_update_at": "2021-01-26T19:02:51+00:00", "question_id": "8e1925c4296709eba228d33141458c50add3fc60_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn main() -> anyhow::Result<()> {\n    init_tracing();\n    let polling_period = CliArgs::from_args().period.into();\n    let rest_url = format!(\"https://{}\", CliArgs::from_args().rest);\n    let rest_cli = rest_client::ActixRestClient::new(&rest_url)?;\n    let kube_client = kube::Client::try_default().await?;\n    let namespace = \"mayastor\";\n    // Validate that our \"CRD\" is up to date?\n    // Manage the MayastorNode CR\n    let nodes_api: Api<MayastorNode> =\n        Api::namespaced(kube_client.clone(), namespace);\n    loop {\n        // Poll for kubernetes nodes and rest nodes\n        // Reconcile from rest into kubernetes\n        if let Err(error) = polling_work(&nodes_api, rest_cli.v0()).await {\n            error!(\"Error while polling: {}\", error);\n        }\n        // Sleep till the next poll\n        tokio::time::delay_for(polling_period).await;\n    }\n"]], "pred": {"ppl": 3.489593744277954, "ppl_lower": 5.110796928405762, "ppl/lowercase_ppl": -1.305308452326931, "ppl/zlib": 0.002777300719528125, "Min_5.0% Prob": 8.506715978894915, "Min_10.0% Prob": 6.960277199745178, "Min_20.0% Prob": 4.942399560359487, "Min_30.0% Prob": 3.77374428233435, "Min_40.0% Prob": 3.033577973382515, "Min_50.0% Prob": 2.4796995673771507, "Min_60.0% Prob": 2.0807288473385364}}
{"hexsha": "7797a8763e556064e5c587a9fe55e0102cd24eb2", "ext": "rs", "lang": "Rust", "content": "async fn ws_index(\n    req: HttpRequest,\n    stream: web::Payload,\n    data: Data<Mutex<AppState>>,\n) -> Result<HttpResponse, Error> {\n    let mut res = ws::handshake(&req)?;\n\n    let (user, is_new) = req\n        .cookie(\"session_id\")\n        .and_then(|cookie| Uuid::from_str(cookie.value()).ok())\n        .and_then(|uuid| data.lock().unwrap().user_with_session_id(uuid.as_u128()))\n        .map_or_else(\n            /* no such user. create new */\n            || (data.lock().unwrap().create_user(), true),\n            /* existing user */\n            |u| (u, false),\n        );\n\n    if is_new {\n        println!(\n            \"User created with user id {} and session id {}\",\n            &user.id, &user.session_id\n        );\n\n        res.cookie(\n            Cookie::build(\"session_id\", &Uuid::from_u128(user.session_id).to_string())\n                .http_only(true)\n                .secure(false)\n                .same_site(SameSite::Strict)\n                .finish(),\n        );\n    }\n\n    Ok(res.streaming(WebsocketContext::create(WebSocket::new(user, data), stream)))\n}", "item_id": 0, "repo": "urholaukkarinen/planpoker", "file": "crates/backend/src/main.rs", "last_update_at": "2021-09-18T17:29:30+00:00", "question_id": "7797a8763e556064e5c587a9fe55e0102cd24eb2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn ws_index(\n    req: HttpRequest,\n    stream: web::Payload,\n    data: Data<Mutex<AppState>>,\n) -> Result<HttpResponse, Error> {\n    let mut res = ws::handshake(&req)?;\n    let (user, is_new) = req\n        .cookie(\"session_id\")\n        .and_then(|cookie| Uuid::from_str(cookie.value()).ok())\n        .and_then(|uuid| data.lock().unwrap().user_with_session_id(uuid.as_u128()))\n        .map_or_else(\n            /* no such user. create new */\n            || (data.lock().unwrap().create_user(), true),\n            /* existing user */\n            |u| (u, false),\n        );\n    if is_new {\n        println!(\n            \"User created with user id {} and session id {}\",\n            &user.id, &user.session_id\n        );\n        res.cookie(\n            Cookie::build(\"session_id\", &Uuid::from_u128(user.session_id).to_string())\n                .http_only(true)\n                .secure(false)\n                .same_site(SameSite::Strict)\n                .finish(),\n        );\n    }\n    Ok(res.streaming(WebsocketContext::create(WebSocket::new(user, data), stream)))\n"]], "pred": {"ppl": 2.1038529872894287, "ppl_lower": 2.7800331115722656, "ppl/lowercase_ppl": -1.374702208503635, "ppl/zlib": 0.0014248475468830195, "Min_5.0% Prob": 6.283086580388686, "Min_10.0% Prob": 4.7145443173015815, "Min_20.0% Prob": 3.1781845495981327, "Min_30.0% Prob": 2.3616785800572737, "Min_40.0% Prob": 1.8431515078583773, "Min_50.0% Prob": 1.4819153563530987, "Min_60.0% Prob": 1.2405143665303522}}
{"hexsha": "e6d58775c43459dfd4d37f11d0ed6bc9767659e5", "ext": "rs", "lang": "Rust", "content": "fn test(u: &mut Unstructured) -> arbitrary::Result<()> {\n    let mut pb = RowProblem::default();\n    let vars = u\n        .arbitrary_iter::<ColData>()?\n        .map(|cd| {\n            let cd = cd?;\n            Ok(pb.add_column_with_integrality(cd.val, cd.range, cd.integrality))\n        })\n        .collect::<Result<Vec<_>, _>>()?;\n\n    let num_rows = u.arbitrary::<u8>()? as usize;\n\n    for _ in 0..num_rows {\n        let range = u.arbitrary::<Range<f64>>()?;\n        pb.add_row(\n            range,\n            &[\n                (*u.choose(&vars)?, u.arbitrary()?),\n                (*u.choose(&vars)?, u.arbitrary()?),\n                (*u.choose(&vars)?, u.arbitrary()?),\n            ],\n        );\n    }\n    if let Ok(solved) = pb\n        .try_optimise(*u.choose(&[Sense::Maximise, Sense::Minimise])?)\n        .and_then(|p| p.try_solve())\n    {\n        let solution = solved.get_solution();\n        // The expected solution is x=0  y=6  z=0.5\n        assert_eq!(solution.columns().len(), vars.len());\n        // All the constraints are at their maximum\n        assert_eq!(solution.rows().len(), num_rows);\n    }\n    Ok(())\n}", "item_id": 0, "repo": "rust-or/highs", "file": "fuzz/fuzz_targets/fuzz_target_1.rs", "last_update_at": "2021-08-31T23:22:19+00:00", "question_id": "e6d58775c43459dfd4d37f11d0ed6bc9767659e5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test(u: &mut Unstructured) -> arbitrary::Result<()> {\n    let mut pb = RowProblem::default();\n    let vars = u\n        .arbitrary_iter::<ColData>()?\n        .map(|cd| {\n            let cd = cd?;\n            Ok(pb.add_column_with_integrality(cd.val, cd.range, cd.integrality))\n        })\n        .collect::<Result<Vec<_>, _>>()?;\n    let num_rows = u.arbitrary::<u8>()? as usize;\n    for _ in 0..num_rows {\n        let range = u.arbitrary::<Range<f64>>()?;\n        pb.add_row(\n            range,\n            &[\n                (*u.choose(&vars)?, u.arbitrary()?),\n                (*u.choose(&vars)?, u.arbitrary()?),\n                (*u.choose(&vars)?, u.arbitrary()?),\n            ],\n        );\n    }\n    if let Ok(solved) = pb\n        .try_optimise(*u.choose(&[Sense::Maximise, Sense::Minimise])?)\n        .and_then(|p| p.try_solve())\n    {\n        let solution = solved.get_solution();\n        // The expected solution is x=0  y=6  z=0.5\n        assert_eq!(solution.columns().len(), vars.len());\n        // All the constraints are at their maximum\n        assert_eq!(solution.rows().len(), num_rows);\n    }\n    Ok(())\n"]], "pred": {"ppl": 2.6422572135925293, "ppl_lower": 3.2502851486206055, "ppl/lowercase_ppl": -1.213155640868997, "ppl/zlib": 0.0019240268455410305, "Min_5.0% Prob": 7.212498539372494, "Min_10.0% Prob": 5.669748006722866, "Min_20.0% Prob": 3.973393038858341, "Min_30.0% Prob": 3.020642881633855, "Min_40.0% Prob": 2.3873470076654533, "Min_50.0% Prob": 1.9356800981166988, "Min_60.0% Prob": 1.618521688795578}}
{"hexsha": "f7764a7b910883eaa0ac2a9d732419667b2bb020", "ext": "rs", "lang": "Rust", "content": "fn grid_grid_bounds() {\n        let mut nodes = Vec::new();\n        nodes.push(Node {\n            latitude: 10.0,\n            longitude: 30.0,\n            rank: 0,\n        });\n        nodes.push(Node {\n            latitude: 20.0,\n            longitude: 30.0,\n            rank: 0,\n        });\n        nodes.push(Node {\n            latitude: 10.0,\n            longitude: 40.0,\n            rank: 0,\n        });\n        nodes.push(Node {\n            latitude: 20.0,\n            longitude: 40.0,\n            rank: 0,\n        });\n\n        let grid_bounds: GridBounds = get_min_max(&nodes);\n\n        assert_eq!(grid_bounds.lat_min, 10.0);\n        assert_eq!(grid_bounds.lat_max, 20.0);\n        assert_eq!(grid_bounds.lng_min, 30.0);\n        assert_eq!(grid_bounds.lng_max, 40.0);\n    }", "item_id": 3, "repo": "Stunkymonkey/osm_dijkstra", "file": "pre/src/grid.rs", "last_update_at": "2021-08-05T08:22:32+00:00", "question_id": "f7764a7b910883eaa0ac2a9d732419667b2bb020_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn grid_grid_bounds() {\n        let mut nodes = Vec::new();\n        nodes.push(Node {\n            latitude: 10.0,\n            longitude: 30.0,\n            rank: 0,\n        });\n        nodes.push(Node {\n            latitude: 20.0,\n            longitude: 30.0,\n            rank: 0,\n        });\n        nodes.push(Node {\n            latitude: 10.0,\n            longitude: 40.0,\n            rank: 0,\n        });\n        nodes.push(Node {\n            latitude: 20.0,\n            longitude: 40.0,\n            rank: 0,\n        });\n        let grid_bounds: GridBounds = get_min_max(&nodes);\n        assert_eq!(grid_bounds.lat_min, 10.0);\n        assert_eq!(grid_bounds.lat_max, 20.0);\n        assert_eq!(grid_bounds.lng_min, 30.0);\n        assert_eq!(grid_bounds.lng_max, 40.0);\n"]], "pred": {"ppl": 1.546621322631836, "ppl_lower": 1.7095588445663452, "ppl/lowercase_ppl": -1.229692383786663, "ppl/zlib": 0.002148141674267959, "Min_5.0% Prob": 6.127717715043288, "Min_10.0% Prob": 3.7827099252630165, "Min_20.0% Prob": 2.1147014197978105, "Min_30.0% Prob": 1.4543786657201807, "Min_40.0% Prob": 1.0890139280056412, "Min_50.0% Prob": 0.8750631296208441, "Min_60.0% Prob": 0.7267016001895888}}
{"hexsha": "c5b695c239fa08a25f26f9b9d67d23af0b1b272f", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<(), Infallible> {\n    // Set up the window.\n    let output_settings = OutputSettingsBuilder::new().scale(3).build();\n    let mut window = Window::new(\"Interactive TextBox demonstration\", &output_settings);\n\n    let text = \"  Hello, World!\\n  \\\n        Lorem Ipsum is simply dummy text of the printing and typesetting industry.   \\\n        Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when \\\n        an unknown printer took a galley of type and scrambled it to make a type specimen book.\";\n\n    let character_style = MonoTextStyleBuilder::new()\n        .font(&FONT_6X10)\n        .text_color(Rgb888::WHITE)\n        .background_color(Rgb888::CSS_STEEL_BLUE)\n        .build();\n\n    // Create a simulated display.\n    let mut display = SimulatorDisplay::new(Size::new(255, 140));\n\n    // Create bounding boxes\n    let bounds = Rectangle::new(Point::zero(), Size::new(255, 140));\n\n    // Create and draw the text boxes.\n    TextBox::with_textbox_style(\n        text,\n        bounds.resized(Size::new(128, 255), AnchorPoint::TopLeft),\n        character_style,\n        TextBoxStyleBuilder::default().build(),\n    )\n    .draw(&mut display)?;\n\n    TextBox::with_textbox_style(\n        text,\n        bounds.resized(Size::new(128, 255), AnchorPoint::TopRight),\n        character_style,\n        TextBoxStyleBuilder::default()\n            .leading_spaces(false)\n            .trailing_spaces(true)\n            .build(),\n    )\n    .draw(&mut display)?;\n\n    // Update the window.\n    window.show_static(&display);\n\n    Ok(())\n}", "item_id": 0, "repo": "embedded-graphics/embedded-text", "file": "examples/whitespace_control.rs", "last_update_at": "2021-12-19T21:38:40+00:00", "question_id": "c5b695c239fa08a25f26f9b9d67d23af0b1b272f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<(), Infallible> {\n    // Set up the window.\n    let output_settings = OutputSettingsBuilder::new().scale(3).build();\n    let mut window = Window::new(\"Interactive TextBox demonstration\", &output_settings);\n    let text = \"  Hello, World!\\n  \\\n        Lorem Ipsum is simply dummy text of the printing and typesetting industry.   \\\n        Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when \\\n        an unknown printer took a galley of type and scrambled it to make a type specimen book.\";\n    let character_style = MonoTextStyleBuilder::new()\n        .font(&FONT_6X10)\n        .text_color(Rgb888::WHITE)\n        .background_color(Rgb888::CSS_STEEL_BLUE)\n        .build();\n    // Create a simulated display.\n    let mut display = SimulatorDisplay::new(Size::new(255, 140));\n    // Create bounding boxes\n    let bounds = Rectangle::new(Point::zero(), Size::new(255, 140));\n    // Create and draw the text boxes.\n    TextBox::with_textbox_style(\n        text,\n        bounds.resized(Size::new(128, 255), AnchorPoint::TopLeft),\n        character_style,\n        TextBoxStyleBuilder::default().build(),\n    )\n    .draw(&mut display)?;\n    TextBox::with_textbox_style(\n        text,\n        bounds.resized(Size::new(128, 255), AnchorPoint::TopRight),\n        character_style,\n        TextBoxStyleBuilder::default()\n            .leading_spaces(false)\n            .trailing_spaces(true)\n            .build(),\n    )\n    .draw(&mut display)?;\n    // Update the window.\n    window.show_static(&display);\n    Ok(())\n"]], "pred": {"ppl": 1.945581078529358, "ppl_lower": 2.688873767852783, "ppl/lowercase_ppl": -1.4861491234254531, "ppl/zlib": 0.0009758954361876249, "Min_5.0% Prob": 6.525392721096675, "Min_10.0% Prob": 4.669052566800799, "Min_20.0% Prob": 3.045145628428218, "Min_30.0% Prob": 2.1664282982581415, "Min_40.0% Prob": 1.6570092961944716, "Min_50.0% Prob": 1.3304056138356006, "Min_60.0% Prob": 1.1090745878915285}}
{"hexsha": "8655321cf0a47b83e7cd094735b141fad56c379d", "ext": "rs", "lang": "Rust", "content": "pub fn mint(account: &AccountInfo) -> Result<Pubkey, ProgramError> {\n        let bytes = account.try_borrow_data()?;\n        let mut mint_bytes = [0u8; 32];\n        mint_bytes.copy_from_slice(&bytes[..32]);\n        Ok(Pubkey::new_from_array(mint_bytes))\n    }", "item_id": 2, "repo": "theycallmeswift/anchor", "file": "spl/src/token.rs", "last_update_at": "2021-12-06T01:27:34+00:00", "question_id": "8655321cf0a47b83e7cd094735b141fad56c379d_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn mint(account: &AccountInfo) -> Result<Pubkey, ProgramError> {\n        let bytes = account.try_borrow_data()?;\n        let mut mint_bytes = [0u8; 32];\n        mint_bytes.copy_from_slice(&bytes[..32]);\n        Ok(Pubkey::new_from_array(mint_bytes))\n"]], "pred": {"ppl": 2.458904266357422, "ppl_lower": 3.57894229888916, "ppl/lowercase_ppl": -1.4171889237106698, "ppl/zlib": 0.005083140285510319, "Min_5.0% Prob": 9.651774406433105, "Min_10.0% Prob": 6.381445142957899, "Min_20.0% Prob": 3.9838186502456665, "Min_30.0% Prob": 2.9033732921988875, "Min_40.0% Prob": 2.269514662110143, "Min_50.0% Prob": 1.7938807320821544, "Min_60.0% Prob": 1.5036630867726424}}
{"hexsha": "8afc5fd03c125c114bbce45535e8420c52319003", "ext": "rs", "lang": "Rust", "content": "fn is_filtered(\n    ii: &IterInfo,\n    current_day: u64,\n    properties: &RRuleProperties,\n) -> Result<bool, RRuleError> {\n    // TODO break this up into parts because this is unmaintainable.\n\n    let by_month: bool = !properties.by_month.is_empty()\n        && !properties\n            .by_month\n            .contains(&ii.month_mask()[current_day as usize]);\n\n    let by_week_no: bool = !properties.by_week_no.is_empty()\n        && (ii.week_no_mask().unwrap()[current_day as usize]) == 0;\n\n    let by_weekday_every_week_only = properties\n        .by_weekday\n        .iter()\n        .filter_map(|by_weekday| match by_weekday {\n            // Filter out only `Every` occurrences.\n            NWeekday::Every(weekday) => Some(weekday.num_days_from_monday() as i16),\n            NWeekday::Nth(_number, _weekday) => None,\n        })\n        .collect::<Vec<_>>();\n    let by_weekday: bool = !by_weekday_every_week_only.is_empty()\n        && !includes(\n            &by_weekday_every_week_only,\n            &(ii.weekday_mask()[current_day as usize] as i16),\n        );\n\n    let neg_weekday_mask: bool = ii.neg_weekday_mask().is_some()\n        && !ii.neg_weekday_mask().unwrap().is_empty()\n        && (ii.neg_weekday_mask().unwrap()[current_day as usize]) == 0;\n\n    // Can only be set to true if feature flag is set.\n    let by_easter: bool = if cfg!(feature = \"by-easter\") {\n        properties.by_easter.is_some()\n            && !(includes(ii.easter_mask().unwrap(), &(current_day as isize)))\n    } else {\n        false\n    };\n\n    let by_month_day: bool = (!properties.by_month_day.is_empty()\n        || !properties.by_n_month_day.is_empty())\n        && !includes(\n            &properties.by_month_day,\n            &(ii.month_day_mask()[current_day as usize]),\n        )\n        && !includes(\n            &properties.by_n_month_day,\n            &(ii.neg_month_day_mask()[current_day as usize]),\n        );\n\n    let by_year_day: bool = !properties.by_year_day.is_empty()\n        && ((current_day < ii.year_len().unwrap() as u64\n            && !includes(&properties.by_year_day, &(current_day as i16 + 1))\n            && !includes(\n                &properties.by_year_day,\n                &(current_day as i16 - ii.year_len().unwrap() as i16),\n            ))\n            || (current_day >= ii.year_len().unwrap() as u64\n                && !includes(\n                    &properties.by_year_day,\n                    &(current_day as i16 + 1 - ii.year_len().unwrap() as i16),\n                )\n                && !includes(\n                    &properties.by_year_day,\n                    &(current_day as i16\n                        - ii.next_year_len().unwrap() as i16\n                        - ii.year_len().unwrap() as i16),\n                )));\n    Ok(by_month\n        || by_week_no\n        || by_weekday\n        || neg_weekday_mask\n        || by_easter\n        || by_month_day\n        || by_year_day)\n}", "item_id": 1, "repo": "aggregat4/rust-rrule", "file": "rrule/src/iter/mod.rs", "last_update_at": "2021-09-16T22:00:57+00:00", "question_id": "8afc5fd03c125c114bbce45535e8420c52319003_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn is_filtered(\n    ii: &IterInfo,\n    current_day: u64,\n    properties: &RRuleProperties,\n) -> Result<bool, RRuleError> {\n    // TODO break this up into parts because this is unmaintainable.\n    let by_month: bool = !properties.by_month.is_empty()\n        && !properties\n            .by_month\n            .contains(&ii.month_mask()[current_day as usize]);\n    let by_week_no: bool = !properties.by_week_no.is_empty()\n        && (ii.week_no_mask().unwrap()[current_day as usize]) == 0;\n    let by_weekday_every_week_only = properties\n        .by_weekday\n        .iter()\n        .filter_map(|by_weekday| match by_weekday {\n            // Filter out only `Every` occurrences.\n            NWeekday::Every(weekday) => Some(weekday.num_days_from_monday() as i16),\n            NWeekday::Nth(_number, _weekday) => None,\n        })\n        .collect::<Vec<_>>();\n    let by_weekday: bool = !by_weekday_every_week_only.is_empty()\n        && !includes(\n            &by_weekday_every_week_only,\n            &(ii.weekday_mask()[current_day as usize] as i16),\n        );\n    let neg_weekday_mask: bool = ii.neg_weekday_mask().is_some()\n        && !ii.neg_weekday_mask().unwrap().is_empty()\n        && (ii.neg_weekday_mask().unwrap()[current_day as usize]) == 0;\n    // Can only be set to true if feature flag is set.\n    let by_easter: bool = if cfg!(feature = \"by-easter\") {\n        properties.by_easter.is_some()\n            && !(includes(ii.easter_mask().unwrap(), &(current_day as isize)))\n    } else {\n        false\n    };\n    let by_month_day: bool = (!properties.by_month_day.is_empty()\n        || !properties.by_n_month_day.is_empty())\n        && !includes(\n            &properties.by_month_day,\n            &(ii.month_day_mask()[current_day as usize]),\n        )\n        && !includes(\n            &properties.by_n_month_day,\n            &(ii.neg_month_day_mask()[current_day as usize]),\n        );\n    let by_year_day: bool = !properties.by_year_day.is_empty()\n        && ((current_day < ii.year_len().unwrap() as u64\n            && !includes(&properties.by_year_day, &(current_day as i16 + 1))\n            && !includes(\n                &properties.by_year_day,\n                &(current_day as i16 - ii.year_len().unwrap() as i16),\n            ))\n            || (current_day >= ii.year_len().unwrap() as u64\n                && !includes(\n                    &properties.by_year_day,\n                    &(current_day as i16 + 1 - ii.year_len().unwrap() as i16),\n                )\n                && !includes(\n                    &properties.by_year_day,\n                    &(current_day as i16\n                        - ii.next_year_len().unwrap() as i16\n                        - ii.year_len().unwrap() as i16),\n                )));\n    Ok(by_month\n        || by_week_no\n        || by_weekday\n        || neg_weekday_mask\n        || by_easter\n        || by_month_day\n        || by_year_day)\n"]], "pred": {"ppl": 1.7662386894226074, "ppl_lower": 1.858993649482727, "ppl/lowercase_ppl": -1.0899759845436747, "ppl/zlib": 0.0007397298456074975, "Min_5.0% Prob": 6.084088437100674, "Min_10.0% Prob": 4.337714861568652, "Min_20.0% Prob": 2.64983532285191, "Min_30.0% Prob": 1.8608399506541495, "Min_40.0% Prob": 1.4146102060109143, "Min_50.0% Prob": 1.1358525889803168, "Min_60.0% Prob": 0.9490248962818201}}
{"hexsha": "c22c89dbf384bf15f4c9122e54ff069cc0d78ef3", "ext": "rs", "lang": "Rust", "content": "fn get_configs_provider() -> Vec<(Config, String)> {\n        let config_without_countries = Config {\n            http: false,\n            https: true,\n            ipv4: false,\n            ipv6: true,\n            countries: None,\n        };\n\n        let countries = Some(vec![\"France\".to_string()]);\n\n        let full_config = Config {\n            http: true,\n            https: true,\n            ipv4: true,\n            ipv6: true,\n            countries,\n        };\n\n        vec![\n            (\n                config_without_countries,\n                \"https://www.archlinux.org/mirrorlist/?&ip_version=6&protocol=https\".to_string(),\n            ),\n            (full_config, \"https://www.archlinux.org/mirrorlist/?&ip_version=4&ip_version=6&protocol=http&protocol=https&country=FR\".to_string()),\n        ]\n    }", "item_id": 1, "repo": "shempignon/scaramanga", "file": "src/uri.rs", "last_update_at": "2021-04-06T15:18:44+00:00", "question_id": "c22c89dbf384bf15f4c9122e54ff069cc0d78ef3_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_configs_provider() -> Vec<(Config, String)> {\n        let config_without_countries = Config {\n            http: false,\n            https: true,\n            ipv4: false,\n            ipv6: true,\n            countries: None,\n        };\n        let countries = Some(vec![\"France\".to_string()]);\n        let full_config = Config {\n            http: true,\n            https: true,\n            ipv4: true,\n            ipv6: true,\n            countries,\n        };\n        vec![\n            (\n                config_without_countries,\n                \"https://www.archlinux.org/mirrorlist/?&ip_version=6&protocol=https\".to_string(),\n            ),\n            (full_config, \"https://www.archlinux.org/mirrorlist/?&ip_version=4&ip_version=6&protocol=http&protocol=https&country=FR\".to_string()),\n        ]\n"]], "pred": {"ppl": 2.071943759918213, "ppl_lower": 2.317610025405884, "ppl/lowercase_ppl": -1.1538109592097752, "ppl/zlib": 0.0025560953723938458, "Min_5.0% Prob": 7.216459491036155, "Min_10.0% Prob": 5.069300226543261, "Min_20.0% Prob": 3.2586319218290614, "Min_30.0% Prob": 2.3859552213123867, "Min_40.0% Prob": 1.8162265018896853, "Min_50.0% Prob": 1.4545113127994336, "Min_60.0% Prob": 1.2188308210349938}}
{"hexsha": "c1efd2a6e176a4d02f2e9319a256d5ffc6a25ec7", "ext": "rs", "lang": "Rust", "content": "fn shape_for_elementwise_op(sh1: &[usize], sh2: &[usize]) -> Vec<usize> {\n    let mut out_sh = vec![0usize; max(sh2.len(), sh1.len())];\n    if sh1.len() == sh2.len() {\n        for i in 0..sh1.len() {\n            out_sh[i] = max(sh1[i], sh2[i]);\n        }\n    } else if sh1.len() > sh2.len() {\n        assert!(false);\n    } else if sh2.len() > sh1.len() {\n        assert!(false);\n    }\n    out_sh\n}", "item_id": 1, "repo": "neutronest/numeric", "file": "src/tensor/generics.rs", "last_update_at": "2021-08-08T03:45:23+00:00", "question_id": "c1efd2a6e176a4d02f2e9319a256d5ffc6a25ec7_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn shape_for_elementwise_op(sh1: &[usize], sh2: &[usize]) -> Vec<usize> {\n    let mut out_sh = vec![0usize; max(sh2.len(), sh1.len())];\n    if sh1.len() == sh2.len() {\n        for i in 0..sh1.len() {\n            out_sh[i] = max(sh1[i], sh2[i]);\n        }\n    } else if sh1.len() > sh2.len() {\n        assert!(false);\n    } else if sh2.len() > sh1.len() {\n        assert!(false);\n    }\n    out_sh\n"]], "pred": {"ppl": 2.0161070823669434, "ppl_lower": 2.1868057250976562, "ppl/lowercase_ppl": -1.1159114322156214, "ppl/zlib": 0.0035592307870657264, "Min_5.0% Prob": 8.001981616020203, "Min_10.0% Prob": 5.857692867517471, "Min_20.0% Prob": 3.4142473647088716, "Min_30.0% Prob": 2.3383571526408193, "Min_40.0% Prob": 1.7646277970008886, "Min_50.0% Prob": 1.4093341335676433, "Min_60.0% Prob": 1.1727158337287458}}
{"hexsha": "cfab3bec9b2a338d3090f711b11015e75d5e4555", "ext": "rs", "lang": "Rust", "content": "pub fn XMVectorFloor(V: FXMVECTOR) -> XMVECTOR {\n    #[cfg(_XM_NO_INTRINSICS_)]\n    unsafe {\n        let Result = XMVECTORF32 {\n            f: [\n                floorf(V.vector4_f32[0]),\n                floorf(V.vector4_f32[1]),\n                floorf(V.vector4_f32[2]),\n                floorf(V.vector4_f32[3])\n            ]\n        };\n        return Result.v;\n    }\n\n    #[cfg(_XM_ARM_NEON_INTRINSICS_)]\n    {\n        unimplemented!()\n    }\n\n    #[cfg(_XM_SSE4_INTRINSICS_)]\n    unsafe {\n        return _mm_floor_ps(V);\n    }\n\n    #[cfg(all(not(_XM_SSE4_INTRINSICS_), _XM_SSE_INTRINSICS_))]\n    unsafe {\n        // To handle NAN, INF and numbers greater than 8388608, use masking\n        let mut vTest: __m128i = _mm_and_si128(_mm_castps_si128(V), g_XMAbsMask.m128i());\n        vTest = _mm_cmplt_epi32(vTest, g_XMNoFraction.m128i());\n        // Truncate\n        let vInt: __m128i = _mm_cvttps_epi32(V);\n        let mut vResult: XMVECTOR = _mm_cvtepi32_ps(vInt);\n        let mut vLarger: __m128 = _mm_cmpgt_ps(vResult, V);\n        // 0 -> 0, 0xffffffff -> -1.0f\n        vLarger = _mm_cvtepi32_ps(_mm_castps_si128(vLarger));\n        vResult = _mm_add_ps(vResult, vLarger);\n        // All numbers less than 8388608 will use the round to int\n        vResult = _mm_and_ps(vResult, _mm_castsi128_ps(vTest));\n        // All others, use the ORIGINAL value\n        vTest = _mm_andnot_si128(vTest, _mm_castps_si128(V));\n        vResult = _mm_or_ps(vResult, _mm_castsi128_ps(vTest));\n        return vResult;\n    }\n}", "item_id": 71, "repo": "aloucks/directx_math", "file": "src/vector.rs", "last_update_at": "2021-03-15T21:14:40+00:00", "question_id": "cfab3bec9b2a338d3090f711b11015e75d5e4555_71", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn XMVectorFloor(V: FXMVECTOR) -> XMVECTOR {\n    #[cfg(_XM_NO_INTRINSICS_)]\n    unsafe {\n        let Result = XMVECTORF32 {\n            f: [\n                floorf(V.vector4_f32[0]),\n                floorf(V.vector4_f32[1]),\n                floorf(V.vector4_f32[2]),\n                floorf(V.vector4_f32[3])\n            ]\n        };\n        return Result.v;\n    }\n    #[cfg(_XM_ARM_NEON_INTRINSICS_)]\n    {\n        unimplemented!()\n    }\n    #[cfg(_XM_SSE4_INTRINSICS_)]\n    unsafe {\n        return _mm_floor_ps(V);\n    }\n    #[cfg(all(not(_XM_SSE4_INTRINSICS_), _XM_SSE_INTRINSICS_))]\n    unsafe {\n        // To handle NAN, INF and numbers greater than 8388608, use masking\n        let mut vTest: __m128i = _mm_and_si128(_mm_castps_si128(V), g_XMAbsMask.m128i());\n        vTest = _mm_cmplt_epi32(vTest, g_XMNoFraction.m128i());\n        // Truncate\n        let vInt: __m128i = _mm_cvttps_epi32(V);\n        let mut vResult: XMVECTOR = _mm_cvtepi32_ps(vInt);\n        let mut vLarger: __m128 = _mm_cmpgt_ps(vResult, V);\n        // 0 -> 0, 0xffffffff -> -1.0f\n        vLarger = _mm_cvtepi32_ps(_mm_castps_si128(vLarger));\n        vResult = _mm_add_ps(vResult, vLarger);\n        // All numbers less than 8388608 will use the round to int\n        vResult = _mm_and_ps(vResult, _mm_castsi128_ps(vTest));\n        // All others, use the ORIGINAL value\n        vTest = _mm_andnot_si128(vTest, _mm_castps_si128(V));\n        vResult = _mm_or_ps(vResult, _mm_castsi128_ps(vTest));\n        return vResult;\n    }\n"]], "pred": {"ppl": 1.5168609619140625, "ppl_lower": 1.9793461561203003, "ppl/lowercase_ppl": -1.6387326698759543, "ppl/zlib": 0.000749357990730763, "Min_5.0% Prob": 4.810917854309082, "Min_10.0% Prob": 3.3841223897355976, "Min_20.0% Prob": 2.009945530416374, "Min_30.0% Prob": 1.3789237377420067, "Min_40.0% Prob": 1.0428329759235389, "Min_50.0% Prob": 0.8341593303754031, "Min_60.0% Prob": 0.6946823022981699}}
{"hexsha": "cd3812cfe0410eac4dfe421ab66d7563874e40f0", "ext": "rs", "lang": "Rust", "content": "async fn stream<T>(\n    modio: Modio,\n    route: Route,\n    filter: Filter,\n) -> Result<(impl Stream<Item = Result<Page<T>>>, (u32, u32))>\nwhere\n    T: DeserializeOwned + Send,\n{\n    struct State {\n        offset: u32,\n        limit: u32,\n        remaining: u32,\n    }\n    let list = modio\n        .request(route)\n        .query(&filter)\n        .send::<List<T>>()\n        .await?;\n\n    let state = State {\n        offset: list.offset,\n        limit: list.limit,\n        remaining: list.total - list.count,\n    };\n    let initial = (modio, route, filter, state);\n    let stats = (list.total, list.limit);\n    if list.total == 0 {\n        return Ok((Either::Left(stream::empty()), stats));\n    }\n\n    let first = stream::once(async { Ok::<_, crate::Error>(Page(list)) });\n\n    let others = stream::try_unfold(initial, |(modio, route, filter, state)| async move {\n        if let State { remaining: 0, .. } = state {\n            return Ok(None);\n        }\n        let filter = filter.offset((state.offset + state.limit) as usize);\n        let remaining = state.remaining;\n\n        let list = modio\n            .request(route)\n            .query(&filter)\n            .send::<List<T>>()\n            .await?;\n\n        let state = (\n            modio,\n            route,\n            filter,\n            State {\n                offset: list.offset,\n                limit: list.limit,\n                remaining: remaining - list.count,\n            },\n        );\n\n        Ok(Some((Page(list), state)))\n    });\n\n    Ok((Either::Right(first.chain(others)), stats))\n}", "item_id": 0, "repo": "qwerty541/modio-rs", "file": "src/loader.rs", "last_update_at": "2021-01-03T13:20:19+00:00", "question_id": "cd3812cfe0410eac4dfe421ab66d7563874e40f0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn stream<T>(\n    modio: Modio,\n    route: Route,\n    filter: Filter,\n) -> Result<(impl Stream<Item = Result<Page<T>>>, (u32, u32))>\nwhere\n    T: DeserializeOwned + Send,\n{\n    struct State {\n        offset: u32,\n        limit: u32,\n        remaining: u32,\n    }\n    let list = modio\n        .request(route)\n        .query(&filter)\n        .send::<List<T>>()\n        .await?;\n    let state = State {\n        offset: list.offset,\n        limit: list.limit,\n        remaining: list.total - list.count,\n    };\n    let initial = (modio, route, filter, state);\n    let stats = (list.total, list.limit);\n    if list.total == 0 {\n        return Ok((Either::Left(stream::empty()), stats));\n    }\n    let first = stream::once(async { Ok::<_, crate::Error>(Page(list)) });\n    let others = stream::try_unfold(initial, |(modio, route, filter, state)| async move {\n        if let State { remaining: 0, .. } = state {\n            return Ok(None);\n        }\n        let filter = filter.offset((state.offset + state.limit) as usize);\n        let remaining = state.remaining;\n        let list = modio\n            .request(route)\n            .query(&filter)\n            .send::<List<T>>()\n            .await?;\n        let state = (\n            modio,\n            route,\n            filter,\n            State {\n                offset: list.offset,\n                limit: list.limit,\n                remaining: remaining - list.count,\n            },\n        );\n        Ok(Some((Page(list), state)))\n    });\n    Ok((Either::Right(first.chain(others)), stats))\n"]], "pred": {"ppl": 1.949805736541748, "ppl_lower": 2.2221384048461914, "ppl/lowercase_ppl": -1.1957981253276422, "ppl/zlib": 0.0011632922392451966, "Min_5.0% Prob": 6.5177785356839495, "Min_10.0% Prob": 4.754145669440429, "Min_20.0% Prob": 2.9885235149413347, "Min_30.0% Prob": 2.149144192950593, "Min_40.0% Prob": 1.6572157304423552, "Min_50.0% Prob": 1.3318816784970247, "Min_60.0% Prob": 1.112961219222475}}
{"hexsha": "ad7fc4c92fb99953502143eca5e5134c7fe99c12", "ext": "rs", "lang": "Rust", "content": "fn test_timestamp() -> Result<(), Box<EvalAltResult>> {\n    let engine = Engine::new();\n\n    assert_eq!(engine.eval::<String>(\"type_of(timestamp())\")?, \"timestamp\");\n\n    #[cfg(not(feature = \"no_float\"))]\n    assert!(\n        engine.eval::<FLOAT>(\n            r#\"\n                let time = timestamp();\n                let x = 10_000;\n                while x > 0 { x -= 1; }\n                elapsed(time)\n    \"#\n        )? < 10.0\n    );\n\n    #[cfg(feature = \"no_float\")]\n    assert!(\n        engine.eval::<INT>(\n            r#\"\n                let time = timestamp();\n                let x = 10_000;\n                while x > 0 { x -= 1; }\n                elapsed(time)\n    \"#\n        )? < 10\n    );\n\n    assert!(engine.eval::<bool>(\n        r\"\n            let time1 = timestamp();\n            for x in range(0, 10000) {}\n            let time2 = timestamp();\n            time1 <= time2\n        \"\n    )?);\n\n    Ok(())\n}", "item_id": 0, "repo": "JoNil/rhai", "file": "tests/time.rs", "last_update_at": "2021-05-16T20:44:37+00:00", "question_id": "ad7fc4c92fb99953502143eca5e5134c7fe99c12_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_timestamp() -> Result<(), Box<EvalAltResult>> {\n    let engine = Engine::new();\n    assert_eq!(engine.eval::<String>(\"type_of(timestamp())\")?, \"timestamp\");\n    #[cfg(not(feature = \"no_float\"))]\n    assert!(\n        engine.eval::<FLOAT>(\n            r#\"\n                let time = timestamp();\n                let x = 10_000;\n                while x > 0 { x -= 1; }\n                elapsed(time)\n    \"#\n        )? < 10.0\n    );\n    #[cfg(feature = \"no_float\")]\n    assert!(\n        engine.eval::<INT>(\n            r#\"\n                let time = timestamp();\n                let x = 10_000;\n                while x > 0 { x -= 1; }\n                elapsed(time)\n    \"#\n        )? < 10\n    );\n    assert!(engine.eval::<bool>(\n        r\"\n            let time1 = timestamp();\n            for x in range(0, 10000) {}\n            let time2 = timestamp();\n            time1 <= time2\n        \"\n    )?);\n    Ok(())\n"]], "pred": {"ppl": 1.7198576927185059, "ppl_lower": 2.2433924674987793, "ppl/lowercase_ppl": -1.490090926609488, "ppl/zlib": 0.0016735850327497474, "Min_5.0% Prob": 5.207250642776489, "Min_10.0% Prob": 3.7777742743492126, "Min_20.0% Prob": 2.445346646507581, "Min_30.0% Prob": 1.761993905239635, "Min_40.0% Prob": 1.3437761654538556, "Min_50.0% Prob": 1.0845818687353703, "Min_60.0% Prob": 0.9069358412078607}}
{"hexsha": "5a68a94951885d440ff1e2aa9d37f6728f507942", "ext": "rs", "lang": "Rust", "content": "fn __action454<\n    'input,\n>(\n    input: &'input str,\n    __0: (usize, &'input str, usize),\n) -> Expression\n{\n    let __start0 = __0.2.clone();\n    let __end0 = __0.2.clone();\n    let __temp0 = __action227(\n        input,\n        &__start0,\n        &__end0,\n    );\n    let __temp0 = (__start0, __temp0, __end0);\n    __action345(\n        input,\n        __0,\n        __temp0,\n    )\n}", "item_id": 499, "repo": "casper-ecosystem/caspiler", "file": "src/parser/solidity.rs", "last_update_at": "2021-11-29T21:36:49+00:00", "question_id": "5a68a94951885d440ff1e2aa9d37f6728f507942_499", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn __action454<\n    'input,\n>(\n    input: &'input str,\n    __0: (usize, &'input str, usize),\n) -> Expression\n{\n    let __start0 = __0.2.clone();\n    let __end0 = __0.2.clone();\n    let __temp0 = __action227(\n        input,\n        &__start0,\n        &__end0,\n    );\n    let __temp0 = (__start0, __temp0, __end0);\n    __action345(\n        input,\n        __0,\n        __temp0,\n    )\n"]], "pred": {"ppl": 2.5345702171325684, "ppl_lower": 2.615003824234009, "ppl/lowercase_ppl": -1.033592115977929, "ppl/zlib": 0.005344965994695459, "Min_5.0% Prob": 7.049018927982876, "Min_10.0% Prob": 5.272596534093221, "Min_20.0% Prob": 3.6780913952858216, "Min_30.0% Prob": 2.862188748691393, "Min_40.0% Prob": 2.260605660657729, "Min_50.0% Prob": 1.8382524547095482, "Min_60.0% Prob": 1.5528742603717312}}
{"hexsha": "1cabd56d2d18368ee0fa1f80d4ec95d3b159a436", "ext": "rs", "lang": "Rust", "content": "async fn accept_connection(\n    stream: TcpStream,\n    peer_map: Arc<Mutex<HashMap<String, UnboundedSender<Message>>>>,\n) {\n    let addr = stream\n        .peer_addr()\n        .expect(\"connected streams should have a peer address\");\n    println!(\"Peer address: {}\", addr);\n    let local_addr = format!(\"{:?}\", stream.local_addr());\n\n    let ws_stream = tokio_tungstenite::accept_async(stream)\n        .await\n        .expect(\"Error during the websocket handshake occurred\");\n\n    println!(\"New WebSocket connection: {}\", addr);\n\n    let (tx, rx) = unbounded();\n    peer_map.lock().unwrap().insert(local_addr.clone(), tx);\n    let mut client_id = None;\n\n    let (outgoing, incoming) = ws_stream.split();\n\n    let broadcast_incoming = incoming.try_for_each(|msg| {\n        println!(\"{:?}\", msg);\n        if let Message::Text(text) = msg {\n            let mut peers = peer_map.lock().unwrap();\n            if client_id.is_none() {\n                let tx = peers.remove(&local_addr).unwrap();\n                peers.insert(text.clone(), tx);\n                println!(\"{} registered.\", text);\n                client_id = Some(text);\n            } else {\n                //\u8f6c\u53d1\u6d88\u606f\n                if let Ok(Value::Object(map)) = serde_json::from_str::<Value>(&text) {\n                    if let Some(Value::String(target)) = map.get(\"target\") {\n                        if let Some(tx) = peers.get_mut(target) {\n                            let msg = Message::Binary(vec![\n                                get_as_u8(&map, \"r\"),\n                                get_as_u8(&map, \"g\"),\n                                get_as_u8(&map, \"b\"),\n                            ]);\n                            println!(\"send {:?} to {}\", msg, target);\n                            tx.unbounded_send(msg).unwrap();\n                        }\n                    }\n                }\n            }\n        }\n        future::ok(())\n    });\n\n    let receive_from_others = rx.map(Ok).forward(outgoing);\n\n    pin_mut!(broadcast_incoming, receive_from_others);\n    future::select(broadcast_incoming, receive_from_others).await;\n\n    println!(\"{:?} disconnected\", client_id);\n    if let Some(client_id) = client_id {\n        peer_map.lock().unwrap().remove(&client_id);\n    }\n}", "item_id": 1, "repo": "planet0104/w600_rust", "file": "websocket-server/src/main.rs", "last_update_at": "2021-11-10T03:02:14+00:00", "question_id": "1cabd56d2d18368ee0fa1f80d4ec95d3b159a436_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn accept_connection(\n    stream: TcpStream,\n    peer_map: Arc<Mutex<HashMap<String, UnboundedSender<Message>>>>,\n) {\n    let addr = stream\n        .peer_addr()\n        .expect(\"connected streams should have a peer address\");\n    println!(\"Peer address: {}\", addr);\n    let local_addr = format!(\"{:?}\", stream.local_addr());\n    let ws_stream = tokio_tungstenite::accept_async(stream)\n        .await\n        .expect(\"Error during the websocket handshake occurred\");\n    println!(\"New WebSocket connection: {}\", addr);\n    let (tx, rx) = unbounded();\n    peer_map.lock().unwrap().insert(local_addr.clone(), tx);\n    let mut client_id = None;\n    let (outgoing, incoming) = ws_stream.split();\n    let broadcast_incoming = incoming.try_for_each(|msg| {\n        println!(\"{:?}\", msg);\n        if let Message::Text(text) = msg {\n            let mut peers = peer_map.lock().unwrap();\n            if client_id.is_none() {\n                let tx = peers.remove(&local_addr).unwrap();\n                peers.insert(text.clone(), tx);\n                println!(\"{} registered.\", text);\n                client_id = Some(text);\n            } else {\n                //\u8f6c\u53d1\u6d88\u606f\n                if let Ok(Value::Object(map)) = serde_json::from_str::<Value>(&text) {\n                    if let Some(Value::String(target)) = map.get(\"target\") {\n                        if let Some(tx) = peers.get_mut(target) {\n                            let msg = Message::Binary(vec![\n                                get_as_u8(&map, \"r\"),\n                                get_as_u8(&map, \"g\"),\n                                get_as_u8(&map, \"b\"),\n                            ]);\n                            println!(\"send {:?} to {}\", msg, target);\n                            tx.unbounded_send(msg).unwrap();\n                        }\n                    }\n                }\n            }\n        }\n        future::ok(())\n    });\n    let receive_from_others = rx.map(Ok).forward(outgoing);\n    pin_mut!(broadcast_incoming, receive_from_others);\n    future::select(broadcast_incoming, receive_from_others).await;\n    println!(\"{:?} disconnected\", client_id);\n    if let Some(client_id) = client_id {\n        peer_map.lock().unwrap().remove(&client_id);\n    }\n"]], "pred": {"ppl": 1.8232386112213135, "ppl_lower": 2.1046974658966064, "ppl/lowercase_ppl": -1.2390175199337845, "ppl/zlib": 0.0007082716703376233, "Min_5.0% Prob": 6.15105938911438, "Min_10.0% Prob": 4.3323975186795, "Min_20.0% Prob": 2.708320808503055, "Min_30.0% Prob": 1.937997234389954, "Min_40.0% Prob": 1.487866887197071, "Min_50.0% Prob": 1.1978748162265545, "Min_60.0% Prob": 1.002248154943521}}
{"hexsha": "e651dc1361ac8e20e4ca80ec309dc43550ff7700", "ext": "rs", "lang": "Rust", "content": "fn get_last_present_count(&self) -> Result<UINT, MethodError> {\n        let mut count = 0;\n        let hr = unsafe { self.as_winapi().GetLastPresentCount(&mut count) };\n        MethodError::check(\"IDirect3DSwapChain9Ex::GetLastPresentCount\", hr)?;\n        Ok(count)\n    }", "item_id": 1, "repo": "MaulingMonkey/thindx", "file": "thindx/src/headers/d3d9.h/interfaces/swap_chain_ex.rs", "last_update_at": "2021-04-18T08:13:18+00:00", "question_id": "e651dc1361ac8e20e4ca80ec309dc43550ff7700_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_last_present_count(&self) -> Result<UINT, MethodError> {\n        let mut count = 0;\n        let hr = unsafe { self.as_winapi().GetLastPresentCount(&mut count) };\n        MethodError::check(\"IDirect3DSwapChain9Ex::GetLastPresentCount\", hr)?;\n        Ok(count)\n"]], "pred": {"ppl": 2.6137917041778564, "ppl_lower": 5.5082783699035645, "ppl/lowercase_ppl": -1.7758625063809406, "ppl/zlib": 0.005193523931463692, "Min_5.0% Prob": 7.570629835128784, "Min_10.0% Prob": 6.060557007789612, "Min_20.0% Prob": 4.256638365633347, "Min_30.0% Prob": 3.1186558168668013, "Min_40.0% Prob": 2.402640244790486, "Min_50.0% Prob": 1.9313719155774876, "Min_60.0% Prob": 1.6112089771777391}}
{"hexsha": "b36722b21e81135bcdc4bfeca1e7c66536ff78ca", "ext": "rs", "lang": "Rust", "content": "fn assert_valid_url_dyno_stop() {\n        let app_id = \"123xyz\";\n        let dyno_id = \"xyz123\";\n        let response = util::get_client().request(&dynos::DynoActionStop {\n            app_id: app_id,\n            dyno_id: dyno_id,\n        });\n        let endpoint = format!(\n            \"{}{}{}{}{}\",\n            \"apps/\", app_id, \"/dynos/\", dyno_id, \"/actions/stop\"\n        );\n        assert_valid_url(response, endpoint)\n    }", "item_id": 1, "repo": "klaxit/heroku_rs", "file": "tests/dynos.rs", "last_update_at": "2021-09-21T04:40:58+00:00", "question_id": "b36722b21e81135bcdc4bfeca1e7c66536ff78ca_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn assert_valid_url_dyno_stop() {\n        let app_id = \"123xyz\";\n        let dyno_id = \"xyz123\";\n        let response = util::get_client().request(&dynos::DynoActionStop {\n            app_id: app_id,\n            dyno_id: dyno_id,\n        });\n        let endpoint = format!(\n            \"{}{}{}{}{}\",\n            \"apps/\", app_id, \"/dynos/\", dyno_id, \"/actions/stop\"\n        );\n        assert_valid_url(response, endpoint)\n"]], "pred": {"ppl": 3.172976016998291, "ppl_lower": 3.5726120471954346, "ppl/lowercase_ppl": -1.1027367514010904, "ppl/zlib": 0.005345694231990422, "Min_5.0% Prob": 8.19475609915597, "Min_10.0% Prob": 6.4767563501993815, "Min_20.0% Prob": 4.668941005071004, "Min_30.0% Prob": 3.567317529519399, "Min_40.0% Prob": 2.8274397775530815, "Min_50.0% Prob": 2.287035008990451, "Min_60.0% Prob": 1.9243352669444713}}
{"hexsha": "901595a7bbe434dc174cef7f75fa9977d9dc48b6", "ext": "rs", "lang": "Rust", "content": "pub fn test() -> Result<()> {\n    let mut renderer = Renderer::new();\n    renderer.test()?;\n\n    Ok(())\n}", "item_id": 0, "repo": "LackingInGrav1tas/intershell", "file": "src/tests.rs", "last_update_at": "2021-06-22T21:01:12+00:00", "question_id": "901595a7bbe434dc174cef7f75fa9977d9dc48b6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn test() -> Result<()> {\n    let mut renderer = Renderer::new();\n    renderer.test()?;\n    Ok(())\n"]], "pred": {"ppl": 4.031712532043457, "ppl_lower": 6.2041802406311035, "ppl/lowercase_ppl": -1.309162800507028, "ppl/zlib": 0.015491013684568188, "Min_5.0% Prob": 10.094831466674805, "Min_10.0% Prob": 9.175361315409342, "Min_20.0% Prob": 5.856287922177996, "Min_30.0% Prob": 4.264666589823636, "Min_40.0% Prob": 3.3773399432500204, "Min_50.0% Prob": 2.7948629620828127, "Min_60.0% Prob": 2.351721703682257}}
{"hexsha": "68fe9419da1524be6091cd178d665446e7ff9910", "ext": "rs", "lang": "Rust", "content": "fn escape_html() {\n    assert_eq!(voca_rs::escape::escape_html(\"\"), \"\");\n    assert_eq!(\n        voca_rs::escape::escape_html(\"<>&\\\"'`\"),\n        \"&lt;&gt;&amp;&quot;&#x27;&#x60;\"\n    );\n    assert_eq!(\n        voca_rs::escape::escape_html(voca_rs::utils::PUNCTUATION),\n        \"!&quot;#$%&amp;&#x27;()*+,-./:;&lt;=&gt;?@[\\\\]^_&#x60;{|}~\"\n    );\n    assert_eq!(\n        voca_rs::escape::escape_html(\"<p>wonderful world</p>\"),\n        \"&lt;p&gt;wonderful world&lt;/p&gt;\"\n    );\n    assert_eq!(voca_rs::escape::escape_html(\"<span>\"), \"&lt;span&gt;\");\n    assert_eq!(\n        voca_rs::escape::escape_html(\"<p>wonderful<span>world<span/></p>\"),\n        \"&lt;p&gt;wonderful&lt;span&gt;world&lt;span/&gt;&lt;/p&gt;\"\n    );\n}", "item_id": 0, "repo": "e1r0nd/voca.rs", "file": "tests/unit/escape.rs", "last_update_at": "2021-08-24T12:27:41+00:00", "question_id": "68fe9419da1524be6091cd178d665446e7ff9910_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn escape_html() {\n    assert_eq!(voca_rs::escape::escape_html(\"\"), \"\");\n    assert_eq!(\n        voca_rs::escape::escape_html(\"<>&\\\"'`\"),\n        \"&lt;&gt;&amp;&quot;&#x27;&#x60;\"\n    );\n    assert_eq!(\n        voca_rs::escape::escape_html(voca_rs::utils::PUNCTUATION),\n        \"!&quot;#$%&amp;&#x27;()*+,-./:;&lt;=&gt;?@[\\\\]^_&#x60;{|}~\"\n    );\n    assert_eq!(\n        voca_rs::escape::escape_html(\"<p>wonderful world</p>\"),\n        \"&lt;p&gt;wonderful world&lt;/p&gt;\"\n    );\n    assert_eq!(voca_rs::escape::escape_html(\"<span>\"), \"&lt;span&gt;\");\n    assert_eq!(\n        voca_rs::escape::escape_html(\"<p>wonderful<span>world<span/></p>\"),\n        \"&lt;p&gt;wonderful&lt;span&gt;world&lt;span/&gt;&lt;/p&gt;\"\n    );\n"]], "pred": {"ppl": 1.6135904788970947, "ppl_lower": 1.6397761106491089, "ppl/lowercase_ppl": -1.0336451254312211, "ppl/zlib": 0.0018617190937964454, "Min_5.0% Prob": 5.695901981989542, "Min_10.0% Prob": 3.9659732695548766, "Min_20.0% Prob": 2.351806855009448, "Min_30.0% Prob": 1.5883311949511791, "Min_40.0% Prob": 1.1997746742293238, "Min_50.0% Prob": 0.9563064783156084, "Min_60.0% Prob": 0.7989522630975463}}
{"hexsha": "e4428ccbf8f776c6cb43e287fdb921f61ccea7a5", "ext": "rs", "lang": "Rust", "content": "pub fn encrypt(i_data:String,i_key:String) -> ENCRYPTED {\n\n    let key = GenericArray::clone_from_slice(i_key.as_bytes());\n    let aead = Aes256Gcm::new(key);\n\n    let my_data = i_data.as_bytes();\n\n    let mut iv: [u8; 12] = [0; 12];\n    let mut rng = thread_rng();\n    rng.fill(&mut iv);\n\n    let nonce = GenericArray::from_slice(&iv); // 96-bits; unique per message\n    let ciphertext = aead.encrypt(nonce, my_data.as_ref()).expect(\"encryption failure!\");\n\n    return ENCRYPTED {\n        nonce:iv.to_vec(),\n        cipher:ciphertext\n    };\n\n}", "item_id": 1, "repo": "gzbakku/fdb", "file": "postoffice/src/client/crypt.rs", "last_update_at": "2021-04-04T09:19:59+00:00", "question_id": "e4428ccbf8f776c6cb43e287fdb921f61ccea7a5_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn encrypt(i_data:String,i_key:String) -> ENCRYPTED {\n    let key = GenericArray::clone_from_slice(i_key.as_bytes());\n    let aead = Aes256Gcm::new(key);\n    let my_data = i_data.as_bytes();\n    let mut iv: [u8; 12] = [0; 12];\n    let mut rng = thread_rng();\n    rng.fill(&mut iv);\n    let nonce = GenericArray::from_slice(&iv); // 96-bits; unique per message\n    let ciphertext = aead.encrypt(nonce, my_data.as_ref()).expect(\"encryption failure!\");\n    return ENCRYPTED {\n        nonce:iv.to_vec(),\n        cipher:ciphertext\n    };\n"]], "pred": {"ppl": 2.213392972946167, "ppl_lower": 2.6966195106506348, "ppl/lowercase_ppl": -1.2485408675016862, "ppl/zlib": 0.0025143247470424505, "Min_5.0% Prob": 7.703602313995361, "Min_10.0% Prob": 5.348407688595, "Min_20.0% Prob": 3.3960689805274784, "Min_30.0% Prob": 2.4820497366098255, "Min_40.0% Prob": 1.9300506512324016, "Min_50.0% Prob": 1.5690828898767812, "Min_60.0% Prob": 1.3261986257651677}}
{"hexsha": "7e936c7d59bc1581235ce46e34b0a29e2d6b7e73", "ext": "rs", "lang": "Rust", "content": "fn nested() {\n        let mut rt = rt();\n        let tokens = [\n            Ident(rt.intern_string(\"hugo\")),\n            Dot,\n            Ident(rt.intern_string(\"name\")),\n            Dot,\n            Ident(rt.intern_string(\"print\")),\n            ParenO,\n            ParenC,\n        ]\n        .map(token)\n        .into();\n        let alloc = Bump::new();\n        let ast = parse_call(tokens, &alloc);\n        insta::assert_debug_snapshot!(ast);\n    }", "item_id": 26, "repo": "Nilstrieb/script_lang", "file": "src/syntax/parse/test.rs", "last_update_at": "2021-11-02T12:07:03+00:00", "question_id": "7e936c7d59bc1581235ce46e34b0a29e2d6b7e73_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn nested() {\n        let mut rt = rt();\n        let tokens = [\n            Ident(rt.intern_string(\"hugo\")),\n            Dot,\n            Ident(rt.intern_string(\"name\")),\n            Dot,\n            Ident(rt.intern_string(\"print\")),\n            ParenO,\n            ParenC,\n        ]\n        .map(token)\n        .into();\n        let alloc = Bump::new();\n        let ast = parse_call(tokens, &alloc);\n        insta::assert_debug_snapshot!(ast);\n"]], "pred": {"ppl": 3.7089548110961914, "ppl_lower": 4.783747673034668, "ppl/lowercase_ppl": -1.1941439131618918, "ppl/zlib": 0.006586683994229782, "Min_5.0% Prob": 9.157702128092447, "Min_10.0% Prob": 7.739896040696364, "Min_20.0% Prob": 5.53208409415351, "Min_30.0% Prob": 4.116597643712672, "Min_40.0% Prob": 3.223727623982863, "Min_50.0% Prob": 2.6166503604339515, "Min_60.0% Prob": 2.1888326242207046}}
{"hexsha": "b562eb5c3b4a82e52f846ee182e8f7e0dff024ad", "ext": "rs", "lang": "Rust", "content": "async fn it_gets_a_character() {\n        let data = \"{ \\\"id\\\": 1, \\\"name\\\": \\\"John Doe\\\", \\\"status\\\": \\\"Alive\\\", \\\"species\\\": \\\"Human\\\", \\\"type\\\": \\\"\\\", \\\"gender\\\": \\\"Male\\\", \\\"origin\\\": { \\\"name\\\": \\\"\\\", \\\"url\\\": \\\"\\\" }, \\\"location\\\": { \\\"name\\\": \\\"\\\", \\\"url\\\": \\\"\\\" }, \\\"image\\\": \\\"mock.jpeg\\\", \\\"episode\\\": [], \\\"url\\\": \\\"mock.mock\\\", \\\"created\\\": \\\"mock\\\" }\";\n\n        let _m = mock(\"GET\", \"/api/character/1\")\n            .with_status(200)\n            .with_header(\"content-type\", \"application/json\")\n            .with_body(data)\n            .create();\n\n        let mut expected = character::Character::default();\n        expected.id = 1;\n        expected.name = \"John Doe\".to_string();\n        expected.status = \"Alive\".to_string();\n        expected.character_type = \"\".to_string();\n        expected.gender = \"Male\".to_string();\n        expected.image = \"mock.jpeg\".to_string();\n        expected.url = \"mock.mock\".to_string();\n        expected.created = \"mock\".to_string();\n        expected.species = \"Human\".to_string();\n\n        let req = character::get(1).await;\n        match req {\n            Ok(c) => {\n                assert_eq!(c, expected)\n            }\n            Err(e) => {\n                println!(\"request error: {:?}\", e);\n                panic!(\"request failed\");\n            }\n        }\n    }", "item_id": 0, "repo": "dshomoye/rick-and-morty", "file": "src/entities/character.rs", "last_update_at": "2021-10-05T19:13:38+00:00", "question_id": "b562eb5c3b4a82e52f846ee182e8f7e0dff024ad_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn it_gets_a_character() {\n        let data = \"{ \\\"id\\\": 1, \\\"name\\\": \\\"John Doe\\\", \\\"status\\\": \\\"Alive\\\", \\\"species\\\": \\\"Human\\\", \\\"type\\\": \\\"\\\", \\\"gender\\\": \\\"Male\\\", \\\"origin\\\": { \\\"name\\\": \\\"\\\", \\\"url\\\": \\\"\\\" }, \\\"location\\\": { \\\"name\\\": \\\"\\\", \\\"url\\\": \\\"\\\" }, \\\"image\\\": \\\"mock.jpeg\\\", \\\"episode\\\": [], \\\"url\\\": \\\"mock.mock\\\", \\\"created\\\": \\\"mock\\\" }\";\n        let _m = mock(\"GET\", \"/api/character/1\")\n            .with_status(200)\n            .with_header(\"content-type\", \"application/json\")\n            .with_body(data)\n            .create();\n        let mut expected = character::Character::default();\n        expected.id = 1;\n        expected.name = \"John Doe\".to_string();\n        expected.status = \"Alive\".to_string();\n        expected.character_type = \"\".to_string();\n        expected.gender = \"Male\".to_string();\n        expected.image = \"mock.jpeg\".to_string();\n        expected.url = \"mock.mock\".to_string();\n        expected.created = \"mock\".to_string();\n        expected.species = \"Human\".to_string();\n        let req = character::get(1).await;\n        match req {\n            Ok(c) => {\n                assert_eq!(c, expected)\n            }\n            Err(e) => {\n                println!(\"request error: {:?}\", e);\n                panic!(\"request failed\");\n            }\n        }\n"]], "pred": {"ppl": 1.75485098361969, "ppl_lower": 1.8825691938400269, "ppl/lowercase_ppl": -1.1249208720583972, "ppl/zlib": 0.0011547924921856121, "Min_5.0% Prob": 6.67028734558507, "Min_10.0% Prob": 4.41186398267746, "Min_20.0% Prob": 2.634396558845198, "Min_30.0% Prob": 1.8456771376317944, "Min_40.0% Prob": 1.4019711569912972, "Min_50.0% Prob": 1.1249399315997881, "Min_60.0% Prob": 0.937964082297833}}
{"hexsha": "e0d1ce9539528d06be2f2b8b239112b6d9e6ee9c", "ext": "rs", "lang": "Rust", "content": "fn send() -> Result<(), RMError> {\n    let config = AppConfig::read()?;\n\n    let mut db = DB::new()?;\n    let stories = db.get_highest_scoring_stories()?;\n    let stories_markup = Story::render_list(&stories);\n\n    let email = make_email_message(&stories_markup, &config);\n    let mailer = make_mailer(&config);\n\n    info!(\"Sending newsletter\");\n    mailer.send(&email)?;\n\n    info!(\"Cleaning up database\");\n    db.mark_highest_scoring_stories()?;\n\n    info!(\"Done!\");\n    Ok(())\n}", "item_id": 1, "repo": "s3thi/reddit-mailer", "file": "src/bin/sender.rs", "last_update_at": "2021-11-29T01:23:49+00:00", "question_id": "e0d1ce9539528d06be2f2b8b239112b6d9e6ee9c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn send() -> Result<(), RMError> {\n    let config = AppConfig::read()?;\n    let mut db = DB::new()?;\n    let stories = db.get_highest_scoring_stories()?;\n    let stories_markup = Story::render_list(&stories);\n    let email = make_email_message(&stories_markup, &config);\n    let mailer = make_mailer(&config);\n    info!(\"Sending newsletter\");\n    mailer.send(&email)?;\n    info!(\"Cleaning up database\");\n    db.mark_highest_scoring_stories()?;\n    info!(\"Done!\");\n    Ok(())\n"]], "pred": {"ppl": 3.093926191329956, "ppl_lower": 3.534085273742676, "ppl/lowercase_ppl": -1.117769426540296, "ppl/zlib": 0.004310843116206668, "Min_5.0% Prob": 7.511826753616333, "Min_10.0% Prob": 5.971121255089255, "Min_20.0% Prob": 4.379583562121672, "Min_30.0% Prob": 3.3677879174550376, "Min_40.0% Prob": 2.685443887815756, "Min_50.0% Prob": 2.217595673308653, "Min_60.0% Prob": 1.8733598847015231}}
{"hexsha": "860e4a9f12c1d2733ac8fe0c1e341ae5ee5988bb", "ext": "rs", "lang": "Rust", "content": "pub fn imul_power<T>(x: &mut T, radix: u32, n: u32)\n    where T: CloneableVecLike<Limb>\n{\n    use super::large::KARATSUBA_CUTOFF;\n\n    let small_powers = get_small_powers(radix);\n    let large_powers = get_large_powers(radix);\n\n    if n == 0 {\n        // No exponent, just return.\n        // The 0-index of the large powers is `2^0`, which is 1, so we want\n        // to make sure we don't take that path with a literal 0.\n        return;\n    }\n\n    // We want to use the asymptotically faster algorithm if we're going\n    // to be using Karabatsu multiplication sometime during the result,\n    // otherwise, just use exponentiation by squaring.\n    let bit_length = 32 - n.leading_zeros().as_usize();\n    debug_assert!(bit_length != 0 && bit_length <= large_powers.len());\n    if x.len() + large_powers[bit_length-1].len() < 2*KARATSUBA_CUTOFF {\n        // We can use iterative small powers to make this faster for the\n        // easy cases.\n\n        // Multiply by the largest small power until n < step.\n        let step = small_powers.len() - 1;\n        let power = small_powers[step];\n        let mut n = n.as_usize();\n        while n >= step {\n            imul(x, power);\n            n -= step;\n        }\n\n        // Multiply by the remainder.\n        imul(x, small_powers[n]);\n    } else {\n        // In theory, this code should be asymptotically a lot faster,\n        // in practice, our small::imul seems to be the limiting step,\n        // and large imul is slow as well.\n\n        // Multiply by higher order powers.\n        let mut idx: usize = 0;\n        let mut bit: usize = 1;\n        let mut n = n.as_usize();\n        while n != 0 {\n            if n & bit != 0 {\n                debug_assert!(idx < large_powers.len());\n                large::imul(x, large_powers[idx]);\n                n ^= bit;\n            }\n            idx += 1;\n            bit <<= 1;\n        }\n    }\n}", "item_id": 0, "repo": "raphaelcohn/olympus-xmp", "file": "workspace/.cargo/vendored-sources/lexical-core-0.7.6/src/atof/algorithm/math.rs", "last_update_at": "2021-12-28T16:17:48+00:00", "question_id": "860e4a9f12c1d2733ac8fe0c1e341ae5ee5988bb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn imul_power<T>(x: &mut T, radix: u32, n: u32)\n    where T: CloneableVecLike<Limb>\n{\n    use super::large::KARATSUBA_CUTOFF;\n    let small_powers = get_small_powers(radix);\n    let large_powers = get_large_powers(radix);\n    if n == 0 {\n        // No exponent, just return.\n        // The 0-index of the large powers is `2^0`, which is 1, so we want\n        // to make sure we don't take that path with a literal 0.\n        return;\n    }\n    // We want to use the asymptotically faster algorithm if we're going\n    // to be using Karabatsu multiplication sometime during the result,\n    // otherwise, just use exponentiation by squaring.\n    let bit_length = 32 - n.leading_zeros().as_usize();\n    debug_assert!(bit_length != 0 && bit_length <= large_powers.len());\n    if x.len() + large_powers[bit_length-1].len() < 2*KARATSUBA_CUTOFF {\n        // We can use iterative small powers to make this faster for the\n        // easy cases.\n        // Multiply by the largest small power until n < step.\n        let step = small_powers.len() - 1;\n        let power = small_powers[step];\n        let mut n = n.as_usize();\n        while n >= step {\n            imul(x, power);\n            n -= step;\n        }\n        // Multiply by the remainder.\n        imul(x, small_powers[n]);\n    } else {\n        // In theory, this code should be asymptotically a lot faster,\n        // in practice, our small::imul seems to be the limiting step,\n        // and large imul is slow as well.\n        // Multiply by higher order powers.\n        let mut idx: usize = 0;\n        let mut bit: usize = 1;\n        let mut n = n.as_usize();\n        while n != 0 {\n            if n & bit != 0 {\n                debug_assert!(idx < large_powers.len());\n                large::imul(x, large_powers[idx]);\n                n ^= bit;\n            }\n            idx += 1;\n            bit <<= 1;\n        }\n    }\n"]], "pred": {"ppl": 3.418492317199707, "ppl_lower": 3.6691906452178955, "ppl/lowercase_ppl": -1.0575752656657853, "ppl/zlib": 0.0015231717607814648, "Min_5.0% Prob": 8.365171607335409, "Min_10.0% Prob": 6.615937858331399, "Min_20.0% Prob": 4.8429165296867245, "Min_30.0% Prob": 3.722817572413898, "Min_40.0% Prob": 2.9618047002626926, "Min_50.0% Prob": 2.4325281309049114, "Min_60.0% Prob": 2.0467123646461673}}
{"hexsha": "01d90edbc54795059169112dd4262ef2e1618593", "ext": "rs", "lang": "Rust", "content": "pub fn parallel_binary_search<T, F, G>(mut f: F, q: usize, ok: T, err: T) -> Vec<T>\nwhere\n    T: Bisect,\n    F: FnMut(&[T]) -> G,\n    G: Fn(usize) -> bool,\n{\n    let mut ok = vec![ok; q];\n    let mut err = vec![err; q];\n    while !ok.iter().zip(&err).all(|(ok, err)| ok.section_end(err)) {\n        let m: Vec<_> = ok.iter().zip(&err).map(|(ok, err)| ok.halve(err)).collect();\n        let g = f(&m);\n        for (i, m) in m.into_iter().enumerate() {\n            if g(i) {\n                ok[i] = m;\n            } else {\n                err[i] = m;\n            }\n        }\n    }\n    ok\n}", "item_id": 5, "repo": "to-omer/competitive-library", "file": "crates/competitive/src/algorithm/binary_search.rs", "last_update_at": "2021-03-16T07:51:02+00:00", "question_id": "01d90edbc54795059169112dd4262ef2e1618593_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn parallel_binary_search<T, F, G>(mut f: F, q: usize, ok: T, err: T) -> Vec<T>\nwhere\n    T: Bisect,\n    F: FnMut(&[T]) -> G,\n    G: Fn(usize) -> bool,\n{\n    let mut ok = vec![ok; q];\n    let mut err = vec![err; q];\n    while !ok.iter().zip(&err).all(|(ok, err)| ok.section_end(err)) {\n        let m: Vec<_> = ok.iter().zip(&err).map(|(ok, err)| ok.halve(err)).collect();\n        let g = f(&m);\n        for (i, m) in m.into_iter().enumerate() {\n            if g(i) {\n                ok[i] = m;\n            } else {\n                err[i] = m;\n            }\n        }\n    }\n    ok\n"]], "pred": {"ppl": 2.35984206199646, "ppl_lower": 2.8375864028930664, "ppl/lowercase_ppl": -1.2147219638020312, "ppl/zlib": 0.0027696603029523444, "Min_5.0% Prob": 9.114060011777012, "Min_10.0% Prob": 6.022243997325068, "Min_20.0% Prob": 3.836973947027455, "Min_30.0% Prob": 2.7519086305584226, "Min_40.0% Prob": 2.1332937551922697, "Min_50.0% Prob": 1.708678422543483, "Min_60.0% Prob": 1.4328911220588323}}
{"hexsha": "aeed588aa4dac4e4d7e6deba038bd6f6df9fe88c", "ext": "rs", "lang": "Rust", "content": "fn decode_header_map<R>(reader: &mut R) -> Result<HashMap<String, Vec<u8>>, AvrowErr>\nwhere\n    R: Read,\n{\n    let count: i64 = reader.read_varint().map_err(AvrowErr::DecodeFailed)?;\n    let count = count as usize;\n    let mut map = HashMap::with_capacity(count);\n\n    for _ in 0..count {\n        let key = decode_string(reader)?;\n        let val = decode_bytes(reader)?;\n        map.insert(key, val);\n    }\n\n    let _map_end: i64 = reader.read_varint().map_err(AvrowErr::DecodeFailed)?;\n\n    Ok(map)\n}", "item_id": 1, "repo": "creativcoder/avrow", "file": "src/reader.rs", "last_update_at": "2021-11-24T15:43:07+00:00", "question_id": "aeed588aa4dac4e4d7e6deba038bd6f6df9fe88c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn decode_header_map<R>(reader: &mut R) -> Result<HashMap<String, Vec<u8>>, AvrowErr>\nwhere\n    R: Read,\n{\n    let count: i64 = reader.read_varint().map_err(AvrowErr::DecodeFailed)?;\n    let count = count as usize;\n    let mut map = HashMap::with_capacity(count);\n    for _ in 0..count {\n        let key = decode_string(reader)?;\n        let val = decode_bytes(reader)?;\n        map.insert(key, val);\n    }\n    let _map_end: i64 = reader.read_varint().map_err(AvrowErr::DecodeFailed)?;\n    Ok(map)\n"]], "pred": {"ppl": 1.9868422746658325, "ppl_lower": 2.692243814468384, "ppl/lowercase_ppl": -1.442545930544738, "ppl/zlib": 0.002524068315407584, "Min_5.0% Prob": 6.86033566792806, "Min_10.0% Prob": 4.892467697461446, "Min_20.0% Prob": 3.1183488594519124, "Min_30.0% Prob": 2.236992227489298, "Min_40.0% Prob": 1.7062806429693829, "Min_50.0% Prob": 1.3692775899844785, "Min_60.0% Prob": 1.1495920198105343}}
{"hexsha": "bb8bfcc7febbd2c47007d23c0f5930e8fe23b867", "ext": "rs", "lang": "Rust", "content": "pub fn softplus<T: Into<Variable>>(x: T) -> Function {\n    let xv = x.into();\n    let xpayload: VariableInner = xv.borrow().payload;\n    let payload = unsafe {\n        let mut error_p: *mut i8 = ptr::null_mut();\n        let payload = cpp!([xpayload as \"Variable\", mut error_p as \"char*\"] -> FunctionInner as \"FunctionPtr\" {\n            try {\n                return Softplus(xpayload);\n            } catch (std::exception& e) {\n                auto what = e.what();\n                error_p = new char[strlen(what)+1];\n                strcpy(error_p, what);\n                return nullptr;\n            }\n        });\n        if !error_p.is_null() {\n             let msg = CStr::from_ptr(error_p).to_str().unwrap();\n             panic!(\"{}\", msg);\n        }\n        payload\n    };\n    Function {payload}\n}", "item_id": 38, "repo": "usamec/cntk-rs", "file": "src/ops.rs", "last_update_at": "2021-11-30T05:35:43+00:00", "question_id": "bb8bfcc7febbd2c47007d23c0f5930e8fe23b867_38", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn softplus<T: Into<Variable>>(x: T) -> Function {\n    let xv = x.into();\n    let xpayload: VariableInner = xv.borrow().payload;\n    let payload = unsafe {\n        let mut error_p: *mut i8 = ptr::null_mut();\n        let payload = cpp!([xpayload as \"Variable\", mut error_p as \"char*\"] -> FunctionInner as \"FunctionPtr\" {\n            try {\n                return Softplus(xpayload);\n            } catch (std::exception& e) {\n                auto what = e.what();\n                error_p = new char[strlen(what)+1];\n                strcpy(error_p, what);\n                return nullptr;\n            }\n        });\n        if !error_p.is_null() {\n             let msg = CStr::from_ptr(error_p).to_str().unwrap();\n             panic!(\"{}\", msg);\n        }\n        payload\n    };\n    Function {payload}\n"]], "pred": {"ppl": 2.3804361820220947, "ppl_lower": 2.8527822494506836, "ppl/lowercase_ppl": -1.2087102488204648, "ppl/zlib": 0.0023440101098613935, "Min_5.0% Prob": 7.948383490244548, "Min_10.0% Prob": 6.068922032912572, "Min_20.0% Prob": 3.9096789037187896, "Min_30.0% Prob": 2.7970982007682323, "Min_40.0% Prob": 2.148258027853444, "Min_50.0% Prob": 1.734106500291576, "Min_60.0% Prob": 1.4498467300953861}}
{"hexsha": "5e3e9f81f7d7869cfd97b15642efacb7cb144fcb", "ext": "rs", "lang": "Rust", "content": "pub fn get_part_one(input: &str) -> isize {\n    let target = target::target(input.trim()).unwrap();\n\n    let max_ys_on_target = get_max_ys_on_target(target);\n\n    *max_ys_on_target.iter().max().unwrap()\n}", "item_id": 0, "repo": "PsypherPunk/advent-of-code", "file": "2021/17/src/lib.rs", "last_update_at": "2021-12-26T22:58:42+00:00", "question_id": "5e3e9f81f7d7869cfd97b15642efacb7cb144fcb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_part_one(input: &str) -> isize {\n    let target = target::target(input.trim()).unwrap();\n    let max_ys_on_target = get_max_ys_on_target(target);\n    *max_ys_on_target.iter().max().unwrap()\n"]], "pred": {"ppl": 4.4380950927734375, "ppl_lower": 4.4380950927734375, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.011642384775187026, "Min_5.0% Prob": 9.349356333414713, "Min_10.0% Prob": 7.577692576817104, "Min_20.0% Prob": 5.7903759479522705, "Min_30.0% Prob": 4.641830476847562, "Min_40.0% Prob": 3.616471169392268, "Min_50.0% Prob": 2.9289096633070395, "Min_60.0% Prob": 2.499644802014033}}
{"hexsha": "c240406724e617c2807b34cce868240a68adda52", "ext": "rs", "lang": "Rust", "content": "fn check_datarate(hex: &str, datarate: f32) {\n        let vht = Vht::from_hex(hex);\n        let users: Vec<_> = vht.users().into();\n        let datarates: Vec<_> = users\n            .into_iter()\n            .map(|o| o.map(|u| u.to_mbps()).flatten().map(|r| r.unwrap()))\n            .collect();\n        assert_eq!(datarates, vec![Some(datarate), None, None, None]);\n    }", "item_id": 1, "repo": "rossmacarthur/radiotap", "file": "src/field/vht.rs", "last_update_at": "2021-11-02T01:05:43+00:00", "question_id": "c240406724e617c2807b34cce868240a68adda52_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn check_datarate(hex: &str, datarate: f32) {\n        let vht = Vht::from_hex(hex);\n        let users: Vec<_> = vht.users().into();\n        let datarates: Vec<_> = users\n            .into_iter()\n            .map(|o| o.map(|u| u.to_mbps()).flatten().map(|r| r.unwrap()))\n            .collect();\n        assert_eq!(datarates, vec![Some(datarate), None, None, None]);\n"]], "pred": {"ppl": 3.351919174194336, "ppl_lower": 3.963707208633423, "ppl/lowercase_ppl": -1.138604462934559, "ppl/zlib": 0.005815062834704809, "Min_5.0% Prob": 8.819154977798462, "Min_10.0% Prob": 6.953224145449125, "Min_20.0% Prob": 4.738922136801261, "Min_30.0% Prob": 3.6416706532239913, "Min_40.0% Prob": 2.8889207354298345, "Min_50.0% Prob": 2.3700755413840797, "Min_60.0% Prob": 2.01948475856104}}
{"hexsha": "4cad3e9d062b9fb20922a460bc31f39de51d65bd", "ext": "rs", "lang": "Rust", "content": "fn parse_message(msg: Message) -> Fallible<WebsocketEvent> {\n    let bin = match msg {\n        Message::Text(msg) => return Ok(WebsocketEvent::Text(msg)),\n        Message::Binary(b) => b,\n        Message::Pong(b) => b,\n        Message::Ping(b) => b,\n        Message::Close(..) => return Err(failure::format_err!(\"Socket closed\")),\n    };\n\n    let mut d = GzDecoder::new(&*bin);\n    let mut s = String::new();\n    d.read_to_string(&mut s).unwrap();\n\n    trace!(\"Incoming websocket message {:?}\", s);\n\n    let message: WebsocketEvent = from_str(&s)?;\n\n    Ok(message)\n}", "item_id": 0, "repo": "ShuyoTrader/huobi_future_async", "file": "src/client/websocket.rs", "last_update_at": "2021-03-31T01:24:43+00:00", "question_id": "4cad3e9d062b9fb20922a460bc31f39de51d65bd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_message(msg: Message) -> Fallible<WebsocketEvent> {\n    let bin = match msg {\n        Message::Text(msg) => return Ok(WebsocketEvent::Text(msg)),\n        Message::Binary(b) => b,\n        Message::Pong(b) => b,\n        Message::Ping(b) => b,\n        Message::Close(..) => return Err(failure::format_err!(\"Socket closed\")),\n    };\n    let mut d = GzDecoder::new(&*bin);\n    let mut s = String::new();\n    d.read_to_string(&mut s).unwrap();\n    trace!(\"Incoming websocket message {:?}\", s);\n    let message: WebsocketEvent = from_str(&s)?;\n    Ok(message)\n"]], "pred": {"ppl": 2.2450621128082275, "ppl_lower": 2.799001455307007, "ppl/lowercase_ppl": -1.2726851646013717, "ppl/zlib": 0.002741468433853035, "Min_5.0% Prob": 6.522954516940647, "Min_10.0% Prob": 5.022100059609664, "Min_20.0% Prob": 3.4819874355667517, "Min_30.0% Prob": 2.563191749547657, "Min_40.0% Prob": 1.9980248342219151, "Min_50.0% Prob": 1.616380872185293, "Min_60.0% Prob": 1.3527970086913883}}
{"hexsha": "c0c2ab67e382e0194906e80c4955867a84636b7c", "ext": "rs", "lang": "Rust", "content": "fn get_variant<'a>(adt_def: &'a AdtDef, qpath: &QPath<'_>) -> Option<&'a VariantDef> {\n    if adt_def.is_struct() {\n        if let Some(variant) = adt_def.variants.iter().next() {\n            return Some(variant);\n        }\n    }\n\n    if adt_def.is_enum() {\n        let pat_ident = last_path_segment(qpath).ident;\n        for variant in &adt_def.variants {\n            if variant.ident == pat_ident {\n                return Some(variant);\n            }\n        }\n    }\n\n    None\n}", "item_id": 1, "repo": "rep-nop/rust", "file": "src/tools/clippy/clippy_lints/src/pattern_type_mismatch.rs", "last_update_at": "2021-04-07T15:17:43+00:00", "question_id": "c0c2ab67e382e0194906e80c4955867a84636b7c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_variant<'a>(adt_def: &'a AdtDef, qpath: &QPath<'_>) -> Option<&'a VariantDef> {\n    if adt_def.is_struct() {\n        if let Some(variant) = adt_def.variants.iter().next() {\n            return Some(variant);\n        }\n    }\n    if adt_def.is_enum() {\n        let pat_ident = last_path_segment(qpath).ident;\n        for variant in &adt_def.variants {\n            if variant.ident == pat_ident {\n                return Some(variant);\n            }\n        }\n    }\n    None\n"]], "pred": {"ppl": 1.9878281354904175, "ppl_lower": 2.4821743965148926, "ppl/lowercase_ppl": -1.323258380166657, "ppl/zlib": 0.003040011741312956, "Min_5.0% Prob": 7.805698215961456, "Min_10.0% Prob": 5.274680279195309, "Min_20.0% Prob": 3.2517521642148495, "Min_30.0% Prob": 2.245421035557377, "Min_40.0% Prob": 1.7215458488235107, "Min_50.0% Prob": 1.3722243831015941, "Min_60.0% Prob": 1.1493338587413522}}
{"hexsha": "a838f1775648dcbbe84dc17020b4c9c9203a7257", "ext": "rs", "lang": "Rust", "content": "fn center(val: &String, width: usize) -> String {\n    if val.len() >= width {\n        return val.to_owned();\n    }\n    let diff = width - val.len();\n    let end = diff / 2;\n    let start = diff - end;\n    [\" \".repeat(start), val.to_owned(), \" \".repeat(end)]\n        .concat()\n        .to_owned()\n}", "item_id": 0, "repo": "odd12258053/docker-compose-host", "file": "src/main.rs", "last_update_at": "2021-03-18T13:51:18+00:00", "question_id": "a838f1775648dcbbe84dc17020b4c9c9203a7257_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn center(val: &String, width: usize) -> String {\n    if val.len() >= width {\n        return val.to_owned();\n    }\n    let diff = width - val.len();\n    let end = diff / 2;\n    let start = diff - end;\n    [\" \".repeat(start), val.to_owned(), \" \".repeat(end)]\n        .concat()\n        .to_owned()\n"]], "pred": {"ppl": 2.0534884929656982, "ppl_lower": 2.2100963592529297, "ppl/lowercase_ppl": -1.1021431193344629, "ppl/zlib": 0.00423258853399099, "Min_5.0% Prob": 7.774131965637207, "Min_10.0% Prob": 5.286964094638824, "Min_20.0% Prob": 3.2743532568216325, "Min_30.0% Prob": 2.350281814734141, "Min_40.0% Prob": 1.8027395395562054, "Min_50.0% Prob": 1.4302846642539782, "Min_60.0% Prob": 1.2010925699819306}}
{"hexsha": "c174ec8e6f2d9b3befe86246f2d267ecb0dd1645", "ext": "rs", "lang": "Rust", "content": "unsafe fn read_ss_family(storage: *const sockaddr_storage) -> u16 {\n    // Assert that we know the layout of `sockaddr`.\n    let _ = libc::sockaddr {\n        #[cfg(any(\n            target_os = \"netbsd\",\n            target_os = \"macos\",\n            target_os = \"ios\",\n            target_os = \"freebsd\",\n            target_os = \"openbsd\"\n        ))]\n        sa_len: 0_u8,\n        #[cfg(any(\n            target_os = \"netbsd\",\n            target_os = \"macos\",\n            target_os = \"ios\",\n            target_os = \"freebsd\",\n            target_os = \"openbsd\"\n        ))]\n        sa_family: 0_u8,\n        #[cfg(not(any(\n            target_os = \"netbsd\",\n            target_os = \"macos\",\n            target_os = \"ios\",\n            target_os = \"freebsd\",\n            target_os = \"openbsd\"\n        )))]\n        sa_family: 0_u16,\n        sa_data: [0; 14],\n    };\n\n    (*storage.cast::<sockaddr_header>()).ss_family.into()\n}", "item_id": 0, "repo": "ratmice/rsix", "file": "src/imp/libc/net/read_sockaddr.rs", "last_update_at": "2021-08-14T08:11:41+00:00", "question_id": "c174ec8e6f2d9b3befe86246f2d267ecb0dd1645_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe fn read_ss_family(storage: *const sockaddr_storage) -> u16 {\n    // Assert that we know the layout of `sockaddr`.\n    let _ = libc::sockaddr {\n        #[cfg(any(\n            target_os = \"netbsd\",\n            target_os = \"macos\",\n            target_os = \"ios\",\n            target_os = \"freebsd\",\n            target_os = \"openbsd\"\n        ))]\n        sa_len: 0_u8,\n        #[cfg(any(\n            target_os = \"netbsd\",\n            target_os = \"macos\",\n            target_os = \"ios\",\n            target_os = \"freebsd\",\n            target_os = \"openbsd\"\n        ))]\n        sa_family: 0_u8,\n        #[cfg(not(any(\n            target_os = \"netbsd\",\n            target_os = \"macos\",\n            target_os = \"ios\",\n            target_os = \"freebsd\",\n            target_os = \"openbsd\"\n        )))]\n        sa_family: 0_u16,\n        sa_data: [0; 14],\n    };\n    (*storage.cast::<sockaddr_header>()).ss_family.into()\n"]], "pred": {"ppl": 1.704710602760315, "ppl_lower": 1.7360714673995972, "ppl/lowercase_ppl": -1.0341761902578226, "ppl/zlib": 0.0020358601598378994, "Min_5.0% Prob": 6.941230837504069, "Min_10.0% Prob": 4.679985915460894, "Min_20.0% Prob": 2.6264127605865077, "Min_30.0% Prob": 1.7847094106417831, "Min_40.0% Prob": 1.3340920470282436, "Min_50.0% Prob": 1.0698981354332482, "Min_60.0% Prob": 0.8927433228535443}}
{"hexsha": "03d660c5420b4599a5f2aece38f200b596a7bf9a", "ext": "rs", "lang": "Rust", "content": "fn execute_state_machine_returns_304_if_non_match_star_exists_and_is_a_head_or_get() {\n  let mut context = WebmachineContext {\n    request: WebmachineRequest {\n      method: \"HEAD\".to_string(),\n      headers: hashmap! {\n        \"If-None-Match\".to_string() => vec![h!(\"*\")]\n      },\n      ..WebmachineRequest::default()\n    },\n    ..WebmachineContext::default()\n  };\n  let resource = WebmachineResource {\n    resource_exists: callback(&|_, _| true),\n    allowed_methods: vec![\"HEAD\"],\n    ..WebmachineResource::default()\n  };\n  execute_state_machine(&mut context, &resource);\n  expect(context.response.status).to(be_equal_to(304));\n}", "item_id": 43, "repo": "uglyog/webmachine-rust", "file": "src/tests.rs", "last_update_at": "2021-11-18T20:05:47+00:00", "question_id": "03d660c5420b4599a5f2aece38f200b596a7bf9a_43", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn execute_state_machine_returns_304_if_non_match_star_exists_and_is_a_head_or_get() {\n  let mut context = WebmachineContext {\n    request: WebmachineRequest {\n      method: \"HEAD\".to_string(),\n      headers: hashmap! {\n        \"If-None-Match\".to_string() => vec![h!(\"*\")]\n      },\n      ..WebmachineRequest::default()\n    },\n    ..WebmachineContext::default()\n  };\n  let resource = WebmachineResource {\n    resource_exists: callback(&|_, _| true),\n    allowed_methods: vec![\"HEAD\"],\n    ..WebmachineResource::default()\n  };\n  execute_state_machine(&mut context, &resource);\n  expect(context.response.status).to(be_equal_to(304));\n"]], "pred": {"ppl": 3.006253957748413, "ppl_lower": 3.1482770442962646, "ppl/lowercase_ppl": -1.0419376587885214, "ppl/zlib": 0.003335438701144898, "Min_5.0% Prob": 8.185577535629273, "Min_10.0% Prob": 6.5709998369216915, "Min_20.0% Prob": 4.570779186487198, "Min_30.0% Prob": 3.4126067532867683, "Min_40.0% Prob": 2.6994159173818284, "Min_50.0% Prob": 2.183141345998236, "Min_60.0% Prob": 1.8350745495103422}}
{"hexsha": "b299af364153005aefc827c5c50dea5d0a6f7c44", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let input = fs::read_to_string(\"input.txt\").expect(\"Error reading input.txt\");\n\n    let food = Food::from_str(&input).unwrap();\n\n    println!(\n        \"How many times do any of those ingredients appear? {}\",\n        food.get_safe_count(),\n    );\n\n    println!(\n        \"What is your canonical dangerous ingredient list? {}\",\n        food.get_canonical_dangerous_ingredients(),\n    );\n}", "item_id": 0, "repo": "PsypherPunk/advent-of-code", "file": "2020/21/src/main.rs", "last_update_at": "2021-12-26T22:58:42+00:00", "question_id": "b299af364153005aefc827c5c50dea5d0a6f7c44_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let input = fs::read_to_string(\"input.txt\").expect(\"Error reading input.txt\");\n    let food = Food::from_str(&input).unwrap();\n    println!(\n        \"How many times do any of those ingredients appear? {}\",\n        food.get_safe_count(),\n    );\n    println!(\n        \"What is your canonical dangerous ingredient list? {}\",\n        food.get_canonical_dangerous_ingredients(),\n    );\n"]], "pred": {"ppl": 2.032254695892334, "ppl_lower": 2.344909191131592, "ppl/lowercase_ppl": -1.2017931987682484, "ppl/zlib": 0.0031239905917542932, "Min_5.0% Prob": 5.765880227088928, "Min_10.0% Prob": 4.278714577356975, "Min_20.0% Prob": 3.0388373037179313, "Min_30.0% Prob": 2.257755099071397, "Min_40.0% Prob": 1.7398325299121895, "Min_50.0% Prob": 1.4207870397167128, "Min_60.0% Prob": 1.1928687090283796}}
{"hexsha": "1b22b01dd4b0436efa827c27eba18ae0778f41eb", "ext": "rs", "lang": "Rust", "content": "pub fn get_aeroway_geo_tile(props: &GeoTileProperties, geometry: Geometry) -> GeoTile {\n    let aeroway_type_str = props[\"aeroway\"].as_str().unwrap();\n    let aeroway_type = extract_type_from_string!(aeroway_type_str<props> => AerowayType [Aerodrome, Apron, Gate, Hangar, Helipad, Heliport, Navigationaid, Runway, Spaceport, Taxiway, Terminal, Windsock, Unclassified]);\n    geotile_from_properties!(geometry<props> => Aeroway<aeroway_type> [name, description, iata, icao, operator, surface]);\n}", "item_id": 0, "repo": "edouardpoitras/osm-geo-mapper", "file": "src/features/aeroway_feature.rs", "last_update_at": "2021-12-31T14:08:24+00:00", "question_id": "1b22b01dd4b0436efa827c27eba18ae0778f41eb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_aeroway_geo_tile(props: &GeoTileProperties, geometry: Geometry) -> GeoTile {\n    let aeroway_type_str = props[\"aeroway\"].as_str().unwrap();\n    let aeroway_type = extract_type_from_string!(aeroway_type_str<props> => AerowayType [Aerodrome, Apron, Gate, Hangar, Helipad, Heliport, Navigationaid, Runway, Spaceport, Taxiway, Terminal, Windsock, Unclassified]);\n    geotile_from_properties!(geometry<props> => Aeroway<aeroway_type> [name, description, iata, icao, operator, surface]);\n"]], "pred": {"ppl": 4.5535197257995605, "ppl_lower": 5.37225866317749, "ppl/lowercase_ppl": -1.10907571290526, "ppl/zlib": 0.00513864576279526, "Min_5.0% Prob": 9.285355197058784, "Min_10.0% Prob": 7.630007637871636, "Min_20.0% Prob": 5.585904790295495, "Min_30.0% Prob": 4.4244553888285605, "Min_40.0% Prob": 3.5907600017057524, "Min_50.0% Prob": 2.9594546215874806, "Min_60.0% Prob": 2.50863890801001}}
{"hexsha": "07860db15f5e56d63b2e5be5b6bed234e91a5132", "ext": "rs", "lang": "Rust", "content": "pub fn draw_tile_and_tokens_at<'a, T>(\n    hex: &Hex,\n    ctx: &Context,\n    map: &Map,\n    addr: &HexAddress,\n    tile: &Tile,\n    radians: f64,\n    tokens: T,\n) where\n    T: IntoIterator<Item = (&'a TokenSpace, &'a Token)>,\n{\n    let m = map.prepare_to_draw(*addr, hex, ctx);\n    // Retrieve the original tile's rotation, which has been applied.\n    let orig_rotn =\n        map.hex_state(*addr).map(|hs| hs.radians()).unwrap_or(0.0);\n    // Apply this additional rotation to the specified tile.\n    ctx.rotate(radians);\n    // Account for the effective rotation (i.e., the combination of the\n    // original tile and the specified tile) so that it can be corrected for\n    // by `token.draw()`, below.\n    let token_rotn = radians + orig_rotn;\n    tile.draw(ctx, hex);\n    for (token_space, token) in tokens.into_iter() {\n        if tile.define_token_space(token_space, hex, ctx) {\n            let tok_name = map.try_token_name(token);\n            if let Some(name) = tok_name {\n                // NOTE: `token_rotn` is the rotation (in radians) that will\n                // be *reversed* when drawing the token.\n                token.draw(hex, ctx, name, token_rotn);\n            } else {\n                debug!(\"Invalid token for this map: {:?}\", token);\n            }\n        } else {\n            debug!(\"Tile {} has no {:?}\", tile.name, token_space);\n        }\n    }\n    ctx.set_matrix(m);\n}", "item_id": 12, "repo": "robmoss/rusty_train", "file": "crates/n18brush/src/lib.rs", "last_update_at": "2021-11-26T16:48:17+00:00", "question_id": "07860db15f5e56d63b2e5be5b6bed234e91a5132_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn draw_tile_and_tokens_at<'a, T>(\n    hex: &Hex,\n    ctx: &Context,\n    map: &Map,\n    addr: &HexAddress,\n    tile: &Tile,\n    radians: f64,\n    tokens: T,\n) where\n    T: IntoIterator<Item = (&'a TokenSpace, &'a Token)>,\n{\n    let m = map.prepare_to_draw(*addr, hex, ctx);\n    // Retrieve the original tile's rotation, which has been applied.\n    let orig_rotn =\n        map.hex_state(*addr).map(|hs| hs.radians()).unwrap_or(0.0);\n    // Apply this additional rotation to the specified tile.\n    ctx.rotate(radians);\n    // Account for the effective rotation (i.e., the combination of the\n    // original tile and the specified tile) so that it can be corrected for\n    // by `token.draw()`, below.\n    let token_rotn = radians + orig_rotn;\n    tile.draw(ctx, hex);\n    for (token_space, token) in tokens.into_iter() {\n        if tile.define_token_space(token_space, hex, ctx) {\n            let tok_name = map.try_token_name(token);\n            if let Some(name) = tok_name {\n                // NOTE: `token_rotn` is the rotation (in radians) that will\n                // be *reversed* when drawing the token.\n                token.draw(hex, ctx, name, token_rotn);\n            } else {\n                debug!(\"Invalid token for this map: {:?}\", token);\n            }\n        } else {\n            debug!(\"Tile {} has no {:?}\", tile.name, token_space);\n        }\n    }\n    ctx.set_matrix(m);\n"]], "pred": {"ppl": 3.4707322120666504, "ppl_lower": 3.966195583343506, "ppl/lowercase_ppl": -1.1072367813834243, "ppl/zlib": 0.0019352497415580016, "Min_5.0% Prob": 8.143155358054422, "Min_10.0% Prob": 6.304352627860175, "Min_20.0% Prob": 4.670221360175164, "Min_30.0% Prob": 3.672180646482636, "Min_40.0% Prob": 2.949917358356518, "Min_50.0% Prob": 2.4453849466886814, "Min_60.0% Prob": 2.06162691623955}}
{"hexsha": "38677133e56d19bae2e14bb835693327c2c691ca", "ext": "rs", "lang": "Rust", "content": "fn test_simpleslicedeserializer_simpledeserializer_read_fail() {\n    let s: [u8; 8] = [0, 3, 0, 0, 0, 0, 0, 0];\n\n    let mut v = SimpleSliceDeserializer::new(&s[..2]);\n    assert!(matches!(v.read(3), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n\n    let mut v = SimpleSliceDeserializer::new(&s[..0]);\n    assert!(matches!(v.read_u8(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n    assert!(matches!(v.read_i8(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n\n    let mut v = SimpleSliceDeserializer::new(&s[..1]);\n    assert!(matches!(v.read_u16(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n    assert!(matches!(v.read_i16(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n\n    let mut v = SimpleSliceDeserializer::new(&s[..3]);\n    assert!(matches!(v.read_u32(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n    assert!(matches!(v.read_i32(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n    assert!(matches!(v.read_f32(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n\n    let mut v = SimpleSliceDeserializer::new(&s[..7]);\n    assert!(matches!(v.read_u64(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n    assert!(matches!(v.read_i64(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n    assert!(matches!(v.read_f64(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n\n    let mut v = SimpleSliceDeserializer::new(&s[..4]);\n    assert!(matches!(v.read_byte_array(), Err(ErrorKind::UnableToRead)));\n}", "item_id": 7, "repo": "interlockledger/rust-il2-utils", "file": "src/simple_serialization/tests.rs", "last_update_at": "2021-09-02T05:26:48+00:00", "question_id": "38677133e56d19bae2e14bb835693327c2c691ca_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_simpleslicedeserializer_simpledeserializer_read_fail() {\n    let s: [u8; 8] = [0, 3, 0, 0, 0, 0, 0, 0];\n    let mut v = SimpleSliceDeserializer::new(&s[..2]);\n    assert!(matches!(v.read(3), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n    let mut v = SimpleSliceDeserializer::new(&s[..0]);\n    assert!(matches!(v.read_u8(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n    assert!(matches!(v.read_i8(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n    let mut v = SimpleSliceDeserializer::new(&s[..1]);\n    assert!(matches!(v.read_u16(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n    assert!(matches!(v.read_i16(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n    let mut v = SimpleSliceDeserializer::new(&s[..3]);\n    assert!(matches!(v.read_u32(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n    assert!(matches!(v.read_i32(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n    assert!(matches!(v.read_f32(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n    let mut v = SimpleSliceDeserializer::new(&s[..7]);\n    assert!(matches!(v.read_u64(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n    assert!(matches!(v.read_i64(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n    assert!(matches!(v.read_f64(), Err(ErrorKind::UnableToRead)));\n    assert_eq!(v.offset, 0);\n    assert_eq!(v.data_offset, 0);\n    let mut v = SimpleSliceDeserializer::new(&s[..4]);\n    assert!(matches!(v.read_byte_array(), Err(ErrorKind::UnableToRead)));\n"]], "pred": {"ppl": 1.3313425779342651, "ppl_lower": 1.3776075839996338, "ppl/lowercase_ppl": -1.1193637848004159, "ppl/zlib": 0.0010444813509777513, "Min_5.0% Prob": 4.5336970916161174, "Min_10.0% Prob": 2.741528110244335, "Min_20.0% Prob": 1.4245481903006316, "Min_30.0% Prob": 0.9551307169928592, "Min_40.0% Prob": 0.7153048084688797, "Min_50.0% Prob": 0.5730713886798408, "Min_60.0% Prob": 0.4769709120634506}}
{"hexsha": "fe81453e31e723184bd61c26dc4381983d5078be", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() != 2 {\n        return;\n    }\n\n    let filename = &args[1];\n    let file = File::open(filename).unwrap_or_else(|_| panic!(\"Failed to open file {}\", filename));\n    let mut reader = BufReader::new(file);\n\n    let mut new_math_sum = 0;\n    let mut advanced_math_sum = 0;\n\n    let mut line = String::new();\n    loop {\n        let bytes = reader\n            .read_line(&mut line)\n            .unwrap_or_else(|_| panic!(\"Failed to read line\"));\n        if bytes == 0 {\n            break;\n        }\n\n        {\n            let (value, _) = evaluate_expression(false, line.trim());\n            new_math_sum += value;\n        }\n        {\n            let (value, _) = evaluate_expression(true, line.trim());\n            advanced_math_sum += value;\n        }\n\n        line.clear();\n    }\n\n    println!(\"New math sum: {}\", new_math_sum);\n    println!(\"Advanced math sum: {}\", advanced_math_sum);\n}", "item_id": 2, "repo": "dstoza/advent-2017", "file": "2020/day-18/src/main.rs", "last_update_at": "2021-12-15T21:27:31+00:00", "question_id": "fe81453e31e723184bd61c26dc4381983d5078be_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() != 2 {\n        return;\n    }\n    let filename = &args[1];\n    let file = File::open(filename).unwrap_or_else(|_| panic!(\"Failed to open file {}\", filename));\n    let mut reader = BufReader::new(file);\n    let mut new_math_sum = 0;\n    let mut advanced_math_sum = 0;\n    let mut line = String::new();\n    loop {\n        let bytes = reader\n            .read_line(&mut line)\n            .unwrap_or_else(|_| panic!(\"Failed to read line\"));\n        if bytes == 0 {\n            break;\n        }\n        {\n            let (value, _) = evaluate_expression(false, line.trim());\n            new_math_sum += value;\n        }\n        {\n            let (value, _) = evaluate_expression(true, line.trim());\n            advanced_math_sum += value;\n        }\n        line.clear();\n    }\n    println!(\"New math sum: {}\", new_math_sum);\n    println!(\"Advanced math sum: {}\", advanced_math_sum);\n"]], "pred": {"ppl": 1.5888850688934326, "ppl_lower": 1.8543182611465454, "ppl/lowercase_ppl": -1.3336364941427385, "ppl/zlib": 0.0011964665522837406, "Min_5.0% Prob": 6.017212088902792, "Min_10.0% Prob": 3.767919894059499, "Min_20.0% Prob": 2.199261756738027, "Min_30.0% Prob": 1.5238238405022355, "Min_40.0% Prob": 1.1531466377899051, "Min_50.0% Prob": 0.9245957192561278, "Min_60.0% Prob": 0.7712011199276377}}
{"hexsha": "56a2724ed7b658a2fc5a24d70231115f289387c1", "ext": "rs", "lang": "Rust", "content": "fn next_starting_with(start: &str, current_word: &str) -> Option<&'static str> {\n        let words = Self::starting_with(start);\n        let position = words.iter().position(|word| word == &current_word)?;\n\n        // if the last word cycle back to the first word in the list\n        let position = if position == (words.len() - 1) {\n            0\n        } else {\n            position\n        };\n\n        Some(*words.get(position + 1)?)\n    }", "item_id": 2, "repo": "avencera/splitmonic", "file": "crates/splitmonic/src/wordlist.rs", "last_update_at": "2021-04-13T21:31:50+00:00", "question_id": "56a2724ed7b658a2fc5a24d70231115f289387c1_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn next_starting_with(start: &str, current_word: &str) -> Option<&'static str> {\n        let words = Self::starting_with(start);\n        let position = words.iter().position(|word| word == &current_word)?;\n        // if the last word cycle back to the first word in the list\n        let position = if position == (words.len() - 1) {\n            0\n        } else {\n            position\n        };\n        Some(*words.get(position + 1)?)\n"]], "pred": {"ppl": 2.846017360687256, "ppl_lower": 3.578598976135254, "ppl/lowercase_ppl": -1.2189944215252904, "ppl/zlib": 0.004607579734271871, "Min_5.0% Prob": 7.823200861612956, "Min_10.0% Prob": 6.0420876282912035, "Min_20.0% Prob": 4.359316344444569, "Min_30.0% Prob": 3.2948378248092456, "Min_40.0% Prob": 2.5630891592456746, "Min_50.0% Prob": 2.0874788066515557, "Min_60.0% Prob": 1.7531979040553172}}
{"hexsha": "28fca27b0ea7eb3787bb9d4b3c2277b216ae22e6", "ext": "rs", "lang": "Rust", "content": "fn sync_bin_size() {\n    // should have a size of 4 words\n    let word_size = core::mem::size_of::<usize>();\n    let sync_bin_size = core::mem::size_of::<SBin>();\n    assert_eq!(word_size * 4, sync_bin_size);\n    assert_eq!(core::mem::size_of::<Bin>(), sync_bin_size);\n}", "item_id": 1, "repo": "cronosun/abin", "file": "abin/tests/size_and_align.rs", "last_update_at": "2021-04-28T12:02:04+00:00", "question_id": "28fca27b0ea7eb3787bb9d4b3c2277b216ae22e6_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn sync_bin_size() {\n    // should have a size of 4 words\n    let word_size = core::mem::size_of::<usize>();\n    let sync_bin_size = core::mem::size_of::<SBin>();\n    assert_eq!(word_size * 4, sync_bin_size);\n    assert_eq!(core::mem::size_of::<Bin>(), sync_bin_size);\n"]], "pred": {"ppl": 2.7194716930389404, "ppl_lower": 2.8860058784484863, "ppl/lowercase_ppl": -1.0594098666957663, "ppl/zlib": 0.0071459830781594996, "Min_5.0% Prob": 8.188968563079834, "Min_10.0% Prob": 6.463812160491943, "Min_20.0% Prob": 4.343963623046875, "Min_30.0% Prob": 3.220859495862838, "Min_40.0% Prob": 2.4534865639039447, "Min_50.0% Prob": 2.0091817307357607, "Min_60.0% Prob": 1.6655618285257665}}
{"hexsha": "1f804aa0648eb34d98326784a68d9ce6b913e9d2", "ext": "rs", "lang": "Rust", "content": "pub async fn insert_bano_item(\n    bano_id: &str,\n    item_id: &str,\n    context: &gql::Context,\n) -> Result<Item, error::Error> {\n    // FIXME This should be a transaction grouping both actions\n    let item = sqlx::query_as(\"INSERT INTO main.env_bano_item (id) VALUES ($1) RETURNING *\")\n        .bind(item_id)\n        .fetch_one(&context.pool)\n        .await\n        .context(error::DBError {\n            details: format!(\"Could not insert BANO item {}\", item_id),\n        })?;\n    let conn = context.pool.acquire().await.context(error::DBError {\n        details: \"Could not get conn\",\n    })?;\n    // FIXME should not use this method to build a query.\n    sqlx::query(&format!(\n        \"INSERT INTO main.env_bano_map VALUES ('{}', '{}')\",\n        bano_id, item_id\n    ))\n    .execute(conn)\n    .await\n    .context(error::DBError {\n        details: \"Could not retrieve BANO item\",\n    })?;\n    Ok(item)\n}", "item_id": 2, "repo": "crocme10/mjolnir_back", "file": "backend/src/model/environments/item.rs", "last_update_at": "2021-08-15T20:01:59+00:00", "question_id": "1f804aa0648eb34d98326784a68d9ce6b913e9d2_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn insert_bano_item(\n    bano_id: &str,\n    item_id: &str,\n    context: &gql::Context,\n) -> Result<Item, error::Error> {\n    // FIXME This should be a transaction grouping both actions\n    let item = sqlx::query_as(\"INSERT INTO main.env_bano_item (id) VALUES ($1) RETURNING *\")\n        .bind(item_id)\n        .fetch_one(&context.pool)\n        .await\n        .context(error::DBError {\n            details: format!(\"Could not insert BANO item {}\", item_id),\n        })?;\n    let conn = context.pool.acquire().await.context(error::DBError {\n        details: \"Could not get conn\",\n    })?;\n    // FIXME should not use this method to build a query.\n    sqlx::query(&format!(\n        \"INSERT INTO main.env_bano_map VALUES ('{}', '{}')\",\n        bano_id, item_id\n    ))\n    .execute(conn)\n    .await\n    .context(error::DBError {\n        details: \"Could not retrieve BANO item\",\n    })?;\n    Ok(item)\n"]], "pred": {"ppl": 2.7544007301330566, "ppl_lower": 3.2745871543884277, "ppl/lowercase_ppl": -1.1707381767528564, "ppl/zlib": 0.002334561977237201, "Min_5.0% Prob": 8.404962403433663, "Min_10.0% Prob": 6.3658646961738325, "Min_20.0% Prob": 4.359627907559023, "Min_30.0% Prob": 3.2069589870699335, "Min_40.0% Prob": 2.492745483873271, "Min_50.0% Prob": 2.0212669813092923, "Min_60.0% Prob": 1.6906184226836405}}
{"hexsha": "03d04b810d9d8171b72291c9178095bf04f065dd", "ext": "rs", "lang": "Rust", "content": "fn connects_matrix__neg(from: Syllable, to: Syllable, from_i: u8, to_i: u8) {\n        assert_eq!(from.jnext.bits(), from_i);\n        assert_eq!(to.jprevious.bits(), to_i);\n        assert!(!from.connects(&to));\n    }", "item_id": 1, "repo": "folkengine/random_name_generator_rs", "file": "src/rng_syllable.rs", "last_update_at": "2021-07-13T18:24:01+00:00", "question_id": "03d04b810d9d8171b72291c9178095bf04f065dd_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn connects_matrix__neg(from: Syllable, to: Syllable, from_i: u8, to_i: u8) {\n        assert_eq!(from.jnext.bits(), from_i);\n        assert_eq!(to.jprevious.bits(), to_i);\n        assert!(!from.connects(&to));\n"]], "pred": {"ppl": 6.028501510620117, "ppl_lower": 6.651538848876953, "ppl/lowercase_ppl": -1.0547452508330224, "ppl/zlib": 0.013307396104851576, "Min_5.0% Prob": 10.412686586380005, "Min_10.0% Prob": 9.160117983818054, "Min_20.0% Prob": 7.104733422398567, "Min_30.0% Prob": 5.50216305732727, "Min_40.0% Prob": 4.42096310673338, "Min_50.0% Prob": 3.545534191032251, "Min_60.0% Prob": 3.0060124465823175}}
{"hexsha": "b9732bed1d93ee151e2c4b7884050ce29803a61c", "ext": "rs", "lang": "Rust", "content": "fn lanczos_cgamma(z: C64) -> C64 {\n    let p = [\n        0.99999999999980993, 676.5203681218851, -1259.1392167224028,\n        771.32342877765313, -176.61502916214059, 12.507343278686905,\n        -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7\n    ];\n    let z = z - 1.0;\n    let mut y = C64 {re: p[0], im: 0.0};\n    y += p[1]/(z + 1.0); y += p[2]/(z + 2.0);\n    y += p[3]/(z + 3.0); y += p[4]/(z + 4.0);\n    y += p[5]/(z + 5.0); y += p[6]/(z + 6.0);\n    y += p[7]/(z + 7.0); y += p[8]/(z + 8.0);\n    let t = z + 7.5;\n    SQRT_2PI*t.powc(z + 0.5)*(-t).exp()*y\n}", "item_id": 2, "repo": "JohnBSmith/moss", "file": "src/modules/math.rs", "last_update_at": "2021-05-14T18:38:36+00:00", "question_id": "b9732bed1d93ee151e2c4b7884050ce29803a61c_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn lanczos_cgamma(z: C64) -> C64 {\n    let p = [\n        0.99999999999980993, 676.5203681218851, -1259.1392167224028,\n        771.32342877765313, -176.61502916214059, 12.507343278686905,\n        -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7\n    ];\n    let z = z - 1.0;\n    let mut y = C64 {re: p[0], im: 0.0};\n    y += p[1]/(z + 1.0); y += p[2]/(z + 2.0);\n    y += p[3]/(z + 3.0); y += p[4]/(z + 4.0);\n    y += p[5]/(z + 5.0); y += p[6]/(z + 6.0);\n    y += p[7]/(z + 7.0); y += p[8]/(z + 8.0);\n    let t = z + 7.5;\n    SQRT_2PI*t.powc(z + 0.5)*(-t).exp()*y\n"]], "pred": {"ppl": 1.4422516822814941, "ppl_lower": 1.4371423721313477, "ppl/lowercase_ppl": -0.990309042702785, "ppl/zlib": 0.0011479798137387918, "Min_5.0% Prob": 5.027936124801636, "Min_10.0% Prob": 3.2326925876663952, "Min_20.0% Prob": 1.793783586337624, "Min_30.0% Prob": 1.2198089165913482, "Min_40.0% Prob": 0.914282695165869, "Min_50.0% Prob": 0.7338618394167383, "Min_60.0% Prob": 0.6102447817095061}}
{"hexsha": "10f6c0bb84f13c937bfcd2d15caa9bb7a1ab69f5", "ext": "rs", "lang": "Rust", "content": "fn name_tables_mirroring() {\n        let mut emu = mock_emu_horizontal();\n        emu.name_tables[0x0305] = 0x66;\n        let mut bus = borrow_ppu_bus!(emu);\n\n        emu.ppu.write(&mut bus, 0x2000, 0b0);\n\n        emu.ppu.write(&mut bus, 0x2006, 0x63); // 0x6305 -> 0x2305\n        emu.ppu.write(&mut bus, 0x2006, 0x05);\n\n        emu.ppu.read(&mut bus, 0x2007);\n        assert_eq!(emu.ppu.read(&mut bus, 0x2007), 0x66);\n    }", "item_id": 6, "repo": "reinaldogoes/nestadia", "file": "nestadia/src/ppu/mod.rs", "last_update_at": "2021-06-20T15:15:01+00:00", "question_id": "10f6c0bb84f13c937bfcd2d15caa9bb7a1ab69f5_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn name_tables_mirroring() {\n        let mut emu = mock_emu_horizontal();\n        emu.name_tables[0x0305] = 0x66;\n        let mut bus = borrow_ppu_bus!(emu);\n        emu.ppu.write(&mut bus, 0x2000, 0b0);\n        emu.ppu.write(&mut bus, 0x2006, 0x63); // 0x6305 -> 0x2305\n        emu.ppu.write(&mut bus, 0x2006, 0x05);\n        emu.ppu.read(&mut bus, 0x2007);\n        assert_eq!(emu.ppu.read(&mut bus, 0x2007), 0x66);\n"]], "pred": {"ppl": 2.7299180030822754, "ppl_lower": 2.7299180030822754, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.005123834557371406, "Min_5.0% Prob": 8.620275640487671, "Min_10.0% Prob": 6.25613386290414, "Min_20.0% Prob": 4.262616112118676, "Min_30.0% Prob": 3.1736877970397472, "Min_40.0% Prob": 2.4760256213300367, "Min_50.0% Prob": 1.994533848400428, "Min_60.0% Prob": 1.6749439347768202}}
{"hexsha": "d0fbba2b54ba8e63349a4714db4433485305c83e", "ext": "rs", "lang": "Rust", "content": "fn protocol_number_to_string() {\n        assert_eq!(\"TCP\", ProtocolNumbers::Tcp.to_string());\n        assert_eq!(\"UDP\", ProtocolNumbers::Udp.to_string());\n        assert_eq!(\"IPv6 Route\", ProtocolNumbers::Ipv6Route.to_string());\n        assert_eq!(\"ICMPv6\", ProtocolNumbers::Icmpv6.to_string());\n        assert_eq!(\"0x00\", ProtocolNumber::new(0).to_string());\n    }", "item_id": 1, "repo": "ported-pw/capsule", "file": "core/src/packets/ip/mod.rs", "last_update_at": "2021-11-08T14:32:00+00:00", "question_id": "d0fbba2b54ba8e63349a4714db4433485305c83e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn protocol_number_to_string() {\n        assert_eq!(\"TCP\", ProtocolNumbers::Tcp.to_string());\n        assert_eq!(\"UDP\", ProtocolNumbers::Udp.to_string());\n        assert_eq!(\"IPv6 Route\", ProtocolNumbers::Ipv6Route.to_string());\n        assert_eq!(\"ICMPv6\", ProtocolNumbers::Icmpv6.to_string());\n        assert_eq!(\"0x00\", ProtocolNumber::new(0).to_string());\n"]], "pred": {"ppl": 1.968509554862976, "ppl_lower": 2.5965418815612793, "ppl/lowercase_ppl": -1.408848901683461, "ppl/zlib": 0.004803380746595565, "Min_5.0% Prob": 7.626220782597859, "Min_10.0% Prob": 5.228229443232219, "Min_20.0% Prob": 3.189034171104431, "Min_30.0% Prob": 2.251831737321776, "Min_40.0% Prob": 1.6854033733159304, "Min_50.0% Prob": 1.3640750070823537, "Min_60.0% Prob": 1.1285018967712919}}
{"hexsha": "a4880c41513b5b92bcf98ea4ca8a35339d525dc5", "ext": "rs", "lang": "Rust", "content": "pub fn inventory_item_reveal_system(\n    mut inventory_query: Query<&mut Inventory>,\n    mut object_query: Query<(&Object, &mut Visible, &mut Collider, &Handle<Map>)>,\n    game: Res<Game>,\n) {\n    let mut do_reveal = false;\n    let mut total_gems = 0;\n    for inventory in inventory_query.iter_mut() {\n        total_gems += inventory.num_gems;\n    }\n    if total_gems >= 4 {\n        do_reveal = true;\n    }\n    if do_reveal {\n        for (object, mut visible, mut collider, map_handle) in object_query.iter_mut() {\n            // only reveal if it's invisible\n            if visible.is_visible {\n                continue;\n            }\n            if total_gems >= 8 && object.name.starts_with(\"load:\") {\n                // show hidden portals when you have enough gems\n                visible.is_visible = true;\n                collider.insert_behavior(ColliderBehavior::Load { path: object.name[5..].to_string() });\n                // clear inventory for new map\n                for mut items in inventory_query.iter_mut() {\n                    items.num_gems = 0;\n                }\n            }\n\n            if object.name == \"biggem\" && *map_handle == game.current_map {\n                visible.is_visible = true;\n                collider.behaviors.clear();\n                collider.insert_behavior(ColliderBehavior::Collect);\n                collider.insert_behavior(ColliderBehavior::Dialogue(\n                    DialogueSpec {\n                        node_name: \"collectedBigGem\".to_string(),\n                        ui_type: crate::core::game::DialogueUiType::Notice,\n                        auto_display: true,\n                }));\n            }\n        }\n    }\n}", "item_id": 0, "repo": "chipflask/twodina", "file": "src/items.rs", "last_update_at": "2021-03-28T01:20:03+00:00", "question_id": "a4880c41513b5b92bcf98ea4ca8a35339d525dc5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn inventory_item_reveal_system(\n    mut inventory_query: Query<&mut Inventory>,\n    mut object_query: Query<(&Object, &mut Visible, &mut Collider, &Handle<Map>)>,\n    game: Res<Game>,\n) {\n    let mut do_reveal = false;\n    let mut total_gems = 0;\n    for inventory in inventory_query.iter_mut() {\n        total_gems += inventory.num_gems;\n    }\n    if total_gems >= 4 {\n        do_reveal = true;\n    }\n    if do_reveal {\n        for (object, mut visible, mut collider, map_handle) in object_query.iter_mut() {\n            // only reveal if it's invisible\n            if visible.is_visible {\n                continue;\n            }\n            if total_gems >= 8 && object.name.starts_with(\"load:\") {\n                // show hidden portals when you have enough gems\n                visible.is_visible = true;\n                collider.insert_behavior(ColliderBehavior::Load { path: object.name[5..].to_string() });\n                // clear inventory for new map\n                for mut items in inventory_query.iter_mut() {\n                    items.num_gems = 0;\n                }\n            }\n            if object.name == \"biggem\" && *map_handle == game.current_map {\n                visible.is_visible = true;\n                collider.behaviors.clear();\n                collider.insert_behavior(ColliderBehavior::Collect);\n                collider.insert_behavior(ColliderBehavior::Dialogue(\n                    DialogueSpec {\n                        node_name: \"collectedBigGem\".to_string(),\n                        ui_type: crate::core::game::DialogueUiType::Notice,\n                        auto_display: true,\n                }));\n            }\n        }\n    }\n"]], "pred": {"ppl": 2.751035451889038, "ppl_lower": 3.1338841915130615, "ppl/lowercase_ppl": -1.128753691742193, "ppl/zlib": 0.0016838225769871327, "Min_5.0% Prob": 8.129802144092062, "Min_10.0% Prob": 6.467113251381732, "Min_20.0% Prob": 4.3552767866536195, "Min_30.0% Prob": 3.2095184884440733, "Min_40.0% Prob": 2.4922193936611476, "Min_50.0% Prob": 2.0149449186102184, "Min_60.0% Prob": 1.6885031363289607}}
{"hexsha": "fb13b451b9de6398312d51d0ec2fc8e4dbb931f8", "ext": "rs", "lang": "Rust", "content": "fn test_part_one() {\n        let input = r#\"#######\n#.G...#\n#...EG#\n#.#.#G#\n#..G#E#\n#.....#\n#######\"#;\n\n        let mut cave = Cave::from_str(&input).unwrap();\n\n        assert_eq!(27_730, cave.get_outcome());\n    }", "item_id": 1, "repo": "PsypherPunk/advent-of-code", "file": "2018/15/src/lib.rs", "last_update_at": "2021-12-26T22:58:42+00:00", "question_id": "fb13b451b9de6398312d51d0ec2fc8e4dbb931f8_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_part_one() {\n        let input = r#\"#######\n#.G...#\n#...EG#\n#.#.#G#\n#..G#E#\n#.....#\n#######\"#;\n        let mut cave = Cave::from_str(&input).unwrap();\n        assert_eq!(27_730, cave.get_outcome());\n"]], "pred": {"ppl": 2.2699363231658936, "ppl_lower": 3.2214436531066895, "ppl/lowercase_ppl": -1.427053441814769, "ppl/zlib": 0.005323063504098001, "Min_5.0% Prob": 7.202019810676575, "Min_10.0% Prob": 5.431183338165283, "Min_20.0% Prob": 3.4903219059893957, "Min_30.0% Prob": 2.5680172669476478, "Min_40.0% Prob": 2.012534520564935, "Min_50.0% Prob": 1.6302726099989853, "Min_60.0% Prob": 1.383089194572049}}
{"hexsha": "232dfda793151cd6d1550bbef06be3edac9264d4", "ext": "rs", "lang": "Rust", "content": "fn difference_3d() {\n        let cube1 = SFCGeometry::new(\n            \"\n            SOLID((((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)),\\\n            ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)),\\\n            ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)),\\\n            ((1 1 1, 0 1 1, 0 0 1, 1 0 1, 1 1 1)),\\\n            ((1 1 1, 1 0 1, 1 0 0, 1 1 0, 1 1 1)),\\\n            ((1 1 1, 1 1 0, 0 1 0, 0 1 1, 1 1 1))))\",\n        )\n        .unwrap();\n        let cube2 = SFCGeometry::new(\n            \"\n            SOLID((((0 0 0.5, 0 1 0.5, 1 1 0.5, 1 0 0.5, 0 0 0.5)),\\\n            ((0 0 0.5, 0 0 1, 0 1 1, 0 1 0.5, 0 0 0.5)),\\\n            ((0 0 0.5, 1 0 0.5, 1 0 1, 0 0 1, 0 0 0.5)),\\\n            ((1 1 1, 0 1 1, 0 0 1, 1 0 1, 1 1 1)),\\\n            ((1 1 1, 1 0 1, 1 0 0.5, 1 1 0.5, 1 1 1)),\\\n            ((1 1 1, 1 1 0.5, 0 1 0.5, 0 1 1, 1 1 1))))\",\n        )\n        .unwrap();\n        let diff = cube1.difference_3d(&cube2).unwrap();\n        assert_eq!(diff.is_valid().unwrap(), true);\n        assert_ulps_eq!(diff.volume().unwrap(), 0.5);\n    }", "item_id": 17, "repo": "mthh/sfcgal-rs", "file": "src/geometry.rs", "last_update_at": "2021-12-20T09:31:12+00:00", "question_id": "232dfda793151cd6d1550bbef06be3edac9264d4_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn difference_3d() {\n        let cube1 = SFCGeometry::new(\n            \"\n            SOLID((((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)),\\\n            ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)),\\\n            ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)),\\\n            ((1 1 1, 0 1 1, 0 0 1, 1 0 1, 1 1 1)),\\\n            ((1 1 1, 1 0 1, 1 0 0, 1 1 0, 1 1 1)),\\\n            ((1 1 1, 1 1 0, 0 1 0, 0 1 1, 1 1 1))))\",\n        )\n        .unwrap();\n        let cube2 = SFCGeometry::new(\n            \"\n            SOLID((((0 0 0.5, 0 1 0.5, 1 1 0.5, 1 0 0.5, 0 0 0.5)),\\\n            ((0 0 0.5, 0 0 1, 0 1 1, 0 1 0.5, 0 0 0.5)),\\\n            ((0 0 0.5, 1 0 0.5, 1 0 1, 0 0 1, 0 0 0.5)),\\\n            ((1 1 1, 0 1 1, 0 0 1, 1 0 1, 1 1 1)),\\\n            ((1 1 1, 1 0 1, 1 0 0.5, 1 1 0.5, 1 1 1)),\\\n            ((1 1 1, 1 1 0.5, 0 1 0.5, 0 1 1, 1 1 1))))\",\n        )\n        .unwrap();\n        let diff = cube1.difference_3d(&cube2).unwrap();\n        assert_eq!(diff.is_valid().unwrap(), true);\n        assert_ulps_eq!(diff.volume().unwrap(), 0.5);\n"]], "pred": {"ppl": 1.4053120613098145, "ppl_lower": 1.4350199699401855, "ppl/lowercase_ppl": -1.0614806835728163, "ppl/zlib": 0.0012373068575173276, "Min_5.0% Prob": 5.008357342084249, "Min_10.0% Prob": 3.1293836414813994, "Min_20.0% Prob": 1.6847036270316966, "Min_30.0% Prob": 1.131468731408509, "Min_40.0% Prob": 0.8498559285572312, "Min_50.0% Prob": 0.6800314223785934, "Min_60.0% Prob": 0.5681787419061248}}
{"hexsha": "7f31ef83455df4262a10bf3f3f0987f417506575", "ext": "rs", "lang": "Rust", "content": "fn never() {\n    let mut never = Never::new();\n    let _subscription = never.subscribe_error(\n        |_x: u8| panic!(\"never observable should not produce a value\"),\n        || panic!(\"never observable should not complete\"),\n        |_err: ()| panic!(\"never observable should not fail\")\n    );\n\n    // Without something like a message loop, the observable cannot suddenly\n    // start pushing values, so if it did not produce anything here, it never\n    // will.\n}", "item_id": 0, "repo": "ruuda/rx", "file": "tests/rx.rs", "last_update_at": "2021-12-22T03:12:32+00:00", "question_id": "7f31ef83455df4262a10bf3f3f0987f417506575_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn never() {\n    let mut never = Never::new();\n    let _subscription = never.subscribe_error(\n        |_x: u8| panic!(\"never observable should not produce a value\"),\n        || panic!(\"never observable should not complete\"),\n        |_err: ()| panic!(\"never observable should not fail\")\n    );\n    // Without something like a message loop, the observable cannot suddenly\n    // start pushing values, so if it did not produce anything here, it never\n    // will.\n"]], "pred": {"ppl": 5.647854328155518, "ppl_lower": 5.86486291885376, "ppl/lowercase_ppl": -1.0217778143655853, "ppl/zlib": 0.007124591391362799, "Min_5.0% Prob": 9.819873491923014, "Min_10.0% Prob": 7.90399173895518, "Min_20.0% Prob": 5.6894515454769135, "Min_30.0% Prob": 4.621490306324429, "Min_40.0% Prob": 3.8748899276057878, "Min_50.0% Prob": 3.2807341618616075, "Min_60.0% Prob": 2.828576620719204}}
{"hexsha": "ee23bceb61999618b90fa59c426d25d22c6d6bf1", "ext": "rs", "lang": "Rust", "content": "fn assign_fractional_seconds(\n    fractional: &str,\n    mut setter: FractionalSecondSetter,\n) -> FractionalSecondSetter {\n    let number_of_digits = fractional.len();\n    // If the precision is less than or equal to nanoseconds...\n    if number_of_digits <= 9 {\n        // Convert the number to nanoseconds and make a note of its original precision.\n        let power = 9 - number_of_digits;\n        let nanoseconds =\n            trim_zeros_expect_u32(fractional, \"fractional seconds\") * 10u32.pow(power as u32);\n        setter = setter.with_nanoseconds_and_precision(nanoseconds, number_of_digits as u32);\n    } else {\n        // Otherwise, the number's precision is great enough that we'll need to construct a Decimal\n        // to store it without loss of fidelity.\n        let coefficient =\n            BigUint::from_str(fractional).expect(\"parsing fractional seconds as BigUint failed\");\n        let mut digit_count = 1i64;\n        let mut tmp_coefficient = coefficient.clone();\n        let ten = BigUint::from(10u32);\n        while tmp_coefficient > ten {\n            tmp_coefficient.div_assign(&ten);\n            digit_count += 1;\n        }\n        let decimal = Decimal::new(coefficient, -1 * digit_count);\n        setter = setter.with_fractional_seconds(decimal);\n    }\n    setter\n}", "item_id": 0, "repo": "upsuper-forks/ion-rust", "file": "src/text/parsers/timestamp.rs", "last_update_at": "2021-07-10T08:27:50+00:00", "question_id": "ee23bceb61999618b90fa59c426d25d22c6d6bf1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn assign_fractional_seconds(\n    fractional: &str,\n    mut setter: FractionalSecondSetter,\n) -> FractionalSecondSetter {\n    let number_of_digits = fractional.len();\n    // If the precision is less than or equal to nanoseconds...\n    if number_of_digits <= 9 {\n        // Convert the number to nanoseconds and make a note of its original precision.\n        let power = 9 - number_of_digits;\n        let nanoseconds =\n            trim_zeros_expect_u32(fractional, \"fractional seconds\") * 10u32.pow(power as u32);\n        setter = setter.with_nanoseconds_and_precision(nanoseconds, number_of_digits as u32);\n    } else {\n        // Otherwise, the number's precision is great enough that we'll need to construct a Decimal\n        // to store it without loss of fidelity.\n        let coefficient =\n            BigUint::from_str(fractional).expect(\"parsing fractional seconds as BigUint failed\");\n        let mut digit_count = 1i64;\n        let mut tmp_coefficient = coefficient.clone();\n        let ten = BigUint::from(10u32);\n        while tmp_coefficient > ten {\n            tmp_coefficient.div_assign(&ten);\n            digit_count += 1;\n        }\n        let decimal = Decimal::new(coefficient, -1 * digit_count);\n        setter = setter.with_fractional_seconds(decimal);\n    }\n    setter\n"]], "pred": {"ppl": 2.672328233718872, "ppl_lower": 2.9486277103424072, "ppl/lowercase_ppl": -1.1000964241085078, "ppl/zlib": 0.0018338621083779836, "Min_5.0% Prob": 7.781779384613037, "Min_10.0% Prob": 5.958490473031998, "Min_20.0% Prob": 4.075413657724857, "Min_30.0% Prob": 3.057397886614005, "Min_40.0% Prob": 2.397987159155309, "Min_50.0% Prob": 1.953368947021663, "Min_60.0% Prob": 1.6380148286931218}}
{"hexsha": "3d2259d8a01be262eb3f081d00e29db146116d2c", "ext": "rs", "lang": "Rust", "content": "fn load_thread_state() {\n        let init_epoch = Epoch::with_epoch(128);\n        let thread_state = ThreadState::new(init_epoch);\n        let (epoch, state) = thread_state.load(Relaxed);\n\n        assert_eq!(init_epoch, epoch);\n        assert_eq!(state, Inactive);\n    }", "item_id": 1, "repo": "oliver-giersch/debra-common", "file": "src/thread.rs", "last_update_at": "2021-07-15T15:55:40+00:00", "question_id": "3d2259d8a01be262eb3f081d00e29db146116d2c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn load_thread_state() {\n        let init_epoch = Epoch::with_epoch(128);\n        let thread_state = ThreadState::new(init_epoch);\n        let (epoch, state) = thread_state.load(Relaxed);\n        assert_eq!(init_epoch, epoch);\n        assert_eq!(state, Inactive);\n"]], "pred": {"ppl": 3.4114229679107666, "ppl_lower": 4.243007659912109, "ppl/lowercase_ppl": -1.1777667924865465, "ppl/zlib": 0.008235768435540391, "Min_5.0% Prob": 8.29231858253479, "Min_10.0% Prob": 6.366664356655544, "Min_20.0% Prob": 4.689259742435656, "Min_30.0% Prob": 3.7135950241770064, "Min_40.0% Prob": 2.916048515784113, "Min_50.0% Prob": 2.4172562252967915, "Min_60.0% Prob": 2.028508433647323}}
{"hexsha": "ceb6035bbfb0d690a3018df797bedb38865bc265", "ext": "rs", "lang": "Rust", "content": "pub fn run(args: Args) {\n\tlet tangram_path = std::env::current_dir().unwrap();\n\tlet dist_path = tangram_path.join(\"dist\");\n\n\teprintln!(\"clean and create release directory\");\n\tlet release_path = dist_path.join(\"release\");\n\tclean_and_create(&release_path);\n\n\teprintln!(\"tangram_cli\");\n\tfor target in [\n\t\tTarget::X8664UnknownLinuxGnu,\n\t\tTarget::AArch64UnknownLinuxGnu,\n\t\tTarget::X8664UnknownLinuxMusl,\n\t\tTarget::AArch64UnknownLinuxMusl,\n\t\tTarget::X8664AppleDarwin,\n\t\tTarget::AArch64AppleDarwin,\n\t\tTarget::X8664PcWindowsMsvc,\n\t\tTarget::X8664PcWindowsGnu,\n\t] {\n\t\tlet tangram_cli_file_name = TargetFileNames::for_target(target).tangram_cli_file_name;\n\t\tlet tangram_cli_path = dist_path.join(target.as_str()).join(tangram_cli_file_name);\n\t\tlet output_path =\n\t\t\trelease_path.join(format!(\"tangram_cli_{}_{}.tar.gz\", args.version, target));\n\t\tlet inputs = vec![(\n\t\t\ttangram_cli_path.clone(),\n\t\t\tPathBuf::from(tangram_cli_file_name),\n\t\t)];\n\t\ttar(inputs, &output_path);\n\t}\n\n\teprintln!(\"deb\");\n\t#[allow(clippy::single_element_loop)]\n\tfor target in [Target::X8664UnknownLinuxGnu, Target::AArch64UnknownLinuxGnu] {\n\t\t// Create the deb directory.\n\t\tlet deb_path = dist_path.join(\"deb\");\n\t\tclean_and_create(&deb_path);\n\t\t// Create /usr/bin in the deb directory.\n\t\tlet bin_path = deb_path.join(\"usr\").join(\"bin\");\n\t\tstd::fs::create_dir_all(&bin_path).unwrap();\n\t\t// Copy the tangram cli to the deb's /usr/bin.\n\t\tlet tangram_cli_file_name = TargetFileNames::for_target(target).tangram_cli_file_name;\n\t\tlet tangram_cli_path = dist_path.join(target.as_str()).join(tangram_cli_file_name);\n\t\tstd::fs::copy(tangram_cli_path, bin_path.join(tangram_cli_file_name)).unwrap();\n\t\t// Create the control file.\n\t\tlet debian_path = deb_path.join(\"DEBIAN\");\n\t\tstd::fs::create_dir_all(&debian_path).unwrap();\n\t\tlet control_path = debian_path.join(\"control\");\n\t\tlet architecture = match target {\n\t\t\tTarget::X8664UnknownLinuxGnu => \"amd64\",\n\t\t\tTarget::AArch64UnknownLinuxGnu => \"arm64\",\n\t\t\t_ => unreachable!(),\n\t\t};\n\t\tlet control = formatdoc!(\n\t\t\tr#\"\n\t\t\t\tPackage: tangram\n\t\t\t\tArchitecture: {}\n\t\t\t\tVersion: {}\n\t\t\t\tMaintainer: Tangram <root@tangram.dev>\n\t\t\t\tHomepage: https://www.tangram.dev\n\t\t\t\tDescription: Tangram makes it easy for programmers to train, deploy, and monitor machine learning models.\n\t\t\t\"#,\n\t\t\tarchitecture,\n\t\t\targs.version,\n\t\t);\n\t\tstd::fs::write(&control_path, &control).unwrap();\n\t\t// Run dpkg-deb\n\t\tlet deb_file_name = format!(\"tangram_{}_{}.deb\", args.version, architecture);\n\t\tlet deb_output_path = release_path.join(&deb_file_name);\n\t\tcmd!(\"dpkg-deb\", \"--build\", &deb_path, &deb_output_path)\n\t\t\t.run()\n\t\t\t.unwrap();\n\t\tstd::fs::remove_dir_all(&deb_path).unwrap();\n\t}\n\n\teprintln!(\"rpm\");\n\t#[allow(clippy::single_element_loop)]\n\tfor target in [Target::X8664UnknownLinuxGnu, Target::AArch64UnknownLinuxGnu] {\n\t\t// Create the rpm directory.\n\t\tlet rpm_path = dist_path.join(\"rpm\");\n\t\tclean_and_create(&rpm_path);\n\t\tfor subdir in [\"BUILD\", \"BUILDROOT\", \"RPMS\", \"SOURCES\", \"SPECS\", \"SRPMS\"] {\n\t\t\tstd::fs::create_dir(rpm_path.join(subdir)).unwrap();\n\t\t}\n\t\t// Make the tar.\n\t\tlet tangram_cli_file_name = TargetFileNames::for_target(target).tangram_cli_file_name;\n\t\tlet tangram_cli_path = dist_path.join(target.as_str()).join(tangram_cli_file_name);\n\t\tlet tangram_path_in_tar = PathBuf::from(format!(\"tangram-{}/tangram\", args.version));\n\t\tlet sources_path = rpm_path.join(\"SOURCES\");\n\t\tlet tar_path = sources_path.join(\"tangram.tar.gz\");\n\t\ttar(vec![(tangram_cli_path, tangram_path_in_tar)], &tar_path);\n\t\t// Write the spec file.\n\t\tlet spec = formatdoc!(\n\t\t\tr#\"\n\t\t\t\t%global __strip true\n\n\t\t\t\tName: tangram\n\t\t\t\tVersion: {}\n\t\t\t\tRelease: 1\n\t\t\t\tSummary: Tangram makes it easy for programmers to train, deploy, and monitor machine learning models.\n\t\t\t\tLicense: MIT\n\t\t\t\tSource0: tangram.tar.gz\n\n\t\t\t\t%description\n\t\t\t\t%summary\n\n\t\t\t\t%prep\n\t\t\t\t%setup -q\n\n\t\t\t\t%install\n\t\t\t\tmkdir -p %buildroot/usr/bin\n\t\t\t\tinstall -m 755 tangram %buildroot/usr/bin/tangram\n\n\t\t\t\t%files\n\t\t\t\t%attr(0755, root, root) /usr/bin/tangram\n\t\t\t\"#,\n\t\t\targs.version,\n\t\t);\n\t\tlet spec_path = rpm_path.join(\"SPECS/tangram.spec\");\n\t\tstd::fs::write(&spec_path, spec).unwrap();\n\t\t// Run rpmbuild.\n\t\tlet target = match target {\n\t\t\tTarget::X8664UnknownLinuxGnu => \"x86_64\",\n\t\t\tTarget::AArch64UnknownLinuxGnu => \"aarch64\",\n\t\t\t_ => unreachable!(),\n\t\t};\n\t\tcmd!(\n\t\t\t\"rpmbuild\",\n\t\t\t\"-D\",\n\t\t\tformat!(\"_topdir {}\", rpm_path.display()),\n\t\t\t\"--target\",\n\t\t\ttarget,\n\t\t\t\"-bb\",\n\t\t\tspec_path,\n\t\t)\n\t\t.run()\n\t\t.unwrap();\n\t\t// Move the rpm to the release directory.\n\t\tlet src_rpm_file_name = format!(\"tangram-{}-1.{}.rpm\", args.version, target);\n\t\tlet dst_rpm_file_name = format!(\"tangram_{}_{}.rpm\", args.version, target);\n\t\tstd::fs::copy(\n\t\t\trpm_path.join(\"RPMS\").join(target).join(&src_rpm_file_name),\n\t\t\trelease_path.join(&dst_rpm_file_name),\n\t\t)\n\t\t.unwrap();\n\t\tstd::fs::remove_dir_all(rpm_path).unwrap();\n\t}\n\n\teprintln!(\"container\");\n\tlet dockerfile_path = tangram_path.join(\"Dockerfile\");\n\tlet target = Target::X8664UnknownLinuxMusl;\n\tlet tangram_cli_file_name = TargetFileNames::for_target(target).tangram_cli_file_name;\n\tlet tangram_cli_path = dist_path\n\t\t.strip_prefix(&tangram_path)\n\t\t.unwrap()\n\t\t.join(target.as_str())\n\t\t.join(tangram_cli_file_name);\n\tlet dockerfile = formatdoc!(\n\t\tr#\"\n\t\t\tFROM docker.io/alpine\n\t\t\tWORKDIR /\n\t\t\tCOPY {} .\n\t\t\tENTRYPOINT [\"/tangram\"]\n\t\t\"#,\n\t\ttangram_cli_path.display(),\n\t);\n\tstd::fs::write(&dockerfile_path, &dockerfile).unwrap();\n\tlet tag = format!(\"docker.io/tangramdotdev/tangram:{}\", args.version);\n\tcmd!(\"docker\", \"build\", \"-t\", tag, &tangram_path)\n\t\t.run()\n\t\t.unwrap();\n\tstd::fs::remove_file(&dockerfile_path).unwrap();\n\n\teprintln!(\"libtangram\");\n\tfor target in [\n\t\tTarget::X8664UnknownLinuxGnu,\n\t\tTarget::AArch64UnknownLinuxGnu,\n\t\tTarget::X8664UnknownLinuxMusl,\n\t\tTarget::AArch64UnknownLinuxMusl,\n\t\tTarget::X8664AppleDarwin,\n\t\tTarget::AArch64AppleDarwin,\n\t\tTarget::X8664PcWindowsMsvc,\n\t\tTarget::X8664PcWindowsGnu,\n\t] {\n\t\tlet target_file_names = TargetFileNames::for_target(target);\n\t\tlet target_path = dist_path.join(target.as_str());\n\t\tlet output_path =\n\t\t\trelease_path.join(format!(\"libtangram_{}_{}.tar.gz\", args.version, target));\n\t\tlet inputs = vec![\n\t\t\t(\n\t\t\t\ttarget_path.join(target_file_names.tangram_h_file_name),\n\t\t\t\tPathBuf::from(target_file_names.tangram_h_file_name),\n\t\t\t),\n\t\t\t(\n\t\t\t\ttarget_path.join(target_file_names.libtangram_dynamic_file_name),\n\t\t\t\tPathBuf::from(target_file_names.libtangram_dynamic_file_name),\n\t\t\t),\n\t\t\t(\n\t\t\t\ttarget_path.join(target_file_names.libtangram_static_file_name),\n\t\t\t\tPathBuf::from(target_file_names.libtangram_static_file_name),\n\t\t\t),\n\t\t];\n\t\ttar(inputs, &output_path);\n\t}\n}", "item_id": 0, "repo": "isabella/tangram", "file": "crates/build/prepare_release.rs", "last_update_at": "2021-11-23T18:53:22+00:00", "question_id": "ceb6035bbfb0d690a3018df797bedb38865bc265_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn run(args: Args) {\n\tlet tangram_path = std::env::current_dir().unwrap();\n\tlet dist_path = tangram_path.join(\"dist\");\n\teprintln!(\"clean and create release directory\");\n\tlet release_path = dist_path.join(\"release\");\n\tclean_and_create(&release_path);\n\teprintln!(\"tangram_cli\");\n\tfor target in [\n\t\tTarget::X8664UnknownLinuxGnu,\n\t\tTarget::AArch64UnknownLinuxGnu,\n\t\tTarget::X8664UnknownLinuxMusl,\n\t\tTarget::AArch64UnknownLinuxMusl,\n\t\tTarget::X8664AppleDarwin,\n\t\tTarget::AArch64AppleDarwin,\n\t\tTarget::X8664PcWindowsMsvc,\n\t\tTarget::X8664PcWindowsGnu,\n\t] {\n\t\tlet tangram_cli_file_name = TargetFileNames::for_target(target).tangram_cli_file_name;\n\t\tlet tangram_cli_path = dist_path.join(target.as_str()).join(tangram_cli_file_name);\n\t\tlet output_path =\n\t\t\trelease_path.join(format!(\"tangram_cli_{}_{}.tar.gz\", args.version, target));\n\t\tlet inputs = vec![(\n\t\t\ttangram_cli_path.clone(),\n\t\t\tPathBuf::from(tangram_cli_file_name),\n\t\t)];\n\t\ttar(inputs, &output_path);\n\t}\n\teprintln!(\"deb\");\n\t#[allow(clippy::single_element_loop)]\n\tfor target in [Target::X8664UnknownLinuxGnu, Target::AArch64UnknownLinuxGnu] {\n\t\t// Create the deb directory.\n\t\tlet deb_path = dist_path.join(\"deb\");\n\t\tclean_and_create(&deb_path);\n\t\t// Create /usr/bin in the deb directory.\n\t\tlet bin_path = deb_path.join(\"usr\").join(\"bin\");\n\t\tstd::fs::create_dir_all(&bin_path).unwrap();\n\t\t// Copy the tangram cli to the deb's /usr/bin.\n\t\tlet tangram_cli_file_name = TargetFileNames::for_target(target).tangram_cli_file_name;\n\t\tlet tangram_cli_path = dist_path.join(target.as_str()).join(tangram_cli_file_name);\n\t\tstd::fs::copy(tangram_cli_path, bin_path.join(tangram_cli_file_name)).unwrap();\n\t\t// Create the control file.\n\t\tlet debian_path = deb_path.join(\"DEBIAN\");\n\t\tstd::fs::create_dir_all(&debian_path).unwrap();\n\t\tlet control_path = debian_path.join(\"control\");\n\t\tlet architecture = match target {\n\t\t\tTarget::X8664UnknownLinuxGnu => \"amd64\",\n\t\t\tTarget::AArch64UnknownLinuxGnu => \"arm64\",\n\t\t\t_ => unreachable!(),\n\t\t};\n\t\tlet control = formatdoc!(\n\t\t\tr#\"\n\t\t\t\tPackage: tangram\n\t\t\t\tArchitecture: {}\n\t\t\t\tVersion: {}\n\t\t\t\tMaintainer: Tangram <root@tangram.dev>\n\t\t\t\tHomepage: https://www.tangram.dev\n\t\t\t\tDescription: Tangram makes it easy for programmers to train, deploy, and monitor machine learning models.\n\t\t\t\"#,\n\t\t\tarchitecture,\n\t\t\targs.version,\n\t\t);\n\t\tstd::fs::write(&control_path, &control).unwrap();\n\t\t// Run dpkg-deb\n\t\tlet deb_file_name = format!(\"tangram_{}_{}.deb\", args.version, architecture);\n\t\tlet deb_output_path = release_path.join(&deb_file_name);\n\t\tcmd!(\"dpkg-deb\", \"--build\", &deb_path, &deb_output_path)\n\t\t\t.run()\n\t\t\t.unwrap();\n\t\tstd::fs::remove_dir_all(&deb_path).unwrap();\n\t}\n\teprintln!(\"rpm\");\n\t#[allow(clippy::single_element_loop)]\n\tfor target in [Target::X8664UnknownLinuxGnu, Target::AArch64UnknownLinuxGnu] {\n\t\t// Create the rpm directory.\n\t\tlet rpm_path = dist_path.join(\"rpm\");\n\t\tclean_and_create(&rpm_path);\n\t\tfor subdir in [\"BUILD\", \"BUILDROOT\", \"RPMS\", \"SOURCES\", \"SPECS\", \"SRPMS\"] {\n\t\t\tstd::fs::create_dir(rpm_path.join(subdir)).unwrap();\n\t\t}\n\t\t// Make the tar.\n\t\tlet tangram_cli_file_name = TargetFileNames::for_target(target).tangram_cli_file_name;\n\t\tlet tangram_cli_path = dist_path.join(target.as_str()).join(tangram_cli_file_name);\n\t\tlet tangram_path_in_tar = PathBuf::from(format!(\"tangram-{}/tangram\", args.version));\n\t\tlet sources_path = rpm_path.join(\"SOURCES\");\n\t\tlet tar_path = sources_path.join(\"tangram.tar.gz\");\n\t\ttar(vec![(tangram_cli_path, tangram_path_in_tar)], &tar_path);\n\t\t// Write the spec file.\n\t\tlet spec = formatdoc!(\n\t\t\tr#\"\n\t\t\t\t%global __strip true\n\t\t\t\tName: tangram\n\t\t\t\tVersion: {}\n\t\t\t\tRelease: 1\n\t\t\t\tSummary: Tangram makes it easy for programmers to train, deploy, and monitor machine learning models.\n\t\t\t\tLicense: MIT\n\t\t\t\tSource0: tangram.tar.gz\n\t\t\t\t%description\n\t\t\t\t%summary\n\t\t\t\t%prep\n\t\t\t\t%setup -q\n\t\t\t\t%install\n\t\t\t\tmkdir -p %buildroot/usr/bin\n\t\t\t\tinstall -m 755 tangram %buildroot/usr/bin/tangram\n\t\t\t\t%files\n\t\t\t\t%attr(0755, root, root) /usr/bin/tangram\n\t\t\t\"#,\n\t\t\targs.version,\n\t\t);\n\t\tlet spec_path = rpm_path.join(\"SPECS/tangram.spec\");\n\t\tstd::fs::write(&spec_path, spec).unwrap();\n\t\t// Run rpmbuild.\n\t\tlet target = match target {\n\t\t\tTarget::X8664UnknownLinuxGnu => \"x86_64\",\n\t\t\tTarget::AArch64UnknownLinuxGnu => \"aarch64\",\n\t\t\t_ => unreachable!(),\n\t\t};\n\t\tcmd!(\n\t\t\t\"rpmbuild\",\n\t\t\t\"-D\",\n\t\t\tformat!(\"_topdir {}\", rpm_path.display()),\n\t\t\t\"--target\",\n\t\t\ttarget,\n\t\t\t\"-bb\",\n\t\t\tspec_path,\n\t\t)\n\t\t.run()\n\t\t.unwrap();\n\t\t// Move the rpm to the release directory.\n\t\tlet src_rpm_file_name = format!(\"tangram-{}-1.{}.rpm\", args.version, target);\n\t\tlet dst_rpm_file_name = format!(\"tangram_{}_{}.rpm\", args.version, target);\n\t\tstd::fs::copy(\n\t\t\trpm_path.join(\"RPMS\").join(target).join(&src_rpm_file_name),\n\t\t\trelease_path.join(&dst_rpm_file_name),\n\t\t)\n\t\t.unwrap();\n\t\tstd::fs::remove_dir_all(rpm_path).unwrap();\n\t}\n\teprintln!(\"container\");\n\tlet dockerfile_path = tangram_path.join(\"Dockerfile\");\n\tlet target = Target::X8664UnknownLinuxMusl;\n\tlet tangram_cli_file_name = TargetFileNames::for_target(target).tangram_cli_file_name;\n\tlet tangram_cli_path = dist_path\n\t\t.strip_prefix(&tangram_path)\n\t\t.unwrap()\n\t\t.join(target.as_str())\n\t\t.join(tangram_cli_file_name);\n\tlet dockerfile = formatdoc!(\n\t\tr#\"\n\t\t\tFROM docker.io/alpine\n\t\t\tWORKDIR /\n\t\t\tCOPY {} .\n\t\t\tENTRYPOINT [\"/tangram\"]\n\t\t\"#,\n\t\ttangram_cli_path.display(),\n\t);\n\tstd::fs::write(&dockerfile_path, &dockerfile).unwrap();\n\tlet tag = format!(\"docker.io/tangramdotdev/tangram:{}\", args.version);\n\tcmd!(\"docker\", \"build\", \"-t\", tag, &tangram_path)\n\t\t.run()\n\t\t.unwrap();\n\tstd::fs::remove_file(&dockerfile_path).unwrap();\n\teprintln!(\"libtangram\");\n\tfor target in [\n\t\tTarget::X8664UnknownLinuxGnu,\n\t\tTarget::AArch64UnknownLinuxGnu,\n\t\tTarget::X8664UnknownLinuxMusl,\n\t\tTarget::AArch64UnknownLinuxMusl,\n\t\tTarget::X8664AppleDarwin,\n\t\tTarget::AArch64AppleDarwin,\n\t\tTarget::X8664PcWindowsMsvc,\n\t\tTarget::X8664PcWindowsGnu,\n\t] {\n\t\tlet target_file_names = TargetFileNames::for_target(target);\n\t\tlet target_path = dist_path.join(target.as_str());\n\t\tlet output_path =\n\t\t\trelease_path.join(format!(\"libtangram_{}_{}.tar.gz\", args.version, target));\n\t\tlet inputs = vec![\n\t\t\t(\n\t\t\t\ttarget_path.join(target_file_names.tangram_h_file_name),\n\t\t\t\tPathBuf::from(target_file_names.tangram_h_file_name),\n\t\t\t),\n\t\t\t(\n\t\t\t\ttarget_path.join(target_file_names.libtangram_dynamic_file_name),\n\t\t\t\tPathBuf::from(target_file_names.libtangram_dynamic_file_name),\n\t\t\t),\n\t\t\t(\n\t\t\t\ttarget_path.join(target_file_names.libtangram_static_file_name),\n\t\t\t\tPathBuf::from(target_file_names.libtangram_static_file_name),\n\t\t\t),\n\t\t];\n\t\ttar(inputs, &output_path);\n\t}\n"]], "pred": {"ppl": 1.57865571975708, "ppl_lower": 1.6846742630004883, "ppl/lowercase_ppl": -1.142361591107082, "ppl/zlib": 0.00026422087651276294, "Min_5.0% Prob": 5.268496938780243, "Min_10.0% Prob": 3.5924282284343945, "Min_20.0% Prob": 2.1644880169746923, "Min_30.0% Prob": 1.5065099987280524, "Min_40.0% Prob": 1.1386062163804955, "Min_50.0% Prob": 0.9133691266024168, "Min_60.0% Prob": 0.761825866558548}}
{"hexsha": "6fe2bffcce32dd12d561bfd8a5a333df30fe509e", "ext": "rs", "lang": "Rust", "content": "fn test_unstake_without_stake() {\n    let mut deps = mock_dependencies(&[]);\n    let env = mock_env();\n    let instantiate_msg = InstantiateMsg {\n        owner: Addr::unchecked(\"owner0000\"),\n        nft_contract_addr: Addr::unchecked(\"internnft0000\"),\n        terrand_addr: Addr::unchecked(\"terrand0000\"),\n        stamina_constant: 1,\n        exp_constant: 1,\n    };\n\n    let info = mock_info(\"addr0000\", &[]);\n\n    let _instantiate_res =\n        instantiate(deps.as_mut(), mock_env(), info.clone(), instantiate_msg).unwrap();\n\n    let unstake_res = withdraw_nft(deps.as_mut(), env, info, \"0\".to_string());\n\n    match unstake_res {\n        Err(ContractError::NoStakedToken {}) => (),\n        _ => panic!(\"Must return no staked token error\"),\n    }\n}", "item_id": 8, "repo": "hippietechies/internft-contracts", "file": "contracts/internnft-staking-contract/src/testing/tests.rs", "last_update_at": "2021-12-27T09:19:15+00:00", "question_id": "6fe2bffcce32dd12d561bfd8a5a333df30fe509e_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_unstake_without_stake() {\n    let mut deps = mock_dependencies(&[]);\n    let env = mock_env();\n    let instantiate_msg = InstantiateMsg {\n        owner: Addr::unchecked(\"owner0000\"),\n        nft_contract_addr: Addr::unchecked(\"internnft0000\"),\n        terrand_addr: Addr::unchecked(\"terrand0000\"),\n        stamina_constant: 1,\n        exp_constant: 1,\n    };\n    let info = mock_info(\"addr0000\", &[]);\n    let _instantiate_res =\n        instantiate(deps.as_mut(), mock_env(), info.clone(), instantiate_msg).unwrap();\n    let unstake_res = withdraw_nft(deps.as_mut(), env, info, \"0\".to_string());\n    match unstake_res {\n        Err(ContractError::NoStakedToken {}) => (),\n        _ => panic!(\"Must return no staked token error\"),\n    }\n"]], "pred": {"ppl": 2.2022032737731934, "ppl_lower": 2.939283609390259, "ppl/lowercase_ppl": -1.3657033142863209, "ppl/zlib": 0.002236425912998246, "Min_5.0% Prob": 7.7523322105407715, "Min_10.0% Prob": 5.4144957432380085, "Min_20.0% Prob": 3.502332009948217, "Min_30.0% Prob": 2.5399369922203894, "Min_40.0% Prob": 1.949170050876481, "Min_50.0% Prob": 1.5791760212706245, "Min_60.0% Prob": 1.3212031084083162}}
{"hexsha": "810afef4f529224fac1df2091573646701493152", "ext": "rs", "lang": "Rust", "content": "pub fn replace_slashes<P: AsRef<Path>>(path: P) -> PathBuf {\n    #[cfg(target_os = \"windows\")]\n    {\n        if path.as_ref().is_absolute() {\n            // Absolute Windows paths are incompatible with other operating systems so\n            // don't bother here and return existing path as owned.\n            path.as_ref().to_owned()\n        } else {\n            // Replace all \\ to /. This is needed because on macos or linux \\ is a valid symbol in\n            // file name, and not separator (except linux which understand both variants).\n            let mut os_str = std::ffi::OsString::new();\n            let count = path.as_ref().components().count();\n            for (i, component) in path.as_ref().components().enumerate() {\n                os_str.push(component.as_os_str());\n                if i != count - 1 {\n                    os_str.push(\"/\");\n                }\n            }\n            PathBuf::from(os_str)\n        }\n    }\n\n    #[cfg(not(target_os = \"windows\"))]\n    {\n        path.as_ref().to_owned()\n    }\n}", "item_id": 0, "repo": "martin-t/Fyrox", "file": "rg3d-core/src/lib.rs", "last_update_at": "2021-12-07T22:38:40+00:00", "question_id": "810afef4f529224fac1df2091573646701493152_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn replace_slashes<P: AsRef<Path>>(path: P) -> PathBuf {\n    #[cfg(target_os = \"windows\")]\n    {\n        if path.as_ref().is_absolute() {\n            // Absolute Windows paths are incompatible with other operating systems so\n            // don't bother here and return existing path as owned.\n            path.as_ref().to_owned()\n        } else {\n            // Replace all \\ to /. This is needed because on macos or linux \\ is a valid symbol in\n            // file name, and not separator (except linux which understand both variants).\n            let mut os_str = std::ffi::OsString::new();\n            let count = path.as_ref().components().count();\n            for (i, component) in path.as_ref().components().enumerate() {\n                os_str.push(component.as_os_str());\n                if i != count - 1 {\n                    os_str.push(\"/\");\n                }\n            }\n            PathBuf::from(os_str)\n        }\n    }\n    #[cfg(not(target_os = \"windows\"))]\n    {\n        path.as_ref().to_owned()\n    }\n"]], "pred": {"ppl": 2.6694397926330566, "ppl_lower": 3.605531692504883, "ppl/lowercase_ppl": -1.3061515581511918, "ppl/zlib": 0.0021115454514076797, "Min_5.0% Prob": 8.034898383276802, "Min_10.0% Prob": 6.1840211605203566, "Min_20.0% Prob": 4.312392043656316, "Min_30.0% Prob": 3.183207796907973, "Min_40.0% Prob": 2.4405135069813193, "Min_50.0% Prob": 1.96114104656053, "Min_60.0% Prob": 1.6358907180597428}}
{"hexsha": "687a8d4fd76d113071183b6338c2a949aec154a4", "ext": "rs", "lang": "Rust", "content": "fn test_opcode_0X85() {\n    let mem = Rc::new(RefCell::new(FakeMemory::new()));\n    let reg = Register::new_from_debug_string(\n        \"register { a: 13, b: 6, c: 0, d: 0, e: 0, f: 0, h: 156, l: 19, pc: 7634, sp: 50100 }\",\n    );\n    mem.borrow_mut().fake_data(7634, 111);\n    let mut cpu = CPU::new(mem, false);\n    cpu.set_reg(reg);\n    cpu.op_0x85();\n    assert_eq!(\n        format!(\"{:?}\", cpu.get_reg_snapshot()).to_lowercase(),\n        \"register { a: 32, b: 6, c: 0, d: 0, e: 0, f: 32, h: 156, l: 19, pc: 7634, sp: 50100 }\"\n    );\n}", "item_id": 65, "repo": "Hanaasagi/NGC-224", "file": "tests/opcodes.rs", "last_update_at": "2021-06-07T00:56:59+00:00", "question_id": "687a8d4fd76d113071183b6338c2a949aec154a4_65", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_opcode_0X85() {\n    let mem = Rc::new(RefCell::new(FakeMemory::new()));\n    let reg = Register::new_from_debug_string(\n        \"register { a: 13, b: 6, c: 0, d: 0, e: 0, f: 0, h: 156, l: 19, pc: 7634, sp: 50100 }\",\n    );\n    mem.borrow_mut().fake_data(7634, 111);\n    let mut cpu = CPU::new(mem, false);\n    cpu.set_reg(reg);\n    cpu.op_0x85();\n    assert_eq!(\n        format!(\"{:?}\", cpu.get_reg_snapshot()).to_lowercase(),\n        \"register { a: 32, b: 6, c: 0, d: 0, e: 0, f: 32, h: 156, l: 19, pc: 7634, sp: 50100 }\"\n    );\n"]], "pred": {"ppl": 2.961984395980835, "ppl_lower": 3.54864239692688, "ppl/lowercase_ppl": -1.166417172639682, "ppl/zlib": 0.0035955610853084115, "Min_5.0% Prob": 6.9755335587721605, "Min_10.0% Prob": 5.845438321431478, "Min_20.0% Prob": 4.359149009531195, "Min_30.0% Prob": 3.3781646411102937, "Min_40.0% Prob": 2.671880498799411, "Min_50.0% Prob": 2.1652507605436058, "Min_60.0% Prob": 1.8079309462603317}}
{"hexsha": "280909d27d1b477ada1859382bed40a6c210a1f2", "ext": "rs", "lang": "Rust", "content": "fn test_interval_compare() {\n            use std::cmp::Ordering;\n            {\n                let iv = Interval::<i32>::bounded(1, 10, Vec::new());\n                use std::cmp::Ordering;\n                assert!(iv.compare_elem(&0) == Ordering::Greater);\n                assert!(iv.compare_elem(&2) == Ordering::Equal);\n                assert!(iv.compare_elem(&11) == Ordering::Less);\n            }\n            {\n                let iv = Interval::<i32>::with_lower_bound(1, Vec::new());\n                assert!(iv.compare_elem(&0) == Ordering::Greater);\n                // Not sure this should be equal\n                assert!(iv.compare_elem(&1) == Ordering::Equal);\n                assert!(iv.compare_elem(&2) == Ordering::Less);\n            }\n        }", "item_id": 1, "repo": "JustusAdam/noria", "file": "noria-server/dataflow/src/state/click_ana.rs", "last_update_at": "2021-03-19T04:31:19+00:00", "question_id": "280909d27d1b477ada1859382bed40a6c210a1f2_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_interval_compare() {\n            use std::cmp::Ordering;\n            {\n                let iv = Interval::<i32>::bounded(1, 10, Vec::new());\n                use std::cmp::Ordering;\n                assert!(iv.compare_elem(&0) == Ordering::Greater);\n                assert!(iv.compare_elem(&2) == Ordering::Equal);\n                assert!(iv.compare_elem(&11) == Ordering::Less);\n            }\n            {\n                let iv = Interval::<i32>::with_lower_bound(1, Vec::new());\n                assert!(iv.compare_elem(&0) == Ordering::Greater);\n                // Not sure this should be equal\n                assert!(iv.compare_elem(&1) == Ordering::Equal);\n                assert!(iv.compare_elem(&2) == Ordering::Less);\n            }\n"]], "pred": {"ppl": 2.17862868309021, "ppl_lower": 2.601621627807617, "ppl/lowercase_ppl": -1.2278673609441528, "ppl/zlib": 0.0033564467000667822, "Min_5.0% Prob": 7.778133296966553, "Min_10.0% Prob": 5.59958130972726, "Min_20.0% Prob": 3.5480377493902693, "Min_30.0% Prob": 2.534832315519452, "Min_40.0% Prob": 1.9294483069936896, "Min_50.0% Prob": 1.5617090012599653, "Min_60.0% Prob": 1.2971054387509882}}
{"hexsha": "005a1dabb89dacad4f9fde1bc1ea687065a751e4", "ext": "rs", "lang": "Rust", "content": "pub async fn check_clean(allow_dirty: bool) -> Result<()> {\n    // Figure out state of the repo.\n    let repo = Repository::discover(\".\").expect(\"unable to find repository\");\n    let mut options = StatusOptions::new();\n    options\n        .include_untracked(true)\n        .include_ignored(false)\n        .include_unmodified(false)\n        .exclude_submodules(true)\n        .sort_case_insensitively(true);\n    let statuses = repo\n        .statuses(Some(&mut options))\n        .expect(\"unable to list repository changes\");\n\n    // Determine if the repo is clean or not.\n    let clean = statuses.iter().next().is_none();\n    if clean {\n        return Ok(());\n    }\n\n    // Warn if the user --allow-dirty or fail if not.\n    if allow_dirty {\n        eprintln!(\"Not all changes are committed to git but --allow-dirty was set.\");\n        return Ok(());\n    }\n    let error = anyhow::anyhow!(\"Not all changes are committed to git\");\n    ReleaseCheck::failed(error)\n}", "item_id": 1, "repo": "replicante-io/replicante", "file": "devtools/replidev/src/command/release/git.rs", "last_update_at": "2021-11-03T11:36:42+00:00", "question_id": "005a1dabb89dacad4f9fde1bc1ea687065a751e4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn check_clean(allow_dirty: bool) -> Result<()> {\n    // Figure out state of the repo.\n    let repo = Repository::discover(\".\").expect(\"unable to find repository\");\n    let mut options = StatusOptions::new();\n    options\n        .include_untracked(true)\n        .include_ignored(false)\n        .include_unmodified(false)\n        .exclude_submodules(true)\n        .sort_case_insensitively(true);\n    let statuses = repo\n        .statuses(Some(&mut options))\n        .expect(\"unable to list repository changes\");\n    // Determine if the repo is clean or not.\n    let clean = statuses.iter().next().is_none();\n    if clean {\n        return Ok(());\n    }\n    // Warn if the user --allow-dirty or fail if not.\n    if allow_dirty {\n        eprintln!(\"Not all changes are committed to git but --allow-dirty was set.\");\n        return Ok(());\n    }\n    let error = anyhow::anyhow!(\"Not all changes are committed to git\");\n    ReleaseCheck::failed(error)\n"]], "pred": {"ppl": 2.5806312561035156, "ppl_lower": 3.081294298171997, "ppl/lowercase_ppl": -1.1870351544780207, "ppl/zlib": 0.0020699433229570546, "Min_5.0% Prob": 8.063451085771833, "Min_10.0% Prob": 5.935137101582119, "Min_20.0% Prob": 3.9481766053608487, "Min_30.0% Prob": 2.928552715918597, "Min_40.0% Prob": 2.314795364584543, "Min_50.0% Prob": 1.8821623768185225, "Min_60.0% Prob": 1.5811418071608334}}
{"hexsha": "b37510c572dd0fb1209d0493fad1b9440cda272c", "ext": "rs", "lang": "Rust", "content": "fn test_n_triples_plain_literal_node_formatting() {\n        let formatter = NTriplesFormatter::new();\n        let node = Node::LiteralNode {\n            literal: \"literal\".to_string(),\n            data_type: None,\n            language: None,\n        };\n\n        assert_eq!(formatter.format_node(&node), \"\\\"literal\\\"\".to_string());\n    }", "item_id": 2, "repo": "Sparika/rdf-rs", "file": "src/writer/formatter/n_triples_formatter.rs", "last_update_at": "2021-12-17T03:40:05+00:00", "question_id": "b37510c572dd0fb1209d0493fad1b9440cda272c_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_n_triples_plain_literal_node_formatting() {\n        let formatter = NTriplesFormatter::new();\n        let node = Node::LiteralNode {\n            literal: \"literal\".to_string(),\n            data_type: None,\n            language: None,\n        };\n        assert_eq!(formatter.format_node(&node), \"\\\"literal\\\"\".to_string());\n"]], "pred": {"ppl": 2.668710708618164, "ppl_lower": 3.7604990005493164, "ppl/lowercase_ppl": -1.3493864785244905, "ppl/zlib": 0.005363909700111416, "Min_5.0% Prob": 7.426301002502441, "Min_10.0% Prob": 5.993900561332703, "Min_20.0% Prob": 3.9638153314590454, "Min_30.0% Prob": 3.0020620107650755, "Min_40.0% Prob": 2.365041120350361, "Min_50.0% Prob": 1.9435144433379172, "Min_60.0% Prob": 1.6409701986859242}}
{"hexsha": "811b87b3c4d69c493f9e3c49d2c798539bc4d965", "ext": "rs", "lang": "Rust", "content": "fn test_rotation_path_minutely() {\n        let r = Rotation::MINUTELY;\n        let mock_now = Utc.ymd(2020, 2, 1).and_hms(10, 3, 1);\n        let path = r.join_date(\"MyApplication.log\", &mock_now);\n        assert_eq!(\"MyApplication.log.2020-02-01-10-03\", path);\n    }", "item_id": 7, "repo": "dev-wei/tracing", "file": "tracing-appender/src/rolling.rs", "last_update_at": "2021-11-17T02:24:20+00:00", "question_id": "811b87b3c4d69c493f9e3c49d2c798539bc4d965_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_rotation_path_minutely() {\n        let r = Rotation::MINUTELY;\n        let mock_now = Utc.ymd(2020, 2, 1).and_hms(10, 3, 1);\n        let path = r.join_date(\"MyApplication.log\", &mock_now);\n        assert_eq!(\"MyApplication.log.2020-02-01-10-03\", path);\n"]], "pred": {"ppl": 3.6259732246398926, "ppl_lower": 4.125807762145996, "ppl/lowercase_ppl": -1.100253718761078, "ppl/zlib": 0.006962825556952425, "Min_5.0% Prob": 9.00633487701416, "Min_10.0% Prob": 7.8973895853216, "Min_20.0% Prob": 5.303955632707347, "Min_30.0% Prob": 3.9291685410908292, "Min_40.0% Prob": 3.1549760459557823, "Min_50.0% Prob": 2.5577112279575447, "Min_60.0% Prob": 2.141752373959337}}
{"hexsha": "f2ddeeea0ca361e6353a3481cdb7393a13d7d2d2", "ext": "rs", "lang": "Rust", "content": "fn test_timeout_search() {\n        let result = search(\n            Raid::new(346, 0, 4, false, 4, 0), // 5* Cradily, Den 166,\n            0xbb810e6006a2a035,\n            FrameFilter::new()\n                .set_shiny(ShinyFilter::Square)\n                .set_ability(AbilityFilter::Hidden)\n                .set_gender(GenderFilter::Male)\n                .set_ivs(\n                    Some(SingleIVFilter::new_at_least(IVJudgment::Best)),\n                    Some(SingleIVFilter::new_at_least(IVJudgment::Best)),\n                    Some(SingleIVFilter::new_at_least(IVJudgment::Best)),\n                    Some(SingleIVFilter::new_at_least(IVJudgment::Best)),\n                    Some(SingleIVFilter::new_at_least(IVJudgment::Best)),\n                    Some(SingleIVFilter::new_at_least(IVJudgment::Best)),\n                ),\n        )\n        .unwrap();\n        assert_eq!(result.1.ivs, IVs(31, 31, 31, 31, 31, 31));\n        assert_eq!(result.1.shiny, Shininess::Square);\n        assert_eq!(result.1.gender, Gender::Male);\n        assert_eq!(result.1.ability, Ability::Hidden);\n    }", "item_id": 3, "repo": "sliminality/raidtomi", "file": "crate/src/lib.rs", "last_update_at": "2021-08-05T07:07:47+00:00", "question_id": "f2ddeeea0ca361e6353a3481cdb7393a13d7d2d2_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_timeout_search() {\n        let result = search(\n            Raid::new(346, 0, 4, false, 4, 0), // 5* Cradily, Den 166,\n            0xbb810e6006a2a035,\n            FrameFilter::new()\n                .set_shiny(ShinyFilter::Square)\n                .set_ability(AbilityFilter::Hidden)\n                .set_gender(GenderFilter::Male)\n                .set_ivs(\n                    Some(SingleIVFilter::new_at_least(IVJudgment::Best)),\n                    Some(SingleIVFilter::new_at_least(IVJudgment::Best)),\n                    Some(SingleIVFilter::new_at_least(IVJudgment::Best)),\n                    Some(SingleIVFilter::new_at_least(IVJudgment::Best)),\n                    Some(SingleIVFilter::new_at_least(IVJudgment::Best)),\n                    Some(SingleIVFilter::new_at_least(IVJudgment::Best)),\n                ),\n        )\n        .unwrap();\n        assert_eq!(result.1.ivs, IVs(31, 31, 31, 31, 31, 31));\n        assert_eq!(result.1.shiny, Shininess::Square);\n        assert_eq!(result.1.gender, Gender::Male);\n        assert_eq!(result.1.ability, Ability::Hidden);\n"]], "pred": {"ppl": 3.0003108978271484, "ppl_lower": 3.1446640491485596, "ppl/lowercase_ppl": -1.0427691519146636, "ppl/zlib": 0.0033910985058878745, "Min_5.0% Prob": 8.874618583255344, "Min_10.0% Prob": 6.642033699396494, "Min_20.0% Prob": 4.647847326596578, "Min_30.0% Prob": 3.51460008003882, "Min_40.0% Prob": 2.7200648378332457, "Min_50.0% Prob": 2.1888541553288383, "Min_60.0% Prob": 1.8336916238069534}}
{"hexsha": "39909517ca920507369d0a764e5d99a89423a8d1", "ext": "rs", "lang": "Rust", "content": "fn test_basic_model_without_users() {\n        let mut m = Model::new();\n        m.load_model(\"examples/basic_without_users_model.conf\");\n\n        let adapter = FileAdapter::new(\"examples/basic_without_users_policy.csv\");\n        let e = Enforcer::new(m, adapter);\n\n        assert!(e.enforce(vec![\"data1\", \"read\"]));\n        assert!(!e.enforce(vec![\"data1\", \"write\"]));\n        assert!(!e.enforce(vec![\"data2\", \"read\"]));\n        assert!(e.enforce(vec![\"data2\", \"write\"]));\n    }", "item_id": 14, "repo": "Devolutions/casbin-rs", "file": "src/model.rs", "last_update_at": "2021-03-11T05:26:55+00:00", "question_id": "39909517ca920507369d0a764e5d99a89423a8d1_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_basic_model_without_users() {\n        let mut m = Model::new();\n        m.load_model(\"examples/basic_without_users_model.conf\");\n        let adapter = FileAdapter::new(\"examples/basic_without_users_policy.csv\");\n        let e = Enforcer::new(m, adapter);\n        assert!(e.enforce(vec![\"data1\", \"read\"]));\n        assert!(!e.enforce(vec![\"data1\", \"write\"]));\n        assert!(!e.enforce(vec![\"data2\", \"read\"]));\n        assert!(e.enforce(vec![\"data2\", \"write\"]));\n"]], "pred": {"ppl": 2.2626872062683105, "ppl_lower": 2.484943151473999, "ppl/lowercase_ppl": -1.1147465390598497, "ppl/zlib": 0.004022429242713981, "Min_5.0% Prob": 7.746642172336578, "Min_10.0% Prob": 5.743434906005859, "Min_20.0% Prob": 3.628028314560652, "Min_30.0% Prob": 2.6228794058163962, "Min_40.0% Prob": 2.033914743224159, "Min_50.0% Prob": 1.6292598208895437, "Min_60.0% Prob": 1.3629117470532273}}
{"hexsha": "636ed3f6c8e51d96ce3f60346b3eed1fd0474a66", "ext": "rs", "lang": "Rust", "content": "fn different_values() {\n        let zero: Result<Enum, _> = 0u8.try_into();\n        assert_eq!(zero, Ok(Enum::Zero));\n\n        let one: Result<Enum, _> = 1u8.try_into();\n        assert_eq!(one, Ok(Enum::One));\n\n        let two: Result<Enum, _> = 2u8.try_into();\n        assert_eq!(two, Ok(Enum::Two));\n\n        let three: Result<Enum, _> = 3u8.try_into();\n        assert_eq!(\n            three.unwrap_err().to_string(),\n            \"No discriminant in enum `Enum` matches the value `3`\",\n        );\n\n        let four: Result<Enum, _> = 4u8.try_into();\n        assert_eq!(four, Ok(Enum::Four));\n\n        let five: Result<Enum, _> = 5u8.try_into();\n        assert_eq!(five, Ok(Enum::Five));\n\n        let six: Result<Enum, _> = 6u8.try_into();\n        assert_eq!(six, Ok(Enum::Six));\n\n        let seven: Result<Enum, _> = 7u8.try_into();\n        assert_eq!(seven, Ok(Enum::Seven));\n    }", "item_id": 4, "repo": "ritikmishra/babycat", "file": "vendor/num_enum-0.5.1/tests/try_from_primitive.rs", "last_update_at": "2021-07-11T09:06:13+00:00", "question_id": "636ed3f6c8e51d96ce3f60346b3eed1fd0474a66_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn different_values() {\n        let zero: Result<Enum, _> = 0u8.try_into();\n        assert_eq!(zero, Ok(Enum::Zero));\n        let one: Result<Enum, _> = 1u8.try_into();\n        assert_eq!(one, Ok(Enum::One));\n        let two: Result<Enum, _> = 2u8.try_into();\n        assert_eq!(two, Ok(Enum::Two));\n        let three: Result<Enum, _> = 3u8.try_into();\n        assert_eq!(\n            three.unwrap_err().to_string(),\n            \"No discriminant in enum `Enum` matches the value `3`\",\n        );\n        let four: Result<Enum, _> = 4u8.try_into();\n        assert_eq!(four, Ok(Enum::Four));\n        let five: Result<Enum, _> = 5u8.try_into();\n        assert_eq!(five, Ok(Enum::Five));\n        let six: Result<Enum, _> = 6u8.try_into();\n        assert_eq!(six, Ok(Enum::Six));\n        let seven: Result<Enum, _> = 7u8.try_into();\n        assert_eq!(seven, Ok(Enum::Seven));\n"]], "pred": {"ppl": 1.4418368339538574, "ppl_lower": 1.5328378677368164, "ppl/lowercase_ppl": -1.1672587112516983, "ppl/zlib": 0.001288443238952956, "Min_5.0% Prob": 5.481451258063316, "Min_10.0% Prob": 3.3843316342681646, "Min_20.0% Prob": 1.8121478796005248, "Min_30.0% Prob": 1.215184842369386, "Min_40.0% Prob": 0.9186593290275106, "Min_50.0% Prob": 0.7335111825238411, "Min_60.0% Prob": 0.6103341800370966}}
{"hexsha": "f1f50c44e1a3b9cb77c15e35f587e14ce4738774", "ext": "rs", "lang": "Rust", "content": "pub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -> Result<Response, ContractError> {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    if msg.unit_price == Uint128::new(0) {\n        return Err(ContractError::InvalidUnitPrice {});\n    }\n\n    if msg.max_tokens == 0 {\n        return Err(ContractError::InvalidMaxTokens {});\n    }\n\n    let config = Config {\n        cw721_address: None,\n        cw20_address: msg.cw20_address,\n        unit_price: msg.unit_price,\n        max_tokens: msg.max_tokens,\n        owner: info.sender,\n        name: msg.name.clone(),\n        symbol: msg.symbol.clone(),\n        token_uri: msg.token_uri.clone(),\n        extension: msg.extension.clone(),\n        unused_token_id: 0,\n    };\n\n    CONFIG.save(deps.storage, &config)?;\n\n    let sub_msg: Vec<SubMsg> = vec![SubMsg {\n        msg: WasmMsg::Instantiate {\n            code_id: msg.token_code_id,\n            msg: to_binary(&Cw721InstantiateMsg {\n                name: msg.name.clone(),\n                symbol: msg.symbol,\n                minter: env.contract.address.to_string(),\n            })?,\n            funds: vec![],\n            admin: None,\n            label: String::from(\"Instantiate Limited Edition NFT\"),\n        }\n        .into(),\n        id: INSTANTIATE_TOKEN_REPLY_ID,\n        gas_limit: None,\n        reply_on: ReplyOn::Success,\n    }];\n\n    Ok(Response::new().add_submessages(sub_msg))\n}", "item_id": 0, "repo": "verminator23/cw-editions", "file": "src/contract.rs", "last_update_at": "2021-12-25T05:59:19+00:00", "question_id": "f1f50c44e1a3b9cb77c15e35f587e14ce4738774_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -> Result<Response, ContractError> {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n    if msg.unit_price == Uint128::new(0) {\n        return Err(ContractError::InvalidUnitPrice {});\n    }\n    if msg.max_tokens == 0 {\n        return Err(ContractError::InvalidMaxTokens {});\n    }\n    let config = Config {\n        cw721_address: None,\n        cw20_address: msg.cw20_address,\n        unit_price: msg.unit_price,\n        max_tokens: msg.max_tokens,\n        owner: info.sender,\n        name: msg.name.clone(),\n        symbol: msg.symbol.clone(),\n        token_uri: msg.token_uri.clone(),\n        extension: msg.extension.clone(),\n        unused_token_id: 0,\n    };\n    CONFIG.save(deps.storage, &config)?;\n    let sub_msg: Vec<SubMsg> = vec![SubMsg {\n        msg: WasmMsg::Instantiate {\n            code_id: msg.token_code_id,\n            msg: to_binary(&Cw721InstantiateMsg {\n                name: msg.name.clone(),\n                symbol: msg.symbol,\n                minter: env.contract.address.to_string(),\n            })?,\n            funds: vec![],\n            admin: None,\n            label: String::from(\"Instantiate Limited Edition NFT\"),\n        }\n        .into(),\n        id: INSTANTIATE_TOKEN_REPLY_ID,\n        gas_limit: None,\n        reply_on: ReplyOn::Success,\n    }];\n    Ok(Response::new().add_submessages(sub_msg))\n"]], "pred": {"ppl": 1.6336396932601929, "ppl_lower": 2.2686727046966553, "ppl/lowercase_ppl": -1.6690657705431304, "ppl/zlib": 0.0007633133221805335, "Min_5.0% Prob": 5.751697460810344, "Min_10.0% Prob": 3.9181025344498304, "Min_20.0% Prob": 2.3474847987444716, "Min_30.0% Prob": 1.6167033299203688, "Min_40.0% Prob": 1.2274181467546808, "Min_50.0% Prob": 0.9824061843701789, "Min_60.0% Prob": 0.8181784702011777}}
{"hexsha": "7d9d79394ea454de3a509f3f9264551996d96f98", "ext": "rs", "lang": "Rust", "content": "fn test_8xy2() {\n        let mut chip = Chip8::new(&sdl2::init().unwrap());\n\n        chip.v[1] = 0xFF;\n        chip.v[2] = 0x0F;\n        chip.run_op_code(0x8122);\n        assert_eq!(chip.v[1], 0x0F);\n        assert_eq!(chip.pc, 0x202);\n    }", "item_id": 11, "repo": "scnplt/chip8-emu", "file": "src/chip8.rs", "last_update_at": "2021-12-14T17:19:58+00:00", "question_id": "7d9d79394ea454de3a509f3f9264551996d96f98_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_8xy2() {\n        let mut chip = Chip8::new(&sdl2::init().unwrap());\n        chip.v[1] = 0xFF;\n        chip.v[2] = 0x0F;\n        chip.run_op_code(0x8122);\n        assert_eq!(chip.v[1], 0x0F);\n        assert_eq!(chip.pc, 0x202);\n"]], "pred": {"ppl": 2.377358913421631, "ppl_lower": 2.546497106552124, "ppl/lowercase_ppl": -1.0793641338089857, "ppl/zlib": 0.00581201457226288, "Min_5.0% Prob": 8.646274280548095, "Min_10.0% Prob": 6.085853056474165, "Min_20.0% Prob": 3.749267055229707, "Min_30.0% Prob": 2.665374945191776, "Min_40.0% Prob": 2.121966990497377, "Min_50.0% Prob": 1.7116878850941073, "Min_60.0% Prob": 1.4442398210658747}}
{"hexsha": "0b8f38ea404908995727b6433d03b872e26a724a", "ext": "rs", "lang": "Rust", "content": "fn it_works_with_trinary() {\n    let base3 = BaseCustom::<u8>::new(b\"ABC\");\n    assert_eq!(base3.decimal(b\"ABC\"), 5);\n    assert_eq!(base3.gen(123), b\"BBBCA\");\n  }", "item_id": 3, "repo": "jdv9so/base_custom", "file": "tests/lib.rs", "last_update_at": "2021-12-28T22:05:21+00:00", "question_id": "0b8f38ea404908995727b6433d03b872e26a724a_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn it_works_with_trinary() {\n    let base3 = BaseCustom::<u8>::new(b\"ABC\");\n    assert_eq!(base3.decimal(b\"ABC\"), 5);\n    assert_eq!(base3.gen(123), b\"BBBCA\");\n"]], "pred": {"ppl": 7.768576622009277, "ppl_lower": 8.680697441101074, "ppl/lowercase_ppl": -1.0541513210766085, "ppl/zlib": 0.015892146966417206, "Min_5.0% Prob": 10.741244951883951, "Min_10.0% Prob": 8.97208867754255, "Min_20.0% Prob": 7.128936529159546, "Min_30.0% Prob": 5.785709540049235, "Min_40.0% Prob": 4.6747317478574555, "Min_50.0% Prob": 3.9541995343234806, "Min_60.0% Prob": 3.401422619126564}}
{"hexsha": "7fd46080a235e03361e873a3167fb0002f882258", "ext": "rs", "lang": "Rust", "content": "pub unsafe fn create_vertex_array_object() -> GLuint {\n    let vertices: [f32; 180] = [\n         -0.5, -0.5, -0.5,  0.0, 0.0,\n          0.5, -0.5, -0.5,  1.0, 0.0,\n          0.5,  0.5, -0.5,  1.0, 1.0,\n          0.5,  0.5, -0.5,  1.0, 1.0,\n         -0.5,  0.5, -0.5,  0.0, 1.0,\n         -0.5, -0.5, -0.5,  0.0, 0.0,\n\n         -0.5, -0.5,  0.5,  0.0, 0.0,\n          0.5, -0.5,  0.5,  1.0, 0.0,\n          0.5,  0.5,  0.5,  1.0, 1.0,\n          0.5,  0.5,  0.5,  1.0, 1.0,\n         -0.5,  0.5,  0.5,  0.0, 1.0,\n         -0.5, -0.5,  0.5,  0.0, 0.0,\n\n         -0.5,  0.5,  0.5,  1.0, 0.0,\n         -0.5,  0.5, -0.5,  1.0, 1.0,\n         -0.5, -0.5, -0.5,  0.0, 1.0,\n         -0.5, -0.5, -0.5,  0.0, 1.0,\n         -0.5, -0.5,  0.5,  0.0, 0.0,\n         -0.5,  0.5,  0.5,  1.0, 0.0,\n\n          0.5,  0.5,  0.5,  1.0, 0.0,\n          0.5,  0.5, -0.5,  1.0, 1.0,\n          0.5, -0.5, -0.5,  0.0, 1.0,\n          0.5, -0.5, -0.5,  0.0, 1.0,\n          0.5, -0.5,  0.5,  0.0, 0.0,\n          0.5,  0.5,  0.5,  1.0, 0.0,\n\n         -0.5, -0.5, -0.5,  0.0, 1.0,\n          0.5, -0.5, -0.5,  1.0, 1.0,\n          0.5, -0.5,  0.5,  1.0, 0.0,\n          0.5, -0.5,  0.5,  1.0, 0.0,\n         -0.5, -0.5,  0.5,  0.0, 0.0,\n         -0.5, -0.5, -0.5,  0.0, 1.0,\n\n         -0.5,  0.5, -0.5,  0.0, 1.0,\n          0.5,  0.5, -0.5,  1.0, 1.0,\n          0.5,  0.5,  0.5,  1.0, 0.0,\n          0.5,  0.5,  0.5,  1.0, 0.0,\n         -0.5,  0.5,  0.5,  0.0, 0.0,\n         -0.5,  0.5, -0.5,  0.0, 1.0\n    ];\n\n    let (mut vbo, mut vao) = (0, 0);\n    gl::GenVertexArrays(1, &mut vao);\n    gl::GenBuffers(1, &mut vbo);\n\n    gl::BindVertexArray(vao);\n\n    gl::BindBuffer(gl::ARRAY_BUFFER, vbo);\n    gl::BufferData(\n        gl::ARRAY_BUFFER,\n        (vertices.len() * mem::size_of::<GLfloat>()) as GLsizeiptr,\n        &vertices[0] as *const f32 as *const c_void,\n        gl::STATIC_DRAW,\n    );\n\n    let stride = 5 * mem::size_of::<GLfloat>() as GLsizei;\n    // position attribute\n    gl::VertexAttribPointer(0, 3, gl::FLOAT, gl::FALSE, stride, ptr::null());\n    gl::EnableVertexAttribArray(0);\n    // texture coord attribute\n    gl::VertexAttribPointer(\n        1,\n        2,\n        gl::FLOAT,\n        gl::FALSE,\n        stride,\n        (3 * mem::size_of::<GLfloat>()) as *const c_void,\n    );\n    gl::EnableVertexAttribArray(1);\n\n    return vao;\n}", "item_id": 0, "repo": "weclaw1/learn_opengl", "file": "src/coordinate.rs", "last_update_at": "2021-05-30T22:27:21+00:00", "question_id": "7fd46080a235e03361e873a3167fb0002f882258_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe fn create_vertex_array_object() -> GLuint {\n    let vertices: [f32; 180] = [\n         -0.5, -0.5, -0.5,  0.0, 0.0,\n          0.5, -0.5, -0.5,  1.0, 0.0,\n          0.5,  0.5, -0.5,  1.0, 1.0,\n          0.5,  0.5, -0.5,  1.0, 1.0,\n         -0.5,  0.5, -0.5,  0.0, 1.0,\n         -0.5, -0.5, -0.5,  0.0, 0.0,\n         -0.5, -0.5,  0.5,  0.0, 0.0,\n          0.5, -0.5,  0.5,  1.0, 0.0,\n          0.5,  0.5,  0.5,  1.0, 1.0,\n          0.5,  0.5,  0.5,  1.0, 1.0,\n         -0.5,  0.5,  0.5,  0.0, 1.0,\n         -0.5, -0.5,  0.5,  0.0, 0.0,\n         -0.5,  0.5,  0.5,  1.0, 0.0,\n         -0.5,  0.5, -0.5,  1.0, 1.0,\n         -0.5, -0.5, -0.5,  0.0, 1.0,\n         -0.5, -0.5, -0.5,  0.0, 1.0,\n         -0.5, -0.5,  0.5,  0.0, 0.0,\n         -0.5,  0.5,  0.5,  1.0, 0.0,\n          0.5,  0.5,  0.5,  1.0, 0.0,\n          0.5,  0.5, -0.5,  1.0, 1.0,\n          0.5, -0.5, -0.5,  0.0, 1.0,\n          0.5, -0.5, -0.5,  0.0, 1.0,\n          0.5, -0.5,  0.5,  0.0, 0.0,\n          0.5,  0.5,  0.5,  1.0, 0.0,\n         -0.5, -0.5, -0.5,  0.0, 1.0,\n          0.5, -0.5, -0.5,  1.0, 1.0,\n          0.5, -0.5,  0.5,  1.0, 0.0,\n          0.5, -0.5,  0.5,  1.0, 0.0,\n         -0.5, -0.5,  0.5,  0.0, 0.0,\n         -0.5, -0.5, -0.5,  0.0, 1.0,\n         -0.5,  0.5, -0.5,  0.0, 1.0,\n          0.5,  0.5, -0.5,  1.0, 1.0,\n          0.5,  0.5,  0.5,  1.0, 0.0,\n          0.5,  0.5,  0.5,  1.0, 0.0,\n         -0.5,  0.5,  0.5,  0.0, 0.0,\n         -0.5,  0.5, -0.5,  0.0, 1.0\n    ];\n    let (mut vbo, mut vao) = (0, 0);\n    gl::GenVertexArrays(1, &mut vao);\n    gl::GenBuffers(1, &mut vbo);\n    gl::BindVertexArray(vao);\n    gl::BindBuffer(gl::ARRAY_BUFFER, vbo);\n    gl::BufferData(\n        gl::ARRAY_BUFFER,\n        (vertices.len() * mem::size_of::<GLfloat>()) as GLsizeiptr,\n        &vertices[0] as *const f32 as *const c_void,\n        gl::STATIC_DRAW,\n    );\n    let stride = 5 * mem::size_of::<GLfloat>() as GLsizei;\n    // position attribute\n    gl::VertexAttribPointer(0, 3, gl::FLOAT, gl::FALSE, stride, ptr::null());\n    gl::EnableVertexAttribArray(0);\n    // texture coord attribute\n    gl::VertexAttribPointer(\n        1,\n        2,\n        gl::FLOAT,\n        gl::FALSE,\n        stride,\n        (3 * mem::size_of::<GLfloat>()) as *const c_void,\n    );\n    gl::EnableVertexAttribArray(1);\n    return vao;\n"]], "pred": {"ppl": 1.094675064086914, "ppl_lower": 1.1152667999267578, "ppl/lowercase_ppl": -1.2060201681699094, "ppl/zlib": 0.00016537033657186684, "Min_5.0% Prob": 1.7806569364141016, "Min_10.0% Prob": 0.9065227442302322, "Min_20.0% Prob": 0.45358645104163003, "Min_30.0% Prob": 0.3024052495257802, "Min_40.0% Prob": 0.2262527275533812, "Min_50.0% Prob": 0.18109171173640934, "Min_60.0% Prob": 0.1509593013645941}}
{"hexsha": "d5f7914aa6c2ec9a0fe708bf4d43d61423d24ebe", "ext": "rs", "lang": "Rust", "content": "pub async fn location_update_address_by_id_json(\n     path: web::Path<i32>\n   , data: web::Json<Option<String>>\n   , pool: web::Data<DbPool>\n  ) -> Result<HttpResponse,actix_web::Error> {\n\n    let conn = pool.get().expect(\"couldn't get db connection from pool\");\n\n    let id = *path;\n    // use web::block to offload blocking Diesel code without blocking server thread\n    web::block(move || location_update_address_by_id(data.as_deref(), id, &conn))\n        .await\n        .map_err(|e| {\n            eprintln!(\"{}\", e);\n            HttpResponse::InternalServerError().finish()\n        })?;\n\n    location_address_by_id_json(path,pool).await\n}", "item_id": 15, "repo": "mephistopheles-8/basicweb-rust-experiments", "file": "app-biz/src/routes/location.rs", "last_update_at": "2021-05-07T01:34:08+00:00", "question_id": "d5f7914aa6c2ec9a0fe708bf4d43d61423d24ebe_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn location_update_address_by_id_json(\n     path: web::Path<i32>\n   , data: web::Json<Option<String>>\n   , pool: web::Data<DbPool>\n  ) -> Result<HttpResponse,actix_web::Error> {\n    let conn = pool.get().expect(\"couldn't get db connection from pool\");\n    let id = *path;\n    // use web::block to offload blocking Diesel code without blocking server thread\n    web::block(move || location_update_address_by_id(data.as_deref(), id, &conn))\n        .await\n        .map_err(|e| {\n            eprintln!(\"{}\", e);\n            HttpResponse::InternalServerError().finish()\n        })?;\n    location_address_by_id_json(path,pool).await\n"]], "pred": {"ppl": 2.462212324142456, "ppl_lower": 4.107846736907959, "ppl/lowercase_ppl": -1.568040494628518, "ppl/zlib": 0.0024418977359255806, "Min_5.0% Prob": 7.809373140335083, "Min_10.0% Prob": 5.761892962455749, "Min_20.0% Prob": 3.9259533242481512, "Min_30.0% Prob": 2.8789422281326784, "Min_40.0% Prob": 2.2234056258057975, "Min_50.0% Prob": 1.7960935070251043, "Min_60.0% Prob": 1.5026806285083294}}
{"hexsha": "b3be688e3f9079e7e5780ba86fb433a6b2eb77e5", "ext": "rs", "lang": "Rust", "content": "fn brow_cap_remote() {\n        let mut ch_op = ChromeOptions::new();\n        ch_op.add_args(vec![\"--headless\",\"--window-size=500,1000\"]);\n        ch_op.add_mobile_emulation(MobileDevice::standard_device(\"Nexus 6\"));\n        let mut c = Capabilities::new(BrowserName::Chrome, \"linux\");\n        c.set_chrome_options(ch_op);\n        let mut br = Browser::start_remote_session_with_capabilities(c,\"192.168.1.67\",\"4444\").unwrap();\n        br.open(\"https://vk.com\").unwrap();\n        br.open(\"https://github.com\").unwrap();\n        let link = br.get_link().unwrap();\n        assert!(link.contains(\"hub\"));\n        br.close_browser().unwrap();\n    }", "item_id": 71, "repo": "SergeyBibikov/rust-selenium", "file": "src/browser.rs", "last_update_at": "2021-02-16T19:03:23+00:00", "question_id": "b3be688e3f9079e7e5780ba86fb433a6b2eb77e5_71", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn brow_cap_remote() {\n        let mut ch_op = ChromeOptions::new();\n        ch_op.add_args(vec![\"--headless\",\"--window-size=500,1000\"]);\n        ch_op.add_mobile_emulation(MobileDevice::standard_device(\"Nexus 6\"));\n        let mut c = Capabilities::new(BrowserName::Chrome, \"linux\");\n        c.set_chrome_options(ch_op);\n        let mut br = Browser::start_remote_session_with_capabilities(c,\"192.168.1.67\",\"4444\").unwrap();\n        br.open(\"https://vk.com\").unwrap();\n        br.open(\"https://github.com\").unwrap();\n        let link = br.get_link().unwrap();\n        assert!(link.contains(\"hub\"));\n        br.close_browser().unwrap();\n"]], "pred": {"ppl": 3.7417385578155518, "ppl_lower": 4.0227952003479, "ppl/lowercase_ppl": -1.0548873527758305, "ppl/zlib": 0.003915579698651955, "Min_5.0% Prob": 8.844248034737326, "Min_10.0% Prob": 6.831946676427668, "Min_20.0% Prob": 4.861221215941689, "Min_30.0% Prob": 3.82588831764279, "Min_40.0% Prob": 3.099390283226967, "Min_50.0% Prob": 2.5679178218949925, "Min_60.0% Prob": 2.1786959136300013}}
{"hexsha": "020acb8f778b98099a1f61c29d6c6b844e020097", "ext": "rs", "lang": "Rust", "content": "fn find_best_stream_config(device: &cpal::Device) -> Result<cpal::SupportedStreamConfig, Error> {\n    let default_config = device.default_output_config()\n        .context(\"failed to retrieve default audio stream  config\")?;\n\n    // If the default config has all properties we certainly want, we\n    // immediately take it.\n    if default_config.channels() == 2 && default_config.sample_format() == SampleFormat::F32 {\n        return Ok(default_config);\n    }\n\n    // Otherwise, we have to search through all other configs to find one.\n    let mut supported_configs = device.supported_output_configs()\n        .context(\"could not retrieve supported configs from audio device\")?\n        .filter(|config| config.channels() == 2)\n        .collect::<Vec<_>>();\n\n    if supported_configs.is_empty() {\n        bail!(\"your default audio device does not support stereo\");\n    }\n\n    debug!(\"Supported stereo audio config ranges: {:#?}\", supported_configs);\n\n    // Sort by sample format as we prefer `f32` samples.\n    supported_configs.sort_by_key(|config| config.sample_format().sample_size());\n    let candidate = supported_configs.pop().unwrap();\n\n    let default_sample_rate = default_config.sample_rate();\n    let supported_sample_rates = candidate.min_sample_rate()..candidate.max_sample_rate();\n\n    for sample_rate in &[default_sample_rate, SampleRate(44100), SampleRate(48000)] {\n        if supported_sample_rates.contains(sample_rate) {\n            return Ok(candidate.with_sample_rate(default_sample_rate));\n        }\n    }\n\n    Err(format_err!(\"could not find a stereo audio stream config with an expected sample rate\"))\n}", "item_id": 0, "repo": "LukasKalbertodt/mahboi", "file": "desktop/src/env.rs", "last_update_at": "2021-12-22T04:24:57+00:00", "question_id": "020acb8f778b98099a1f61c29d6c6b844e020097_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn find_best_stream_config(device: &cpal::Device) -> Result<cpal::SupportedStreamConfig, Error> {\n    let default_config = device.default_output_config()\n        .context(\"failed to retrieve default audio stream  config\")?;\n    // If the default config has all properties we certainly want, we\n    // immediately take it.\n    if default_config.channels() == 2 && default_config.sample_format() == SampleFormat::F32 {\n        return Ok(default_config);\n    }\n    // Otherwise, we have to search through all other configs to find one.\n    let mut supported_configs = device.supported_output_configs()\n        .context(\"could not retrieve supported configs from audio device\")?\n        .filter(|config| config.channels() == 2)\n        .collect::<Vec<_>>();\n    if supported_configs.is_empty() {\n        bail!(\"your default audio device does not support stereo\");\n    }\n    debug!(\"Supported stereo audio config ranges: {:#?}\", supported_configs);\n    // Sort by sample format as we prefer `f32` samples.\n    supported_configs.sort_by_key(|config| config.sample_format().sample_size());\n    let candidate = supported_configs.pop().unwrap();\n    let default_sample_rate = default_config.sample_rate();\n    let supported_sample_rates = candidate.min_sample_rate()..candidate.max_sample_rate();\n    for sample_rate in &[default_sample_rate, SampleRate(44100), SampleRate(48000)] {\n        if supported_sample_rates.contains(sample_rate) {\n            return Ok(candidate.with_sample_rate(default_sample_rate));\n        }\n    }\n    Err(format_err!(\"could not find a stereo audio stream config with an expected sample rate\"))\n"]], "pred": {"ppl": 2.2421979904174805, "ppl_lower": 2.5914793014526367, "ppl/lowercase_ppl": -1.179294138628509, "ppl/zlib": 0.0011891850228014013, "Min_5.0% Prob": 6.744171059649924, "Min_10.0% Prob": 5.172140684533627, "Min_20.0% Prob": 3.4780565639759633, "Min_30.0% Prob": 2.5645234187444053, "Min_40.0% Prob": 1.9848253755342393, "Min_50.0% Prob": 1.611036358606386, "Min_60.0% Prob": 1.348296931595953}}
{"hexsha": "94f97bf6e490a678dfe1faa198de6c5a7be2c099", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let att = DataType::INT;\n    let att2 = DataType::INT;\n    assert_eq!(att, att2);\n    print!(\"A\");\n    print!(\"B\");\n    println!(\"C\");\n    print!(\"D\");\n}", "item_id": 0, "repo": "InfernapeXavier/RustyBase", "file": "src/scratch/comp.rs", "last_update_at": "2021-01-15T18:26:32+00:00", "question_id": "94f97bf6e490a678dfe1faa198de6c5a7be2c099_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let att = DataType::INT;\n    let att2 = DataType::INT;\n    assert_eq!(att, att2);\n    print!(\"A\");\n    print!(\"B\");\n    println!(\"C\");\n    print!(\"D\");\n"]], "pred": {"ppl": 3.3966498374938965, "ppl_lower": 3.884096145629883, "ppl/lowercase_ppl": -1.1096678447642554, "ppl/zlib": 0.012737391707709246, "Min_5.0% Prob": 9.5441042582194, "Min_10.0% Prob": 7.297774155934651, "Min_20.0% Prob": 4.793894549210866, "Min_30.0% Prob": 3.6557735800743103, "Min_40.0% Prob": 2.950914204120636, "Min_50.0% Prob": 2.3776722555198977, "Min_60.0% Prob": 2.0258183664566762}}
{"hexsha": "ad67a6ebc1a1f64a2205137dae49b6d6ed24b739", "ext": "rs", "lang": "Rust", "content": "fn basic2() {\n        // data from yorgos's e-mail\n        let subject = Subject{\n            name: String::from(\"subj01\"),\n            prices: Matrix::from_slice(3, 3, &[\n                2.0, 2.0, 3.0,\n                5.0, 5.0, 1.0,\n                3.0, 4.0, 2.0,\n            ]),\n            amounts: Matrix::from_slice(3, 3, &[\n                10.0, 20.0,  5.0,\n                 7.0,  2.0, 10.0,\n                 8.0, 12.0,  7.0,\n            ]),\n        };\n\n        let resp = super::run(DummyLogger, subject).unwrap();\n\n        assert_eq!(resp.name, \"subj01\");\n        assert_eq!(resp.violations, &[\n        ]);\n        assert_eq!(resp.warp_strict, 0);\n        assert_eq!(resp.warp_nonstrict, 0);\n        assert_eq!(resp.hm_garp.lower, 0);\n        assert_eq!(resp.hm_garp.upper, 0);\n        assert_eq!(resp.hm_sarp.lower, 0);\n        assert_eq!(resp.hm_sarp.upper, 0);\n        assert_eq!(resp.hm_warp_strict.lower, 0);\n        assert_eq!(resp.hm_warp_strict.upper, 0);\n        assert_eq!(resp.hm_warp_nonstrict.lower, 0);\n        assert_eq!(resp.hm_warp_nonstrict.upper, 0);\n    }", "item_id": 6, "repo": "vishalbelsare/prest", "file": "core/src/budgetary/consistency.rs", "last_update_at": "2021-12-07T06:49:43+00:00", "question_id": "ad67a6ebc1a1f64a2205137dae49b6d6ed24b739_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn basic2() {\n        // data from yorgos's e-mail\n        let subject = Subject{\n            name: String::from(\"subj01\"),\n            prices: Matrix::from_slice(3, 3, &[\n                2.0, 2.0, 3.0,\n                5.0, 5.0, 1.0,\n                3.0, 4.0, 2.0,\n            ]),\n            amounts: Matrix::from_slice(3, 3, &[\n                10.0, 20.0,  5.0,\n                 7.0,  2.0, 10.0,\n                 8.0, 12.0,  7.0,\n            ]),\n        };\n        let resp = super::run(DummyLogger, subject).unwrap();\n        assert_eq!(resp.name, \"subj01\");\n        assert_eq!(resp.violations, &[\n        ]);\n        assert_eq!(resp.warp_strict, 0);\n        assert_eq!(resp.warp_nonstrict, 0);\n        assert_eq!(resp.hm_garp.lower, 0);\n        assert_eq!(resp.hm_garp.upper, 0);\n        assert_eq!(resp.hm_sarp.lower, 0);\n        assert_eq!(resp.hm_sarp.upper, 0);\n        assert_eq!(resp.hm_warp_strict.lower, 0);\n        assert_eq!(resp.hm_warp_strict.upper, 0);\n        assert_eq!(resp.hm_warp_nonstrict.lower, 0);\n        assert_eq!(resp.hm_warp_nonstrict.upper, 0);\n"]], "pred": {"ppl": 2.3909389972686768, "ppl_lower": 2.5045437812805176, "ppl/lowercase_ppl": -1.0532535921613901, "ppl/zlib": 0.0026575798008245254, "Min_5.0% Prob": 8.361491884504046, "Min_10.0% Prob": 6.244391297185143, "Min_20.0% Prob": 3.966795364330555, "Min_30.0% Prob": 2.8496488206661663, "Min_40.0% Prob": 2.1650520609798787, "Min_50.0% Prob": 1.7437535599646619, "Min_60.0% Prob": 1.4516745633481363}}
{"hexsha": "bd3ae9ec775032fdf42a7d05096c325724816f72", "ext": "rs", "lang": "Rust", "content": "fn build_guardian_set(length: usize) -> GuardianSetInfo {\n        let mut addresses: Vec<GuardianAddress> = Vec::with_capacity(length);\n        for _ in 0..length {\n            addresses.push(GuardianAddress {\n                bytes: vec![].into(),\n            });\n        }\n\n        GuardianSetInfo {\n            addresses,\n            expiration_time: 0,\n        }\n    }", "item_id": 0, "repo": "dr497/wormhole", "file": "terra/contracts/wormhole/src/state.rs", "last_update_at": "2021-03-23T10:41:38+00:00", "question_id": "bd3ae9ec775032fdf42a7d05096c325724816f72_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn build_guardian_set(length: usize) -> GuardianSetInfo {\n        let mut addresses: Vec<GuardianAddress> = Vec::with_capacity(length);\n        for _ in 0..length {\n            addresses.push(GuardianAddress {\n                bytes: vec![].into(),\n            });\n        }\n        GuardianSetInfo {\n            addresses,\n            expiration_time: 0,\n        }\n"]], "pred": {"ppl": 2.3392372131347656, "ppl_lower": 3.295715570449829, "ppl/lowercase_ppl": -1.403375347610373, "ppl/zlib": 0.0043805407161578765, "Min_5.0% Prob": 7.904298973083496, "Min_10.0% Prob": 6.172463917732239, "Min_20.0% Prob": 3.942643427848816, "Min_30.0% Prob": 2.7521191633516744, "Min_40.0% Prob": 2.130193597296389, "Min_50.0% Prob": 1.6958034764258907, "Min_60.0% Prob": 1.4246524379949175}}
{"hexsha": "030b292def66396e54e16589379f12b870634539", "ext": "rs", "lang": "Rust", "content": "fn foo(c: foo::Context) {\n        static mut STATE: bool = false;\n\n        gpio::set_out_xor(if *STATE { gpio::RED } else { 0 });\n        *STATE = !*STATE;\n\n        c.schedule.foo(c.scheduled + Duration::from_secs(1)).ok();\n    }", "item_id": 1, "repo": "japaric/hifive1", "file": "rtfm/examples/periodic.rs", "last_update_at": "2021-02-10T09:04:27+00:00", "question_id": "030b292def66396e54e16589379f12b870634539_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn foo(c: foo::Context) {\n        static mut STATE: bool = false;\n        gpio::set_out_xor(if *STATE { gpio::RED } else { 0 });\n        *STATE = !*STATE;\n        c.schedule.foo(c.scheduled + Duration::from_secs(1)).ok();\n"]], "pred": {"ppl": 4.34551477432251, "ppl_lower": 4.880186080932617, "ppl/lowercase_ppl": -1.0789841606814403, "ppl/zlib": 0.009182151417517055, "Min_5.0% Prob": 9.164997339248657, "Min_10.0% Prob": 7.733883857727051, "Min_20.0% Prob": 5.675703062730677, "Min_30.0% Prob": 4.299447898681347, "Min_40.0% Prob": 3.505882862736197, "Min_50.0% Prob": 2.8927436027415965, "Min_60.0% Prob": 2.4362321561918807}}
{"hexsha": "c6de237a8345276d108f0e535b47e3f9844c6e4c", "ext": "rs", "lang": "Rust", "content": "async fn to_file_stream(\n    mut stream: impl Stream<Item = IoResult> + Unpin,\n    logger: slog::Logger,\n) -> Result<impl Stream<Item = IoResult>> {\n    let path = format!(\n        \"/mnt/cache/{}\",\n        FILE_ID.fetch_add(1, std::sync::atomic::Ordering::SeqCst)\n    );\n    let mut file = FileWrapper::open(&path).await?;\n    while let Some(v) = stream.next().await {\n        let v = v?;\n        file.as_mut().write_all(&v).await?;\n    }\n    Ok(file.into_bytes_stream(logger).await?)\n}", "item_id": 0, "repo": "sjtug/mirror-intel", "file": "src/artifacts.rs", "last_update_at": "2021-12-04T02:25:38+00:00", "question_id": "c6de237a8345276d108f0e535b47e3f9844c6e4c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn to_file_stream(\n    mut stream: impl Stream<Item = IoResult> + Unpin,\n    logger: slog::Logger,\n) -> Result<impl Stream<Item = IoResult>> {\n    let path = format!(\n        \"/mnt/cache/{}\",\n        FILE_ID.fetch_add(1, std::sync::atomic::Ordering::SeqCst)\n    );\n    let mut file = FileWrapper::open(&path).await?;\n    while let Some(v) = stream.next().await {\n        let v = v?;\n        file.as_mut().write_all(&v).await?;\n    }\n    Ok(file.into_bytes_stream(logger).await?)\n"]], "pred": {"ppl": 2.762234926223755, "ppl_lower": 4.206666946411133, "ppl/lowercase_ppl": -1.4139900814246515, "ppl/zlib": 0.003398127451276987, "Min_5.0% Prob": 7.960369646549225, "Min_10.0% Prob": 6.1474979204290054, "Min_20.0% Prob": 4.17197570029427, "Min_30.0% Prob": 3.15137341560102, "Min_40.0% Prob": 2.4841543571913944, "Min_50.0% Prob": 2.0207490344257915, "Min_60.0% Prob": 1.6902179775540442}}
{"hexsha": "53146e12435182e27ab84d64a0dd96f326f65e3a", "ext": "rs", "lang": "Rust", "content": "fn integration_test_opt_in() {\n        // PRECONDITIONS:\n        //   - The BTC Parachain status in the Security component MUST be `RUNNING:0`.\n        //   - A Vault with id `vaultId` MUST be registered.\n        //   - The Vault MUST NOT be opted in.\n        // POSTCONDITION: The Vault MUST be allowed to receive nominated collateral.\n        test_with(|_| {\n            assert_noop!(\n                Call::Nomination(NominationCall::set_nomination_enabled(true)).dispatch(origin_of(account_of(CAROL))),\n                DispatchError::BadOrigin\n            );\n            let mut nomination_enabled = true;\n            assert_ok!(\n                Call::Nomination(NominationCall::set_nomination_enabled(nomination_enabled))\n                    .dispatch(<Runtime as frame_system::Config>::Origin::root())\n            );\n            assert_eq!(NominationPallet::is_nomination_enabled(), nomination_enabled);\n            nomination_enabled = false;\n            assert_ok!(\n                Call::Nomination(NominationCall::set_nomination_enabled(nomination_enabled))\n                    .dispatch(<Runtime as frame_system::Config>::Origin::root())\n            );\n            assert_eq!(NominationPallet::is_nomination_enabled(), nomination_enabled);\n        })\n    }", "item_id": 3, "repo": "Thang83473361/interbtc", "file": "standalone/runtime/tests/test_nomination.rs", "last_update_at": "2021-09-25T17:10:33+00:00", "question_id": "53146e12435182e27ab84d64a0dd96f326f65e3a_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn integration_test_opt_in() {\n        // PRECONDITIONS:\n        //   - The BTC Parachain status in the Security component MUST be `RUNNING:0`.\n        //   - A Vault with id `vaultId` MUST be registered.\n        //   - The Vault MUST NOT be opted in.\n        // POSTCONDITION: The Vault MUST be allowed to receive nominated collateral.\n        test_with(|_| {\n            assert_noop!(\n                Call::Nomination(NominationCall::set_nomination_enabled(true)).dispatch(origin_of(account_of(CAROL))),\n                DispatchError::BadOrigin\n            );\n            let mut nomination_enabled = true;\n            assert_ok!(\n                Call::Nomination(NominationCall::set_nomination_enabled(nomination_enabled))\n                    .dispatch(<Runtime as frame_system::Config>::Origin::root())\n            );\n            assert_eq!(NominationPallet::is_nomination_enabled(), nomination_enabled);\n            nomination_enabled = false;\n            assert_ok!(\n                Call::Nomination(NominationCall::set_nomination_enabled(nomination_enabled))\n                    .dispatch(<Runtime as frame_system::Config>::Origin::root())\n            );\n            assert_eq!(NominationPallet::is_nomination_enabled(), nomination_enabled);\n        })\n"]], "pred": {"ppl": 2.38246750831604, "ppl_lower": 3.5322229862213135, "ppl/lowercase_ppl": -1.4536044686714853, "ppl/zlib": 0.002057196016138463, "Min_5.0% Prob": 8.166794075685388, "Min_10.0% Prob": 6.014245692421408, "Min_20.0% Prob": 3.941887620566548, "Min_30.0% Prob": 2.831380550391399, "Min_40.0% Prob": 2.1650950787521954, "Min_50.0% Prob": 1.738774711726469, "Min_60.0% Prob": 1.449250840454955}}
{"hexsha": "6dc9a3d2205df6a78355851fd18812b967628c17", "ext": "rs", "lang": "Rust", "content": "fn get_parents(input: &[Vec<String>], child: String) -> Vec<String> {\n    let parents = |x: Vec<String>| {\n        x.iter()\n            .rev()\n            .cloned()\n            .skip_while(|y| *y != child)\n            .skip(1)\n            .collect::<Vec<_>>()\n    };\n    let mut result = Vec::new();\n    for line in input {\n        let mut current_parents = parents(line.clone());\n        if !current_parents.is_empty() {\n            result.push(current_parents.pop().unwrap());\n        }\n    }\n    result\n}", "item_id": 2, "repo": "mohamed-abdelnour/AdventOfCode", "file": "2020/07/Rust/src/main.rs", "last_update_at": "2021-11-30T22:05:14+00:00", "question_id": "6dc9a3d2205df6a78355851fd18812b967628c17_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_parents(input: &[Vec<String>], child: String) -> Vec<String> {\n    let parents = |x: Vec<String>| {\n        x.iter()\n            .rev()\n            .cloned()\n            .skip_while(|y| *y != child)\n            .skip(1)\n            .collect::<Vec<_>>()\n    };\n    let mut result = Vec::new();\n    for line in input {\n        let mut current_parents = parents(line.clone());\n        if !current_parents.is_empty() {\n            result.push(current_parents.pop().unwrap());\n        }\n    }\n    result\n"]], "pred": {"ppl": 2.000673532485962, "ppl_lower": 2.2249202728271484, "ppl/lowercase_ppl": -1.1531934540140947, "ppl/zlib": 0.002796306008507673, "Min_5.0% Prob": 5.595587909221649, "Min_10.0% Prob": 4.312555402517319, "Min_20.0% Prob": 2.991407509893179, "Min_30.0% Prob": 2.2391414480904737, "Min_40.0% Prob": 1.715192785171362, "Min_50.0% Prob": 1.3889715264516849, "Min_60.0% Prob": 1.1638015546864762}}
{"hexsha": "7dd41a55ce1c74937639b8b4e7e38443fc76af10", "ext": "rs", "lang": "Rust", "content": "pub fn split<S: Session, D1: Into<Vec<u8>>, D2: Into<Vec<u8>>>(\n    stream: TcpStream,\n    session: S,\n    read_buf_cfg: BufCfg<D1>,\n    write_buf_cfg: BufCfg<D2>,\n) -> (ReadHalf<S>, WriteHalf<S>) {\n    assert!(!session.is_handshaking());\n\n    let shared = Arc::new(Shared {\n        stream,\n        session: Mutex::new(session),\n    });\n\n    let read_half = ReadHalf {\n        shared: shared.clone(),\n        buf: Buffer::build_from(read_buf_cfg),\n    };\n\n    let write_half = WriteHalf {\n        shared,\n        buf: Buffer::build_from(write_buf_cfg),\n    };\n\n    (read_half, write_half)\n}", "item_id": 1, "repo": "patins/rustls-split", "file": "src/lib.rs", "last_update_at": "2021-08-13T07:32:13+00:00", "question_id": "7dd41a55ce1c74937639b8b4e7e38443fc76af10_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn split<S: Session, D1: Into<Vec<u8>>, D2: Into<Vec<u8>>>(\n    stream: TcpStream,\n    session: S,\n    read_buf_cfg: BufCfg<D1>,\n    write_buf_cfg: BufCfg<D2>,\n) -> (ReadHalf<S>, WriteHalf<S>) {\n    assert!(!session.is_handshaking());\n    let shared = Arc::new(Shared {\n        stream,\n        session: Mutex::new(session),\n    });\n    let read_half = ReadHalf {\n        shared: shared.clone(),\n        buf: Buffer::build_from(read_buf_cfg),\n    };\n    let write_half = WriteHalf {\n        shared,\n        buf: Buffer::build_from(write_buf_cfg),\n    };\n    (read_half, write_half)\n"]], "pred": {"ppl": 2.08345365524292, "ppl_lower": 3.551795482635498, "ppl/lowercase_ppl": -1.7267121915558084, "ppl/zlib": 0.0025846018589051906, "Min_5.0% Prob": 7.186466520482844, "Min_10.0% Prob": 5.244307322935625, "Min_20.0% Prob": 3.3730014297697277, "Min_30.0% Prob": 2.415497155331854, "Min_40.0% Prob": 1.8320537310507563, "Min_50.0% Prob": 1.4660990807944827, "Min_60.0% Prob": 1.2283642108776365}}
{"hexsha": "051d6e3067c3cb429fe5956ee53ade84e86afc2e", "ext": "rs", "lang": "Rust", "content": "pub fn estimated_memory_cost(mempool: &Mempool) -> usize {\n    let txbytes: usize = mempool.items().map(|item| item.tx.encoded_length()).sum();\n\n    let utxoproofsbytes: usize = mempool\n        .items()\n        .flat_map(|i| i.proofs.iter().map(|p| utreexo_proof_memory_cost(p)))\n        .sum();\n    txbytes + utxoproofsbytes\n}", "item_id": 0, "repo": "TAIPANBOX/slingshot", "file": "demo/src/mempool.rs", "last_update_at": "2021-01-19T21:36:55+00:00", "question_id": "051d6e3067c3cb429fe5956ee53ade84e86afc2e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn estimated_memory_cost(mempool: &Mempool) -> usize {\n    let txbytes: usize = mempool.items().map(|item| item.tx.encoded_length()).sum();\n    let utxoproofsbytes: usize = mempool\n        .items()\n        .flat_map(|i| i.proofs.iter().map(|p| utreexo_proof_memory_cost(p)))\n        .sum();\n    txbytes + utxoproofsbytes\n"]], "pred": {"ppl": 4.090156078338623, "ppl_lower": 4.315643787384033, "ppl/lowercase_ppl": -1.038097418251543, "ppl/zlib": 0.007613962866430205, "Min_5.0% Prob": 9.368109607696534, "Min_10.0% Prob": 8.061411467465488, "Min_20.0% Prob": 5.910933567130047, "Min_30.0% Prob": 4.469454921994891, "Min_40.0% Prob": 3.4749622902971633, "Min_50.0% Prob": 2.814533056596578, "Min_60.0% Prob": 2.357084504263082}}
{"hexsha": "7f4954d74021dbde904b450c6b66c7681dc2fc65", "ext": "rs", "lang": "Rust", "content": "pub fn broadcast(x: Rc<RefCell<Variable>>, shape: Vec<usize>) -> Rc<RefCell<Variable>> {\n    let output = Rc::new(RefCell::new(Variable::new(shape.clone())));\n    let function = Box::new(Broadcast { shape });\n    let cg_function = Rc::new(RefCell::new(CgFunction::new(\n        vec![x],\n        vec![output.clone()],\n        function,\n    )));\n    cg_function.borrow_mut().forward();\n    output.borrow_mut().set_parent(cg_function);\n    output\n}", "item_id": 2, "repo": "takuseno/miniature", "file": "src/functions/mod.rs", "last_update_at": "2021-11-29T00:34:00+00:00", "question_id": "7f4954d74021dbde904b450c6b66c7681dc2fc65_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn broadcast(x: Rc<RefCell<Variable>>, shape: Vec<usize>) -> Rc<RefCell<Variable>> {\n    let output = Rc::new(RefCell::new(Variable::new(shape.clone())));\n    let function = Box::new(Broadcast { shape });\n    let cg_function = Rc::new(RefCell::new(CgFunction::new(\n        vec![x],\n        vec![output.clone()],\n        function,\n    )));\n    cg_function.borrow_mut().forward();\n    output.borrow_mut().set_parent(cg_function);\n    output\n"]], "pred": {"ppl": 2.5960659980773926, "ppl_lower": 3.512545108795166, "ppl/lowercase_ppl": -1.3169229937111877, "ppl/zlib": 0.0043963005599396065, "Min_5.0% Prob": 8.077593735286168, "Min_10.0% Prob": 6.235728247960409, "Min_20.0% Prob": 4.194312886397044, "Min_30.0% Prob": 3.018150560233904, "Min_40.0% Prob": 2.362440818645915, "Min_50.0% Prob": 1.8965863958968745, "Min_60.0% Prob": 1.5951407302535423}}
{"hexsha": "0b8dd0539077de18bf9818291fd1c1c98e8ab743", "ext": "rs", "lang": "Rust", "content": "fn test_marginal_zero_twosample() {\n        let union = setup(2);\n        let zero_likelihoods = zero_likelihoods();\n        let (allelefreq_likelihoods, marginal) = union.marginal(&zero_likelihoods, &union.prior);\n        println!(\"{:?} {}\", allelefreq_likelihoods, marginal);\n        for p in allelefreq_likelihoods {\n            assert!(eq(p, 0.0));\n        }\n    }", "item_id": 4, "repo": "johanneskoester/alpaca", "file": "src/call/sample_union.rs", "last_update_at": "2021-07-30T07:39:48+00:00", "question_id": "0b8dd0539077de18bf9818291fd1c1c98e8ab743_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_marginal_zero_twosample() {\n        let union = setup(2);\n        let zero_likelihoods = zero_likelihoods();\n        let (allelefreq_likelihoods, marginal) = union.marginal(&zero_likelihoods, &union.prior);\n        println!(\"{:?} {}\", allelefreq_likelihoods, marginal);\n        for p in allelefreq_likelihoods {\n            assert!(eq(p, 0.0));\n        }\n"]], "pred": {"ppl": 4.921542167663574, "ppl_lower": 4.921542167663574, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.009054670057395119, "Min_5.0% Prob": 8.936259110768637, "Min_10.0% Prob": 7.797736247380574, "Min_20.0% Prob": 5.991872886816661, "Min_30.0% Prob": 4.723743200302124, "Min_40.0% Prob": 3.7812272894139194, "Min_50.0% Prob": 3.1397516141172317, "Min_60.0% Prob": 2.663527060861457}}
{"hexsha": "9344eb8fa3ae39ba4da49b746909260eabdd6dc2", "ext": "rs", "lang": "Rust", "content": "fn make_system_notifications_adjustment_row() -> impl Widget<TomataState> {\n    let description_label = Label::new(\"Use system notifications:\");\n    let switch = Switch::new();\n    let switch = LensWrap::new(switch, Settings::system_notifications_are_enabled);\n    let switch = LensWrap::new(switch, TomataState::settings);\n    Flex::row()\n        .with_child(description_label)\n        .with_flex_child(Align::right(switch), 1.0)\n}", "item_id": 7, "repo": "khrynczenko/tomata", "file": "src/widget.rs", "last_update_at": "2021-05-08T10:09:32+00:00", "question_id": "9344eb8fa3ae39ba4da49b746909260eabdd6dc2_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn make_system_notifications_adjustment_row() -> impl Widget<TomataState> {\n    let description_label = Label::new(\"Use system notifications:\");\n    let switch = Switch::new();\n    let switch = LensWrap::new(switch, Settings::system_notifications_are_enabled);\n    let switch = LensWrap::new(switch, TomataState::settings);\n    Flex::row()\n        .with_child(description_label)\n        .with_flex_child(Align::right(switch), 1.0)\n"]], "pred": {"ppl": 3.7204322814941406, "ppl_lower": 5.451394081115723, "ppl/lowercase_ppl": -1.2907747848473963, "ppl/zlib": 0.005712347244506686, "Min_5.0% Prob": 9.535335381825766, "Min_10.0% Prob": 7.929522367624136, "Min_20.0% Prob": 5.505289829694307, "Min_30.0% Prob": 4.0702811896801, "Min_40.0% Prob": 3.2309626037219785, "Min_50.0% Prob": 2.6037662551919025, "Min_60.0% Prob": 2.194311118405312}}
{"hexsha": "e44b15a42bde104a0af919003d7108077e10781b", "ext": "rs", "lang": "Rust", "content": "fn backwards_sqrt() {\n        let a = Tensor::new(vec![3.0], &[1]).unwrap();\n\n        let b = a.sqrt().unwrap();\n\n        b.backward();\n\n        assert!(\n            (b.derivative == RefCell::new(vec![1.0])\n                && (a.derivative == RefCell::new(vec![0.5 * ((3.0 as f32).powf(-0.5))])))\n        )\n    }", "item_id": 55, "repo": "bkahn-github/L2", "file": "src/tensor.rs", "last_update_at": "2021-01-23T22:09:45+00:00", "question_id": "e44b15a42bde104a0af919003d7108077e10781b_55", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn backwards_sqrt() {\n        let a = Tensor::new(vec![3.0], &[1]).unwrap();\n        let b = a.sqrt().unwrap();\n        b.backward();\n        assert!(\n            (b.derivative == RefCell::new(vec![1.0])\n                && (a.derivative == RefCell::new(vec![0.5 * ((3.0 as f32).powf(-0.5))])))\n        )\n"]], "pred": {"ppl": 4.034495830535889, "ppl_lower": 5.158951759338379, "ppl/lowercase_ppl": -1.1762530321986977, "ppl/zlib": 0.007880685564143447, "Min_5.0% Prob": 10.038993453979492, "Min_10.0% Prob": 8.046696402809836, "Min_20.0% Prob": 5.460619294125101, "Min_30.0% Prob": 4.222719591004508, "Min_40.0% Prob": 3.403581463772318, "Min_50.0% Prob": 2.7789170775434067, "Min_60.0% Prob": 2.3219110128070626}}
{"hexsha": "74d5adaef7242d1689e13c9f16854704d534c808", "ext": "rs", "lang": "Rust", "content": "fn websocket() {\n        let counter = AtomicUsize::new(0);\n        let mock = MockData::new();\n        let mut proto = PureProto::new(mock.clone(),\n            &Config::new().inflight_request_limit(1).done(),\n            MockWs { websockets: &counter });\n        proto.process().unwrap();\n        mock.add_input(\"GET /chat HTTP/1.1\\r\\n\\\n            Host: server.example.com\\r\\n\\\n            Upgrade: websocket\\r\\n\\\n            Connection: Upgrade\\r\\n\\\n            Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\\r\\n\\\n            Sec-WebSocket-Protocol: chat, superchat\\r\\n\\\n            Sec-WebSocket-Version: 13\\r\\n\\\n            Origin: http://example.com\\r\\n\\r\\n\");\n        proto.process().unwrap();\n        // counts as a request and as a websocket\n        assert_eq!(counter.load(Ordering::SeqCst), 2);\n    }", "item_id": 4, "repo": "pyfisch/tk-http", "file": "src/server/proto.rs", "last_update_at": "2021-07-06T06:06:36+00:00", "question_id": "74d5adaef7242d1689e13c9f16854704d534c808_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn websocket() {\n        let counter = AtomicUsize::new(0);\n        let mock = MockData::new();\n        let mut proto = PureProto::new(mock.clone(),\n            &Config::new().inflight_request_limit(1).done(),\n            MockWs { websockets: &counter });\n        proto.process().unwrap();\n        mock.add_input(\"GET /chat HTTP/1.1\\r\\n\\\n            Host: server.example.com\\r\\n\\\n            Upgrade: websocket\\r\\n\\\n            Connection: Upgrade\\r\\n\\\n            Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\\r\\n\\\n            Sec-WebSocket-Protocol: chat, superchat\\r\\n\\\n            Sec-WebSocket-Version: 13\\r\\n\\\n            Origin: http://example.com\\r\\n\\r\\n\");\n        proto.process().unwrap();\n        // counts as a request and as a websocket\n        assert_eq!(counter.load(Ordering::SeqCst), 2);\n"]], "pred": {"ppl": 2.4872381687164307, "ppl_lower": 4.9316558837890625, "ppl/lowercase_ppl": -1.751231589210545, "ppl/zlib": 0.002312621638840225, "Min_5.0% Prob": 8.038241129655104, "Min_10.0% Prob": 6.088278461385657, "Min_20.0% Prob": 4.116883543906389, "Min_30.0% Prob": 2.9671992427772946, "Min_40.0% Prob": 2.2666543566305704, "Min_50.0% Prob": 1.8256857748800779, "Min_60.0% Prob": 1.5251906682291507}}
{"hexsha": "d4c3e1026d97040aae8578f639e702323531ab9a", "ext": "rs", "lang": "Rust", "content": "fn print_stats(mut times: Vec<u32>) {\n    times.sort();\n\n    let p50 = times.len() as f64 * 0.5;\n    let p95 = times.len() as f64 * 0.95;\n    let p99 = times.len() as f64 * 0.99;\n    let p999 = times.len() as f64 * 0.999;\n\n    println!(\"Stats (ns): p50: {} p95: {} p99: {} p999: {} max: {}\",\n        times[p50 as usize],\n        times[p95 as usize],\n        times[p99 as usize],\n        times[p999 as usize],\n        times.last().unwrap(),\n    );\n}", "item_id": 0, "repo": "StephanDollberg/PingPong", "file": "src/bin/pinger.rs", "last_update_at": "2021-11-26T13:10:03+00:00", "question_id": "d4c3e1026d97040aae8578f639e702323531ab9a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn print_stats(mut times: Vec<u32>) {\n    times.sort();\n    let p50 = times.len() as f64 * 0.5;\n    let p95 = times.len() as f64 * 0.95;\n    let p99 = times.len() as f64 * 0.99;\n    let p999 = times.len() as f64 * 0.999;\n    println!(\"Stats (ns): p50: {} p95: {} p99: {} p999: {} max: {}\",\n        times[p50 as usize],\n        times[p95 as usize],\n        times[p99 as usize],\n        times[p999 as usize],\n        times.last().unwrap(),\n    );\n"]], "pred": {"ppl": 1.6054210662841797, "ppl_lower": 1.7215920686721802, "ppl/lowercase_ppl": -1.147582322046559, "ppl/zlib": 0.0024655524415085075, "Min_5.0% Prob": 5.606881213188172, "Min_10.0% Prob": 3.804145932197571, "Min_20.0% Prob": 2.2721654407680036, "Min_30.0% Prob": 1.5804878999789556, "Min_40.0% Prob": 1.1828003005802998, "Min_50.0% Prob": 0.9508037260724324, "Min_60.0% Prob": 0.7940254292194924}}
{"hexsha": "81eb41f999bbf956413f7dc13997085e2fca3606", "ext": "rs", "lang": "Rust", "content": "fn history_tree_is_updated_for_network_upgrade(\n    network: Network,\n    network_upgrade: NetworkUpgrade,\n) -> Result<()> {\n    let blocks = match network {\n        Network::Mainnet => &*zebra_test::vectors::MAINNET_BLOCKS,\n        Network::Testnet => &*zebra_test::vectors::TESTNET_BLOCKS,\n    };\n    let height = network_upgrade.activation_height(network).unwrap().0;\n\n    let prev_block = Arc::new(\n        blocks\n            .get(&(height - 1))\n            .expect(\"test vector exists\")\n            .zcash_deserialize_into::<Block>()\n            .expect(\"block is structurally valid\"),\n    );\n\n    let mut state = NonFinalizedState::new(network);\n    let finalized_state = FinalizedState::new(&Config::ephemeral(), network);\n\n    state\n        .commit_new_chain(prev_block.clone().prepare(), &finalized_state)\n        .unwrap();\n\n    let chain = state.best_chain().unwrap();\n    if network_upgrade == NetworkUpgrade::Heartwood {\n        assert!(\n            chain.history_tree.as_ref().is_none(),\n            \"history tree must not exist yet\"\n        );\n    } else {\n        assert!(\n            chain.history_tree.as_ref().is_some(),\n            \"history tree must already exist\"\n        );\n    }\n\n    // The Heartwood activation block has an all-zero commitment\n    let activation_block = prev_block.make_fake_child().set_block_commitment([0u8; 32]);\n\n    state\n        .commit_block(activation_block.clone().prepare(), &finalized_state)\n        .unwrap();\n\n    let chain = state.best_chain().unwrap();\n    assert!(\n        chain.history_tree.as_ref().is_some(),\n        \"history tree must have been (re)created\"\n    );\n    assert_eq!(\n        chain.history_tree.as_ref().as_ref().unwrap().size(),\n        1,\n        \"history tree must have a single node\"\n    );\n\n    // To fix the commitment in the next block we must recreate the history tree\n    let tree = NonEmptyHistoryTree::from_block(\n        Network::Mainnet,\n        activation_block.clone(),\n        &chain.sapling_note_commitment_tree.root(),\n        &chain.orchard_note_commitment_tree.root(),\n    )\n    .unwrap();\n\n    let next_block = activation_block\n        .make_fake_child()\n        .set_block_commitment(tree.hash().into());\n\n    state\n        .commit_block(next_block.prepare(), &finalized_state)\n        .unwrap();\n\n    assert!(\n        state.best_chain().unwrap().history_tree.as_ref().is_some(),\n        \"history tree must still exist\"\n    );\n\n    Ok(())\n}", "item_id": 16, "repo": "feifeivv/zebra", "file": "zebra-state/src/service/non_finalized_state/tests/vectors.rs", "last_update_at": "2021-11-15T09:41:54+00:00", "question_id": "81eb41f999bbf956413f7dc13997085e2fca3606_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn history_tree_is_updated_for_network_upgrade(\n    network: Network,\n    network_upgrade: NetworkUpgrade,\n) -> Result<()> {\n    let blocks = match network {\n        Network::Mainnet => &*zebra_test::vectors::MAINNET_BLOCKS,\n        Network::Testnet => &*zebra_test::vectors::TESTNET_BLOCKS,\n    };\n    let height = network_upgrade.activation_height(network).unwrap().0;\n    let prev_block = Arc::new(\n        blocks\n            .get(&(height - 1))\n            .expect(\"test vector exists\")\n            .zcash_deserialize_into::<Block>()\n            .expect(\"block is structurally valid\"),\n    );\n    let mut state = NonFinalizedState::new(network);\n    let finalized_state = FinalizedState::new(&Config::ephemeral(), network);\n    state\n        .commit_new_chain(prev_block.clone().prepare(), &finalized_state)\n        .unwrap();\n    let chain = state.best_chain().unwrap();\n    if network_upgrade == NetworkUpgrade::Heartwood {\n        assert!(\n            chain.history_tree.as_ref().is_none(),\n            \"history tree must not exist yet\"\n        );\n    } else {\n        assert!(\n            chain.history_tree.as_ref().is_some(),\n            \"history tree must already exist\"\n        );\n    }\n    // The Heartwood activation block has an all-zero commitment\n    let activation_block = prev_block.make_fake_child().set_block_commitment([0u8; 32]);\n    state\n        .commit_block(activation_block.clone().prepare(), &finalized_state)\n        .unwrap();\n    let chain = state.best_chain().unwrap();\n    assert!(\n        chain.history_tree.as_ref().is_some(),\n        \"history tree must have been (re)created\"\n    );\n    assert_eq!(\n        chain.history_tree.as_ref().as_ref().unwrap().size(),\n        1,\n        \"history tree must have a single node\"\n    );\n    // To fix the commitment in the next block we must recreate the history tree\n    let tree = NonEmptyHistoryTree::from_block(\n        Network::Mainnet,\n        activation_block.clone(),\n        &chain.sapling_note_commitment_tree.root(),\n        &chain.orchard_note_commitment_tree.root(),\n    )\n    .unwrap();\n    let next_block = activation_block\n        .make_fake_child()\n        .set_block_commitment(tree.hash().into());\n    state\n        .commit_block(next_block.prepare(), &finalized_state)\n        .unwrap();\n    assert!(\n        state.best_chain().unwrap().history_tree.as_ref().is_some(),\n        \"history tree must still exist\"\n    );\n    Ok(())\n"]], "pred": {"ppl": 2.1118788719177246, "ppl_lower": 2.3789303302764893, "ppl/lowercase_ppl": -1.159278271716281, "ppl/zlib": 0.0009321421594608789, "Min_5.0% Prob": 6.615629724554114, "Min_10.0% Prob": 4.968873197967942, "Min_20.0% Prob": 3.278945228135264, "Min_30.0% Prob": 2.3835621435899994, "Min_40.0% Prob": 1.8452690447101723, "Min_50.0% Prob": 1.492040000634419, "Min_60.0% Prob": 1.246901141712442}}
{"hexsha": "0fa43e5aba425d2178f55950eeb61438ed26794e", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<()>{\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input)?;\n\n    let points = input.lines().\n        map(|l| l.parse()).collect::<Result<Vec<Point>>>()?;\n\n    let n = points.len();\n    let mut connections: Vec<usize> = (0..n).collect();\n\n    for i in 0..n {\n        for j in 0..n {\n            if find(i, &mut connections) == find(j, &mut connections) {\n                continue;\n            }\n            if points[i].is_same_constellation(&points[j]) {\n                union(i, j, &mut connections)\n            }\n        }\n    }\n\n    let mut constellation = HashSet::new();\n    for &i in &connections {\n        if !constellation.contains(&i) {\n            constellation.insert(i);\n        }\n    }\n\n    println!(\"part1 answer: {:?}\", constellation.len());\n\n    Ok(())\n}", "item_id": 0, "repo": "livexia/rust-learning", "file": "practice/advent-of-code/aoc25/src/main.rs", "last_update_at": "2021-12-17T06:16:22+00:00", "question_id": "0fa43e5aba425d2178f55950eeb61438ed26794e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<()>{\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input)?;\n    let points = input.lines().\n        map(|l| l.parse()).collect::<Result<Vec<Point>>>()?;\n    let n = points.len();\n    let mut connections: Vec<usize> = (0..n).collect();\n    for i in 0..n {\n        for j in 0..n {\n            if find(i, &mut connections) == find(j, &mut connections) {\n                continue;\n            }\n            if points[i].is_same_constellation(&points[j]) {\n                union(i, j, &mut connections)\n            }\n        }\n    }\n    let mut constellation = HashSet::new();\n    for &i in &connections {\n        if !constellation.contains(&i) {\n            constellation.insert(i);\n        }\n    }\n    println!(\"part1 answer: {:?}\", constellation.len());\n    Ok(())\n"]], "pred": {"ppl": 2.0388143062591553, "ppl_lower": 2.3110311031341553, "ppl/lowercase_ppl": -1.1759277511202524, "ppl/zlib": 0.0019570560891728366, "Min_5.0% Prob": 6.180491300729605, "Min_10.0% Prob": 4.682554932741018, "Min_20.0% Prob": 3.1304364766714707, "Min_30.0% Prob": 2.283910020620008, "Min_40.0% Prob": 1.7565953232488543, "Min_50.0% Prob": 1.423347945494408, "Min_60.0% Prob": 1.1851492414321259}}
{"hexsha": "ee4d532b06074860ee78a6a033ea1c4abfd2ec28", "ext": "rs", "lang": "Rust", "content": "fn try_read_up_to() {\n            let src = b\"1234567890\";\n            let mut buf = TryVec::new();\n            super::try_read_up_to(&mut src.as_ref(), 5, &mut buf).unwrap();\n            assert_eq!(buf.len(), 5);\n            assert_eq!(buf, b\"12345\".as_ref());\n        }", "item_id": 4, "repo": "emilio/fallible_collections", "file": "src/vec.rs", "last_update_at": "2021-01-07T18:47:18+00:00", "question_id": "ee4d532b06074860ee78a6a033ea1c4abfd2ec28_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn try_read_up_to() {\n            let src = b\"1234567890\";\n            let mut buf = TryVec::new();\n            super::try_read_up_to(&mut src.as_ref(), 5, &mut buf).unwrap();\n            assert_eq!(buf.len(), 5);\n            assert_eq!(buf, b\"12345\".as_ref());\n"]], "pred": {"ppl": 2.462332248687744, "ppl_lower": 2.7795517444610596, "ppl/lowercase_ppl": -1.1344795207192697, "ppl/zlib": 0.005889601107080827, "Min_5.0% Prob": 7.782614994049072, "Min_10.0% Prob": 5.970273900032043, "Min_20.0% Prob": 3.9458694458007812, "Min_30.0% Prob": 2.8618314703305563, "Min_40.0% Prob": 2.1840615381554858, "Min_50.0% Prob": 1.7909326791471125, "Min_60.0% Prob": 1.5129622566651126}}
{"hexsha": "9e5b8a7d4d282a3f6376882d0af334b036b442c6", "ext": "rs", "lang": "Rust", "content": "fn new_with_existing_path() {\n        let directory = TempDir::new().unwrap();\n        let repository = Repository::new(directory.into_path());\n\n        assert!(repository.is_ok())\n    }", "item_id": 0, "repo": "daniel-stoneuk/alfred-gitignore", "file": "src/repository.rs", "last_update_at": "2021-12-13T18:59:18+00:00", "question_id": "9e5b8a7d4d282a3f6376882d0af334b036b442c6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn new_with_existing_path() {\n        let directory = TempDir::new().unwrap();\n        let repository = Repository::new(directory.into_path());\n        assert!(repository.is_ok())\n"]], "pred": {"ppl": 3.5980916023254395, "ppl_lower": 4.99515438079834, "ppl/lowercase_ppl": -1.2562197776356445, "ppl/zlib": 0.01016193328919587, "Min_5.0% Prob": 7.97223424911499, "Min_10.0% Prob": 6.70080680847168, "Min_20.0% Prob": 5.227771329879761, "Min_30.0% Prob": 3.9957525730133057, "Min_40.0% Prob": 3.060035613321123, "Min_50.0% Prob": 2.529856318464646, "Min_60.0% Prob": 2.1570037353423333}}
{"hexsha": "1d16805294dec2b89573b4fabacd0b817a33103a", "ext": "rs", "lang": "Rust", "content": "fn parse_derive_attr(reg: &Registry,\n                     nested: Vec<NestedMetaItem>)\n                     -> (Vec<Ident>, Option<Attribute>) {\n    let mut derives = Vec::new();\n\n    let remaining: Vec<_> = nested.into_iter()\n        .flat_map(|meta| {\n            let word = match meta {\n                NestedMetaItem::MetaItem(MetaItem::Word(word)) => word,\n                _ => return Some(meta),\n            };\n            if reg.derives.contains_key(word.as_ref()) {\n                derives.push(word);\n                None\n            } else {\n                Some(NestedMetaItem::MetaItem(MetaItem::Word(word)))\n            }\n        })\n        .collect();\n\n    let attr = if remaining.is_empty() {\n        // Elide an empty #[derive()]\n        None\n    } else {\n        Some(Attribute {\n            style: AttrStyle::Outer,\n            value: MetaItem::List(\"derive\".into(), remaining),\n            is_sugared_doc: false,\n        })\n    };\n\n    (derives, attr)\n}", "item_id": 4, "repo": "integer32llc/syn", "file": "src/registry.rs", "last_update_at": "2021-03-09T23:10:48+00:00", "question_id": "1d16805294dec2b89573b4fabacd0b817a33103a_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_derive_attr(reg: &Registry,\n                     nested: Vec<NestedMetaItem>)\n                     -> (Vec<Ident>, Option<Attribute>) {\n    let mut derives = Vec::new();\n    let remaining: Vec<_> = nested.into_iter()\n        .flat_map(|meta| {\n            let word = match meta {\n                NestedMetaItem::MetaItem(MetaItem::Word(word)) => word,\n                _ => return Some(meta),\n            };\n            if reg.derives.contains_key(word.as_ref()) {\n                derives.push(word);\n                None\n            } else {\n                Some(NestedMetaItem::MetaItem(MetaItem::Word(word)))\n            }\n        })\n        .collect();\n    let attr = if remaining.is_empty() {\n        // Elide an empty #[derive()]\n        None\n    } else {\n        Some(Attribute {\n            style: AttrStyle::Outer,\n            value: MetaItem::List(\"derive\".into(), remaining),\n            is_sugared_doc: false,\n        })\n    };\n    (derives, attr)\n"]], "pred": {"ppl": 2.009568691253662, "ppl_lower": 2.5720086097717285, "ppl/lowercase_ppl": -1.3535749007309195, "ppl/zlib": 0.0016776925903347305, "Min_5.0% Prob": 6.818111603076641, "Min_10.0% Prob": 4.9511144161224365, "Min_20.0% Prob": 3.152446406537836, "Min_30.0% Prob": 2.2563973514430495, "Min_40.0% Prob": 1.7338343508340217, "Min_50.0% Prob": 1.396905867423085, "Min_60.0% Prob": 1.1652897510922955}}
{"hexsha": "e646e26bddb9e80f2a86726ce71efb592188ff01", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    println!(\"{}\", read_file(\"src/main.rs\").unwrap()); // this line succeeds\n    println!(\"{}\", read_file(\"src/failure.rs\").unwrap()); // this line fails\n}", "item_id": 1, "repo": "brndnmtthws/code-like-a-pro-in-rust-book", "file": "c4/4.7/error-conversion/src/main.rs", "last_update_at": "2021-11-27T02:53:30+00:00", "question_id": "e646e26bddb9e80f2a86726ce71efb592188ff01_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    println!(\"{}\", read_file(\"src/main.rs\").unwrap()); // this line succeeds\n    println!(\"{}\", read_file(\"src/failure.rs\").unwrap()); // this line fails\n"]], "pred": {"ppl": 3.2134909629821777, "ppl_lower": 3.2134909629821777, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.011333571588555011, "Min_5.0% Prob": 8.117249011993408, "Min_10.0% Prob": 6.584478950500488, "Min_20.0% Prob": 4.671529698371887, "Min_30.0% Prob": 3.685198012987773, "Min_40.0% Prob": 2.8749687775969504, "Min_50.0% Prob": 2.2723941115232615, "Min_60.0% Prob": 1.9332783746142541}}
{"hexsha": "ef651b75cf5fbbbc8568091dc8d277df24d00ef1", "ext": "rs", "lang": "Rust", "content": "fn count_gc_content(dna: &String) -> u32 {\n        let mut gc_content: u32 = 0;\n        for i in dna.chars() {\n            match i {\n                'G' | 'g'  => gc_content += 1,\n                'C' | 'c' => gc_content += 1,\n                _ => (), \n            };\n        }\n        gc_content\n    }", "item_id": 0, "repo": "hhandika/gc-counter", "file": "src/counter.rs", "last_update_at": "2021-01-03T15:15:54+00:00", "question_id": "ef651b75cf5fbbbc8568091dc8d277df24d00ef1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn count_gc_content(dna: &String) -> u32 {\n        let mut gc_content: u32 = 0;\n        for i in dna.chars() {\n            match i {\n                'G' | 'g'  => gc_content += 1,\n                'C' | 'c' => gc_content += 1,\n                _ => (), \n            };\n        }\n        gc_content\n"]], "pred": {"ppl": 1.9513139724731445, "ppl_lower": 2.1772031784057617, "ppl/lowercase_ppl": -1.1638558591382102, "ppl/zlib": 0.004340928426560331, "Min_5.0% Prob": 7.6903129577636715, "Min_10.0% Prob": 5.066640008579601, "Min_20.0% Prob": 3.089461835947904, "Min_30.0% Prob": 2.165808748566743, "Min_40.0% Prob": 1.6538985215804793, "Min_50.0% Prob": 1.3315678546374494, "Min_60.0% Prob": 1.1123255401369974}}
{"hexsha": "6fd57cd09e234b7cef7f65292f3deaaf316c4592", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let x = 5;\n    let _y = fn~(move x) -> int {\n        let _z = fn~(move x) -> int { x }; //~ ERROR moving out of captured outer variable in a heap closure\n        22\n    }", "item_id": 0, "repo": "mernen/rust", "file": "src/test/compile-fail/cap-clause-move-upvar.rs", "last_update_at": "2021-11-17T10:43:56+00:00", "question_id": "6fd57cd09e234b7cef7f65292f3deaaf316c4592_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let x = 5;\n    let _y = fn~(move x) -> int {\n        let _z = fn~(move x) -> int { x }; //~ ERROR moving out of captured outer variable in a heap closure\n        22\n"]], "pred": {"ppl": 4.522053241729736, "ppl_lower": 5.144724369049072, "ppl/lowercase_ppl": -1.0854927380180854, "ppl/zlib": 0.01126094140089931, "Min_5.0% Prob": 9.915481567382812, "Min_10.0% Prob": 7.877074082692464, "Min_20.0% Prob": 5.714300672213237, "Min_30.0% Prob": 4.353315729843943, "Min_40.0% Prob": 3.546914403438568, "Min_50.0% Prob": 2.8831926798447967, "Min_60.0% Prob": 2.473132709139272}}
{"hexsha": "9a262f90165c22522bcd1431d381db509df51a6e", "ext": "rs", "lang": "Rust", "content": "fn parse_operation_definition(\n    pair: Pair<Rule>,\n    pc: &mut PositionCalculator,\n) -> Result<Positioned<OperationDefinition>> {\n    debug_assert_eq!(pair.as_rule(), Rule::operation_definition);\n\n    let pos = pc.step(&pair);\n    let pair = exactly_one(pair.into_inner());\n    Ok(Positioned::new(\n        match pair.as_rule() {\n            Rule::named_operation_definition => parse_named_operation_definition(pair, pc)?,\n            Rule::selection_set => OperationDefinition {\n                ty: OperationType::Query,\n                name: None,\n                variable_definitions: Vec::new(),\n                directives: Vec::new(),\n                selection_set: parse_selection_set(pair, pc)?,\n            },\n            _ => unreachable!(),\n        },\n        pos,\n    ))\n}", "item_id": 1, "repo": "mwilliammyers/async-graphql", "file": "parser/src/parse/executable.rs", "last_update_at": "2021-02-02T18:43:41+00:00", "question_id": "9a262f90165c22522bcd1431d381db509df51a6e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_operation_definition(\n    pair: Pair<Rule>,\n    pc: &mut PositionCalculator,\n) -> Result<Positioned<OperationDefinition>> {\n    debug_assert_eq!(pair.as_rule(), Rule::operation_definition);\n    let pos = pc.step(&pair);\n    let pair = exactly_one(pair.into_inner());\n    Ok(Positioned::new(\n        match pair.as_rule() {\n            Rule::named_operation_definition => parse_named_operation_definition(pair, pc)?,\n            Rule::selection_set => OperationDefinition {\n                ty: OperationType::Query,\n                name: None,\n                variable_definitions: Vec::new(),\n                directives: Vec::new(),\n                selection_set: parse_selection_set(pair, pc)?,\n            },\n            _ => unreachable!(),\n        },\n        pos,\n    ))\n"]], "pred": {"ppl": 1.9042221307754517, "ppl_lower": 2.6460206508636475, "ppl/lowercase_ppl": -1.510785223839839, "ppl/zlib": 0.0019283640565495373, "Min_5.0% Prob": 7.059762740135193, "Min_10.0% Prob": 5.072293088549659, "Min_20.0% Prob": 3.0652323982050254, "Min_30.0% Prob": 2.1392270298674703, "Min_40.0% Prob": 1.60450987821055, "Min_50.0% Prob": 1.292521664446272, "Min_60.0% Prob": 1.0729629166131882}}
{"hexsha": "ea10c8bcf011c08141369fab482a1c92882c15f5", "ext": "rs", "lang": "Rust", "content": "pub fn generate_NS_trick<'a, 'b>(\n    original_packet: &ndp::NeighborSolicitPacket<'a>,\n    src_addr: &Ipv6Addr,\n    dst_addr: &Ipv6Addr,\n) -> Option<Icmpv6Packet<'b>> {\n    let pkt_buf: Vec<u8> =\n        vec![0; original_packet.packet_size() + Icmpv6Packet::minimum_packet_size()];\n    let mut ret = match MutableIcmpv6Packet::owned(pkt_buf) {\n        Some(v) => v,\n        None => return None,\n    };\n    // update the option field if needed\n    // convert it into a icmp echo request\n    ret.set_icmpv6_type(Icmpv6Types::EchoRequest);\n    ret.set_payload(original_packet.packet());\n    //\n    let csum = pnet::util::ipv6_checksum(\n        ret.packet(),\n        1,\n        &[],\n        src_addr,\n        dst_addr,\n        pnet::packet::ip::IpNextHeaderProtocols::Icmpv6,\n    );\n    ret.set_checksum(csum);\n\n    Some(ret.consume_to_immutable())\n}", "item_id": 1, "repo": "6-6-6/ndproxy", "file": "src/packets.rs", "last_update_at": "2021-09-22T06:44:46+00:00", "question_id": "ea10c8bcf011c08141369fab482a1c92882c15f5_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn generate_NS_trick<'a, 'b>(\n    original_packet: &ndp::NeighborSolicitPacket<'a>,\n    src_addr: &Ipv6Addr,\n    dst_addr: &Ipv6Addr,\n) -> Option<Icmpv6Packet<'b>> {\n    let pkt_buf: Vec<u8> =\n        vec![0; original_packet.packet_size() + Icmpv6Packet::minimum_packet_size()];\n    let mut ret = match MutableIcmpv6Packet::owned(pkt_buf) {\n        Some(v) => v,\n        None => return None,\n    };\n    // update the option field if needed\n    // convert it into a icmp echo request\n    ret.set_icmpv6_type(Icmpv6Types::EchoRequest);\n    ret.set_payload(original_packet.packet());\n    //\n    let csum = pnet::util::ipv6_checksum(\n        ret.packet(),\n        1,\n        &[],\n        src_addr,\n        dst_addr,\n        pnet::packet::ip::IpNextHeaderProtocols::Icmpv6,\n    );\n    ret.set_checksum(csum);\n    Some(ret.consume_to_immutable())\n"]], "pred": {"ppl": 2.9172420501708984, "ppl_lower": 3.48067045211792, "ppl/lowercase_ppl": -1.1649354472293119, "ppl/zlib": 0.0024059295878420153, "Min_5.0% Prob": 8.339696854352951, "Min_10.0% Prob": 6.594216346740723, "Min_20.0% Prob": 4.4790874954425925, "Min_30.0% Prob": 3.3582981969370986, "Min_40.0% Prob": 2.6285876516591418, "Min_50.0% Prob": 2.1360360409274244, "Min_60.0% Prob": 1.786831809932159}}
{"hexsha": "d3e24b2e8db00b6f5c8dfe99fc0bbb30a1f9b561", "ext": "rs", "lang": "Rust", "content": "fn parse_relocation<Elf: FileHeader>(\n    header: &Elf,\n    endian: Elf::Endian,\n    reloc: Elf::Rela,\n    implicit_addend: bool,\n) -> Relocation {\n    let mut encoding = RelocationEncoding::Generic;\n    let is_mips64el = header.is_mips64el(endian);\n    let (kind, size) = match header.e_machine(endian) {\n        elf::EM_AARCH64 => match reloc.r_type(endian, false) {\n            elf::R_AARCH64_ABS64 => (RelocationKind::Absolute, 64),\n            elf::R_AARCH64_ABS32 => (RelocationKind::Absolute, 32),\n            elf::R_AARCH64_ABS16 => (RelocationKind::Absolute, 16),\n            elf::R_AARCH64_PREL64 => (RelocationKind::Relative, 64),\n            elf::R_AARCH64_PREL32 => (RelocationKind::Relative, 32),\n            elf::R_AARCH64_PREL16 => (RelocationKind::Relative, 16),\n            elf::R_AARCH64_CALL26 => {\n                encoding = RelocationEncoding::AArch64Call;\n                (RelocationKind::PltRelative, 26)\n            }\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_ARM => match reloc.r_type(endian, false) {\n            elf::R_ARM_ABS32 => (RelocationKind::Absolute, 32),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_AVR => match reloc.r_type(endian, false) {\n            elf::R_AVR_32 => (RelocationKind::Absolute, 32),\n            elf::R_AVR_16 => (RelocationKind::Absolute, 16),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_BPF => match reloc.r_type(endian, false) {\n            elf::R_BPF_64_64 => (RelocationKind::Absolute, 64),\n            elf::R_BPF_64_32 => (RelocationKind::Absolute, 32),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_386 => match reloc.r_type(endian, false) {\n            elf::R_386_32 => (RelocationKind::Absolute, 32),\n            elf::R_386_PC32 => (RelocationKind::Relative, 32),\n            elf::R_386_GOT32 => (RelocationKind::Got, 32),\n            elf::R_386_PLT32 => (RelocationKind::PltRelative, 32),\n            elf::R_386_GOTOFF => (RelocationKind::GotBaseOffset, 32),\n            elf::R_386_GOTPC => (RelocationKind::GotBaseRelative, 32),\n            elf::R_386_16 => (RelocationKind::Absolute, 16),\n            elf::R_386_PC16 => (RelocationKind::Relative, 16),\n            elf::R_386_8 => (RelocationKind::Absolute, 8),\n            elf::R_386_PC8 => (RelocationKind::Relative, 8),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_X86_64 => match reloc.r_type(endian, false) {\n            elf::R_X86_64_64 => (RelocationKind::Absolute, 64),\n            elf::R_X86_64_PC32 => (RelocationKind::Relative, 32),\n            elf::R_X86_64_GOT32 => (RelocationKind::Got, 32),\n            elf::R_X86_64_PLT32 => (RelocationKind::PltRelative, 32),\n            elf::R_X86_64_GOTPCREL => (RelocationKind::GotRelative, 32),\n            elf::R_X86_64_32 => (RelocationKind::Absolute, 32),\n            elf::R_X86_64_32S => {\n                encoding = RelocationEncoding::X86Signed;\n                (RelocationKind::Absolute, 32)\n            }\n            elf::R_X86_64_16 => (RelocationKind::Absolute, 16),\n            elf::R_X86_64_PC16 => (RelocationKind::Relative, 16),\n            elf::R_X86_64_8 => (RelocationKind::Absolute, 8),\n            elf::R_X86_64_PC8 => (RelocationKind::Relative, 8),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_HEXAGON => match reloc.r_type(endian, false) {\n            elf::R_HEX_32 => (RelocationKind::Absolute, 32),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_MIPS => match reloc.r_type(endian, is_mips64el) {\n            elf::R_MIPS_16 => (RelocationKind::Absolute, 16),\n            elf::R_MIPS_32 => (RelocationKind::Absolute, 32),\n            elf::R_MIPS_64 => (RelocationKind::Absolute, 64),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_MSP430 => match reloc.r_type(endian, false) {\n            elf::R_MSP430_32 => (RelocationKind::Absolute, 32),\n            elf::R_MSP430_16_BYTE => (RelocationKind::Absolute, 16),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_PPC => match reloc.r_type(endian, false) {\n            elf::R_PPC_ADDR32 => (RelocationKind::Absolute, 32),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_PPC64 => match reloc.r_type(endian, false) {\n            elf::R_PPC64_ADDR32 => (RelocationKind::Absolute, 32),\n            elf::R_PPC64_ADDR64 => (RelocationKind::Absolute, 64),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_RISCV => match reloc.r_type(endian, false) {\n            elf::R_RISCV_32 => (RelocationKind::Absolute, 32),\n            elf::R_RISCV_64 => (RelocationKind::Absolute, 64),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_S390 => match reloc.r_type(endian, false) {\n            elf::R_390_8 => (RelocationKind::Absolute, 8),\n            elf::R_390_16 => (RelocationKind::Absolute, 16),\n            elf::R_390_32 => (RelocationKind::Absolute, 32),\n            elf::R_390_64 => (RelocationKind::Absolute, 64),\n            elf::R_390_PC16 => (RelocationKind::Relative, 16),\n            elf::R_390_PC32 => (RelocationKind::Relative, 32),\n            elf::R_390_PC64 => (RelocationKind::Relative, 64),\n            elf::R_390_PC16DBL => {\n                encoding = RelocationEncoding::S390xDbl;\n                (RelocationKind::Relative, 16)\n            }\n            elf::R_390_PC32DBL => {\n                encoding = RelocationEncoding::S390xDbl;\n                (RelocationKind::Relative, 32)\n            }\n            elf::R_390_PLT16DBL => {\n                encoding = RelocationEncoding::S390xDbl;\n                (RelocationKind::PltRelative, 16)\n            }\n            elf::R_390_PLT32DBL => {\n                encoding = RelocationEncoding::S390xDbl;\n                (RelocationKind::PltRelative, 32)\n            }\n            elf::R_390_GOT16 => (RelocationKind::Got, 16),\n            elf::R_390_GOT32 => (RelocationKind::Got, 32),\n            elf::R_390_GOT64 => (RelocationKind::Got, 64),\n            elf::R_390_GOTENT => {\n                encoding = RelocationEncoding::S390xDbl;\n                (RelocationKind::GotRelative, 32)\n            }\n            elf::R_390_GOTOFF16 => (RelocationKind::GotBaseOffset, 16),\n            elf::R_390_GOTOFF32 => (RelocationKind::GotBaseOffset, 32),\n            elf::R_390_GOTOFF64 => (RelocationKind::GotBaseOffset, 64),\n            elf::R_390_GOTPC => (RelocationKind::GotBaseRelative, 64),\n            elf::R_390_GOTPCDBL => {\n                encoding = RelocationEncoding::S390xDbl;\n                (RelocationKind::GotBaseRelative, 32)\n            }\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_SPARC | elf::EM_SPARC32PLUS | elf::EM_SPARCV9 => {\n            match reloc.r_type(endian, false) {\n                elf::R_SPARC_32 | elf::R_SPARC_UA32 => (RelocationKind::Absolute, 32),\n                elf::R_SPARC_64 | elf::R_SPARC_UA64 => (RelocationKind::Absolute, 64),\n                r_type => (RelocationKind::Elf(r_type), 0),\n            }\n        }\n        _ => (RelocationKind::Elf(reloc.r_type(endian, false)), 0),\n    };\n    let sym = reloc.r_sym(endian, is_mips64el) as usize;\n    let target = if sym == 0 {\n        RelocationTarget::Absolute\n    } else {\n        RelocationTarget::Symbol(SymbolIndex(sym))\n    };\n    Relocation {\n        kind,\n        encoding,\n        size,\n        target,\n        addend: reloc.r_addend(endian).into(),\n        implicit_addend,\n    }\n}", "item_id": 0, "repo": "phip1611/object", "file": "src/read/elf/relocation.rs", "last_update_at": "2021-11-27T01:35:50+00:00", "question_id": "d3e24b2e8db00b6f5c8dfe99fc0bbb30a1f9b561_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_relocation<Elf: FileHeader>(\n    header: &Elf,\n    endian: Elf::Endian,\n    reloc: Elf::Rela,\n    implicit_addend: bool,\n) -> Relocation {\n    let mut encoding = RelocationEncoding::Generic;\n    let is_mips64el = header.is_mips64el(endian);\n    let (kind, size) = match header.e_machine(endian) {\n        elf::EM_AARCH64 => match reloc.r_type(endian, false) {\n            elf::R_AARCH64_ABS64 => (RelocationKind::Absolute, 64),\n            elf::R_AARCH64_ABS32 => (RelocationKind::Absolute, 32),\n            elf::R_AARCH64_ABS16 => (RelocationKind::Absolute, 16),\n            elf::R_AARCH64_PREL64 => (RelocationKind::Relative, 64),\n            elf::R_AARCH64_PREL32 => (RelocationKind::Relative, 32),\n            elf::R_AARCH64_PREL16 => (RelocationKind::Relative, 16),\n            elf::R_AARCH64_CALL26 => {\n                encoding = RelocationEncoding::AArch64Call;\n                (RelocationKind::PltRelative, 26)\n            }\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_ARM => match reloc.r_type(endian, false) {\n            elf::R_ARM_ABS32 => (RelocationKind::Absolute, 32),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_AVR => match reloc.r_type(endian, false) {\n            elf::R_AVR_32 => (RelocationKind::Absolute, 32),\n            elf::R_AVR_16 => (RelocationKind::Absolute, 16),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_BPF => match reloc.r_type(endian, false) {\n            elf::R_BPF_64_64 => (RelocationKind::Absolute, 64),\n            elf::R_BPF_64_32 => (RelocationKind::Absolute, 32),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_386 => match reloc.r_type(endian, false) {\n            elf::R_386_32 => (RelocationKind::Absolute, 32),\n            elf::R_386_PC32 => (RelocationKind::Relative, 32),\n            elf::R_386_GOT32 => (RelocationKind::Got, 32),\n            elf::R_386_PLT32 => (RelocationKind::PltRelative, 32),\n            elf::R_386_GOTOFF => (RelocationKind::GotBaseOffset, 32),\n            elf::R_386_GOTPC => (RelocationKind::GotBaseRelative, 32),\n            elf::R_386_16 => (RelocationKind::Absolute, 16),\n            elf::R_386_PC16 => (RelocationKind::Relative, 16),\n            elf::R_386_8 => (RelocationKind::Absolute, 8),\n            elf::R_386_PC8 => (RelocationKind::Relative, 8),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_X86_64 => match reloc.r_type(endian, false) {\n            elf::R_X86_64_64 => (RelocationKind::Absolute, 64),\n            elf::R_X86_64_PC32 => (RelocationKind::Relative, 32),\n            elf::R_X86_64_GOT32 => (RelocationKind::Got, 32),\n            elf::R_X86_64_PLT32 => (RelocationKind::PltRelative, 32),\n            elf::R_X86_64_GOTPCREL => (RelocationKind::GotRelative, 32),\n            elf::R_X86_64_32 => (RelocationKind::Absolute, 32),\n            elf::R_X86_64_32S => {\n                encoding = RelocationEncoding::X86Signed;\n                (RelocationKind::Absolute, 32)\n            }\n            elf::R_X86_64_16 => (RelocationKind::Absolute, 16),\n            elf::R_X86_64_PC16 => (RelocationKind::Relative, 16),\n            elf::R_X86_64_8 => (RelocationKind::Absolute, 8),\n            elf::R_X86_64_PC8 => (RelocationKind::Relative, 8),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_HEXAGON => match reloc.r_type(endian, false) {\n            elf::R_HEX_32 => (RelocationKind::Absolute, 32),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_MIPS => match reloc.r_type(endian, is_mips64el) {\n            elf::R_MIPS_16 => (RelocationKind::Absolute, 16),\n            elf::R_MIPS_32 => (RelocationKind::Absolute, 32),\n            elf::R_MIPS_64 => (RelocationKind::Absolute, 64),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_MSP430 => match reloc.r_type(endian, false) {\n            elf::R_MSP430_32 => (RelocationKind::Absolute, 32),\n            elf::R_MSP430_16_BYTE => (RelocationKind::Absolute, 16),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_PPC => match reloc.r_type(endian, false) {\n            elf::R_PPC_ADDR32 => (RelocationKind::Absolute, 32),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_PPC64 => match reloc.r_type(endian, false) {\n            elf::R_PPC64_ADDR32 => (RelocationKind::Absolute, 32),\n            elf::R_PPC64_ADDR64 => (RelocationKind::Absolute, 64),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_RISCV => match reloc.r_type(endian, false) {\n            elf::R_RISCV_32 => (RelocationKind::Absolute, 32),\n            elf::R_RISCV_64 => (RelocationKind::Absolute, 64),\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_S390 => match reloc.r_type(endian, false) {\n            elf::R_390_8 => (RelocationKind::Absolute, 8),\n            elf::R_390_16 => (RelocationKind::Absolute, 16),\n            elf::R_390_32 => (RelocationKind::Absolute, 32),\n            elf::R_390_64 => (RelocationKind::Absolute, 64),\n            elf::R_390_PC16 => (RelocationKind::Relative, 16),\n            elf::R_390_PC32 => (RelocationKind::Relative, 32),\n            elf::R_390_PC64 => (RelocationKind::Relative, 64),\n            elf::R_390_PC16DBL => {\n                encoding = RelocationEncoding::S390xDbl;\n                (RelocationKind::Relative, 16)\n            }\n            elf::R_390_PC32DBL => {\n                encoding = RelocationEncoding::S390xDbl;\n                (RelocationKind::Relative, 32)\n            }\n            elf::R_390_PLT16DBL => {\n                encoding = RelocationEncoding::S390xDbl;\n                (RelocationKind::PltRelative, 16)\n            }\n            elf::R_390_PLT32DBL => {\n                encoding = RelocationEncoding::S390xDbl;\n                (RelocationKind::PltRelative, 32)\n            }\n            elf::R_390_GOT16 => (RelocationKind::Got, 16),\n            elf::R_390_GOT32 => (RelocationKind::Got, 32),\n            elf::R_390_GOT64 => (RelocationKind::Got, 64),\n            elf::R_390_GOTENT => {\n                encoding = RelocationEncoding::S390xDbl;\n                (RelocationKind::GotRelative, 32)\n            }\n            elf::R_390_GOTOFF16 => (RelocationKind::GotBaseOffset, 16),\n            elf::R_390_GOTOFF32 => (RelocationKind::GotBaseOffset, 32),\n            elf::R_390_GOTOFF64 => (RelocationKind::GotBaseOffset, 64),\n            elf::R_390_GOTPC => (RelocationKind::GotBaseRelative, 64),\n            elf::R_390_GOTPCDBL => {\n                encoding = RelocationEncoding::S390xDbl;\n                (RelocationKind::GotBaseRelative, 32)\n            }\n            r_type => (RelocationKind::Elf(r_type), 0),\n        },\n        elf::EM_SPARC | elf::EM_SPARC32PLUS | elf::EM_SPARCV9 => {\n            match reloc.r_type(endian, false) {\n                elf::R_SPARC_32 | elf::R_SPARC_UA32 => (RelocationKind::Absolute, 32),\n                elf::R_SPARC_64 | elf::R_SPARC_UA64 => (RelocationKind::Absolute, 64),\n                r_type => (RelocationKind::Elf(r_type), 0),\n            }\n        }\n        _ => (RelocationKind::Elf(reloc.r_type(endian, false)), 0),\n    };\n    let sym = reloc.r_sym(endian, is_mips64el) as usize;\n    let target = if sym == 0 {\n        RelocationTarget::Absolute\n    } else {\n        RelocationTarget::Symbol(SymbolIndex(sym))\n    };\n    Relocation {\n        kind,\n        encoding,\n        size,\n        target,\n        addend: reloc.r_addend(endian).into(),\n        implicit_addend,\n    }\n"]], "pred": {"ppl": 1.2245582342147827, "ppl_lower": 1.3549284934997559, "ppl/lowercase_ppl": -1.49939998997442, "ppl/zlib": 0.0001993899151821071, "Min_5.0% Prob": 3.3293097767175412, "Min_10.0% Prob": 1.9231260794342733, "Min_20.0% Prob": 1.0082106865376381, "Min_30.0% Prob": 0.6762258266372716, "Min_40.0% Prob": 0.5064996162026411, "Min_50.0% Prob": 0.40551224930659335, "Min_60.0% Prob": 0.3380641461048588}}
{"hexsha": "76ef5465b6b52dd4e9b1cf90c2416cf75368a392", "ext": "rs", "lang": "Rust", "content": "fn id_is_optional() {\n        let raw_schema = r#\"{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"description\": \"A product from Acme's catalog\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"productId\": {\n        \"description\": \"The unique identifier for a product\",\n        \"type\": \"integer\"\n        }\n    },\n    \"required\": [ \"productId\" ]\n    }\"#;\n\n        let schema = Schema::try_from(raw_schema).unwrap();\n        println!(\"{:#?}\", schema);\n        assert!(schema.id().is_none());\n    }", "item_id": 15, "repo": "hoodie/serde-json-schema", "file": "tests/lib.rs", "last_update_at": "2021-12-04T04:04:32+00:00", "question_id": "76ef5465b6b52dd4e9b1cf90c2416cf75368a392_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn id_is_optional() {\n        let raw_schema = r#\"{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"description\": \"A product from Acme's catalog\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"productId\": {\n        \"description\": \"The unique identifier for a product\",\n        \"type\": \"integer\"\n        }\n    },\n    \"required\": [ \"productId\" ]\n    }\"#;\n        let schema = Schema::try_from(raw_schema).unwrap();\n        println!(\"{:#?}\", schema);\n        assert!(schema.id().is_none());\n"]], "pred": {"ppl": 1.8902168273925781, "ppl_lower": 2.2048683166503906, "ppl/lowercase_ppl": -1.24183804821721, "ppl/zlib": 0.002249793448690641, "Min_5.0% Prob": 6.491853415966034, "Min_10.0% Prob": 4.739137530326843, "Min_20.0% Prob": 2.909854161016869, "Min_30.0% Prob": 2.0901393233513343, "Min_40.0% Prob": 1.5849503516925103, "Min_50.0% Prob": 1.2687559488667064, "Min_60.0% Prob": 1.0661363974966185}}
{"hexsha": "c3091368183bf9cfc7deeb2d56dcedc89f220b57", "ext": "rs", "lang": "Rust", "content": "fn it_works() {\n    let builder = SqlSessionFactoryBuilder::build();\n    let mut session = builder.open_session();\n    let res = select_one!(session, \"UserDao.queryUserInfoById\", 1u64).unwrap();\n    println!(\"{:?}\", res);\n}", "item_id": 0, "repo": "Forsworns/design-pattern", "file": "mediator/tests/test.rs", "last_update_at": "2021-07-14T23:56:53+00:00", "question_id": "c3091368183bf9cfc7deeb2d56dcedc89f220b57_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn it_works() {\n    let builder = SqlSessionFactoryBuilder::build();\n    let mut session = builder.open_session();\n    let res = select_one!(session, \"UserDao.queryUserInfoById\", 1u64).unwrap();\n    println!(\"{:?}\", res);\n"]], "pred": {"ppl": 5.413581371307373, "ppl_lower": 7.3789143562316895, "ppl/lowercase_ppl": -1.1833818842657695, "ppl/zlib": 0.010298236980722663, "Min_5.0% Prob": 8.842227300008139, "Min_10.0% Prob": 8.174349239894322, "Min_20.0% Prob": 6.173479659216745, "Min_30.0% Prob": 4.801675711359296, "Min_40.0% Prob": 3.8985980238233293, "Min_50.0% Prob": 3.254575590576444, "Min_60.0% Prob": 2.7634914261954173}}
{"hexsha": "2fa1192c84ae3a79653c24debd50b5f53db84dba", "ext": "rs", "lang": "Rust", "content": "fn select(array: &mut [isize], left: usize, right: usize, k: usize) -> isize {\n    let mut pivot_index;\n    let (mut left, mut right) = (left, right);\n    loop {\n        if left == right {\n            return array[left];\n        }\n        pivot_index = thread_rng().gen_range(left, right);\n        pivot_index = partition(array, left, right, pivot_index);\n        if pivot_index == k {\n            return array[k];\n        } else if pivot_index < k {\n            left = pivot_index + 1;\n        } else {\n            right = pivot_index - 1;\n        }\n    }\n}", "item_id": 2, "repo": "Ninjani/rosalind", "file": "a_med/src/lib.rs", "last_update_at": "2021-09-17T20:50:36+00:00", "question_id": "2fa1192c84ae3a79653c24debd50b5f53db84dba_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn select(array: &mut [isize], left: usize, right: usize, k: usize) -> isize {\n    let mut pivot_index;\n    let (mut left, mut right) = (left, right);\n    loop {\n        if left == right {\n            return array[left];\n        }\n        pivot_index = thread_rng().gen_range(left, right);\n        pivot_index = partition(array, left, right, pivot_index);\n        if pivot_index == k {\n            return array[k];\n        } else if pivot_index < k {\n            left = pivot_index + 1;\n        } else {\n            right = pivot_index - 1;\n        }\n    }\n"]], "pred": {"ppl": 1.6652612686157227, "ppl_lower": 1.6652612686157227, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.002226995760740493, "Min_5.0% Prob": 5.921992659568787, "Min_10.0% Prob": 3.9697868333143345, "Min_20.0% Prob": 2.357374694417505, "Min_30.0% Prob": 1.6572431045082898, "Min_40.0% Prob": 1.2723244353049044, "Min_50.0% Prob": 1.0158197398714979, "Min_60.0% Prob": 0.8518607150584173}}
{"hexsha": "48af2f1ade1104e61a8b202d5b6e268fb3f33361", "ext": "rs", "lang": "Rust", "content": "pub fn divergent_series(x:f64, max_n:u64) -> f64{\n    //starts off iteration zero.\n    let mut nfact_xn = 1.0;\n    let mut sum = nfact_xn;\n    let mut diff = std::f64::INFINITY;\n    let mut first_sum = sum;\n    for n in 1..max_n{\n        nfact_xn *= (n as f64 / x);\n        //nfact_xn /= x;\n        let last_sum = sum;\n        sum += nfact_xn;\n        //creates a \"U\" of precision to approximation, so we need to figure out when we're \"out\" of the U\n        //see https://en.wikipedia.org/wiki/Asymptotic_expansion#:~:text=In%20mathematics%2C%20an%20asymptotic%20expansion,the%20function%20tends%20towards%20a\n        let new_diff = (last_sum - sum).abs();\n        if new_diff > diff{\n            sum = first_sum;\n            break;\n        }else{\n            first_sum = last_sum;\n            diff = new_diff;\n        }\n    }\n    (x.exp()/x)*sum\n}", "item_id": 2, "repo": "Cazadorro/sfal", "file": "src/ei.rs", "last_update_at": "2021-03-02T09:06:41+00:00", "question_id": "48af2f1ade1104e61a8b202d5b6e268fb3f33361_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn divergent_series(x:f64, max_n:u64) -> f64{\n    //starts off iteration zero.\n    let mut nfact_xn = 1.0;\n    let mut sum = nfact_xn;\n    let mut diff = std::f64::INFINITY;\n    let mut first_sum = sum;\n    for n in 1..max_n{\n        nfact_xn *= (n as f64 / x);\n        //nfact_xn /= x;\n        let last_sum = sum;\n        sum += nfact_xn;\n        //creates a \"U\" of precision to approximation, so we need to figure out when we're \"out\" of the U\n        //see https://en.wikipedia.org/wiki/Asymptotic_expansion#:~:text=In%20mathematics%2C%20an%20asymptotic%20expansion,the%20function%20tends%20towards%20a\n        let new_diff = (last_sum - sum).abs();\n        if new_diff > diff{\n            sum = first_sum;\n            break;\n        }else{\n            first_sum = last_sum;\n            diff = new_diff;\n        }\n    }\n    (x.exp()/x)*sum\n"]], "pred": {"ppl": 3.159846544265747, "ppl_lower": 3.5496511459350586, "ppl/lowercase_ppl": -1.101106903962405, "ppl/zlib": 0.0026570980703889886, "Min_5.0% Prob": 8.511945605278015, "Min_10.0% Prob": 6.4796320958571, "Min_20.0% Prob": 4.758861870476694, "Min_30.0% Prob": 3.6265608541893237, "Min_40.0% Prob": 2.8247620844931314, "Min_50.0% Prob": 2.2915422640063547, "Min_60.0% Prob": 1.9182655990801074}}
{"hexsha": "7e55261a1248777eef0aae82a8393788fc023fde", "ext": "rs", "lang": "Rust", "content": "pub(super) fn handle_prev_state<'i>(\n    tetraplet: &RSecurityTetraplet,\n    output: &CallOutputValue<'i>,\n    prev_result: CallResult,\n    trace_pos: usize,\n    exec_ctx: &mut ExecutionCtx<'i>,\n    trace_ctx: &mut TraceHandler,\n) -> ExecutionResult<bool> {\n    use CallResult::*;\n\n    let result = match &prev_result {\n        // this call was failed on one of the previous executions,\n        // here it's needed to bubble this special error up\n        CallServiceFailed(ret_code, err_msg) => {\n            exec_ctx.subtree_complete = false;\n            exec_err!(ExecutionError::LocalServiceError(*ret_code, err_msg.clone()))\n        }\n        RequestSentBy(Sender::PeerIdWithCallId { peer_id, call_id })\n            if peer_id.as_str() == exec_ctx.current_peer_id.as_str() =>\n        {\n            // call results are identified by call_id that is saved in data\n            match exec_ctx.call_results.remove(call_id) {\n                Some(call_result) => {\n                    update_state_with_service_result(tetraplet, output, call_result, exec_ctx, trace_ctx)?;\n                    return Ok(false);\n                }\n                // result hasn't been prepared yet\n                None => {\n                    exec_ctx.subtree_complete = false;\n                    Ok(false)\n                }\n            }\n        }\n        RequestSentBy(..) => {\n            // check whether current node can execute this call\n            let is_current_peer = tetraplet.borrow().triplet.peer_pk.as_str() == exec_ctx.current_peer_id.as_str();\n            if is_current_peer {\n                // if this peer could execute this call early return and\n                return Ok(true);\n            }\n\n            exec_ctx.subtree_complete = false;\n            Ok(false)\n        }\n        // this instruction's been already executed\n        Executed(value) => {\n            set_result_from_value(value.clone(), tetraplet.clone(), trace_pos, output, exec_ctx)?;\n\n            exec_ctx.subtree_complete = true;\n            Ok(false)\n        }\n    };\n\n    trace_ctx.meet_call_end(prev_result);\n    result\n}", "item_id": 0, "repo": "fluencelabs/aquamarine", "file": "air/src/execution_step/air/call/prev_result_handler.rs", "last_update_at": "2021-04-10T15:02:25+00:00", "question_id": "7e55261a1248777eef0aae82a8393788fc023fde_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(super) fn handle_prev_state<'i>(\n    tetraplet: &RSecurityTetraplet,\n    output: &CallOutputValue<'i>,\n    prev_result: CallResult,\n    trace_pos: usize,\n    exec_ctx: &mut ExecutionCtx<'i>,\n    trace_ctx: &mut TraceHandler,\n) -> ExecutionResult<bool> {\n    use CallResult::*;\n    let result = match &prev_result {\n        // this call was failed on one of the previous executions,\n        // here it's needed to bubble this special error up\n        CallServiceFailed(ret_code, err_msg) => {\n            exec_ctx.subtree_complete = false;\n            exec_err!(ExecutionError::LocalServiceError(*ret_code, err_msg.clone()))\n        }\n        RequestSentBy(Sender::PeerIdWithCallId { peer_id, call_id })\n            if peer_id.as_str() == exec_ctx.current_peer_id.as_str() =>\n        {\n            // call results are identified by call_id that is saved in data\n            match exec_ctx.call_results.remove(call_id) {\n                Some(call_result) => {\n                    update_state_with_service_result(tetraplet, output, call_result, exec_ctx, trace_ctx)?;\n                    return Ok(false);\n                }\n                // result hasn't been prepared yet\n                None => {\n                    exec_ctx.subtree_complete = false;\n                    Ok(false)\n                }\n            }\n        }\n        RequestSentBy(..) => {\n            // check whether current node can execute this call\n            let is_current_peer = tetraplet.borrow().triplet.peer_pk.as_str() == exec_ctx.current_peer_id.as_str();\n            if is_current_peer {\n                // if this peer could execute this call early return and\n                return Ok(true);\n            }\n            exec_ctx.subtree_complete = false;\n            Ok(false)\n        }\n        // this instruction's been already executed\n        Executed(value) => {\n            set_result_from_value(value.clone(), tetraplet.clone(), trace_pos, output, exec_ctx)?;\n            exec_ctx.subtree_complete = true;\n            Ok(false)\n        }\n    };\n    trace_ctx.meet_call_end(prev_result);\n    result\n"]], "pred": {"ppl": 3.807379722595215, "ppl_lower": 4.29494047164917, "ppl/lowercase_ppl": -1.0901284800858035, "ppl/zlib": 0.0017228623913498537, "Min_5.0% Prob": 8.707553323109945, "Min_10.0% Prob": 7.137008315227071, "Min_20.0% Prob": 5.234784868896985, "Min_30.0% Prob": 4.045225685411464, "Min_40.0% Prob": 3.2264293959883394, "Min_50.0% Prob": 2.649275736730607, "Min_60.0% Prob": 2.227229158735015}}
{"hexsha": "4e2824d986e6d827234318dfe6bb12f7ed91a1be", "ext": "rs", "lang": "Rust", "content": "fn test_parse_header() -> Result<(), VCFError> {\r\n    let mut simple1_vcf = BufReader::new(&include_bytes!(\"../../testfiles/simple1.vcf\")[..]);\r\n\r\n    let (line_count, unprocessed_line, header) = parse_header(&mut simple1_vcf)?;\r\n    assert_eq!(line_count, 20);\r\n    assert_eq!(unprocessed_line, None);\r\n\r\n    assert_eq!(\r\n        header.samples,\r\n        vec![\r\n            b\"ERP001775_HiSeq2000_SAMEA1531955-1\".to_vec(),\r\n            b\"ERP001775_HiSeq2000_SAMEA1531955-2\".to_vec()\r\n        ]\r\n    );\r\n\r\n    let expected_items = vec![\r\n            VCFHeaderLine {\r\n                line: b\"##fileformat=VCFv4.2\\n\".to_vec(),\r\n                contents: VCFHeaderContent::FileFormat(VCFVersion::Vcf4_2)\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##FILTER=<ID=PASS,Description=\\\"All filters passed\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::FILTER{\r\n                    id: b\"PASS\".to_vec(),\r\n                    description: b\"All filters passed\".to_vec()\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##ALT=<ID=NON_REF,Description=\\\"Represents any possible alternative allele at this location\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::ALT{\r\n                    id: b\"NON_REF\".to_vec(),\r\n                    description: b\"Represents any possible alternative allele at this location\".to_vec()\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##FILTER=<ID=LowQual,Description=\\\"Low quality\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::FILTER{\r\n                    id: b\"LowQual\".to_vec(),\r\n                    description: b\"Low quality\".to_vec()\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##FORMAT=<ID=AD,Number=R,Type=Integer,Description=\\\"Allelic depths for the ref and alt alleles in the order listed\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::FORMAT{\r\n                    id: b\"AD\".to_vec(),\r\n                    number: Number::Reference,\r\n                    value_type: ValueType::Integer,\r\n                    description: b\"Allelic depths for the ref and alt alleles in the order listed\".to_vec(),\r\n                    source: None,\r\n                    version: None,\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##FORMAT=<ID=DP,Number=1,Type=Integer,Description=\\\"Approximate read depth (reads with MQ=255 or with bad mates are filtered)\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::FORMAT{\r\n                    id: b\"DP\".to_vec(),\r\n                    number: Number::Number(1),\r\n                    value_type: ValueType::Integer,\r\n                    description: b\"Approximate read depth (reads with MQ=255 or with bad mates are filtered)\".to_vec(),\r\n                    source: None,\r\n                    version: None,\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##FORMAT=<ID=GT,Number=1,Type=String,Description=\\\"Genotype\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::FORMAT{\r\n                    id: b\"GT\".to_vec(),\r\n                    number: Number::Number(1),\r\n                    value_type: ValueType::String,\r\n                    description: b\"Genotype\".to_vec(),\r\n                    source: None,\r\n                    version: None,\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##GATKCommandLine=<ID=HaplotypeCaller,CommandLine=\\\"HaplotypeCaller  --contamination-fraction-to-filter 0.0 --emit-ref-confidence GVCF --output ERP001775_HiSeq2000_SAMEA1531955-1.hs37d5.g.vcf.gz --intervals /cromwell-executions/VariantCall/6f09e738-2160-49dd-8287-ff8ef9368d27/call-HaplotypeCaller/shard-20/inputs/1101158470/0020-scattered.interval_list --input /cromwell-executions/VariantCall/6f09e738-2160-49dd-8287-ff8ef9368d27/call-HaplotypeCaller/shard-20/inputs/-929370236/ERP001775_HiSeq2000_SAMEA1531955-1.hs37d5.bam --reference /cromwell-executions/VariantCall/6f09e738-2160-49dd-8287-ff8ef9368d27/call-HaplotypeCaller/shard-20/inputs/865204270/hs37d5.fa  --use-new-qual-calculator true --use-old-qual-calculator false --annotate-with-num-discovered-alleles false --heterozygosity 0.001 --indel-heterozygosity 1.25E-4 --heterozygosity-stdev 0.01 --standard-min-confidence-threshold-for-calling 30.0 --max-alternate-alleles 6 --max-genotype-count 1024 --sample-ploidy 2 --num-reference-samples-if-no-call 0 --genotyping-mode DISCOVERY --genotype-filtered-alleles false --output-mode EMIT_VARIANTS_ONLY --all-site-pls false --gvcf-gq-bands 1 --gvcf-gq-bands 2 --gvcf-gq-bands 3 --gvcf-gq-bands 4 --gvcf-gq-bands 5 --gvcf-gq-bands 6 --gvcf-gq-bands 7 --gvcf-gq-bands 8 --gvcf-gq-bands 9 --gvcf-gq-bands 10 --gvcf-gq-bands 11 --gvcf-gq-bands 12 --gvcf-gq-bands 13 --gvcf-gq-bands 14 --gvcf-gq-bands 15 --gvcf-gq-bands 16 --gvcf-gq-bands 17 --gvcf-gq-bands 18 --gvcf-gq-bands 19 --gvcf-gq-bands 20 --gvcf-gq-bands 21 --gvcf-gq-bands 22 --gvcf-gq-bands 23 --gvcf-gq-bands 24 --gvcf-gq-bands 25 --gvcf-gq-bands 26 --gvcf-gq-bands 27 --gvcf-gq-bands 28 --gvcf-gq-bands 29 --gvcf-gq-bands 30 --gvcf-gq-bands 31 --gvcf-gq-bands 32 --gvcf-gq-bands 33 --gvcf-gq-bands 34 --gvcf-gq-bands 35 --gvcf-gq-bands 36 --gvcf-gq-bands 37 --gvcf-gq-bands 38 --gvcf-gq-bands 39 --gvcf-gq-bands 40 --gvcf-gq-bands 41 --gvcf-gq-bands 42 --gvcf-gq-bands 43 --gvcf-gq-bands 44 --gvcf-gq-bands 45 --gvcf-gq-bands 46 --gvcf-gq-bands 47 --gvcf-gq-bands 48 --gvcf-gq-bands 49 --gvcf-gq-bands 50 --gvcf-gq-bands 51 --gvcf-gq-bands 52 --gvcf-gq-bands 53 --gvcf-gq-bands 54 --gvcf-gq-bands 55 --gvcf-gq-bands 56 --gvcf-gq-bands 57 --gvcf-gq-bands 58 --gvcf-gq-bands 59 --gvcf-gq-bands 60 --gvcf-gq-bands 70 --gvcf-gq-bands 80 --gvcf-gq-bands 90 --gvcf-gq-bands 99 --floor-blocks false --indel-size-to-eliminate-in-ref-model 10 --use-alleles-trigger false --disable-optimizations false --just-determine-active-regions false --dont-genotype false --do-not-run-physical-phasing false --use-filtered-reads-for-annotations false --correct-overlapping-quality false --adaptive-pruning false --do-not-recover-dangling-branches false --recover-dangling-heads false --consensus false --dont-trim-active-regions false --max-disc-ar-extension 25 --max-gga-ar-extension 300 --padding-around-indels 150 --padding-around-snps 20 --kmer-size 10 --kmer-size 25 --dont-increase-kmer-sizes-for-cycles false --allow-non-unique-kmers-in-ref false --num-pruning-samples 1 --min-dangling-branch-length 4 --recover-all-dangling-branches false --max-num-haplotypes-in-population 128 --min-pruning 2 --adaptive-pruning-initial-error-rate 0.001 --pruning-lod-threshold 2.302585092994046 --max-unpruned-variants 100 --debug-assembly false --debug-graph-transformations false --capture-assembly-failure-bam false --error-correct-reads false --kmer-length-for-read-error-correction 25 --min-observations-for-kmer-to-be-solid 20 --likelihood-calculation-engine PairHMM --base-quality-score-threshold 18 --pair-hmm-gap-continuation-penalty 10 --pair-hmm-implementation FASTEST_AVAILABLE --pcr-indel-model CONSERVATIVE --phred-scaled-global-read-mismapping-rate 45 --native-pair-hmm-threads 4 --native-pair-hmm-use-double-precision false --bam-writer-type CALLED_HAPLOTYPES --dont-use-soft-clipped-bases false --min-base-quality-score 10 --smith-waterman JAVA --max-mnp-distance 0 --min-assembly-region-size 50 --max-assembly-region-size 300 --assembly-region-padding 100 --max-reads-per-alignment-start 50 --active-probability-threshold 0.002 --max-prob-propagation-distance 50 --force-active false --interval-set-rule UNION --interval-padding 0 --interval-exclusion-padding 0 --interval-merging-rule ALL --read-validation-stringency SILENT --seconds-between-progress-updates 10.0 --disable-sequence-dictionary-validation false --create-output-bam-index true --create-output-bam-md5 false --create-output-variant-index true --create-output-variant-md5 false --lenient false --add-output-sam-program-record true --add-output-vcf-command-line true --cloud-prefetch-buffer 40 --cloud-index-prefetch-buffer -1 --disable-bam-index-caching false --sites-only-vcf-output false --help false --version false --showHidden false --verbosity INFO --QUIET false --use-jdk-deflater false --use-jdk-inflater false --gcs-max-retries 20 --gcs-project-for-requester-pays  --disable-tool-default-read-filters false --minimum-mapping-quality 20 --disable-tool-default-annotations false --enable-all-annotations false --allow-old-rms-mapping-quality-annotation-data false\\\",Version=\\\"4.1.3.0\\\",Date=\\\"October 3, 2019 5:19:41 PM UTC\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::Other\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##INFO=<ID=AC,Number=A,Type=Integer,Description=\\\"Allele count in genotypes, for each ALT allele, in the same order as listed\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::INFO{\r\n                    id: b\"AC\".to_vec(),\r\n                    number: Number::Allele,\r\n                    value_type: ValueType::Integer,\r\n                    description: b\"Allele count in genotypes, for each ALT allele, in the same order as listed\".to_vec(),\r\n                    source: None,\r\n                    version: None,\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##INFO=<ID=AF,Number=A,Type=Float,Description=\\\"Allele Frequency, for each ALT allele, in the same order as listed\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::INFO{\r\n                    id: b\"AF\".to_vec(),\r\n                    number: Number::Allele,\r\n                    value_type: ValueType::Float,\r\n                    description: b\"Allele Frequency, for each ALT allele, in the same order as listed\".to_vec(),\r\n                    source: None,\r\n                    version: None,\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##INFO=<ID=AN,Number=1,Type=Integer,Description=\\\"Total number of alleles in called genotypes\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::INFO{\r\n                    id: b\"AN\".to_vec(),\r\n                    number: Number::Number(1),\r\n                    value_type: ValueType::Integer,\r\n                    description: b\"Total number of alleles in called genotypes\".to_vec(),\r\n                    source: None,\r\n                    version: None,\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##INFO=<ID=DP,Number=1,Type=Integer,Description=\\\"Approximate read depth; some reads may have been filtered\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::INFO{\r\n                    id: b\"DP\".to_vec(),\r\n                    number: Number::Number(1),\r\n                    value_type: ValueType::Integer,\r\n                    description: b\"Approximate read depth; some reads may have been filtered\".to_vec(),\r\n                    source: None,\r\n                    version: None,\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##contig=<ID=13,length=115169878>\\n\".to_vec(),\r\n                contents: VCFHeaderContent::Contig {\r\n                    id: b\"13\".to_vec(),\r\n                    length: Some(115169878),\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##contig=<ID=14,length=107349540>\\n\".to_vec(),\r\n                contents: VCFHeaderContent::Contig {\r\n                    id: b\"14\".to_vec(),\r\n                    length: Some(107349540),\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##source=CombineGVCFs\\n\".to_vec(),\r\n                contents: VCFHeaderContent::Other\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##source=GenotypeGVCFs\\n\".to_vec(),\r\n                contents: VCFHeaderContent::Other\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##source=HaplotypeCaller\\n\".to_vec(),\r\n                contents: VCFHeaderContent::Other\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##bcftools_viewVersion=1.9+htslib-1.9\\n\".to_vec(),\r\n                contents: VCFHeaderContent::Other\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##bcftools_viewCommand=view -O z -o /tmp/NA12878-subset.vcf.gz -r 13:32889150-32975410,17:41194315-41277931 NA12878_comparison.genotyped.vcf.gz; Date=Sat Mar  7 20:29:56 2020\\n\".to_vec(),\r\n                contents: VCFHeaderContent::Other\r\n            }\r\n        ];\r\n\r\n    for (x, y) in expected_items.iter().zip(header.items.iter()) {\r\n        assert_eq!(x, y);\r\n    }\r\n    assert_eq!(expected_items.len(), header.items.len());\r\n\r\n    assert_eq!(\r\n        header.info(b\"AC\"),\r\n        Some(VCFHeaderInfoFormat {\r\n            id: b\"AC\",\r\n            number: &Number::Allele,\r\n            value_type: &ValueType::Integer,\r\n            description:\r\n                b\"Allele count in genotypes, for each ALT allele, in the same order as listed\",\r\n            source: None,\r\n            version: None,\r\n        })\r\n    );\r\n\r\n    assert_eq!(header.info(b\"XX\"), None);\r\n    assert_eq!(header.info_key.len(), 4);\r\n\r\n    assert_eq!(\r\n        header.format(b\"AD\"),\r\n        Some(VCFHeaderInfoFormat {\r\n            id: b\"AD\",\r\n            number: &Number::Reference,\r\n            value_type: &ValueType::Integer,\r\n            description: b\"Allelic depths for the ref and alt alleles in the order listed\",\r\n            source: None,\r\n            version: None,\r\n        })\r\n    );\r\n    assert_eq!(header.format(b\"AC\"), None);\r\n    assert_eq!(header.format_key.len(), 3);\r\n    assert_eq!(\r\n        header\r\n            .format_list()\r\n            .map(|x| -> &[u8] { &x })\r\n            .collect::<HashSet<&[u8]>>(),\r\n        [&b\"AD\"[..], &b\"DP\"[..], &b\"GT\"[..]]\r\n            .iter()\r\n            .cloned()\r\n            .collect::<HashSet<&[u8]>>()\r\n    );\r\n\r\n    assert_eq!(\r\n        header.filter(b\"LowQual\"),\r\n        Some(VCFHeaderFilterAlt {\r\n            id: b\"LowQual\",\r\n            description: b\"Low quality\",\r\n        })\r\n    );\r\n    assert_eq!(header.filter(b\"AC\"), None);\r\n    assert_eq!(header.filter_key.len(), 2);\r\n    assert_eq!(\r\n        header\r\n            .filter_list()\r\n            .map(|x| -> &[u8] { &x })\r\n            .collect::<HashSet<&[u8]>>(),\r\n        [&b\"PASS\"[..], &b\"LowQual\"[..]]\r\n            .iter()\r\n            .cloned()\r\n            .collect::<HashSet<&[u8]>>()\r\n    );\r\n\r\n    assert_eq!(header.alt(b\"DEL\"), None);\r\n    assert_eq!(header.alt_key.len(), 1);\r\n    assert_eq!(\r\n        header\r\n            .alt_list()\r\n            .map(|x| -> &[u8] { &x })\r\n            .collect::<HashSet<&[u8]>>(),\r\n        [&b\"NON_REF\"[..]]\r\n            .iter()\r\n            .cloned()\r\n            .collect::<HashSet<&[u8]>>()\r\n    );\r\n    assert_eq!(\r\n        header.alt(b\"NON_REF\"),\r\n        Some(VCFHeaderFilterAlt {\r\n            id: b\"NON_REF\",\r\n            description: b\"Represents any possible alternative allele at this location\",\r\n        })\r\n    );\r\n\r\n    Ok(())\r\n}", "item_id": 10, "repo": "informationsea/vcf-rs", "file": "src/header/test.rs", "last_update_at": "2021-10-06T07:13:06+00:00", "question_id": "4e2824d986e6d827234318dfe6bb12f7ed91a1be_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_parse_header() -> Result<(), VCFError> {\r\n    let mut simple1_vcf = BufReader::new(&include_bytes!(\"../../testfiles/simple1.vcf\")[..]);\r\n\r\n    let (line_count, unprocessed_line, header) = parse_header(&mut simple1_vcf)?;\r\n    assert_eq!(line_count, 20);\r\n    assert_eq!(unprocessed_line, None);\r\n\r\n    assert_eq!(\r\n        header.samples,\r\n        vec![\r\n            b\"ERP001775_HiSeq2000_SAMEA1531955-1\".to_vec(),\r\n            b\"ERP001775_HiSeq2000_SAMEA1531955-2\".to_vec()\r\n        ]\r\n    );\r\n\r\n    let expected_items = vec![\r\n            VCFHeaderLine {\r\n                line: b\"##fileformat=VCFv4.2\\n\".to_vec(),\r\n                contents: VCFHeaderContent::FileFormat(VCFVersion::Vcf4_2)\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##FILTER=<ID=PASS,Description=\\\"All filters passed\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::FILTER{\r\n                    id: b\"PASS\".to_vec(),\r\n                    description: b\"All filters passed\".to_vec()\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##ALT=<ID=NON_REF,Description=\\\"Represents any possible alternative allele at this location\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::ALT{\r\n                    id: b\"NON_REF\".to_vec(),\r\n                    description: b\"Represents any possible alternative allele at this location\".to_vec()\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##FILTER=<ID=LowQual,Description=\\\"Low quality\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::FILTER{\r\n                    id: b\"LowQual\".to_vec(),\r\n                    description: b\"Low quality\".to_vec()\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##FORMAT=<ID=AD,Number=R,Type=Integer,Description=\\\"Allelic depths for the ref and alt alleles in the order listed\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::FORMAT{\r\n                    id: b\"AD\".to_vec(),\r\n                    number: Number::Reference,\r\n                    value_type: ValueType::Integer,\r\n                    description: b\"Allelic depths for the ref and alt alleles in the order listed\".to_vec(),\r\n                    source: None,\r\n                    version: None,\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##FORMAT=<ID=DP,Number=1,Type=Integer,Description=\\\"Approximate read depth (reads with MQ=255 or with bad mates are filtered)\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::FORMAT{\r\n                    id: b\"DP\".to_vec(),\r\n                    number: Number::Number(1),\r\n                    value_type: ValueType::Integer,\r\n                    description: b\"Approximate read depth (reads with MQ=255 or with bad mates are filtered)\".to_vec(),\r\n                    source: None,\r\n                    version: None,\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##FORMAT=<ID=GT,Number=1,Type=String,Description=\\\"Genotype\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::FORMAT{\r\n                    id: b\"GT\".to_vec(),\r\n                    number: Number::Number(1),\r\n                    value_type: ValueType::String,\r\n                    description: b\"Genotype\".to_vec(),\r\n                    source: None,\r\n                    version: None,\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##GATKCommandLine=<ID=HaplotypeCaller,CommandLine=\\\"HaplotypeCaller  --contamination-fraction-to-filter 0.0 --emit-ref-confidence GVCF --output ERP001775_HiSeq2000_SAMEA1531955-1.hs37d5.g.vcf.gz --intervals /cromwell-executions/VariantCall/6f09e738-2160-49dd-8287-ff8ef9368d27/call-HaplotypeCaller/shard-20/inputs/1101158470/0020-scattered.interval_list --input /cromwell-executions/VariantCall/6f09e738-2160-49dd-8287-ff8ef9368d27/call-HaplotypeCaller/shard-20/inputs/-929370236/ERP001775_HiSeq2000_SAMEA1531955-1.hs37d5.bam --reference /cromwell-executions/VariantCall/6f09e738-2160-49dd-8287-ff8ef9368d27/call-HaplotypeCaller/shard-20/inputs/865204270/hs37d5.fa  --use-new-qual-calculator true --use-old-qual-calculator false --annotate-with-num-discovered-alleles false --heterozygosity 0.001 --indel-heterozygosity 1.25E-4 --heterozygosity-stdev 0.01 --standard-min-confidence-threshold-for-calling 30.0 --max-alternate-alleles 6 --max-genotype-count 1024 --sample-ploidy 2 --num-reference-samples-if-no-call 0 --genotyping-mode DISCOVERY --genotype-filtered-alleles false --output-mode EMIT_VARIANTS_ONLY --all-site-pls false --gvcf-gq-bands 1 --gvcf-gq-bands 2 --gvcf-gq-bands 3 --gvcf-gq-bands 4 --gvcf-gq-bands 5 --gvcf-gq-bands 6 --gvcf-gq-bands 7 --gvcf-gq-bands 8 --gvcf-gq-bands 9 --gvcf-gq-bands 10 --gvcf-gq-bands 11 --gvcf-gq-bands 12 --gvcf-gq-bands 13 --gvcf-gq-bands 14 --gvcf-gq-bands 15 --gvcf-gq-bands 16 --gvcf-gq-bands 17 --gvcf-gq-bands 18 --gvcf-gq-bands 19 --gvcf-gq-bands 20 --gvcf-gq-bands 21 --gvcf-gq-bands 22 --gvcf-gq-bands 23 --gvcf-gq-bands 24 --gvcf-gq-bands 25 --gvcf-gq-bands 26 --gvcf-gq-bands 27 --gvcf-gq-bands 28 --gvcf-gq-bands 29 --gvcf-gq-bands 30 --gvcf-gq-bands 31 --gvcf-gq-bands 32 --gvcf-gq-bands 33 --gvcf-gq-bands 34 --gvcf-gq-bands 35 --gvcf-gq-bands 36 --gvcf-gq-bands 37 --gvcf-gq-bands 38 --gvcf-gq-bands 39 --gvcf-gq-bands 40 --gvcf-gq-bands 41 --gvcf-gq-bands 42 --gvcf-gq-bands 43 --gvcf-gq-bands 44 --gvcf-gq-bands 45 --gvcf-gq-bands 46 --gvcf-gq-bands 47 --gvcf-gq-bands 48 --gvcf-gq-bands 49 --gvcf-gq-bands 50 --gvcf-gq-bands 51 --gvcf-gq-bands 52 --gvcf-gq-bands 53 --gvcf-gq-bands 54 --gvcf-gq-bands 55 --gvcf-gq-bands 56 --gvcf-gq-bands 57 --gvcf-gq-bands 58 --gvcf-gq-bands 59 --gvcf-gq-bands 60 --gvcf-gq-bands 70 --gvcf-gq-bands 80 --gvcf-gq-bands 90 --gvcf-gq-bands 99 --floor-blocks false --indel-size-to-eliminate-in-ref-model 10 --use-alleles-trigger false --disable-optimizations false --just-determine-active-regions false --dont-genotype false --do-not-run-physical-phasing false --use-filtered-reads-for-annotations false --correct-overlapping-quality false --adaptive-pruning false --do-not-recover-dangling-branches false --recover-dangling-heads false --consensus false --dont-trim-active-regions false --max-disc-ar-extension 25 --max-gga-ar-extension 300 --padding-around-indels 150 --padding-around-snps 20 --kmer-size 10 --kmer-size 25 --dont-increase-kmer-sizes-for-cycles false --allow-non-unique-kmers-in-ref false --num-pruning-samples 1 --min-dangling-branch-length 4 --recover-all-dangling-branches false --max-num-haplotypes-in-population 128 --min-pruning 2 --adaptive-pruning-initial-error-rate 0.001 --pruning-lod-threshold 2.302585092994046 --max-unpruned-variants 100 --debug-assembly false --debug-graph-transformations false --capture-assembly-failure-bam false --error-correct-reads false --kmer-length-for-read-error-correction 25 --min-observations-for-kmer-to-be-solid 20 --likelihood-calculation-engine PairHMM --base-quality-score-threshold 18 --pair-hmm-gap-continuation-penalty 10 --pair-hmm-implementation FASTEST_AVAILABLE --pcr-indel-model CONSERVATIVE --phred-scaled-global-read-mismapping-rate 45 --native-pair-hmm-threads 4 --native-pair-hmm-use-double-precision false --bam-writer-type CALLED_HAPLOTYPES --dont-use-soft-clipped-bases false --min-base-quality-score 10 --smith-waterman JAVA --max-mnp-distance 0 --min-assembly-region-size 50 --max-assembly-region-size 300 --assembly-region-padding 100 --max-reads-per-alignment-start 50 --active-probability-threshold 0.002 --max-prob-propagation-distance 50 --force-active false --interval-set-rule UNION --interval-padding 0 --interval-exclusion-padding 0 --interval-merging-rule ALL --read-validation-stringency SILENT --seconds-between-progress-updates 10.0 --disable-sequence-dictionary-validation false --create-output-bam-index true --create-output-bam-md5 false --create-output-variant-index true --create-output-variant-md5 false --lenient false --add-output-sam-program-record true --add-output-vcf-command-line true --cloud-prefetch-buffer 40 --cloud-index-prefetch-buffer -1 --disable-bam-index-caching false --sites-only-vcf-output false --help false --version false --showHidden false --verbosity INFO --QUIET false --use-jdk-deflater false --use-jdk-inflater false --gcs-max-retries 20 --gcs-project-for-requester-pays  --disable-tool-default-read-filters false --minimum-mapping-quality 20 --disable-tool-default-annotations false --enable-all-annotations false --allow-old-rms-mapping-quality-annotation-data false\\\",Version=\\\"4.1.3.0\\\",Date=\\\"October 3, 2019 5:19:41 PM UTC\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::Other\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##INFO=<ID=AC,Number=A,Type=Integer,Description=\\\"Allele count in genotypes, for each ALT allele, in the same order as listed\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::INFO{\r\n                    id: b\"AC\".to_vec(),\r\n                    number: Number::Allele,\r\n                    value_type: ValueType::Integer,\r\n                    description: b\"Allele count in genotypes, for each ALT allele, in the same order as listed\".to_vec(),\r\n                    source: None,\r\n                    version: None,\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##INFO=<ID=AF,Number=A,Type=Float,Description=\\\"Allele Frequency, for each ALT allele, in the same order as listed\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::INFO{\r\n                    id: b\"AF\".to_vec(),\r\n                    number: Number::Allele,\r\n                    value_type: ValueType::Float,\r\n                    description: b\"Allele Frequency, for each ALT allele, in the same order as listed\".to_vec(),\r\n                    source: None,\r\n                    version: None,\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##INFO=<ID=AN,Number=1,Type=Integer,Description=\\\"Total number of alleles in called genotypes\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::INFO{\r\n                    id: b\"AN\".to_vec(),\r\n                    number: Number::Number(1),\r\n                    value_type: ValueType::Integer,\r\n                    description: b\"Total number of alleles in called genotypes\".to_vec(),\r\n                    source: None,\r\n                    version: None,\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##INFO=<ID=DP,Number=1,Type=Integer,Description=\\\"Approximate read depth; some reads may have been filtered\\\">\\n\".to_vec(),\r\n                contents: VCFHeaderContent::INFO{\r\n                    id: b\"DP\".to_vec(),\r\n                    number: Number::Number(1),\r\n                    value_type: ValueType::Integer,\r\n                    description: b\"Approximate read depth; some reads may have been filtered\".to_vec(),\r\n                    source: None,\r\n                    version: None,\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##contig=<ID=13,length=115169878>\\n\".to_vec(),\r\n                contents: VCFHeaderContent::Contig {\r\n                    id: b\"13\".to_vec(),\r\n                    length: Some(115169878),\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##contig=<ID=14,length=107349540>\\n\".to_vec(),\r\n                contents: VCFHeaderContent::Contig {\r\n                    id: b\"14\".to_vec(),\r\n                    length: Some(107349540),\r\n                }\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##source=CombineGVCFs\\n\".to_vec(),\r\n                contents: VCFHeaderContent::Other\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##source=GenotypeGVCFs\\n\".to_vec(),\r\n                contents: VCFHeaderContent::Other\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##source=HaplotypeCaller\\n\".to_vec(),\r\n                contents: VCFHeaderContent::Other\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##bcftools_viewVersion=1.9+htslib-1.9\\n\".to_vec(),\r\n                contents: VCFHeaderContent::Other\r\n            },\r\n            VCFHeaderLine {\r\n                line: b\"##bcftools_viewCommand=view -O z -o /tmp/NA12878-subset.vcf.gz -r 13:32889150-32975410,17:41194315-41277931 NA12878_comparison.genotyped.vcf.gz; Date=Sat Mar  7 20:29:56 2020\\n\".to_vec(),\r\n                contents: VCFHeaderContent::Other\r\n            }\r\n        ];\r\n\r\n    for (x, y) in expected_items.iter().zip(header.items.iter()) {\r\n        assert_eq!(x, y);\r\n    }\r\n    assert_eq!(expected_items.len(), header.items.len());\r\n\r\n    assert_eq!(\r\n        header.info(b\"AC\"),\r\n        Some(VCFHeaderInfoFormat {\r\n            id: b\"AC\",\r\n            number: &Number::Allele,\r\n            value_type: &ValueType::Integer,\r\n            description:\r\n                b\"Allele count in genotypes, for each ALT allele, in the same order as listed\",\r\n            source: None,\r\n            version: None,\r\n        })\r\n    );\r\n\r\n    assert_eq!(header.info(b\"XX\"), None);\r\n    assert_eq!(header.info_key.len(), 4);\r\n\r\n    assert_eq!(\r\n        header.format(b\"AD\"),\r\n        Some(VCFHeaderInfoFormat {\r\n            id: b\"AD\",\r\n            number: &Number::Reference,\r\n            value_type: &ValueType::Integer,\r\n            description: b\"Allelic depths for the ref and alt alleles in the order listed\",\r\n            source: None,\r\n            version: None,\r\n        })\r\n    );\r\n    assert_eq!(header.format(b\"AC\"), None);\r\n    assert_eq!(header.format_key.len(), 3);\r\n    assert_eq!(\r\n        header\r\n            .format_list()\r\n            .map(|x| -> &[u8] { &x })\r\n            .collect::<HashSet<&[u8]>>(),\r\n        [&b\"AD\"[..], &b\"DP\"[..], &b\"GT\"[..]]\r\n            .iter()\r\n            .cloned()\r\n            .collect::<HashSet<&[u8]>>()\r\n    );\r\n\r\n    assert_eq!(\r\n        header.filter(b\"LowQual\"),\r\n        Some(VCFHeaderFilterAlt {\r\n            id: b\"LowQual\",\r\n            description: b\"Low quality\",\r\n        })\r\n    );\r\n    assert_eq!(header.filter(b\"AC\"), None);\r\n    assert_eq!(header.filter_key.len(), 2);\r\n    assert_eq!(\r\n        header\r\n            .filter_list()\r\n            .map(|x| -> &[u8] { &x })\r\n            .collect::<HashSet<&[u8]>>(),\r\n        [&b\"PASS\"[..], &b\"LowQual\"[..]]\r\n            .iter()\r\n            .cloned()\r\n            .collect::<HashSet<&[u8]>>()\r\n    );\r\n\r\n    assert_eq!(header.alt(b\"DEL\"), None);\r\n    assert_eq!(header.alt_key.len(), 1);\r\n    assert_eq!(\r\n        header\r\n            .alt_list()\r\n            .map(|x| -> &[u8] { &x })\r\n            .collect::<HashSet<&[u8]>>(),\r\n        [&b\"NON_REF\"[..]]\r\n            .iter()\r\n            .cloned()\r\n            .collect::<HashSet<&[u8]>>()\r\n    );\r\n    assert_eq!(\r\n        header.alt(b\"NON_REF\"),\r\n        Some(VCFHeaderFilterAlt {\r\n            id: b\"NON_REF\",\r\n            description: b\"Represents any possible alternative allele at this location\",\r\n        })\r\n    );\r\n\r\n    Ok(())\r\n"]], "pred": {"ppl": 1.4392198324203491, "ppl_lower": 1.714348554611206, "ppl/lowercase_ppl": -1.4804487900773953, "ppl/zlib": 0.00010680586205016774, "Min_5.0% Prob": 4.932225713542864, "Min_10.0% Prob": 3.299042929621304, "Min_20.0% Prob": 1.8092530656277257, "Min_30.0% Prob": 1.2144000007180509, "Min_40.0% Prob": 0.9100672135694284, "Min_50.0% Prob": 0.7287386903251565, "Min_60.0% Prob": 0.6075808551158398}}
{"hexsha": "d9978a75a3e525617b622bf31ea91bcc1ebf1088", "ext": "rs", "lang": "Rust", "content": "fn test_failing() {\n        let mut at = ArrayStump::new_explicit(|a: &f64, b: &f64| a.partial_cmp(b).unwrap(), 16);\n        #[rustfmt::skip]\n        let vals = vec![0.6994135560499647, 0.15138991083383901, 0.17989509662598502, 0.22855960374503625, 0.7394173591733456, 0.8606810583068278, 0.025843624735059523, 0.1416162372765526, 0.9789425643425963, 0.6312677864630949, 0.34678659888024466, 0.7876614416763924, 0.6260871506068197, 0.34733559592131624, 0.5722923635764159, 0.14416998787798063, 0.839158671060864, 0.2621428817535354, 0.9334439919690996, 0.016414089291711065, 0.8795903741012259, 0.051958655798298614, 0.8313985552845266, 0.026928982020677505, 0.779969564116276, 0.6437306675337413, 0.03822809941255523, 0.777911020749552, 0.4639770428538855, 0.7039388191038694, 0.31363729764551374, 0.8111651227165783, 0.5174339383176408, 0.49384841003283086, 0.5214549475595969, 0.0823716635367353, 0.7310183483079477, 0.6196297749276181, 0.6226877845880779, 0.8987550167723078, 0.9536731852226494, 0.2719858776118911, 0.837006810218081, 0.7570466272336563, 0.9649096907962248, 0.09547804495341239, 0.26299769639555115, 0.6883529379785718, 0.23545125345269502, 0.5611223421257663, 0.81145380876482, 0.7821846165410649, 0.8385374221326543, 0.2287909449815878, 0.9938012642875733, 0.30515950398348823, 0.021945251189301795, 0.7456118789178752, 0.24917873250483202, 0.19461925257672297, 0.08596890658908873, 0.8208413553993631, 0.2799020116906893, 0.622583855342935, 0.3406868767224045, 0.7125811318179431, 0.8171813899535424, 0.9875530622413784, 0.8124194427320398, 0.27890169087536465, 0.4582999489551358, 0.8170130026270258, 0.1116683852975886, 0.9523649049789342, 0.1626401579175366, 0.7006463636943299, 0.5396656897339597, 0.73824000529768, 0.8975902131523751, 0.3138666758196337, 0.959190654990596, 0.6786382471256971, 0.8807317907186307, 0.9923109213923168, 0.7704353170122445, 0.20331717853087872, 0.9191784945915048, 0.3458975102965529, 0.44567705127366397, 0.08758863415076357, 0.8940937525362007, 0.2046747373689708, 0.1540080303289173, 0.8088614347095653, 0.09821866105193844, 0.050284880746519045, 0.9585396829998039, 0.35100273069739263, 0.8263845327940142, 0.6305932414080216];\n        for (i, x) in vals.iter().enumerate() {\n            at.insert(*x);\n            let mut expected = vals[0 .. i + 1].to_vec();\n            expected.sort_by(|a, b| a.partial_cmp(b).unwrap());\n            assert_eq!(at.collect(), expected);\n        }\n    }", "item_id": 14, "repo": "bluenote10/rust-array-stump", "file": "lib/src/array_stump.rs", "last_update_at": "2021-11-08T03:40:00+00:00", "question_id": "d9978a75a3e525617b622bf31ea91bcc1ebf1088_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_failing() {\n        let mut at = ArrayStump::new_explicit(|a: &f64, b: &f64| a.partial_cmp(b).unwrap(), 16);\n        #[rustfmt::skip]\n        let vals = vec![0.6994135560499647, 0.15138991083383901, 0.17989509662598502, 0.22855960374503625, 0.7394173591733456, 0.8606810583068278, 0.025843624735059523, 0.1416162372765526, 0.9789425643425963, 0.6312677864630949, 0.34678659888024466, 0.7876614416763924, 0.6260871506068197, 0.34733559592131624, 0.5722923635764159, 0.14416998787798063, 0.839158671060864, 0.2621428817535354, 0.9334439919690996, 0.016414089291711065, 0.8795903741012259, 0.051958655798298614, 0.8313985552845266, 0.026928982020677505, 0.779969564116276, 0.6437306675337413, 0.03822809941255523, 0.777911020749552, 0.4639770428538855, 0.7039388191038694, 0.31363729764551374, 0.8111651227165783, 0.5174339383176408, 0.49384841003283086, 0.5214549475595969, 0.0823716635367353, 0.7310183483079477, 0.6196297749276181, 0.6226877845880779, 0.8987550167723078, 0.9536731852226494, 0.2719858776118911, 0.837006810218081, 0.7570466272336563, 0.9649096907962248, 0.09547804495341239, 0.26299769639555115, 0.6883529379785718, 0.23545125345269502, 0.5611223421257663, 0.81145380876482, 0.7821846165410649, 0.8385374221326543, 0.2287909449815878, 0.9938012642875733, 0.30515950398348823, 0.021945251189301795, 0.7456118789178752, 0.24917873250483202, 0.19461925257672297, 0.08596890658908873, 0.8208413553993631, 0.2799020116906893, 0.622583855342935, 0.3406868767224045, 0.7125811318179431, 0.8171813899535424, 0.9875530622413784, 0.8124194427320398, 0.27890169087536465, 0.4582999489551358, 0.8170130026270258, 0.1116683852975886, 0.9523649049789342, 0.1626401579175366, 0.7006463636943299, 0.5396656897339597, 0.73824000529768, 0.8975902131523751, 0.3138666758196337, 0.959190654990596, 0.6786382471256971, 0.8807317907186307, 0.9923109213923168, 0.7704353170122445, 0.20331717853087872, 0.9191784945915048, 0.3458975102965529, 0.44567705127366397, 0.08758863415076357, 0.8940937525362007, 0.2046747373689708, 0.1540080303289173, 0.8088614347095653, 0.09821866105193844, 0.050284880746519045, 0.9585396829998039, 0.35100273069739263, 0.8263845327940142, 0.6305932414080216];\n        for (i, x) in vals.iter().enumerate() {\n            at.insert(*x);\n            let mut expected = vals[0 .. i + 1].to_vec();\n            expected.sort_by(|a, b| a.partial_cmp(b).unwrap());\n            assert_eq!(at.collect(), expected);\n        }\n"]], "pred": {"ppl": 6.584725379943848, "ppl_lower": 6.634037017822266, "ppl/lowercase_ppl": -1.003958551355516, "ppl/zlib": 0.001467875880408605, "Min_5.0% Prob": 3.806320723365335, "Min_10.0% Prob": 3.0972341579549454, "Min_20.0% Prob": 2.7236985260365056, "Min_30.0% Prob": 2.5913989099801755, "Min_40.0% Prob": 2.520173735606933, "Min_50.0% Prob": 2.4753283740489684, "Min_60.0% Prob": 2.442591763242812}}
{"hexsha": "4a17270a6ca08e799560301be797cdc5deca6f39", "ext": "rs", "lang": "Rust", "content": "fn parse_script<'a, A: Allocator>(\n    tokens: &mut TokenStream,\n    allocator: A,\n) -> Result<Block<A>, ParseError> {\n    // TODO: shebang\n    let block = parse_block_open(tokens, allocator)?;\n    if tokens.matches(Token::EOF) {\n        Ok(block)\n    } else {\n        Err(PureParseError::Generic(b\"Unconsumed tokens!\").into())\n    }\n}", "item_id": 3, "repo": "WimbledonLabs/shimlang", "file": "libshim/src/lib.rs", "last_update_at": "2021-10-14T13:28:17+00:00", "question_id": "4a17270a6ca08e799560301be797cdc5deca6f39_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_script<'a, A: Allocator>(\n    tokens: &mut TokenStream,\n    allocator: A,\n) -> Result<Block<A>, ParseError> {\n    // TODO: shebang\n    let block = parse_block_open(tokens, allocator)?;\n    if tokens.matches(Token::EOF) {\n        Ok(block)\n    } else {\n        Err(PureParseError::Generic(b\"Unconsumed tokens!\").into())\n    }\n"]], "pred": {"ppl": 3.8880841732025146, "ppl_lower": 5.923669338226318, "ppl/lowercase_ppl": -1.3100629019287269, "ppl/zlib": 0.0060893118199555575, "Min_5.0% Prob": 8.829896068572998, "Min_10.0% Prob": 7.324030919508501, "Min_20.0% Prob": 5.335537433624268, "Min_30.0% Prob": 4.0994933366775514, "Min_40.0% Prob": 3.256297986558143, "Min_50.0% Prob": 2.6680555353730413, "Min_60.0% Prob": 2.2757560519235476}}
{"hexsha": "00ea53dac1e39ffc5382be4fb0a44d1632aa4112", "ext": "rs", "lang": "Rust", "content": "fn get_h_prime_fn(x: f32, y: f32) -> f32 {\n    let mut hue_angle;\n\n    if x == 0.0 && y == 0.0 {\n        return 0.0;\n    }\n\n    hue_angle = radians_to_degrees(x.atan2(y));\n\n    if hue_angle < 0.0 {\n        hue_angle += 360.0;\n    }\n\n    hue_angle\n}", "item_id": 0, "repo": "remilauzier/DeltaE", "file": "src/de2000.rs", "last_update_at": "2021-04-19T18:10:36+00:00", "question_id": "00ea53dac1e39ffc5382be4fb0a44d1632aa4112_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_h_prime_fn(x: f32, y: f32) -> f32 {\n    let mut hue_angle;\n    if x == 0.0 && y == 0.0 {\n        return 0.0;\n    }\n    hue_angle = radians_to_degrees(x.atan2(y));\n    if hue_angle < 0.0 {\n        hue_angle += 360.0;\n    }\n    hue_angle\n"]], "pred": {"ppl": 2.1611380577087402, "ppl_lower": 2.1611380577087402, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.00513756641008771, "Min_5.0% Prob": 7.3758548100789385, "Min_10.0% Prob": 5.666323820749919, "Min_20.0% Prob": 3.5474831891059875, "Min_30.0% Prob": 2.502425807087045, "Min_40.0% Prob": 1.9120847823865272, "Min_50.0% Prob": 1.5355754367774352, "Min_60.0% Prob": 1.295686780916233}}
{"hexsha": "0fb12cd5cb6e2b0b0f9b7978bb0aa7b2cc922f51", "ext": "rs", "lang": "Rust", "content": "fn save_new_todo_saves() -> Result<(), Box<dyn std::error::Error>> {\n        let storage = Rc::new(MockStorage::new().with_inbox(\"* Inbox\\n** one\"));\n        let mut todos = Inbox::load(storage)?;\n\n        save_new_reminder(&mut todos, \"two\")?;\n\n        assert_eq!(\"one\\ntwo\", todos.reminders());\n        Ok(())\n    }", "item_id": 9, "repo": "paytonrules/Capture", "file": "godot-capture/src/nodes/capture_note.rs", "last_update_at": "2021-08-20T22:20:07+00:00", "question_id": "0fb12cd5cb6e2b0b0f9b7978bb0aa7b2cc922f51_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn save_new_todo_saves() -> Result<(), Box<dyn std::error::Error>> {\n        let storage = Rc::new(MockStorage::new().with_inbox(\"* Inbox\\n** one\"));\n        let mut todos = Inbox::load(storage)?;\n        save_new_reminder(&mut todos, \"two\")?;\n        assert_eq!(\"one\\ntwo\", todos.reminders());\n        Ok(())\n"]], "pred": {"ppl": 4.832197189331055, "ppl_lower": 7.105180740356445, "ppl/lowercase_ppl": -1.2447296517005788, "ppl/zlib": 0.007610151057247092, "Min_5.0% Prob": 8.478846549987793, "Min_10.0% Prob": 7.286286700855602, "Min_20.0% Prob": 5.8084238009019336, "Min_30.0% Prob": 4.746044090299895, "Min_40.0% Prob": 3.8302332000298933, "Min_50.0% Prob": 3.093573002942971, "Min_60.0% Prob": 2.6168004144261134}}
{"hexsha": "cfa731e3c86c3770c63368a4bc87291f0058e60b", "ext": "rs", "lang": "Rust", "content": "pub fn flipgame(fronts: Vec<i32>, backs: Vec<i32>) -> i32 {\n    let n = fronts.len();\n    let mut hs = HashSet::new();\n    let mut res = i32::MAX;\n    for i in 0..n {\n        if fronts[i] == backs[i] {\n            hs.insert(fronts[i]);\n        }\n    }\n    for i in 0..n {\n        if !hs.contains(&fronts[i]) {\n            res = res.min(fronts[i]);\n        }\n        if !hs.contains(&backs[i]) {\n            res = res.min(backs[i]);\n        }\n    }\n    if res == i32::MAX {\n        0\n    } else {\n        res\n    }\n}", "item_id": 0, "repo": "SmiteWindows/leetcode", "file": "leetcode/src/other/leetcode822.rs", "last_update_at": "2021-05-13T16:15:20+00:00", "question_id": "cfa731e3c86c3770c63368a4bc87291f0058e60b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn flipgame(fronts: Vec<i32>, backs: Vec<i32>) -> i32 {\n    let n = fronts.len();\n    let mut hs = HashSet::new();\n    let mut res = i32::MAX;\n    for i in 0..n {\n        if fronts[i] == backs[i] {\n            hs.insert(fronts[i]);\n        }\n    }\n    for i in 0..n {\n        if !hs.contains(&fronts[i]) {\n            res = res.min(fronts[i]);\n        }\n        if !hs.contains(&backs[i]) {\n            res = res.min(backs[i]);\n        }\n    }\n    if res == i32::MAX {\n        0\n    } else {\n        res\n    }\n"]], "pred": {"ppl": 1.651835322380066, "ppl_lower": 1.842382788658142, "ppl/lowercase_ppl": -1.2175245509567578, "ppl/zlib": 0.0022709818386457956, "Min_5.0% Prob": 6.430276250839233, "Min_10.0% Prob": 4.195535957813263, "Min_20.0% Prob": 2.374785517047091, "Min_30.0% Prob": 1.6601354161002597, "Min_40.0% Prob": 1.252485104768378, "Min_50.0% Prob": 1.0009701007036764, "Min_60.0% Prob": 0.8397344037685998}}
{"hexsha": "265cc3220ff865a85103c9eb644e97399a472475", "ext": "rs", "lang": "Rust", "content": "fn get_colored_circles (center_to_center: i32, small_radius: i32, colors: Vec<[u8; 4]>) -> Vec<Circle> {\n    let positions = position_circle_set(center_to_center);\n    let mut out: Vec<Circle> = Vec::with_capacity(19);\n// no checking is done here for positions.len() == 19 and colors.len() == 19;\n// however, no other length is expected.\n    for (i, position) in positions.iter().enumerate() {\n        let new = Circle {\n            x_center: position.x_center,\n            y_center: position.y_center,\n            radius: small_radius,\n            rgba_color: colors[i],\n        };\n        out.push(new);\n    }\n    out\n}", "item_id": 0, "repo": "paritytech/polkadot-identicon-rust", "file": "src/circles.rs", "last_update_at": "2021-11-16T03:52:31+00:00", "question_id": "265cc3220ff865a85103c9eb644e97399a472475_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_colored_circles (center_to_center: i32, small_radius: i32, colors: Vec<[u8; 4]>) -> Vec<Circle> {\n    let positions = position_circle_set(center_to_center);\n    let mut out: Vec<Circle> = Vec::with_capacity(19);\n// no checking is done here for positions.len() == 19 and colors.len() == 19;\n// however, no other length is expected.\n    for (i, position) in positions.iter().enumerate() {\n        let new = Circle {\n            x_center: position.x_center,\n            y_center: position.y_center,\n            radius: small_radius,\n            rgba_color: colors[i],\n        };\n        out.push(new);\n    }\n    out\n"]], "pred": {"ppl": 3.3852784633636475, "ppl_lower": 3.6378519535064697, "ppl/lowercase_ppl": -1.0590085974557832, "ppl/zlib": 0.00393366505451325, "Min_5.0% Prob": 8.00922360420227, "Min_10.0% Prob": 6.5692533493042, "Min_20.0% Prob": 4.903322091916713, "Min_30.0% Prob": 3.7785709109462675, "Min_40.0% Prob": 2.9465046088869977, "Min_50.0% Prob": 2.42103229784498, "Min_60.0% Prob": 2.0244899233727436}}
{"hexsha": "274f4e4e8a1f7761e9d1175b4436b1bafe05a11e", "ext": "rs", "lang": "Rust", "content": "fn input_style_tailwind_grid() -> InputStyle{\n    let minor_height = \"h-6\";\n    let major_height = \"h-10\";\n    InputStyle {\n        label: (\n            style! {},\n            class![\n                \"w-auto\",\n                \"text-right\",\n                \"box-border\"\n                , \"pt-2 pb-2 pl-2\",\n                major_height\n            ],\n        ),\n        input:  (\n            style! {},\n            class![\"border-solid border-2 border-gray-400 focus:border-yellow-500 w-full outline-none\", \"p-2\", major_height],\n        ),\n        guidance:   (\n                style! {},\n                class![\"w-auto text-sm text-right text-gray-600\", minor_height],\n            ),\n        label_and_guidance:(\n            style! {},\n            class![\"flex flex-col col-start-1 col-end-1\"],\n        ),\n        validation_position:(\n            style! {},\n            class![\"flex flex-col\"],\n        ),\n        input_and_validation:  (\n            style! {},\n            class![\n                   \"col-start-3\",\n                    \"col-end-4\",\n                    // tailwind.config.js\n                    //\n                    // module.exports = {\n                    //     theme: {\n                    //       extend: {\n                    //         gridTemplateColumns: {\n                    //           // Simple 16 column grid\n                    //   +       'form': ' 1fr 1em 2fr',\n                    //         }\n                    //       }\n                    //     }\n                    //   }\n                    ],\n        ),\n        validation_errors:   (\n            style! {\n            },\n            class![\"w-auto text-sm text-right text-red-600\", minor_height],\n        ),\n \n        invalid_input: ( style!{},class![\n            \"border-solid border-2 border-red-400\"\n        ]),\n\n        container   :(\n            style! {St::GridTemplateColumns => \"1fr 0.5em 2fr\"},\n            class![\"grid grid-flow-row-dense row-gap-1 col-gap-1 p-4\"],\n        ),\n    }\n}", "item_id": 0, "repo": "arn-the-long-beard/styles_hooks", "file": "seed_hooks/src/form.rs", "last_update_at": "2021-12-29T09:34:00+00:00", "question_id": "274f4e4e8a1f7761e9d1175b4436b1bafe05a11e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn input_style_tailwind_grid() -> InputStyle{\n    let minor_height = \"h-6\";\n    let major_height = \"h-10\";\n    InputStyle {\n        label: (\n            style! {},\n            class![\n                \"w-auto\",\n                \"text-right\",\n                \"box-border\"\n                , \"pt-2 pb-2 pl-2\",\n                major_height\n            ],\n        ),\n        input:  (\n            style! {},\n            class![\"border-solid border-2 border-gray-400 focus:border-yellow-500 w-full outline-none\", \"p-2\", major_height],\n        ),\n        guidance:   (\n                style! {},\n                class![\"w-auto text-sm text-right text-gray-600\", minor_height],\n            ),\n        label_and_guidance:(\n            style! {},\n            class![\"flex flex-col col-start-1 col-end-1\"],\n        ),\n        validation_position:(\n            style! {},\n            class![\"flex flex-col\"],\n        ),\n        input_and_validation:  (\n            style! {},\n            class![\n                   \"col-start-3\",\n                    \"col-end-4\",\n                    // tailwind.config.js\n                    //\n                    // module.exports = {\n                    //     theme: {\n                    //       extend: {\n                    //         gridTemplateColumns: {\n                    //           // Simple 16 column grid\n                    //   +       'form': ' 1fr 1em 2fr',\n                    //         }\n                    //       }\n                    //     }\n                    //   }\n                    ],\n        ),\n        validation_errors:   (\n            style! {\n            },\n            class![\"w-auto text-sm text-right text-red-600\", minor_height],\n        ),\n        invalid_input: ( style!{},class![\n            \"border-solid border-2 border-red-400\"\n        ]),\n        container   :(\n            style! {St::GridTemplateColumns => \"1fr 0.5em 2fr\"},\n            class![\"grid grid-flow-row-dense row-gap-1 col-gap-1 p-4\"],\n        ),\n    }\n"]], "pred": {"ppl": 3.0331039428710938, "ppl_lower": 3.2452356815338135, "ppl/lowercase_ppl": -1.0609249283045714, "ppl/zlib": 0.0018774729251536454, "Min_5.0% Prob": 7.622136814253671, "Min_10.0% Prob": 6.183719818081174, "Min_20.0% Prob": 4.388774350681136, "Min_30.0% Prob": 3.35860240212559, "Min_40.0% Prob": 2.6708522544497937, "Min_50.0% Prob": 2.1871664514074056, "Min_60.0% Prob": 1.8433435077952072}}
{"hexsha": "f1fd5c7f962441840dc0f5f7e99356acf6e5c0ef", "ext": "rs", "lang": "Rust", "content": "pub fn print_argv() -> Result<(), ()> {\n\tlet args = env::args();\n\n\t// Prints each argument on a separate line\n\tfor (i, argument) in args.enumerate() {\n\t\tprintln!(\"argument[{}] = {}\", i, argument);\n\t}\n\n\tOk(())\n}", "item_id": 7, "repo": "ssrg-vt/RustyMPK", "file": "tests/src/tests/mod.rs", "last_update_at": "2021-12-15T21:14:44+00:00", "question_id": "f1fd5c7f962441840dc0f5f7e99356acf6e5c0ef_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn print_argv() -> Result<(), ()> {\n\tlet args = env::args();\n\t// Prints each argument on a separate line\n\tfor (i, argument) in args.enumerate() {\n\t\tprintln!(\"argument[{}] = {}\", i, argument);\n\t}\n\tOk(())\n"]], "pred": {"ppl": 2.9556612968444824, "ppl_lower": 3.7753450870513916, "ppl/lowercase_ppl": -1.2258598456560337, "ppl/zlib": 0.0067311951238464614, "Min_5.0% Prob": 9.57903798421224, "Min_10.0% Prob": 6.586903401783535, "Min_20.0% Prob": 4.618553280830383, "Min_30.0% Prob": 3.3848127993670376, "Min_40.0% Prob": 2.7050142976744422, "Min_50.0% Prob": 2.1560835860468246, "Min_60.0% Prob": 1.8178470169024712}}
{"hexsha": "eeeb98e665da8cb818d373ba14cf1c265bab8cc9", "ext": "rs", "lang": "Rust", "content": "fn NewDirectory(task: &Task, msrc: &Arc<QMutex<MountSource>>) -> Inode {\n    let iops = Dir::New(task, BTreeMap::new(), &ROOT_OWNER, &FilePermissions::FromMode(FileMode(0o0555)));\n\n    let deviceId = PROC_DEVICE.lock().id.DeviceID();\n    let inodeId = PROC_DEVICE.lock().NextIno();\n\n    let stableAttr = StableAttr {\n        Type: InodeType::Directory,\n        DeviceId: deviceId,\n        InodeId: inodeId,\n        BlockSize: MemoryDef::PAGE_SIZE as i64,\n        DeviceFileMajor: 0,\n        DeviceFileMinor: 0,\n    };\n\n    let inodeInternal = InodeIntern {\n        InodeOp: Arc::new(iops),\n        StableAttr: stableAttr,\n        LockCtx: LockCtx::default(),\n        MountSource: msrc.clone(),\n        Overlay: None,\n        ..Default::default()\n    };\n\n    return Inode(Arc::new(QMutex::new(inodeInternal)))\n}", "item_id": 5, "repo": "xiliangMa/Quark", "file": "qkernel/src/fs/dev/dev.rs", "last_update_at": "2021-11-30T08:53:28+00:00", "question_id": "eeeb98e665da8cb818d373ba14cf1c265bab8cc9_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn NewDirectory(task: &Task, msrc: &Arc<QMutex<MountSource>>) -> Inode {\n    let iops = Dir::New(task, BTreeMap::new(), &ROOT_OWNER, &FilePermissions::FromMode(FileMode(0o0555)));\n    let deviceId = PROC_DEVICE.lock().id.DeviceID();\n    let inodeId = PROC_DEVICE.lock().NextIno();\n    let stableAttr = StableAttr {\n        Type: InodeType::Directory,\n        DeviceId: deviceId,\n        InodeId: inodeId,\n        BlockSize: MemoryDef::PAGE_SIZE as i64,\n        DeviceFileMajor: 0,\n        DeviceFileMinor: 0,\n    };\n    let inodeInternal = InodeIntern {\n        InodeOp: Arc::new(iops),\n        StableAttr: stableAttr,\n        LockCtx: LockCtx::default(),\n        MountSource: msrc.clone(),\n        Overlay: None,\n        ..Default::default()\n    };\n    return Inode(Arc::new(QMutex::new(inodeInternal)))\n"]], "pred": {"ppl": 2.2261059284210205, "ppl_lower": 4.526341915130615, "ppl/lowercase_ppl": -1.886793934828339, "ppl/zlib": 0.0019759354039824103, "Min_5.0% Prob": 7.615396363394601, "Min_10.0% Prob": 5.705090233257839, "Min_20.0% Prob": 3.6438621554458352, "Min_30.0% Prob": 2.5968434689349906, "Min_40.0% Prob": 1.989667690448139, "Min_50.0% Prob": 1.5977362105105486, "Min_60.0% Prob": 1.3393168367640398}}
{"hexsha": "8c4ca7c6186e282c993f45a0b6af9b8ba6240c83", "ext": "rs", "lang": "Rust", "content": "fn c102_l136_action_invoke(result_object: &ResultObject) {\n    println!(\"Executing function {}\", \"c102_l136_action_invoke\");\n    let func_index = match result_object.module.info.exports.get(\"i32.trunc_u_f64\") {\n        Some(&Export::Function(index)) => index,\n        _ => panic!(\"Function not found\"),\n    };\n    let invoke_fn: fn(f64, &Instance) -> i32 = get_instance_function!(result_object.instance, func_index);\n    let result = invoke_fn(-0.9999999999999999 as f64, &result_object.instance);\n    assert_eq!(result, 0 as i32);\n}", "item_id": 126, "repo": "0xflotus/wasmer", "file": "src/spectests/conversions.rs", "last_update_at": "2021-03-13T15:31:32+00:00", "question_id": "8c4ca7c6186e282c993f45a0b6af9b8ba6240c83_126", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn c102_l136_action_invoke(result_object: &ResultObject) {\n    println!(\"Executing function {}\", \"c102_l136_action_invoke\");\n    let func_index = match result_object.module.info.exports.get(\"i32.trunc_u_f64\") {\n        Some(&Export::Function(index)) => index,\n        _ => panic!(\"Function not found\"),\n    };\n    let invoke_fn: fn(f64, &Instance) -> i32 = get_instance_function!(result_object.instance, func_index);\n    let result = invoke_fn(-0.9999999999999999 as f64, &result_object.instance);\n    assert_eq!(result, 0 as i32);\n"]], "pred": {"ppl": 3.539433479309082, "ppl_lower": 4.249363899230957, "ppl/lowercase_ppl": -1.1446261389457524, "ppl/zlib": 0.004328653014538978, "Min_5.0% Prob": 7.443534421920776, "Min_10.0% Prob": 6.31523826122284, "Min_20.0% Prob": 4.787100005149841, "Min_30.0% Prob": 3.816199900706609, "Min_40.0% Prob": 3.05164340659976, "Min_50.0% Prob": 2.47882348240012, "Min_60.0% Prob": 2.094094041396271}}
{"hexsha": "98b78798b06d517e7d04aeb527fd40be71817175", "ext": "rs", "lang": "Rust", "content": "fn sbi_call(which: usize, arg0: usize, arg1: usize, arg2: usize) -> usize {\n    let ret;\n    unsafe {\n        llvm_asm!(\"ecall\"\n            : \"={x10}\" (ret)\n            : \"{x10}\" (arg0), \"{x11}\" (arg1), \"{x12}\" (arg2), \"{x17}\" (which)\n            : \"memory\"\n            : \"volatile\");\n    }\n    ret\n}", "item_id": 0, "repo": "Tan-YiFan/rCore", "file": "kernel/src/arch/riscv/sbi.rs", "last_update_at": "2021-12-24T11:35:47+00:00", "question_id": "98b78798b06d517e7d04aeb527fd40be71817175_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn sbi_call(which: usize, arg0: usize, arg1: usize, arg2: usize) -> usize {\n    let ret;\n    unsafe {\n        llvm_asm!(\"ecall\"\n            : \"={x10}\" (ret)\n            : \"{x10}\" (arg0), \"{x11}\" (arg1), \"{x12}\" (arg2), \"{x17}\" (which)\n            : \"memory\"\n            : \"volatile\");\n    }\n    ret\n"]], "pred": {"ppl": 1.31632661819458, "ppl_lower": 1.31632661819458, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0017285848567705374, "Min_5.0% Prob": 4.762745102246602, "Min_10.0% Prob": 2.575344646970431, "Min_20.0% Prob": 1.3691907553002238, "Min_30.0% Prob": 0.9314231457602646, "Min_40.0% Prob": 0.6881782332511277, "Min_50.0% Prob": 0.553616132972701, "Min_60.0% Prob": 0.46289227719176307}}
{"hexsha": "f8f1435b8cbe7ea0bc554a80558fe8be4cd58671", "ext": "rs", "lang": "Rust", "content": "fn try_lock_conflict_addr<P: AsRef<Path>>(path: P) -> File {\n    let f = File::create(path.as_ref()).unwrap_or_else(|e| {\n        fatal!(\n            \"failed to create dagger at {}: {}\",\n            path.as_ref().display(),\n            e\n        )\n    });\n\n    if f.try_lock_exclusive().is_err() {\n        fatal!(\n            \"{} already in use, maybe another instance is Constrained with this address.\",\n            path.as_ref().file_name().unwrap().to_str().unwrap()\n        );\n    }\n    f\n}", "item_id": 2, "repo": "whtcorpsinc/einsteindb-prod", "file": "causetq/cmd/src/server.rs", "last_update_at": "2021-11-08T21:23:16+00:00", "question_id": "f8f1435b8cbe7ea0bc554a80558fe8be4cd58671_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn try_lock_conflict_addr<P: AsRef<Path>>(path: P) -> File {\n    let f = File::create(path.as_ref()).unwrap_or_else(|e| {\n        fatal!(\n            \"failed to create dagger at {}: {}\",\n            path.as_ref().display(),\n            e\n        )\n    });\n    if f.try_lock_exclusive().is_err() {\n        fatal!(\n            \"{} already in use, maybe another instance is Constrained with this address.\",\n            path.as_ref().file_name().unwrap().to_str().unwrap()\n        );\n    }\n    f\n"]], "pred": {"ppl": 2.8289499282836914, "ppl_lower": 3.534964084625244, "ppl/lowercase_ppl": -1.2142478588414276, "ppl/zlib": 0.0037952758858489028, "Min_5.0% Prob": 8.606792109353202, "Min_10.0% Prob": 6.728720029195149, "Min_20.0% Prob": 4.542583261766741, "Min_30.0% Prob": 3.3478021748522493, "Min_40.0% Prob": 2.580359127076845, "Min_50.0% Prob": 2.073514951322275, "Min_60.0% Prob": 1.7462744535481993}}
{"hexsha": "e0f3e655bef40366141efe0de68d0f17ebf46306", "ext": "rs", "lang": "Rust", "content": "fn scaffold_sbt() {\n        let mut filename = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n        filename.push(\"tests/data/v5.sbt.json\");\n\n        let sbt = MHBT::from_path(filename).expect(\"Loading error\");\n\n        let new_sbt: MHBT = scaffold(sbt.leaves());\n        assert_eq!(new_sbt.leaves().len(), 7);\n    }", "item_id": 2, "repo": "luizirber/sourmash-rust", "file": "src/index/sbt.rs", "last_update_at": "2021-02-02T07:59:37+00:00", "question_id": "e0f3e655bef40366141efe0de68d0f17ebf46306_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn scaffold_sbt() {\n        let mut filename = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n        filename.push(\"tests/data/v5.sbt.json\");\n        let sbt = MHBT::from_path(filename).expect(\"Loading error\");\n        let new_sbt: MHBT = scaffold(sbt.leaves());\n        assert_eq!(new_sbt.leaves().len(), 7);\n"]], "pred": {"ppl": 4.04998254776001, "ppl_lower": 6.289524555206299, "ppl/lowercase_ppl": -1.314698614549109, "ppl/zlib": 0.006597700810915584, "Min_5.0% Prob": 8.244301954905191, "Min_10.0% Prob": 7.083186825116475, "Min_20.0% Prob": 5.385481963555018, "Min_30.0% Prob": 4.191659208801058, "Min_40.0% Prob": 3.3631963469088078, "Min_50.0% Prob": 2.7826739529768627, "Min_60.0% Prob": 2.3429924322085247}}
{"hexsha": "504b3a2f1e97e04e41b11f7ee666e22bf59f3cb6", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_ntp_packet(pack: NtpPacket) -> Vec<u8> {\n    let mut buff = Cursor::new(Vec::new());\n    buff.write_all(&serialize_header(pack.header))\n        .expect(\"buffer write failed; can't serialize NtpPacket\");\n    buff.write_all(&serialize_extensions(pack.exts))\n        .expect(\"buffer write failed; can't serialize NtpPacket\");\n    buff.into_inner()\n}", "item_id": 3, "repo": "GriffinLeclerc/cfnts", "file": "src/ntp/protocol.rs", "last_update_at": "2021-11-21T05:58:11+00:00", "question_id": "504b3a2f1e97e04e41b11f7ee666e22bf59f3cb6_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn serialize_ntp_packet(pack: NtpPacket) -> Vec<u8> {\n    let mut buff = Cursor::new(Vec::new());\n    buff.write_all(&serialize_header(pack.header))\n        .expect(\"buffer write failed; can't serialize NtpPacket\");\n    buff.write_all(&serialize_extensions(pack.exts))\n        .expect(\"buffer write failed; can't serialize NtpPacket\");\n    buff.into_inner()\n"]], "pred": {"ppl": 2.7917959690093994, "ppl_lower": 3.5649068355560303, "ppl/lowercase_ppl": -1.2380991152679135, "ppl/zlib": 0.00561030112146179, "Min_5.0% Prob": 8.173271894454956, "Min_10.0% Prob": 6.588521599769592, "Min_20.0% Prob": 4.46124850710233, "Min_30.0% Prob": 3.2458316650655537, "Min_40.0% Prob": 2.513826538498203, "Min_50.0% Prob": 2.039123716702064, "Min_60.0% Prob": 1.706409009354603}}
{"hexsha": "6cd867972cf90c801674188782b1405551f0c319", "ext": "rs", "lang": "Rust", "content": "fn vector_bitand_int_broadcast() {\n        let a = vector![1, 2, 3, 4, 5];\n        let b = 2;\n\n        let exp = vector![1 & 2, 2 & 2, 3 & 2, 4 & 2, 5 & 2];\n\n        // Allocating new memory\n        let c = &a & &b;\n        assert_eq!(c, exp);\n\n        // Allocating new memory\n        let c = &a & b;\n        assert_eq!(c, exp);\n\n        // Reusing memory\n        let c = a.clone() & &b;\n        assert_eq!(c, exp);\n\n        // Reusing memory\n        let c = a & b;\n        assert_eq!(c, exp);\n    }", "item_id": 25, "repo": "bradyjoestar/rust-sgx-sdk", "file": "third_party/rulinalg/src/vector/impl_ops.rs", "last_update_at": "2021-04-22T21:37:29+00:00", "question_id": "6cd867972cf90c801674188782b1405551f0c319_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn vector_bitand_int_broadcast() {\n        let a = vector![1, 2, 3, 4, 5];\n        let b = 2;\n        let exp = vector![1 & 2, 2 & 2, 3 & 2, 4 & 2, 5 & 2];\n        // Allocating new memory\n        let c = &a & &b;\n        assert_eq!(c, exp);\n        // Allocating new memory\n        let c = &a & b;\n        assert_eq!(c, exp);\n        // Reusing memory\n        let c = a.clone() & &b;\n        assert_eq!(c, exp);\n        // Reusing memory\n        let c = a & b;\n        assert_eq!(c, exp);\n"]], "pred": {"ppl": 1.9777394533157349, "ppl_lower": 2.0142579078674316, "ppl/lowercase_ppl": -1.0268292698876524, "ppl/zlib": 0.003686240552632893, "Min_5.0% Prob": 6.754481315612793, "Min_10.0% Prob": 4.879575164694535, "Min_20.0% Prob": 3.1757733944134836, "Min_30.0% Prob": 2.2197313523393567, "Min_40.0% Prob": 1.7089539899084814, "Min_50.0% Prob": 1.367309743120354, "Min_60.0% Prob": 1.1375658578570869}}
{"hexsha": "700443df51d3eb1116a72193e2afe42d350cad2f", "ext": "rs", "lang": "Rust", "content": "fn root_defaults() {\n    let config = r#\"\n        {\n            \"services\": {\n                \"foo\": {\n                    \"uris\": [\n                        \"http://foo1.com\"\n                    ]\n                }\n            },\n            \"security\": {\n                \"ca-file\": \"/foo/bar\"\n            },\n            \"proxy\": {\n                \"type\": \"http\",\n                \"host-and-port\": \"localhost:1234\",\n                \"credentials\": {\n                    \"username\": \"admin\",\n                    \"password\": \"palantir\"\n                }\n            },\n            \"connect-timeout\": \"11 seconds\",\n            \"read-timeout\": \"3 minutes\"\n        }\n    \"#;\n    let config = serde_json::from_str::<ServicesConfig>(config).unwrap();\n    let expected = ServiceConfig::builder()\n        .uris(vec![\"http://foo1.com\".parse().unwrap()])\n        .security(\n            SecurityConfig::builder()\n                .ca_file(Some(\"/foo/bar\".into()))\n                .build(),\n        )\n        .proxy(ProxyConfig::Http(\n            HttpProxyConfig::builder()\n                .host_and_port(HostAndPort::new(\"localhost\", 1234))\n                .credentials(Some(BasicCredentials::new(\"admin\", \"palantir\")))\n                .build(),\n        ))\n        .connect_timeout(Duration::from_secs(11))\n        .read_timeout(Duration::from_secs(3 * 60))\n        .build();\n    assert_eq!(config.merged_service(\"foo\"), Some(expected));\n}", "item_id": 2, "repo": "palantir/conjure-rust-runtime", "file": "conjure-runtime-config/src/test.rs", "last_update_at": "2021-04-12T05:37:25+00:00", "question_id": "700443df51d3eb1116a72193e2afe42d350cad2f_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn root_defaults() {\n    let config = r#\"\n        {\n            \"services\": {\n                \"foo\": {\n                    \"uris\": [\n                        \"http://foo1.com\"\n                    ]\n                }\n            },\n            \"security\": {\n                \"ca-file\": \"/foo/bar\"\n            },\n            \"proxy\": {\n                \"type\": \"http\",\n                \"host-and-port\": \"localhost:1234\",\n                \"credentials\": {\n                    \"username\": \"admin\",\n                    \"password\": \"palantir\"\n                }\n            },\n            \"connect-timeout\": \"11 seconds\",\n            \"read-timeout\": \"3 minutes\"\n        }\n    \"#;\n    let config = serde_json::from_str::<ServicesConfig>(config).unwrap();\n    let expected = ServiceConfig::builder()\n        .uris(vec![\"http://foo1.com\".parse().unwrap()])\n        .security(\n            SecurityConfig::builder()\n                .ca_file(Some(\"/foo/bar\".into()))\n                .build(),\n        )\n        .proxy(ProxyConfig::Http(\n            HttpProxyConfig::builder()\n                .host_and_port(HostAndPort::new(\"localhost\", 1234))\n                .credentials(Some(BasicCredentials::new(\"admin\", \"palantir\")))\n                .build(),\n        ))\n        .connect_timeout(Duration::from_secs(11))\n        .read_timeout(Duration::from_secs(3 * 60))\n        .build();\n    assert_eq!(config.merged_service(\"foo\"), Some(expected));\n"]], "pred": {"ppl": 1.9792606830596924, "ppl_lower": 2.2838354110717773, "ppl/lowercase_ppl": -1.2096498355879113, "ppl/zlib": 0.001310409563501058, "Min_5.0% Prob": 6.639914763601203, "Min_10.0% Prob": 4.715298915520693, "Min_20.0% Prob": 3.027622355690485, "Min_30.0% Prob": 2.1945862994860796, "Min_40.0% Prob": 1.6861248749155033, "Min_50.0% Prob": 1.3642140542000987, "Min_60.0% Prob": 1.13675776055232}}
{"hexsha": "4809de7cfd3f4e35906d20f2904d9bfa89006d43", "ext": "rs", "lang": "Rust", "content": "pub fn repeated_n_times(a: Vec<i32>) -> i32 {\n    let mut set = HashSet::new();\n    for i in a {\n        if !set.insert(i) {\n            return i;\n        }\n    }\n    0\n}", "item_id": 0, "repo": "ccqpein/Arithmetic-Exercises", "file": "N-Repeated-Element-in-Size-2N-Array/NREIS2A.rs", "last_update_at": "2021-10-09T06:46:10+00:00", "question_id": "4809de7cfd3f4e35906d20f2904d9bfa89006d43_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn repeated_n_times(a: Vec<i32>) -> i32 {\n    let mut set = HashSet::new();\n    for i in a {\n        if !set.insert(i) {\n            return i;\n        }\n    }\n    0\n"]], "pred": {"ppl": 2.5645666122436523, "ppl_lower": 3.3926148414611816, "ppl/lowercase_ppl": -1.2971061588571382, "ppl/zlib": 0.007244534632759896, "Min_5.0% Prob": 9.914030392964682, "Min_10.0% Prob": 7.185959895451863, "Min_20.0% Prob": 4.131955816195561, "Min_30.0% Prob": 3.059074900652233, "Min_40.0% Prob": 2.3395043686032295, "Min_50.0% Prob": 1.8723339275880293, "Min_60.0% Prob": 1.590042386442805}}
{"hexsha": "f99a31db839445f7bcf25ba7325e077cd1b80683", "ext": "rs", "lang": "Rust", "content": "fn test_dirichlet_with_param() {\n        let alpha = 0.5f64;\n        let size = 2;\n        let d = Dirichlet::new_with_param(alpha, size);\n        let mut rng = crate::test::rng(221);\n        let samples = d.sample(&mut rng);\n        let _: Vec<f64> = samples\n            .into_iter()\n            .map(|x| {\n                assert!(x > 0.0);\n                x\n            })\n            .collect();\n    }", "item_id": 1, "repo": "Lawliet-Chan/phala-pruntime", "file": "vendor/rand/src/distributions/dirichlet.rs", "last_update_at": "2021-11-05T02:06:12+00:00", "question_id": "f99a31db839445f7bcf25ba7325e077cd1b80683_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_dirichlet_with_param() {\n        let alpha = 0.5f64;\n        let size = 2;\n        let d = Dirichlet::new_with_param(alpha, size);\n        let mut rng = crate::test::rng(221);\n        let samples = d.sample(&mut rng);\n        let _: Vec<f64> = samples\n            .into_iter()\n            .map(|x| {\n                assert!(x > 0.0);\n                x\n            })\n            .collect();\n"]], "pred": {"ppl": 2.208444356918335, "ppl_lower": 2.613748073577881, "ppl/lowercase_ppl": -1.2126711525105274, "ppl/zlib": 0.003941733118265589, "Min_5.0% Prob": 6.831838210423787, "Min_10.0% Prob": 5.03238138785729, "Min_20.0% Prob": 3.3883829205124467, "Min_30.0% Prob": 2.490164288660375, "Min_40.0% Prob": 1.9560665709001046, "Min_50.0% Prob": 1.5808542055242203, "Min_60.0% Prob": 1.3196940581518701}}
{"hexsha": "e6c02ad05eeca0f370510452e04d754f2ab11ce7", "ext": "rs", "lang": "Rust", "content": "async fn test_client() {\n        env_logger::try_init().ok();\n        let client = ClientBuilder::<NodeTemplateRuntime>::new()\n            .build()\n            .await\n            .unwrap();\n        let signer = PairSigner::new(AccountKeyring::Alice.pair());\n        let to = AccountKeyring::Bob.to_account_id().into();\n        client\n            .transfer_and_watch(&signer, &to, 10_000)\n            .await\n            .unwrap();\n    }", "item_id": 0, "repo": "tolak/phala-blockchain", "file": "subxt/client/src/lib.rs", "last_update_at": "2021-06-07T09:14:52+00:00", "question_id": "e6c02ad05eeca0f370510452e04d754f2ab11ce7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn test_client() {\n        env_logger::try_init().ok();\n        let client = ClientBuilder::<NodeTemplateRuntime>::new()\n            .build()\n            .await\n            .unwrap();\n        let signer = PairSigner::new(AccountKeyring::Alice.pair());\n        let to = AccountKeyring::Bob.to_account_id().into();\n        client\n            .transfer_and_watch(&signer, &to, 10_000)\n            .await\n            .unwrap();\n"]], "pred": {"ppl": 2.595676898956299, "ppl_lower": 4.127140522003174, "ppl/lowercase_ppl": -1.4861757799796746, "ppl/zlib": 0.004201970616674414, "Min_5.0% Prob": 7.6043548583984375, "Min_10.0% Prob": 6.217358986536662, "Min_20.0% Prob": 4.163314743041992, "Min_30.0% Prob": 3.0638730408329713, "Min_40.0% Prob": 2.3503678473187426, "Min_50.0% Prob": 1.8974581556394696, "Min_60.0% Prob": 1.6040983350555365}}
{"hexsha": "f3068e5da33e1d3431320c12b862ec0fb90d610c", "ext": "rs", "lang": "Rust", "content": "fn test_empty_section() {\n        let x = r#\"read      |     write\npages per bulk r/w     rpcs  % cum % |  rpcs        % cum %\n\"#;\n\n        let result = section().parse(x);\n\n        assert_eq!(\n            result,\n            Ok((\n                BrwStats {\n                    name: \"pages\".to_string(),\n                    unit: \"rpcs\".to_string(),\n                    buckets: vec![],\n                },\n                \"\",\n            ))\n        );\n    }", "item_id": 5, "repo": "whamcloud/lustre-collector", "file": "src/oss/brw_stats_parser.rs", "last_update_at": "2021-10-21T22:53:05+00:00", "question_id": "f3068e5da33e1d3431320c12b862ec0fb90d610c_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_empty_section() {\n        let x = r#\"read      |     write\npages per bulk r/w     rpcs  % cum % |  rpcs        % cum %\n\"#;\n        let result = section().parse(x);\n        assert_eq!(\n            result,\n            Ok((\n                BrwStats {\n                    name: \"pages\".to_string(),\n                    unit: \"rpcs\".to_string(),\n                    buckets: vec![],\n                },\n                \"\",\n            ))\n        );\n"]], "pred": {"ppl": 6.261672019958496, "ppl_lower": 7.478687286376953, "ppl/lowercase_ppl": -1.0968193744896808, "ppl/zlib": 0.008414895620588435, "Min_5.0% Prob": 10.321979522705078, "Min_10.0% Prob": 8.715931562276987, "Min_20.0% Prob": 6.748865430171673, "Min_30.0% Prob": 5.521544841619638, "Min_40.0% Prob": 4.457635700702667, "Min_50.0% Prob": 3.6412541123536917, "Min_60.0% Prob": 3.0684101161284323}}
{"hexsha": "0783cd99c82f9d5bc7af11bdd3aa10223062e13f", "ext": "rs", "lang": "Rust", "content": "fn is_empty_after_entity_created_and_destroyed() {\n        let mut state = State::new();\n        let e = state.create_entity();\n        state.destroy_entity(e).unwrap();\n        assert!(state.is_empty());\n    }", "item_id": 2, "repo": "OpenStarscape/OSpServerRs", "file": "src/engine/state.rs", "last_update_at": "2021-02-28T05:52:07+00:00", "question_id": "0783cd99c82f9d5bc7af11bdd3aa10223062e13f_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn is_empty_after_entity_created_and_destroyed() {\n        let mut state = State::new();\n        let e = state.create_entity();\n        state.destroy_entity(e).unwrap();\n        assert!(state.is_empty());\n"]], "pred": {"ppl": 3.361360549926758, "ppl_lower": 3.8566112518310547, "ppl/lowercase_ppl": -1.1133695223498266, "ppl/zlib": 0.009398029593707884, "Min_5.0% Prob": 9.403739929199219, "Min_10.0% Prob": 7.399008512496948, "Min_20.0% Prob": 5.209420561790466, "Min_30.0% Prob": 3.8894899454381733, "Min_40.0% Prob": 2.938003200292587, "Min_50.0% Prob": 2.4124890094803226, "Min_60.0% Prob": 2.044892077510421}}
{"hexsha": "2b81f2131d8504856126fad66bc1e79d8171f5de", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_TfLiteTransposeParams() {\n    assert_eq!(\n        ::std::mem::size_of::<TfLiteTransposeParams>(),\n        1usize,\n        concat!(\"Size of: \", stringify!(TfLiteTransposeParams))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<TfLiteTransposeParams>(),\n        1usize,\n        concat!(\"Alignment of \", stringify!(TfLiteTransposeParams))\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<TfLiteTransposeParams>())).placeholder as *const _ as usize\n        },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TfLiteTransposeParams),\n            \"::\",\n            stringify!(placeholder)\n        )\n    );\n}", "item_id": 59, "repo": "Nugine/tensorflow-lite", "file": "src/bindings.rs", "last_update_at": "2021-11-10T09:52:05+00:00", "question_id": "2b81f2131d8504856126fad66bc1e79d8171f5de_59", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout_TfLiteTransposeParams() {\n    assert_eq!(\n        ::std::mem::size_of::<TfLiteTransposeParams>(),\n        1usize,\n        concat!(\"Size of: \", stringify!(TfLiteTransposeParams))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<TfLiteTransposeParams>(),\n        1usize,\n        concat!(\"Alignment of \", stringify!(TfLiteTransposeParams))\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<TfLiteTransposeParams>())).placeholder as *const _ as usize\n        },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TfLiteTransposeParams),\n            \"::\",\n            stringify!(placeholder)\n        )\n    );\n"]], "pred": {"ppl": 1.4202879667282104, "ppl_lower": 1.5524669885635376, "ppl/lowercase_ppl": -1.2536217204207627, "ppl/zlib": 0.0014034385780956954, "Min_5.0% Prob": 5.8717960877852, "Min_10.0% Prob": 3.5450341295112264, "Min_20.0% Prob": 1.7854020487284288, "Min_30.0% Prob": 1.1729214034167488, "Min_40.0% Prob": 0.883039866999139, "Min_50.0% Prob": 0.7017137564240719, "Min_60.0% Prob": 0.5865103002918509}}
{"hexsha": "1854d6486215672df4496b4002b9967f22073a2b", "ext": "rs", "lang": "Rust", "content": "fn test_md5() {\n        assert_eq!(md5(b\"\"), hex(\"d41d8cd98f00b204e9800998ecf8427e\").unwrap());\n        assert_eq!(md5(b\"a\"), hex(\"0cc175b9c0f1b6a831c399e269772661\").unwrap());\n        assert_eq!(\n            md5(b\"abc\"),\n            hex(\"900150983cd24fb0d6963f7d28e17f72\").unwrap()\n        );\n        assert_eq!(\n            md5(b\"message digest\"),\n            hex(\"f96b697d7cb7938d525a2f31aaf161d0\").unwrap()\n        );\n        assert_eq!(\n            md5(b\"abcdefghijklmnopqrstuvwxyz\"),\n            hex(\"c3fcd3d76192e4007dfb496cca67e13b\").unwrap()\n        );\n        assert_eq!(\n            md5(b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"),\n            hex(\"d174ab98d277d9f5a5611c2c9f419d9f\").unwrap()\n        );\n        assert_eq!(\n            md5(b\"12345678901234567890123456789012345678901\\\n                234567890123456789012345678901234567890\"),\n            hex(\"57edf4a22be3c955ac49da2e2107b67a\").unwrap()\n        );\n    }", "item_id": 4, "repo": "boxdot/cr", "file": "cr/src/md5.rs", "last_update_at": "2021-05-19T19:58:35+00:00", "question_id": "1854d6486215672df4496b4002b9967f22073a2b_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_md5() {\n        assert_eq!(md5(b\"\"), hex(\"d41d8cd98f00b204e9800998ecf8427e\").unwrap());\n        assert_eq!(md5(b\"a\"), hex(\"0cc175b9c0f1b6a831c399e269772661\").unwrap());\n        assert_eq!(\n            md5(b\"abc\"),\n            hex(\"900150983cd24fb0d6963f7d28e17f72\").unwrap()\n        );\n        assert_eq!(\n            md5(b\"message digest\"),\n            hex(\"f96b697d7cb7938d525a2f31aaf161d0\").unwrap()\n        );\n        assert_eq!(\n            md5(b\"abcdefghijklmnopqrstuvwxyz\"),\n            hex(\"c3fcd3d76192e4007dfb496cca67e13b\").unwrap()\n        );\n        assert_eq!(\n            md5(b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"),\n            hex(\"d174ab98d277d9f5a5611c2c9f419d9f\").unwrap()\n        );\n        assert_eq!(\n            md5(b\"12345678901234567890123456789012345678901\\\n                234567890123456789012345678901234567890\"),\n            hex(\"57edf4a22be3c955ac49da2e2107b67a\").unwrap()\n        );\n"]], "pred": {"ppl": 1.1508771181106567, "ppl_lower": 1.179053544998169, "ppl/lowercase_ppl": -1.1721244099108816, "ppl/zlib": 0.0003871194574633663, "Min_5.0% Prob": 2.7160053527355195, "Min_10.0% Prob": 1.394049833802616, "Min_20.0% Prob": 0.7050248767504943, "Min_30.0% Prob": 0.47075996140483767, "Min_40.0% Prob": 0.35154163313365155, "Min_50.0% Prob": 0.2815623739550688, "Min_60.0% Prob": 0.23480685025936388}}
{"hexsha": "c964fbd0ebbd95a38a4784b7af429894f461fec3", "ext": "rs", "lang": "Rust", "content": "pub fn encode_vox(map: &Array3<VoxColor>) -> DotVoxData {\n    let global_extent = *map.extent();\n    let local_extent = global_extent - global_extent.minimum;\n    let shape = local_extent.shape;\n\n    // VOX coordinates are limited to u8.\n    assert!(shape <= PointN([std::u8::MAX as i32; 3]));\n\n    let size = dot_vox::Size {\n        x: shape.x() as u32,\n        y: shape.y() as u32,\n        z: shape.z() as u32,\n    };\n\n    let mut voxels = Vec::new();\n    for p in local_extent.iter_points() {\n        if let VoxColor::Color(i) = map.get(&Local(p)) {\n            voxels.push(dot_vox::Voxel {\n                x: p.x() as u8,\n                y: p.y() as u8,\n                z: p.z() as u8,\n                i,\n            });\n        }\n    }\n\n    let model = dot_vox::Model { size, voxels };\n\n    DotVoxData {\n        version: 150,\n        models: vec![model],\n        palette: Vec::new(),\n        materials: Vec::new(),\n    }\n}", "item_id": 0, "repo": "superdump/building-blocks", "file": "crates/building_blocks_vox/src/lib.rs", "last_update_at": "2021-08-02T17:42:41+00:00", "question_id": "c964fbd0ebbd95a38a4784b7af429894f461fec3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn encode_vox(map: &Array3<VoxColor>) -> DotVoxData {\n    let global_extent = *map.extent();\n    let local_extent = global_extent - global_extent.minimum;\n    let shape = local_extent.shape;\n    // VOX coordinates are limited to u8.\n    assert!(shape <= PointN([std::u8::MAX as i32; 3]));\n    let size = dot_vox::Size {\n        x: shape.x() as u32,\n        y: shape.y() as u32,\n        z: shape.z() as u32,\n    };\n    let mut voxels = Vec::new();\n    for p in local_extent.iter_points() {\n        if let VoxColor::Color(i) = map.get(&Local(p)) {\n            voxels.push(dot_vox::Voxel {\n                x: p.x() as u8,\n                y: p.y() as u8,\n                z: p.z() as u8,\n                i,\n            });\n        }\n    }\n    let model = dot_vox::Model { size, voxels };\n    DotVoxData {\n        version: 150,\n        models: vec![model],\n        palette: Vec::new(),\n        materials: Vec::new(),\n    }\n"]], "pred": {"ppl": 2.193479299545288, "ppl_lower": 2.693209409713745, "ppl/lowercase_ppl": -1.2612952772253607, "ppl/zlib": 0.0018746754281609237, "Min_5.0% Prob": 7.795274706447826, "Min_10.0% Prob": 5.82763422236723, "Min_20.0% Prob": 3.6182828001354053, "Min_30.0% Prob": 2.5552109456979313, "Min_40.0% Prob": 1.9612996600352335, "Min_50.0% Prob": 1.573363329149309, "Min_60.0% Prob": 1.310070021046648}}
{"hexsha": "037795e145eb026fdc4889fb5aa7f8a97951fbd3", "ext": "rs", "lang": "Rust", "content": "fn part2(input: &str) {\n\n    let (dots, ins) = parse_input(&input);\n\n    let mut paper = Paper{dots};\n\n    paper.run(&ins);\n    paper.show();\n}", "item_id": 2, "repo": "gcalmettes/AdventOfCode2017", "file": "2021/src/day13/main.rs", "last_update_at": "2021-12-12T22:59:49+00:00", "question_id": "037795e145eb026fdc4889fb5aa7f8a97951fbd3_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn part2(input: &str) {\n    let (dots, ins) = parse_input(&input);\n    let mut paper = Paper{dots};\n    paper.run(&ins);\n    paper.show();\n"]], "pred": {"ppl": 3.8544809818267822, "ppl_lower": 4.554839134216309, "ppl/lowercase_ppl": -1.1237395133170889, "ppl/zlib": 0.01272864493289425, "Min_5.0% Prob": 7.812311410903931, "Min_10.0% Prob": 6.274752235412597, "Min_20.0% Prob": 4.576659896157005, "Min_30.0% Prob": 3.7677107602357864, "Min_40.0% Prob": 3.082298541610891, "Min_50.0% Prob": 2.631907613189132, "Min_60.0% Prob": 2.2153702956257444}}
{"hexsha": "bfef59a6a5403c8fd4eab2e86a080864783f711a", "ext": "rs", "lang": "Rust", "content": "fn get_bytes(tryte: Tryte) -> Vec<u8> {\n        let mut bytes = vec![];\n        tryte.write_bytes(&mut bytes).unwrap();\n        bytes\n    }", "item_id": 4, "repo": "jdanford/ternary-rs", "file": "src/tryte.rs", "last_update_at": "2021-11-14T14:48:45+00:00", "question_id": "bfef59a6a5403c8fd4eab2e86a080864783f711a_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_bytes(tryte: Tryte) -> Vec<u8> {\n        let mut bytes = vec![];\n        tryte.write_bytes(&mut bytes).unwrap();\n        bytes\n"]], "pred": {"ppl": 3.345025062561035, "ppl_lower": 4.238447189331055, "ppl/lowercase_ppl": -1.1960479071631818, "ppl/zlib": 0.012321165164250285, "Min_5.0% Prob": 9.972163200378418, "Min_10.0% Prob": 7.816910743713379, "Min_20.0% Prob": 5.223157670762804, "Min_30.0% Prob": 3.696635033403124, "Min_40.0% Prob": 2.9976988898383246, "Min_50.0% Prob": 2.41806546760642, "Min_60.0% Prob": 2.017308528934206}}
{"hexsha": "c19755dbc5444266c8a6d06099cb2cb48be742fb", "ext": "rs", "lang": "Rust", "content": "fn init(ctx: init::Context) -> (Shared, Local, init::Monotonics) {\n        ctx.device.RCC.ahbenr.modify(|_, w| w.dma1en().enabled());\n        let mut rcc = ctx.device.RCC.constrain();\n        let mut flash = ctx.device.FLASH.constrain();\n        let clocks = rcc.cfgr.freeze(&mut flash.acr);\n        let mut gpioc = ctx.device.GPIOC.split(&mut rcc.ahb);\n        let pins = (\n            gpioc\n                .pc4\n                .into_af7_push_pull(&mut gpioc.moder, &mut gpioc.otyper, &mut gpioc.afrl),\n            gpioc\n                .pc5\n                .into_af7_push_pull(&mut gpioc.moder, &mut gpioc.otyper, &mut gpioc.afrl),\n        );\n        let serial = Serial::new(ctx.device.USART1, pins, 9600.Bd(), clocks, &mut rcc.apb2);\n        let (tx, rx) = serial.split();\n        let mut dma1 = ctx.device.DMA1.split(&mut rcc.ahb);\n        dma1.ch4.listen(Event::TransferComplete);\n        dma1.ch5.listen(Event::TransferComplete);\n        (\n            Shared {\n                send: Some(TxTransfer::Idle(ctx.local.tx_buf, dma1.ch4, tx)),\n            },\n            Local {\n                recv: Some(rx.read_exact(ctx.local.rx_buf, dma1.ch5)),\n            },\n            init::Monotonics(),\n        )\n    }", "item_id": 0, "repo": "kalkyl/f303-rtic", "file": "src/bin/serial.rs", "last_update_at": "2021-12-29T11:23:53+00:00", "question_id": "c19755dbc5444266c8a6d06099cb2cb48be742fb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn init(ctx: init::Context) -> (Shared, Local, init::Monotonics) {\n        ctx.device.RCC.ahbenr.modify(|_, w| w.dma1en().enabled());\n        let mut rcc = ctx.device.RCC.constrain();\n        let mut flash = ctx.device.FLASH.constrain();\n        let clocks = rcc.cfgr.freeze(&mut flash.acr);\n        let mut gpioc = ctx.device.GPIOC.split(&mut rcc.ahb);\n        let pins = (\n            gpioc\n                .pc4\n                .into_af7_push_pull(&mut gpioc.moder, &mut gpioc.otyper, &mut gpioc.afrl),\n            gpioc\n                .pc5\n                .into_af7_push_pull(&mut gpioc.moder, &mut gpioc.otyper, &mut gpioc.afrl),\n        );\n        let serial = Serial::new(ctx.device.USART1, pins, 9600.Bd(), clocks, &mut rcc.apb2);\n        let (tx, rx) = serial.split();\n        let mut dma1 = ctx.device.DMA1.split(&mut rcc.ahb);\n        dma1.ch4.listen(Event::TransferComplete);\n        dma1.ch5.listen(Event::TransferComplete);\n        (\n            Shared {\n                send: Some(TxTransfer::Idle(ctx.local.tx_buf, dma1.ch4, tx)),\n            },\n            Local {\n                recv: Some(rx.read_exact(ctx.local.rx_buf, dma1.ch5)),\n            },\n            init::Monotonics(),\n        )\n"]], "pred": {"ppl": 1.6351357698440552, "ppl_lower": 1.8833438158035278, "ppl/lowercase_ppl": -1.2874019833188732, "ppl/zlib": 0.001068969218612147, "Min_5.0% Prob": 5.3849534013054585, "Min_10.0% Prob": 3.7915133969350294, "Min_20.0% Prob": 2.325537158684297, "Min_30.0% Prob": 1.6181006120671904, "Min_40.0% Prob": 1.2296544401406568, "Min_50.0% Prob": 0.9826075498283178, "Min_60.0% Prob": 0.820576912373798}}
{"hexsha": "a3e3ffb5ec74feae6a7d14ee883823b7a182ebdb", "ext": "rs", "lang": "Rust", "content": "pub fn path<'a>(\n    network: &'a Network<Node>,\n    a: &str,\n    b: &str,\n    algorithm: &dyn Fn(&Network<Node>, Node, Node) -> io::Result<Vec<Node>>,\n) -> io::Result<Vec<Node>> {\n    let opt_goal = network.get(b);\n    let opt_start = network.get(a);\n    if opt_goal.is_none() || opt_start.is_none() {\n        Err(Error::new(\n            ErrorKind::Other,\n            \"Start or Goal path does not exist in Network\",\n        ))\n    } else {\n        algorithm(&network, opt_start.unwrap(), opt_goal.unwrap())\n    }\n}", "item_id": 0, "repo": "pontuslaestadius/pathfinder", "file": "src/map/network.rs", "last_update_at": "2021-02-27T15:23:48+00:00", "question_id": "a3e3ffb5ec74feae6a7d14ee883823b7a182ebdb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn path<'a>(\n    network: &'a Network<Node>,\n    a: &str,\n    b: &str,\n    algorithm: &dyn Fn(&Network<Node>, Node, Node) -> io::Result<Vec<Node>>,\n) -> io::Result<Vec<Node>> {\n    let opt_goal = network.get(b);\n    let opt_start = network.get(a);\n    if opt_goal.is_none() || opt_start.is_none() {\n        Err(Error::new(\n            ErrorKind::Other,\n            \"Start or Goal path does not exist in Network\",\n        ))\n    } else {\n        algorithm(&network, opt_start.unwrap(), opt_goal.unwrap())\n    }\n"]], "pred": {"ppl": 2.487774610519409, "ppl_lower": 3.2084665298461914, "ppl/lowercase_ppl": -1.2791394711718962, "ppl/zlib": 0.003518874826818947, "Min_5.0% Prob": 8.920351386070251, "Min_10.0% Prob": 6.54258119358736, "Min_20.0% Prob": 4.074567522321429, "Min_30.0% Prob": 2.9240438117171235, "Min_40.0% Prob": 2.2579671343867207, "Min_50.0% Prob": 1.8187431496348274, "Min_60.0% Prob": 1.52933842009197}}
{"hexsha": "6c11c4d7c052cc34184bb63dd07cc9105ac089fe", "ext": "rs", "lang": "Rust", "content": "pub fn parse_mac(cx: &ExtCtxt, mac: &ast::Mac) -> P<ast::Expr> {\n    let tts = quoted::parse(&mac.node.tts, false, &cx.parse_sess());\n    let rdr = transcribe::transcribe(&cx.parse_sess().span_diagnostic, None, tts);\n\n    let mut parser = Parser::new(\n        cx.parse_sess(),\n        rdr.clone(),\n        None,\n        false);\n\n    let expr = panictry!(parser.parse_expr());\n    panictry!(parser.expect(&Token::Eof));\n\n    expr\n}", "item_id": 0, "repo": "erickt/stateful", "file": "src/build/mac.rs", "last_update_at": "2021-06-05T05:48:50+00:00", "question_id": "6c11c4d7c052cc34184bb63dd07cc9105ac089fe_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn parse_mac(cx: &ExtCtxt, mac: &ast::Mac) -> P<ast::Expr> {\n    let tts = quoted::parse(&mac.node.tts, false, &cx.parse_sess());\n    let rdr = transcribe::transcribe(&cx.parse_sess().span_diagnostic, None, tts);\n    let mut parser = Parser::new(\n        cx.parse_sess(),\n        rdr.clone(),\n        None,\n        false);\n    let expr = panictry!(parser.parse_expr());\n    panictry!(parser.expect(&Token::Eof));\n    expr\n"]], "pred": {"ppl": 2.9543774127960205, "ppl_lower": 3.920621871948242, "ppl/lowercase_ppl": -1.2612069538670105, "ppl/zlib": 0.0045325855198778235, "Min_5.0% Prob": 8.46215888432094, "Min_10.0% Prob": 6.373042233784994, "Min_20.0% Prob": 4.312398898986078, "Min_30.0% Prob": 3.2646428955362197, "Min_40.0% Prob": 2.6239574705400774, "Min_50.0% Prob": 2.148736208677292, "Min_60.0% Prob": 1.8028819377117968}}
{"hexsha": "c525b8e5c7385c032a982a8a99fa6d9d1ff26e82", "ext": "rs", "lang": "Rust", "content": "fn size_hint() {\n        assert_eq!(Lowercase::with_slice(b\"\").size_hint(), (0, Some(0)));\n        assert_eq!(Lowercase::with_slice(b\"abc, xyz\").size_hint(), (8, Some(8)));\n        assert_eq!(\n            Lowercase::with_slice(b\"abc, \\xFF\\xFE, xyz\").size_hint(),\n            (12, Some(12))\n        );\n        assert_eq!(\n            Lowercase::with_slice(\"\ufffd\".as_bytes()).size_hint(),\n            (3, Some(3))\n        );\n        assert_eq!(\n            Lowercase::with_slice(\"\u0388\u03c4\u03bf\u03c2\".as_bytes()).size_hint(),\n            (8, Some(8))\n        );\n        assert_eq!(\n            Lowercase::with_slice(\"Z\u023a\u023e\".as_bytes()).size_hint(),\n            (5, Some(5))\n        );\n\n        let mut utf8_with_invalid_bytes = b\"\\xFF\\xFE\".to_vec();\n        utf8_with_invalid_bytes.extend_from_slice(\"\u0388\u03c4\u03bf\u03c2\".as_bytes());\n        assert_eq!(\n            Lowercase::with_slice(&utf8_with_invalid_bytes).size_hint(),\n            (10, Some(10))\n        );\n    }", "item_id": 7, "repo": "artichoke/roe", "file": "src/lowercase/ascii.rs", "last_update_at": "2021-02-06T09:15:01+00:00", "question_id": "c525b8e5c7385c032a982a8a99fa6d9d1ff26e82_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn size_hint() {\n        assert_eq!(Lowercase::with_slice(b\"\").size_hint(), (0, Some(0)));\n        assert_eq!(Lowercase::with_slice(b\"abc, xyz\").size_hint(), (8, Some(8)));\n        assert_eq!(\n            Lowercase::with_slice(b\"abc, \\xFF\\xFE, xyz\").size_hint(),\n            (12, Some(12))\n        );\n        assert_eq!(\n            Lowercase::with_slice(\"\ufffd\".as_bytes()).size_hint(),\n            (3, Some(3))\n        );\n        assert_eq!(\n            Lowercase::with_slice(\"\u0388\u03c4\u03bf\u03c2\".as_bytes()).size_hint(),\n            (8, Some(8))\n        );\n        assert_eq!(\n            Lowercase::with_slice(\"Z\u023a\u023e\".as_bytes()).size_hint(),\n            (5, Some(5))\n        );\n        let mut utf8_with_invalid_bytes = b\"\\xFF\\xFE\".to_vec();\n        utf8_with_invalid_bytes.extend_from_slice(\"\u0388\u03c4\u03bf\u03c2\".as_bytes());\n        assert_eq!(\n            Lowercase::with_slice(&utf8_with_invalid_bytes).size_hint(),\n            (10, Some(10))\n        );\n"]], "pred": {"ppl": 1.8901937007904053, "ppl_lower": 2.0486185550689697, "ppl/lowercase_ppl": -1.1264158863265632, "ppl/zlib": 0.002375669070935777, "Min_5.0% Prob": 7.39391428232193, "Min_10.0% Prob": 5.085677804368915, "Min_20.0% Prob": 3.070560791727268, "Min_30.0% Prob": 2.1170997841641155, "Min_40.0% Prob": 1.598489090856729, "Min_50.0% Prob": 1.272658367275193, "Min_60.0% Prob": 1.0620142057638653}}
{"hexsha": "147e8e1729a174bd5ca7fc70d48cfb068f55c894", "ext": "rs", "lang": "Rust", "content": "pub fn lookup_ipv4(host: &str, port: u16) -> SocketAddr {\n    use std::net::ToSocketAddrs;\n\n    let addrs = (host, port).to_socket_addrs().unwrap();\n    for addr in addrs {\n        if let SocketAddr::V4(_) = addr {\n            return addr;\n        }\n    }\n\n    unreachable!(\"Cannot lookup address\");\n}", "item_id": 0, "repo": "IPSE-TEAM/TEE-worker", "file": "worker/src/enclave/attestation_ocalls.rs", "last_update_at": "2021-11-12T12:42:37+00:00", "question_id": "147e8e1729a174bd5ca7fc70d48cfb068f55c894_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn lookup_ipv4(host: &str, port: u16) -> SocketAddr {\n    use std::net::ToSocketAddrs;\n    let addrs = (host, port).to_socket_addrs().unwrap();\n    for addr in addrs {\n        if let SocketAddr::V4(_) = addr {\n            return addr;\n        }\n    }\n    unreachable!(\"Cannot lookup address\");\n"]], "pred": {"ppl": 1.9719096422195435, "ppl_lower": 3.2096641063690186, "ppl/lowercase_ppl": -1.7174699709683001, "ppl/zlib": 0.003518147330337685, "Min_5.0% Prob": 7.39471206665039, "Min_10.0% Prob": 5.152790451049805, "Min_20.0% Prob": 3.0604454420861744, "Min_30.0% Prob": 2.2289197834268695, "Min_40.0% Prob": 1.6809822343999432, "Min_50.0% Prob": 1.3671890068441057, "Min_60.0% Prob": 1.1307114419409088}}
{"hexsha": "58e9fc8797ce5798864390deed20cffb0f64b42d", "ext": "rs", "lang": "Rust", "content": "fn given_cfd_expires_within_23hours_then_rollover() {\n        // --|----|-------------------------------------------------|--> time\n        //   ct   1h                                                24h\n        // --|----|<--------------------rollover------------------->|--\n        //        now\n\n        let cfd = Cfd::dummy_open(BitMexPriceEventId::with_20_digits(\n            datetime!(2021-11-19 10:00:00).assume_utc(),\n        ));\n\n        let result = cfd.can_auto_rollover_taker(datetime!(2021-11-18 11:00:00).assume_utc());\n\n        assert!(result.is_ok());\n    }", "item_id": 20, "repo": "comit-network/hermes", "file": "daemon/src/model/cfd.rs", "last_update_at": "2021-09-30T09:47:06+00:00", "question_id": "58e9fc8797ce5798864390deed20cffb0f64b42d_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn given_cfd_expires_within_23hours_then_rollover() {\n        // --|----|-------------------------------------------------|--> time\n        //   ct   1h                                                24h\n        // --|----|<--------------------rollover------------------->|--\n        //        now\n        let cfd = Cfd::dummy_open(BitMexPriceEventId::with_20_digits(\n            datetime!(2021-11-19 10:00:00).assume_utc(),\n        ));\n        let result = cfd.can_auto_rollover_taker(datetime!(2021-11-18 11:00:00).assume_utc());\n        assert!(result.is_ok());\n"]], "pred": {"ppl": 4.980969429016113, "ppl_lower": 5.778527736663818, "ppl/lowercase_ppl": -1.0925025704727775, "ppl/zlib": 0.006105036260657646, "Min_5.0% Prob": 8.772809081607395, "Min_10.0% Prob": 7.528110378666928, "Min_20.0% Prob": 5.67593274361048, "Min_30.0% Prob": 4.536104840747381, "Min_40.0% Prob": 3.7286108188991305, "Min_50.0% Prob": 3.127151420622161, "Min_60.0% Prob": 2.661545079420595}}
{"hexsha": "7382dcf7370d2f4b38588e9c78fdbf8dae7467b3", "ext": "rs", "lang": "Rust", "content": "fn transfer_multi() {\n    let mut token = Oep5TokenInstance;\n    let owner = Address::zero();\n    build_runtime().witness(&[owner]);\n    assert_eq!(token.initialize(&owner), true);\n    let alice = Address::repeat_byte(1);\n    let bob = Address::repeat_byte(2);\n    let token_id_1 = token.query_token_id_by_index(U128::new(1));\n    let token_id_2 = token.query_token_id_by_index(U128::new(2));\n    assert_eq!(token.owner_of(token_id_1.clone()), owner);\n    assert_eq!(token.owner_of(token_id_2.clone()), owner);\n    let states = [(alice.clone(), token_id_1.clone()), (bob.clone(), token_id_2.clone())];\n    assert_eq!(token.transfer_multi(&states), true);\n    assert_eq!(token.owner_of(token_id_1.clone()), alice);\n    assert_eq!(token.owner_of(token_id_2.clone()), bob);\n}", "item_id": 3, "repo": "zhiqiangxu/ontology-wasm-cdt-rust", "file": "examples/oep5token/src/test.rs", "last_update_at": "2021-07-15T10:06:04+00:00", "question_id": "7382dcf7370d2f4b38588e9c78fdbf8dae7467b3_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn transfer_multi() {\n    let mut token = Oep5TokenInstance;\n    let owner = Address::zero();\n    build_runtime().witness(&[owner]);\n    assert_eq!(token.initialize(&owner), true);\n    let alice = Address::repeat_byte(1);\n    let bob = Address::repeat_byte(2);\n    let token_id_1 = token.query_token_id_by_index(U128::new(1));\n    let token_id_2 = token.query_token_id_by_index(U128::new(2));\n    assert_eq!(token.owner_of(token_id_1.clone()), owner);\n    assert_eq!(token.owner_of(token_id_2.clone()), owner);\n    let states = [(alice.clone(), token_id_1.clone()), (bob.clone(), token_id_2.clone())];\n    assert_eq!(token.transfer_multi(&states), true);\n    assert_eq!(token.owner_of(token_id_1.clone()), alice);\n    assert_eq!(token.owner_of(token_id_2.clone()), bob);\n"]], "pred": {"ppl": 2.1680965423583984, "ppl_lower": 2.3230948448181152, "ppl/lowercase_ppl": -1.089230087054342, "ppl/zlib": 0.002705767878300906, "Min_5.0% Prob": 7.947895560945783, "Min_10.0% Prob": 5.870231483663831, "Min_20.0% Prob": 3.5993089550419857, "Min_30.0% Prob": 2.544278667604222, "Min_40.0% Prob": 1.9257259119890238, "Min_50.0% Prob": 1.5512850017903346, "Min_60.0% Prob": 1.2893373947631437}}
{"hexsha": "2d7445fb25ed1c4ffb9e3497149f409456199d89", "ext": "rs", "lang": "Rust", "content": "pub fn handler(classes: &mut Classes, rl: &mut Editor<()>) -> bool {\n    let mut will_write = true;\n    let mut help = HashMap::<&str, (Option<&str>, &str, Option<&str>)>::new();\n\n    println!();\n\n    let late = classes.late();\n\n    if late.len() > 0 {\n        println!(\"You have some late assignments!\\n\\n{}\\n\", late.join(\"\\n\"));\n    }\n\n    help.insert(\"add\", (Some(\"<class> <date> <name...>\"), \"Adds a dated assignment to a class.\\n\\nDates should be formatted as 'd-m-y'.\\nExample: 31-1-2021\", Some(\"a\")));\n    help.insert(\"all\", (None, \"Displays assignments across all classes.\", None));\n    help.insert(\"clean\", (Some(\"<class>\"), \"Removes all completed assignments from a class.\", None));\n    help.insert(\"complete\", (Some(\"<class> <index>\"), \"Moves an assignment to a class's completed list.\", Some(\"c\")));\n    help.insert(\"create\", (Some(\"<id> <period> <name...>\"), \"Creates a class with metadata.\", None));\n    help.insert(\"delete\", (Some(\"<id>\"), \"Deletes a class, including all of its assignments.\", None));\n    help.insert(\"encode\", (None, \"Displays encoded class data.\", None));\n    help.insert(\"help\", (Some(\"(<command>)\"), \"Displays help info for a command.\\nIf no command is supplied, displays all commands.\", Some(\"h\")));\n    help.insert(\"info\", (Some(\"(<id>)\"), \"Displays class info and assignments.\\nIf no ID is supplied, displays all class info.\", Some(\"i\")));\n    help.insert(\"klog\", (Some(\"<avg> (<path>)\"), \"Displays assignment data in klog format.\\nThis is particularly useful for keeping track of\\nassignments you've completed with date and time.\\n\\nThe 'avg' argument is how many hours on average\\nyou'd expect to complete the assignments in.\\nYou can modify these values after writing.\\n\\nOptionally specify a path to write to.\\n'.klg' is automatically appended to the path.\\n\\nLearn more about klog at: https://klog.jotaen.net\", None));\n    help.insert(\"list\", (Some(\"(<sort>)\"), \"Lists all classes by ID and name.\\nYou can sort classes by id, name and period (default).\", Some(\"ls, l\")));\n    help.insert(\"modify\", (Some(\"<id> <property> <value...>\"), \"Modifies class metadata by input.\\nClass ID cannot be modified.\", Some(\"mod, m\")));\n    help.insert(\"panic\", (None, \"Prevents writing to config upon exiting the program.\\nThis is useful if you've made an irreversible mistake while editing.\", None));\n    help.insert(\"quit\", (None, \"Exits the program.\", Some(\"q\")));\n    help.insert(\"remove\", (Some(\"<id> <index>\"), \"Removes an assignment without completing it.\", Some(\"r\")));\n    help.insert(\"write\", (None, \"Writes encoded classes to the config file.\\nThis is done automatically upon exit.\", Some(\"w\")));\n\n    loop {\n        match input(rl) {\n            Some(args) => {\n                //println!(\"{:#?}\", args);\n                match args.command.as_str() {\n                    \"add\" | \"a\" => {\n                        if args.check(3, true) {\n                            match classes.get_class(&args) {\n                                Ok(c) => {\n                                    match Assignment::parse_date(args.list[1].as_str()) {\n                                        Ok(d) => {\n                                            c.add_assignment(args.input_from(2), d);\n                                            println!(\"\\n{}\", c.display_info());\n                                        }\n                                        Err(e) => err(e)\n                                    }\n                                },\n                                Err(e) => err(e)\n                            }  \n                        }\n                    }\n                    \"all\" => {\n                        println!(\"\\n{}\", classes.display_all_combined());\n                    }\n                    \"clean\" => {\n                        if args.check(1, true) {\n                            match classes.get_class(&args) {\n                                Ok(c) => {\n                                    c.completed.clear();\n                                    println!(\"\\n{}\", c.display_info());\n                                },\n                                Err(e) => err(e)\n                            }\n                        }\n                    }\n                    \"complete\" | \"c\" => {\n                        if args.check(2, true) {\n                            match classes.get_class(&args) {\n                                Ok(c) => {\n                                    match to_int(&args.list[1]) {\n                                        Some(n) => {\n                                            match c.complete_assignment(n) {\n                                                Ok(_) => println!(\"\\n{}\", c.display_info()),\n                                                Err(e) => err(e)\n                                            }\n                                        }\n                                        None => ()\n                                    }\n                                },\n                                Err(e) => err(e)\n                            }  \n                        }\n                    }\n                    \"create\" => {\n                        if args.check(3, true) {\n                            let id = args.list[0].to_lowercase();\n\n                            if classes.map.contains_key(&id) {\n                                err(format!(\"Class ID '{}' already exists\", id));\n                            } else {\n                                match to_int(&args.list[1]) {\n                                    Some(n) => {\n                                        classes.add_class_data(id.clone(), args.input_from(2), n);\n                                        success(format!(\"created class '{}'\", id));\n                                    }\n                                    None => ()\n                                }\n                            }  \n                        }\n                    }\n                    \"delete\" => {\n                        if args.check(1, true) {\n                            match classes.remove_class(&args.list[0]) {\n                                Ok(c) => success(format!(\"deleted class '{}'\", c.name)),\n                                Err(e) => err(e)\n                            }\n                        }\n                    }\n                    \"encode\" => {\n                        println!(\"\\n{}\", classes.encode());\n                    }\n                    \"help\" | \"h\" => {\n                        if args.check(1, false) {\n                            if help.contains_key(&args.list[0].as_str()) {\n                                let data = help.get(&args.list[0].as_str()).unwrap();\n\n                                let arg_str = match data.0 {\n                                    Some(s) => String::from(s),\n                                    None => String::new()\n                                };\n\n                                println!(\"\\n{}\\n\\n{}{}\",\n                                    Class::str_property(\"Syntax\", &format!(\"{} {}\", args.list[0], arg_str)),\n                                    \n                                    data.1,\n\n                                    if data.2.is_some() { \n                                        format!(\"\\n\\n{}\", Class::str_property(\"Aliases\", &data.2.unwrap().to_string())) \n                                    } else { \n                                        String::new()\n                                    }\n                                );\n                            } else {\n                                err(format!(\"Command '{}' not found\", args.list[0]));\n                            }\n                        } else {\n                            let mut sorted_keys = help.keys().collect::<Vec<&&str>>();\n\n                            sorted_keys.sort();\n                            \n                            let lines = sorted_keys\n                                .iter()\n                                .map(|k| {\n                                    let l = help.get(*k).unwrap().1.split(\"\\n\").collect::<Vec<&str>>()[0];\n                                    Class::info_property(k, &l.to_string(), Green.bold())\n                                })\n                                .collect::<Vec<String>>();\n                                \n                            println!(\"\\n{}\", lines.join(\"\\n\"));\n                        }\n                    }\n                    \"info\" | \"i\" => {\n                        if args.check(1, false) {\n                            match classes.get_class(&args) {\n                                Ok(c) => println!(\"\\n{}\", c.display_info()),\n                                Err(e) => err(e)\n                            }\n                        } else {\n                            println!(\"\\n{}\", classes.display_all_info());\n                        }\n                    }\n                    \"klog\" => {\n                        if args.check(1, true) {\n                            match to_int(&args.list[0]) {\n                                Some(n) => {\n                                    let data = classes.klog(n);\n                                    \n                                    if args.check(2, false) {\n                                        let mut path = PathBuf::from(args.list[1].clone());\n                                        path.set_extension(\"klg\");\n\n                                        classes.write(path, data);\n                                    } else {\n                                        println!(\"\\n{}\", data);\n                                    }\n                                }\n                                None => ()\n                            }\n                        }\n                    }\n                    \"list\" | \"ls\" | \"l\" => {\n                        use SortingMethod::*;\n\n                        let by_period: Option<SortingMethod> = if args.check(1, false) {\n                            match args.list[0].to_lowercase().as_str() {\n                                \"id\" => Some(ID),\n                                \"name\" => Some(Name),\n                                \"period\" => Some(Period),\n                                _ => None\n                            }\n                        } else { \n                            Some(Period)\n                        };\n\n                        match by_period {\n                            Some(v) => println!(\"\\n{}\", classes.display_list(v)),\n                            None => err(format!(\"Invalid sorting method '{}'\", args.list[0]))\n                        }\n                    }\n                    \"modify\" | \"mod\" | \"m\" => {\n                        if args.check(3, true) {\n                            match classes.get_class(&args) {\n                                Ok(c) => {\n                                    match c.modify(args.list[1].clone(), args.input_from(2)) {\n                                        Ok(_) => success(format!(\"modified '{}'\", c.name)),\n                                        Err(e) => err(e)\n                                    }\n                                },\n                                Err(e) => err(e)\n                            }\n                        }\n                    }\n                    \"panic\" => {\n                        will_write = false;\n                        success(String::from(\"prevented write on shutdown. None of the changes made during this session will be saved.\\nTo view the encoded version of the changes you've made, run 'encode'.\"));\n                    }\n                    \"quit\" | \"q\" => {\n                        print!(\"Exiting... \");\n                        break;\n                    }\n                    \"remove\" | \"r\" => {\n                        if args.check(2, true) {\n                            match classes.get_class(&args) {\n                                Ok(c) => {\n                                    match to_int(&args.list[1]) {\n                                        Some(n) => {\n                                            match c.remove_assignment(n) {\n                                                Ok(_) => println!(\"\\n{}\", c.display_info()),\n                                                Err(e) => err(e)\n                                            }\n                                        }\n                                        None => ()\n                                    }\n                                },\n                                Err(e) => err(e)\n                            }  \n                        }\n                    }\n                    \"write\" | \"w\" => {\n                        write_config(&classes);\n                    }\n                    _ => err(format!(\"Unrecognized command '{}'. Run 'help' for a list of commands.\", args.command))\n                }\n\n                println!();\n            }\n            None => { \n                print!(\"Exiting... \");\n                break;\n            }\n        }\n    }\n\n    will_write\n}", "item_id": 0, "repo": "acikek/skid", "file": "src/cli/handler.rs", "last_update_at": "2021-09-01T10:15:24+00:00", "question_id": "2d7445fb25ed1c4ffb9e3497149f409456199d89_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn handler(classes: &mut Classes, rl: &mut Editor<()>) -> bool {\n    let mut will_write = true;\n    let mut help = HashMap::<&str, (Option<&str>, &str, Option<&str>)>::new();\n    println!();\n    let late = classes.late();\n    if late.len() > 0 {\n        println!(\"You have some late assignments!\\n\\n{}\\n\", late.join(\"\\n\"));\n    }\n    help.insert(\"add\", (Some(\"<class> <date> <name...>\"), \"Adds a dated assignment to a class.\\n\\nDates should be formatted as 'd-m-y'.\\nExample: 31-1-2021\", Some(\"a\")));\n    help.insert(\"all\", (None, \"Displays assignments across all classes.\", None));\n    help.insert(\"clean\", (Some(\"<class>\"), \"Removes all completed assignments from a class.\", None));\n    help.insert(\"complete\", (Some(\"<class> <index>\"), \"Moves an assignment to a class's completed list.\", Some(\"c\")));\n    help.insert(\"create\", (Some(\"<id> <period> <name...>\"), \"Creates a class with metadata.\", None));\n    help.insert(\"delete\", (Some(\"<id>\"), \"Deletes a class, including all of its assignments.\", None));\n    help.insert(\"encode\", (None, \"Displays encoded class data.\", None));\n    help.insert(\"help\", (Some(\"(<command>)\"), \"Displays help info for a command.\\nIf no command is supplied, displays all commands.\", Some(\"h\")));\n    help.insert(\"info\", (Some(\"(<id>)\"), \"Displays class info and assignments.\\nIf no ID is supplied, displays all class info.\", Some(\"i\")));\n    help.insert(\"klog\", (Some(\"<avg> (<path>)\"), \"Displays assignment data in klog format.\\nThis is particularly useful for keeping track of\\nassignments you've completed with date and time.\\n\\nThe 'avg' argument is how many hours on average\\nyou'd expect to complete the assignments in.\\nYou can modify these values after writing.\\n\\nOptionally specify a path to write to.\\n'.klg' is automatically appended to the path.\\n\\nLearn more about klog at: https://klog.jotaen.net\", None));\n    help.insert(\"list\", (Some(\"(<sort>)\"), \"Lists all classes by ID and name.\\nYou can sort classes by id, name and period (default).\", Some(\"ls, l\")));\n    help.insert(\"modify\", (Some(\"<id> <property> <value...>\"), \"Modifies class metadata by input.\\nClass ID cannot be modified.\", Some(\"mod, m\")));\n    help.insert(\"panic\", (None, \"Prevents writing to config upon exiting the program.\\nThis is useful if you've made an irreversible mistake while editing.\", None));\n    help.insert(\"quit\", (None, \"Exits the program.\", Some(\"q\")));\n    help.insert(\"remove\", (Some(\"<id> <index>\"), \"Removes an assignment without completing it.\", Some(\"r\")));\n    help.insert(\"write\", (None, \"Writes encoded classes to the config file.\\nThis is done automatically upon exit.\", Some(\"w\")));\n    loop {\n        match input(rl) {\n            Some(args) => {\n                //println!(\"{:#?}\", args);\n                match args.command.as_str() {\n                    \"add\" | \"a\" => {\n                        if args.check(3, true) {\n                            match classes.get_class(&args) {\n                                Ok(c) => {\n                                    match Assignment::parse_date(args.list[1].as_str()) {\n                                        Ok(d) => {\n                                            c.add_assignment(args.input_from(2), d);\n                                            println!(\"\\n{}\", c.display_info());\n                                        }\n                                        Err(e) => err(e)\n                                    }\n                                },\n                                Err(e) => err(e)\n                            }  \n                        }\n                    }\n                    \"all\" => {\n                        println!(\"\\n{}\", classes.display_all_combined());\n                    }\n                    \"clean\" => {\n                        if args.check(1, true) {\n                            match classes.get_class(&args) {\n                                Ok(c) => {\n                                    c.completed.clear();\n                                    println!(\"\\n{}\", c.display_info());\n                                },\n                                Err(e) => err(e)\n                            }\n                        }\n                    }\n                    \"complete\" | \"c\" => {\n                        if args.check(2, true) {\n                            match classes.get_class(&args) {\n                                Ok(c) => {\n                                    match to_int(&args.list[1]) {\n                                        Some(n) => {\n                                            match c.complete_assignment(n) {\n                                                Ok(_) => println!(\"\\n{}\", c.display_info()),\n                                                Err(e) => err(e)\n                                            }\n                                        }\n                                        None => ()\n                                    }\n                                },\n                                Err(e) => err(e)\n                            }  \n                        }\n                    }\n                    \"create\" => {\n                        if args.check(3, true) {\n                            let id = args.list[0].to_lowercase();\n                            if classes.map.contains_key(&id) {\n                                err(format!(\"Class ID '{}' already exists\", id));\n                            } else {\n                                match to_int(&args.list[1]) {\n                                    Some(n) => {\n                                        classes.add_class_data(id.clone(), args.input_from(2), n);\n                                        success(format!(\"created class '{}'\", id));\n                                    }\n                                    None => ()\n                                }\n                            }  \n                        }\n                    }\n                    \"delete\" => {\n                        if args.check(1, true) {\n                            match classes.remove_class(&args.list[0]) {\n                                Ok(c) => success(format!(\"deleted class '{}'\", c.name)),\n                                Err(e) => err(e)\n                            }\n                        }\n                    }\n                    \"encode\" => {\n                        println!(\"\\n{}\", classes.encode());\n                    }\n                    \"help\" | \"h\" => {\n                        if args.check(1, false) {\n                            if help.contains_key(&args.list[0].as_str()) {\n                                let data = help.get(&args.list[0].as_str()).unwrap();\n                                let arg_str = match data.0 {\n                                    Some(s) => String::from(s),\n                                    None => String::new()\n                                };\n                                println!(\"\\n{}\\n\\n{}{}\",\n                                    Class::str_property(\"Syntax\", &format!(\"{} {}\", args.list[0], arg_str)),\n                                    data.1,\n                                    if data.2.is_some() { \n                                        format!(\"\\n\\n{}\", Class::str_property(\"Aliases\", &data.2.unwrap().to_string())) \n                                    } else { \n                                        String::new()\n                                    }\n                                );\n                            } else {\n                                err(format!(\"Command '{}' not found\", args.list[0]));\n                            }\n                        } else {\n                            let mut sorted_keys = help.keys().collect::<Vec<&&str>>();\n                            sorted_keys.sort();\n                            let lines = sorted_keys\n                                .iter()\n                                .map(|k| {\n                                    let l = help.get(*k).unwrap().1.split(\"\\n\").collect::<Vec<&str>>()[0];\n                                    Class::info_property(k, &l.to_string(), Green.bold())\n                                })\n                                .collect::<Vec<String>>();\n                            println!(\"\\n{}\", lines.join(\"\\n\"));\n                        }\n                    }\n                    \"info\" | \"i\" => {\n                        if args.check(1, false) {\n                            match classes.get_class(&args) {\n                                Ok(c) => println!(\"\\n{}\", c.display_info()),\n                                Err(e) => err(e)\n                            }\n                        } else {\n                            println!(\"\\n{}\", classes.display_all_info());\n                        }\n                    }\n                    \"klog\" => {\n                        if args.check(1, true) {\n                            match to_int(&args.list[0]) {\n                                Some(n) => {\n                                    let data = classes.klog(n);\n                                    if args.check(2, false) {\n                                        let mut path = PathBuf::from(args.list[1].clone());\n                                        path.set_extension(\"klg\");\n                                        classes.write(path, data);\n                                    } else {\n                                        println!(\"\\n{}\", data);\n                                    }\n                                }\n                                None => ()\n                            }\n                        }\n                    }\n                    \"list\" | \"ls\" | \"l\" => {\n                        use SortingMethod::*;\n                        let by_period: Option<SortingMethod> = if args.check(1, false) {\n                            match args.list[0].to_lowercase().as_str() {\n                                \"id\" => Some(ID),\n                                \"name\" => Some(Name),\n                                \"period\" => Some(Period),\n                                _ => None\n                            }\n                        } else { \n                            Some(Period)\n                        };\n                        match by_period {\n                            Some(v) => println!(\"\\n{}\", classes.display_list(v)),\n                            None => err(format!(\"Invalid sorting method '{}'\", args.list[0]))\n                        }\n                    }\n                    \"modify\" | \"mod\" | \"m\" => {\n                        if args.check(3, true) {\n                            match classes.get_class(&args) {\n                                Ok(c) => {\n                                    match c.modify(args.list[1].clone(), args.input_from(2)) {\n                                        Ok(_) => success(format!(\"modified '{}'\", c.name)),\n                                        Err(e) => err(e)\n                                    }\n                                },\n                                Err(e) => err(e)\n                            }\n                        }\n                    }\n                    \"panic\" => {\n                        will_write = false;\n                        success(String::from(\"prevented write on shutdown. None of the changes made during this session will be saved.\\nTo view the encoded version of the changes you've made, run 'encode'.\"));\n                    }\n                    \"quit\" | \"q\" => {\n                        print!(\"Exiting... \");\n                        break;\n                    }\n                    \"remove\" | \"r\" => {\n                        if args.check(2, true) {\n                            match classes.get_class(&args) {\n                                Ok(c) => {\n                                    match to_int(&args.list[1]) {\n                                        Some(n) => {\n                                            match c.remove_assignment(n) {\n                                                Ok(_) => println!(\"\\n{}\", c.display_info()),\n                                                Err(e) => err(e)\n                                            }\n                                        }\n                                        None => ()\n                                    }\n                                },\n                                Err(e) => err(e)\n                            }  \n                        }\n                    }\n                    \"write\" | \"w\" => {\n                        write_config(&classes);\n                    }\n                    _ => err(format!(\"Unrecognized command '{}'. Run 'help' for a list of commands.\", args.command))\n                }\n                println!();\n            }\n            None => { \n                print!(\"Exiting... \");\n                break;\n            }\n        }\n    }\n    will_write\n"]], "pred": {"ppl": 3.0299530029296875, "ppl_lower": 3.136704921722412, "ppl/lowercase_ppl": -1.0312352554514583, "ppl/zlib": 0.0004301696192536771, "Min_5.0% Prob": 7.590997406080658, "Min_10.0% Prob": 5.96248536717658, "Min_20.0% Prob": 4.255940721315496, "Min_30.0% Prob": 3.2998088765767664, "Min_40.0% Prob": 2.651540920539124, "Min_50.0% Prob": 2.1869062529967955, "Min_60.0% Prob": 1.8435373957379801}}
{"hexsha": "c84149e09857d3bda75ba75990ddd96ca9ab52e0", "ext": "rs", "lang": "Rust", "content": "fn read_vp8_chunk(chunk: &mut RiffChunk) -> Result<VP8Metadata> {\n    let r = chunk.contents();\n\n    let mut hdr = [0u8; 3];\n    try!(r.read_exact(&mut hdr).map_err(if_eof!(std, \"when reading VP8 frame header\")));\n\n    let mut result = VP8Metadata {\n        version_number: 0,\n        show_frame: false,\n        first_partition_len: 0,\n        frame: VP8Frame::Inter\n    };\n\n    // bits of first three bytes:\n    //    xxxsvvvf xxxxxxxx xxxxxxxx\n    // where\n    //    f  --  frame type, 0 is key frame, 1 is interframe\n    //    v  --  version number\n    //    s  --  show frame flag, 1 is display, 0 is don't display\n    //    x  --  size of first data partition in bytes\n\n    let key_frame = hdr[0] & 1 == 0;\n    result.version_number = (hdr[0] >> 1) & 7;\n    result.show_frame = (hdr[0] >> 4) & 1 == 1;\n    result.first_partition_len = ((hdr[0] >> 5) as u32) | \n                                 ((hdr[1] as u32) << 3) | \n                                 ((hdr[2] as u32) << 11);\n\n    if key_frame {\n        let mut hdr = [0u8; 7];\n        try!(r.read_exact(&mut hdr).map_err(if_eof!(std, \"when reading VP8 key frame header\")));\n\n        // check magic value\n        if &hdr[..3] != &[0x9d, 0x01, 0x2a] {\n            return Err(invalid_format!(\"VP8 key frame magic code is invalid: {:?}\", &hdr[..3]));\n        }\n\n        // bits of next four bytes:\n        //    wwwwwwww xxwwwwww hhhhhhhh yyhhhhhh\n        // where\n        //    x  --  horizontal scale\n        //    w  --  width\n        //    y  --  vertical scale\n        //    h  --  height\n\n        let width  = ((hdr[4] & 0x3f) as u32) << 8 | hdr[3] as u32;\n        let height = ((hdr[6] & 0x3f) as u32) << 8 | hdr[5] as u32;\n        let x_scale = hdr[4] >> 6;\n        let y_scale = hdr[6] >> 6;\n\n        result.frame = VP8Frame::Key {\n            dimensions: (width, height).into(),\n            x_scale: x_scale,\n            y_scale: y_scale\n        };\n    }\n\n    Ok(result)\n}", "item_id": 0, "repo": "jasongraalum/immeta", "file": "src/formats/webp.rs", "last_update_at": "2021-12-23T10:30:29+00:00", "question_id": "c84149e09857d3bda75ba75990ddd96ca9ab52e0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn read_vp8_chunk(chunk: &mut RiffChunk) -> Result<VP8Metadata> {\n    let r = chunk.contents();\n    let mut hdr = [0u8; 3];\n    try!(r.read_exact(&mut hdr).map_err(if_eof!(std, \"when reading VP8 frame header\")));\n    let mut result = VP8Metadata {\n        version_number: 0,\n        show_frame: false,\n        first_partition_len: 0,\n        frame: VP8Frame::Inter\n    };\n    // bits of first three bytes:\n    //    xxxsvvvf xxxxxxxx xxxxxxxx\n    // where\n    //    f  --  frame type, 0 is key frame, 1 is interframe\n    //    v  --  version number\n    //    s  --  show frame flag, 1 is display, 0 is don't display\n    //    x  --  size of first data partition in bytes\n    let key_frame = hdr[0] & 1 == 0;\n    result.version_number = (hdr[0] >> 1) & 7;\n    result.show_frame = (hdr[0] >> 4) & 1 == 1;\n    result.first_partition_len = ((hdr[0] >> 5) as u32) | \n                                 ((hdr[1] as u32) << 3) | \n                                 ((hdr[2] as u32) << 11);\n    if key_frame {\n        let mut hdr = [0u8; 7];\n        try!(r.read_exact(&mut hdr).map_err(if_eof!(std, \"when reading VP8 key frame header\")));\n        // check magic value\n        if &hdr[..3] != &[0x9d, 0x01, 0x2a] {\n            return Err(invalid_format!(\"VP8 key frame magic code is invalid: {:?}\", &hdr[..3]));\n        }\n        // bits of next four bytes:\n        //    wwwwwwww xxwwwwww hhhhhhhh yyhhhhhh\n        // where\n        //    x  --  horizontal scale\n        //    w  --  width\n        //    y  --  vertical scale\n        //    h  --  height\n        let width  = ((hdr[4] & 0x3f) as u32) << 8 | hdr[3] as u32;\n        let height = ((hdr[6] & 0x3f) as u32) << 8 | hdr[5] as u32;\n        let x_scale = hdr[4] >> 6;\n        let y_scale = hdr[6] >> 6;\n        result.frame = VP8Frame::Key {\n            dimensions: (width, height).into(),\n            x_scale: x_scale,\n            y_scale: y_scale\n        };\n    }\n    Ok(result)\n"]], "pred": {"ppl": 2.0189239978790283, "ppl_lower": 2.07705020904541, "ppl/lowercase_ppl": -1.0404005829677376, "ppl/zlib": 0.0009405149868466341, "Min_5.0% Prob": 6.282965028608167, "Min_10.0% Prob": 4.734431978818533, "Min_20.0% Prob": 3.1177000226201237, "Min_30.0% Prob": 2.249823371925696, "Min_40.0% Prob": 1.7381213836196296, "Min_50.0% Prob": 1.3998726245456485, "Min_60.0% Prob": 1.170686512147682}}
{"hexsha": "c3ee27846fb65d6ca3f263da3cddd453c14728a6", "ext": "rs", "lang": "Rust", "content": "fn test_word_automatic() {\n    let regex = generate_regex(\"automatic\");\n    let matcher = Regex::new(&regex).unwrap();\n    assert!(matcher.is_match(\"\u0985\u099f\u09cb\u09ae\u09c7\u099f\u09bf\u0995\"));\n}", "item_id": 841, "repo": "OpenBangla/engreji", "file": "tests/autocorrect.rs", "last_update_at": "2021-05-06T13:25:26+00:00", "question_id": "c3ee27846fb65d6ca3f263da3cddd453c14728a6_841", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_word_automatic() {\n    let regex = generate_regex(\"automatic\");\n    let matcher = Regex::new(&regex).unwrap();\n    assert!(matcher.is_match(\"\u0985\u099f\u09cb\u09ae\u09c7\u099f\u09bf\u0995\"));\n"]], "pred": {"ppl": 3.7586350440979004, "ppl_lower": 4.608892917633057, "ppl/lowercase_ppl": -1.1540205464599458, "ppl/zlib": 0.009007182798008813, "Min_5.0% Prob": 9.386897722880045, "Min_10.0% Prob": 8.144591172536215, "Min_20.0% Prob": 5.906629274288814, "Min_30.0% Prob": 4.254607121149699, "Min_40.0% Prob": 3.2064554035663604, "Min_50.0% Prob": 2.6465348995500997, "Min_60.0% Prob": 2.2415890156014546}}
{"hexsha": "2200788ed2620f6d693f556bc2b57826240231eb", "ext": "rs", "lang": "Rust", "content": "fn add_and_focus_webview<T, B>(window_index: u32, uri: Option<T>, buffer_config: Option<B>)\n    where B: BrowserConfiguration,\n          T: Into<String> {\n    let store = _WKUserContentExtensionStore::default_store();\n    let ref config = super::UI.engine.config;\n    let uri = uri.map(|u| u.into()).unwrap_or(String::new());\n    let mut private_browsing = config.use_private_browsing(&uri);\n    let mut use_plugins = config.use_plugins(&uri);\n    let mut skip_content_filter = config.skip_content_filter(&uri);\n    let mut use_js = config.use_javascript(&uri);\n    if let Some(buffer_config) = buffer_config {\n        private_browsing = buffer_config.use_private_browsing(&uri);\n        use_plugins = buffer_config.use_plugins(&uri);\n        skip_content_filter = buffer_config.skip_content_filter(&uri);\n        use_js = buffer_config.use_javascript(&uri);\n    }\n    let block = ConcreteBlock::new(move |filter: Id, err: Id| {\n        if let Some(window) = window_for_index(window_index) {\n            let container = subview(&window, WindowArea::WebView);\n            let subviews = container.subviews().unwrap();\n            for index in 0 .. subviews.count() {\n                if let Some(view) = subviews.get::<NSView>(index) {\n                    view.set_hidden(true);\n                }\n            }\n            let config = WKWebViewConfiguration::new().autorelease();\n            if private_browsing {\n                info!(\"blocking data storage in buffer\");\n                config.set_website_data_store(WKWebsiteDataStore::nonpersistent_store());\n            }\n            info!(\"setting plugins option to {}\", use_plugins);\n            config.preferences().set_plugins_enabled(use_plugins);\n            info!(\"setting js option to {}\", use_js);\n            config.preferences().set_javascript_enabled(use_js);\n            if let Some(filter) = _WKUserContentFilter::from_ptr(filter) {\n                config.user_content_controller().add_user_content_filter(filter);\n            } else if err != nil {\n                log_error_description(err);\n            }\n            let webview = WKWebView::new(CGRect::zero(), config).autorelease();\n            webview.set_navigation_delegate(WebViewHistoryDelegate::new());\n            webview.set_custom_user_agent(&default_user_agent());\n            let webview_view = webview.coerce::<NSView>().unwrap();\n            webview_view.disable_translates_autoresizing_mask_into_constraints();\n            container.add_subview(&webview_view);\n            container.add_constraint(NSLayoutConstraint::bind(&webview_view, NSLayoutAttribute::Top, &container, NSLayoutAttribute::Top));\n            container.add_constraint(NSLayoutConstraint::bind(&webview_view, NSLayoutAttribute::Bottom, &container, NSLayoutAttribute::Bottom));\n            container.add_constraint(NSLayoutConstraint::bind(&webview_view, NSLayoutAttribute::Left, &container, NSLayoutAttribute::Left));\n            container.add_constraint(NSLayoutConstraint::bind(&webview_view, NSLayoutAttribute::Right, &container, NSLayoutAttribute::Right));\n            if !uri.is_empty() {\n                webview.load_request(super::create_request(&uri));\n            }\n        }\n    });\n    if skip_content_filter {\n        let block = block.copy();\n        unsafe { block.call((nil, nil)); }\n    } else {\n        store.lookup_content_extension(\"filter\", &block.copy());\n    }\n}", "item_id": 5, "repo": "ozbe/webkitten", "file": "webkitten-cocoa/src/ui/window.rs", "last_update_at": "2021-10-14T00:16:01+00:00", "question_id": "2200788ed2620f6d693f556bc2b57826240231eb_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn add_and_focus_webview<T, B>(window_index: u32, uri: Option<T>, buffer_config: Option<B>)\n    where B: BrowserConfiguration,\n          T: Into<String> {\n    let store = _WKUserContentExtensionStore::default_store();\n    let ref config = super::UI.engine.config;\n    let uri = uri.map(|u| u.into()).unwrap_or(String::new());\n    let mut private_browsing = config.use_private_browsing(&uri);\n    let mut use_plugins = config.use_plugins(&uri);\n    let mut skip_content_filter = config.skip_content_filter(&uri);\n    let mut use_js = config.use_javascript(&uri);\n    if let Some(buffer_config) = buffer_config {\n        private_browsing = buffer_config.use_private_browsing(&uri);\n        use_plugins = buffer_config.use_plugins(&uri);\n        skip_content_filter = buffer_config.skip_content_filter(&uri);\n        use_js = buffer_config.use_javascript(&uri);\n    }\n    let block = ConcreteBlock::new(move |filter: Id, err: Id| {\n        if let Some(window) = window_for_index(window_index) {\n            let container = subview(&window, WindowArea::WebView);\n            let subviews = container.subviews().unwrap();\n            for index in 0 .. subviews.count() {\n                if let Some(view) = subviews.get::<NSView>(index) {\n                    view.set_hidden(true);\n                }\n            }\n            let config = WKWebViewConfiguration::new().autorelease();\n            if private_browsing {\n                info!(\"blocking data storage in buffer\");\n                config.set_website_data_store(WKWebsiteDataStore::nonpersistent_store());\n            }\n            info!(\"setting plugins option to {}\", use_plugins);\n            config.preferences().set_plugins_enabled(use_plugins);\n            info!(\"setting js option to {}\", use_js);\n            config.preferences().set_javascript_enabled(use_js);\n            if let Some(filter) = _WKUserContentFilter::from_ptr(filter) {\n                config.user_content_controller().add_user_content_filter(filter);\n            } else if err != nil {\n                log_error_description(err);\n            }\n            let webview = WKWebView::new(CGRect::zero(), config).autorelease();\n            webview.set_navigation_delegate(WebViewHistoryDelegate::new());\n            webview.set_custom_user_agent(&default_user_agent());\n            let webview_view = webview.coerce::<NSView>().unwrap();\n            webview_view.disable_translates_autoresizing_mask_into_constraints();\n            container.add_subview(&webview_view);\n            container.add_constraint(NSLayoutConstraint::bind(&webview_view, NSLayoutAttribute::Top, &container, NSLayoutAttribute::Top));\n            container.add_constraint(NSLayoutConstraint::bind(&webview_view, NSLayoutAttribute::Bottom, &container, NSLayoutAttribute::Bottom));\n            container.add_constraint(NSLayoutConstraint::bind(&webview_view, NSLayoutAttribute::Left, &container, NSLayoutAttribute::Left));\n            container.add_constraint(NSLayoutConstraint::bind(&webview_view, NSLayoutAttribute::Right, &container, NSLayoutAttribute::Right));\n            if !uri.is_empty() {\n                webview.load_request(super::create_request(&uri));\n            }\n        }\n    });\n    if skip_content_filter {\n        let block = block.copy();\n        unsafe { block.call((nil, nil)); }\n    } else {\n        store.lookup_content_extension(\"filter\", &block.copy());\n    }\n"]], "pred": {"ppl": 2.2694389820098877, "ppl_lower": 2.4475200176239014, "ppl/lowercase_ppl": -1.0921776785087376, "ppl/zlib": 0.0007666348516922759, "Min_5.0% Prob": 7.22955001955447, "Min_10.0% Prob": 5.5060259962594635, "Min_20.0% Prob": 3.6571647056969265, "Min_30.0% Prob": 2.6425396205062937, "Min_40.0% Prob": 2.0275600228298414, "Min_50.0% Prob": 1.6344655029635917, "Min_60.0% Prob": 1.3649068160723614}}
{"hexsha": "7fee3e7b85ab0adffe92126a30a634a5c76cb944", "ext": "rs", "lang": "Rust", "content": "fn bitxor_false() {\n        let mut p1 = Imp::new(true);\n        p1 ^= false;\n        assert_eq!(p1, true);\n    }", "item_id": 59, "repo": "samhamnam/interior_mutability_pointer", "file": "src/tests.rs", "last_update_at": "2021-11-28T20:47:51+00:00", "question_id": "7fee3e7b85ab0adffe92126a30a634a5c76cb944_59", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bitxor_false() {\n        let mut p1 = Imp::new(true);\n        p1 ^= false;\n        assert_eq!(p1, true);\n"]], "pred": {"ppl": 5.433780193328857, "ppl_lower": 6.188663482666016, "ppl/lowercase_ppl": -1.0768530033236714, "ppl/zlib": 0.019455575401536734, "Min_5.0% Prob": 10.242148399353027, "Min_10.0% Prob": 8.800132274627686, "Min_20.0% Prob": 6.399826258420944, "Min_30.0% Prob": 4.99459840854009, "Min_40.0% Prob": 3.8832983830395866, "Min_50.0% Prob": 3.3276100783121016, "Min_60.0% Prob": 2.869578423500061}}
{"hexsha": "b372998d3f05bbefc82598963ffe98842b1da74b", "ext": "rs", "lang": "Rust", "content": "fn round_trip_data() {\n        let instance = TestCase::new_with_output(\n            \"foo\",\n            \"bar\",\n            &TestResult::success(),\n            Cow::Borrowed(\"standard output\"),\n            Cow::Borrowed(\"standard error\"),\n            Duration::milliseconds(123456789),\n        );\n        assert_eq!(instance.name(), \"foo\");\n        assert_eq!(instance.class(), \"bar\");\n        assert_eq!(instance.result(), &TestResult::success());\n        assert_eq!(instance.stdout(), \"standard output\");\n        assert_eq!(instance.stderr(), \"standard error\");\n    }", "item_id": 0, "repo": "cloudbees-oss/juxr", "file": "src/reports/case.rs", "last_update_at": "2021-01-10T06:56:16+00:00", "question_id": "b372998d3f05bbefc82598963ffe98842b1da74b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn round_trip_data() {\n        let instance = TestCase::new_with_output(\n            \"foo\",\n            \"bar\",\n            &TestResult::success(),\n            Cow::Borrowed(\"standard output\"),\n            Cow::Borrowed(\"standard error\"),\n            Duration::milliseconds(123456789),\n        );\n        assert_eq!(instance.name(), \"foo\");\n        assert_eq!(instance.class(), \"bar\");\n        assert_eq!(instance.result(), &TestResult::success());\n        assert_eq!(instance.stdout(), \"standard output\");\n        assert_eq!(instance.stderr(), \"standard error\");\n"]], "pred": {"ppl": 2.4737651348114014, "ppl_lower": 2.859602689743042, "ppl/lowercase_ppl": -1.1600251127514505, "ppl/zlib": 0.003904057483108701, "Min_5.0% Prob": 8.073977061680385, "Min_10.0% Prob": 6.148104683558146, "Min_20.0% Prob": 3.9260607381020822, "Min_30.0% Prob": 2.862856608756045, "Min_40.0% Prob": 2.234330566866057, "Min_50.0% Prob": 1.8030162919548494, "Min_60.0% Prob": 1.5203728264276968}}
{"hexsha": "0a2a425f8c7ab0f667c6d55705bdfd8c4be3d356", "ext": "rs", "lang": "Rust", "content": "fn test_get_save_resource_quota() {\n        let ctx = SecurityContext::new(\"myorg\", \"myid\");\n        let ds = DefaultDataSource::new();\n        let locator = RepositoryLocator::new(&ds);\n        let pm = locator.new_persistence_manager();\n        pm.clear();\n        let realm = pm.realm_repository.create(&ctx, &SecurityRealm::new(\"myrealm\", None)).unwrap();\n\n        let resource = pm.new_resource_with(&ctx, &realm, \"report\").unwrap();\n        let loaded = pm.resource_repository.get(&ctx, \"myrealm\", resource.id.as_str()).unwrap();\n        assert_eq!(format!(\"{:?}\", resource), format!(\"{:?}\", loaded));\n\n        let org = pm.org_repository.create(&ctx, &Organization::new(\"\", None, \"myorg\", \"url\", None)).unwrap();\n\n        let policy = pm.license_policy_repository.create(&ctx, &LicensePolicy::new(\"\", org.id.as_str(), \"default-policy\", Some(\"desc\".to_string()), Utc::now().naive_utc(), NaiveDate::from_ymd(2100, 1, 1).and_hms(0, 0, 0))).unwrap();\n\n        let _ = pm.resource_quota_repository.create(&ctx, &ResourceQuota::new(\"\", resource.id.as_str(), policy.id.as_str(), \"\", 2, Utc::now().naive_utc(), NaiveDate::from_ymd(2100, 1, 1).and_hms(0, 0, 0))).unwrap();\n\n        let instance = pm.resource_instance_repository._create(&ctx, &ResourceInstance::new(\"\", resource.id.as_str(), \"22\", \"\", \"refid\", \"INFLIGHT\", Some(\"blah\".to_string()))).unwrap();\n\n        let loaded = pm.resource_instance_repository.get(&ctx, instance.id.as_str()).unwrap();\n        assert_eq!(format!(\"{:?}\", instance), format!(\"{:?}\", loaded));\n\n        let quota = pm.resource_quota_repository.create(&ctx, &ResourceQuota::new(\"\", resource.id.as_str(), \"22\", \"\", 22, Utc::now().naive_utc(), NaiveDate::from_ymd(2100, 1, 1).and_hms(0, 0, 0))).unwrap();\n        let loaded = pm.resource_quota_repository.get(&ctx, quota.id.as_str()).unwrap();\n        assert_eq!(format!(\"{:?}\", quota), format!(\"{:?}\", loaded));\n    }", "item_id": 7, "repo": "bhatti/saas_rbac", "file": "rbac/src/plexrbac/persistence/manager.rs", "last_update_at": "2021-08-03T11:03:18+00:00", "question_id": "0a2a425f8c7ab0f667c6d55705bdfd8c4be3d356_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_get_save_resource_quota() {\n        let ctx = SecurityContext::new(\"myorg\", \"myid\");\n        let ds = DefaultDataSource::new();\n        let locator = RepositoryLocator::new(&ds);\n        let pm = locator.new_persistence_manager();\n        pm.clear();\n        let realm = pm.realm_repository.create(&ctx, &SecurityRealm::new(\"myrealm\", None)).unwrap();\n        let resource = pm.new_resource_with(&ctx, &realm, \"report\").unwrap();\n        let loaded = pm.resource_repository.get(&ctx, \"myrealm\", resource.id.as_str()).unwrap();\n        assert_eq!(format!(\"{:?}\", resource), format!(\"{:?}\", loaded));\n        let org = pm.org_repository.create(&ctx, &Organization::new(\"\", None, \"myorg\", \"url\", None)).unwrap();\n        let policy = pm.license_policy_repository.create(&ctx, &LicensePolicy::new(\"\", org.id.as_str(), \"default-policy\", Some(\"desc\".to_string()), Utc::now().naive_utc(), NaiveDate::from_ymd(2100, 1, 1).and_hms(0, 0, 0))).unwrap();\n        let _ = pm.resource_quota_repository.create(&ctx, &ResourceQuota::new(\"\", resource.id.as_str(), policy.id.as_str(), \"\", 2, Utc::now().naive_utc(), NaiveDate::from_ymd(2100, 1, 1).and_hms(0, 0, 0))).unwrap();\n        let instance = pm.resource_instance_repository._create(&ctx, &ResourceInstance::new(\"\", resource.id.as_str(), \"22\", \"\", \"refid\", \"INFLIGHT\", Some(\"blah\".to_string()))).unwrap();\n        let loaded = pm.resource_instance_repository.get(&ctx, instance.id.as_str()).unwrap();\n        assert_eq!(format!(\"{:?}\", instance), format!(\"{:?}\", loaded));\n        let quota = pm.resource_quota_repository.create(&ctx, &ResourceQuota::new(\"\", resource.id.as_str(), \"22\", \"\", 22, Utc::now().naive_utc(), NaiveDate::from_ymd(2100, 1, 1).and_hms(0, 0, 0))).unwrap();\n        let loaded = pm.resource_quota_repository.get(&ctx, quota.id.as_str()).unwrap();\n        assert_eq!(format!(\"{:?}\", quota), format!(\"{:?}\", loaded));\n"]], "pred": {"ppl": 2.170530080795288, "ppl_lower": 2.3486692905426025, "ppl/lowercase_ppl": -1.1017811655459027, "ppl/zlib": 0.0013740627918188315, "Min_5.0% Prob": 7.570493452476732, "Min_10.0% Prob": 5.5390517242027055, "Min_20.0% Prob": 3.498541877125249, "Min_30.0% Prob": 2.5014387606972397, "Min_40.0% Prob": 1.9175608087839051, "Min_50.0% Prob": 1.5454587446695025, "Min_60.0% Prob": 1.2905020608220983}}
{"hexsha": "95778c540c831a7d750f745440297bf357d08f39", "ext": "rs", "lang": "Rust", "content": "fn artist_menu(artist: &ArtistLink) -> Menu<AppState> {\n    let mut menu = Menu::empty();\n\n    menu = menu.entry(\n        MenuItem::new(\n            LocalizedString::new(\"menu-item-copy-link\").with_placeholder(\"Copy Link to Artist\"),\n        )\n        .command(cmd::COPY.with(artist.url())),\n    );\n\n    menu\n}", "item_id": 1, "repo": "soooch/psst", "file": "psst-gui/src/ui/artist.rs", "last_update_at": "2021-08-22T03:53:29+00:00", "question_id": "95778c540c831a7d750f745440297bf357d08f39_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn artist_menu(artist: &ArtistLink) -> Menu<AppState> {\n    let mut menu = Menu::empty();\n    menu = menu.entry(\n        MenuItem::new(\n            LocalizedString::new(\"menu-item-copy-link\").with_placeholder(\"Copy Link to Artist\"),\n        )\n        .command(cmd::COPY.with(artist.url())),\n    );\n    menu\n"]], "pred": {"ppl": 2.7633931636810303, "ppl_lower": 5.05298376083374, "ppl/lowercase_ppl": -1.5937469035144705, "ppl/zlib": 0.0048634417787451764, "Min_5.0% Prob": 8.770517921447754, "Min_10.0% Prob": 6.246790432929993, "Min_20.0% Prob": 4.073821580410003, "Min_30.0% Prob": 3.0624826927979787, "Min_40.0% Prob": 2.4460947319865225, "Min_50.0% Prob": 1.9905760118774338, "Min_60.0% Prob": 1.687326712808648}}
{"hexsha": "7f92dedc1d0e24f99ebf71a33338209e33fbc65a", "ext": "rs", "lang": "Rust", "content": "fn verify_txn_accepts_genesis_write_set() {\n    let test_env = TestEnvironment::empty();\n    assert_eq!(test_env.get_version(), 0);\n\n    proptest!(|(txn in SignedTransaction::genesis_strategy())| {\n        test_env.verify_txn(txn).expect(\"genesis write set txns should verify correctly\");\n    });\n}", "item_id": 6, "repo": "end-o/libra", "file": "language/functional_tests/_old_move_ir_tests/src/tests/verify_transaction.rs", "last_update_at": "2021-01-15T08:27:10+00:00", "question_id": "7f92dedc1d0e24f99ebf71a33338209e33fbc65a_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn verify_txn_accepts_genesis_write_set() {\n    let test_env = TestEnvironment::empty();\n    assert_eq!(test_env.get_version(), 0);\n    proptest!(|(txn in SignedTransaction::genesis_strategy())| {\n        test_env.verify_txn(txn).expect(\"genesis write set txns should verify correctly\");\n    });\n"]], "pred": {"ppl": 4.091525554656982, "ppl_lower": 5.201102256774902, "ppl/lowercase_ppl": -1.170309909027186, "ppl/zlib": 0.0069748410730571956, "Min_5.0% Prob": 9.06959581375122, "Min_10.0% Prob": 7.416211652755737, "Min_20.0% Prob": 5.527324664592743, "Min_30.0% Prob": 4.283251583576202, "Min_40.0% Prob": 3.390439358353615, "Min_50.0% Prob": 2.7795283010602, "Min_60.0% Prob": 2.3472018100321295}}
{"hexsha": "9db605c1484379e94b041d4898aad9d9e67107f0", "ext": "rs", "lang": "Rust", "content": "unsafe fn perform_impl(\n    request: *const u8,\n    request_length: i32,\n    response: *mut u8,\n    response_length: i32,\n) -> Result<i32> {\n    let request_data = std::slice::from_raw_parts(request, request_length as usize);\n    let game_request = GameRequest::decode(request_data)?;\n    let command_list = requests::perform_action(game_request)?;\n    let mut out = std::slice::from_raw_parts_mut(response, response_length as usize);\n    command_list.encode(&mut out)?;\n    Ok(command_list.encoded_len() as i32)\n}", "item_id": 2, "repo": "thurn/Spelldawn", "file": "crates/plugin/src/lib.rs", "last_update_at": "2021-12-30T19:13:53+00:00", "question_id": "9db605c1484379e94b041d4898aad9d9e67107f0_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe fn perform_impl(\n    request: *const u8,\n    request_length: i32,\n    response: *mut u8,\n    response_length: i32,\n) -> Result<i32> {\n    let request_data = std::slice::from_raw_parts(request, request_length as usize);\n    let game_request = GameRequest::decode(request_data)?;\n    let command_list = requests::perform_action(game_request)?;\n    let mut out = std::slice::from_raw_parts_mut(response, response_length as usize);\n    command_list.encode(&mut out)?;\n    Ok(command_list.encoded_len() as i32)\n"]], "pred": {"ppl": 2.518073320388794, "ppl_lower": 2.940973997116089, "ppl/lowercase_ppl": -1.1681080280908607, "ppl/zlib": 0.003784811695493939, "Min_5.0% Prob": 8.592255294322968, "Min_10.0% Prob": 6.296876668930054, "Min_20.0% Prob": 4.1506761768284965, "Min_30.0% Prob": 3.0147128549276614, "Min_40.0% Prob": 2.28821244760268, "Min_50.0% Prob": 1.8515802612744792, "Min_60.0% Prob": 1.5498030373410692}}
{"hexsha": "86ed672fbc4757daa501d3250935362095976981", "ext": "rs", "lang": "Rust", "content": "pub async fn add_comment(\n    configuration: &configuration::Configuration,\n    params: AddCommentParams,\n) -> Result<models::Comment, Error<AddCommentError>> {\n    // unbox the parameters\n    let issue_id_or_key = params.issue_id_or_key;\n    let request_body = params.request_body;\n    let expand = params.expand;\n\n    let local_var_client = &configuration.client;\n\n    let local_var_uri_str = format!(\n        \"{}/rest/api/3/issue/{issueIdOrKey}/comment\",\n        configuration.base_path,\n        issueIdOrKey = crate::gen::apis::urlencode(issue_id_or_key)\n    );\n    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());\n\n    if let Some(ref local_var_str) = expand {\n        local_var_req_builder =\n            local_var_req_builder.query(&[(\"expand\", &local_var_str.to_string())]);\n    }\n    if let Some(ref local_var_user_agent) = configuration.user_agent {\n        local_var_req_builder =\n            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());\n    }\n    if let Some(ref local_var_token) = configuration.oauth_access_token {\n        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());\n    };\n    if let Some(ref local_var_auth_conf) = configuration.basic_auth {\n        local_var_req_builder = local_var_req_builder.basic_auth(\n            local_var_auth_conf.0.to_owned(),\n            local_var_auth_conf.1.to_owned(),\n        );\n    };\n    local_var_req_builder = local_var_req_builder.json(&request_body);\n\n    let local_var_req = local_var_req_builder.build()?;\n    let local_var_resp = local_var_client.execute(local_var_req).await?;\n\n    let local_var_status = local_var_resp.status();\n    let local_var_content = local_var_resp.text().await?;\n\n    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {\n        serde_json::from_str(&local_var_content).map_err(Error::from)\n    } else {\n        let local_var_entity: Option<AddCommentError> =\n            serde_json::from_str(&local_var_content).ok();\n        let local_var_error = ResponseContent {\n            status: local_var_status,\n            content: local_var_content,\n            entity: local_var_entity,\n        };\n        Err(Error::ResponseError(local_var_error))\n    }\n}", "item_id": 0, "repo": "hdost/jira-rust", "file": "src/gen/apis/issue_comments_api.rs", "last_update_at": "2021-11-05T06:00:43+00:00", "question_id": "86ed672fbc4757daa501d3250935362095976981_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn add_comment(\n    configuration: &configuration::Configuration,\n    params: AddCommentParams,\n) -> Result<models::Comment, Error<AddCommentError>> {\n    // unbox the parameters\n    let issue_id_or_key = params.issue_id_or_key;\n    let request_body = params.request_body;\n    let expand = params.expand;\n    let local_var_client = &configuration.client;\n    let local_var_uri_str = format!(\n        \"{}/rest/api/3/issue/{issueIdOrKey}/comment\",\n        configuration.base_path,\n        issueIdOrKey = crate::gen::apis::urlencode(issue_id_or_key)\n    );\n    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());\n    if let Some(ref local_var_str) = expand {\n        local_var_req_builder =\n            local_var_req_builder.query(&[(\"expand\", &local_var_str.to_string())]);\n    }\n    if let Some(ref local_var_user_agent) = configuration.user_agent {\n        local_var_req_builder =\n            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());\n    }\n    if let Some(ref local_var_token) = configuration.oauth_access_token {\n        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());\n    };\n    if let Some(ref local_var_auth_conf) = configuration.basic_auth {\n        local_var_req_builder = local_var_req_builder.basic_auth(\n            local_var_auth_conf.0.to_owned(),\n            local_var_auth_conf.1.to_owned(),\n        );\n    };\n    local_var_req_builder = local_var_req_builder.json(&request_body);\n    let local_var_req = local_var_req_builder.build()?;\n    let local_var_resp = local_var_client.execute(local_var_req).await?;\n    let local_var_status = local_var_resp.status();\n    let local_var_content = local_var_resp.text().await?;\n    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {\n        serde_json::from_str(&local_var_content).map_err(Error::from)\n    } else {\n        let local_var_entity: Option<AddCommentError> =\n            serde_json::from_str(&local_var_content).ok();\n        let local_var_error = ResponseContent {\n            status: local_var_status,\n            content: local_var_content,\n            entity: local_var_entity,\n        };\n        Err(Error::ResponseError(local_var_error))\n    }\n"]], "pred": {"ppl": 1.5123648643493652, "ppl_lower": 1.7497283220291138, "ppl/lowercase_ppl": -1.3524170543955143, "ppl/zlib": 0.000573751124891208, "Min_5.0% Prob": 5.613287706632872, "Min_10.0% Prob": 3.5835823311999038, "Min_20.0% Prob": 2.011496798311536, "Min_30.0% Prob": 1.368995779632453, "Min_40.0% Prob": 1.0343884456752226, "Min_50.0% Prob": 0.827004989610374, "Min_60.0% Prob": 0.6900142114576853}}
{"hexsha": "a5dea9d5fea1f6f8165a1665f74f310adddbb7f4", "ext": "rs", "lang": "Rust", "content": "fn pattern_to_number(pattern: &str, alphabet: &[char]) -> Result<usize, Error> {\n    let num_alphabets = alphabet.len();\n    let alphabet_map: HashMap<char, char> = alphabet\n        .iter()\n        .enumerate()\n        .map(|(n, c)| {\n            (\n                *c,\n                char::from_digit(n as u32, num_alphabets as u32)\n                    .unwrap()\n                    .to_ascii_uppercase(),\n            )\n        })\n        .collect();\n    Ok(RadixNum::from_str(\n        &pattern\n            .chars()\n            .map(|c| alphabet_map[&c])\n            .collect::<String>(),\n        num_alphabets,\n    )?\n        .as_decimal()?)\n}", "item_id": 1, "repo": "Ninjani/rosalind", "file": "t_ba1l/src/lib.rs", "last_update_at": "2021-09-17T20:50:36+00:00", "question_id": "a5dea9d5fea1f6f8165a1665f74f310adddbb7f4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn pattern_to_number(pattern: &str, alphabet: &[char]) -> Result<usize, Error> {\n    let num_alphabets = alphabet.len();\n    let alphabet_map: HashMap<char, char> = alphabet\n        .iter()\n        .enumerate()\n        .map(|(n, c)| {\n            (\n                *c,\n                char::from_digit(n as u32, num_alphabets as u32)\n                    .unwrap()\n                    .to_ascii_uppercase(),\n            )\n        })\n        .collect();\n    Ok(RadixNum::from_str(\n        &pattern\n            .chars()\n            .map(|c| alphabet_map[&c])\n            .collect::<String>(),\n        num_alphabets,\n    )?\n        .as_decimal()?)\n"]], "pred": {"ppl": 1.979409098625183, "ppl_lower": 2.2614099979400635, "ppl/lowercase_ppl": -1.1950651221678412, "ppl/zlib": 0.002246047253710723, "Min_5.0% Prob": 6.366622352600098, "Min_10.0% Prob": 4.831545066833496, "Min_20.0% Prob": 3.0471235673602033, "Min_30.0% Prob": 2.2039785443759357, "Min_40.0% Prob": 1.688928410774324, "Min_50.0% Prob": 1.3693335817615484, "Min_60.0% Prob": 1.1374780531760638}}
{"hexsha": "f1cd11120a491962bbd301a9efa607a0b4aee9a8", "ext": "rs", "lang": "Rust", "content": "fn test_auto() {\n    let trace = false;\n    test_file(\"./tests/data/builtins.gos\", trace);\n    test_file(\"./tests/data/const0.gos\", trace);\n    test_file(\"./tests/data/const1.gos\", trace);\n    test_file(\"./tests/data/constdecl.gos\", trace);\n    test_file(\"./tests/data/conversions.gos\", trace);\n    test_file(\"./tests/data/conversions2.gos\", trace);\n    test_file(\"./tests/data/cycles.gos\", trace);\n    test_file(\"./tests/data/cycles1.gos\", trace);\n    test_file(\"./tests/data/cycles2.gos\", trace);\n    test_file(\"./tests/data/cycles3.gos\", trace);\n    test_file(\"./tests/data/cycles4.gos\", trace);\n    test_file(\"./tests/data/cycles5.gos\", trace);\n    test_file(\"./tests/data/decls0.src\", trace);\n    test_file(\"./tests/data/decls1.src\", trace);\n    test_file(\"./tests/data/decls2\", trace);\n    test_file(\"./tests/data/decls3.src\", trace);\n    test_file(\"./tests/data/decls4.src\", trace);\n    test_file(\"./tests/data/decls5.src\", trace);\n    test_file(\"./tests/data/errors.src\", trace);\n    test_file(\"./tests/data/expr0.src\", trace);\n    test_file(\"./tests/data/expr2.src\", trace);\n    test_file(\"./tests/data/expr3.src\", trace);\n    test_file(\"./tests/data/gotos.src\", trace);\n    test_file(\"./tests/data/importdecl0\", trace);\n    test_file(\"./tests/data/importdecl1\", trace);\n\n    test_file(\"./tests/data/init0.src\", trace);\n    test_file(\"./tests/data/init1.src\", trace);\n    test_file(\"./tests/data/init2.src\", trace);\n\n    test_file(\"./tests/data/issues.src\", trace);\n    test_file(\"./tests/data/labels.src\", trace);\n    test_file(\"./tests/data/methodsets.src\", trace);\n    test_file(\"./tests/data/shifts.src\", trace);\n    test_file(\"./tests/data/stmt0.src\", trace);\n    test_file(\"./tests/data/stmt1.src\", trace);\n    test_file(\"./tests/data/vardecl.src\", trace);\n}", "item_id": 3, "repo": "MakotoE/goscript", "file": "types/tests/test.rs", "last_update_at": "2021-09-26T15:32:19+00:00", "question_id": "f1cd11120a491962bbd301a9efa607a0b4aee9a8_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_auto() {\n    let trace = false;\n    test_file(\"./tests/data/builtins.gos\", trace);\n    test_file(\"./tests/data/const0.gos\", trace);\n    test_file(\"./tests/data/const1.gos\", trace);\n    test_file(\"./tests/data/constdecl.gos\", trace);\n    test_file(\"./tests/data/conversions.gos\", trace);\n    test_file(\"./tests/data/conversions2.gos\", trace);\n    test_file(\"./tests/data/cycles.gos\", trace);\n    test_file(\"./tests/data/cycles1.gos\", trace);\n    test_file(\"./tests/data/cycles2.gos\", trace);\n    test_file(\"./tests/data/cycles3.gos\", trace);\n    test_file(\"./tests/data/cycles4.gos\", trace);\n    test_file(\"./tests/data/cycles5.gos\", trace);\n    test_file(\"./tests/data/decls0.src\", trace);\n    test_file(\"./tests/data/decls1.src\", trace);\n    test_file(\"./tests/data/decls2\", trace);\n    test_file(\"./tests/data/decls3.src\", trace);\n    test_file(\"./tests/data/decls4.src\", trace);\n    test_file(\"./tests/data/decls5.src\", trace);\n    test_file(\"./tests/data/errors.src\", trace);\n    test_file(\"./tests/data/expr0.src\", trace);\n    test_file(\"./tests/data/expr2.src\", trace);\n    test_file(\"./tests/data/expr3.src\", trace);\n    test_file(\"./tests/data/gotos.src\", trace);\n    test_file(\"./tests/data/importdecl0\", trace);\n    test_file(\"./tests/data/importdecl1\", trace);\n    test_file(\"./tests/data/init0.src\", trace);\n    test_file(\"./tests/data/init1.src\", trace);\n    test_file(\"./tests/data/init2.src\", trace);\n    test_file(\"./tests/data/issues.src\", trace);\n    test_file(\"./tests/data/labels.src\", trace);\n    test_file(\"./tests/data/methodsets.src\", trace);\n    test_file(\"./tests/data/shifts.src\", trace);\n    test_file(\"./tests/data/stmt0.src\", trace);\n    test_file(\"./tests/data/stmt1.src\", trace);\n    test_file(\"./tests/data/vardecl.src\", trace);\n"]], "pred": {"ppl": 1.4740663766860962, "ppl_lower": 1.4740663766860962, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0015902656738783338, "Min_5.0% Prob": 5.967229720317956, "Min_10.0% Prob": 3.6897855238481, "Min_20.0% Prob": 1.938759158760535, "Min_30.0% Prob": 1.2928128384063067, "Min_40.0% Prob": 0.9717484533167356, "Min_50.0% Prob": 0.7758803124210295, "Min_60.0% Prob": 0.6472945350999464}}
{"hexsha": "c3eb62013709a27ab3bd4ad90f60814caa58ee5a", "ext": "rs", "lang": "Rust", "content": "fn test_audio_tags() {\n    let stream = parse_full_1s_audio();\n\n    // stream_info block\n    let info = stream.stream_info();\n    assert_eq!(info.min_block_size, 4608);\n    assert_eq!(info.max_block_size, 4608);\n    assert_eq!(info.min_frame_size, 798);\n    assert_eq!(info.max_frame_size, 1317);\n    assert_eq!(info.sample_rate, 44100);\n    assert_eq!(info.channels, 1);\n    assert_eq!(info.bits_per_sample, 16);\n    assert_eq!(info.total_samples, 44100);\n    assert_eq!(info.md5_signature, [0xee, 0xc1, 0xef, 0x02, 0x73, 0xe8, 0xc0, 0x26, 0x1e, 0x52, 0x15, 0x9f, 0xc2, 0x13, 0x67, 0xb0]);\n\n    for (i, block) in stream.blocks.iter().enumerate().skip(1) {\n        // assert_eq!(block.length, block.data.len());\n        match &block.data {\n            MetadataBlockData::SeekTable(table) => {\n                assert_eq!(i, 1);\n                // assert_eq!(block.is_last, false);\n                // assert_eq!(block.length, 18);\n                assert_eq!(table.seek_points.len(), 1);\n                assert_eq!(table.seek_points[0].sample_number, 0);\n                assert_eq!(table.seek_points[0].stream_offset, 0);\n                assert_eq!(table.seek_points[0].frame_samples, 4608);\n            }\n            MetadataBlockData::Comment(comment) => {\n                assert_eq!(i, 2);\n                // assert_eq!(block.is_last, false);\n                // assert_eq!(block.length, 163);\n                assert_eq!(comment.vendor_string, \"Lavf58.45.100\");\n                assert_eq!(comment.len(), 8);\n                let map = comment.to_map();\n                assert_eq!(map[\"TITLE\"].value(), \"TRACK ONE\");\n                assert_eq!(map[\"ALBUM\"].value(), \"TestAlbum\");\n                assert_eq!(map[\"DATE\"].value(), \"2021-01-24\");\n                assert_eq!(map[\"TRACKNUMBER\"].value(), \"1\");\n                assert_eq!(map[\"TRACKTOTAL\"].value(), \"1\");\n                assert_eq!(map[\"DISCNUMBER\"].value(), \"1\");\n                assert_eq!(map[\"DISCTOTAL\"].value(), \"1\");\n            }\n            MetadataBlockData::Picture(picture) => {\n                assert_eq!(i, 3);\n                // assert_eq!(block.is_last, false);\n                // assert_eq!(block.length, 2006);\n                assert!(matches!(picture.picture_type, PictureType::CoverFront));\n                assert_eq!(picture.mime_type, \"image/png\");\n                assert_eq!(picture.description, \"\");\n                assert_eq!(picture.width, 640);\n                assert_eq!(picture.height, 480);\n                assert_eq!(picture.depth, 24);\n                assert_eq!(picture.colors, 0);\n                assert!(!picture.color_indexed());\n                assert_eq!(picture.data.len(), 1965);\n\n                let mut file = File::open(\"../assets/1s-cover.png\").expect(\"Failed to open cover file.\");\n                let mut data = Vec::new();\n                file.read_to_end(&mut data).expect(\"Failed to read test cover.\");\n                assert_eq!(&data, &picture.data);\n            }\n            MetadataBlockData::Padding(len) => {\n                assert_eq!(i, 4);\n                assert_eq!(*len, 6043);\n                // assert_eq!(block.is_last, true);\n                // assert_eq!(block.length, 6043);\n            }\n            _ => panic!(\"Invalid block.\")\n        }\n    }\n}", "item_id": 1, "repo": "project-anni/anni", "file": "anni-flac/tests/common.rs", "last_update_at": "2021-09-22T04:43:34+00:00", "question_id": "c3eb62013709a27ab3bd4ad90f60814caa58ee5a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_audio_tags() {\n    let stream = parse_full_1s_audio();\n    // stream_info block\n    let info = stream.stream_info();\n    assert_eq!(info.min_block_size, 4608);\n    assert_eq!(info.max_block_size, 4608);\n    assert_eq!(info.min_frame_size, 798);\n    assert_eq!(info.max_frame_size, 1317);\n    assert_eq!(info.sample_rate, 44100);\n    assert_eq!(info.channels, 1);\n    assert_eq!(info.bits_per_sample, 16);\n    assert_eq!(info.total_samples, 44100);\n    assert_eq!(info.md5_signature, [0xee, 0xc1, 0xef, 0x02, 0x73, 0xe8, 0xc0, 0x26, 0x1e, 0x52, 0x15, 0x9f, 0xc2, 0x13, 0x67, 0xb0]);\n    for (i, block) in stream.blocks.iter().enumerate().skip(1) {\n        // assert_eq!(block.length, block.data.len());\n        match &block.data {\n            MetadataBlockData::SeekTable(table) => {\n                assert_eq!(i, 1);\n                // assert_eq!(block.is_last, false);\n                // assert_eq!(block.length, 18);\n                assert_eq!(table.seek_points.len(), 1);\n                assert_eq!(table.seek_points[0].sample_number, 0);\n                assert_eq!(table.seek_points[0].stream_offset, 0);\n                assert_eq!(table.seek_points[0].frame_samples, 4608);\n            }\n            MetadataBlockData::Comment(comment) => {\n                assert_eq!(i, 2);\n                // assert_eq!(block.is_last, false);\n                // assert_eq!(block.length, 163);\n                assert_eq!(comment.vendor_string, \"Lavf58.45.100\");\n                assert_eq!(comment.len(), 8);\n                let map = comment.to_map();\n                assert_eq!(map[\"TITLE\"].value(), \"TRACK ONE\");\n                assert_eq!(map[\"ALBUM\"].value(), \"TestAlbum\");\n                assert_eq!(map[\"DATE\"].value(), \"2021-01-24\");\n                assert_eq!(map[\"TRACKNUMBER\"].value(), \"1\");\n                assert_eq!(map[\"TRACKTOTAL\"].value(), \"1\");\n                assert_eq!(map[\"DISCNUMBER\"].value(), \"1\");\n                assert_eq!(map[\"DISCTOTAL\"].value(), \"1\");\n            }\n            MetadataBlockData::Picture(picture) => {\n                assert_eq!(i, 3);\n                // assert_eq!(block.is_last, false);\n                // assert_eq!(block.length, 2006);\n                assert!(matches!(picture.picture_type, PictureType::CoverFront));\n                assert_eq!(picture.mime_type, \"image/png\");\n                assert_eq!(picture.description, \"\");\n                assert_eq!(picture.width, 640);\n                assert_eq!(picture.height, 480);\n                assert_eq!(picture.depth, 24);\n                assert_eq!(picture.colors, 0);\n                assert!(!picture.color_indexed());\n                assert_eq!(picture.data.len(), 1965);\n                let mut file = File::open(\"../assets/1s-cover.png\").expect(\"Failed to open cover file.\");\n                let mut data = Vec::new();\n                file.read_to_end(&mut data).expect(\"Failed to read test cover.\");\n                assert_eq!(&data, &picture.data);\n            }\n            MetadataBlockData::Padding(len) => {\n                assert_eq!(i, 4);\n                assert_eq!(*len, 6043);\n                // assert_eq!(block.is_last, true);\n                // assert_eq!(block.length, 6043);\n            }\n            _ => panic!(\"Invalid block.\")\n        }\n    }\n"]], "pred": {"ppl": 1.8235366344451904, "ppl_lower": 1.9446288347244263, "ppl/lowercase_ppl": -1.1070167786901446, "ppl/zlib": 0.0006594707148692294, "Min_5.0% Prob": 5.359599566927143, "Min_10.0% Prob": 4.056445699112088, "Min_20.0% Prob": 2.742062826074806, "Min_30.0% Prob": 1.9470543451363744, "Min_40.0% Prob": 1.4862038112976441, "Min_50.0% Prob": 1.197804873455644, "Min_60.0% Prob": 1.0010733184014216}}
{"hexsha": "90ca9c3f0e8ab30e8928ef9fbff03ef338536d3e", "ext": "rs", "lang": "Rust", "content": "async fn get_put_large_value() {\n        let (_tmpdir, values) = test_init().await;\n \n        const SIZE: usize = 1_000_000;\n        let mut builder = values.make_batch().await;\n\n        let mut data = vec![];\n        data.resize(SIZE, 'a' as u8);\n\n        let value = String::from_utf8(data).unwrap();\n\n        let e = crate::get_encoder();\n        let vid = builder.add_value(e.serialize(&value).unwrap()).await;\n\n        builder.finish().await.unwrap();\n\n        let result = values.get::<String>(vid).await.unwrap();\n        assert_eq!(result, value);\n    }", "item_id": 5, "repo": "kaimast/lsm-rs", "file": "src/values.rs", "last_update_at": "2021-12-31T08:07:16+00:00", "question_id": "90ca9c3f0e8ab30e8928ef9fbff03ef338536d3e_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn get_put_large_value() {\n        let (_tmpdir, values) = test_init().await;\n        const SIZE: usize = 1_000_000;\n        let mut builder = values.make_batch().await;\n        let mut data = vec![];\n        data.resize(SIZE, 'a' as u8);\n        let value = String::from_utf8(data).unwrap();\n        let e = crate::get_encoder();\n        let vid = builder.add_value(e.serialize(&value).unwrap()).await;\n        builder.finish().await.unwrap();\n        let result = values.get::<String>(vid).await.unwrap();\n        assert_eq!(result, value);\n"]], "pred": {"ppl": 3.5472397804260254, "ppl_lower": 3.9104018211364746, "ppl/lowercase_ppl": -1.0769804838375066, "ppl/zlib": 0.004442700962863699, "Min_5.0% Prob": 9.312744246588814, "Min_10.0% Prob": 7.334575547112359, "Min_20.0% Prob": 5.180134866688703, "Min_30.0% Prob": 3.855689106204293, "Min_40.0% Prob": 3.021515482180827, "Min_50.0% Prob": 2.4913553903284282, "Min_60.0% Prob": 2.092774203298865}}
{"hexsha": "226cf81ec27c1d8692fac7953d04fa88855973c1", "ext": "rs", "lang": "Rust", "content": "pub fn spawn(commands: &mut Commands, style: &Style) -> Entity {\n    let mut entity = None;\n    commands.with_children(|parent| {\n        parent\n            .spawn(NodeBundle {\n                style: ui::Style {\n                    flex_direction: FlexDirection::ColumnReverse,\n                    position: Rect {\n                        left: Val::Undefined,\n                        top: Val::Px(0.0), // We use this for vertical scrolling\n                        bottom: Val::Undefined,\n                        right: Val::Undefined,\n                    },\n                    size: Size {\n                        width: Val::Percent(100.),\n                        height: Val::Undefined, // Height will grow as needed\n                    },\n                    flex_shrink: 0.,\n                    padding: Rect {\n                        left: Val::Px(4.0),\n                        right: Val::Px(4.0),\n                        top: Val::Px(0.0),\n                        bottom: Val::Px(0.0),\n                    },\n                    ..Default::default()\n                },\n                material: style.color_background.clone(),\n                ..Default::default()\n            })\n            .with(Children::default())\n            .with(SceneList {\n                style: style.clone(),\n            })\n            .with(DebugIgnore)\n            .with_children(|parent| {\n                parent\n                    .spawn(ButtonBundle::default())\n                    .with(SaveSceneButton)\n                    .with(DebugIgnore)\n                    .with_children(|parent| {\n                        parent\n                            .spawn(TextBundle {\n                                text: Text::with_section(\n                                    \"Save\",\n                                    TextStyle {\n                                        font: style.font.clone(),\n                                        font_size: style.font_size,\n                                        color: Color::BLACK,\n                                    },\n                                    TextAlignment::default(),\n                                ),\n                                focus_policy: FocusPolicy::Pass,\n                                ..Default::default()\n                            })\n                            .with(DebugIgnore);\n                    });\n            });\n        entity = Some(parent.current_entity().unwrap());\n    });\n    entity.unwrap()\n}", "item_id": 0, "repo": "Davier/bevy_debug_menu", "file": "src/scene.rs", "last_update_at": "2021-01-31T17:37:27+00:00", "question_id": "226cf81ec27c1d8692fac7953d04fa88855973c1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn spawn(commands: &mut Commands, style: &Style) -> Entity {\n    let mut entity = None;\n    commands.with_children(|parent| {\n        parent\n            .spawn(NodeBundle {\n                style: ui::Style {\n                    flex_direction: FlexDirection::ColumnReverse,\n                    position: Rect {\n                        left: Val::Undefined,\n                        top: Val::Px(0.0), // We use this for vertical scrolling\n                        bottom: Val::Undefined,\n                        right: Val::Undefined,\n                    },\n                    size: Size {\n                        width: Val::Percent(100.),\n                        height: Val::Undefined, // Height will grow as needed\n                    },\n                    flex_shrink: 0.,\n                    padding: Rect {\n                        left: Val::Px(4.0),\n                        right: Val::Px(4.0),\n                        top: Val::Px(0.0),\n                        bottom: Val::Px(0.0),\n                    },\n                    ..Default::default()\n                },\n                material: style.color_background.clone(),\n                ..Default::default()\n            })\n            .with(Children::default())\n            .with(SceneList {\n                style: style.clone(),\n            })\n            .with(DebugIgnore)\n            .with_children(|parent| {\n                parent\n                    .spawn(ButtonBundle::default())\n                    .with(SaveSceneButton)\n                    .with(DebugIgnore)\n                    .with_children(|parent| {\n                        parent\n                            .spawn(TextBundle {\n                                text: Text::with_section(\n                                    \"Save\",\n                                    TextStyle {\n                                        font: style.font.clone(),\n                                        font_size: style.font_size,\n                                        color: Color::BLACK,\n                                    },\n                                    TextAlignment::default(),\n                                ),\n                                focus_policy: FocusPolicy::Pass,\n                                ..Default::default()\n                            })\n                            .with(DebugIgnore);\n                    });\n            });\n        entity = Some(parent.current_entity().unwrap());\n    });\n    entity.unwrap()\n"]], "pred": {"ppl": 1.7812262773513794, "ppl_lower": 2.3142123222351074, "ppl/lowercase_ppl": -1.4534321928573892, "ppl/zlib": 0.0008922751885130844, "Min_5.0% Prob": 6.148372879395118, "Min_10.0% Prob": 4.230809317444855, "Min_20.0% Prob": 2.6652698399864625, "Min_30.0% Prob": 1.882461082953844, "Min_40.0% Prob": 1.4339679579055586, "Min_50.0% Prob": 1.1520750143679488, "Min_60.0% Prob": 0.9638402538116652}}
{"hexsha": "9402ec57e65b4be9eb02b08d16ec4f1cdad4e394", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn validate_buildid(s: &str) -> Result<()> {\n    // None of this supports non-ASCII\n    if let Some(c) = s.chars().find(|c| !c.is_ascii()) {\n        bail!(\"Invalid non-ASCII character {} in buildid\", c);\n    }\n    // Validating the first character is alphanumeric shuts down potential\n    // special characters like `-` and `.` etc.\n    match s.chars().next() {\n        Some(c) => {\n            if !c.is_ascii_alphanumeric() {\n                bail!(\"Invalid alphanumeric character {} in buildid\", c);\n            }\n        }\n        None => {\n            bail!(\"Invalid empty buildid\");\n        }\n    }\n    Ok(())\n}", "item_id": 1, "repo": "cgwalters/koji-sane-json-api", "file": "src/koji.rs", "last_update_at": "2021-03-08T10:49:47+00:00", "question_id": "9402ec57e65b4be9eb02b08d16ec4f1cdad4e394_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn validate_buildid(s: &str) -> Result<()> {\n    // None of this supports non-ASCII\n    if let Some(c) = s.chars().find(|c| !c.is_ascii()) {\n        bail!(\"Invalid non-ASCII character {} in buildid\", c);\n    }\n    // Validating the first character is alphanumeric shuts down potential\n    // special characters like `-` and `.` etc.\n    match s.chars().next() {\n        Some(c) => {\n            if !c.is_ascii_alphanumeric() {\n                bail!(\"Invalid alphanumeric character {} in buildid\", c);\n            }\n        }\n        None => {\n            bail!(\"Invalid empty buildid\");\n        }\n    }\n    Ok(())\n"]], "pred": {"ppl": 2.8626089096069336, "ppl_lower": 3.1919867992401123, "ppl/lowercase_ppl": -1.103552979538102, "ppl/zlib": 0.00342584174326008, "Min_5.0% Prob": 8.59641875161065, "Min_10.0% Prob": 6.868078959615607, "Min_20.0% Prob": 4.52655352690281, "Min_30.0% Prob": 3.352211679877906, "Min_40.0% Prob": 2.582873988801088, "Min_50.0% Prob": 2.0879022970947685, "Min_60.0% Prob": 1.7587344808838306}}
{"hexsha": "e0b60a12d2909abda96d306c330eef5008dd0b1c", "ext": "rs", "lang": "Rust", "content": "pub fn get_image_openshift_io_api_group(\n) -> Result<(http::Request<Vec<u8>>, fn(http::StatusCode) -> k8s_openapi::ResponseBody<GetImageOpenshiftIoAPIGroupResponse>), k8s_openapi::RequestError> {\n    let __url = \"/apis/image.openshift.io/\".to_owned();\n\n    let __request = http::Request::get(__url);\n    let __body = vec![];\n    match __request.body(__body) {\n        Ok(request) => Ok((request, k8s_openapi::ResponseBody::new)),\n        Err(err) => Err(k8s_openapi::RequestError::Http(err)),\n    }\n}", "item_id": 6, "repo": "ctron/openshift-openapi", "file": "src/v4_2/mod.rs", "last_update_at": "2021-11-29T09:49:33+00:00", "question_id": "e0b60a12d2909abda96d306c330eef5008dd0b1c_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_image_openshift_io_api_group(\n) -> Result<(http::Request<Vec<u8>>, fn(http::StatusCode) -> k8s_openapi::ResponseBody<GetImageOpenshiftIoAPIGroupResponse>), k8s_openapi::RequestError> {\n    let __url = \"/apis/image.openshift.io/\".to_owned();\n    let __request = http::Request::get(__url);\n    let __body = vec![];\n    match __request.body(__body) {\n        Ok(request) => Ok((request, k8s_openapi::ResponseBody::new)),\n        Err(err) => Err(k8s_openapi::RequestError::Http(err)),\n    }\n"]], "pred": {"ppl": 1.6802382469177246, "ppl_lower": 3.255368232727051, "ppl/lowercase_ppl": -2.2744737582364554, "ppl/zlib": 0.0018533414178645228, "Min_5.0% Prob": 7.009559896257189, "Min_10.0% Prob": 4.790781206554836, "Min_20.0% Prob": 2.609180082877477, "Min_30.0% Prob": 1.7471398440258648, "Min_40.0% Prob": 1.3113986139198661, "Min_50.0% Prob": 1.0377807197430309, "Min_60.0% Prob": 0.8664567949614271}}
{"hexsha": "df41f7bdb989c76875a16473396f0a1bb7600126", "ext": "rs", "lang": "Rust", "content": "fn setup(\n    mut commands: Commands,\n    asset_server: Res<AssetServer>,\n    mut texture_atlases: ResMut<Assets<TextureAtlas>>,\n) {\n    let texture_handle = asset_server.load(\"circle.png\");\n    let texture_atlas = TextureAtlas::from_grid(texture_handle, Vec2::new(32.0, 32.0), 1, 1);\n    let texture_atlas_handle = texture_atlases.add(texture_atlas);\n    commands.spawn(OrthographicCameraBundle::new_2d());\n\n    let mut rng = rand::thread_rng();\n    for _ in 0..1000 {\n        let x = rng.gen_range(-500.0..500.0);\n        let y = rng.gen_range(-500.0..500.0);\n        commands.spawn(sprite_batch::BatchedSpriteBundle::new(\n            texture_atlas_handle.clone(),\n            0,\n            Transform::from_translation(Vec3::new(x, y, 0.0)),\n        ));\n    }\n}", "item_id": 0, "repo": "alec-deason/sprite_batch_experiment", "file": "src/main.rs", "last_update_at": "2021-04-23T01:02:24+00:00", "question_id": "df41f7bdb989c76875a16473396f0a1bb7600126_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn setup(\n    mut commands: Commands,\n    asset_server: Res<AssetServer>,\n    mut texture_atlases: ResMut<Assets<TextureAtlas>>,\n) {\n    let texture_handle = asset_server.load(\"circle.png\");\n    let texture_atlas = TextureAtlas::from_grid(texture_handle, Vec2::new(32.0, 32.0), 1, 1);\n    let texture_atlas_handle = texture_atlases.add(texture_atlas);\n    commands.spawn(OrthographicCameraBundle::new_2d());\n    let mut rng = rand::thread_rng();\n    for _ in 0..1000 {\n        let x = rng.gen_range(-500.0..500.0);\n        let y = rng.gen_range(-500.0..500.0);\n        commands.spawn(sprite_batch::BatchedSpriteBundle::new(\n            texture_atlas_handle.clone(),\n            0,\n            Transform::from_translation(Vec3::new(x, y, 0.0)),\n        ));\n    }\n"]], "pred": {"ppl": 1.5548787117004395, "ppl_lower": 2.1008152961730957, "ppl/lowercase_ppl": -1.6817617503367386, "ppl/zlib": 0.0012295196202859464, "Min_5.0% Prob": 6.02990596635001, "Min_10.0% Prob": 3.802002187432914, "Min_20.0% Prob": 2.1329244239063097, "Min_30.0% Prob": 1.4654281473365323, "Min_40.0% Prob": 1.108169821861746, "Min_50.0% Prob": 0.8821881118450594, "Min_60.0% Prob": 0.7363189402275852}}
{"hexsha": "62dbc2743d826d9e409ade507c8534a613c3bc7f", "ext": "rs", "lang": "Rust", "content": "fn merkle_crh_sprout(left: [u8; 32], right: [u8; 32]) -> [u8; 32] {\n    let mut other_block = [0u8; 64];\n    other_block[..32].copy_from_slice(&left[..]);\n    other_block[32..].copy_from_slice(&right[..]);\n\n    // H256: Sha256 initial state\n    // https://github.com/RustCrypto/hashes/blob/master/sha2/src/consts.rs#L170\n    let mut state = [\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab,\n        0x5be0cd19,\n    ];\n    sha2::compress256(&mut state, &[GenericArray::clone_from_slice(&other_block)]);\n\n    // Yes, sha256 does big endian here.\n    // https://github.com/RustCrypto/hashes/blob/master/sha2/src/sha256.rs#L40\n    let mut derived_bytes = [0u8; 32];\n    BigEndian::write_u32_into(&state, &mut derived_bytes);\n\n    derived_bytes\n}", "item_id": 0, "repo": "oxarbitrage/zebra", "file": "zebra-chain/src/sprout/tree.rs", "last_update_at": "2021-11-15T09:41:54+00:00", "question_id": "62dbc2743d826d9e409ade507c8534a613c3bc7f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn merkle_crh_sprout(left: [u8; 32], right: [u8; 32]) -> [u8; 32] {\n    let mut other_block = [0u8; 64];\n    other_block[..32].copy_from_slice(&left[..]);\n    other_block[32..].copy_from_slice(&right[..]);\n    // H256: Sha256 initial state\n    // https://github.com/RustCrypto/hashes/blob/master/sha2/src/consts.rs#L170\n    let mut state = [\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab,\n        0x5be0cd19,\n    ];\n    sha2::compress256(&mut state, &[GenericArray::clone_from_slice(&other_block)]);\n    // Yes, sha256 does big endian here.\n    // https://github.com/RustCrypto/hashes/blob/master/sha2/src/sha256.rs#L40\n    let mut derived_bytes = [0u8; 32];\n    BigEndian::write_u32_into(&state, &mut derived_bytes);\n    derived_bytes\n"]], "pred": {"ppl": 1.9358772039413452, "ppl_lower": 2.0911476612091064, "ppl/lowercase_ppl": -1.1167984907192248, "ppl/zlib": 0.001591712190666302, "Min_5.0% Prob": 7.656638346220317, "Min_10.0% Prob": 5.337514387933831, "Min_20.0% Prob": 3.1576912026656303, "Min_30.0% Prob": 2.180178112366743, "Min_40.0% Prob": 1.6482453429703845, "Min_50.0% Prob": 1.3205795145569075, "Min_60.0% Prob": 1.1008311991601276}}
{"hexsha": "a5b63dcdbcff36110b8bffdeaacf982609e365cc", "ext": "rs", "lang": "Rust", "content": "fn can_convert_between_document_and_card() {\n        let card = Card {\n            id: Uuid::new_v4(),\n            name: \"test card\".to_owned(),\n            description: \"test description\".to_owned(),\n            image_uri: \"https://localhost/test_uri.png\".to_owned(),\n            stat_base: StatsI {\n                physical: 24,\n                mental: 12,\n                tactical: 19,\n            },\n            stat_multiplier: StatsF {\n                physical: 2.0,\n                mental: 0.9,\n                tactical: 0.5,\n            },\n        };\n\n        let card_clone = card.clone();\n        let mut doc: Document = card_clone.into();\n        doc.name = format!(\"parent_path/{}\", card.id.to_string());\n\n        let card_from_doc: Card = doc.try_into().unwrap();\n\n        assert_eq!(card, card_from_doc);\n    }", "item_id": 0, "repo": "circlesabound/pccg-rs", "file": "models/src/card.rs", "last_update_at": "2021-01-27T07:24:55+00:00", "question_id": "a5b63dcdbcff36110b8bffdeaacf982609e365cc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn can_convert_between_document_and_card() {\n        let card = Card {\n            id: Uuid::new_v4(),\n            name: \"test card\".to_owned(),\n            description: \"test description\".to_owned(),\n            image_uri: \"https://localhost/test_uri.png\".to_owned(),\n            stat_base: StatsI {\n                physical: 24,\n                mental: 12,\n                tactical: 19,\n            },\n            stat_multiplier: StatsF {\n                physical: 2.0,\n                mental: 0.9,\n                tactical: 0.5,\n            },\n        };\n        let card_clone = card.clone();\n        let mut doc: Document = card_clone.into();\n        doc.name = format!(\"parent_path/{}\", card.id.to_string());\n        let card_from_doc: Card = doc.try_into().unwrap();\n        assert_eq!(card, card_from_doc);\n"]], "pred": {"ppl": 2.8138818740844727, "ppl_lower": 3.133725881576538, "ppl/lowercase_ppl": -1.1040608336214215, "ppl/zlib": 0.0029728878732006078, "Min_5.0% Prob": 7.956277807553609, "Min_10.0% Prob": 6.251460085312526, "Min_20.0% Prob": 4.221463385893374, "Min_30.0% Prob": 3.1902003014409863, "Min_40.0% Prob": 2.535405224379228, "Min_50.0% Prob": 2.058394053784328, "Min_60.0% Prob": 1.722452145170521}}
{"hexsha": "2b26791328df611b04961851144db368422b2df3", "ext": "rs", "lang": "Rust", "content": "fn dangling_pointer() -> *const i32 {\n    let b = Box::new((42, 42)); // make it bigger than the alignment, so that there is some \"room\" after this pointer\n    &b.0 as *const i32\n}", "item_id": 4, "repo": "ehuss/miri", "file": "tests/run-pass/pointers.rs", "last_update_at": "2021-11-17T11:08:27+00:00", "question_id": "2b26791328df611b04961851144db368422b2df3_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn dangling_pointer() -> *const i32 {\n    let b = Box::new((42, 42)); // make it bigger than the alignment, so that there is some \"room\" after this pointer\n    &b.0 as *const i32\n"]], "pred": {"ppl": 7.033498287200928, "ppl_lower": 8.836203575134277, "ppl/lowercase_ppl": -1.1169708143092474, "ppl/zlib": 0.01336085071709192, "Min_5.0% Prob": 7.880664507548015, "Min_10.0% Prob": 7.110815604527791, "Min_20.0% Prob": 5.957503875096639, "Min_30.0% Prob": 5.098998016781277, "Min_40.0% Prob": 4.305032539367676, "Min_50.0% Prob": 3.7281619541106688, "Min_60.0% Prob": 3.223639867595724}}
{"hexsha": "c002ff2ef77014699c7bcf47aab99a0ac3e98876", "ext": "rs", "lang": "Rust", "content": "fn test_katakana_katsuyou1() {\n        let expected = \"\u306a\u3093\u3061\u3083\u30c3\u30c6\".to_string();\n        let actual = OnaraPattern::katakana_katsuyou(\"\u306a\u3093\u3061\u3083\u3063\u3066\".to_string(), 2);\n        assert_eq!(actual, expected)\n    }", "item_id": 0, "repo": "gamoutatsumi/ojichat_rs", "file": "src/pattern/onara_pattern.rs", "last_update_at": "2021-06-04T14:29:32+00:00", "question_id": "c002ff2ef77014699c7bcf47aab99a0ac3e98876_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_katakana_katsuyou1() {\n        let expected = \"\u306a\u3093\u3061\u3083\u30c3\u30c6\".to_string();\n        let actual = OnaraPattern::katakana_katsuyou(\"\u306a\u3093\u3061\u3083\u3063\u3066\".to_string(), 2);\n        assert_eq!(actual, expected)\n"]], "pred": {"ppl": 5.000643253326416, "ppl_lower": 4.981276035308838, "ppl/lowercase_ppl": -0.9975891244705062, "ppl/zlib": 0.010802460099493937, "Min_5.0% Prob": 10.564860661824545, "Min_10.0% Prob": 8.595500877925328, "Min_20.0% Prob": 6.284697961807251, "Min_30.0% Prob": 4.949866377789041, "Min_40.0% Prob": 3.8941136098677114, "Min_50.0% Prob": 3.171049716380926, "Min_60.0% Prob": 2.7143505881338017}}
{"hexsha": "81dd3e7ece39bfa1cbf6f7529d465808da1700bf", "ext": "rs", "lang": "Rust", "content": "pub async fn generate_address(\n    snapshot_path: &Path,\n    account_index: usize,\n    address_index: usize,\n    internal: bool,\n) -> Result<Address> {\n    let mut runtime = actor_runtime().lock().await;\n    check_snapshot(&mut runtime, &snapshot_path, None).await?;\n    load_private_data_actor(&mut runtime, snapshot_path, None).await?;\n\n    let chain = Chain::from_u32_hardened(vec![\n        44,\n        4218,\n        account_index.try_into()?,\n        internal as u32,\n        address_index.try_into()?,\n    ]);\n\n    let derived_location = derive(&mut runtime, chain).await?;\n    let public_key = get_public_key(&mut runtime, derived_location).await?;\n\n    // Hash the public key to get the address\n    let hash = Blake2b256::digest(&public_key);\n\n    let ed25519_address = Ed25519Address::new(hash.try_into().unwrap());\n    let address = Address::Ed25519(ed25519_address);\n    Ok(address)\n}", "item_id": 11, "repo": "shufps/wallet.rs", "file": "src/stronghold.rs", "last_update_at": "2021-05-25T19:03:15+00:00", "question_id": "81dd3e7ece39bfa1cbf6f7529d465808da1700bf_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn generate_address(\n    snapshot_path: &Path,\n    account_index: usize,\n    address_index: usize,\n    internal: bool,\n) -> Result<Address> {\n    let mut runtime = actor_runtime().lock().await;\n    check_snapshot(&mut runtime, &snapshot_path, None).await?;\n    load_private_data_actor(&mut runtime, snapshot_path, None).await?;\n    let chain = Chain::from_u32_hardened(vec![\n        44,\n        4218,\n        account_index.try_into()?,\n        internal as u32,\n        address_index.try_into()?,\n    ]);\n    let derived_location = derive(&mut runtime, chain).await?;\n    let public_key = get_public_key(&mut runtime, derived_location).await?;\n    // Hash the public key to get the address\n    let hash = Blake2b256::digest(&public_key);\n    let ed25519_address = Ed25519Address::new(hash.try_into().unwrap());\n    let address = Address::Ed25519(ed25519_address);\n    Ok(address)\n"]], "pred": {"ppl": 2.7008299827575684, "ppl_lower": 3.236527919769287, "ppl/lowercase_ppl": -1.1821149781876494, "ppl/zlib": 0.002411551278625222, "Min_5.0% Prob": 8.446861394246419, "Min_10.0% Prob": 6.310507973035176, "Min_20.0% Prob": 4.124822182733505, "Min_30.0% Prob": 3.0894149725253763, "Min_40.0% Prob": 2.4235518691969697, "Min_50.0% Prob": 1.9700117660990728, "Min_60.0% Prob": 1.6580396820002241}}
{"hexsha": "1982e9fbc04224ee1068bd61c4efe94786b13bc0", "ext": "rs", "lang": "Rust", "content": "fn new_chars() {\n        let mut n = NormalizedString::from(\"\u00e9l\u00e9gant\");\n        n.nfd();\n        assert_eq!(\n            &n.alignments,\n            &[\n                (0, 1),\n                (0, 1),\n                (1, 2),\n                (2, 3),\n                (2, 3),\n                (3, 4),\n                (4, 5),\n                (5, 6),\n                (6, 7)\n            ]\n        );\n    }", "item_id": 0, "repo": "adelevie/tokenizers", "file": "tokenizers/src/tokenizer/normalizer.rs", "last_update_at": "2021-09-08T08:22:57+00:00", "question_id": "1982e9fbc04224ee1068bd61c4efe94786b13bc0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn new_chars() {\n        let mut n = NormalizedString::from(\"\u00e9l\u00e9gant\");\n        n.nfd();\n        assert_eq!(\n            &n.alignments,\n            &[\n                (0, 1),\n                (0, 1),\n                (1, 2),\n                (2, 3),\n                (2, 3),\n                (3, 4),\n                (4, 5),\n                (5, 6),\n                (6, 7)\n            ]\n        );\n"]], "pred": {"ppl": 2.396169900894165, "ppl_lower": 2.6061389446258545, "ppl/lowercase_ppl": -1.096121910446948, "ppl/zlib": 0.005110360163521241, "Min_5.0% Prob": 8.433175007502237, "Min_10.0% Prob": 6.088273008664449, "Min_20.0% Prob": 3.7749428272247316, "Min_30.0% Prob": 2.752480924129486, "Min_40.0% Prob": 2.1624171453363754, "Min_50.0% Prob": 1.7503746702568606, "Min_60.0% Prob": 1.4619251798789996}}
{"hexsha": "a0a4a475ff7313100cc6712a2adc4428df6c9b7e", "ext": "rs", "lang": "Rust", "content": "fn tangram(py: Python, m: &PyModule) -> PyResult<()> {\n\tm.add_class::<LoadModelOptions>()?;\n\tm.add_class::<Model>()?;\n\tm.add_class::<PredictOptions>()?;\n\tm.add_class::<RegressionPredictOutput>()?;\n\tm.add_class::<BinaryClassificationPredictOutput>()?;\n\tm.add_class::<MulticlassClassificationPredictOutput>()?;\n\tm.add_class::<FeatureContributions>()?;\n\tm.add_class::<IdentityFeatureContribution>()?;\n\tm.add_class::<NormalizedFeatureContribution>()?;\n\tm.add_class::<OneHotEncodedFeatureContribution>()?;\n\tm.add_class::<BagOfWordsFeatureContribution>()?;\n\tm.add_class::<BagOfWordsCosineSimilarityFeatureContribution>()?;\n\tm.add_class::<WordEmbeddingFeatureContribution>()?;\n\tm.add(\"PredictInput\", predict_input(py)?)?;\n\tm.add(\"PredictOutput\", predict_output(py)?)?;\n\tm.add(\"FeatureContributionEntry\", feature_contribution_entry(py)?)?;\n\tm.add(\"NGram\", ngram(py)?)?;\n\tOk(())\n}", "item_id": 0, "repo": "deciduously/tangram", "file": "languages/python/lib.rs", "last_update_at": "2021-11-23T18:53:22+00:00", "question_id": "a0a4a475ff7313100cc6712a2adc4428df6c9b7e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn tangram(py: Python, m: &PyModule) -> PyResult<()> {\n\tm.add_class::<LoadModelOptions>()?;\n\tm.add_class::<Model>()?;\n\tm.add_class::<PredictOptions>()?;\n\tm.add_class::<RegressionPredictOutput>()?;\n\tm.add_class::<BinaryClassificationPredictOutput>()?;\n\tm.add_class::<MulticlassClassificationPredictOutput>()?;\n\tm.add_class::<FeatureContributions>()?;\n\tm.add_class::<IdentityFeatureContribution>()?;\n\tm.add_class::<NormalizedFeatureContribution>()?;\n\tm.add_class::<OneHotEncodedFeatureContribution>()?;\n\tm.add_class::<BagOfWordsFeatureContribution>()?;\n\tm.add_class::<BagOfWordsCosineSimilarityFeatureContribution>()?;\n\tm.add_class::<WordEmbeddingFeatureContribution>()?;\n\tm.add(\"PredictInput\", predict_input(py)?)?;\n\tm.add(\"PredictOutput\", predict_output(py)?)?;\n\tm.add(\"FeatureContributionEntry\", feature_contribution_entry(py)?)?;\n\tm.add(\"NGram\", ngram(py)?)?;\n\tOk(())\n"]], "pred": {"ppl": 1.9042292833328247, "ppl_lower": 2.3316309452056885, "ppl/lowercase_ppl": -1.314388710964194, "ppl/zlib": 0.0021613333927434117, "Min_5.0% Prob": 8.054175049066544, "Min_10.0% Prob": 5.535756414586848, "Min_20.0% Prob": 3.142704659339153, "Min_30.0% Prob": 2.1334515274925665, "Min_40.0% Prob": 1.6105761583471163, "Min_50.0% Prob": 1.2914752096163504, "Min_60.0% Prob": 1.0765664513667368}}
{"hexsha": "1b9bfc0736b7f25dfa4689128cef9acd38efbe50", "ext": "rs", "lang": "Rust", "content": "fn hit<'a>(ray: &Ray, sphere: &'a Sphere) -> Option<Intersection<'a>> {\n    // At this stage, shapes always returned ordered hits, so we can use the first.\n    //\n    sphere.intersections(ray).get(0).cloned()\n}", "item_id": 0, "repo": "saveriomiroddi/ray_tracer_challenge-progress", "file": "practice/src/chapter06.rs", "last_update_at": "2021-05-20T11:27:36+00:00", "question_id": "1b9bfc0736b7f25dfa4689128cef9acd38efbe50_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn hit<'a>(ray: &Ray, sphere: &'a Sphere) -> Option<Intersection<'a>> {\n    // At this stage, shapes always returned ordered hits, so we can use the first.\n    //\n    sphere.intersections(ray).get(0).cloned()\n"]], "pred": {"ppl": 6.505867958068848, "ppl_lower": 8.455066680908203, "ppl/lowercase_ppl": -1.139937364335575, "ppl/zlib": 0.011631705170411023, "Min_5.0% Prob": 9.513586362202963, "Min_10.0% Prob": 8.840996106465658, "Min_20.0% Prob": 7.036787528258103, "Min_30.0% Prob": 5.546685457229614, "Min_40.0% Prob": 4.445878558688694, "Min_50.0% Prob": 3.6875032554654514, "Min_60.0% Prob": 3.121634555299108}}
{"hexsha": "c2479d9e3377377f8cd568468a7f713c938c0a28", "ext": "rs", "lang": "Rust", "content": "async fn load_bvs<'a, 'b>(bytes: &'a [u8], load_context: &'a mut LoadContext<'b>) -> Result<()> {\n\tlet now = Instant::now();\n\n\tlet assets = read_bvs(bytes).await?;\n\n\tlet textures: Vec<_> = assets\n\t\t.textures\n\t\t.into_iter()\n\t\t.enumerate()\n\t\t.map(|(i, tex)| load_context.set_labeled_asset(&format!(\"Tex{}\", i), LoadedAsset::new(tex)))\n\t\t.collect();\n\n\tlet bvs_path = load_context.path().to_str().unwrap().to_string();\n\n\tlet mut meshes = vec![];\n\tfor (name, primitives) in assets.meshes {\n\t\tlet mut primitive_handles = vec![];\n\t\tfor (i, (mesh, material)) in primitives.into_iter().enumerate() {\n\t\t\tlet mesh = load_context.set_labeled_asset(&format!(\"{}-Primitive{}\", name, i), LoadedAsset::new(mesh));\n\t\t\tlet (mat, lazy) = cvt_standard_material(bvs_path.clone(), &material, &textures);\n\t\t\tlet material = load_context.set_labeled_asset(&format!(\"{}-Material{}\", name, i), LoadedAsset::new(mat));\n\t\t\tprimitive_handles.push((mesh, material, lazy));\n\t\t}\n\t\tmeshes.push(primitive_handles);\n\t}\n\n\tlet mut world = World::default();\n\tworld.spawn().insert(LazyTextures { bvs_path: bvs_path.clone(), texcount: textures.len() });\n\n\tlet nodes = assets.nodes;\n\tworld.spawn().insert_bundle((Transform::identity(), GlobalTransform::identity())).with_children(|parent| {\n\t\tfor node in nodes {\n\t\t\tif let Some(meshi) = node.meshi {\n\t\t\t\tfor (mesh, material, lazy) in meshes[meshi].clone() {\n\t\t\t\t\tparent\n\t\t\t\t\t\t.spawn_bundle(PbrBundle { mesh, material, transform: node.transform, ..Default::default() })\n\t\t\t\t\t\t.insert(lazy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\tload_context.set_labeled_asset(\"Scene0\", LoadedAsset::new(Scene::new(world)));\n\n\tprintln!(\"bvs {}\", now.elapsed().as_secs_f64());\n\n\tOk(())\n}", "item_id": 1, "repo": "IcyDefiance/bvs", "file": "bvs_loader/src/lib.rs", "last_update_at": "2021-06-15T15:22:15+00:00", "question_id": "c2479d9e3377377f8cd568468a7f713c938c0a28_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn load_bvs<'a, 'b>(bytes: &'a [u8], load_context: &'a mut LoadContext<'b>) -> Result<()> {\n\tlet now = Instant::now();\n\tlet assets = read_bvs(bytes).await?;\n\tlet textures: Vec<_> = assets\n\t\t.textures\n\t\t.into_iter()\n\t\t.enumerate()\n\t\t.map(|(i, tex)| load_context.set_labeled_asset(&format!(\"Tex{}\", i), LoadedAsset::new(tex)))\n\t\t.collect();\n\tlet bvs_path = load_context.path().to_str().unwrap().to_string();\n\tlet mut meshes = vec![];\n\tfor (name, primitives) in assets.meshes {\n\t\tlet mut primitive_handles = vec![];\n\t\tfor (i, (mesh, material)) in primitives.into_iter().enumerate() {\n\t\t\tlet mesh = load_context.set_labeled_asset(&format!(\"{}-Primitive{}\", name, i), LoadedAsset::new(mesh));\n\t\t\tlet (mat, lazy) = cvt_standard_material(bvs_path.clone(), &material, &textures);\n\t\t\tlet material = load_context.set_labeled_asset(&format!(\"{}-Material{}\", name, i), LoadedAsset::new(mat));\n\t\t\tprimitive_handles.push((mesh, material, lazy));\n\t\t}\n\t\tmeshes.push(primitive_handles);\n\t}\n\tlet mut world = World::default();\n\tworld.spawn().insert(LazyTextures { bvs_path: bvs_path.clone(), texcount: textures.len() });\n\tlet nodes = assets.nodes;\n\tworld.spawn().insert_bundle((Transform::identity(), GlobalTransform::identity())).with_children(|parent| {\n\t\tfor node in nodes {\n\t\t\tif let Some(meshi) = node.meshi {\n\t\t\t\tfor (mesh, material, lazy) in meshes[meshi].clone() {\n\t\t\t\t\tparent\n\t\t\t\t\t\t.spawn_bundle(PbrBundle { mesh, material, transform: node.transform, ..Default::default() })\n\t\t\t\t\t\t.insert(lazy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\tload_context.set_labeled_asset(\"Scene0\", LoadedAsset::new(Scene::new(world)));\n\tprintln!(\"bvs {}\", now.elapsed().as_secs_f64());\n\tOk(())\n"]], "pred": {"ppl": 2.088726282119751, "ppl_lower": 2.4112448692321777, "ppl/lowercase_ppl": -1.1949465004309237, "ppl/zlib": 0.001021573433846924, "Min_5.0% Prob": 6.732625424861908, "Min_10.0% Prob": 5.0124866627156734, "Min_20.0% Prob": 3.234200006816536, "Min_30.0% Prob": 2.3441652337399623, "Min_40.0% Prob": 1.8121056027594022, "Min_50.0% Prob": 1.4679761251318268, "Min_60.0% Prob": 1.228136990039881}}
{"hexsha": "39dbd4abdfdd2a2751c87dd4d1cb76f099479085", "ext": "rs", "lang": "Rust", "content": "async fn get_matching_stream(ctx: &Ctx, user: &User) -> Option<Livestream> {\n    let data = ctx.data.read().await;\n    let streams = data.get::<StreamIndex>().unwrap().borrow();\n\n    let matching_stream = streams\n        .iter()\n        .map(|(_, s)| s)\n        .find(|s| s.state == StreamState::Live && s.streamer == *user);\n\n    matching_stream.cloned()\n}", "item_id": 1, "repo": "anden3/schedule-poster", "file": "crates/commands/src/unused/claim.rs", "last_update_at": "2021-11-14T05:40:27+00:00", "question_id": "39dbd4abdfdd2a2751c87dd4d1cb76f099479085_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn get_matching_stream(ctx: &Ctx, user: &User) -> Option<Livestream> {\n    let data = ctx.data.read().await;\n    let streams = data.get::<StreamIndex>().unwrap().borrow();\n    let matching_stream = streams\n        .iter()\n        .map(|(_, s)| s)\n        .find(|s| s.state == StreamState::Live && s.streamer == *user);\n    matching_stream.cloned()\n"]], "pred": {"ppl": 2.920605182647705, "ppl_lower": 3.5484890937805176, "ppl/lowercase_ppl": -1.1816875526828456, "ppl/zlib": 0.00478478057650618, "Min_5.0% Prob": 8.044767220815023, "Min_10.0% Prob": 6.659742871920268, "Min_20.0% Prob": 4.52711143096288, "Min_30.0% Prob": 3.3222372184197106, "Min_40.0% Prob": 2.614089595153928, "Min_50.0% Prob": 2.1065973891097993, "Min_60.0% Prob": 1.7816589817608872}}
{"hexsha": "7037f8077078b8613cd4aa62b86ed8bfeceed43d", "ext": "rs", "lang": "Rust", "content": "pub fn print_nbits(data: &[u8], nbits: usize) -> Result<String, std::fmt::Error> {\n    let mut result = String::new();\n    write!(&mut result, \"[\")?;\n    for i in 0..nbits {\n        let byte = i / 8;\n        let bit = i % 8;\n        let num = if 0 != (data[byte] & (1 << bit)) { 1 } else { 0 };\n        write!(&mut result, \"{}\", num)?;\n    }\n\n    write!(&mut result, \"]\")?;\n    Ok(result)\n}", "item_id": 3, "repo": "vldm/stegos", "file": "crypto/src/utils/mod.rs", "last_update_at": "2021-12-31T14:17:51+00:00", "question_id": "7037f8077078b8613cd4aa62b86ed8bfeceed43d_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn print_nbits(data: &[u8], nbits: usize) -> Result<String, std::fmt::Error> {\n    let mut result = String::new();\n    write!(&mut result, \"[\")?;\n    for i in 0..nbits {\n        let byte = i / 8;\n        let bit = i % 8;\n        let num = if 0 != (data[byte] & (1 << bit)) { 1 } else { 0 };\n        write!(&mut result, \"{}\", num)?;\n    }\n    write!(&mut result, \"]\")?;\n    Ok(result)\n"]], "pred": {"ppl": 2.037350654602051, "ppl_lower": 2.498821973800659, "ppl/lowercase_ppl": -1.286895340679721, "ppl/zlib": 0.0031628900670737925, "Min_5.0% Prob": 6.9761689731052945, "Min_10.0% Prob": 4.931950124104818, "Min_20.0% Prob": 3.1722123702367147, "Min_30.0% Prob": 2.303846063216527, "Min_40.0% Prob": 1.7551949368637116, "Min_50.0% Prob": 1.4258788858393305, "Min_60.0% Prob": 1.1951005339806715}}
{"hexsha": "38efdbd359a5c1199b149f45932d73e986995b52", "ext": "rs", "lang": "Rust", "content": "fn hash_string(ctx: CallContext) -> Result<JsString> {\n  let s = ctx.get::<JsString>(0)?.into_utf8()?;\n  let s = s.as_slice();\n  let res = xxh3_64(s);\n  let res_str = format!(\"{:016x}\", res);\n  return ctx.env.create_string_from_std(res_str);\n}", "item_id": 0, "repo": "LironHazan/parcel", "file": "packages/utils/hash/src/lib.rs", "last_update_at": "2021-07-23T12:19:54+00:00", "question_id": "38efdbd359a5c1199b149f45932d73e986995b52_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn hash_string(ctx: CallContext) -> Result<JsString> {\n  let s = ctx.get::<JsString>(0)?.into_utf8()?;\n  let s = s.as_slice();\n  let res = xxh3_64(s);\n  let res_str = format!(\"{:016x}\", res);\n  return ctx.env.create_string_from_std(res_str);\n"]], "pred": {"ppl": 2.4228579998016357, "ppl_lower": 3.1543519496917725, "ppl/lowercase_ppl": -1.298136483577679, "ppl/zlib": 0.004999705282486407, "Min_5.0% Prob": 7.660330772399902, "Min_10.0% Prob": 5.75775637626648, "Min_20.0% Prob": 3.7264154255390167, "Min_30.0% Prob": 2.777928300698598, "Min_40.0% Prob": 2.153766797810066, "Min_50.0% Prob": 1.7655647280169469, "Min_60.0% Prob": 1.4888314026423166}}
{"hexsha": "6f749aa54c976e488f9ecf357e07439a9aceb563", "ext": "rs", "lang": "Rust", "content": "fn emit_mu_types(suffix: &str, vm: &VM) {\n    create_emit_directory(vm);\n\n    let mut file_path = path::PathBuf::new();\n    file_path.push(&vm.vm_options.flag_aot_emit_dir);\n    file_path.push(\"___types\".to_string() + suffix + \".uir\");\n    let mut file = match File::create(file_path.as_path()) {\r\n        Err(why) => {\n            panic!(\n                \"couldn't create mu types file {}: {}\",\n                file_path.to_str().unwrap(),\n                why\n            )\n        }\r\n        Ok(file) => file\r\n    };\n\n    {\n        use ast::types::*;\n\n        let ty_guard = vm.types().read().unwrap();\n        let struct_map = STRUCT_TAG_MAP.read().unwrap();\n        let hybrid_map = HYBRID_TAG_MAP.read().unwrap();\n\n        for ty in ty_guard.values() {\n            if ty.is_struct() {\n                write!(file, \".typedef {} = \", ty.hdr).unwrap();\n\n                let struct_ty = struct_map\n                    .get(&ty.get_struct_hybrid_tag().unwrap())\n                    .unwrap();\n                writeln!(file, \"{}\", struct_ty).unwrap();\n                writeln!(file, \"\\n\\t/*{}*/\", vm.get_backend_type_info(ty.id())).unwrap();\n            } else if ty.is_hybrid() {\n                write!(file, \".typedef {} = \", ty.hdr).unwrap();\n                let hybrid_ty = hybrid_map\n                    .get(&ty.get_struct_hybrid_tag().unwrap())\n                    .unwrap();\n                writeln!(file, \"{}\", hybrid_ty).unwrap();\n                writeln!(file, \"\\n\\t/*{}*/\", vm.get_backend_type_info(ty.id())).unwrap();\n            } else {\n                // we only care about struct\n            }\n        }\n    }\n}", "item_id": 0, "repo": "jstnlef/zebu-vm", "file": "src/vm/uir_output.rs", "last_update_at": "2021-05-28T20:21:26+00:00", "question_id": "6f749aa54c976e488f9ecf357e07439a9aceb563_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn emit_mu_types(suffix: &str, vm: &VM) {\n    create_emit_directory(vm);\n    let mut file_path = path::PathBuf::new();\n    file_path.push(&vm.vm_options.flag_aot_emit_dir);\n    file_path.push(\"___types\".to_string() + suffix + \".uir\");\n    let mut file = match File::create(file_path.as_path()) {\r\n        Err(why) => {\n            panic!(\n                \"couldn't create mu types file {}: {}\",\n                file_path.to_str().unwrap(),\n                why\n            )\n        }\r\n        Ok(file) => file\r\n    };\n    {\n        use ast::types::*;\n        let ty_guard = vm.types().read().unwrap();\n        let struct_map = STRUCT_TAG_MAP.read().unwrap();\n        let hybrid_map = HYBRID_TAG_MAP.read().unwrap();\n        for ty in ty_guard.values() {\n            if ty.is_struct() {\n                write!(file, \".typedef {} = \", ty.hdr).unwrap();\n                let struct_ty = struct_map\n                    .get(&ty.get_struct_hybrid_tag().unwrap())\n                    .unwrap();\n                writeln!(file, \"{}\", struct_ty).unwrap();\n                writeln!(file, \"\\n\\t/*{}*/\", vm.get_backend_type_info(ty.id())).unwrap();\n            } else if ty.is_hybrid() {\n                write!(file, \".typedef {} = \", ty.hdr).unwrap();\n                let hybrid_ty = hybrid_map\n                    .get(&ty.get_struct_hybrid_tag().unwrap())\n                    .unwrap();\n                writeln!(file, \"{}\", hybrid_ty).unwrap();\n                writeln!(file, \"\\n\\t/*{}*/\", vm.get_backend_type_info(ty.id())).unwrap();\n            } else {\n                // we only care about struct\n            }\n        }\n    }\n"]], "pred": {"ppl": 2.5589325428009033, "ppl_lower": 2.8148210048675537, "ppl/lowercase_ppl": -1.101436219441015, "ppl/zlib": 0.001699078112232603, "Min_5.0% Prob": 8.466795387268066, "Min_10.0% Prob": 6.2821978073494105, "Min_20.0% Prob": 4.181726429976669, "Min_30.0% Prob": 3.0333584379526526, "Min_40.0% Prob": 2.33404267652362, "Min_50.0% Prob": 1.8733824149312568, "Min_60.0% Prob": 1.5653223338800843}}
{"hexsha": "fb1899d1f4ff3356fca34160763acb03902e9783", "ext": "rs", "lang": "Rust", "content": "pub fn new_salt() -> error::Result<Vec<u8>> {\n    const SALT_SIZE: usize = 16;\n    let mut salt = vec![0u8; SALT_SIZE];\n    let rng = rand::SystemRandom::new();\n    rng.fill(&mut salt)?;\n    Ok(salt)\n}", "item_id": 0, "repo": "jaemk/transfer", "file": "src/auth.rs", "last_update_at": "2021-12-19T09:31:43+00:00", "question_id": "fb1899d1f4ff3356fca34160763acb03902e9783_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn new_salt() -> error::Result<Vec<u8>> {\n    const SALT_SIZE: usize = 16;\n    let mut salt = vec![0u8; SALT_SIZE];\n    let rng = rand::SystemRandom::new();\n    rng.fill(&mut salt)?;\n    Ok(salt)\n"]], "pred": {"ppl": 2.236894369125366, "ppl_lower": 4.3328046798706055, "ppl/lowercase_ppl": -1.821185043001518, "ppl/zlib": 0.00490907598482759, "Min_5.0% Prob": 9.389240384101868, "Min_10.0% Prob": 6.324919372797012, "Min_20.0% Prob": 3.6716035394107593, "Min_30.0% Prob": 2.6461914384365084, "Min_40.0% Prob": 1.990711703458253, "Min_50.0% Prob": 1.621359966517914, "Min_60.0% Prob": 1.3393846826408715}}
{"hexsha": "9f9cce082e3c13f4983c739e059ae55557c18e76", "ext": "rs", "lang": "Rust", "content": "fn from_path(path: &str) -> PyResult<Vec<Map>> {\n    let mut maps = Vec::new();\n\n    let inner_maps = rsprocmaps::from_path(Path::new(path)).map_err(ProcmapsError)?;\n    for map in inner_maps {\n        maps.push(Map {\n            inner: map.map_err(ProcmapsError)?,\n        })\n    }\n\n    Ok(maps)\n}", "item_id": 1, "repo": "woodruffw/procmaps.py", "file": "src/lib.rs", "last_update_at": "2021-12-26T16:40:07+00:00", "question_id": "9f9cce082e3c13f4983c739e059ae55557c18e76_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn from_path(path: &str) -> PyResult<Vec<Map>> {\n    let mut maps = Vec::new();\n    let inner_maps = rsprocmaps::from_path(Path::new(path)).map_err(ProcmapsError)?;\n    for map in inner_maps {\n        maps.push(Map {\n            inner: map.map_err(ProcmapsError)?,\n        })\n    }\n    Ok(maps)\n"]], "pred": {"ppl": 3.374767780303955, "ppl_lower": 5.044837474822998, "ppl/lowercase_ppl": -1.3305353593274998, "ppl/zlib": 0.006833295034389876, "Min_5.0% Prob": 9.39198703765869, "Min_10.0% Prob": 7.6935426712036135, "Min_20.0% Prob": 5.280533535139901, "Min_30.0% Prob": 3.828317005187273, "Min_40.0% Prob": 3.0391817461876642, "Min_50.0% Prob": 2.4414839885144866, "Min_60.0% Prob": 2.0306228172848932}}
{"hexsha": "465b02dd931a87a7d6e06b0c9451298db0f6d3b2", "ext": "rs", "lang": "Rust", "content": "pub fn register_debug_actions(context: &AgentContext) {\n    debug!(context.logger, \"Registering debug actions\");\n    ACTIONS::register_reserved(Fail {});\n    ACTIONS::register_reserved(Progress {});\n    ACTIONS::register_reserved(Success {});\n}", "item_id": 0, "repo": "replicante-io/replicante-agents", "file": "libs/rust/sdk/src/actions/impls/debug.rs", "last_update_at": "2021-05-07T07:16:53+00:00", "question_id": "465b02dd931a87a7d6e06b0c9451298db0f6d3b2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn register_debug_actions(context: &AgentContext) {\n    debug!(context.logger, \"Registering debug actions\");\n    ACTIONS::register_reserved(Fail {});\n    ACTIONS::register_reserved(Progress {});\n    ACTIONS::register_reserved(Success {});\n"]], "pred": {"ppl": 6.530289173126221, "ppl_lower": 9.794703483581543, "ppl/lowercase_ppl": -1.2160410816886815, "ppl/zlib": 0.0134996491085928, "Min_5.0% Prob": 11.767586390177408, "Min_10.0% Prob": 10.124841213226318, "Min_20.0% Prob": 7.959535087857928, "Min_30.0% Prob": 5.9778883797781805, "Min_40.0% Prob": 4.5421720023812915, "Min_50.0% Prob": 3.7452020934886403, "Min_60.0% Prob": 3.169708569382512}}
{"hexsha": "a0ea26127e38f9f4f2dcaa48bb5cc17f930e4fef", "ext": "rs", "lang": "Rust", "content": "fn formatted_with_crop_2() {\n        let stop_words = fst::Set::default();\n        let mut config = AnalyzerConfig::default();\n        config.stop_words(&stop_words);\n        let analyzer = Analyzer::new(config);\n        let formatter = Formatter::new(&analyzer, (String::from(\"<em>\"), String::from(\"</em>\")));\n\n        let mut fields = FieldsIdsMap::new();\n        let title = fields.insert(\"title\").unwrap();\n        let author = fields.insert(\"author\").unwrap();\n\n        let mut buf = Vec::new();\n        let mut obkv = obkv::KvWriter::new(&mut buf);\n        obkv.insert(\n            title,\n            Value::String(\"Harry Potter and the Half-Blood Prince\".into())\n                .to_string()\n                .as_bytes(),\n        )\n        .unwrap();\n        obkv.finish().unwrap();\n        obkv = obkv::KvWriter::new(&mut buf);\n        obkv.insert(\n            author,\n            Value::String(\"J. K. Rowling\".into()).to_string().as_bytes(),\n        )\n        .unwrap();\n        obkv.finish().unwrap();\n\n        let obkv = obkv::KvReader::new(&buf);\n\n        let mut formatted_options = BTreeMap::new();\n        formatted_options.insert(\n            title,\n            FormatOptions {\n                highlight: false,\n                crop: Some(2),\n            },\n        );\n        formatted_options.insert(\n            author,\n            FormatOptions {\n                highlight: false,\n                crop: None,\n            },\n        );\n\n        let mut matching_words = BTreeMap::new();\n        matching_words.insert(\"potter\", Some(6));\n\n        let value = format_fields(\n            &fields,\n            obkv,\n            &formatter,\n            &matching_words,\n            &formatted_options,\n        )\n        .unwrap();\n\n        assert_eq!(value[\"title\"], \"Harry Potter and\");\n        assert_eq!(value[\"author\"], \"J. K. Rowling\");\n    }", "item_id": 9, "repo": "palfrey/MeiliSearch", "file": "meilisearch-lib/src/index/search.rs", "last_update_at": "2021-10-07T17:42:43+00:00", "question_id": "a0ea26127e38f9f4f2dcaa48bb5cc17f930e4fef_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn formatted_with_crop_2() {\n        let stop_words = fst::Set::default();\n        let mut config = AnalyzerConfig::default();\n        config.stop_words(&stop_words);\n        let analyzer = Analyzer::new(config);\n        let formatter = Formatter::new(&analyzer, (String::from(\"<em>\"), String::from(\"</em>\")));\n        let mut fields = FieldsIdsMap::new();\n        let title = fields.insert(\"title\").unwrap();\n        let author = fields.insert(\"author\").unwrap();\n        let mut buf = Vec::new();\n        let mut obkv = obkv::KvWriter::new(&mut buf);\n        obkv.insert(\n            title,\n            Value::String(\"Harry Potter and the Half-Blood Prince\".into())\n                .to_string()\n                .as_bytes(),\n        )\n        .unwrap();\n        obkv.finish().unwrap();\n        obkv = obkv::KvWriter::new(&mut buf);\n        obkv.insert(\n            author,\n            Value::String(\"J. K. Rowling\".into()).to_string().as_bytes(),\n        )\n        .unwrap();\n        obkv.finish().unwrap();\n        let obkv = obkv::KvReader::new(&buf);\n        let mut formatted_options = BTreeMap::new();\n        formatted_options.insert(\n            title,\n            FormatOptions {\n                highlight: false,\n                crop: Some(2),\n            },\n        );\n        formatted_options.insert(\n            author,\n            FormatOptions {\n                highlight: false,\n                crop: None,\n            },\n        );\n        let mut matching_words = BTreeMap::new();\n        matching_words.insert(\"potter\", Some(6));\n        let value = format_fields(\n            &fields,\n            obkv,\n            &formatter,\n            &matching_words,\n            &formatted_options,\n        )\n        .unwrap();\n        assert_eq!(value[\"title\"], \"Harry Potter and\");\n        assert_eq!(value[\"author\"], \"J. K. Rowling\");\n"]], "pred": {"ppl": 2.0375118255615234, "ppl_lower": 2.4841840267181396, "ppl/lowercase_ppl": -1.278497536309931, "ppl/zlib": 0.001280088795094629, "Min_5.0% Prob": 6.803219996965849, "Min_10.0% Prob": 5.058953555730673, "Min_20.0% Prob": 3.2356489094404073, "Min_30.0% Prob": 2.3042734698125513, "Min_40.0% Prob": 1.7672350746735432, "Min_50.0% Prob": 1.4197304514414482, "Min_60.0% Prob": 1.1868593108938164}}
{"hexsha": "b8b64c9753da0dc4e7b62b705112d08d2f219ee8", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<(), Box<dyn Error + Sync + Send>> {\n    eprintln!(\"Server starting...\");\n\n    let (connection, io_threads) = Connection::stdio();\n    eprintln!(\"Created connection\");\n\n    // Run the server and wait for the two threads to end (typically by trigger LSP Exit event).\n    let server_capabilities = serde_json::to_value(&ServerCapabilities::default()).unwrap();\n    eprintln!(\"Server Capabilities: {:?}\", server_capabilities);\n\n    let initialize_params = connection.initialize(server_capabilities)?;\n\n    eprintln!(\"Calling main loop\");\n    main_loop(&connection, initialize_params)?;\n    io_threads.join()?;\n\n    eprintln!(\"Shutting down server\");\n\n    Ok(())\n}", "item_id": 0, "repo": "Strum355/lsif-protocol-rs", "file": "src/server/main.rs", "last_update_at": "2021-02-05T06:44:21+00:00", "question_id": "b8b64c9753da0dc4e7b62b705112d08d2f219ee8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<(), Box<dyn Error + Sync + Send>> {\n    eprintln!(\"Server starting...\");\n    let (connection, io_threads) = Connection::stdio();\n    eprintln!(\"Created connection\");\n    // Run the server and wait for the two threads to end (typically by trigger LSP Exit event).\n    let server_capabilities = serde_json::to_value(&ServerCapabilities::default()).unwrap();\n    eprintln!(\"Server Capabilities: {:?}\", server_capabilities);\n    let initialize_params = connection.initialize(server_capabilities)?;\n    eprintln!(\"Calling main loop\");\n    main_loop(&connection, initialize_params)?;\n    io_threads.join()?;\n    eprintln!(\"Shutting down server\");\n    Ok(())\n"]], "pred": {"ppl": 3.2999684810638428, "ppl_lower": 4.376740455627441, "ppl/lowercase_ppl": -1.2365259122500396, "ppl/zlib": 0.003411179763525848, "Min_5.0% Prob": 8.008551438649496, "Min_10.0% Prob": 6.368399017735531, "Min_20.0% Prob": 4.716656741343047, "Min_30.0% Prob": 3.6339085436703864, "Min_40.0% Prob": 2.9078422329927744, "Min_50.0% Prob": 2.381157117454629, "Min_60.0% Prob": 1.9970231439852923}}
{"hexsha": "a2361ff584d090eae64e33f4ce6e3bf3fe247310", "ext": "rs", "lang": "Rust", "content": "pub fn initialize_paging(frame_alloctor: &mut impl FrameAllocator<Size4KiB>) -> PageTables {\r\n    let physical_offset = VirtAddr::new(0x00);\r\n    let old_table = {\r\n        let frame = control::Cr3::read().0;\r\n        let ptr: *const PageTable = (physical_offset + frame.start_address().as_u64()).as_ptr();\r\n\r\n        unsafe {\r\n            &*ptr\r\n        }\r\n    };\r\n\r\n    let new_frame = frame_alloctor.allocate_frame().unwrap();\r\n    let new_table = {\r\n        let ptr: *mut PageTable = (physical_offset + new_frame.start_address().as_u64()).as_mut_ptr();\r\n\r\n        unsafe {\r\n            ptr.write(PageTable::new());\r\n\r\n            &mut *ptr\r\n        }\r\n    };\r\n\r\n    new_table[0] = old_table[0].clone();\r\n\r\n    let boot_page_table = unsafe {\r\n        control::Cr3::write(new_frame, control::Cr3Flags::empty());\r\n        OffsetPageTable::new(&mut *new_table, physical_offset)\r\n    };\r\n\r\n    let (kernel_page_table, kernel_level_four_frame) = {\r\n        let frame = frame_alloctor.allocate_frame().expect(\"No unused frames are available for allocation.\");\r\n        log::info!(\"Created a new page table for the System Kernel at: {:#?}\", &frame);\r\n\r\n        let address = physical_offset + frame.start_address().as_u64();\r\n\r\n        let ptr =  address.as_mut_ptr();\r\n        unsafe {\r\n            *ptr = PageTable::new()\r\n        };\r\n\r\n        let level_four_table = unsafe {\r\n            &mut *ptr\r\n        };\r\n\r\n        (\r\n            unsafe {\r\n                OffsetPageTable::new(level_four_table, physical_offset)\r\n            },\r\n            frame\r\n        )\r\n    };\r\n\r\n    PageTables {\r\n        boot_page_table,\r\n        kernel_page_table,\r\n        kernel_level_four_frame\r\n    }\r\n}", "item_id": 0, "repo": "HT-Studios/project-lightsaber", "file": "lightsaber_bootloader/src/paging.rs", "last_update_at": "2021-06-20T23:25:23+00:00", "question_id": "a2361ff584d090eae64e33f4ce6e3bf3fe247310_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn initialize_paging(frame_alloctor: &mut impl FrameAllocator<Size4KiB>) -> PageTables {\r\n    let physical_offset = VirtAddr::new(0x00);\r\n    let old_table = {\r\n        let frame = control::Cr3::read().0;\r\n        let ptr: *const PageTable = (physical_offset + frame.start_address().as_u64()).as_ptr();\r\n\r\n        unsafe {\r\n            &*ptr\r\n        }\r\n    };\r\n\r\n    let new_frame = frame_alloctor.allocate_frame().unwrap();\r\n    let new_table = {\r\n        let ptr: *mut PageTable = (physical_offset + new_frame.start_address().as_u64()).as_mut_ptr();\r\n\r\n        unsafe {\r\n            ptr.write(PageTable::new());\r\n\r\n            &mut *ptr\r\n        }\r\n    };\r\n\r\n    new_table[0] = old_table[0].clone();\r\n\r\n    let boot_page_table = unsafe {\r\n        control::Cr3::write(new_frame, control::Cr3Flags::empty());\r\n        OffsetPageTable::new(&mut *new_table, physical_offset)\r\n    };\r\n\r\n    let (kernel_page_table, kernel_level_four_frame) = {\r\n        let frame = frame_alloctor.allocate_frame().expect(\"No unused frames are available for allocation.\");\r\n        log::info!(\"Created a new page table for the System Kernel at: {:#?}\", &frame);\r\n\r\n        let address = physical_offset + frame.start_address().as_u64();\r\n\r\n        let ptr =  address.as_mut_ptr();\r\n        unsafe {\r\n            *ptr = PageTable::new()\r\n        };\r\n\r\n        let level_four_table = unsafe {\r\n            &mut *ptr\r\n        };\r\n\r\n        (\r\n            unsafe {\r\n                OffsetPageTable::new(level_four_table, physical_offset)\r\n            },\r\n            frame\r\n        )\r\n    };\r\n\r\n    PageTables {\r\n        boot_page_table,\r\n        kernel_page_table,\r\n        kernel_level_four_frame\r\n    }\r\n"]], "pred": {"ppl": 2.098738431930542, "ppl_lower": 2.4303622245788574, "ppl/lowercase_ppl": -1.1978911178276983, "ppl/zlib": 0.001312099853998292, "Min_5.0% Prob": 7.293117303114671, "Min_10.0% Prob": 5.2048706513530805, "Min_20.0% Prob": 3.348843058693075, "Min_30.0% Prob": 2.405524740181863, "Min_40.0% Prob": 1.8372085947438934, "Min_50.0% Prob": 1.47834204621057, "Min_60.0% Prob": 1.2369090454809577}}
{"hexsha": "8c093c23edd679f86ea412bfd9b822feb1720421", "ext": "rs", "lang": "Rust", "content": "pub async fn endorsing_rights(\n    req: Request<Body>,\n    params: Params,\n    query: Query,\n    env: Arc<RpcServiceEnvironment>,\n) -> ServiceResult {\n    let chain_id_param = required_param!(params, \"chain_id\")?;\n    let chain_id = parse_chain_id(chain_id_param, &env)?;\n    let block_hash =\n        parse_block_hash_or_fail!(&chain_id, required_param!(params, \"block_id\")?, &env);\n\n    let level = query.get_str(\"level\");\n    let cycle = query.get_str(\"cycle\");\n    let delegate = query.get_str(\"delegate\");\n    let has_all = query.contains_key(\"all\");\n\n    // get RPC response and unpack it from RpcResponseData enum\n    match services::protocol::check_and_get_endorsing_rights(\n        &chain_id,\n        &block_hash,\n        level,\n        delegate,\n        cycle,\n        has_all,\n        &env,\n    )\n    .await\n    {\n        Ok(Some(rights)) => result_to_json_response(Ok(Some(rights)), env.log()),\n        Ok(None) => {\n            let res: Result<Option<String>, RpcServiceError> = Ok(None);\n            result_to_json_response(res, env.log())\n        }\n        Err(RightsError::UnsupportedProtocolError { .. }) => {\n            // fallback, if protocol is not supported, we trigger rpc protocol router\n            result_to_json_response(\n                services::protocol::call_protocol_rpc(\n                    chain_id_param,\n                    chain_id,\n                    block_hash,\n                    create_rpc_request(req).await?,\n                    &env,\n                ),\n                env.log(),\n            )\n        }\n        Err(RightsError::ServiceError { reason }) => {\n            slog::warn!(env.log(), \"Failed to execute RPC function for endorsing rights\"; \"reason\" => format!(\"{:?}\", &reason));\n            handle_rpc_service_error(RpcServiceError::UnexpectedError {\n                reason: format!(\"{}\", reason),\n            })\n        }\n    }\n}", "item_id": 2, "repo": "tizoc/tezedge", "file": "rpc/src/server/protocol_handler.rs", "last_update_at": "2021-04-13T23:55:58+00:00", "question_id": "8c093c23edd679f86ea412bfd9b822feb1720421_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn endorsing_rights(\n    req: Request<Body>,\n    params: Params,\n    query: Query,\n    env: Arc<RpcServiceEnvironment>,\n) -> ServiceResult {\n    let chain_id_param = required_param!(params, \"chain_id\")?;\n    let chain_id = parse_chain_id(chain_id_param, &env)?;\n    let block_hash =\n        parse_block_hash_or_fail!(&chain_id, required_param!(params, \"block_id\")?, &env);\n    let level = query.get_str(\"level\");\n    let cycle = query.get_str(\"cycle\");\n    let delegate = query.get_str(\"delegate\");\n    let has_all = query.contains_key(\"all\");\n    // get RPC response and unpack it from RpcResponseData enum\n    match services::protocol::check_and_get_endorsing_rights(\n        &chain_id,\n        &block_hash,\n        level,\n        delegate,\n        cycle,\n        has_all,\n        &env,\n    )\n    .await\n    {\n        Ok(Some(rights)) => result_to_json_response(Ok(Some(rights)), env.log()),\n        Ok(None) => {\n            let res: Result<Option<String>, RpcServiceError> = Ok(None);\n            result_to_json_response(res, env.log())\n        }\n        Err(RightsError::UnsupportedProtocolError { .. }) => {\n            // fallback, if protocol is not supported, we trigger rpc protocol router\n            result_to_json_response(\n                services::protocol::call_protocol_rpc(\n                    chain_id_param,\n                    chain_id,\n                    block_hash,\n                    create_rpc_request(req).await?,\n                    &env,\n                ),\n                env.log(),\n            )\n        }\n        Err(RightsError::ServiceError { reason }) => {\n            slog::warn!(env.log(), \"Failed to execute RPC function for endorsing rights\"; \"reason\" => format!(\"{:?}\", &reason));\n            handle_rpc_service_error(RpcServiceError::UnexpectedError {\n                reason: format!(\"{}\", reason),\n            })\n        }\n    }\n"]], "pred": {"ppl": 2.668660879135132, "ppl_lower": 3.2172157764434814, "ppl/lowercase_ppl": -1.1904481809315008, "ppl/zlib": 0.0013670986117021147, "Min_5.0% Prob": 7.514270322663443, "Min_10.0% Prob": 5.953035746301923, "Min_20.0% Prob": 4.181169718503952, "Min_30.0% Prob": 3.107301787961097, "Min_40.0% Prob": 2.4144685149325857, "Min_50.0% Prob": 1.9538715600036085, "Min_60.0% Prob": 1.633672233870519}}
{"hexsha": "b644796625e67076767bdf93763db5546cc90c1b", "ext": "rs", "lang": "Rust", "content": "pub fn rtr_32<T: Core>(core: &mut T) -> Result<Cycles> {\n    let new_ccr = core.pop_16();\n    let new_pc = core.pop_32();\n    core.jump(new_pc);\n    core.ccr_to_flags(new_ccr);\n    Ok(Cycles(20))\n}", "item_id": 33, "repo": "theblacklotus/magia", "file": "magia-cpu/src/cpu/ops/mod.rs", "last_update_at": "2021-11-27T12:51:41+00:00", "question_id": "b644796625e67076767bdf93763db5546cc90c1b_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn rtr_32<T: Core>(core: &mut T) -> Result<Cycles> {\n    let new_ccr = core.pop_16();\n    let new_pc = core.pop_32();\n    core.jump(new_pc);\n    core.ccr_to_flags(new_ccr);\n    Ok(Cycles(20))\n"]], "pred": {"ppl": 4.754127025604248, "ppl_lower": 7.111508369445801, "ppl/lowercase_ppl": -1.258305259668838, "ppl/zlib": 0.011056830413565128, "Min_5.0% Prob": 9.900789022445679, "Min_10.0% Prob": 8.24029148949517, "Min_20.0% Prob": 6.1412120660146075, "Min_30.0% Prob": 4.727591050995721, "Min_40.0% Prob": 3.7333858883058704, "Min_50.0% Prob": 3.0962491599114044, "Min_60.0% Prob": 2.6170729092576286}}
{"hexsha": "4e29030d1670739438df0b803c52e72867833db3", "ext": "rs", "lang": "Rust", "content": "fn test_multi_over_capacity() {\n        let mut map = populate_hashmap();\n\n        let mut buffer = [null_mut(); 3];\n        let mut wrapper = map.multi_mut(&mut buffer);\n        \n        let _one = wrapper.get_mut(\"key_one\").unwrap();\n        let _two = wrapper.get_mut(\"key_two\").unwrap();\n        let _three = wrapper.get_mut(\"key_three\").unwrap();\n        let _four = wrapper.get_mut(\"key_four\").unwrap();\n    }", "item_id": 22, "repo": "golddranks/multi_mut", "file": "src/lib.rs", "last_update_at": "2021-08-03T13:08:31+00:00", "question_id": "4e29030d1670739438df0b803c52e72867833db3_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_multi_over_capacity() {\n        let mut map = populate_hashmap();\n        let mut buffer = [null_mut(); 3];\n        let mut wrapper = map.multi_mut(&mut buffer);\n        let _one = wrapper.get_mut(\"key_one\").unwrap();\n        let _two = wrapper.get_mut(\"key_two\").unwrap();\n        let _three = wrapper.get_mut(\"key_three\").unwrap();\n        let _four = wrapper.get_mut(\"key_four\").unwrap();\n"]], "pred": {"ppl": 3.1371243000030518, "ppl_lower": 3.1371243000030518, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.006647131117842717, "Min_5.0% Prob": 8.752977768580118, "Min_10.0% Prob": 6.904650529225667, "Min_20.0% Prob": 4.870726919174194, "Min_30.0% Prob": 3.6079500035235754, "Min_40.0% Prob": 2.8020283048059427, "Min_50.0% Prob": 2.278001999715343, "Min_60.0% Prob": 1.9098068783906372}}
{"hexsha": "83e7c2ed442eb0b75773fc2447722f1f1e61d632", "ext": "rs", "lang": "Rust", "content": "fn test_parse_limit() {\n        let yaml = load_yaml!(\"cli.yml\");\n        let app = App::from_yaml(yaml);\n\n        // Testing a valid limit value\n        let matches = app.get_matches_from(vec![\"cub\", \"ls\", \"-l\", \"42\"]);\n        let subcommand = matches.subcommand_matches(\"ls\").unwrap();\n        let limit = parse_limit(subcommand);\n\n        match limit {\n            Limit::FINITE(val) => assert_eq!(val, 42),\n            Limit::INFINITE => {}\n        }\n    }", "item_id": 5, "repo": "jessmartin/cub-cli", "file": "src/args.rs", "last_update_at": "2021-12-27T01:52:59+00:00", "question_id": "83e7c2ed442eb0b75773fc2447722f1f1e61d632_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_parse_limit() {\n        let yaml = load_yaml!(\"cli.yml\");\n        let app = App::from_yaml(yaml);\n        // Testing a valid limit value\n        let matches = app.get_matches_from(vec![\"cub\", \"ls\", \"-l\", \"42\"]);\n        let subcommand = matches.subcommand_matches(\"ls\").unwrap();\n        let limit = parse_limit(subcommand);\n        match limit {\n            Limit::FINITE(val) => assert_eq!(val, 42),\n            Limit::INFINITE => {}\n        }\n"]], "pred": {"ppl": 3.246149778366089, "ppl_lower": 3.6831109523773193, "ppl/lowercase_ppl": -1.1072538526347044, "ppl/zlib": 0.004691113985934947, "Min_5.0% Prob": 8.847495555877686, "Min_10.0% Prob": 7.00849369594029, "Min_20.0% Prob": 5.013848362297847, "Min_30.0% Prob": 3.743038311600685, "Min_40.0% Prob": 2.8923597957118083, "Min_50.0% Prob": 2.3362682085182214, "Min_60.0% Prob": 1.9742159063250504}}
{"hexsha": "8e9ce975aaa522a6355fe99d60baa602d78a9c76", "ext": "rs", "lang": "Rust", "content": "fn test_bash_parser_exit() {\n        let (core, _): (ShellCore, UserStream) = ShellCore::new(None, 32, Box::new(Bash::new()));\n        let parser: Bash = Bash::new();\n        //Simple case\n        let mut input: VecDeque<String> = parser.readline(&String::from(\"0\")).unwrap();\n        assert_eq!(parser.parse_exit(&mut input).unwrap(), ShellStatement::Exit(0));\n        assert_eq!(input.len(), 0); //Should be empty\n        //Simple case\n        let mut input: VecDeque<String> = parser.readline(&String::from(\"128\")).unwrap();\n        assert_eq!(parser.parse_exit(&mut input).unwrap(), ShellStatement::Exit(128));\n        assert_eq!(input.len(), 0); //Should be empty\n        //Bad case\n        let mut input: VecDeque<String> = parser.readline(&String::from(\"foobar\")).unwrap();\n        assert_eq!(parser.parse_exit(&mut input).unwrap(), ShellStatement::Exit(2));\n        assert_eq!(input.len(), 0); //Should be empty\n        //No arg\n        let mut input: VecDeque<String> = VecDeque::new();\n        assert_eq!(parser.parse_exit(&mut input).unwrap(), ShellStatement::Exit(0));\n        assert_eq!(input.len(), 0); //Should be empty\n    }", "item_id": 7, "repo": "ChristianVisintin/shell-core", "file": "src/parsers/bash.rs", "last_update_at": "2021-02-21T20:02:05+00:00", "question_id": "8e9ce975aaa522a6355fe99d60baa602d78a9c76_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_bash_parser_exit() {\n        let (core, _): (ShellCore, UserStream) = ShellCore::new(None, 32, Box::new(Bash::new()));\n        let parser: Bash = Bash::new();\n        //Simple case\n        let mut input: VecDeque<String> = parser.readline(&String::from(\"0\")).unwrap();\n        assert_eq!(parser.parse_exit(&mut input).unwrap(), ShellStatement::Exit(0));\n        assert_eq!(input.len(), 0); //Should be empty\n        //Simple case\n        let mut input: VecDeque<String> = parser.readline(&String::from(\"128\")).unwrap();\n        assert_eq!(parser.parse_exit(&mut input).unwrap(), ShellStatement::Exit(128));\n        assert_eq!(input.len(), 0); //Should be empty\n        //Bad case\n        let mut input: VecDeque<String> = parser.readline(&String::from(\"foobar\")).unwrap();\n        assert_eq!(parser.parse_exit(&mut input).unwrap(), ShellStatement::Exit(2));\n        assert_eq!(input.len(), 0); //Should be empty\n        //No arg\n        let mut input: VecDeque<String> = VecDeque::new();\n        assert_eq!(parser.parse_exit(&mut input).unwrap(), ShellStatement::Exit(0));\n        assert_eq!(input.len(), 0); //Should be empty\n"]], "pred": {"ppl": 2.0945661067962646, "ppl_lower": 2.4540514945983887, "ppl/lowercase_ppl": -1.2142350352819529, "ppl/zlib": 0.0025233666313866487, "Min_5.0% Prob": 6.676038910360897, "Min_10.0% Prob": 5.120438044411795, "Min_20.0% Prob": 3.4286462920052663, "Min_30.0% Prob": 2.4161136340139047, "Min_40.0% Prob": 1.8471469643479543, "Min_50.0% Prob": 1.4765763498874287, "Min_60.0% Prob": 1.2339888748335037}}
{"hexsha": "cbbb0f5b20d079806b678d1e3d1b100d76814f2c", "ext": "rs", "lang": "Rust", "content": "pub async fn recommend_categories(state: Data<AppState>) -> Result<impl Responder, AppError> {\n    let sublog = state.log.new(o!(\"handler\" => \"recommend_categories\"));\n    let client: Client = get_client(state.pool.clone(), sublog.clone()).await?;\n    db::hot_categories(&client)\n        .await\n        .map(|cate| ResultResponse::normal(cate))\n        .map_err(log_error(sublog))\n}", "item_id": 11, "repo": "pzxpan/panfp-blog-backend", "file": "src/handlers/article_handler.rs", "last_update_at": "2021-01-18T03:41:08+00:00", "question_id": "cbbb0f5b20d079806b678d1e3d1b100d76814f2c_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn recommend_categories(state: Data<AppState>) -> Result<impl Responder, AppError> {\n    let sublog = state.log.new(o!(\"handler\" => \"recommend_categories\"));\n    let client: Client = get_client(state.pool.clone(), sublog.clone()).await?;\n    db::hot_categories(&client)\n        .await\n        .map(|cate| ResultResponse::normal(cate))\n        .map_err(log_error(sublog))\n"]], "pred": {"ppl": 4.782306671142578, "ppl_lower": 7.0558762550354, "ppl/lowercase_ppl": -1.24853477415993, "ppl/zlib": 0.006687705116623529, "Min_5.0% Prob": 9.751145203908285, "Min_10.0% Prob": 8.450704256693522, "Min_20.0% Prob": 6.226193120082219, "Min_30.0% Prob": 4.608541246917513, "Min_40.0% Prob": 3.6817202419042587, "Min_50.0% Prob": 3.0491770232717195, "Min_60.0% Prob": 2.586031011202269}}
{"hexsha": "b125a8aec733d1c1ee2d51141f705f91e5291b26", "ext": "rs", "lang": "Rust", "content": "pub async fn create_store_builder_single_conn(\n    mut conn: sqlx::PgConnection,\n    read_config: BasiliqStoreConfig,\n) -> Result<BasiliqStoreBuilder, BasiliqError> {\n    info!(\"Scanning the database...\");\n    let mut builder = BasiliqStoreBuilder::new(BasiliqDbScannedTable::scan_db(&mut conn).await?);\n    builder.basiliq_config_merge(&read_config)?;\n    Ok(builder)\n}", "item_id": 1, "repo": "basiliqio/basiliq", "file": "src/config/check.rs", "last_update_at": "2021-05-30T10:04:28+00:00", "question_id": "b125a8aec733d1c1ee2d51141f705f91e5291b26_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn create_store_builder_single_conn(\n    mut conn: sqlx::PgConnection,\n    read_config: BasiliqStoreConfig,\n) -> Result<BasiliqStoreBuilder, BasiliqError> {\n    info!(\"Scanning the database...\");\n    let mut builder = BasiliqStoreBuilder::new(BasiliqDbScannedTable::scan_db(&mut conn).await?);\n    builder.basiliq_config_merge(&read_config)?;\n    Ok(builder)\n"]], "pred": {"ppl": 4.630384922027588, "ppl_lower": 8.797323226928711, "ppl/lowercase_ppl": -1.4187594574220994, "ppl/zlib": 0.0066348051997815296, "Min_5.0% Prob": 9.234394709269205, "Min_10.0% Prob": 7.750956853230794, "Min_20.0% Prob": 5.881795346736908, "Min_30.0% Prob": 4.5453040268686085, "Min_40.0% Prob": 3.6678977559010186, "Min_50.0% Prob": 3.041764789323012, "Min_60.0% Prob": 2.565433192273809}}
{"hexsha": "ea0850b98c76acce3979694f0423bba9fb7604b7", "ext": "rs", "lang": "Rust", "content": "fn test_string_writer_markdown() {\n        let mut writer = StringWriter::markdown();\n        writer.spacing(2);\n        assert_eq!(writer.write(), \"\\n\\n\");\n\n        let mut writer = StringWriter::markdown();\n        writer.title(\"Hello world\");\n        writer.spacing(2);\n        assert_eq!(writer.write(), \"# Hello world\\n\\n\\n\");\n\n        let mut writer = StringWriter::markdown();\n        writer.title(\"TITLE\");\n        let variant = variant!(\"basic\", \"Basic Notes\", true);\n        writer.variant_header(&variant);\n        writer.release_note(&variant, \"ticket\", \"description\", \"issue\");\n        writer.variant_footer();\n        assert_eq!(\n            writer.write(),\n            \"# TITLE\\n\\n## Basic Notes\\n\\n- ticket: description issue\\n\"\n        );\n    }", "item_id": 1, "repo": "dcchut/noter", "file": "src/lib.rs", "last_update_at": "2021-08-24T19:10:35+00:00", "question_id": "ea0850b98c76acce3979694f0423bba9fb7604b7_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_string_writer_markdown() {\n        let mut writer = StringWriter::markdown();\n        writer.spacing(2);\n        assert_eq!(writer.write(), \"\\n\\n\");\n        let mut writer = StringWriter::markdown();\n        writer.title(\"Hello world\");\n        writer.spacing(2);\n        assert_eq!(writer.write(), \"# Hello world\\n\\n\\n\");\n        let mut writer = StringWriter::markdown();\n        writer.title(\"TITLE\");\n        let variant = variant!(\"basic\", \"Basic Notes\", true);\n        writer.variant_header(&variant);\n        writer.release_note(&variant, \"ticket\", \"description\", \"issue\");\n        writer.variant_footer();\n        assert_eq!(\n            writer.write(),\n            \"# TITLE\\n\\n## Basic Notes\\n\\n- ticket: description issue\\n\"\n        );\n"]], "pred": {"ppl": 3.008737564086914, "ppl_lower": 3.1178646087646484, "ppl/lowercase_ppl": -1.0323441714318813, "ppl/zlib": 0.0039766085807131785, "Min_5.0% Prob": 9.177821111679076, "Min_10.0% Prob": 6.911845615931919, "Min_20.0% Prob": 4.636211758436159, "Min_30.0% Prob": 3.439263396996718, "Min_40.0% Prob": 2.7122624863025755, "Min_50.0% Prob": 2.1988350590346037, "Min_60.0% Prob": 1.8356113318640452}}
{"hexsha": "4d23d4dedb3898a9aba7aaddc082db0d4af63142", "ext": "rs", "lang": "Rust", "content": "fn validate_endpoint(\n    endpoint: &ConnectionEndpoint,\n    strict: bool,\n) -> Result<(IpAddr, u16), InvariantCheckError> {\n    if endpoint.protocol() != Protocol::Http1\n        && endpoint.protocol() != Protocol::Http1Tls13\n        && endpoint.protocol() != Protocol::P2p1Tls13\n    {\n        return Err(InvariantCheckError {\n            msg: format!(\n                \"Endpoint protocol is not supported: {:?}\",\n                endpoint.protocol\n            ),\n            source: None,\n        });\n    }\n\n    let ip: IpAddr = endpoint\n        .ip_addr\n        .parse::<IpAddr>()\n        .map_err(|e| InvariantCheckError {\n            msg: format!(\"Failed to parse IP address: {:?}\", endpoint.ip_addr),\n            source: Some(Box::new(e)),\n        })?;\n\n    let port = u16::try_from(endpoint.port).map_err(|e| InvariantCheckError {\n        msg: format!(\"Failed to parse port: {:?}\", endpoint.port),\n        source: Some(Box::new(e)),\n    })?;\n\n    if ip.is_unspecified() {\n        return Err(InvariantCheckError {\n            msg: format!(\"IP Address {:?} is unspecified\", ip),\n            source: None,\n        });\n    }\n\n    if let IpAddr::V4(ipv4) = ip {\n        if ipv4.is_broadcast() {\n            return Err(InvariantCheckError {\n                msg: format!(\"IP Address {:?} is a broadcast address\", ip),\n                source: None,\n            });\n        }\n\n        if ipv4.is_multicast() {\n            return Err(InvariantCheckError {\n                msg: format!(\"IP Address {:?} is a multicast address\", ip),\n                source: None,\n            });\n        }\n    } else if let IpAddr::V6(ipv6) = ip {\n        let multicast_addr_and_mask = Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0);\n        if mask_ipv6(ipv6, multicast_addr_and_mask) == multicast_addr_and_mask {\n            return Err(InvariantCheckError {\n                msg: format!(\"IP Address {:?} is a multicast address\", ip),\n                source: None,\n            });\n        }\n    }\n\n    if strict {\n        if ip.is_loopback() {\n            return Err(InvariantCheckError {\n                msg: format!(\"IP Address {:?} is the loopback address\", ip),\n                source: None,\n            });\n        }\n\n        if let IpAddr::V4(ipv4) = ip {\n            if ipv4.is_private() {\n                return Err(InvariantCheckError {\n                    msg: format!(\"IP Address {:?} is a private address\", ip),\n                    source: None,\n                });\n            }\n            if ipv4.is_link_local() {\n                return Err(InvariantCheckError {\n                    msg: format!(\"IP Address {:?} is a link local address\", ip),\n                    source: None,\n                });\n            }\n            for (addr, mask, res_type) in &IPV4_STRICT_CHECKS {\n                if mask_ipv4(ipv4, *mask) == *addr {\n                    return Err(InvariantCheckError {\n                        msg: format!(\"IP Address {:?} is not allowed ({})\", ip, res_type),\n                        source: None,\n                    });\n                }\n            }\n        } else if let IpAddr::V6(ipv6) = ip {\n            for (addr, mask, res_type) in &IPV6_STRICT_CHECKS {\n                if mask_ipv6(ipv6, *mask) == *addr {\n                    return Err(InvariantCheckError {\n                        msg: format!(\"IP Address {:?} is not allowed ({})\", ip, res_type),\n                        source: None,\n                    });\n                }\n            }\n        }\n    }\n\n    Ok((ip, port))\n}", "item_id": 1, "repo": "audieleon/ic", "file": "rs/registry/canister/src/invariants/endpoint.rs", "last_update_at": "2021-09-15T01:19:25+00:00", "question_id": "4d23d4dedb3898a9aba7aaddc082db0d4af63142_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn validate_endpoint(\n    endpoint: &ConnectionEndpoint,\n    strict: bool,\n) -> Result<(IpAddr, u16), InvariantCheckError> {\n    if endpoint.protocol() != Protocol::Http1\n        && endpoint.protocol() != Protocol::Http1Tls13\n        && endpoint.protocol() != Protocol::P2p1Tls13\n    {\n        return Err(InvariantCheckError {\n            msg: format!(\n                \"Endpoint protocol is not supported: {:?}\",\n                endpoint.protocol\n            ),\n            source: None,\n        });\n    }\n    let ip: IpAddr = endpoint\n        .ip_addr\n        .parse::<IpAddr>()\n        .map_err(|e| InvariantCheckError {\n            msg: format!(\"Failed to parse IP address: {:?}\", endpoint.ip_addr),\n            source: Some(Box::new(e)),\n        })?;\n    let port = u16::try_from(endpoint.port).map_err(|e| InvariantCheckError {\n        msg: format!(\"Failed to parse port: {:?}\", endpoint.port),\n        source: Some(Box::new(e)),\n    })?;\n    if ip.is_unspecified() {\n        return Err(InvariantCheckError {\n            msg: format!(\"IP Address {:?} is unspecified\", ip),\n            source: None,\n        });\n    }\n    if let IpAddr::V4(ipv4) = ip {\n        if ipv4.is_broadcast() {\n            return Err(InvariantCheckError {\n                msg: format!(\"IP Address {:?} is a broadcast address\", ip),\n                source: None,\n            });\n        }\n        if ipv4.is_multicast() {\n            return Err(InvariantCheckError {\n                msg: format!(\"IP Address {:?} is a multicast address\", ip),\n                source: None,\n            });\n        }\n    } else if let IpAddr::V6(ipv6) = ip {\n        let multicast_addr_and_mask = Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0);\n        if mask_ipv6(ipv6, multicast_addr_and_mask) == multicast_addr_and_mask {\n            return Err(InvariantCheckError {\n                msg: format!(\"IP Address {:?} is a multicast address\", ip),\n                source: None,\n            });\n        }\n    }\n    if strict {\n        if ip.is_loopback() {\n            return Err(InvariantCheckError {\n                msg: format!(\"IP Address {:?} is the loopback address\", ip),\n                source: None,\n            });\n        }\n        if let IpAddr::V4(ipv4) = ip {\n            if ipv4.is_private() {\n                return Err(InvariantCheckError {\n                    msg: format!(\"IP Address {:?} is a private address\", ip),\n                    source: None,\n                });\n            }\n            if ipv4.is_link_local() {\n                return Err(InvariantCheckError {\n                    msg: format!(\"IP Address {:?} is a link local address\", ip),\n                    source: None,\n                });\n            }\n            for (addr, mask, res_type) in &IPV4_STRICT_CHECKS {\n                if mask_ipv4(ipv4, *mask) == *addr {\n                    return Err(InvariantCheckError {\n                        msg: format!(\"IP Address {:?} is not allowed ({})\", ip, res_type),\n                        source: None,\n                    });\n                }\n            }\n        } else if let IpAddr::V6(ipv6) = ip {\n            for (addr, mask, res_type) in &IPV6_STRICT_CHECKS {\n                if mask_ipv6(ipv6, *mask) == *addr {\n                    return Err(InvariantCheckError {\n                        msg: format!(\"IP Address {:?} is not allowed ({})\", ip, res_type),\n                        source: None,\n                    });\n                }\n            }\n        }\n    }\n    Ok((ip, port))\n"]], "pred": {"ppl": 1.393963098526001, "ppl_lower": 1.4777626991271973, "ppl/lowercase_ppl": -1.175758742138959, "ppl/zlib": 0.00044885248694909267, "Min_5.0% Prob": 4.490626470715392, "Min_10.0% Prob": 2.9193109881644155, "Min_20.0% Prob": 1.6259936262287347, "Min_30.0% Prob": 1.1054417410183675, "Min_40.0% Prob": 0.8299532975764685, "Min_50.0% Prob": 0.6647591353343971, "Min_60.0% Prob": 0.5542620864637359}}
{"hexsha": "4f7a0731bc428da40525927d8abddf150731ea59", "ext": "rs", "lang": "Rust", "content": "fn succeeds_with_escape_option(test_cases: Vec<&str>, expected_output: &str) {\n            let regexp = RegExpBuilder::from(&test_cases)\n                .with_conversion_of(&[Feature::NonDigit])\n                .with_escaping_of_non_ascii_chars(false)\n                .build();\n            test_if_regexp_is_correct(regexp, expected_output, &test_cases);\n            test_if_regexp_matches_test_cases(expected_output, test_cases);\n        }", "item_id": 46, "repo": "asheraryam/grex", "file": "tests/lib_integration_tests.rs", "last_update_at": "2021-03-22T01:42:04+00:00", "question_id": "4f7a0731bc428da40525927d8abddf150731ea59_46", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn succeeds_with_escape_option(test_cases: Vec<&str>, expected_output: &str) {\n            let regexp = RegExpBuilder::from(&test_cases)\n                .with_conversion_of(&[Feature::NonDigit])\n                .with_escaping_of_non_ascii_chars(false)\n                .build();\n            test_if_regexp_is_correct(regexp, expected_output, &test_cases);\n            test_if_regexp_matches_test_cases(expected_output, test_cases);\n"]], "pred": {"ppl": 3.7547624111175537, "ppl_lower": 4.7613444328308105, "ppl/lowercase_ppl": -1.1795166832074093, "ppl/zlib": 0.0059063616542077745, "Min_5.0% Prob": 8.796914339065552, "Min_10.0% Prob": 6.905507784623366, "Min_20.0% Prob": 4.904545448444508, "Min_30.0% Prob": 3.8006415861408884, "Min_40.0% Prob": 3.126528309451209, "Min_50.0% Prob": 2.5882336760268494, "Min_60.0% Prob": 2.1890722745802345}}
{"hexsha": "14fddacb342df1033d738190f7de22ae672564e0", "ext": "rs", "lang": "Rust", "content": "fn peerv6_compact_transform() {\n        let peer = Peer::V6(Peerv6 {\n            peer_id: \"ABCDEFGHIJKLMNOPQRST\".to_string(),\n            ip: Ipv6Addr::new(\n                0x2001, 0x0db8, 0x85a3, 0x0000, 0x0000, 0x8a2e, 0x0370, 0x7334,\n            ),\n            port: 6681,\n            last_announced: Instant::now(),\n        });\n\n        let mut localhost_port_byte_string = vec![];\n        let localhost_decimal = 42540766452641154071740215577757643572 as u128;\n        let port = 6681 as u16;\n        localhost_port_byte_string.put_slice(&localhost_decimal.to_be_bytes());\n        localhost_port_byte_string.put_slice(&port.to_be_bytes());\n\n        let compact_rep_byte_string = peer.compact();\n\n        assert_eq!(compact_rep_byte_string, localhost_port_byte_string.to_vec());\n    }", "item_id": 3, "repo": "deekerno/tyto", "file": "src/bittorrent.rs", "last_update_at": "2021-11-23T04:23:50+00:00", "question_id": "14fddacb342df1033d738190f7de22ae672564e0_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn peerv6_compact_transform() {\n        let peer = Peer::V6(Peerv6 {\n            peer_id: \"ABCDEFGHIJKLMNOPQRST\".to_string(),\n            ip: Ipv6Addr::new(\n                0x2001, 0x0db8, 0x85a3, 0x0000, 0x0000, 0x8a2e, 0x0370, 0x7334,\n            ),\n            port: 6681,\n            last_announced: Instant::now(),\n        });\n        let mut localhost_port_byte_string = vec![];\n        let localhost_decimal = 42540766452641154071740215577757643572 as u128;\n        let port = 6681 as u16;\n        localhost_port_byte_string.put_slice(&localhost_decimal.to_be_bytes());\n        localhost_port_byte_string.put_slice(&port.to_be_bytes());\n        let compact_rep_byte_string = peer.compact();\n        assert_eq!(compact_rep_byte_string, localhost_port_byte_string.to_vec());\n"]], "pred": {"ppl": 2.6794488430023193, "ppl_lower": 2.977203369140625, "ppl/lowercase_ppl": -1.1069116139958695, "ppl/zlib": 0.0027003044322646682, "Min_5.0% Prob": 7.765613853931427, "Min_10.0% Prob": 5.712120092276371, "Min_20.0% Prob": 4.098539157347246, "Min_30.0% Prob": 3.085346231460571, "Min_40.0% Prob": 2.4212703954680523, "Min_50.0% Prob": 1.9581929303839536, "Min_60.0% Prob": 1.6433191284537316}}
{"hexsha": "e5877840d427d14ead6edf829d36c4d5a130ee60", "ext": "rs", "lang": "Rust", "content": "fn to_bytes_unspec() {\n        let header = Header::new(\n            Version::Two,\n            Command::Local,\n            Protocol::Unspecified,\n            vec![],\n            Addresses::None,\n        );\n        let mut output: Vec<u8> = Vec::with_capacity(PREFIX.len());\n\n        output.extend_from_slice(PREFIX);\n        output.push(0x20);\n        output.push(0x00);\n        output.extend(&[0, 0]);\n\n        assert_eq!(to_bytes(header), Ok(output));\n    }", "item_id": 21, "repo": "conblem/ppp", "file": "src/binary.rs", "last_update_at": "2021-09-20T11:12:26+00:00", "question_id": "e5877840d427d14ead6edf829d36c4d5a130ee60_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn to_bytes_unspec() {\n        let header = Header::new(\n            Version::Two,\n            Command::Local,\n            Protocol::Unspecified,\n            vec![],\n            Addresses::None,\n        );\n        let mut output: Vec<u8> = Vec::with_capacity(PREFIX.len());\n        output.extend_from_slice(PREFIX);\n        output.push(0x20);\n        output.push(0x00);\n        output.extend(&[0, 0]);\n        assert_eq!(to_bytes(header), Ok(output));\n"]], "pred": {"ppl": 3.181267499923706, "ppl_lower": 4.431334972381592, "ppl/lowercase_ppl": -1.2863795017929687, "ppl/zlib": 0.004556219300235833, "Min_5.0% Prob": 7.547943047114781, "Min_10.0% Prob": 6.348510503768921, "Min_20.0% Prob": 4.498484307322009, "Min_30.0% Prob": 3.5082812309265137, "Min_40.0% Prob": 2.7786300876017274, "Min_50.0% Prob": 2.2697445786979102, "Min_60.0% Prob": 1.928177038828532}}
{"hexsha": "571ee8216cf55e877a124a634afc4513dff59c41", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_lldiv_t() {\n    assert_eq!(\n        ::std::mem::size_of::<lldiv_t>(),\n        16usize,\n        concat!(\"Size of: \", stringify!(lldiv_t))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<lldiv_t>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(lldiv_t))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(lldiv_t),\n            \"::\",\n            stringify!(quot)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },\n        8usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(lldiv_t),\n            \"::\",\n            stringify!(rem)\n        )\n    );\n}", "item_id": 2, "repo": "oliverfunk/darknet-rs", "file": "darknet-sys/src/lib.rs", "last_update_at": "2021-07-11T15:21:16+00:00", "question_id": "571ee8216cf55e877a124a634afc4513dff59c41_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout_lldiv_t() {\n    assert_eq!(\n        ::std::mem::size_of::<lldiv_t>(),\n        16usize,\n        concat!(\"Size of: \", stringify!(lldiv_t))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<lldiv_t>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(lldiv_t))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(lldiv_t),\n            \"::\",\n            stringify!(quot)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },\n        8usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(lldiv_t),\n            \"::\",\n            stringify!(rem)\n        )\n    );\n"]], "pred": {"ppl": 1.1717020273208618, "ppl_lower": 1.2077816724777222, "ppl/lowercase_ppl": -1.1913948448993101, "ppl/zlib": 0.0006313044459335739, "Min_5.0% Prob": 3.1908685650144304, "Min_10.0% Prob": 1.5955418875633642, "Min_20.0% Prob": 0.8002925707119646, "Min_30.0% Prob": 0.5336253844864263, "Min_40.0% Prob": 0.3968139328398037, "Min_50.0% Prob": 0.31799821424833496, "Min_60.0% Prob": 0.2653024558627177}}
{"hexsha": "1ecca08e58d4310286b9f074f34dbe6ccd1d62f2", "ext": "rs", "lang": "Rust", "content": "fn should_trim_start() -> Result {\n    assert_eq!(trim_start_regexp(\"  abc  \", \"\\\\s\")?, \"abc  \");\n    assert_eq!(trim_start_regexp(\"\\t\\t\\tabc\\t\\t\", \"\\\\t\")?, \"abc\\t\\t\");\n    assert_eq!(trim_start_regexp(\"\\n\\nabc\\t\\t\", \"\\n\")?, \"abc\\t\\t\");\n    assert_eq!(trim_start_regexp(\"\\n\\n\\n\", \"\\n\")?, \"\");\n\n    Ok(())\n  }", "item_id": 3, "repo": "h-a-n-a/magic-string-rs", "file": "core/src/utils.rs", "last_update_at": "2021-12-27T03:19:36+00:00", "question_id": "1ecca08e58d4310286b9f074f34dbe6ccd1d62f2_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn should_trim_start() -> Result {\n    assert_eq!(trim_start_regexp(\"  abc  \", \"\\\\s\")?, \"abc  \");\n    assert_eq!(trim_start_regexp(\"\\t\\t\\tabc\\t\\t\", \"\\\\t\")?, \"abc\\t\\t\");\n    assert_eq!(trim_start_regexp(\"\\n\\nabc\\t\\t\", \"\\n\")?, \"abc\\t\\t\");\n    assert_eq!(trim_start_regexp(\"\\n\\n\\n\", \"\\n\")?, \"\");\n    Ok(())\n"]], "pred": {"ppl": 2.433105230331421, "ppl_lower": 2.7288944721221924, "ppl/lowercase_ppl": -1.1290287293841315, "ppl/zlib": 0.0066854760461096795, "Min_5.0% Prob": 7.223196903864543, "Min_10.0% Prob": 5.565083888860849, "Min_20.0% Prob": 3.8559201337673046, "Min_30.0% Prob": 2.903067764712543, "Min_40.0% Prob": 2.2191823409362272, "Min_50.0% Prob": 1.7846867403798345, "Min_60.0% Prob": 1.4881294447906226}}
{"hexsha": "99c7fbd9415c282254c081e2b59b48efa948cb98", "ext": "rs", "lang": "Rust", "content": "fn loc_is_adjacent_to_other() {\n        let loc = Loc::new(1, 1);\n        assert!(loc.is_adjacent_to(&Loc::new(1, 0)));\n        assert!(loc.is_adjacent_to(&Loc::new(1, 2)));\n        assert!(loc.is_adjacent_to(&Loc::new(0, 1)));\n        assert!(loc.is_adjacent_to(&Loc::new(2, 1)));\n        assert!(!loc.is_adjacent_to(&Loc::new(1, 1)));\n        assert!(!loc.is_adjacent_to(&Loc::new(0, 0)));\n        assert!(!loc.is_adjacent_to(&Loc::new(0, 2)));\n        assert!(!loc.is_adjacent_to(&Loc::new(2, 0)));\n        assert!(!loc.is_adjacent_to(&Loc::new(2, 2)));\n    }", "item_id": 0, "repo": "shrugalic/advent_of_code", "file": "2018/src/day15.rs", "last_update_at": "2021-12-17T18:26:17+00:00", "question_id": "99c7fbd9415c282254c081e2b59b48efa948cb98_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn loc_is_adjacent_to_other() {\n        let loc = Loc::new(1, 1);\n        assert!(loc.is_adjacent_to(&Loc::new(1, 0)));\n        assert!(loc.is_adjacent_to(&Loc::new(1, 2)));\n        assert!(loc.is_adjacent_to(&Loc::new(0, 1)));\n        assert!(loc.is_adjacent_to(&Loc::new(2, 1)));\n        assert!(!loc.is_adjacent_to(&Loc::new(1, 1)));\n        assert!(!loc.is_adjacent_to(&Loc::new(0, 0)));\n        assert!(!loc.is_adjacent_to(&Loc::new(0, 2)));\n        assert!(!loc.is_adjacent_to(&Loc::new(2, 0)));\n        assert!(!loc.is_adjacent_to(&Loc::new(2, 2)));\n"]], "pred": {"ppl": 1.3255436420440674, "ppl_lower": 1.3734722137451172, "ppl/lowercase_ppl": -1.126034306515956, "ppl/zlib": 0.0022190761509619005, "Min_5.0% Prob": 4.279303453185341, "Min_10.0% Prob": 2.5273884897646695, "Min_20.0% Prob": 1.4037703787503035, "Min_30.0% Prob": 0.9492812363187904, "Min_40.0% Prob": 0.7057115374788923, "Min_50.0% Prob": 0.5659815670713152, "Min_60.0% Prob": 0.47237758646993866}}
{"hexsha": "206f08add486ad6919aac8b62b8b7a65ed5ea455", "ext": "rs", "lang": "Rust", "content": "fn rocfl(path: impl AsRef<Path>, command: &str) -> Command {\n    let mut rocfl = Command::cargo_bin(\"rocfl\").unwrap();\n    rocfl\n        .arg(\"-S\")\n        .arg(\"-r\")\n        .arg(path.as_ref().to_string_lossy().as_ref())\n        .arg(command);\n    rocfl\n}", "item_id": 4, "repo": "pwinckles/rocfl", "file": "tests/cli-tests.rs", "last_update_at": "2021-12-20T21:27:55+00:00", "question_id": "206f08add486ad6919aac8b62b8b7a65ed5ea455_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn rocfl(path: impl AsRef<Path>, command: &str) -> Command {\n    let mut rocfl = Command::cargo_bin(\"rocfl\").unwrap();\n    rocfl\n        .arg(\"-S\")\n        .arg(\"-r\")\n        .arg(path.as_ref().to_string_lossy().as_ref())\n        .arg(command);\n    rocfl\n"]], "pred": {"ppl": 2.5979228019714355, "ppl_lower": 3.4028842449188232, "ppl/lowercase_ppl": -1.2827147018550058, "ppl/zlib": 0.005929889462113307, "Min_5.0% Prob": 8.193984150886536, "Min_10.0% Prob": 6.58126081360711, "Min_20.0% Prob": 4.274548379998458, "Min_30.0% Prob": 3.0444797113023956, "Min_40.0% Prob": 2.35003132888904, "Min_50.0% Prob": 1.9003456511667796, "Min_60.0% Prob": 1.6110324644130365}}
{"hexsha": "37f6c251f7454fede9b55291317f4daaf7093e18", "ext": "rs", "lang": "Rust", "content": "pub unsafe fn parse_8_chars(s: &[u8]) -> Result<u32, Pie> {\n    debug_assert!(s.len() >= 8);\n    const MASK_HI: u64 = 0xf0f0f0f0f0f0f0f0u64;\n    const ASCII_ZEROS: u64 = 0x3030303030303030u64;\n\n    let chunk = unsafe {\n        let ptr = s.as_ptr();\n        debug_assert!(ptr as usize % core::mem::size_of::<u64>() == 0);\n        //        (if ptr as usize % core::mem::size_of::<u64>() == 0 {\n        *(ptr as *const u64)\n        // } else {\n        //     panic!(\"swoops8\");\n\n        //     core::ptr::read_unaligned(ptr as *const u64)\n        // })\n         ^ ASCII_ZEROS\n    };\n\n    let valid = (chunk & MASK_HI)\n        | (chunk.wrapping_add(0x7676767676767676u64) & 0x8080808080808080u64)\n        == 0;\n\n    // 1-byte mask trick (works on 4 pairs of single digits)\n    let lower_digits = ((chunk & 0x0f000f000f000f00) >> 8) * 10; //Compiler does *8 + *2\n    let upper_digits = chunk & 0x000f000f000f000f;\n    let chunk = lower_digits + upper_digits;\n\n    // 2-byte mask trick (works on 2 pairs of two digits)\n    let lower_digits = ((chunk & 0x00ff000000ff0000) >> 16) * 100; //TODO: decompose * 100 to shifts\n    let upper_digits = chunk & 0x000000ff000000ff;\n    let chunk = lower_digits + upper_digits;\n\n    // 4-byte mask trick (works on a pair of four digits)\n    let lower_digits = (((chunk & 0x0000ffff00000000) >> 32) * 10000) as u32;\n    let upper_digits = chunk as u32;\n\n    //We do this before the if shaving 300ps.\n    let chunk = lower_digits + upper_digits;\n\n    if likely!(valid) {\n        Ok(chunk) //u32 can guarantee to contain 9 digits.\n    } else {\n        Err(Pie {\n            kind: IntErrorKind::InvalidDigit,\n        })\n    }\n}", "item_id": 7, "repo": "gilescope/atoi_radix10", "file": "src/lib.rs", "last_update_at": "2021-12-07T18:40:02+00:00", "question_id": "37f6c251f7454fede9b55291317f4daaf7093e18_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe fn parse_8_chars(s: &[u8]) -> Result<u32, Pie> {\n    debug_assert!(s.len() >= 8);\n    const MASK_HI: u64 = 0xf0f0f0f0f0f0f0f0u64;\n    const ASCII_ZEROS: u64 = 0x3030303030303030u64;\n    let chunk = unsafe {\n        let ptr = s.as_ptr();\n        debug_assert!(ptr as usize % core::mem::size_of::<u64>() == 0);\n        //        (if ptr as usize % core::mem::size_of::<u64>() == 0 {\n        *(ptr as *const u64)\n        // } else {\n        //     panic!(\"swoops8\");\n        //     core::ptr::read_unaligned(ptr as *const u64)\n        // })\n         ^ ASCII_ZEROS\n    };\n    let valid = (chunk & MASK_HI)\n        | (chunk.wrapping_add(0x7676767676767676u64) & 0x8080808080808080u64)\n        == 0;\n    // 1-byte mask trick (works on 4 pairs of single digits)\n    let lower_digits = ((chunk & 0x0f000f000f000f00) >> 8) * 10; //Compiler does *8 + *2\n    let upper_digits = chunk & 0x000f000f000f000f;\n    let chunk = lower_digits + upper_digits;\n    // 2-byte mask trick (works on 2 pairs of two digits)\n    let lower_digits = ((chunk & 0x00ff000000ff0000) >> 16) * 100; //TODO: decompose * 100 to shifts\n    let upper_digits = chunk & 0x000000ff000000ff;\n    let chunk = lower_digits + upper_digits;\n    // 4-byte mask trick (works on a pair of four digits)\n    let lower_digits = (((chunk & 0x0000ffff00000000) >> 32) * 10000) as u32;\n    let upper_digits = chunk as u32;\n    //We do this before the if shaving 300ps.\n    let chunk = lower_digits + upper_digits;\n    if likely!(valid) {\n        Ok(chunk) //u32 can guarantee to contain 9 digits.\n    } else {\n        Err(Pie {\n            kind: IntErrorKind::InvalidDigit,\n        })\n    }\n"]], "pred": {"ppl": 2.5575530529022217, "ppl_lower": 2.7319655418395996, "ppl/lowercase_ppl": -1.070252168176342, "ppl/zlib": 0.0014402622126936798, "Min_5.0% Prob": 7.947650869687398, "Min_10.0% Prob": 6.121207975361445, "Min_20.0% Prob": 4.153721397425852, "Min_30.0% Prob": 3.008239849860018, "Min_40.0% Prob": 2.314159175368393, "Min_50.0% Prob": 1.871050555177784, "Min_60.0% Prob": 1.5623611336206498}}
{"hexsha": "7614b7ee5b1ee1087b369fb9593e3e759b518639", "ext": "rs", "lang": "Rust", "content": "fn rpc_protocol() {\n    ::libra_logger::try_init_for_testing();\n\n    let listener_peer_id = PeerId::random();\n    let dialer_peer_id = PeerId::random();\n    let protocol_id = b\"/get_blocks/1.0.0\";\n    let req_data = b\"hello\";\n    let res_data = b\"goodbye\";\n\n    let mut rt = Runtime::new().unwrap();\n\n    let (dialer_substream, listener_substream) = MemorySocket::new_pair();\n\n    // Set up the dialer Rpc protocol actor\n    let (mut dialer_rpc_tx, dialer_rpc_rx) = channel::new_test(8);\n    let (_, dialer_peer_notifs_rx) = channel::new_test(8);\n    let (dialer_peer_reqs_tx, mut dialer_peer_reqs_rx) = channel::new_test(8);\n    let dialer_peer_reqs_tx = PeerHandle::new(\n        listener_peer_id,\n        Multiaddr::from_str(\"/ip6/::1/tcp/8080\").unwrap(),\n        dialer_peer_reqs_tx,\n    );\n    let (rpc_handler_tx, _) = channel::new_test(8);\n    let dialer_rpc = Rpc::new(\n        rt.handle().clone(),\n        dialer_peer_reqs_tx,\n        dialer_rpc_rx,\n        dialer_peer_notifs_rx,\n        rpc_handler_tx,\n        Duration::from_millis(500),\n        10,\n        10,\n    );\n\n    // Fake the dialer NetworkProvider\n    let f_dialer_network = async move {\n        let (res_tx, res_rx) = oneshot::channel();\n\n        let req = OutboundRpcRequest {\n            protocol: ProtocolId::from_static(protocol_id),\n            data: Bytes::from_static(req_data),\n            res_tx,\n            timeout: Duration::from_secs(1),\n        };\n\n        // Tell Rpc to send an rpc request\n        dialer_rpc_tx.send(RpcRequest::SendRpc(req)).await.unwrap();\n\n        // Fulfill the open substream request\n        match dialer_peer_reqs_rx.next().await.unwrap() {\n            PeerRequest::OpenSubstream(protocol, substream_tx) => {\n                assert_eq!(protocol.as_ref(), protocol_id);\n                substream_tx.send(Ok(dialer_substream)).unwrap();\n            }\n            _ => {\n                unreachable!();\n            }\n        }\n\n        // Check the rpc response data\n        let data = res_rx.await.unwrap().unwrap();\n        assert_eq!(data.as_ref(), res_data);\n    };\n\n    // Set up the listener Rpc protocol actor\n    let (_, listener_rpc_reqs_rx) = channel::new_test(8);\n    let (mut listener_peer_notifs_tx, listener_peer_notifs_rx) = channel::new_test(8);\n    let (listener_peer_reqs_tx, _) = channel::new_test(8);\n    let listener_peer_reqs_tx = PeerHandle::new(\n        dialer_peer_id,\n        Multiaddr::from_str(\"/ip6/::1/tcp/8081\").unwrap(),\n        listener_peer_reqs_tx,\n    );\n    let (listener_rpc_notifs_tx, mut listener_rpc_notifs_rx) = channel::new_test(8);\n    let listener_rpc = Rpc::new(\n        rt.handle().clone(),\n        listener_peer_reqs_tx,\n        listener_rpc_reqs_rx,\n        listener_peer_notifs_rx,\n        listener_rpc_notifs_tx,\n        Duration::from_millis(500),\n        10,\n        10,\n    );\n\n    // Fake the listener NetworkProvider\n    let f_listener_network = async move {\n        // Notify Rpc of a new inbound substream\n\n        listener_peer_notifs_tx\n            .send(PeerNotification::NewSubstream(\n                dialer_peer_id,\n                NegotiatedSubstream {\n                    protocol: ProtocolId::from_static(protocol_id),\n                    substream: listener_substream,\n                },\n            ))\n            .await\n            .unwrap();\n\n        // Handle the inbound rpc request\n        match listener_rpc_notifs_rx.next().await.unwrap() {\n            RpcNotification::RecvRpc(req) => {\n                assert_eq!(req.protocol.as_ref(), protocol_id);\n                assert_eq!(req.data.as_ref(), req_data);\n                req.res_tx.send(Ok(Bytes::from_static(res_data))).unwrap();\n            }\n        }\n    };\n\n    let f = join4(\n        f_listener_network,\n        listener_rpc.start(),\n        f_dialer_network,\n        dialer_rpc.start(),\n    );\n    rt.block_on(f);\n}", "item_id": 11, "repo": "Lufundza/libra", "file": "network/src/protocols/rpc/test.rs", "last_update_at": "2021-09-16T03:21:56+00:00", "question_id": "7614b7ee5b1ee1087b369fb9593e3e759b518639_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn rpc_protocol() {\n    ::libra_logger::try_init_for_testing();\n    let listener_peer_id = PeerId::random();\n    let dialer_peer_id = PeerId::random();\n    let protocol_id = b\"/get_blocks/1.0.0\";\n    let req_data = b\"hello\";\n    let res_data = b\"goodbye\";\n    let mut rt = Runtime::new().unwrap();\n    let (dialer_substream, listener_substream) = MemorySocket::new_pair();\n    // Set up the dialer Rpc protocol actor\n    let (mut dialer_rpc_tx, dialer_rpc_rx) = channel::new_test(8);\n    let (_, dialer_peer_notifs_rx) = channel::new_test(8);\n    let (dialer_peer_reqs_tx, mut dialer_peer_reqs_rx) = channel::new_test(8);\n    let dialer_peer_reqs_tx = PeerHandle::new(\n        listener_peer_id,\n        Multiaddr::from_str(\"/ip6/::1/tcp/8080\").unwrap(),\n        dialer_peer_reqs_tx,\n    );\n    let (rpc_handler_tx, _) = channel::new_test(8);\n    let dialer_rpc = Rpc::new(\n        rt.handle().clone(),\n        dialer_peer_reqs_tx,\n        dialer_rpc_rx,\n        dialer_peer_notifs_rx,\n        rpc_handler_tx,\n        Duration::from_millis(500),\n        10,\n        10,\n    );\n    // Fake the dialer NetworkProvider\n    let f_dialer_network = async move {\n        let (res_tx, res_rx) = oneshot::channel();\n        let req = OutboundRpcRequest {\n            protocol: ProtocolId::from_static(protocol_id),\n            data: Bytes::from_static(req_data),\n            res_tx,\n            timeout: Duration::from_secs(1),\n        };\n        // Tell Rpc to send an rpc request\n        dialer_rpc_tx.send(RpcRequest::SendRpc(req)).await.unwrap();\n        // Fulfill the open substream request\n        match dialer_peer_reqs_rx.next().await.unwrap() {\n            PeerRequest::OpenSubstream(protocol, substream_tx) => {\n                assert_eq!(protocol.as_ref(), protocol_id);\n                substream_tx.send(Ok(dialer_substream)).unwrap();\n            }\n            _ => {\n                unreachable!();\n            }\n        }\n        // Check the rpc response data\n        let data = res_rx.await.unwrap().unwrap();\n        assert_eq!(data.as_ref(), res_data);\n    };\n    // Set up the listener Rpc protocol actor\n    let (_, listener_rpc_reqs_rx) = channel::new_test(8);\n    let (mut listener_peer_notifs_tx, listener_peer_notifs_rx) = channel::new_test(8);\n    let (listener_peer_reqs_tx, _) = channel::new_test(8);\n    let listener_peer_reqs_tx = PeerHandle::new(\n        dialer_peer_id,\n        Multiaddr::from_str(\"/ip6/::1/tcp/8081\").unwrap(),\n        listener_peer_reqs_tx,\n    );\n    let (listener_rpc_notifs_tx, mut listener_rpc_notifs_rx) = channel::new_test(8);\n    let listener_rpc = Rpc::new(\n        rt.handle().clone(),\n        listener_peer_reqs_tx,\n        listener_rpc_reqs_rx,\n        listener_peer_notifs_rx,\n        listener_rpc_notifs_tx,\n        Duration::from_millis(500),\n        10,\n        10,\n    );\n    // Fake the listener NetworkProvider\n    let f_listener_network = async move {\n        // Notify Rpc of a new inbound substream\n        listener_peer_notifs_tx\n            .send(PeerNotification::NewSubstream(\n                dialer_peer_id,\n                NegotiatedSubstream {\n                    protocol: ProtocolId::from_static(protocol_id),\n                    substream: listener_substream,\n                },\n            ))\n            .await\n            .unwrap();\n        // Handle the inbound rpc request\n        match listener_rpc_notifs_rx.next().await.unwrap() {\n            RpcNotification::RecvRpc(req) => {\n                assert_eq!(req.protocol.as_ref(), protocol_id);\n                assert_eq!(req.data.as_ref(), req_data);\n                req.res_tx.send(Ok(Bytes::from_static(res_data))).unwrap();\n            }\n        }\n    };\n    let f = join4(\n        f_listener_network,\n        listener_rpc.start(),\n        f_dialer_network,\n        dialer_rpc.start(),\n    );\n    rt.block_on(f);\n"]], "pred": {"ppl": 1.6108384132385254, "ppl_lower": 1.8254765272140503, "ppl/lowercase_ppl": -1.2623702320786512, "ppl/zlib": 0.000460188028007327, "Min_5.0% Prob": 5.251624214882944, "Min_10.0% Prob": 3.679476617598066, "Min_20.0% Prob": 2.2338862042216694, "Min_30.0% Prob": 1.568106193046749, "Min_40.0% Prob": 1.18788281461101, "Min_50.0% Prob": 0.9535351523130753, "Min_60.0% Prob": 0.7954532028469112}}
{"hexsha": "b563d050d34868c77a1a89289a4a572ac873715a", "ext": "rs", "lang": "Rust", "content": "fn chained_comparisons_with_larger_context() {\n    let input = \"x == 3 && 1 + 2 > x.abs() == 3 && T\";\n    let err = binary_expr::<FieldGrammar, Complete>(InputSpan::new(input)).unwrap_err();\n    let err = match err {\n        NomErr::Failure(err) => err,\n        _ => panic!(\"Unexpected error: {:?}\", err),\n    };\n    assert_matches!(err.kind(), ErrorKind::ChainedComparison);\n    assert_eq!(*err.span().fragment(), \"1 + 2 > x.abs() == 3\");\n}", "item_id": 5, "repo": "slowli/arithmetic-parser", "file": "parser/src/parser/tests/order.rs", "last_update_at": "2021-12-27T14:39:35+00:00", "question_id": "b563d050d34868c77a1a89289a4a572ac873715a_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn chained_comparisons_with_larger_context() {\n    let input = \"x == 3 && 1 + 2 > x.abs() == 3 && T\";\n    let err = binary_expr::<FieldGrammar, Complete>(InputSpan::new(input)).unwrap_err();\n    let err = match err {\n        NomErr::Failure(err) => err,\n        _ => panic!(\"Unexpected error: {:?}\", err),\n    };\n    assert_matches!(err.kind(), ErrorKind::ChainedComparison);\n    assert_eq!(*err.span().fragment(), \"1 + 2 > x.abs() == 3\");\n"]], "pred": {"ppl": 4.2511749267578125, "ppl_lower": 6.1828765869140625, "ppl/lowercase_ppl": -1.2588373572237381, "ppl/zlib": 0.005150161559021059, "Min_5.0% Prob": 8.594748428889684, "Min_10.0% Prob": 7.330034065246582, "Min_20.0% Prob": 5.368191795964395, "Min_30.0% Prob": 4.267872389326704, "Min_40.0% Prob": 3.4419624199942938, "Min_50.0% Prob": 2.8415315792530396, "Min_60.0% Prob": 2.419049951782886}}
{"hexsha": "9cabdbe62a0e4864d1edf0d4817383797db3064e", "ext": "rs", "lang": "Rust", "content": "pub fn update_table_circuit<F, O>(\n    circuit: &mut F,\n    evaluator_table: impl encoded::LazilyEncodedTable<\n        F,\n        Item = BytesBundle<<F as Fancy>::Item, LOCATION_BYTES>,\n        Error = anyhow::Error,\n    >,\n    last_upd_table: encoded::IndexColumns<<F as Fancy>::Item>,\n    r: impl encoded::LazilyEncodedTable<\n        F,\n        Item = (\n            BytesBundle<<F as Fancy>::Item, LOCATION_BYTES>,\n            BytesBundle<<F as Fancy>::Item, LOCATION_BYTES>,\n        ),\n        Error = anyhow::Error,\n    >,\n    receiver: encoded::Receiver<<F as Fancy>::Item>,\n    evaluator_loc_share: encoded::LocationShare<<F as Fancy>::Item>,\n    mut output_builder: O,\n) -> Result<O::Output>\nwhere\n    F: Fancy + FancyInput<Item = <F as Fancy>::Item>,\n    O: OutputBuilder<\n        F,\n        Item = BytesBundle<<F as Fancy>::Item, LOCATION_BYTES>,\n        Error = anyhow::Error,\n    >,\n{\n    {\n        // Check pre-conditions\n        let evaluator_table_size = evaluator_table.size();\n        let last_upd_table_size = last_upd_table.size();\n        let r_size = r.size();\n\n        ensure!(\n            evaluator_table_size.m == last_upd_table_size,\n            \"evaluator table and last upd tables are differently sized (evaluator table size = {:?}, last upd tables size = {})\",\n            evaluator_table_size, last_upd_table_size\n        );\n        ensure!(\n            evaluator_table_size == r_size,\n            \"evaluator table and r table are differently sized (evaluator table size = {:?}, r size = {:?})\",\n            evaluator_table_size, r_size\n        )\n    }\n\n    let size = evaluator_table.size();\n\n    let receiver = circuit\n        .bytes_xor(&receiver.gb, &receiver.ev)\n        .context(\"construct receiver wires\")?;\n\n    let joint_tables = last_upd_table\n        .join()\n        .zip(evaluator_table.rows_iter())\n        .zip(r.rows_iter());\n    for (i, (((last_upd_gb, last_upd_ev), mut loc_row), mut blinding_row)) in\n        joint_tables.enumerate()\n    {\n        let index = circuit\n            .bytes_xor(last_upd_gb, last_upd_ev)\n            .context(\"construct last_upd_index\")?;\n        for j in 0..size.l {\n            let prev_loc = loc_row\n                .next_item(circuit)\n                .context(\"retrieve next item\")?\n                .context(\"internal: unexpected end of row\")?;\n            let (r_gb, r_ev) = blinding_row\n                .next_item(circuit)\n                .context(\"retrieve next blinding\")?\n                .context(\"internal: unexpected end of row (blindings)\")?;\n\n            let i_bundle = circuit\n                .bytes_constant(&ByteArray::new((i as u16).to_be_bytes()))\n                .context(\"convert i to wires\")?;\n            let j_bundle = circuit\n                .bytes_constant(&ByteArray::new((j as u16).to_be_bytes()))\n                .context(\"convert j to wires\")?;\n            let condition_a = circuit\n                .bytes_eq(&i_bundle, &receiver)\n                .context(\"construct condition_a\")?;\n            let condition_b = circuit\n                .bytes_eq(&j_bundle, &index)\n                .context(\"construct condition_b\")?;\n            let condition = circuit\n                .and(&condition_a, &condition_b)\n                .map_err(|e| anyhow!(\"construct condition: {}\", e))?;\n\n            let maybe_overridden = circuit\n                .bytes_mux(&condition, &prev_loc, &evaluator_loc_share)\n                .context(\"construct maybe_overridden\")?;\n            let r = circuit.bytes_xor(&r_gb, &r_ev).context(\"construct r\")?;\n            let new_value = circuit\n                .bytes_xor(&maybe_overridden, &r)\n                .context(\"construct new_value\")?;\n\n            output_builder\n                .process_next(circuit, &new_value)\n                .context(\"not processed by output_builder\")?;\n        }\n    }\n    output_builder.finish()\n}", "item_id": 0, "repo": "anonymous-modq/privacy-preserving-signaling", "file": "pps-garbled-circuits/src/circuits/update_table.rs", "last_update_at": "2021-10-03T16:53:37+00:00", "question_id": "9cabdbe62a0e4864d1edf0d4817383797db3064e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn update_table_circuit<F, O>(\n    circuit: &mut F,\n    evaluator_table: impl encoded::LazilyEncodedTable<\n        F,\n        Item = BytesBundle<<F as Fancy>::Item, LOCATION_BYTES>,\n        Error = anyhow::Error,\n    >,\n    last_upd_table: encoded::IndexColumns<<F as Fancy>::Item>,\n    r: impl encoded::LazilyEncodedTable<\n        F,\n        Item = (\n            BytesBundle<<F as Fancy>::Item, LOCATION_BYTES>,\n            BytesBundle<<F as Fancy>::Item, LOCATION_BYTES>,\n        ),\n        Error = anyhow::Error,\n    >,\n    receiver: encoded::Receiver<<F as Fancy>::Item>,\n    evaluator_loc_share: encoded::LocationShare<<F as Fancy>::Item>,\n    mut output_builder: O,\n) -> Result<O::Output>\nwhere\n    F: Fancy + FancyInput<Item = <F as Fancy>::Item>,\n    O: OutputBuilder<\n        F,\n        Item = BytesBundle<<F as Fancy>::Item, LOCATION_BYTES>,\n        Error = anyhow::Error,\n    >,\n{\n    {\n        // Check pre-conditions\n        let evaluator_table_size = evaluator_table.size();\n        let last_upd_table_size = last_upd_table.size();\n        let r_size = r.size();\n        ensure!(\n            evaluator_table_size.m == last_upd_table_size,\n            \"evaluator table and last upd tables are differently sized (evaluator table size = {:?}, last upd tables size = {})\",\n            evaluator_table_size, last_upd_table_size\n        );\n        ensure!(\n            evaluator_table_size == r_size,\n            \"evaluator table and r table are differently sized (evaluator table size = {:?}, r size = {:?})\",\n            evaluator_table_size, r_size\n        )\n    }\n    let size = evaluator_table.size();\n    let receiver = circuit\n        .bytes_xor(&receiver.gb, &receiver.ev)\n        .context(\"construct receiver wires\")?;\n    let joint_tables = last_upd_table\n        .join()\n        .zip(evaluator_table.rows_iter())\n        .zip(r.rows_iter());\n    for (i, (((last_upd_gb, last_upd_ev), mut loc_row), mut blinding_row)) in\n        joint_tables.enumerate()\n    {\n        let index = circuit\n            .bytes_xor(last_upd_gb, last_upd_ev)\n            .context(\"construct last_upd_index\")?;\n        for j in 0..size.l {\n            let prev_loc = loc_row\n                .next_item(circuit)\n                .context(\"retrieve next item\")?\n                .context(\"internal: unexpected end of row\")?;\n            let (r_gb, r_ev) = blinding_row\n                .next_item(circuit)\n                .context(\"retrieve next blinding\")?\n                .context(\"internal: unexpected end of row (blindings)\")?;\n            let i_bundle = circuit\n                .bytes_constant(&ByteArray::new((i as u16).to_be_bytes()))\n                .context(\"convert i to wires\")?;\n            let j_bundle = circuit\n                .bytes_constant(&ByteArray::new((j as u16).to_be_bytes()))\n                .context(\"convert j to wires\")?;\n            let condition_a = circuit\n                .bytes_eq(&i_bundle, &receiver)\n                .context(\"construct condition_a\")?;\n            let condition_b = circuit\n                .bytes_eq(&j_bundle, &index)\n                .context(\"construct condition_b\")?;\n            let condition = circuit\n                .and(&condition_a, &condition_b)\n                .map_err(|e| anyhow!(\"construct condition: {}\", e))?;\n            let maybe_overridden = circuit\n                .bytes_mux(&condition, &prev_loc, &evaluator_loc_share)\n                .context(\"construct maybe_overridden\")?;\n            let r = circuit.bytes_xor(&r_gb, &r_ev).context(\"construct r\")?;\n            let new_value = circuit\n                .bytes_xor(&maybe_overridden, &r)\n                .context(\"construct new_value\")?;\n            output_builder\n                .process_next(circuit, &new_value)\n                .context(\"not processed by output_builder\")?;\n        }\n    }\n    output_builder.finish()\n"]], "pred": {"ppl": 2.458189010620117, "ppl_lower": 2.7039239406585693, "ppl/lowercase_ppl": -1.105933385417631, "ppl/zlib": 0.0008940605410437966, "Min_5.0% Prob": 7.854126378601673, "Min_10.0% Prob": 6.030507994633095, "Min_20.0% Prob": 4.011013245465708, "Min_30.0% Prob": 2.9100055272867476, "Min_40.0% Prob": 2.232800489514702, "Min_50.0% Prob": 1.7972629841876357, "Min_60.0% Prob": 1.5002344930787581}}
{"hexsha": "f247b81871ac7fc8b3cd28ed6adc77546b140f9e", "ext": "rs", "lang": "Rust", "content": "pub fn relationship_map<G, T>(graph: &G, node_subset: &mut NodeSubset, mapper: &T)\nwhere\n    G: Graph + Sync + ?Sized,\n    T: RelationshipMapper + Sync + ?Sized,\n{\n    let subset_size = node_subset.subset_count();\n\n    let degrees = if node_subset.is_dense() {\n        par_vec(node_subset.node_count(), |node_id| {\n            if node_subset.contains(node_id) {\n                graph.out_degree(node_id)\n            } else {\n                0\n            }\n        })\n    } else {\n        par_vec(subset_size, |i| {\n            let node_id = node_subset.node(i);\n            graph.out_degree(node_id)\n        })\n    };\n\n    let out_degrees = degrees.par_iter().sum::<usize>();\n\n    if out_degrees > graph.threshold() {\n        node_subset.to_dense();\n        relationship_map_dense(graph, node_subset, mapper)\n    } else {\n        relationship_map_sparse(graph, node_subset, degrees, mapper)\n    }\n}", "item_id": 3, "repo": "knutwalker/ligrust", "file": "src/ligra.rs", "last_update_at": "2021-02-03T07:56:37+00:00", "question_id": "f247b81871ac7fc8b3cd28ed6adc77546b140f9e_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn relationship_map<G, T>(graph: &G, node_subset: &mut NodeSubset, mapper: &T)\nwhere\n    G: Graph + Sync + ?Sized,\n    T: RelationshipMapper + Sync + ?Sized,\n{\n    let subset_size = node_subset.subset_count();\n    let degrees = if node_subset.is_dense() {\n        par_vec(node_subset.node_count(), |node_id| {\n            if node_subset.contains(node_id) {\n                graph.out_degree(node_id)\n            } else {\n                0\n            }\n        })\n    } else {\n        par_vec(subset_size, |i| {\n            let node_id = node_subset.node(i);\n            graph.out_degree(node_id)\n        })\n    };\n    let out_degrees = degrees.par_iter().sum::<usize>();\n    if out_degrees > graph.threshold() {\n        node_subset.to_dense();\n        relationship_map_dense(graph, node_subset, mapper)\n    } else {\n        relationship_map_sparse(graph, node_subset, degrees, mapper)\n    }\n"]], "pred": {"ppl": 2.237433910369873, "ppl_lower": 2.5572023391723633, "ppl/lowercase_ppl": -1.1658751716474807, "ppl/zlib": 0.002389702176456316, "Min_5.0% Prob": 7.298699982961019, "Min_10.0% Prob": 5.290314459800721, "Min_20.0% Prob": 3.5051194820247713, "Min_30.0% Prob": 2.5694837521599685, "Min_40.0% Prob": 1.9980020048554803, "Min_50.0% Prob": 1.6091321690215006, "Min_60.0% Prob": 1.3421691899066386}}
{"hexsha": "665b453d1cdccb60e9103b94359f09cf45078b78", "ext": "rs", "lang": "Rust", "content": "fn literal() {\n        let tpl = String::from(\"Simple template string\");\n        let tpl = parse(tpl).unwrap();\n        let rendered = render(&tpl, &HashMap::new(), &HashMap::new()).unwrap();\n        assert_eq!(rendered, tpl.tpl_str);\n    }", "item_id": 2, "repo": "Julian-Alberts/i3_notify_bar", "file": "mini_template/src/renderer.rs", "last_update_at": "2021-02-07T23:31:41+00:00", "question_id": "665b453d1cdccb60e9103b94359f09cf45078b78_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn literal() {\n        let tpl = String::from(\"Simple template string\");\n        let tpl = parse(tpl).unwrap();\n        let rendered = render(&tpl, &HashMap::new(), &HashMap::new()).unwrap();\n        assert_eq!(rendered, tpl.tpl_str);\n"]], "pred": {"ppl": 4.15625, "ppl_lower": 4.830751895904541, "ppl/lowercase_ppl": -1.1055647241462296, "ppl/zlib": 0.009691246431442362, "Min_5.0% Prob": 10.125800768534342, "Min_10.0% Prob": 7.963124888283866, "Min_20.0% Prob": 5.691684450422015, "Min_30.0% Prob": 4.311567295165289, "Min_40.0% Prob": 3.3725110682947883, "Min_50.0% Prob": 2.8054986513323255, "Min_60.0% Prob": 2.3916673164728075}}
{"hexsha": "a13d280ea3f136730edd34ac4eda6f2718fabe94", "ext": "rs", "lang": "Rust", "content": "fn spawn_rayto_point(&self, p2: &Point3f) -> Ray {\n        let o = offset_ray_origin(&self.p(), &self.p_error(), &self.n(), &(*p2 - self.p()));\n        let d = *p2 - self.p();\n\n        Ray::new(&o, &d, 1.0 - SHADOW_EPSILON, self.time(), self.get_medium_vec(&d), None)\n    }", "item_id": 0, "repo": "alexmeli100/pbrt-rust", "file": "src/core/interaction.rs", "last_update_at": "2021-05-22T22:00:18+00:00", "question_id": "a13d280ea3f136730edd34ac4eda6f2718fabe94_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn spawn_rayto_point(&self, p2: &Point3f) -> Ray {\n        let o = offset_ray_origin(&self.p(), &self.p_error(), &self.n(), &(*p2 - self.p()));\n        let d = *p2 - self.p();\n        Ray::new(&o, &d, 1.0 - SHADOW_EPSILON, self.time(), self.get_medium_vec(&d), None)\n"]], "pred": {"ppl": 4.564393520355225, "ppl_lower": 6.5475850105285645, "ppl/lowercase_ppl": -1.2376434432968215, "ppl/zlib": 0.007990977110381277, "Min_5.0% Prob": 10.191183471679688, "Min_10.0% Prob": 8.055881196802313, "Min_20.0% Prob": 5.759611015734465, "Min_30.0% Prob": 4.45546573751113, "Min_40.0% Prob": 3.5333653584770532, "Min_50.0% Prob": 2.9600689139282492, "Min_60.0% Prob": 2.5051839893710786}}
{"hexsha": "b557cd7190e4e6ed1950b802a5c17f2b276185c1", "ext": "rs", "lang": "Rust", "content": "fn extract_ir_lengths(ir: &[bool], n_taps: usize, expected: Option<&[usize]>)\n    -> Result<Vec<usize>>\n{\n    // Find all `10` patterns which indicate potential IR start positions.\n    let starts = ir.windows(2)\n                   .enumerate()\n                   .filter(|(_, w)| w[0] && !w[1])\n                   .map(|(i, _)| i)\n                   .collect::<Vec<usize>>();\n    log::trace!(\"Possible IR start positions: {:?}\", starts);\n\n    if n_taps == 0 {\n        log::error!(\"Cannot scan IR without at least one TAP\");\n        Err(Error::InvalidIR)\n    } else if n_taps > starts.len() {\n        // We must have at least as many `10` patterns as TAPs.\n        log::error!(\"Fewer IRs detected than TAPs\");\n        Err(Error::InvalidIR)\n    } else if starts[0] != 0 {\n        // The chain must begin with a possible start location.\n        log::error!(\"IR chain does not begin with a valid start pattern\");\n        Err(Error::InvalidIR)\n    } else if let Some(expected) = expected {\n        // If expected lengths are available, verify and return them.\n        if expected.len() != n_taps {\n            log::error!(\"Number of provided IR lengths ({}) does not match \\\n                         number of detected TAPs ({})\", expected.len(), n_taps);\n            Err(Error::InvalidIR)\n        } else if expected.iter().sum::<usize>() != ir.len() {\n            log::error!(\"Sum of provided IR lengths ({}) does not match \\\n                         length of IR scan ({} bits)\",\n                         expected.iter().sum::<usize>(), ir.len());\n            Err(Error::InvalidIR)\n        } else {\n            let exp_starts = expected.iter()\n                                     .scan(0, |a, &x| { let b = *a; *a += x; Some(b) })\n                                     .collect::<Vec<usize>>();\n            log::trace!(\"Provided IR start positions: {:?}\", exp_starts);\n            let unsupported = exp_starts.iter().filter(|s| !starts.contains(s)).count();\n            if unsupported > 0 {\n                log::error!(\"Provided IR lengths imply an IR start position \\\n                             which is not supported by the IR scan\");\n                Err(Error::InvalidIR)\n            } else {\n                log::debug!(\"Verified provided IR lengths against IR scan\");\n                Ok(starts_to_lens(&exp_starts, ir.len()))\n            }\n        }\n    } else if n_taps == 1 {\n        // If there's only one TAP, this is easy.\n        log::info!(\"Only one TAP detected, IR length {}\", ir.len());\n        Ok(vec![ir.len()])\n    } else if n_taps == starts.len() {\n        // If the number of possible starts matches the number of TAPs,\n        // we can unambiguously find all lengths.\n        let irlens = starts_to_lens(&starts, ir.len());\n        log::info!(\"IR lengths are unambiguous: {:?}\", irlens);\n        Ok(irlens)\n    } else {\n        log::error!(\"IR lengths are ambiguous and must be specified with --ir-lengths.\");\n        Err(Error::InvalidIR)\n    }\n}", "item_id": 2, "repo": "ikle/rust-jtagdap", "file": "src/jtag.rs", "last_update_at": "2021-11-14T17:05:39+00:00", "question_id": "b557cd7190e4e6ed1950b802a5c17f2b276185c1_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn extract_ir_lengths(ir: &[bool], n_taps: usize, expected: Option<&[usize]>)\n    -> Result<Vec<usize>>\n{\n    // Find all `10` patterns which indicate potential IR start positions.\n    let starts = ir.windows(2)\n                   .enumerate()\n                   .filter(|(_, w)| w[0] && !w[1])\n                   .map(|(i, _)| i)\n                   .collect::<Vec<usize>>();\n    log::trace!(\"Possible IR start positions: {:?}\", starts);\n    if n_taps == 0 {\n        log::error!(\"Cannot scan IR without at least one TAP\");\n        Err(Error::InvalidIR)\n    } else if n_taps > starts.len() {\n        // We must have at least as many `10` patterns as TAPs.\n        log::error!(\"Fewer IRs detected than TAPs\");\n        Err(Error::InvalidIR)\n    } else if starts[0] != 0 {\n        // The chain must begin with a possible start location.\n        log::error!(\"IR chain does not begin with a valid start pattern\");\n        Err(Error::InvalidIR)\n    } else if let Some(expected) = expected {\n        // If expected lengths are available, verify and return them.\n        if expected.len() != n_taps {\n            log::error!(\"Number of provided IR lengths ({}) does not match \\\n                         number of detected TAPs ({})\", expected.len(), n_taps);\n            Err(Error::InvalidIR)\n        } else if expected.iter().sum::<usize>() != ir.len() {\n            log::error!(\"Sum of provided IR lengths ({}) does not match \\\n                         length of IR scan ({} bits)\",\n                         expected.iter().sum::<usize>(), ir.len());\n            Err(Error::InvalidIR)\n        } else {\n            let exp_starts = expected.iter()\n                                     .scan(0, |a, &x| { let b = *a; *a += x; Some(b) })\n                                     .collect::<Vec<usize>>();\n            log::trace!(\"Provided IR start positions: {:?}\", exp_starts);\n            let unsupported = exp_starts.iter().filter(|s| !starts.contains(s)).count();\n            if unsupported > 0 {\n                log::error!(\"Provided IR lengths imply an IR start position \\\n                             which is not supported by the IR scan\");\n                Err(Error::InvalidIR)\n            } else {\n                log::debug!(\"Verified provided IR lengths against IR scan\");\n                Ok(starts_to_lens(&exp_starts, ir.len()))\n            }\n        }\n    } else if n_taps == 1 {\n        // If there's only one TAP, this is easy.\n        log::info!(\"Only one TAP detected, IR length {}\", ir.len());\n        Ok(vec![ir.len()])\n    } else if n_taps == starts.len() {\n        // If the number of possible starts matches the number of TAPs,\n        // we can unambiguously find all lengths.\n        let irlens = starts_to_lens(&starts, ir.len());\n        log::info!(\"IR lengths are unambiguous: {:?}\", irlens);\n        Ok(irlens)\n    } else {\n        log::error!(\"IR lengths are ambiguous and must be specified with --ir-lengths.\");\n        Err(Error::InvalidIR)\n    }\n"]], "pred": {"ppl": 2.1272950172424316, "ppl_lower": 2.253047227859497, "ppl/lowercase_ppl": -1.076084390713899, "ppl/zlib": 0.000756363955612501, "Min_5.0% Prob": 6.133063895361764, "Min_10.0% Prob": 4.716951390107472, "Min_20.0% Prob": 3.235746260200228, "Min_30.0% Prob": 2.3970003814800926, "Min_40.0% Prob": 1.8632518892295282, "Min_50.0% Prob": 1.5036942879735575, "Min_60.0% Prob": 1.2577106783740781}}
{"hexsha": "d19d24448c5c0236fa9d47abdc42259e81b4351e", "ext": "rs", "lang": "Rust", "content": "fn regex_rule_with_matching_file() {\n        let rule = RegexRule { rule: Regex::new(\"match\").unwrap() };\n        let file = PathBuf::from(\"./is/a/match.txt\");\n        let is_match = rule.file_matches_rule(&file, &dummy_map_file_context());\n        assert_eq!(is_match, true);\n    }", "item_id": 0, "repo": "mhspradlin/map", "file": "src/rule.rs", "last_update_at": "2021-07-23T15:38:53+00:00", "question_id": "d19d24448c5c0236fa9d47abdc42259e81b4351e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn regex_rule_with_matching_file() {\n        let rule = RegexRule { rule: Regex::new(\"match\").unwrap() };\n        let file = PathBuf::from(\"./is/a/match.txt\");\n        let is_match = rule.file_matches_rule(&file, &dummy_map_file_context());\n        assert_eq!(is_match, true);\n"]], "pred": {"ppl": 4.363021373748779, "ppl_lower": 6.12347936630249, "ppl/lowercase_ppl": -1.2300935153342065, "ppl/zlib": 0.008050080836036356, "Min_5.0% Prob": 8.814078569412231, "Min_10.0% Prob": 7.460738976796468, "Min_20.0% Prob": 5.659725387891133, "Min_30.0% Prob": 4.327239602804184, "Min_40.0% Prob": 3.5145063722455823, "Min_50.0% Prob": 2.8674683076270084, "Min_60.0% Prob": 2.443382980035884}}
{"hexsha": "bfd81c99c7cd09423ebe9148c404f5012d9be215", "ext": "rs", "lang": "Rust", "content": "pub fn type_generics_constrint() {\n    let source = r#\"\n        type Foo = number\n        type Bar<T extends Foo> = { a: T[] }\n    \"#;\n\n    let spec = TestSpec {\n        source,\n        exports: vec![],\n        imports: vec![],\n        scope: TestScope {\n            type_bindings: vec![\"Foo\", \"Bar\"],\n            inner: vec![\n                TestScope::default(),\n                TestScope {\n                    type_bindings: vec![\"T\"],\n                    type_references: vec![\"Foo\", \"T\"],\n                    ..Default::default()\n                },\n            ],\n            ..Default::default()\n        },\n    };\n\n    run_test(spec);\n}", "item_id": 6, "repo": "paavohuhtala/customs", "file": "src/tests/usages.rs", "last_update_at": "2021-11-21T09:52:33+00:00", "question_id": "bfd81c99c7cd09423ebe9148c404f5012d9be215_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn type_generics_constrint() {\n    let source = r#\"\n        type Foo = number\n        type Bar<T extends Foo> = { a: T[] }\n    \"#;\n    let spec = TestSpec {\n        source,\n        exports: vec![],\n        imports: vec![],\n        scope: TestScope {\n            type_bindings: vec![\"Foo\", \"Bar\"],\n            inner: vec![\n                TestScope::default(),\n                TestScope {\n                    type_bindings: vec![\"T\"],\n                    type_references: vec![\"Foo\", \"T\"],\n                    ..Default::default()\n                },\n            ],\n            ..Default::default()\n        },\n    };\n    run_test(spec);\n"]], "pred": {"ppl": 2.9476749897003174, "ppl_lower": 3.7318918704986572, "ppl/lowercase_ppl": -1.2182191856590323, "ppl/zlib": 0.0041577566173930675, "Min_5.0% Prob": 8.105075783199734, "Min_10.0% Prob": 6.292196498976813, "Min_20.0% Prob": 4.342566235197915, "Min_30.0% Prob": 3.3106105073734566, "Min_40.0% Prob": 2.6185649724470244, "Min_50.0% Prob": 2.1404118188553385, "Min_60.0% Prob": 1.7969434173363779}}
{"hexsha": "de95b5085e7a583b5227cf5bd274aadf138586dc", "ext": "rs", "lang": "Rust", "content": "pub fn __state11<\n        'input,\n        __TOKENS: Iterator<Item=Result<(usize, (usize, &'input str), usize),__ParseError<usize,(usize, &'input str),()>>>,\n    >(\n        input: &'input str,\n        __lookbehind: Option<usize>,\n        __tokens: &mut __TOKENS,\n        __sym0: &mut Option<&'input str>,\n        __sym1: &mut Option<i32>,\n        __sym2: &mut Option<&'input str>,\n    ) -> Result<(Option<usize>, Option<(usize, (usize, &'input str), usize)>, __Nonterminal<>), __ParseError<usize,(usize, &'input str),()>>\n    {\n        let mut __result: (Option<usize>, Option<(usize, (usize, &'input str), usize)>, __Nonterminal<>);\n        let __lookahead = match __tokens.next() {\n            Some(Ok(v)) => Some(v),\n            None => None,\n            Some(Err(e)) => return Err(e),\n        };\n        match __lookahead {\n            Some((_, (0, _), _)) => {\n                let __sym0 = __sym0.take().unwrap();\n                let __sym1 = __sym1.take().unwrap();\n                let __sym2 = __sym2.take().unwrap();\n                let __nt = super::__action2(input, __sym0, __sym1, __sym2);\n                return Ok((__lookbehind, __lookahead, __Nonterminal::Term(__nt)));\n            }\n            _ => {\n                return Err(__ParseError::UnrecognizedToken {\n                    token: __lookahead,\n                    expected: vec![],\n                });\n            }\n        }\n    }", "item_id": 9, "repo": "Marwes/lalrpop", "file": "doc/calculator/src/calculator2.rs", "last_update_at": "2021-06-04T08:36:40+00:00", "question_id": "de95b5085e7a583b5227cf5bd274aadf138586dc_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn __state11<\n        'input,\n        __TOKENS: Iterator<Item=Result<(usize, (usize, &'input str), usize),__ParseError<usize,(usize, &'input str),()>>>,\n    >(\n        input: &'input str,\n        __lookbehind: Option<usize>,\n        __tokens: &mut __TOKENS,\n        __sym0: &mut Option<&'input str>,\n        __sym1: &mut Option<i32>,\n        __sym2: &mut Option<&'input str>,\n    ) -> Result<(Option<usize>, Option<(usize, (usize, &'input str), usize)>, __Nonterminal<>), __ParseError<usize,(usize, &'input str),()>>\n    {\n        let mut __result: (Option<usize>, Option<(usize, (usize, &'input str), usize)>, __Nonterminal<>);\n        let __lookahead = match __tokens.next() {\n            Some(Ok(v)) => Some(v),\n            None => None,\n            Some(Err(e)) => return Err(e),\n        };\n        match __lookahead {\n            Some((_, (0, _), _)) => {\n                let __sym0 = __sym0.take().unwrap();\n                let __sym1 = __sym1.take().unwrap();\n                let __sym2 = __sym2.take().unwrap();\n                let __nt = super::__action2(input, __sym0, __sym1, __sym2);\n                return Ok((__lookbehind, __lookahead, __Nonterminal::Term(__nt)));\n            }\n            _ => {\n                return Err(__ParseError::UnrecognizedToken {\n                    token: __lookahead,\n                    expected: vec![],\n                });\n            }\n        }\n"]], "pred": {"ppl": 1.592042088508606, "ppl_lower": 2.070706844329834, "ppl/lowercase_ppl": -1.565295889311954, "ppl/zlib": 0.001015322106065791, "Min_5.0% Prob": 5.082489869811318, "Min_10.0% Prob": 3.645434488190545, "Min_20.0% Prob": 2.2204770049551033, "Min_30.0% Prob": 1.53325565333349, "Min_40.0% Prob": 1.160396491518356, "Min_50.0% Prob": 0.9303913244725445, "Min_60.0% Prob": 0.7757490689620714}}
{"hexsha": "529a550eb02314c93c29164bfd5b27c3e7a4dc64", "ext": "rs", "lang": "Rust", "content": "fn test_get_devnode() {\n        let _ = env_logger::builder().is_test(true).try_init();\n\n        let mut mock_query = MockEnvVarQuery::new();\n        const MOCK_DEVICE_PATH: &str = \"/dev/video0\";\n\n        mock_query\n            .expect_get_env_var()\n            .times(1)\n            .withf(move |name: &str| name == UDEV_DEVNODE_LABEL_ID)\n            .returning(move |_| Ok(MOCK_DEVICE_PATH.to_string()));\n\n        assert_eq!(MOCK_DEVICE_PATH.to_string(), get_video_devnode(&mock_query));\n    }", "item_id": 2, "repo": "HernanGatta/akri-1", "file": "samples/brokers/udev-video-broker/src/main.rs", "last_update_at": "2021-03-11T07:45:24+00:00", "question_id": "529a550eb02314c93c29164bfd5b27c3e7a4dc64_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_get_devnode() {\n        let _ = env_logger::builder().is_test(true).try_init();\n        let mut mock_query = MockEnvVarQuery::new();\n        const MOCK_DEVICE_PATH: &str = \"/dev/video0\";\n        mock_query\n            .expect_get_env_var()\n            .times(1)\n            .withf(move |name: &str| name == UDEV_DEVNODE_LABEL_ID)\n            .returning(move |_| Ok(MOCK_DEVICE_PATH.to_string()));\n        assert_eq!(MOCK_DEVICE_PATH.to_string(), get_video_devnode(&mock_query));\n"]], "pred": {"ppl": 2.5404574871063232, "ppl_lower": 3.4260149002075195, "ppl/lowercase_ppl": -1.320754479202164, "ppl/zlib": 0.003306185027822786, "Min_5.0% Prob": 7.720524549484253, "Min_10.0% Prob": 6.150384355993832, "Min_20.0% Prob": 3.9170444999422345, "Min_30.0% Prob": 2.9389613419771194, "Min_40.0% Prob": 2.2837152604545867, "Min_50.0% Prob": 1.8514720324257559, "Min_60.0% Prob": 1.5604329264234928}}
{"hexsha": "ad677d67fa83715cad9a52ff82aa39df32bfa494", "ext": "rs", "lang": "Rust", "content": "fn group_by_get_indices(\n        &self,\n        block: &DataBlock,\n        column_names: &[String],\n    ) -> Result<GroupIndices<Self::HashKey>> {\n        // Table for <group_key, (indices, keys) >\n        let mut group_indices = GroupIndices::<Self::HashKey>::default();\n        // 1. Get group by columns.\n        let mut group_columns = Vec::with_capacity(column_names.len());\n        {\n            for col in column_names {\n                group_columns.push(block.try_column_by_name(col)?);\n            }\n        }\n\n        // 2. Build serialized keys\n        let group_keys = self.build_keys(&group_columns, block.num_rows())?;\n        // 2. Make group with indices.\n        {\n            for (row, group_key) in group_keys.iter().enumerate().take(block.num_rows()) {\n                match group_indices.get_mut(group_key) {\n                    None => {\n                        let mut group_values = Vec::with_capacity(group_columns.len());\n                        for col in &group_columns {\n                            group_values.push(col.try_get(row)?);\n                        }\n                        group_indices.insert(group_key.clone(), (vec![row as u32], group_values));\n                    }\n                    Some((v, _)) => {\n                        v.push(row as u32);\n                    }\n                }\n            }\n        }\n\n        Ok(group_indices)\n    }", "item_id": 0, "repo": "willie-lin/databend", "file": "common/datablocks/src/kernels/data_block_group_by_hash.rs", "last_update_at": "2021-11-26T06:09:36+00:00", "question_id": "ad677d67fa83715cad9a52ff82aa39df32bfa494_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn group_by_get_indices(\n        &self,\n        block: &DataBlock,\n        column_names: &[String],\n    ) -> Result<GroupIndices<Self::HashKey>> {\n        // Table for <group_key, (indices, keys) >\n        let mut group_indices = GroupIndices::<Self::HashKey>::default();\n        // 1. Get group by columns.\n        let mut group_columns = Vec::with_capacity(column_names.len());\n        {\n            for col in column_names {\n                group_columns.push(block.try_column_by_name(col)?);\n            }\n        }\n        // 2. Build serialized keys\n        let group_keys = self.build_keys(&group_columns, block.num_rows())?;\n        // 2. Make group with indices.\n        {\n            for (row, group_key) in group_keys.iter().enumerate().take(block.num_rows()) {\n                match group_indices.get_mut(group_key) {\n                    None => {\n                        let mut group_values = Vec::with_capacity(group_columns.len());\n                        for col in &group_columns {\n                            group_values.push(col.try_get(row)?);\n                        }\n                        group_indices.insert(group_key.clone(), (vec![row as u32], group_values));\n                    }\n                    Some((v, _)) => {\n                        v.push(row as u32);\n                    }\n                }\n            }\n        }\n        Ok(group_indices)\n"]], "pred": {"ppl": 2.012824058532715, "ppl_lower": 2.3755133152008057, "ppl/lowercase_ppl": -1.2368343554151824, "ppl/zlib": 0.001404696265504395, "Min_5.0% Prob": 6.6809414562426115, "Min_10.0% Prob": 4.740151148576003, "Min_20.0% Prob": 3.1236844673941406, "Min_30.0% Prob": 2.2505774816044237, "Min_40.0% Prob": 1.7388134294578546, "Min_50.0% Prob": 1.3990718181047477, "Min_60.0% Prob": 1.166306212861404}}
{"hexsha": "3e4ede6600567cafb4db41b978141eab404570a5", "ext": "rs", "lang": "Rust", "content": "fn meta() -> MetaOrAttrs {\n        let mut meta = MetaOrAttrs::new();\n        meta.insert(\"foo\".into(), 123.into());\n        meta.insert(\"bar\".into(), \"qwe\".into());\n        meta\n    }", "item_id": 0, "repo": "kotovalexarian/jsonapis.rs", "file": "src/builders/resource.rs", "last_update_at": "2021-09-10T17:33:21+00:00", "question_id": "3e4ede6600567cafb4db41b978141eab404570a5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn meta() -> MetaOrAttrs {\n        let mut meta = MetaOrAttrs::new();\n        meta.insert(\"foo\".into(), 123.into());\n        meta.insert(\"bar\".into(), \"qwe\".into());\n        meta\n"]], "pred": {"ppl": 3.282127618789673, "ppl_lower": 4.225628852844238, "ppl/lowercase_ppl": -1.2126023907253793, "ppl/zlib": 0.011427806503552561, "Min_5.0% Prob": 9.693168640136719, "Min_10.0% Prob": 6.791250745455424, "Min_20.0% Prob": 4.639970163504283, "Min_30.0% Prob": 3.5209596157073975, "Min_40.0% Prob": 2.859686180949211, "Min_50.0% Prob": 2.3718304107586543, "Min_60.0% Prob": 2.001687347268065}}
{"hexsha": "ade5775c9437e909b53da93284089648b0da1c52", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn peek_end(iter: &mut TokenStream) -> bool {\n    let idx = iter.idx;\n    let end = if consume_block(iter, Block::RParen)\n        || (consume_comma(iter) && consume_block(iter, Block::RParen))\n    {\n        true\n    } else {\n        false\n    };\n    iter.idx = idx;\n    end\n}", "item_id": 1, "repo": "Hosshii/rs9cc", "file": "src/ast/util.rs", "last_update_at": "2021-02-19T15:46:19+00:00", "question_id": "ade5775c9437e909b53da93284089648b0da1c52_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn peek_end(iter: &mut TokenStream) -> bool {\n    let idx = iter.idx;\n    let end = if consume_block(iter, Block::RParen)\n        || (consume_comma(iter) && consume_block(iter, Block::RParen))\n    {\n        true\n    } else {\n        false\n    };\n    iter.idx = idx;\n    end\n"]], "pred": {"ppl": 3.640048027038574, "ppl_lower": 4.048352241516113, "ppl/lowercase_ppl": -1.0822858557728636, "ppl/zlib": 0.0075999816223704265, "Min_5.0% Prob": 8.59319086074829, "Min_10.0% Prob": 7.1613694190979, "Min_20.0% Prob": 5.450423455238342, "Min_30.0% Prob": 4.107836580276489, "Min_40.0% Prob": 3.1644853891395943, "Min_50.0% Prob": 2.584914177363994, "Min_60.0% Prob": 2.1770653470617827}}
{"hexsha": "98be397a5e8ba4ec44074a32de20214fc0f05ab3", "ext": "rs", "lang": "Rust", "content": "async fn authenticate() {\n        let (mut tor, mock_state) = setup_test().await;\n\n        tor.authenticate(&Authentication::None).await.unwrap();\n        let mut req = mock_state.take_requests().await;\n        assert_eq!(req.len(), 1);\n        assert_eq!(req.remove(0), \"AUTHENTICATE\");\n\n        tor.authenticate(&Authentication::HashedPassword(\"ab\\\"cde\".to_string()))\n            .await\n            .unwrap();\n        let mut req = mock_state.take_requests().await;\n        assert_eq!(req.len(), 1);\n        assert_eq!(req.remove(0), \"AUTHENTICATE \\\"ab\\\\\\\"cde\\\"\");\n\n        tor.authenticate(&Authentication::Cookie(\"NOTACTUALLYHEXENCODED\".to_string()))\n            .await\n            .unwrap();\n        let mut req = mock_state.take_requests().await;\n        assert_eq!(req.len(), 1);\n        assert_eq!(req.remove(0), \"AUTHENTICATE NOTACTUALLYHEXENCODED\");\n    }", "item_id": 2, "repo": "lessless/tari", "file": "comms/src/tor/control_client/client.rs", "last_update_at": "2021-08-17T09:59:31+00:00", "question_id": "98be397a5e8ba4ec44074a32de20214fc0f05ab3_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn authenticate() {\n        let (mut tor, mock_state) = setup_test().await;\n        tor.authenticate(&Authentication::None).await.unwrap();\n        let mut req = mock_state.take_requests().await;\n        assert_eq!(req.len(), 1);\n        assert_eq!(req.remove(0), \"AUTHENTICATE\");\n        tor.authenticate(&Authentication::HashedPassword(\"ab\\\"cde\".to_string()))\n            .await\n            .unwrap();\n        let mut req = mock_state.take_requests().await;\n        assert_eq!(req.len(), 1);\n        assert_eq!(req.remove(0), \"AUTHENTICATE \\\"ab\\\\\\\"cde\\\"\");\n        tor.authenticate(&Authentication::Cookie(\"NOTACTUALLYHEXENCODED\".to_string()))\n            .await\n            .unwrap();\n        let mut req = mock_state.take_requests().await;\n        assert_eq!(req.len(), 1);\n        assert_eq!(req.remove(0), \"AUTHENTICATE NOTACTUALLYHEXENCODED\");\n"]], "pred": {"ppl": 2.012265682220459, "ppl_lower": 2.268002986907959, "ppl/lowercase_ppl": -1.1710925684252425, "ppl/zlib": 0.002589856638285706, "Min_5.0% Prob": 7.569383401137132, "Min_10.0% Prob": 5.250525792439778, "Min_20.0% Prob": 3.2752978669272528, "Min_30.0% Prob": 2.3101407718143347, "Min_40.0% Prob": 1.754145109784548, "Min_50.0% Prob": 1.3972853090655168, "Min_60.0% Prob": 1.1665881031787058}}
{"hexsha": "9005f5b6d8e80f147425223a20183d539e4077b4", "ext": "rs", "lang": "Rust", "content": "unsafe fn find_key_partition_sse2(skiplist: &[u32; SKIP_LEN], key: &MortonKey) -> usize {\n    let key = key.0 as i32;\n    let keys4 = _mm_set_epi32(key, key, key, key);\n\n    let [s0, s1, s2, s3, s4, s5, s6, s7]: [i32; SKIP_LEN] = mem::transmute(*skiplist);\n    let skiplist_a: __m128i = _mm_set_epi32(s0, s1, s2, s3);\n    let skiplist_b: __m128i = _mm_set_epi32(s4, s5, s6, s7);\n\n    // set every 32 bits to 0xFFFF if key < skip else sets it to 0x0000\n    let results_a: __m128i = _mm_cmpgt_epi32(keys4, skiplist_a);\n    let results_b: __m128i = _mm_cmpgt_epi32(keys4, skiplist_b);\n\n    // create a mask from the most significant bit of each 8bit element\n    let mask_a: i32 = _mm_movemask_epi8(results_a);\n    let mask_b: i32 = _mm_movemask_epi8(results_b);\n\n    // count the number of bits set to 1\n    let index: i32 = _popcnt32(mask_a) + _popcnt32(mask_b);\n    // because the mask was created from 8 bit wide items every key in skip list is counted\n    // 4 times.\n    index as usize / 4\n}", "item_id": 0, "repo": "snorrwe/morton-table", "file": "morton-table/src/morton_table/mod.rs", "last_update_at": "2021-08-15T14:16:37+00:00", "question_id": "9005f5b6d8e80f147425223a20183d539e4077b4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe fn find_key_partition_sse2(skiplist: &[u32; SKIP_LEN], key: &MortonKey) -> usize {\n    let key = key.0 as i32;\n    let keys4 = _mm_set_epi32(key, key, key, key);\n    let [s0, s1, s2, s3, s4, s5, s6, s7]: [i32; SKIP_LEN] = mem::transmute(*skiplist);\n    let skiplist_a: __m128i = _mm_set_epi32(s0, s1, s2, s3);\n    let skiplist_b: __m128i = _mm_set_epi32(s4, s5, s6, s7);\n    // set every 32 bits to 0xFFFF if key < skip else sets it to 0x0000\n    let results_a: __m128i = _mm_cmpgt_epi32(keys4, skiplist_a);\n    let results_b: __m128i = _mm_cmpgt_epi32(keys4, skiplist_b);\n    // create a mask from the most significant bit of each 8bit element\n    let mask_a: i32 = _mm_movemask_epi8(results_a);\n    let mask_b: i32 = _mm_movemask_epi8(results_b);\n    // count the number of bits set to 1\n    let index: i32 = _popcnt32(mask_a) + _popcnt32(mask_b);\n    // because the mask was created from 8 bit wide items every key in skip list is counted\n    // 4 times.\n    index as usize / 4\n"]], "pred": {"ppl": 2.358085870742798, "ppl_lower": 2.417625665664673, "ppl/lowercase_ppl": -1.0290676739407199, "ppl/zlib": 0.00187713395672153, "Min_5.0% Prob": 7.428099177100441, "Min_10.0% Prob": 5.704880481296115, "Min_20.0% Prob": 3.77352333996031, "Min_30.0% Prob": 2.7609818584389156, "Min_40.0% Prob": 2.12640857309597, "Min_50.0% Prob": 1.715912017501495, "Min_60.0% Prob": 1.4332660092418925}}
{"hexsha": "3e370f719b850b7f0224ce4b7075057418a987d3", "ext": "rs", "lang": "Rust", "content": "fn cc_compile(target_env: Environment) {\n    let root = env::current_dir().unwrap().join(\"PhysX/physx\");\n\n    let ccenv = target_env;\n\n    let mut ctx = Context {\n        builder: cc::Build::new(),\n        root,\n        env: ccenv,\n        includes: Vec::with_capacity(1000),\n    };\n\n    add_common(&mut ctx);\n\n    // Add the sources and includes for each major physx component\n    fastxml(&mut ctx);\n    task(&mut ctx);\n    foundation(&mut ctx);\n    lowlevel(&mut ctx);\n    lowlevelaabb(&mut ctx);\n    lowleveldynamics(&mut ctx);\n    vehicle(&mut ctx);\n    extensions(&mut ctx);\n    physxcharacterkinematic(&mut ctx);\n    common(&mut ctx);\n    geomutils(&mut ctx);\n    cooking(&mut ctx);\n    pvd(&mut ctx);\n    physx(&mut ctx);\n    scenequery(&mut ctx);\n    simulationcontroller(&mut ctx);\n\n    ctx.includes.push(ctx.root.join(\"source/pvd/include\"));\n\n    // Strip out duplicate include paths, C++ already has it hard enough as it is\n    ctx.includes.sort();\n    ctx.includes.dedup();\n\n    for dir in ctx.includes {\n        ctx.builder.include(dir);\n    }\n\n    ctx.builder.compile(\"physx\");\n}", "item_id": 8, "repo": "Hentropy/physx-rs", "file": "physx-sys/cc.rs", "last_update_at": "2021-12-02T12:02:38+00:00", "question_id": "3e370f719b850b7f0224ce4b7075057418a987d3_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn cc_compile(target_env: Environment) {\n    let root = env::current_dir().unwrap().join(\"PhysX/physx\");\n    let ccenv = target_env;\n    let mut ctx = Context {\n        builder: cc::Build::new(),\n        root,\n        env: ccenv,\n        includes: Vec::with_capacity(1000),\n    };\n    add_common(&mut ctx);\n    // Add the sources and includes for each major physx component\n    fastxml(&mut ctx);\n    task(&mut ctx);\n    foundation(&mut ctx);\n    lowlevel(&mut ctx);\n    lowlevelaabb(&mut ctx);\n    lowleveldynamics(&mut ctx);\n    vehicle(&mut ctx);\n    extensions(&mut ctx);\n    physxcharacterkinematic(&mut ctx);\n    common(&mut ctx);\n    geomutils(&mut ctx);\n    cooking(&mut ctx);\n    pvd(&mut ctx);\n    physx(&mut ctx);\n    scenequery(&mut ctx);\n    simulationcontroller(&mut ctx);\n    ctx.includes.push(ctx.root.join(\"source/pvd/include\"));\n    // Strip out duplicate include paths, C++ already has it hard enough as it is\n    ctx.includes.sort();\n    ctx.includes.dedup();\n    for dir in ctx.includes {\n        ctx.builder.include(dir);\n    }\n    ctx.builder.compile(\"physx\");\n"]], "pred": {"ppl": 3.09098744392395, "ppl_lower": 3.467954158782959, "ppl/lowercase_ppl": -1.1019718191569414, "ppl/zlib": 0.0023364194637708175, "Min_5.0% Prob": 8.038001537322998, "Min_10.0% Prob": 6.372772574424744, "Min_20.0% Prob": 4.594009558359782, "Min_30.0% Prob": 3.5482957426784107, "Min_40.0% Prob": 2.786905948234641, "Min_50.0% Prob": 2.246655360510239, "Min_60.0% Prob": 1.884279431226317}}
{"hexsha": "be54b322e89d117a290068007a7da1bcbcfb74aa", "ext": "rs", "lang": "Rust", "content": "pub fn perpendicular_bisector(p1: &Multivector, p2: &Multivector) -> Multivector {\n    let p1 = p1.normalized();\n    let p2 = p2.normalized();\n\n    let midpoint = midpoint(&p1, &p2);\n    let line_between = p1.join(&p2);\n\n    orthogonal(&midpoint, &line_between)\n}", "item_id": 5, "repo": "mwalczyk/pga-axioms", "file": "src/geometry.rs", "last_update_at": "2021-03-17T16:52:28+00:00", "question_id": "be54b322e89d117a290068007a7da1bcbcfb74aa_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn perpendicular_bisector(p1: &Multivector, p2: &Multivector) -> Multivector {\n    let p1 = p1.normalized();\n    let p2 = p2.normalized();\n    let midpoint = midpoint(&p1, &p2);\n    let line_between = p1.join(&p2);\n    orthogonal(&midpoint, &line_between)\n"]], "pred": {"ppl": 3.0788655281066895, "ppl_lower": 3.144671678543091, "ppl/lowercase_ppl": -1.018805820413095, "ppl/zlib": 0.007072711912598605, "Min_5.0% Prob": 9.682684898376465, "Min_10.0% Prob": 7.5780974388122555, "Min_20.0% Prob": 4.8428640127182, "Min_30.0% Prob": 3.5335136791070303, "Min_40.0% Prob": 2.7870552383363245, "Min_50.0% Prob": 2.2561322511732578, "Min_60.0% Prob": 1.8890472631901503}}
{"hexsha": "e5a76389b61719df43177b3dded0b880a2eac13c", "ext": "rs", "lang": "Rust", "content": "pub fn direct_step_single(\n    in_slice: &[f32],\n    out_slice: &mut [f32],\n    out_stride: usize,\n    out_sample: usize,\n    n: usize,\n    sinc_table: &[f32],\n) {\n    #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n    {\n        if is_x86_feature_detected!(\"avx\") {\n            unsafe {\n                avx_wrapper::direct_step_single(\n                    in_slice, out_slice, out_stride, out_sample, n, sinc_table,\n                );\n            }\n            return;\n        }\n\n        if is_x86_feature_detected!(\"sse3\") {\n            unsafe {\n                sse3_wrapper::direct_step_single(\n                    in_slice, out_slice, out_stride, out_sample, n, sinc_table,\n                );\n            }\n            return;\n        }\n    }\n\n    super::native::direct_step_single(\n        in_slice, out_slice, out_stride, out_sample, n, sinc_table,\n    );\n}", "item_id": 2, "repo": "rust-av/speexdsp-rs", "file": "resampler/src/speex/dynnative/mod.rs", "last_update_at": "2021-05-09T14:26:06+00:00", "question_id": "e5a76389b61719df43177b3dded0b880a2eac13c_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn direct_step_single(\n    in_slice: &[f32],\n    out_slice: &mut [f32],\n    out_stride: usize,\n    out_sample: usize,\n    n: usize,\n    sinc_table: &[f32],\n) {\n    #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n    {\n        if is_x86_feature_detected!(\"avx\") {\n            unsafe {\n                avx_wrapper::direct_step_single(\n                    in_slice, out_slice, out_stride, out_sample, n, sinc_table,\n                );\n            }\n            return;\n        }\n        if is_x86_feature_detected!(\"sse3\") {\n            unsafe {\n                sse3_wrapper::direct_step_single(\n                    in_slice, out_slice, out_stride, out_sample, n, sinc_table,\n                );\n            }\n            return;\n        }\n    }\n    super::native::direct_step_single(\n        in_slice, out_slice, out_stride, out_sample, n, sinc_table,\n    );\n"]], "pred": {"ppl": 1.6000422239303589, "ppl_lower": 1.6000422239303589, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0018218217785038802, "Min_5.0% Prob": 6.278005441029866, "Min_10.0% Prob": 4.195467861493428, "Min_20.0% Prob": 2.3124522728021026, "Min_30.0% Prob": 1.5599638874764028, "Min_40.0% Prob": 1.1809348773867747, "Min_50.0% Prob": 0.9427386795344087, "Min_60.0% Prob": 0.7841446873274475}}
{"hexsha": "5d5d00ddc0c10459b3e34a3e06ce068937083bba", "ext": "rs", "lang": "Rust", "content": "pub fn get_opts() -> Options {\n    let mut opts = Options::new();\n    opts.optflag(\"h\", \"help\", \"print this help text\");\n    opts.optflag(\"v\", \"verbose\", \"print debug info on each instruction\");\n    opts\n}", "item_id": 0, "repo": "HactarCE/Metatape-Rust", "file": "src/cli.rs", "last_update_at": "2021-02-11T07:25:50+00:00", "question_id": "5d5d00ddc0c10459b3e34a3e06ce068937083bba_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_opts() -> Options {\n    let mut opts = Options::new();\n    opts.optflag(\"h\", \"help\", \"print this help text\");\n    opts.optflag(\"v\", \"verbose\", \"print debug info on each instruction\");\n    opts\n"]], "pred": {"ppl": 3.4523565769195557, "ppl_lower": 3.959657907485962, "ppl/lowercase_ppl": -1.1106491177254083, "ppl/zlib": 0.008725753969252164, "Min_5.0% Prob": 9.42825730641683, "Min_10.0% Prob": 8.167252699534098, "Min_20.0% Prob": 5.5223197638988495, "Min_30.0% Prob": 4.0356597900390625, "Min_40.0% Prob": 3.0365849244594574, "Min_50.0% Prob": 2.484902910167171, "Min_60.0% Prob": 2.0959149633307717}}
{"hexsha": "38f004ecd3af0fa6170d6f741acf46d21ffa31fe", "ext": "rs", "lang": "Rust", "content": "fn main () -> ! {\n\n    let dp = pac::Peripherals::take().unwrap();\n\n    let mut flash = dp.FLASH.constrain();\n    let rcc = dp.RCC.constrain();\n    let _clocks = rcc\n        .cfgr\n        .use_hse(8.mhz())       // esternal (quartz) oscillator\n        .sysclk(72.mhz())      \n        .freeze(&mut flash.acr);\n\n    let mut cp = Peripherals::take().unwrap();\n    cp.DWT.enable_cycle_counter();\n    let mut m = Measure::new();\n    m.measure();\n\n    loop {}\n}", "item_id": 0, "repo": "Simsys/fchashmap", "file": "benches/cm4_performance/src/main.rs", "last_update_at": "2021-08-02T02:03:06+00:00", "question_id": "38f004ecd3af0fa6170d6f741acf46d21ffa31fe_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main () -> ! {\n    let dp = pac::Peripherals::take().unwrap();\n    let mut flash = dp.FLASH.constrain();\n    let rcc = dp.RCC.constrain();\n    let _clocks = rcc\n        .cfgr\n        .use_hse(8.mhz())       // esternal (quartz) oscillator\n        .sysclk(72.mhz())      \n        .freeze(&mut flash.acr);\n    let mut cp = Peripherals::take().unwrap();\n    cp.DWT.enable_cycle_counter();\n    let mut m = Measure::new();\n    m.measure();\n    loop {}\n"]], "pred": {"ppl": 2.6937332153320312, "ppl_lower": 3.5638277530670166, "ppl/lowercase_ppl": -1.2824696874997241, "ppl/zlib": 0.0038408063716406237, "Min_5.0% Prob": 8.371082544326782, "Min_10.0% Prob": 6.6616097057566925, "Min_20.0% Prob": 4.530773464371176, "Min_30.0% Prob": 3.2566542374152765, "Min_40.0% Prob": 2.4638365028776983, "Min_50.0% Prob": 1.987489416372291, "Min_60.0% Prob": 1.6623368618141823}}
{"hexsha": "d2378e1a488efdc112b6ce611b92832d6e0f7f7e", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout___wasi_prestat_t() {\n        assert_eq!(\n            ::std::mem::size_of::<__wasi_prestat_t>(),\n            16usize,\n            concat!(\"Size of: \", stringify!(__wasi_prestat_t))\n        );\n        assert_eq!(\n            ::std::mem::align_of::<__wasi_prestat_t>(),\n            8usize,\n            concat!(\"Alignment of \", stringify!(__wasi_prestat_t))\n        );\n        assert_eq!(\n            unsafe { &(*(::std::ptr::null::<__wasi_prestat_t>())).pr_type as *const _ as usize },\n            0usize,\n            concat!(\n                \"Offset of field: \",\n                stringify!(__wasi_prestat_t),\n                \"::\",\n                stringify!(pr_type)\n            )\n        );\n        assert_eq!(\n            unsafe { &(*(::std::ptr::null::<__wasi_prestat_t>())).u as *const _ as usize },\n            8usize,\n            concat!(\n                \"Offset of field: \",\n                stringify!(__wasi_prestat_t),\n                \"::\",\n                stringify!(u)\n            )\n        );\n    }", "item_id": 0, "repo": "svsintel/wasmtime", "file": "crates/wasi-common/src/host.rs", "last_update_at": "2021-11-20T13:45:20+00:00", "question_id": "d2378e1a488efdc112b6ce611b92832d6e0f7f7e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout___wasi_prestat_t() {\n        assert_eq!(\n            ::std::mem::size_of::<__wasi_prestat_t>(),\n            16usize,\n            concat!(\"Size of: \", stringify!(__wasi_prestat_t))\n        );\n        assert_eq!(\n            ::std::mem::align_of::<__wasi_prestat_t>(),\n            8usize,\n            concat!(\"Alignment of \", stringify!(__wasi_prestat_t))\n        );\n        assert_eq!(\n            unsafe { &(*(::std::ptr::null::<__wasi_prestat_t>())).pr_type as *const _ as usize },\n            0usize,\n            concat!(\n                \"Offset of field: \",\n                stringify!(__wasi_prestat_t),\n                \"::\",\n                stringify!(pr_type)\n            )\n        );\n        assert_eq!(\n            unsafe { &(*(::std::ptr::null::<__wasi_prestat_t>())).u as *const _ as usize },\n            8usize,\n            concat!(\n                \"Offset of field: \",\n                stringify!(__wasi_prestat_t),\n                \"::\",\n                stringify!(u)\n            )\n        );\n"]], "pred": {"ppl": 1.175533652305603, "ppl_lower": 1.2144683599472046, "ppl/lowercase_ppl": -1.2014825248480991, "ppl/zlib": 0.0006244101029580633, "Min_5.0% Prob": 3.1804888267070055, "Min_10.0% Prob": 1.624859273772348, "Min_20.0% Prob": 0.8156964701148822, "Min_30.0% Prob": 0.5439406907846774, "Min_40.0% Prob": 0.4049053747879323, "Min_50.0% Prob": 0.32441618711204845, "Min_60.0% Prob": 0.27061989435056355}}
{"hexsha": "af364db3b5951c6f44dd477bc6da9885f136d0e0", "ext": "rs", "lang": "Rust", "content": "fn find_target_profile_dir(dir: PathBuf) -> Option<PathBuf> {\r\n    //out dir looks like ...\\plctag-rs\\target\\debug\\build\\XXXXX\r\n    //profile dir looks like ...\\plctag-rs\\target\\debug\\\r\n    let mut dir = dir;\r\n    loop {\r\n        if let Some(p) = dir.parent() {\r\n            let buf = p.to_path_buf();\r\n            if buf.ends_with(\"build\") {\r\n                return Some(buf.parent().unwrap().to_path_buf());\r\n            }\r\n            dir = buf;\r\n        } else {\r\n            return None;\r\n        }\r\n    }\r\n}", "item_id": 1, "repo": "cjgriscom/plctag-rs", "file": "build.rs", "last_update_at": "2021-01-26T23:07:29+00:00", "question_id": "af364db3b5951c6f44dd477bc6da9885f136d0e0_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn find_target_profile_dir(dir: PathBuf) -> Option<PathBuf> {\r\n    //out dir looks like ...\\plctag-rs\\target\\debug\\build\\XXXXX\r\n    //profile dir looks like ...\\plctag-rs\\target\\debug\\\r\n    let mut dir = dir;\r\n    loop {\r\n        if let Some(p) = dir.parent() {\r\n            let buf = p.to_path_buf();\r\n            if buf.ends_with(\"build\") {\r\n                return Some(buf.parent().unwrap().to_path_buf());\r\n            }\r\n            dir = buf;\r\n        } else {\r\n            return None;\r\n        }\r\n    }\r\n"]], "pred": {"ppl": 3.0053212642669678, "ppl_lower": 3.513364315032959, "ppl/lowercase_ppl": -1.141940934734432, "ppl/zlib": 0.00443703416201019, "Min_5.0% Prob": 8.933326840400696, "Min_10.0% Prob": 7.040592074394226, "Min_20.0% Prob": 4.781830180436373, "Min_30.0% Prob": 3.523017625013987, "Min_40.0% Prob": 2.6997320241653, "Min_50.0% Prob": 2.1961787710035288, "Min_60.0% Prob": 1.84408528204124}}
{"hexsha": "1ea14478987993f91371bf19ab20b740001ae85f", "ext": "rs", "lang": "Rust", "content": "pub fn parse_video_information(html: &str) -> Result<VideoInformation> {\n    let document = Html::parse_document(html);\n\n    let video_id = try_select_attribute(&document, &ID_SELECTOR, \"content\")?;\n    let url = try_select_attribute(&document, &URL_SELECTOR, \"href\")?;\n    let author = try_select_attribute(&document, &CHANNEL_SELECTOR, \"content\")?;\n    let title = try_select_attribute(&document, &TITLE_SELECTOR, \"content\")?;\n    let thumbnail = try_select_attribute(&document, &THUMBNAIL_SELECTOR, \"content\").ok();\n\n    Ok(VideoInformation {\n        id: video_id.to_string(),\n        url: url.to_string(),\n        title: title.to_string(),\n        uploader: author.to_string(),\n        thumbnail: thumbnail.map(|s| s.to_string()),\n    })\n}", "item_id": 0, "repo": "Trivernis/youtube-metadata-rs", "file": "src/parsing/video_information.rs", "last_update_at": "2021-07-20T00:11:09+00:00", "question_id": "1ea14478987993f91371bf19ab20b740001ae85f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn parse_video_information(html: &str) -> Result<VideoInformation> {\n    let document = Html::parse_document(html);\n    let video_id = try_select_attribute(&document, &ID_SELECTOR, \"content\")?;\n    let url = try_select_attribute(&document, &URL_SELECTOR, \"href\")?;\n    let author = try_select_attribute(&document, &CHANNEL_SELECTOR, \"content\")?;\n    let title = try_select_attribute(&document, &TITLE_SELECTOR, \"content\")?;\n    let thumbnail = try_select_attribute(&document, &THUMBNAIL_SELECTOR, \"content\").ok();\n    Ok(VideoInformation {\n        id: video_id.to_string(),\n        url: url.to_string(),\n        title: title.to_string(),\n        uploader: author.to_string(),\n        thumbnail: thumbnail.map(|s| s.to_string()),\n    })\n"]], "pred": {"ppl": 1.8331273794174194, "ppl_lower": 2.1920881271362305, "ppl/lowercase_ppl": -1.295089424209188, "ppl/zlib": 0.0020473765498658252, "Min_5.0% Prob": 6.507541100184123, "Min_10.0% Prob": 4.612526640295982, "Min_20.0% Prob": 2.763659885774056, "Min_30.0% Prob": 1.9590080067929294, "Min_40.0% Prob": 1.4989014490662764, "Min_50.0% Prob": 1.2073178749221067, "Min_60.0% Prob": 1.0086610113826788}}
{"hexsha": "860761981e824b15d26b3f1f5db5aa7158f8fc89", "ext": "rs", "lang": "Rust", "content": "async fn get_rooms() {\n        let agent = ureq::builder().user_agent(USER_AGENT).build();\n\n        let res = agent.get(&format!(\"{}/Room\", SERVER)).call().unwrap();\n\n        println!(\"{:#?}\", res);\n\n        let res: Vec<Room> = validate_response(res).await.unwrap();\n        println!(\"{:?}\", res);\n    }", "item_id": 0, "repo": "anden3/schedule-poster", "file": "crates/apis/mchad/src/client.rs", "last_update_at": "2021-11-14T05:40:27+00:00", "question_id": "860761981e824b15d26b3f1f5db5aa7158f8fc89_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn get_rooms() {\n        let agent = ureq::builder().user_agent(USER_AGENT).build();\n        let res = agent.get(&format!(\"{}/Room\", SERVER)).call().unwrap();\n        println!(\"{:#?}\", res);\n        let res: Vec<Room> = validate_response(res).await.unwrap();\n        println!(\"{:?}\", res);\n"]], "pred": {"ppl": 4.097343444824219, "ppl_lower": 4.867029666900635, "ppl/lowercase_ppl": -1.1220593236715186, "ppl/zlib": 0.007383972897484085, "Min_5.0% Prob": 10.396315336227417, "Min_10.0% Prob": 7.682773219214545, "Min_20.0% Prob": 5.160040692279213, "Min_30.0% Prob": 3.9860231383093474, "Min_40.0% Prob": 3.329630533331319, "Min_50.0% Prob": 2.7660119707385697, "Min_60.0% Prob": 2.3338401929057877}}
{"hexsha": "cb10447cf716fdc3671bf2eecb5086e45814d483", "ext": "rs", "lang": "Rust", "content": "fn default_plane() {\n        let o = Object::default_plane();\n\n        assert_relative_eq!(o.transform, Transform::default());\n        assert_relative_eq!(o.material, Material::default());\n        assert_relative_eq!(o.shape, Shape::Plane(Plane));\n    }", "item_id": 5, "repo": "mpycroft/raytracer", "file": "src/object/mod.rs", "last_update_at": "2021-04-07T08:55:44+00:00", "question_id": "cb10447cf716fdc3671bf2eecb5086e45814d483_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn default_plane() {\n        let o = Object::default_plane();\n        assert_relative_eq!(o.transform, Transform::default());\n        assert_relative_eq!(o.material, Material::default());\n        assert_relative_eq!(o.shape, Shape::Plane(Plane));\n"]], "pred": {"ppl": 2.834146022796631, "ppl_lower": 3.4312069416046143, "ppl/lowercase_ppl": -1.1835115191327539, "ppl/zlib": 0.007891974736932808, "Min_5.0% Prob": 8.980860074361166, "Min_10.0% Prob": 6.62137736592974, "Min_20.0% Prob": 4.317702142397563, "Min_30.0% Prob": 3.2470374053174798, "Min_40.0% Prob": 2.5092388560374577, "Min_50.0% Prob": 2.0772111633339443, "Min_60.0% Prob": 1.726026649773121}}
{"hexsha": "3a1627c3740bd6635b55bcc8ac25be63b498c7a4", "ext": "rs", "lang": "Rust", "content": "fn test_symbol() {\n            let mut base = DaoBase::default();\n\n            base.set_symbol(\"https://example.com/logo.jpg\".to_string());\n\n            let dbg_msg = format!(\"logo is {}\", base.get_symbol());\n            ink_env::debug_println!(\"{}\", &dbg_msg );\n\n            assert_eq!(base.get_symbol(), \"https://example.com/logo.jpg\");\n        }", "item_id": 1, "repo": "RainbowDAO/RainbowDAO-Protocol-Ink-Test-Version-05", "file": "dao_base/lib.rs", "last_update_at": "2021-12-16T03:51:18+00:00", "question_id": "3a1627c3740bd6635b55bcc8ac25be63b498c7a4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_symbol() {\n            let mut base = DaoBase::default();\n            base.set_symbol(\"https://example.com/logo.jpg\".to_string());\n            let dbg_msg = format!(\"logo is {}\", base.get_symbol());\n            ink_env::debug_println!(\"{}\", &dbg_msg );\n            assert_eq!(base.get_symbol(), \"https://example.com/logo.jpg\");\n"]], "pred": {"ppl": 3.999690532684326, "ppl_lower": 4.287223815917969, "ppl/lowercase_ppl": -1.0500804732899824, "ppl/zlib": 0.007412925087155105, "Min_5.0% Prob": 9.479260635375976, "Min_10.0% Prob": 8.264781379699707, "Min_20.0% Prob": 5.807687259855724, "Min_30.0% Prob": 4.327569747343659, "Min_40.0% Prob": 3.3773034644681355, "Min_50.0% Prob": 2.740451912085215, "Min_60.0% Prob": 2.3293326186249033}}
{"hexsha": "d9eda8e10a392702a5c2464d513be2b36c1e5394", "ext": "rs", "lang": "Rust", "content": "fn join<T: Iterator<Item = String>>(start: &str, sep: &str, end: &str, strings: T) -> String {\n    let mut res = String::new();\n    res.push_str(start);\n    for (i, s) in strings.enumerate() {\n        if i > 0 {\n            res.push_str(sep);\n        }\n        res.push_str(&s);\n    }\n    res.push_str(end);\n    res\n}", "item_id": 2, "repo": "mateiz/weld", "file": "weld/pretty_print.rs", "last_update_at": "2021-06-14T18:13:15+00:00", "question_id": "d9eda8e10a392702a5c2464d513be2b36c1e5394_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn join<T: Iterator<Item = String>>(start: &str, sep: &str, end: &str, strings: T) -> String {\n    let mut res = String::new();\n    res.push_str(start);\n    for (i, s) in strings.enumerate() {\n        if i > 0 {\n            res.push_str(sep);\n        }\n        res.push_str(&s);\n    }\n    res.push_str(end);\n    res\n"]], "pred": {"ppl": 1.6049004793167114, "ppl_lower": 2.1457717418670654, "ppl/lowercase_ppl": -1.6139526759736287, "ppl/zlib": 0.002766442970779137, "Min_5.0% Prob": 7.428734588623047, "Min_10.0% Prob": 4.346916155381636, "Min_20.0% Prob": 2.329695437265479, "Min_30.0% Prob": 1.5742327805076326, "Min_40.0% Prob": 1.1840320564013846, "Min_50.0% Prob": 0.9452691281182786, "Min_60.0% Prob": 0.7970970711221785}}
{"hexsha": "7f295859d1d471d7215f0134ff7abc90e7dcd288", "ext": "rs", "lang": "Rust", "content": "fn generalized_time_tests() {\n        check_spec(\n            &Utc.ymd(1992, 5, 21).and_hms(0, 0, 0),\n            \"19920521000000Z\".to_string(),\n        );\n        check_spec(\n            &Utc.ymd(1992, 6, 22).and_hms(12, 34, 21),\n            \"19920622123421Z\".to_string(),\n        );\n        check_spec(\n            &Utc.ymd(1992, 7, 22).and_hms_milli(13, 21, 00, 300),\n            \"19920722132100.3Z\".to_string(),\n        );\n    }", "item_id": 15, "repo": "mesalock-linux/simple_asn1-sgx", "file": "src/lib.rs", "last_update_at": "2021-11-18T14:23:55+00:00", "question_id": "7f295859d1d471d7215f0134ff7abc90e7dcd288_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn generalized_time_tests() {\n        check_spec(\n            &Utc.ymd(1992, 5, 21).and_hms(0, 0, 0),\n            \"19920521000000Z\".to_string(),\n        );\n        check_spec(\n            &Utc.ymd(1992, 6, 22).and_hms(12, 34, 21),\n            \"19920622123421Z\".to_string(),\n        );\n        check_spec(\n            &Utc.ymd(1992, 7, 22).and_hms_milli(13, 21, 00, 300),\n            \"19920722132100.3Z\".to_string(),\n        );\n"]], "pred": {"ppl": 1.8310381174087524, "ppl_lower": 1.9503791332244873, "ppl/lowercase_ppl": -1.1043849620390835, "ppl/zlib": 0.003360461573805248, "Min_5.0% Prob": 6.4118521430275655, "Min_10.0% Prob": 4.689840468493375, "Min_20.0% Prob": 2.8856699228286744, "Min_30.0% Prob": 2.0050896842088273, "Min_40.0% Prob": 1.5065744599534405, "Min_50.0% Prob": 1.2140877068367055, "Min_60.0% Prob": 1.0078036144824216}}
{"hexsha": "4c8b5e3ed9c0b342b6c70f4a8d73064e20a3ef4a", "ext": "rs", "lang": "Rust", "content": "fn test_get_data_ok() {\n        // prepare\n        let test_ok = create_test_config();\n\n        // launch test and check result\n        match get_data(&test_ok) {\n            // TODO: better test here\n            Ok(data) => assert_ne!(data[\"stats\"][\"user_count\"], 0),\n            Err(e) => panic!(e),\n        }\n    }", "item_id": 4, "repo": "papey/fediwatcher", "file": "src/get.rs", "last_update_at": "2021-02-27T18:17:33+00:00", "question_id": "4c8b5e3ed9c0b342b6c70f4a8d73064e20a3ef4a_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_get_data_ok() {\n        // prepare\n        let test_ok = create_test_config();\n        // launch test and check result\n        match get_data(&test_ok) {\n            // TODO: better test here\n            Ok(data) => assert_ne!(data[\"stats\"][\"user_count\"], 0),\n            Err(e) => panic!(e),\n        }\n"]], "pred": {"ppl": 4.254156589508057, "ppl_lower": 4.7808709144592285, "ppl/lowercase_ppl": -1.0806177799579286, "ppl/zlib": 0.007580610084010745, "Min_5.0% Prob": 7.858919024467468, "Min_10.0% Prob": 6.562409771813287, "Min_20.0% Prob": 5.32365157729701, "Min_30.0% Prob": 4.192406802341856, "Min_40.0% Prob": 3.409308433532715, "Min_50.0% Prob": 2.8208148423582315, "Min_60.0% Prob": 2.3943105401663947}}
{"hexsha": "647b877cb76d8d9dc71190b5be30d2b7f7d9acfd", "ext": "rs", "lang": "Rust", "content": "fn test_invalid_sub_rr() {\n    // FIXME: Is this only testing that at least one of the statements panics?\n    lower(&[ SubRR(RAX, EAX) ]);\n    lower(&[ SubRR(EAX, AH) ]);\n  }", "item_id": 21, "repo": "bdash/brainrust", "file": "src/assembler/x86_64.rs", "last_update_at": "2021-07-24T23:12:02+00:00", "question_id": "647b877cb76d8d9dc71190b5be30d2b7f7d9acfd_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_invalid_sub_rr() {\n    // FIXME: Is this only testing that at least one of the statements panics?\n    lower(&[ SubRR(RAX, EAX) ]);\n    lower(&[ SubRR(EAX, AH) ]);\n"]], "pred": {"ppl": 10.844930648803711, "ppl_lower": 15.32695198059082, "ppl/lowercase_ppl": -1.145117012672494, "ppl/zlib": 0.016786603869691337, "Min_5.0% Prob": 11.664581616719564, "Min_10.0% Prob": 10.159483114878336, "Min_20.0% Prob": 8.23747418476985, "Min_30.0% Prob": 6.920113646984101, "Min_40.0% Prob": 5.649012163833335, "Min_50.0% Prob": 4.640622291494818, "Min_60.0% Prob": 4.0045264177024364}}
{"hexsha": "dfb84c7df22927b61c9f53a3426a088b29dd1890", "ext": "rs", "lang": "Rust", "content": "fn id3v2() {\n    let meta = mp3_metadata::read_from_file(\"assets/id3v2.mp3\").expect(\"File error\");\n    assert_eq!(meta.optional_info[0].position, 0);\n    assert_eq!(meta.optional_info[0].major_version, 4);\n    assert_eq!(meta.optional_info[0].minor_version, 0);\n    assert_eq!(meta.optional_info[0].album_movie_show, Some(\"\u00e9\u00e0\u00b5\u00a3\u00f8\u00a7\".to_owned()));\n    assert_eq!(meta.optional_info[0].bpm, None);\n    assert_eq!(meta.optional_info[0].composers,\n               vec!(\"not Mozart\".to_owned(), \"not Beethoven\".to_owned()));\n    assert_eq!(meta.optional_info[0].content_type,\n               vec!(mp3_metadata::Genre::InstrumentalPop));\n    assert_eq!(meta.optional_info[0].copyright, Some(\"Is there?\".to_owned()));\n    assert_eq!(meta.optional_info[0].date, None);\n    assert_eq!(meta.optional_info[0].playlist_delay, None);\n    assert_eq!(meta.optional_info[0].encoded_by, Some(\"some website...\".to_owned()));\n    assert_eq!(meta.optional_info[0].text_writers.len(), 0);\n    assert_eq!(meta.optional_info[0].file_type, None);\n    assert_eq!(meta.optional_info[0].time, None);\n    assert_eq!(meta.optional_info[0].content_group_description, None);\n    assert_eq!(meta.optional_info[0].subtitle_refinement_description, None);\n    assert_eq!(meta.optional_info[0].title,\n               Some(\"This is a wonderful title isn't it?\".to_owned()));\n    assert_eq!(meta.optional_info[0].performers,\n               vec!(\"Someone\".to_owned(), \"Someone else\".to_owned()));\n    assert_eq!(meta.optional_info[0].band,\n               Some(\"I like artists! But who to choose? So many of them...\".to_owned()));\n    assert_eq!(meta.optional_info[0].track_number, Some(\"01\".to_owned()));\n\n    assert_eq!(meta.tag, Some(mp3_metadata::AudioTag {\n        title: \"This is a wonderful title isn'\".to_owned(),\n        artist: \"Someone/Someone else          \".to_owned(),\n        album: \"\".to_owned(),\n        year: 2015,\n        comment: \"Some random comment because \".to_owned(),\n        genre: mp3_metadata::Genre::Other,\n    }));\n}", "item_id": 0, "repo": "ahti/mp3-metadata", "file": "tests/id3v2.rs", "last_update_at": "2021-03-19T15:51:12+00:00", "question_id": "dfb84c7df22927b61c9f53a3426a088b29dd1890_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn id3v2() {\n    let meta = mp3_metadata::read_from_file(\"assets/id3v2.mp3\").expect(\"File error\");\n    assert_eq!(meta.optional_info[0].position, 0);\n    assert_eq!(meta.optional_info[0].major_version, 4);\n    assert_eq!(meta.optional_info[0].minor_version, 0);\n    assert_eq!(meta.optional_info[0].album_movie_show, Some(\"\u00e9\u00e0\u00b5\u00a3\u00f8\u00a7\".to_owned()));\n    assert_eq!(meta.optional_info[0].bpm, None);\n    assert_eq!(meta.optional_info[0].composers,\n               vec!(\"not Mozart\".to_owned(), \"not Beethoven\".to_owned()));\n    assert_eq!(meta.optional_info[0].content_type,\n               vec!(mp3_metadata::Genre::InstrumentalPop));\n    assert_eq!(meta.optional_info[0].copyright, Some(\"Is there?\".to_owned()));\n    assert_eq!(meta.optional_info[0].date, None);\n    assert_eq!(meta.optional_info[0].playlist_delay, None);\n    assert_eq!(meta.optional_info[0].encoded_by, Some(\"some website...\".to_owned()));\n    assert_eq!(meta.optional_info[0].text_writers.len(), 0);\n    assert_eq!(meta.optional_info[0].file_type, None);\n    assert_eq!(meta.optional_info[0].time, None);\n    assert_eq!(meta.optional_info[0].content_group_description, None);\n    assert_eq!(meta.optional_info[0].subtitle_refinement_description, None);\n    assert_eq!(meta.optional_info[0].title,\n               Some(\"This is a wonderful title isn't it?\".to_owned()));\n    assert_eq!(meta.optional_info[0].performers,\n               vec!(\"Someone\".to_owned(), \"Someone else\".to_owned()));\n    assert_eq!(meta.optional_info[0].band,\n               Some(\"I like artists! But who to choose? So many of them...\".to_owned()));\n    assert_eq!(meta.optional_info[0].track_number, Some(\"01\".to_owned()));\n    assert_eq!(meta.tag, Some(mp3_metadata::AudioTag {\n        title: \"This is a wonderful title isn'\".to_owned(),\n        artist: \"Someone/Someone else          \".to_owned(),\n        album: \"\".to_owned(),\n        year: 2015,\n        comment: \"Some random comment because \".to_owned(),\n        genre: mp3_metadata::Genre::Other,\n    }));\n"]], "pred": {"ppl": 2.260313034057617, "ppl_lower": 2.3707828521728516, "ppl/lowercase_ppl": -1.0585122130105649, "ppl/zlib": 0.00134793936254123, "Min_5.0% Prob": 7.87904252427997, "Min_10.0% Prob": 6.078574237538807, "Min_20.0% Prob": 3.8425043556425305, "Min_30.0% Prob": 2.6899899455285308, "Min_40.0% Prob": 2.0337755668770385, "Min_50.0% Prob": 1.6286867953445652, "Min_60.0% Prob": 1.3604580873152081}}
{"hexsha": "50fae912484e2bdb5819e7c2d4409a3c8263f600", "ext": "rs", "lang": "Rust", "content": "fn test_get_input_radix() {\n        let mut calculator = Calculator::new();\n        calculator.get_input_radix().unwrap();\n        assert_eq!(calculator.stack.len(), 1);\n        assert_eq!(\n            *calculator.stack.back().unwrap(),\n            StackValue::Number(BigInt::from(calculator.input_radix))\n        );\n    }", "item_id": 20, "repo": "nagyf/dc", "file": "src/calculator.rs", "last_update_at": "2021-06-04T16:29:37+00:00", "question_id": "50fae912484e2bdb5819e7c2d4409a3c8263f600_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_get_input_radix() {\n        let mut calculator = Calculator::new();\n        calculator.get_input_radix().unwrap();\n        assert_eq!(calculator.stack.len(), 1);\n        assert_eq!(\n            *calculator.stack.back().unwrap(),\n            StackValue::Number(BigInt::from(calculator.input_radix))\n        );\n"]], "pred": {"ppl": 2.713132619857788, "ppl_lower": 3.3615877628326416, "ppl/lowercase_ppl": -1.2147166160659344, "ppl/zlib": 0.006012674190269969, "Min_5.0% Prob": 8.855840921401978, "Min_10.0% Prob": 6.37821610768636, "Min_20.0% Prob": 4.317127083477221, "Min_30.0% Prob": 3.144454392893561, "Min_40.0% Prob": 2.477722556967484, "Min_50.0% Prob": 1.9897363238657515, "Min_60.0% Prob": 1.6590481040806606}}
{"hexsha": "61bd17c47b1075379112034e748e6260ca2c3604", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn __reduce31<\n        'err,\n        'input,\n        'v,\n    >(\n        input: &'input str,\n        errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, ParserError>>,\n        validator: &'v mut VariableValidator<'input>,\n        __lookahead_start: Option<&usize>,\n        __symbols: &mut alloc::vec::Vec<(usize,__Symbol<'input>,usize)>,\n        _: core::marker::PhantomData<(&'err (), &'input (), &'v ())>,\n    ) -> (usize, usize)\n    {\n        // CallInstrValue = InitPeerId => ActionFn(28);\n        let __sym0 = __pop_Variant0(__symbols);\n        let __start = __sym0.0.clone();\n        let __end = __sym0.2.clone();\n        let __nt = super::__action28::<>(input, errors, validator, __sym0);\n        __symbols.push((__start, __Symbol::Variant13(__nt), __end));\n        (1, 10)\n    }", "item_id": 33, "repo": "fluencelabs/aquamarine", "file": "crates/air-lib/air-parser/src/parser/air.rs", "last_update_at": "2021-04-10T15:02:25+00:00", "question_id": "61bd17c47b1075379112034e748e6260ca2c3604_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn __reduce31<\n        'err,\n        'input,\n        'v,\n    >(\n        input: &'input str,\n        errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, ParserError>>,\n        validator: &'v mut VariableValidator<'input>,\n        __lookahead_start: Option<&usize>,\n        __symbols: &mut alloc::vec::Vec<(usize,__Symbol<'input>,usize)>,\n        _: core::marker::PhantomData<(&'err (), &'input (), &'v ())>,\n    ) -> (usize, usize)\n    {\n        // CallInstrValue = InitPeerId => ActionFn(28);\n        let __sym0 = __pop_Variant0(__symbols);\n        let __start = __sym0.0.clone();\n        let __end = __sym0.2.clone();\n        let __nt = super::__action28::<>(input, errors, validator, __sym0);\n        __symbols.push((__start, __Symbol::Variant13(__nt), __end));\n        (1, 10)\n"]], "pred": {"ppl": 4.429009437561035, "ppl_lower": 5.938657760620117, "ppl/lowercase_ppl": -1.1970917381630342, "ppl/zlib": 0.0037580200903907786, "Min_5.0% Prob": 9.419876677649361, "Min_10.0% Prob": 7.812412755829947, "Min_20.0% Prob": 5.805955435100355, "Min_30.0% Prob": 4.532272901645927, "Min_40.0% Prob": 3.597721161013064, "Min_50.0% Prob": 2.952268739644852, "Min_60.0% Prob": 2.477980959794425}}
{"hexsha": "e9e65a6f4ce3164a316e8c939c6cc7aaa78b308d", "ext": "rs", "lang": "Rust", "content": "fn next_u64(&mut self) -> u64 {\n        let mut bytes = [0; 8];\n        self.fill_bytes(&mut bytes);\n        u64::from_ne_bytes(bytes)\n    }", "item_id": 4, "repo": "nvzqz/chance-rs", "file": "src/rng/mod.rs", "last_update_at": "2021-09-26T05:50:56+00:00", "question_id": "e9e65a6f4ce3164a316e8c939c6cc7aaa78b308d_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn next_u64(&mut self) -> u64 {\n        let mut bytes = [0; 8];\n        self.fill_bytes(&mut bytes);\n        u64::from_ne_bytes(bytes)\n"]], "pred": {"ppl": 1.992309331893921, "ppl_lower": 1.992309331893921, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.006962570042443993, "Min_5.0% Prob": 7.836484909057617, "Min_10.0% Prob": 5.319087028503418, "Min_20.0% Prob": 3.1816593571142717, "Min_30.0% Prob": 2.2969181649386883, "Min_40.0% Prob": 1.7037412917072123, "Min_50.0% Prob": 1.3982634018692706, "Min_60.0% Prob": 1.1480532516302033}}
{"hexsha": "cd84618250aae6bd88ab87616c4eba24790d237b", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn parse_hdel(mut iter: Iter<Vec<u8>>) -> HDEL {\n    let key = iter.next().unwrap();\n    let mut fields = Vec::new();\n    while let Some(field) = iter.next() {\n        fields.push(field.as_slice());\n    }\n    HDEL { key, fields }\n}", "item_id": 0, "repo": "maplestoria/redis-event", "file": "src/cmd/hashes.rs", "last_update_at": "2021-12-17T02:19:48+00:00", "question_id": "cd84618250aae6bd88ab87616c4eba24790d237b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn parse_hdel(mut iter: Iter<Vec<u8>>) -> HDEL {\n    let key = iter.next().unwrap();\n    let mut fields = Vec::new();\n    while let Some(field) = iter.next() {\n        fields.push(field.as_slice());\n    }\n    HDEL { key, fields }\n"]], "pred": {"ppl": 2.6657721996307373, "ppl_lower": 3.3463947772979736, "ppl/lowercase_ppl": -1.2319135678688802, "ppl/zlib": 0.005942386494579747, "Min_5.0% Prob": 8.60940706729889, "Min_10.0% Prob": 6.628856778144836, "Min_20.0% Prob": 4.342540123883416, "Min_30.0% Prob": 3.1213938066592584, "Min_40.0% Prob": 2.428428780606815, "Min_50.0% Prob": 1.9641452121802352, "Min_60.0% Prob": 1.6426773363689207}}
{"hexsha": "ea196c04010a3701eeb7409e2ddee5fddfd07b74", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<()> {\n    let opts: Opts = Opts::parse();\n    let mut input = String::new();\n    File::open(opts.input)?.read_to_string(&mut input)?;\n    let numbers = input\n        .split(',')\n        .filter_map(|n| match n.trim() {\n            \"\" => None,\n            n => Some(u32::from_str(n)),\n        })\n        .collect::<std::result::Result<Vec<_>, _>>()?;\n    let (target, score) = optimize(&numbers, opts.expensive);\n    println!(\"Best target is {} with a fuel cost of {}\", target, score);\n    Ok(())\n}", "item_id": 0, "repo": "Raniz85/aoc21", "file": "day07/src/main.rs", "last_update_at": "2021-12-02T07:30:33+00:00", "question_id": "ea196c04010a3701eeb7409e2ddee5fddfd07b74_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<()> {\n    let opts: Opts = Opts::parse();\n    let mut input = String::new();\n    File::open(opts.input)?.read_to_string(&mut input)?;\n    let numbers = input\n        .split(',')\n        .filter_map(|n| match n.trim() {\n            \"\" => None,\n            n => Some(u32::from_str(n)),\n        })\n        .collect::<std::result::Result<Vec<_>, _>>()?;\n    let (target, score) = optimize(&numbers, opts.expensive);\n    println!(\"Best target is {} with a fuel cost of {}\", target, score);\n    Ok(())\n"]], "pred": {"ppl": 2.2540202140808105, "ppl_lower": 3.218644618988037, "ppl/lowercase_ppl": -1.438339138953368, "ppl/zlib": 0.002613232744919651, "Min_5.0% Prob": 6.7140421867370605, "Min_10.0% Prob": 5.412574193056892, "Min_20.0% Prob": 3.4866704134380115, "Min_30.0% Prob": 2.5870485714837614, "Min_40.0% Prob": 2.0110640845754566, "Min_50.0% Prob": 1.6220029426190783, "Min_60.0% Prob": 1.353938162956825}}
{"hexsha": "8fbd63582788474dbc94e0582dac8286cb21466b", "ext": "rs", "lang": "Rust", "content": "fn from_nested_fn_application() {\n        let env = Default::default();\n        let iter = 'a'..='z';\n\n        // (((\\x -> (\\y -> x + y)) 3) 4)\n        let x = Expr::Variable(\"x\".to_string());\n        let y = Expr::Variable(\"y\".to_string());\n        let plus_expr = Expr::Plus(Box::new(x), Box::new(y));\n        let inner_fn_expr = Expr::Lambda(\"y\".to_string(), Box::new(plus_expr));\n        let outer_fn_expr = Expr::Lambda(\"x\".to_string(), Box::new(inner_fn_expr));\n        let inner_apply_expr =\n            Expr::Application(Box::new(outer_fn_expr), Box::new(Expr::Integer(3)));\n        let outer_apply_expr =\n            Expr::Application(Box::new(inner_apply_expr), Box::new(Expr::Integer(4)));\n\n        let result = infer(env, iter, outer_apply_expr);\n        assert!(result.is_ok());\n\n        let (_env, _iter, t) = result.unwrap();\n        assert_eq!(Type::Integer, t);\n    }", "item_id": 7, "repo": "Drumato/blog_samples", "file": "toy-type-system/mincaml-inferer/src/inference.rs", "last_update_at": "2021-04-16T20:27:55+00:00", "question_id": "8fbd63582788474dbc94e0582dac8286cb21466b_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn from_nested_fn_application() {\n        let env = Default::default();\n        let iter = 'a'..='z';\n        // (((\\x -> (\\y -> x + y)) 3) 4)\n        let x = Expr::Variable(\"x\".to_string());\n        let y = Expr::Variable(\"y\".to_string());\n        let plus_expr = Expr::Plus(Box::new(x), Box::new(y));\n        let inner_fn_expr = Expr::Lambda(\"y\".to_string(), Box::new(plus_expr));\n        let outer_fn_expr = Expr::Lambda(\"x\".to_string(), Box::new(inner_fn_expr));\n        let inner_apply_expr =\n            Expr::Application(Box::new(outer_fn_expr), Box::new(Expr::Integer(3)));\n        let outer_apply_expr =\n            Expr::Application(Box::new(inner_apply_expr), Box::new(Expr::Integer(4)));\n        let result = infer(env, iter, outer_apply_expr);\n        assert!(result.is_ok());\n        let (_env, _iter, t) = result.unwrap();\n        assert_eq!(Type::Integer, t);\n"]], "pred": {"ppl": 2.008782386779785, "ppl_lower": 2.3310508728027344, "ppl/lowercase_ppl": -1.213310807870765, "ppl/zlib": 0.0021073376458973616, "Min_5.0% Prob": 6.597865445273263, "Min_10.0% Prob": 4.948351046134686, "Min_20.0% Prob": 3.1953897142814376, "Min_30.0% Prob": 2.2647571808166718, "Min_40.0% Prob": 1.7331310654012095, "Min_50.0% Prob": 1.392371192136967, "Min_60.0% Prob": 1.167258534923175}}
{"hexsha": "29ac1c5997a292d330ffa57ed701a5277bcfd236", "ext": "rs", "lang": "Rust", "content": "fn can_split_page_content_valid() {\n        let content = r#\"\n+++\ntitle = \"Title\"\ndescription = \"hey there\"\ndate = 2002-10-12\n+++\nHello\n\"#;\n        let (front_matter, content) = split_page_content(Path::new(\"\"), content).unwrap();\n        assert_eq!(content, \"Hello\\n\");\n        assert_eq!(front_matter.title.unwrap(), \"Title\");\n    }", "item_id": 3, "repo": "Recmo/zola", "file": "components/front_matter/src/lib.rs", "last_update_at": "2021-05-26T06:38:04+00:00", "question_id": "29ac1c5997a292d330ffa57ed701a5277bcfd236_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn can_split_page_content_valid() {\n        let content = r#\"\n+++\ntitle = \"Title\"\ndescription = \"hey there\"\ndate = 2002-10-12\n+++\nHello\n\"#;\n        let (front_matter, content) = split_page_content(Path::new(\"\"), content).unwrap();\n        assert_eq!(content, \"Hello\\n\");\n        assert_eq!(front_matter.title.unwrap(), \"Title\");\n"]], "pred": {"ppl": 3.1342387199401855, "ppl_lower": 3.367812395095825, "ppl/lowercase_ppl": -1.0629183664588924, "ppl/zlib": 0.005919100062390261, "Min_5.0% Prob": 8.827463150024414, "Min_10.0% Prob": 6.694725135962169, "Min_20.0% Prob": 4.463933378458023, "Min_30.0% Prob": 3.406566275490655, "Min_40.0% Prob": 2.7363683842122555, "Min_50.0% Prob": 2.253721768409014, "Min_60.0% Prob": 1.90392943057749}}
{"hexsha": "a0fe8c3db7140816c5ddb7578ab0a6163d191027", "ext": "rs", "lang": "Rust", "content": "fn part_1(input: &TParsed) -> usize {\r\n  let mut i = input.to_owned();\r\n  i.retain(|(f, t)| f.x == t.x || f.y == t.y);\r\n  count_overlapping(&i)\r\n}", "item_id": 2, "repo": "SanderHageman/advent_of_code_2021", "file": "src/day05.rs", "last_update_at": "2021-12-04T13:40:11+00:00", "question_id": "a0fe8c3db7140816c5ddb7578ab0a6163d191027_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn part_1(input: &TParsed) -> usize {\r\n  let mut i = input.to_owned();\r\n  i.retain(|(f, t)| f.x == t.x || f.y == t.y);\r\n  count_overlapping(&i)\r\n"]], "pred": {"ppl": 4.748476028442383, "ppl_lower": 5.361959934234619, "ppl/lowercase_ppl": -1.0779971666835435, "ppl/zlib": 0.012076152949226655, "Min_5.0% Prob": 10.59612766901652, "Min_10.0% Prob": 8.196390787760416, "Min_20.0% Prob": 6.028861229236309, "Min_30.0% Prob": 4.687977260351181, "Min_40.0% Prob": 3.7300730568391307, "Min_50.0% Prob": 3.0499296836993275, "Min_60.0% Prob": 2.6276063345372678}}
{"hexsha": "167bfa131b24aa234d655fab9eea8d6f38a1c8dd", "ext": "rs", "lang": "Rust", "content": "fn test_it() -> Result<(), String> {\n\n        //tag::report-testdata[]\n        let vec1 = vec![\n            199,\n            200,\n            208,\n            210,\n            200,\n            207,\n            240,\n            269,\n            260,\n            263\n        ];\n        //end::report-testdata[] \n\n        //tag::test-calculate-increases[]\n        assert_eq!(calculate_increases(&vec1).unwrap(), 7);\n        //end::test-calculate-increases[]\n        \n        //tag::test-calculate-window[]\n        let vec2 = calculate_window(&vec1).unwrap();\n        assert_eq!(calculate_increases(&vec2).unwrap(), 5);\n        //end::test-calculate-window[]\n\n        Ok(())\n    }", "item_id": 0, "repo": "AlexisTM/aoc-2021", "file": "day01/rust/dfriedenberger/src/lib.rs", "last_update_at": "2021-12-21T10:38:34+00:00", "question_id": "167bfa131b24aa234d655fab9eea8d6f38a1c8dd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_it() -> Result<(), String> {\n        //tag::report-testdata[]\n        let vec1 = vec![\n            199,\n            200,\n            208,\n            210,\n            200,\n            207,\n            240,\n            269,\n            260,\n            263\n        ];\n        //end::report-testdata[] \n        //tag::test-calculate-increases[]\n        assert_eq!(calculate_increases(&vec1).unwrap(), 7);\n        //end::test-calculate-increases[]\n        //tag::test-calculate-window[]\n        let vec2 = calculate_window(&vec1).unwrap();\n        assert_eq!(calculate_increases(&vec2).unwrap(), 5);\n        //end::test-calculate-window[]\n        Ok(())\n"]], "pred": {"ppl": 2.042421817779541, "ppl_lower": 2.2390735149383545, "ppl/lowercase_ppl": -1.1287231940799278, "ppl/zlib": 0.003051864398762802, "Min_5.0% Prob": 7.230506506833163, "Min_10.0% Prob": 5.301973559639671, "Min_20.0% Prob": 3.2944824139277142, "Min_30.0% Prob": 2.3483169296784188, "Min_40.0% Prob": 1.7749770765917168, "Min_50.0% Prob": 1.4315570457090092, "Min_60.0% Prob": 1.189279087950234}}
{"hexsha": "86574efccd9c60520dc9c5b5f55b843f33903315", "ext": "rs", "lang": "Rust", "content": "fn test_display() {\n        check_display!(U8, 7);\n        check_display!(U16, 707);\n        check_display!(U32, 70707);\n        check_display!(U64, 7070707);\n        check_display!(Usize, 707070707);\n    }", "item_id": 0, "repo": "r-bk/cds", "file": "src/len/length_type.rs", "last_update_at": "2021-11-24T16:16:26+00:00", "question_id": "86574efccd9c60520dc9c5b5f55b843f33903315_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_display() {\n        check_display!(U8, 7);\n        check_display!(U16, 707);\n        check_display!(U32, 70707);\n        check_display!(U64, 7070707);\n        check_display!(Usize, 707070707);\n"]], "pred": {"ppl": 2.1254942417144775, "ppl_lower": 2.003298759460449, "ppl/lowercase_ppl": -0.9214737191469464, "ppl/zlib": 0.00979226441128651, "Min_5.0% Prob": 7.193469762802124, "Min_10.0% Prob": 5.423466841379802, "Min_20.0% Prob": 3.4795341557926602, "Min_30.0% Prob": 2.4845426789036504, "Min_40.0% Prob": 1.9023920723961458, "Min_50.0% Prob": 1.5002493112064574, "Min_60.0% Prob": 1.258481886136261}}
{"hexsha": "b6bc1c6ba0faaad1ae0cdc3eea42429aea859bce", "ext": "rs", "lang": "Rust", "content": "pub fn request_to_string(name: &str, args: Vec<Value>) -> Result<String> {\n    let mut writer = Writer::new(Vec::new());\n\n    writer\n        .write(br#\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\"#)\n        .map_err(error::EncodingError::from)?;\n\n    writer.write_start_tag(b\"methodCall\")?;\n    writer.write_tag(b\"methodName\", name)?;\n\n    writer.write_start_tag(b\"params\")?;\n    for value in args {\n        writer.write_start_tag(b\"param\")?;\n\n        let deserializer = value::Deserializer::from_value(value);\n        let serializer = ValueSerializer::new(&mut writer);\n        transcode(deserializer, serializer)?;\n\n        writer.write_end_tag(b\"param\")?;\n    }\n    writer.write_end_tag(b\"params\")?;\n    writer.write_end_tag(b\"methodCall\")?;\n\n    Ok(String::from_utf8(writer.into_inner()).map_err(error::EncodingError::from)?)\n}", "item_id": 1, "repo": "belak/simple-xmlrpc", "file": "src/lib.rs", "last_update_at": "2021-09-13T21:49:59+00:00", "question_id": "b6bc1c6ba0faaad1ae0cdc3eea42429aea859bce_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn request_to_string(name: &str, args: Vec<Value>) -> Result<String> {\n    let mut writer = Writer::new(Vec::new());\n    writer\n        .write(br#\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\"#)\n        .map_err(error::EncodingError::from)?;\n    writer.write_start_tag(b\"methodCall\")?;\n    writer.write_tag(b\"methodName\", name)?;\n    writer.write_start_tag(b\"params\")?;\n    for value in args {\n        writer.write_start_tag(b\"param\")?;\n        let deserializer = value::Deserializer::from_value(value);\n        let serializer = ValueSerializer::new(&mut writer);\n        transcode(deserializer, serializer)?;\n        writer.write_end_tag(b\"param\")?;\n    }\n    writer.write_end_tag(b\"params\")?;\n    writer.write_end_tag(b\"methodCall\")?;\n    Ok(String::from_utf8(writer.into_inner()).map_err(error::EncodingError::from)?)\n"]], "pred": {"ppl": 1.8306005001068115, "ppl_lower": 2.190185308456421, "ppl/lowercase_ppl": -1.296607730267068, "ppl/zlib": 0.0017128726775108888, "Min_5.0% Prob": 6.49093793119703, "Min_10.0% Prob": 4.390915767899875, "Min_20.0% Prob": 2.722602477361416, "Min_30.0% Prob": 1.9572638273239136, "Min_40.0% Prob": 1.5067115598839933, "Min_50.0% Prob": 1.2067289524392721, "Min_60.0% Prob": 1.0082456357564245}}
{"hexsha": "4d5860bbc6fd8de447d1119974c6f2ee66687673", "ext": "rs", "lang": "Rust", "content": "fn prepare_format_args<T>(tag: &str, buf: &mut MallocDataBlock<T>) -> (CString, *mut T, c_int) {\n\tlet (p, _, cap) = unsafe {buf.raw_parts()};\n\tlet cap = cap as c_int;\n\tlet tag = CString::new(tag).unwrap();\n\t(tag, p, cap)\t\t\n}", "item_id": 0, "repo": "IsmailM/gemBS-rs", "file": "rust/r_htslib/src/vcf.rs", "last_update_at": "2021-04-26T16:53:08+00:00", "question_id": "4d5860bbc6fd8de447d1119974c6f2ee66687673_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn prepare_format_args<T>(tag: &str, buf: &mut MallocDataBlock<T>) -> (CString, *mut T, c_int) {\n\tlet (p, _, cap) = unsafe {buf.raw_parts()};\n\tlet cap = cap as c_int;\n\tlet tag = CString::new(tag).unwrap();\n\t(tag, p, cap)\t\t\n"]], "pred": {"ppl": 5.282843589782715, "ppl_lower": 6.418874263763428, "ppl/lowercase_ppl": -1.1170215653433457, "ppl/zlib": 0.009733710593090441, "Min_5.0% Prob": 9.917010307312012, "Min_10.0% Prob": 8.376469718085396, "Min_20.0% Prob": 6.185783938357704, "Min_30.0% Prob": 4.9341893792152405, "Min_40.0% Prob": 3.972433479208695, "Min_50.0% Prob": 3.247297370185455, "Min_60.0% Prob": 2.7700198125420954}}
{"hexsha": "27a4d1fda92c2326af29d430ae646027e5f1e064", "ext": "rs", "lang": "Rust", "content": "fn sorting() {\n        let elems = vec!['a', 'b', 'e', 'g', 'f'];\n        let perm = permutation::sort(&elems[..]);\n        println!(\"{:?}\", perm);\n        assert_eq!(perm, Permutation::from_vec(vec![0, 1, 2, 4, 3]));\n    }", "item_id": 8, "repo": "jeremysalwen/rust-permutations", "file": "src/permutation.rs", "last_update_at": "2021-06-11T14:39:51+00:00", "question_id": "27a4d1fda92c2326af29d430ae646027e5f1e064_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn sorting() {\n        let elems = vec!['a', 'b', 'e', 'g', 'f'];\n        let perm = permutation::sort(&elems[..]);\n        println!(\"{:?}\", perm);\n        assert_eq!(perm, Permutation::from_vec(vec![0, 1, 2, 4, 3]));\n"]], "pred": {"ppl": 3.023003339767456, "ppl_lower": 3.106820821762085, "ppl/lowercase_ppl": -1.0247223671574632, "ppl/zlib": 0.007137102068274226, "Min_5.0% Prob": 9.394524335861206, "Min_10.0% Prob": 6.82379737496376, "Min_20.0% Prob": 4.391207400490256, "Min_30.0% Prob": 3.2216120591530433, "Min_40.0% Prob": 2.643995924907572, "Min_50.0% Prob": 2.1777110737423566, "Min_60.0% Prob": 1.8305857892219837}}
{"hexsha": "a36b87cc4d19effefcd8ce0c9a1f9d7eb3a239fe", "ext": "rs", "lang": "Rust", "content": "pub fn module_doc(module: DbItem<&RustModule>, database: &DatabaseClient) -> Result<String> {\n    let mut output = String::new();\n\n    match module.item.kind {\n        RustModuleKind::Special(kind) => match kind {\n            RustSpecialModuleKind::CrateRoot => {\n                let doc_item = database.find_doc_for(&module.id)?;\n                if let Some(doc_item) = &doc_item {\n                    write!(output, \"{}\", doc_item.item.html)?;\n                }\n                writeln!(\n                    output,\n                    \"This crate was generated by `ritual`.\n                    See [README](https://github.com/rust-qt/ritual) for more information.\\n\"\n                )?;\n            }\n            RustSpecialModuleKind::Ffi => {\n                write!(output, \"Functions provided by the C++ wrapper library\")?;\n            }\n            RustSpecialModuleKind::Ops => {\n                write!(output, \"Functions that provide access to C++ operators\")?;\n            }\n            RustSpecialModuleKind::SizedTypes => {\n                write!(\n                    output,\n                    \"Types with the same size and alignment as corresponding C++ types\"\n                )?;\n            }\n        },\n        RustModuleKind::CppNamespace { .. } => {\n            let cpp_item = database\n                .source_cpp_item(&module.id)?\n                .ok_or_else(|| err_msg(\"source cpp item not found\"))?\n                .item\n                .as_namespace_ref()\n                .ok_or_else(|| err_msg(\"invalid source cpp item type\"))?;\n\n            let cpp_path_text = wrap_inline_cpp_code(&cpp_item.path.to_cpp_pseudo_code());\n            write!(output, \"C++ namespace: {}\", cpp_path_text)?;\n        }\n        RustModuleKind::CppNestedTypes { .. } => {\n            let cpp_item = database\n                .source_cpp_item(&module.id)?\n                .ok_or_else(|| err_msg(\"source cpp item not found\"))?\n                .item\n                .as_type_ref()\n                .ok_or_else(|| err_msg(\"invalid source cpp item type\"))?;\n\n            let cpp_path_text = wrap_inline_cpp_code(&cpp_item.path.to_cpp_pseudo_code());\n            write!(output, \"C++ type: {}\", cpp_path_text)?;\n        }\n    };\n    Ok(output)\n}", "item_id": 0, "repo": "not-a-seagull/ritual", "file": "ritual/src/doc_formatter.rs", "last_update_at": "2021-01-01T10:25:32+00:00", "question_id": "a36b87cc4d19effefcd8ce0c9a1f9d7eb3a239fe_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn module_doc(module: DbItem<&RustModule>, database: &DatabaseClient) -> Result<String> {\n    let mut output = String::new();\n    match module.item.kind {\n        RustModuleKind::Special(kind) => match kind {\n            RustSpecialModuleKind::CrateRoot => {\n                let doc_item = database.find_doc_for(&module.id)?;\n                if let Some(doc_item) = &doc_item {\n                    write!(output, \"{}\", doc_item.item.html)?;\n                }\n                writeln!(\n                    output,\n                    \"This crate was generated by `ritual`.\n                    See [README](https://github.com/rust-qt/ritual) for more information.\\n\"\n                )?;\n            }\n            RustSpecialModuleKind::Ffi => {\n                write!(output, \"Functions provided by the C++ wrapper library\")?;\n            }\n            RustSpecialModuleKind::Ops => {\n                write!(output, \"Functions that provide access to C++ operators\")?;\n            }\n            RustSpecialModuleKind::SizedTypes => {\n                write!(\n                    output,\n                    \"Types with the same size and alignment as corresponding C++ types\"\n                )?;\n            }\n        },\n        RustModuleKind::CppNamespace { .. } => {\n            let cpp_item = database\n                .source_cpp_item(&module.id)?\n                .ok_or_else(|| err_msg(\"source cpp item not found\"))?\n                .item\n                .as_namespace_ref()\n                .ok_or_else(|| err_msg(\"invalid source cpp item type\"))?;\n            let cpp_path_text = wrap_inline_cpp_code(&cpp_item.path.to_cpp_pseudo_code());\n            write!(output, \"C++ namespace: {}\", cpp_path_text)?;\n        }\n        RustModuleKind::CppNestedTypes { .. } => {\n            let cpp_item = database\n                .source_cpp_item(&module.id)?\n                .ok_or_else(|| err_msg(\"source cpp item not found\"))?\n                .item\n                .as_type_ref()\n                .ok_or_else(|| err_msg(\"invalid source cpp item type\"))?;\n            let cpp_path_text = wrap_inline_cpp_code(&cpp_item.path.to_cpp_pseudo_code());\n            write!(output, \"C++ type: {}\", cpp_path_text)?;\n        }\n    };\n    Ok(output)\n"]], "pred": {"ppl": 2.35451078414917, "ppl_lower": 2.6875011920928955, "ppl/lowercase_ppl": -1.1544712986597299, "ppl/zlib": 0.0012994430514718946, "Min_5.0% Prob": 7.414383826717254, "Min_10.0% Prob": 5.533803894406273, "Min_20.0% Prob": 3.7955225989932107, "Min_30.0% Prob": 2.7592966927107048, "Min_40.0% Prob": 2.1215906257608106, "Min_50.0% Prob": 1.7095447192589441, "Min_60.0% Prob": 1.4268191515285737}}
{"hexsha": "d3cb1caf0f4985c176855d204e8bcd8abc4de32e", "ext": "rs", "lang": "Rust", "content": "fn generic_example_struct2() {\n    let arg = GenericExampleStruct {\n        a: 123 as i32,\n        b: 456 as i32,\n    };\n\n    let expected_ast = ASTNode::from(ASTAggregate {\n        context: b\"genfoo2\",\n        name: b\"GenericExampleStruct\".to_vec(),\n        elems: vec![\n            ASTNode::from(ASTPrimitive {\n                context: b\"a\",\n                type_name: b\"int\",\n                data: 123u32.to_le_bytes().to_vec(),\n            }),\n            ASTNode::from(ASTPrimitive {\n                context: b\"b\",\n                type_name: b\"int\",\n                data: 456u32.to_le_bytes().to_vec(),\n            }),\n        ],\n        is_completed: true,\n    });\n    digestible_test_case_ast(\"genfoo2\", &arg, expected_ast.clone());\n    assert_eq!(\n        arg.digest32::<MerlinTranscript>(b\"genfoo2\"),\n        [\n            27, 164, 2, 106, 152, 28, 209, 36, 245, 234, 252, 175, 99, 43, 159, 210, 187, 204, 78,\n            238, 220, 43, 143, 239, 232, 89, 245, 87, 170, 14, 217, 198\n        ]\n    );\n\n    let arg2 = GenericExampleStruct {\n        a: Some(123 as i32),\n        b: Some(456 as i32),\n    };\n\n    digestible_test_case_ast(\"genfoo2\", &arg2, expected_ast);\n    assert_eq!(\n        arg2.digest32::<MerlinTranscript>(b\"genfoo2\"),\n        [\n            27, 164, 2, 106, 152, 28, 209, 36, 245, 234, 252, 175, 99, 43, 159, 210, 187, 204, 78,\n            238, 220, 43, 143, 239, 232, 89, 245, 87, 170, 14, 217, 198\n        ]\n    );\n}", "item_id": 9, "repo": "mccobr/mobilecoin", "file": "crypto/digestible/derive/test/tests/behavior.rs", "last_update_at": "2021-08-19T00:43:55+00:00", "question_id": "d3cb1caf0f4985c176855d204e8bcd8abc4de32e_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn generic_example_struct2() {\n    let arg = GenericExampleStruct {\n        a: 123 as i32,\n        b: 456 as i32,\n    };\n    let expected_ast = ASTNode::from(ASTAggregate {\n        context: b\"genfoo2\",\n        name: b\"GenericExampleStruct\".to_vec(),\n        elems: vec![\n            ASTNode::from(ASTPrimitive {\n                context: b\"a\",\n                type_name: b\"int\",\n                data: 123u32.to_le_bytes().to_vec(),\n            }),\n            ASTNode::from(ASTPrimitive {\n                context: b\"b\",\n                type_name: b\"int\",\n                data: 456u32.to_le_bytes().to_vec(),\n            }),\n        ],\n        is_completed: true,\n    });\n    digestible_test_case_ast(\"genfoo2\", &arg, expected_ast.clone());\n    assert_eq!(\n        arg.digest32::<MerlinTranscript>(b\"genfoo2\"),\n        [\n            27, 164, 2, 106, 152, 28, 209, 36, 245, 234, 252, 175, 99, 43, 159, 210, 187, 204, 78,\n            238, 220, 43, 143, 239, 232, 89, 245, 87, 170, 14, 217, 198\n        ]\n    );\n    let arg2 = GenericExampleStruct {\n        a: Some(123 as i32),\n        b: Some(456 as i32),\n    };\n    digestible_test_case_ast(\"genfoo2\", &arg2, expected_ast);\n    assert_eq!(\n        arg2.digest32::<MerlinTranscript>(b\"genfoo2\"),\n        [\n            27, 164, 2, 106, 152, 28, 209, 36, 245, 234, 252, 175, 99, 43, 159, 210, 187, 204, 78,\n            238, 220, 43, 143, 239, 232, 89, 245, 87, 170, 14, 217, 198\n        ]\n    );\n"]], "pred": {"ppl": 2.0320310592651367, "ppl_lower": 2.211886167526245, "ppl/lowercase_ppl": -1.1196128666209926, "ppl/zlib": 0.0015215360829846471, "Min_5.0% Prob": 6.115670723073623, "Min_10.0% Prob": 4.373585777006287, "Min_20.0% Prob": 3.136278446169867, "Min_30.0% Prob": 2.3256136222162107, "Min_40.0% Prob": 1.7709280400118534, "Min_50.0% Prob": 1.419583957662563, "Min_60.0% Prob": 1.1833492119508067}}
{"hexsha": "1262a6640cc8f605bd84f0df1f64eca2df723402", "ext": "rs", "lang": "Rust", "content": "fn contract_map() -> ContractMap<TxContext> {\n\tlet mut contract_map = ContractMap::new();\n\tcontract_map.register_contract(\n\t\t\"file:../output/adder.wasm\",\n\t\tBox::new(|context| Box::new(AdderImpl::new(context))),\n\t);\n\tcontract_map\n}", "item_id": 0, "repo": "AtlanticBridge/brandywine-bridge", "file": "packages/erd-contracts/egld_holding/tests/mandos_test.rs", "last_update_at": "2021-07-13T20:52:45+00:00", "question_id": "1262a6640cc8f605bd84f0df1f64eca2df723402_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn contract_map() -> ContractMap<TxContext> {\n\tlet mut contract_map = ContractMap::new();\n\tcontract_map.register_contract(\n\t\t\"file:../output/adder.wasm\",\n\t\tBox::new(|context| Box::new(AdderImpl::new(context))),\n\t);\n\tcontract_map\n"]], "pred": {"ppl": 3.2385218143463135, "ppl_lower": 5.015796184539795, "ppl/lowercase_ppl": -1.3722822285205303, "ppl/zlib": 0.007731032865523526, "Min_5.0% Prob": 9.038609266281128, "Min_10.0% Prob": 7.396464169025421, "Min_20.0% Prob": 4.9693643766291, "Min_30.0% Prob": 3.704184495485746, "Min_40.0% Prob": 2.8830991089344025, "Min_50.0% Prob": 2.348559032786976, "Min_60.0% Prob": 1.9668923955199853}}
{"hexsha": "efa3e506cba735b860040230e5b566e8ff96b2f2", "ext": "rs", "lang": "Rust", "content": "fn cmd_reindex1() -> Result<i32> {\n    let bc1 = Blockchain::new2()?;\n    let utxo_set = UTXOSet { blockchain: bc1 };\n\n\n    utxo_set.reindex()?;\n    utxo_set.count_transactions1()\n}", "item_id": 3, "repo": "RedStoneCoin/redstone-poc", "file": "src/cli.rs", "last_update_at": "2021-06-15T18:40:28+00:00", "question_id": "efa3e506cba735b860040230e5b566e8ff96b2f2_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn cmd_reindex1() -> Result<i32> {\n    let bc1 = Blockchain::new2()?;\n    let utxo_set = UTXOSet { blockchain: bc1 };\n    utxo_set.reindex()?;\n    utxo_set.count_transactions1()\n"]], "pred": {"ppl": 5.411281108856201, "ppl_lower": 6.698169231414795, "ppl/lowercase_ppl": -1.1263548456594004, "ppl/zlib": 0.012235404845506545, "Min_5.0% Prob": 8.75978934764862, "Min_10.0% Prob": 7.802897751331329, "Min_20.0% Prob": 6.443317338824272, "Min_30.0% Prob": 5.104849805434545, "Min_40.0% Prob": 4.094580387696624, "Min_50.0% Prob": 3.319736180509009, "Min_60.0% Prob": 2.80981581947025}}
{"hexsha": "ad061bb2e83d69c1a356f286feb48ee1a994c11a", "ext": "rs", "lang": "Rust", "content": "fn bench(f: fn()) {\n    let t0 = time::Instant::now();\n    let ret = f();\n    println!(\"time used {:?}\", time::Instant::now().duration_since(t0));\n\n    ret\n}", "item_id": 0, "repo": "Fadi88/AoC", "file": "2021/day25/main.rs", "last_update_at": "2021-12-24T17:03:41+00:00", "question_id": "ad061bb2e83d69c1a356f286feb48ee1a994c11a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bench(f: fn()) {\n    let t0 = time::Instant::now();\n    let ret = f();\n    println!(\"time used {:?}\", time::Instant::now().duration_since(t0));\n    ret\n"]], "pred": {"ppl": 3.2108871936798096, "ppl_lower": 3.7591261863708496, "ppl/lowercase_ppl": -1.1351331850259647, "ppl/zlib": 0.009561862977694603, "Min_5.0% Prob": 8.697524070739746, "Min_10.0% Prob": 6.819972324371338, "Min_20.0% Prob": 4.76943978396329, "Min_30.0% Prob": 3.629840710583855, "Min_40.0% Prob": 2.8733091963374098, "Min_50.0% Prob": 2.3162644983365617, "Min_60.0% Prob": 1.985803648172056}}
{"hexsha": "bc16bef8b5259cd706f1d32c6c92af27a34bed17", "ext": "rs", "lang": "Rust", "content": "async fn run_loop(client: &mut Client, config: Config) -> anyhow::Result<()> {\n    let (mqtt_sender, mqtt_receiver) = mpsc::unbounded_channel();\n    let (mqtt_event_sender, _) = broadcast::channel(10);\n    let (state_sender, state_receiver) = mpsc::unbounded_channel();\n\n    let mut mqtt_worker = MqttWorker::new(client, mqtt_receiver, mqtt_event_sender.clone());\n    let mut hass_discovery_worker = HomeAssistantWorker::new(mqtt_sender.clone());\n    let mut state = State::new(mqtt_sender.clone(), state_receiver);\n    let mut idle_module = IdleModule::new(state_sender.clone());\n    let mut backlight_module = if let Some(backlight) = config.modules.backlight {\n        get_backlight_module(state_sender.clone(), mqtt_event_sender.subscribe(), backlight)\n    }else {\n        Box::new(EmptyWorker) as Box<dyn LocalWorker>\n    };\n    let mut notifications_module = NotificationsModule::new(mqtt_event_sender.subscribe(), mqtt_sender);\n    let mut sensors_module = SensorsModule::new(state_sender.clone());\n\n    tokio::try_join!(\n        mqtt_worker.run(&config),\n        hass_discovery_worker.run(&config),\n        state.run(&config),\n        idle_module.run(&config),\n        backlight_module.run(&config),\n        notifications_module.run(&config),\n        sensors_module.run(&config),\n    )?;\n\n    Ok(())\n}", "item_id": 3, "repo": "instance-id/desktop2mqtt", "file": "src/main.rs", "last_update_at": "2021-03-22T03:06:34+00:00", "question_id": "bc16bef8b5259cd706f1d32c6c92af27a34bed17_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn run_loop(client: &mut Client, config: Config) -> anyhow::Result<()> {\n    let (mqtt_sender, mqtt_receiver) = mpsc::unbounded_channel();\n    let (mqtt_event_sender, _) = broadcast::channel(10);\n    let (state_sender, state_receiver) = mpsc::unbounded_channel();\n    let mut mqtt_worker = MqttWorker::new(client, mqtt_receiver, mqtt_event_sender.clone());\n    let mut hass_discovery_worker = HomeAssistantWorker::new(mqtt_sender.clone());\n    let mut state = State::new(mqtt_sender.clone(), state_receiver);\n    let mut idle_module = IdleModule::new(state_sender.clone());\n    let mut backlight_module = if let Some(backlight) = config.modules.backlight {\n        get_backlight_module(state_sender.clone(), mqtt_event_sender.subscribe(), backlight)\n    }else {\n        Box::new(EmptyWorker) as Box<dyn LocalWorker>\n    };\n    let mut notifications_module = NotificationsModule::new(mqtt_event_sender.subscribe(), mqtt_sender);\n    let mut sensors_module = SensorsModule::new(state_sender.clone());\n    tokio::try_join!(\n        mqtt_worker.run(&config),\n        hass_discovery_worker.run(&config),\n        state.run(&config),\n        idle_module.run(&config),\n        backlight_module.run(&config),\n        notifications_module.run(&config),\n        sensors_module.run(&config),\n    )?;\n    Ok(())\n"]], "pred": {"ppl": 2.0018436908721924, "ppl_lower": 2.354294776916504, "ppl/lowercase_ppl": -1.2336550351973181, "ppl/zlib": 0.0015187496747428551, "Min_5.0% Prob": 6.905468622843425, "Min_10.0% Prob": 5.077624440193176, "Min_20.0% Prob": 3.1245358803692986, "Min_30.0% Prob": 2.2363685411401093, "Min_40.0% Prob": 1.7178380251017928, "Min_50.0% Prob": 1.3856723192800706, "Min_60.0% Prob": 1.1573693298767338}}
{"hexsha": "483c33e770ea13fd7193c63dfa55bf751fc2b58b", "ext": "rs", "lang": "Rust", "content": "fn player_collides_with_enemy_above() {\n    let mut game = TestableGame::from_strings(vec![\n        \".E..\",\n        \".@..\",\n        \"....\"\n    ]);\n\n    game.input.simulate_move(Up);\n    game.verify_next_tiles(vec![\n        \".E..\",\n        \".@..\",\n        \"....\"\n    ]);\n}", "item_id": 2, "repo": "wolfgang/srl", "file": "src/_tests/feature/player_enemy_collision_test.rs", "last_update_at": "2021-05-31T12:29:47+00:00", "question_id": "483c33e770ea13fd7193c63dfa55bf751fc2b58b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn player_collides_with_enemy_above() {\n    let mut game = TestableGame::from_strings(vec![\n        \".E..\",\n        \".@..\",\n        \"....\"\n    ]);\n    game.input.simulate_move(Up);\n    game.verify_next_tiles(vec![\n        \".E..\",\n        \".@..\",\n        \"....\"\n    ]);\n"]], "pred": {"ppl": 4.517856121063232, "ppl_lower": 5.430187702178955, "ppl/lowercase_ppl": -1.1219705215446125, "ppl/zlib": 0.009425234823903271, "Min_5.0% Prob": 9.189414501190186, "Min_10.0% Prob": 7.902839326858521, "Min_20.0% Prob": 6.157071757316589, "Min_30.0% Prob": 4.670270693302155, "Min_40.0% Prob": 3.6588767573237417, "Min_50.0% Prob": 3.000907119214535, "Min_60.0% Prob": 2.525729189813137}}
{"hexsha": "a94f068c27303d2b256fd2ab7da51e2c0b43988c", "ext": "rs", "lang": "Rust", "content": "fn msb_bits_to_byte(bits: &[bool]) -> u8 {\n    // bits is encoded msb -> lsb\n    debug_assert_eq!(8, bits.len());\n    let mut result: u8 = 0;\n    let mut mask: u8 = 0x80; // msb set\n    for i in 0..bits.len() {\n        if bits[i] {\n            result |= mask;\n        }\n        if i < bits.len() - 1 {\n            mask >>= 1;\n        }\n    }\n    result\n}", "item_id": 11, "repo": "ngeor/rusty-basic", "file": "src/variant/bits.rs", "last_update_at": "2021-05-26T13:20:31+00:00", "question_id": "a94f068c27303d2b256fd2ab7da51e2c0b43988c_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn msb_bits_to_byte(bits: &[bool]) -> u8 {\n    // bits is encoded msb -> lsb\n    debug_assert_eq!(8, bits.len());\n    let mut result: u8 = 0;\n    let mut mask: u8 = 0x80; // msb set\n    for i in 0..bits.len() {\n        if bits[i] {\n            result |= mask;\n        }\n        if i < bits.len() - 1 {\n            mask >>= 1;\n        }\n    }\n    result\n"]], "pred": {"ppl": 2.112083911895752, "ppl_lower": 2.112083911895752, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0037761368488182095, "Min_5.0% Prob": 6.582456668217977, "Min_10.0% Prob": 4.888298676564143, "Min_20.0% Prob": 3.3591789448702776, "Min_30.0% Prob": 2.450760254045812, "Min_40.0% Prob": 1.8682300858876921, "Min_50.0% Prob": 1.4983446702523076, "Min_60.0% Prob": 1.2493051469146488}}
{"hexsha": "ca58661d0ee5543b6957342daa3e5bc870a956d7", "ext": "rs", "lang": "Rust", "content": "pub fn multiple_two_sum(xs: &[f64]) -> (f64, f64) {\n        let (mut r0, mut r1) = (*xs.get(0).unwrap_or(&0.), 0.);\n        for &x in xs.iter() {\n            let (s, e) = two_sum(r0, x);\n            r0 = s;\n            r1 += e;\n        }\n        (r0, r1)\n    }", "item_id": 7, "repo": "to-omer/competitive-library", "file": "crates/competitive/src/num/quad_double.rs", "last_update_at": "2021-03-16T07:51:02+00:00", "question_id": "ca58661d0ee5543b6957342daa3e5bc870a956d7_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn multiple_two_sum(xs: &[f64]) -> (f64, f64) {\n        let (mut r0, mut r1) = (*xs.get(0).unwrap_or(&0.), 0.);\n        for &x in xs.iter() {\n            let (s, e) = two_sum(r0, x);\n            r0 = s;\n            r1 += e;\n        }\n        (r0, r1)\n"]], "pred": {"ppl": 2.459061861038208, "ppl_lower": 2.459061861038208, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.005520122208021727, "Min_5.0% Prob": 8.819339179992676, "Min_10.0% Prob": 6.233535051345825, "Min_20.0% Prob": 3.930815100669861, "Min_30.0% Prob": 2.8965265531750286, "Min_40.0% Prob": 2.202778470257054, "Min_50.0% Prob": 1.7996856974143731, "Min_60.0% Prob": 1.4951962812169306}}
{"hexsha": "1358f340c5aec7a699671f9f4d1cb84502ffa41c", "ext": "rs", "lang": "Rust", "content": "async fn timer_task(mut t: r2r::Timer) -> Result<(), Box<dyn std::error::Error>> {\n    let mut x: i32 = 0;\n    loop {\n        let elapsed = t.tick().await?;\n        println!(\n            \"timer called ({}), {}us since last call\",\n            x,\n            elapsed.as_micros()\n        );\n\n        x += 1;\n        if x == 10 {\n            break;\n        }\n    }\n    Ok(())\n}", "item_id": 0, "repo": "midnightexigent/r2r", "file": "examples/wall_timer.rs", "last_update_at": "2021-09-30T02:54:54+00:00", "question_id": "1358f340c5aec7a699671f9f4d1cb84502ffa41c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn timer_task(mut t: r2r::Timer) -> Result<(), Box<dyn std::error::Error>> {\n    let mut x: i32 = 0;\n    loop {\n        let elapsed = t.tick().await?;\n        println!(\n            \"timer called ({}), {}us since last call\",\n            x,\n            elapsed.as_micros()\n        );\n        x += 1;\n        if x == 10 {\n            break;\n        }\n    }\n    Ok(())\n"]], "pred": {"ppl": 2.6843974590301514, "ppl_lower": 3.4030580520629883, "ppl/lowercase_ppl": -1.240231556040201, "ppl/zlib": 0.004330948652335482, "Min_5.0% Prob": 7.681233962376912, "Min_10.0% Prob": 5.98903242746989, "Min_20.0% Prob": 4.131568894386292, "Min_30.0% Prob": 3.073684926095762, "Min_40.0% Prob": 2.4190654386492336, "Min_50.0% Prob": 1.971321294317022, "Min_60.0% Prob": 1.6498637683689594}}
{"hexsha": "3a92454c466f60efe00cd40ce6e865efd262048e", "ext": "rs", "lang": "Rust", "content": "fn try_insert(&self, db: &Database) -> Result<String, Box<dyn Error>> where Self: Serialize {\n        let coll = (*db).collection(Self::collection_name());\n        let new_doc = self.as_document();\n        coll.insert_one(new_doc, None)?;\n        return Ok(String::from(self.primary_key()));\n    }", "item_id": 1, "repo": "ericpan64/DuGuo-Chinese-Reading-App", "file": "app/src/lib.rs", "last_update_at": "2021-05-19T01:15:43+00:00", "question_id": "3a92454c466f60efe00cd40ce6e865efd262048e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn try_insert(&self, db: &Database) -> Result<String, Box<dyn Error>> where Self: Serialize {\n        let coll = (*db).collection(Self::collection_name());\n        let new_doc = self.as_document();\n        coll.insert_one(new_doc, None)?;\n        return Ok(String::from(self.primary_key()));\n"]], "pred": {"ppl": 3.934662342071533, "ppl_lower": 6.212398529052734, "ppl/lowercase_ppl": -1.3334162871293622, "ppl/zlib": 0.006682073508835204, "Min_5.0% Prob": 8.205645203590393, "Min_10.0% Prob": 7.028966426849365, "Min_20.0% Prob": 5.46417776743571, "Min_30.0% Prob": 4.170466317070855, "Min_40.0% Prob": 3.312867353359858, "Min_50.0% Prob": 2.7139386590984134, "Min_60.0% Prob": 2.2823024534240917}}
{"hexsha": "0651ab0dc08f3f2d1b5d25023fff11df1c0a25ee", "ext": "rs", "lang": "Rust", "content": "pub fn get_scaling(out: &mut Vec3, mat: &Mat4) -> Vec3 {\n    let mut vec_1: Vec3 = [0_f32; 3];\n    vec_1[0] = mat[0]; // m11\n    vec_1[1] = mat[1]; // m12\n    vec_1[2] = mat[2]; // m13\n    \n    let mut vec_2: Vec3 = [0_f32; 3];\n    vec_2[0] = mat[4]; // m21\n    vec_2[1] = mat[5]; // m22\n    vec_2[2] = mat[6]; // m23\n    \n    let mut vec_3: Vec3 = [0_f32; 3];\n    vec_3[0] = mat[8]; // m31\n    vec_3[1] = mat[9]; // m32\n    vec_3[2] = mat[10]; // m33\n\n    out[0] = hypot(&vec_1);\n    out[1] = hypot(&vec_2);\n    out[2] = hypot(&vec_3);\n\n    *out\n}", "item_id": 26, "repo": "DrAirRock/gl-matrix", "file": "src/mat4.rs", "last_update_at": "2021-05-30T21:20:41+00:00", "question_id": "0651ab0dc08f3f2d1b5d25023fff11df1c0a25ee_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_scaling(out: &mut Vec3, mat: &Mat4) -> Vec3 {\n    let mut vec_1: Vec3 = [0_f32; 3];\n    vec_1[0] = mat[0]; // m11\n    vec_1[1] = mat[1]; // m12\n    vec_1[2] = mat[2]; // m13\n    let mut vec_2: Vec3 = [0_f32; 3];\n    vec_2[0] = mat[4]; // m21\n    vec_2[1] = mat[5]; // m22\n    vec_2[2] = mat[6]; // m23\n    let mut vec_3: Vec3 = [0_f32; 3];\n    vec_3[0] = mat[8]; // m31\n    vec_3[1] = mat[9]; // m32\n    vec_3[2] = mat[10]; // m33\n    out[0] = hypot(&vec_1);\n    out[1] = hypot(&vec_2);\n    out[2] = hypot(&vec_3);\n    *out\n"]], "pred": {"ppl": 1.5314068794250488, "ppl_lower": 1.551975965499878, "ppl/lowercase_ppl": -1.031305737880471, "ppl/zlib": 0.002029461152059454, "Min_5.0% Prob": 5.875656349318368, "Min_10.0% Prob": 3.8559553335452903, "Min_20.0% Prob": 2.101267761219356, "Min_30.0% Prob": 1.423143963731656, "Min_40.0% Prob": 1.0636955395664514, "Min_50.0% Prob": 0.8546574635836645, "Min_60.0% Prob": 0.7101253578853715}}
{"hexsha": "b979e82bfcd8d6891b34c6a52fa9a5baf0c5bd1f", "ext": "rs", "lang": "Rust", "content": "fn test_enum() {\n    let u = E::Unit;\n    let expected = vec![0, 0, 0, 0];\n    assert_eq!(to_bytes(&u).unwrap(), expected);\n    is_same(u);\n\n    let n = E::Newtype(1);\n    let expected = vec![1, 0, 0, 0, 1, 0];\n    assert_eq!(to_bytes(&n).unwrap(), expected);\n    is_same(n);\n\n    let t = E::Tuple(1, 2);\n    let expected = vec![2, 0, 0, 0, 1, 0, 2, 0];\n    assert_eq!(to_bytes(&t).unwrap(), expected);\n    is_same(t);\n\n    let s = E::Struct { a: 1 };\n    let expected = vec![3, 0, 0, 0, 1, 0, 0, 0];\n    assert_eq!(to_bytes(&s).unwrap(), expected);\n    is_same(s);\n}", "item_id": 1, "repo": "tcoinx/Libra", "file": "common/lcs/tests/serde.rs", "last_update_at": "2021-11-20T02:17:28+00:00", "question_id": "b979e82bfcd8d6891b34c6a52fa9a5baf0c5bd1f_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_enum() {\n    let u = E::Unit;\n    let expected = vec![0, 0, 0, 0];\n    assert_eq!(to_bytes(&u).unwrap(), expected);\n    is_same(u);\n    let n = E::Newtype(1);\n    let expected = vec![1, 0, 0, 0, 1, 0];\n    assert_eq!(to_bytes(&n).unwrap(), expected);\n    is_same(n);\n    let t = E::Tuple(1, 2);\n    let expected = vec![2, 0, 0, 0, 1, 0, 2, 0];\n    assert_eq!(to_bytes(&t).unwrap(), expected);\n    is_same(t);\n    let s = E::Struct { a: 1 };\n    let expected = vec![3, 0, 0, 0, 1, 0, 0, 0];\n    assert_eq!(to_bytes(&s).unwrap(), expected);\n    is_same(s);\n"]], "pred": {"ppl": 1.5891706943511963, "ppl_lower": 1.7188796997070312, "ppl/lowercase_ppl": -1.1693833178076405, "ppl/zlib": 0.0023277000215295223, "Min_5.0% Prob": 6.226998686790466, "Min_10.0% Prob": 3.9110424184799193, "Min_20.0% Prob": 2.264939718386706, "Min_30.0% Prob": 1.5415341611225883, "Min_40.0% Prob": 1.1611177734668972, "Min_50.0% Prob": 0.9290088116256303, "Min_60.0% Prob": 0.7737027454497893}}
{"hexsha": "69a77231ebcd47efafab8fb6ba15288776b6efdd", "ext": "rs", "lang": "Rust", "content": "fn sequence<'a, T>(token_stream: &mut Peekable<T>) -> Result<Ast<'a>, Error<'a>>\n    where T: Iterator<Item=Token<'a>>\n{\n    let mut seq: Vec<Ast> = vec![];\n\n    loop {\n        seq.push(\n            match token_stream.peek() {\n                Some(&Token::Literal(text)) => { token_stream.next(); Ast::Literal(text) },\n                Some(&Token::Interpolation(_)) => {\n                    match token_stream.next() {\n                        Some(Token::Interpolation(name)) => Ast::Interpolation(name),\n                        _ => panic!(\"Outer match should guarantee match in inner match\"),\n                    }\n                },\n                Some(&Token::UnescapedInterpolation(_)) => {\n                    match token_stream.next() {\n                        Some(Token::UnescapedInterpolation(name)) => Ast::UnescapedInterpolation(name),\n                        _ => panic!(\"Outer match should guarantee match in inner match\"),\n                    }\n                },\n                Some(&Token::SectionOpener(..)) => section(token_stream)?,\n                Some(&Token::PartialInclude(..)) => {\n                    match token_stream.next() {\n                        Some(Token::PartialInclude(partial_name, root)) => {\n                            Ast::PartialInclude { partial_name, root }\n                        },\n                        _ => panic!(\"Outer match should guarantee match in inner match\"),\n                    }\n                },\n                _ => break\n            }\n        )\n    }\n\n    Ok(Ast::Sequence(seq))\n}", "item_id": 1, "repo": "maghoff/stache", "file": "libs/bart_derive/src/parser.rs", "last_update_at": "2021-03-05T14:44:14+00:00", "question_id": "69a77231ebcd47efafab8fb6ba15288776b6efdd_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn sequence<'a, T>(token_stream: &mut Peekable<T>) -> Result<Ast<'a>, Error<'a>>\n    where T: Iterator<Item=Token<'a>>\n{\n    let mut seq: Vec<Ast> = vec![];\n    loop {\n        seq.push(\n            match token_stream.peek() {\n                Some(&Token::Literal(text)) => { token_stream.next(); Ast::Literal(text) },\n                Some(&Token::Interpolation(_)) => {\n                    match token_stream.next() {\n                        Some(Token::Interpolation(name)) => Ast::Interpolation(name),\n                        _ => panic!(\"Outer match should guarantee match in inner match\"),\n                    }\n                },\n                Some(&Token::UnescapedInterpolation(_)) => {\n                    match token_stream.next() {\n                        Some(Token::UnescapedInterpolation(name)) => Ast::UnescapedInterpolation(name),\n                        _ => panic!(\"Outer match should guarantee match in inner match\"),\n                    }\n                },\n                Some(&Token::SectionOpener(..)) => section(token_stream)?,\n                Some(&Token::PartialInclude(..)) => {\n                    match token_stream.next() {\n                        Some(Token::PartialInclude(partial_name, root)) => {\n                            Ast::PartialInclude { partial_name, root }\n                        },\n                        _ => panic!(\"Outer match should guarantee match in inner match\"),\n                    }\n                },\n                _ => break\n            }\n        )\n    }\n    Ok(Ast::Sequence(seq))\n"]], "pred": {"ppl": 1.8623716831207275, "ppl_lower": 2.198608160018921, "ppl/lowercase_ppl": -1.2669028304633707, "ppl/zlib": 0.0015020550094914814, "Min_5.0% Prob": 6.536027264595032, "Min_10.0% Prob": 4.68565616607666, "Min_20.0% Prob": 2.9233973041176795, "Min_30.0% Prob": 2.044353158896168, "Min_40.0% Prob": 1.550213679531589, "Min_50.0% Prob": 1.2447129204822704, "Min_60.0% Prob": 1.0383386186595696}}
{"hexsha": "a8aedec168acbb2036abd6251d5b65493521da8e", "ext": "rs", "lang": "Rust", "content": "fn load_configuration(args: &ArgMatches<'_>) -> Result<config::Config, Error> {\n    let mut cfg = load_configuration_file(args)?;\n    // Override global.chain via command-line or environment.\n    if let Some(chain) = args.value_of(\"chain\") {\n        cfg.general.chain = chain.to_string();\n    }\n\n    // Override global.data_dir via command-line or environment.\n    if let Some(data_dir) = args.value_of_os(\"data-dir\") {\n        cfg.general.data_dir = PathBuf::from(data_dir);\n    }\n\n    // Override global.consistency_check via command-line.\n    if args.is_present(\"recover\") {\n        cfg.general.consistency_check = ConsistencyCheck::LoadChain;\n    }\n    // Override global.consistency_check via command-line.\n    if args.is_present(\"force-check\") {\n        if args.is_present(\"recover\") {\n            error!(\"--force-check is set, ignoring --recover\")\n        }\n        cfg.general.consistency_check = ConsistencyCheck::Full;\n    }\n\n    // Override network.endpoint via command-line or environment.\n    if let Some(endpoint) = args.value_of(\"node-endpoint\") {\n        cfg.network.endpoint = endpoint.to_string();\n    }\n\n    if cfg.network.endpoint != \"\" {\n        SocketAddr::from_str(&cfg.network.endpoint).map_err(|e| {\n            format_err!(\"Invalid network.endpoint '{}': {}\", cfg.network.endpoint, e)\n        })?;\n    }\n\n    // Override network.advertised_endpoint via command-line or environment.\n    if let Some(network_endpoint) = args.value_of(\"advertised-endpoint\") {\n        cfg.network.advertised_endpoint = network_endpoint.to_string();\n    }\n    if cfg.network.advertised_endpoint != \"\" {\n        SocketAddr::from_str(&cfg.network.advertised_endpoint).map_err(|e| {\n            format_err!(\n                \"Invalid network.advertised_endpoint '{}': {}\",\n                cfg.network.advertised_endpoint,\n                e\n            )\n        })?;\n    }\n\n    // Use default SRV record for the chain\n    if cfg.general.chain != \"dev\" && cfg.network.seed_pool == \"\" {\n        cfg.network.seed_pool =\n            format!(\"_stegos._tcp.{}.stegos.com\", cfg.general.chain).to_string();\n    }\n\n    if args.is_present(\"no-network\") {\n        cfg.network.min_connections = 0;\n        cfg.network.max_connections = 0;\n        cfg.network.readiness_threshold = 0;\n        cfg.network.seed_pool = String::from(\"\");\n    }\n\n    // Override global.prometheus_endpoint via command-line or environment.\n    if let Some(prometheus_endpoint) = args.value_of(\"prometheus-endpoint\") {\n        cfg.general.prometheus_endpoint = prometheus_endpoint.to_string();\n    }\n    if cfg.general.prometheus_endpoint != \"\" {\n        SocketAddr::from_str(&cfg.general.prometheus_endpoint).map_err(|e| {\n            format_err!(\n                \"Invalid prometheus_endpoint '{}': {}\",\n                cfg.general.prometheus_endpoint,\n                e\n            )\n        })?;\n    }\n\n    // Override global.api_endpoint via command-line or environment.\n    if let Some(api_endpoint) = args.value_of(\"api-endpoint\") {\n        cfg.general.api_endpoint = api_endpoint.to_string();\n    } else if cfg.general.api_endpoint != \"\" {\n        SocketAddr::from_str(&cfg.general.api_endpoint).map_err(|e| {\n            format_err!(\n                \"Invalid api_endpoint '{}': {}\",\n                &cfg.general.api_endpoint,\n                e\n            )\n        })?;\n    }\n\n    // Disable [node] sections.\n    if cfg.general.chain == \"mainnet\" && cfg.node != Default::default() {\n        return Err(format_err!(\n            \"Can't override [node] options for {}\",\n            cfg.general.chain\n        ));\n    }\n\n    if cfg.general.chain != \"mainnet\" {\n        enable_debug();\n    }\n\n    Ok(cfg)\n}", "item_id": 4, "repo": "vldm/stegos", "file": "src/bin/stegosd/main.rs", "last_update_at": "2021-12-31T14:17:51+00:00", "question_id": "a8aedec168acbb2036abd6251d5b65493521da8e_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn load_configuration(args: &ArgMatches<'_>) -> Result<config::Config, Error> {\n    let mut cfg = load_configuration_file(args)?;\n    // Override global.chain via command-line or environment.\n    if let Some(chain) = args.value_of(\"chain\") {\n        cfg.general.chain = chain.to_string();\n    }\n    // Override global.data_dir via command-line or environment.\n    if let Some(data_dir) = args.value_of_os(\"data-dir\") {\n        cfg.general.data_dir = PathBuf::from(data_dir);\n    }\n    // Override global.consistency_check via command-line.\n    if args.is_present(\"recover\") {\n        cfg.general.consistency_check = ConsistencyCheck::LoadChain;\n    }\n    // Override global.consistency_check via command-line.\n    if args.is_present(\"force-check\") {\n        if args.is_present(\"recover\") {\n            error!(\"--force-check is set, ignoring --recover\")\n        }\n        cfg.general.consistency_check = ConsistencyCheck::Full;\n    }\n    // Override network.endpoint via command-line or environment.\n    if let Some(endpoint) = args.value_of(\"node-endpoint\") {\n        cfg.network.endpoint = endpoint.to_string();\n    }\n    if cfg.network.endpoint != \"\" {\n        SocketAddr::from_str(&cfg.network.endpoint).map_err(|e| {\n            format_err!(\"Invalid network.endpoint '{}': {}\", cfg.network.endpoint, e)\n        })?;\n    }\n    // Override network.advertised_endpoint via command-line or environment.\n    if let Some(network_endpoint) = args.value_of(\"advertised-endpoint\") {\n        cfg.network.advertised_endpoint = network_endpoint.to_string();\n    }\n    if cfg.network.advertised_endpoint != \"\" {\n        SocketAddr::from_str(&cfg.network.advertised_endpoint).map_err(|e| {\n            format_err!(\n                \"Invalid network.advertised_endpoint '{}': {}\",\n                cfg.network.advertised_endpoint,\n                e\n            )\n        })?;\n    }\n    // Use default SRV record for the chain\n    if cfg.general.chain != \"dev\" && cfg.network.seed_pool == \"\" {\n        cfg.network.seed_pool =\n            format!(\"_stegos._tcp.{}.stegos.com\", cfg.general.chain).to_string();\n    }\n    if args.is_present(\"no-network\") {\n        cfg.network.min_connections = 0;\n        cfg.network.max_connections = 0;\n        cfg.network.readiness_threshold = 0;\n        cfg.network.seed_pool = String::from(\"\");\n    }\n    // Override global.prometheus_endpoint via command-line or environment.\n    if let Some(prometheus_endpoint) = args.value_of(\"prometheus-endpoint\") {\n        cfg.general.prometheus_endpoint = prometheus_endpoint.to_string();\n    }\n    if cfg.general.prometheus_endpoint != \"\" {\n        SocketAddr::from_str(&cfg.general.prometheus_endpoint).map_err(|e| {\n            format_err!(\n                \"Invalid prometheus_endpoint '{}': {}\",\n                cfg.general.prometheus_endpoint,\n                e\n            )\n        })?;\n    }\n    // Override global.api_endpoint via command-line or environment.\n    if let Some(api_endpoint) = args.value_of(\"api-endpoint\") {\n        cfg.general.api_endpoint = api_endpoint.to_string();\n    } else if cfg.general.api_endpoint != \"\" {\n        SocketAddr::from_str(&cfg.general.api_endpoint).map_err(|e| {\n            format_err!(\n                \"Invalid api_endpoint '{}': {}\",\n                &cfg.general.api_endpoint,\n                e\n            )\n        })?;\n    }\n    // Disable [node] sections.\n    if cfg.general.chain == \"mainnet\" && cfg.node != Default::default() {\n        return Err(format_err!(\n            \"Can't override [node] options for {}\",\n            cfg.general.chain\n        ));\n    }\n    if cfg.general.chain != \"mainnet\" {\n        enable_debug();\n    }\n    Ok(cfg)\n"]], "pred": {"ppl": 1.6550977230072021, "ppl_lower": 1.753827691078186, "ppl/lowercase_ppl": -1.114993432643192, "ppl/zlib": 0.000580483933433265, "Min_5.0% Prob": 6.263966214423086, "Min_10.0% Prob": 4.265298765079648, "Min_20.0% Prob": 2.4347255191966597, "Min_30.0% Prob": 1.6692843154754513, "Min_40.0% Prob": 1.2566653054576449, "Min_50.0% Prob": 1.0077740650308735, "Min_60.0% Prob": 0.840655612442331}}
{"hexsha": "54024b9093e75a208399f2dcc50e7cc066a971f7", "ext": "rs", "lang": "Rust", "content": "async fn prepare_amqp_chan(conn: &Connection) -> Channel {\n    let chan = conn\n        .create_channel()\n        .await\n        .expect(\"unable to create channel\");\n    chan.exchange_declare(\n        \"test\",\n        ExchangeKind::Topic,\n        ExchangeDeclareOptions {\n            durable: true,\n            ..Default::default()\n        },\n        Default::default(),\n    )\n    .await\n    .expect(\"unable to declare exchange\");\n    chan.queue_declare(\n        \"test_queue\",\n        QueueDeclareOptions {\n            exclusive: true,\n            ..Default::default()\n        },\n        Default::default(),\n    )\n    .await\n    .expect(\"unable to create queue\");\n    chan.queue_bind(\n        \"test_queue\",\n        \"test\",\n        \"#\",\n        QueueBindOptions::default(),\n        Default::default(),\n    )\n    .await\n    .expect(\"unable to bind queue to exchange\");\n    chan\n}", "item_id": 1, "repo": "suisei-cn/stargazer-rs", "file": "src/lib/collector/tests.rs", "last_update_at": "2021-07-03T23:02:42+00:00", "question_id": "54024b9093e75a208399f2dcc50e7cc066a971f7_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn prepare_amqp_chan(conn: &Connection) -> Channel {\n    let chan = conn\n        .create_channel()\n        .await\n        .expect(\"unable to create channel\");\n    chan.exchange_declare(\n        \"test\",\n        ExchangeKind::Topic,\n        ExchangeDeclareOptions {\n            durable: true,\n            ..Default::default()\n        },\n        Default::default(),\n    )\n    .await\n    .expect(\"unable to declare exchange\");\n    chan.queue_declare(\n        \"test_queue\",\n        QueueDeclareOptions {\n            exclusive: true,\n            ..Default::default()\n        },\n        Default::default(),\n    )\n    .await\n    .expect(\"unable to create queue\");\n    chan.queue_bind(\n        \"test_queue\",\n        \"test\",\n        \"#\",\n        QueueBindOptions::default(),\n        Default::default(),\n    )\n    .await\n    .expect(\"unable to bind queue to exchange\");\n    chan\n"]], "pred": {"ppl": 1.562668800354004, "ppl_lower": 1.8823717832565308, "ppl/lowercase_ppl": -1.416979100863388, "ppl/zlib": 0.0015608221294402841, "Min_5.0% Prob": 5.6969172557195025, "Min_10.0% Prob": 3.8003532787164054, "Min_20.0% Prob": 2.1584333236120186, "Min_30.0% Prob": 1.4849707406718988, "Min_40.0% Prob": 1.1197216017830252, "Min_50.0% Prob": 0.895771593758611, "Min_60.0% Prob": 0.7458127342998957}}
{"hexsha": "c73d8822d7b3e13fe4df61de9075755154e39cac", "ext": "rs", "lang": "Rust", "content": "pub fn circular_tuple_windows<I, T>(iter: I) -> CircularTupleWindows<I, T>\n    where I: Iterator<Item = T::Item> + Clone + ExactSizeIterator,\n          T: TupleCollect + Clone,\n          T::Item: Clone\n{\n    let len = iter.len();\n    let iter = tuple_windows(iter.cycle()).take(len);\n\n    CircularTupleWindows {\n        iter,\n        phantom_data: PhantomData{}\n    }\n}", "item_id": 1, "repo": "vadixidav/itertools", "file": "src/tuple_impl.rs", "last_update_at": "2021-03-26T10:30:54+00:00", "question_id": "c73d8822d7b3e13fe4df61de9075755154e39cac_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn circular_tuple_windows<I, T>(iter: I) -> CircularTupleWindows<I, T>\n    where I: Iterator<Item = T::Item> + Clone + ExactSizeIterator,\n          T: TupleCollect + Clone,\n          T::Item: Clone\n{\n    let len = iter.len();\n    let iter = tuple_windows(iter.cycle()).take(len);\n    CircularTupleWindows {\n        iter,\n        phantom_data: PhantomData{}\n    }\n"]], "pred": {"ppl": 3.2339301109313965, "ppl_lower": 5.521203994750977, "ppl/lowercase_ppl": -1.4557371085601323, "ppl/zlib": 0.005408747235950977, "Min_5.0% Prob": 9.738821824391684, "Min_10.0% Prob": 7.889244278271993, "Min_20.0% Prob": 4.868673281669617, "Min_30.0% Prob": 3.6896686618392533, "Min_40.0% Prob": 2.8650595331192017, "Min_50.0% Prob": 2.318847290580235, "Min_60.0% Prob": 1.96316088895003}}
{"hexsha": "a5a86739eb86fbc35e209641a008e5e7e3b0c001", "ext": "rs", "lang": "Rust", "content": "fn test_standalone_short_works_with_verbatim_casing() {\n    #[derive(Clap, Debug, PartialEq)]\n    struct Opt {\n        #[clap(rename_all = \"verbatim\", short)]\n        _foo: bool,\n    }\n\n    assert_eq!(Opt { _foo: true }, Opt::parse_from(&[\"test\", \"-_\"]));\n}", "item_id": 13, "repo": "omar25h/clap", "file": "clap_derive/tests/argument_naming.rs", "last_update_at": "2021-10-09T14:12:02+00:00", "question_id": "a5a86739eb86fbc35e209641a008e5e7e3b0c001_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_standalone_short_works_with_verbatim_casing() {\n    #[derive(Clap, Debug, PartialEq)]\n    struct Opt {\n        #[clap(rename_all = \"verbatim\", short)]\n        _foo: bool,\n    }\n    assert_eq!(Opt { _foo: true }, Opt::parse_from(&[\"test\", \"-_\"]));\n"]], "pred": {"ppl": 3.177887439727783, "ppl_lower": 4.5130767822265625, "ppl/lowercase_ppl": -1.3033708999963973, "ppl/zlib": 0.0060534903083738845, "Min_5.0% Prob": 8.727405548095703, "Min_10.0% Prob": 6.998826079898411, "Min_20.0% Prob": 4.92217388905977, "Min_30.0% Prob": 3.5766197956841568, "Min_40.0% Prob": 2.8478320170389977, "Min_50.0% Prob": 2.3189726676791906, "Min_60.0% Prob": 1.9311198851992857}}
{"hexsha": "2e07316562a67cdc60c0e202fc10c482fe4481e9", "ext": "rs", "lang": "Rust", "content": "pub fn get_total_duration(\n    start: chrono::DateTime<chrono::Utc>,\n    end: chrono::DateTime<chrono::Utc>,\n) -> Result<chrono::Duration, Error> {\n    let repo = get_repo()?;\n\n    let mut total_duration = chrono::Duration::seconds(0);\n\n    for task in repo.list_tasks()?.values() {\n        total_duration = total_duration.add(task.duration_between(start, end));\n    }\n\n    Ok(total_duration)\n}", "item_id": 7, "repo": "frapa/timers", "file": "src/lib.rs", "last_update_at": "2021-11-08T12:37:46+00:00", "question_id": "2e07316562a67cdc60c0e202fc10c482fe4481e9_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_total_duration(\n    start: chrono::DateTime<chrono::Utc>,\n    end: chrono::DateTime<chrono::Utc>,\n) -> Result<chrono::Duration, Error> {\n    let repo = get_repo()?;\n    let mut total_duration = chrono::Duration::seconds(0);\n    for task in repo.list_tasks()?.values() {\n        total_duration = total_duration.add(task.duration_between(start, end));\n    }\n    Ok(total_duration)\n"]], "pred": {"ppl": 2.3828227519989014, "ppl_lower": 3.3613409996032715, "ppl/lowercase_ppl": -1.3962453148667269, "ppl/zlib": 0.00417445103440753, "Min_5.0% Prob": 7.8404364585876465, "Min_10.0% Prob": 5.461901334615854, "Min_20.0% Prob": 3.730816286343795, "Min_30.0% Prob": 2.780097325642904, "Min_40.0% Prob": 2.1721465696509066, "Min_50.0% Prob": 1.7314829446488258, "Min_60.0% Prob": 1.4499961494916132}}
{"hexsha": "4e7ae383ca222b011940b511f5525d9e54488a4e", "ext": "rs", "lang": "Rust", "content": "fn run_build(project: String, database: &MysqlConnection) -> Result<(), Box<dyn Error>> {\n    println!(\"Building '{}'\", project);\n    let project_path = format!(\"data/projects/{}\", project);\n    let path = Path::new(&project_path);\n\n    let project_id = get_project_id(database, &project);\n\n    if path.exists() && path.is_dir() {\n        let settings_file_path = format!(\"{}/.drovah\", project_path);\n        let ci_settings_file = Path::new(&settings_file_path);\n        let settings_string = fs::read_to_string(ci_settings_file)?;\n        let ci_config: CIConfig = toml::from_str(&settings_string)?;\n\n        if run_commands(\n            ci_config.build.commands,\n            &project_path,\n            ci_config.archive.is_some(),\n        ) {\n            println!(\"Success! '{}' has been built.\", project);\n\n            if let Some(files) = ci_config.archive {\n                if archive_files(\n                    files.files,\n                    project_id.unwrap(),\n                    database,\n                    files.append_buildnumber,\n                ) {\n                    println!(\"Successfully archived files for '{}'\", project);\n\n                    if let Some(post_archive) = ci_config.postarchive {\n                        if run_commands(post_archive.commands, &project_path, false) {\n                            println!(\"Successfully ran post-archive commands for '{}'\", project);\n                        } else {\n                            println!(\n                                \"Error occurred running post-archive commands for '{}'\",\n                                project\n                            );\n                        }\n                    }\n                } else {\n                    println!(\"Failed to archive files for '{}'\", project);\n                }\n            } else {\n                save_project_build_data(project, \"passing\".to_owned(), database, vec![]);\n            }\n        } else {\n            println!(\"'{}' has failed to build.\", project);\n            save_project_build_data(project, \"failing\".to_owned(), database, vec![]);\n        }\n    }\n    Ok(())\n}", "item_id": 0, "repo": "Huskehhh/drovah", "file": "backend/src/lib.rs", "last_update_at": "2021-06-10T13:06:37+00:00", "question_id": "4e7ae383ca222b011940b511f5525d9e54488a4e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn run_build(project: String, database: &MysqlConnection) -> Result<(), Box<dyn Error>> {\n    println!(\"Building '{}'\", project);\n    let project_path = format!(\"data/projects/{}\", project);\n    let path = Path::new(&project_path);\n    let project_id = get_project_id(database, &project);\n    if path.exists() && path.is_dir() {\n        let settings_file_path = format!(\"{}/.drovah\", project_path);\n        let ci_settings_file = Path::new(&settings_file_path);\n        let settings_string = fs::read_to_string(ci_settings_file)?;\n        let ci_config: CIConfig = toml::from_str(&settings_string)?;\n        if run_commands(\n            ci_config.build.commands,\n            &project_path,\n            ci_config.archive.is_some(),\n        ) {\n            println!(\"Success! '{}' has been built.\", project);\n            if let Some(files) = ci_config.archive {\n                if archive_files(\n                    files.files,\n                    project_id.unwrap(),\n                    database,\n                    files.append_buildnumber,\n                ) {\n                    println!(\"Successfully archived files for '{}'\", project);\n                    if let Some(post_archive) = ci_config.postarchive {\n                        if run_commands(post_archive.commands, &project_path, false) {\n                            println!(\"Successfully ran post-archive commands for '{}'\", project);\n                        } else {\n                            println!(\n                                \"Error occurred running post-archive commands for '{}'\",\n                                project\n                            );\n                        }\n                    }\n                } else {\n                    println!(\"Failed to archive files for '{}'\", project);\n                }\n            } else {\n                save_project_build_data(project, \"passing\".to_owned(), database, vec![]);\n            }\n        } else {\n            println!(\"'{}' has failed to build.\", project);\n            save_project_build_data(project, \"failing\".to_owned(), database, vec![]);\n        }\n    }\n    Ok(())\n"]], "pred": {"ppl": 2.1617186069488525, "ppl_lower": 2.43591570854187, "ppl/lowercase_ppl": -1.154908080405087, "ppl/zlib": 0.0012140213491315499, "Min_5.0% Prob": 6.574447384587041, "Min_10.0% Prob": 4.895508554246691, "Min_20.0% Prob": 3.3016350125824965, "Min_30.0% Prob": 2.4312558014083794, "Min_40.0% Prob": 1.892831429011292, "Min_50.0% Prob": 1.5339864317603684, "Min_60.0% Prob": 1.2831966133075363}}
{"hexsha": "bef9179308cd458936bd6720221775ad753b505c", "ext": "rs", "lang": "Rust", "content": "fn out<S:Into<String>>(label: &str, msg: S, color: color::Color) -> std::io::Result<()> {\n  let mut out = term::stdout().unwrap();\n  try!(out.reset());\n  try!(out.fg(color));\n  try!(write!(&mut std::io::stdout(), \"{:>12}\", format!(\"Capgun {}\", label)));\n  try!(out.reset());\n  try!(write!(&mut std::io::stdout(), \" {}\\n\", msg.into()));\n  try!(out.flush());\n  Ok(())\n}", "item_id": 0, "repo": "softprops/capgun", "file": "src/main.rs", "last_update_at": "2021-07-29T16:51:20+00:00", "question_id": "bef9179308cd458936bd6720221775ad753b505c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn out<S:Into<String>>(label: &str, msg: S, color: color::Color) -> std::io::Result<()> {\n  let mut out = term::stdout().unwrap();\n  try!(out.reset());\n  try!(out.fg(color));\n  try!(write!(&mut std::io::stdout(), \"{:>12}\", format!(\"Capgun {}\", label)));\n  try!(out.reset());\n  try!(write!(&mut std::io::stdout(), \" {}\\n\", msg.into()));\n  try!(out.flush());\n  Ok(())\n"]], "pred": {"ppl": 2.8424460887908936, "ppl_lower": 3.3623688220977783, "ppl/lowercase_ppl": -1.1607986818500895, "ppl/zlib": 0.004858906885293578, "Min_5.0% Prob": 9.690292494637626, "Min_10.0% Prob": 7.002418228558132, "Min_20.0% Prob": 4.669331214257649, "Min_30.0% Prob": 3.366023438317435, "Min_40.0% Prob": 2.579488478600979, "Min_50.0% Prob": 2.0796401253768377, "Min_60.0% Prob": 1.7377535969994606}}
{"hexsha": "7573b812027883906f99703dcf3c5aa2f4438055", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn parse_nodes(\n    nodes_iterator: Option<\n        ItersWrapper<\n            Result<(usize, (String, Option<Vec<String>>))>,\n            impl Iterator<Item = Result<(usize, (String, Option<Vec<String>>))>>,\n            impl ParallelIterator<Item = Result<(usize, (String, Option<Vec<String>>))>>,\n        >,\n    >,\n    nodes_number: Option<NodeT>,\n    node_types_vocabulary: Option<Vocabulary<NodeTypeT>>,\n    node_list_is_correct: bool,\n    numeric_node_ids: bool,\n    numeric_node_list_node_type_ids: bool,\n    minimum_node_ids: Option<NodeT>,\n    skip_node_types_if_unavailable: Option<bool>,\n) -> Result<(Vocabulary<NodeT>, Option<NodeTypeVocabulary>)> {\n    let skip_node_types_if_unavailable = skip_node_types_if_unavailable.unwrap_or(false);\n    if !numeric_node_ids && minimum_node_ids.is_some() {\n        return Err(\n            \"Giving the minimum id is not meaningfull when numeric_ids is false.\".to_string(),\n        );\n    }\n\n    if nodes_iterator.is_none() && node_types_vocabulary.is_some() {\n        return Err(\n            \"Node types vocabulary was provided but no nodes iterator was given.\".to_string(),\n        );\n    }\n\n    let has_node_types = node_types_vocabulary.is_some();\n\n    if !has_node_types && !skip_node_types_if_unavailable && numeric_node_list_node_type_ids {\n        return Err(concat!(\n            \"The numeric node list node type IDs parameter does not make sense \",\n            \"in the context where the node types have not been provided.\\n\",\n            \"If the node types within the nodes list are numeric, simply use \",\n            \"the numeric node types ids parameter.\"\n        )\n        .to_string());\n    }\n\n    let node_types_method = match (\n        has_node_types,\n        node_types_vocabulary\n            .as_ref()\n            .map_or(true, |x| x.is_empty()),\n        node_list_is_correct,\n        numeric_node_list_node_type_ids,\n    ) {\n        (false, _, _, _) => NodeTypeParser::ignore,\n        (true, true, true, false) => NodeTypeParser::parse_strings_unchecked,\n        (true, true, false, false) => NodeTypeParser::parse_strings,\n        (true, false, true, false) => NodeTypeParser::get_unchecked,\n        (true, false, false, false) => NodeTypeParser::get,\n        (true, _, true, true) => NodeTypeParser::to_numeric_unchecked,\n        (true, _, false, true) => NodeTypeParser::to_numeric,\n    };\n    let node_types_vocabulary = node_types_vocabulary.unwrap_or(Vocabulary::new());\n\n    let mut node_type_parser = NodeTypeParser::new(node_types_vocabulary);\n    let nodes_iterator: Option<\n        ItersWrapper<Result<(usize, (String, Option<Vec<NodeTypeT>>))>, _, _>,\n    > = nodes_iterator\n        .map(|ni| ni.method_caller(node_types_method, node_types_method, &mut node_type_parser));\n\n    let (nodes_vocabulary, node_types_ids, node_types_vocabulary) = match (\n        nodes_iterator,\n        nodes_number,\n        numeric_node_ids,\n        minimum_node_ids,\n        node_list_is_correct,\n    ) {\n        // When the nodes iterator was provided, and the node IDs are expected\n        // NOT to be numeric and a minimum node ID is therefore meaningless.\n        // Note that this is the use case when the node list is ASSUMED TO BE CORRECT\n        // and the total number of nodes is known and provided.\n        (Some(ni), Some(nodes_number), false, None, true) => {\n            let (node_names, node_types_ids): (Vec<String>, Option<Vec<Option<Vec<NodeTypeT>>>>) =\n                if has_node_types {\n                    // If there are node types we need to collect them.\n                    // We cannot use the unzip utility because in this context\n                    // since we need to use a ParallellIterator,\n                    // note that it is NOT an IndexedParallellIterator.\n                    // Since we know the number of nodes and the node list\n                    // is provided as correct, it is possible to pre-allocate the vectors\n                    // and populate them with a foreach.\n                    let node_names = ThreadDataRaceAware {\n                        value: std::cell::UnsafeCell::new(vec![\n                            \"\".to_owned();\n                            nodes_number as usize\n                        ]),\n                    };\n                    let node_types_ids = ThreadDataRaceAware {\n                        value: std::cell::UnsafeCell::new(vec![None; nodes_number as usize]),\n                    };\n                    ni.for_each(|line| unsafe {\n                        // We can unwrap because the user tells us that this is surely\n                        // a correct node list.\n                        let (line_number, (node_name, node_type_ids)) = line.unwrap();\n                        (*node_names.value.get())[line_number] = node_name;\n                        (*node_types_ids.value.get())[line_number] = node_type_ids;\n                    });\n                    let node_type_ids = node_types_ids.value.into_inner();\n                    (node_names.value.into_inner(), optionify!(node_type_ids))\n                } else {\n                    let node_names = ThreadDataRaceAware {\n                        value: std::cell::UnsafeCell::new(vec![\n                            \"\".to_owned();\n                            nodes_number as usize\n                        ]),\n                    };\n                    ni.for_each(|line| unsafe {\n                        // We can unwrap because the user tells us that this is surely\n                        // a correct node list.\n                        let (line_number, (node_name, _)) = line.unwrap();\n                        (*node_names.value.get())[line_number] = node_name;\n                    });\n                    (node_names.value.into_inner(), None)\n                };\n            let mut node_type_vocabulary = node_type_parser.into_inner();\n            if node_type_vocabulary.is_empty() {\n                node_type_vocabulary.build()?;\n            }\n\n            Ok::<_, String>((\n                Vocabulary::from_reverse_map(node_names)?,\n                node_types_ids,\n                Some(node_type_vocabulary),\n            ))\n        }\n        // When the nodes iterator was provided, and the node IDs are expected\n        // NOT to be numeric and a minimum node ID is therefore meaningless.\n        // Note that this is the use case when it is not known if the node list is\n        // correct and how many nodes are inside it.\n        (Some(ni), _, false, None, _) => {\n            let (node_names, node_types_ids): (Vec<String>, Option<Vec<Option<Vec<NodeTypeT>>>>) =\n                if has_node_types {\n                    // If there are node types we need to collect them.\n                    // We need to use the unzip utility because in this context we do not\n                    // know the number of the nodes and we need to use a ParallellIterator,\n                    // note that it is NOT an IndexedParallellIterator.\n                    let (node_names, node_types_ids) = match ni\n                        .map(|line| line.map(|(_, node_and_node_type)| node_and_node_type))\n                    {\n                        ItersWrapper::Parallel(ni_par) => ni_par\n                            .collect::<Result<(Vec<String>, Vec<Option<Vec<NodeTypeT>>>)>>()?,\n                        ItersWrapper::Sequential(ni_seq) => {\n                            let mut node_names = Vec::new();\n                            let mut node_types_ids = Vec::new();\n                            for line in ni_seq {\n                                let (node_name, node_type_ids) = line?;\n                                node_names.push(node_name);\n                                node_types_ids.push(node_type_ids);\n                            }\n                            (node_names, node_types_ids)\n                        }\n                    };\n\n                    (node_names, optionify!(node_types_ids))\n                } else {\n                    (\n                        ni.map(|x| x.map(|(_, (name, _))| name))\n                            .collect::<Result<Vec<String>>>()?,\n                        None,\n                    )\n                };\n            let mut node_type_vocabulary = node_type_parser.into_inner();\n            if node_type_vocabulary.is_empty() {\n                node_type_vocabulary.build()?;\n            }\n\n            Ok::<_, String>((\n                Vocabulary::from_reverse_map(node_names)?,\n                node_types_ids,\n                Some(node_type_vocabulary),\n            ))\n        }\n        // When the node iterator was provided, and the nodes number is not known\n        // and the node IDs are expected to be numeric.\n        (Some(ni), maybe_nodes_number, true, _, _) => {\n            // In case the node types are expected to exist.\n            let (min, max) = if has_node_types {\n                return Err(concat!(\n                    \"This case is not supported. You cannot have a nodes iterator of numeric node ids with node types.\",\n                    \" This would require to sort the csv and thus it requires a higher memory peak.\",\n                    \" If you want to load it just set numeric_node_ids to false and load them as strings.\",\n                ).to_string());\n            } else {\n                // Alternatively we can focus exclusively on the\n                // node IDs, which being numeric boil down to collecting\n                // the minimum and the maximum value.\n                let (mut min, mut max, actual_nodes_number): (NodeT, NodeT, NodeT) = ni\n                    .map(|line| match line {\n                        Ok((line_number, (node_name, _))) => match node_name.parse::<NodeT>() {\n                            Ok(node_id) => Ok(node_id),\n                            Err(_) => Err(format!(\n                                concat!(\n                                    \"While parsing the provided node list, \",\n                                    \"the node ID {:?} was found and it is not \",\n                                    \"possible to convert it to an integer as was requested.\\n\",\n                                    \"Specifically the line with the error is {}.\"\n                                ),\n                                node_name, line_number\n                            )),\n                        },\n                        Err(e) => Err(e),\n                    })\n                    .map(|maybe_node_id: Result<NodeT>| {\n                        maybe_node_id.map(|node_id| (node_id, node_id, 1))\n                    })\n                    .reduce(\n                        || Ok((NodeT::MAX, 0 as NodeT, 0)),\n                        |line1: Result<(NodeT, NodeT, NodeT)>,\n                         line2: Result<(NodeT, NodeT, NodeT)>| match (\n                            line1, line2,\n                        ) {\n                            (Ok((min1, max1, count1)), Ok((min2, max2, count2))) => {\n                                Ok((min1.min(min2), max1.max(max2), count1 + count2))\n                            }\n                            (Err(e), _) => Err(e),\n                            (_, Err(e)) => Err(e),\n                        },\n                    )?;\n\n                if actual_nodes_number == 0 {\n                    min = 0;\n                    max = 0;\n                }\n\n                if let Some(nn) = maybe_nodes_number {\n                    if nn != max - min {\n                        return Err(format!(\n                                \"The given nodes number '{}' is different from the actual nodes number '{}'.\",\n                                nn, actual_nodes_number,\n                            ));\n                    }\n                }\n\n                (min, max)\n            };\n            let minimum_node_ids = minimum_node_ids.unwrap_or(min);\n\n            if min < minimum_node_ids {\n                return Err(format!(\n                    concat!(\n                        \"The given minimum id {:?} is higher \",\n                        \"than the minimum id found in the iterator {:?}.\"\n                    ),\n                    minimum_node_ids, min\n                ));\n            }\n\n            let mut node_type_vocabulary = node_type_parser.into_inner();\n            if node_type_vocabulary.is_empty() {\n                node_type_vocabulary.build()?;\n            }\n\n            Ok((\n                Vocabulary::from_range(min.min(minimum_node_ids)..(max + 1)),\n                None,\n                Some(node_type_vocabulary),\n            ))\n        }\n        (None, Some(ntn), true, None, _) => Ok((Vocabulary::from_range(0..ntn), None, None)),\n        (None, Some(ntn), true, Some(min_val), _) => {\n            let max = match min_val.checked_add(ntn){\n                Some(max) => Ok(max),\n                None => Err(format!(\n                    concat!(\n                        \"To compute the maximum node type, it is needed to sum \",\n                        \"the minimum node type ID `{}` to the provided number of node types `{}`, \",\n                        \"but this would lead to an overflow, that is a value higher than the maximum U32.\"\n                    ),\n                    min_val, ntn\n                ))\n            }?;\n            Ok((Vocabulary::from_range(min_val..max), None, None))\n        }\n        (None, None, true, _, _) => {\n            let min = minimum_node_ids.unwrap_or(0);\n            Ok((Vocabulary::from_range(min..min), None, None))\n        }\n        (None, Some(ntn), false, None, _) => {\n            Ok((Vocabulary::with_capacity(ntn as usize), None, None))\n        }\n        (None, None, false, None, _) => Ok((Vocabulary::new(), None, None)),\n        // TODO! improve error\n        _ => unreachable!(\"All other cases must be explicitly handled.\"),\n    }?;\n\n    // Executing self-consistency check for the node type IDs\n    if node_types_ids.as_ref().map_or(false, |node_types_ids| {\n        nodes_vocabulary.len() != node_types_ids.len()\n    }) {\n        panic!(\n            concat!(\n                \"The length of the nodes vocabulary is {}, \",\n                \"while the length of the node type IDs vector is {}.\"\n            ),\n            nodes_vocabulary.len(),\n            node_types_ids.unwrap().len()\n        );\n    }\n\n    Ok((\n        nodes_vocabulary,\n        NodeTypeVocabulary::from_option_structs(node_types_ids, node_types_vocabulary),\n    ))\n}", "item_id": 0, "repo": "AnacletoLAB/ensmallen_graph", "file": "graph/src/constructors/parse_nodes.rs", "last_update_at": "2021-08-09T16:41:47+00:00", "question_id": "7573b812027883906f99703dcf3c5aa2f4438055_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn parse_nodes(\n    nodes_iterator: Option<\n        ItersWrapper<\n            Result<(usize, (String, Option<Vec<String>>))>,\n            impl Iterator<Item = Result<(usize, (String, Option<Vec<String>>))>>,\n            impl ParallelIterator<Item = Result<(usize, (String, Option<Vec<String>>))>>,\n        >,\n    >,\n    nodes_number: Option<NodeT>,\n    node_types_vocabulary: Option<Vocabulary<NodeTypeT>>,\n    node_list_is_correct: bool,\n    numeric_node_ids: bool,\n    numeric_node_list_node_type_ids: bool,\n    minimum_node_ids: Option<NodeT>,\n    skip_node_types_if_unavailable: Option<bool>,\n) -> Result<(Vocabulary<NodeT>, Option<NodeTypeVocabulary>)> {\n    let skip_node_types_if_unavailable = skip_node_types_if_unavailable.unwrap_or(false);\n    if !numeric_node_ids && minimum_node_ids.is_some() {\n        return Err(\n            \"Giving the minimum id is not meaningfull when numeric_ids is false.\".to_string(),\n        );\n    }\n    if nodes_iterator.is_none() && node_types_vocabulary.is_some() {\n        return Err(\n            \"Node types vocabulary was provided but no nodes iterator was given.\".to_string(),\n        );\n    }\n    let has_node_types = node_types_vocabulary.is_some();\n    if !has_node_types && !skip_node_types_if_unavailable && numeric_node_list_node_type_ids {\n        return Err(concat!(\n            \"The numeric node list node type IDs parameter does not make sense \",\n            \"in the context where the node types have not been provided.\\n\",\n            \"If the node types within the nodes list are numeric, simply use \",\n            \"the numeric node types ids parameter.\"\n        )\n        .to_string());\n    }\n    let node_types_method = match (\n        has_node_types,\n        node_types_vocabulary\n            .as_ref()\n            .map_or(true, |x| x.is_empty()),\n        node_list_is_correct,\n        numeric_node_list_node_type_ids,\n    ) {\n        (false, _, _, _) => NodeTypeParser::ignore,\n        (true, true, true, false) => NodeTypeParser::parse_strings_unchecked,\n        (true, true, false, false) => NodeTypeParser::parse_strings,\n        (true, false, true, false) => NodeTypeParser::get_unchecked,\n        (true, false, false, false) => NodeTypeParser::get,\n        (true, _, true, true) => NodeTypeParser::to_numeric_unchecked,\n        (true, _, false, true) => NodeTypeParser::to_numeric,\n    };\n    let node_types_vocabulary = node_types_vocabulary.unwrap_or(Vocabulary::new());\n    let mut node_type_parser = NodeTypeParser::new(node_types_vocabulary);\n    let nodes_iterator: Option<\n        ItersWrapper<Result<(usize, (String, Option<Vec<NodeTypeT>>))>, _, _>,\n    > = nodes_iterator\n        .map(|ni| ni.method_caller(node_types_method, node_types_method, &mut node_type_parser));\n    let (nodes_vocabulary, node_types_ids, node_types_vocabulary) = match (\n        nodes_iterator,\n        nodes_number,\n        numeric_node_ids,\n        minimum_node_ids,\n        node_list_is_correct,\n    ) {\n        // When the nodes iterator was provided, and the node IDs are expected\n        // NOT to be numeric and a minimum node ID is therefore meaningless.\n        // Note that this is the use case when the node list is ASSUMED TO BE CORRECT\n        // and the total number of nodes is known and provided.\n        (Some(ni), Some(nodes_number), false, None, true) => {\n            let (node_names, node_types_ids): (Vec<String>, Option<Vec<Option<Vec<NodeTypeT>>>>) =\n                if has_node_types {\n                    // If there are node types we need to collect them.\n                    // We cannot use the unzip utility because in this context\n                    // since we need to use a ParallellIterator,\n                    // note that it is NOT an IndexedParallellIterator.\n                    // Since we know the number of nodes and the node list\n                    // is provided as correct, it is possible to pre-allocate the vectors\n                    // and populate them with a foreach.\n                    let node_names = ThreadDataRaceAware {\n                        value: std::cell::UnsafeCell::new(vec![\n                            \"\".to_owned();\n                            nodes_number as usize\n                        ]),\n                    };\n                    let node_types_ids = ThreadDataRaceAware {\n                        value: std::cell::UnsafeCell::new(vec![None; nodes_number as usize]),\n                    };\n                    ni.for_each(|line| unsafe {\n                        // We can unwrap because the user tells us that this is surely\n                        // a correct node list.\n                        let (line_number, (node_name, node_type_ids)) = line.unwrap();\n                        (*node_names.value.get())[line_number] = node_name;\n                        (*node_types_ids.value.get())[line_number] = node_type_ids;\n                    });\n                    let node_type_ids = node_types_ids.value.into_inner();\n                    (node_names.value.into_inner(), optionify!(node_type_ids))\n                } else {\n                    let node_names = ThreadDataRaceAware {\n                        value: std::cell::UnsafeCell::new(vec![\n                            \"\".to_owned();\n                            nodes_number as usize\n                        ]),\n                    };\n                    ni.for_each(|line| unsafe {\n                        // We can unwrap because the user tells us that this is surely\n                        // a correct node list.\n                        let (line_number, (node_name, _)) = line.unwrap();\n                        (*node_names.value.get())[line_number] = node_name;\n                    });\n                    (node_names.value.into_inner(), None)\n                };\n            let mut node_type_vocabulary = node_type_parser.into_inner();\n            if node_type_vocabulary.is_empty() {\n                node_type_vocabulary.build()?;\n            }\n            Ok::<_, String>((\n                Vocabulary::from_reverse_map(node_names)?,\n                node_types_ids,\n                Some(node_type_vocabulary),\n            ))\n        }\n        // When the nodes iterator was provided, and the node IDs are expected\n        // NOT to be numeric and a minimum node ID is therefore meaningless.\n        // Note that this is the use case when it is not known if the node list is\n        // correct and how many nodes are inside it.\n        (Some(ni), _, false, None, _) => {\n            let (node_names, node_types_ids): (Vec<String>, Option<Vec<Option<Vec<NodeTypeT>>>>) =\n                if has_node_types {\n                    // If there are node types we need to collect them.\n                    // We need to use the unzip utility because in this context we do not\n                    // know the number of the nodes and we need to use a ParallellIterator,\n                    // note that it is NOT an IndexedParallellIterator.\n                    let (node_names, node_types_ids) = match ni\n                        .map(|line| line.map(|(_, node_and_node_type)| node_and_node_type))\n                    {\n                        ItersWrapper::Parallel(ni_par) => ni_par\n                            .collect::<Result<(Vec<String>, Vec<Option<Vec<NodeTypeT>>>)>>()?,\n                        ItersWrapper::Sequential(ni_seq) => {\n                            let mut node_names = Vec::new();\n                            let mut node_types_ids = Vec::new();\n                            for line in ni_seq {\n                                let (node_name, node_type_ids) = line?;\n                                node_names.push(node_name);\n                                node_types_ids.push(node_type_ids);\n                            }\n                            (node_names, node_types_ids)\n                        }\n                    };\n                    (node_names, optionify!(node_types_ids))\n                } else {\n                    (\n                        ni.map(|x| x.map(|(_, (name, _))| name))\n                            .collect::<Result<Vec<String>>>()?,\n                        None,\n                    )\n                };\n            let mut node_type_vocabulary = node_type_parser.into_inner();\n            if node_type_vocabulary.is_empty() {\n                node_type_vocabulary.build()?;\n            }\n            Ok::<_, String>((\n                Vocabulary::from_reverse_map(node_names)?,\n                node_types_ids,\n                Some(node_type_vocabulary),\n            ))\n        }\n        // When the node iterator was provided, and the nodes number is not known\n        // and the node IDs are expected to be numeric.\n        (Some(ni), maybe_nodes_number, true, _, _) => {\n            // In case the node types are expected to exist.\n            let (min, max) = if has_node_types {\n                return Err(concat!(\n                    \"This case is not supported. You cannot have a nodes iterator of numeric node ids with node types.\",\n                    \" This would require to sort the csv and thus it requires a higher memory peak.\",\n                    \" If you want to load it just set numeric_node_ids to false and load them as strings.\",\n                ).to_string());\n            } else {\n                // Alternatively we can focus exclusively on the\n                // node IDs, which being numeric boil down to collecting\n                // the minimum and the maximum value.\n                let (mut min, mut max, actual_nodes_number): (NodeT, NodeT, NodeT) = ni\n                    .map(|line| match line {\n                        Ok((line_number, (node_name, _))) => match node_name.parse::<NodeT>() {\n                            Ok(node_id) => Ok(node_id),\n                            Err(_) => Err(format!(\n                                concat!(\n                                    \"While parsing the provided node list, \",\n                                    \"the node ID {:?} was found and it is not \",\n                                    \"possible to convert it to an integer as was requested.\\n\",\n                                    \"Specifically the line with the error is {}.\"\n                                ),\n                                node_name, line_number\n                            )),\n                        },\n                        Err(e) => Err(e),\n                    })\n                    .map(|maybe_node_id: Result<NodeT>| {\n                        maybe_node_id.map(|node_id| (node_id, node_id, 1))\n                    })\n                    .reduce(\n                        || Ok((NodeT::MAX, 0 as NodeT, 0)),\n                        |line1: Result<(NodeT, NodeT, NodeT)>,\n                         line2: Result<(NodeT, NodeT, NodeT)>| match (\n                            line1, line2,\n                        ) {\n                            (Ok((min1, max1, count1)), Ok((min2, max2, count2))) => {\n                                Ok((min1.min(min2), max1.max(max2), count1 + count2))\n                            }\n                            (Err(e), _) => Err(e),\n                            (_, Err(e)) => Err(e),\n                        },\n                    )?;\n                if actual_nodes_number == 0 {\n                    min = 0;\n                    max = 0;\n                }\n                if let Some(nn) = maybe_nodes_number {\n                    if nn != max - min {\n                        return Err(format!(\n                                \"The given nodes number '{}' is different from the actual nodes number '{}'.\",\n                                nn, actual_nodes_number,\n                            ));\n                    }\n                }\n                (min, max)\n            };\n            let minimum_node_ids = minimum_node_ids.unwrap_or(min);\n            if min < minimum_node_ids {\n                return Err(format!(\n                    concat!(\n                        \"The given minimum id {:?} is higher \",\n                        \"than the minimum id found in the iterator {:?}.\"\n                    ),\n                    minimum_node_ids, min\n                ));\n            }\n            let mut node_type_vocabulary = node_type_parser.into_inner();\n            if node_type_vocabulary.is_empty() {\n                node_type_vocabulary.build()?;\n            }\n            Ok((\n                Vocabulary::from_range(min.min(minimum_node_ids)..(max + 1)),\n                None,\n                Some(node_type_vocabulary),\n            ))\n        }\n        (None, Some(ntn), true, None, _) => Ok((Vocabulary::from_range(0..ntn), None, None)),\n        (None, Some(ntn), true, Some(min_val), _) => {\n            let max = match min_val.checked_add(ntn){\n                Some(max) => Ok(max),\n                None => Err(format!(\n                    concat!(\n                        \"To compute the maximum node type, it is needed to sum \",\n                        \"the minimum node type ID `{}` to the provided number of node types `{}`, \",\n                        \"but this would lead to an overflow, that is a value higher than the maximum U32.\"\n                    ),\n                    min_val, ntn\n                ))\n            }?;\n            Ok((Vocabulary::from_range(min_val..max), None, None))\n        }\n        (None, None, true, _, _) => {\n            let min = minimum_node_ids.unwrap_or(0);\n            Ok((Vocabulary::from_range(min..min), None, None))\n        }\n        (None, Some(ntn), false, None, _) => {\n            Ok((Vocabulary::with_capacity(ntn as usize), None, None))\n        }\n        (None, None, false, None, _) => Ok((Vocabulary::new(), None, None)),\n        // TODO! improve error\n        _ => unreachable!(\"All other cases must be explicitly handled.\"),\n    }?;\n    // Executing self-consistency check for the node type IDs\n    if node_types_ids.as_ref().map_or(false, |node_types_ids| {\n        nodes_vocabulary.len() != node_types_ids.len()\n    }) {\n        panic!(\n            concat!(\n                \"The length of the nodes vocabulary is {}, \",\n                \"while the length of the node type IDs vector is {}.\"\n            ),\n            nodes_vocabulary.len(),\n            node_types_ids.unwrap().len()\n        );\n    }\n    Ok((\n        nodes_vocabulary,\n        NodeTypeVocabulary::from_option_structs(node_types_ids, node_types_vocabulary),\n    ))\n"]], "pred": {"ppl": 2.2182300090789795, "ppl_lower": 2.3834354877471924, "ppl/lowercase_ppl": -1.0901625207278727, "ppl/zlib": 0.00024704173168038775, "Min_5.0% Prob": 6.667063928117939, "Min_10.0% Prob": 5.049463431040446, "Min_20.0% Prob": 3.433617775931078, "Min_30.0% Prob": 2.5385073393193727, "Min_40.0% Prob": 1.9697457228065411, "Min_50.0% Prob": 1.592267621414273, "Min_60.0% Prob": 1.3292321395668312}}
{"hexsha": "b3b8bea9c7e31edc3c98dd2360ee30b8729e95c9", "ext": "rs", "lang": "Rust", "content": "fn mutate_int(val_old: u64, fmt: &IntFmt, range: Option<(u64, u64)>, align: u64) -> u64 {\n    let mut mutated = false;\n    let mut rng = thread_rng();\n    let mut val_new = val_old;\n    if rng.gen_ratio(1, 10) {\n        val_new = MAGIC64.choose(&mut rng).unwrap() + (val_old & 1);\n        if val_new != val_old {\n            mutated = true;\n        }\n    }\n    if rng.gen_ratio(3, 10) {\n        let (val, _) = if rng.gen() {\n            val_new.overflowing_sub(rng.gen_range(1..=32))\n        } else {\n            val_new.overflowing_add(rng.gen_range(1..=32))\n        };\n        val_new = val;\n    }\n    if !mutated || rng.gen_ratio(1, 100) {\n        val_new = gen_integer(fmt.bitfield_len, range, align);\n    }\n\n    val_new\n}", "item_id": 4, "repo": "Healer-fuzz/healer-fuzz", "file": "src/fuzz/mutation.rs", "last_update_at": "2021-11-05T16:04:35+00:00", "question_id": "b3b8bea9c7e31edc3c98dd2360ee30b8729e95c9_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn mutate_int(val_old: u64, fmt: &IntFmt, range: Option<(u64, u64)>, align: u64) -> u64 {\n    let mut mutated = false;\n    let mut rng = thread_rng();\n    let mut val_new = val_old;\n    if rng.gen_ratio(1, 10) {\n        val_new = MAGIC64.choose(&mut rng).unwrap() + (val_old & 1);\n        if val_new != val_old {\n            mutated = true;\n        }\n    }\n    if rng.gen_ratio(3, 10) {\n        let (val, _) = if rng.gen() {\n            val_new.overflowing_sub(rng.gen_range(1..=32))\n        } else {\n            val_new.overflowing_add(rng.gen_range(1..=32))\n        };\n        val_new = val;\n    }\n    if !mutated || rng.gen_ratio(1, 100) {\n        val_new = gen_integer(fmt.bitfield_len, range, align);\n    }\n    val_new\n"]], "pred": {"ppl": 2.576585292816162, "ppl_lower": 2.741595506668091, "ppl/lowercase_ppl": -1.0655862189871885, "ppl/zlib": 0.0029484890728286584, "Min_5.0% Prob": 7.276285775502523, "Min_10.0% Prob": 5.564380399386088, "Min_20.0% Prob": 3.960190317669853, "Min_30.0% Prob": 2.9888321390518775, "Min_40.0% Prob": 2.3234437997223902, "Min_50.0% Prob": 1.8894751450831169, "Min_60.0% Prob": 1.5754199445736212}}
{"hexsha": "7c6165af0d0a7f61daff2541209e362ada3c9073", "ext": "rs", "lang": "Rust", "content": "fn parse_formals(formals: PoolPtr) -> Result<Formals, String> {\n    let mut values = Vec::new();\n    let mut formal = formals;\n    loop {\n        if let Some(dt) = get_define_target(formal) {\n            return Ok(Formals {\n                values,\n                rest: Some(dt),\n            });\n        } else {\n            match &*formal {\n                Value::EmptyList => return Ok(Formals { values, rest: None }),\n                Value::Pair(car, cdr) => {\n                    if let Some(dt) = get_define_target(car.get()) {\n                        values.push(dt);\n                        formal = cdr.get();\n                    } else {\n                        return Err(format!(\"malformed formals: {}.\", formals.pretty_print()));\n                    }\n                }\n                _ => {\n                    return Err(format!(\"malformed formals: {}.\", formals.pretty_print()));\n                }\n            }\n        }\n    }\n}", "item_id": 7, "repo": "mwatts/peroxide", "file": "src/ast.rs", "last_update_at": "2021-12-06T02:13:30+00:00", "question_id": "7c6165af0d0a7f61daff2541209e362ada3c9073_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_formals(formals: PoolPtr) -> Result<Formals, String> {\n    let mut values = Vec::new();\n    let mut formal = formals;\n    loop {\n        if let Some(dt) = get_define_target(formal) {\n            return Ok(Formals {\n                values,\n                rest: Some(dt),\n            });\n        } else {\n            match &*formal {\n                Value::EmptyList => return Ok(Formals { values, rest: None }),\n                Value::Pair(car, cdr) => {\n                    if let Some(dt) = get_define_target(car.get()) {\n                        values.push(dt);\n                        formal = cdr.get();\n                    } else {\n                        return Err(format!(\"malformed formals: {}.\", formals.pretty_print()));\n                    }\n                }\n                _ => {\n                    return Err(format!(\"malformed formals: {}.\", formals.pretty_print()));\n                }\n            }\n        }\n    }\n"]], "pred": {"ppl": 2.1504805088043213, "ppl_lower": 2.707327127456665, "ppl/lowercase_ppl": -1.3007354736987717, "ppl/zlib": 0.002377923321850859, "Min_5.0% Prob": 7.355764905611674, "Min_10.0% Prob": 5.097898511886597, "Min_20.0% Prob": 3.3760564017295835, "Min_30.0% Prob": 2.4666868940989177, "Min_40.0% Prob": 1.9068682123720646, "Min_50.0% Prob": 1.5272208198550201, "Min_60.0% Prob": 1.2769361121290124}}
{"hexsha": "e0dfd43e1ffda46aaadebcdd7fdca1f8011858a4", "ext": "rs", "lang": "Rust", "content": "fn addi() {\n    let word: u32 = 0x12358513;\n\n    let instruction = decode(word).unwrap();\n\n    assert_eq!(*instruction.op(), Op::Addi);\n    assert_eq!(*instruction.rd(), Register::A0);\n    assert_eq!(*instruction.rs1(), Register::A1);\n    assert_eq!(instruction.immediate(), 0x123);\n}", "item_id": 1, "repo": "falconre/falcon-riscv", "file": "lib/test.rs", "last_update_at": "2021-03-19T01:50:29+00:00", "question_id": "e0dfd43e1ffda46aaadebcdd7fdca1f8011858a4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn addi() {\n    let word: u32 = 0x12358513;\n    let instruction = decode(word).unwrap();\n    assert_eq!(*instruction.op(), Op::Addi);\n    assert_eq!(*instruction.rd(), Register::A0);\n    assert_eq!(*instruction.rs1(), Register::A1);\n    assert_eq!(instruction.immediate(), 0x123);\n"]], "pred": {"ppl": 2.8463053703308105, "ppl_lower": 3.0139782428741455, "ppl/lowercase_ppl": -1.0547207428550436, "ppl/zlib": 0.006705267897371299, "Min_5.0% Prob": 7.724066638946534, "Min_10.0% Prob": 5.7958056709983135, "Min_20.0% Prob": 4.031462225047025, "Min_30.0% Prob": 3.107204742503889, "Min_40.0% Prob": 2.51990661973303, "Min_50.0% Prob": 2.060986927045243, "Min_60.0% Prob": 1.738124575855127}}
{"hexsha": "1cdc03430c8bdba3a976d3fa3ba603e52359b910", "ext": "rs", "lang": "Rust", "content": "fn gen_tuple_n_impl_size(ctx: &Ctx, size: usize, item_names: &[Ident]) -> TokenStream {\n    let tuple_name = format_ident!(\"Tuple{}\", size);\n\n    let nts = &ctx.nts[0..size];\n\n    let tks = quote! {\n        pub trait #tuple_name: Tuple {\n            #(type #item_names;)*\n        }\n        impl<#(#nts),*> #tuple_name for (#(#nts),*) {\n            #(type #item_names = #nts;)*\n        }\n    };\n    tks\n}", "item_id": 5, "repo": "libsugar/tuplers", "file": "code_gen/src/code_gen.rs", "last_update_at": "2021-12-15T10:07:38+00:00", "question_id": "1cdc03430c8bdba3a976d3fa3ba603e52359b910_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn gen_tuple_n_impl_size(ctx: &Ctx, size: usize, item_names: &[Ident]) -> TokenStream {\n    let tuple_name = format_ident!(\"Tuple{}\", size);\n    let nts = &ctx.nts[0..size];\n    let tks = quote! {\n        pub trait #tuple_name: Tuple {\n            #(type #item_names;)*\n        }\n        impl<#(#nts),*> #tuple_name for (#(#nts),*) {\n            #(type #item_names = #nts;)*\n        }\n    };\n    tks\n"]], "pred": {"ppl": 2.62969970703125, "ppl_lower": 3.0728023052215576, "ppl/lowercase_ppl": -1.1610561328851237, "ppl/zlib": 0.00431638240997604, "Min_5.0% Prob": 7.3842727797372, "Min_10.0% Prob": 5.802809492746989, "Min_20.0% Prob": 4.020171100093473, "Min_30.0% Prob": 3.0563357809315557, "Min_40.0% Prob": 2.3555662973273184, "Min_50.0% Prob": 1.9287428765908463, "Min_60.0% Prob": 1.6070509598219906}}
{"hexsha": "90737d3a430e73372d49b9255b1a071d04c431ce", "ext": "rs", "lang": "Rust", "content": "fn get_inbound_ruleset_details<T: HerokuApiClient>(api_client: &T) {\n    let space_id = \"123\";\n    let ruleset_id = \"123\";\n    let space = &space::InboundRulesetDetails::new(space_id, ruleset_id);\n    let response = api_client.request(space);\n\n    print_response(response);\n}", "item_id": 10, "repo": "klaxit/heroku_rs", "file": "examples/src/spaces_examples.rs", "last_update_at": "2021-09-21T04:40:58+00:00", "question_id": "90737d3a430e73372d49b9255b1a071d04c431ce_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_inbound_ruleset_details<T: HerokuApiClient>(api_client: &T) {\n    let space_id = \"123\";\n    let ruleset_id = \"123\";\n    let space = &space::InboundRulesetDetails::new(space_id, ruleset_id);\n    let response = api_client.request(space);\n    print_response(response);\n"]], "pred": {"ppl": 3.0303080081939697, "ppl_lower": 5.528165817260742, "ppl/lowercase_ppl": -1.5422667911747034, "ppl/zlib": 0.006638708186971688, "Min_5.0% Prob": 7.01246747970581, "Min_10.0% Prob": 5.774738407135009, "Min_20.0% Prob": 4.450475251674652, "Min_30.0% Prob": 3.4018380522727965, "Min_40.0% Prob": 2.687385281920433, "Min_50.0% Prob": 2.1984288585186005, "Min_60.0% Prob": 1.855291530241569}}
{"hexsha": "6e33c3e19a2967459a839994df5d700eb8fdbde5", "ext": "rs", "lang": "Rust", "content": "fn main() unsafe {\n    let i = ~@1;\n    let j = ~@2;\n    let rc1 = refcount(*i);\n    let j = i;\n    let rc2 = refcount(*i);\n    error!(\"rc1: %u rc2: %u\", rc1, rc2);\n    assert rc1 + 1u == rc2;\n}", "item_id": 0, "repo": "0c0w3/rust", "file": "src/test/run-pass/unique-copy-box.rs", "last_update_at": "2021-11-17T10:43:56+00:00", "question_id": "6e33c3e19a2967459a839994df5d700eb8fdbde5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() unsafe {\n    let i = ~@1;\n    let j = ~@2;\n    let rc1 = refcount(*i);\n    let j = i;\n    let rc2 = refcount(*i);\n    error!(\"rc1: %u rc2: %u\", rc1, rc2);\n    assert rc1 + 1u == rc2;\n"]], "pred": {"ppl": 2.8578009605407715, "ppl_lower": 2.8578009605407715, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.008750436951372004, "Min_5.0% Prob": 8.870259523391724, "Min_10.0% Prob": 6.778581354353163, "Min_20.0% Prob": 4.4719482158359725, "Min_30.0% Prob": 3.326213466269629, "Min_40.0% Prob": 2.5540906512423565, "Min_50.0% Prob": 2.0939884349069695, "Min_60.0% Prob": 1.7401836416439007}}
{"hexsha": "854b5212e7f41872f5f78bae53add1d8165a6486", "ext": "rs", "lang": "Rust", "content": "fn should_2_e6_contains_n_3_4_5_6() {\n    let range = Range::init(\"(2,6]\");\n    let range_2 = Range::init(\"{3,4,5,6}\");\n    assert_eq!(range.range_contains(&range_2), true);\n}", "item_id": 48, "repo": "VWWL/learn-rust", "file": "tests/dojo/range.rs", "last_update_at": "2021-12-17T07:32:44+00:00", "question_id": "854b5212e7f41872f5f78bae53add1d8165a6486_48", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn should_2_e6_contains_n_3_4_5_6() {\n    let range = Range::init(\"(2,6]\");\n    let range_2 = Range::init(\"{3,4,5,6}\");\n    assert_eq!(range.range_contains(&range_2), true);\n"]], "pred": {"ppl": 5.324213981628418, "ppl_lower": 5.675050258636475, "ppl/lowercase_ppl": -1.0381604137880058, "ppl/zlib": 0.013064571028252583, "Min_5.0% Prob": 9.201631546020508, "Min_10.0% Prob": 8.082043170928955, "Min_20.0% Prob": 6.42675584157308, "Min_30.0% Prob": 4.829611845638441, "Min_40.0% Prob": 3.945150305827459, "Min_50.0% Prob": 3.25644157121056, "Min_60.0% Prob": 2.7571494812550754}}
{"hexsha": "5451323731edaa563b71764afe73291e9b6ee11b", "ext": "rs", "lang": "Rust", "content": "fn test_ffi() {\n        let outer = vec![\n            [4.0, 1.0],\n            [5.0, 2.0],\n            [5.0, 3.0],\n            [4.0, 4.0],\n            [3.0, 4.0],\n            [2.0, 3.0],\n            [2.0, 2.0],\n            [3.0, 1.0],\n            [4.0, 1.0],\n        ];\n        let inners = vec![\n            vec![[3.5, 3.5], [4.4, 2.0], [2.6, 2.0], [3.5, 3.5]],\n            vec![[4.0, 3.0], [4.0, 3.2], [4.5, 3.2], [4.0, 3.0]],\n        ];\n\n        let res = polylabel_ffi(outer, inners, 0.1);\n        assert_eq!(res, (3.125, 2.875, 0.8838834764831844));\n    }", "item_id": 1, "repo": "ComPathIC/pylylabel", "file": "src/ffi.rs", "last_update_at": "2021-11-07T14:19:31+00:00", "question_id": "5451323731edaa563b71764afe73291e9b6ee11b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_ffi() {\n        let outer = vec![\n            [4.0, 1.0],\n            [5.0, 2.0],\n            [5.0, 3.0],\n            [4.0, 4.0],\n            [3.0, 4.0],\n            [2.0, 3.0],\n            [2.0, 2.0],\n            [3.0, 1.0],\n            [4.0, 1.0],\n        ];\n        let inners = vec![\n            vec![[3.5, 3.5], [4.4, 2.0], [2.6, 2.0], [3.5, 3.5]],\n            vec![[4.0, 3.0], [4.0, 3.2], [4.5, 3.2], [4.0, 3.0]],\n        ];\n        let res = polylabel_ffi(outer, inners, 0.1);\n        assert_eq!(res, (3.125, 2.875, 0.8838834764831844));\n"]], "pred": {"ppl": 1.990026831626892, "ppl_lower": 1.990026831626892, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.003261365506517048, "Min_5.0% Prob": 5.0919404711042136, "Min_10.0% Prob": 3.9081944926031706, "Min_20.0% Prob": 2.7848398788221953, "Min_30.0% Prob": 2.1233702439001236, "Min_40.0% Prob": 1.6825299387605026, "Min_50.0% Prob": 1.3716366870136096, "Min_60.0% Prob": 1.148866018344616}}
{"hexsha": "9d2190c763e84333cf2077c6c68424f35afd1af1", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_ble_opt_t() {\n    assert_eq!(\n        ::core::mem::size_of::<ble_opt_t>(),\n        8usize,\n        concat!(\"Size of: \", stringify!(ble_opt_t))\n    );\n    assert_eq!(\n        ::core::mem::align_of::<ble_opt_t>(),\n        4usize,\n        concat!(\"Alignment of \", stringify!(ble_opt_t))\n    );\n    assert_eq!(\n        unsafe { &(*(::core::ptr::null::<ble_opt_t>())).common_opt as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(ble_opt_t),\n            \"::\",\n            stringify!(common_opt)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::core::ptr::null::<ble_opt_t>())).gap_opt as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(ble_opt_t),\n            \"::\",\n            stringify!(gap_opt)\n        )\n    );\n}", "item_id": 284, "repo": "timokroeger/nrf-softdevice", "file": "nrf-softdevice-s140/src/bindings.rs", "last_update_at": "2021-03-15T08:53:59+00:00", "question_id": "9d2190c763e84333cf2077c6c68424f35afd1af1_284", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout_ble_opt_t() {\n    assert_eq!(\n        ::core::mem::size_of::<ble_opt_t>(),\n        8usize,\n        concat!(\"Size of: \", stringify!(ble_opt_t))\n    );\n    assert_eq!(\n        ::core::mem::align_of::<ble_opt_t>(),\n        4usize,\n        concat!(\"Alignment of \", stringify!(ble_opt_t))\n    );\n    assert_eq!(\n        unsafe { &(*(::core::ptr::null::<ble_opt_t>())).common_opt as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(ble_opt_t),\n            \"::\",\n            stringify!(common_opt)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::core::ptr::null::<ble_opt_t>())).gap_opt as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(ble_opt_t),\n            \"::\",\n            stringify!(gap_opt)\n        )\n    );\n"]], "pred": {"ppl": 1.260846495628357, "ppl_lower": 1.3044874668121338, "ppl/lowercase_ppl": -1.146804787187579, "ppl/zlib": 0.0009234395112323768, "Min_5.0% Prob": 4.3449345350265505, "Min_10.0% Prob": 2.3119776137173176, "Min_20.0% Prob": 1.1662388111464679, "Min_30.0% Prob": 0.7777094376900803, "Min_40.0% Prob": 0.5833098123252057, "Min_50.0% Prob": 0.4635632960728359, "Min_60.0% Prob": 0.3867312872944365}}
{"hexsha": "848e89ba564c377dee99981595d960e969b2b111", "ext": "rs", "lang": "Rust", "content": "fn pseudo_element_style(\n    _which: WhichPseudoElement,\n    _element: NodeId,\n    _element_style: &ComputedValues,\n    _context: &Context,\n) -> Option<Arc<ComputedValues>> {\n    // FIXME: run the cascade, then return None for `content: normal` or `content: none`\n    // https://drafts.csswg.org/css2/generate.html#content\n    None\n}", "item_id": 1, "repo": "SimonSapin/victor", "file": "victor/src/layout/dom_traversal.rs", "last_update_at": "2021-01-07T18:54:08+00:00", "question_id": "848e89ba564c377dee99981595d960e969b2b111_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn pseudo_element_style(\n    _which: WhichPseudoElement,\n    _element: NodeId,\n    _element_style: &ComputedValues,\n    _context: &Context,\n) -> Option<Arc<ComputedValues>> {\n    // FIXME: run the cascade, then return None for `content: normal` or `content: none`\n    // https://drafts.csswg.org/css2/generate.html#content\n    None\n"]], "pred": {"ppl": 3.9119069576263428, "ppl_lower": 5.596286296844482, "ppl/lowercase_ppl": -1.2625159046275785, "ppl/zlib": 0.006256995266293046, "Min_5.0% Prob": 9.528901481628418, "Min_10.0% Prob": 6.827139420942827, "Min_20.0% Prob": 5.114974639632485, "Min_30.0% Prob": 4.018436456427855, "Min_40.0% Prob": 3.2782718181610107, "Min_50.0% Prob": 2.6832388116602313, "Min_60.0% Prob": 2.276588384719456}}
{"hexsha": "0bbfcbabf56ddedfc277662426ff2a2a09e31612", "ext": "rs", "lang": "Rust", "content": "fn test_compare_backward() {\n        let compare = |east, north| {\n            let a = backward_ref(Point3035::new(east, north));\n            let b = backward(Point3035::new(east, north));\n            assert_approx_eq(a.coords.0, b.coords.0, 1e-6);\n            assert_approx_eq(a.coords.1, b.coords.1, 1e-6);\n        };\n        compare(3962799.45, 2999718.85);\n        compare(3963799.45, 2998718.85);\n    }", "item_id": 8, "repo": "b-r-u/geomatic", "file": "src/laea.rs", "last_update_at": "2021-12-02T06:28:12+00:00", "question_id": "0bbfcbabf56ddedfc277662426ff2a2a09e31612_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_compare_backward() {\n        let compare = |east, north| {\n            let a = backward_ref(Point3035::new(east, north));\n            let b = backward(Point3035::new(east, north));\n            assert_approx_eq(a.coords.0, b.coords.0, 1e-6);\n            assert_approx_eq(a.coords.1, b.coords.1, 1e-6);\n        };\n        compare(3962799.45, 2999718.85);\n        compare(3963799.45, 2998718.85);\n"]], "pred": {"ppl": 3.2340776920318604, "ppl_lower": 3.374830484390259, "ppl/lowercase_ppl": -1.0362952395627512, "ppl/zlib": 0.006668998774866569, "Min_5.0% Prob": 8.584985077381134, "Min_10.0% Prob": 6.4616820531732895, "Min_20.0% Prob": 4.543176773616246, "Min_30.0% Prob": 3.5914423173328616, "Min_40.0% Prob": 2.8445634787351315, "Min_50.0% Prob": 2.318279324790065, "Min_60.0% Prob": 1.9637623184694435}}
{"hexsha": "5db25372330da5eb6299618faca33db715307ad6", "ext": "rs", "lang": "Rust", "content": "fn with_project_tools() {\n            let expected = \"\u26a1\ufe0f Currently active tools:\n\n    Node: v12.2.0 (current @ ~/path/to/project.json)\n    npm: v6.13.1 (current @ ~/path/to/project.json)\n    Yarn: v1.16.0 (current @ ~/path/to/project.json)\n    Tool binaries available:\n        create-react-app (current @ ~/path/to/project.json)\n        tsc, tsserver (default)\n\nSee options for more detailed reports by running `volta list --help`.\";\n\n            let runtime = Some(Box::new(Node {\n                source: Source::Project(PROJECT_PATH.clone()),\n                version: NODE_12.clone(),\n            }));\n            let package_managers = vec![\n                PackageManager {\n                    kind: PackageManagerKind::Npm,\n                    source: Source::Project(PROJECT_PATH.clone()),\n                    version: NPM_VERSION.clone(),\n                },\n                PackageManager {\n                    kind: PackageManagerKind::Yarn,\n                    source: Source::Project(PROJECT_PATH.clone()),\n                    version: YARN_VERSION.clone(),\n                },\n            ];\n            let packages = vec![\n                Package::Project {\n                    name: \"create-react-app\".to_string(),\n                    path: PROJECT_PATH.clone(),\n                    tools: vec![\"create-react-app\".to_string()],\n                },\n                Package::Default {\n                    details: PackageDetails {\n                        name: \"typescript\".to_string(),\n                        version: Version::from((3, 4, 3)),\n                    },\n                    node: NODE_12.clone(),\n                    tools: vec![\"tsc\".to_string(), \"tsserver\".to_string()],\n                },\n            ];\n\n            assert_eq!(\n                display_active(&runtime, &package_managers, &packages),\n                expected\n            );\n        }", "item_id": 15, "repo": "gregjopa/volta", "file": "src/command/list/human.rs", "last_update_at": "2021-05-15T10:18:41+00:00", "question_id": "5db25372330da5eb6299618faca33db715307ad6_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn with_project_tools() {\n            let expected = \"\u26a1\ufe0f Currently active tools:\n    Node: v12.2.0 (current @ ~/path/to/project.json)\n    npm: v6.13.1 (current @ ~/path/to/project.json)\n    Yarn: v1.16.0 (current @ ~/path/to/project.json)\n    Tool binaries available:\n        create-react-app (current @ ~/path/to/project.json)\n        tsc, tsserver (default)\nSee options for more detailed reports by running `volta list --help`.\";\n            let runtime = Some(Box::new(Node {\n                source: Source::Project(PROJECT_PATH.clone()),\n                version: NODE_12.clone(),\n            }));\n            let package_managers = vec![\n                PackageManager {\n                    kind: PackageManagerKind::Npm,\n                    source: Source::Project(PROJECT_PATH.clone()),\n                    version: NPM_VERSION.clone(),\n                },\n                PackageManager {\n                    kind: PackageManagerKind::Yarn,\n                    source: Source::Project(PROJECT_PATH.clone()),\n                    version: YARN_VERSION.clone(),\n                },\n            ];\n            let packages = vec![\n                Package::Project {\n                    name: \"create-react-app\".to_string(),\n                    path: PROJECT_PATH.clone(),\n                    tools: vec![\"create-react-app\".to_string()],\n                },\n                Package::Default {\n                    details: PackageDetails {\n                        name: \"typescript\".to_string(),\n                        version: Version::from((3, 4, 3)),\n                    },\n                    node: NODE_12.clone(),\n                    tools: vec![\"tsc\".to_string(), \"tsserver\".to_string()],\n                },\n            ];\n            assert_eq!(\n                display_active(&runtime, &package_managers, &packages),\n                expected\n            );\n"]], "pred": {"ppl": 2.491840124130249, "ppl_lower": 2.754838466644287, "ppl/lowercase_ppl": -1.1098959565656465, "ppl/zlib": 0.0015242428100520496, "Min_5.0% Prob": 7.617389440536499, "Min_10.0% Prob": 5.969723604163345, "Min_20.0% Prob": 4.052848429095988, "Min_30.0% Prob": 2.954280262090722, "Min_40.0% Prob": 2.262728612926708, "Min_50.0% Prob": 1.825179642444946, "Min_60.0% Prob": 1.524946449858026}}
{"hexsha": "e913ff3b57e18c9f8c91e7000124039928661733", "ext": "rs", "lang": "Rust", "content": "fn atlas_basic() {\n    let mut atlas = AtlasAllocator::new(size2(1000, 1000));\n\n    let full = atlas.allocate(size2(1000, 1000)).unwrap().0;\n    assert!(atlas.allocate(size2(1, 1)).is_none());\n\n    atlas.deallocate(full);\n\n    let a = atlas.allocate(size2(10, 10)).unwrap().0;\n    let b = atlas.allocate(size2(50, 30)).unwrap().0;\n    let c = atlas.allocate(size2(12, 45)).unwrap().0;\n    let d = atlas.allocate(size2(60, 45)).unwrap().0;\n    let e = atlas.allocate(size2(1, 1)).unwrap().0;\n    let f = atlas.allocate(size2(128, 128)).unwrap().0;\n    let g = atlas.allocate(size2(256, 256)).unwrap().0;\n\n    atlas.deallocate(b);\n    atlas.deallocate(f);\n    atlas.deallocate(c);\n    atlas.deallocate(e);\n    let h = atlas.allocate(size2(500, 200)).unwrap().0;\n    atlas.deallocate(a);\n    let i = atlas.allocate(size2(500, 200)).unwrap().0;\n    atlas.deallocate(g);\n    atlas.deallocate(h);\n    atlas.deallocate(d);\n    atlas.deallocate(i);\n\n    let full = atlas.allocate(size2(1000, 1000)).unwrap().0;\n    assert!(atlas.allocate(size2(1, 1)).is_none());\n    atlas.deallocate(full);\n}", "item_id": 3, "repo": "nical/texture-atlas", "file": "src/etagere.rs", "last_update_at": "2021-04-13T01:58:00+00:00", "question_id": "e913ff3b57e18c9f8c91e7000124039928661733_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn atlas_basic() {\n    let mut atlas = AtlasAllocator::new(size2(1000, 1000));\n    let full = atlas.allocate(size2(1000, 1000)).unwrap().0;\n    assert!(atlas.allocate(size2(1, 1)).is_none());\n    atlas.deallocate(full);\n    let a = atlas.allocate(size2(10, 10)).unwrap().0;\n    let b = atlas.allocate(size2(50, 30)).unwrap().0;\n    let c = atlas.allocate(size2(12, 45)).unwrap().0;\n    let d = atlas.allocate(size2(60, 45)).unwrap().0;\n    let e = atlas.allocate(size2(1, 1)).unwrap().0;\n    let f = atlas.allocate(size2(128, 128)).unwrap().0;\n    let g = atlas.allocate(size2(256, 256)).unwrap().0;\n    atlas.deallocate(b);\n    atlas.deallocate(f);\n    atlas.deallocate(c);\n    atlas.deallocate(e);\n    let h = atlas.allocate(size2(500, 200)).unwrap().0;\n    atlas.deallocate(a);\n    let i = atlas.allocate(size2(500, 200)).unwrap().0;\n    atlas.deallocate(g);\n    atlas.deallocate(h);\n    atlas.deallocate(d);\n    atlas.deallocate(i);\n    let full = atlas.allocate(size2(1000, 1000)).unwrap().0;\n    assert!(atlas.allocate(size2(1, 1)).is_none());\n    atlas.deallocate(full);\n"]], "pred": {"ppl": 1.4587762355804443, "ppl_lower": 1.505252718925476, "ppl/lowercase_ppl": -1.0830590294675353, "ppl/zlib": 0.0015225721348009749, "Min_5.0% Prob": 4.400701294342677, "Min_10.0% Prob": 2.957452581853283, "Min_20.0% Prob": 1.7798097263080905, "Min_30.0% Prob": 1.2512828886911675, "Min_40.0% Prob": 0.9438583084730187, "Min_50.0% Prob": 0.7546714702161074, "Min_60.0% Prob": 0.63043001125863}}
{"hexsha": "6ae9adfcdbb7b211818a1d238e9eec94778570c2", "ext": "rs", "lang": "Rust", "content": "fn load_auth_provider(args: &clap::ArgMatches) -> Result<HeaderV4AuthorisationProvider, IoError> {\n    let access_tokens = args.value_of(\"access_tokens\").unwrap();\n    let access_tokens = AccessToken::load_from(access_tokens)?;\n    Ok(HeaderV4AuthorisationProvider::new(access_tokens))\n}", "item_id": 2, "repo": "ushkarev/rusty-kms", "file": "src/main.rs", "last_update_at": "2021-04-16T16:55:57+00:00", "question_id": "6ae9adfcdbb7b211818a1d238e9eec94778570c2_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn load_auth_provider(args: &clap::ArgMatches) -> Result<HeaderV4AuthorisationProvider, IoError> {\n    let access_tokens = args.value_of(\"access_tokens\").unwrap();\n    let access_tokens = AccessToken::load_from(access_tokens)?;\n    Ok(HeaderV4AuthorisationProvider::new(access_tokens))\n"]], "pred": {"ppl": 3.411076068878174, "ppl_lower": 5.688318252563477, "ppl/lowercase_ppl": -1.4167687451815874, "ppl/zlib": 0.006816821134649189, "Min_5.0% Prob": 8.638872146606445, "Min_10.0% Prob": 7.3407966825697155, "Min_20.0% Prob": 5.316435012552473, "Min_30.0% Prob": 3.8805226904374583, "Min_40.0% Prob": 2.9604491607562915, "Min_50.0% Prob": 2.4393621508194054, "Min_60.0% Prob": 2.066104878620668}}
{"hexsha": "9c1c5f7dc7aec65b223ee08ce83976aa8406b267", "ext": "rs", "lang": "Rust", "content": "fn rountrip_basic() {\n        let from_keypair = Keypair::gen_keypair();\n        let format = format::Basic {\n            pwhash: PWHash::argon2id13_default(),\n        };\n        let password = b\"passsword\";\n        let wallet = Wallet::encrypt(&from_keypair, password, Format::Basic(format))\n            .expect(\"wallet creation\");\n        let to_keypair = wallet.decrypt(password).expect(\"wallet to keypair\");\n        assert_eq!(from_keypair, to_keypair);\n    }", "item_id": 0, "repo": "Wheaties466/helium-wallet-rs", "file": "src/wallet.rs", "last_update_at": "2021-08-18T23:33:20+00:00", "question_id": "9c1c5f7dc7aec65b223ee08ce83976aa8406b267_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn rountrip_basic() {\n        let from_keypair = Keypair::gen_keypair();\n        let format = format::Basic {\n            pwhash: PWHash::argon2id13_default(),\n        };\n        let password = b\"passsword\";\n        let wallet = Wallet::encrypt(&from_keypair, password, Format::Basic(format))\n            .expect(\"wallet creation\");\n        let to_keypair = wallet.decrypt(password).expect(\"wallet to keypair\");\n        assert_eq!(from_keypair, to_keypair);\n"]], "pred": {"ppl": 3.537933588027954, "ppl_lower": 3.627927541732788, "ppl/lowercase_ppl": -1.019879607635724, "ppl/zlib": 0.0054936644544009644, "Min_5.0% Prob": 9.336785452706474, "Min_10.0% Prob": 7.697688477379935, "Min_20.0% Prob": 5.45090546279118, "Min_30.0% Prob": 4.003430037335916, "Min_40.0% Prob": 3.0981341191267564, "Min_50.0% Prob": 2.5156497196168512, "Min_60.0% Prob": 2.107760755198725}}
{"hexsha": "984aeded2839855438f53fc26fe6fdf1ef4b8e08", "ext": "rs", "lang": "Rust", "content": "pub fn parse(file: &str) -> Makefile {\n    // rule line with deps\n    // https://www.gnu.org/software/make/manual/html_node/Rule-Syntax.html#Rule-Syntax\n    let rule = Regex::new(\"^([a-zA-Z-_]+):(.*)?\").unwrap();\n    // rule body lines, intended by tabs\n    let rule_body = Regex::new(\"^\\t+(.*)\").unwrap();\n\n    // http://www.gnu.org/software/make/manual/make.html#Reading-Makefiles\n    // variables come in the forms =, :=, ::=, +=, and ?=\n    let var = Regex::new(\"^([a-zA-Z-_]+)\\\\s*(=|:=|::=|\\\\+=|\\\\?=)(.*)\").unwrap();\n\n    // special .-prefixed vars\n    let special_var = Regex::new(\"^\\\\.([a-zA-Z-_]+):(.*)\").unwrap();\n\n    let mut makefile = Makefile::new();\n    for (i, line) in file.lines().filter(|l| !l.is_empty() && !l.starts_with('#')).enumerate() {\n        if let Some(rule) = rule.captures(line) {\n            if let Some(target) = rule.at(1) {\n                let deps = rule.at(2)\n                    .map(|d| {\n                        d.trim()\n                            .split(\" \")\n                            .filter(|d| !d.is_empty())\n                            .map(|d| d.to_owned())\n                            .collect::<Vec<_>>()\n                    })\n                    .unwrap_or(vec![]);\n                makefile.add_rule(Rule {\n                    target: target.to_owned(),\n                    dependencies: deps,\n                    line: i,\n                    ..Default::default()\n                })\n            }\n        } else if let Some(body) = rule_body.captures(line) {\n            if let Some(bod) = body.at(1) {\n                makefile.rule_line(bod.trim().to_owned());\n            }\n        } else if let Some(var) = var.captures(line) {\n            if let (Some(k), Some(b), Some(v)) = (var.at(1), var.at(2), var.at(3)) {\n                let (key, value) = (k.to_owned(), v.trim().to_owned());\n                let v = match b {\n                        \"=\" => Var::Eq(key, value, i),\n                        \":=\" => Var::ColonEq(key, value, i),\n                        \"::=\" => Var::DoubleColonEq(key, value, i),\n                        \"+=\" => Var::PlusEq(key, value, i),\n                        \"?=\" => Var::QuestionEq(key, value, i),\n                        _ => unreachable!()\n                };\n                makefile.add_var(v);\n            }\n        } else if let Some(var) = special_var.captures(line) {\n            if let (Some(k), Some(v)) = (var.at(1), var.at(2)) {\n                let v = Var::Special(k.to_owned(), v.trim().to_owned(), i);\n                makefile.add_var(v);\n            }\n        } else {\n            println!(\"unparsed line! '{}''\", line)\n        }\n    }\n    makefile\n}", "item_id": 0, "repo": "softprops/mint", "file": "src/parse.rs", "last_update_at": "2021-09-06T12:37:59+00:00", "question_id": "984aeded2839855438f53fc26fe6fdf1ef4b8e08_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn parse(file: &str) -> Makefile {\n    // rule line with deps\n    // https://www.gnu.org/software/make/manual/html_node/Rule-Syntax.html#Rule-Syntax\n    let rule = Regex::new(\"^([a-zA-Z-_]+):(.*)?\").unwrap();\n    // rule body lines, intended by tabs\n    let rule_body = Regex::new(\"^\\t+(.*)\").unwrap();\n    // http://www.gnu.org/software/make/manual/make.html#Reading-Makefiles\n    // variables come in the forms =, :=, ::=, +=, and ?=\n    let var = Regex::new(\"^([a-zA-Z-_]+)\\\\s*(=|:=|::=|\\\\+=|\\\\?=)(.*)\").unwrap();\n    // special .-prefixed vars\n    let special_var = Regex::new(\"^\\\\.([a-zA-Z-_]+):(.*)\").unwrap();\n    let mut makefile = Makefile::new();\n    for (i, line) in file.lines().filter(|l| !l.is_empty() && !l.starts_with('#')).enumerate() {\n        if let Some(rule) = rule.captures(line) {\n            if let Some(target) = rule.at(1) {\n                let deps = rule.at(2)\n                    .map(|d| {\n                        d.trim()\n                            .split(\" \")\n                            .filter(|d| !d.is_empty())\n                            .map(|d| d.to_owned())\n                            .collect::<Vec<_>>()\n                    })\n                    .unwrap_or(vec![]);\n                makefile.add_rule(Rule {\n                    target: target.to_owned(),\n                    dependencies: deps,\n                    line: i,\n                    ..Default::default()\n                })\n            }\n        } else if let Some(body) = rule_body.captures(line) {\n            if let Some(bod) = body.at(1) {\n                makefile.rule_line(bod.trim().to_owned());\n            }\n        } else if let Some(var) = var.captures(line) {\n            if let (Some(k), Some(b), Some(v)) = (var.at(1), var.at(2), var.at(3)) {\n                let (key, value) = (k.to_owned(), v.trim().to_owned());\n                let v = match b {\n                        \"=\" => Var::Eq(key, value, i),\n                        \":=\" => Var::ColonEq(key, value, i),\n                        \"::=\" => Var::DoubleColonEq(key, value, i),\n                        \"+=\" => Var::PlusEq(key, value, i),\n                        \"?=\" => Var::QuestionEq(key, value, i),\n                        _ => unreachable!()\n                };\n                makefile.add_var(v);\n            }\n        } else if let Some(var) = special_var.captures(line) {\n            if let (Some(k), Some(v)) = (var.at(1), var.at(2)) {\n                let v = Var::Special(k.to_owned(), v.trim().to_owned(), i);\n                makefile.add_var(v);\n            }\n        } else {\n            println!(\"unparsed line! '{}''\", line)\n        }\n    }\n    makefile\n"]], "pred": {"ppl": 1.7789491415023804, "ppl_lower": 1.9509785175323486, "ppl/lowercase_ppl": -1.1602509958693141, "ppl/zlib": 0.0006923351202218238, "Min_5.0% Prob": 5.882179317020235, "Min_10.0% Prob": 4.206857099419548, "Min_20.0% Prob": 2.6535414152202152, "Min_30.0% Prob": 1.8771926870658284, "Min_40.0% Prob": 1.4289923498091959, "Min_50.0% Prob": 1.1502304153645195, "Min_60.0% Prob": 0.9606140453921687}}
{"hexsha": "4e967138d8e6d96ef46aeea0f9f8bacf30bc9ac5", "ext": "rs", "lang": "Rust", "content": "fn test_vector3_rotate_y() {\n        let a = Vec3(3.0, 0.5, 0.5);\n\n        let rotated = a.rotate_y(90.0);\n        assert_approx_eq!(rotated.0, 0.5, ASSERT_MARGIN);\n        assert_approx_eq!(rotated.1, 0.5, ASSERT_MARGIN);\n        assert_approx_eq!(rotated.2, -3.0, ASSERT_MARGIN);\n\n        let rotated = a.rotate_y(-90.0);\n        assert_approx_eq!(rotated.0, -0.5, ASSERT_MARGIN);\n        assert_approx_eq!(rotated.1, 0.5, ASSERT_MARGIN);\n        assert_approx_eq!(rotated.2, 3.0, ASSERT_MARGIN);\n    }", "item_id": 2, "repo": "jschouls/cpu_raytracer", "file": "src/math/vector.rs", "last_update_at": "2021-05-28T09:00:40+00:00", "question_id": "4e967138d8e6d96ef46aeea0f9f8bacf30bc9ac5_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_vector3_rotate_y() {\n        let a = Vec3(3.0, 0.5, 0.5);\n        let rotated = a.rotate_y(90.0);\n        assert_approx_eq!(rotated.0, 0.5, ASSERT_MARGIN);\n        assert_approx_eq!(rotated.1, 0.5, ASSERT_MARGIN);\n        assert_approx_eq!(rotated.2, -3.0, ASSERT_MARGIN);\n        let rotated = a.rotate_y(-90.0);\n        assert_approx_eq!(rotated.0, -0.5, ASSERT_MARGIN);\n        assert_approx_eq!(rotated.1, 0.5, ASSERT_MARGIN);\n        assert_approx_eq!(rotated.2, 3.0, ASSERT_MARGIN);\n"]], "pred": {"ppl": 1.5536856651306152, "ppl_lower": 1.6830567121505737, "ppl/lowercase_ppl": -1.181516607466986, "ppl/zlib": 0.0029572480321775002, "Min_5.0% Prob": 5.100184418938377, "Min_10.0% Prob": 3.7013241311778193, "Min_20.0% Prob": 2.15888956869426, "Min_30.0% Prob": 1.460834847071341, "Min_40.0% Prob": 1.107195740635757, "Min_50.0% Prob": 0.88082541193232, "Min_60.0% Prob": 0.7363620648597134}}
{"hexsha": "2b3fc09cc7f9bd69b77b67df6c96b887959fa8dc", "ext": "rs", "lang": "Rust", "content": "fn func_donate_thunk(ctx: &ScFuncContext) {\n\tctx.log(\"donatewithfeedback.funcDonate\");\n\tlet f = DonateContext {\n\t\tparams: ImmutableDonateParams { proxy: params_proxy() },\n\t\tstate: MutableDonateWithFeedbackState { proxy: state_proxy() },\n\t};\n\tfunc_donate(ctx, &f);\n\tctx.log(\"donatewithfeedback.funcDonate ok\");\n}", "item_id": 0, "repo": "Dr-Electron/wasp", "file": "contracts/wasm/donatewithfeedback/src/lib.rs", "last_update_at": "2021-11-07T15:43:51+00:00", "question_id": "2b3fc09cc7f9bd69b77b67df6c96b887959fa8dc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn func_donate_thunk(ctx: &ScFuncContext) {\n\tctx.log(\"donatewithfeedback.funcDonate\");\n\tlet f = DonateContext {\n\t\tparams: ImmutableDonateParams { proxy: params_proxy() },\n\t\tstate: MutableDonateWithFeedbackState { proxy: state_proxy() },\n\t};\n\tfunc_donate(ctx, &f);\n\tctx.log(\"donatewithfeedback.funcDonate ok\");\n"]], "pred": {"ppl": 2.0861737728118896, "ppl_lower": 5.367080211639404, "ppl/lowercase_ppl": -2.285069630073486, "ppl/zlib": 0.00397476571583322, "Min_5.0% Prob": 8.95323143005371, "Min_10.0% Prob": 6.113403927196156, "Min_20.0% Prob": 3.4593908734943555, "Min_30.0% Prob": 2.439599585883758, "Min_40.0% Prob": 1.8289835563172465, "Min_50.0% Prob": 1.480893808972548, "Min_60.0% Prob": 1.2246491499582604}}
{"hexsha": "81c6311b6b1edd46ffab1fc1e85edcf717111bd8", "ext": "rs", "lang": "Rust", "content": "async fn it_returns_safe_illustrations() {\n    common::setup();\n    let client = PixivClient::new();\n\n    for id in SAFE_ILLUSTRATION_IDS {\n        let illustration = client.illustration(id).await.unwrap();\n        assert_eq!(illustration.id, *id);\n        assert!(illustration.title.len() > 0);\n        assert!(illustration.tags.tags.len() > 0);\n        assert_eq!(illustration.age_restrict, 0);\n    }\n}", "item_id": 0, "repo": "Trivernis/pixiv-rs", "file": "tests/test_illustrations.rs", "last_update_at": "2021-09-06T18:07:10+00:00", "question_id": "81c6311b6b1edd46ffab1fc1e85edcf717111bd8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn it_returns_safe_illustrations() {\n    common::setup();\n    let client = PixivClient::new();\n    for id in SAFE_ILLUSTRATION_IDS {\n        let illustration = client.illustration(id).await.unwrap();\n        assert_eq!(illustration.id, *id);\n        assert!(illustration.title.len() > 0);\n        assert!(illustration.tags.tags.len() > 0);\n        assert_eq!(illustration.age_restrict, 0);\n    }\n"]], "pred": {"ppl": 2.8118512630462646, "ppl_lower": 3.373332977294922, "ppl/lowercase_ppl": -1.1760984761291553, "ppl/zlib": 0.004764253819797081, "Min_5.0% Prob": 9.54675555229187, "Min_10.0% Prob": 7.232960517589863, "Min_20.0% Prob": 4.612582963246566, "Min_30.0% Prob": 3.254101974517107, "Min_40.0% Prob": 2.539002541101204, "Min_50.0% Prob": 2.0435392767635743, "Min_60.0% Prob": 1.7230159231461584}}
{"hexsha": "eaeb3416666044774f759822997b409f44227516", "ext": "rs", "lang": "Rust", "content": "fn test_server() -> GameServer {\n        // Address for player 0\n        let channel: (\n            channel::AddressSender<Websocket>,\n            channel::AddressReceiver<Websocket>,\n        ) = channel::channel(1024);\n        let addr0 = Addr::new(channel.0);\n\n        // Address for player 1\n        let channel: (\n            channel::AddressSender<Websocket>,\n            channel::AddressReceiver<Websocket>,\n        ) = channel::channel(1024);\n        let addr1 = Addr::new(channel.0);\n\n        let mut server = GameServer::new();\n\n        server.clients.push(addr0);\n        server.clients.push(addr1);\n\n        server\n    }", "item_id": 0, "repo": "Miol-Mor/battle-game", "file": "backend/src/game_server.rs", "last_update_at": "2021-05-27T15:16:23+00:00", "question_id": "eaeb3416666044774f759822997b409f44227516_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_server() -> GameServer {\n        // Address for player 0\n        let channel: (\n            channel::AddressSender<Websocket>,\n            channel::AddressReceiver<Websocket>,\n        ) = channel::channel(1024);\n        let addr0 = Addr::new(channel.0);\n        // Address for player 1\n        let channel: (\n            channel::AddressSender<Websocket>,\n            channel::AddressReceiver<Websocket>,\n        ) = channel::channel(1024);\n        let addr1 = Addr::new(channel.0);\n        let mut server = GameServer::new();\n        server.clients.push(addr0);\n        server.clients.push(addr1);\n        server\n"]], "pred": {"ppl": 2.3480064868927, "ppl_lower": 2.671166181564331, "ppl/lowercase_ppl": -1.1510701973461432, "ppl/zlib": 0.004246600321856551, "Min_5.0% Prob": 7.784784197807312, "Min_10.0% Prob": 5.921091963263119, "Min_20.0% Prob": 3.8977722712925504, "Min_30.0% Prob": 2.798186613141366, "Min_40.0% Prob": 2.1287172298196335, "Min_50.0% Prob": 1.7056363730094908, "Min_60.0% Prob": 1.4330199611316137}}
{"hexsha": "da744eb06693d9613fa7caeb5923caa230ccc25f", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<()> {\n    //Dump {}.run()?;\n    let opts = Opts::parse();\n\n    let hid = hidapi::HidApi::new()?;\n    let mut dev = GloriousDevice::open_first(&hid)?;\n    dev.send_msg(0x02, 1)?;\n\n    match opts.cmd {\n        Command::Dump(dump) => dump.run(&mut dev),\n        Command::Button(b) => b.run(&mut dev),\n        Command::Rgb { rgbcmd } => rgbcmd.run(&mut dev),\n        Command::Dpi(dpi) => dpi.run(&mut dev),\n        Command::Macro(macro_) => macro_.run(&mut dev),\n    }\n}", "item_id": 0, "repo": "sammko/gloryctl", "file": "src/main.rs", "last_update_at": "2021-12-06T22:55:36+00:00", "question_id": "da744eb06693d9613fa7caeb5923caa230ccc25f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<()> {\n    //Dump {}.run()?;\n    let opts = Opts::parse();\n    let hid = hidapi::HidApi::new()?;\n    let mut dev = GloriousDevice::open_first(&hid)?;\n    dev.send_msg(0x02, 1)?;\n    match opts.cmd {\n        Command::Dump(dump) => dump.run(&mut dev),\n        Command::Button(b) => b.run(&mut dev),\n        Command::Rgb { rgbcmd } => rgbcmd.run(&mut dev),\n        Command::Dpi(dpi) => dpi.run(&mut dev),\n        Command::Macro(macro_) => macro_.run(&mut dev),\n    }\n"]], "pred": {"ppl": 3.158189535140991, "ppl_lower": 4.154785633087158, "ppl/lowercase_ppl": -1.2384888328626702, "ppl/zlib": 0.0045454503221075354, "Min_5.0% Prob": 9.237759113311768, "Min_10.0% Prob": 6.796471026208666, "Min_20.0% Prob": 4.644634163057482, "Min_30.0% Prob": 3.546040987968445, "Min_40.0% Prob": 2.799050789829847, "Min_50.0% Prob": 2.2800531595624904, "Min_60.0% Prob": 1.9218918761020307}}
{"hexsha": "afcb31291c6c5d54f3c25dddbdb964b276defc7a", "ext": "rs", "lang": "Rust", "content": "async fn fetch(\n    client: &reqwest::Client,\n    url: &str,\n    path_buf: PathBuf,\n    problem: Oj,\n) -> Result<(), Box<dyn std::error::Error>> {\n    use io::ErrorKind::{NotFound, PermissionDenied};\n\n    if path_buf.exists() {\n        return Ok(());\n    }\n\n    let client = match problem {\n        Yukicoder(_) => client.get(url).bearer_auth(yukitoken()),\n        Aoj(_) => client.get(url),\n    };\n    let content = client.send().await?.text().await?;\n\n    if content == \"/* This is a single file for multiple testcases. serial should be 1. */\"{\n        Err(Box::new(io::Error::new(NotFound, \"no more cases\")))\n    } else if content.starts_with(\"/* Test case #\") && content.ends_with(\" is not available. */\") {\n        Err(Box::new(io::Error::new(PermissionDenied, \"not available\")))\n    } else {\n        let mut file = std::fs::File::create(&path_buf)?;\n        file.write_all(content.as_bytes())?;\n        eprintln!(\"save to {:#?}\", file);\n        Ok(())\n    }\n}", "item_id": 1, "repo": "rsk0315/library-rs", "file": "verifiers/download/src/lib.rs", "last_update_at": "2021-12-29T13:48:59+00:00", "question_id": "afcb31291c6c5d54f3c25dddbdb964b276defc7a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn fetch(\n    client: &reqwest::Client,\n    url: &str,\n    path_buf: PathBuf,\n    problem: Oj,\n) -> Result<(), Box<dyn std::error::Error>> {\n    use io::ErrorKind::{NotFound, PermissionDenied};\n    if path_buf.exists() {\n        return Ok(());\n    }\n    let client = match problem {\n        Yukicoder(_) => client.get(url).bearer_auth(yukitoken()),\n        Aoj(_) => client.get(url),\n    };\n    let content = client.send().await?.text().await?;\n    if content == \"/* This is a single file for multiple testcases. serial should be 1. */\"{\n        Err(Box::new(io::Error::new(NotFound, \"no more cases\")))\n    } else if content.starts_with(\"/* Test case #\") && content.ends_with(\" is not available. */\") {\n        Err(Box::new(io::Error::new(PermissionDenied, \"not available\")))\n    } else {\n        let mut file = std::fs::File::create(&path_buf)?;\n        file.write_all(content.as_bytes())?;\n        eprintln!(\"save to {:#?}\", file);\n        Ok(())\n    }\n"]], "pred": {"ppl": 2.9555890560150146, "ppl_lower": 3.5946004390716553, "ppl/lowercase_ppl": -1.1806175458546513, "ppl/zlib": 0.0021544691314694204, "Min_5.0% Prob": 9.010672777891159, "Min_10.0% Prob": 6.8188331797719, "Min_20.0% Prob": 4.567639879882336, "Min_30.0% Prob": 3.3935397447397313, "Min_40.0% Prob": 2.6499079821645752, "Min_50.0% Prob": 2.1628410190066196, "Min_60.0% Prob": 1.8111342005914202}}
{"hexsha": "301dc60c2f8048798447213759b50c5234c7b0c7", "ext": "rs", "lang": "Rust", "content": "fn write_body(multi: &mut Multipart<Request<Streaming>>) -> hyper::Result<()> {\n    let mut binary = \"Hello world from binary!\".as_bytes();\n\n    multi.write_text(\"text\", \"Hello, world!\")?;\n    multi.write_file(\"file\", \"lorem_ipsum.txt\")?;\n    // &[u8] impl Read\n    multi\n        .write_stream(\"binary\", &mut binary, None, None)\n        .and(Ok(()))\n}", "item_id": 1, "repo": "bachue/multipart", "file": "examples/hyper_client.rs", "last_update_at": "2021-04-25T11:33:11+00:00", "question_id": "301dc60c2f8048798447213759b50c5234c7b0c7_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn write_body(multi: &mut Multipart<Request<Streaming>>) -> hyper::Result<()> {\n    let mut binary = \"Hello world from binary!\".as_bytes();\n    multi.write_text(\"text\", \"Hello, world!\")?;\n    multi.write_file(\"file\", \"lorem_ipsum.txt\")?;\n    // &[u8] impl Read\n    multi\n        .write_stream(\"binary\", &mut binary, None, None)\n        .and(Ok(()))\n"]], "pred": {"ppl": 4.050015926361084, "ppl_lower": 5.698184013366699, "ppl/lowercase_ppl": -1.2440992606104122, "ppl/zlib": 0.006081394841502397, "Min_5.0% Prob": 8.817680358886719, "Min_10.0% Prob": 7.03500513235728, "Min_20.0% Prob": 5.202302306890488, "Min_30.0% Prob": 4.084412044949001, "Min_40.0% Prob": 3.3145594840147057, "Min_50.0% Prob": 2.7558958080948375, "Min_60.0% Prob": 2.3347359358856123}}
{"hexsha": "c5fb082f6c1c020ced5a2b2ba571a8f1e84af913", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    unsafe { pinmux_init() };\n\n    log_init();\n\n    info!(\"Hello World\");\n\n    TSEC.init();\n\n    bring_up_sors();\n\n    let mut argument0 = 0;\n    let mut argument1 = 0;\n    let res = execute_tsec_fw(&*FALCON_FW, 0, &mut argument0, &mut argument1);\n\n    info!(\"{:?}\", res);\n    info!(\"argument0: 0x{:x}\", argument0);\n    info!(\"argument1: 0x{:x}\", argument1);\n\n    TSEC.finalize();\n}", "item_id": 2, "repo": "Thog/rboot", "file": "src/main.rs", "last_update_at": "2021-02-11T21:46:59+00:00", "question_id": "c5fb082f6c1c020ced5a2b2ba571a8f1e84af913_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    unsafe { pinmux_init() };\n    log_init();\n    info!(\"Hello World\");\n    TSEC.init();\n    bring_up_sors();\n    let mut argument0 = 0;\n    let mut argument1 = 0;\n    let res = execute_tsec_fw(&*FALCON_FW, 0, &mut argument0, &mut argument1);\n    info!(\"{:?}\", res);\n    info!(\"argument0: 0x{:x}\", argument0);\n    info!(\"argument1: 0x{:x}\", argument1);\n    TSEC.finalize();\n"]], "pred": {"ppl": 4.268978118896484, "ppl_lower": 4.371508598327637, "ppl/lowercase_ppl": -1.0163525572839356, "ppl/zlib": 0.007114580795010317, "Min_5.0% Prob": 11.188745634896415, "Min_10.0% Prob": 9.1895050684611, "Min_20.0% Prob": 6.325460134014007, "Min_30.0% Prob": 4.536212489960041, "Min_40.0% Prob": 3.5690325777376852, "Min_50.0% Prob": 2.895408090299521, "Min_60.0% Prob": 2.4189901172005115}}
{"hexsha": "66f4adf594e0743d9ab9ff27d4c5bf767504cf99", "ext": "rs", "lang": "Rust", "content": "fn test_complex_log() {\n        let s1 = Complex::new(f64x2::new(1.5, 0.0), f64x2::new(10.0, 0.0));\n        let gt = Complex::new(\n            f64x2::new(2.3137103974614557, -1.1772777930167866e-16),\n            f64x2::new(1.4219063791853994, -4.7442629531916207e-17),\n        );\n        assert_complex_close(s1.ln(), gt, 1e-30);\n    }", "item_id": 1, "repo": "roosephu/apc", "file": "F64x2/src/functions.rs", "last_update_at": "2021-05-12T06:35:11+00:00", "question_id": "66f4adf594e0743d9ab9ff27d4c5bf767504cf99_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_complex_log() {\n        let s1 = Complex::new(f64x2::new(1.5, 0.0), f64x2::new(10.0, 0.0));\n        let gt = Complex::new(\n            f64x2::new(2.3137103974614557, -1.1772777930167866e-16),\n            f64x2::new(1.4219063791853994, -4.7442629531916207e-17),\n        );\n        assert_complex_close(s1.ln(), gt, 1e-30);\n"]], "pred": {"ppl": 4.110168933868408, "ppl_lower": 4.213975429534912, "ppl/lowercase_ppl": -1.0176462588275208, "ppl/zlib": 0.007439284898918064, "Min_5.0% Prob": 6.38848696814643, "Min_10.0% Prob": 4.846664817709672, "Min_20.0% Prob": 3.714280794828366, "Min_30.0% Prob": 3.2597263990822487, "Min_40.0% Prob": 2.98243914676618, "Min_50.0% Prob": 2.6792775512945775, "Min_60.0% Prob": 2.3281205895088486}}
{"hexsha": "b52cb94f11dc694822e57050c8da63c984116cbb", "ext": "rs", "lang": "Rust", "content": "pub fn start_stored<'a>(conf_paths: &[&str], lock: &'a ProcLock, filter: LevelFilter) -> Proc<'a> {\n    build_stored();\n\n    let mut proc = lock.lock().unwrap();\n    let processes = if let Some(proc) = &mut *proc {\n        proc.clone()\n    } else {\n        let mut processes = Vec::with_capacity(conf_paths.len());\n\n        for conf_path in conf_paths {\n            let mut child = Command::new(env!(\"CARGO_BIN_EXE_stored\"));\n\n            let capturing_output = if filter == LevelFilter::Off {\n                child.stderr(Stdio::null()).stdout(Stdio::null());\n                false\n            } else {\n                child\n                    .stderr(Stdio::piped())\n                    .stdout(Stdio::piped())\n                    .env(\"LOG_LEVEL\", filter.to_string());\n                if filter >= LevelFilter::Debug {\n                    // Gets a little noisy otherwise.\n                    child.env(\"LOG_TARGET\", \"stored\");\n                }\n                true\n            };\n\n            let mut child = child\n                .stdin(Stdio::null())\n                .arg(conf_path)\n                .spawn()\n                .map(|inner| ChildCommand { inner })\n                .expect(\"unable to start server\");\n\n            if capturing_output {\n                let stdout = Receiver::from(child.inner.stdout.take().unwrap());\n                stdout.set_nonblocking(true).unwrap();\n                STDOUT.lock().unwrap().push(Some(stdout));\n\n                let stderr = Receiver::from(child.inner.stderr.take().unwrap());\n                stderr.set_nonblocking(true).unwrap();\n                STDERR.lock().unwrap().push(Some(stderr));\n\n                match &mut *RELAY.lock().unwrap() {\n                    relay @ None => {\n                        let poll = Poll::new().unwrap();\n                        let new_waker = Waker::new(poll.registry(), NEW_PROCESS).unwrap();\n                        let handle = thread::spawn(move || relay_process_output(poll));\n                        // Ensure it will add the new output.\n                        new_waker.wake().unwrap();\n                        let handle = WaitHandle {\n                            handle: Some(handle),\n                        };\n                        *relay = Some((new_waker, handle));\n                    }\n                    Some((waker, ..)) => waker.wake().unwrap(),\n                }\n            }\n\n            processes.push(child);\n        }\n\n        // Give the processes some time to start and sync up.\n        if conf_paths.len() == 1 {\n            sleep(Duration::from_millis(200));\n        } else {\n            sleep(Duration::from_millis(processes.len() as u64 * 300));\n        }\n\n        let processes = Arc::new(processes.into_boxed_slice());\n        proc.replace(processes.clone());\n        processes\n    };\n    Proc { lock, processes }\n}", "item_id": 1, "repo": "Thomasdezeeuw/stored", "file": "tests/util/mod.rs", "last_update_at": "2021-12-31T20:33:56+00:00", "question_id": "b52cb94f11dc694822e57050c8da63c984116cbb_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn start_stored<'a>(conf_paths: &[&str], lock: &'a ProcLock, filter: LevelFilter) -> Proc<'a> {\n    build_stored();\n    let mut proc = lock.lock().unwrap();\n    let processes = if let Some(proc) = &mut *proc {\n        proc.clone()\n    } else {\n        let mut processes = Vec::with_capacity(conf_paths.len());\n        for conf_path in conf_paths {\n            let mut child = Command::new(env!(\"CARGO_BIN_EXE_stored\"));\n            let capturing_output = if filter == LevelFilter::Off {\n                child.stderr(Stdio::null()).stdout(Stdio::null());\n                false\n            } else {\n                child\n                    .stderr(Stdio::piped())\n                    .stdout(Stdio::piped())\n                    .env(\"LOG_LEVEL\", filter.to_string());\n                if filter >= LevelFilter::Debug {\n                    // Gets a little noisy otherwise.\n                    child.env(\"LOG_TARGET\", \"stored\");\n                }\n                true\n            };\n            let mut child = child\n                .stdin(Stdio::null())\n                .arg(conf_path)\n                .spawn()\n                .map(|inner| ChildCommand { inner })\n                .expect(\"unable to start server\");\n            if capturing_output {\n                let stdout = Receiver::from(child.inner.stdout.take().unwrap());\n                stdout.set_nonblocking(true).unwrap();\n                STDOUT.lock().unwrap().push(Some(stdout));\n                let stderr = Receiver::from(child.inner.stderr.take().unwrap());\n                stderr.set_nonblocking(true).unwrap();\n                STDERR.lock().unwrap().push(Some(stderr));\n                match &mut *RELAY.lock().unwrap() {\n                    relay @ None => {\n                        let poll = Poll::new().unwrap();\n                        let new_waker = Waker::new(poll.registry(), NEW_PROCESS).unwrap();\n                        let handle = thread::spawn(move || relay_process_output(poll));\n                        // Ensure it will add the new output.\n                        new_waker.wake().unwrap();\n                        let handle = WaitHandle {\n                            handle: Some(handle),\n                        };\n                        *relay = Some((new_waker, handle));\n                    }\n                    Some((waker, ..)) => waker.wake().unwrap(),\n                }\n            }\n            processes.push(child);\n        }\n        // Give the processes some time to start and sync up.\n        if conf_paths.len() == 1 {\n            sleep(Duration::from_millis(200));\n        } else {\n            sleep(Duration::from_millis(processes.len() as u64 * 300));\n        }\n        let processes = Arc::new(processes.into_boxed_slice());\n        proc.replace(processes.clone());\n        processes\n    };\n    Proc { lock, processes }\n"]], "pred": {"ppl": 2.357752561569214, "ppl_lower": 2.8960025310516357, "ppl/lowercase_ppl": -1.2397345964275364, "ppl/zlib": 0.0008860628728179317, "Min_5.0% Prob": 7.489881866856625, "Min_10.0% Prob": 5.688719111603576, "Min_20.0% Prob": 3.792523809841701, "Min_30.0% Prob": 2.75965685490922, "Min_40.0% Prob": 2.1255506947394704, "Min_50.0% Prob": 1.7102727936918563, "Min_60.0% Prob": 1.4291725186238842}}
{"hexsha": "bd9c0e4350219e9f6799c1fb4668f1ef90536ff9", "ext": "rs", "lang": "Rust", "content": "fn test_sha256() {\n        let input = b\"\";\n        let expected =\n            hex::decode(\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\")\n                .unwrap();\n\n        let res = SHA256::run(input, 60, &new_context()).unwrap().1;\n        assert_eq!(res, expected);\n    }", "item_id": 0, "repo": "matklad/aurora-engine", "file": "src/precompiles/hash.rs", "last_update_at": "2021-04-29T23:35:09+00:00", "question_id": "bd9c0e4350219e9f6799c1fb4668f1ef90536ff9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_sha256() {\n        let input = b\"\";\n        let expected =\n            hex::decode(\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\")\n                .unwrap();\n        let res = SHA256::run(input, 60, &new_context()).unwrap().1;\n        assert_eq!(res, expected);\n"]], "pred": {"ppl": 2.045555591583252, "ppl_lower": 2.0099024772644043, "ppl/lowercase_ppl": -0.9754310684112922, "ppl/zlib": 0.003508183507458028, "Min_5.0% Prob": 7.109913349151611, "Min_10.0% Prob": 5.0375731358161335, "Min_20.0% Prob": 3.4155989289283752, "Min_30.0% Prob": 2.3550207559019327, "Min_40.0% Prob": 1.8020570512931302, "Min_50.0% Prob": 1.4306630078397358, "Min_60.0% Prob": 1.1986447186507576}}
{"hexsha": "4a45f54d3eac01a9fe0a62d4551ff90e7db04ecc", "ext": "rs", "lang": "Rust", "content": "fn render_world_ch7(name: &str) {\r\n    // World\r\n    let mut world = HittableList {\r\n        objects: Vec::new(),\r\n    };\r\n\r\n    world.add(Sphere {\r\n        center: Point3::new(0.0, 0.0, -1.0),\r\n        radius: 0.5,\r\n    });\r\n    world.add(Sphere {\r\n        center: Point3::new(0.0, -100.5, -1.0),\r\n        radius: 100.0,\r\n    });\r\n\r\n    // Camera\r\n    let cam = Camera::new(RATIO);\r\n\r\n    // create image buffer\r\n    let mut imgbuf = ImageBuffer::new(WIDTH, HEIGHT);\r\n\r\n    // Iterate over the coordinates and pixels of the image\r\n    let len = WIDTH as u64 * HEIGHT as u64;\r\n    let bar = ProgressBar::new(len);\r\n    for (x, y, pixel) in imgbuf.enumerate_pixels_mut() {\r\n        bar.inc(1);\r\n\r\n        let mut c = Color::zero();\r\n        for _s in 0..SAMPLES_PER_PIXEL {\r\n            let u = (x as f64 + random_double()) / (WIDTH as f64 - 1f64);\r\n            let v = ((HEIGHT - y) as f64 + random_double()) / (HEIGHT as f64 - 1f64);\r\n\r\n            let r = cam.get_ray(u, v);\r\n\r\n            c += ray_color_world(&r, &world);\r\n        }\r\n\r\n        *pixel = Rgb(c.to_u8_avg(SAMPLES_PER_PIXEL));\r\n    }\r\n    bar.finish();\r\n\r\n    // write the generated image (format is deduced based on extension)\r\n    imgbuf.save(name).unwrap();\r\n}", "item_id": 6, "repo": "pbmtp/raytracer", "file": "src/backup.rs", "last_update_at": "2021-10-06T00:51:49+00:00", "question_id": "4a45f54d3eac01a9fe0a62d4551ff90e7db04ecc_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn render_world_ch7(name: &str) {\r\n    // World\r\n    let mut world = HittableList {\r\n        objects: Vec::new(),\r\n    };\r\n\r\n    world.add(Sphere {\r\n        center: Point3::new(0.0, 0.0, -1.0),\r\n        radius: 0.5,\r\n    });\r\n    world.add(Sphere {\r\n        center: Point3::new(0.0, -100.5, -1.0),\r\n        radius: 100.0,\r\n    });\r\n\r\n    // Camera\r\n    let cam = Camera::new(RATIO);\r\n\r\n    // create image buffer\r\n    let mut imgbuf = ImageBuffer::new(WIDTH, HEIGHT);\r\n\r\n    // Iterate over the coordinates and pixels of the image\r\n    let len = WIDTH as u64 * HEIGHT as u64;\r\n    let bar = ProgressBar::new(len);\r\n    for (x, y, pixel) in imgbuf.enumerate_pixels_mut() {\r\n        bar.inc(1);\r\n\r\n        let mut c = Color::zero();\r\n        for _s in 0..SAMPLES_PER_PIXEL {\r\n            let u = (x as f64 + random_double()) / (WIDTH as f64 - 1f64);\r\n            let v = ((HEIGHT - y) as f64 + random_double()) / (HEIGHT as f64 - 1f64);\r\n\r\n            let r = cam.get_ray(u, v);\r\n\r\n            c += ray_color_world(&r, &world);\r\n        }\r\n\r\n        *pixel = Rgb(c.to_u8_avg(SAMPLES_PER_PIXEL));\r\n    }\r\n    bar.finish();\r\n\r\n    // write the generated image (format is deduced based on extension)\r\n    imgbuf.save(name).unwrap();\r\n"]], "pred": {"ppl": 1.8830324411392212, "ppl_lower": 2.0878634452819824, "ppl/lowercase_ppl": -1.163154504342463, "ppl/zlib": 0.0010911784102750777, "Min_5.0% Prob": 6.976480214492135, "Min_10.0% Prob": 4.835277445772861, "Min_20.0% Prob": 2.966081047311742, "Min_30.0% Prob": 2.0739084805579897, "Min_40.0% Prob": 1.5745753088886751, "Min_50.0% Prob": 1.2639665472182504, "Min_60.0% Prob": 1.054366302414771}}
{"hexsha": "9be353eaf9cb85e5438acd001f82a58479b6c888", "ext": "rs", "lang": "Rust", "content": "fn discovery_returns_level_1_puzzles_when_in_level_0() -> TmouResult<()> {\n    let inventory = vec![item(\"puzzles\", 0, \"puzzles-0\")];\n\n    // checkpoint with puzzles\n    let node_contents = vec![item(\"puzzles\", 1, \"puzzles-1\")];\n\n    let expected_inventory = vec![\n        item(\"puzzles\", 0, \"puzzles-0\"),\n        item(\"puzzles\", 1, \"puzzles-1\"),\n    ];\n\n    let evt = dis::discover_node(Utc::now(), &inventory, &node_contents)?;\n    assert_eq!(evt.event, dis::EventType::PuzzlesFound);\n    assert_eq!(evt.updated_inventory, expected_inventory);\n    assert_eq!(\n        evt.newly_discovered_items,\n        vec![item(\"puzzles\", 1, \"puzzles-1\")]\n    );\n    Ok(())\n}", "item_id": 2, "repo": "Crypto-ALE/tmou-mapa", "file": "tmou-mapa-backend/src/tests/discovery_tests.rs", "last_update_at": "2021-07-18T13:26:47+00:00", "question_id": "9be353eaf9cb85e5438acd001f82a58479b6c888_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn discovery_returns_level_1_puzzles_when_in_level_0() -> TmouResult<()> {\n    let inventory = vec![item(\"puzzles\", 0, \"puzzles-0\")];\n    // checkpoint with puzzles\n    let node_contents = vec![item(\"puzzles\", 1, \"puzzles-1\")];\n    let expected_inventory = vec![\n        item(\"puzzles\", 0, \"puzzles-0\"),\n        item(\"puzzles\", 1, \"puzzles-1\"),\n    ];\n    let evt = dis::discover_node(Utc::now(), &inventory, &node_contents)?;\n    assert_eq!(evt.event, dis::EventType::PuzzlesFound);\n    assert_eq!(evt.updated_inventory, expected_inventory);\n    assert_eq!(\n        evt.newly_discovered_items,\n        vec![item(\"puzzles\", 1, \"puzzles-1\")]\n    );\n    Ok(())\n"]], "pred": {"ppl": 2.9390206336975098, "ppl_lower": 3.5464982986450195, "ppl/lowercase_ppl": -1.1742773633315322, "ppl/zlib": 0.0036421500272451747, "Min_5.0% Prob": 9.012755274772644, "Min_10.0% Prob": 6.921530237197876, "Min_20.0% Prob": 4.579662425845277, "Min_30.0% Prob": 3.398934893793874, "Min_40.0% Prob": 2.6507346349433787, "Min_50.0% Prob": 2.149718604577604, "Min_60.0% Prob": 1.79831178851666}}
{"hexsha": "100dfcea2b00c219f692e497961c37bec7d1e394", "ext": "rs", "lang": "Rust", "content": "fn get_parameter(&self, name: &str) -> Option<Parameter> {\n        let lock = internal::get_entity(self);\n        let entity = lock.read().unwrap();\n        entity.get_parameter(name)\n    }", "item_id": 5, "repo": "taku-y/primitiv-rust", "file": "src/model.rs", "last_update_at": "2021-11-22T07:39:28+00:00", "question_id": "100dfcea2b00c219f692e497961c37bec7d1e394_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_parameter(&self, name: &str) -> Option<Parameter> {\n        let lock = internal::get_entity(self);\n        let entity = lock.read().unwrap();\n        entity.get_parameter(name)\n"]], "pred": {"ppl": 3.9573545455932617, "ppl_lower": 4.735649585723877, "ppl/lowercase_ppl": -1.130522180489171, "ppl/zlib": 0.010581351984487952, "Min_5.0% Prob": 10.148237228393555, "Min_10.0% Prob": 9.186846160888672, "Min_20.0% Prob": 5.751886649565264, "Min_30.0% Prob": 4.3473893739283085, "Min_40.0% Prob": 3.3213295950130983, "Min_50.0% Prob": 2.7542914350827536, "Min_60.0% Prob": 2.2745927687395704}}
{"hexsha": "9249644d514494de999031f3fc67949e9dc3e447", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    // ANCHOR: here\n    let mut s = String::from(\"hola\");\n\n    {\n        let r1 = &mut s;\n    } // r1 sale del alcance aqui, por lo que podemos hacer una referencia nueva sin problemas.\n\n    let r2 = &mut s;\n    // ANCHOR_END: here\n}", "item_id": 0, "repo": "josemgdt/rust-lang-book-es", "file": "listings/ch04-understanding-ownership/no-listing-11-muts-in-separate-scopes/src/main.rs", "last_update_at": "2021-04-13T20:04:24+00:00", "question_id": "9249644d514494de999031f3fc67949e9dc3e447_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    // ANCHOR: here\n    let mut s = String::from(\"hola\");\n    {\n        let r1 = &mut s;\n    } // r1 sale del alcance aqui, por lo que podemos hacer una referencia nueva sin problemas.\n    let r2 = &mut s;\n    // ANCHOR_END: here\n"]], "pred": {"ppl": 2.216434955596924, "ppl_lower": 4.166241645812988, "ppl/lowercase_ppl": -1.7929567697337052, "ppl/zlib": 0.004522159256967139, "Min_5.0% Prob": 6.927202105522156, "Min_10.0% Prob": 5.542771250009537, "Min_20.0% Prob": 3.5659288658815274, "Min_30.0% Prob": 2.574653921219019, "Min_40.0% Prob": 1.9732053569384984, "Min_50.0% Prob": 1.5857340720566837, "Min_60.0% Prob": 1.3454912162851542}}
{"hexsha": "e4a3c74aeda420cb7cd19c8e11a7c90d1c2b9d1f", "ext": "rs", "lang": "Rust", "content": "extern \"x86-interrupt\" fn timer_interrupt_handler(_frame: InterruptStackFrame) {\n    crate::time::pit_tick();\n    // might not be initialized yet\n    if let Some(exc) = crate::task::executor::GLOBAL_EXECUTOR.get() {\n        exc.sleep_tick_set();\n    }\n\n    match LOCAL_APIC.lock().as_mut() {\n        Some(apic) => unsafe { apic.end_of_interrupt() },\n        None => unsafe { PICS.lock().notify_end_of_interrupt(InterruptIndex::Timer.as_u8()); }\n    }\n}", "item_id": 18, "repo": "trashbyte/os", "file": "kernel/src/arch/x86_64/interrupts.rs", "last_update_at": "2021-04-05T08:12:36+00:00", "question_id": "e4a3c74aeda420cb7cd19c8e11a7c90d1c2b9d1f_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["extern \"x86-interrupt\" fn timer_interrupt_handler(_frame: InterruptStackFrame) {\n    crate::time::pit_tick();\n    // might not be initialized yet\n    if let Some(exc) = crate::task::executor::GLOBAL_EXECUTOR.get() {\n        exc.sleep_tick_set();\n    }\n    match LOCAL_APIC.lock().as_mut() {\n        Some(apic) => unsafe { apic.end_of_interrupt() },\n        None => unsafe { PICS.lock().notify_end_of_interrupt(InterruptIndex::Timer.as_u8()); }\n    }\n"]], "pred": {"ppl": 3.673464298248291, "ppl_lower": 5.45615816116333, "ppl/lowercase_ppl": -1.3040496877220251, "ppl/zlib": 0.0045494236618943, "Min_5.0% Prob": 8.864058494567871, "Min_10.0% Prob": 7.216601550579071, "Min_20.0% Prob": 5.169546753168106, "Min_30.0% Prob": 3.995339405779936, "Min_40.0% Prob": 3.185475971148564, "Min_50.0% Prob": 2.5785906505657405, "Min_60.0% Prob": 2.171207765459406}}
{"hexsha": "34b32829b1c114138ede140210591eeacaee1049", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout__jl_methtable_t() {\n    assert_eq!(\n        ::std::mem::size_of::<_jl_methtable_t>(),\n        80usize,\n        concat!(\"Size of: \", stringify!(_jl_methtable_t))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<_jl_methtable_t>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(_jl_methtable_t))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).name as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(name)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).defs as *const _ as usize },\n        8usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(defs)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).cache as *const _ as usize },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(cache)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).max_args as *const _ as usize },\n        24usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(max_args)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).kwsorter as *const _ as usize },\n        32usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(kwsorter)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).module as *const _ as usize },\n        40usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(module)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).backedges as *const _ as usize },\n        48usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(backedges)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).writelock as *const _ as usize },\n        56usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(writelock)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).offs as *const _ as usize },\n        72usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(offs)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).frozen as *const _ as usize },\n        73usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(frozen)\n        )\n    );\n}", "item_id": 31, "repo": "Darksonn/jl-sys", "file": "dummy-bindings.rs", "last_update_at": "2021-06-19T00:53:10+00:00", "question_id": "34b32829b1c114138ede140210591eeacaee1049_31", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout__jl_methtable_t() {\n    assert_eq!(\n        ::std::mem::size_of::<_jl_methtable_t>(),\n        80usize,\n        concat!(\"Size of: \", stringify!(_jl_methtable_t))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<_jl_methtable_t>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(_jl_methtable_t))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).name as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(name)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).defs as *const _ as usize },\n        8usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(defs)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).cache as *const _ as usize },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(cache)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).max_args as *const _ as usize },\n        24usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(max_args)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).kwsorter as *const _ as usize },\n        32usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(kwsorter)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).module as *const _ as usize },\n        40usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(module)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).backedges as *const _ as usize },\n        48usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(backedges)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).writelock as *const _ as usize },\n        56usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(writelock)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).offs as *const _ as usize },\n        72usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(offs)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).frozen as *const _ as usize },\n        73usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(_jl_methtable_t),\n            \"::\",\n            stringify!(frozen)\n        )\n    );\n"]], "pred": {"ppl": 1.1516482830047607, "ppl_lower": 1.1616803407669067, "ppl/lowercase_ppl": -1.061428305556695, "ppl/zlib": 0.00036769324418084687, "Min_5.0% Prob": 2.7847520513277426, "Min_10.0% Prob": 1.4147186915107144, "Min_20.0% Prob": 0.7079528893207716, "Min_30.0% Prob": 0.47201511577326993, "Min_40.0% Prob": 0.3531537907163995, "Min_50.0% Prob": 0.28266326975021816, "Min_60.0% Prob": 0.2356302170311951}}
{"hexsha": "c2549b3aa9691b4954e9b0646df9c09e9f610afa", "ext": "rs", "lang": "Rust", "content": "async fn main() -> Result<(), Error> {\n    fuchsia_syslog::init_with_tags(&[\"overnet_debug_proxy\"])?;\n\n    let mut fs = ServiceFs::new_local();\n    let mut svc_dir = fs.dir(\"svc\");\n    svc_dir.add_fidl_service(IncomingService::NewDeviceProxy);\n    fs.take_and_serve_directory_handle()?;\n\n    let root_resource =\n        fuchsia_component::client::connect_to_service::<RootResourceMarker>()?.get().await?;\n\n    let (tx_write, rx_write) = mpsc::channel(0);\n    let (tx_read, rx_read) = mpsc::channel(0);\n\n    let reader = &Mutex::new(Some(rx_read));\n\n    let r = future::try_join3(\n        Task::blocking(reader_task(tx_read, root_resource)),\n        Task::blocking(writer_task(rx_write)),\n        async move {\n            fs.for_each_concurrent(None, move |IncomingService::NewDeviceProxy(requests)| {\n                let tx_write = tx_write.clone();\n                requests.for_each_concurrent(None, move |request| {\n                    let tx_write = tx_write.clone();\n                    async move {\n                        match request {\n                            Ok(request) => {\n                                if let Some(mut r) = reader.lock().await.take() {\n                                    run_safe(request, &mut tx_write.clone(), &mut r).await;\n                                    *reader.lock().await = Some(r);\n                                } else {\n                                    log::warn!(\"Failed to acquire root resource (already taken)\")\n                                }\n                            }\n                            Err(e) => log::warn!(\"Bad incoming request: {:?}\", e),\n                        }\n                    }\n                })\n            })\n            .await;\n            Ok(())\n        },\n    )\n    .map_ok(drop)\n    .await;\n\n    if let Err(e) = &r {\n        log::error!(\"main loop failed: {:?}\", e);\n    }\n\n    r\n}", "item_id": 0, "repo": "EnderNightLord-ChromeBook/zircon-rpi", "file": "src/connectivity/overnet/tools/debug-serial/src/main.rs", "last_update_at": "2021-09-20T02:46:20+00:00", "question_id": "c2549b3aa9691b4954e9b0646df9c09e9f610afa_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn main() -> Result<(), Error> {\n    fuchsia_syslog::init_with_tags(&[\"overnet_debug_proxy\"])?;\n    let mut fs = ServiceFs::new_local();\n    let mut svc_dir = fs.dir(\"svc\");\n    svc_dir.add_fidl_service(IncomingService::NewDeviceProxy);\n    fs.take_and_serve_directory_handle()?;\n    let root_resource =\n        fuchsia_component::client::connect_to_service::<RootResourceMarker>()?.get().await?;\n    let (tx_write, rx_write) = mpsc::channel(0);\n    let (tx_read, rx_read) = mpsc::channel(0);\n    let reader = &Mutex::new(Some(rx_read));\n    let r = future::try_join3(\n        Task::blocking(reader_task(tx_read, root_resource)),\n        Task::blocking(writer_task(rx_write)),\n        async move {\n            fs.for_each_concurrent(None, move |IncomingService::NewDeviceProxy(requests)| {\n                let tx_write = tx_write.clone();\n                requests.for_each_concurrent(None, move |request| {\n                    let tx_write = tx_write.clone();\n                    async move {\n                        match request {\n                            Ok(request) => {\n                                if let Some(mut r) = reader.lock().await.take() {\n                                    run_safe(request, &mut tx_write.clone(), &mut r).await;\n                                    *reader.lock().await = Some(r);\n                                } else {\n                                    log::warn!(\"Failed to acquire root resource (already taken)\")\n                                }\n                            }\n                            Err(e) => log::warn!(\"Bad incoming request: {:?}\", e),\n                        }\n                    }\n                })\n            })\n            .await;\n            Ok(())\n        },\n    )\n    .map_ok(drop)\n    .await;\n    if let Err(e) = &r {\n        log::error!(\"main loop failed: {:?}\", e);\n    }\n    r\n"]], "pred": {"ppl": 2.040558099746704, "ppl_lower": 2.6156980991363525, "ppl/lowercase_ppl": -1.3481485471482533, "ppl/zlib": 0.0010396841818478306, "Min_5.0% Prob": 6.719624148474799, "Min_10.0% Prob": 4.95091559710326, "Min_20.0% Prob": 3.184781207530587, "Min_30.0% Prob": 2.2934233154411667, "Min_40.0% Prob": 1.768921376619902, "Min_50.0% Prob": 1.4254453923139307, "Min_60.0% Prob": 1.1901809124600855}}
{"hexsha": "a3664442ef97a1196d2e155a5051043b13f2f50f", "ext": "rs", "lang": "Rust", "content": "fn order_by1() {\n        let expected = vec![2, 3, 4, 5, 6];\n        let actual = vec![4, 3, 2, 5, 6];\n        assert_eq!(actual.order_by(&|a: i32, b: i32| a < b), expected);\n    }", "item_id": 3, "repo": "maetaro/ragbag", "file": "src/lib.rs", "last_update_at": "2021-03-05T04:23:39+00:00", "question_id": "a3664442ef97a1196d2e155a5051043b13f2f50f_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn order_by1() {\n        let expected = vec![2, 3, 4, 5, 6];\n        let actual = vec![4, 3, 2, 5, 6];\n        assert_eq!(actual.order_by(&|a: i32, b: i32| a < b), expected);\n"]], "pred": {"ppl": 2.4717564582824707, "ppl_lower": 2.4717564582824707, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0073571464604044725, "Min_5.0% Prob": 7.6630939245224, "Min_10.0% Prob": 5.376386612653732, "Min_20.0% Prob": 3.6843867525458336, "Min_30.0% Prob": 2.811532956858476, "Min_40.0% Prob": 2.175984852241747, "Min_50.0% Prob": 1.8007398131417065, "Min_60.0% Prob": 1.5246787801841084}}
{"hexsha": "2e5ea2ac7ebca3fec182d20864725ccd94e1fe27", "ext": "rs", "lang": "Rust", "content": "fn derive_unit(item: &DeriveInput, _: &DataStruct) -> syn::Result<TokenStream> {\n    let ident = &item.ident;\n\n    let code = quote! {\n        impl ::btmgmt_packet_helper::pack::Pack for #ident {\n            fn pack<W>(&self, _: &mut W) -> ::btmgmt_packet_helper::pack::Result<()> where W: ::std::io::Write {\n                Ok(())\n            }\n        }\n    };\n    Ok(code)\n}", "item_id": 0, "repo": "yskszk63/btmgmt", "file": "packet/macros/src/pack.rs", "last_update_at": "2021-02-07T12:40:50+00:00", "question_id": "2e5ea2ac7ebca3fec182d20864725ccd94e1fe27_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn derive_unit(item: &DeriveInput, _: &DataStruct) -> syn::Result<TokenStream> {\n    let ident = &item.ident;\n    let code = quote! {\n        impl ::btmgmt_packet_helper::pack::Pack for #ident {\n            fn pack<W>(&self, _: &mut W) -> ::btmgmt_packet_helper::pack::Result<()> where W: ::std::io::Write {\n                Ok(())\n            }\n        }\n    };\n    Ok(code)\n"]], "pred": {"ppl": 2.460561990737915, "ppl_lower": 4.261834144592285, "ppl/lowercase_ppl": -1.6100800538242481, "ppl/zlib": 0.0039664747813774204, "Min_5.0% Prob": 7.263225793838501, "Min_10.0% Prob": 5.430481947385347, "Min_20.0% Prob": 3.8776152638288646, "Min_30.0% Prob": 2.8938817045627494, "Min_40.0% Prob": 2.2135602455094174, "Min_50.0% Prob": 1.803826666578199, "Min_60.0% Prob": 1.513662879343463}}
{"hexsha": "b9020ae65c255fa607fb0c9e4d367c8629c19f01", "ext": "rs", "lang": "Rust", "content": "fn builds_action_with_millisecond_delay() {\n        let mut data_hash = RCHash::new();\n        data_hash.insert(k(\"sequence\"), k(\"ctrl+shift+t\"));\n        data_hash.insert(k(\"delay_ms\"), RawConfig::Integer(20));\n\n        let action = build_action_key_sequence(Some(&RawConfig::Hash(data_hash)))\n            .ok().unwrap();\n\n        assert_eq!(action, Action::KeySequence {\n            sequence: \"ctrl+shift+t\".to_string(),\n            count: 1,\n            delay: Some(20_000)\n        })\n    }", "item_id": 4, "repo": "michd/midi-macro-pad", "file": "mmpd-lib/src/config/versions/version1/actions/key_sequence.rs", "last_update_at": "2021-11-22T22:44:59+00:00", "question_id": "b9020ae65c255fa607fb0c9e4d367c8629c19f01_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn builds_action_with_millisecond_delay() {\n        let mut data_hash = RCHash::new();\n        data_hash.insert(k(\"sequence\"), k(\"ctrl+shift+t\"));\n        data_hash.insert(k(\"delay_ms\"), RawConfig::Integer(20));\n        let action = build_action_key_sequence(Some(&RawConfig::Hash(data_hash)))\n            .ok().unwrap();\n        assert_eq!(action, Action::KeySequence {\n            sequence: \"ctrl+shift+t\".to_string(),\n            count: 1,\n            delay: Some(20_000)\n        })\n"]], "pred": {"ppl": 4.158111095428467, "ppl_lower": 5.482635974884033, "ppl/lowercase_ppl": -1.1940444044183673, "ppl/zlib": 0.005397957983167249, "Min_5.0% Prob": 9.488390241350446, "Min_10.0% Prob": 7.981929969787598, "Min_20.0% Prob": 5.506689510037822, "Min_30.0% Prob": 4.307187658289204, "Min_40.0% Prob": 3.422762010366686, "Min_50.0% Prob": 2.8034649395789857, "Min_60.0% Prob": 2.3774184727220127}}
{"hexsha": "9839f2334dc25c063b473f3bf7fe88e11d0faf85", "ext": "rs", "lang": "Rust", "content": "pub fn main(input: &str) -> Result<(usize, usize), String> {\n    let bytes: Vec<_> = input.trim_end().as_bytes().chunks(2)\n        .map(|slice| {\n            let hi = (slice[0] as char).to_digit(16).expect(\"invalid digit\") as u8;\n            let lo = if slice.len() > 1 {\n                (slice[1] as char).to_digit(16).expect(\"invalid digit\") as u8\n            } else {\n                0\n            };\n            hi << 4 | lo\n        })\n        .collect();\n    let mut bits = BitsIter::new(bytes);\n    \n    let mut messages = Vec::new();\n    while !bits.is_empty() {\n        messages.push(Message::parse(&mut bits));\n    }\n    let part1 = messages\n        .iter()\n        .map(|m| m.versions_sum() as usize)\n        .sum::<usize>();\n\n    assert_eq!(messages.len(), 1);\n    let part2 = messages[0].result_value();\n    Ok((part1, part2))\n}", "item_id": 0, "repo": "popravich/adventofcode2021", "file": "src/day16.rs", "last_update_at": "2021-12-03T10:23:41+00:00", "question_id": "9839f2334dc25c063b473f3bf7fe88e11d0faf85_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn main(input: &str) -> Result<(usize, usize), String> {\n    let bytes: Vec<_> = input.trim_end().as_bytes().chunks(2)\n        .map(|slice| {\n            let hi = (slice[0] as char).to_digit(16).expect(\"invalid digit\") as u8;\n            let lo = if slice.len() > 1 {\n                (slice[1] as char).to_digit(16).expect(\"invalid digit\") as u8\n            } else {\n                0\n            };\n            hi << 4 | lo\n        })\n        .collect();\n    let mut bits = BitsIter::new(bytes);\n    let mut messages = Vec::new();\n    while !bits.is_empty() {\n        messages.push(Message::parse(&mut bits));\n    }\n    let part1 = messages\n        .iter()\n        .map(|m| m.versions_sum() as usize)\n        .sum::<usize>();\n    assert_eq!(messages.len(), 1);\n    let part2 = messages[0].result_value();\n    Ok((part1, part2))\n"]], "pred": {"ppl": 1.9948886632919312, "ppl_lower": 2.3081557750701904, "ppl/lowercase_ppl": -1.211212109253967, "ppl/zlib": 0.0016761850507543464, "Min_5.0% Prob": 5.7762631348201205, "Min_10.0% Prob": 4.420639744826725, "Min_20.0% Prob": 2.981561204152448, "Min_30.0% Prob": 2.1940451473707245, "Min_40.0% Prob": 1.6984529721417598, "Min_50.0% Prob": 1.3772585141339473, "Min_60.0% Prob": 1.152854699148087}}
{"hexsha": "611e3b67dfe2fd2e8a97b87da3f14ed2843d3b20", "ext": "rs", "lang": "Rust", "content": "fn test_23() {\n        let input = String::from(\n            r#\"         A\n         A\n  #######.#########\n  #######.........#\n  #######.#######.#\n  #######.#######.#\n  #######.#######.#\n  #####  B    ###.#\nBC...##  C    ###.#\n  ##.##       ###.#\n  ##...DE  F  ###.#\n  #####    G  ###.#\n  #########.#####.#\nDE..#######...###.#\n  #.#########.###.#\nFG..#########.....#\n  ###########.#####\n             Z\n             Z       \"#,\n        );\n        let maze = get_maze(&input);\n        assert_eq!(23, breadth_first_search(&maze));\n    }", "item_id": 5, "repo": "PsypherPunk/advent-of-code", "file": "2019/20/src/main.rs", "last_update_at": "2021-12-26T22:58:42+00:00", "question_id": "611e3b67dfe2fd2e8a97b87da3f14ed2843d3b20_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_23() {\n        let input = String::from(\n            r#\"         A\n         A\n  #######.#########\n  #######.........#\n  #######.#######.#\n  #######.#######.#\n  #######.#######.#\n  #####  B    ###.#\nBC...##  C    ###.#\n  ##.##       ###.#\n  ##...DE  F  ###.#\n  #####    G  ###.#\n  #########.#####.#\nDE..#######...###.#\n  #.#########.###.#\nFG..#########.....#\n  ###########.#####\n             Z\n             Z       \"#,\n        );\n        let maze = get_maze(&input);\n        assert_eq!(23, breadth_first_search(&maze));\n"]], "pred": {"ppl": 1.8876944780349731, "ppl_lower": 2.4677186012268066, "ppl/lowercase_ppl": -1.4217127899753226, "ppl/zlib": 0.002982893105886601, "Min_5.0% Prob": 6.730047750473022, "Min_10.0% Prob": 4.700887328102475, "Min_20.0% Prob": 2.9228392087277912, "Min_30.0% Prob": 2.062417805431381, "Min_40.0% Prob": 1.580715632598315, "Min_50.0% Prob": 1.2645384497097079, "Min_60.0% Prob": 1.0585501303925642}}
{"hexsha": "e90f5904a90ec85620ffa34a5ae5a806d4edd92f", "ext": "rs", "lang": "Rust", "content": "fn get_name_index(ctx: CallContext) -> Result<JsNumber> {\n    let this: JsObject = ctx.this_unchecked();\n    let source_map_instance: &SourceMap = ctx.env.unwrap(&this)?;\n\n    let name = ctx.get::<JsString>(0)?.into_utf8()?;\n    let name_index = source_map_instance.get_name_index(name.as_str()?);\n\n    match name_index {\n        Some(i) => ctx.env.create_uint32(i),\n        None => ctx.env.create_int32(-1),\n    }\n}", "item_id": 12, "repo": "ginaphil/map-scroll", "file": "node_modules/@parcel/source-map/parcel_sourcemap_node/src/lib.rs", "last_update_at": "2021-10-09T16:39:15+00:00", "question_id": "e90f5904a90ec85620ffa34a5ae5a806d4edd92f_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_name_index(ctx: CallContext) -> Result<JsNumber> {\n    let this: JsObject = ctx.this_unchecked();\n    let source_map_instance: &SourceMap = ctx.env.unwrap(&this)?;\n    let name = ctx.get::<JsString>(0)?.into_utf8()?;\n    let name_index = source_map_instance.get_name_index(name.as_str()?);\n    match name_index {\n        Some(i) => ctx.env.create_uint32(i),\n        None => ctx.env.create_int32(-1),\n    }\n"]], "pred": {"ppl": 2.0572896003723145, "ppl_lower": 2.935253858566284, "ppl/lowercase_ppl": -1.4926667348578615, "ppl/zlib": 0.002885557553987388, "Min_5.0% Prob": 6.536752428327288, "Min_10.0% Prob": 4.8041735331217446, "Min_20.0% Prob": 3.113568132923495, "Min_30.0% Prob": 2.324567593958067, "Min_40.0% Prob": 1.784019375760709, "Min_50.0% Prob": 1.4342560051725461, "Min_60.0% Prob": 1.2079946832751394}}
{"hexsha": "255f7b95564c275c2702684ece4be16257e3b926", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let opts: Opts = Opts::parse();\n    let groups = art(opts);\n    let mut document = base_a4_landscape(\"white\");\n    for g in groups {\n        document = document.add(g);\n    }\n    svg::save(\"image.svg\", &document).unwrap();\n}", "item_id": 1, "repo": "gre/one-day-one-plot", "file": "examples/082/main.rs", "last_update_at": "2021-04-27T20:26:06+00:00", "question_id": "255f7b95564c275c2702684ece4be16257e3b926_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let opts: Opts = Opts::parse();\n    let groups = art(opts);\n    let mut document = base_a4_landscape(\"white\");\n    for g in groups {\n        document = document.add(g);\n    }\n    svg::save(\"image.svg\", &document).unwrap();\n"]], "pred": {"ppl": 1.7227118015289307, "ppl_lower": 2.1303164958953857, "ppl/lowercase_ppl": -1.3904596542894467, "ppl/zlib": 0.0034424030256133007, "Min_5.0% Prob": 9.139015197753906, "Min_10.0% Prob": 5.478502418313708, "Min_20.0% Prob": 2.7826833923657737, "Min_30.0% Prob": 1.8578055431337461, "Min_40.0% Prob": 1.3835466210279734, "Min_50.0% Prob": 1.1012544202773522, "Min_60.0% Prob": 0.9140764701544267}}
{"hexsha": "1c2e8260d9172082429920ff429bbeba4a4d24d3", "ext": "rs", "lang": "Rust", "content": "fn test_erc1155_deploy() {\n    let t = Token::deployed();\n    assert_eq!(t.name(), token_cfg::NAME);\n    assert_eq!(t.symbol(), token_cfg::SYMBOL);\n\n \n    \n}", "item_id": 0, "repo": "Herasoft/CSPR-1155-DEVXDAO-GRANT-RUST-BASE", "file": "tests/src/tests.rs", "last_update_at": "2021-11-29T10:43:38+00:00", "question_id": "1c2e8260d9172082429920ff429bbeba4a4d24d3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_erc1155_deploy() {\n    let t = Token::deployed();\n    assert_eq!(t.name(), token_cfg::NAME);\n    assert_eq!(t.symbol(), token_cfg::SYMBOL);\n"]], "pred": {"ppl": 4.6492719650268555, "ppl_lower": 5.894946098327637, "ppl/lowercase_ppl": -1.1544758937416895, "ppl/zlib": 0.01302297153119097, "Min_5.0% Prob": 10.047185262044271, "Min_10.0% Prob": 8.522921244303385, "Min_20.0% Prob": 6.369647602240245, "Min_30.0% Prob": 4.847610175609589, "Min_40.0% Prob": 3.722032539844513, "Min_50.0% Prob": 3.0668627446697605, "Min_60.0% Prob": 2.6051225271579384}}
{"hexsha": "2a925af2179677fd6200844fb688979a5f90ec7f", "ext": "rs", "lang": "Rust", "content": "pub fn solve() -> util::Result<()> {\n    let (mut p1, mut p2, mut hashes) = (0, 0, vec![]);\n    for x in 0usize..128 {\n        let mut lengths: Vec<_> = format!(\"{}-{}\", INPUT, x)\n            .bytes()\n            .map(|b| b as usize)\n            .collect();\n        lengths.extend_from_slice(&[17, 31, 73, 47, 23]);\n        let k = util::tie_knots(&lengths, 64);\n        let h = util::knot_hash(&k);\n        p1 += h.count_ones();\n        hashes.push(h);\n    }\n    let mut grid: HashSet<(i8, i8)> = HashSet::new();\n\n    for (y, h) in hashes.iter().enumerate() {\n        for x in 0..=127i8 {\n            if h & (1 << x) != 0 {\n                grid.insert((x, y as i8));\n            }\n        }\n    }\n\n    while !grid.is_empty() {\n        let coord = *grid.iter().next().expect(\"len>0 but no entries\");\n        remove_group(coord, &mut grid);\n        p2 += 1;\n    }\n\n    writeln!(io::stdout(), \"Day 14 Part 1: {}\\nDay 14 Part 2: {}\", p1, p2)?;\n    Ok(())\n}", "item_id": 0, "repo": "theodorepauw/advent", "file": "src/twenty17/day14.rs", "last_update_at": "2021-01-14T19:12:20+00:00", "question_id": "2a925af2179677fd6200844fb688979a5f90ec7f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn solve() -> util::Result<()> {\n    let (mut p1, mut p2, mut hashes) = (0, 0, vec![]);\n    for x in 0usize..128 {\n        let mut lengths: Vec<_> = format!(\"{}-{}\", INPUT, x)\n            .bytes()\n            .map(|b| b as usize)\n            .collect();\n        lengths.extend_from_slice(&[17, 31, 73, 47, 23]);\n        let k = util::tie_knots(&lengths, 64);\n        let h = util::knot_hash(&k);\n        p1 += h.count_ones();\n        hashes.push(h);\n    }\n    let mut grid: HashSet<(i8, i8)> = HashSet::new();\n    for (y, h) in hashes.iter().enumerate() {\n        for x in 0..=127i8 {\n            if h & (1 << x) != 0 {\n                grid.insert((x, y as i8));\n            }\n        }\n    }\n    while !grid.is_empty() {\n        let coord = *grid.iter().next().expect(\"len>0 but no entries\");\n        remove_group(coord, &mut grid);\n        p2 += 1;\n    }\n    writeln!(io::stdout(), \"Day 14 Part 1: {}\\nDay 14 Part 2: {}\", p1, p2)?;\n    Ok(())\n"]], "pred": {"ppl": 2.1409170627593994, "ppl_lower": 2.366776704788208, "ppl/lowercase_ppl": -1.1317527623618198, "ppl/zlib": 0.0014667326998824832, "Min_5.0% Prob": 7.518549495273167, "Min_10.0% Prob": 5.329941923553879, "Min_20.0% Prob": 3.4192724974950153, "Min_30.0% Prob": 2.445717006130556, "Min_40.0% Prob": 1.8836221217319666, "Min_50.0% Prob": 1.5193861036231278, "Min_60.0% Prob": 1.269405901280236}}
{"hexsha": "7b0bb9ed158bbb76cfde4efc321f42d88a7bd85e", "ext": "rs", "lang": "Rust", "content": "fn build_config(env: &Environment) -> Result<app_state::Config, environment::Error> {\n    let encryption_key = environment::lookup(env, \"ENCRYPTION_KEY\")?;\n    let server = build_server_config(env)?;\n    let cookie = build_cookie_config(env)?;\n    let site_key = build_site_key_config(env)?;\n    let quota_nano = build_site_quota_limits_nano(env)?;\n\n    Ok(app_state::Config{\n        encryption_key,\n        server,\n        cookie,\n        site_key,\n        site: site::Config{\n            quota_nano,\n        }\n    })\n}", "item_id": 4, "repo": "prasmussen/orri", "file": "backend/src/main.rs", "last_update_at": "2021-05-23T05:50:46+00:00", "question_id": "7b0bb9ed158bbb76cfde4efc321f42d88a7bd85e_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn build_config(env: &Environment) -> Result<app_state::Config, environment::Error> {\n    let encryption_key = environment::lookup(env, \"ENCRYPTION_KEY\")?;\n    let server = build_server_config(env)?;\n    let cookie = build_cookie_config(env)?;\n    let site_key = build_site_key_config(env)?;\n    let quota_nano = build_site_quota_limits_nano(env)?;\n    Ok(app_state::Config{\n        encryption_key,\n        server,\n        cookie,\n        site_key,\n        site: site::Config{\n            quota_nano,\n        }\n    })\n"]], "pred": {"ppl": 2.8890180587768555, "ppl_lower": 3.231983184814453, "ppl/lowercase_ppl": -1.1057380551296854, "ppl/zlib": 0.004457633077055499, "Min_5.0% Prob": 8.650982201099396, "Min_10.0% Prob": 7.09890287062701, "Min_20.0% Prob": 4.800350199727451, "Min_30.0% Prob": 3.4264520944333543, "Min_40.0% Prob": 2.608577885921451, "Min_50.0% Prob": 2.1188438146613366, "Min_60.0% Prob": 1.778536682152777}}
{"hexsha": "dc15ab4f40ac819b848723059039889769581e6a", "ext": "rs", "lang": "Rust", "content": "fn default_logger() {\n    use std::sync::Once;\n    use tracing_subscriber::prelude::*;\n    use tracing_subscriber::{fmt, EnvFilter};\n    static START: Once = Once::new();\n    START.call_once(|| {\n        let fmt_layer = fmt::layer().with_target(false);\n        let filter_layer = EnvFilter::try_from_default_env()\n            .or_else(|_| EnvFilter::try_new(\"debug\"))\n            .unwrap();\n\n        tracing_subscriber::registry()\n            .with(fmt_layer)\n            .with(filter_layer)\n            .init();\n    });\n}", "item_id": 0, "repo": "ritelabs/balsa", "file": "datadriven/src/lib.rs", "last_update_at": "2021-05-25T04:36:09+00:00", "question_id": "dc15ab4f40ac819b848723059039889769581e6a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn default_logger() {\n    use std::sync::Once;\n    use tracing_subscriber::prelude::*;\n    use tracing_subscriber::{fmt, EnvFilter};\n    static START: Once = Once::new();\n    START.call_once(|| {\n        let fmt_layer = fmt::layer().with_target(false);\n        let filter_layer = EnvFilter::try_from_default_env()\n            .or_else(|_| EnvFilter::try_new(\"debug\"))\n            .unwrap();\n        tracing_subscriber::registry()\n            .with(fmt_layer)\n            .with(filter_layer)\n            .init();\n    });\n"]], "pred": {"ppl": 1.4805105924606323, "ppl_lower": 2.1080126762390137, "ppl/lowercase_ppl": -1.9005359504611794, "ppl/zlib": 0.00152679775558287, "Min_5.0% Prob": 4.981129348278046, "Min_10.0% Prob": 3.289873677141526, "Min_20.0% Prob": 1.9027927785235292, "Min_30.0% Prob": 1.3098357424286067, "Min_40.0% Prob": 0.989748326020644, "Min_50.0% Prob": 0.7842823949285112, "Min_60.0% Prob": 0.6551185042599614}}
{"hexsha": "7d16ae909a3f7f8de4d4c26522585bc28700c01e", "ext": "rs", "lang": "Rust", "content": "fn send_low_mtu() {\n    let mut server = OpenSSLServer::new_rsa(9110);\n    server.run();\n\n    server.client()\n        .mtu(128)\n        .expect(\"Ciphers common between both SSL end points\")\n        .go();\n}", "item_id": 12, "repo": "rot256/rustls", "file": "tests/features.rs", "last_update_at": "2021-04-22T21:37:29+00:00", "question_id": "7d16ae909a3f7f8de4d4c26522585bc28700c01e_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn send_low_mtu() {\n    let mut server = OpenSSLServer::new_rsa(9110);\n    server.run();\n    server.client()\n        .mtu(128)\n        .expect(\"Ciphers common between both SSL end points\")\n        .go();\n"]], "pred": {"ppl": 7.3154072761535645, "ppl_lower": 9.077753067016602, "ppl/lowercase_ppl": -1.1084652603155094, "ppl/zlib": 0.013006422939683772, "Min_5.0% Prob": 9.688888549804688, "Min_10.0% Prob": 8.307788303920201, "Min_20.0% Prob": 6.317833773295084, "Min_30.0% Prob": 5.264902342449535, "Min_40.0% Prob": 4.4017202973365785, "Min_50.0% Prob": 3.8341154858872697, "Min_60.0% Prob": 3.265136307477951}}
