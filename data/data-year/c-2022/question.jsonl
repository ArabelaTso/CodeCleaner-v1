{"hexsha": "c32cfa22c53cd688da78cf38b800dd4dcad143e1", "ext": "c", "lang": "C", "content": "void GameOver_Draw(void)\n{\n\tPlaying_Draw();\n\n\tColor edgeColor = ColorAlpha(BLACK, 0.9f);\n\tColor centerColor = ColorAlpha(BLACK, 0.1f);\n\tDrawRectangleGradientV(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT / 2, edgeColor, centerColor);\n\tDrawRectangleGradientV(0, SCREEN_HEIGHT / 2, SCREEN_WIDTH, SCREEN_HEIGHT / 2, centerColor, edgeColor);\n\t\n\t//DrawRectangleVCentered(screenCenter, Vec2(300, 100), BLACK);\n\t//DrawTextCentered(\"YOU DIED\", screenCenter.x, screenCenter.y - 20, 40, RED);\n\n\tDrawRectangleVCentered(Vec2(screenCenter.x, screenCenter.y + 160), Vec2(400, 340), GRAY);\n\tDrawCircleV(screenCenter, 200, GRAY);\n\tDrawRectangleVCentered(Vec2(screenCenter.x, screenCenter.y + 160), Vec2(380, 320), DARKGRAY);\n\tDrawCircleV(screenCenter, 190, DARKGRAY);\n\n\tDrawTextCentered(\"Magus Maximillius\", screenCenter.x, screenCenter.y - 40, 40, GRAY);\n\n\tconst char *suffix = \"\";\n\tbool isTeen = deathCount > 10 && deathCount <= 20;\n\tif (isTeen)\n\t\tsuffix = \"th\";\n\telse\n\t{\n\t\tswitch (deathCount % 10)\n\t\t{\n\t\t\tcase 0: suffix = \"th\"; break;\n\t\t\tcase 1: suffix = \"st\"; break;\n\t\t\tcase 2: suffix = \"nd\"; break;\n\t\t\tcase 3: suffix = \"rd\"; break;\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\tcase 6:\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\tcase 9:\n\t\t\t\tsuffix = \"th\"; break;\n\t\t}\n\t}\n\n\tchar text[256];\n\tsnprintf(text, sizeof text, \"The %d%s\", deathCount, suffix);\n\tDrawTextCentered(text, screenCenter.x, screenCenter.y + 10, 40, GRAY);\n\n\tDrawTextCentered(\"YOU DIED\", screenCenter.x, screenCenter.y + 100, 40, RED);\n\tDrawTextCentered(\"YOU DIED\", screenCenter.x, screenCenter.y + 102, 40, RED);\n\n\tRectangle rR = Rect(360, 660, 40, 40);\n\tVector2 cR = RectangleCenter(rR);\n\tif (inputMode == INPUT_MODE_KEYBOARD_AND_MOUSE)\n\t{\n\t\tDrawRectangleLinesEx(rR, 4, GRAY);\n\t\tDrawTextCentered(\"R\", cR.x, cR.y, 28, GRAY);\n\t}\n\telse if (inputMode == INPUT_MODE_CONTROLLER)\n\t{\n\t\tDrawRing(cR, 24, 28, 0, 360, 64, Grayscale(0.2f));\n\t\tDrawRing(cR, 20, 24, 0, 360, 64, GRAY);\n\t\tDrawTextCentered(\"Y\", cR.x, cR.y, 32, GRAY);\n\t}\n\tDrawText(\"Restart\", 420, 665, 28, GRAY);\n}", "item_id": 73, "repo": "blat-blatnik/Pictomage", "file": "src/game.c", "last_update_at": "2022-01-29T20:42:23+00:00", "question_id": "c32cfa22c53cd688da78cf38b800dd4dcad143e1_73", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void GameOver_Draw(void)\n{\n\tPlaying_Draw();\n\tColor edgeColor = ColorAlpha(BLACK, 0.9f);\n\tColor centerColor = ColorAlpha(BLACK, 0.1f);\n\tDrawRectangleGradientV(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT / 2, edgeColor, centerColor);\n\tDrawRectangleGradientV(0, SCREEN_HEIGHT / 2, SCREEN_WIDTH, SCREEN_HEIGHT / 2, centerColor, edgeColor);\n\t\n\t//DrawRectangleVCentered(screenCenter, Vec2(300, 100), BLACK);\n\t//DrawTextCentered(\"YOU DIED\", screenCenter.x, screenCenter.y - 20, 40, RED);\n\tDrawRectangleVCentered(Vec2(screenCenter.x, screenCenter.y + 160), Vec2(400, 340), GRAY);\n\tDrawCircleV(screenCenter, 200, GRAY);\n\tDrawRectangleVCentered(Vec2(screenCenter.x, screenCenter.y + 160), Vec2(380, 320), DARKGRAY);\n\tDrawCircleV(screenCenter, 190, DARKGRAY);\n\tDrawTextCentered(\"Magus Maximillius\", screenCenter.x, screenCenter.y - 40, 40, GRAY);\n\tconst char *suffix = \"\";\n\tbool isTeen = deathCount > 10 && deathCount <= 20;\n\tif (isTeen)\n\t\tsuffix = \"th\";\n\telse\n\t{\n\t\tswitch (deathCount % 10)\n\t\t{\n\t\t\tcase 0: suffix = \"th\"; break;\n\t\t\tcase 1: suffix = \"st\"; break;\n\t\t\tcase 2: suffix = \"nd\"; break;\n\t\t\tcase 3: suffix = \"rd\"; break;\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\tcase 6:\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\tcase 9:\n\t\t\t\tsuffix = \"th\"; break;\n\t\t}\n\t}\n\tchar text[256];\n\tsnprintf(text, sizeof text, \"The %d%s\", deathCount, suffix);\n\tDrawTextCentered(text, screenCenter.x, screenCenter.y + 10, 40, GRAY);\n\tDrawTextCentered(\"YOU DIED\", screenCenter.x, screenCenter.y + 100, 40, RED);\n\tDrawTextCentered(\"YOU DIED\", screenCenter.x, screenCenter.y + 102, 40, RED);\n\tRectangle rR = Rect(360, 660, 40, 40);\n\tVector2 cR = RectangleCenter(rR);\n\tif (inputMode == INPUT_MODE_KEYBOARD_AND_MOUSE)\n\t{\n\t\tDrawRectangleLinesEx(rR, 4, GRAY);\n\t\tDrawTextCentered(\"R\", cR.x, cR.y, 28, GRAY);\n\t}\n\telse if (inputMode == INPUT_MODE_CONTROLLER)\n\t{\n\t\tDrawRing(cR, 24, 28, 0, 360, 64, Grayscale(0.2f));\n\t\tDrawRing(cR, 20, 24, 0, 360, 64, GRAY);\n\t\tDrawTextCentered(\"Y\", cR.x, cR.y, 32, GRAY);\n\t}\n\tDrawText(\"Restart\", 420, 665, 28, GRAY);\n"]]}
{"hexsha": "b8d336cf6e3d78126ba13ebe752a046b794bbe49", "ext": "c", "lang": "C", "content": "static void _plog_strncat_attribute(char *buffer, size_t n, const plog_attribute_data_t *data)\n{\n#define ATTR_TEXT_MAX 65\n    char  text[ATTR_TEXT_MAX + 1];\n    char *text_ptr = text;\n\n    text[0] = '\\0';\n\n    if ((uint64_t) 1 << data->attribute_type & VALID_UINT_ATTRS) {\n        sprintf(text, \"%\"PRIu64, data->value.uint_val);\n    } else if ((uint64_t) 1 << data->attribute_type & (VALID_STRING_ATTRS | VALID_TRACE_ATTRS)) {\n        text_ptr = data->value.string_val;\n    } else if ((uint64_t) 1 << data->attribute_type & VALID_REF_ATTRS) {\n        _plog_strncat_id(text, ATTR_TEXT_MAX, &data->value.ref_val);\n    }\n\n    strncat(buffer, text_ptr, n);\n}", "item_id": 4, "repo": "ted-ross/skupper-router", "file": "src/protocol_log.c", "last_update_at": "2022-01-19T16:47:03+00:00", "question_id": "b8d336cf6e3d78126ba13ebe752a046b794bbe49_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void _plog_strncat_attribute(char *buffer, size_t n, const plog_attribute_data_t *data)\n{\n#define ATTR_TEXT_MAX 65\n    char  text[ATTR_TEXT_MAX + 1];\n    char *text_ptr = text;\n    text[0] = '\\0';\n    if ((uint64_t) 1 << data->attribute_type & VALID_UINT_ATTRS) {\n        sprintf(text, \"%\"PRIu64, data->value.uint_val);\n    } else if ((uint64_t) 1 << data->attribute_type & (VALID_STRING_ATTRS | VALID_TRACE_ATTRS)) {\n        text_ptr = data->value.string_val;\n    } else if ((uint64_t) 1 << data->attribute_type & VALID_REF_ATTRS) {\n        _plog_strncat_id(text, ATTR_TEXT_MAX, &data->value.ref_val);\n    }\n    strncat(buffer, text_ptr, n);\n"]]}
{"hexsha": "2fcf87ce73fc84dec90a6aaf189a09c16407c65d", "ext": "h", "lang": "C", "content": "virtual int serialize(char **buf, size_t *buf_siz,\n\t\t\tconst int allow_realloc, size_t *nargs, va_list_t &ap) {\n    if (use_generic()) {\n      generic_t gen_arg = pop_generic(nargs, ap);\n      return serialize(buf, buf_siz, allow_realloc,\n\t\t       (YggGeneric*)(gen_arg.obj));\n    }\n    va_list_t ap_copy = copy_va_list(ap);\n    update_from_serialization_args(nargs, ap_copy);\n    if (nargs_exp() != *nargs) {\n      ygglog_throw_error(\"MetaschemaType::serialize: %d arguments expected, but %d provided.\",\n\t\t\t nargs_exp(), *nargs);\n    }\n    rapidjson::StringBuffer body_buf;\n    rapidjson::Writer<rapidjson::StringBuffer> body_writer(body_buf);\n    bool out = encode_data_wrap(&body_writer, nargs, ap);\n    if (!(out)) {\n      return -1;\n    }\n    if (*nargs != 0) {\n      ygglog_error(\"MetaschemaType::serialize: %d arguments were not used.\", *nargs);\n      return -1;\n    }\n    // Copy message to buffer\n    return copy_to_buffer(body_buf.GetString(), body_buf.GetSize(),\n\t\t\t  buf, *buf_siz, allow_realloc);\n  }", "item_id": 25, "repo": "cropsinsilico/yggdrasil", "file": "yggdrasil/languages/C/datatypes/MetaschemaType.h", "last_update_at": "2022-02-25T09:00:40+00:00", "question_id": "2fcf87ce73fc84dec90a6aaf189a09c16407c65d_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["virtual int serialize(char **buf, size_t *buf_siz,\n\t\t\tconst int allow_realloc, size_t *nargs, va_list_t &ap) {\n    if (use_generic()) {\n      generic_t gen_arg = pop_generic(nargs, ap);\n      return serialize(buf, buf_siz, allow_realloc,\n\t\t       (YggGeneric*)(gen_arg.obj));\n    }\n    va_list_t ap_copy = copy_va_list(ap);\n    update_from_serialization_args(nargs, ap_copy);\n    if (nargs_exp() != *nargs) {\n      ygglog_throw_error(\"MetaschemaType::serialize: %d arguments expected, but %d provided.\",\n\t\t\t nargs_exp(), *nargs);\n    }\n    rapidjson::StringBuffer body_buf;\n    rapidjson::Writer<rapidjson::StringBuffer> body_writer(body_buf);\n    bool out = encode_data_wrap(&body_writer, nargs, ap);\n    if (!(out)) {\n      return -1;\n    }\n    if (*nargs != 0) {\n      ygglog_error(\"MetaschemaType::serialize: %d arguments were not used.\", *nargs);\n      return -1;\n    }\n    // Copy message to buffer\n    return copy_to_buffer(body_buf.GetString(), body_buf.GetSize(),\n\t\t\t  buf, *buf_siz, allow_realloc);\n"]]}
{"hexsha": "43ff170ff1c242df694b6c5d6ec74ca3aba7b16a", "ext": "c", "lang": "C", "content": "static int zynqmp_sha_init_tfm(struct crypto_shash *hash)\n{\n\tconst char *fallback_driver_name = crypto_shash_alg_name(hash);\n\tstruct zynqmp_sha_tfm_ctx *tfm_ctx = crypto_shash_ctx(hash);\n\tstruct shash_alg *alg = crypto_shash_alg(hash);\n\tstruct crypto_shash *fallback_tfm;\n\tstruct zynqmp_sha_drv_ctx *drv_ctx;\n\n\tdrv_ctx = container_of(alg, struct zynqmp_sha_drv_ctx, sha3_384);\n\ttfm_ctx->dev = drv_ctx->dev;\n\n\t/* Allocate a fallback and abort if it failed. */\n\tfallback_tfm = crypto_alloc_shash(fallback_driver_name, 0,\n\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK);\n\tif (IS_ERR(fallback_tfm))\n\t\treturn PTR_ERR(fallback_tfm);\n\n\ttfm_ctx->fbk_tfm = fallback_tfm;\n\thash->descsize += crypto_shash_descsize(tfm_ctx->fbk_tfm);\n\n\treturn 0;\n}", "item_id": 0, "repo": "OpenMPDK/SMDK", "file": "lib/linux-5.18-rc3-smdk/drivers/crypto/xilinx/zynqmp-sha.c", "last_update_at": "2022-03-31T16:02:35+00:00", "question_id": "43ff170ff1c242df694b6c5d6ec74ca3aba7b16a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int zynqmp_sha_init_tfm(struct crypto_shash *hash)\n{\n\tconst char *fallback_driver_name = crypto_shash_alg_name(hash);\n\tstruct zynqmp_sha_tfm_ctx *tfm_ctx = crypto_shash_ctx(hash);\n\tstruct shash_alg *alg = crypto_shash_alg(hash);\n\tstruct crypto_shash *fallback_tfm;\n\tstruct zynqmp_sha_drv_ctx *drv_ctx;\n\tdrv_ctx = container_of(alg, struct zynqmp_sha_drv_ctx, sha3_384);\n\ttfm_ctx->dev = drv_ctx->dev;\n\t/* Allocate a fallback and abort if it failed. */\n\tfallback_tfm = crypto_alloc_shash(fallback_driver_name, 0,\n\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK);\n\tif (IS_ERR(fallback_tfm))\n\t\treturn PTR_ERR(fallback_tfm);\n\ttfm_ctx->fbk_tfm = fallback_tfm;\n\thash->descsize += crypto_shash_descsize(tfm_ctx->fbk_tfm);\n\treturn 0;\n"]]}
{"hexsha": "81afab2cfb91db15d880e8d80295023ae54cf673", "ext": "c", "lang": "C", "content": "SshNdisPacket SSH_PACKET_POOL_API \nssh_packet_clone(SshInterceptor interceptor,\n                 SshPacketPool pool,\n                 SshInterceptorProtocol protocol,\n                 SshNativeNetDataPacket src,\n                 Boolean copy_data)\n{\n  SshMediaHeader media_hdr;\n  SshNdisPacket packet;\n  SshNdisBuffer buff_chain;\n  SshUInt32 total_len;\n  SshUInt32 bytes_copied = 0;\n  void *media_info;\n  SshUInt32 media_info_len;\n\n  SSH_ASSERT(interceptor != NULL);\n  SSH_ASSERT(pool != NULL);\n  SSH_ASSERT(src != NULL);\n\n  /* Query source packet len */\n  NdisQueryPacket(src, NULL, NULL, NULL, &total_len);\n\n  /* Allocate new packet for copying */\n  packet = (SshNdisPacket)ssh_net_packet_alloc(interceptor, pool, total_len);\n  if (packet == NULL)\n    {\n      SSH_DEBUG(SSH_D_FAIL, \n                (\"Error: ssh_packet_clone(): \"\n                 \"Cannot allocate destination packet[len=%d]\",\n                 total_len));\n      return NULL;  \n    }\n\n  buff_chain = (SshNdisBuffer)ssh_buffer_chain_alloc(interceptor, pool, \n                                                     total_len,\n                                                     &packet->data_space, \n                                                     &packet->backfill_space);\n  if (buff_chain == NULL)\n    {\n      SSH_DEBUG(SSH_D_FAIL, (\"Out of buffer pool!\"));\n      ssh_packet_free((SshNetDataPacket)packet, pool);\n      return NULL;\n    }\n\n  if (copy_data) \n    {\n copy_packet:\n      SSH_RESET_PACKET((SshNetDataPacket)packet, \n                       (SshNetDataBuffer)buff_chain);\n\n      /* Copy packet contents */\n      NdisCopyFromPacketToPacket(packet->np, 0, total_len, \n                                 src, 0, &bytes_copied);\n      if (bytes_copied != total_len)\n        {\n          SSH_DEBUG(SSH_D_FAIL, \n                    (\"Packet[0x%p, %d, %d] copy failed\",\n                     packet, total_len, bytes_copied));\n          ssh_packet_free((SshNetDataPacket)packet, pool);\n          return NULL;\n        }\n      packet->f.flags.packet_copied = 1;\n    }\n  else\n    {\n      SshNdisBufferHeader prev = NULL;\n      NDIS_BUFFER *ndis_buf;\n      unsigned char *buf_addr;\n      UINT buf_len;\n      UINT pkt_len;\n\n      SSH_RESET_PACKET((SshNetDataPacket)packet, NULL);\n\n      packet->buff = (SshNetDataBuffer)buff_chain;\n      /* Copy buffer descriptors (so we don't need to revert changes in\n         original packet before returning it back to miniport/protocol). */\n      NdisGetFirstBufferFromPacketSafe(src, &ndis_buf, &buf_addr,  &buf_len, \n                                       &pkt_len, NormalPagePriority);      \n      if (ndis_buf == NULL)\n        {\n          ssh_packet_free((SshNetDataPacket)packet, pool);\n          return NULL;\n        }\n\n      while (ndis_buf)\n        {\n          SshNdisBufferHeader buf_hdr;\n          NDIS_STATUS status;\n\n          NdisQueryBufferSafe(ndis_buf, &buf_addr, &buf_len, \n                              NormalPagePriority);\n          if (buf_addr == NULL)\n            {\n              ssh_packet_free((SshNetDataPacket)packet, pool);\n              return NULL;\n            }\n\n          /* Skip zero-length buffers */\n          if (buf_len > 0)\n            {\n              if (packet->clone_buffers_in_use \n                                      == SSH_CLONE_BUF_DESCRIPTORS_PER_PACKET)\n                goto copy_packet;\n\n              buf_hdr = &packet->clone_buffers[packet->clone_buffers_in_use];\n\n              SSH_ASSERT(buf_hdr->nb == NULL);\n              NdisCopyBuffer(&status, &buf_hdr->nb, pool->buffer_list_context, \n                             ndis_buf, 0, ndis_buf->ByteCount);\n              if (status != NDIS_STATUS_SUCCESS)\n                {\n                  ssh_packet_free((SshNetDataPacket)packet, pool);\n                  return NULL;\n                }\n\n              SSH_ASSERT(buf_hdr->nb->Next == NULL);\n\n              buf_hdr->total_size = ndis_buf->ByteCount;\n              buf_hdr->data_len = buf_hdr->total_size;\n              buf_hdr->offset = 0;\n#ifndef _WIN32_WCE\n              SSH_NB_DESCRIPTOR(buf_hdr->nb) = buf_hdr;\n#endif /* _WIN32_WCE */\n\n              buf_hdr->prev = prev;\n              buf_hdr->next = NULL;\n              if (prev)\n                prev->next = buf_hdr;\n              prev = buf_hdr;\n\n              NdisChainBufferAtBack(packet->np, buf_hdr->nb);\n\n              packet->clone_buffers_in_use++;\n            }\n\n          NdisGetNextBuffer(ndis_buf, &ndis_buf);\n        }\n\n      packet->buf_chain_backfill = packet->backfill_space;\n      packet->buf_chain_data_space = packet->data_space;\n      packet->backfill_space = 0;\n      packet->data_space = pkt_len;\n\n      /* Force-update packet counts */\n      NdisRecalculatePacketCounts(packet->np);\n      NdisQueryPacket(packet->np, NULL, NULL, NULL, &pkt_len);\n    }\n\n  /* Set OOB information */\n  RtlCopyMemory(NDIS_OOB_DATA_FROM_PACKET(packet->np),\n                NDIS_OOB_DATA_FROM_PACKET(src),\n                sizeof(NDIS_PACKET_OOB_DATA));\n\n  /* Set media specific information */\n  NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(src, &media_info, &media_info_len);\n  NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(packet->np, \n                                      media_info, media_info_len);\n\n  /* Copy IEEE802.1p priority value */\n  NDIS_PER_PACKET_INFO_FROM_PACKET(packet->np, Ieee8021pPriority) =\n    NDIS_PER_PACKET_INFO_FROM_PACKET(src, Ieee8021pPriority);\n\n  /* Copy packet flags */\n  NdisSetPacketFlags(packet->np, NdisGetPacketFlags(src));\n\n  /* Set packet header size */\n  NDIS_SET_PACKET_HEADER_SIZE(packet->np, \n                              NDIS_GET_PACKET_HEADER_SIZE(src));\n\n  packet->packet_len = total_len;\n\n  ssh_packet_query_media_header(packet->np, &media_hdr);\n  if (media_hdr != NULL)\n    {\n      if (protocol == SSH_PROTOCOL_ETHERNET)\n        {\n          if (SSH_ETHER_IS_MULTICAST(media_hdr->dst))\n            packet->ip.flags |= SSH_PACKET_MEDIABCAST;\n        }\n      packet->eth_type = SSH_GET_16BIT(media_hdr->type);\n    }\n\n  return packet;\n}", "item_id": 17, "repo": "Sirherobrine23/Dir819gpl_code", "file": "DIR819_v1.06/src/kernel/linux-2.6.36.x/drivers/net/eip93_drivers/quickSec/src/interceptor_quickset5.1/windows/ndis5_packet_pool_impl.c", "last_update_at": "2022-03-19T06:38:01+00:00", "question_id": "81afab2cfb91db15d880e8d80295023ae54cf673_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["SshNdisPacket SSH_PACKET_POOL_API \nssh_packet_clone(SshInterceptor interceptor,\n                 SshPacketPool pool,\n                 SshInterceptorProtocol protocol,\n                 SshNativeNetDataPacket src,\n                 Boolean copy_data)\n{\n  SshMediaHeader media_hdr;\n  SshNdisPacket packet;\n  SshNdisBuffer buff_chain;\n  SshUInt32 total_len;\n  SshUInt32 bytes_copied = 0;\n  void *media_info;\n  SshUInt32 media_info_len;\n  SSH_ASSERT(interceptor != NULL);\n  SSH_ASSERT(pool != NULL);\n  SSH_ASSERT(src != NULL);\n  /* Query source packet len */\n  NdisQueryPacket(src, NULL, NULL, NULL, &total_len);\n  /* Allocate new packet for copying */\n  packet = (SshNdisPacket)ssh_net_packet_alloc(interceptor, pool, total_len);\n  if (packet == NULL)\n    {\n      SSH_DEBUG(SSH_D_FAIL, \n                (\"Error: ssh_packet_clone(): \"\n                 \"Cannot allocate destination packet[len=%d]\",\n                 total_len));\n      return NULL;  \n    }\n  buff_chain = (SshNdisBuffer)ssh_buffer_chain_alloc(interceptor, pool, \n                                                     total_len,\n                                                     &packet->data_space, \n                                                     &packet->backfill_space);\n  if (buff_chain == NULL)\n    {\n      SSH_DEBUG(SSH_D_FAIL, (\"Out of buffer pool!\"));\n      ssh_packet_free((SshNetDataPacket)packet, pool);\n      return NULL;\n    }\n  if (copy_data) \n    {\n copy_packet:\n      SSH_RESET_PACKET((SshNetDataPacket)packet, \n                       (SshNetDataBuffer)buff_chain);\n      /* Copy packet contents */\n      NdisCopyFromPacketToPacket(packet->np, 0, total_len, \n                                 src, 0, &bytes_copied);\n      if (bytes_copied != total_len)\n        {\n          SSH_DEBUG(SSH_D_FAIL, \n                    (\"Packet[0x%p, %d, %d] copy failed\",\n                     packet, total_len, bytes_copied));\n          ssh_packet_free((SshNetDataPacket)packet, pool);\n          return NULL;\n        }\n      packet->f.flags.packet_copied = 1;\n    }\n  else\n    {\n      SshNdisBufferHeader prev = NULL;\n      NDIS_BUFFER *ndis_buf;\n      unsigned char *buf_addr;\n      UINT buf_len;\n      UINT pkt_len;\n      SSH_RESET_PACKET((SshNetDataPacket)packet, NULL);\n      packet->buff = (SshNetDataBuffer)buff_chain;\n      /* Copy buffer descriptors (so we don't need to revert changes in\n         original packet before returning it back to miniport/protocol). */\n      NdisGetFirstBufferFromPacketSafe(src, &ndis_buf, &buf_addr,  &buf_len, \n                                       &pkt_len, NormalPagePriority);      \n      if (ndis_buf == NULL)\n        {\n          ssh_packet_free((SshNetDataPacket)packet, pool);\n          return NULL;\n        }\n      while (ndis_buf)\n        {\n          SshNdisBufferHeader buf_hdr;\n          NDIS_STATUS status;\n          NdisQueryBufferSafe(ndis_buf, &buf_addr, &buf_len, \n                              NormalPagePriority);\n          if (buf_addr == NULL)\n            {\n              ssh_packet_free((SshNetDataPacket)packet, pool);\n              return NULL;\n            }\n          /* Skip zero-length buffers */\n          if (buf_len > 0)\n            {\n              if (packet->clone_buffers_in_use \n                                      == SSH_CLONE_BUF_DESCRIPTORS_PER_PACKET)\n                goto copy_packet;\n              buf_hdr = &packet->clone_buffers[packet->clone_buffers_in_use];\n              SSH_ASSERT(buf_hdr->nb == NULL);\n              NdisCopyBuffer(&status, &buf_hdr->nb, pool->buffer_list_context, \n                             ndis_buf, 0, ndis_buf->ByteCount);\n              if (status != NDIS_STATUS_SUCCESS)\n                {\n                  ssh_packet_free((SshNetDataPacket)packet, pool);\n                  return NULL;\n                }\n              SSH_ASSERT(buf_hdr->nb->Next == NULL);\n              buf_hdr->total_size = ndis_buf->ByteCount;\n              buf_hdr->data_len = buf_hdr->total_size;\n              buf_hdr->offset = 0;\n#ifndef _WIN32_WCE\n              SSH_NB_DESCRIPTOR(buf_hdr->nb) = buf_hdr;\n#endif /* _WIN32_WCE */\n              buf_hdr->prev = prev;\n              buf_hdr->next = NULL;\n              if (prev)\n                prev->next = buf_hdr;\n              prev = buf_hdr;\n              NdisChainBufferAtBack(packet->np, buf_hdr->nb);\n              packet->clone_buffers_in_use++;\n            }\n          NdisGetNextBuffer(ndis_buf, &ndis_buf);\n        }\n      packet->buf_chain_backfill = packet->backfill_space;\n      packet->buf_chain_data_space = packet->data_space;\n      packet->backfill_space = 0;\n      packet->data_space = pkt_len;\n      /* Force-update packet counts */\n      NdisRecalculatePacketCounts(packet->np);\n      NdisQueryPacket(packet->np, NULL, NULL, NULL, &pkt_len);\n    }\n  /* Set OOB information */\n  RtlCopyMemory(NDIS_OOB_DATA_FROM_PACKET(packet->np),\n                NDIS_OOB_DATA_FROM_PACKET(src),\n                sizeof(NDIS_PACKET_OOB_DATA));\n  /* Set media specific information */\n  NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(src, &media_info, &media_info_len);\n  NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(packet->np, \n                                      media_info, media_info_len);\n  /* Copy IEEE802.1p priority value */\n  NDIS_PER_PACKET_INFO_FROM_PACKET(packet->np, Ieee8021pPriority) =\n    NDIS_PER_PACKET_INFO_FROM_PACKET(src, Ieee8021pPriority);\n  /* Copy packet flags */\n  NdisSetPacketFlags(packet->np, NdisGetPacketFlags(src));\n  /* Set packet header size */\n  NDIS_SET_PACKET_HEADER_SIZE(packet->np, \n                              NDIS_GET_PACKET_HEADER_SIZE(src));\n  packet->packet_len = total_len;\n  ssh_packet_query_media_header(packet->np, &media_hdr);\n  if (media_hdr != NULL)\n    {\n      if (protocol == SSH_PROTOCOL_ETHERNET)\n        {\n          if (SSH_ETHER_IS_MULTICAST(media_hdr->dst))\n            packet->ip.flags |= SSH_PACKET_MEDIABCAST;\n        }\n      packet->eth_type = SSH_GET_16BIT(media_hdr->type);\n    }\n  return packet;\n"]]}
{"hexsha": "b0ea68767e5829ac2c890a445204664cf46e333f", "ext": "c", "lang": "C", "content": "INLINE static void\ncalc_phase (OPLL_SLOT * slot, e_int32 lfo)\n{\n  if (slot->patch->PM)\n    slot->phase += (slot->dphase * lfo) >> PM_AMP_BITS;\n  else\n    slot->phase += slot->dphase;\n\n  slot->phase &= (DP_WIDTH - 1);\n\n  slot->pgout = HIGHBITS (slot->phase, DP_BASE_BITS);\n}", "item_id": 23, "repo": "Osmose/moseamp", "file": "musicplayer/plugins/s98plugin/m_s98/device/emu2413/emu2413.c", "last_update_at": "2022-01-11T14:44:14+00:00", "question_id": "b0ea68767e5829ac2c890a445204664cf46e333f_23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["INLINE static void\ncalc_phase (OPLL_SLOT * slot, e_int32 lfo)\n{\n  if (slot->patch->PM)\n    slot->phase += (slot->dphase * lfo) >> PM_AMP_BITS;\n  else\n    slot->phase += slot->dphase;\n  slot->phase &= (DP_WIDTH - 1);\n  slot->pgout = HIGHBITS (slot->phase, DP_BASE_BITS);\n"]]}
{"hexsha": "7f80c9713b0cf46eb43a46bb6cfe0b43fd79e8fb", "ext": "c", "lang": "C", "content": "static int bpf_object__elf_init(struct bpf_object *obj)\n{\n\tint err = 0;\n\tGElf_Ehdr *ep;\n\n\tif (obj_elf_valid(obj)) {\n\t\tpr_warning(\"elf init: internal error\\n\");\n\t\treturn -LIBBPF_ERRNO__LIBELF;\n\t}\n\n\tif (obj->efile.obj_buf_sz > 0) {\n\t\t/*\n\t\t * obj_buf should have been validated by\n\t\t * bpf_object__open_buffer().\n\t\t */\n\t\tobj->efile.elf = elf_memory(obj->efile.obj_buf,\n\t\t\t\t\t    obj->efile.obj_buf_sz);\n\t} else {\n\t\tobj->efile.fd = open(obj->path, O_RDONLY);\n\t\tif (obj->efile.fd < 0) {\n\t\t\tchar errmsg[STRERR_BUFSIZE], *cp;\n\n\t\t\terr = -errno;\n\t\t\tcp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));\n\t\t\tpr_warning(\"failed to open %s: %s\\n\", obj->path, cp);\n\t\t\treturn err;\n\t\t}\n\n\t\tobj->efile.elf = elf_begin(obj->efile.fd,\n\t\t\t\t\t   LIBBPF_ELF_C_READ_MMAP, NULL);\n\t}\n\n\tif (!obj->efile.elf) {\n\t\tpr_warning(\"failed to open %s as ELF file\\n\", obj->path);\n\t\terr = -LIBBPF_ERRNO__LIBELF;\n\t\tgoto errout;\n\t}\n\n\tif (!gelf_getehdr(obj->efile.elf, &obj->efile.ehdr)) {\n\t\tpr_warning(\"failed to get EHDR from %s\\n\", obj->path);\n\t\terr = -LIBBPF_ERRNO__FORMAT;\n\t\tgoto errout;\n\t}\n\tep = &obj->efile.ehdr;\n\n\t/* Old LLVM set e_machine to EM_NONE */\n\tif (ep->e_type != ET_REL ||\n\t    (ep->e_machine && ep->e_machine != EM_BPF)) {\n\t\tpr_warning(\"%s is not an eBPF object file\\n\", obj->path);\n\t\terr = -LIBBPF_ERRNO__FORMAT;\n\t\tgoto errout;\n\t}\n\n\treturn 0;\nerrout:\n\tbpf_object__elf_finish(obj);\n\treturn err;\n}", "item_id": 9, "repo": "alan-maguire/dtrace-utils", "file": "libbpf/libbpf.c", "last_update_at": "2022-03-15T14:36:05+00:00", "question_id": "7f80c9713b0cf46eb43a46bb6cfe0b43fd79e8fb_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int bpf_object__elf_init(struct bpf_object *obj)\n{\n\tint err = 0;\n\tGElf_Ehdr *ep;\n\tif (obj_elf_valid(obj)) {\n\t\tpr_warning(\"elf init: internal error\\n\");\n\t\treturn -LIBBPF_ERRNO__LIBELF;\n\t}\n\tif (obj->efile.obj_buf_sz > 0) {\n\t\t/*\n\t\t * obj_buf should have been validated by\n\t\t * bpf_object__open_buffer().\n\t\t */\n\t\tobj->efile.elf = elf_memory(obj->efile.obj_buf,\n\t\t\t\t\t    obj->efile.obj_buf_sz);\n\t} else {\n\t\tobj->efile.fd = open(obj->path, O_RDONLY);\n\t\tif (obj->efile.fd < 0) {\n\t\t\tchar errmsg[STRERR_BUFSIZE], *cp;\n\t\t\terr = -errno;\n\t\t\tcp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));\n\t\t\tpr_warning(\"failed to open %s: %s\\n\", obj->path, cp);\n\t\t\treturn err;\n\t\t}\n\t\tobj->efile.elf = elf_begin(obj->efile.fd,\n\t\t\t\t\t   LIBBPF_ELF_C_READ_MMAP, NULL);\n\t}\n\tif (!obj->efile.elf) {\n\t\tpr_warning(\"failed to open %s as ELF file\\n\", obj->path);\n\t\terr = -LIBBPF_ERRNO__LIBELF;\n\t\tgoto errout;\n\t}\n\tif (!gelf_getehdr(obj->efile.elf, &obj->efile.ehdr)) {\n\t\tpr_warning(\"failed to get EHDR from %s\\n\", obj->path);\n\t\terr = -LIBBPF_ERRNO__FORMAT;\n\t\tgoto errout;\n\t}\n\tep = &obj->efile.ehdr;\n\t/* Old LLVM set e_machine to EM_NONE */\n\tif (ep->e_type != ET_REL ||\n\t    (ep->e_machine && ep->e_machine != EM_BPF)) {\n\t\tpr_warning(\"%s is not an eBPF object file\\n\", obj->path);\n\t\terr = -LIBBPF_ERRNO__FORMAT;\n\t\tgoto errout;\n\t}\n\treturn 0;\nerrout:\n\tbpf_object__elf_finish(obj);\n\treturn err;\n"]]}
{"hexsha": "72b616439f9d250a23706d1e8aa2791b30c838b2", "ext": "h", "lang": "C", "content": "static __rte_always_inline uint16_t\notx2_ssogws_dual_get_work(struct otx2_ssogws_state *ws,\n\t\t\t  struct otx2_ssogws_state *ws_pair,\n\t\t\t  struct rte_event *ev, const uint32_t flags,\n\t\t\t  const void * const lookup_mem,\n\t\t\t  struct otx2_timesync_info * const tstamp)\n{\n\tconst uint64_t set_gw = BIT_ULL(16) | 1;\n\tunion otx2_sso_event event;\n\tuint64_t tstamp_ptr;\n\tuint64_t get_work1;\n\tuint64_t mbuf;\n\n\tif (flags & NIX_RX_OFFLOAD_PTYPE_F)\n\t\trte_prefetch_non_temporal(lookup_mem);\n#ifdef RTE_ARCH_ARM64\n\tasm volatile(\n\t\t\t\"rty%=:\t                             \\n\"\n\t\t\t\"        ldr %[tag], [%[tag_loc]]    \\n\"\n\t\t\t\"        ldr %[wqp], [%[wqp_loc]]    \\n\"\n\t\t\t\"        tbnz %[tag], 63, rty%=      \\n\"\n\t\t\t\"done%=: str %[gw], [%[pong]]        \\n\"\n\t\t\t\"        dmb ld                      \\n\"\n\t\t\t\"        prfm pldl1keep, [%[wqp], #8]\\n\"\n\t\t\t\"        sub %[mbuf], %[wqp], #0x80  \\n\"\n\t\t\t\"        prfm pldl1keep, [%[mbuf]]   \\n\"\n\t\t\t: [tag] \"=&r\" (event.get_work0),\n\t\t\t  [wqp] \"=&r\" (get_work1),\n\t\t\t  [mbuf] \"=&r\" (mbuf)\n\t\t\t: [tag_loc] \"r\" (ws->tag_op),\n\t\t\t  [wqp_loc] \"r\" (ws->wqp_op),\n\t\t\t  [gw] \"r\" (set_gw),\n\t\t\t  [pong] \"r\" (ws_pair->getwrk_op)\n\t\t\t);\n#else\n\tevent.get_work0 = otx2_read64(ws->tag_op);\n\twhile ((BIT_ULL(63)) & event.get_work0)\n\t\tevent.get_work0 = otx2_read64(ws->tag_op);\n\tget_work1 = otx2_read64(ws->wqp_op);\n\totx2_write64(set_gw, ws_pair->getwrk_op);\n\n\trte_prefetch0((const void *)get_work1);\n\tmbuf = (uint64_t)((char *)get_work1 - sizeof(struct rte_mbuf));\n\trte_prefetch0((const void *)mbuf);\n#endif\n\tevent.get_work0 = (event.get_work0 & (0x3ull << 32)) << 6 |\n\t\t(event.get_work0 & (0x3FFull << 36)) << 4 |\n\t\t(event.get_work0 & 0xffffffff);\n\n\tif (event.sched_type != SSO_TT_EMPTY) {\n\t\tif ((flags & NIX_RX_OFFLOAD_SECURITY_F) &&\n\t\t    (event.event_type == RTE_EVENT_TYPE_CRYPTODEV)) {\n\t\t\tget_work1 = otx2_handle_crypto_event(get_work1);\n\t\t} else if (event.event_type == RTE_EVENT_TYPE_ETHDEV) {\n\t\t\tuint8_t port = event.sub_event_type;\n\n\t\t\tevent.sub_event_type = 0;\n\t\t\totx2_wqe_to_mbuf(get_work1, mbuf, port,\n\t\t\t\t\t event.flow_id, flags, lookup_mem);\n\t\t\t/* Extracting tstamp, if PTP enabled. CGX will prepend\n\t\t\t * the timestamp at starting of packet data and it can\n\t\t\t * be derieved from WQE 9 dword which corresponds to SG\n\t\t\t * iova.\n\t\t\t * rte_pktmbuf_mtod_offset can be used for this purpose\n\t\t\t * but it brings down the performance as it reads\n\t\t\t * mbuf->buf_addr which is not part of cache in general\n\t\t\t * fast path.\n\t\t\t */\n\t\t\ttstamp_ptr = *(uint64_t *)(((struct nix_wqe_hdr_s *)\n\t\t\t\t\t\t     get_work1) +\n\t\t\t\t\t\t     OTX2_SSO_WQE_SG_PTR);\n\t\t\totx2_nix_mbuf_to_tstamp((struct rte_mbuf *)mbuf, tstamp,\n\t\t\t\t\t\tflags, (uint64_t *)tstamp_ptr);\n\t\t\tget_work1 = mbuf;\n\t\t}\n\t}\n\n\tev->event = event.get_work0;\n\tev->u64 = get_work1;\n\n\treturn !!get_work1;\n}", "item_id": 0, "repo": "ajitkhaparde/trex-core", "file": "src/dpdk/drivers/event/octeontx2/otx2_worker_dual.h", "last_update_at": "2022-03-30T06:25:04+00:00", "question_id": "72b616439f9d250a23706d1e8aa2791b30c838b2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static __rte_always_inline uint16_t\notx2_ssogws_dual_get_work(struct otx2_ssogws_state *ws,\n\t\t\t  struct otx2_ssogws_state *ws_pair,\n\t\t\t  struct rte_event *ev, const uint32_t flags,\n\t\t\t  const void * const lookup_mem,\n\t\t\t  struct otx2_timesync_info * const tstamp)\n{\n\tconst uint64_t set_gw = BIT_ULL(16) | 1;\n\tunion otx2_sso_event event;\n\tuint64_t tstamp_ptr;\n\tuint64_t get_work1;\n\tuint64_t mbuf;\n\tif (flags & NIX_RX_OFFLOAD_PTYPE_F)\n\t\trte_prefetch_non_temporal(lookup_mem);\n#ifdef RTE_ARCH_ARM64\n\tasm volatile(\n\t\t\t\"rty%=:\t                             \\n\"\n\t\t\t\"        ldr %[tag], [%[tag_loc]]    \\n\"\n\t\t\t\"        ldr %[wqp], [%[wqp_loc]]    \\n\"\n\t\t\t\"        tbnz %[tag], 63, rty%=      \\n\"\n\t\t\t\"done%=: str %[gw], [%[pong]]        \\n\"\n\t\t\t\"        dmb ld                      \\n\"\n\t\t\t\"        prfm pldl1keep, [%[wqp], #8]\\n\"\n\t\t\t\"        sub %[mbuf], %[wqp], #0x80  \\n\"\n\t\t\t\"        prfm pldl1keep, [%[mbuf]]   \\n\"\n\t\t\t: [tag] \"=&r\" (event.get_work0),\n\t\t\t  [wqp] \"=&r\" (get_work1),\n\t\t\t  [mbuf] \"=&r\" (mbuf)\n\t\t\t: [tag_loc] \"r\" (ws->tag_op),\n\t\t\t  [wqp_loc] \"r\" (ws->wqp_op),\n\t\t\t  [gw] \"r\" (set_gw),\n\t\t\t  [pong] \"r\" (ws_pair->getwrk_op)\n\t\t\t);\n#else\n\tevent.get_work0 = otx2_read64(ws->tag_op);\n\twhile ((BIT_ULL(63)) & event.get_work0)\n\t\tevent.get_work0 = otx2_read64(ws->tag_op);\n\tget_work1 = otx2_read64(ws->wqp_op);\n\totx2_write64(set_gw, ws_pair->getwrk_op);\n\trte_prefetch0((const void *)get_work1);\n\tmbuf = (uint64_t)((char *)get_work1 - sizeof(struct rte_mbuf));\n\trte_prefetch0((const void *)mbuf);\n#endif\n\tevent.get_work0 = (event.get_work0 & (0x3ull << 32)) << 6 |\n\t\t(event.get_work0 & (0x3FFull << 36)) << 4 |\n\t\t(event.get_work0 & 0xffffffff);\n\tif (event.sched_type != SSO_TT_EMPTY) {\n\t\tif ((flags & NIX_RX_OFFLOAD_SECURITY_F) &&\n\t\t    (event.event_type == RTE_EVENT_TYPE_CRYPTODEV)) {\n\t\t\tget_work1 = otx2_handle_crypto_event(get_work1);\n\t\t} else if (event.event_type == RTE_EVENT_TYPE_ETHDEV) {\n\t\t\tuint8_t port = event.sub_event_type;\n\t\t\tevent.sub_event_type = 0;\n\t\t\totx2_wqe_to_mbuf(get_work1, mbuf, port,\n\t\t\t\t\t event.flow_id, flags, lookup_mem);\n\t\t\t/* Extracting tstamp, if PTP enabled. CGX will prepend\n\t\t\t * the timestamp at starting of packet data and it can\n\t\t\t * be derieved from WQE 9 dword which corresponds to SG\n\t\t\t * iova.\n\t\t\t * rte_pktmbuf_mtod_offset can be used for this purpose\n\t\t\t * but it brings down the performance as it reads\n\t\t\t * mbuf->buf_addr which is not part of cache in general\n\t\t\t * fast path.\n\t\t\t */\n\t\t\ttstamp_ptr = *(uint64_t *)(((struct nix_wqe_hdr_s *)\n\t\t\t\t\t\t     get_work1) +\n\t\t\t\t\t\t     OTX2_SSO_WQE_SG_PTR);\n\t\t\totx2_nix_mbuf_to_tstamp((struct rte_mbuf *)mbuf, tstamp,\n\t\t\t\t\t\tflags, (uint64_t *)tstamp_ptr);\n\t\t\tget_work1 = mbuf;\n\t\t}\n\t}\n\tev->event = event.get_work0;\n\tev->u64 = get_work1;\n\treturn !!get_work1;\n"]]}
{"hexsha": "15bb3296d3667296758fe057fcdfccf0f874c873", "ext": "c", "lang": "C", "content": "static void FMPI_Group_excl(MPI_Fint *group, MPI_Fint *n, MPI_Fint *ranks, MPI_Fint *newgroup, MPI_Fint *ierr)\r\n{\r\n#ifdef DEBUG_MPI\r\n\tint debug_rank;\r\n\tPMPI_Comm_rank(MPI_COMM_WORLD, &debug_rank);\r\n\tprintf(\"[DEBUG][RANK:%d] Start MPI_Group_excl()\\n\", debug_rank);\r\n#endif\r\n\tcall_start(__MPI_GROUP_EXCL, MPI_COMM_WORLD, MPI_NONE);\r\n\tpmpi_group_excl_(group, n, ranks, newgroup, ierr);\r\n    call_end(__MPI_GROUP_EXCL, MPI_COMM_WORLD, MPI_NONE);\r\n#ifdef DEBUG_MPI\r\n\tprintf(\"[DEBUG][RANK:%d] End MPI_Group_excl()\\n\", debug_rank);\r\n#endif\r\n}", "item_id": 204, "repo": "f-tesser/countdown", "file": "src/wrapper_pmpi_fortran.c", "last_update_at": "2022-03-22T14:45:38+00:00", "question_id": "15bb3296d3667296758fe057fcdfccf0f874c873_204", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void FMPI_Group_excl(MPI_Fint *group, MPI_Fint *n, MPI_Fint *ranks, MPI_Fint *newgroup, MPI_Fint *ierr)\r\n{\r\n#ifdef DEBUG_MPI\r\n\tint debug_rank;\r\n\tPMPI_Comm_rank(MPI_COMM_WORLD, &debug_rank);\r\n\tprintf(\"[DEBUG][RANK:%d] Start MPI_Group_excl()\\n\", debug_rank);\r\n#endif\r\n\tcall_start(__MPI_GROUP_EXCL, MPI_COMM_WORLD, MPI_NONE);\r\n\tpmpi_group_excl_(group, n, ranks, newgroup, ierr);\r\n    call_end(__MPI_GROUP_EXCL, MPI_COMM_WORLD, MPI_NONE);\r\n#ifdef DEBUG_MPI\r\n\tprintf(\"[DEBUG][RANK:%d] End MPI_Group_excl()\\n\", debug_rank);\r\n#endif\r\n"]]}
{"hexsha": "9affd652287053c3b3b31a5178199d3cb973e52e", "ext": "c", "lang": "C", "content": "static struct segment *\ngsc_getentry(struct gen_sc *gsc, double x)\n{\n\tstruct segment\t*new, *prev, *s;\n\n\tprev = NULL;\n\tLIST_FOREACH(s, gsc, _next) {\n\t\tif (s->x == x)\n\t\t\treturn (s);\t/* matching entry found */\n\t\telse if (s->x < x)\n\t\t\tprev = s;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\t/* we have to create a new entry */\n\tif ((new = calloc(1, sizeof(struct segment))) == NULL)\n\t\treturn (NULL);\n\n\tnew->x = x;\n\tif (x == INFINITY || s == NULL)\n\t\tnew->d = 0;\n\telse if (s->x == INFINITY)\n\t\tnew->d = INFINITY;\n\telse\n\t\tnew->d = s->x - x;\n\tif (prev == NULL) {\n\t\t/* insert the new entry at the head of the list */\n\t\tnew->y = 0;\n\t\tnew->m = 0;\n\t\tLIST_INSERT_HEAD(gsc, new, _next);\n\t} else {\n\t\t/*\n\t\t * the start point intersects with the segment pointed by\n\t\t * prev.  divide prev into 2 segments\n\t\t */\n\t\tif (x == INFINITY) {\n\t\t\tprev->d = INFINITY;\n\t\t\tif (prev->m == 0)\n\t\t\t\tnew->y = prev->y;\n\t\t\telse\n\t\t\t\tnew->y = INFINITY;\n\t\t} else {\n\t\t\tprev->d = x - prev->x;\n\t\t\tnew->y = prev->d * prev->m + prev->y;\n\t\t}\n\t\tnew->m = prev->m;\n\t\tLIST_INSERT_AFTER(prev, new, _next);\n\t}\n\treturn (new);\n}", "item_id": 22, "repo": "MarginC/kame", "file": "kame/kame/pfctl/pfctl_altq.c", "last_update_at": "2022-03-11T16:43:28+00:00", "question_id": "9affd652287053c3b3b31a5178199d3cb973e52e_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct segment *\ngsc_getentry(struct gen_sc *gsc, double x)\n{\n\tstruct segment\t*new, *prev, *s;\n\tprev = NULL;\n\tLIST_FOREACH(s, gsc, _next) {\n\t\tif (s->x == x)\n\t\t\treturn (s);\t/* matching entry found */\n\t\telse if (s->x < x)\n\t\t\tprev = s;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/* we have to create a new entry */\n\tif ((new = calloc(1, sizeof(struct segment))) == NULL)\n\t\treturn (NULL);\n\tnew->x = x;\n\tif (x == INFINITY || s == NULL)\n\t\tnew->d = 0;\n\telse if (s->x == INFINITY)\n\t\tnew->d = INFINITY;\n\telse\n\t\tnew->d = s->x - x;\n\tif (prev == NULL) {\n\t\t/* insert the new entry at the head of the list */\n\t\tnew->y = 0;\n\t\tnew->m = 0;\n\t\tLIST_INSERT_HEAD(gsc, new, _next);\n\t} else {\n\t\t/*\n\t\t * the start point intersects with the segment pointed by\n\t\t * prev.  divide prev into 2 segments\n\t\t */\n\t\tif (x == INFINITY) {\n\t\t\tprev->d = INFINITY;\n\t\t\tif (prev->m == 0)\n\t\t\t\tnew->y = prev->y;\n\t\t\telse\n\t\t\t\tnew->y = INFINITY;\n\t\t} else {\n\t\t\tprev->d = x - prev->x;\n\t\t\tnew->y = prev->d * prev->m + prev->y;\n\t\t}\n\t\tnew->m = prev->m;\n\t\tLIST_INSERT_AFTER(prev, new, _next);\n\t}\n\treturn (new);\n"]]}
{"hexsha": "d201c1523d57df5268805e01098a44d64a201306", "ext": "c", "lang": "C", "content": "int net_service_lookup(char *service)\n{\n  struct servent *se;\n  se = getservbyname(service, NULL);\n  if (se != NULL)\n    return ntohs(se->s_port);\n  else\n    return 0;\n}", "item_id": 25, "repo": "FauxFaux/PuTTYTray", "file": "unix/uxnet.c", "last_update_at": "2022-03-29T06:32:24+00:00", "question_id": "d201c1523d57df5268805e01098a44d64a201306_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int net_service_lookup(char *service)\n{\n  struct servent *se;\n  se = getservbyname(service, NULL);\n  if (se != NULL)\n    return ntohs(se->s_port);\n  else\n    return 0;\n"]]}
{"hexsha": "09e7d28b0f3f4bf6a5159a0101ef99b8f0807a03", "ext": "c", "lang": "C", "content": "uint8_t duProcUlCcchInd(UlCcchIndInfo *ulCcchIndInfo)\n{\n\n   uint8_t ret = ROK;\n   int32_t gnbDuUeF1apId = 0;\n\n   gnbDuUeF1apId = genGnbDuUeF1apId(ulCcchIndInfo->cellId);\n   \n   if(gnbDuUeF1apId == -1)\n   {\n      DU_LOG(\"ERROR  --> DU_APP : duProcUlCcchInd(): Received cellId[%d] does not exist\", ulCcchIndInfo->cellId);\n      return RFAILED;\n   }\n\n   /* Store Ue mapping */\n   duCb.ueCcchCtxt[duCb.numUe].gnbDuUeF1apId = (uint32_t)gnbDuUeF1apId;\n   duCb.ueCcchCtxt[duCb.numUe].crnti         = ulCcchIndInfo->crnti;\n   duCb.ueCcchCtxt[duCb.numUe].cellId        = ulCcchIndInfo->cellId;\n\n   duCb.numUe++;\n\n   ret = (BuildAndSendInitialRrcMsgTransfer(gnbDuUeF1apId, ulCcchIndInfo->crnti, ulCcchIndInfo->ulCcchMsgLen,\n\t    ulCcchIndInfo->ulCcchMsg));\n   if(ret != ROK)\n   {\n      DU_LOG(\"\\nERROR  -->  DU_APP : BuildAndSendInitialRrcMsgTransfer failed\");\n   }\n\n   DU_FREE_SHRABL_BUF(MAC_MEM_REGION, MAC_POOL, ulCcchIndInfo->ulCcchMsg, ulCcchIndInfo->ulCcchMsgLen);\n   DU_FREE_SHRABL_BUF(MAC_MEM_REGION, MAC_POOL, ulCcchIndInfo, sizeof(UlCcchIndInfo));\n\n   return ret;\n\n}", "item_id": 9, "repo": "o-ran-sc/o-du-l2", "file": "src/du_app/du_ue_mgr.c", "last_update_at": "2022-03-05T17:57:52+00:00", "question_id": "09e7d28b0f3f4bf6a5159a0101ef99b8f0807a03_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint8_t duProcUlCcchInd(UlCcchIndInfo *ulCcchIndInfo)\n{\n   uint8_t ret = ROK;\n   int32_t gnbDuUeF1apId = 0;\n   gnbDuUeF1apId = genGnbDuUeF1apId(ulCcchIndInfo->cellId);\n   if(gnbDuUeF1apId == -1)\n   {\n      DU_LOG(\"ERROR  --> DU_APP : duProcUlCcchInd(): Received cellId[%d] does not exist\", ulCcchIndInfo->cellId);\n      return RFAILED;\n   }\n   /* Store Ue mapping */\n   duCb.ueCcchCtxt[duCb.numUe].gnbDuUeF1apId = (uint32_t)gnbDuUeF1apId;\n   duCb.ueCcchCtxt[duCb.numUe].crnti         = ulCcchIndInfo->crnti;\n   duCb.ueCcchCtxt[duCb.numUe].cellId        = ulCcchIndInfo->cellId;\n   duCb.numUe++;\n   ret = (BuildAndSendInitialRrcMsgTransfer(gnbDuUeF1apId, ulCcchIndInfo->crnti, ulCcchIndInfo->ulCcchMsgLen,\n\t    ulCcchIndInfo->ulCcchMsg));\n   if(ret != ROK)\n   {\n      DU_LOG(\"\\nERROR  -->  DU_APP : BuildAndSendInitialRrcMsgTransfer failed\");\n   }\n   DU_FREE_SHRABL_BUF(MAC_MEM_REGION, MAC_POOL, ulCcchIndInfo->ulCcchMsg, ulCcchIndInfo->ulCcchMsgLen);\n   DU_FREE_SHRABL_BUF(MAC_MEM_REGION, MAC_POOL, ulCcchIndInfo, sizeof(UlCcchIndInfo));\n   return ret;\n"]]}
{"hexsha": "6dc2b57f62bc4fbe83ad330a835fcfd890aed5ee", "ext": "c", "lang": "C", "content": "void hfs_bnode_free(struct hfs_bnode *node)\n{\n\t//int i;\n\n\t//for (i = 0; i < node->tree->pages_per_bnode; i++)\n\t//\tif (node->page[i])\n\t//\t\tpage_cache_release(node->page[i]);\n\tkfree(node);\n}", "item_id": 25, "repo": "oslab-swrc/juxta", "file": "analyzer/data/fs/linux-4.0-rc2/hfs.c", "last_update_at": "2022-02-12T15:53:20+00:00", "question_id": "6dc2b57f62bc4fbe83ad330a835fcfd890aed5ee_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void hfs_bnode_free(struct hfs_bnode *node)\n{\n\t//int i;\n\t//for (i = 0; i < node->tree->pages_per_bnode; i++)\n\t//\tif (node->page[i])\n\t//\t\tpage_cache_release(node->page[i]);\n\tkfree(node);\n"]]}
{"hexsha": "0d0f85874c1b37365ef46b5fcddd947e08fbd818", "ext": "c", "lang": "C", "content": "void pbox_dec2on(shape *dshape)\t\t\n{\n  dec2power(dshape->pwr);\n  if (dshape->pwrf) dec2pwrf(dshape->pwrf);\n#ifndef NVPSG\n  dec2prgon(dshape->name, 1.0/dshape->dmf, dshape->dres); \n  dec2on();\n#else\n  dec2on();\n  dec2prgon(dshape->name, 1.0/dshape->dmf, dshape->dres); \n#endif\n}", "item_id": 10, "repo": "DanIverson/OpenVnmrJ", "file": "src/psg/Pbox_psg.c", "last_update_at": "2022-03-28T17:54:44+00:00", "question_id": "0d0f85874c1b37365ef46b5fcddd947e08fbd818_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void pbox_dec2on(shape *dshape)\t\t\n{\n  dec2power(dshape->pwr);\n  if (dshape->pwrf) dec2pwrf(dshape->pwrf);\n#ifndef NVPSG\n  dec2prgon(dshape->name, 1.0/dshape->dmf, dshape->dres); \n  dec2on();\n#else\n  dec2on();\n  dec2prgon(dshape->name, 1.0/dshape->dmf, dshape->dres); \n#endif\n"]]}
{"hexsha": "6ae29c45e11a2651b7933af7d325483988f55ccd", "ext": "c", "lang": "C", "content": "Bool \nS3V_I2CInit(ScrnInfoPtr pScrn)\n{\n    S3VPtr ps3v = S3VPTR(pScrn);\n    I2CBusPtr I2CPtr;\n\n\n    I2CPtr = xf86CreateI2CBusRec();\n    if(!I2CPtr) return FALSE;\n\n    ps3v->I2C = I2CPtr;\n\n    I2CPtr->BusName    = \"I2C bus\";\n    I2CPtr->scrnIndex  = pScrn->scrnIndex;\n    I2CPtr->I2CPutBits = s3v_I2CPutBits;\n    I2CPtr->I2CGetBits = s3v_I2CGetBits;\n\n    if (!xf86I2CBusInit(I2CPtr))\n      return FALSE;\n\n    return TRUE;\n}", "item_id": 2, "repo": "sourcecode-reloaded/Xming", "file": "programs/Xserver/hw/xfree86/drivers/s3virge/s3v_i2c.c", "last_update_at": "2022-01-15T11:26:11+00:00", "question_id": "6ae29c45e11a2651b7933af7d325483988f55ccd_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Bool \nS3V_I2CInit(ScrnInfoPtr pScrn)\n{\n    S3VPtr ps3v = S3VPTR(pScrn);\n    I2CBusPtr I2CPtr;\n    I2CPtr = xf86CreateI2CBusRec();\n    if(!I2CPtr) return FALSE;\n    ps3v->I2C = I2CPtr;\n    I2CPtr->BusName    = \"I2C bus\";\n    I2CPtr->scrnIndex  = pScrn->scrnIndex;\n    I2CPtr->I2CPutBits = s3v_I2CPutBits;\n    I2CPtr->I2CGetBits = s3v_I2CGetBits;\n    if (!xf86I2CBusInit(I2CPtr))\n      return FALSE;\n    return TRUE;\n"]]}
{"hexsha": "ca4248aed6902fef56f2716e004067dbc8bfb8b3", "ext": "c", "lang": "C", "content": "static void r600_vce_get_buffer(struct pipe_resource *resource,\n\t\t\t\tstruct pb_buffer **handle,\n\t\t\t\tstruct radeon_surf **surface)\n{\n\tstruct r600_texture *res = (struct r600_texture *)resource;\n\n\tif (handle)\n\t\t*handle = res->resource.buf;\n\n\tif (surface)\n\t\t*surface = &res->surface;\n}", "item_id": 2, "repo": "thermasol/mesa3d", "file": "src/gallium/drivers/r600/r600_uvd.c", "last_update_at": "2022-03-26T08:39:34+00:00", "question_id": "ca4248aed6902fef56f2716e004067dbc8bfb8b3_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void r600_vce_get_buffer(struct pipe_resource *resource,\n\t\t\t\tstruct pb_buffer **handle,\n\t\t\t\tstruct radeon_surf **surface)\n{\n\tstruct r600_texture *res = (struct r600_texture *)resource;\n\tif (handle)\n\t\t*handle = res->resource.buf;\n\tif (surface)\n\t\t*surface = &res->surface;\n"]]}
{"hexsha": "7ee4055bf91401857d7901c2de68cecbdce77bbc", "ext": "c", "lang": "C", "content": "static int sensor_irq(void *ctx)\n{\n    if (g_dvp_finish_flag == 1)\n    {\n        dvp_config_interrupt(DVP_CFG_START_INT_ENABLE | DVP_CFG_FINISH_INT_ENABLE, 0);\n    }\n\n    // sensor_t *sensor = ctx;\n    if (dvp_get_interrupt(DVP_STS_FRAME_FINISH))\n    { //frame end\n        dvp_clear_interrupt(DVP_STS_FRAME_START | DVP_STS_FRAME_FINISH);\n        g_dvp_finish_flag = 1;\n    }\n    else\n    {                               //frame start\n        if (g_dvp_finish_flag == 0) //only we finish the convert, do transmit again\n            dvp_start_convert();    //so we need deal img ontime, or skip one framebefore next\n        dvp_clear_interrupt(DVP_STS_FRAME_START);\n    }\n    //rt_kprintf(\"D\\n\");\n    return 0;\n}", "item_id": 14, "repo": "yangtuo250/K210-Micropython-OpenMV", "file": "src/openmv/omv/hal/k210/cambus.c", "last_update_at": "2022-03-25T09:14:28+00:00", "question_id": "7ee4055bf91401857d7901c2de68cecbdce77bbc_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int sensor_irq(void *ctx)\n{\n    if (g_dvp_finish_flag == 1)\n    {\n        dvp_config_interrupt(DVP_CFG_START_INT_ENABLE | DVP_CFG_FINISH_INT_ENABLE, 0);\n    }\n    // sensor_t *sensor = ctx;\n    if (dvp_get_interrupt(DVP_STS_FRAME_FINISH))\n    { //frame end\n        dvp_clear_interrupt(DVP_STS_FRAME_START | DVP_STS_FRAME_FINISH);\n        g_dvp_finish_flag = 1;\n    }\n    else\n    {                               //frame start\n        if (g_dvp_finish_flag == 0) //only we finish the convert, do transmit again\n            dvp_start_convert();    //so we need deal img ontime, or skip one framebefore next\n        dvp_clear_interrupt(DVP_STS_FRAME_START);\n    }\n    //rt_kprintf(\"D\\n\");\n    return 0;\n"]]}
{"hexsha": "c547d019512306e53bdbd200dc65427432bf17ff", "ext": "c", "lang": "C", "content": "void create(){\n   ::create();\n\n   set_long(::query_long()+\"\\n%^C247%^To the South you can see stairs leading down.%^CRST%^\\n\");\n\nset_exits(([\n\"south\" : WHITE\"8\",\n\"southwest\" : WHITE\"10\",\n\"southeast\" : WHITE\"14\",\n\n]));\n\n\n}", "item_id": 0, "repo": "Dbevan/SunderingShadows", "file": "d/islands/serakii/rooms/white/9.c", "last_update_at": "2022-02-25T19:44:15+00:00", "question_id": "c547d019512306e53bdbd200dc65427432bf17ff_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void create(){\n   ::create();\n   set_long(::query_long()+\"\\n%^C247%^To the South you can see stairs leading down.%^CRST%^\\n\");\nset_exits(([\n\"south\" : WHITE\"8\",\n\"southwest\" : WHITE\"10\",\n\"southeast\" : WHITE\"14\",\n]));\n"]]}
{"hexsha": "6cfa598c36e593ae541ee899a9d99018dd9082e4", "ext": "c", "lang": "C", "content": "static int set_sampler_gain(int gain, void *param)\n{\n    if (gain < 1 || gain > 200) {\n        return -1;\n    }\n\n    sampler_gain = gain;\n\n    return 0;\n}", "item_id": 4, "repo": "slajerek/RetroDebugger", "file": "src/Emulators/vice/samplerdrv/sampler.c", "last_update_at": "2022-03-10T20:16:03+00:00", "question_id": "6cfa598c36e593ae541ee899a9d99018dd9082e4_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int set_sampler_gain(int gain, void *param)\n{\n    if (gain < 1 || gain > 200) {\n        return -1;\n    }\n    sampler_gain = gain;\n    return 0;\n"]]}
{"hexsha": "dbb8d9de5b798425b8cd4d0a4d271f8501ce76aa", "ext": "h", "lang": "C", "content": "always_inline void *\nvlib_physmem_at_offset (vlib_main_t * vm, vlib_physmem_region_index_t idx,\n\t\t\tuword offset)\n{\n  vlib_physmem_region_t *pr = vlib_physmem_get_region (vm, idx);\n  ASSERT (offset < pr->size);\n  return uword_to_pointer (pointer_to_uword (pr->mem) + offset, void *);\n}", "item_id": 2, "repo": "nightairuta/vpp-fd", "file": "src/vlib/physmem_funcs.h", "last_update_at": "2022-03-11T09:55:03+00:00", "question_id": "dbb8d9de5b798425b8cd4d0a4d271f8501ce76aa_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["always_inline void *\nvlib_physmem_at_offset (vlib_main_t * vm, vlib_physmem_region_index_t idx,\n\t\t\tuword offset)\n{\n  vlib_physmem_region_t *pr = vlib_physmem_get_region (vm, idx);\n  ASSERT (offset < pr->size);\n  return uword_to_pointer (pointer_to_uword (pr->mem) + offset, void *);\n"]]}
{"hexsha": "f7a94fe582b2e0450878ee787e2f298247757661", "ext": "c", "lang": "C", "content": "static void vnode_server_delclient(vnode_cliententry_t *client)\n{\n#ifdef DEBUG\n  WARNX(\"deleting client for fds %d %d\", client->clientfd, client->msgio.fd);\n#endif\n\n  TAILQ_REMOVE(&client->server->clientlisthead, client, entries);\n  vnode_msgiostop(&client->msgio);\n  close(client->clientfd);\n  memset(client, 0, sizeof(*client));\n  free(client);\n\n  return;\n}", "item_id": 2, "repo": "alehmannFRA-UAS/core", "file": "netns/vnode_server.c", "last_update_at": "2022-03-31T16:11:29+00:00", "question_id": "f7a94fe582b2e0450878ee787e2f298247757661_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void vnode_server_delclient(vnode_cliententry_t *client)\n{\n#ifdef DEBUG\n  WARNX(\"deleting client for fds %d %d\", client->clientfd, client->msgio.fd);\n#endif\n  TAILQ_REMOVE(&client->server->clientlisthead, client, entries);\n  vnode_msgiostop(&client->msgio);\n  close(client->clientfd);\n  memset(client, 0, sizeof(*client));\n  free(client);\n  return;\n"]]}
{"hexsha": "dcd81104bed97e1239a780600c669557cbf41d60", "ext": "c", "lang": "C", "content": "static struct roots_text_input *relay_get_focusable_text_input(\n\t\tstruct roots_input_method_relay *relay) {\n\tstruct roots_text_input *text_input = NULL;\n\twl_list_for_each(text_input, &relay->text_inputs, link) {\n\t\tif (text_input->pending_focused_surface) {\n\t\t\treturn text_input;\n\t\t}\n\t}\n\treturn NULL;\n}", "item_id": 0, "repo": "any1/wlroots", "file": "rootston/text_input.c", "last_update_at": "2022-01-08T02:38:24+00:00", "question_id": "dcd81104bed97e1239a780600c669557cbf41d60_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct roots_text_input *relay_get_focusable_text_input(\n\t\tstruct roots_input_method_relay *relay) {\n\tstruct roots_text_input *text_input = NULL;\n\twl_list_for_each(text_input, &relay->text_inputs, link) {\n\t\tif (text_input->pending_focused_surface) {\n\t\t\treturn text_input;\n\t\t}\n\t}\n\treturn NULL;\n"]]}
{"hexsha": "cf8c1bbc10aefe71a4f898727439d9c67dbe963d", "ext": "c", "lang": "C", "content": "void\nngx_postgres_wev_handler(ngx_http_request_t *r, ngx_http_upstream_t *u)\n{\n    ngx_connection_t  *pgxc;\n\n    dd(\"entering\");\n\n    /* just to ensure u->reinit_request always gets called for\n     * upstream_next */\n    u->request_sent = 1;\n\n    pgxc = u->peer.connection;\n\n    if (pgxc->write->timedout) {\n        dd(\"postgres connection write timeout\");\n\n        ngx_postgres_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_TIMEOUT);\n\n        dd(\"returning\");\n        return;\n    }\n\n    if (ngx_postgres_upstream_test_connect(pgxc) != NGX_OK) {\n        dd(\"postgres connection is broken\");\n\n        ngx_postgres_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_ERROR);\n\n        dd(\"returning\");\n        return;\n    }\n\n    ngx_postgres_process_events(r);\n\n    dd(\"returning\");\n}", "item_id": 1, "repo": "alexspetty/openresty", "file": "bundle/ngx_postgres-1.0rc7/src/ngx_postgres_handler.c", "last_update_at": "2022-03-27T21:29:27+00:00", "question_id": "cf8c1bbc10aefe71a4f898727439d9c67dbe963d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nngx_postgres_wev_handler(ngx_http_request_t *r, ngx_http_upstream_t *u)\n{\n    ngx_connection_t  *pgxc;\n    dd(\"entering\");\n    /* just to ensure u->reinit_request always gets called for\n     * upstream_next */\n    u->request_sent = 1;\n    pgxc = u->peer.connection;\n    if (pgxc->write->timedout) {\n        dd(\"postgres connection write timeout\");\n        ngx_postgres_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_TIMEOUT);\n        dd(\"returning\");\n        return;\n    }\n    if (ngx_postgres_upstream_test_connect(pgxc) != NGX_OK) {\n        dd(\"postgres connection is broken\");\n        ngx_postgres_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_ERROR);\n        dd(\"returning\");\n        return;\n    }\n    ngx_postgres_process_events(r);\n    dd(\"returning\");\n"]]}
{"hexsha": "15f9b7c9e4d38e93a52864a953e12d4172602797", "ext": "c", "lang": "C", "content": "static int ntb_setup_bwd_msix(struct ntb_device *ndev, int msix_entries)\n{\n\tstruct pci_dev *pdev = ndev->pdev;\n\tstruct msix_entry *msix;\n\tint rc, i;\n\n\tmsix_entries = pci_enable_msix_range(pdev, ndev->msix_entries,\n\t\t\t\t\t     1, msix_entries);\n\tif (msix_entries < 0)\n\t\treturn msix_entries;\n\n\tfor (i = 0; i < msix_entries; i++) {\n\t\tmsix = &ndev->msix_entries[i];\n\t\tWARN_ON(!msix->vector);\n\n\t\trc = request_irq(msix->vector, bwd_callback_msix_irq, 0,\n\t\t\t\t \"ntb-callback-msix\", &ndev->db_cb[i]);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\tndev->num_msix = msix_entries;\n\tndev->max_cbs = msix_entries;\n\n\treturn 0;\n\nerr:\n\twhile (--i >= 0)\n\t\tfree_irq(msix->vector, &ndev->db_cb[i]);\n\n\tpci_disable_msix(pdev);\n\tndev->num_msix = 0;\n\n\treturn rc;\n}", "item_id": 24, "repo": "atakanakbulut/imx-kernel", "file": "imx7d-variscite/drivers/ntb/ntb_hw.c", "last_update_at": "2022-02-21T07:09:11+00:00", "question_id": "15f9b7c9e4d38e93a52864a953e12d4172602797_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int ntb_setup_bwd_msix(struct ntb_device *ndev, int msix_entries)\n{\n\tstruct pci_dev *pdev = ndev->pdev;\n\tstruct msix_entry *msix;\n\tint rc, i;\n\tmsix_entries = pci_enable_msix_range(pdev, ndev->msix_entries,\n\t\t\t\t\t     1, msix_entries);\n\tif (msix_entries < 0)\n\t\treturn msix_entries;\n\tfor (i = 0; i < msix_entries; i++) {\n\t\tmsix = &ndev->msix_entries[i];\n\t\tWARN_ON(!msix->vector);\n\t\trc = request_irq(msix->vector, bwd_callback_msix_irq, 0,\n\t\t\t\t \"ntb-callback-msix\", &ndev->db_cb[i]);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\tndev->num_msix = msix_entries;\n\tndev->max_cbs = msix_entries;\n\treturn 0;\nerr:\n\twhile (--i >= 0)\n\t\tfree_irq(msix->vector, &ndev->db_cb[i]);\n\tpci_disable_msix(pdev);\n\tndev->num_msix = 0;\n\treturn rc;\n"]]}
{"hexsha": "b796717562bfbab3e01408f27470e15550478e69", "ext": "c", "lang": "C", "content": "void\nmpz_lcm_ui (mpz_ptr r, mpz_srcptr u, mpir_ui v)\n{\n  mp_size_t      usize;\n  mp_srcptr      up;\n  mp_ptr         rp;\n  mpir_ui         g;\n  mp_limb_t      c;\n\n#if BITS_PER_UI > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (v > GMP_NUMB_MAX)\n    {\n      mpz_t vz;\n      mp_limb_t vlimbs[2];\n      vlimbs[0] = v & GMP_NUMB_MASK;\n      vlimbs[1] = v >> GMP_NUMB_BITS;\n      PTR(vz) = vlimbs;\n      SIZ(vz) = 2;\n      mpz_lcm (r, u, vz);\n      return;\n    }\n#endif\n\n  /* result zero if either operand zero */\n  usize = SIZ(u);\n  if (usize == 0 || v == 0)\n    {\n      SIZ(r) = 0;\n      return;\n    }\n  usize = ABS(usize);\n\n  MPZ_REALLOC (r, usize+1);\n\n  up = PTR(u);\n  g = (mpir_ui) mpn_gcd_1 (up, usize, (mp_limb_t) v);\n  v /= g;\n\n  rp = PTR(r);\n  c = mpn_mul_1 (rp, up, usize, (mp_limb_t) v);\n  rp[usize] = c;\n  usize += (c != 0);\n  SIZ(r) = usize;\n}", "item_id": 0, "repo": "JaminChan/eos_win", "file": "externals/mpir-3.0.0/mpz/lcm_ui.c", "last_update_at": "2022-03-31T15:01:21+00:00", "question_id": "b796717562bfbab3e01408f27470e15550478e69_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nmpz_lcm_ui (mpz_ptr r, mpz_srcptr u, mpir_ui v)\n{\n  mp_size_t      usize;\n  mp_srcptr      up;\n  mp_ptr         rp;\n  mpir_ui         g;\n  mp_limb_t      c;\n#if BITS_PER_UI > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (v > GMP_NUMB_MAX)\n    {\n      mpz_t vz;\n      mp_limb_t vlimbs[2];\n      vlimbs[0] = v & GMP_NUMB_MASK;\n      vlimbs[1] = v >> GMP_NUMB_BITS;\n      PTR(vz) = vlimbs;\n      SIZ(vz) = 2;\n      mpz_lcm (r, u, vz);\n      return;\n    }\n#endif\n  /* result zero if either operand zero */\n  usize = SIZ(u);\n  if (usize == 0 || v == 0)\n    {\n      SIZ(r) = 0;\n      return;\n    }\n  usize = ABS(usize);\n  MPZ_REALLOC (r, usize+1);\n  up = PTR(u);\n  g = (mpir_ui) mpn_gcd_1 (up, usize, (mp_limb_t) v);\n  v /= g;\n  rp = PTR(r);\n  c = mpn_mul_1 (rp, up, usize, (mp_limb_t) v);\n  rp[usize] = c;\n  usize += (c != 0);\n  SIZ(r) = usize;\n"]]}
{"hexsha": "0b7f7a02b65ce6926d64aa8575f3cc9d7ec0a35f", "ext": "c", "lang": "C", "content": "uint8_t ListValidAlarmCodes(uint16_t DeviceId) {\n\tuint8_t DeviceIndex;\n\tpAuthorizedCodes codes;\n\tuint8_t i;\n\tuint8_t AlarmCodeCount = 0;\n\n\tif ((DeviceIndex = FindDeviceId(DeviceId)) == MAX_DEVICES) {\n\t\treturn(0);\n\t}\n\n\t// make sure it's a keypad or swipe device\n\tif (Devices[DeviceIndex].Type != DEVICE_KEYPAD && Devices[DeviceIndex].Type != DEVICE_SWIPE) {\n\t\treturn(0);\n\t}\n\n\t// make a copy of the device's valid codes\n\tif (!Devices[DeviceIndex].Attributes) {\n\t\tSendBytes((unsigned char *)&AlarmCodeCount, 1);\n\t\tSendResp(RESP_SUCCESS, NULL);\n\t\treturn(1);\n\t}\n\tif ((codes = (pAuthorizedCodes)calloc(sizeof(AuthorizedCodes))) == NULL) {\n\t\treturn(0);\n\t}\n\tmemcpy(codes, Devices[DeviceIndex].Attributes, sizeof(AuthorizedCodes));\n\tSortCodes(codes);\n\n\t// once through to get a count of codes we'll be sending\n\tfor (i = 0; i < MAX_USERS; i++) {\n\t\tif (codes->AccessCodes[i][0] == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tAlarmCodeCount++;\n\t}\n\n\t// Send the count\n\tSendBytes((unsigned char *)&AlarmCodeCount, 1);\n\n\t// Send the codes\n\tfor (i = 0; i < MAX_USERS; i++) {\n\t\tif (codes->AccessCodes[i][0] == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tSendBytes((unsigned char *)&codes->AccessCodes[i], 32);\n\t}\n\n\tSendResp(RESP_SUCCESS, NULL);\n\n\tfree(codes);\n\n\treturn(1);\n}", "item_id": 15, "repo": "li-xin-yi/cgc-cbs", "file": "examples/CROMU_00092/src/device.c", "last_update_at": "2022-02-21T15:37:22+00:00", "question_id": "0b7f7a02b65ce6926d64aa8575f3cc9d7ec0a35f_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint8_t ListValidAlarmCodes(uint16_t DeviceId) {\n\tuint8_t DeviceIndex;\n\tpAuthorizedCodes codes;\n\tuint8_t i;\n\tuint8_t AlarmCodeCount = 0;\n\tif ((DeviceIndex = FindDeviceId(DeviceId)) == MAX_DEVICES) {\n\t\treturn(0);\n\t}\n\t// make sure it's a keypad or swipe device\n\tif (Devices[DeviceIndex].Type != DEVICE_KEYPAD && Devices[DeviceIndex].Type != DEVICE_SWIPE) {\n\t\treturn(0);\n\t}\n\t// make a copy of the device's valid codes\n\tif (!Devices[DeviceIndex].Attributes) {\n\t\tSendBytes((unsigned char *)&AlarmCodeCount, 1);\n\t\tSendResp(RESP_SUCCESS, NULL);\n\t\treturn(1);\n\t}\n\tif ((codes = (pAuthorizedCodes)calloc(sizeof(AuthorizedCodes))) == NULL) {\n\t\treturn(0);\n\t}\n\tmemcpy(codes, Devices[DeviceIndex].Attributes, sizeof(AuthorizedCodes));\n\tSortCodes(codes);\n\t// once through to get a count of codes we'll be sending\n\tfor (i = 0; i < MAX_USERS; i++) {\n\t\tif (codes->AccessCodes[i][0] == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tAlarmCodeCount++;\n\t}\n\t// Send the count\n\tSendBytes((unsigned char *)&AlarmCodeCount, 1);\n\t// Send the codes\n\tfor (i = 0; i < MAX_USERS; i++) {\n\t\tif (codes->AccessCodes[i][0] == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tSendBytes((unsigned char *)&codes->AccessCodes[i], 32);\n\t}\n\tSendResp(RESP_SUCCESS, NULL);\n\tfree(codes);\n\treturn(1);\n"]]}
{"hexsha": "8612543ffdfd40e3b789d5bfa923203654529e6e", "ext": "c", "lang": "C", "content": "void test_IotBleSetDeviceName_While_BLE_Is_On( void )\n{\n    prvTestTurnOnBLE();\n\n    prvBleTestSetDeviceProperty_Stub( prvSaveConfiguration );\n\n    prvBleTestSetAdvData_IgnoreAndReturn( eBTStatusSuccess );\n    IotSemaphore_Wait_Ignore();\n    prvBleTestSetAdvData_IgnoreAndReturn( eBTStatusSuccess );\n    IotSemaphore_Wait_Ignore();\n    TEST_ASSERT_EQUAL( eBTStatusSuccess, IotBle_SetDeviceName( CUSTOM_BLE_DEVICE_NAME, strlen( CUSTOM_BLE_DEVICE_NAME ) ) );\n\n    TEST_ASSERT_EQUAL( 0, strncmp( bleConfig.deviceName, CUSTOM_BLE_DEVICE_NAME, strlen( CUSTOM_BLE_DEVICE_NAME ) ) );\n\n    prvTestTurnOffBLE();\n}", "item_id": 25, "repo": "archigup/amazon-freertos", "file": "libraries/ble/utest/middleware/iot_ble_gap_gatt_utest.c", "last_update_at": "2022-03-29T01:03:36+00:00", "question_id": "8612543ffdfd40e3b789d5bfa923203654529e6e_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void test_IotBleSetDeviceName_While_BLE_Is_On( void )\n{\n    prvTestTurnOnBLE();\n    prvBleTestSetDeviceProperty_Stub( prvSaveConfiguration );\n    prvBleTestSetAdvData_IgnoreAndReturn( eBTStatusSuccess );\n    IotSemaphore_Wait_Ignore();\n    prvBleTestSetAdvData_IgnoreAndReturn( eBTStatusSuccess );\n    IotSemaphore_Wait_Ignore();\n    TEST_ASSERT_EQUAL( eBTStatusSuccess, IotBle_SetDeviceName( CUSTOM_BLE_DEVICE_NAME, strlen( CUSTOM_BLE_DEVICE_NAME ) ) );\n    TEST_ASSERT_EQUAL( 0, strncmp( bleConfig.deviceName, CUSTOM_BLE_DEVICE_NAME, strlen( CUSTOM_BLE_DEVICE_NAME ) ) );\n    prvTestTurnOffBLE();\n"]]}
{"hexsha": "a8307d55c70eaadc99e03aba65cef24d71668121", "ext": "c", "lang": "C", "content": "static int __init imx_phycore_init(void)\n{\n\tint ret;\n\n\tif (!machine_is_pcm043() && !machine_is_pca100())\n\t\t/* return happy. We might run on a totally different machine */\n\t\treturn 0;\n\n\timx_phycore_snd_device = platform_device_alloc(\"soc-audio\", -1);\n\tif (!imx_phycore_snd_device)\n\t\treturn -ENOMEM;\n\n\timx_phycore_dai_ac97[0].cpu_dai = &imx_ssi_pcm_dai[0];\n\n\tplatform_set_drvdata(imx_phycore_snd_device, &imx_phycore_snd_devdata);\n\timx_phycore_snd_devdata.dev = &imx_phycore_snd_device->dev;\n\tret = platform_device_add(imx_phycore_snd_device);\n\n\tif (ret) {\n\t\tprintk(KERN_ERR \"ASoC: Platform device allocation failed\\n\");\n\t\tplatform_device_put(imx_phycore_snd_device);\n\t}\n\n\treturn ret;\n}", "item_id": 0, "repo": "afeng11/tomato-arm", "file": "release/src-rt-6.x.4708/linux/linux-2.6.36/sound/soc/imx/phycore-ac97.c", "last_update_at": "2022-03-20T14:24:29+00:00", "question_id": "a8307d55c70eaadc99e03aba65cef24d71668121_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int __init imx_phycore_init(void)\n{\n\tint ret;\n\tif (!machine_is_pcm043() && !machine_is_pca100())\n\t\t/* return happy. We might run on a totally different machine */\n\t\treturn 0;\n\timx_phycore_snd_device = platform_device_alloc(\"soc-audio\", -1);\n\tif (!imx_phycore_snd_device)\n\t\treturn -ENOMEM;\n\timx_phycore_dai_ac97[0].cpu_dai = &imx_ssi_pcm_dai[0];\n\tplatform_set_drvdata(imx_phycore_snd_device, &imx_phycore_snd_devdata);\n\timx_phycore_snd_devdata.dev = &imx_phycore_snd_device->dev;\n\tret = platform_device_add(imx_phycore_snd_device);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"ASoC: Platform device allocation failed\\n\");\n\t\tplatform_device_put(imx_phycore_snd_device);\n\t}\n\treturn ret;\n"]]}
{"hexsha": "583aa66edb52cbbb87701a97737865d0772ff770", "ext": "c", "lang": "C", "content": "static enum rte_vhost_msg_result\nextern_vhost_pre_msg_handler(int vid, void *_msg)\n{\n\tstruct vhost_user_msg *msg = _msg;\n\tstruct spdk_vhost_session *vsession;\n\n\tvsession = vhost_session_find_by_vid(vid);\n\tif (vsession == NULL) {\n\t\tSPDK_ERRLOG(\"Received a message to unitialized session (vid %d).\\n\", vid);\n\t\tassert(false);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\n\tswitch (msg->request) {\n\tcase VHOST_USER_GET_VRING_BASE:\n\t\tif (vsession->forced_polling && vsession->started) {\n\t\t\t/* Our queue is stopped for whatever reason, but we may still\n\t\t\t * need to poll it after it's initialized again.\n\t\t\t */\n\t\t\tg_spdk_vhost_ops.destroy_device(vid);\n\t\t}\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ADDR:\n\tcase VHOST_USER_SET_VRING_NUM:\n\t\tif (vsession->forced_polling && vsession->started) {\n\t\t\t/* Additional queues are being initialized, so we either processed\n\t\t\t * enough I/Os and are switching from SeaBIOS to the OS now, or\n\t\t\t * we were never in SeaBIOS in the first place. Either way, we\n\t\t\t * don't need our workaround anymore.\n\t\t\t */\n\t\t\tg_spdk_vhost_ops.destroy_device(vid);\n\t\t\tvsession->forced_polling = false;\n\t\t}\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_KICK:\n\t\t/* rte_vhost(after 20.08) will call new_device after one active vring is\n\t\t * configured, we will start the session before all vrings are available,\n\t\t * so for each new vring, if the session is started, we need to restart it\n\t\t * again.\n\t\t */\n\tcase VHOST_USER_SET_VRING_CALL:\n\t\t/* rte_vhost will close the previous callfd and won't notify\n\t\t * us about any change. This will effectively make SPDK fail\n\t\t * to deliver any subsequent interrupts until a session is\n\t\t * restarted. We stop the session here before closing the previous\n\t\t * fd (so that all interrupts must have been delivered by the\n\t\t * time the descriptor is closed) and start right after (which\n\t\t * will make SPDK retrieve the latest, up-to-date callfd from\n\t\t * rte_vhost.\n\t\t */\n\tcase VHOST_USER_SET_MEM_TABLE:\n\t\t/* rte_vhost will unmap previous memory that SPDK may still\n\t\t * have pending DMA operations on. We can't let that happen,\n\t\t * so stop the device before letting rte_vhost unmap anything.\n\t\t * This will block until all pending I/Os are finished.\n\t\t * We will start the device again from the post-processing\n\t\t * message handler.\n\t\t */\n\t\tif (vsession->started) {\n\t\t\tg_spdk_vhost_ops.destroy_device(vid);\n\t\t\tvsession->needs_restart = true;\n\t\t}\n\t\tbreak;\n\tcase VHOST_USER_GET_CONFIG: {\n\t\tint rc = 0;\n\n\t\tspdk_vhost_lock();\n\t\tif (vsession->vdev->backend->vhost_get_config) {\n\t\t\trc = vsession->vdev->backend->vhost_get_config(vsession->vdev,\n\t\t\t\tmsg->payload.cfg.region, msg->payload.cfg.size);\n\t\t\tif (rc != 0) {\n\t\t\t\tmsg->size = 0;\n\t\t\t}\n\t\t}\n\t\tspdk_vhost_unlock();\n\n\t\treturn RTE_VHOST_MSG_RESULT_REPLY;\n\t}\n\tcase VHOST_USER_SET_CONFIG: {\n\t\tint rc = 0;\n\n\t\tspdk_vhost_lock();\n\t\tif (vsession->vdev->backend->vhost_set_config) {\n\t\t\trc = vsession->vdev->backend->vhost_set_config(vsession->vdev,\n\t\t\t\tmsg->payload.cfg.region, msg->payload.cfg.offset,\n\t\t\t\tmsg->payload.cfg.size, msg->payload.cfg.flags);\n\t\t}\n\t\tspdk_vhost_unlock();\n\n\t\treturn rc == 0 ? RTE_VHOST_MSG_RESULT_OK : RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn RTE_VHOST_MSG_RESULT_NOT_HANDLED;\n}", "item_id": 5, "repo": "xiangping-chen/spdk", "file": "lib/vhost/rte_vhost_user.c", "last_update_at": "2022-02-10T11:43:21+00:00", "question_id": "583aa66edb52cbbb87701a97737865d0772ff770_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static enum rte_vhost_msg_result\nextern_vhost_pre_msg_handler(int vid, void *_msg)\n{\n\tstruct vhost_user_msg *msg = _msg;\n\tstruct spdk_vhost_session *vsession;\n\tvsession = vhost_session_find_by_vid(vid);\n\tif (vsession == NULL) {\n\t\tSPDK_ERRLOG(\"Received a message to unitialized session (vid %d).\\n\", vid);\n\t\tassert(false);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tswitch (msg->request) {\n\tcase VHOST_USER_GET_VRING_BASE:\n\t\tif (vsession->forced_polling && vsession->started) {\n\t\t\t/* Our queue is stopped for whatever reason, but we may still\n\t\t\t * need to poll it after it's initialized again.\n\t\t\t */\n\t\t\tg_spdk_vhost_ops.destroy_device(vid);\n\t\t}\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ADDR:\n\tcase VHOST_USER_SET_VRING_NUM:\n\t\tif (vsession->forced_polling && vsession->started) {\n\t\t\t/* Additional queues are being initialized, so we either processed\n\t\t\t * enough I/Os and are switching from SeaBIOS to the OS now, or\n\t\t\t * we were never in SeaBIOS in the first place. Either way, we\n\t\t\t * don't need our workaround anymore.\n\t\t\t */\n\t\t\tg_spdk_vhost_ops.destroy_device(vid);\n\t\t\tvsession->forced_polling = false;\n\t\t}\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_KICK:\n\t\t/* rte_vhost(after 20.08) will call new_device after one active vring is\n\t\t * configured, we will start the session before all vrings are available,\n\t\t * so for each new vring, if the session is started, we need to restart it\n\t\t * again.\n\t\t */\n\tcase VHOST_USER_SET_VRING_CALL:\n\t\t/* rte_vhost will close the previous callfd and won't notify\n\t\t * us about any change. This will effectively make SPDK fail\n\t\t * to deliver any subsequent interrupts until a session is\n\t\t * restarted. We stop the session here before closing the previous\n\t\t * fd (so that all interrupts must have been delivered by the\n\t\t * time the descriptor is closed) and start right after (which\n\t\t * will make SPDK retrieve the latest, up-to-date callfd from\n\t\t * rte_vhost.\n\t\t */\n\tcase VHOST_USER_SET_MEM_TABLE:\n\t\t/* rte_vhost will unmap previous memory that SPDK may still\n\t\t * have pending DMA operations on. We can't let that happen,\n\t\t * so stop the device before letting rte_vhost unmap anything.\n\t\t * This will block until all pending I/Os are finished.\n\t\t * We will start the device again from the post-processing\n\t\t * message handler.\n\t\t */\n\t\tif (vsession->started) {\n\t\t\tg_spdk_vhost_ops.destroy_device(vid);\n\t\t\tvsession->needs_restart = true;\n\t\t}\n\t\tbreak;\n\tcase VHOST_USER_GET_CONFIG: {\n\t\tint rc = 0;\n\t\tspdk_vhost_lock();\n\t\tif (vsession->vdev->backend->vhost_get_config) {\n\t\t\trc = vsession->vdev->backend->vhost_get_config(vsession->vdev,\n\t\t\t\tmsg->payload.cfg.region, msg->payload.cfg.size);\n\t\t\tif (rc != 0) {\n\t\t\t\tmsg->size = 0;\n\t\t\t}\n\t\t}\n\t\tspdk_vhost_unlock();\n\t\treturn RTE_VHOST_MSG_RESULT_REPLY;\n\t}\n\tcase VHOST_USER_SET_CONFIG: {\n\t\tint rc = 0;\n\t\tspdk_vhost_lock();\n\t\tif (vsession->vdev->backend->vhost_set_config) {\n\t\t\trc = vsession->vdev->backend->vhost_set_config(vsession->vdev,\n\t\t\t\tmsg->payload.cfg.region, msg->payload.cfg.offset,\n\t\t\t\tmsg->payload.cfg.size, msg->payload.cfg.flags);\n\t\t}\n\t\tspdk_vhost_unlock();\n\t\treturn rc == 0 ? RTE_VHOST_MSG_RESULT_OK : RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\treturn RTE_VHOST_MSG_RESULT_NOT_HANDLED;\n"]]}
{"hexsha": "824d1f91334573edc0dfc8285409900603e09a3e", "ext": "c", "lang": "C", "content": "void close(file_t *file)\n{\n    free(file->name);\n    free(file->content);\n    free(file);\n}", "item_id": 3, "repo": "mducat/OS_S", "file": "oss_lib/src/fs.c", "last_update_at": "2022-02-15T22:41:22+00:00", "question_id": "824d1f91334573edc0dfc8285409900603e09a3e_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void close(file_t *file)\n{\n    free(file->name);\n    free(file->content);\n    free(file);\n"]]}
{"hexsha": "7f3e3983b781d72af83b0fc47006b1a2ff34078c", "ext": "c", "lang": "C", "content": "static int mt7601u_submit_rx(struct mt7601u_dev *dev)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < dev->rx_q.entries; i++) {\n\t\tret = mt7601u_submit_rx_buf(dev, &dev->rx_q.e[i], GFP_KERNEL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "item_id": 14, "repo": "bingchunjin/1806_SDK", "file": "linux-4.14.90-dev/linux-4.14.90/drivers/net/wireless/mediatek/mt7601u/dma.c", "last_update_at": "2022-03-07T12:09:00+00:00", "question_id": "7f3e3983b781d72af83b0fc47006b1a2ff34078c_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int mt7601u_submit_rx(struct mt7601u_dev *dev)\n{\n\tint i, ret;\n\tfor (i = 0; i < dev->rx_q.entries; i++) {\n\t\tret = mt7601u_submit_rx_buf(dev, &dev->rx_q.e[i], GFP_KERNEL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n"]]}
{"hexsha": "b5dbbfbbdd770d96fbefbd245e3dd2fe9be9f13e", "ext": "c", "lang": "C", "content": "static int\njson_encode_network_credentials(const struct dpp_network *network, struct json_object **jcredentials)\n{\n    int ret;\n    json_object *credentials = json_object_new_array();\n    if (!credentials) {\n        zlog_error(\"failed to allocate json array for network credentials\");\n        return -ENOMEM;\n    }\n\n    struct json_object *jcredential;\n    struct dpp_network_credential *credential;\n    list_for_each_entry (credential, &network->credentials, list) {\n        ret = json_encode_network_credential(credential, &jcredential);\n        if (ret < 0) {\n            zlog_error(\"failed to encode network credential for json network object (%d)\", ret);\n            goto fail;\n        }\n\n        ret = json_object_array_add(credentials, jcredential);\n        if (ret < 0) {\n            zlog_error(\"failed to add network credential to json credentials array (%d)\", ret);\n            json_object_put(jcredential);\n            goto fail;\n        }\n    }\n\n    *jcredentials = credentials;\nout:\n    return ret;\nfail:\n    json_object_put(credentials);\n    goto out;\n}", "item_id": 21, "repo": "microsoft/wifi-ztp", "file": "src/core/ztp_configurator_config.c", "last_update_at": "2022-01-26T18:39:41+00:00", "question_id": "b5dbbfbbdd770d96fbefbd245e3dd2fe9be9f13e_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\njson_encode_network_credentials(const struct dpp_network *network, struct json_object **jcredentials)\n{\n    int ret;\n    json_object *credentials = json_object_new_array();\n    if (!credentials) {\n        zlog_error(\"failed to allocate json array for network credentials\");\n        return -ENOMEM;\n    }\n    struct json_object *jcredential;\n    struct dpp_network_credential *credential;\n    list_for_each_entry (credential, &network->credentials, list) {\n        ret = json_encode_network_credential(credential, &jcredential);\n        if (ret < 0) {\n            zlog_error(\"failed to encode network credential for json network object (%d)\", ret);\n            goto fail;\n        }\n        ret = json_object_array_add(credentials, jcredential);\n        if (ret < 0) {\n            zlog_error(\"failed to add network credential to json credentials array (%d)\", ret);\n            json_object_put(jcredential);\n            goto fail;\n        }\n    }\n    *jcredentials = credentials;\nout:\n    return ret;\nfail:\n    json_object_put(credentials);\n    goto out;\n"]]}
{"hexsha": "a64a89a0719c5f7c1e9a37a1e50a63d99054ae16", "ext": "h", "lang": "C", "content": "class MT_Vector3\n{\npublic:\n    explicit MT_Vector3() {}\n    template <typename T>\n    explicit MT_Vector3(const T *v) { setValue(v); }", "item_id": 0, "repo": "linluofeng/upbge", "file": "intern/moto/include/MT_Vector3.h", "last_update_at": "2022-01-11T10:02:21+00:00", "question_id": "a64a89a0719c5f7c1e9a37a1e50a63d99054ae16_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class MT_Vector3\n{\npublic:\n    explicit MT_Vector3() {}\n    template <typename T>\n"]]}
{"hexsha": "48520eb771941244e16c71f5213c3ae70318abb7", "ext": "c", "lang": "C", "content": "static int LZ4F_decompress_safe (const char* source, char* dest, int compressedSize, int maxDecompressedSize, const char* dictStart, int dictSize)\n{\n    (void)dictStart; (void)dictSize;\n    return LZ4_decompress_safe (source, dest, compressedSize, maxDecompressedSize);\n}", "item_id": 65, "repo": "eckserah/nifskope", "file": "lib/lz4frame.c", "last_update_at": "2022-03-28T16:32:15+00:00", "question_id": "48520eb771941244e16c71f5213c3ae70318abb7_65", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int LZ4F_decompress_safe (const char* source, char* dest, int compressedSize, int maxDecompressedSize, const char* dictStart, int dictSize)\n{\n    (void)dictStart; (void)dictSize;\n    return LZ4_decompress_safe (source, dest, compressedSize, maxDecompressedSize);\n"]]}
{"hexsha": "995b31ece6b8604fe93242f2402fdfb0ae91cdf0", "ext": "c", "lang": "C", "content": "WRITE_HANDLER( m72_port02_w )\n{\n\tif (offset != 0)\n\t{\n\t\tif (data) log_cb(RETRO_LOG_DEBUG, LOGPRE \"write %02x to port 03\\n\",data);\n\t\treturn;\n\t}\n\tif (data & 0xe0) log_cb(RETRO_LOG_DEBUG, LOGPRE \"write %02x to port 02\\n\",data);\n\n\t/* bits 0/1 are coin counters */\n\tcoin_counter_w(0,data & 0x01);\n\tcoin_counter_w(1,data & 0x02);\n\n\t/* bit 2 is flip screen (handled both by software and hardware) */\n\tflip_screen_set(((data & 0x04) >> 2) ^ (~readinputport(5) & 1));\n\n\t/* bit 3 is display disable */\n\tvideo_off = data & 0x08;\n\n\t/* bit 4 resets sound CPU (active low) */\n\tif (data & 0x10)\n\t\tcpu_set_reset_line(1,CLEAR_LINE);\n\telse\n\t\tcpu_set_reset_line(1,ASSERT_LINE);\n\n\t/* bit 5 = \"bank\"? */\n}", "item_id": 17, "repo": "trngaje/mame-2003-plus-kaze", "file": "src/vidhrdw/m72_vidhrdw.c", "last_update_at": "2022-03-27T17:39:03+00:00", "question_id": "995b31ece6b8604fe93242f2402fdfb0ae91cdf0_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["WRITE_HANDLER( m72_port02_w )\n{\n\tif (offset != 0)\n\t{\n\t\tif (data) log_cb(RETRO_LOG_DEBUG, LOGPRE \"write %02x to port 03\\n\",data);\n\t\treturn;\n\t}\n\tif (data & 0xe0) log_cb(RETRO_LOG_DEBUG, LOGPRE \"write %02x to port 02\\n\",data);\n\t/* bits 0/1 are coin counters */\n\tcoin_counter_w(0,data & 0x01);\n\tcoin_counter_w(1,data & 0x02);\n\t/* bit 2 is flip screen (handled both by software and hardware) */\n\tflip_screen_set(((data & 0x04) >> 2) ^ (~readinputport(5) & 1));\n\t/* bit 3 is display disable */\n\tvideo_off = data & 0x08;\n\t/* bit 4 resets sound CPU (active low) */\n\tif (data & 0x10)\n\t\tcpu_set_reset_line(1,CLEAR_LINE);\n\telse\n\t\tcpu_set_reset_line(1,ASSERT_LINE);\n\t/* bit 5 = \"bank\"? */\n"]]}
{"hexsha": "2ed47c658c9fcbe7f9392f164baac9bcb8bf73ec", "ext": "c", "lang": "C", "content": "int TaskLocalNewton_Solve(SUNNonlinearSolver NLS,\n                          N_Vector y0, N_Vector ycor,\n                          N_Vector w, double tol,\n                          booleantype callLSetup, void* mem)\n{\n  /* local variables */\n  MPI_Comm comm;\n  int solve_status, recover, nonrecover;\n\n  /* check that the inputs are non-null */\n  if ((NLS  == NULL) ||\n      (y0   == NULL) ||\n      (ycor == NULL) ||\n      (w    == NULL) ||\n      (mem  == NULL))\n    return SUN_NLS_MEM_NULL;\n\n  /* shortcuts */\n  comm = GET_NLS_CONTENT(NLS)->comm;\n\n  /* each tasks solves the local nonlinear system */\n  solve_status = SUNNonlinSolSolve(LOCAL_NLS(NLS),\n                                   N_VGetLocalVector_MPIPlusX(y0),\n                                   N_VGetLocalVector_MPIPlusX(ycor),\n                                   N_VGetLocalVector_MPIPlusX(w),\n                                   tol, callLSetup, mem);\n\n  /* if any process had a nonrecoverable failure, return it */\n  MPI_Allreduce(&solve_status, &nonrecover, 1, MPI_INT, MPI_MIN, comm);\n  if (nonrecover < 0) return nonrecover;\n\n  /* check if any process has a recoverable convergence failure */\n  MPI_Allreduce(&solve_status, &recover, 1, MPI_INT, MPI_MAX, comm);\n  if (recover == SUN_NLS_CONV_RECVR) GET_NLS_CONTENT(NLS)->ncnf++;\n\n  /* return success (recover == 0) or a recoverable error code (recover > 0) */\n  return recover;\n}", "item_id": 11, "repo": "chrispbradley/sundials", "file": "examples/arkode/C_parallel/ark_brusselator1D_task_local_nls.c", "last_update_at": "2022-02-04T06:07:42+00:00", "question_id": "2ed47c658c9fcbe7f9392f164baac9bcb8bf73ec_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int TaskLocalNewton_Solve(SUNNonlinearSolver NLS,\n                          N_Vector y0, N_Vector ycor,\n                          N_Vector w, double tol,\n                          booleantype callLSetup, void* mem)\n{\n  /* local variables */\n  MPI_Comm comm;\n  int solve_status, recover, nonrecover;\n  /* check that the inputs are non-null */\n  if ((NLS  == NULL) ||\n      (y0   == NULL) ||\n      (ycor == NULL) ||\n      (w    == NULL) ||\n      (mem  == NULL))\n    return SUN_NLS_MEM_NULL;\n  /* shortcuts */\n  comm = GET_NLS_CONTENT(NLS)->comm;\n  /* each tasks solves the local nonlinear system */\n  solve_status = SUNNonlinSolSolve(LOCAL_NLS(NLS),\n                                   N_VGetLocalVector_MPIPlusX(y0),\n                                   N_VGetLocalVector_MPIPlusX(ycor),\n                                   N_VGetLocalVector_MPIPlusX(w),\n                                   tol, callLSetup, mem);\n  /* if any process had a nonrecoverable failure, return it */\n  MPI_Allreduce(&solve_status, &nonrecover, 1, MPI_INT, MPI_MIN, comm);\n  if (nonrecover < 0) return nonrecover;\n  /* check if any process has a recoverable convergence failure */\n  MPI_Allreduce(&solve_status, &recover, 1, MPI_INT, MPI_MAX, comm);\n  if (recover == SUN_NLS_CONV_RECVR) GET_NLS_CONTENT(NLS)->ncnf++;\n  /* return success (recover == 0) or a recoverable error code (recover > 0) */\n  return recover;\n"]]}
{"hexsha": "36ded5c10d2c79af3592d043fc53d34a4f7728f7", "ext": "c", "lang": "C", "content": "static void init_pointdensityrangedata(PointDensity *pd, PointDensityRangeData *pdr, \n\tfloat *density, float *vec, float *age, struct CurveMapping *density_curve, float velscale)\n{\n\tpdr->squared_radius = pd->radius*pd->radius;\n\tpdr->density = density;\n\tpdr->point_data = pd->point_data;\n\tpdr->falloff_type = pd->falloff_type;\n\tpdr->vec = vec;\n\tpdr->age = age;\n\tpdr->softness = pd->falloff_softness;\n\tpdr->noise_influence = pd->noise_influence;\n\tpdr->point_data_used = point_data_used(pd);\n\tpdr->offset = (pdr->point_data_used & POINT_DATA_VEL)?pd->totpoints*3:0;\n\tpdr->density_curve = density_curve;\n\tpdr->velscale = velscale;\n}", "item_id": 9, "repo": "wycivil08/blendocv", "file": "source/blender/render/intern/source/pointdensity.c", "last_update_at": "2022-01-10T07:47:29+00:00", "question_id": "36ded5c10d2c79af3592d043fc53d34a4f7728f7_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void init_pointdensityrangedata(PointDensity *pd, PointDensityRangeData *pdr, \n\tfloat *density, float *vec, float *age, struct CurveMapping *density_curve, float velscale)\n{\n\tpdr->squared_radius = pd->radius*pd->radius;\n\tpdr->density = density;\n\tpdr->point_data = pd->point_data;\n\tpdr->falloff_type = pd->falloff_type;\n\tpdr->vec = vec;\n\tpdr->age = age;\n\tpdr->softness = pd->falloff_softness;\n\tpdr->noise_influence = pd->noise_influence;\n\tpdr->point_data_used = point_data_used(pd);\n\tpdr->offset = (pdr->point_data_used & POINT_DATA_VEL)?pd->totpoints*3:0;\n\tpdr->density_curve = density_curve;\n\tpdr->velscale = velscale;\n"]]}
{"hexsha": "e523da4b448072e3b7422d26c4f2ee524bc20574", "ext": "c", "lang": "C", "content": "static void start_encoding( void )\n{   low = 0;                                    /* Full code range.         */\n    high = Top_value;\n    bits_to_follow = 0;                         /* No bits to follow next.  */\n}", "item_id": 4, "repo": "Nuullll/llvm-test-suite", "file": "MultiSource/Benchmarks/FreeBench/pcompress2/arithmetic.c", "last_update_at": "2022-03-28T02:16:13+00:00", "question_id": "e523da4b448072e3b7422d26c4f2ee524bc20574_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void start_encoding( void )\n{   low = 0;                                    /* Full code range.         */\n    high = Top_value;\n    bits_to_follow = 0;                         /* No bits to follow next.  */\n"]]}
{"hexsha": "9c95873d0dba32f4c5b67bd482fa1ae39d3b826f", "ext": "c", "lang": "C", "content": "signed long\n_kcl_fence_wait_timeout(struct dma_fence *fence, bool intr, signed long timeout)\n{\n\tsigned long ret;\n\n\tif (WARN_ON(timeout < 0))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Modifications [2017-03-29] (c) [2017]\n\t * Advanced Micro Devices, Inc.\n\t */\n\ttrace_kcl_fence_wait_start(fence);\n\tif (fence->ops->wait)\n\t\tret = fence->ops->wait(fence, intr, timeout);\n\telse\n\t\tret = _kcl_fence_default_wait(fence, intr, timeout);\n\ttrace_kcl_fence_wait_end(fence);\n\treturn ret;\n}", "item_id": 3, "repo": "SJTU-IPADS/reef-artifacts", "file": "reef-env/amdgpu-dkms/amdgpu-4.3-52/amd/amdkcl/kcl_fence.c", "last_update_at": "2022-03-30T02:44:42+00:00", "question_id": "9c95873d0dba32f4c5b67bd482fa1ae39d3b826f_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["signed long\n_kcl_fence_wait_timeout(struct dma_fence *fence, bool intr, signed long timeout)\n{\n\tsigned long ret;\n\tif (WARN_ON(timeout < 0))\n\t\treturn -EINVAL;\n\t/*\n\t * Modifications [2017-03-29] (c) [2017]\n\t * Advanced Micro Devices, Inc.\n\t */\n\ttrace_kcl_fence_wait_start(fence);\n\tif (fence->ops->wait)\n\t\tret = fence->ops->wait(fence, intr, timeout);\n\telse\n\t\tret = _kcl_fence_default_wait(fence, intr, timeout);\n\ttrace_kcl_fence_wait_end(fence);\n\treturn ret;\n"]]}
{"hexsha": "9aa9c505b90ee129b87eb49761c7dd63813e5d26", "ext": "c", "lang": "C", "content": "int ili9341_vcom_ctrl_2(const ili9341_t *dev, ili9341_vcom_ctrl_2_t config)\n{\n    uint8_t data[1] = { 0 };\n    data[0] = *(uint8_t*)&config ;\n    return _sendCommandData(dev, ILI9341_VCOM_CTR_2, data, sizeof(data));\n}", "item_id": 16, "repo": "lukasa1993/esp-open-rtos", "file": "lvgl/lv_drivers/display/ILI9341.c", "last_update_at": "2022-03-24T23:28:52+00:00", "question_id": "9aa9c505b90ee129b87eb49761c7dd63813e5d26_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int ili9341_vcom_ctrl_2(const ili9341_t *dev, ili9341_vcom_ctrl_2_t config)\n{\n    uint8_t data[1] = { 0 };\n    data[0] = *(uint8_t*)&config ;\n    return _sendCommandData(dev, ILI9341_VCOM_CTR_2, data, sizeof(data));\n"]]}
{"hexsha": "806cc9aa58d0ce76dcee6162b896cfdd6cfe2e71", "ext": "h", "lang": "C", "content": "namespace gpu3d {\n\n\n/**  Defines the different states for a memory request entry.  */\nenum MemReqState\n{\n    MRS_READY,      /**<  The memory request can be processed.  */\n    MRS_WAITING,    /**<  The memory request is waiting for the memory module response.  */\n    MRS_MEMORY,     /**<  The memory request is going to GPU memory.  */\n    MRS_TRANSMITING /**<  The memory request is being transmited to a GPU unit.  */\n};\n\n/***  This defines the GPU unit source of the memory transaction request.  */\nenum GPUUnit\n{\n    COMMANDPROCESSOR = 0,   /**<  Command Processor unit.  */\n    STREAMERFETCH,          /**<  Streamer Fetch unit.  */\n    STREAMERLOADER,         /**<  Streamer Loader unit.  */\n    ZSTENCILTEST,           /**<  Z Stencil Test unit.  */\n    COLORWRITE,             /**<  Color Write unit.  */\n    DACB,                   /**<  DAC unit.  */\n    TEXTUREUNIT,            /**<  Texture Unit.  */\n    MEMORYMODULE,           /**<  Memory modules buses (channels), not used in Version 2 */\n    SYSTEM,                 /**<  System memory bus.  */\n    LASTGPUBUS              /**<  Marks the last GPU bus entry.  */\n};\n\n/**\n * Defines the memory controller state.\n */\nenum MemState\n{\n    MS_NONE         = 0x00, /**<  Does not accept any request.  */\n    MS_READ_ACCEPT  = 0x01, /**<  Read requests can be issued.  */\n    MS_WRITE_ACCEPT = 0x02, /**<  Write data can be sent to the Memory Controller.  */\n    MS_BOTH         = 0x03  /**<  Accepts read requests and write data transactions.  */\n};\n\n/*\n * This defines the different types of memory transactions.\n */\nenum MemTransCom\n{\n    MT_READ_REQ,    /**<  Read request from GPU memory.  */\n    MT_READ_DATA,   /**<  Read data from GPU memory.  */\n    MT_WRITE_DATA,  /**<  Write data to GPU memory.  */\n    MT_PRELOAD_DATA,/**<  Preload data into GPU memory.  */\n    MT_STATE        /**<  Carries the current state of the memory controller.  */\n};\n\n\n\n/***  Maximum size of a memory transaction.  */\nconst u32bit MAX_TRANSACTION_SIZE = 64;\n\n/**\n *  Defines the mask to get the offset for a transaction\n *  offset.\n */\nconst u32bit TRANSACTION_OFFSET_MASK = (MAX_TRANSACTION_SIZE - 1);\n\n/**  Write mask size.  */\nconst u32bit WRITE_MASK_SIZE = (MAX_TRANSACTION_SIZE >> 2);\n\n/***  Maximum number of memory transaction ids availables.  */\nstatic const u32bit MAX_MEMORY_TICKETS = 256;\n\n\n}", "item_id": 0, "repo": "attila-sim/attila-sim", "file": "src/sim/MemoryController/MemoryControllerDefs.h", "last_update_at": "2022-01-13T14:02:08+00:00", "question_id": "806cc9aa58d0ce76dcee6162b896cfdd6cfe2e71_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace gpu3d {\n/**  Defines the different states for a memory request entry.  */\nenum MemReqState\n{\n    MRS_READY,      /**<  The memory request can be processed.  */\n    MRS_WAITING,    /**<  The memory request is waiting for the memory module response.  */\n    MRS_MEMORY,     /**<  The memory request is going to GPU memory.  */\n    MRS_TRANSMITING /**<  The memory request is being transmited to a GPU unit.  */\n};\n/***  This defines the GPU unit source of the memory transaction request.  */\nenum GPUUnit\n{\n    COMMANDPROCESSOR = 0,   /**<  Command Processor unit.  */\n    STREAMERFETCH,          /**<  Streamer Fetch unit.  */\n    STREAMERLOADER,         /**<  Streamer Loader unit.  */\n    ZSTENCILTEST,           /**<  Z Stencil Test unit.  */\n    COLORWRITE,             /**<  Color Write unit.  */\n    DACB,                   /**<  DAC unit.  */\n    TEXTUREUNIT,            /**<  Texture Unit.  */\n    MEMORYMODULE,           /**<  Memory modules buses (channels), not used in Version 2 */\n    SYSTEM,                 /**<  System memory bus.  */\n    LASTGPUBUS              /**<  Marks the last GPU bus entry.  */\n};\n/**\n * Defines the memory controller state.\n */\nenum MemState\n{\n    MS_NONE         = 0x00, /**<  Does not accept any request.  */\n    MS_READ_ACCEPT  = 0x01, /**<  Read requests can be issued.  */\n    MS_WRITE_ACCEPT = 0x02, /**<  Write data can be sent to the Memory Controller.  */\n    MS_BOTH         = 0x03  /**<  Accepts read requests and write data transactions.  */\n};\n/*\n * This defines the different types of memory transactions.\n */\nenum MemTransCom\n{\n    MT_READ_REQ,    /**<  Read request from GPU memory.  */\n    MT_READ_DATA,   /**<  Read data from GPU memory.  */\n    MT_WRITE_DATA,  /**<  Write data to GPU memory.  */\n    MT_PRELOAD_DATA,/**<  Preload data into GPU memory.  */\n    MT_STATE        /**<  Carries the current state of the memory controller.  */\n};\n/***  Maximum size of a memory transaction.  */\nconst u32bit MAX_TRANSACTION_SIZE = 64;\n/**\n *  Defines the mask to get the offset for a transaction\n *  offset.\n */\nconst u32bit TRANSACTION_OFFSET_MASK = (MAX_TRANSACTION_SIZE - 1);\n/**  Write mask size.  */\nconst u32bit WRITE_MASK_SIZE = (MAX_TRANSACTION_SIZE >> 2);\n/***  Maximum number of memory transaction ids availables.  */\nstatic const u32bit MAX_MEMORY_TICKETS = 256;\n"]]}
{"hexsha": "af497e52e9312f4a4917ecacad0ed224392e73d0", "ext": "c", "lang": "C", "content": "void draw_test (int id, ps_context* gc)\n{\n    ps_color col = {0, 0, 1, 1};\n    ps_color sol = {1, 0, 0, 1};\n    ps_rect cr = {2.7f , 3.4f, 272.4f, 261.3f};\n    ps_point s = {50.1f, 50.3f};\n    ps_point e = {200.7f, 50.3f};\n\n    ps_point p[3] = {{100,100},{200, 300},{ 300, 40}};\n    ps_point cp = {128, 128};\n    ps_point sc = {10, 228};\n    ps_rect br = {50, 50, 120, 100};\n\n    ps_set_line_width(gc, 1);\n    ps_set_stroke_color(gc, &sol);\n\n//    ps_set_line_dash(gc, dashs[0].s, dashs[0].d, 4);\n    ps_set_source_color(gc, &col);\n    ps_arc (gc, &cp, 10 , 0, 6.28f, True);\n    ps_stroke(gc);\n\n//    ps_set_line_dash(gc, dashs[1].s, dashs[1].d, 4);\n    ps_tangent_arc(gc, &br, 0, 1.254f);\n    ps_stroke(gc);\n    ps_move_to(gc, &sc);\n    ps_bezier_curve_to(gc, &p[0], &p[1], &p[2]);\n\n    ps_arc (gc, &cp, 100 , 0.785f, 3.140f, False);\n    \n    ps_bezier_curve_to(gc, &p[0], &p[1], &p[2]);\n    \n//    ps_set_line_dash(gc, dashs[2].s, dashs[2].d, 4);\n    ps_quad_curve_to(gc, &p[1], &p[2]);\n    ps_stroke(gc);\n\n//    ps_set_line_dash(gc, dashs[3].s, dashs[3].d, 4);\n    ps_rectangle(gc, &cr);\n    ps_rounded_rect(gc, &gt, 45.2f, 35.2f, 25.2f, 25.2f, 35.2f, 55.2f, 65.2f, 85.2f);\n    ps_ellipse(gc, &gr);\n    ps_stroke(gc);\n\n//    ps_reset_line_dash(gc);\n    ps_move_to(gc, &s);\n    ps_line_to(gc, &e);\n    ps_stroke(gc);\n}", "item_id": 0, "repo": "xuxiandi/picasso-graphic", "file": "test/gamma_func.c", "last_update_at": "2022-03-30T10:06:21+00:00", "question_id": "af497e52e9312f4a4917ecacad0ed224392e73d0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void draw_test (int id, ps_context* gc)\n{\n    ps_color col = {0, 0, 1, 1};\n    ps_color sol = {1, 0, 0, 1};\n    ps_rect cr = {2.7f , 3.4f, 272.4f, 261.3f};\n    ps_point s = {50.1f, 50.3f};\n    ps_point e = {200.7f, 50.3f};\n    ps_point p[3] = {{100,100},{200, 300},{ 300, 40}};\n    ps_point cp = {128, 128};\n    ps_point sc = {10, 228};\n    ps_rect br = {50, 50, 120, 100};\n    ps_set_line_width(gc, 1);\n    ps_set_stroke_color(gc, &sol);\n//    ps_set_line_dash(gc, dashs[0].s, dashs[0].d, 4);\n    ps_set_source_color(gc, &col);\n    ps_arc (gc, &cp, 10 , 0, 6.28f, True);\n    ps_stroke(gc);\n//    ps_set_line_dash(gc, dashs[1].s, dashs[1].d, 4);\n    ps_tangent_arc(gc, &br, 0, 1.254f);\n    ps_stroke(gc);\n    ps_move_to(gc, &sc);\n    ps_bezier_curve_to(gc, &p[0], &p[1], &p[2]);\n    ps_arc (gc, &cp, 100 , 0.785f, 3.140f, False);\n    ps_bezier_curve_to(gc, &p[0], &p[1], &p[2]);\n//    ps_set_line_dash(gc, dashs[2].s, dashs[2].d, 4);\n    ps_quad_curve_to(gc, &p[1], &p[2]);\n    ps_stroke(gc);\n//    ps_set_line_dash(gc, dashs[3].s, dashs[3].d, 4);\n    ps_rectangle(gc, &cr);\n    ps_rounded_rect(gc, &gt, 45.2f, 35.2f, 25.2f, 25.2f, 35.2f, 55.2f, 65.2f, 85.2f);\n    ps_ellipse(gc, &gr);\n    ps_stroke(gc);\n//    ps_reset_line_dash(gc);\n    ps_move_to(gc, &s);\n    ps_line_to(gc, &e);\n    ps_stroke(gc);\n"]]}
{"hexsha": "801daf4ab44dd9aaff62906624d0182e120a9444", "ext": "c", "lang": "C", "content": "GtkWidget *\ngtr_message_log_window_new (GtkWindow * parent, TrCore * core)\n{\n  GtkWidget * win;\n  GtkWidget * vbox;\n  GtkWidget * toolbar;\n  GtkWidget * w;\n  GtkWidget * view;\n  GtkToolItem * item;\n  struct MsgData * data;\n\n  data = g_new0 (struct MsgData, 1);\n  data->core = core;\n\n  win = gtk_window_new (GTK_WINDOW_TOPLEVEL);\n  gtk_window_set_transient_for (GTK_WINDOW (win), parent);\n  gtk_window_set_title (GTK_WINDOW (win), _(\"Message Log\"));\n  gtk_window_set_default_size (GTK_WINDOW (win), 560, 350);\n  gtk_window_set_role (GTK_WINDOW (win), \"message-log\");\n  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);\n\n  /**\n  ***  toolbar\n  **/\n\n  toolbar = gtk_toolbar_new ();\n  gtk_toolbar_set_style (GTK_TOOLBAR (toolbar), GTK_TOOLBAR_BOTH_HORIZ);\n  gtk_style_context_add_class (gtk_widget_get_style_context (toolbar),\n                               GTK_STYLE_CLASS_PRIMARY_TOOLBAR);\n\n  item = gtk_tool_button_new_from_stock (GTK_STOCK_SAVE_AS);\n  g_object_set (G_OBJECT (item), \"is-important\", TRUE, NULL);\n  g_signal_connect (item, \"clicked\", G_CALLBACK (onSaveRequest), data);\n  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);\n\n  item = gtk_tool_button_new_from_stock (GTK_STOCK_CLEAR);\n  g_object_set (G_OBJECT (item), \"is-important\", TRUE, NULL);\n  g_signal_connect (item, \"clicked\", G_CALLBACK (onClearRequest), data);\n  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);\n\n  item = gtk_separator_tool_item_new ();\n  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);\n\n  item = gtk_toggle_tool_button_new_from_stock (GTK_STOCK_MEDIA_PAUSE);\n  g_object_set (G_OBJECT (item), \"is-important\", TRUE, NULL);\n  g_signal_connect (item, \"toggled\", G_CALLBACK (onPauseToggled), data);\n  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);\n\n  item = gtk_separator_tool_item_new ();\n  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);\n\n  w = gtk_label_new (_(\"Level\"));\n  gtk_misc_set_padding (GTK_MISC (w), GUI_PAD, 0);\n  item = gtk_tool_item_new ();\n  gtk_container_add (GTK_CONTAINER (item), w);\n  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);\n\n  w = debug_level_combo_new ();\n  g_signal_connect (w, \"changed\", G_CALLBACK (level_combo_changed_cb), data);\n  item = gtk_tool_item_new ();\n  gtk_container_add (GTK_CONTAINER (item), w);\n  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);\n\n  gtk_box_pack_start (GTK_BOX (vbox), toolbar, FALSE, FALSE, 0);\n\n  /**\n  ***  messages\n  **/\n\n  data->store = gtk_list_store_new (N_COLUMNS,\n                                    G_TYPE_UINT,       /* sequence */\n                                    G_TYPE_POINTER,    /* category */\n                                    G_TYPE_POINTER,    /* message */\n                                    G_TYPE_POINTER);   /* struct tr_log_message */\n\n  addMessages (data->store, myHead);\n  onRefresh (data); /* much faster to populate *before* it has listeners */\n\n  data->filter = gtk_tree_model_filter_new (GTK_TREE_MODEL (data->store), NULL);\n  data->sort = gtk_tree_model_sort_new_with_model (data->filter);\n  g_object_unref (data->filter);\n  gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (data->sort),\n                                        COL_SEQUENCE,\n                                        GTK_SORT_ASCENDING);\n  data->maxLevel = gtr_pref_int_get (TR_KEY_message_level);\n  gtk_tree_model_filter_set_visible_func (GTK_TREE_MODEL_FILTER (data->filter),\n                                          isRowVisible, data, NULL);\n\n\n  view = gtk_tree_view_new_with_model (data->sort);\n  g_object_unref (data->sort);\n  g_signal_connect (view, \"button-release-event\",\n                    G_CALLBACK (on_tree_view_button_released), NULL);\n  data->view = GTK_TREE_VIEW (view);\n  gtk_tree_view_set_rules_hint (data->view, TRUE);\n  appendColumn (data->view, COL_SEQUENCE);\n  appendColumn (data->view, COL_NAME);\n  appendColumn (data->view, COL_MESSAGE);\n  w = gtk_scrolled_window_new (NULL, NULL);\n  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (w),\n                                  GTK_POLICY_AUTOMATIC,\n                                  GTK_POLICY_AUTOMATIC);\n  gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (w),\n                                       GTK_SHADOW_IN);\n  gtk_container_add (GTK_CONTAINER (w), view);\n  gtk_box_pack_start (GTK_BOX (vbox), w, TRUE, TRUE, 0);\n  gtk_container_add (GTK_CONTAINER (win), vbox);\n\n  data->refresh_tag = gdk_threads_add_timeout_seconds (SECONDARY_WINDOW_REFRESH_INTERVAL_SECONDS, onRefresh, data);\n  g_object_weak_ref (G_OBJECT (win), onWindowDestroyed, data);\n\n  scroll_to_bottom (data);\n  gtk_widget_show_all (win);\n  return win;\n}", "item_id": 13, "repo": "afeng11/tomato-arm", "file": "release/src-rt-6.x.4708/router/transmission/gtk/msgwin.c", "last_update_at": "2022-01-20T18:21:05+00:00", "question_id": "801daf4ab44dd9aaff62906624d0182e120a9444_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["GtkWidget *\ngtr_message_log_window_new (GtkWindow * parent, TrCore * core)\n{\n  GtkWidget * win;\n  GtkWidget * vbox;\n  GtkWidget * toolbar;\n  GtkWidget * w;\n  GtkWidget * view;\n  GtkToolItem * item;\n  struct MsgData * data;\n  data = g_new0 (struct MsgData, 1);\n  data->core = core;\n  win = gtk_window_new (GTK_WINDOW_TOPLEVEL);\n  gtk_window_set_transient_for (GTK_WINDOW (win), parent);\n  gtk_window_set_title (GTK_WINDOW (win), _(\"Message Log\"));\n  gtk_window_set_default_size (GTK_WINDOW (win), 560, 350);\n  gtk_window_set_role (GTK_WINDOW (win), \"message-log\");\n  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);\n  /**\n  ***  toolbar\n  **/\n  toolbar = gtk_toolbar_new ();\n  gtk_toolbar_set_style (GTK_TOOLBAR (toolbar), GTK_TOOLBAR_BOTH_HORIZ);\n  gtk_style_context_add_class (gtk_widget_get_style_context (toolbar),\n                               GTK_STYLE_CLASS_PRIMARY_TOOLBAR);\n  item = gtk_tool_button_new_from_stock (GTK_STOCK_SAVE_AS);\n  g_object_set (G_OBJECT (item), \"is-important\", TRUE, NULL);\n  g_signal_connect (item, \"clicked\", G_CALLBACK (onSaveRequest), data);\n  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);\n  item = gtk_tool_button_new_from_stock (GTK_STOCK_CLEAR);\n  g_object_set (G_OBJECT (item), \"is-important\", TRUE, NULL);\n  g_signal_connect (item, \"clicked\", G_CALLBACK (onClearRequest), data);\n  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);\n  item = gtk_separator_tool_item_new ();\n  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);\n  item = gtk_toggle_tool_button_new_from_stock (GTK_STOCK_MEDIA_PAUSE);\n  g_object_set (G_OBJECT (item), \"is-important\", TRUE, NULL);\n  g_signal_connect (item, \"toggled\", G_CALLBACK (onPauseToggled), data);\n  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);\n  item = gtk_separator_tool_item_new ();\n  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);\n  w = gtk_label_new (_(\"Level\"));\n  gtk_misc_set_padding (GTK_MISC (w), GUI_PAD, 0);\n  item = gtk_tool_item_new ();\n  gtk_container_add (GTK_CONTAINER (item), w);\n  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);\n  w = debug_level_combo_new ();\n  g_signal_connect (w, \"changed\", G_CALLBACK (level_combo_changed_cb), data);\n  item = gtk_tool_item_new ();\n  gtk_container_add (GTK_CONTAINER (item), w);\n  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);\n  gtk_box_pack_start (GTK_BOX (vbox), toolbar, FALSE, FALSE, 0);\n  /**\n  ***  messages\n  **/\n  data->store = gtk_list_store_new (N_COLUMNS,\n                                    G_TYPE_UINT,       /* sequence */\n                                    G_TYPE_POINTER,    /* category */\n                                    G_TYPE_POINTER,    /* message */\n                                    G_TYPE_POINTER);   /* struct tr_log_message */\n  addMessages (data->store, myHead);\n  onRefresh (data); /* much faster to populate *before* it has listeners */\n  data->filter = gtk_tree_model_filter_new (GTK_TREE_MODEL (data->store), NULL);\n  data->sort = gtk_tree_model_sort_new_with_model (data->filter);\n  g_object_unref (data->filter);\n  gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (data->sort),\n                                        COL_SEQUENCE,\n                                        GTK_SORT_ASCENDING);\n  data->maxLevel = gtr_pref_int_get (TR_KEY_message_level);\n  gtk_tree_model_filter_set_visible_func (GTK_TREE_MODEL_FILTER (data->filter),\n                                          isRowVisible, data, NULL);\n  view = gtk_tree_view_new_with_model (data->sort);\n  g_object_unref (data->sort);\n  g_signal_connect (view, \"button-release-event\",\n                    G_CALLBACK (on_tree_view_button_released), NULL);\n  data->view = GTK_TREE_VIEW (view);\n  gtk_tree_view_set_rules_hint (data->view, TRUE);\n  appendColumn (data->view, COL_SEQUENCE);\n  appendColumn (data->view, COL_NAME);\n  appendColumn (data->view, COL_MESSAGE);\n  w = gtk_scrolled_window_new (NULL, NULL);\n  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (w),\n                                  GTK_POLICY_AUTOMATIC,\n                                  GTK_POLICY_AUTOMATIC);\n  gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (w),\n                                       GTK_SHADOW_IN);\n  gtk_container_add (GTK_CONTAINER (w), view);\n  gtk_box_pack_start (GTK_BOX (vbox), w, TRUE, TRUE, 0);\n  gtk_container_add (GTK_CONTAINER (win), vbox);\n  data->refresh_tag = gdk_threads_add_timeout_seconds (SECONDARY_WINDOW_REFRESH_INTERVAL_SECONDS, onRefresh, data);\n  g_object_weak_ref (G_OBJECT (win), onWindowDestroyed, data);\n  scroll_to_bottom (data);\n  gtk_widget_show_all (win);\n  return win;\n"]]}
{"hexsha": "8617da86f17de245981526b84aaefc4718fc2c3a", "ext": "c", "lang": "C", "content": "void DaoException_Init( DaoException *self, DaoProcess *proc, const char *summary, DaoValue *dat )\n{\n\tDaoVmCode *vmc = proc->activeCode;\n\tDaoRoutine *rout = proc->activeRoutine;\n\tDaoStackFrame *frame = proc->topFrame->prev;\n\tint line, id = (int) (vmc - proc->topFrame->active->codes);\n\n\tif( rout == NULL ) return;\n\n\tline = rout->defLine;\n\tif( proc->topFrame->active == proc->topFrame->prev ){\n\t\tDaoRoutine *rout2 = proc->topFrame->prev->routine;\n\t\t/*\n\t\t// proc->activeCode could be a dummy code set by:\n\t\t//   DaoProcess_InterceptReturnValue();\n\t\t// So always use the entry index whenever possible.\n\t\t*/\n\t\tid = proc->topFrame->prev->entry;\n\t\tif( rout2->body && id && id <= rout2->body->vmCodes->size ){\n\t\t\tline = rout2->body->annotCodes->items.pVmc[id-1]->line;\n\t\t}\n\t}else{\n\t\tid = (int) (vmc - proc->topFrame->active->codes);\n\t\tif( id < 0 || id > 0xffff ) id = 0; /* Not the precise location, but a safe one; */\n\t\tif( vmc && id < rout->body->vmCodes->size ){\n\t\t\tline = rout->body->annotCodes->items.pVmc[id]->line;\n\t\t}\n\t}\n\n\tif( summary && summary[0] != 0 ) DString_SetChars( self->info, summary );\n\tGC_Assign( & self->data, dat );\n\n\tDList_Clear( self->callers );\n\tDList_Clear( self->lines );\n\tDList_Append( self->callers, proc->topFrame->routine );\n\tDList_Append( self->lines, (daoint) (line<<16)|id );\n\twhile( frame && frame != proc->startFrame->prev  && frame->routine ){\n\t\tDaoRoutineBody *body = frame->routine->body;\n\t\tif( self->callers->size >= 5 ) break;\n\t\tif( frame->entry ){\n\t\t\t/* deferred anonymous function may have been pushed but not executed: */\n\t\t\tline = body ? body->annotCodes->items.pVmc[ frame->entry - 1 ]->line : 0;\n\t\t\tDList_Append( self->callers, frame->routine );\n\t\t\tDList_Append( self->lines, (daoint) (line<<16)|(frame->entry - 1) );\n\t\t}\n\t\tframe = frame->prev;\n\t}\n}", "item_id": 240, "repo": "kunal/dao", "file": "kernel/daoStdtype.c", "last_update_at": "2022-02-05T06:20:45+00:00", "question_id": "8617da86f17de245981526b84aaefc4718fc2c3a_240", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void DaoException_Init( DaoException *self, DaoProcess *proc, const char *summary, DaoValue *dat )\n{\n\tDaoVmCode *vmc = proc->activeCode;\n\tDaoRoutine *rout = proc->activeRoutine;\n\tDaoStackFrame *frame = proc->topFrame->prev;\n\tint line, id = (int) (vmc - proc->topFrame->active->codes);\n\tif( rout == NULL ) return;\n\tline = rout->defLine;\n\tif( proc->topFrame->active == proc->topFrame->prev ){\n\t\tDaoRoutine *rout2 = proc->topFrame->prev->routine;\n\t\t/*\n\t\t// proc->activeCode could be a dummy code set by:\n\t\t//   DaoProcess_InterceptReturnValue();\n\t\t// So always use the entry index whenever possible.\n\t\t*/\n\t\tid = proc->topFrame->prev->entry;\n\t\tif( rout2->body && id && id <= rout2->body->vmCodes->size ){\n\t\t\tline = rout2->body->annotCodes->items.pVmc[id-1]->line;\n\t\t}\n\t}else{\n\t\tid = (int) (vmc - proc->topFrame->active->codes);\n\t\tif( id < 0 || id > 0xffff ) id = 0; /* Not the precise location, but a safe one; */\n\t\tif( vmc && id < rout->body->vmCodes->size ){\n\t\t\tline = rout->body->annotCodes->items.pVmc[id]->line;\n\t\t}\n\t}\n\tif( summary && summary[0] != 0 ) DString_SetChars( self->info, summary );\n\tGC_Assign( & self->data, dat );\n\tDList_Clear( self->callers );\n\tDList_Clear( self->lines );\n\tDList_Append( self->callers, proc->topFrame->routine );\n\tDList_Append( self->lines, (daoint) (line<<16)|id );\n\twhile( frame && frame != proc->startFrame->prev  && frame->routine ){\n\t\tDaoRoutineBody *body = frame->routine->body;\n\t\tif( self->callers->size >= 5 ) break;\n\t\tif( frame->entry ){\n\t\t\t/* deferred anonymous function may have been pushed but not executed: */\n\t\t\tline = body ? body->annotCodes->items.pVmc[ frame->entry - 1 ]->line : 0;\n\t\t\tDList_Append( self->callers, frame->routine );\n\t\t\tDList_Append( self->lines, (daoint) (line<<16)|(frame->entry - 1) );\n\t\t}\n\t\tframe = frame->prev;\n\t}\n"]]}
{"hexsha": "f68f4647184c5005f132d0d82734ee360dd78f17", "ext": "c", "lang": "C", "content": "static void\nnk_eve_scissor(EVE_HalContext *phost, float x, float y, float w, float h)\n{\n    Ft_Esd_Rect16 rect;\n    rect.X = (int)x;\n    rect.Y = (int)y;\n    rect.Width = (int)(w + 1);\n    rect.Height = (int)(h + 1);\n    Esd_Dl_Scissor_Adjust(rect, eve.scissor);\n}", "item_id": 5, "repo": "kaetemi/nuklear_eve", "file": "src/nuklear_eve.c", "last_update_at": "2022-02-11T12:59:43+00:00", "question_id": "f68f4647184c5005f132d0d82734ee360dd78f17_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nnk_eve_scissor(EVE_HalContext *phost, float x, float y, float w, float h)\n{\n    Ft_Esd_Rect16 rect;\n    rect.X = (int)x;\n    rect.Y = (int)y;\n    rect.Width = (int)(w + 1);\n    rect.Height = (int)(h + 1);\n    Esd_Dl_Scissor_Adjust(rect, eve.scissor);\n"]]}
{"hexsha": "4215725b243072b5b6b93b519abaab307629e7dd", "ext": "c", "lang": "C", "content": "static mRosSizeType get_arglen(mRosEncodeArgType *arg)\n{\n\tmRosSizeType len = 0;\n\tmRosSizeType i;\n\tfor (i = 0; i < arg->args_char; i++) {\n\t\tlen += strlen(arg->argv[i]) + 1;\n\t}\n\tfor (i = 0; i < arg->args_int; i++) {\n\t\tlen += get_digit(arg->argi[i]) + 1;\n\t}\n\treturn len;\n}", "item_id": 3, "repo": "mikoto2000/athrill-1", "file": "src/device/peripheral/mros-dev/mros-src/packet/cimpl/version/kinetic/mros_packet_encoder_cimpl.c", "last_update_at": "2022-01-23T20:14:48+00:00", "question_id": "4215725b243072b5b6b93b519abaab307629e7dd_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static mRosSizeType get_arglen(mRosEncodeArgType *arg)\n{\n\tmRosSizeType len = 0;\n\tmRosSizeType i;\n\tfor (i = 0; i < arg->args_char; i++) {\n\t\tlen += strlen(arg->argv[i]) + 1;\n\t}\n\tfor (i = 0; i < arg->args_int; i++) {\n\t\tlen += get_digit(arg->argi[i]) + 1;\n\t}\n\treturn len;\n"]]}
{"hexsha": "2472b3a28a4d65f1aec7de94421a072dba2c9025", "ext": "c", "lang": "C", "content": "sljit_jump* sljit_emit_call(struct sljit_compiler *compiler, sljit_s32 type,\n\tsljit_s32 arg_types)\n{\n\tstruct sljit_jump *jump;\n\tsljit_ins ins = NOP;\n\n\tCHECK_ERROR_PTR();\n\tCHECK_PTR(check_sljit_emit_call(compiler, type, arg_types));\n\n\tjump = (struct sljit_jump*)ensure_abuf(compiler, sizeof(struct sljit_jump));\n\tPTR_FAIL_IF(!jump);\n\tset_jump(jump, compiler, type & SLJIT_REWRITABLE_JUMP);\n\n\tif (type & SLJIT_CALL_RETURN)\n\t\tPTR_FAIL_IF(emit_stack_frame_release(compiler, 0, &ins));\n\n\tPTR_FAIL_IF(call_with_args(compiler, arg_types, &ins));\n\n\tSLJIT_ASSERT(DR(PIC_ADDR_REG) == 25 && PIC_ADDR_REG == TMP_REG2);\n\n\tif (!(type & SLJIT_CALL_RETURN)) {\n\t\tjump->flags |= IS_JAL | IS_CALL;\n\t\tPTR_FAIL_IF(push_inst(compiler, JALR | S(PIC_ADDR_REG) | DA(RETURN_ADDR_REG), UNMOVABLE_INS));\n\t} else\n\t\tPTR_FAIL_IF(push_inst(compiler, JR | S(PIC_ADDR_REG), UNMOVABLE_INS));\n\n\tjump->addr = compiler->size;\n\tPTR_FAIL_IF(push_inst(compiler, ins, UNMOVABLE_INS));\n\n\t/* Maximum number of instructions required for generating a constant. */\n\tcompiler->size += 6;\n\treturn jump;\n}", "item_id": 4, "repo": "Ortheore/BizHawk", "file": "waterbox/ares64/ares/thirdparty/sljit/sljit_src/sljitNativeMIPS_64.c", "last_update_at": "2022-03-31T01:21:39+00:00", "question_id": "2472b3a28a4d65f1aec7de94421a072dba2c9025_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["sljit_jump* sljit_emit_call(struct sljit_compiler *compiler, sljit_s32 type,\n\tsljit_s32 arg_types)\n{\n\tstruct sljit_jump *jump;\n\tsljit_ins ins = NOP;\n\tCHECK_ERROR_PTR();\n\tCHECK_PTR(check_sljit_emit_call(compiler, type, arg_types));\n\tjump = (struct sljit_jump*)ensure_abuf(compiler, sizeof(struct sljit_jump));\n\tPTR_FAIL_IF(!jump);\n\tset_jump(jump, compiler, type & SLJIT_REWRITABLE_JUMP);\n\tif (type & SLJIT_CALL_RETURN)\n\t\tPTR_FAIL_IF(emit_stack_frame_release(compiler, 0, &ins));\n\tPTR_FAIL_IF(call_with_args(compiler, arg_types, &ins));\n\tSLJIT_ASSERT(DR(PIC_ADDR_REG) == 25 && PIC_ADDR_REG == TMP_REG2);\n\tif (!(type & SLJIT_CALL_RETURN)) {\n\t\tjump->flags |= IS_JAL | IS_CALL;\n\t\tPTR_FAIL_IF(push_inst(compiler, JALR | S(PIC_ADDR_REG) | DA(RETURN_ADDR_REG), UNMOVABLE_INS));\n\t} else\n\t\tPTR_FAIL_IF(push_inst(compiler, JR | S(PIC_ADDR_REG), UNMOVABLE_INS));\n\tjump->addr = compiler->size;\n\tPTR_FAIL_IF(push_inst(compiler, ins, UNMOVABLE_INS));\n\t/* Maximum number of instructions required for generating a constant. */\n\tcompiler->size += 6;\n\treturn jump;\n"]]}
{"hexsha": "9e4d7e66baf3f2d4273e3e42b2fb1efc884d202e", "ext": "c", "lang": "C", "content": "void next_change() {\n    int now, next, tot;\n    string str;\n\n    now = query_hour(time())*60 + query_minutes(time());\n    switch(__TimeOfDay) {\n        case \"night\":\n            str = \"sunrise\";\n            break;\n        case \"dawn\":\n            str = \"morning\";\n            break;\n        case \"day\":\n            str = \"twilight\";\n            break;\n        case \"twilight\":\n            str = \"sunset\";\n            break;\n    }\n    next = (60*__Almanac[str][0]) + __Almanac[str][1];\n    if(next > now) tot = next-now;\n    else {\n        now = (1200)-now;\n        tot = next + now;\n    }\n    __Events[file_name(this_object())] =\n      ([\"time\":time()+(20*tot),\"function\":\"change_sky\",\"args\":({}),\"regular\":0]);\n}", "item_id": 7, "repo": "Dbevan/SunderingShadows", "file": "daemon/events_d.c", "last_update_at": "2022-02-25T19:44:15+00:00", "question_id": "9e4d7e66baf3f2d4273e3e42b2fb1efc884d202e_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void next_change() {\n    int now, next, tot;\n    string str;\n    now = query_hour(time())*60 + query_minutes(time());\n    switch(__TimeOfDay) {\n        case \"night\":\n            str = \"sunrise\";\n            break;\n        case \"dawn\":\n            str = \"morning\";\n            break;\n        case \"day\":\n            str = \"twilight\";\n            break;\n        case \"twilight\":\n            str = \"sunset\";\n            break;\n    }\n    next = (60*__Almanac[str][0]) + __Almanac[str][1];\n    if(next > now) tot = next-now;\n    else {\n        now = (1200)-now;\n        tot = next + now;\n    }\n    __Events[file_name(this_object())] =\n      ([\"time\":time()+(20*tot),\"function\":\"change_sky\",\"args\":({}),\"regular\":0]);\n"]]}
{"hexsha": "3439e09eb7817d28463b3e602b8e92569340c98a", "ext": "c", "lang": "C", "content": "int\ntcpprep_set_min_mask(tcpprep_t *ctx, int value)\n{\n    assert(ctx);\n    ctx->options->min_mask = value;\n    return 0;\n}", "item_id": 8, "repo": "ppietikainen/tcpreplay", "file": "src/tcpprep_api.c", "last_update_at": "2022-03-23T07:00:34+00:00", "question_id": "3439e09eb7817d28463b3e602b8e92569340c98a_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\ntcpprep_set_min_mask(tcpprep_t *ctx, int value)\n{\n    assert(ctx);\n    ctx->options->min_mask = value;\n    return 0;\n"]]}
{"hexsha": "6f5eb3f69598643f7c3f92d3ab4ebf0efe9a57bd", "ext": "c", "lang": "C", "content": "BOOTLOADER_SECTION void\nsubmit_request_new() {\n\n  uint8_t sreg;\n  sreg = SREG;\n  cli();\n  uint8_t key[32];\n  load_key(key);\n  char *DEFAULT_URL = \"http://localhost:8008\";\n  submit_checkRequest(\"testID\", key, DEFAULT_URL);\n  SREG = sreg;\n}", "item_id": 8, "repo": "sss-wue/scraps", "file": "IoT-Clients/SCRAPS_ATMEGA/core/microvisor.c", "last_update_at": "2022-03-23T17:25:28+00:00", "question_id": "6f5eb3f69598643f7c3f92d3ab4ebf0efe9a57bd_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["BOOTLOADER_SECTION void\nsubmit_request_new() {\n  uint8_t sreg;\n  sreg = SREG;\n  cli();\n  uint8_t key[32];\n  load_key(key);\n  char *DEFAULT_URL = \"http://localhost:8008\";\n  submit_checkRequest(\"testID\", key, DEFAULT_URL);\n  SREG = sreg;\n"]]}
{"hexsha": "3e8e03e4caee9bf8e065c966a1fd63b3a9583bde", "ext": "h", "lang": "C", "content": "const T item{static_cast<T>(value)};\n    /** In case of vec<> the static_cast calls an appropriate constructor, so\n     *  all elements of the vector are initialized to the value given\n     */\n    result[i] = item;\n    *iteratorPtr = item;\n  }", "item_id": 0, "repo": "hvdijk/SYCL-CTS", "file": "tests/common/async_work_group_copy.h", "last_update_at": "2022-02-18T08:40:19+00:00", "question_id": "3e8e03e4caee9bf8e065c966a1fd63b3a9583bde_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const T item{static_cast<T>(value)};\n    /** In case of vec<> the static_cast calls an appropriate constructor, so\n     *  all elements of the vector are initialized to the value given\n     */\n    result[i] = item;\n    *iteratorPtr = item;\n"]]}
{"hexsha": "c6b68d3a26216b4d8a980d7c9607ae02b23e637e", "ext": "c", "lang": "C", "content": "void CurveInterpolation4(MImagePoint *pt1,MImagePoint *pt2,int type,float d11,float d12,MMatrix *mat,MImageCurve *curve)\n{\n    float x1,y1,x2,y2;\n    curve->type=type;\n    if(type==MORN_CURVE_X) {x1=pt1->x;y1=pt1->y;x2=pt2->x;y2=pt2->y;}\n    else                   {x1=pt1->y;y1=pt1->x;x2=pt2->y;y2=pt2->x;}\n    curve->v1=*pt1;curve->v2=*pt2;\n    curve->curve = curve_interpolation;\n    \n    mMatrixRedefine(mat,4,5);float **data=mat->data;\n    data[0][0]=1;data[0][1]=x1;data[0][2]=x1*x1;data[0][3]=x1*x1*x1;data[0][4]=0-y1;\n    data[1][0]=1;data[1][1]=x2;data[1][2]=x2*x2;data[1][3]=x2*x2*x2;data[1][4]=0-y2;\n    data[2][0]=0;data[2][1]= 1;data[2][2]= 2*x1;data[2][3]= 3*x1*x1;data[2][4]=0-d11;\n    data[3][0]=0;data[3][1]= 0;data[3][2]= 2   ;data[3][3]= 6*x1   ;data[3][4]=0-d12;\n    mLinearEquation(mat,curve->para);\n}", "item_id": 2, "repo": "ishine/Morn", "file": "src/math/morn_interpolation.c", "last_update_at": "2022-03-30T03:23:49+00:00", "question_id": "c6b68d3a26216b4d8a980d7c9607ae02b23e637e_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void CurveInterpolation4(MImagePoint *pt1,MImagePoint *pt2,int type,float d11,float d12,MMatrix *mat,MImageCurve *curve)\n{\n    float x1,y1,x2,y2;\n    curve->type=type;\n    if(type==MORN_CURVE_X) {x1=pt1->x;y1=pt1->y;x2=pt2->x;y2=pt2->y;}\n    else                   {x1=pt1->y;y1=pt1->x;x2=pt2->y;y2=pt2->x;}\n    curve->v1=*pt1;curve->v2=*pt2;\n    curve->curve = curve_interpolation;\n    mMatrixRedefine(mat,4,5);float **data=mat->data;\n    data[0][0]=1;data[0][1]=x1;data[0][2]=x1*x1;data[0][3]=x1*x1*x1;data[0][4]=0-y1;\n    data[1][0]=1;data[1][1]=x2;data[1][2]=x2*x2;data[1][3]=x2*x2*x2;data[1][4]=0-y2;\n    data[2][0]=0;data[2][1]= 1;data[2][2]= 2*x1;data[2][3]= 3*x1*x1;data[2][4]=0-d11;\n    data[3][0]=0;data[3][1]= 0;data[3][2]= 2   ;data[3][3]= 6*x1   ;data[3][4]=0-d12;\n    mLinearEquation(mat,curve->para);\n"]]}
{"hexsha": "4dd34f7d87912abc165633f8bfc09a0b99e3162b", "ext": "c", "lang": "C", "content": "ssize_t pka_queue_get_memsize(uint32_t size)\r\n{\r\n    ssize_t q_size;\r\n\r\n    // size must be a power of 2\r\n    if ((!POWEROF2(size)) || (size > PKA_QUEUE_MASK_SIZE ))\r\n    {\r\n        PKA_DEBUG(PKA_QUEUE, \"Requested size %u is invalid, must be \"\r\n                       \"power of 2, and do not exceed the size limit %u\\n\",\r\n                        size, PKA_QUEUE_MASK_SIZE);\r\n        return -EINVAL;\r\n    }\r\n\r\n    q_size = sizeof(pka_queue_t) + size;\r\n    q_size = PKA_ALIGN(q_size, PKA_CACHE_LINE_SIZE);\r\n\r\n    return q_size;\r\n}", "item_id": 0, "repo": "kblaiech/pka", "file": "lib/pka_queue.c", "last_update_at": "2022-01-05T08:02:53+00:00", "question_id": "4dd34f7d87912abc165633f8bfc09a0b99e3162b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ssize_t pka_queue_get_memsize(uint32_t size)\r\n{\r\n    ssize_t q_size;\r\n\r\n    // size must be a power of 2\r\n    if ((!POWEROF2(size)) || (size > PKA_QUEUE_MASK_SIZE ))\r\n    {\r\n        PKA_DEBUG(PKA_QUEUE, \"Requested size %u is invalid, must be \"\r\n                       \"power of 2, and do not exceed the size limit %u\\n\",\r\n                        size, PKA_QUEUE_MASK_SIZE);\r\n        return -EINVAL;\r\n    }\r\n\r\n    q_size = sizeof(pka_queue_t) + size;\r\n    q_size = PKA_ALIGN(q_size, PKA_CACHE_LINE_SIZE);\r\n\r\n    return q_size;\r\n"]]}
{"hexsha": "383e283121a0a4d5bbe7628a169f96677366e245", "ext": "c", "lang": "C", "content": "int\ntr_dhtInit (tr_session *ss)\n{\n    tr_variant benc;\n    int rc;\n    bool have_id = false;\n    char * dat_file;\n    uint8_t * nodes = NULL, * nodes6 = NULL;\n    const uint8_t * raw;\n    size_t len, len6;\n    struct bootstrap_closure * cl;\n\n    if (session) /* already initialized */\n        return -1;\n\n    tr_logAddNamedDbg (\"DHT\", \"Initializing DHT\");\n\n    if (tr_env_key_exists (\"TR_DHT_VERBOSE\"))\n        dht_debug = stderr;\n\n    dat_file = tr_buildPath (ss->configDir, \"dht.dat\", NULL);\n    rc = tr_variantFromFile (&benc, TR_VARIANT_FMT_BENC, dat_file, NULL) ? 0 : -1;\n    tr_free (dat_file);\n    if (rc == 0) {\n        have_id = tr_variantDictFindRaw (&benc, TR_KEY_id, &raw, &len);\n        if (have_id && len==20)\n            memcpy (myid, raw, len);\n        if (ss->udp_socket != TR_BAD_SOCKET &&\n            tr_variantDictFindRaw (&benc, TR_KEY_nodes, &raw, &len) && ! (len%6)) {\n                nodes = tr_memdup (raw, len);\n        }\n        if (ss->udp6_socket != TR_BAD_SOCKET &&\n            tr_variantDictFindRaw (&benc, TR_KEY_nodes6, &raw, &len6) && ! (len6%18)) {\n            nodes6 = tr_memdup (raw, len6);\n        }\n        tr_variantFree (&benc);\n    }\n\n    if (nodes == NULL)\n        len = 0;\n    if (nodes6 == NULL)\n        len6 = 0;\n\n    if (have_id)\n        tr_logAddNamedInfo (\"DHT\", \"Reusing old id\");\n    else {\n        /* Note that DHT ids need to be distributed uniformly,\n         * so it should be something truly random. */\n        tr_logAddNamedInfo (\"DHT\", \"Generating new id\");\n        tr_rand_buffer (myid, 20);\n    }\n\n    rc = dht_init (ss->udp_socket, ss->udp6_socket, myid, NULL);\n    if (rc < 0)\n        goto fail;\n\n    session = ss;\n\n    cl = tr_new (struct bootstrap_closure, 1);\n    cl->session = session;\n    cl->nodes = nodes;\n    cl->nodes6 = nodes6;\n    cl->len = len;\n    cl->len6 = len6;\n    tr_threadNew (dht_bootstrap, cl);\n\n    dht_timer = evtimer_new (session->event_base, timer_callback, session);\n    tr_timerAdd (dht_timer, 0, tr_rand_int_weak (1000000));\n\n    tr_logAddNamedDbg (\"DHT\", \"DHT initialized\");\n\n    return 1;\n\n fail:\n    tr_logAddNamedDbg (\"DHT\", \"DHT initialization failed (errno = %d)\", errno);\n    session = NULL;\n    return -1;\n}", "item_id": 4, "repo": "afeng11/tomato-arm", "file": "release/src-rt-6.x.4708/router/transmission/libtransmission/tr-dht.c", "last_update_at": "2022-01-20T18:21:05+00:00", "question_id": "383e283121a0a4d5bbe7628a169f96677366e245_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\ntr_dhtInit (tr_session *ss)\n{\n    tr_variant benc;\n    int rc;\n    bool have_id = false;\n    char * dat_file;\n    uint8_t * nodes = NULL, * nodes6 = NULL;\n    const uint8_t * raw;\n    size_t len, len6;\n    struct bootstrap_closure * cl;\n    if (session) /* already initialized */\n        return -1;\n    tr_logAddNamedDbg (\"DHT\", \"Initializing DHT\");\n    if (tr_env_key_exists (\"TR_DHT_VERBOSE\"))\n        dht_debug = stderr;\n    dat_file = tr_buildPath (ss->configDir, \"dht.dat\", NULL);\n    rc = tr_variantFromFile (&benc, TR_VARIANT_FMT_BENC, dat_file, NULL) ? 0 : -1;\n    tr_free (dat_file);\n    if (rc == 0) {\n        have_id = tr_variantDictFindRaw (&benc, TR_KEY_id, &raw, &len);\n        if (have_id && len==20)\n            memcpy (myid, raw, len);\n        if (ss->udp_socket != TR_BAD_SOCKET &&\n            tr_variantDictFindRaw (&benc, TR_KEY_nodes, &raw, &len) && ! (len%6)) {\n                nodes = tr_memdup (raw, len);\n        }\n        if (ss->udp6_socket != TR_BAD_SOCKET &&\n            tr_variantDictFindRaw (&benc, TR_KEY_nodes6, &raw, &len6) && ! (len6%18)) {\n            nodes6 = tr_memdup (raw, len6);\n        }\n        tr_variantFree (&benc);\n    }\n    if (nodes == NULL)\n        len = 0;\n    if (nodes6 == NULL)\n        len6 = 0;\n    if (have_id)\n        tr_logAddNamedInfo (\"DHT\", \"Reusing old id\");\n    else {\n        /* Note that DHT ids need to be distributed uniformly,\n         * so it should be something truly random. */\n        tr_logAddNamedInfo (\"DHT\", \"Generating new id\");\n        tr_rand_buffer (myid, 20);\n    }\n    rc = dht_init (ss->udp_socket, ss->udp6_socket, myid, NULL);\n    if (rc < 0)\n        goto fail;\n    session = ss;\n    cl = tr_new (struct bootstrap_closure, 1);\n    cl->session = session;\n    cl->nodes = nodes;\n    cl->nodes6 = nodes6;\n    cl->len = len;\n    cl->len6 = len6;\n    tr_threadNew (dht_bootstrap, cl);\n    dht_timer = evtimer_new (session->event_base, timer_callback, session);\n    tr_timerAdd (dht_timer, 0, tr_rand_int_weak (1000000));\n    tr_logAddNamedDbg (\"DHT\", \"DHT initialized\");\n    return 1;\n fail:\n    tr_logAddNamedDbg (\"DHT\", \"DHT initialization failed (errno = %d)\", errno);\n    session = NULL;\n    return -1;\n"]]}
{"hexsha": "977c8f9a07a2194322deada32da2afd0481d50ad", "ext": "c", "lang": "C", "content": "static int nmk_gpio_init_irq(struct nmk_gpio_chip *nmk_chip)\n{\n\tunsigned int first_irq;\n\tint i;\n\n\tfirst_irq = NOMADIK_GPIO_TO_IRQ(nmk_chip->chip.base);\n\tfor (i = first_irq; i < first_irq + NMK_GPIO_PER_CHIP; i++) {\n\t\tset_irq_chip(i, &nmk_gpio_irq_chip);\n\t\tset_irq_handler(i, handle_edge_irq);\n\t\tset_irq_flags(i, IRQF_VALID);\n\t\tset_irq_chip_data(i, nmk_chip);\n\t\tset_irq_type(i, IRQ_TYPE_EDGE_FALLING);\n\t}\n\tset_irq_chained_handler(nmk_chip->parent_irq, nmk_gpio_irq_handler);\n\tset_irq_data(nmk_chip->parent_irq, nmk_chip);\n\treturn 0;\n}", "item_id": 15, "repo": "zhoutao0712/rtn11pb1", "file": "release/src-ra-4300/linux/linux-2.6.36.x/arch/arm/plat-nomadik/gpio.c", "last_update_at": "2022-03-19T06:38:01+00:00", "question_id": "977c8f9a07a2194322deada32da2afd0481d50ad_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int nmk_gpio_init_irq(struct nmk_gpio_chip *nmk_chip)\n{\n\tunsigned int first_irq;\n\tint i;\n\tfirst_irq = NOMADIK_GPIO_TO_IRQ(nmk_chip->chip.base);\n\tfor (i = first_irq; i < first_irq + NMK_GPIO_PER_CHIP; i++) {\n\t\tset_irq_chip(i, &nmk_gpio_irq_chip);\n\t\tset_irq_handler(i, handle_edge_irq);\n\t\tset_irq_flags(i, IRQF_VALID);\n\t\tset_irq_chip_data(i, nmk_chip);\n\t\tset_irq_type(i, IRQ_TYPE_EDGE_FALLING);\n\t}\n\tset_irq_chained_handler(nmk_chip->parent_irq, nmk_gpio_irq_handler);\n\tset_irq_data(nmk_chip->parent_irq, nmk_chip);\n\treturn 0;\n"]]}
{"hexsha": "33b0c8d530440318e4514195f5db8ac277f21115", "ext": "c", "lang": "C", "content": "static\nsync_cell_t*\nsync_array_find_thread(\n/*===================*/\n\t\t\t\t/* out: pointer to cell or NULL\n\t\t\t\tif not found */\n\tsync_array_t*\tarr,\t/* in: wait array */\n\tos_thread_id_t\tthread)\t/* in: thread id */\n{\n\tulint\t\ti;\n\tsync_cell_t*\tcell;\n\n\tfor (i = 0; i < arr->n_cells; i++) {\n\n\t\tcell = sync_array_get_nth_cell(arr, i);\n\n\t\tif (cell->wait_object != NULL\n\t\t    && os_thread_eq(cell->thread, thread)) {\n\n\t\t\treturn(cell);\t/* Found */\n\t\t}\n\t}\n\n\treturn(NULL);\t/* Not found */\n}", "item_id": 9, "repo": "afeng11/tomato-arm", "file": "release/src-rt-6.x.4708/router/mysql/storage/innobase/sync/sync0arr.c", "last_update_at": "2022-01-20T18:21:05+00:00", "question_id": "33b0c8d530440318e4514195f5db8ac277f21115_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static\nsync_cell_t*\nsync_array_find_thread(\n/*===================*/\n\t\t\t\t/* out: pointer to cell or NULL\n\t\t\t\tif not found */\n\tsync_array_t*\tarr,\t/* in: wait array */\n\tos_thread_id_t\tthread)\t/* in: thread id */\n{\n\tulint\t\ti;\n\tsync_cell_t*\tcell;\n\tfor (i = 0; i < arr->n_cells; i++) {\n\t\tcell = sync_array_get_nth_cell(arr, i);\n\t\tif (cell->wait_object != NULL\n\t\t    && os_thread_eq(cell->thread, thread)) {\n\t\t\treturn(cell);\t/* Found */\n\t\t}\n\t}\n\treturn(NULL);\t/* Not found */\n"]]}
{"hexsha": "5cff95c5783657160ba1123b0e3d7ed72bb88dd2", "ext": "c", "lang": "C", "content": "int wps_send_eap_identity_rsp(u8 id)\n{\n    struct wps_sm *sm = gWpsSm;\n    struct wpabuf *eap_buf = NULL;\n    u8 bssid[6];\n    u8 *buf = NULL;\n    int len;\n    int ret = ESP_OK;\n\n    wpa_printf(MSG_DEBUG, \"wps send eapol id rsp\");\n    eap_buf = eap_msg_alloc(EAP_VENDOR_IETF, EAP_TYPE_IDENTITY, sm->identity_len,\n                            EAP_CODE_RESPONSE, id);\n    if (!eap_buf) {\n        ret = ESP_FAIL;\n        goto _err;\n    }\n\n    ret = esp_wifi_get_assoc_bssid_internal(bssid);\n    if (ret != 0) {\n        wpa_printf(MSG_ERROR, \"bssid is empty!\");\n        return ESP_FAIL;\n    }\n\n    wpabuf_put_data(eap_buf, sm->identity, sm->identity_len);\n\n    buf = wps_sm_alloc_eapol(sm, IEEE802_1X_TYPE_EAP_PACKET, wpabuf_head_u8(eap_buf), wpabuf_len(eap_buf), (size_t *)&len, NULL);\n    if (!buf) {\n        ret = ESP_ERR_NO_MEM;\n        goto _err;\n    }\n\n    ret = wps_sm_ether_send(sm, bssid, ETH_P_EAPOL, buf, len);\n    if (ret) {\n        ret = ESP_FAIL;\n        goto _err;\n    }\n\n_err:\n    wps_sm_free_eapol(buf);\n    wpabuf_free(eap_buf);\n    return ret;\n}", "item_id": 13, "repo": "hfudev/esp-idf", "file": "components/wpa_supplicant/esp_supplicant/src/esp_wps.c", "last_update_at": "2022-01-04T06:58:43+00:00", "question_id": "5cff95c5783657160ba1123b0e3d7ed72bb88dd2_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int wps_send_eap_identity_rsp(u8 id)\n{\n    struct wps_sm *sm = gWpsSm;\n    struct wpabuf *eap_buf = NULL;\n    u8 bssid[6];\n    u8 *buf = NULL;\n    int len;\n    int ret = ESP_OK;\n    wpa_printf(MSG_DEBUG, \"wps send eapol id rsp\");\n    eap_buf = eap_msg_alloc(EAP_VENDOR_IETF, EAP_TYPE_IDENTITY, sm->identity_len,\n                            EAP_CODE_RESPONSE, id);\n    if (!eap_buf) {\n        ret = ESP_FAIL;\n        goto _err;\n    }\n    ret = esp_wifi_get_assoc_bssid_internal(bssid);\n    if (ret != 0) {\n        wpa_printf(MSG_ERROR, \"bssid is empty!\");\n        return ESP_FAIL;\n    }\n    wpabuf_put_data(eap_buf, sm->identity, sm->identity_len);\n    buf = wps_sm_alloc_eapol(sm, IEEE802_1X_TYPE_EAP_PACKET, wpabuf_head_u8(eap_buf), wpabuf_len(eap_buf), (size_t *)&len, NULL);\n    if (!buf) {\n        ret = ESP_ERR_NO_MEM;\n        goto _err;\n    }\n    ret = wps_sm_ether_send(sm, bssid, ETH_P_EAPOL, buf, len);\n    if (ret) {\n        ret = ESP_FAIL;\n        goto _err;\n    }\n_err:\n    wps_sm_free_eapol(buf);\n    wpabuf_free(eap_buf);\n    return ret;\n"]]}
{"hexsha": "ac4e2de5d06f5e28cb45a554d9ad759392df799a", "ext": "c", "lang": "C", "content": "const char* GetModStringID(const int id)\n{\n\tint i = 0;\n\tfor(i = 0; i < (sizeof(g_IDs)/sizeof(g_IDs[0])); i++){\n\t\tif(g_IDs[i].number == id){\n\t\t\treturn g_IDs[i].string;\n\t\t}\n\t}\n\treturn NULL;\n}", "item_id": 1, "repo": "gkr09/Canon-CAPT", "file": "cndrvcups-capt-2.71/cngplp/cngplpmodIF.c", "last_update_at": "2022-01-20T19:37:49+00:00", "question_id": "ac4e2de5d06f5e28cb45a554d9ad759392df799a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const char* GetModStringID(const int id)\n{\n\tint i = 0;\n\tfor(i = 0; i < (sizeof(g_IDs)/sizeof(g_IDs[0])); i++){\n\t\tif(g_IDs[i].number == id){\n\t\t\treturn g_IDs[i].string;\n\t\t}\n\t}\n\treturn NULL;\n"]]}
{"hexsha": "1a624eec4bec18680a7870c1237ac4c5c0466dff", "ext": "c", "lang": "C", "content": "static int cmd_setup_device(int argc, char* argv[]) {\n  char * free_loop = loopdev_find_unused();\n\n  printf(\"Loop device: %s\\n\", free_loop);\n\n  if(loopdev_setup_device(argv[0], atoi(argv[1]), free_loop)) {\n    fprintf(stderr, \"Failed to associate loop device (%s) to file (%s).\\n\", free_loop, argv[0]);\n    goto error;\n  }\n\n  free(free_loop);\n\n  return 0;\n\n  error:\n    free(free_loop);\n    return 1;\n}", "item_id": 1, "repo": "XP1/piimg", "file": "src/piimg-loopdev.c", "last_update_at": "2022-02-20T11:17:42+00:00", "question_id": "1a624eec4bec18680a7870c1237ac4c5c0466dff_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int cmd_setup_device(int argc, char* argv[]) {\n  char * free_loop = loopdev_find_unused();\n  printf(\"Loop device: %s\\n\", free_loop);\n  if(loopdev_setup_device(argv[0], atoi(argv[1]), free_loop)) {\n    fprintf(stderr, \"Failed to associate loop device (%s) to file (%s).\\n\", free_loop, argv[0]);\n    goto error;\n  }\n  free(free_loop);\n  return 0;\n  error:\n    free(free_loop);\n    return 1;\n"]]}
{"hexsha": "96cc99fedcc35d4da86afc3b2c18ae40cba78a08", "ext": "h", "lang": "C", "content": "static inline const char *parse_hex_uint64(const char *buf, size_t len, uint64_t *value, int *status)\n{\n    buf = parse_hex_integer(buf, len, value, status);\n    if (*status == PARSE_INTEGER_SIGNED) {\n        *status = PARSE_INTEGER_UNDERFLOW;\n        return 0;\n    }\n    return buf;\n}", "item_id": 3, "repo": "timrulebosch/flatcc", "file": "include/flatcc/portable/pparseint.h", "last_update_at": "2022-03-20T08:54:42+00:00", "question_id": "96cc99fedcc35d4da86afc3b2c18ae40cba78a08_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline const char *parse_hex_uint64(const char *buf, size_t len, uint64_t *value, int *status)\n{\n    buf = parse_hex_integer(buf, len, value, status);\n    if (*status == PARSE_INTEGER_SIGNED) {\n        *status = PARSE_INTEGER_UNDERFLOW;\n        return 0;\n    }\n    return buf;\n"]]}
{"hexsha": "800b894733b1d4d38493918ac049f48c8973aa48", "ext": "c", "lang": "C", "content": "static config_item *game_configure(const game_params *params)\n{\n    config_item *ret;\n    char buf[80];\n    \n    ret = snewn(7, config_item);\n    \n    ret[0].name = \"Width\";\n    ret[0].type = C_STRING;\n    sprintf(buf, \"%d\", params->w);\n    ret[0].u.string.sval = dupstr(buf);\n    \n    ret[1].name = \"Height\";\n    ret[1].type = C_STRING;\n    sprintf(buf, \"%d\", params->h);\n    ret[1].u.string.sval = dupstr(buf);\n    \n    ret[2].name = \"Always show start and end points\";\n    ret[2].type = C_BOOLEAN;\n    ret[2].u.boolean.bval = !params->removeends;\n    \n    ret[3].name = \"Symmetrical clues\";\n    ret[3].type = C_BOOLEAN;\n    ret[3].u.boolean.bval = params->symmetrical;\n\n    ret[4].name = \"Grid type\";\n    ret[4].type = C_CHOICES;\n    ret[4].u.choices.choicenames = MODELIST(CONFIG);\n    ret[4].u.choices.selected = params->mode;\n\n    ret[5].name = \"Difficulty\";\n    ret[5].type = C_CHOICES;\n    ret[5].u.choices.choicenames = DIFFLIST(CONFIG);\n    ret[5].u.choices.selected = params->diff;\n    \n    ret[6].name = NULL;\n    ret[6].type = C_END;\n    \n    return ret;\n}", "item_id": 6, "repo": "Skeeve/PocketPuzzles", "file": "games/ascent.c", "last_update_at": "2022-02-26T23:25:15+00:00", "question_id": "800b894733b1d4d38493918ac049f48c8973aa48_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static config_item *game_configure(const game_params *params)\n{\n    config_item *ret;\n    char buf[80];\n    ret = snewn(7, config_item);\n    ret[0].name = \"Width\";\n    ret[0].type = C_STRING;\n    sprintf(buf, \"%d\", params->w);\n    ret[0].u.string.sval = dupstr(buf);\n    ret[1].name = \"Height\";\n    ret[1].type = C_STRING;\n    sprintf(buf, \"%d\", params->h);\n    ret[1].u.string.sval = dupstr(buf);\n    ret[2].name = \"Always show start and end points\";\n    ret[2].type = C_BOOLEAN;\n    ret[2].u.boolean.bval = !params->removeends;\n    ret[3].name = \"Symmetrical clues\";\n    ret[3].type = C_BOOLEAN;\n    ret[3].u.boolean.bval = params->symmetrical;\n    ret[4].name = \"Grid type\";\n    ret[4].type = C_CHOICES;\n    ret[4].u.choices.choicenames = MODELIST(CONFIG);\n    ret[4].u.choices.selected = params->mode;\n    ret[5].name = \"Difficulty\";\n    ret[5].type = C_CHOICES;\n    ret[5].u.choices.choicenames = DIFFLIST(CONFIG);\n    ret[5].u.choices.selected = params->diff;\n    ret[6].name = NULL;\n    ret[6].type = C_END;\n    return ret;\n"]]}
{"hexsha": "364ea6b22d9833381c621707e1c6392557ef36e8", "ext": "c", "lang": "C", "content": "int wdata_read_cycle(wdata_metadata *md, const char *varname, int cycle, void *data)\n{\n    int ierr;\n    wdata_variable var;\n    ierr = wdata_get_variable(md, varname, &var);\n    if (ierr > 0)\n        return 10 + ierr;\n\n    return wdata_load_datablock(md, &var, cycle, data);\n}", "item_id": 16, "repo": "visit-dav/vis", "file": "src/databases/WData/wdata.c", "last_update_at": "2022-03-30T19:16:31+00:00", "question_id": "364ea6b22d9833381c621707e1c6392557ef36e8_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int wdata_read_cycle(wdata_metadata *md, const char *varname, int cycle, void *data)\n{\n    int ierr;\n    wdata_variable var;\n    ierr = wdata_get_variable(md, varname, &var);\n    if (ierr > 0)\n        return 10 + ierr;\n    return wdata_load_datablock(md, &var, cycle, data);\n"]]}
{"hexsha": "03e4375e05566bd7136eaa437425d7c0dc31ad07", "ext": "c", "lang": "C", "content": "int PSMSettDHCPV4RecordValues(PCOSA_DML_LAN_MANAGEMENT pNewCfg,ULONG instancenum)//LNT_EMU\n{\n        int retPsmSet = CCSP_SUCCESS;\n        char param_name[256] = {0};\n        char param_value[256] = {0};\n        _ansc_sprintf(param_value, \"%d.%d.%d.%d\",\n            pNewCfg->LanIPAddress.Dot[0], pNewCfg->LanIPAddress.Dot[1], pNewCfg->LanIPAddress.Dot[2], pNewCfg->LanIPAddress.Dot[3]);\n         _PSM_WRITE_PARAM(PSM_DHCPV4_SERVER_POOL_IPROUTERS);\n        _ansc_sprintf(param_value, \"%d.%d.%d.%d\",\n            pNewCfg->LanSubnetMask.Dot[0], pNewCfg->LanSubnetMask.Dot[1],pNewCfg->LanSubnetMask.Dot[2],pNewCfg->LanSubnetMask.Dot[3]);\n        _PSM_WRITE_PARAM(PSM_DHCPV4_SERVER_POOL_SUBNETMASK);\n        return 0;\n}", "item_id": 18, "repo": "rdkcmf/rdkb-CcspPandM", "file": "source-pc/TR-181/board_sbapi/cosa_x_cisco_com_devicecontrol_apis.c", "last_update_at": "2022-02-16T23:14:26+00:00", "question_id": "03e4375e05566bd7136eaa437425d7c0dc31ad07_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int PSMSettDHCPV4RecordValues(PCOSA_DML_LAN_MANAGEMENT pNewCfg,ULONG instancenum)//LNT_EMU\n{\n        int retPsmSet = CCSP_SUCCESS;\n        char param_name[256] = {0};\n        char param_value[256] = {0};\n        _ansc_sprintf(param_value, \"%d.%d.%d.%d\",\n            pNewCfg->LanIPAddress.Dot[0], pNewCfg->LanIPAddress.Dot[1], pNewCfg->LanIPAddress.Dot[2], pNewCfg->LanIPAddress.Dot[3]);\n         _PSM_WRITE_PARAM(PSM_DHCPV4_SERVER_POOL_IPROUTERS);\n        _ansc_sprintf(param_value, \"%d.%d.%d.%d\",\n            pNewCfg->LanSubnetMask.Dot[0], pNewCfg->LanSubnetMask.Dot[1],pNewCfg->LanSubnetMask.Dot[2],pNewCfg->LanSubnetMask.Dot[3]);\n        _PSM_WRITE_PARAM(PSM_DHCPV4_SERVER_POOL_SUBNETMASK);\n        return 0;\n"]]}
{"hexsha": "a350872cd5cd50d2158bda2d1c9c723172b21e10", "ext": "c", "lang": "C", "content": "struct tm *localtime_r(const time_t *timep, struct tm *tm)\n{\n   struct tm *ltm;\n\n   static pthread_mutex_t mutex;\n   static int first = 1;\n\n   if (first) {\n      pthread_mutex_init(&mutex, NULL);\n      first = 0;\n   }\n\n   P(mutex);\n\n   ltm = localtime(timep);\n   if (ltm)\n      memcpy(tm, ltm, sizeof(struct tm));\n\n   V(mutex);\n\n   return ltm ? tm : NULL;\n}", "item_id": 5, "repo": "afeng11/tomato-arm", "file": "release/src-rt-6.x.4708/router/apcupsd/src/lib/asys.c", "last_update_at": "2022-01-20T18:21:05+00:00", "question_id": "a350872cd5cd50d2158bda2d1c9c723172b21e10_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct tm *localtime_r(const time_t *timep, struct tm *tm)\n{\n   struct tm *ltm;\n   static pthread_mutex_t mutex;\n   static int first = 1;\n   if (first) {\n      pthread_mutex_init(&mutex, NULL);\n      first = 0;\n   }\n   P(mutex);\n   ltm = localtime(timep);\n   if (ltm)\n      memcpy(tm, ltm, sizeof(struct tm));\n   V(mutex);\n   return ltm ? tm : NULL;\n"]]}
{"hexsha": "23a140f487dd2a523d5a176370c750be5e8f0458", "ext": "c", "lang": "C", "content": "S16 RlcLiRguBndCfm(Pst *pst,SuId suId,uint8_t status)\n{\n   uint16_t      event;     /* Event */\n   uint16_t      cause;     /* Cause */\n   RlcRguSapCb   *rguSap;   /* RGU SAP Control Block */\n   RlcCb         *tRlcCb;\n\n#if (ERRCLASS & ERRCLS_INT_PAR)\n   if (pst->dstInst >= MAX_RLC_INSTANCES)\n   {\n      return  (RFAILED);\n   }\n#endif\n   tRlcCb = RLC_GET_RLCCB(pst->dstInst);\n\n   DU_LOG(\"\\nDEBUG  -->  RLC UL : RlcLiRguBndCfm(suId(%d), status(%d)\", suId, status);\n\n#if (ERRCLASS & ERRCLS_INT_PAR)\n   if (tRlcCb->init.cfgDone != TRUE)\n   {\n      DU_LOG(\"\\nERROR  -->  RLC UL : General configuration not done\");\n      \n      RLC_SEND_SAPID_ALARM(tRlcCb,suId,LKW_EVENT_LI_BND_CFM, LCM_CAUSE_INV_STATE);\n\n      return RFAILED;\n   }\n\n   if ((suId >= tRlcCb->genCfg.maxRguSaps) || (suId < 0))\n   {\n      DU_LOG(\"\\nERROR  -->  RLC UL : Invalid suId\");\n      \n      RLC_SEND_SAPID_ALARM(tRlcCb,suId, LKW_EVENT_LI_BND_CFM, LCM_CAUSE_INV_SUID);\n\n      return RFAILED;\n   }\n#endif /* ERRCLASS & ERRCLS_INT_PAR */\n\n   rguSap = (tRlcCb->genCfg.rlcMode == LKW_RLC_MODE_DL) ?\n            &(tRlcCb->u.dlCb->rguDlSap[suId]) : &(tRlcCb->u.ulCb->rguUlSap[suId]);\n\n   DU_LOG(\"\\nDEBUG  -->  RLC UL : RlcLiRguBndCfm: For RGU SAP state=%d\", rguSap->state);\n\n   switch (rguSap->state)\n   {\n      case RLC_SAP_BINDING:\n      {\n         rlcStopTmr (tRlcCb,(PTR)rguSap, EVENT_RLC_WAIT_BNDCFM);\n\n         rguSap->retryCnt = 0;\n          \n         if (status == CM_BND_OK)\n         {\n            rguSap->state = RLC_SAP_BND;\n            event = LCM_EVENT_BND_OK;\n            cause = LKW_CAUSE_SAP_BNDENB;\n         }\n         else\n         {\n            rguSap->state = RLC_SAP_CFG;\n            event = LCM_EVENT_BND_FAIL;\n            cause = LKW_CAUSE_UNKNOWN;\n         }\n\n         break;\n      }\n      default:\n         event = LKW_EVENT_RGU_BND_CFM;\n         cause = LCM_CAUSE_INV_STATE;\n         break;\n   }\n\n   /* Send an alarm with proper event and cause */\n   RLC_SEND_SAPID_ALARM(tRlcCb, suId, event, cause);\n\n   return (ROK);\n}", "item_id": 0, "repo": "tanmayg14/o-du-l2", "file": "src/5gnrrlc/rlc_lwr_inf_mgr.c", "last_update_at": "2022-03-05T17:57:52+00:00", "question_id": "23a140f487dd2a523d5a176370c750be5e8f0458_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["S16 RlcLiRguBndCfm(Pst *pst,SuId suId,uint8_t status)\n{\n   uint16_t      event;     /* Event */\n   uint16_t      cause;     /* Cause */\n   RlcRguSapCb   *rguSap;   /* RGU SAP Control Block */\n   RlcCb         *tRlcCb;\n#if (ERRCLASS & ERRCLS_INT_PAR)\n   if (pst->dstInst >= MAX_RLC_INSTANCES)\n   {\n      return  (RFAILED);\n   }\n#endif\n   tRlcCb = RLC_GET_RLCCB(pst->dstInst);\n   DU_LOG(\"\\nDEBUG  -->  RLC UL : RlcLiRguBndCfm(suId(%d), status(%d)\", suId, status);\n#if (ERRCLASS & ERRCLS_INT_PAR)\n   if (tRlcCb->init.cfgDone != TRUE)\n   {\n      DU_LOG(\"\\nERROR  -->  RLC UL : General configuration not done\");\n      RLC_SEND_SAPID_ALARM(tRlcCb,suId,LKW_EVENT_LI_BND_CFM, LCM_CAUSE_INV_STATE);\n      return RFAILED;\n   }\n   if ((suId >= tRlcCb->genCfg.maxRguSaps) || (suId < 0))\n   {\n      DU_LOG(\"\\nERROR  -->  RLC UL : Invalid suId\");\n      RLC_SEND_SAPID_ALARM(tRlcCb,suId, LKW_EVENT_LI_BND_CFM, LCM_CAUSE_INV_SUID);\n      return RFAILED;\n   }\n#endif /* ERRCLASS & ERRCLS_INT_PAR */\n   rguSap = (tRlcCb->genCfg.rlcMode == LKW_RLC_MODE_DL) ?\n            &(tRlcCb->u.dlCb->rguDlSap[suId]) : &(tRlcCb->u.ulCb->rguUlSap[suId]);\n   DU_LOG(\"\\nDEBUG  -->  RLC UL : RlcLiRguBndCfm: For RGU SAP state=%d\", rguSap->state);\n   switch (rguSap->state)\n   {\n      case RLC_SAP_BINDING:\n      {\n         rlcStopTmr (tRlcCb,(PTR)rguSap, EVENT_RLC_WAIT_BNDCFM);\n         rguSap->retryCnt = 0;\n         if (status == CM_BND_OK)\n         {\n            rguSap->state = RLC_SAP_BND;\n            event = LCM_EVENT_BND_OK;\n            cause = LKW_CAUSE_SAP_BNDENB;\n         }\n         else\n         {\n            rguSap->state = RLC_SAP_CFG;\n            event = LCM_EVENT_BND_FAIL;\n            cause = LKW_CAUSE_UNKNOWN;\n         }\n         break;\n      }\n      default:\n         event = LKW_EVENT_RGU_BND_CFM;\n         cause = LCM_CAUSE_INV_STATE;\n         break;\n   }\n   /* Send an alarm with proper event and cause */\n   RLC_SEND_SAPID_ALARM(tRlcCb, suId, event, cause);\n   return (ROK);\n"]]}
{"hexsha": "ea9284064f729254add2bb73f4cdd791b32f7f3b", "ext": "c", "lang": "C", "content": "static void test_builtin_macro_override() {\n  unsigned char ram[] = { 0x39, 0x30 };\n  memory_t memory;\n  rc_richpresence_t* richpresence;\n  char buffer[256];\n\n  memory.ram = ram;\n  memory.size = sizeof(ram);\n\n  assert_parse_richpresence(&richpresence, buffer, \"Format:Number\\nFormatType=SECS\\n\\nDisplay:\\n@Number(0x 0)\");\n  assert_richpresence_output(richpresence, &memory, \"3h25:45\");\n}", "item_id": 56, "repo": "Jamiras/rcheevos", "file": "test/rcheevos/test_richpresence.c", "last_update_at": "2022-03-25T08:26:35+00:00", "question_id": "ea9284064f729254add2bb73f4cdd791b32f7f3b_56", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void test_builtin_macro_override() {\n  unsigned char ram[] = { 0x39, 0x30 };\n  memory_t memory;\n  rc_richpresence_t* richpresence;\n  char buffer[256];\n  memory.ram = ram;\n  memory.size = sizeof(ram);\n  assert_parse_richpresence(&richpresence, buffer, \"Format:Number\\nFormatType=SECS\\n\\nDisplay:\\n@Number(0x 0)\");\n  assert_richpresence_output(richpresence, &memory, \"3h25:45\");\n"]]}
{"hexsha": "325f0fb3fd16aee145893c24472611faf8aaff35", "ext": "c", "lang": "C", "content": "static void Test_cascade_five_timers(nlTestSuite *inSuite, void *inContext)\n{\n    BaseType_t wait_result;\n    timer_test_info2_t test_info1;\n    timer_test_info2_t test_info2;\n    timer_test_info2_t test_info3;\n    timer_test_info2_t test_info4;\n    timer_test_info2_t test_info5;\n    nl_swtimer_t timer1;\n    nl_swtimer_t timer2;\n    nl_swtimer_t timer3;\n    nl_swtimer_t timer4;\n    nl_swtimer_t timer5;\n    nl_swtimer_t *timer_list1[1];\n    uint32_t timer_delays1[1];\n    timer_test_info2_t *timer_infos1[1];\n    nl_swtimer_t *timer_list2[3];\n    uint32_t timer_delays2[3];\n    timer_test_info2_t *timer_infos2[3];\n\n    if (s_test_with_tick_count_near_wrap)\n    {\n        AdjustTickCount(nl_time_ms_to_delay_time_native(TIMER_TEST_DELAY_50_MS));\n    }\n\n    // test five one shot timers where timer1 starts timer2 from\n    // it's timer function, and timer2 starts timer3, timer4, and\n    // timer5 from it's timer function.\n    // timer1 has a timeout of 100MS\n    // timer2 has a timeout of 500MS\n    // timer3 has a timeout of 1000MS\n    // timer4 has a timeout of 1000MS\n    // timer5 has a timeout of 2000MS\n    printf(\"%s: start. test takes about 3 seconds...\\n\", __func__);\n    ulTaskNotifyTake(pdTRUE, 0); // clear any old notifications\n    memset(&test_info1, 0, sizeof(test_info1));\n    memset(&test_info2, 0, sizeof(test_info2));\n    memset(&test_info3, 0, sizeof(test_info3));\n    memset(&test_info4, 0, sizeof(test_info4));\n    memset(&test_info5, 0, sizeof(test_info5));\n    nl_swtimer_init(&timer1, cascade_timer_test, &test_info1);\n    nl_swtimer_init(&timer2, cascade_timer_test, &test_info2);\n    nl_swtimer_init(&timer3, cascade_timer_test, &test_info3);\n    nl_swtimer_init(&timer4, cascade_timer_test, &test_info4);\n    nl_swtimer_init(&timer5, cascade_timer_test, &test_info5);\n    test_info1.test_suite = inSuite;\n    test_info1.num_timers = 1;\n    timer_list1[0] = &timer2;\n    timer_delays1[0] = TIMER_TEST_DELAY_500_MS;\n    timer_infos1[0] = &test_info2;\n    test_info1.timers = timer_list1;\n    test_info1.timer_infos = timer_infos1;\n    test_info1.timer_delays = timer_delays1;\n\n    test_info2.test_suite = inSuite;\n    test_info2.num_timers = 3;\n    timer_list2[0] = &timer3;\n    timer_list2[1] = &timer4;\n    timer_list2[2] = &timer5;\n    timer_delays2[0] = TIMER_TEST_DELAY_1000_MS;\n    timer_delays2[1] = TIMER_TEST_DELAY_1000_MS;\n    timer_delays2[2] = TIMER_TEST_DELAY_2000_MS;\n    timer_infos2[0] = &test_info3;\n    timer_infos2[1] = &test_info4;\n    timer_infos2[2] = &test_info5;\n    test_info2.timers = timer_list2;\n    test_info2.timer_infos = timer_infos2;\n    test_info2.timer_delays = timer_delays2;\n\n    test_info3.test_suite = inSuite;\n    test_info4.test_suite = inSuite;\n    test_info5.test_suite = inSuite;\n    test_info5.notifyTaskHandle = xTaskGetCurrentTaskHandle();\n\n    test_info1.expectedRunTimeMin = xTaskGetTickCount() + nl_time_ms_to_delay_time_native(TIMER_TEST_DELAY_100_MS);\n    test_info1.expectedRunTimeMax = test_info1.expectedRunTimeMin + TIMING_ERROR_TOLERANCE_TICKS;\n    nl_swtimer_start(&timer1, TIMER_TEST_DELAY_100_MS);\n    NL_TEST_ASSERT(inSuite, nl_swtimer_is_active(&timer1));\n    // delay until we expect everything to have been run.  since\n    // restarting a timer from within itself isn't quite the same\n    // as true periodic, because of the extra tick added to the\n    // each start, we have to wait a bit longer than 10 seconds\n    wait_result = ulTaskNotifyTake(pdTRUE, nl_time_ms_to_delay_time_native(TIMER_TEST_DELAY_5000_MS));\n    NL_TEST_ASSERT(inSuite, wait_result != 0); // assert did not timeout\n    NL_TEST_ASSERT(inSuite, nl_swtimer_is_active(&timer1) == false);\n    NL_TEST_ASSERT(inSuite, nl_swtimer_is_active(&timer2) == false);\n    NL_TEST_ASSERT(inSuite, nl_swtimer_is_active(&timer3) == false);\n    NL_TEST_ASSERT(inSuite, nl_swtimer_is_active(&timer4) == false);\n    NL_TEST_ASSERT(inSuite, nl_swtimer_is_active(&timer5) == false);\n    NL_TEST_ASSERT(inSuite, test_info1.count == 1);\n    NL_TEST_ASSERT(inSuite, test_info2.count == 1);\n    NL_TEST_ASSERT(inSuite, test_info3.count == 1);\n    NL_TEST_ASSERT(inSuite, test_info4.count == 1);\n    NL_TEST_ASSERT(inSuite, test_info5.count == 1);\n\n    // cleanup just in case of failure before we run next test, else\n    // our stack timer structure will corrupt the nl_swtimer implementation\n    (void)nl_swtimer_cancel(&timer1);\n    (void)nl_swtimer_cancel(&timer2);\n    (void)nl_swtimer_cancel(&timer3);\n    (void)nl_swtimer_cancel(&timer4);\n    (void)nl_swtimer_cancel(&timer5);\n}", "item_id": 15, "repo": "nestlabs/nlplatform", "file": "test/nlswtimer-test.c", "last_update_at": "2022-01-17T11:56:47+00:00", "question_id": "325f0fb3fd16aee145893c24472611faf8aaff35_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void Test_cascade_five_timers(nlTestSuite *inSuite, void *inContext)\n{\n    BaseType_t wait_result;\n    timer_test_info2_t test_info1;\n    timer_test_info2_t test_info2;\n    timer_test_info2_t test_info3;\n    timer_test_info2_t test_info4;\n    timer_test_info2_t test_info5;\n    nl_swtimer_t timer1;\n    nl_swtimer_t timer2;\n    nl_swtimer_t timer3;\n    nl_swtimer_t timer4;\n    nl_swtimer_t timer5;\n    nl_swtimer_t *timer_list1[1];\n    uint32_t timer_delays1[1];\n    timer_test_info2_t *timer_infos1[1];\n    nl_swtimer_t *timer_list2[3];\n    uint32_t timer_delays2[3];\n    timer_test_info2_t *timer_infos2[3];\n    if (s_test_with_tick_count_near_wrap)\n    {\n        AdjustTickCount(nl_time_ms_to_delay_time_native(TIMER_TEST_DELAY_50_MS));\n    }\n    // test five one shot timers where timer1 starts timer2 from\n    // it's timer function, and timer2 starts timer3, timer4, and\n    // timer5 from it's timer function.\n    // timer1 has a timeout of 100MS\n    // timer2 has a timeout of 500MS\n    // timer3 has a timeout of 1000MS\n    // timer4 has a timeout of 1000MS\n    // timer5 has a timeout of 2000MS\n    printf(\"%s: start. test takes about 3 seconds...\\n\", __func__);\n    ulTaskNotifyTake(pdTRUE, 0); // clear any old notifications\n    memset(&test_info1, 0, sizeof(test_info1));\n    memset(&test_info2, 0, sizeof(test_info2));\n    memset(&test_info3, 0, sizeof(test_info3));\n    memset(&test_info4, 0, sizeof(test_info4));\n    memset(&test_info5, 0, sizeof(test_info5));\n    nl_swtimer_init(&timer1, cascade_timer_test, &test_info1);\n    nl_swtimer_init(&timer2, cascade_timer_test, &test_info2);\n    nl_swtimer_init(&timer3, cascade_timer_test, &test_info3);\n    nl_swtimer_init(&timer4, cascade_timer_test, &test_info4);\n    nl_swtimer_init(&timer5, cascade_timer_test, &test_info5);\n    test_info1.test_suite = inSuite;\n    test_info1.num_timers = 1;\n    timer_list1[0] = &timer2;\n    timer_delays1[0] = TIMER_TEST_DELAY_500_MS;\n    timer_infos1[0] = &test_info2;\n    test_info1.timers = timer_list1;\n    test_info1.timer_infos = timer_infos1;\n    test_info1.timer_delays = timer_delays1;\n    test_info2.test_suite = inSuite;\n    test_info2.num_timers = 3;\n    timer_list2[0] = &timer3;\n    timer_list2[1] = &timer4;\n    timer_list2[2] = &timer5;\n    timer_delays2[0] = TIMER_TEST_DELAY_1000_MS;\n    timer_delays2[1] = TIMER_TEST_DELAY_1000_MS;\n    timer_delays2[2] = TIMER_TEST_DELAY_2000_MS;\n    timer_infos2[0] = &test_info3;\n    timer_infos2[1] = &test_info4;\n    timer_infos2[2] = &test_info5;\n    test_info2.timers = timer_list2;\n    test_info2.timer_infos = timer_infos2;\n    test_info2.timer_delays = timer_delays2;\n    test_info3.test_suite = inSuite;\n    test_info4.test_suite = inSuite;\n    test_info5.test_suite = inSuite;\n    test_info5.notifyTaskHandle = xTaskGetCurrentTaskHandle();\n    test_info1.expectedRunTimeMin = xTaskGetTickCount() + nl_time_ms_to_delay_time_native(TIMER_TEST_DELAY_100_MS);\n    test_info1.expectedRunTimeMax = test_info1.expectedRunTimeMin + TIMING_ERROR_TOLERANCE_TICKS;\n    nl_swtimer_start(&timer1, TIMER_TEST_DELAY_100_MS);\n    NL_TEST_ASSERT(inSuite, nl_swtimer_is_active(&timer1));\n    // delay until we expect everything to have been run.  since\n    // restarting a timer from within itself isn't quite the same\n    // as true periodic, because of the extra tick added to the\n    // each start, we have to wait a bit longer than 10 seconds\n    wait_result = ulTaskNotifyTake(pdTRUE, nl_time_ms_to_delay_time_native(TIMER_TEST_DELAY_5000_MS));\n    NL_TEST_ASSERT(inSuite, wait_result != 0); // assert did not timeout\n    NL_TEST_ASSERT(inSuite, nl_swtimer_is_active(&timer1) == false);\n    NL_TEST_ASSERT(inSuite, nl_swtimer_is_active(&timer2) == false);\n    NL_TEST_ASSERT(inSuite, nl_swtimer_is_active(&timer3) == false);\n    NL_TEST_ASSERT(inSuite, nl_swtimer_is_active(&timer4) == false);\n    NL_TEST_ASSERT(inSuite, nl_swtimer_is_active(&timer5) == false);\n    NL_TEST_ASSERT(inSuite, test_info1.count == 1);\n    NL_TEST_ASSERT(inSuite, test_info2.count == 1);\n    NL_TEST_ASSERT(inSuite, test_info3.count == 1);\n    NL_TEST_ASSERT(inSuite, test_info4.count == 1);\n    NL_TEST_ASSERT(inSuite, test_info5.count == 1);\n    // cleanup just in case of failure before we run next test, else\n    // our stack timer structure will corrupt the nl_swtimer implementation\n    (void)nl_swtimer_cancel(&timer1);\n    (void)nl_swtimer_cancel(&timer2);\n    (void)nl_swtimer_cancel(&timer3);\n    (void)nl_swtimer_cancel(&timer4);\n    (void)nl_swtimer_cancel(&timer5);\n"]]}
{"hexsha": "59eb1169f5a4e54c213cf5dd2a2d328614b3fd66", "ext": "c", "lang": "C", "content": "static void VecDT_Save(RedisModuleIO *rdb, void *value){\n    VecDT* vDT = value;\n\n    RedisModule_SaveString(rdb, vDT->keyName);\n    RedisModule_SaveStringBuffer(rdb, (char*)&HOLDER_VEC(vDT->holder, vDT->index), sizeof(float) * VEC_SIZE);\n}", "item_id": 16, "repo": "rafie/VecSim", "file": "src/vector_similarity.c", "last_update_at": "2022-01-03T08:56:28+00:00", "question_id": "59eb1169f5a4e54c213cf5dd2a2d328614b3fd66_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void VecDT_Save(RedisModuleIO *rdb, void *value){\n    VecDT* vDT = value;\n    RedisModule_SaveString(rdb, vDT->keyName);\n    RedisModule_SaveStringBuffer(rdb, (char*)&HOLDER_VEC(vDT->holder, vDT->index), sizeof(float) * VEC_SIZE);\n"]]}
{"hexsha": "3d18f2a4e6b84408bf20e80127d89a4ea95fa713", "ext": "c", "lang": "C", "content": "void hookrw_init ( void )\n{\n    DEBUG(\"Hooking sys_read and sys_write\\n\");\n\n    sys_read = (void *)sys_call_table[__NR_read];\n    hijack_start(sys_read, &n_sys_read);\n\n    sys_write = (void *)sys_call_table[__NR_write];\n    hijack_start(sys_write, &n_sys_write);\n}", "item_id": 2, "repo": "dsapoetra/suterusu", "file": "hookrw.c", "last_update_at": "2022-03-09T23:52:44+00:00", "question_id": "3d18f2a4e6b84408bf20e80127d89a4ea95fa713_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void hookrw_init ( void )\n{\n    DEBUG(\"Hooking sys_read and sys_write\\n\");\n    sys_read = (void *)sys_call_table[__NR_read];\n    hijack_start(sys_read, &n_sys_read);\n    sys_write = (void *)sys_call_table[__NR_write];\n    hijack_start(sys_write, &n_sys_write);\n"]]}
{"hexsha": "c8d4b1331293d6333e012d753b9962e85ebec760", "ext": "c", "lang": "C", "content": "JNICALL Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeRGBA(JNIEnv *jenv, jclass jcls, jbyteArray jarg1, jint jarg2, jint jarg3, jintArray jarg4, jint jarg5, jint jarg6, jint jarg7, jfloat jarg8) {\n  jbyteArray jresult = 0 ;\n  uint8_t *arg1 = (uint8_t *) 0 ;\n  int *arg2 = (int *) 0 ;\n  int *arg3 = (int *) 0 ;\n  int *arg4 = (int *) 0 ;\n  int arg5 ;\n  int arg6 ;\n  int arg7 ;\n  float arg8 ;\n  jbyte *jarr1 ;\n  int temp4 ;\n  uint8_t *result = 0 ;\n\n  (void)jenv;\n  (void)jcls;\n  if (!SWIG_JavaArrayInUint8(jenv, &jarr1, &arg1, jarg1)) return 0;\n  arg2 = (int *)&jarg2;\n  arg3 = (int *)&jarg3;\n  {\n    if (!jarg4) {\n      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, \"array null\");\n      return 0;\n    }\n    if ((*jenv)->GetArrayLength(jenv, jarg4) == 0) {\n      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, \"Array must contain at least 1 element\");\n      return 0;\n    }\n    arg4 = &temp4;\n  }\n  arg5 = (int)jarg5;\n  arg6 = (int)jarg6;\n  arg7 = (int)jarg7;\n  arg8 = (float)jarg8;\n  result = (uint8_t *)wrap_WebPEncodeRGBA((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);\n  jresult = SWIG_JavaArrayOutUint8(jenv, result, FillMeInAsSizeCannotBeDeterminedAutomatically);\n  SWIG_JavaArrayArgoutUint8(jenv, jarr1, arg1, jarg1);\n  {\n    jint jvalue = (jint)temp4;\n    (*jenv)->SetIntArrayRegion(jenv, jarg4, 0, 1, &jvalue);\n  }\n  free(arg1);\n\n\n\n  free(result);\n  return jresult;\n}", "item_id": 51, "repo": "yue-f/react-native-fast-image", "file": "ios/Vendor/SDWebImage/Vendors/libwebp/swig/libwebp_java_wrap.c", "last_update_at": "2022-03-30T02:29:30+00:00", "question_id": "c8d4b1331293d6333e012d753b9962e85ebec760_51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["JNICALL Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeRGBA(JNIEnv *jenv, jclass jcls, jbyteArray jarg1, jint jarg2, jint jarg3, jintArray jarg4, jint jarg5, jint jarg6, jint jarg7, jfloat jarg8) {\n  jbyteArray jresult = 0 ;\n  uint8_t *arg1 = (uint8_t *) 0 ;\n  int *arg2 = (int *) 0 ;\n  int *arg3 = (int *) 0 ;\n  int *arg4 = (int *) 0 ;\n  int arg5 ;\n  int arg6 ;\n  int arg7 ;\n  float arg8 ;\n  jbyte *jarr1 ;\n  int temp4 ;\n  uint8_t *result = 0 ;\n  (void)jenv;\n  (void)jcls;\n  if (!SWIG_JavaArrayInUint8(jenv, &jarr1, &arg1, jarg1)) return 0;\n  arg2 = (int *)&jarg2;\n  arg3 = (int *)&jarg3;\n  {\n    if (!jarg4) {\n      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, \"array null\");\n      return 0;\n    }\n    if ((*jenv)->GetArrayLength(jenv, jarg4) == 0) {\n      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, \"Array must contain at least 1 element\");\n      return 0;\n    }\n    arg4 = &temp4;\n  }\n  arg5 = (int)jarg5;\n  arg6 = (int)jarg6;\n  arg7 = (int)jarg7;\n  arg8 = (float)jarg8;\n  result = (uint8_t *)wrap_WebPEncodeRGBA((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);\n  jresult = SWIG_JavaArrayOutUint8(jenv, result, FillMeInAsSizeCannotBeDeterminedAutomatically);\n  SWIG_JavaArrayArgoutUint8(jenv, jarr1, arg1, jarg1);\n  {\n    jint jvalue = (jint)temp4;\n    (*jenv)->SetIntArrayRegion(jenv, jarg4, 0, 1, &jvalue);\n  }\n  free(arg1);\n  free(result);\n  return jresult;\n"]]}
{"hexsha": "681c6a441320e2a985c973416c4ef5a1fe21dd1c", "ext": "c", "lang": "C", "content": "static OSStatus     audioCallback (void                            *inRefCon,\r\n                                   AudioUnitRenderActionFlags      *ioActionFlags,\r\n                                   const AudioTimeStamp            *inTimeStamp,\r\n                                   UInt32                          inBusNumber,\r\n                                   UInt32                          inNumberFrames,\r\n                                   AudioBufferList                 *ioData)\r\n{\r\n    SDL_AudioDevice *this = (SDL_AudioDevice *)inRefCon;\r\n    UInt32 remaining, len;\r\n    AudioBuffer *abuf;\r\n    void *ptr;\r\n    UInt32 i;\r\n\r\n    /* Only do anything if audio is enabled and not paused */\r\n    if ( ! this->enabled || this->paused ) {\r\n        for (i = 0; i < ioData->mNumberBuffers; i++) {\r\n            abuf = &ioData->mBuffers[i];\r\n            SDL_memset(abuf->mData, this->spec.silence, abuf->mDataByteSize);\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    /* No SDL conversion should be needed here, ever, since we accept\r\n       any input format in OpenAudio, and leave the conversion to CoreAudio.\r\n     */\r\n    /*\r\n    assert(!this->convert.needed);\r\n    assert(this->spec.channels == ioData->mNumberChannels);\r\n     */\r\n\r\n    for (i = 0; i < ioData->mNumberBuffers; i++) {\r\n        abuf = &ioData->mBuffers[i];\r\n        remaining = abuf->mDataByteSize;\r\n        ptr = abuf->mData;\r\n        while (remaining > 0) {\r\n            if (bufferOffset >= bufferSize) {\r\n                /* Generate the data */\r\n                SDL_memset(buffer, this->spec.silence, bufferSize);\r\n                SDL_mutexP(this->mixer_lock);\r\n                (*this->spec.callback)(this->spec.userdata,\r\n                            buffer, bufferSize);\r\n                SDL_mutexV(this->mixer_lock);\r\n                bufferOffset = 0;\r\n            }\r\n        \r\n            len = bufferSize - bufferOffset;\r\n            if (len > remaining)\r\n                len = remaining;\r\n            SDL_memcpy(ptr, (char *)buffer + bufferOffset, len);\r\n            ptr = (char *)ptr + len;\r\n            remaining -= len;\r\n            bufferOffset += len;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}", "item_id": 1, "repo": "dinodeck/dinodeck", "file": "lib/sdl/src/audio/macosx/SDL_coreaudio.c", "last_update_at": "2022-03-25T03:18:16+00:00", "question_id": "681c6a441320e2a985c973416c4ef5a1fe21dd1c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static OSStatus     audioCallback (void                            *inRefCon,\r\n                                   AudioUnitRenderActionFlags      *ioActionFlags,\r\n                                   const AudioTimeStamp            *inTimeStamp,\r\n                                   UInt32                          inBusNumber,\r\n                                   UInt32                          inNumberFrames,\r\n                                   AudioBufferList                 *ioData)\r\n{\r\n    SDL_AudioDevice *this = (SDL_AudioDevice *)inRefCon;\r\n    UInt32 remaining, len;\r\n    AudioBuffer *abuf;\r\n    void *ptr;\r\n    UInt32 i;\r\n\r\n    /* Only do anything if audio is enabled and not paused */\r\n    if ( ! this->enabled || this->paused ) {\r\n        for (i = 0; i < ioData->mNumberBuffers; i++) {\r\n            abuf = &ioData->mBuffers[i];\r\n            SDL_memset(abuf->mData, this->spec.silence, abuf->mDataByteSize);\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    /* No SDL conversion should be needed here, ever, since we accept\r\n       any input format in OpenAudio, and leave the conversion to CoreAudio.\r\n     */\r\n    /*\r\n    assert(!this->convert.needed);\r\n    assert(this->spec.channels == ioData->mNumberChannels);\r\n     */\r\n\r\n    for (i = 0; i < ioData->mNumberBuffers; i++) {\r\n        abuf = &ioData->mBuffers[i];\r\n        remaining = abuf->mDataByteSize;\r\n        ptr = abuf->mData;\r\n        while (remaining > 0) {\r\n            if (bufferOffset >= bufferSize) {\r\n                /* Generate the data */\r\n                SDL_memset(buffer, this->spec.silence, bufferSize);\r\n                SDL_mutexP(this->mixer_lock);\r\n                (*this->spec.callback)(this->spec.userdata,\r\n                            buffer, bufferSize);\r\n                SDL_mutexV(this->mixer_lock);\r\n                bufferOffset = 0;\r\n            }\r\n        \r\n            len = bufferSize - bufferOffset;\r\n            if (len > remaining)\r\n                len = remaining;\r\n            SDL_memcpy(ptr, (char *)buffer + bufferOffset, len);\r\n            ptr = (char *)ptr + len;\r\n            remaining -= len;\r\n            bufferOffset += len;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n"]]}
{"hexsha": "e316a1cf5487932214030b9a7927749c6c40b286", "ext": "c", "lang": "C", "content": "int doreader(key, type, child)\nint type, child;\nlong key;\n{\n\tint i, size;\n\tint id;\n\n\tif ((id = msgget(key, 0)) < 0) {\n\t\ttst_resm(TFAIL|TERRNO,\n\t\t\t \"Msgget error in reader of child group %d\",\n\t\t\t child);\n\t\ttst_exit();\n\t}\n\tif (id != tid) {\n\t\ttst_resm(TFAIL,\n\t\t\t \"Message queue mismatch in reader of child group %d for message queue id %d\",\n\t\t\t child, id);\n\t\ttst_exit();\n\t}\n\tfor (i = 0; i < nreps; i++) {\n\t\tif ((size = msgrcv(id, &buffer, 100, type, 0)) < 0) {\n\t\t\ttst_resm(TFAIL|TERRNO,\n\t\t\t\t \"Msgrcv error in child %d, read # = %d\",\n\t\t\t\t (i + 1), child);\n\t\t\ttst_exit();\n\t\t}\n\t\tif (buffer.type != type) {\n\t\t\ttst_resm(TFAIL,\n\t\t\t\t \"Size mismatch in child %d, read # = %d\",\n\t\t\t\t child, (i + 1));\n\t\t\ttst_resm(TFAIL,\n\t\t\t\t \"\\tfor message size got  %d expected  %d\",\n\t\t\t\t size, buffer.data.len);\n\t\t\ttst_exit();\n\t\t}\n\t\tif (buffer.data.len + 1 != size) {\n\t\t\ttst_resm(TFAIL,\n\t\t\t\t \"Size mismatch in child %d, read # = %d, size = %d, expected = %d\",\n\t\t\t\t child, (i + 1), buffer.data.len, size);\n\t\t\ttst_exit();\n\t\t}\n\t\tif (verify(buffer.data.pbytes, (key % 255), size - 1, child)) {\n\t\t\ttst_resm(TFAIL, \"in child %d read # = %d,key =  %lx\",\n\t\t\t\t child, (i + 1), key);\n\t\t\ttst_exit();\n\t\t}\n\t\tkey++;\n\t}\n\texit(PASS);\n}", "item_id": 3, "repo": "maurizioabba/rose", "file": "projects/simulator/syscall_tests/syscall_tst.117.msgctl.09.c", "last_update_at": "2022-03-30T07:15:46+00:00", "question_id": "e316a1cf5487932214030b9a7927749c6c40b286_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int doreader(key, type, child)\nint type, child;\nlong key;\n{\n\tint i, size;\n\tint id;\n\tif ((id = msgget(key, 0)) < 0) {\n\t\ttst_resm(TFAIL|TERRNO,\n\t\t\t \"Msgget error in reader of child group %d\",\n\t\t\t child);\n\t\ttst_exit();\n\t}\n\tif (id != tid) {\n\t\ttst_resm(TFAIL,\n\t\t\t \"Message queue mismatch in reader of child group %d for message queue id %d\",\n\t\t\t child, id);\n\t\ttst_exit();\n\t}\n\tfor (i = 0; i < nreps; i++) {\n\t\tif ((size = msgrcv(id, &buffer, 100, type, 0)) < 0) {\n\t\t\ttst_resm(TFAIL|TERRNO,\n\t\t\t\t \"Msgrcv error in child %d, read # = %d\",\n\t\t\t\t (i + 1), child);\n\t\t\ttst_exit();\n\t\t}\n\t\tif (buffer.type != type) {\n\t\t\ttst_resm(TFAIL,\n\t\t\t\t \"Size mismatch in child %d, read # = %d\",\n\t\t\t\t child, (i + 1));\n\t\t\ttst_resm(TFAIL,\n\t\t\t\t \"\\tfor message size got  %d expected  %d\",\n\t\t\t\t size, buffer.data.len);\n\t\t\ttst_exit();\n\t\t}\n\t\tif (buffer.data.len + 1 != size) {\n\t\t\ttst_resm(TFAIL,\n\t\t\t\t \"Size mismatch in child %d, read # = %d, size = %d, expected = %d\",\n\t\t\t\t child, (i + 1), buffer.data.len, size);\n\t\t\ttst_exit();\n\t\t}\n\t\tif (verify(buffer.data.pbytes, (key % 255), size - 1, child)) {\n\t\t\ttst_resm(TFAIL, \"in child %d read # = %d,key =  %lx\",\n\t\t\t\t child, (i + 1), key);\n\t\t\ttst_exit();\n\t\t}\n\t\tkey++;\n\t}\n\texit(PASS);\n"]]}
{"hexsha": "35c1ebf88bec10504cd8fc974da690c3e75f5e4c", "ext": "c", "lang": "C", "content": "off_t VFS_Truncate(int FD, off_t Size)\n{\n\ttVFS_Handle\t*h = VFS_GetHandle(FD);\n\tif(!h) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\t\n\tif( !h->Node->Type->Truncate)\n\t{\n\t\tLog_Notice(\"VFS\", \"Nodetype '%s' doesn't have a Truncate method\", h->Node->Type->TypeName);\n\t\terrno = ENOTIMPL;\n\t\treturn -1;\t\n\t}\n\t\n\treturn h->Node->Type->Truncate(h->Node, Size);\n}", "item_id": 6, "repo": "thepowersgang/acess2", "file": "KernelLand/Kernel/vfs/io.c", "last_update_at": "2022-02-23T14:11:11+00:00", "question_id": "35c1ebf88bec10504cd8fc974da690c3e75f5e4c_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["off_t VFS_Truncate(int FD, off_t Size)\n{\n\ttVFS_Handle\t*h = VFS_GetHandle(FD);\n\tif(!h) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\t\n\tif( !h->Node->Type->Truncate)\n\t{\n\t\tLog_Notice(\"VFS\", \"Nodetype '%s' doesn't have a Truncate method\", h->Node->Type->TypeName);\n\t\terrno = ENOTIMPL;\n\t\treturn -1;\t\n\t}\n\t\n\treturn h->Node->Type->Truncate(h->Node, Size);\n"]]}
{"hexsha": "c10f9f0a30fe4b851d0f0a061a6aa4d2b264b78f", "ext": "c", "lang": "C", "content": "int\ncomputeFieldOffsets(fields, class)\n  fieldList\t*fields;\n  int\t\t class;\n{\n\tint\t offset;\n\tint\t bitOffset;\n\tfield\t*aField;\n\n\tif (class > 1)\n\t\toffset = objectBase;\n\telse\n\t\toffset = 0;\n\tif (fields == NULL)\n\t\treturn(offset);\n\n\tbitOffset = 0;\n\twhile (fields != NULL) {\n\t\taField = fields->field;\n\t\taField->offset = offset + (bitOffset << 14);\n\n\t\tif (class == -1)\n\t\t\tobjectBase = offset;\n\n\t\tswitch (aField->type) {\n\t\tCase FIELD_ENTITY:\n\t\t\toffset += 6 * aField->dimension;\n\n\t\tCase FIELD_AVAID:\n\t\tcase FIELD_BIN31:\n\t\tcase FIELD_OBJID:\n\t\tcase FIELD_REGID:\n\t\tcase FIELD_FATWORD:\n\t\t\toffset += 4 * aField->dimension;\n\n\t\tCase FIELD_BIN15:\n\t\tcase FIELD_WORDS:\n\t\t\toffset += 2 * aField->dimension;\n\n\t\tCase FIELD_BYTE:\n\t\tcase FIELD_CHARACTER:\n\t\t\toffset += aField->dimension;\n\n\t\tCase FIELD_VARSTRING:\n\t\t\toffset += aField->dimension + 2;\n\n\t\tCase FIELD_BIT:\n\t\t\tbitOffset += aField->dimension;\n\t\t\tif (bitOffset > 15) {\n\t\t\t\toffset += 2 * (bitOffset >> 4);\n\t\t\t\tbitOffset -= (bitOffset & ~0xF);\n\t\t\t}\n\t\t}\n\n\t\tif (aField->type != FIELD_BIT && bitOffset > 0) {\n\t\t\tbitOffset = 0;\n\t\t\toffset += 2;\n\t\t} else if (aField->type != FIELD_CHARACTER &&\n\t\t\t   aField->type != FIELD_BYTE && (offset & 1) == 1)\n\t\t\t++offset;\n\n\t\tfields = fields->nextField;\n\t}\n\tif (bitOffset > 0)\n\t\toffset += 2;\n\treturn(offset);\n}", "item_id": 12, "repo": "Museum-of-Art-and-Digital-Entertainment/Habitat", "file": "sources/tools/griddle/exec.c", "last_update_at": "2022-03-01T20:52:50+00:00", "question_id": "c10f9f0a30fe4b851d0f0a061a6aa4d2b264b78f_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\ncomputeFieldOffsets(fields, class)\n  fieldList\t*fields;\n  int\t\t class;\n{\n\tint\t offset;\n\tint\t bitOffset;\n\tfield\t*aField;\n\tif (class > 1)\n\t\toffset = objectBase;\n\telse\n\t\toffset = 0;\n\tif (fields == NULL)\n\t\treturn(offset);\n\tbitOffset = 0;\n\twhile (fields != NULL) {\n\t\taField = fields->field;\n\t\taField->offset = offset + (bitOffset << 14);\n\t\tif (class == -1)\n\t\t\tobjectBase = offset;\n\t\tswitch (aField->type) {\n\t\tCase FIELD_ENTITY:\n\t\t\toffset += 6 * aField->dimension;\n\t\tCase FIELD_AVAID:\n\t\tcase FIELD_BIN31:\n\t\tcase FIELD_OBJID:\n\t\tcase FIELD_REGID:\n\t\tcase FIELD_FATWORD:\n\t\t\toffset += 4 * aField->dimension;\n\t\tCase FIELD_BIN15:\n\t\tcase FIELD_WORDS:\n\t\t\toffset += 2 * aField->dimension;\n\t\tCase FIELD_BYTE:\n\t\tcase FIELD_CHARACTER:\n\t\t\toffset += aField->dimension;\n\t\tCase FIELD_VARSTRING:\n\t\t\toffset += aField->dimension + 2;\n\t\tCase FIELD_BIT:\n\t\t\tbitOffset += aField->dimension;\n\t\t\tif (bitOffset > 15) {\n\t\t\t\toffset += 2 * (bitOffset >> 4);\n\t\t\t\tbitOffset -= (bitOffset & ~0xF);\n\t\t\t}\n\t\t}\n\t\tif (aField->type != FIELD_BIT && bitOffset > 0) {\n\t\t\tbitOffset = 0;\n\t\t\toffset += 2;\n\t\t} else if (aField->type != FIELD_CHARACTER &&\n\t\t\t   aField->type != FIELD_BYTE && (offset & 1) == 1)\n\t\t\t++offset;\n\t\tfields = fields->nextField;\n\t}\n\tif (bitOffset > 0)\n\t\toffset += 2;\n\treturn(offset);\n"]]}
{"hexsha": "e7ce7abf4636068b9615275526c4722fe782f4b0", "ext": "h", "lang": "C", "content": "class DecagonES2_Cond : public Variable {\n public:\n    /**\n     * @brief Construct a new DecagonES2_Cond object.\n     *\n     * @param parentSense The parent DecagonES2 providing the result values.\n     * @param uuid A universally unique identifier (UUID or GUID) for the\n     * variable; optional with the default value of an empty string.\n     * @param varCode A short code to help identify the variable in files;\n     * optional with a default value of \"ES2Cond\".\n     */\n    explicit DecagonES2_Cond(DecagonES2* parentSense, const char* uuid = \"\",\n                             const char* varCode = ES2_COND_DEFAULT_CODE)\n        : Variable(parentSense, (const uint8_t)ES2_COND_VAR_NUM,\n                   (uint8_t)ES2_COND_RESOLUTION, ES2_COND_VAR_NAME,\n                   ES2_COND_UNIT_NAME, varCode, uuid) {}\n    /**\n     * @brief Construct a new DecagonES2_Cond object.\n     *\n     * @note This must be tied with a parent DecagonES2 before it can be used.\n     */\n    DecagonES2_Cond()\n        : Variable((const uint8_t)ES2_COND_VAR_NUM,\n                   (uint8_t)ES2_COND_RESOLUTION, ES2_COND_VAR_NAME,\n                   ES2_COND_UNIT_NAME, ES2_COND_DEFAULT_CODE) {}\n    /**\n     * @brief Destroy the DecagonES2_Cond object - no action needed.\n     */\n    ~DecagonES2_Cond() {}\n}", "item_id": 1, "repo": "AndresLu97/ModularSensors", "file": "src/sensors/DecagonES2.h", "last_update_at": "2022-03-20T17:48:27+00:00", "question_id": "e7ce7abf4636068b9615275526c4722fe782f4b0_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class DecagonES2_Cond : public Variable {\n public:\n    /**\n     * @brief Construct a new DecagonES2_Cond object.\n     *\n     * @param parentSense The parent DecagonES2 providing the result values.\n     * @param uuid A universally unique identifier (UUID or GUID) for the\n     * variable; optional with the default value of an empty string.\n     * @param varCode A short code to help identify the variable in files;\n     * optional with a default value of \"ES2Cond\".\n     */\n    explicit DecagonES2_Cond(DecagonES2* parentSense, const char* uuid = \"\",\n                             const char* varCode = ES2_COND_DEFAULT_CODE)\n        : Variable(parentSense, (const uint8_t)ES2_COND_VAR_NUM,\n                   (uint8_t)ES2_COND_RESOLUTION, ES2_COND_VAR_NAME,\n                   ES2_COND_UNIT_NAME, varCode, uuid) {}\n    /**\n     * @brief Construct a new DecagonES2_Cond object.\n     *\n     * @note This must be tied with a parent DecagonES2 before it can be used.\n     */\n    DecagonES2_Cond()\n        : Variable((const uint8_t)ES2_COND_VAR_NUM,\n                   (uint8_t)ES2_COND_RESOLUTION, ES2_COND_VAR_NAME,\n                   ES2_COND_UNIT_NAME, ES2_COND_DEFAULT_CODE) {}\n    /**\n     * @brief Destroy the DecagonES2_Cond object - no action needed.\n     */\n    ~DecagonES2_Cond() {}\n"]]}
{"hexsha": "09ba3ffb82de7f9438a0ad27c93a7445344a4ffd", "ext": "c", "lang": "C", "content": "void readargs(int argc, char *const argv[])\n{\n    /* Wrong usage. */\n    if (argc < 3)\n    {\n        fprintf(stderr, \"Usage: %s <remote.ipv4> <remote.port>\\n\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n\n    args.remote.ipv4 = argv[1];\n    sscanf(argv[2], \"%\" SCNu16, &args.remote.port);\n}", "item_id": 3, "repo": "demikernel/turn", "file": "src/posix/src/peer.c", "last_update_at": "2022-01-03T12:35:25+00:00", "question_id": "09ba3ffb82de7f9438a0ad27c93a7445344a4ffd_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void readargs(int argc, char *const argv[])\n{\n    /* Wrong usage. */\n    if (argc < 3)\n    {\n        fprintf(stderr, \"Usage: %s <remote.ipv4> <remote.port>\\n\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n    args.remote.ipv4 = argv[1];\n    sscanf(argv[2], \"%\" SCNu16, &args.remote.port);\n"]]}
{"hexsha": "4946f0b6a7e6830f68f582798b28740cc788610e", "ext": "h", "lang": "C", "content": "static inline void\nvn_decode_VkPipelineTessellationStateCreateInfo_temp(struct vn_cs_decoder *dec, VkPipelineTessellationStateCreateInfo *val)\n{\n    VkStructureType stype;\n    vn_decode_VkStructureType(dec, &stype);\n    if (stype != VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO)\n        vn_cs_decoder_set_fatal(dec);\n\n    val->sType = stype;\n    val->pNext = vn_decode_VkPipelineTessellationStateCreateInfo_pnext_temp(dec);\n    vn_decode_VkPipelineTessellationStateCreateInfo_self_temp(dec, val);\n}", "item_id": 25, "repo": "lygstate/virglrenderer", "file": "src/venus/venus-protocol/vn_protocol_renderer_pipeline.h", "last_update_at": "2022-03-28T02:28:59+00:00", "question_id": "4946f0b6a7e6830f68f582798b28740cc788610e_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void\nvn_decode_VkPipelineTessellationStateCreateInfo_temp(struct vn_cs_decoder *dec, VkPipelineTessellationStateCreateInfo *val)\n{\n    VkStructureType stype;\n    vn_decode_VkStructureType(dec, &stype);\n    if (stype != VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO)\n        vn_cs_decoder_set_fatal(dec);\n    val->sType = stype;\n    val->pNext = vn_decode_VkPipelineTessellationStateCreateInfo_pnext_temp(dec);\n    vn_decode_VkPipelineTessellationStateCreateInfo_self_temp(dec, val);\n"]]}
{"hexsha": "7603cb9ead1dc2d03e57f80bb9b2e39880ee204e", "ext": "c", "lang": "C", "content": "static int crypto_stm32_ecb_encrypt(struct cipher_ctx *ctx,\n\t\t\t\t    struct cipher_pkt *pkt)\n{\n\tint ret;\n\n\t/* For security reasons, ECB mode should not be used to encrypt\n\t * more than one block. Use CBC mode instead.\n\t */\n\tif (pkt->in_len > 16) {\n\t\tLOG_ERR(\"Cannot encrypt more than 1 block\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = do_encrypt(ctx, pkt->in_buf, pkt->in_len, pkt->out_buf);\n\tif (ret == 0) {\n\t\tpkt->out_len = 16;\n\t}\n\n\treturn ret;\n}", "item_id": 3, "repo": "maxvankessel/zephyr", "file": "drivers/crypto/crypto_stm32.c", "last_update_at": "2022-02-22T05:57:52+00:00", "question_id": "7603cb9ead1dc2d03e57f80bb9b2e39880ee204e_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int crypto_stm32_ecb_encrypt(struct cipher_ctx *ctx,\n\t\t\t\t    struct cipher_pkt *pkt)\n{\n\tint ret;\n\t/* For security reasons, ECB mode should not be used to encrypt\n\t * more than one block. Use CBC mode instead.\n\t */\n\tif (pkt->in_len > 16) {\n\t\tLOG_ERR(\"Cannot encrypt more than 1 block\");\n\t\treturn -EINVAL;\n\t}\n\tret = do_encrypt(ctx, pkt->in_buf, pkt->in_len, pkt->out_buf);\n\tif (ret == 0) {\n\t\tpkt->out_len = 16;\n\t}\n\treturn ret;\n"]]}
{"hexsha": "5cc3ad585d405237047065d52451c61638fae716", "ext": "c", "lang": "C", "content": "static D3DCOLOR WINAPI d3drm_frame3_GetSceneBackground(IDirect3DRMFrame3 *iface)\n{\n    struct d3drm_frame *frame = impl_from_IDirect3DRMFrame3(iface);\n\n    TRACE(\"iface %p.\\n\", iface);\n\n    return frame->scenebackground;\n}", "item_id": 98, "repo": "Heersin/wine", "file": "dlls/d3drm/frame.c", "last_update_at": "2022-02-03T16:23:30+00:00", "question_id": "5cc3ad585d405237047065d52451c61638fae716_98", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static D3DCOLOR WINAPI d3drm_frame3_GetSceneBackground(IDirect3DRMFrame3 *iface)\n{\n    struct d3drm_frame *frame = impl_from_IDirect3DRMFrame3(iface);\n    TRACE(\"iface %p.\\n\", iface);\n    return frame->scenebackground;\n"]]}
{"hexsha": "30fe68b20d3f326bf07ad6496707ba7f7392a899", "ext": "c", "lang": "C", "content": "TICK_COUNTER_HANDLE tickcounter_create(void)\n{\n    TICK_COUNTER_INSTANCE* result = (TICK_COUNTER_INSTANCE*)malloc(sizeof(TICK_COUNTER_INSTANCE));\n    if (result != NULL)\n    {\n        if (!QueryPerformanceFrequency(&result->perf_freqency))\n        {\n            result->backup_time_value = time(NULL);\n            if (result->backup_time_value == INVALID_TIME_VALUE)\n            {\n                LogError(\"tickcounter failed: time return INVALID_TIME.\");\n                free(result);\n                result = NULL;\n            }\n            else\n            {\n                result->current_ms = 0;\n            }\n        }\n        else\n        {\n            if (!QueryPerformanceCounter(&result->last_perf_counter))\n            {\n                LogError(\"tickcounter failed: QueryPerformanceCounter failed %d.\", GetLastError());\n                free(result);\n                result = NULL;\n            }\n            else\n            {\n                result->backup_time_value = INVALID_TIME_VALUE;\n                result->current_ms = 0;\n            }\n        }\n    }\n    return result;\n}", "item_id": 0, "repo": "mahilleb-msft/azure-c-shared-utility", "file": "adapters/tickcounter_win32.c", "last_update_at": "2022-02-16T18:45:45+00:00", "question_id": "30fe68b20d3f326bf07ad6496707ba7f7392a899_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TICK_COUNTER_HANDLE tickcounter_create(void)\n{\n    TICK_COUNTER_INSTANCE* result = (TICK_COUNTER_INSTANCE*)malloc(sizeof(TICK_COUNTER_INSTANCE));\n    if (result != NULL)\n    {\n        if (!QueryPerformanceFrequency(&result->perf_freqency))\n        {\n            result->backup_time_value = time(NULL);\n            if (result->backup_time_value == INVALID_TIME_VALUE)\n            {\n                LogError(\"tickcounter failed: time return INVALID_TIME.\");\n                free(result);\n                result = NULL;\n            }\n            else\n            {\n                result->current_ms = 0;\n            }\n        }\n        else\n        {\n            if (!QueryPerformanceCounter(&result->last_perf_counter))\n            {\n                LogError(\"tickcounter failed: QueryPerformanceCounter failed %d.\", GetLastError());\n                free(result);\n                result = NULL;\n            }\n            else\n            {\n                result->backup_time_value = INVALID_TIME_VALUE;\n                result->current_ms = 0;\n            }\n        }\n    }\n    return result;\n"]]}
{"hexsha": "85c4eba59d334db6c43fdcdcb31f9549ad99734f", "ext": "h", "lang": "C", "content": "static inline void gpio_set_interrupt_risc1(GPIO_PinTypeDef pin, GPIO_PolTypeDef falling)\n{\n\tunsigned char\tbit = pin & 0xff;\n\tBM_SET(reg_gpio_irq_risc1_en(pin), bit);\n\treg_irq_mask |= FLD_IRQ_GPIO_RISC1_EN;\n\tif(falling){\n\t\tBM_SET(reg_gpio_pol(pin), bit);\n\t}else{\n\t\tBM_CLR(reg_gpio_pol(pin), bit);\n\t}\n}", "item_id": 1, "repo": "dckiller51/esphome-yeelight-led-screen-light-bar", "file": "Remote TLSR8368 SDK/8367_lighting/8367_lighting_V1.0.0/drivers/8231/gpio_8231.h", "last_update_at": "2022-01-26T13:42:53+00:00", "question_id": "85c4eba59d334db6c43fdcdcb31f9549ad99734f_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void gpio_set_interrupt_risc1(GPIO_PinTypeDef pin, GPIO_PolTypeDef falling)\n{\n\tunsigned char\tbit = pin & 0xff;\n\tBM_SET(reg_gpio_irq_risc1_en(pin), bit);\n\treg_irq_mask |= FLD_IRQ_GPIO_RISC1_EN;\n\tif(falling){\n\t\tBM_SET(reg_gpio_pol(pin), bit);\n\t}else{\n\t\tBM_CLR(reg_gpio_pol(pin), bit);\n\t}\n"]]}
{"hexsha": "d0452b58f888f4c8a5f95ffb89d1ae55f278b4ee", "ext": "c", "lang": "C", "content": "static void\nprintflags(U2 flags, int type)\n{\n\tstatic struct {\n\t\tchar *s;\n\t\tU2 flag;\n\t\tint type;\n\t} flagstab[] = {\n\t\t{\"ACC_PUBLIC\",       0x0001, TYPE_CLASS | TYPE_FIELD | TYPE_METHOD | TYPE_INNER },\n\t\t{\"ACC_PRIVATE\",      0x0002,              TYPE_FIELD | TYPE_METHOD | TYPE_INNER },\n\t\t{\"ACC_PROTECTED\",    0x0004,              TYPE_FIELD | TYPE_METHOD | TYPE_INNER },\n\t\t{\"ACC_STATIC\",       0x0008,              TYPE_FIELD | TYPE_METHOD | TYPE_INNER },\n\t\t{\"ACC_FINAL\",        0x0010, TYPE_CLASS | TYPE_FIELD | TYPE_METHOD | TYPE_INNER },\n\t\t{\"ACC_SUPER\",        0x0020, TYPE_CLASS                                         },\n\t\t{\"ACC_SYNCHRONIZED\", 0x0020,                           TYPE_METHOD              },\n\t\t{\"ACC_VOLATILE\",     0x0040,              TYPE_FIELD                            },\n\t\t{\"ACC_BRIDGE\",       0x0040,                           TYPE_METHOD              },\n\t\t{\"ACC_TRANSIENT\",    0x0080,              TYPE_FIELD                            },\n\t\t{\"ACC_VARARGS\",      0x0080,                           TYPE_METHOD              },\n\t\t{\"ACC_NATIVE\",       0x0100,                           TYPE_METHOD              },\n\t\t{\"ACC_INTERFACE\",    0x0200, TYPE_CLASS                            | TYPE_INNER },\n\t\t{\"ACC_ABSTRACT\",     0x0400, TYPE_CLASS              | TYPE_METHOD | TYPE_INNER },\n\t\t{\"ACC_STRICT\",       0x0800,                           TYPE_METHOD              },\n\t\t{\"ACC_SYNTHETIC\",    0x1000, TYPE_CLASS | TYPE_FIELD | TYPE_METHOD | TYPE_INNER },\n\t\t{\"ACC_ANNOTATION\",   0x2000, TYPE_CLASS                            | TYPE_INNER },\n\t\t{\"ACC_ENUM\",         0x4000, TYPE_CLASS | TYPE_FIELD               | TYPE_INNER }\n\t};\n\tint p = 0;      /* whether a flag was printed */\n\tsize_t i;\n\n\tprintf(\"flags: (0x%04X) \", flags);\n\tfor (i = 0; i < LEN(flagstab); i++) {\n\t\tif (flags & flagstab[i].flag && flagstab[i].type & type) {\n\t\t\tif (p)\n\t\t\t\tprintf(\", \");\n\t\t\tprintf(\"%s\", flagstab[i].s);\n\t\t\tp = 1;\n\t\t}\n\t}\n\tputchar('\\n');\n}", "item_id": 0, "repo": "tekknolagi/jvm", "file": "javap.c", "last_update_at": "2022-03-19T06:26:22+00:00", "question_id": "d0452b58f888f4c8a5f95ffb89d1ae55f278b4ee_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nprintflags(U2 flags, int type)\n{\n\tstatic struct {\n\t\tchar *s;\n\t\tU2 flag;\n\t\tint type;\n\t} flagstab[] = {\n\t\t{\"ACC_PUBLIC\",       0x0001, TYPE_CLASS | TYPE_FIELD | TYPE_METHOD | TYPE_INNER },\n\t\t{\"ACC_PRIVATE\",      0x0002,              TYPE_FIELD | TYPE_METHOD | TYPE_INNER },\n\t\t{\"ACC_PROTECTED\",    0x0004,              TYPE_FIELD | TYPE_METHOD | TYPE_INNER },\n\t\t{\"ACC_STATIC\",       0x0008,              TYPE_FIELD | TYPE_METHOD | TYPE_INNER },\n\t\t{\"ACC_FINAL\",        0x0010, TYPE_CLASS | TYPE_FIELD | TYPE_METHOD | TYPE_INNER },\n\t\t{\"ACC_SUPER\",        0x0020, TYPE_CLASS                                         },\n\t\t{\"ACC_SYNCHRONIZED\", 0x0020,                           TYPE_METHOD              },\n\t\t{\"ACC_VOLATILE\",     0x0040,              TYPE_FIELD                            },\n\t\t{\"ACC_BRIDGE\",       0x0040,                           TYPE_METHOD              },\n\t\t{\"ACC_TRANSIENT\",    0x0080,              TYPE_FIELD                            },\n\t\t{\"ACC_VARARGS\",      0x0080,                           TYPE_METHOD              },\n\t\t{\"ACC_NATIVE\",       0x0100,                           TYPE_METHOD              },\n\t\t{\"ACC_INTERFACE\",    0x0200, TYPE_CLASS                            | TYPE_INNER },\n\t\t{\"ACC_ABSTRACT\",     0x0400, TYPE_CLASS              | TYPE_METHOD | TYPE_INNER },\n\t\t{\"ACC_STRICT\",       0x0800,                           TYPE_METHOD              },\n\t\t{\"ACC_SYNTHETIC\",    0x1000, TYPE_CLASS | TYPE_FIELD | TYPE_METHOD | TYPE_INNER },\n\t\t{\"ACC_ANNOTATION\",   0x2000, TYPE_CLASS                            | TYPE_INNER },\n\t\t{\"ACC_ENUM\",         0x4000, TYPE_CLASS | TYPE_FIELD               | TYPE_INNER }\n\t};\n\tint p = 0;      /* whether a flag was printed */\n\tsize_t i;\n\tprintf(\"flags: (0x%04X) \", flags);\n\tfor (i = 0; i < LEN(flagstab); i++) {\n\t\tif (flags & flagstab[i].flag && flagstab[i].type & type) {\n\t\t\tif (p)\n\t\t\t\tprintf(\", \");\n\t\t\tprintf(\"%s\", flagstab[i].s);\n\t\t\tp = 1;\n\t\t}\n\t}\n\tputchar('\\n');\n"]]}
{"hexsha": "8678ec1dcbf1798ff010a7d077dad0580921042f", "ext": "c", "lang": "C", "content": "static int transmit_response_bysession(struct skinnysession *s, struct skinny_req *req)\n{\n\tint res = 0;\n\n\tif (!s) {\n\t\tast_log(LOG_WARNING, \"Asked to transmit to a non-existent session!\\n\");\n\t\treturn -1;\n\t}\n\n\tast_mutex_lock(&s->lock);\n\n\tSKINNY_DEVONLY(if (skinnydebug>1) ast_verb(4, \"Transmitting %s to %s\\n\", message2str(req->e), s->device->name);)\n\n\tif ((letohl(req->len) > SKINNY_MAX_PACKET) || (letohl(req->len) < 0)) {\n\t\tast_log(LOG_WARNING, \"transmit_response: the length of the request (%d) is out of bounds (%d)\\n\", letohl(req->len), SKINNY_MAX_PACKET);\n\t\tast_mutex_unlock(&s->lock);\n\t\treturn -1;\n\t}\n\n\tmemset(s->outbuf, 0, sizeof(s->outbuf));\n\tmemcpy(s->outbuf, req, skinny_header_size);\n\tmemcpy(s->outbuf+skinny_header_size, &req->data, letohl(req->len));\n\n\tres = write(s->fd, s->outbuf, letohl(req->len)+8);\n\t\n\tif (res != letohl(req->len)+8) {\n\t\tast_log(LOG_WARNING, \"Transmit: write only sent %d out of %d bytes: %s\\n\", res, letohl(req->len)+8, strerror(errno));\n\t\tif (res == -1) {\n\t\t\tif (skinnydebug)\n\t\t\t\tast_log(LOG_WARNING, \"Transmit: Skinny Client was lost, unregistering\\n\");\n\t\t\tskinny_unregister(NULL, s);\n\t\t}\n\t\t\n\t}\n\t\n\tast_free(req);\n\tast_mutex_unlock(&s->lock);\n\treturn 1;\n}", "item_id": 19, "repo": "CGCL-codes/VulDeePecker", "file": "CWE-399/source_files/148818/chan_skinny.c", "last_update_at": "2022-03-30T02:58:36+00:00", "question_id": "8678ec1dcbf1798ff010a7d077dad0580921042f_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int transmit_response_bysession(struct skinnysession *s, struct skinny_req *req)\n{\n\tint res = 0;\n\tif (!s) {\n\t\tast_log(LOG_WARNING, \"Asked to transmit to a non-existent session!\\n\");\n\t\treturn -1;\n\t}\n\tast_mutex_lock(&s->lock);\n\tSKINNY_DEVONLY(if (skinnydebug>1) ast_verb(4, \"Transmitting %s to %s\\n\", message2str(req->e), s->device->name);)\n\tif ((letohl(req->len) > SKINNY_MAX_PACKET) || (letohl(req->len) < 0)) {\n\t\tast_log(LOG_WARNING, \"transmit_response: the length of the request (%d) is out of bounds (%d)\\n\", letohl(req->len), SKINNY_MAX_PACKET);\n\t\tast_mutex_unlock(&s->lock);\n\t\treturn -1;\n\t}\n\tmemset(s->outbuf, 0, sizeof(s->outbuf));\n\tmemcpy(s->outbuf, req, skinny_header_size);\n\tmemcpy(s->outbuf+skinny_header_size, &req->data, letohl(req->len));\n\tres = write(s->fd, s->outbuf, letohl(req->len)+8);\n\t\n\tif (res != letohl(req->len)+8) {\n\t\tast_log(LOG_WARNING, \"Transmit: write only sent %d out of %d bytes: %s\\n\", res, letohl(req->len)+8, strerror(errno));\n\t\tif (res == -1) {\n\t\t\tif (skinnydebug)\n\t\t\t\tast_log(LOG_WARNING, \"Transmit: Skinny Client was lost, unregistering\\n\");\n\t\t\tskinny_unregister(NULL, s);\n\t\t}\n\t\t\n\t}\n\t\n\tast_free(req);\n\tast_mutex_unlock(&s->lock);\n\treturn 1;\n"]]}
{"hexsha": "d2de877435fe71f8adbde74973ec065c515fceeb", "ext": "c", "lang": "C", "content": "int readOvrParams(int fd, int * a, int * b)\n{\n    unsigned char buf[4];\n\n    if(a == NULL || b == NULL)\n        return SB_ERROR;\n\n    buf[0] = HOST_CMD_READ_OVRLIMIT;\n    buf[1] = buf[0];\n\n    writeData(fd, buf, 2);\n    readData(fd, buf, 1);\n\n    if(buf[0] != HOST_REPLY_OVRLIMIT)\n        return SB_ERROR;\n\n    readData(fd, buf+1, 3);\n\n    if(((buf[0] + buf[1] + buf[2]) & 0xFF) != buf[3])\n\t{\n\t\tprintf(\"got cs: %02x, read: %02x\\n\", (buf[0] + buf[1] + buf[2]) & 0xFF, buf[3]);\n        return SB_BADCC;\n\t}\n    *a = buf[1];\n    *b = buf[2];\n\n    return SB_OK;\n}", "item_id": 20, "repo": "robotics-at-maryland/qubo", "file": "src/vl_tortuga/drivers/src/sensorapi.c", "last_update_at": "2022-03-11T01:36:39+00:00", "question_id": "d2de877435fe71f8adbde74973ec065c515fceeb_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int readOvrParams(int fd, int * a, int * b)\n{\n    unsigned char buf[4];\n    if(a == NULL || b == NULL)\n        return SB_ERROR;\n    buf[0] = HOST_CMD_READ_OVRLIMIT;\n    buf[1] = buf[0];\n    writeData(fd, buf, 2);\n    readData(fd, buf, 1);\n    if(buf[0] != HOST_REPLY_OVRLIMIT)\n        return SB_ERROR;\n    readData(fd, buf+1, 3);\n    if(((buf[0] + buf[1] + buf[2]) & 0xFF) != buf[3])\n\t{\n\t\tprintf(\"got cs: %02x, read: %02x\\n\", (buf[0] + buf[1] + buf[2]) & 0xFF, buf[3]);\n        return SB_BADCC;\n\t}\n    *a = buf[1];\n    *b = buf[2];\n    return SB_OK;\n"]]}
{"hexsha": "12fd0a5fc91adde9d23f341e7ebd42a90636f9e3", "ext": "c", "lang": "C", "content": "void unhide_dependencies(struct data_node *deps)\n{\n\tstruct module_node *mod_node = (struct module_node *)deps->data;\n\tunhide_module(mod_node->mod, mod_node->mod_next);\n\tkfree(mod_node);\n}", "item_id": 5, "repo": "tekcellat/University", "file": "XFouth course/7th semester/CW Operating Systems/src/module_hiding.c", "last_update_at": "2022-03-08T17:47:47+00:00", "question_id": "12fd0a5fc91adde9d23f341e7ebd42a90636f9e3_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void unhide_dependencies(struct data_node *deps)\n{\n\tstruct module_node *mod_node = (struct module_node *)deps->data;\n\tunhide_module(mod_node->mod, mod_node->mod_next);\n\tkfree(mod_node);\n"]]}
{"hexsha": "a9704c3da1922d8b2f2f4c68258a2a027b0b3c2f", "ext": "c", "lang": "C", "content": "static void PrintSymbolForAddress(DWORD64 addr) {\n  /*\n   * Code adapted from Chromium's stack_trace_win.cc, in turn adapted\n   * from an MSDN example:\n   * http://msdn.microsoft.com/en-us/library/ms680578(VS.85).aspx\n   */\n  ULONG64 buffer[(sizeof(SYMBOL_INFO) +\n                  MAX_SYMBOL_NAME_LENGTH * sizeof(wchar_t) +\n                  sizeof(ULONG64) - 1) /\n                 sizeof(ULONG64)];\n  DWORD64 sym_displacement = 0;\n  PSYMBOL_INFO symbol = (PSYMBOL_INFO) buffer;\n  BOOL has_symbol;\n  memset(buffer, 0, sizeof(buffer));\n\n  SymInitialize(GetCurrentProcess(), NULL, TRUE);\n\n  symbol->SizeOfStruct = sizeof(SYMBOL_INFO);\n  symbol->MaxNameLen = MAX_SYMBOL_NAME_LENGTH - 1;\n  has_symbol = SymFromAddr(GetCurrentProcess(),\n                           addr, &sym_displacement, symbol);\n  if (has_symbol) {\n    fprintf(stderr, \"%s + 0x%x\\n\", symbol->Name, sym_displacement);\n  } else {\n    fprintf(stderr, \"<no symbol>\\n\");\n  }\n}", "item_id": 0, "repo": "zipated/src", "file": "native_client/tests/trusted_crash/crash_in_syscall/test_host.c", "last_update_at": "2022-03-31T08:39:18+00:00", "question_id": "a9704c3da1922d8b2f2f4c68258a2a027b0b3c2f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void PrintSymbolForAddress(DWORD64 addr) {\n  /*\n   * Code adapted from Chromium's stack_trace_win.cc, in turn adapted\n   * from an MSDN example:\n   * http://msdn.microsoft.com/en-us/library/ms680578(VS.85).aspx\n   */\n  ULONG64 buffer[(sizeof(SYMBOL_INFO) +\n                  MAX_SYMBOL_NAME_LENGTH * sizeof(wchar_t) +\n                  sizeof(ULONG64) - 1) /\n                 sizeof(ULONG64)];\n  DWORD64 sym_displacement = 0;\n  PSYMBOL_INFO symbol = (PSYMBOL_INFO) buffer;\n  BOOL has_symbol;\n  memset(buffer, 0, sizeof(buffer));\n  SymInitialize(GetCurrentProcess(), NULL, TRUE);\n  symbol->SizeOfStruct = sizeof(SYMBOL_INFO);\n  symbol->MaxNameLen = MAX_SYMBOL_NAME_LENGTH - 1;\n  has_symbol = SymFromAddr(GetCurrentProcess(),\n                           addr, &sym_displacement, symbol);\n  if (has_symbol) {\n    fprintf(stderr, \"%s + 0x%x\\n\", symbol->Name, sym_displacement);\n  } else {\n    fprintf(stderr, \"<no symbol>\\n\");\n  }\n"]]}
{"hexsha": "b6c546f1879525b5e321dce924f62786657bd8c7", "ext": "c", "lang": "C", "content": "int vehicle_rt_dl1_mk3_measure_time_4_pack(\n    uint8_t *dst_p,\n    const struct vehicle_rt_dl1_mk3_measure_time_4_t *src_p,\n    size_t size)\n{\n    if (size < 3u) {\n        return (-EINVAL);\n    }\n\n    memset(&dst_p[0], 0, 3);\n\n    dst_p[0] |= pack_left_shift_u32(src_p->measured_time_4, 0u, 0xffu);\n    dst_p[1] |= pack_right_shift_u32(src_p->measured_time_4, 8u, 0xffu);\n    dst_p[2] |= pack_right_shift_u32(src_p->measured_time_4, 16u, 0xffu);\n\n    return (3);\n}", "item_id": 342, "repo": "v0lker/cantools", "file": "tests/files/c_source/vehicle.c", "last_update_at": "2022-01-04T09:09:05+00:00", "question_id": "b6c546f1879525b5e321dce924f62786657bd8c7_342", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int vehicle_rt_dl1_mk3_measure_time_4_pack(\n    uint8_t *dst_p,\n    const struct vehicle_rt_dl1_mk3_measure_time_4_t *src_p,\n    size_t size)\n{\n    if (size < 3u) {\n        return (-EINVAL);\n    }\n    memset(&dst_p[0], 0, 3);\n    dst_p[0] |= pack_left_shift_u32(src_p->measured_time_4, 0u, 0xffu);\n    dst_p[1] |= pack_right_shift_u32(src_p->measured_time_4, 8u, 0xffu);\n    dst_p[2] |= pack_right_shift_u32(src_p->measured_time_4, 16u, 0xffu);\n    return (3);\n"]]}
{"hexsha": "7654c82cd3852f8c1cbd58044a7a9cc01f543e82", "ext": "c", "lang": "C", "content": "static int strdupped_cmp(const void *a, const void *b)\n{\n    char *c = *(char**)a;\n    char *d = *(char**)b;\n\n    return strcmp(c, d);\n}", "item_id": 18, "repo": "slajerek/RetroDebugger", "file": "src/Plugins/GoatTracker/gt2/asm/gt-lexyy.c", "last_update_at": "2022-03-10T20:16:03+00:00", "question_id": "7654c82cd3852f8c1cbd58044a7a9cc01f543e82_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int strdupped_cmp(const void *a, const void *b)\n{\n    char *c = *(char**)a;\n    char *d = *(char**)b;\n    return strcmp(c, d);\n"]]}
{"hexsha": "7fa60f5b7ae408b39461107954d561bc303926af", "ext": "c", "lang": "C", "content": "static void pio_irq_enable(struct pxa_ep *ep)\n{\n\tstruct pxa_udc *udc = ep->dev;\n\tint index = EPIDX(ep);\n\tu32 udcicr0 = udc_readl(udc, UDCICR0);\n\tu32 udcicr1 = udc_readl(udc, UDCICR1);\n\n\tif (index < 16)\n\t\tudc_writel(udc, UDCICR0, udcicr0 | (3 << (index * 2)));\n\telse\n\t\tudc_writel(udc, UDCICR1, udcicr1 | (3 << ((index - 16) * 2)));\n}", "item_id": 8, "repo": "Albocoder/KOOBE", "file": "s2e/source/s2e-linux-kernel/linux-4.9.3/drivers/usb/gadget/udc/pxa27x_udc.c", "last_update_at": "2022-01-16T07:19:47+00:00", "question_id": "7fa60f5b7ae408b39461107954d561bc303926af_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void pio_irq_enable(struct pxa_ep *ep)\n{\n\tstruct pxa_udc *udc = ep->dev;\n\tint index = EPIDX(ep);\n\tu32 udcicr0 = udc_readl(udc, UDCICR0);\n\tu32 udcicr1 = udc_readl(udc, UDCICR1);\n\tif (index < 16)\n\t\tudc_writel(udc, UDCICR0, udcicr0 | (3 << (index * 2)));\n\telse\n\t\tudc_writel(udc, UDCICR1, udcicr1 | (3 << ((index - 16) * 2)));\n"]]}
{"hexsha": "335b564cda044e705a7e9dd113fea50fb297f12f", "ext": "c", "lang": "C", "content": "int\nosip_message_set_header (osip_message_t * sip, const char *hname,\n\t\t\t const char *hvalue)\n{\n  osip_header_t *h;\n  int i;\n\n  if (hname == NULL)\n    return -1;\n\n  i = osip_header_init (&h);\n  if (i != 0)\n    return -1;\n\n  h->hname = (char *) osip_malloc (strlen (hname) + 1);\n\n  if (h->hname == NULL)\n    {\n      osip_header_free (h);\n      return -1;\n    }\n  osip_strncpy (h->hname, hname, strlen (hname));\n  osip_clrspace (h->hname);\n\n  if (hvalue != NULL)\n    {\t\t\t\t/* some headers can be null (\"subject:\") */\n      h->hvalue = (char *) osip_malloc (strlen (hvalue) + 1);\n      if (h->hvalue == NULL)\n\t{\n\t  osip_header_free (h);\n\t  return -1;\n\t}\n      osip_strncpy (h->hvalue, hvalue, strlen (hvalue));\n      osip_clrspace (h->hvalue);\n    }\n  else\n    h->hvalue = NULL;\n  sip->message_property = 2;\n  osip_list_add (sip->headers, h, -1);\n  return 0;\t\t\t/* ok */\n}", "item_id": 0, "repo": "Sirherobrine23/Dir819gpl_code", "file": "DIR819_v1.06/src/opensource/libosip2/libosip2-2.0.9/src/osipparser2/osip_header.c", "last_update_at": "2022-03-19T06:38:01+00:00", "question_id": "335b564cda044e705a7e9dd113fea50fb297f12f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nosip_message_set_header (osip_message_t * sip, const char *hname,\n\t\t\t const char *hvalue)\n{\n  osip_header_t *h;\n  int i;\n  if (hname == NULL)\n    return -1;\n  i = osip_header_init (&h);\n  if (i != 0)\n    return -1;\n  h->hname = (char *) osip_malloc (strlen (hname) + 1);\n  if (h->hname == NULL)\n    {\n      osip_header_free (h);\n      return -1;\n    }\n  osip_strncpy (h->hname, hname, strlen (hname));\n  osip_clrspace (h->hname);\n  if (hvalue != NULL)\n    {\t\t\t\t/* some headers can be null (\"subject:\") */\n      h->hvalue = (char *) osip_malloc (strlen (hvalue) + 1);\n      if (h->hvalue == NULL)\n\t{\n\t  osip_header_free (h);\n\t  return -1;\n\t}\n      osip_strncpy (h->hvalue, hvalue, strlen (hvalue));\n      osip_clrspace (h->hvalue);\n    }\n  else\n    h->hvalue = NULL;\n  sip->message_property = 2;\n  osip_list_add (sip->headers, h, -1);\n  return 0;\t\t\t/* ok */\n"]]}
{"hexsha": "883d73f52ef85083062edeb0cc500e67fdc19ea1", "ext": "c", "lang": "C", "content": "static void example_coap_server_thread(void *para){\n  while(wifi_is_ready_to_transceive(RTW_STA_INTERFACE) != RTW_SUCCESS){\n    printf(\"Wait for WIFI connection ...\\n\");\n    vTaskDelay(1000);\n  }\n  printf(\"\\nCoAP Server Example starts...\\n\");\n  \n  coap_context_t *ctx;\n  struct timeval tv, *timeout;\n  coap_tick_t now,obs_start,obs_wait;\n  coap_queue_t *nextpdu;\n  coap_log_t log_level = LOG_WARNING;\n  \n  coap_set_log_level(log_level);\n  \n  clock_offset = xTaskGetTickCount();\n    \n  ctx = get_context(SERVER_HOST, SERVER_PORT);\n  if (!ctx)\n  {\n    printf(\"\\n [COAP_SERVER]get_context failed \\n\");\n    goto exit;\n  }\n  \n  init_resources(ctx);\n  \n  coap_ticks(&obs_start);\n  while (!quit)\n  {    \n    nextpdu = coap_peek_next(ctx);\n    \n    coap_ticks(&now);\n    while (nextpdu && nextpdu->t <= now - ctx->sendqueue_basetime)\n    {\n      coap_retransmit(ctx, coap_pop_next(ctx));\n      nextpdu = coap_peek_next(ctx);\n    }\n\n    if (nextpdu && nextpdu->t <= COAP_RESOURCE_CHECK_TIME)\n    {\n      /* set timeout if there is a pdu to send before our automatic timeout occurs */\n      tv.tv_usec = ((nextpdu->t) % COAP_TICKS_PER_SECOND) * 1000000 / COAP_TICKS_PER_SECOND;\n      tv.tv_sec = (nextpdu->t) / COAP_TICKS_PER_SECOND;\n      timeout = &tv;\n    }\n    else\n    {\n      tv.tv_usec = 0;\n      tv.tv_sec = COAP_RESOURCE_CHECK_TIME;\n      timeout = &tv;\n    }\n    \n    coap_dispatch(ctx, (const char*)&response); /* and dispatch PDUs from receivequeue */\n\n    coap_ticks(&obs_wait);\n    if((obs_wait-obs_start)/COAP_TICKS_PER_SECOND > (timeout->tv_sec + timeout->tv_usec/10000)){\n        coap_ticks(&obs_start);\n        if (time_resource)\n        {\n            time_resource->dirty = 1;\n        }\n    }\n#ifndef WITHOUT_ASYNC\n    /* check if we have to send asynchronous responses */\n    check_async(ctx, now);\n#endif /* WITHOUT_ASYNC */\n    \n#ifndef WITHOUT_OBSERVE\n    /* check if we have to send observe notifications */\n    coap_check_notify(ctx);\n#endif /* WITHOUT_OBSERVE */\n  }\n  \nexit:\n  coap_free_context(ctx); \n  printf(\"\\nCoAP Server Example end.\\n\");\n  \n  vTaskDelete(NULL);\n}", "item_id": 8, "repo": "Ameba8195/amazon-freertos", "file": "vendors/realtek/sdk/amebaZ2/component/common/example/coap_server/example_coap_server.c", "last_update_at": "2022-01-11T07:16:52+00:00", "question_id": "883d73f52ef85083062edeb0cc500e67fdc19ea1_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void example_coap_server_thread(void *para){\n  while(wifi_is_ready_to_transceive(RTW_STA_INTERFACE) != RTW_SUCCESS){\n    printf(\"Wait for WIFI connection ...\\n\");\n    vTaskDelay(1000);\n  }\n  printf(\"\\nCoAP Server Example starts...\\n\");\n  coap_context_t *ctx;\n  struct timeval tv, *timeout;\n  coap_tick_t now,obs_start,obs_wait;\n  coap_queue_t *nextpdu;\n  coap_log_t log_level = LOG_WARNING;\n  coap_set_log_level(log_level);\n  clock_offset = xTaskGetTickCount();\n  ctx = get_context(SERVER_HOST, SERVER_PORT);\n  if (!ctx)\n  {\n    printf(\"\\n [COAP_SERVER]get_context failed \\n\");\n    goto exit;\n  }\n  init_resources(ctx);\n  coap_ticks(&obs_start);\n  while (!quit)\n  {    \n    nextpdu = coap_peek_next(ctx);\n    coap_ticks(&now);\n    while (nextpdu && nextpdu->t <= now - ctx->sendqueue_basetime)\n    {\n      coap_retransmit(ctx, coap_pop_next(ctx));\n      nextpdu = coap_peek_next(ctx);\n    }\n    if (nextpdu && nextpdu->t <= COAP_RESOURCE_CHECK_TIME)\n    {\n      /* set timeout if there is a pdu to send before our automatic timeout occurs */\n      tv.tv_usec = ((nextpdu->t) % COAP_TICKS_PER_SECOND) * 1000000 / COAP_TICKS_PER_SECOND;\n      tv.tv_sec = (nextpdu->t) / COAP_TICKS_PER_SECOND;\n      timeout = &tv;\n    }\n    else\n    {\n      tv.tv_usec = 0;\n      tv.tv_sec = COAP_RESOURCE_CHECK_TIME;\n      timeout = &tv;\n    }\n    coap_dispatch(ctx, (const char*)&response); /* and dispatch PDUs from receivequeue */\n    coap_ticks(&obs_wait);\n    if((obs_wait-obs_start)/COAP_TICKS_PER_SECOND > (timeout->tv_sec + timeout->tv_usec/10000)){\n        coap_ticks(&obs_start);\n        if (time_resource)\n        {\n            time_resource->dirty = 1;\n        }\n    }\n#ifndef WITHOUT_ASYNC\n    /* check if we have to send asynchronous responses */\n    check_async(ctx, now);\n#endif /* WITHOUT_ASYNC */\n#ifndef WITHOUT_OBSERVE\n    /* check if we have to send observe notifications */\n    coap_check_notify(ctx);\n#endif /* WITHOUT_OBSERVE */\n  }\nexit:\n  coap_free_context(ctx); \n  printf(\"\\nCoAP Server Example end.\\n\");\n  vTaskDelete(NULL);\n"]]}
{"hexsha": "c0d9c9bd97eb3fa5a324959b98747680fc9c9294", "ext": "c", "lang": "C", "content": "static void test_pack_GOPHER_LOCATION_ATTRIBUTE_TYPEW(void)\n{\n    /* GOPHER_LOCATION_ATTRIBUTE_TYPEW */\n    TEST_TYPE_SIZE   (GOPHER_LOCATION_ATTRIBUTE_TYPEW, 8)\n    TEST_TYPE_ALIGN  (GOPHER_LOCATION_ATTRIBUTE_TYPEW, 8)\n    TEST_FIELD_SIZE  (GOPHER_LOCATION_ATTRIBUTE_TYPEW, Location, 8)\n    TEST_FIELD_ALIGN (GOPHER_LOCATION_ATTRIBUTE_TYPEW, Location, 8)\n    TEST_FIELD_OFFSET(GOPHER_LOCATION_ATTRIBUTE_TYPEW, Location, 0)\n}", "item_id": 14, "repo": "Heersin/wine", "file": "dlls/wininet/tests/generated.c", "last_update_at": "2022-03-31T18:52:48+00:00", "question_id": "c0d9c9bd97eb3fa5a324959b98747680fc9c9294_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void test_pack_GOPHER_LOCATION_ATTRIBUTE_TYPEW(void)\n{\n    /* GOPHER_LOCATION_ATTRIBUTE_TYPEW */\n    TEST_TYPE_SIZE   (GOPHER_LOCATION_ATTRIBUTE_TYPEW, 8)\n    TEST_TYPE_ALIGN  (GOPHER_LOCATION_ATTRIBUTE_TYPEW, 8)\n    TEST_FIELD_SIZE  (GOPHER_LOCATION_ATTRIBUTE_TYPEW, Location, 8)\n    TEST_FIELD_ALIGN (GOPHER_LOCATION_ATTRIBUTE_TYPEW, Location, 8)\n    TEST_FIELD_OFFSET(GOPHER_LOCATION_ATTRIBUTE_TYPEW, Location, 0)\n"]]}
{"hexsha": "29f2a2b76c71e80348a4399f3171c44f3b818e17", "ext": "c", "lang": "C", "content": "DFL_FUNC uint64_t uint64_t_avx2_gather_dfl_glob_load(unsigned char* obj, unsigned char* ptr, unsigned long field_off, unsigned long field_size) { \n    // set the index vector to 0,1,2,3 \"little\" endian\n    // so that 0 is in index[0:31], ecc\n    __m256i index = _mm256_setr_epi64x(0*DFL_STRIDE, 1*DFL_STRIDE, 2*DFL_STRIDE, 3*DFL_STRIDE);\n    __m256i res   = _mm256_setzero_si256();\n\n    __m256i target    = _mm256_set1_epi64x((unsigned long) ptr);\n    __m256i increment = _mm256_set1_epi64x(4*DFL_STRIDE);\n\n    unsigned long cache_off = ((unsigned long) ptr) & (DFL_STRIDE-1uL);\n\n    unsigned char* aligned_obj = (unsigned char*)(((unsigned long)obj + field_off) & ~(DFL_STRIDE - 1));\n\n    field_size += (((unsigned long)obj + field_off) - (unsigned long)aligned_obj);\n    field_size = ((field_size + 4*DFL_STRIDE - 1) / (4*DFL_STRIDE)) * 4*DFL_STRIDE;\n    unsigned char* _end =  aligned_obj + field_size;\n\n    DEBUG(\"GLOB AVX2 LOAD: %p - size: %lu - ptr: %p - sizeof: %lu\\n\", obj, field_size, ptr, sizeof(unsigned long));\n\n    // initialize the current avx ptrs for each iteration\n    __m256i current = _mm256_set1_epi64x((unsigned long) aligned_obj + cache_off);\n    current  = _mm256_add_epi64(current, index);\n\n    for(volatile unsigned char* _ptr = aligned_obj + cache_off; _ptr < _end; _ptr = _ptr + 4*DFL_STRIDE) {\n        // the mask will select which value will get actually loaded\n        __m256i mask = _mm256_cmpeq_epi64(target, current);\n        current = _mm256_add_epi64(current, increment);\n        __m256i loaded = _mm256_i64gather_epi64(_ptr, index, 1);\n        res = _mm256_blendv_epi8(res, loaded, mask);\n    }\n    return mm256_hadd_to_64(res);\n}", "item_id": 5, "repo": "pietroborrello/constantine", "file": "src/lib/dfl/dfl.c", "last_update_at": "2022-03-24T20:11:10+00:00", "question_id": "29f2a2b76c71e80348a4399f3171c44f3b818e17_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["DFL_FUNC uint64_t uint64_t_avx2_gather_dfl_glob_load(unsigned char* obj, unsigned char* ptr, unsigned long field_off, unsigned long field_size) { \n    // set the index vector to 0,1,2,3 \"little\" endian\n    // so that 0 is in index[0:31], ecc\n    __m256i index = _mm256_setr_epi64x(0*DFL_STRIDE, 1*DFL_STRIDE, 2*DFL_STRIDE, 3*DFL_STRIDE);\n    __m256i res   = _mm256_setzero_si256();\n    __m256i target    = _mm256_set1_epi64x((unsigned long) ptr);\n    __m256i increment = _mm256_set1_epi64x(4*DFL_STRIDE);\n    unsigned long cache_off = ((unsigned long) ptr) & (DFL_STRIDE-1uL);\n    unsigned char* aligned_obj = (unsigned char*)(((unsigned long)obj + field_off) & ~(DFL_STRIDE - 1));\n    field_size += (((unsigned long)obj + field_off) - (unsigned long)aligned_obj);\n    field_size = ((field_size + 4*DFL_STRIDE - 1) / (4*DFL_STRIDE)) * 4*DFL_STRIDE;\n    unsigned char* _end =  aligned_obj + field_size;\n    DEBUG(\"GLOB AVX2 LOAD: %p - size: %lu - ptr: %p - sizeof: %lu\\n\", obj, field_size, ptr, sizeof(unsigned long));\n    // initialize the current avx ptrs for each iteration\n    __m256i current = _mm256_set1_epi64x((unsigned long) aligned_obj + cache_off);\n    current  = _mm256_add_epi64(current, index);\n    for(volatile unsigned char* _ptr = aligned_obj + cache_off; _ptr < _end; _ptr = _ptr + 4*DFL_STRIDE) {\n        // the mask will select which value will get actually loaded\n        __m256i mask = _mm256_cmpeq_epi64(target, current);\n        current = _mm256_add_epi64(current, increment);\n        __m256i loaded = _mm256_i64gather_epi64(_ptr, index, 1);\n        res = _mm256_blendv_epi8(res, loaded, mask);\n    }\n    return mm256_hadd_to_64(res);\n"]]}
{"hexsha": "8828ad23a67ea055658bce426031230854cf7bac", "ext": "h", "lang": "C", "content": "class EcalPerEvtLaserAnalyzer : public edm::EDAnalyzer {\npublic:\n  explicit EcalPerEvtLaserAnalyzer(const edm::ParameterSet &iConfig);\n  ~EcalPerEvtLaserAnalyzer() override;\n\n  void analyze(const edm::Event &e, const edm::EventSetup &c) override;\n  void beginJob() override;\n  void endJob() override;\n\n  enum VarCol { iBlue, iRed, nColor };\n\nprivate:\n  int iEvent;\n\n  // Framework parameters\n\n  unsigned int _nsamples;\n  unsigned int _presample;\n  unsigned int _firstsample;\n  unsigned int _lastsample;\n  unsigned int _samplemin;\n  unsigned int _samplemax;\n  unsigned int _nsamplesPN;\n  unsigned int _presamplePN;\n  unsigned int _firstsamplePN;\n  unsigned int _lastsamplePN;\n  unsigned int _timingcutlow;\n  unsigned int _timingcuthigh;\n  unsigned int _niter;\n  int _fedid;\n  unsigned int _tower;\n  unsigned int _channel;\n  std::string _ecalPart;\n\n  std::string resdir_;\n  std::string refalphabeta_;\n  std::string digiCollection_;\n  std::string digiPNCollection_;\n  std::string digiProducer_;\n  std::string eventHeaderCollection_;\n  std::string eventHeaderProducer_;\n\n  // Output file names\n\n  std::string alphafile;\n  std::string ADCfile;\n  std::string APDfile;\n  std::string resfile;\n\n  //  Define geometrical constants\n  //  Default values correspond to \"EB\" geometry (1700 crystals)\n\n  unsigned int nCrys;\n  unsigned int nTT;\n  unsigned int nSides;\n\n  int IsFileCreated;\n\n  // Define number of channels (68 or 1700) for alpha and beta calculation\n\n  unsigned int nCh;\n\n  // Identify run type\n\n  int runType;\n  int runNum;\n  int dccID;\n  int fedID;\n  int lightside;\n\n  int channelNumber;\n\n  std::vector<int> colors;\n\n  // Temporary root files and trees\n  TFile *matacqFile;\n  TTree *matacqTree;\n\n  TFile *ADCFile;\n  TTree *ADCtrees;\n\n  TFile *APDFile;\n  TTree *header[2];\n  TTree *APDtrees;\n\n  int doesRefFileExist;\n  int IsThereDataADC[nColor];\n  int IsHeaderFilled[nColor];\n\n  double ttMat, peakMat, peak;\n  int evtMat, colMat;\n\n  // Declaration of leaves types for temporary trees\n\n  int phi, eta;\n  int event;\n  int color;\n  double adc[10];\n  int adcG[10];\n  double tt;\n  double ttrig;\n  double pn0, pn1;\n  double pn[50];\n  double apdAmpl;\n  double apdTime;\n  double pnAmpl;\n}", "item_id": 0, "repo": "ckamtsikis/cmssw", "file": "CalibCalorimetry/EcalLaserAnalyzer/plugins/EcalPerEvtLaserAnalyzer.h", "last_update_at": "2022-02-08T16:11:30+00:00", "question_id": "8828ad23a67ea055658bce426031230854cf7bac_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class EcalPerEvtLaserAnalyzer : public edm::EDAnalyzer {\npublic:\n  explicit EcalPerEvtLaserAnalyzer(const edm::ParameterSet &iConfig);\n  ~EcalPerEvtLaserAnalyzer() override;\n  void analyze(const edm::Event &e, const edm::EventSetup &c) override;\n  void beginJob() override;\n  void endJob() override;\n  enum VarCol { iBlue, iRed, nColor };\nprivate:\n  int iEvent;\n  // Framework parameters\n  unsigned int _nsamples;\n  unsigned int _presample;\n  unsigned int _firstsample;\n  unsigned int _lastsample;\n  unsigned int _samplemin;\n  unsigned int _samplemax;\n  unsigned int _nsamplesPN;\n  unsigned int _presamplePN;\n  unsigned int _firstsamplePN;\n  unsigned int _lastsamplePN;\n  unsigned int _timingcutlow;\n  unsigned int _timingcuthigh;\n  unsigned int _niter;\n  int _fedid;\n  unsigned int _tower;\n  unsigned int _channel;\n  std::string _ecalPart;\n  std::string resdir_;\n  std::string refalphabeta_;\n  std::string digiCollection_;\n  std::string digiPNCollection_;\n  std::string digiProducer_;\n  std::string eventHeaderCollection_;\n  std::string eventHeaderProducer_;\n  // Output file names\n  std::string alphafile;\n  std::string ADCfile;\n  std::string APDfile;\n  std::string resfile;\n  //  Define geometrical constants\n  //  Default values correspond to \"EB\" geometry (1700 crystals)\n  unsigned int nCrys;\n  unsigned int nTT;\n  unsigned int nSides;\n  int IsFileCreated;\n  // Define number of channels (68 or 1700) for alpha and beta calculation\n  unsigned int nCh;\n  // Identify run type\n  int runType;\n  int runNum;\n  int dccID;\n  int fedID;\n  int lightside;\n  int channelNumber;\n  std::vector<int> colors;\n  // Temporary root files and trees\n  TFile *matacqFile;\n  TTree *matacqTree;\n  TFile *ADCFile;\n  TTree *ADCtrees;\n  TFile *APDFile;\n  TTree *header[2];\n  TTree *APDtrees;\n  int doesRefFileExist;\n  int IsThereDataADC[nColor];\n  int IsHeaderFilled[nColor];\n  double ttMat, peakMat, peak;\n  int evtMat, colMat;\n  // Declaration of leaves types for temporary trees\n  int phi, eta;\n  int event;\n  int color;\n  double adc[10];\n  int adcG[10];\n  double tt;\n  double ttrig;\n  double pn0, pn1;\n  double pn[50];\n  double apdAmpl;\n  double apdTime;\n  double pnAmpl;\n"]]}
{"hexsha": "fdb0b4a3dbe5bef9cf7a9f226a93f3479c2e870c", "ext": "c", "lang": "C", "content": "static int\nmch_call_shell_fork(\n    char_u *cmd,\n    int options) /* SHELL_*, see vim.h */\n{\n  int tmode = cur_tmode;\n  pid_t pid;\n  pid_t wpid = 0;\n  pid_t wait_pid = 0;\n#ifdef HAVE_UNION_WAIT\n  union wait status;\n#else\n  int status = -1;\n#endif\n  int retval = -1;\n  char **argv = NULL;\n  char_u *tofree1 = NULL;\n  char_u *tofree2 = NULL;\n  int i;\n  int pty_master_fd = -1; /* for pty's */\n  int fd_toshell[2];      /* for pipes */\n  int fd_fromshell[2];\n  int pipe_error = FALSE;\n  int did_settmode = FALSE; /* settmode(TMODE_RAW) called */\n\n  if (options & SHELL_COOKED)\n    settmode(TMODE_COOK); /* set to normal mode */\n\n  if (build_argv(cmd, &argv, &tofree1, &tofree2) == FAIL)\n    goto error;\n\n  /*\n     * For the GUI, when writing the output into the buffer and when reading\n     * input from the buffer: Try using a pseudo-tty to get the stdin/stdout\n     * of the executed command into the Vim window.  Or use a pipe.\n     */\n  if ((options & (SHELL_READ | SHELL_WRITE)))\n  {\n    pipe_error = (pipe(fd_toshell) < 0);\n    if (!pipe_error) /* pipe create OK */\n    {\n      pipe_error = (pipe(fd_fromshell) < 0);\n      if (pipe_error) /* pipe create failed */\n      {\n        close(fd_toshell[0]);\n        close(fd_toshell[1]);\n      }\n    }\n    if (pipe_error)\n    {\n      msg_puts(_(\"\\nCannot create pipes\\n\"));\n    }\n  }\n\n  if (!pipe_error) /* pty or pipe opened or not used */\n  {\n    SIGSET_DECL(curset)\n\n#ifdef __BEOS__\n    beos_cleanup_read_thread();\n#endif\n\n    BLOCK_SIGNALS(&curset);\n    pid = fork(); /* maybe we should use vfork() */\n    if (pid == -1)\n    {\n      UNBLOCK_SIGNALS(&curset);\n\n      msg_puts(_(\"\\nCannot fork\\n\"));\n      if ((options & (SHELL_READ | SHELL_WRITE)))\n      {\n\n        close(fd_toshell[0]);\n        close(fd_toshell[1]);\n        close(fd_fromshell[0]);\n        close(fd_fromshell[1]);\n      }\n    }\n    else if (pid == 0) /* child */\n    {\n      reset_signals(); /* handle signals normally */\n      UNBLOCK_SIGNALS(&curset);\n\n#ifdef FEAT_JOB_CHANNEL\n      if (ch_log_active())\n        /* close the log file in the child */\n        ch_logfile((char_u *)\"\", (char_u *)\"\");\n#endif\n\n      if (!show_shell_mess || (options & SHELL_EXPAND))\n      {\n        int fd;\n\n        /*\n\t\t * Don't want to show any message from the shell.  Can't just\n\t\t * close stdout and stderr though, because some systems will\n\t\t * break if you try to write to them after that, so we must\n\t\t * use dup() to replace them with something else -- webb\n\t\t * Connect stdin to /dev/null too, so \":n `cat`\" doesn't hang,\n\t\t * waiting for input.\n\t\t */\n        fd = open(\"/dev/null\", O_RDWR | O_EXTRA, 0);\n        fclose(stdin);\n        fclose(stdout);\n        fclose(stderr);\n\n        /*\n\t\t * If any of these open()'s and dup()'s fail, we just continue\n\t\t * anyway.  It's not fatal, and on most systems it will make\n\t\t * no difference at all.  On a few it will cause the execvp()\n\t\t * to exit with a non-zero status even when the completion\n\t\t * could be done, which is nothing too serious.  If the open()\n\t\t * or dup() failed we'd just do the same thing ourselves\n\t\t * anyway -- webb\n\t\t */\n        if (fd >= 0)\n        {\n          vim_ignored = dup(fd); /* To replace stdin  (fd 0) */\n          vim_ignored = dup(fd); /* To replace stdout (fd 1) */\n          vim_ignored = dup(fd); /* To replace stderr (fd 2) */\n\n          /* Don't need this now that we've duplicated it */\n          close(fd);\n        }\n      }\n      else if ((options & (SHELL_READ | SHELL_WRITE)))\n      {\n\n#ifdef HAVE_SETSID\n        /* Create our own process group, so that the child and all its\n\t\t * children can be kill()ed.  Don't do this when using pipes,\n\t\t * because stdin is not a tty, we would lose /dev/tty. */\n        if (p_stmp)\n        {\n          (void)setsid();\n#if defined(SIGHUP)\n          /* When doing \"!xterm&\" and 'shell' is bash: the shell\n\t\t     * will exit and send SIGHUP to all processes in its\n\t\t     * group, killing the just started process.  Ignore SIGHUP\n\t\t     * to avoid that. (suggested by Simon Schubert)\n\t\t     */\n          signal(SIGHUP, SIG_IGN);\n#endif\n        }\n#endif\n        set_default_child_environment(FALSE);\n\n        /*\n\t\t * stderr is only redirected when using the GUI, so that a\n\t\t * program like gpg can still access the terminal to get a\n\t\t * passphrase using stderr.\n\t\t */\n\n        /* set up stdin for the child */\n        close(fd_toshell[1]);\n        close(0);\n        vim_ignored = dup(fd_toshell[0]);\n        close(fd_toshell[0]);\n\n        /* set up stdout for the child */\n        close(fd_fromshell[0]);\n        close(1);\n        vim_ignored = dup(fd_fromshell[1]);\n        close(fd_fromshell[1]);\n      }\n\n      /*\n\t     * There is no type cast for the argv, because the type may be\n\t     * different on different machines. This may cause a warning\n\t     * message with strict compilers, don't worry about it.\n\t     * Call _exit() instead of exit() to avoid closing the connection\n\t     * to the X server (esp. with GTK, which uses atexit()).\n\t     */\n      execvp(argv[0], argv);\n      _exit(EXEC_FAILED); /* exec failed, return failure code */\n    }\n    else /* parent */\n    {\n      /*\n\t     * While child is running, ignore terminating signals.\n\t     * Do catch CTRL-C, so that \"got_int\" is set.\n\t     */\n      catch_signals(SIG_IGN, SIG_ERR);\n      catch_int_signal();\n      UNBLOCK_SIGNALS(&curset);\n#ifdef FEAT_JOB_CHANNEL\n      ++dont_check_job_ended;\n#endif\n      /*\n\t     * For the GUI we redirect stdin, stdout and stderr to our window.\n\t     * This is also used to pipe stdin/stdout to/from the external\n\t     * command.\n\t     */\n      if ((options & (SHELL_READ | SHELL_WRITE)))\n      {\n#define BUFLEN 100 /* length for buffer, pseudo tty limit is 128 */\n        char_u buffer[BUFLEN + 1];\n        int buffer_off = 0;        /* valid bytes in buffer[] */\n        char_u ta_buf[BUFLEN + 1]; /* TypeAHead */\n        int ta_len = 0;            /* valid bytes in ta_buf[] */\n        int len;\n        int p_more_save;\n        int old_State;\n        int c;\n        int toshell_fd;\n        int fromshell_fd;\n        garray_T ga;\n        int noread_cnt;\n#ifdef ELAPSED_FUNC\n        elapsed_T start_tv;\n#endif\n\n        close(fd_toshell[0]);\n        close(fd_fromshell[1]);\n        toshell_fd = fd_toshell[1];\n        fromshell_fd = fd_fromshell[0];\n\n        /*\n\t\t * Write to the child if there are typed characters.\n\t\t * Read from the child if there are characters available.\n\t\t *   Repeat the reading a few times if more characters are\n\t\t *   available. Need to check for typed keys now and then, but\n\t\t *   not too often (delays when no chars are available).\n\t\t * This loop is quit if no characters can be read from the pty\n\t\t * (WaitForChar detected special condition), or there are no\n\t\t * characters available and the child has exited.\n\t\t * Only check if the child has exited when there is no more\n\t\t * output. The child may exit before all the output has\n\t\t * been printed.\n\t\t *\n\t\t * Currently this busy loops!\n\t\t * This can probably dead-lock when the write blocks!\n\t\t */\n        p_more_save = p_more;\n        p_more = FALSE;\n        old_State = State;\n        State = EXTERNCMD; /* don't redraw at window resize */\n\n        if ((options & SHELL_WRITE) && toshell_fd >= 0)\n        {\n          /* Fork a process that will write the lines to the\n\t\t     * external program. */\n          if ((wpid = fork()) == -1)\n          {\n            msg_puts(_(\"\\nCannot fork\\n\"));\n          }\n          else if (wpid == 0) /* child */\n          {\n            linenr_T lnum = curbuf->b_op_start.lnum;\n            int written = 0;\n            char_u *lp = ml_get(lnum);\n            size_t l;\n\n            close(fromshell_fd);\n            for (;;)\n            {\n              l = STRLEN(lp + written);\n              if (l == 0)\n                len = 0;\n              else if (lp[written] == NL)\n                /* NL -> NUL translation */\n                len = write(toshell_fd, \"\", (size_t)1);\n              else\n              {\n                char_u *s = vim_strchr(lp + written, NL);\n\n                len = write(toshell_fd, (char *)lp + written,\n                            s == NULL ? l\n                                      : (size_t)(s - (lp + written)));\n              }\n              if (len == (int)l)\n              {\n                /* Finished a line, add a NL, unless this line\n\t\t\t\t * should not have one. */\n                if (lnum != curbuf->b_op_end.lnum || (!curbuf->b_p_bin && curbuf->b_p_fixeol) || (lnum != curbuf->b_no_eol_lnum && (lnum != curbuf->b_ml.ml_line_count || curbuf->b_p_eol)))\n                  vim_ignored = write(toshell_fd, \"\\n\",\n                                      (size_t)1);\n                ++lnum;\n                if (lnum > curbuf->b_op_end.lnum)\n                {\n                  /* finished all the lines, close pipe */\n                  close(toshell_fd);\n                  toshell_fd = -1;\n                  break;\n                }\n                lp = ml_get(lnum);\n                written = 0;\n              }\n              else if (len > 0)\n                written += len;\n            }\n            _exit(0);\n          }\n          else /* parent */\n          {\n            close(toshell_fd);\n            toshell_fd = -1;\n          }\n        }\n\n        if (options & SHELL_READ)\n          ga_init2(&ga, 1, BUFLEN);\n\n        noread_cnt = 0;\n#ifdef ELAPSED_FUNC\n        ELAPSED_INIT(start_tv);\n#endif\n        for (;;)\n        {\n          /*\n\t\t     * Check if keys have been typed, write them to the child\n\t\t     * if there are any.\n\t\t     * Don't do this if we are expanding wild cards (would eat\n\t\t     * typeahead).\n\t\t     * Don't do this when filtering and terminal is in cooked\n\t\t     * mode, the shell command will handle the I/O.  Avoids\n\t\t     * that a typed password is echoed for ssh or gpg command.\n\t\t     * Don't get characters when the child has already\n\t\t     * finished (wait_pid == 0).\n\t\t     * Don't read characters unless we didn't get output for a\n\t\t     * while (noread_cnt > 4), avoids that \":r !ls\" eats\n\t\t     * typeahead.\n\t\t     */\n          len = 0;\n          if (!(options & SHELL_EXPAND) && ((options & (SHELL_READ | SHELL_WRITE | SHELL_COOKED)) != (SHELL_READ | SHELL_WRITE | SHELL_COOKED)) &&\n              wait_pid == 0 && (ta_len > 0 || noread_cnt > 4))\n          {\n            if (ta_len == 0)\n            {\n              /* Get extra characters when we don't have any.\n\t\t\t   * Reset the counter and timer. */\n              noread_cnt = 0;\n#ifdef ELAPSED_FUNC\n              ELAPSED_INIT(start_tv);\n#endif\n              len = ui_inchar(ta_buf, BUFLEN, 10L, 0);\n            }\n            if (ta_len > 0 || len > 0)\n            {\n              /*\n\t\t\t * For pipes:\n\t\t\t * Check for CTRL-C: send interrupt signal to child.\n\t\t\t * Check for CTRL-D: EOF, close pipe to child.\n\t\t\t */\n              if (len == 1 && (pty_master_fd < 0 || cmd != NULL))\n              {\n                /*\n\t\t\t     * Send SIGINT to the child's group or all\n\t\t\t     * processes in our group.\n\t\t\t     */\n                may_send_sigint(ta_buf[ta_len], pid, wpid);\n\n                if (pty_master_fd < 0 && toshell_fd >= 0 && ta_buf[ta_len] == Ctrl_D)\n                {\n                  close(toshell_fd);\n                  toshell_fd = -1;\n                }\n              }\n\n              /* replace K_BS by <BS> and K_DEL by <DEL> */\n              for (i = ta_len; i < ta_len + len; ++i)\n              {\n                if (ta_buf[i] == CSI && len - i > 2)\n                {\n                  c = TERMCAP2KEY(ta_buf[i + 1], ta_buf[i + 2]);\n                  if (c == K_DEL || c == K_KDEL || c == K_BS)\n                  {\n                    mch_memmove(ta_buf + i + 1, ta_buf + i + 3,\n                                (size_t)(len - i - 2));\n                    if (c == K_DEL || c == K_KDEL)\n                      ta_buf[i] = DEL;\n                    else\n                      ta_buf[i] = Ctrl_H;\n                    len -= 2;\n                  }\n                }\n                else if (ta_buf[i] == '\\r')\n                  ta_buf[i] = '\\n';\n                if (has_mbyte)\n                  i += (*mb_ptr2len_len)(ta_buf + i,\n                                         ta_len + len - i) -\n                       1;\n              }\n\n              /*\n\t\t\t * For pipes: echo the typed characters.\n\t\t\t * For a pty this does not seem to work.\n\t\t\t */\n              if (pty_master_fd < 0)\n              {\n                for (i = ta_len; i < ta_len + len; ++i)\n                {\n                  if (ta_buf[i] == '\\n' || ta_buf[i] == '\\b')\n                    msg_putchar(ta_buf[i]);\n                  else if (has_mbyte)\n                  {\n                    int l = (*mb_ptr2len)(ta_buf + i);\n\n                    msg_outtrans_len(ta_buf + i, l);\n                    i += l - 1;\n                  }\n                  else\n                    msg_outtrans_len(ta_buf + i, 1);\n                }\n                windgoto(msg_row, msg_col);\n              }\n\n              ta_len += len;\n\n              /*\n\t\t\t * Write the characters to the child, unless EOF has\n\t\t\t * been typed for pipes.  Write one character at a\n\t\t\t * time, to avoid losing too much typeahead.\n\t\t\t * When writing buffer lines, drop the typed\n\t\t\t * characters (only check for CTRL-C).\n\t\t\t */\n              if (options & SHELL_WRITE)\n                ta_len = 0;\n              else if (toshell_fd >= 0)\n              {\n                len = write(toshell_fd, (char *)ta_buf, (size_t)1);\n                if (len > 0)\n                {\n                  ta_len -= len;\n                  mch_memmove(ta_buf, ta_buf + len, ta_len);\n                }\n              }\n            }\n          }\n\n          if (got_int)\n          {\n            /* CTRL-C sends a signal to the child, we ignore it\n\t\t\t * ourselves */\n#ifdef HAVE_SETSID\n            kill(-pid, SIGINT);\n#else\n            kill(0, SIGINT);\n#endif\n            if (wpid > 0)\n              kill(wpid, SIGINT);\n            got_int = FALSE;\n          }\n\n          /*\n\t\t     * Check if the child has any characters to be printed.\n\t\t     * Read them and write them to our window.\tRepeat this as\n\t\t     * long as there is something to do, avoid the 10ms wait\n\t\t     * for mch_inchar(), or sending typeahead characters to\n\t\t     * the external process.\n\t\t     * TODO: This should handle escape sequences, compatible\n\t\t     * to some terminal (vt52?).\n\t\t     */\n          ++noread_cnt;\n          while (RealWaitForChar(fromshell_fd, 10L, NULL, NULL))\n          {\n            len = read_eintr(fromshell_fd, buffer + buffer_off, (size_t)(BUFLEN - buffer_off));\n            if (len <= 0) /* end of file or error */\n              goto finished;\n\n            noread_cnt = 0;\n            if (options & SHELL_READ)\n            {\n              /* Do NUL -> NL translation, append NL separated\n\t\t\t     * lines to the current buffer. */\n              for (i = 0; i < len; ++i)\n              {\n                if (buffer[i] == NL)\n                  append_ga_line(&ga);\n                else if (buffer[i] == NUL)\n                  ga_append(&ga, NL);\n                else\n                  ga_append(&ga, buffer[i]);\n              }\n            }\n            else if (has_mbyte)\n            {\n              int l;\n              char_u *p;\n\n              len += buffer_off;\n              buffer[len] = NUL;\n\n              /* Check if the last character in buffer[] is\n\t\t\t     * incomplete, keep these bytes for the next\n\t\t\t     * round. */\n              for (p = buffer; p < buffer + len; p += l)\n              {\n                l = MB_CPTR2LEN(p);\n                if (l == 0)\n                  l = 1; /* NUL byte? */\n                else if (MB_BYTE2LEN(*p) != l)\n                  break;\n              }\n              if (p == buffer) /* no complete character */\n              {\n                /* avoid getting stuck at an illegal byte */\n                if (len >= 12)\n                  ++p;\n                else\n                {\n                  buffer_off = len;\n                  continue;\n                }\n              }\n              c = *p;\n              *p = NUL;\n              msg_puts((char *)buffer);\n              if (p < buffer + len)\n              {\n                *p = c;\n                buffer_off = (buffer + len) - p;\n                mch_memmove(buffer, p, buffer_off);\n                continue;\n              }\n              buffer_off = 0;\n            }\n            else\n            {\n              buffer[len] = NUL;\n              msg_puts((char *)buffer);\n            }\n\n            windgoto(msg_row, msg_col);\n            cursor_on();\n            if (got_int)\n              break;\n\n#ifdef ELAPSED_FUNC\n            if (wait_pid == 0)\n            {\n              long msec = ELAPSED_FUNC(start_tv);\n\n              /* Avoid that we keep looping here without\n\t\t\t     * checking for a CTRL-C for a long time.  Don't\n\t\t\t     * break out too often to avoid losing typeahead. */\n              if (msec > 2000)\n              {\n                noread_cnt = 5;\n                break;\n              }\n            }\n#endif\n          }\n\n          /* If we already detected the child has finished, continue\n\t\t     * reading output for a short while.  Some text may be\n\t\t     * buffered. */\n          if (wait_pid == pid)\n          {\n            if (noread_cnt < 5)\n              continue;\n            break;\n          }\n\n          /*\n\t\t     * Check if the child still exists, before checking for\n\t\t     * typed characters (otherwise we would lose typeahead).\n\t\t     */\n#ifdef __NeXT__\n          wait_pid = wait4(pid, &status, WNOHANG, (struct rusage *)0);\n#else\n          wait_pid = waitpid(pid, &status, WNOHANG);\n#endif\n          if ((wait_pid == (pid_t)-1 && errno == ECHILD) || (wait_pid == pid && WIFEXITED(status)))\n          {\n            /* Don't break the loop yet, try reading more\n\t\t\t * characters from \"fromshell_fd\" first.  When using\n\t\t\t * pipes there might still be something to read and\n\t\t\t * then we'll break the loop at the \"break\" above. */\n            wait_pid = pid;\n          }\n          else\n            wait_pid = 0;\n\n#if defined(FEAT_XCLIPBOARD) && defined(FEAT_X11)\n          /* Handle any X events, e.g. serving the clipboard. */\n          clip_update();\n#endif\n        }\n      finished:\n        p_more = p_more_save;\n        if (options & SHELL_READ)\n        {\n          if (ga.ga_len > 0)\n          {\n            append_ga_line(&ga);\n            /* remember that the NL was missing */\n            curbuf->b_no_eol_lnum = curwin->w_cursor.lnum;\n          }\n          else\n            curbuf->b_no_eol_lnum = 0;\n          ga_clear(&ga);\n        }\n\n        /*\n\t\t * Give all typeahead that wasn't used back to ui_inchar().\n\t\t */\n        if (ta_len)\n          ui_inchar_undo(ta_buf, ta_len);\n        State = old_State;\n        if (toshell_fd >= 0)\n          close(toshell_fd);\n        close(fromshell_fd);\n      }\n#if defined(FEAT_XCLIPBOARD) && defined(FEAT_X11)\n      else\n      {\n        long delay_msec = 1;\n\n        /*\n\t\t * Similar to the loop above, but only handle X events, no\n\t\t * I/O.\n\t\t */\n        for (;;)\n        {\n          if (got_int)\n          {\n            /* CTRL-C sends a signal to the child, we ignore it\n\t\t\t * ourselves */\n#ifdef HAVE_SETSID\n            kill(-pid, SIGINT);\n#else\n            kill(0, SIGINT);\n#endif\n            got_int = FALSE;\n          }\n#ifdef __NeXT__\n          wait_pid = wait4(pid, &status, WNOHANG, (struct rusage *)0);\n#else\n          wait_pid = waitpid(pid, &status, WNOHANG);\n#endif\n          if ((wait_pid == (pid_t)-1 && errno == ECHILD) || (wait_pid == pid && WIFEXITED(status)))\n          {\n            wait_pid = pid;\n            break;\n          }\n\n          /* Handle any X events, e.g. serving the clipboard. */\n          clip_update();\n\n          /* Wait for 1 to 10 msec. 1 is faster but gives the child\n\t\t     * less time. */\n          mch_delay(delay_msec, TRUE);\n          if (++delay_msec > 10)\n            delay_msec = 10;\n        }\n      }\n#endif\n\n      /*\n\t     * Wait until our child has exited.\n\t     * Ignore wait() returning pids of other children and returning\n\t     * because of some signal like SIGWINCH.\n\t     * Don't wait if wait_pid was already set above, indicating the\n\t     * child already exited.\n\t     */\n      if (wait_pid != pid)\n        wait_pid = wait4pid(pid, &status);\n\n      /* Make sure the child that writes to the external program is\n\t     * dead. */\n      if (wpid > 0)\n      {\n        kill(wpid, SIGKILL);\n        wait4pid(wpid, NULL);\n      }\n\n#ifdef FEAT_JOB_CHANNEL\n      --dont_check_job_ended;\n#endif\n\n      /*\n\t     * Set to raw mode right now, otherwise a CTRL-C after\n\t     * catch_signals() will kill Vim.\n\t     */\n      if (tmode == TMODE_RAW)\n        settmode(TMODE_RAW);\n      did_settmode = TRUE;\n      set_signals();\n\n      if (WIFEXITED(status))\n      {\n        /* LINTED avoid \"bitwise operation on signed value\" */\n        retval = WEXITSTATUS(status);\n        if (retval != 0 && !emsg_silent)\n        {\n          if (retval == EXEC_FAILED)\n          {\n            msg_puts(_(\"\\nCannot execute shell \"));\n            msg_outtrans(p_sh);\n            msg_putchar('\\n');\n          }\n          else if (!(options & SHELL_SILENT))\n          {\n            msg_puts(_(\"\\nshell returned \"));\n            msg_outnum((long)retval);\n            msg_putchar('\\n');\n          }\n        }\n      }\n      else\n        msg_puts(_(\"\\nCommand terminated\\n\"));\n    }\n  }\n\nerror:\n  if (!did_settmode)\n    if (tmode == TMODE_RAW)\n      settmode(TMODE_RAW); /* set to raw mode */\n  vim_free(argv);\n  vim_free(tofree1);\n  vim_free(tofree2);\n\n  return retval;\n}", "item_id": 49, "repo": "titanous/libvim", "file": "src/os_unix.c", "last_update_at": "2022-03-31T19:37:58+00:00", "question_id": "fdb0b4a3dbe5bef9cf7a9f226a93f3479c2e870c_49", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nmch_call_shell_fork(\n    char_u *cmd,\n    int options) /* SHELL_*, see vim.h */\n{\n  int tmode = cur_tmode;\n  pid_t pid;\n  pid_t wpid = 0;\n  pid_t wait_pid = 0;\n#ifdef HAVE_UNION_WAIT\n  union wait status;\n#else\n  int status = -1;\n#endif\n  int retval = -1;\n  char **argv = NULL;\n  char_u *tofree1 = NULL;\n  char_u *tofree2 = NULL;\n  int i;\n  int pty_master_fd = -1; /* for pty's */\n  int fd_toshell[2];      /* for pipes */\n  int fd_fromshell[2];\n  int pipe_error = FALSE;\n  int did_settmode = FALSE; /* settmode(TMODE_RAW) called */\n  if (options & SHELL_COOKED)\n    settmode(TMODE_COOK); /* set to normal mode */\n  if (build_argv(cmd, &argv, &tofree1, &tofree2) == FAIL)\n    goto error;\n  /*\n     * For the GUI, when writing the output into the buffer and when reading\n     * input from the buffer: Try using a pseudo-tty to get the stdin/stdout\n     * of the executed command into the Vim window.  Or use a pipe.\n     */\n  if ((options & (SHELL_READ | SHELL_WRITE)))\n  {\n    pipe_error = (pipe(fd_toshell) < 0);\n    if (!pipe_error) /* pipe create OK */\n    {\n      pipe_error = (pipe(fd_fromshell) < 0);\n      if (pipe_error) /* pipe create failed */\n      {\n        close(fd_toshell[0]);\n        close(fd_toshell[1]);\n      }\n    }\n    if (pipe_error)\n    {\n      msg_puts(_(\"\\nCannot create pipes\\n\"));\n    }\n  }\n  if (!pipe_error) /* pty or pipe opened or not used */\n  {\n    SIGSET_DECL(curset)\n#ifdef __BEOS__\n    beos_cleanup_read_thread();\n#endif\n    BLOCK_SIGNALS(&curset);\n    pid = fork(); /* maybe we should use vfork() */\n    if (pid == -1)\n    {\n      UNBLOCK_SIGNALS(&curset);\n      msg_puts(_(\"\\nCannot fork\\n\"));\n      if ((options & (SHELL_READ | SHELL_WRITE)))\n      {\n        close(fd_toshell[0]);\n        close(fd_toshell[1]);\n        close(fd_fromshell[0]);\n        close(fd_fromshell[1]);\n      }\n    }\n    else if (pid == 0) /* child */\n    {\n      reset_signals(); /* handle signals normally */\n      UNBLOCK_SIGNALS(&curset);\n#ifdef FEAT_JOB_CHANNEL\n      if (ch_log_active())\n        /* close the log file in the child */\n        ch_logfile((char_u *)\"\", (char_u *)\"\");\n#endif\n      if (!show_shell_mess || (options & SHELL_EXPAND))\n      {\n        int fd;\n        /*\n\t\t * Don't want to show any message from the shell.  Can't just\n\t\t * close stdout and stderr though, because some systems will\n\t\t * break if you try to write to them after that, so we must\n\t\t * use dup() to replace them with something else -- webb\n\t\t * Connect stdin to /dev/null too, so \":n `cat`\" doesn't hang,\n\t\t * waiting for input.\n\t\t */\n        fd = open(\"/dev/null\", O_RDWR | O_EXTRA, 0);\n        fclose(stdin);\n        fclose(stdout);\n        fclose(stderr);\n        /*\n\t\t * If any of these open()'s and dup()'s fail, we just continue\n\t\t * anyway.  It's not fatal, and on most systems it will make\n\t\t * no difference at all.  On a few it will cause the execvp()\n\t\t * to exit with a non-zero status even when the completion\n\t\t * could be done, which is nothing too serious.  If the open()\n\t\t * or dup() failed we'd just do the same thing ourselves\n\t\t * anyway -- webb\n\t\t */\n        if (fd >= 0)\n        {\n          vim_ignored = dup(fd); /* To replace stdin  (fd 0) */\n          vim_ignored = dup(fd); /* To replace stdout (fd 1) */\n          vim_ignored = dup(fd); /* To replace stderr (fd 2) */\n          /* Don't need this now that we've duplicated it */\n          close(fd);\n        }\n      }\n      else if ((options & (SHELL_READ | SHELL_WRITE)))\n      {\n#ifdef HAVE_SETSID\n        /* Create our own process group, so that the child and all its\n\t\t * children can be kill()ed.  Don't do this when using pipes,\n\t\t * because stdin is not a tty, we would lose /dev/tty. */\n        if (p_stmp)\n        {\n          (void)setsid();\n#if defined(SIGHUP)\n          /* When doing \"!xterm&\" and 'shell' is bash: the shell\n\t\t     * will exit and send SIGHUP to all processes in its\n\t\t     * group, killing the just started process.  Ignore SIGHUP\n\t\t     * to avoid that. (suggested by Simon Schubert)\n\t\t     */\n          signal(SIGHUP, SIG_IGN);\n#endif\n        }\n#endif\n        set_default_child_environment(FALSE);\n        /*\n\t\t * stderr is only redirected when using the GUI, so that a\n\t\t * program like gpg can still access the terminal to get a\n\t\t * passphrase using stderr.\n\t\t */\n        /* set up stdin for the child */\n        close(fd_toshell[1]);\n        close(0);\n        vim_ignored = dup(fd_toshell[0]);\n        close(fd_toshell[0]);\n        /* set up stdout for the child */\n        close(fd_fromshell[0]);\n        close(1);\n        vim_ignored = dup(fd_fromshell[1]);\n        close(fd_fromshell[1]);\n      }\n      /*\n\t     * There is no type cast for the argv, because the type may be\n\t     * different on different machines. This may cause a warning\n\t     * message with strict compilers, don't worry about it.\n\t     * Call _exit() instead of exit() to avoid closing the connection\n\t     * to the X server (esp. with GTK, which uses atexit()).\n\t     */\n      execvp(argv[0], argv);\n      _exit(EXEC_FAILED); /* exec failed, return failure code */\n    }\n    else /* parent */\n    {\n      /*\n\t     * While child is running, ignore terminating signals.\n\t     * Do catch CTRL-C, so that \"got_int\" is set.\n\t     */\n      catch_signals(SIG_IGN, SIG_ERR);\n      catch_int_signal();\n      UNBLOCK_SIGNALS(&curset);\n#ifdef FEAT_JOB_CHANNEL\n      ++dont_check_job_ended;\n#endif\n      /*\n\t     * For the GUI we redirect stdin, stdout and stderr to our window.\n\t     * This is also used to pipe stdin/stdout to/from the external\n\t     * command.\n\t     */\n      if ((options & (SHELL_READ | SHELL_WRITE)))\n      {\n#define BUFLEN 100 /* length for buffer, pseudo tty limit is 128 */\n        char_u buffer[BUFLEN + 1];\n        int buffer_off = 0;        /* valid bytes in buffer[] */\n        char_u ta_buf[BUFLEN + 1]; /* TypeAHead */\n        int ta_len = 0;            /* valid bytes in ta_buf[] */\n        int len;\n        int p_more_save;\n        int old_State;\n        int c;\n        int toshell_fd;\n        int fromshell_fd;\n        garray_T ga;\n        int noread_cnt;\n#ifdef ELAPSED_FUNC\n        elapsed_T start_tv;\n#endif\n        close(fd_toshell[0]);\n        close(fd_fromshell[1]);\n        toshell_fd = fd_toshell[1];\n        fromshell_fd = fd_fromshell[0];\n        /*\n\t\t * Write to the child if there are typed characters.\n\t\t * Read from the child if there are characters available.\n\t\t *   Repeat the reading a few times if more characters are\n\t\t *   available. Need to check for typed keys now and then, but\n\t\t *   not too often (delays when no chars are available).\n\t\t * This loop is quit if no characters can be read from the pty\n\t\t * (WaitForChar detected special condition), or there are no\n\t\t * characters available and the child has exited.\n\t\t * Only check if the child has exited when there is no more\n\t\t * output. The child may exit before all the output has\n\t\t * been printed.\n\t\t *\n\t\t * Currently this busy loops!\n\t\t * This can probably dead-lock when the write blocks!\n\t\t */\n        p_more_save = p_more;\n        p_more = FALSE;\n        old_State = State;\n        State = EXTERNCMD; /* don't redraw at window resize */\n        if ((options & SHELL_WRITE) && toshell_fd >= 0)\n        {\n          /* Fork a process that will write the lines to the\n\t\t     * external program. */\n          if ((wpid = fork()) == -1)\n          {\n            msg_puts(_(\"\\nCannot fork\\n\"));\n          }\n          else if (wpid == 0) /* child */\n          {\n            linenr_T lnum = curbuf->b_op_start.lnum;\n            int written = 0;\n            char_u *lp = ml_get(lnum);\n            size_t l;\n            close(fromshell_fd);\n            for (;;)\n            {\n              l = STRLEN(lp + written);\n              if (l == 0)\n                len = 0;\n              else if (lp[written] == NL)\n                /* NL -> NUL translation */\n                len = write(toshell_fd, \"\", (size_t)1);\n              else\n              {\n                char_u *s = vim_strchr(lp + written, NL);\n                len = write(toshell_fd, (char *)lp + written,\n                            s == NULL ? l\n                                      : (size_t)(s - (lp + written)));\n              }\n              if (len == (int)l)\n              {\n                /* Finished a line, add a NL, unless this line\n\t\t\t\t * should not have one. */\n                if (lnum != curbuf->b_op_end.lnum || (!curbuf->b_p_bin && curbuf->b_p_fixeol) || (lnum != curbuf->b_no_eol_lnum && (lnum != curbuf->b_ml.ml_line_count || curbuf->b_p_eol)))\n                  vim_ignored = write(toshell_fd, \"\\n\",\n                                      (size_t)1);\n                ++lnum;\n                if (lnum > curbuf->b_op_end.lnum)\n                {\n                  /* finished all the lines, close pipe */\n                  close(toshell_fd);\n                  toshell_fd = -1;\n                  break;\n                }\n                lp = ml_get(lnum);\n                written = 0;\n              }\n              else if (len > 0)\n                written += len;\n            }\n            _exit(0);\n          }\n          else /* parent */\n          {\n            close(toshell_fd);\n            toshell_fd = -1;\n          }\n        }\n        if (options & SHELL_READ)\n          ga_init2(&ga, 1, BUFLEN);\n        noread_cnt = 0;\n#ifdef ELAPSED_FUNC\n        ELAPSED_INIT(start_tv);\n#endif\n        for (;;)\n        {\n          /*\n\t\t     * Check if keys have been typed, write them to the child\n\t\t     * if there are any.\n\t\t     * Don't do this if we are expanding wild cards (would eat\n\t\t     * typeahead).\n\t\t     * Don't do this when filtering and terminal is in cooked\n\t\t     * mode, the shell command will handle the I/O.  Avoids\n\t\t     * that a typed password is echoed for ssh or gpg command.\n\t\t     * Don't get characters when the child has already\n\t\t     * finished (wait_pid == 0).\n\t\t     * Don't read characters unless we didn't get output for a\n\t\t     * while (noread_cnt > 4), avoids that \":r !ls\" eats\n\t\t     * typeahead.\n\t\t     */\n          len = 0;\n          if (!(options & SHELL_EXPAND) && ((options & (SHELL_READ | SHELL_WRITE | SHELL_COOKED)) != (SHELL_READ | SHELL_WRITE | SHELL_COOKED)) &&\n              wait_pid == 0 && (ta_len > 0 || noread_cnt > 4))\n          {\n            if (ta_len == 0)\n            {\n              /* Get extra characters when we don't have any.\n\t\t\t   * Reset the counter and timer. */\n              noread_cnt = 0;\n#ifdef ELAPSED_FUNC\n              ELAPSED_INIT(start_tv);\n#endif\n              len = ui_inchar(ta_buf, BUFLEN, 10L, 0);\n            }\n            if (ta_len > 0 || len > 0)\n            {\n              /*\n\t\t\t * For pipes:\n\t\t\t * Check for CTRL-C: send interrupt signal to child.\n\t\t\t * Check for CTRL-D: EOF, close pipe to child.\n\t\t\t */\n              if (len == 1 && (pty_master_fd < 0 || cmd != NULL))\n              {\n                /*\n\t\t\t     * Send SIGINT to the child's group or all\n\t\t\t     * processes in our group.\n\t\t\t     */\n                may_send_sigint(ta_buf[ta_len], pid, wpid);\n                if (pty_master_fd < 0 && toshell_fd >= 0 && ta_buf[ta_len] == Ctrl_D)\n                {\n                  close(toshell_fd);\n                  toshell_fd = -1;\n                }\n              }\n              /* replace K_BS by <BS> and K_DEL by <DEL> */\n              for (i = ta_len; i < ta_len + len; ++i)\n              {\n                if (ta_buf[i] == CSI && len - i > 2)\n                {\n                  c = TERMCAP2KEY(ta_buf[i + 1], ta_buf[i + 2]);\n                  if (c == K_DEL || c == K_KDEL || c == K_BS)\n                  {\n                    mch_memmove(ta_buf + i + 1, ta_buf + i + 3,\n                                (size_t)(len - i - 2));\n                    if (c == K_DEL || c == K_KDEL)\n                      ta_buf[i] = DEL;\n                    else\n                      ta_buf[i] = Ctrl_H;\n                    len -= 2;\n                  }\n                }\n                else if (ta_buf[i] == '\\r')\n                  ta_buf[i] = '\\n';\n                if (has_mbyte)\n                  i += (*mb_ptr2len_len)(ta_buf + i,\n                                         ta_len + len - i) -\n                       1;\n              }\n              /*\n\t\t\t * For pipes: echo the typed characters.\n\t\t\t * For a pty this does not seem to work.\n\t\t\t */\n              if (pty_master_fd < 0)\n              {\n                for (i = ta_len; i < ta_len + len; ++i)\n                {\n                  if (ta_buf[i] == '\\n' || ta_buf[i] == '\\b')\n                    msg_putchar(ta_buf[i]);\n                  else if (has_mbyte)\n                  {\n                    int l = (*mb_ptr2len)(ta_buf + i);\n                    msg_outtrans_len(ta_buf + i, l);\n                    i += l - 1;\n                  }\n                  else\n                    msg_outtrans_len(ta_buf + i, 1);\n                }\n                windgoto(msg_row, msg_col);\n              }\n              ta_len += len;\n              /*\n\t\t\t * Write the characters to the child, unless EOF has\n\t\t\t * been typed for pipes.  Write one character at a\n\t\t\t * time, to avoid losing too much typeahead.\n\t\t\t * When writing buffer lines, drop the typed\n\t\t\t * characters (only check for CTRL-C).\n\t\t\t */\n              if (options & SHELL_WRITE)\n                ta_len = 0;\n              else if (toshell_fd >= 0)\n              {\n                len = write(toshell_fd, (char *)ta_buf, (size_t)1);\n                if (len > 0)\n                {\n                  ta_len -= len;\n                  mch_memmove(ta_buf, ta_buf + len, ta_len);\n                }\n              }\n            }\n          }\n          if (got_int)\n          {\n            /* CTRL-C sends a signal to the child, we ignore it\n\t\t\t * ourselves */\n#ifdef HAVE_SETSID\n            kill(-pid, SIGINT);\n#else\n            kill(0, SIGINT);\n#endif\n            if (wpid > 0)\n              kill(wpid, SIGINT);\n            got_int = FALSE;\n          }\n          /*\n\t\t     * Check if the child has any characters to be printed.\n\t\t     * Read them and write them to our window.\tRepeat this as\n\t\t     * long as there is something to do, avoid the 10ms wait\n\t\t     * for mch_inchar(), or sending typeahead characters to\n\t\t     * the external process.\n\t\t     * TODO: This should handle escape sequences, compatible\n\t\t     * to some terminal (vt52?).\n\t\t     */\n          ++noread_cnt;\n          while (RealWaitForChar(fromshell_fd, 10L, NULL, NULL))\n          {\n            len = read_eintr(fromshell_fd, buffer + buffer_off, (size_t)(BUFLEN - buffer_off));\n            if (len <= 0) /* end of file or error */\n              goto finished;\n            noread_cnt = 0;\n            if (options & SHELL_READ)\n            {\n              /* Do NUL -> NL translation, append NL separated\n\t\t\t     * lines to the current buffer. */\n              for (i = 0; i < len; ++i)\n              {\n                if (buffer[i] == NL)\n                  append_ga_line(&ga);\n                else if (buffer[i] == NUL)\n                  ga_append(&ga, NL);\n                else\n                  ga_append(&ga, buffer[i]);\n              }\n            }\n            else if (has_mbyte)\n            {\n              int l;\n              char_u *p;\n              len += buffer_off;\n              buffer[len] = NUL;\n              /* Check if the last character in buffer[] is\n\t\t\t     * incomplete, keep these bytes for the next\n\t\t\t     * round. */\n              for (p = buffer; p < buffer + len; p += l)\n              {\n                l = MB_CPTR2LEN(p);\n                if (l == 0)\n                  l = 1; /* NUL byte? */\n                else if (MB_BYTE2LEN(*p) != l)\n                  break;\n              }\n              if (p == buffer) /* no complete character */\n              {\n                /* avoid getting stuck at an illegal byte */\n                if (len >= 12)\n                  ++p;\n                else\n                {\n                  buffer_off = len;\n                  continue;\n                }\n              }\n              c = *p;\n              *p = NUL;\n              msg_puts((char *)buffer);\n              if (p < buffer + len)\n              {\n                *p = c;\n                buffer_off = (buffer + len) - p;\n                mch_memmove(buffer, p, buffer_off);\n                continue;\n              }\n              buffer_off = 0;\n            }\n            else\n            {\n              buffer[len] = NUL;\n              msg_puts((char *)buffer);\n            }\n            windgoto(msg_row, msg_col);\n            cursor_on();\n            if (got_int)\n              break;\n#ifdef ELAPSED_FUNC\n            if (wait_pid == 0)\n            {\n              long msec = ELAPSED_FUNC(start_tv);\n              /* Avoid that we keep looping here without\n\t\t\t     * checking for a CTRL-C for a long time.  Don't\n\t\t\t     * break out too often to avoid losing typeahead. */\n              if (msec > 2000)\n              {\n                noread_cnt = 5;\n                break;\n              }\n            }\n#endif\n          }\n          /* If we already detected the child has finished, continue\n\t\t     * reading output for a short while.  Some text may be\n\t\t     * buffered. */\n          if (wait_pid == pid)\n          {\n            if (noread_cnt < 5)\n              continue;\n            break;\n          }\n          /*\n\t\t     * Check if the child still exists, before checking for\n\t\t     * typed characters (otherwise we would lose typeahead).\n\t\t     */\n#ifdef __NeXT__\n          wait_pid = wait4(pid, &status, WNOHANG, (struct rusage *)0);\n#else\n          wait_pid = waitpid(pid, &status, WNOHANG);\n#endif\n          if ((wait_pid == (pid_t)-1 && errno == ECHILD) || (wait_pid == pid && WIFEXITED(status)))\n          {\n            /* Don't break the loop yet, try reading more\n\t\t\t * characters from \"fromshell_fd\" first.  When using\n\t\t\t * pipes there might still be something to read and\n\t\t\t * then we'll break the loop at the \"break\" above. */\n            wait_pid = pid;\n          }\n          else\n            wait_pid = 0;\n#if defined(FEAT_XCLIPBOARD) && defined(FEAT_X11)\n          /* Handle any X events, e.g. serving the clipboard. */\n          clip_update();\n#endif\n        }\n      finished:\n        p_more = p_more_save;\n        if (options & SHELL_READ)\n        {\n          if (ga.ga_len > 0)\n          {\n            append_ga_line(&ga);\n            /* remember that the NL was missing */\n            curbuf->b_no_eol_lnum = curwin->w_cursor.lnum;\n          }\n          else\n            curbuf->b_no_eol_lnum = 0;\n          ga_clear(&ga);\n        }\n        /*\n\t\t * Give all typeahead that wasn't used back to ui_inchar().\n\t\t */\n        if (ta_len)\n          ui_inchar_undo(ta_buf, ta_len);\n        State = old_State;\n        if (toshell_fd >= 0)\n          close(toshell_fd);\n        close(fromshell_fd);\n      }\n#if defined(FEAT_XCLIPBOARD) && defined(FEAT_X11)\n      else\n      {\n        long delay_msec = 1;\n        /*\n\t\t * Similar to the loop above, but only handle X events, no\n\t\t * I/O.\n\t\t */\n        for (;;)\n        {\n          if (got_int)\n          {\n            /* CTRL-C sends a signal to the child, we ignore it\n\t\t\t * ourselves */\n#ifdef HAVE_SETSID\n            kill(-pid, SIGINT);\n#else\n            kill(0, SIGINT);\n#endif\n            got_int = FALSE;\n          }\n#ifdef __NeXT__\n          wait_pid = wait4(pid, &status, WNOHANG, (struct rusage *)0);\n#else\n          wait_pid = waitpid(pid, &status, WNOHANG);\n#endif\n          if ((wait_pid == (pid_t)-1 && errno == ECHILD) || (wait_pid == pid && WIFEXITED(status)))\n          {\n            wait_pid = pid;\n            break;\n          }\n          /* Handle any X events, e.g. serving the clipboard. */\n          clip_update();\n          /* Wait for 1 to 10 msec. 1 is faster but gives the child\n\t\t     * less time. */\n          mch_delay(delay_msec, TRUE);\n          if (++delay_msec > 10)\n            delay_msec = 10;\n        }\n      }\n#endif\n      /*\n\t     * Wait until our child has exited.\n\t     * Ignore wait() returning pids of other children and returning\n\t     * because of some signal like SIGWINCH.\n\t     * Don't wait if wait_pid was already set above, indicating the\n\t     * child already exited.\n\t     */\n      if (wait_pid != pid)\n        wait_pid = wait4pid(pid, &status);\n      /* Make sure the child that writes to the external program is\n\t     * dead. */\n      if (wpid > 0)\n      {\n        kill(wpid, SIGKILL);\n        wait4pid(wpid, NULL);\n      }\n#ifdef FEAT_JOB_CHANNEL\n      --dont_check_job_ended;\n#endif\n      /*\n\t     * Set to raw mode right now, otherwise a CTRL-C after\n\t     * catch_signals() will kill Vim.\n\t     */\n      if (tmode == TMODE_RAW)\n        settmode(TMODE_RAW);\n      did_settmode = TRUE;\n      set_signals();\n      if (WIFEXITED(status))\n      {\n        /* LINTED avoid \"bitwise operation on signed value\" */\n        retval = WEXITSTATUS(status);\n        if (retval != 0 && !emsg_silent)\n        {\n          if (retval == EXEC_FAILED)\n          {\n            msg_puts(_(\"\\nCannot execute shell \"));\n            msg_outtrans(p_sh);\n            msg_putchar('\\n');\n          }\n          else if (!(options & SHELL_SILENT))\n          {\n            msg_puts(_(\"\\nshell returned \"));\n            msg_outnum((long)retval);\n            msg_putchar('\\n');\n          }\n        }\n      }\n      else\n        msg_puts(_(\"\\nCommand terminated\\n\"));\n    }\n  }\nerror:\n  if (!did_settmode)\n    if (tmode == TMODE_RAW)\n      settmode(TMODE_RAW); /* set to raw mode */\n  vim_free(argv);\n  vim_free(tofree1);\n  vim_free(tofree2);\n  return retval;\n"]]}
{"hexsha": "d0f50d2a22c740e8272b75d8d68f43e89a1fdc6d", "ext": "c", "lang": "C", "content": "void\nowcty_global_init   (run_t *run, wctx_t *ctx)\n{\n    ctx->global = RTmallocZero (sizeof(alg_global_t));\n    size_t len = state_info_serialize_int_size (ctx->state);\n    ctx->global->stack = dfs_stack_create (len);\n    ctx->global->in_stack = dfs_stack_create (len);\n    ctx->global->out_stack = dfs_stack_create (len);\n\n    lb_local_init (run->shared->lb, ctx->id, ctx); // Barrier\n    (void) run;\n}", "item_id": 20, "repo": "LieuweVinkhuijzen/ltsmin", "file": "src/pins2lts-mc/algorithm/owcty.c", "last_update_at": "2022-03-17T10:47:11+00:00", "question_id": "d0f50d2a22c740e8272b75d8d68f43e89a1fdc6d_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nowcty_global_init   (run_t *run, wctx_t *ctx)\n{\n    ctx->global = RTmallocZero (sizeof(alg_global_t));\n    size_t len = state_info_serialize_int_size (ctx->state);\n    ctx->global->stack = dfs_stack_create (len);\n    ctx->global->in_stack = dfs_stack_create (len);\n    ctx->global->out_stack = dfs_stack_create (len);\n    lb_local_init (run->shared->lb, ctx->id, ctx); // Barrier\n    (void) run;\n"]]}
{"hexsha": "89c99532d5bbf2e5fad532d8cb917a6848595dd6", "ext": "c", "lang": "C", "content": "int\ndsnode_bmod (\n\t    const int  jcol,\t  /* in */\n\t    const int  jsupno,    /* in */\n\t    const int  fsupc,     /* in */\n\t    double     *dense,    /* in */\n\t    double     *tempv,    /* working array */\n\t    GlobalLU_t *Glu,      /* modified */\n\t    SuperLUStat_t *stat   /* output */\n\t    )\n{\n#ifdef USE_VENDOR_BLAS\n#ifdef _CRAY\n    _fcd ftcs1 = _cptofcd(\"L\", strlen(\"L\")),\n\t ftcs2 = _cptofcd(\"N\", strlen(\"N\")),\n\t ftcs3 = _cptofcd(\"U\", strlen(\"U\"));\n#endif\n    int            incx = 1, incy = 1;\n    double         alpha = -1.0, beta = 1.0;\n#endif\n\n    int            luptr, nsupc, nsupr, nrow;\n    int            isub, irow, i, iptr; \n    register int   ufirst, nextlu;\n    int            *lsub, *xlsub;\n    double         *lusup;\n    int            *xlusup;\n    flops_t *ops = stat->ops;\n\n    lsub    = Glu->lsub;\n    xlsub   = Glu->xlsub;\n    lusup   = Glu->lusup;\n    xlusup  = Glu->xlusup;\n\n    nextlu = xlusup[jcol];\n    \n    /*\n     *\tProcess the supernodal portion of L\\U[*,j]\n     */\n    for (isub = xlsub[fsupc]; isub < xlsub[fsupc+1]; isub++) {\n  \tirow = lsub[isub];\n\tlusup[nextlu] = dense[irow];\n\tdense[irow] = 0;\n\t++nextlu;\n    }\n\n    xlusup[jcol + 1] = nextlu;\t/* Initialize xlusup for next column */\n    \n    if ( fsupc < jcol ) {\n\n\tluptr = xlusup[fsupc];\n\tnsupr = xlsub[fsupc+1] - xlsub[fsupc];\n\tnsupc = jcol - fsupc;\t/* Excluding jcol */\n\tufirst = xlusup[jcol];\t/* Points to the beginning of column\n\t\t\t\t   jcol in supernode L\\U(jsupno). */\n\tnrow = nsupr - nsupc;\n\n\tops[TRSV] += nsupc * (nsupc - 1);\n\tops[GEMV] += 2 * nrow * nsupc;\n\n#ifdef USE_VENDOR_BLAS\n#ifdef _CRAY\n\tSTRSV( ftcs1, ftcs2, ftcs3, &nsupc, &lusup[luptr], &nsupr, \n\t      &lusup[ufirst], &incx );\n\tSGEMV( ftcs2, &nrow, &nsupc, &alpha, &lusup[luptr+nsupc], &nsupr, \n\t\t&lusup[ufirst], &incx, &beta, &lusup[ufirst+nsupc], &incy );\n#else\n        hypre_F90_NAME_BLAS(dtrsv,DTRSV)(\"L\",\"N\",\"U\",&nsupc,&lusup[luptr],\n              &nsupr, &lusup[ufirst], &incx );\n        hypre_F90_NAME_BLAS(dgemv,DGEMV)(\"N\",&nrow,&nsupc,&alpha,\n                &lusup[luptr+nsupc], &nsupr,\n                &lusup[ufirst], &incx, &beta, &lusup[ufirst+nsupc], &incy );\n#endif\n#else\n\tsludlsolve ( nsupr, nsupc, &lusup[luptr], &lusup[ufirst] );\n\tsludmatvec ( nsupr, nrow, nsupc, &lusup[luptr+nsupc], \n\t\t\t&lusup[ufirst], &tempv[0] );\n\n        /* Scatter tempv[*] into lusup[*] */\n\tiptr = ufirst + nsupc;\n\tfor (i = 0; i < nrow; i++) {\n\t    lusup[iptr++] -= tempv[i];\n\t    tempv[i] = 0.0;\n\t}\n#endif\n\n    }\n\n    return 0;\n}", "item_id": 0, "repo": "GWU-CFD/flash-distro", "file": "hypre-2.11.2/src/FEI_mv/SuperLU/SRC/dsnode_bmod.c", "last_update_at": "2022-01-24T02:54:32+00:00", "question_id": "89c99532d5bbf2e5fad532d8cb917a6848595dd6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\ndsnode_bmod (\n\t    const int  jcol,\t  /* in */\n\t    const int  jsupno,    /* in */\n\t    const int  fsupc,     /* in */\n\t    double     *dense,    /* in */\n\t    double     *tempv,    /* working array */\n\t    GlobalLU_t *Glu,      /* modified */\n\t    SuperLUStat_t *stat   /* output */\n\t    )\n{\n#ifdef USE_VENDOR_BLAS\n#ifdef _CRAY\n    _fcd ftcs1 = _cptofcd(\"L\", strlen(\"L\")),\n\t ftcs2 = _cptofcd(\"N\", strlen(\"N\")),\n\t ftcs3 = _cptofcd(\"U\", strlen(\"U\"));\n#endif\n    int            incx = 1, incy = 1;\n    double         alpha = -1.0, beta = 1.0;\n#endif\n    int            luptr, nsupc, nsupr, nrow;\n    int            isub, irow, i, iptr; \n    register int   ufirst, nextlu;\n    int            *lsub, *xlsub;\n    double         *lusup;\n    int            *xlusup;\n    flops_t *ops = stat->ops;\n    lsub    = Glu->lsub;\n    xlsub   = Glu->xlsub;\n    lusup   = Glu->lusup;\n    xlusup  = Glu->xlusup;\n    nextlu = xlusup[jcol];\n    /*\n     *\tProcess the supernodal portion of L\\U[*,j]\n     */\n    for (isub = xlsub[fsupc]; isub < xlsub[fsupc+1]; isub++) {\n  \tirow = lsub[isub];\n\tlusup[nextlu] = dense[irow];\n\tdense[irow] = 0;\n\t++nextlu;\n    }\n    xlusup[jcol + 1] = nextlu;\t/* Initialize xlusup for next column */\n    if ( fsupc < jcol ) {\n\tluptr = xlusup[fsupc];\n\tnsupr = xlsub[fsupc+1] - xlsub[fsupc];\n\tnsupc = jcol - fsupc;\t/* Excluding jcol */\n\tufirst = xlusup[jcol];\t/* Points to the beginning of column\n\t\t\t\t   jcol in supernode L\\U(jsupno). */\n\tnrow = nsupr - nsupc;\n\tops[TRSV] += nsupc * (nsupc - 1);\n\tops[GEMV] += 2 * nrow * nsupc;\n#ifdef USE_VENDOR_BLAS\n#ifdef _CRAY\n\tSTRSV( ftcs1, ftcs2, ftcs3, &nsupc, &lusup[luptr], &nsupr, \n\t      &lusup[ufirst], &incx );\n\tSGEMV( ftcs2, &nrow, &nsupc, &alpha, &lusup[luptr+nsupc], &nsupr, \n\t\t&lusup[ufirst], &incx, &beta, &lusup[ufirst+nsupc], &incy );\n#else\n        hypre_F90_NAME_BLAS(dtrsv,DTRSV)(\"L\",\"N\",\"U\",&nsupc,&lusup[luptr],\n              &nsupr, &lusup[ufirst], &incx );\n        hypre_F90_NAME_BLAS(dgemv,DGEMV)(\"N\",&nrow,&nsupc,&alpha,\n                &lusup[luptr+nsupc], &nsupr,\n                &lusup[ufirst], &incx, &beta, &lusup[ufirst+nsupc], &incy );\n#endif\n#else\n\tsludlsolve ( nsupr, nsupc, &lusup[luptr], &lusup[ufirst] );\n\tsludmatvec ( nsupr, nrow, nsupc, &lusup[luptr+nsupc], \n\t\t\t&lusup[ufirst], &tempv[0] );\n        /* Scatter tempv[*] into lusup[*] */\n\tiptr = ufirst + nsupc;\n\tfor (i = 0; i < nrow; i++) {\n\t    lusup[iptr++] -= tempv[i];\n\t    tempv[i] = 0.0;\n\t}\n#endif\n    }\n    return 0;\n"]]}
{"hexsha": "43f623d6a7570dd05d968e7c9f12fa191b1b1d9d", "ext": "c", "lang": "C", "content": "static srpl_state_t\nsrpl_send_candidates_response_send_action(srpl_connection_t *srpl_connection, srpl_event_t *event)\n{\n    REQUIRE_SRPL_EVENT_NULL(srpl_connection, event);\n    REQUIRE_SRPL_INSTANCE(srpl_connection);\n    STATE_ANNOUNCE_NO_EVENTS(srpl_connection);\n\n    srpl_send_candidates_message_send(srpl_connection, true);\n    // When the server has sent its candidate response, it's immediately ready to send a \"send candidate\" message\n    // When the client has sent its candidate response, the database synchronization is done on the client.\n    if (srpl_connection->is_server) {\n        return srpl_state_send_candidates_send;\n    } else {\n        srpl_connection->database_synchronized = true;\n        return srpl_state_ready;\n    }\n}", "item_id": 91, "repo": "twasilczyk/mdnsresponder", "file": "ServiceRegistration/srp-replication.c", "last_update_at": "2022-03-20T07:18:43+00:00", "question_id": "43f623d6a7570dd05d968e7c9f12fa191b1b1d9d_91", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static srpl_state_t\nsrpl_send_candidates_response_send_action(srpl_connection_t *srpl_connection, srpl_event_t *event)\n{\n    REQUIRE_SRPL_EVENT_NULL(srpl_connection, event);\n    REQUIRE_SRPL_INSTANCE(srpl_connection);\n    STATE_ANNOUNCE_NO_EVENTS(srpl_connection);\n    srpl_send_candidates_message_send(srpl_connection, true);\n    // When the server has sent its candidate response, it's immediately ready to send a \"send candidate\" message\n    // When the client has sent its candidate response, the database synchronization is done on the client.\n    if (srpl_connection->is_server) {\n        return srpl_state_send_candidates_send;\n    } else {\n        srpl_connection->database_synchronized = true;\n        return srpl_state_ready;\n    }\n"]]}
{"hexsha": "9e1142b8b91b4b5b71197115a20260e92844aa08", "ext": "c", "lang": "C", "content": "static int is_good_ss_cap(struct usbtest_dev *tdev, u8 *buf)\n{\n\tstruct usb_ss_cap_descriptor *ss;\n\n\tss = (struct usb_ss_cap_descriptor *) buf;\n\n\tif (ss->bLength != USB_DT_USB_SS_CAP_SIZE) {\n\t\tERROR(tdev, \"bogus superspeed device capability descriptor length\\n\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * only bit[1] of bmAttributes is used for LTM and others are\n\t * reserved\n\t */\n\tif (ss->bmAttributes & ~0x02) {\t/* reserved == 0 */\n\t\tERROR(tdev, \"reserved bits set in bmAttributes\\n\");\n\t\treturn 0;\n\t}\n\n\t/* bits[0:3] of wSpeedSupported is used and others are reserved */\n\tif (le16_to_cpu(ss->wSpeedSupported) & ~0x0f) {\t/* reserved == 0 */\n\t\tERROR(tdev, \"reserved bits set in wSpeedSupported\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}", "item_id": 15, "repo": "dme26/intravisor", "file": "runtime/musl-lkl/lkl/drivers/usb/misc/usbtest.c", "last_update_at": "2022-03-08T08:09:08+00:00", "question_id": "9e1142b8b91b4b5b71197115a20260e92844aa08_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int is_good_ss_cap(struct usbtest_dev *tdev, u8 *buf)\n{\n\tstruct usb_ss_cap_descriptor *ss;\n\tss = (struct usb_ss_cap_descriptor *) buf;\n\tif (ss->bLength != USB_DT_USB_SS_CAP_SIZE) {\n\t\tERROR(tdev, \"bogus superspeed device capability descriptor length\\n\");\n\t\treturn 0;\n\t}\n\t/*\n\t * only bit[1] of bmAttributes is used for LTM and others are\n\t * reserved\n\t */\n\tif (ss->bmAttributes & ~0x02) {\t/* reserved == 0 */\n\t\tERROR(tdev, \"reserved bits set in bmAttributes\\n\");\n\t\treturn 0;\n\t}\n\t/* bits[0:3] of wSpeedSupported is used and others are reserved */\n\tif (le16_to_cpu(ss->wSpeedSupported) & ~0x0f) {\t/* reserved == 0 */\n\t\tERROR(tdev, \"reserved bits set in wSpeedSupported\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n"]]}
{"hexsha": "55659107bcb7be7a60b7d09bd5dd794e25538735", "ext": "c", "lang": "C", "content": "char* parse_ld_trace_line_path(const char* line) {\n    char* path = NULL;\n    const char* path_start = strstr(line, \"=> \");\n    if (path_start != NULL) {\n        path_start += 3;\n    } else {\n        path_start = line;\n        while (path_start != NULL && isspace(*path_start))\n            path_start++;\n    }\n\n    char* path_end = strstr(path_start, \" (\");\n\n    if (path_end != NULL)\n        path = strndup(path_start, path_end - path_start);\n    else\n        path = strdup(path_start);\n\n\n    return path;\n}", "item_id": 0, "repo": "AppImageCrafters/AppRun", "file": "src/apprun/runtime_interpreter.c", "last_update_at": "2022-03-29T13:14:50+00:00", "question_id": "55659107bcb7be7a60b7d09bd5dd794e25538735_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char* parse_ld_trace_line_path(const char* line) {\n    char* path = NULL;\n    const char* path_start = strstr(line, \"=> \");\n    if (path_start != NULL) {\n        path_start += 3;\n    } else {\n        path_start = line;\n        while (path_start != NULL && isspace(*path_start))\n            path_start++;\n    }\n    char* path_end = strstr(path_start, \" (\");\n    if (path_end != NULL)\n        path = strndup(path_start, path_end - path_start);\n    else\n        path = strdup(path_start);\n    return path;\n"]]}
{"hexsha": "3ea9dec685a63b8aaa1d801248944203c00eacc1", "ext": "c", "lang": "C", "content": "uint64_t sys_name_to_handle_at(uint64_t dfd, uint64_t name, uint64_t handle,\n                               uint64_t mnt_id, uint64_t flag) {\n  /// TODO: entire syscall\n  DEBUG(\"Call to stubbed syscall (name_to_handle_at)\\n\");\n  return -1;\n}", "item_id": 264, "repo": "SuchyB/CaratCakeArtifact", "file": "src/nautilus/syscalls/stubs.c", "last_update_at": "2022-02-25T22:09:58+00:00", "question_id": "3ea9dec685a63b8aaa1d801248944203c00eacc1_264", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint64_t sys_name_to_handle_at(uint64_t dfd, uint64_t name, uint64_t handle,\n                               uint64_t mnt_id, uint64_t flag) {\n  /// TODO: entire syscall\n  DEBUG(\"Call to stubbed syscall (name_to_handle_at)\\n\");\n  return -1;\n"]]}
{"hexsha": "8bf66fda0e26ed0ae12d74dd4c709e281c3c9221", "ext": "c", "lang": "C", "content": "static mem_inode_t *\n_dir_find(mem_inode_t *dir_inode, char *filename, uint32_t *entry_offset)\n{\n    assert(dir_inode->d_inode.type == INODE_TYPE_DIR);\n\n    /** Search for the filename in this directory. */\n    dentry_t dentry;\n    for (size_t offset = 0;\n         offset < dir_inode->d_inode.size;\n         offset += sizeof(dentry_t)) {\n        if (inode_read(dir_inode, (char *) &dentry, offset,\n                       sizeof(dentry_t)) != sizeof(dentry_t)) {\n            warn(\"dir_find: failed to read at offset %u\", offset);\n            return NULL;\n        }\n        if (dentry.valid == 0)\n            continue;\n\n        /** If matches, get the inode. */\n        if (strncmp(dentry.filename, filename, MAX_FILENAME) == 0) {\n            if (entry_offset != NULL)\n                *entry_offset = offset;\n            return inode_get(dentry.inumber);\n        }\n    }\n\n    return NULL;\n}", "item_id": 2, "repo": "josehu07/hux-kernel", "file": "src/filesys/vsfs.c", "last_update_at": "2022-03-02T22:06:41+00:00", "question_id": "8bf66fda0e26ed0ae12d74dd4c709e281c3c9221_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static mem_inode_t *\n_dir_find(mem_inode_t *dir_inode, char *filename, uint32_t *entry_offset)\n{\n    assert(dir_inode->d_inode.type == INODE_TYPE_DIR);\n    /** Search for the filename in this directory. */\n    dentry_t dentry;\n    for (size_t offset = 0;\n         offset < dir_inode->d_inode.size;\n         offset += sizeof(dentry_t)) {\n        if (inode_read(dir_inode, (char *) &dentry, offset,\n                       sizeof(dentry_t)) != sizeof(dentry_t)) {\n            warn(\"dir_find: failed to read at offset %u\", offset);\n            return NULL;\n        }\n        if (dentry.valid == 0)\n            continue;\n        /** If matches, get the inode. */\n        if (strncmp(dentry.filename, filename, MAX_FILENAME) == 0) {\n            if (entry_offset != NULL)\n                *entry_offset = offset;\n            return inode_get(dentry.inumber);\n        }\n    }\n    return NULL;\n"]]}
{"hexsha": "6cd7d0740005954ed37f33617298faee60816386", "ext": "c", "lang": "C", "content": "static void __init test_copy(void)\n{\n\tDECLARE_BITMAP(bmap1, 1024);\n\tDECLARE_BITMAP(bmap2, 1024);\n\n\tbitmap_zero(bmap1, 1024);\n\tbitmap_zero(bmap2, 1024);\n\n\t/* single-word bitmaps */\n\tbitmap_set(bmap1, 0, 19);\n\tbitmap_copy(bmap2, bmap1, 23);\n\texpect_eq_pbl(\"0-18\", bmap2, 1024);\n\n\tbitmap_set(bmap2, 0, 23);\n\tbitmap_copy(bmap2, bmap1, 23);\n\texpect_eq_pbl(\"0-18\", bmap2, 1024);\n\n\t/* multi-word bitmaps */\n\tbitmap_set(bmap1, 0, 109);\n\tbitmap_copy(bmap2, bmap1, 1024);\n\texpect_eq_pbl(\"0-108\", bmap2, 1024);\n\n\tbitmap_fill(bmap2, 1024);\n\tbitmap_copy(bmap2, bmap1, 1024);\n\texpect_eq_pbl(\"0-108\", bmap2, 1024);\n\n\t/* the following tests assume a 32- or 64-bit arch (even 128b\n\t * if we care)\n\t */\n\n\tbitmap_fill(bmap2, 1024);\n\tbitmap_copy(bmap2, bmap1, 109);  /* ... but 0-padded til word length */\n\texpect_eq_pbl(\"0-108,128-1023\", bmap2, 1024);\n\n\tbitmap_fill(bmap2, 1024);\n\tbitmap_copy(bmap2, bmap1, 97);  /* ... but aligned on word length */\n\texpect_eq_pbl(\"0-108,128-1023\", bmap2, 1024);\n}", "item_id": 4, "repo": "fergy/aplit_linux-5", "file": "lib/test_bitmap.c", "last_update_at": "2022-03-08T08:09:08+00:00", "question_id": "6cd7d0740005954ed37f33617298faee60816386_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void __init test_copy(void)\n{\n\tDECLARE_BITMAP(bmap1, 1024);\n\tDECLARE_BITMAP(bmap2, 1024);\n\tbitmap_zero(bmap1, 1024);\n\tbitmap_zero(bmap2, 1024);\n\t/* single-word bitmaps */\n\tbitmap_set(bmap1, 0, 19);\n\tbitmap_copy(bmap2, bmap1, 23);\n\texpect_eq_pbl(\"0-18\", bmap2, 1024);\n\tbitmap_set(bmap2, 0, 23);\n\tbitmap_copy(bmap2, bmap1, 23);\n\texpect_eq_pbl(\"0-18\", bmap2, 1024);\n\t/* multi-word bitmaps */\n\tbitmap_set(bmap1, 0, 109);\n\tbitmap_copy(bmap2, bmap1, 1024);\n\texpect_eq_pbl(\"0-108\", bmap2, 1024);\n\tbitmap_fill(bmap2, 1024);\n\tbitmap_copy(bmap2, bmap1, 1024);\n\texpect_eq_pbl(\"0-108\", bmap2, 1024);\n\t/* the following tests assume a 32- or 64-bit arch (even 128b\n\t * if we care)\n\t */\n\tbitmap_fill(bmap2, 1024);\n\tbitmap_copy(bmap2, bmap1, 109);  /* ... but 0-padded til word length */\n\texpect_eq_pbl(\"0-108,128-1023\", bmap2, 1024);\n\tbitmap_fill(bmap2, 1024);\n\tbitmap_copy(bmap2, bmap1, 97);  /* ... but aligned on word length */\n\texpect_eq_pbl(\"0-108,128-1023\", bmap2, 1024);\n"]]}
{"hexsha": "443274b42fd955c69d69988da21e08da3f9d6c9c", "ext": "h", "lang": "C", "content": "inline PDBResidue *PDBChain:: \nFindResidue(const char *str) const\n{\n  // Find residue matching string\n  PDBResidue *residue = NULL;\n  if (FindAny(str, &residue, NULL, PDB_RESIDUE) == PDB_RESIDUE) return residue;\n  else return NULL;\n}", "item_id": 3, "repo": "tomfunkhouser/gaps", "file": "pkgs/PDB/PDBChain.h", "last_update_at": "2022-03-26T09:25:25+00:00", "question_id": "443274b42fd955c69d69988da21e08da3f9d6c9c_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["inline PDBResidue *PDBChain:: \nFindResidue(const char *str) const\n{\n  // Find residue matching string\n  PDBResidue *residue = NULL;\n  if (FindAny(str, &residue, NULL, PDB_RESIDUE) == PDB_RESIDUE) return residue;\n  else return NULL;\n"]]}
{"hexsha": "d2623747b489a90116a9876c89fd9fd289966f9e", "ext": "c", "lang": "C", "content": "static void fhci_usb_free(void *lld)\n{\n\tstruct fhci_usb *usb = lld;\n\tstruct fhci_hcd *fhci;\n\n\tif (usb) {\n\t\tfhci = usb->fhci;\n\t\tfhci_config_transceiver(fhci, FHCI_PORT_POWER_OFF);\n\t\tfhci_ep0_free(usb);\n\t\tkfree(usb->actual_frame);\n\t\tkfree(usb);\n\t}\n}", "item_id": 10, "repo": "usenixatc2021/SoftRefresh_Scheduling", "file": "linsched-linsched-alpha/drivers/usb/host/fhci-hcd.c", "last_update_at": "2022-02-17T01:04:14+00:00", "question_id": "d2623747b489a90116a9876c89fd9fd289966f9e_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void fhci_usb_free(void *lld)\n{\n\tstruct fhci_usb *usb = lld;\n\tstruct fhci_hcd *fhci;\n\tif (usb) {\n\t\tfhci = usb->fhci;\n\t\tfhci_config_transceiver(fhci, FHCI_PORT_POWER_OFF);\n\t\tfhci_ep0_free(usb);\n\t\tkfree(usb->actual_frame);\n\t\tkfree(usb);\n\t}\n"]]}
{"hexsha": "a49645ae86bf99e5cda68b101fefd162f7f6fac6", "ext": "c", "lang": "C", "content": "static unsigned int radix_tree_descend(exploit_context* pCtx, const struct radix_tree_node *parent,\n            struct radix_tree_node **nodep, unsigned long index)\n{\n    unsigned int offset = 0;\n    void **entry = NULL;\n    struct radix_tree_node node_in = {0};\n\n    kernel_read(pCtx, (uint64_t)parent, (char*)&node_in, sizeof(node_in));\n    offset = (index >> node_in.shift) & RADIX_TREE_MAP_MASK;\n\n    entry = node_in.slots[offset];\n\n    *nodep = (void *)entry;\n    return offset;\n}", "item_id": 0, "repo": "OsmanDere/metasploit-framework", "file": "external/source/exploits/CVE-2021-3490/Linux_LPE_eBPF_CVE-2021-3490/kmem_search.c", "last_update_at": "2022-03-31T22:51:38+00:00", "question_id": "a49645ae86bf99e5cda68b101fefd162f7f6fac6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static unsigned int radix_tree_descend(exploit_context* pCtx, const struct radix_tree_node *parent,\n            struct radix_tree_node **nodep, unsigned long index)\n{\n    unsigned int offset = 0;\n    void **entry = NULL;\n    struct radix_tree_node node_in = {0};\n    kernel_read(pCtx, (uint64_t)parent, (char*)&node_in, sizeof(node_in));\n    offset = (index >> node_in.shift) & RADIX_TREE_MAP_MASK;\n    entry = node_in.slots[offset];\n    *nodep = (void *)entry;\n    return offset;\n"]]}
{"hexsha": "367388fdc486484202e4bb550420bdcda31a8fdf", "ext": "c", "lang": "C", "content": "static int wm8983_set_bias_level(struct snd_soc_codec *codec,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t/* VMID at 100k */\n\t\tsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8983_VMIDSEL_MASK,\n\t\t\t\t    1 << WM8983_VMIDSEL_SHIFT);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\n\t\t\tret = snd_soc_cache_sync(codec);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(codec->dev, \"Failed to sync cache: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t/* enable anti-pop features */\n\t\t\tsnd_soc_update_bits(codec, WM8983_OUT4_TO_ADC,\n\t\t\t\t\t    WM8983_POBCTRL_MASK | WM8983_DELEN_MASK,\n\t\t\t\t\t    WM8983_POBCTRL | WM8983_DELEN);\n\t\t\t/* enable thermal shutdown */\n\t\t\tsnd_soc_update_bits(codec, WM8983_OUTPUT_CTRL,\n\t\t\t\t\t    WM8983_TSDEN_MASK, WM8983_TSDEN);\n\t\t\t/* enable BIASEN */\n\t\t\tsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,\n\t\t\t\t\t    WM8983_BIASEN_MASK, WM8983_BIASEN);\n\t\t\t/* VMID at 100k */\n\t\t\tsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,\n\t\t\t\t\t    WM8983_VMIDSEL_MASK,\n\t\t\t\t\t    1 << WM8983_VMIDSEL_SHIFT);\n\t\t\tmsleep(250);\n\t\t\t/* disable anti-pop features */\n\t\t\tsnd_soc_update_bits(codec, WM8983_OUT4_TO_ADC,\n\t\t\t\t\t    WM8983_POBCTRL_MASK |\n\t\t\t\t\t    WM8983_DELEN_MASK, 0);\n\t\t}\n\n\t\t/* VMID at 500k */\n\t\tsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8983_VMIDSEL_MASK,\n\t\t\t\t    2 << WM8983_VMIDSEL_SHIFT);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\t/* disable thermal shutdown */\n\t\tsnd_soc_update_bits(codec, WM8983_OUTPUT_CTRL,\n\t\t\t\t    WM8983_TSDEN_MASK, 0);\n\t\t/* disable VMIDSEL and BIASEN */\n\t\tsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8983_VMIDSEL_MASK | WM8983_BIASEN_MASK,\n\t\t\t\t    0);\n\t\t/* wait for VMID to discharge */\n\t\tmsleep(100);\n\t\tsnd_soc_write(codec, WM8983_POWER_MANAGEMENT_1, 0);\n\t\tsnd_soc_write(codec, WM8983_POWER_MANAGEMENT_2, 0);\n\t\tsnd_soc_write(codec, WM8983_POWER_MANAGEMENT_3, 0);\n\t\tbreak;\n\t}\n\n\tcodec->dapm.bias_level = level;\n\treturn 0;\n}", "item_id": 7, "repo": "zhiming-shen/Xen-Blanket-NG", "file": "linux-kernel/linux-3.4.53-blanket/sound/soc/codecs/wm8983.c", "last_update_at": "2022-02-17T01:04:14+00:00", "question_id": "367388fdc486484202e4bb550420bdcda31a8fdf_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int wm8983_set_bias_level(struct snd_soc_codec *codec,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tint ret;\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t/* VMID at 100k */\n\t\tsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8983_VMIDSEL_MASK,\n\t\t\t\t    1 << WM8983_VMIDSEL_SHIFT);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\n\t\t\tret = snd_soc_cache_sync(codec);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(codec->dev, \"Failed to sync cache: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t/* enable anti-pop features */\n\t\t\tsnd_soc_update_bits(codec, WM8983_OUT4_TO_ADC,\n\t\t\t\t\t    WM8983_POBCTRL_MASK | WM8983_DELEN_MASK,\n\t\t\t\t\t    WM8983_POBCTRL | WM8983_DELEN);\n\t\t\t/* enable thermal shutdown */\n\t\t\tsnd_soc_update_bits(codec, WM8983_OUTPUT_CTRL,\n\t\t\t\t\t    WM8983_TSDEN_MASK, WM8983_TSDEN);\n\t\t\t/* enable BIASEN */\n\t\t\tsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,\n\t\t\t\t\t    WM8983_BIASEN_MASK, WM8983_BIASEN);\n\t\t\t/* VMID at 100k */\n\t\t\tsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,\n\t\t\t\t\t    WM8983_VMIDSEL_MASK,\n\t\t\t\t\t    1 << WM8983_VMIDSEL_SHIFT);\n\t\t\tmsleep(250);\n\t\t\t/* disable anti-pop features */\n\t\t\tsnd_soc_update_bits(codec, WM8983_OUT4_TO_ADC,\n\t\t\t\t\t    WM8983_POBCTRL_MASK |\n\t\t\t\t\t    WM8983_DELEN_MASK, 0);\n\t\t}\n\t\t/* VMID at 500k */\n\t\tsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8983_VMIDSEL_MASK,\n\t\t\t\t    2 << WM8983_VMIDSEL_SHIFT);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\t/* disable thermal shutdown */\n\t\tsnd_soc_update_bits(codec, WM8983_OUTPUT_CTRL,\n\t\t\t\t    WM8983_TSDEN_MASK, 0);\n\t\t/* disable VMIDSEL and BIASEN */\n\t\tsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8983_VMIDSEL_MASK | WM8983_BIASEN_MASK,\n\t\t\t\t    0);\n\t\t/* wait for VMID to discharge */\n\t\tmsleep(100);\n\t\tsnd_soc_write(codec, WM8983_POWER_MANAGEMENT_1, 0);\n\t\tsnd_soc_write(codec, WM8983_POWER_MANAGEMENT_2, 0);\n\t\tsnd_soc_write(codec, WM8983_POWER_MANAGEMENT_3, 0);\n\t\tbreak;\n\t}\n\tcodec->dapm.bias_level = level;\n\treturn 0;\n"]]}
{"hexsha": "1e5ee7244aa46abbd6ec20ac61f040543d1abcbe", "ext": "c", "lang": "C", "content": "static uint32_t parse_shift_expr(struct lex_ctx_t *ctx, struct cmd_option_t *const_list)\n{\n    uint32_t v = parse_term_expr(ctx, const_list);\n    while(ctx->lexem.type == LEX_LSHIFT)\n    {\n        next(ctx, true);\n        v <<= parse_term_expr(ctx, const_list);\n    }\n    return v;\n}", "item_id": 17, "repo": "Rockbox-Chinese-Community/Rockbox-RCC", "file": "utils/imxtools/sbtools/dbparser.c", "last_update_at": "2022-01-05T14:09:46+00:00", "question_id": "1e5ee7244aa46abbd6ec20ac61f040543d1abcbe_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static uint32_t parse_shift_expr(struct lex_ctx_t *ctx, struct cmd_option_t *const_list)\n{\n    uint32_t v = parse_term_expr(ctx, const_list);\n    while(ctx->lexem.type == LEX_LSHIFT)\n    {\n        next(ctx, true);\n        v <<= parse_term_expr(ctx, const_list);\n    }\n    return v;\n"]]}
{"hexsha": "49ec5b94c71f958868711ebc048cd068c3fbec23", "ext": "c", "lang": "C", "content": "pci_power_t intel_mid_pci_get_power_state(struct pci_dev *pdev)\n{\n\tstruct mid_pwr *pwr = midpwr;\n\tint id, reg, bit;\n\tu32 power;\n\n\tif (!pwr || !pwr->available)\n\t\treturn PCI_UNKNOWN;\n\n\tid = intel_mid_pwr_get_lss_id(pdev);\n\tif (id < 0)\n\t\treturn PCI_UNKNOWN;\n\n\treg = (id * LSS_PWS_BITS) / 32;\n\tbit = (id * LSS_PWS_BITS) % 32;\n\tpower = mid_pwr_get_state(pwr, reg);\n\treturn (__force pci_power_t)((power >> bit) & 3);\n}", "item_id": 6, "repo": "fergy/aplit_linux-5", "file": "arch/x86/platform/intel-mid/pwr.c", "last_update_at": "2022-03-07T12:09:00+00:00", "question_id": "49ec5b94c71f958868711ebc048cd068c3fbec23_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pci_power_t intel_mid_pci_get_power_state(struct pci_dev *pdev)\n{\n\tstruct mid_pwr *pwr = midpwr;\n\tint id, reg, bit;\n\tu32 power;\n\tif (!pwr || !pwr->available)\n\t\treturn PCI_UNKNOWN;\n\tid = intel_mid_pwr_get_lss_id(pdev);\n\tif (id < 0)\n\t\treturn PCI_UNKNOWN;\n\treg = (id * LSS_PWS_BITS) / 32;\n\tbit = (id * LSS_PWS_BITS) % 32;\n\tpower = mid_pwr_get_state(pwr, reg);\n\treturn (__force pci_power_t)((power >> bit) & 3);\n"]]}
{"hexsha": "c4cd0dcf37267cf27fd75ed3c543bf88c6333110", "ext": "c", "lang": "C", "content": "void gdb_service_start(void)\n{\n    struct netconn *gdb_netconn;\n    err_t err;\n\n\tgdb_netconn = netconn_new(NETCONN_TCP);\n    if (!gdb_netconn)\n    {\n        return;\n    }\n\n\terr = netconn_bind(gdb_netconn, IP_ADDR_ANY, 3333);\n    if (err != ERR_OK)\n    {\n        netconn_delete(gdb_netconn);\n        return;\n    }\n\n\terr = netconn_listen(gdb_netconn);\n    if (err != ERR_OK)\n    {\n        netconn_delete(gdb_netconn);\n        return;\n    }\n\n    thread_new(&gdb_thread, gdb_stack, sizeof(gdb_stack), gdb_mainloop, gdb_netconn);\n}", "item_id": 1, "repo": "westerndigitalcorporation/FissionOS", "file": "common/gdb_stub.c", "last_update_at": "2022-02-17T03:48:52+00:00", "question_id": "c4cd0dcf37267cf27fd75ed3c543bf88c6333110_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void gdb_service_start(void)\n{\n    struct netconn *gdb_netconn;\n    err_t err;\n\tgdb_netconn = netconn_new(NETCONN_TCP);\n    if (!gdb_netconn)\n    {\n        return;\n    }\n\terr = netconn_bind(gdb_netconn, IP_ADDR_ANY, 3333);\n    if (err != ERR_OK)\n    {\n        netconn_delete(gdb_netconn);\n        return;\n    }\n\terr = netconn_listen(gdb_netconn);\n    if (err != ERR_OK)\n    {\n        netconn_delete(gdb_netconn);\n        return;\n    }\n    thread_new(&gdb_thread, gdb_stack, sizeof(gdb_stack), gdb_mainloop, gdb_netconn);\n"]]}
{"hexsha": "3d05c51675fd421e2326362d54f3058964fd8563", "ext": "c", "lang": "C", "content": "static int n_div_eq(__isl_keep isl_basic_map *bmap)\n{\n\tint i;\n\tisl_size total, n_div;\n\n\tif (!bmap)\n\t\treturn -1;\n\n\tif (bmap->n_eq == 0)\n\t\treturn 0;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tif (total < 0 || n_div < 0)\n\t\treturn -1;\n\ttotal -= n_div;\n\n\tfor (i = 0; i < bmap->n_eq; ++i)\n\t\tif (isl_seq_first_non_zero(bmap->eq[i] + 1 + total,\n\t\t\t\t\t    n_div) == -1)\n\t\t\treturn i;\n\n\treturn bmap->n_eq;\n}", "item_id": 64, "repo": "chelini/isl-haystack", "file": "isl_map_simplify.c", "last_update_at": "2022-03-23T13:27:10+00:00", "question_id": "3d05c51675fd421e2326362d54f3058964fd8563_64", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int n_div_eq(__isl_keep isl_basic_map *bmap)\n{\n\tint i;\n\tisl_size total, n_div;\n\tif (!bmap)\n\t\treturn -1;\n\tif (bmap->n_eq == 0)\n\t\treturn 0;\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tif (total < 0 || n_div < 0)\n\t\treturn -1;\n\ttotal -= n_div;\n\tfor (i = 0; i < bmap->n_eq; ++i)\n\t\tif (isl_seq_first_non_zero(bmap->eq[i] + 1 + total,\n\t\t\t\t\t    n_div) == -1)\n\t\t\treturn i;\n\treturn bmap->n_eq;\n"]]}
{"hexsha": "82da462cdb51d2e69937533700f2cac5690b487f", "ext": "c", "lang": "C", "content": "TEST(uper_c_source_d_all_present)\n{\n    uint8_t encoded[10];\n    struct uper_c_source_d_t decoded;\n\n    /* Encode. */\n    decoded.length = 1;\n    decoded.elements[0].a.b.choice = uper_c_source_d_a_b_choice_c_e;\n    decoded.elements[0].a.b.value.c = 0;\n    decoded.elements[0].a.e.length = 3;\n    decoded.elements[0].g.h = uper_c_source_d_g_h_j_e;\n    decoded.elements[0].g.l.length = 2;\n    decoded.elements[0].g.l.buf[0] = 0x54;\n    decoded.elements[0].g.l.buf[1] = 0x55;\n    decoded.elements[0].m.is_n_present = true;\n    decoded.elements[0].m.n = false;\n    decoded.elements[0].m.o = 2;\n    decoded.elements[0].m.is_p_present = true;\n    memset(&decoded.elements[0].m.p.q.buf[0],\n           3,\n           sizeof(decoded.elements[0].m.p.q.buf));\n    decoded.elements[0].m.p.is_r_present = true;\n    decoded.elements[0].m.p.r = true;\n    decoded.elements[0].m.s = true;\n\n    ASSERT_EQ(uper_c_source_d_encode(&encoded[0],\n                                     sizeof(encoded),\n                                     &decoded), sizeof(encoded));\n    ASSERT_MEMORY_EQ(&encoded[0],\n                     \"\\x00\\xaa\\x2a\\xfa\\x40\\xc0\\xc0\\xc0\\xc0\\xf0\",\n                     sizeof(encoded));\n\n    /* Decode. */\n    memset(&decoded, 0, sizeof(decoded));\n    ASSERT_EQ(uper_c_source_d_decode(&decoded,\n                                     &encoded[0],\n                                     sizeof(encoded)), sizeof(encoded));\n\n    ASSERT_EQ(decoded.length, 1);\n    ASSERT_EQ(decoded.elements[0].a.b.choice, uper_c_source_d_a_b_choice_c_e);\n    ASSERT_EQ(decoded.elements[0].a.b.value.c, 0);\n    ASSERT_EQ(decoded.elements[0].a.e.length, 3);\n    ASSERT_EQ(decoded.elements[0].g.h, uper_c_source_d_g_h_j_e);\n    ASSERT_EQ(decoded.elements[0].g.l.length, 2);\n    ASSERT_EQ(decoded.elements[0].g.l.buf[0], 0x54);\n    ASSERT_EQ(decoded.elements[0].g.l.buf[1], 0x55);\n    ASSERT_TRUE(decoded.elements[0].m.is_n_present);\n    ASSERT_EQ(decoded.elements[0].m.n, false);\n    ASSERT_EQ(decoded.elements[0].m.o, 2);\n    ASSERT_TRUE(decoded.elements[0].m.is_p_present);\n    ASSERT_MEMORY_EQ(&decoded.elements[0].m.p.q.buf[0],\n                     \"\\x03\\x03\\x03\\x03\\x03\",\n                     sizeof(decoded.elements[0].m.p.q.buf));\n    ASSERT_TRUE(decoded.elements[0].m.p.is_r_present);\n    ASSERT_EQ(decoded.elements[0].m.p.r, true);\n    ASSERT_EQ(decoded.elements[0].m.s, true);\n}", "item_id": 9, "repo": "cromulencellc/asn1tools", "file": "tests/test_uper.c", "last_update_at": "2022-03-26T10:11:21+00:00", "question_id": "82da462cdb51d2e69937533700f2cac5690b487f_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TEST(uper_c_source_d_all_present)\n{\n    uint8_t encoded[10];\n    struct uper_c_source_d_t decoded;\n    /* Encode. */\n    decoded.length = 1;\n    decoded.elements[0].a.b.choice = uper_c_source_d_a_b_choice_c_e;\n    decoded.elements[0].a.b.value.c = 0;\n    decoded.elements[0].a.e.length = 3;\n    decoded.elements[0].g.h = uper_c_source_d_g_h_j_e;\n    decoded.elements[0].g.l.length = 2;\n    decoded.elements[0].g.l.buf[0] = 0x54;\n    decoded.elements[0].g.l.buf[1] = 0x55;\n    decoded.elements[0].m.is_n_present = true;\n    decoded.elements[0].m.n = false;\n    decoded.elements[0].m.o = 2;\n    decoded.elements[0].m.is_p_present = true;\n    memset(&decoded.elements[0].m.p.q.buf[0],\n           3,\n           sizeof(decoded.elements[0].m.p.q.buf));\n    decoded.elements[0].m.p.is_r_present = true;\n    decoded.elements[0].m.p.r = true;\n    decoded.elements[0].m.s = true;\n    ASSERT_EQ(uper_c_source_d_encode(&encoded[0],\n                                     sizeof(encoded),\n                                     &decoded), sizeof(encoded));\n    ASSERT_MEMORY_EQ(&encoded[0],\n                     \"\\x00\\xaa\\x2a\\xfa\\x40\\xc0\\xc0\\xc0\\xc0\\xf0\",\n                     sizeof(encoded));\n    /* Decode. */\n    memset(&decoded, 0, sizeof(decoded));\n    ASSERT_EQ(uper_c_source_d_decode(&decoded,\n                                     &encoded[0],\n                                     sizeof(encoded)), sizeof(encoded));\n    ASSERT_EQ(decoded.length, 1);\n    ASSERT_EQ(decoded.elements[0].a.b.choice, uper_c_source_d_a_b_choice_c_e);\n    ASSERT_EQ(decoded.elements[0].a.b.value.c, 0);\n    ASSERT_EQ(decoded.elements[0].a.e.length, 3);\n    ASSERT_EQ(decoded.elements[0].g.h, uper_c_source_d_g_h_j_e);\n    ASSERT_EQ(decoded.elements[0].g.l.length, 2);\n    ASSERT_EQ(decoded.elements[0].g.l.buf[0], 0x54);\n    ASSERT_EQ(decoded.elements[0].g.l.buf[1], 0x55);\n    ASSERT_TRUE(decoded.elements[0].m.is_n_present);\n    ASSERT_EQ(decoded.elements[0].m.n, false);\n    ASSERT_EQ(decoded.elements[0].m.o, 2);\n    ASSERT_TRUE(decoded.elements[0].m.is_p_present);\n    ASSERT_MEMORY_EQ(&decoded.elements[0].m.p.q.buf[0],\n                     \"\\x03\\x03\\x03\\x03\\x03\",\n                     sizeof(decoded.elements[0].m.p.q.buf));\n    ASSERT_TRUE(decoded.elements[0].m.p.is_r_present);\n    ASSERT_EQ(decoded.elements[0].m.p.r, true);\n    ASSERT_EQ(decoded.elements[0].m.s, true);\n"]]}
{"hexsha": "6192e4dce7f50f5188691999a83a09336c742eac", "ext": "h", "lang": "C", "content": "void insertBlind(const TypeID &id, Type obj)\n  {\n    HashItem *item = new HashItem(id, obj);\n    item->next( _table[hash(id)] );\n    _table[hash(id)] = item;\n    _numElements++;\n  }", "item_id": 0, "repo": "ezeeyahoo/earthenterprise", "file": "earth_enterprise/src/common/khHashTable.h", "last_update_at": "2022-03-30T09:43:19+00:00", "question_id": "6192e4dce7f50f5188691999a83a09336c742eac_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void insertBlind(const TypeID &id, Type obj)\n  {\n    HashItem *item = new HashItem(id, obj);\n    item->next( _table[hash(id)] );\n    _table[hash(id)] = item;\n    _numElements++;\n"]]}
{"hexsha": "8daa935f7dc29f9d3ff5901755a2a9f1d94511af", "ext": "c", "lang": "C", "content": "static cairo_test_status_t\ndraw_clip (cairo_t *cr, int width, int height)\n{\n    cairo_surface_t *surface;\n\n    surface = cairo_image_surface_create_for_data ((unsigned char *) data,\n\t\t\t\t\t\t   CAIRO_FORMAT_RGB24, 4, 4, 16);\n\n    cairo_test_paint_checkered (cr);\n\n    cairo_rectangle (cr, 10.5, 10.5, 11, 11);\n    cairo_clip (cr);\n\n    cairo_scale (cr, 4, 4);\n\n    cairo_set_source_surface (cr, surface, 2 , 2);\n    cairo_pattern_set_filter (cairo_get_source (cr), CAIRO_FILTER_NEAREST);\n    cairo_paint_with_alpha (cr, 0.5);\n\n    cairo_surface_finish (surface); /* data will go out of scope */\n    cairo_surface_destroy (surface);\n\n    return CAIRO_TEST_SUCCESS;\n}", "item_id": 2, "repo": "ayushajain/Scribe", "file": "server/server/cairo-1.12.18/test/paint-with-alpha.c", "last_update_at": "2022-02-15T00:34:42+00:00", "question_id": "8daa935f7dc29f9d3ff5901755a2a9f1d94511af_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static cairo_test_status_t\ndraw_clip (cairo_t *cr, int width, int height)\n{\n    cairo_surface_t *surface;\n    surface = cairo_image_surface_create_for_data ((unsigned char *) data,\n\t\t\t\t\t\t   CAIRO_FORMAT_RGB24, 4, 4, 16);\n    cairo_test_paint_checkered (cr);\n    cairo_rectangle (cr, 10.5, 10.5, 11, 11);\n    cairo_clip (cr);\n    cairo_scale (cr, 4, 4);\n    cairo_set_source_surface (cr, surface, 2 , 2);\n    cairo_pattern_set_filter (cairo_get_source (cr), CAIRO_FILTER_NEAREST);\n    cairo_paint_with_alpha (cr, 0.5);\n    cairo_surface_finish (surface); /* data will go out of scope */\n    cairo_surface_destroy (surface);\n    return CAIRO_TEST_SUCCESS;\n"]]}
{"hexsha": "f7d8adca84f47de9d9cc21a4fb67892e094cfa0f", "ext": "c", "lang": "C", "content": "static guint16\nde_rr_vgcs_tar_mode_ind(tvbuff_t *tvb, proto_tree *tree, guint32 offset, guint len _U_, gchar *add_string _U_, int string_len _U_)\n{\n    guint32\tcurr_offset;\n\n    curr_offset = offset;\n\n    proto_tree_add_item(tree, hf_gsm_a_rr_target_mode, tvb, curr_offset, 1, FALSE);\n    proto_tree_add_item(tree, hf_gsm_a_rr_group_cipher_key_number, tvb, curr_offset, 1, FALSE);\n    curr_offset = curr_offset + 1;\n\n    return(curr_offset - offset);\n}", "item_id": 79, "repo": "CGCL-codes/VulDeePecker", "file": "CWE-119/source_files/148881/packet-gsm_a_rr.c", "last_update_at": "2022-03-30T02:58:36+00:00", "question_id": "f7d8adca84f47de9d9cc21a4fb67892e094cfa0f_79", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static guint16\nde_rr_vgcs_tar_mode_ind(tvbuff_t *tvb, proto_tree *tree, guint32 offset, guint len _U_, gchar *add_string _U_, int string_len _U_)\n{\n    guint32\tcurr_offset;\n    curr_offset = offset;\n    proto_tree_add_item(tree, hf_gsm_a_rr_target_mode, tvb, curr_offset, 1, FALSE);\n    proto_tree_add_item(tree, hf_gsm_a_rr_group_cipher_key_number, tvb, curr_offset, 1, FALSE);\n    curr_offset = curr_offset + 1;\n    return(curr_offset - offset);\n"]]}
{"hexsha": "ec82bf3c4ff97d82840d7b524e4004229fe2935d", "ext": "c", "lang": "C", "content": "static void blackenFn(WrenVM* vm, ObjFn* fn)\n{\n  // Mark the constants.\n  wrenGrayBuffer(vm, &fn->constants);\n\n  // Keep track of how much memory is still in use.\n  vm->bytesAllocated += sizeof(ObjFn);\n  vm->bytesAllocated += sizeof(uint8_t) * fn->code.capacity;\n  vm->bytesAllocated += sizeof(Value) * fn->constants.capacity;\n  \n  // The debug line number buffer.\n  vm->bytesAllocated += sizeof(int) * fn->code.capacity;\n  // TODO: What about the function name?\n}", "item_id": 42, "repo": "CohenArthur/wren", "file": "src/vm/wren_value.c", "last_update_at": "2022-01-13T06:37:56+00:00", "question_id": "ec82bf3c4ff97d82840d7b524e4004229fe2935d_42", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void blackenFn(WrenVM* vm, ObjFn* fn)\n{\n  // Mark the constants.\n  wrenGrayBuffer(vm, &fn->constants);\n  // Keep track of how much memory is still in use.\n  vm->bytesAllocated += sizeof(ObjFn);\n  vm->bytesAllocated += sizeof(uint8_t) * fn->code.capacity;\n  vm->bytesAllocated += sizeof(Value) * fn->constants.capacity;\n  // The debug line number buffer.\n  vm->bytesAllocated += sizeof(int) * fn->code.capacity;\n  // TODO: What about the function name?\n"]]}
{"hexsha": "eaba584e98c31b83de79046f9ddc8e34f44ce284", "ext": "c", "lang": "C", "content": "int ldap_passwd_s(LDAP *ld, struct berval *user, struct berval *oldpw,\n                  struct berval *newpw, struct berval *newpasswd,\n                  LDAPControl **sctrls, LDAPControl **cctrls) {\n  int rc;\n  int msgid;\n  LDAPMessage *res;\n\n  rc = ldap_passwd(ld, user, oldpw, newpw, sctrls, cctrls, &msgid);\n  if (rc != LDAP_SUCCESS) {\n    return rc;\n  }\n\n  if (ldap_result(ld, msgid, LDAP_MSG_ALL, (struct timeval *)NULL, &res) ==\n          -1 ||\n      !res) {\n    return ld->ld_errno;\n  }\n\n  rc = ldap_parse_passwd(ld, res, newpasswd);\n  if (rc != LDAP_SUCCESS) {\n    ldap_msgfree(res);\n    return rc;\n  }\n\n  return (ldap_result2error(ld, res, 1));\n}", "item_id": 2, "repo": "isolovey-robarts/ReOpenLDAP", "file": "libraries/libreldap/passwd.c", "last_update_at": "2022-03-30T19:21:34+00:00", "question_id": "eaba584e98c31b83de79046f9ddc8e34f44ce284_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int ldap_passwd_s(LDAP *ld, struct berval *user, struct berval *oldpw,\n                  struct berval *newpw, struct berval *newpasswd,\n                  LDAPControl **sctrls, LDAPControl **cctrls) {\n  int rc;\n  int msgid;\n  LDAPMessage *res;\n  rc = ldap_passwd(ld, user, oldpw, newpw, sctrls, cctrls, &msgid);\n  if (rc != LDAP_SUCCESS) {\n    return rc;\n  }\n  if (ldap_result(ld, msgid, LDAP_MSG_ALL, (struct timeval *)NULL, &res) ==\n          -1 ||\n      !res) {\n    return ld->ld_errno;\n  }\n  rc = ldap_parse_passwd(ld, res, newpasswd);\n  if (rc != LDAP_SUCCESS) {\n    ldap_msgfree(res);\n    return rc;\n  }\n  return (ldap_result2error(ld, res, 1));\n"]]}
{"hexsha": "58ae6bd675ec8fe3e4fcf4fbdb1f789e036ea1fe", "ext": "c", "lang": "C", "content": "int proposalPool_proposal_add(RLO_proposal_state* pools, RLO_proposal_state* pp_in) {//add new, or merge value\n    if(!pools || !pp_in)\n        return -1;\n\n    int i = 0;\n    for(i = 0; i <= PROPOSAL_POOL_SIZE - 1; i++) {//exists, merge\n        if(pools[i].pid == pp_in->pid) {\n            printf(\"Function %s:%u - find proposal, pid = %d , index = %d\\n\", __func__, __LINE__, pp_in->pid, i);\n            pools[i] = *pp_in;\n            printf(\"Function %s:%u - confirm in array, pid = %d , index = %d\\n\", __func__, __LINE__, pools[i].pid, i);\n            return i;\n        }\n    }\n\n    // id not found, add new one.\n    for(i = 0; i <= PROPOSAL_POOL_SIZE - 1; i++) {\n        if(pools[i].pid == -1) {//first available\n            pools[i]= *pp_in;\n//            printf(\"Function %s:%u - pp added, confirm in array, pid = %d , index = %d\\n\", __func__, __LINE__, pools[i].pid, i);\n            return i;\n        }\n    }\n\n    if(i == PROPOSAL_POOL_SIZE - 1) //no empty pool for use.\n        return -1;\n\n    return -2;\n}", "item_id": 36, "repo": "mierl/rootless-coll-mpi-ops", "file": "rootless_ops.c", "last_update_at": "2022-01-10T17:08:04+00:00", "question_id": "58ae6bd675ec8fe3e4fcf4fbdb1f789e036ea1fe_36", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int proposalPool_proposal_add(RLO_proposal_state* pools, RLO_proposal_state* pp_in) {//add new, or merge value\n    if(!pools || !pp_in)\n        return -1;\n    int i = 0;\n    for(i = 0; i <= PROPOSAL_POOL_SIZE - 1; i++) {//exists, merge\n        if(pools[i].pid == pp_in->pid) {\n            printf(\"Function %s:%u - find proposal, pid = %d , index = %d\\n\", __func__, __LINE__, pp_in->pid, i);\n            pools[i] = *pp_in;\n            printf(\"Function %s:%u - confirm in array, pid = %d , index = %d\\n\", __func__, __LINE__, pools[i].pid, i);\n            return i;\n        }\n    }\n    // id not found, add new one.\n    for(i = 0; i <= PROPOSAL_POOL_SIZE - 1; i++) {\n        if(pools[i].pid == -1) {//first available\n            pools[i]= *pp_in;\n//            printf(\"Function %s:%u - pp added, confirm in array, pid = %d , index = %d\\n\", __func__, __LINE__, pools[i].pid, i);\n            return i;\n        }\n    }\n    if(i == PROPOSAL_POOL_SIZE - 1) //no empty pool for use.\n        return -1;\n    return -2;\n"]]}
{"hexsha": "21e45b94981a3d6e289cb7a2fd99268f0b20a834", "ext": "c", "lang": "C", "content": "static int data_raw_string_is(data_raw_t *dat, char *key)\n{\n    char *cx;\n    int pos;\n\n    if (dat->type != rawtyp_Str)\n        gli_fatal_error(\"data: Need str\");\n\n    for (pos=0, cx=key; *cx && pos<dat->count; pos++, cx++) {\n        if (dat->str[pos] != (glui32)(*cx))\n            break;\n    }\n\n    if (*cx == '\\0' && pos == dat->count)\n        return TRUE;\n    else\n        return FALSE;\n}", "item_id": 19, "repo": "zedlopez/remglk", "file": "rgdata.c", "last_update_at": "2022-03-16T00:33:09+00:00", "question_id": "21e45b94981a3d6e289cb7a2fd99268f0b20a834_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int data_raw_string_is(data_raw_t *dat, char *key)\n{\n    char *cx;\n    int pos;\n    if (dat->type != rawtyp_Str)\n        gli_fatal_error(\"data: Need str\");\n    for (pos=0, cx=key; *cx && pos<dat->count; pos++, cx++) {\n        if (dat->str[pos] != (glui32)(*cx))\n            break;\n    }\n    if (*cx == '\\0' && pos == dat->count)\n        return TRUE;\n    else\n        return FALSE;\n"]]}
{"hexsha": "11aa2ae6d63a23732e5a1d6532138d358c6bf0e9", "ext": "c", "lang": "C", "content": "static int\nvips_foreign_save_csv_build( VipsObject *object )\n{\n\tVipsForeignSave *save = (VipsForeignSave *) object;\n\tVipsForeignSaveCsv *csv = (VipsForeignSaveCsv *) object;\n\n\tif( VIPS_OBJECT_CLASS( vips_foreign_save_csv_parent_class )->\n\t\tbuild( object ) )\n\t\treturn( -1 );\n\n\tif( vips__csv_write( save->ready, csv->filename, csv->separator ) )\n\t\treturn( -1 );\n\n\treturn( 0 );\n}", "item_id": 0, "repo": "keiserlab/consensus-learning-paper", "file": "software_packages/libvips-8.2.2/libvips/foreign/csvsave.c", "last_update_at": "2022-03-21T15:34:17+00:00", "question_id": "11aa2ae6d63a23732e5a1d6532138d358c6bf0e9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nvips_foreign_save_csv_build( VipsObject *object )\n{\n\tVipsForeignSave *save = (VipsForeignSave *) object;\n\tVipsForeignSaveCsv *csv = (VipsForeignSaveCsv *) object;\n\tif( VIPS_OBJECT_CLASS( vips_foreign_save_csv_parent_class )->\n\t\tbuild( object ) )\n\t\treturn( -1 );\n\tif( vips__csv_write( save->ready, csv->filename, csv->separator ) )\n\t\treturn( -1 );\n\treturn( 0 );\n"]]}
{"hexsha": "647a22baaeb86ca37e6d50b641069ade6552a1df", "ext": "c", "lang": "C", "content": "static void bmw_LoopShellWalker_visitLoop(BMWalker *walker, BMLoop *l)\n{\n  BMwLoopShellWalker *shellWalk = NULL;\n\n  if (BLI_gset_haskey(walker->visit_set, l)) {\n    return;\n  }\n\n  if (!bmw_mask_check_face(walker, l->f)) {\n    return;\n  }\n\n  shellWalk = BMW_state_add(walker);\n  shellWalk->curloop = l;\n  BLI_gset_insert(walker->visit_set, l);\n}", "item_id": 7, "repo": "noorbeast/blender", "file": "source/blender/bmesh/intern/bmesh_walkers_impl.c", "last_update_at": "2022-03-03T15:50:51+00:00", "question_id": "647a22baaeb86ca37e6d50b641069ade6552a1df_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void bmw_LoopShellWalker_visitLoop(BMWalker *walker, BMLoop *l)\n{\n  BMwLoopShellWalker *shellWalk = NULL;\n  if (BLI_gset_haskey(walker->visit_set, l)) {\n    return;\n  }\n  if (!bmw_mask_check_face(walker, l->f)) {\n    return;\n  }\n  shellWalk = BMW_state_add(walker);\n  shellWalk->curloop = l;\n  BLI_gset_insert(walker->visit_set, l);\n"]]}
{"hexsha": "9144ea0825ed07afa176b2b40cf8d55691bf0110", "ext": "c", "lang": "C", "content": "_CODE_ZCL_ static void zcl_gp_sinkTabReqParse(u8 *pData, zcl_gp_sinkTabReqCmd_t *pCmd)\n{\n\tpCmd->options.opts = *pData++;\n\n\tif(pCmd->options.bits.appId == GP_APP_ID_SRC_ID){\n\t\tpCmd->gpdId.srcId = BUILD_U32(pData[0], pData[1], pData[2], pData[3]);\n\t\tpData += 4;\n\t}else if(pCmd->options.bits.appId == GP_APP_ID_GPD){\n\t\tZB_64BIT_ADDR_COPY(pCmd->gpdId.gpdIeeeAddr, pData);\n\t\tpData += EXT_ADDR_LEN;\n\t\tpCmd->endpoint = *pData++;\n\t}\n\n\tif(pCmd->options.bits.reqType == REQUEST_TABLE_ENTRIES_BY_INDEX){\n\t\tpCmd->index = *pData++;\n\t}\n}", "item_id": 14, "repo": "devbis/tl_zigbee_sdk", "file": "zigbee/zcl/general/zcl_greenPower.c", "last_update_at": "2022-03-18T07:20:23+00:00", "question_id": "9144ea0825ed07afa176b2b40cf8d55691bf0110_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["_CODE_ZCL_ static void zcl_gp_sinkTabReqParse(u8 *pData, zcl_gp_sinkTabReqCmd_t *pCmd)\n{\n\tpCmd->options.opts = *pData++;\n\tif(pCmd->options.bits.appId == GP_APP_ID_SRC_ID){\n\t\tpCmd->gpdId.srcId = BUILD_U32(pData[0], pData[1], pData[2], pData[3]);\n\t\tpData += 4;\n\t}else if(pCmd->options.bits.appId == GP_APP_ID_GPD){\n\t\tZB_64BIT_ADDR_COPY(pCmd->gpdId.gpdIeeeAddr, pData);\n\t\tpData += EXT_ADDR_LEN;\n\t\tpCmd->endpoint = *pData++;\n\t}\n\tif(pCmd->options.bits.reqType == REQUEST_TABLE_ENTRIES_BY_INDEX){\n\t\tpCmd->index = *pData++;\n\t}\n"]]}
{"hexsha": "ad46be12731eced24db8f0e5d9e4f32f9bc9b16f", "ext": "c", "lang": "C", "content": "static inline void RENAME(rgb24ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)\n{\n\tint i;\n        assert(src1==src2);\n\tfor(i=0; i<width; i++)\n\t{\n\t\tint r= src1[6*i + 0] + src1[6*i + 3];\n\t\tint g= src1[6*i + 1] + src1[6*i + 4];\n\t\tint b= src1[6*i + 2] + src1[6*i + 5];\n\n\t\tdstU[i]= ((RU*r + GU*g + BU*b)>>(RGB2YUV_SHIFT+1)) + 128;\n\t\tdstV[i]= ((RV*r + GV*g + BV*b)>>(RGB2YUV_SHIFT+1)) + 128;\n\t}\n}", "item_id": 6, "repo": "Narflex/sagetv", "file": "third_party/mplayer/libswscale/swscale_template.c", "last_update_at": "2022-01-26T00:38:45+00:00", "question_id": "ad46be12731eced24db8f0e5d9e4f32f9bc9b16f_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void RENAME(rgb24ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)\n{\n\tint i;\n        assert(src1==src2);\n\tfor(i=0; i<width; i++)\n\t{\n\t\tint r= src1[6*i + 0] + src1[6*i + 3];\n\t\tint g= src1[6*i + 1] + src1[6*i + 4];\n\t\tint b= src1[6*i + 2] + src1[6*i + 5];\n\t\tdstU[i]= ((RU*r + GU*g + BU*b)>>(RGB2YUV_SHIFT+1)) + 128;\n\t\tdstV[i]= ((RV*r + GV*g + BV*b)>>(RGB2YUV_SHIFT+1)) + 128;\n\t}\n"]]}
{"hexsha": "d07f88bd6be5a69ce5235f8570193f1a2f7cda6b", "ext": "h", "lang": "C", "content": "eType findWithDuplicates(eType v) {\n    kType vKey = hashStruct.getKey(v);\n    intT h = firstIndex(vKey);\n    eType c = TA[h];\n    while (1) {\n      if (c == empty) {\n\treturn empty;\n      } else if (!hashStruct.cmp(vKey,hashStruct.getKey(c))) {\n\tintT* vCoordinates = (intT *)v.first;\n\tintT* cCoordinates = (intT *)c.first;\n\tlong i = 0;\n\tfor(;i<g_dim;i++) {\n\t  if(vCoordinates[i] != cCoordinates[i])\n\t    break;\n\t}\n\tif(i == g_dim) {\n\t  // never reach here\n\t  return c;\n\t}\n      }\n      h = incrementIndex(h);\n      c = TA[h];\n    }\n  }", "item_id": 7, "repo": "wangyiqiu/closest-pair", "file": "pbbs/ndHash.h", "last_update_at": "2022-02-27T05:09:32+00:00", "question_id": "d07f88bd6be5a69ce5235f8570193f1a2f7cda6b_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["eType findWithDuplicates(eType v) {\n    kType vKey = hashStruct.getKey(v);\n    intT h = firstIndex(vKey);\n    eType c = TA[h];\n    while (1) {\n      if (c == empty) {\n\treturn empty;\n      } else if (!hashStruct.cmp(vKey,hashStruct.getKey(c))) {\n\tintT* vCoordinates = (intT *)v.first;\n\tintT* cCoordinates = (intT *)c.first;\n\tlong i = 0;\n\tfor(;i<g_dim;i++) {\n\t  if(vCoordinates[i] != cCoordinates[i])\n\t    break;\n\t}\n\tif(i == g_dim) {\n\t  // never reach here\n\t  return c;\n\t}\n      }\n      h = incrementIndex(h);\n      c = TA[h];\n    }\n"]]}
{"hexsha": "2c8f2f259ff44d18eee9a8c38868283d25b47adf", "ext": "c", "lang": "C", "content": "int main(int argc, char*argv[]) {\n    srand( time(NULL) );\n\n    // options\n    float phase_offset = M_PI / 4.0f;   // phase offset\n    float frequency_offset = 0.3f;      // frequency offset\n    float pll_bandwidth = 0.01f;        // PLL bandwidth\n    float zeta = 1/sqrtf(2.0f);         // PLL damping factor\n    float K = 1000.0f;                  // PLL loop gain\n    unsigned int n=512;                 // number of iterations\n\n    int dopt;\n    while ((dopt = getopt(argc,argv,\"uhb:z:K:n:p:f:\")) != EOF) {\n        switch (dopt) {\n        case 'u':\n        case 'h':   usage();    return 0;\n        case 'b':   pll_bandwidth = atof(optarg);   break;\n        case 'z':   zeta = atof(optarg);            break;\n        case 'K':   K = atof(optarg);               break;\n        case 'n':   n = atoi(optarg);               break;\n        case 'p':   phase_offset = atof(optarg);    break;\n        case 'f':   frequency_offset= atof(optarg); break;\n        default:\n            exit(1);\n        }\n    }\n    unsigned int d=n/32;      // print every \"d\" lines\n\n    // validate input\n    if (pll_bandwidth <= 0.0f) {\n        fprintf(stderr,\"error: bandwidth must be greater than 0\\n\");\n        exit(1);\n    } else if (zeta <= 0.0f) {\n        fprintf(stderr,\"error: damping factor must be greater than 0\\n\");\n        exit(1);\n    } else if (K <= 0.0f) {\n        fprintf(stderr,\"error: loop gain must be greater than 0\\n\");\n        exit(1);\n    }\n\n    // data arrays\n    float complex x[n];         // input complex sinusoid\n    float complex y[n];         // output complex sinusoid\n    float phase_error[n];       // output phase error\n\n    // generate PLL filter\n    float b[3];\n    float a[3];\n    iirdes_pll_active_lag(pll_bandwidth, zeta, K, b, a);\n    iirfilt_rrrf pll = iirfilt_rrrf_create(b,3,a,3);\n    iirfilt_rrrf_print(pll);\n\n    unsigned int i;\n    float phi;\n    for (i=0; i<n; i++) {\n        phi = phase_offset + i*frequency_offset;\n        x[i] = cexpf(_Complex_I*phi);\n    }\n\n    // run loop\n    float theta = 0.0f;\n    y[0] = 1.0f;\n    for (i=0; i<n; i++) {\n\n        // generate complex sinusoid\n        y[i] = cexpf(_Complex_I*theta);\n\n        // compute phase error\n        phase_error[i] = cargf(x[i]*conjf(y[i]));\n\n        // update pll\n        iirfilt_rrrf_execute(pll, phase_error[i], &theta);\n\n        // print phase error\n        if ((i)%d == 0 || i==n-1 || i==0)\n            printf(\"%4u : phase error = %12.8f\\n\", i, phase_error[i]);\n    }\n\n    // destroy filter object\n    iirfilt_rrrf_destroy(pll);\n\n    // write output file\n    FILE * fid = fopen(OUTPUT_FILENAME,\"w\");\n    fprintf(fid,\"%% %s : auto-generated file\\n\", OUTPUT_FILENAME);\n    fprintf(fid,\"clear all;\\n\");\n    fprintf(fid,\"close all;\\n\");\n    fprintf(fid,\"n = %u;\\n\", n);\n    fprintf(fid,\"x = zeros(1,n);\\n\");\n    fprintf(fid,\"y = zeros(1,n);\\n\");\n    for (i=0; i<n; i++) {\n        fprintf(fid,\"x(%4u) = %12.4e + j*%12.4e;\\n\", i+1, crealf(x[i]), cimagf(x[i]));\n        fprintf(fid,\"y(%4u) = %12.4e + j*%12.4e;\\n\", i+1, crealf(y[i]), cimagf(y[i]));\n        fprintf(fid,\"e(%4u) = %12.4e;\\n\", i+1, phase_error[i]);\n    }\n    fprintf(fid,\"t=0:(n-1);\\n\");\n    fprintf(fid,\"figure;\\n\");\n    fprintf(fid,\"subplot(2,1,1);\\n\");\n    fprintf(fid,\"  plot(t,real(x),t,real(y));\\n\");\n    fprintf(fid,\"  xlabel('time');\\n\");\n    fprintf(fid,\"  ylabel('real');\\n\");\n    fprintf(fid,\"subplot(2,1,2);\\n\");\n    fprintf(fid,\"  plot(t,imag(x),t,imag(y));\\n\");\n    fprintf(fid,\"  xlabel('time');\\n\");\n    fprintf(fid,\"  ylabel('imag');\\n\");\n\n    fprintf(fid,\"figure;\\n\");\n    fprintf(fid,\"plot(t,e);\\n\");\n    fprintf(fid,\"xlabel('time');\\n\");\n    fprintf(fid,\"ylabel('phase error');\\n\");\n    fprintf(fid,\"grid on;\\n\");\n\n    fclose(fid);\n    printf(\"results written to %s.\\n\",OUTPUT_FILENAME);\n\n    printf(\"done.\\n\");\n    return 0;\n}", "item_id": 1, "repo": "vankxr/liquid-dsp", "file": "examples/iirdes_pll_example.c", "last_update_at": "2022-03-31T18:31:06+00:00", "question_id": "2c8f2f259ff44d18eee9a8c38868283d25b47adf_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char*argv[]) {\n    srand( time(NULL) );\n    // options\n    float phase_offset = M_PI / 4.0f;   // phase offset\n    float frequency_offset = 0.3f;      // frequency offset\n    float pll_bandwidth = 0.01f;        // PLL bandwidth\n    float zeta = 1/sqrtf(2.0f);         // PLL damping factor\n    float K = 1000.0f;                  // PLL loop gain\n    unsigned int n=512;                 // number of iterations\n    int dopt;\n    while ((dopt = getopt(argc,argv,\"uhb:z:K:n:p:f:\")) != EOF) {\n        switch (dopt) {\n        case 'u':\n        case 'h':   usage();    return 0;\n        case 'b':   pll_bandwidth = atof(optarg);   break;\n        case 'z':   zeta = atof(optarg);            break;\n        case 'K':   K = atof(optarg);               break;\n        case 'n':   n = atoi(optarg);               break;\n        case 'p':   phase_offset = atof(optarg);    break;\n        case 'f':   frequency_offset= atof(optarg); break;\n        default:\n            exit(1);\n        }\n    }\n    unsigned int d=n/32;      // print every \"d\" lines\n    // validate input\n    if (pll_bandwidth <= 0.0f) {\n        fprintf(stderr,\"error: bandwidth must be greater than 0\\n\");\n        exit(1);\n    } else if (zeta <= 0.0f) {\n        fprintf(stderr,\"error: damping factor must be greater than 0\\n\");\n        exit(1);\n    } else if (K <= 0.0f) {\n        fprintf(stderr,\"error: loop gain must be greater than 0\\n\");\n        exit(1);\n    }\n    // data arrays\n    float complex x[n];         // input complex sinusoid\n    float complex y[n];         // output complex sinusoid\n    float phase_error[n];       // output phase error\n    // generate PLL filter\n    float b[3];\n    float a[3];\n    iirdes_pll_active_lag(pll_bandwidth, zeta, K, b, a);\n    iirfilt_rrrf pll = iirfilt_rrrf_create(b,3,a,3);\n    iirfilt_rrrf_print(pll);\n    unsigned int i;\n    float phi;\n    for (i=0; i<n; i++) {\n        phi = phase_offset + i*frequency_offset;\n        x[i] = cexpf(_Complex_I*phi);\n    }\n    // run loop\n    float theta = 0.0f;\n    y[0] = 1.0f;\n    for (i=0; i<n; i++) {\n        // generate complex sinusoid\n        y[i] = cexpf(_Complex_I*theta);\n        // compute phase error\n        phase_error[i] = cargf(x[i]*conjf(y[i]));\n        // update pll\n        iirfilt_rrrf_execute(pll, phase_error[i], &theta);\n        // print phase error\n        if ((i)%d == 0 || i==n-1 || i==0)\n            printf(\"%4u : phase error = %12.8f\\n\", i, phase_error[i]);\n    }\n    // destroy filter object\n    iirfilt_rrrf_destroy(pll);\n    // write output file\n    FILE * fid = fopen(OUTPUT_FILENAME,\"w\");\n    fprintf(fid,\"%% %s : auto-generated file\\n\", OUTPUT_FILENAME);\n    fprintf(fid,\"clear all;\\n\");\n    fprintf(fid,\"close all;\\n\");\n    fprintf(fid,\"n = %u;\\n\", n);\n    fprintf(fid,\"x = zeros(1,n);\\n\");\n    fprintf(fid,\"y = zeros(1,n);\\n\");\n    for (i=0; i<n; i++) {\n        fprintf(fid,\"x(%4u) = %12.4e + j*%12.4e;\\n\", i+1, crealf(x[i]), cimagf(x[i]));\n        fprintf(fid,\"y(%4u) = %12.4e + j*%12.4e;\\n\", i+1, crealf(y[i]), cimagf(y[i]));\n        fprintf(fid,\"e(%4u) = %12.4e;\\n\", i+1, phase_error[i]);\n    }\n    fprintf(fid,\"t=0:(n-1);\\n\");\n    fprintf(fid,\"figure;\\n\");\n    fprintf(fid,\"subplot(2,1,1);\\n\");\n    fprintf(fid,\"  plot(t,real(x),t,real(y));\\n\");\n    fprintf(fid,\"  xlabel('time');\\n\");\n    fprintf(fid,\"  ylabel('real');\\n\");\n    fprintf(fid,\"subplot(2,1,2);\\n\");\n    fprintf(fid,\"  plot(t,imag(x),t,imag(y));\\n\");\n    fprintf(fid,\"  xlabel('time');\\n\");\n    fprintf(fid,\"  ylabel('imag');\\n\");\n    fprintf(fid,\"figure;\\n\");\n    fprintf(fid,\"plot(t,e);\\n\");\n    fprintf(fid,\"xlabel('time');\\n\");\n    fprintf(fid,\"ylabel('phase error');\\n\");\n    fprintf(fid,\"grid on;\\n\");\n    fclose(fid);\n    printf(\"results written to %s.\\n\",OUTPUT_FILENAME);\n    printf(\"done.\\n\");\n    return 0;\n"]]}
{"hexsha": "30ed51a11ec34df78071e32e67190ad3ef5cc7e9", "ext": "c", "lang": "C", "content": "static struct str\nsys_x11_clipboard_get(struct arena *a) {\n  struct str ret;\n  ret = arena_str(a, &sys, str(x11.clip.data, x11.clip.len));\n  return ret;\n}", "item_id": 27, "repo": "vurtun/muon", "file": "src/sys/sys_x11.c", "last_update_at": "2022-03-31T09:57:10+00:00", "question_id": "30ed51a11ec34df78071e32e67190ad3ef5cc7e9_27", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct str\nsys_x11_clipboard_get(struct arena *a) {\n  struct str ret;\n  ret = arena_str(a, &sys, str(x11.clip.data, x11.clip.len));\n  return ret;\n"]]}
{"hexsha": "2f2fb6b6adbafdc2abefc39fdbea04247c42ee39", "ext": "c", "lang": "C", "content": "static int\nupdate_bootinfo (struct devinfo_context *ctx)\n{\n\tuint32_t *crcptr;\n\tstruct device_info *info;\n\tssize_t n, cnt;\n\tint idx;\n\n\tif (ctx == NULL) {\n\t\tfprintf(stderr, \"error: invalid context provided for update\\n\");\n\t\treturn -1;\n\t}\n\tif (ctx->readonly) {\n\t\tfprintf(stderr, \"error: update requested for read-only context\\n\");\n\t\treturn -1;\n\t}\n\t/*\n\t * Invalid current index -> initialize\n\t */\n\tif (ctx->current < 0 || ctx->current > 1)\n\t\tidx = 0;\n\telse\n\t\tidx = 1 - ctx->current;\n\n\tinfo = (struct device_info *) ctx->infobuf[idx];\n\tcrcptr = (uint32_t *) &ctx->infobuf[idx][DEVINFO_BLOCK_SIZE + EXTENSION_SIZE - sizeof(uint32_t)];\n\tmemset(info, 0, DEVINFO_BLOCK_SIZE);\n\tmemcpy(info->magic, DEVICE_MAGIC, sizeof(info->magic));\n\tinfo->devinfo_version = DEVINFO_VERSION_CURRENT;\n\tinfo->flags = ctx->curinfo.flags;\n\tinfo->failed_boots = ctx->curinfo.failed_boots;\n\tinfo->sernum = ctx->curinfo.sernum + 1;\n\tinfo->ext_sectors = EXTENSION_SECTOR_COUNT;\n\tif (pack_vars(ctx, idx) < 0)\n\t\treturn -1;\n\tinfo->crcsum = crc32(0, ctx->infobuf[idx], DEVINFO_BLOCK_SIZE);\n\t*crcptr = crc32(0, &ctx->infobuf[idx][DEVINFO_BLOCK_SIZE], EXTENSION_SIZE-sizeof(uint32_t));\n\n\tif (lseek(ctx->fd, devinfo_offset[idx], SEEK_END) < 0) {\n\t\tperror(devinfo_dev);\n\t\tset_bootdev_writeable_status(devinfo_dev, false);\n\t\treturn -1;\n\t}\n\tfor (n = 0; n < DEVINFO_BLOCK_SIZE; n += cnt) {\n\t\tcnt = write(ctx->fd, ctx->infobuf[idx] + n, DEVINFO_BLOCK_SIZE-n);\n\t\tif (cnt < 0) {\n\t\t\tperror(devinfo_dev);\n\t\t\tset_bootdev_writeable_status(devinfo_dev, false);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (lseek(ctx->fd, extension_offset[idx], SEEK_END) < 0) {\n\t\tperror(devinfo_dev);\n\t\tset_bootdev_writeable_status(devinfo_dev, false);\n\t\treturn -1;\n\t}\n\tfor (n = 0; n < EXTENSION_SIZE; n += cnt) {\n\t\tcnt = write(ctx->fd, ctx->infobuf[idx] + DEVINFO_BLOCK_SIZE + n, EXTENSION_SIZE-n);\n\t\tif (cnt < 0) {\n\t\t\tperror(devinfo_dev);\n\t\t\tset_bootdev_writeable_status(devinfo_dev, false);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n\n}", "item_id": 6, "repo": "kekiefer/tegra-boot-tools", "file": "tegra-bootinfo.c", "last_update_at": "2022-03-23T04:11:07+00:00", "question_id": "2f2fb6b6adbafdc2abefc39fdbea04247c42ee39_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nupdate_bootinfo (struct devinfo_context *ctx)\n{\n\tuint32_t *crcptr;\n\tstruct device_info *info;\n\tssize_t n, cnt;\n\tint idx;\n\tif (ctx == NULL) {\n\t\tfprintf(stderr, \"error: invalid context provided for update\\n\");\n\t\treturn -1;\n\t}\n\tif (ctx->readonly) {\n\t\tfprintf(stderr, \"error: update requested for read-only context\\n\");\n\t\treturn -1;\n\t}\n\t/*\n\t * Invalid current index -> initialize\n\t */\n\tif (ctx->current < 0 || ctx->current > 1)\n\t\tidx = 0;\n\telse\n\t\tidx = 1 - ctx->current;\n\tinfo = (struct device_info *) ctx->infobuf[idx];\n\tcrcptr = (uint32_t *) &ctx->infobuf[idx][DEVINFO_BLOCK_SIZE + EXTENSION_SIZE - sizeof(uint32_t)];\n\tmemset(info, 0, DEVINFO_BLOCK_SIZE);\n\tmemcpy(info->magic, DEVICE_MAGIC, sizeof(info->magic));\n\tinfo->devinfo_version = DEVINFO_VERSION_CURRENT;\n\tinfo->flags = ctx->curinfo.flags;\n\tinfo->failed_boots = ctx->curinfo.failed_boots;\n\tinfo->sernum = ctx->curinfo.sernum + 1;\n\tinfo->ext_sectors = EXTENSION_SECTOR_COUNT;\n\tif (pack_vars(ctx, idx) < 0)\n\t\treturn -1;\n\tinfo->crcsum = crc32(0, ctx->infobuf[idx], DEVINFO_BLOCK_SIZE);\n\t*crcptr = crc32(0, &ctx->infobuf[idx][DEVINFO_BLOCK_SIZE], EXTENSION_SIZE-sizeof(uint32_t));\n\tif (lseek(ctx->fd, devinfo_offset[idx], SEEK_END) < 0) {\n\t\tperror(devinfo_dev);\n\t\tset_bootdev_writeable_status(devinfo_dev, false);\n\t\treturn -1;\n\t}\n\tfor (n = 0; n < DEVINFO_BLOCK_SIZE; n += cnt) {\n\t\tcnt = write(ctx->fd, ctx->infobuf[idx] + n, DEVINFO_BLOCK_SIZE-n);\n\t\tif (cnt < 0) {\n\t\t\tperror(devinfo_dev);\n\t\t\tset_bootdev_writeable_status(devinfo_dev, false);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (lseek(ctx->fd, extension_offset[idx], SEEK_END) < 0) {\n\t\tperror(devinfo_dev);\n\t\tset_bootdev_writeable_status(devinfo_dev, false);\n\t\treturn -1;\n\t}\n\tfor (n = 0; n < EXTENSION_SIZE; n += cnt) {\n\t\tcnt = write(ctx->fd, ctx->infobuf[idx] + DEVINFO_BLOCK_SIZE + n, EXTENSION_SIZE-n);\n\t\tif (cnt < 0) {\n\t\t\tperror(devinfo_dev);\n\t\t\tset_bootdev_writeable_status(devinfo_dev, false);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n"]]}
{"hexsha": "e937223d5d2cbc4ef41129d413aeb4c27d55fdf7", "ext": "c", "lang": "C", "content": "void board_spifi_initialize(void)\n{\n  irqstate_t flags = enter_critical_section();\n  uint32_t regval;\n\n  flags = enter_critical_section();\n\n  /* Initial frequency is set by boot ROM in IDIVE */\n\n  /* Pin configuration */\n\n  lpc43_pin_config(PINCONF_SPIFI_CS);\n  lpc43_pin_config(PINCONF_SPIFI_MISO);\n  lpc43_pin_config(PINCONF_SPIFI_MOSI);\n  lpc43_pin_config(PINCONF_SPIFI_SCK);\n  lpc43_pin_config(PINCONF_SPIFI_SIO2);\n  lpc43_pin_config(PINCONF_SPIFI_SIO3);\n\n  /* Initialize LPCSPIFILIB library, reset the interface */\n\n  spifiInit(LPC43_SPIFI_CTRL, true);\n\n  /* Register the family for the device */\n\n  spifiRegisterFamily(spifi_REG_FAMILY_CommonCommandSet);\n\n  /* Initialize and detect a device and get device context */\n\n  SPIFI_HANDLE_T *pSpifi = spifiInitDevice(&lmem, sizeof(lmem),\n                                           LPC43_SPIFI_CTRL,\n                                           LPC43_LOCSRAM_SPIFI_BASE);\n\n  /* Enable quad.  If not supported it will be ignored */\n\n  spifiDevSetOpts(pSpifi, SPIFI_OPT_USE_QUAD, true);\n\n  /* Enter memMode */\n\n  spifiDevSetMemMode(pSpifi, true);\n\n  /* Configure divider as the input to the SPIFI */\n\n  regval  = getreg32(LPC43_BASE_SPIFI_CLK);\n  regval &= ~BASE_SPIFI_CLK_CLKSEL_MASK;\n  regval |= BASE_SPIFI_CLKSEL_IDIVE;\n  putreg32(regval, LPC43_BASE_SPIFI_CLK);\n\n  regval  = getreg32(LPC43_IDIVE_CTRL);\n  regval &= ~(IDIVE_CTRL_CLKSEL_MASK | IDIVE_CTRL_IDIV_MASK);\n  regval |= BASE_SPIFI_CLKSEL_PLL1 | IDIVE_CTRL_AUTOBLOCK |\n            IDIVE_CTRL_IDIV(SPIFI_DEVICE_REQUENCY_DIVIDER);\n  putreg32(regval, LPC43_IDIVE_CTRL);\n\n  leave_critical_section(flags);\n}", "item_id": 0, "repo": "eenurkka/incubator-nuttx", "file": "boards/arm/lpc43xx/lpc4370-link2/src/lpc43_spifilib_init.c", "last_update_at": "2022-01-04T04:04:56+00:00", "question_id": "e937223d5d2cbc4ef41129d413aeb4c27d55fdf7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void board_spifi_initialize(void)\n{\n  irqstate_t flags = enter_critical_section();\n  uint32_t regval;\n  flags = enter_critical_section();\n  /* Initial frequency is set by boot ROM in IDIVE */\n  /* Pin configuration */\n  lpc43_pin_config(PINCONF_SPIFI_CS);\n  lpc43_pin_config(PINCONF_SPIFI_MISO);\n  lpc43_pin_config(PINCONF_SPIFI_MOSI);\n  lpc43_pin_config(PINCONF_SPIFI_SCK);\n  lpc43_pin_config(PINCONF_SPIFI_SIO2);\n  lpc43_pin_config(PINCONF_SPIFI_SIO3);\n  /* Initialize LPCSPIFILIB library, reset the interface */\n  spifiInit(LPC43_SPIFI_CTRL, true);\n  /* Register the family for the device */\n  spifiRegisterFamily(spifi_REG_FAMILY_CommonCommandSet);\n  /* Initialize and detect a device and get device context */\n  SPIFI_HANDLE_T *pSpifi = spifiInitDevice(&lmem, sizeof(lmem),\n                                           LPC43_SPIFI_CTRL,\n                                           LPC43_LOCSRAM_SPIFI_BASE);\n  /* Enable quad.  If not supported it will be ignored */\n  spifiDevSetOpts(pSpifi, SPIFI_OPT_USE_QUAD, true);\n  /* Enter memMode */\n  spifiDevSetMemMode(pSpifi, true);\n  /* Configure divider as the input to the SPIFI */\n  regval  = getreg32(LPC43_BASE_SPIFI_CLK);\n  regval &= ~BASE_SPIFI_CLK_CLKSEL_MASK;\n  regval |= BASE_SPIFI_CLKSEL_IDIVE;\n  putreg32(regval, LPC43_BASE_SPIFI_CLK);\n  regval  = getreg32(LPC43_IDIVE_CTRL);\n  regval &= ~(IDIVE_CTRL_CLKSEL_MASK | IDIVE_CTRL_IDIV_MASK);\n  regval |= BASE_SPIFI_CLKSEL_PLL1 | IDIVE_CTRL_AUTOBLOCK |\n            IDIVE_CTRL_IDIV(SPIFI_DEVICE_REQUENCY_DIVIDER);\n  putreg32(regval, LPC43_IDIVE_CTRL);\n  leave_critical_section(flags);\n"]]}
{"hexsha": "a134504fbd856ebe3b707251f43e6b35d9df4494", "ext": "c", "lang": "C", "content": "void print_entry(\n    char *entry_name,\n    PVFS_handle handle,\n    PVFS_fs_id fs_id)\n{\n    PVFS_object_ref pinode_refn;\n    PVFS_credential credentials;\n    PVFS_sysresp_getattr getattr_response;\n\n    memset(&getattr_response,0, sizeof(PVFS_sysresp_getattr));\n\n    PVFS_util_gen_credential_defaults(&credentials);\n    \n    pinode_refn.handle = handle;\n    pinode_refn.fs_id = fs_id;\n\n    if (PVFS_sys_getattr(pinode_refn, PVFS_ATTR_SYS_ALL,\n                         &credentials, &getattr_response, NULL))\n    {\n        fprintf(stderr,\"Failed to get attributes on handle 0x%08llx \"\n                \"(fs_id is %d)\\n\",llu(handle),fs_id);\n        return;\n    }\n    print_entry_attr(entry_name, &getattr_response.attr);\n}", "item_id": 1, "repo": "dschwoerer/orangefs", "file": "test/client/sysint/ls.c", "last_update_at": "2022-03-16T11:23:49+00:00", "question_id": "a134504fbd856ebe3b707251f43e6b35d9df4494_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void print_entry(\n    char *entry_name,\n    PVFS_handle handle,\n    PVFS_fs_id fs_id)\n{\n    PVFS_object_ref pinode_refn;\n    PVFS_credential credentials;\n    PVFS_sysresp_getattr getattr_response;\n    memset(&getattr_response,0, sizeof(PVFS_sysresp_getattr));\n    PVFS_util_gen_credential_defaults(&credentials);\n    pinode_refn.handle = handle;\n    pinode_refn.fs_id = fs_id;\n    if (PVFS_sys_getattr(pinode_refn, PVFS_ATTR_SYS_ALL,\n                         &credentials, &getattr_response, NULL))\n    {\n        fprintf(stderr,\"Failed to get attributes on handle 0x%08llx \"\n                \"(fs_id is %d)\\n\",llu(handle),fs_id);\n        return;\n    }\n    print_entry_attr(entry_name, &getattr_response.attr);\n"]]}
{"hexsha": "15d34c3dbab62776e5d2ad654d489e2fe54f8033", "ext": "c", "lang": "C", "content": "static pism_data_t\nfb_dev_response_get(pism_device_t *dev)\n{\n\tstruct pism_data_int *pd_int;\n\n\t(void)fb_dev_init_internal(dev);\n\tpd_int = &fb_fifo.pd_int;\n\tif (pd_int->pdi_addr >= FRAMEBUFFER_BASE &&\n\t    pd_int->pdi_addr < FRAMEBUFFER_BASE + FRAMEBUFFER_LENGTH)\n\t\tframebuffer_response_get(pd_int);\n\tif (pd_int->pdi_addr >= TOUCHSCREEN_BASE &&\n\t    pd_int->pdi_addr < TOUCHSCREEN_BASE + TOUCHSCREEN_LENGTH)\n\t\ttouchscreen_response_get(pd_int);\n\tfb_fifo_empty = 0;\n\treturn (fb_fifo);\n}", "item_id": 9, "repo": "tupipa/beri", "file": "cherilibs/trunk/peripherals/pismdev/framebuffer/fb.c", "last_update_at": "2022-02-08T21:16:26+00:00", "question_id": "15d34c3dbab62776e5d2ad654d489e2fe54f8033_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static pism_data_t\nfb_dev_response_get(pism_device_t *dev)\n{\n\tstruct pism_data_int *pd_int;\n\t(void)fb_dev_init_internal(dev);\n\tpd_int = &fb_fifo.pd_int;\n\tif (pd_int->pdi_addr >= FRAMEBUFFER_BASE &&\n\t    pd_int->pdi_addr < FRAMEBUFFER_BASE + FRAMEBUFFER_LENGTH)\n\t\tframebuffer_response_get(pd_int);\n\tif (pd_int->pdi_addr >= TOUCHSCREEN_BASE &&\n\t    pd_int->pdi_addr < TOUCHSCREEN_BASE + TOUCHSCREEN_LENGTH)\n\t\ttouchscreen_response_get(pd_int);\n\tfb_fifo_empty = 0;\n\treturn (fb_fifo);\n"]]}
{"hexsha": "2c010c0702f1f256c9a66733b7c3a76da9917230", "ext": "c", "lang": "C", "content": "UINT  _nx_smtp_rsp_rset(NX_SMTP_CLIENT *client_ptr)\n{\n\nUINT  status;\n\n\n    /* Get server response to RSET command.  */\n    status =  _nx_smtp_utility_read_server_code(client_ptr, NX_SMTP_ENVELOPE_TIMEOUT, NX_TRUE);\n\n    /* Check for error.  */\n    if (status != NX_SUCCESS)\n    {\n\n        /* Return error status.  */\n        return(status);\n    }\n\n    /* Did the session receive the 250 OK from the server?  */  \n    if (client_ptr -> nx_smtp_client_reply_code_status != NX_SMTP_CODE_OK_TO_CONTINUE)\n    {\n\n        /* Yes, set the session state to QUIT.  */\n        client_ptr -> nx_smtp_client_rsp_state = NX_SMTP_CLIENT_STATE_QUIT;            \n        /* Indicate mail cannot be sent. */\n        client_ptr -> nx_smtp_client_mail_status = NX_SMTP_SERVER_ERROR_CODE_RECEIVED;\n    }\n    else\n    {\n\n        /* Yes, session accepted the RSET command with the 250 code.  \n           Reset session state back to MAIL.  */\n        client_ptr -> nx_smtp_client_rsp_state =  NX_SMTP_CLIENT_STATE_MAIL;\n\n    }\n\n    /* Return successful session status.  */\n    return NX_SUCCESS;\n}", "item_id": 31, "repo": "likidu/stm32u5-getting-started", "file": "shared/lib/netxduo/addons/smtp/nxd_smtp_client.c", "last_update_at": "2022-03-16T05:40:57+00:00", "question_id": "2c010c0702f1f256c9a66733b7c3a76da9917230_31", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["UINT  _nx_smtp_rsp_rset(NX_SMTP_CLIENT *client_ptr)\n{\nUINT  status;\n    /* Get server response to RSET command.  */\n    status =  _nx_smtp_utility_read_server_code(client_ptr, NX_SMTP_ENVELOPE_TIMEOUT, NX_TRUE);\n    /* Check for error.  */\n    if (status != NX_SUCCESS)\n    {\n        /* Return error status.  */\n        return(status);\n    }\n    /* Did the session receive the 250 OK from the server?  */  \n    if (client_ptr -> nx_smtp_client_reply_code_status != NX_SMTP_CODE_OK_TO_CONTINUE)\n    {\n        /* Yes, set the session state to QUIT.  */\n        client_ptr -> nx_smtp_client_rsp_state = NX_SMTP_CLIENT_STATE_QUIT;            \n        /* Indicate mail cannot be sent. */\n        client_ptr -> nx_smtp_client_mail_status = NX_SMTP_SERVER_ERROR_CODE_RECEIVED;\n    }\n    else\n    {\n        /* Yes, session accepted the RSET command with the 250 code.  \n           Reset session state back to MAIL.  */\n        client_ptr -> nx_smtp_client_rsp_state =  NX_SMTP_CLIENT_STATE_MAIL;\n    }\n    /* Return successful session status.  */\n    return NX_SUCCESS;\n"]]}
{"hexsha": "e85f6b042954bef829a04519eaa1b227abc6f3d0", "ext": "c", "lang": "C", "content": "extern void icmpttlexceeded6(struct Fs *f, struct Ipifc *ifc, struct block *bp)\n{\n\tstruct block *nbp;\n\tstruct IPICMP *np;\n\tstruct ip6hdr *p;\n\tint osz = BLEN(bp);\n\tint sz = MIN(sizeof(struct IPICMP) + osz, v6MINTU);\n\tstruct Proto *icmp = f->t2p[ICMPv6];\n\tIcmppriv6 *ipriv = icmp->priv;\n\n\tp = (struct ip6hdr *)bp->rp;\n\n\tif (isv6mcast(p->src))\n\t\treturn;\n\n\tnbp = newIPICMP(sz);\n\tnp = (struct IPICMP *)nbp->rp;\n\n\tif (ipv6anylocal(ifc, np->src)) {\n\t\tnetlog(f, Logicmp, \"send icmpttlexceeded6 -> s%I d%I\\n\", p->src,\n\t\t\t   p->dst);\n\t} else {\n\t\tnetlog(f, Logicmp, \"icmpttlexceeded6 fail -> s%I d%I\\n\", p->src,\n\t\t\t   p->dst);\n\t\treturn;\n\t}\n\n\tmemmove(np->dst, p->src, IPaddrlen);\n\tnp->type = TimeExceedV6;\n\tnp->code = 0;\n\tmemmove(nbp->rp + sizeof(struct IPICMP), bp->rp,\n\t\t\tsz - sizeof(struct IPICMP));\n\tset_cksum(nbp);\n\tnp->ttl = HOP_LIMIT;\n\tnp->vcf[0] = 0x06 << 4;\n\tipriv->out[TimeExceedV6]++;\n\tipoput6(f, nbp, 0, MAXTTL, DFLTTOS, NULL);\n}", "item_id": 10, "repo": "goovdl/akaros", "file": "kern/src/net/icmp6.c", "last_update_at": "2022-01-10T23:42:13+00:00", "question_id": "e85f6b042954bef829a04519eaa1b227abc6f3d0_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["extern void icmpttlexceeded6(struct Fs *f, struct Ipifc *ifc, struct block *bp)\n{\n\tstruct block *nbp;\n\tstruct IPICMP *np;\n\tstruct ip6hdr *p;\n\tint osz = BLEN(bp);\n\tint sz = MIN(sizeof(struct IPICMP) + osz, v6MINTU);\n\tstruct Proto *icmp = f->t2p[ICMPv6];\n\tIcmppriv6 *ipriv = icmp->priv;\n\tp = (struct ip6hdr *)bp->rp;\n\tif (isv6mcast(p->src))\n\t\treturn;\n\tnbp = newIPICMP(sz);\n\tnp = (struct IPICMP *)nbp->rp;\n\tif (ipv6anylocal(ifc, np->src)) {\n\t\tnetlog(f, Logicmp, \"send icmpttlexceeded6 -> s%I d%I\\n\", p->src,\n\t\t\t   p->dst);\n\t} else {\n\t\tnetlog(f, Logicmp, \"icmpttlexceeded6 fail -> s%I d%I\\n\", p->src,\n\t\t\t   p->dst);\n\t\treturn;\n\t}\n\tmemmove(np->dst, p->src, IPaddrlen);\n\tnp->type = TimeExceedV6;\n\tnp->code = 0;\n\tmemmove(nbp->rp + sizeof(struct IPICMP), bp->rp,\n\t\t\tsz - sizeof(struct IPICMP));\n\tset_cksum(nbp);\n\tnp->ttl = HOP_LIMIT;\n\tnp->vcf[0] = 0x06 << 4;\n\tipriv->out[TimeExceedV6]++;\n\tipoput6(f, nbp, 0, MAXTTL, DFLTTOS, NULL);\n"]]}
{"hexsha": "4631b1d39bb41beaf01fccdd9655a57304ee9323", "ext": "c", "lang": "C", "content": "void intel_mid_msgbus_write32_raw(u32 cmd, u32 data)\n{\n\tunsigned long irq_flags;\n\n\tspin_lock_irqsave(&msgbus_lock, irq_flags);\n\tpci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, data);\n\tpci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);\n\tspin_unlock_irqrestore(&msgbus_lock, irq_flags);\n}", "item_id": 3, "repo": "bingchunjin/1806_SDK", "file": "linux-4.14.90-dev/linux-4.14.90/drivers/staging/media/atomisp/platform/intel-mid/intel_mid_pcihelpers.c", "last_update_at": "2022-03-07T12:09:00+00:00", "question_id": "4631b1d39bb41beaf01fccdd9655a57304ee9323_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void intel_mid_msgbus_write32_raw(u32 cmd, u32 data)\n{\n\tunsigned long irq_flags;\n\tspin_lock_irqsave(&msgbus_lock, irq_flags);\n\tpci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, data);\n\tpci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);\n\tspin_unlock_irqrestore(&msgbus_lock, irq_flags);\n"]]}
{"hexsha": "d09205b5744bd3518e987809e77a7261fa464316", "ext": "c", "lang": "C", "content": "static void mesh_calc_eigen_matrix(const MVert *verts,\n                                   const float (*vcos)[3],\n                                   const int numverts,\n                                   float r_mat[4][4])\n{\n  float center[3], covmat[3][3];\n  float eigen_val[3], eigen_vec[3][3];\n  float(*cos)[3] = NULL;\n\n  bool eigen_success;\n  int i;\n\n  if (verts) {\n    const MVert *mv;\n    float(*co)[3];\n\n    cos = MEM_mallocN(sizeof(*cos) * (size_t)numverts, __func__);\n    for (i = 0, co = cos, mv = verts; i < numverts; i++, co++, mv++) {\n      copy_v3_v3(*co, mv->co);\n    }\n    /* TODO(sergey): For until we officially drop all compilers which\n     * doesn't handle casting correct we use workaround to avoid explicit\n     * cast here.\n     */\n    vcos = (void *)cos;\n  }\n  unit_m4(r_mat);\n\n  /* Note: here we apply sample correction to covariance matrix, since we consider the vertices\n   *       as a sample of the whole 'surface' population of our mesh. */\n  BLI_covariance_m3_v3n(vcos, numverts, true, covmat, center);\n\n  if (cos) {\n    MEM_freeN(cos);\n  }\n\n  eigen_success = BLI_eigen_solve_selfadjoint_m3((const float(*)[3])covmat, eigen_val, eigen_vec);\n  BLI_assert(eigen_success);\n  UNUSED_VARS_NDEBUG(eigen_success);\n\n  /* Special handling of cases where some eigen values are (nearly) identical. */\n  if (compare_ff_relative(eigen_val[0], eigen_val[1], FLT_EPSILON, 64)) {\n    if (compare_ff_relative(eigen_val[0], eigen_val[2], FLT_EPSILON, 64)) {\n      /* No preferred direction, that set of vertices has a spherical average,\n       * so we simply returned scaled/translated identity matrix (with no rotation). */\n      unit_m3(eigen_vec);\n    }\n    else {\n      /* Ellipsoid defined by eigen values/vectors has a spherical section,\n       * we can only define one axis from eigen_vec[2] (two others computed eigen vecs\n       * are not so nice for us here, they tend to 'randomly' rotate around valid one).\n       * Note that eigen vectors as returned by BLI_eigen_solve_selfadjoint_m3() are normalized. */\n      ortho_basis_v3v3_v3(eigen_vec[0], eigen_vec[1], eigen_vec[2]);\n    }\n  }\n  else if (compare_ff_relative(eigen_val[0], eigen_val[2], FLT_EPSILON, 64)) {\n    /* Same as above, but with eigen_vec[1] as valid axis. */\n    ortho_basis_v3v3_v3(eigen_vec[2], eigen_vec[0], eigen_vec[1]);\n  }\n  else if (compare_ff_relative(eigen_val[1], eigen_val[2], FLT_EPSILON, 64)) {\n    /* Same as above, but with eigen_vec[0] as valid axis. */\n    ortho_basis_v3v3_v3(eigen_vec[1], eigen_vec[2], eigen_vec[0]);\n  }\n\n  for (i = 0; i < 3; i++) {\n    float evi = eigen_val[i];\n\n    /* Protect against 1D/2D degenerated cases! */\n    /* Note: not sure why we need square root of eigen values here\n     * (which are equivalent to singular values, as far as I have understood),\n     * but it seems to heavily reduce (if not completely nullify)\n     * the error due to non-uniform scalings... */\n    evi = (evi < 1e-6f && evi > -1e-6f) ? ((evi < 0.0f) ? -1e-3f : 1e-3f) : sqrtf_signed(evi);\n    mul_v3_fl(eigen_vec[i], evi);\n  }\n\n  copy_m4_m3(r_mat, eigen_vec);\n  copy_v3_v3(r_mat[3], center);\n}", "item_id": 3, "repo": "RemiArnaud/blender", "file": "source/blender/blenkernel/intern/mesh_remap.c", "last_update_at": "2022-03-24T04:46:31+00:00", "question_id": "d09205b5744bd3518e987809e77a7261fa464316_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void mesh_calc_eigen_matrix(const MVert *verts,\n                                   const float (*vcos)[3],\n                                   const int numverts,\n                                   float r_mat[4][4])\n{\n  float center[3], covmat[3][3];\n  float eigen_val[3], eigen_vec[3][3];\n  float(*cos)[3] = NULL;\n  bool eigen_success;\n  int i;\n  if (verts) {\n    const MVert *mv;\n    float(*co)[3];\n    cos = MEM_mallocN(sizeof(*cos) * (size_t)numverts, __func__);\n    for (i = 0, co = cos, mv = verts; i < numverts; i++, co++, mv++) {\n      copy_v3_v3(*co, mv->co);\n    }\n    /* TODO(sergey): For until we officially drop all compilers which\n     * doesn't handle casting correct we use workaround to avoid explicit\n     * cast here.\n     */\n    vcos = (void *)cos;\n  }\n  unit_m4(r_mat);\n  /* Note: here we apply sample correction to covariance matrix, since we consider the vertices\n   *       as a sample of the whole 'surface' population of our mesh. */\n  BLI_covariance_m3_v3n(vcos, numverts, true, covmat, center);\n  if (cos) {\n    MEM_freeN(cos);\n  }\n  eigen_success = BLI_eigen_solve_selfadjoint_m3((const float(*)[3])covmat, eigen_val, eigen_vec);\n  BLI_assert(eigen_success);\n  UNUSED_VARS_NDEBUG(eigen_success);\n  /* Special handling of cases where some eigen values are (nearly) identical. */\n  if (compare_ff_relative(eigen_val[0], eigen_val[1], FLT_EPSILON, 64)) {\n    if (compare_ff_relative(eigen_val[0], eigen_val[2], FLT_EPSILON, 64)) {\n      /* No preferred direction, that set of vertices has a spherical average,\n       * so we simply returned scaled/translated identity matrix (with no rotation). */\n      unit_m3(eigen_vec);\n    }\n    else {\n      /* Ellipsoid defined by eigen values/vectors has a spherical section,\n       * we can only define one axis from eigen_vec[2] (two others computed eigen vecs\n       * are not so nice for us here, they tend to 'randomly' rotate around valid one).\n       * Note that eigen vectors as returned by BLI_eigen_solve_selfadjoint_m3() are normalized. */\n      ortho_basis_v3v3_v3(eigen_vec[0], eigen_vec[1], eigen_vec[2]);\n    }\n  }\n  else if (compare_ff_relative(eigen_val[0], eigen_val[2], FLT_EPSILON, 64)) {\n    /* Same as above, but with eigen_vec[1] as valid axis. */\n    ortho_basis_v3v3_v3(eigen_vec[2], eigen_vec[0], eigen_vec[1]);\n  }\n  else if (compare_ff_relative(eigen_val[1], eigen_val[2], FLT_EPSILON, 64)) {\n    /* Same as above, but with eigen_vec[0] as valid axis. */\n    ortho_basis_v3v3_v3(eigen_vec[1], eigen_vec[2], eigen_vec[0]);\n  }\n  for (i = 0; i < 3; i++) {\n    float evi = eigen_val[i];\n    /* Protect against 1D/2D degenerated cases! */\n    /* Note: not sure why we need square root of eigen values here\n     * (which are equivalent to singular values, as far as I have understood),\n     * but it seems to heavily reduce (if not completely nullify)\n     * the error due to non-uniform scalings... */\n    evi = (evi < 1e-6f && evi > -1e-6f) ? ((evi < 0.0f) ? -1e-3f : 1e-3f) : sqrtf_signed(evi);\n    mul_v3_fl(eigen_vec[i], evi);\n  }\n  copy_m4_m3(r_mat, eigen_vec);\n  copy_v3_v3(r_mat[3], center);\n"]]}
{"hexsha": "0fc59ce2d25a90e8084a35dc9fe2e4480312aaf9", "ext": "c", "lang": "C", "content": "void afcreate_bufr(char *docname, int size, char *outputformat,\n                   char *issTimeStr, char *fxyPath, int debuglvl, int *ier)\n/*******************************************************************************\n  afcreate_bufr\n\n  This routine takes the contents of the input XML document to create a BUFR\nmessage\n  containing SIERRA, TANGO, or ZULU Hazards.\n\n  Input parameters:\n    *docname        char  XML Document String\n    size            int   Length of XML document\n    *outputformat   char  Output Format String used for BUFR Message filename\n    *issTimeStr     char  Issue Time String - to be used as timestamp for BUFR\n    *fxyPath        char  Path to FXY Descriptor Tables\n    debuglvl        int   Debug Level - 0 for no debugging\n                                        1 for Dump of Data_MixVal_t structure\n                                       >1 for more detailed MEL-BUFR Output\n  L. Hinson         01/06 Created\n*******************************************************************************/\n{\n  xmlDocPtr doc;\n  enum GFADesignator GFADesignatorType = SIERRA;\n  char typeBulletin[8];\n  int numberOfBulletins,i,j,num_vals;\n  BUFR_Info_t bufr_info;\n  Data_MixVal_t *bufr_rec;\n  FXY_t *rec_fxy=0x0;\n  int num_fxys;\n  int vals_check=0;\n  GFAByDesignatorInfo *bufr_prerec=0x0;\n  char bufrfilename[MAXST];\n  char dateStamp[16];\n  doc = xmlReadMemory(docname,size,\"noname.xml\",NULL,0);\n  if (doc==NULL) {\n    printf(\"afcreate_bufr::Error in parsing document.\\n\");\n    exit(1);\n  }\n  numberOfBulletins=get_number_of_nodes( doc, (xmlChar*) \"//bulletin\");\n  for (i=0;i<numberOfBulletins;i++) {\n    getInfoStrbySub(doc,\"/gfaInfo\",\"/bulletin[%d]/@type\",i+1,typeBulletin);\n    for(j=0;j<3;j++) {\n      if (strncmp(GFADesignatorNames[j],typeBulletin,6)==0) {\n        GFADesignatorType=(enum GFADesignator) j;\n        break;\n      }\n    }\n    bufr_prerec=BuildRec(doc,GFADesignatorType,&num_vals);\n    buildFilenameAndDateStampFmIssTime(issTimeStr, outputformat,\n                                         bufrfilename, dateStamp);\n    if (debuglvl > 1) {\n       BUFR_Debug(debuglvl);\n       BUFR_Trace(debuglvl);\n    }\n    initBUFR(&bufr_info,bufrfilename,dateStamp,bufr_prerec->td);\n    bufr_rec=(Data_MixVal_t *) malloc(sizeof(Data_MixVal_t) *num_vals);\n    switch(GFADesignatorType) {\n      case SIERRA:\n        rec_fxy=loadFXYs(fxyPath,\"afbufrfxy.sierra\",&num_fxys);\n        fill_arraySIERRA(bufr_prerec->b.sierra,bufr_rec,&vals_check);\n        break;\n      case TANGO:\n        rec_fxy=loadFXYs(fxyPath,\"afbufrfxy.tango\",&num_fxys);\n        fill_arrayTANGO(bufr_prerec->b.tango, bufr_rec, &vals_check);\n        break;\n      case ZULU:\n        rec_fxy=loadFXYs(fxyPath,\"afbufrfxy.zulu\",&num_fxys);\n        fill_arrayZULU(bufr_prerec->b.zulu, bufr_rec, &vals_check);\n        break;\n    }\n    if (debuglvl > 0)\n      printf(\"bufr_rec vals_check=%d \\n\",vals_check);\n    if (vals_check!=num_vals) {\n      printf(\"Inconsistency check on number of values loaded\\n\");\n      printf(\"bufr_prerec, Number items Loaded: %d\\n\",num_vals);\n      printf(\"bufr_rec, Number items Loaded: %d\\n\",vals_check);\n      exit(1);\n    }\n    if (debuglvl > 0) {\n      printf(\"Dumping bufr_rec contents...\\n\");\n      for (i=0;i<vals_check;i++) {\n        if (bufr_rec[i].Val_Type==DT_INT) {\n          printf (\"***DT_INT %d %d \\n\",i, bufr_rec[i].Val.int_number);\n        }\n        else if (bufr_rec[i].Val_Type==DT_STRING) {\n          printf(\"***DT_STRING %d %s \\n\",i,bufr_rec[i].Val.string);\n        }\n        else if (bufr_rec[i].Val_Type==DT_FLOAT) {\n          printf(\"***DT_FLOAT %d %f \\n\",i,bufr_rec[i].Val.ffloat);\n        }\n      }\n    }\n    if ( BUFR_Put_MixArray(bufr_rec,vals_check,rec_fxy,num_fxys)) {\n      BUFR_perror(\" Error on call to BUFR_Put_Array in encodeBUFR\");\n\n      exit(1);\n    }\n    if( BUFR_Encode( &bufr_info)) {\n      BUFR_perror(\"Bufr_Encode error in encodeBUFR\");\n      BUFR_Destroy(1);\n    }\n    BUFR_Destroy(1);\n    free(rec_fxy);\n    free_prerec_items(bufr_prerec);\n    free(bufr_prerec);\n    /*free up all string pointers in bufr_rec*/\n    free_strings(bufr_rec,vals_check);\n    free(bufr_rec);\n    xmlFreeDoc(doc);\n  }\n}", "item_id": 0, "repo": "oxelson/gempak", "file": "gempak/source/contrib/awc/airmet_vgfbufr/afcreatebufr.c", "last_update_at": "2022-02-28T22:36:03+00:00", "question_id": "0fc59ce2d25a90e8084a35dc9fe2e4480312aaf9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void afcreate_bufr(char *docname, int size, char *outputformat,\n                   char *issTimeStr, char *fxyPath, int debuglvl, int *ier)\n/*******************************************************************************\n  afcreate_bufr\n  This routine takes the contents of the input XML document to create a BUFR\nmessage\n  containing SIERRA, TANGO, or ZULU Hazards.\n  Input parameters:\n    *docname        char  XML Document String\n    size            int   Length of XML document\n    *outputformat   char  Output Format String used for BUFR Message filename\n    *issTimeStr     char  Issue Time String - to be used as timestamp for BUFR\n    *fxyPath        char  Path to FXY Descriptor Tables\n    debuglvl        int   Debug Level - 0 for no debugging\n                                        1 for Dump of Data_MixVal_t structure\n                                       >1 for more detailed MEL-BUFR Output\n  L. Hinson         01/06 Created\n*******************************************************************************/\n{\n  xmlDocPtr doc;\n  enum GFADesignator GFADesignatorType = SIERRA;\n  char typeBulletin[8];\n  int numberOfBulletins,i,j,num_vals;\n  BUFR_Info_t bufr_info;\n  Data_MixVal_t *bufr_rec;\n  FXY_t *rec_fxy=0x0;\n  int num_fxys;\n  int vals_check=0;\n  GFAByDesignatorInfo *bufr_prerec=0x0;\n  char bufrfilename[MAXST];\n  char dateStamp[16];\n  doc = xmlReadMemory(docname,size,\"noname.xml\",NULL,0);\n  if (doc==NULL) {\n    printf(\"afcreate_bufr::Error in parsing document.\\n\");\n    exit(1);\n  }\n  numberOfBulletins=get_number_of_nodes( doc, (xmlChar*) \"//bulletin\");\n  for (i=0;i<numberOfBulletins;i++) {\n    getInfoStrbySub(doc,\"/gfaInfo\",\"/bulletin[%d]/@type\",i+1,typeBulletin);\n    for(j=0;j<3;j++) {\n      if (strncmp(GFADesignatorNames[j],typeBulletin,6)==0) {\n        GFADesignatorType=(enum GFADesignator) j;\n        break;\n      }\n    }\n    bufr_prerec=BuildRec(doc,GFADesignatorType,&num_vals);\n    buildFilenameAndDateStampFmIssTime(issTimeStr, outputformat,\n                                         bufrfilename, dateStamp);\n    if (debuglvl > 1) {\n       BUFR_Debug(debuglvl);\n       BUFR_Trace(debuglvl);\n    }\n    initBUFR(&bufr_info,bufrfilename,dateStamp,bufr_prerec->td);\n    bufr_rec=(Data_MixVal_t *) malloc(sizeof(Data_MixVal_t) *num_vals);\n    switch(GFADesignatorType) {\n      case SIERRA:\n        rec_fxy=loadFXYs(fxyPath,\"afbufrfxy.sierra\",&num_fxys);\n        fill_arraySIERRA(bufr_prerec->b.sierra,bufr_rec,&vals_check);\n        break;\n      case TANGO:\n        rec_fxy=loadFXYs(fxyPath,\"afbufrfxy.tango\",&num_fxys);\n        fill_arrayTANGO(bufr_prerec->b.tango, bufr_rec, &vals_check);\n        break;\n      case ZULU:\n        rec_fxy=loadFXYs(fxyPath,\"afbufrfxy.zulu\",&num_fxys);\n        fill_arrayZULU(bufr_prerec->b.zulu, bufr_rec, &vals_check);\n        break;\n    }\n    if (debuglvl > 0)\n      printf(\"bufr_rec vals_check=%d \\n\",vals_check);\n    if (vals_check!=num_vals) {\n      printf(\"Inconsistency check on number of values loaded\\n\");\n      printf(\"bufr_prerec, Number items Loaded: %d\\n\",num_vals);\n      printf(\"bufr_rec, Number items Loaded: %d\\n\",vals_check);\n      exit(1);\n    }\n    if (debuglvl > 0) {\n      printf(\"Dumping bufr_rec contents...\\n\");\n      for (i=0;i<vals_check;i++) {\n        if (bufr_rec[i].Val_Type==DT_INT) {\n          printf (\"***DT_INT %d %d \\n\",i, bufr_rec[i].Val.int_number);\n        }\n        else if (bufr_rec[i].Val_Type==DT_STRING) {\n          printf(\"***DT_STRING %d %s \\n\",i,bufr_rec[i].Val.string);\n        }\n        else if (bufr_rec[i].Val_Type==DT_FLOAT) {\n          printf(\"***DT_FLOAT %d %f \\n\",i,bufr_rec[i].Val.ffloat);\n        }\n      }\n    }\n    if ( BUFR_Put_MixArray(bufr_rec,vals_check,rec_fxy,num_fxys)) {\n      BUFR_perror(\" Error on call to BUFR_Put_Array in encodeBUFR\");\n      exit(1);\n    }\n    if( BUFR_Encode( &bufr_info)) {\n      BUFR_perror(\"Bufr_Encode error in encodeBUFR\");\n      BUFR_Destroy(1);\n    }\n    BUFR_Destroy(1);\n    free(rec_fxy);\n    free_prerec_items(bufr_prerec);\n    free(bufr_prerec);\n    /*free up all string pointers in bufr_rec*/\n    free_strings(bufr_rec,vals_check);\n    free(bufr_rec);\n    xmlFreeDoc(doc);\n  }\n"]]}
{"hexsha": "886d9dd91572940bb3c45e0c165a8e814af6e3b3", "ext": "h", "lang": "C", "content": "class linebuffer_hls_stream_PackedStencil_int32_t_3_3___to_hls_stream_PackedStencil_int32_t_1_1___bnds_16_16 {\npublic:\nPackedStencil_int32_t_1_1_ lb_read();\nvoid lb_write(const PackedStencil_int32_t_3_3_& stencil);\nbool has_valid_data();\n}", "item_id": 460, "repo": "m-malyarenko/ahaHLS", "file": "test/ll_files/gen_classes.h", "last_update_at": "2022-03-24T18:16:44+00:00", "question_id": "886d9dd91572940bb3c45e0c165a8e814af6e3b3_460", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class linebuffer_hls_stream_PackedStencil_int32_t_3_3___to_hls_stream_PackedStencil_int32_t_1_1___bnds_16_16 {\npublic:\nPackedStencil_int32_t_1_1_ lb_read();\nvoid lb_write(const PackedStencil_int32_t_3_3_& stencil);\nbool has_valid_data();\n"]]}
{"hexsha": "c7810d8e96a88efd460ca3a8ffb25975afb5cd67", "ext": "h", "lang": "C", "content": "chars IO_toString_d ( int x )\r\n{                             // variante do printf( )\r\n  chars buffer = IO_new_chars ( STR_SIZE+1 );\r\n  sprintf ( buffer, \"%d\", x );\r\n  return  ( buffer );\r\n}", "item_id": 11, "repo": "0Augusto/Algoritmo-e-Estrutura-de-Dados-1", "file": "ED09/io.h", "last_update_at": "2022-03-03T17:22:22+00:00", "question_id": "c7810d8e96a88efd460ca3a8ffb25975afb5cd67_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["chars IO_toString_d ( int x )\r\n{                             // variante do printf( )\r\n  chars buffer = IO_new_chars ( STR_SIZE+1 );\r\n  sprintf ( buffer, \"%d\", x );\r\n  return  ( buffer );\r\n"]]}
{"hexsha": "3629ff296da2639c9f78f666545beff5872e0421", "ext": "h", "lang": "C", "content": "static inline VALUE\nvm_getivar(VALUE obj, ID id, IVC ic, struct rb_call_cache *cc, int is_attr)\n{\n\n    VALUE val = ((VALUE)RUBY_Qundef);\n\n    if ((((VALUE)(obj) & RUBY_IMMEDIATE_MASK) || !!(((VALUE)(obj) & (VALUE)~((VALUE)RUBY_Qnil)) == 0))) {\n\n    }\n    else if ((__builtin_expect(!!(is_attr ? (cc->aux.index > 0) : (ic->ic_serial == (((struct RClass*)(((struct RBasic*)(obj))->klass))->class_serial))), 1))) {\n\n\n\n        st_index_t index = !is_attr ? ic->index : (cc->aux.index - 1);\n\n        ((void)0);\n\n        if ((__builtin_expect(!!((int)(((struct RBasic*)(obj))->flags & RUBY_T_MASK) == RUBY_T_OBJECT), 1)) &&\n            (__builtin_expect(!!(index < ((((struct RBasic*)(obj))->flags & ROBJECT_EMBED) ? ROBJECT_EMBED_LEN_MAX : ((struct RObject*)(obj))->as.heap.numiv)), 1))) {\n            val = ((((struct RBasic*)(obj))->flags & ROBJECT_EMBED) ? ((struct RObject*)(obj))->as.ary : ((struct RObject*)(obj))->as.heap.ivptr)[index];\n        }\n        else if ((((struct RBasic*)(obj))->flags&(((VALUE)RUBY_FL_EXIVAR)))) {\n            struct gen_ivtbl *ivtbl;\n\n            if ((__builtin_expect(!!(rb_st_lookup(rb_ivar_generic_ivtbl(), (st_data_t)obj, (st_data_t *)&ivtbl)), 1)) &&\n                (__builtin_expect(!!(index < ivtbl->numiv), 1))) {\n                val = ivtbl->ivptr[index];\n            }\n        }\n        goto ret;\n    }\n    else {\n        struct st_table *iv_index_tbl;\n        st_index_t numiv;\n        VALUE *ivptr;\n\n        st_data_t index;\n\n        if ((int)(((struct RBasic*)(obj))->flags & RUBY_T_MASK) == RUBY_T_OBJECT) {\n            iv_index_tbl = ((((struct RBasic*)(obj))->flags & ROBJECT_EMBED) ? ((((struct RClass*)(rb_obj_class(obj)))->ptr)->iv_index_tbl) : ((struct RObject*)(obj))->as.heap.iv_index_tbl);\n            numiv = ((((struct RBasic*)(obj))->flags & ROBJECT_EMBED) ? ROBJECT_EMBED_LEN_MAX : ((struct RObject*)(obj))->as.heap.numiv);\n            ivptr = ((((struct RBasic*)(obj))->flags & ROBJECT_EMBED) ? ((struct RObject*)(obj))->as.ary : ((struct RObject*)(obj))->as.heap.ivptr);\n\n          fill:\n     if (iv_index_tbl) {\n  if (rb_st_lookup(iv_index_tbl, id, &index)) {\n                    if (!is_attr) {\n                        ic->index = index;\n                        ic->ic_serial = (((struct RClass*)(((struct RBasic*)(obj))->klass))->class_serial);\n                    }\n                    else {\n                        cc->aux.index = (int)index + 1;\n                    }\n\n                    if (index < numiv) {\n                        val = ivptr[index];\n      }\n  }\n     }\n }\n        else if ((((struct RBasic*)(obj))->flags&(((VALUE)RUBY_FL_EXIVAR)))) {\n            struct gen_ivtbl *ivtbl;\n\n            if ((__builtin_expect(!!(rb_st_lookup(rb_ivar_generic_ivtbl(), (st_data_t)obj, (st_data_t *)&ivtbl)), 1))) {\n                numiv = ivtbl->numiv;\n                ivptr = ivtbl->ivptr;\n                iv_index_tbl = ((((struct RClass*)(rb_obj_class(obj)))->ptr)->iv_index_tbl);\n                goto fill;\n            }\n        }\n        else {\n\n            goto general_path;\n        }\n\n      ret:\n        if ((__builtin_expect(!!(val != ((VALUE)RUBY_Qundef)), 1))) {\n            return val;\n        }\n        else {\n            if (!is_attr && !(((VALUE)((*rb_ruby_verbose_ptr())) & (VALUE)~((VALUE)RUBY_Qnil)) == 0)) {\n                rb_warning(\"instance variable %\"\"l\"\"i\" \"\\v\"\" not initialized\", rb_id_quote_unprintable(id));\n            }\n            return ((VALUE)RUBY_Qnil);\n        }\n    }\n  general_path:\n\n    ((void)0);\n\n    if (is_attr) {\n        return rb_attr_get(obj, id);\n    }\n    else {\n        return rb_ivar_get(obj, id);\n    }\n}", "item_id": 93, "repo": "megatripcol/sketchup-ruby-debugger", "file": "ThirdParty/include/ruby/mac/x86_64-darwin18/rb_mjit_min_header-2.7.1.h", "last_update_at": "2022-02-22T01:20:51+00:00", "question_id": "3629ff296da2639c9f78f666545beff5872e0421_93", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline VALUE\nvm_getivar(VALUE obj, ID id, IVC ic, struct rb_call_cache *cc, int is_attr)\n{\n    VALUE val = ((VALUE)RUBY_Qundef);\n    if ((((VALUE)(obj) & RUBY_IMMEDIATE_MASK) || !!(((VALUE)(obj) & (VALUE)~((VALUE)RUBY_Qnil)) == 0))) {\n    }\n    else if ((__builtin_expect(!!(is_attr ? (cc->aux.index > 0) : (ic->ic_serial == (((struct RClass*)(((struct RBasic*)(obj))->klass))->class_serial))), 1))) {\n        st_index_t index = !is_attr ? ic->index : (cc->aux.index - 1);\n        ((void)0);\n        if ((__builtin_expect(!!((int)(((struct RBasic*)(obj))->flags & RUBY_T_MASK) == RUBY_T_OBJECT), 1)) &&\n            (__builtin_expect(!!(index < ((((struct RBasic*)(obj))->flags & ROBJECT_EMBED) ? ROBJECT_EMBED_LEN_MAX : ((struct RObject*)(obj))->as.heap.numiv)), 1))) {\n            val = ((((struct RBasic*)(obj))->flags & ROBJECT_EMBED) ? ((struct RObject*)(obj))->as.ary : ((struct RObject*)(obj))->as.heap.ivptr)[index];\n        }\n        else if ((((struct RBasic*)(obj))->flags&(((VALUE)RUBY_FL_EXIVAR)))) {\n            struct gen_ivtbl *ivtbl;\n            if ((__builtin_expect(!!(rb_st_lookup(rb_ivar_generic_ivtbl(), (st_data_t)obj, (st_data_t *)&ivtbl)), 1)) &&\n                (__builtin_expect(!!(index < ivtbl->numiv), 1))) {\n                val = ivtbl->ivptr[index];\n            }\n        }\n        goto ret;\n    }\n    else {\n        struct st_table *iv_index_tbl;\n        st_index_t numiv;\n        VALUE *ivptr;\n        st_data_t index;\n        if ((int)(((struct RBasic*)(obj))->flags & RUBY_T_MASK) == RUBY_T_OBJECT) {\n            iv_index_tbl = ((((struct RBasic*)(obj))->flags & ROBJECT_EMBED) ? ((((struct RClass*)(rb_obj_class(obj)))->ptr)->iv_index_tbl) : ((struct RObject*)(obj))->as.heap.iv_index_tbl);\n            numiv = ((((struct RBasic*)(obj))->flags & ROBJECT_EMBED) ? ROBJECT_EMBED_LEN_MAX : ((struct RObject*)(obj))->as.heap.numiv);\n            ivptr = ((((struct RBasic*)(obj))->flags & ROBJECT_EMBED) ? ((struct RObject*)(obj))->as.ary : ((struct RObject*)(obj))->as.heap.ivptr);\n          fill:\n     if (iv_index_tbl) {\n  if (rb_st_lookup(iv_index_tbl, id, &index)) {\n                    if (!is_attr) {\n                        ic->index = index;\n                        ic->ic_serial = (((struct RClass*)(((struct RBasic*)(obj))->klass))->class_serial);\n                    }\n                    else {\n                        cc->aux.index = (int)index + 1;\n                    }\n                    if (index < numiv) {\n                        val = ivptr[index];\n      }\n  }\n     }\n }\n        else if ((((struct RBasic*)(obj))->flags&(((VALUE)RUBY_FL_EXIVAR)))) {\n            struct gen_ivtbl *ivtbl;\n            if ((__builtin_expect(!!(rb_st_lookup(rb_ivar_generic_ivtbl(), (st_data_t)obj, (st_data_t *)&ivtbl)), 1))) {\n                numiv = ivtbl->numiv;\n                ivptr = ivtbl->ivptr;\n                iv_index_tbl = ((((struct RClass*)(rb_obj_class(obj)))->ptr)->iv_index_tbl);\n                goto fill;\n            }\n        }\n        else {\n            goto general_path;\n        }\n      ret:\n        if ((__builtin_expect(!!(val != ((VALUE)RUBY_Qundef)), 1))) {\n            return val;\n        }\n        else {\n            if (!is_attr && !(((VALUE)((*rb_ruby_verbose_ptr())) & (VALUE)~((VALUE)RUBY_Qnil)) == 0)) {\n                rb_warning(\"instance variable %\"\"l\"\"i\" \"\\v\"\" not initialized\", rb_id_quote_unprintable(id));\n            }\n            return ((VALUE)RUBY_Qnil);\n        }\n    }\n  general_path:\n    ((void)0);\n    if (is_attr) {\n        return rb_attr_get(obj, id);\n    }\n    else {\n        return rb_ivar_get(obj, id);\n    }\n"]]}
{"hexsha": "e1ea28dc0ab3d77af54eb173ec5383a2d1acfe3b", "ext": "c", "lang": "C", "content": "void obj_read_data(struct object *obj, size_t start, size_t len, void *ptr)\n{\n\tstart += OBJ_NULLPAGE_SIZE;\n\tassert(start < OBJ_MAXSIZE && start + len <= OBJ_MAXSIZE && len < OBJ_MAXSIZE);\n\tvoid *addr = (char *)obj_get_kaddr(obj) + start;\n\tmemcpy(ptr, addr, len);\n\tobj_release_kaddr(obj);\n}", "item_id": 7, "repo": "twizzler-operating-system/twizzler-public", "file": "core/obj/rw.c", "last_update_at": "2022-03-30T02:15:18+00:00", "question_id": "e1ea28dc0ab3d77af54eb173ec5383a2d1acfe3b_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void obj_read_data(struct object *obj, size_t start, size_t len, void *ptr)\n{\n\tstart += OBJ_NULLPAGE_SIZE;\n\tassert(start < OBJ_MAXSIZE && start + len <= OBJ_MAXSIZE && len < OBJ_MAXSIZE);\n\tvoid *addr = (char *)obj_get_kaddr(obj) + start;\n\tmemcpy(ptr, addr, len);\n\tobj_release_kaddr(obj);\n"]]}
{"hexsha": "04f691d127b4bb9547da3c0865746e2fb4777fcb", "ext": "c", "lang": "C", "content": "static int wavelan_get_wap(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu,\n\t\t\t   char *extra)\n{\n\t/* Should get the real McCoy instead of own Ethernet address */\n\tmemcpy(wrqu->ap_addr.sa_data, dev->dev_addr, WAVELAN_ADDR_SIZE);\n\twrqu->ap_addr.sa_family = ARPHRD_ETHER;\n\n\treturn -EOPNOTSUPP;\n}", "item_id": 50, "repo": "wangyan98/linux-lib", "file": "src/linux/drivers/staging/wavelan/wavelan_cs.c", "last_update_at": "2022-03-20T14:24:29+00:00", "question_id": "04f691d127b4bb9547da3c0865746e2fb4777fcb_50", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int wavelan_get_wap(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu,\n\t\t\t   char *extra)\n{\n\t/* Should get the real McCoy instead of own Ethernet address */\n\tmemcpy(wrqu->ap_addr.sa_data, dev->dev_addr, WAVELAN_ADDR_SIZE);\n\twrqu->ap_addr.sa_family = ARPHRD_ETHER;\n\treturn -EOPNOTSUPP;\n"]]}
{"hexsha": "aae22a07ed4387375fe1f9c81882dd6acfe6856c", "ext": "c", "lang": "C", "content": "void osRtxThreadListSort (os_thread_t *thread) {\n  os_object_t *object;\n  os_thread_t *thread0;\n\n  // Search for object\n  thread0 = thread;\n  while (thread0->id == osRtxIdThread) {\n    thread0 = thread0->thread_prev;\n    if (thread0 == NULL) { \n      return;\n    }\n  }\n  object = (os_object_t *)thread0;\n\n  osRtxThreadListRemove(thread);\n  osRtxThreadListPut(object, thread);\n}", "item_id": 5, "repo": "pradeep-gr/mbed-os5-onsemi", "file": "rtos/rtx5/TARGET_CORTEX_M/rtx_thread.c", "last_update_at": "2022-02-26T17:14:15+00:00", "question_id": "aae22a07ed4387375fe1f9c81882dd6acfe6856c_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void osRtxThreadListSort (os_thread_t *thread) {\n  os_object_t *object;\n  os_thread_t *thread0;\n  // Search for object\n  thread0 = thread;\n  while (thread0->id == osRtxIdThread) {\n    thread0 = thread0->thread_prev;\n    if (thread0 == NULL) { \n      return;\n    }\n  }\n  object = (os_object_t *)thread0;\n  osRtxThreadListRemove(thread);\n  osRtxThreadListPut(object, thread);\n"]]}
{"hexsha": "365d759e54ae8a20e9a7ab584d0051febd60aca0", "ext": "c", "lang": "C", "content": "char* iupdrvLocaleInfo(void)\n{\n  CPINFOEXA info;\n  GetCPInfoExA(CP_ACP, 0, &info);\n  return iupStrReturnStr(info.CodePageName);\n}", "item_id": 0, "repo": "airways/IupAndroid", "file": "src/win/iupwindows_info.c", "last_update_at": "2022-03-16T17:51:09+00:00", "question_id": "365d759e54ae8a20e9a7ab584d0051febd60aca0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char* iupdrvLocaleInfo(void)\n{\n  CPINFOEXA info;\n  GetCPInfoExA(CP_ACP, 0, &info);\n  return iupStrReturnStr(info.CodePageName);\n"]]}
{"hexsha": "30132c3957cdc3d2d76e03a5a82511d9b0a27829", "ext": "c", "lang": "C", "content": "static int jz4780_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msg,\n\t\t\t   int count)\n{\n\tint i = -EIO;\n\tint ret = 0;\n\tstruct jz4780_i2c *i2c = adap->algo_data;\n\n\tret = jz4780_i2c_prepare(i2c);\n\tif (ret) {\n\t\tdev_err(&i2c->adap.dev, \"I2C prepare failed\\n\");\n\t\tgoto out;\n\t}\n\n\tif (msg->addr != jz4780_i2c_readw(i2c, JZ4780_I2C_TAR)) {\n\t\tret = jz4780_i2c_set_target(i2c, msg->addr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tfor (i = 0; i < count; i++, msg++) {\n\t\tif (msg->flags & I2C_M_RD)\n\t\t\tret = jz4780_i2c_xfer_read(i2c, msg->buf, msg->len,\n\t\t\t\t\t\t   count, i);\n\t\telse\n\t\t\tret = jz4780_i2c_xfer_write(i2c, msg->buf, msg->len,\n\t\t\t\t\t\t    count, i);\n\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = i;\n\nout:\n\tjz4780_i2c_cleanup(i2c);\n\treturn ret;\n}", "item_id": 9, "repo": "fergy/aplit_linux-5", "file": "drivers/i2c/busses/i2c-jz4780.c", "last_update_at": "2022-01-16T07:19:47+00:00", "question_id": "30132c3957cdc3d2d76e03a5a82511d9b0a27829_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int jz4780_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msg,\n\t\t\t   int count)\n{\n\tint i = -EIO;\n\tint ret = 0;\n\tstruct jz4780_i2c *i2c = adap->algo_data;\n\tret = jz4780_i2c_prepare(i2c);\n\tif (ret) {\n\t\tdev_err(&i2c->adap.dev, \"I2C prepare failed\\n\");\n\t\tgoto out;\n\t}\n\tif (msg->addr != jz4780_i2c_readw(i2c, JZ4780_I2C_TAR)) {\n\t\tret = jz4780_i2c_set_target(i2c, msg->addr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tfor (i = 0; i < count; i++, msg++) {\n\t\tif (msg->flags & I2C_M_RD)\n\t\t\tret = jz4780_i2c_xfer_read(i2c, msg->buf, msg->len,\n\t\t\t\t\t\t   count, i);\n\t\telse\n\t\t\tret = jz4780_i2c_xfer_write(i2c, msg->buf, msg->len,\n\t\t\t\t\t\t    count, i);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tret = i;\nout:\n\tjz4780_i2c_cleanup(i2c);\n\treturn ret;\n"]]}
{"hexsha": "499ab030666202302d4272e2ba09a79fa59caa11", "ext": "h", "lang": "C", "content": "intE find_upper_bound_wing(std::vector<intE> &eIds, std::vector<intE> &tipVal, intE nEdgesRem)\n{\n    parallel_unstable_sort_kv_increasing(eIds, tipVal);\n    intE ub = 0;\n    if (nEdgesRem > 10*NUM_THREADS)\n    {\n        intE BS = (nEdgesRem-1)/NUM_THREADS + 1;\n        #pragma omp parallel num_threads(NUM_THREADS) reduction (max:ub)\n        {\n            unsigned tid = omp_get_thread_num();\n            intE start = tid*BS;\n            intE end = std::min(nEdgesRem, start+BS);\n            for (intE i = end-1; i>=start; i--)\n            {\n                intE currSupp = tipVal[eIds[i]];\n                intE numEdgesWithHigherSupp = nEdgesRem - i;\n                if (numEdgesWithHigherSupp >= currSupp)\n                {\n                    ub = std::max(ub, currSupp);\n                    break;\n                }\n                else\n                    ub = std::max(std::min(currSupp, numEdgesWithHigherSupp), ub);\n            }\n        }\n    }\n    else\n    {\n        for (intE i=nEdgesRem-1; i>=0; i--)\n        {\n            intE currSupp = tipVal[eIds[i]];\n            intE numEdgesWithHigherSupp = nEdgesRem - i;\n            if (numEdgesWithHigherSupp >= currSupp)\n            {\n                ub = std::max(ub, currSupp);\n                break;\n            }\n            else\n                ub = std::max(std::min(currSupp, numEdgesWithHigherSupp), ub);\n        }\n    }\n    return ub;\n}", "item_id": 11, "repo": "michaelyhuang23/RECEIPT", "file": "include/peel.h", "last_update_at": "2022-01-17T04:36:58+00:00", "question_id": "499ab030666202302d4272e2ba09a79fa59caa11_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["intE find_upper_bound_wing(std::vector<intE> &eIds, std::vector<intE> &tipVal, intE nEdgesRem)\n{\n    parallel_unstable_sort_kv_increasing(eIds, tipVal);\n    intE ub = 0;\n    if (nEdgesRem > 10*NUM_THREADS)\n    {\n        intE BS = (nEdgesRem-1)/NUM_THREADS + 1;\n        #pragma omp parallel num_threads(NUM_THREADS) reduction (max:ub)\n        {\n            unsigned tid = omp_get_thread_num();\n            intE start = tid*BS;\n            intE end = std::min(nEdgesRem, start+BS);\n            for (intE i = end-1; i>=start; i--)\n            {\n                intE currSupp = tipVal[eIds[i]];\n                intE numEdgesWithHigherSupp = nEdgesRem - i;\n                if (numEdgesWithHigherSupp >= currSupp)\n                {\n                    ub = std::max(ub, currSupp);\n                    break;\n                }\n                else\n                    ub = std::max(std::min(currSupp, numEdgesWithHigherSupp), ub);\n            }\n        }\n    }\n    else\n    {\n        for (intE i=nEdgesRem-1; i>=0; i--)\n        {\n            intE currSupp = tipVal[eIds[i]];\n            intE numEdgesWithHigherSupp = nEdgesRem - i;\n            if (numEdgesWithHigherSupp >= currSupp)\n            {\n                ub = std::max(ub, currSupp);\n                break;\n            }\n            else\n                ub = std::max(std::min(currSupp, numEdgesWithHigherSupp), ub);\n        }\n    }\n    return ub;\n"]]}
{"hexsha": "4a6c8d33098885c2ff9e2850533b9e7f5c5dd79f", "ext": "c", "lang": "C", "content": "void log_message(char *str, unsigned short len)\r\n{\r\n\tchar * str_ptr = str;\r\n\r\n//\tif(!sys_setting.enable_log)\r\n//\t\treturn;\r\n\tif(len == 0)\r\n\t\treturn;\r\n\r\n\twhile(len){\r\n\t\tuart0_writeb(*str_ptr);\r\n\t\tlen--;\r\n\t\tstr_ptr++;\r\n\t}\r\n}", "item_id": 0, "repo": "Youngho-Oh/Airmail", "file": "sys/log.c", "last_update_at": "2022-02-15T15:57:43+00:00", "question_id": "4a6c8d33098885c2ff9e2850533b9e7f5c5dd79f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void log_message(char *str, unsigned short len)\r\n{\r\n\tchar * str_ptr = str;\r\n\r\n//\tif(!sys_setting.enable_log)\r\n//\t\treturn;\r\n\tif(len == 0)\r\n\t\treturn;\r\n\r\n\twhile(len){\r\n\t\tuart0_writeb(*str_ptr);\r\n\t\tlen--;\r\n\t\tstr_ptr++;\r\n\t}\r\n"]]}
{"hexsha": "db5ed9ffd3363435481145591b680ed05330c2a0", "ext": "h", "lang": "C", "content": "inline ::TST::Deprecated_TableStrokeArchive* Deprecated_StrokePresetDataArchive::mutable_deprecated_vertical_stroke() {\n  ::TST::Deprecated_TableStrokeArchive* _msg = _internal_mutable_deprecated_vertical_stroke();\n  // @@protoc_insertion_point(field_mutable:TST.Deprecated_StrokePresetDataArchive.deprecated_vertical_stroke)\n  return _msg;\n}", "item_id": 108, "repo": "eth-siplab/SVG2Keynote-lib", "file": "keynote-protos/gen/TSTStylePropertyArchiving.pb.h", "last_update_at": "2022-03-14T07:52:44+00:00", "question_id": "db5ed9ffd3363435481145591b680ed05330c2a0_108", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["inline ::TST::Deprecated_TableStrokeArchive* Deprecated_StrokePresetDataArchive::mutable_deprecated_vertical_stroke() {\n  ::TST::Deprecated_TableStrokeArchive* _msg = _internal_mutable_deprecated_vertical_stroke();\n  // @@protoc_insertion_point(field_mutable:TST.Deprecated_StrokePresetDataArchive.deprecated_vertical_stroke)\n  return _msg;\n"]]}
{"hexsha": "53ebabf42472224ee1dee0eeea5e8f7879c4739c", "ext": "c", "lang": "C", "content": "static void scarlett2_notify_input_other(\n\tstruct usb_mixer_interface *mixer)\n{\n\tstruct snd_card *card = mixer->chip->card;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tint i;\n\n\tprivate->input_other_updated = 1;\n\n\tfor (i = 0; i < info->level_input_count; i++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &private->level_ctls[i]->id);\n\tfor (i = 0; i < info->pad_input_count; i++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &private->pad_ctls[i]->id);\n\tfor (i = 0; i < info->air_input_count; i++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &private->air_ctls[i]->id);\n\tfor (i = 0; i < info->phantom_count; i++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &private->phantom_ctls[i]->id);\n}", "item_id": 83, "repo": "jainsakshi2395/linux", "file": "sound/usb/mixer_scarlett_gen2.c", "last_update_at": "2022-03-31T03:23:42+00:00", "question_id": "53ebabf42472224ee1dee0eeea5e8f7879c4739c_83", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void scarlett2_notify_input_other(\n\tstruct usb_mixer_interface *mixer)\n{\n\tstruct snd_card *card = mixer->chip->card;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tint i;\n\tprivate->input_other_updated = 1;\n\tfor (i = 0; i < info->level_input_count; i++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &private->level_ctls[i]->id);\n\tfor (i = 0; i < info->pad_input_count; i++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &private->pad_ctls[i]->id);\n\tfor (i = 0; i < info->air_input_count; i++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &private->air_ctls[i]->id);\n\tfor (i = 0; i < info->phantom_count; i++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &private->phantom_ctls[i]->id);\n"]]}
{"hexsha": "6cfd14103a65f135b7307f74243a608fc8eb4e23", "ext": "c", "lang": "C", "content": "int javaBindClass(lua_State *L) {\n    int top;\n    const char *className;\n    jstring javaClassName;\n    jobject classInstance;\n    JNIEnv *javaEnv;\n\n    top = lua_gettop(L);\n\n    if (top != 1) {\n        luaL_error(\n                L, \"Error. Function javaBindClass received %d arguments, expected 1.\",\n                top);\n    }\n\n    /* Gets the JNI Environment */\n    javaEnv = checkEnv(L);\n\n    /* get the string parameter */\n    className = luaL_checkstring(L, 1);\n\n    javaClassName = (*javaEnv)->NewStringUTF(javaEnv, className);\n\n    classInstance = (*javaEnv)->CallStaticObjectMethod(\n            javaEnv, luajava_api_class, bind_class_method, javaClassName);\n\n    (*javaEnv)->DeleteLocalRef(javaEnv, javaClassName);\n    checkError(javaEnv, L);\n\n    /* pushes new object into lua stack */\n    pushJavaObject(L, classInstance);\n    (*javaEnv)->DeleteLocalRef(javaEnv, classInstance);\n    return 1;\n}", "item_id": 9, "repo": "nirenr/AndroLua-", "file": "app/src/main/jni/luajava/luajava.c", "last_update_at": "2022-03-30T13:22:47+00:00", "question_id": "6cfd14103a65f135b7307f74243a608fc8eb4e23_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int javaBindClass(lua_State *L) {\n    int top;\n    const char *className;\n    jstring javaClassName;\n    jobject classInstance;\n    JNIEnv *javaEnv;\n    top = lua_gettop(L);\n    if (top != 1) {\n        luaL_error(\n                L, \"Error. Function javaBindClass received %d arguments, expected 1.\",\n                top);\n    }\n    /* Gets the JNI Environment */\n    javaEnv = checkEnv(L);\n    /* get the string parameter */\n    className = luaL_checkstring(L, 1);\n    javaClassName = (*javaEnv)->NewStringUTF(javaEnv, className);\n    classInstance = (*javaEnv)->CallStaticObjectMethod(\n            javaEnv, luajava_api_class, bind_class_method, javaClassName);\n    (*javaEnv)->DeleteLocalRef(javaEnv, javaClassName);\n    checkError(javaEnv, L);\n    /* pushes new object into lua stack */\n    pushJavaObject(L, classInstance);\n    (*javaEnv)->DeleteLocalRef(javaEnv, classInstance);\n    return 1;\n"]]}
{"hexsha": "ba767b0ba6a7947b320418455e7332dd9cf0a6cc", "ext": "c", "lang": "C", "content": "static void ax_setmulti(sc)\n\tstruct ax_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tstruct ifmultiaddr\t*ifma;\n\tu_int32_t\t\trxfilt;\n\n\tifp = &sc->arpcom.ac_if;\n\n\trxfilt = CSR_READ_4(sc, AX_NETCFG);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= AX_NETCFG_RX_ALLMULTI;\n\t\tCSR_WRITE_4(sc, AX_NETCFG, rxfilt);\n\t\treturn;\n\t} else\n\t\trxfilt &= ~AX_NETCFG_RX_ALLMULTI;\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, AX_FILTIDX, AX_FILTIDX_MAR0);\n\tCSR_WRITE_4(sc, AX_FILTDATA, 0);\n\tCSR_WRITE_4(sc, AX_FILTIDX, AX_FILTIDX_MAR1);\n\tCSR_WRITE_4(sc, AX_FILTDATA, 0);\n\n\t/* now program new ones */\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t\t\t\tifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\th = ax_calchash(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t}\n\n\tCSR_WRITE_4(sc, AX_FILTIDX, AX_FILTIDX_MAR0);\n\tCSR_WRITE_4(sc, AX_FILTDATA, hashes[0]);\n\tCSR_WRITE_4(sc, AX_FILTIDX, AX_FILTIDX_MAR1);\n\tCSR_WRITE_4(sc, AX_FILTDATA, hashes[1]);\n\tCSR_WRITE_4(sc, AX_NETCFG, rxfilt);\n\n\treturn;\n}", "item_id": 12, "repo": "MarginC/kame", "file": "freebsd3/sys/pci/if_ax.c", "last_update_at": "2022-03-11T16:43:28+00:00", "question_id": "ba767b0ba6a7947b320418455e7332dd9cf0a6cc_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void ax_setmulti(sc)\n\tstruct ax_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tstruct ifmultiaddr\t*ifma;\n\tu_int32_t\t\trxfilt;\n\tifp = &sc->arpcom.ac_if;\n\trxfilt = CSR_READ_4(sc, AX_NETCFG);\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= AX_NETCFG_RX_ALLMULTI;\n\t\tCSR_WRITE_4(sc, AX_NETCFG, rxfilt);\n\t\treturn;\n\t} else\n\t\trxfilt &= ~AX_NETCFG_RX_ALLMULTI;\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, AX_FILTIDX, AX_FILTIDX_MAR0);\n\tCSR_WRITE_4(sc, AX_FILTDATA, 0);\n\tCSR_WRITE_4(sc, AX_FILTIDX, AX_FILTIDX_MAR1);\n\tCSR_WRITE_4(sc, AX_FILTDATA, 0);\n\t/* now program new ones */\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t\t\t\tifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\th = ax_calchash(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t}\n\tCSR_WRITE_4(sc, AX_FILTIDX, AX_FILTIDX_MAR0);\n\tCSR_WRITE_4(sc, AX_FILTDATA, hashes[0]);\n\tCSR_WRITE_4(sc, AX_FILTIDX, AX_FILTIDX_MAR1);\n\tCSR_WRITE_4(sc, AX_FILTDATA, hashes[1]);\n\tCSR_WRITE_4(sc, AX_NETCFG, rxfilt);\n\treturn;\n"]]}
{"hexsha": "968699c220483927480a1192fbb3e6d470a4a602", "ext": "c", "lang": "C", "content": "static inline void convert_VkGeometryTrianglesNV_win_to_host(const VkGeometryTrianglesNV *in, VkGeometryTrianglesNV_host *out)\n{\n    if (!in) return;\n\n    out->sType = in->sType;\n    out->pNext = in->pNext;\n    out->vertexData = in->vertexData;\n    out->vertexOffset = in->vertexOffset;\n    out->vertexCount = in->vertexCount;\n    out->vertexStride = in->vertexStride;\n    out->vertexFormat = in->vertexFormat;\n    out->indexData = in->indexData;\n    out->indexOffset = in->indexOffset;\n    out->indexCount = in->indexCount;\n    out->indexType = in->indexType;\n    out->transformData = in->transformData;\n    out->transformOffset = in->transformOffset;\n}", "item_id": 16, "repo": "xilwen/wine", "file": "dlls/winevulkan/vulkan_thunks.c", "last_update_at": "2022-03-31T18:52:48+00:00", "question_id": "968699c220483927480a1192fbb3e6d470a4a602_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void convert_VkGeometryTrianglesNV_win_to_host(const VkGeometryTrianglesNV *in, VkGeometryTrianglesNV_host *out)\n{\n    if (!in) return;\n    out->sType = in->sType;\n    out->pNext = in->pNext;\n    out->vertexData = in->vertexData;\n    out->vertexOffset = in->vertexOffset;\n    out->vertexCount = in->vertexCount;\n    out->vertexStride = in->vertexStride;\n    out->vertexFormat = in->vertexFormat;\n    out->indexData = in->indexData;\n    out->indexOffset = in->indexOffset;\n    out->indexCount = in->indexCount;\n    out->indexType = in->indexType;\n    out->transformData = in->transformData;\n    out->transformOffset = in->transformOffset;\n"]]}
{"hexsha": "04df6a01db950a2bbb8dff70c3d952f6f33473ed", "ext": "c", "lang": "C", "content": "static void brcm_stingray_hsls_tzpcprot_init(void)\n{\n\tunsigned int val;\n\tuintptr_t tzpcdecprot_base = HSLS_TZPC_BASE;\n\n\tVERBOSE(\"hsls tzpcprot init start\\n\");\n\n\t/* Treat third-party masters as non-secured */\n\tval = 0;\n\tval |= BIT(6); /* SDIO1 */\n\tval |= BIT(5); /* SDIO0 */\n\tval |= BIT(0); /* AMAC */\n\tmmio_write_32(tzpcdecprot_base + 0x810, val);\n\n\t/* Print TZPC decode status registers */\n\tVERBOSE(\" - tzpcdecprot0=0x%x\\n\",\n\t\tmmio_read_32(tzpcdecprot_base + 0x800));\n\n\tVERBOSE(\" - tzpcdecprot1=0x%x\\n\",\n\t\tmmio_read_32(tzpcdecprot_base + 0x80c));\n\n\tINFO(\"hsls tzpcprot init done\\n\");\n}", "item_id": 10, "repo": "sohumango/arm-trusted-firmware", "file": "plat/brcm/board/stingray/src/bl31_setup.c", "last_update_at": "2022-03-31T12:54:11+00:00", "question_id": "04df6a01db950a2bbb8dff70c3d952f6f33473ed_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void brcm_stingray_hsls_tzpcprot_init(void)\n{\n\tunsigned int val;\n\tuintptr_t tzpcdecprot_base = HSLS_TZPC_BASE;\n\tVERBOSE(\"hsls tzpcprot init start\\n\");\n\t/* Treat third-party masters as non-secured */\n\tval = 0;\n\tval |= BIT(6); /* SDIO1 */\n\tval |= BIT(5); /* SDIO0 */\n\tval |= BIT(0); /* AMAC */\n\tmmio_write_32(tzpcdecprot_base + 0x810, val);\n\t/* Print TZPC decode status registers */\n\tVERBOSE(\" - tzpcdecprot0=0x%x\\n\",\n\t\tmmio_read_32(tzpcdecprot_base + 0x800));\n\tVERBOSE(\" - tzpcdecprot1=0x%x\\n\",\n\t\tmmio_read_32(tzpcdecprot_base + 0x80c));\n\tINFO(\"hsls tzpcprot init done\\n\");\n"]]}
{"hexsha": "c83c621847d1d80daec3e33d101ef45040b91c89", "ext": "h", "lang": "C", "content": "inline void assign( DenseVector<VT,TF>& lhs, const Band& rhs )\n   {\n      using blaze::row;\n      using blaze::column;\n\n      BLAZE_FUNCTION_TRACE;\n\n      BLAZE_INTERNAL_ASSERT( (~lhs).size() == rhs.size(), \"Invalid vector sizes\" );\n\n      LT A( serial( rhs.operand().leftOperand()  ) );\n      RT B( serial( rhs.operand().rightOperand() ) );\n\n      const size_t n( rhs.size() );\n      for( size_t i=0UL; i<n; ++i ) {\n         (~lhs)[i] = row( A, rhs.row()+i, unchecked ) * column( B, rhs.column()+i, unchecked );\n      }\n   }", "item_id": 2, "repo": "dendisuhubdy/blaze", "file": "blaze/math/views/band/Sparse.h", "last_update_at": "2022-03-07T12:42:29+00:00", "question_id": "c83c621847d1d80daec3e33d101ef45040b91c89_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["inline void assign( DenseVector<VT,TF>& lhs, const Band& rhs )\n   {\n      using blaze::row;\n      using blaze::column;\n      BLAZE_FUNCTION_TRACE;\n      BLAZE_INTERNAL_ASSERT( (~lhs).size() == rhs.size(), \"Invalid vector sizes\" );\n      LT A( serial( rhs.operand().leftOperand()  ) );\n      RT B( serial( rhs.operand().rightOperand() ) );\n      const size_t n( rhs.size() );\n      for( size_t i=0UL; i<n; ++i ) {\n         (~lhs)[i] = row( A, rhs.row()+i, unchecked ) * column( B, rhs.column()+i, unchecked );\n      }\n"]]}
{"hexsha": "1db4b0b3287a8b8ac3362eec14771ebbf776f394", "ext": "c", "lang": "C", "content": "void ceph_fill_file_time(struct inode *inode, int issued,\n\t\t\t u64 time_warp_seq, struct timespec *ctime,\n\t\t\t struct timespec *mtime, struct timespec *atime)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint warn = 0;\n\n\tif (issued & (CEPH_CAP_FILE_EXCL|\n\t\t      CEPH_CAP_FILE_WR|\n\t\t      CEPH_CAP_FILE_BUFFER|\n\t\t      CEPH_CAP_AUTH_EXCL|\n\t\t      CEPH_CAP_XATTR_EXCL)) {\n\t\tif (timespec_compare(ctime, &inode->i_ctime) > 0) {\n\t\t\tdout(\"ctime %ld.%09ld -> %ld.%09ld inc w/ cap\\n\",\n\t\t\t     inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,\n\t\t\t     ctime->tv_sec, ctime->tv_nsec);\n\t\t\tinode->i_ctime = *ctime;\n\t\t}\n\t\tif (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) > 0) {\n\t\t\t/* the MDS did a utimes() */\n\t\t\tdout(\"mtime %ld.%09ld -> %ld.%09ld \"\n\t\t\t     \"tw %d -> %d\\n\",\n\t\t\t     inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,\n\t\t\t     mtime->tv_sec, mtime->tv_nsec,\n\t\t\t     ci->i_time_warp_seq, (int)time_warp_seq);\n\n\t\t\tinode->i_mtime = *mtime;\n\t\t\tinode->i_atime = *atime;\n\t\t\tci->i_time_warp_seq = time_warp_seq;\n\t\t} else if (time_warp_seq == ci->i_time_warp_seq) {\n\t\t\t/* nobody did utimes(); take the max */\n\t\t\tif (timespec_compare(mtime, &inode->i_mtime) > 0) {\n\t\t\t\tdout(\"mtime %ld.%09ld -> %ld.%09ld inc\\n\",\n\t\t\t\t     inode->i_mtime.tv_sec,\n\t\t\t\t     inode->i_mtime.tv_nsec,\n\t\t\t\t     mtime->tv_sec, mtime->tv_nsec);\n\t\t\t\tinode->i_mtime = *mtime;\n\t\t\t}\n\t\t\tif (timespec_compare(atime, &inode->i_atime) > 0) {\n\t\t\t\tdout(\"atime %ld.%09ld -> %ld.%09ld inc\\n\",\n\t\t\t\t     inode->i_atime.tv_sec,\n\t\t\t\t     inode->i_atime.tv_nsec,\n\t\t\t\t     atime->tv_sec, atime->tv_nsec);\n\t\t\t\tinode->i_atime = *atime;\n\t\t\t}\n\t\t} else if (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\t/* we did a utimes(); ignore mds values */\n\t\t} else {\n\t\t\twarn = 1;\n\t\t}\n\t} else {\n\t\t/* we have no write|excl caps; whatever the MDS says is true */\n\t\tif (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) >= 0) {\n\t\t\tinode->i_ctime = *ctime;\n\t\t\tinode->i_mtime = *mtime;\n\t\t\tinode->i_atime = *atime;\n\t\t\tci->i_time_warp_seq = time_warp_seq;\n\t\t} else {\n\t\t\twarn = 1;\n\t\t}\n\t}\n\tif (warn) /* time_warp_seq shouldn't go backwards */\n\t\tdout(\"%p mds time_warp_seq %llu < %u\\n\",\n\t\t     inode, time_warp_seq, ci->i_time_warp_seq);\n}", "item_id": 37, "repo": "oslab-swrc/juxta", "file": "analyzer/data/fs/linux-3.17/ceph.c", "last_update_at": "2022-02-12T15:53:20+00:00", "question_id": "1db4b0b3287a8b8ac3362eec14771ebbf776f394_37", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void ceph_fill_file_time(struct inode *inode, int issued,\n\t\t\t u64 time_warp_seq, struct timespec *ctime,\n\t\t\t struct timespec *mtime, struct timespec *atime)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint warn = 0;\n\tif (issued & (CEPH_CAP_FILE_EXCL|\n\t\t      CEPH_CAP_FILE_WR|\n\t\t      CEPH_CAP_FILE_BUFFER|\n\t\t      CEPH_CAP_AUTH_EXCL|\n\t\t      CEPH_CAP_XATTR_EXCL)) {\n\t\tif (timespec_compare(ctime, &inode->i_ctime) > 0) {\n\t\t\tdout(\"ctime %ld.%09ld -> %ld.%09ld inc w/ cap\\n\",\n\t\t\t     inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,\n\t\t\t     ctime->tv_sec, ctime->tv_nsec);\n\t\t\tinode->i_ctime = *ctime;\n\t\t}\n\t\tif (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) > 0) {\n\t\t\t/* the MDS did a utimes() */\n\t\t\tdout(\"mtime %ld.%09ld -> %ld.%09ld \"\n\t\t\t     \"tw %d -> %d\\n\",\n\t\t\t     inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,\n\t\t\t     mtime->tv_sec, mtime->tv_nsec,\n\t\t\t     ci->i_time_warp_seq, (int)time_warp_seq);\n\t\t\tinode->i_mtime = *mtime;\n\t\t\tinode->i_atime = *atime;\n\t\t\tci->i_time_warp_seq = time_warp_seq;\n\t\t} else if (time_warp_seq == ci->i_time_warp_seq) {\n\t\t\t/* nobody did utimes(); take the max */\n\t\t\tif (timespec_compare(mtime, &inode->i_mtime) > 0) {\n\t\t\t\tdout(\"mtime %ld.%09ld -> %ld.%09ld inc\\n\",\n\t\t\t\t     inode->i_mtime.tv_sec,\n\t\t\t\t     inode->i_mtime.tv_nsec,\n\t\t\t\t     mtime->tv_sec, mtime->tv_nsec);\n\t\t\t\tinode->i_mtime = *mtime;\n\t\t\t}\n\t\t\tif (timespec_compare(atime, &inode->i_atime) > 0) {\n\t\t\t\tdout(\"atime %ld.%09ld -> %ld.%09ld inc\\n\",\n\t\t\t\t     inode->i_atime.tv_sec,\n\t\t\t\t     inode->i_atime.tv_nsec,\n\t\t\t\t     atime->tv_sec, atime->tv_nsec);\n\t\t\t\tinode->i_atime = *atime;\n\t\t\t}\n\t\t} else if (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\t/* we did a utimes(); ignore mds values */\n\t\t} else {\n\t\t\twarn = 1;\n\t\t}\n\t} else {\n\t\t/* we have no write|excl caps; whatever the MDS says is true */\n\t\tif (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) >= 0) {\n\t\t\tinode->i_ctime = *ctime;\n\t\t\tinode->i_mtime = *mtime;\n\t\t\tinode->i_atime = *atime;\n\t\t\tci->i_time_warp_seq = time_warp_seq;\n\t\t} else {\n\t\t\twarn = 1;\n\t\t}\n\t}\n\tif (warn) /* time_warp_seq shouldn't go backwards */\n\t\tdout(\"%p mds time_warp_seq %llu < %u\\n\",\n\t\t     inode, time_warp_seq, ci->i_time_warp_seq);\n"]]}
{"hexsha": "ea56b263a773d97c16ffa067bfa35320f5c9039b", "ext": "c", "lang": "C", "content": "static void loraWriteReg(uint16_t addr, uint8_t *buf, uint32_t len)\r\n{\r\n    uint32_t err_code;\r\n    uint8_t m_tx_buf; /**< TX buffer. */\r\n    uint8_t m_rx_buf; /**< RX buffer. */\r\n\r\n    loraWaitOnBusy();\r\n    udrv_gpio_set_logic(42 /*NSS*/, GPIO_LOGIC_LOW);\r\n\r\n    atcmd_printf(\"writereg=0x%x\\r\\n\", addr);\r\n\r\n    m_tx_buf = 0x0D; //Write reg\r\n    err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);\r\n    //atcmd_printf(\"err_code=0x%x\\r\\n\", err_code);\r\n\r\n    m_tx_buf = (addr & 0xFF00) >> 8;\r\n    err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);\r\n    //atcmd_printf(\"err_code=0x%x\\r\\n\", err_code);\r\n\r\n    m_tx_buf = (addr & 0x00FF);\r\n    err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);\r\n    //atcmd_printf(\"err_code=0x%x\\r\\n\", err_code);\r\n\r\n    //m_tx_buf = 0;\r\n    //err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);\r\n\r\n    m_rx_buf = 0;\r\n    for (int i = 0; i < len; i++)\r\n    {\r\n        m_tx_buf = *(buf + i);\r\n        err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);\r\n        atcmd_printf(\"m_tx_buf=0x%x\\r\\n\", m_tx_buf);\r\n    }\r\n\r\n    atcmd_printf(\"=====\\r\\n\");\r\n\r\n    udrv_gpio_set_logic(42 /*NSS*/, GPIO_LOGIC_HIGH);\r\n    loraWaitOnBusy();\r\n}", "item_id": 2, "repo": "RAKWireless/RAK-nRF52-RUI", "file": "cores/nRF5/component/service/mode/cli/atcmd_join_send.c", "last_update_at": "2022-03-30T09:53:52+00:00", "question_id": "ea56b263a773d97c16ffa067bfa35320f5c9039b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void loraWriteReg(uint16_t addr, uint8_t *buf, uint32_t len)\r\n{\r\n    uint32_t err_code;\r\n    uint8_t m_tx_buf; /**< TX buffer. */\r\n    uint8_t m_rx_buf; /**< RX buffer. */\r\n\r\n    loraWaitOnBusy();\r\n    udrv_gpio_set_logic(42 /*NSS*/, GPIO_LOGIC_LOW);\r\n\r\n    atcmd_printf(\"writereg=0x%x\\r\\n\", addr);\r\n\r\n    m_tx_buf = 0x0D; //Write reg\r\n    err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);\r\n    //atcmd_printf(\"err_code=0x%x\\r\\n\", err_code);\r\n\r\n    m_tx_buf = (addr & 0xFF00) >> 8;\r\n    err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);\r\n    //atcmd_printf(\"err_code=0x%x\\r\\n\", err_code);\r\n\r\n    m_tx_buf = (addr & 0x00FF);\r\n    err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);\r\n    //atcmd_printf(\"err_code=0x%x\\r\\n\", err_code);\r\n\r\n    //m_tx_buf = 0;\r\n    //err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);\r\n\r\n    m_rx_buf = 0;\r\n    for (int i = 0; i < len; i++)\r\n    {\r\n        m_tx_buf = *(buf + i);\r\n        err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);\r\n        atcmd_printf(\"m_tx_buf=0x%x\\r\\n\", m_tx_buf);\r\n    }\r\n\r\n    atcmd_printf(\"=====\\r\\n\");\r\n\r\n    udrv_gpio_set_logic(42 /*NSS*/, GPIO_LOGIC_HIGH);\r\n    loraWaitOnBusy();\r\n"]]}
{"hexsha": "a2cb8597de1c93bb53b665642848d99f4788f17c", "ext": "h", "lang": "C", "content": "namespace sba\n{\n  /// Let's try templated versions\n\n  template <int N>\n    class jacobiBPCG \n    {\n    public:\n      jacobiBPCG() { residual = 0.0; };\n      int doBPCG(int iters, double tol,\n                 vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n                 vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,\n                 VectorXd &x,\n                 VectorXd &b,\n                 bool abstol = false,\n                 bool verbose = false\n                 );\n\n      // uses internal linear storage for Hessian\n      int doBPCG2(int iters, double tol,\n                 vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n                 vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,\n                 VectorXd &x,\n                 VectorXd &b,\n                 bool abstol = false,\n                 bool verbose = false\n                 );\n\n      double residual;\n\n    private:\n      void mMV(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n               vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,\n               const VectorXd &vin,\n               VectorXd &vout);\n \n      // uses internal linear storage\n      void mMV2(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n                const VectorXd &vin,\n                VectorXd &vout);\n \n      void mD(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n              VectorXd &vin,\n              VectorXd &vout);\n\n      vector<int> vcind, vrind;\n      vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > vcols;\n    };\n\n  template <int N>\n    void jacobiBPCG<N>::mMV(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n                        vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,\n                        const VectorXd &vin,\n                        VectorXd &vout)\n    {\n    // loop over all entries\n      if (cols.size() > 0)\n        for (int i=0; i<(int)cols.size(); i++)\n          {\n            vout.segment<N>(i*N) = diag[i]*vin.segment<N>(i*N); // only works with cols ordering\n\n            map<int,Matrix<double,N,N>, less<int>, \n              aligned_allocator<Matrix<double,N,N> > > &col = cols[i];\n            if (col.size() > 0)\n              {\n                typename map<int,Matrix<double,N,N>, less<int>, // need \"typename\" here, barf\n                  aligned_allocator<Matrix<double,N,N > > >::iterator it;\n                for (it = col.begin(); it != col.end(); it++)\n                  {\n                    int ri = (*it).first; // get row index\n                    const Matrix<double,N,N> &M = (*it).second; // matrix\n                    vout.segment<N>(i*N)  += M.transpose()*vin.segment<N>(ri*N);\n                    vout.segment<N>(ri*N) += M*vin.segment<N>(i*N);\n                  }\n              }\n          }\n    }\n\n  //\n  // matrix-vector multiply with linear storage\n  //\n\n  template <int N>\n    void jacobiBPCG<N>::mMV2(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n                             const VectorXd &vin,\n                             VectorXd &vout)\n    {\n      // linear storage for matrices\n      // loop over off-diag entries\n      if (diag.size() > 0)\n        for (int i=0; i<(int)diag.size(); i++)\n          vout.segment<N>(i*N) = diag[i]*vin.segment<N>(i*N); // only works with cols ordering\n\n      for (int i=0; i<(int)vcind.size(); i++)\n        {\n          int ri = vrind[i];\n          int ii = vcind[i];\n          const Matrix<double,N,N> &M = vcols[i];\n          vout.segment<N>(ri*N) += M*vin.segment<N>(ii*N);\n          vout.segment<N>(ii*N) += M.transpose()*vin.segment<N>(ri*N);\n        }\n    }\n\n\n\n\n  template <int N>\n    void jacobiBPCG<N>::mD(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n            VectorXd &vin,\n            VectorXd &vout)\n    {\n      // loop over diag entries\n      for (int i=0; i<(int)diag.size(); i++)\n        vout.segment<N>(i*N) = diag[i]*vin.segment<N>(i*N);\n    }\n\n\n  template <int N>\n    int jacobiBPCG<N>::doBPCG(int iters, double tol,\n\t    vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n\t    vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,\n\t    VectorXd &x,\n\t    VectorXd &b,\n\t    bool abstol,\n\t    bool verbose)\n    {\n      // set up local vars\n      VectorXd r,d,q,s;\n      int n = diag.size();\n      int n6 = n*N;\n      r.setZero(n6);\n      d.setZero(n6);\n      q.setZero(n6);\n      s.setZero(n6);\n\n      // set up Jacobi preconditioner\n      vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > J;\n      J.resize(n);\n      for (int i=0; i<n; i++)\n        J[i] = diag[i].inverse();\n\n      int i;\n      r = b;\n      mD(J,r,d);\n      double dn = r.dot(d);\n      double d0 = tol*dn;\n      if (abstol)               // change tolerances\n        {\n          if (residual > d0) d0 = residual;\n        }\n\n      for (i=0; i<iters; i++)\n        {\n          if (verbose && 0)\n            cout << \"[BPCG] residual[\" << i << \"]: \" << dn << \" < \" << d0 << endl;\n          if (dn < d0) break;\t// done\n          mMV(diag,cols,d,q);\n          double a = dn / d.dot(q);\n          x += a*d;\n          // TODO: reset residual here every 50 iterations\n          r -= a*q;\n          mD(J,r,s);\n          double dold = dn;\n          dn = r.dot(s);\n          double ba = dn / dold;\n          d = s + ba*d;\n        }\n\n  \n      if (verbose)\n        cout << \"[BPCG] residual[\" << i << \"]: \" << dn << endl;\n      residual = dn/2.0;\n      return i;\n    }\n\n\n  // uses internal linear storage for Hessian\n  template <int N>\n    int jacobiBPCG<N>::doBPCG2(int iters, double tol,\n\t    vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n\t    vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,\n\t    VectorXd &x,\n\t    VectorXd &b,\n\t    bool abstol,\n\t    bool verbose)\n    {\n      // set up local vars\n      VectorXd r,d,q,s;\n      int n = diag.size();\n      int n6 = n*N;\n      r.setZero(n6);\n      d.setZero(n6);\n      q.setZero(n6);\n      s.setZero(n6);\n\n      vcind.clear();\n      vrind.clear();\n      vcols.clear();\n\n      // set up alternate rep for sparse matrix\n      for (int i=0; i<(int)cols.size(); i++)\n        {\n          map<int,Matrix<double,N,N>, less<int>, \n            aligned_allocator<Matrix<double,N,N> > > &col = cols[i];\n          if (col.size() > 0)\n            {\n              typename map<int,Matrix<double,N,N>, less<int>, \n                aligned_allocator<Matrix<double,N,N> > >::iterator it;\n              for (it = col.begin(); it != col.end(); it++)\n                {\n                  int ri = (*it).first; // get row index\n                  vrind.push_back(ri);\n                  vcind.push_back(i);\n                  vcols.push_back((*it).second);\n                }\n            }\n        }\n\n      // set up Jacobi preconditioner\n      vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > J;\n      J.resize(n);\n      for (int i=0; i<n; i++)\n        J[i] = diag[i].inverse();\n\n      int i;\n      r = b;\n      mD(J,r,d);\n      double dn = r.dot(d);\n      double d0 = tol*dn;\n      if (abstol)               // change tolerances\n        {\n          if (residual > d0) d0 = residual;\n        }\n\n      for (i=0; i<iters; i++)\n        {\n          if (verbose && 0)\n            cout << \"[BPCG] residual[\" << i << \"]: \" << dn << \" < \" << d0 << endl;\n          if (dn < d0) break;\t// done\n          mMV2(diag,d,q);\n          double a = dn / d.dot(q);\n          x += a*d;\n          // TODO: reset residual here every 50 iterations\n          r -= a*q;\n          mD(J,r,s);\n          double dold = dn;\n          dn = r.dot(s);\n          double ba = dn / dold;\n          d = s + ba*d;\n        }\n\n  \n      if (verbose)\n        cout << \"[BPCG] residual[\" << i << \"]: \" << dn << endl;\n      residual = dn/2.0;\n      return i;\n    }\n\n\n#if 0\n//\n// matrix multiply of compressed column storage + diagonal blocks by a vector\n//\n\nvoid\nmMV(vector< Matrix<double,6,6>, aligned_allocator<Matrix<double,6,6> > > &diag,\n    vector< map<int,Matrix<double,6,6>, less<int>, aligned_allocator<Matrix<double,6,6> > > > &cols,\n    const VectorXd &vin,\n    VectorXd &vout);\n\n//\n// jacobi-preconditioned block conjugate gradient\n// returns number of iterations\n\nint\nbpcg_jacobi(int iters, double tol,\n\t    vector< Matrix<double,6,6>, aligned_allocator<Matrix<double,6,6> > > &diag,\n\t    vector< map<int,Matrix<double,6,6>, less<int>, aligned_allocator<Matrix<double,6,6> > > > &cols,\n\t    VectorXd &x,\n\t    VectorXd &b,\n\t    bool abstol = false,\n\t    bool verbose = false\n         );\n\nint\nbpcg_jacobi_dense(int iters, double tol,\n\t\t  MatrixXd &M,\n\t\t  VectorXd &x,\n\t\t  VectorXd &b);\n\n//\n// jacobi-preconditioned block conjugate gradient\n// returns number of iterations\n\nint\nbpcg_jacobi3(int iters, double tol,\n\t    vector< Matrix<double,3,3>, aligned_allocator<Matrix<double,3,3> > > &diag,\n\t    vector< map<int,Matrix<double,3,3>, less<int>, aligned_allocator<Matrix<double,3,3> > > > &cols,\n\t    VectorXd &x,\n\t    VectorXd &b,\n\t    bool abstol = false,\n\t    bool verbose = false\n         );\n\nint\nbpcg_jacobi_dense3(int iters, double tol,\n\t\t  MatrixXd &M,\n\t\t  VectorXd &x,\n\t\t  VectorXd &b);\n\n#endif\n\n}", "item_id": 0, "repo": "Kin-Zhang/turtlebot_simulation", "file": "src/sparse_bundle_adjustment/include/sparse_bundle_adjustment/bpcg/bpcg.h", "last_update_at": "2022-03-31T06:56:09+00:00", "question_id": "a2cb8597de1c93bb53b665642848d99f4788f17c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace sba\n{\n  /// Let's try templated versions\n  template <int N>\n    class jacobiBPCG \n    {\n    public:\n      jacobiBPCG() { residual = 0.0; };\n      int doBPCG(int iters, double tol,\n                 vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n                 vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,\n                 VectorXd &x,\n                 VectorXd &b,\n                 bool abstol = false,\n                 bool verbose = false\n                 );\n      // uses internal linear storage for Hessian\n      int doBPCG2(int iters, double tol,\n                 vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n                 vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,\n                 VectorXd &x,\n                 VectorXd &b,\n                 bool abstol = false,\n                 bool verbose = false\n                 );\n      double residual;\n    private:\n      void mMV(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n               vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,\n               const VectorXd &vin,\n               VectorXd &vout);\n      // uses internal linear storage\n      void mMV2(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n                const VectorXd &vin,\n                VectorXd &vout);\n      void mD(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n              VectorXd &vin,\n              VectorXd &vout);\n      vector<int> vcind, vrind;\n      vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > vcols;\n    };\n  template <int N>\n    void jacobiBPCG<N>::mMV(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n                        vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,\n                        const VectorXd &vin,\n                        VectorXd &vout)\n    {\n    // loop over all entries\n      if (cols.size() > 0)\n        for (int i=0; i<(int)cols.size(); i++)\n          {\n            vout.segment<N>(i*N) = diag[i]*vin.segment<N>(i*N); // only works with cols ordering\n            map<int,Matrix<double,N,N>, less<int>, \n              aligned_allocator<Matrix<double,N,N> > > &col = cols[i];\n            if (col.size() > 0)\n              {\n                typename map<int,Matrix<double,N,N>, less<int>, // need \"typename\" here, barf\n                  aligned_allocator<Matrix<double,N,N > > >::iterator it;\n                for (it = col.begin(); it != col.end(); it++)\n                  {\n                    int ri = (*it).first; // get row index\n                    const Matrix<double,N,N> &M = (*it).second; // matrix\n                    vout.segment<N>(i*N)  += M.transpose()*vin.segment<N>(ri*N);\n                    vout.segment<N>(ri*N) += M*vin.segment<N>(i*N);\n                  }\n              }\n          }\n    }\n  //\n  // matrix-vector multiply with linear storage\n  //\n  template <int N>\n    void jacobiBPCG<N>::mMV2(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n                             const VectorXd &vin,\n                             VectorXd &vout)\n    {\n      // linear storage for matrices\n      // loop over off-diag entries\n      if (diag.size() > 0)\n        for (int i=0; i<(int)diag.size(); i++)\n          vout.segment<N>(i*N) = diag[i]*vin.segment<N>(i*N); // only works with cols ordering\n      for (int i=0; i<(int)vcind.size(); i++)\n        {\n          int ri = vrind[i];\n          int ii = vcind[i];\n          const Matrix<double,N,N> &M = vcols[i];\n          vout.segment<N>(ri*N) += M*vin.segment<N>(ii*N);\n          vout.segment<N>(ii*N) += M.transpose()*vin.segment<N>(ri*N);\n        }\n    }\n  template <int N>\n    void jacobiBPCG<N>::mD(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n            VectorXd &vin,\n            VectorXd &vout)\n    {\n      // loop over diag entries\n      for (int i=0; i<(int)diag.size(); i++)\n        vout.segment<N>(i*N) = diag[i]*vin.segment<N>(i*N);\n    }\n  template <int N>\n    int jacobiBPCG<N>::doBPCG(int iters, double tol,\n\t    vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n\t    vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,\n\t    VectorXd &x,\n\t    VectorXd &b,\n\t    bool abstol,\n\t    bool verbose)\n    {\n      // set up local vars\n      VectorXd r,d,q,s;\n      int n = diag.size();\n      int n6 = n*N;\n      r.setZero(n6);\n      d.setZero(n6);\n      q.setZero(n6);\n      s.setZero(n6);\n      // set up Jacobi preconditioner\n      vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > J;\n      J.resize(n);\n      for (int i=0; i<n; i++)\n        J[i] = diag[i].inverse();\n      int i;\n      r = b;\n      mD(J,r,d);\n      double dn = r.dot(d);\n      double d0 = tol*dn;\n      if (abstol)               // change tolerances\n        {\n          if (residual > d0) d0 = residual;\n        }\n      for (i=0; i<iters; i++)\n        {\n          if (verbose && 0)\n            cout << \"[BPCG] residual[\" << i << \"]: \" << dn << \" < \" << d0 << endl;\n          if (dn < d0) break;\t// done\n          mMV(diag,cols,d,q);\n          double a = dn / d.dot(q);\n          x += a*d;\n          // TODO: reset residual here every 50 iterations\n          r -= a*q;\n          mD(J,r,s);\n          double dold = dn;\n          dn = r.dot(s);\n          double ba = dn / dold;\n          d = s + ba*d;\n        }\n      if (verbose)\n        cout << \"[BPCG] residual[\" << i << \"]: \" << dn << endl;\n      residual = dn/2.0;\n      return i;\n    }\n  // uses internal linear storage for Hessian\n  template <int N>\n    int jacobiBPCG<N>::doBPCG2(int iters, double tol,\n\t    vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,\n\t    vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,\n\t    VectorXd &x,\n\t    VectorXd &b,\n\t    bool abstol,\n\t    bool verbose)\n    {\n      // set up local vars\n      VectorXd r,d,q,s;\n      int n = diag.size();\n      int n6 = n*N;\n      r.setZero(n6);\n      d.setZero(n6);\n      q.setZero(n6);\n      s.setZero(n6);\n      vcind.clear();\n      vrind.clear();\n      vcols.clear();\n      // set up alternate rep for sparse matrix\n      for (int i=0; i<(int)cols.size(); i++)\n        {\n          map<int,Matrix<double,N,N>, less<int>, \n            aligned_allocator<Matrix<double,N,N> > > &col = cols[i];\n          if (col.size() > 0)\n            {\n              typename map<int,Matrix<double,N,N>, less<int>, \n                aligned_allocator<Matrix<double,N,N> > >::iterator it;\n              for (it = col.begin(); it != col.end(); it++)\n                {\n                  int ri = (*it).first; // get row index\n                  vrind.push_back(ri);\n                  vcind.push_back(i);\n                  vcols.push_back((*it).second);\n                }\n            }\n        }\n      // set up Jacobi preconditioner\n      vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > J;\n      J.resize(n);\n      for (int i=0; i<n; i++)\n        J[i] = diag[i].inverse();\n      int i;\n      r = b;\n      mD(J,r,d);\n      double dn = r.dot(d);\n      double d0 = tol*dn;\n      if (abstol)               // change tolerances\n        {\n          if (residual > d0) d0 = residual;\n        }\n      for (i=0; i<iters; i++)\n        {\n          if (verbose && 0)\n            cout << \"[BPCG] residual[\" << i << \"]: \" << dn << \" < \" << d0 << endl;\n          if (dn < d0) break;\t// done\n          mMV2(diag,d,q);\n          double a = dn / d.dot(q);\n          x += a*d;\n          // TODO: reset residual here every 50 iterations\n          r -= a*q;\n          mD(J,r,s);\n          double dold = dn;\n          dn = r.dot(s);\n          double ba = dn / dold;\n          d = s + ba*d;\n        }\n      if (verbose)\n        cout << \"[BPCG] residual[\" << i << \"]: \" << dn << endl;\n      residual = dn/2.0;\n      return i;\n    }\n#if 0\n//\n// matrix multiply of compressed column storage + diagonal blocks by a vector\n//\nvoid\nmMV(vector< Matrix<double,6,6>, aligned_allocator<Matrix<double,6,6> > > &diag,\n    vector< map<int,Matrix<double,6,6>, less<int>, aligned_allocator<Matrix<double,6,6> > > > &cols,\n    const VectorXd &vin,\n    VectorXd &vout);\n//\n// jacobi-preconditioned block conjugate gradient\n// returns number of iterations\nint\nbpcg_jacobi(int iters, double tol,\n\t    vector< Matrix<double,6,6>, aligned_allocator<Matrix<double,6,6> > > &diag,\n\t    vector< map<int,Matrix<double,6,6>, less<int>, aligned_allocator<Matrix<double,6,6> > > > &cols,\n\t    VectorXd &x,\n\t    VectorXd &b,\n\t    bool abstol = false,\n\t    bool verbose = false\n         );\nint\nbpcg_jacobi_dense(int iters, double tol,\n\t\t  MatrixXd &M,\n\t\t  VectorXd &x,\n\t\t  VectorXd &b);\n//\n// jacobi-preconditioned block conjugate gradient\n// returns number of iterations\nint\nbpcg_jacobi3(int iters, double tol,\n\t    vector< Matrix<double,3,3>, aligned_allocator<Matrix<double,3,3> > > &diag,\n\t    vector< map<int,Matrix<double,3,3>, less<int>, aligned_allocator<Matrix<double,3,3> > > > &cols,\n\t    VectorXd &x,\n\t    VectorXd &b,\n\t    bool abstol = false,\n\t    bool verbose = false\n         );\nint\nbpcg_jacobi_dense3(int iters, double tol,\n\t\t  MatrixXd &M,\n\t\t  VectorXd &x,\n\t\t  VectorXd &b);\n#endif\n"]]}
{"hexsha": "2bef69f6ec53d10418a5d563db3ae021677cfd94", "ext": "c", "lang": "C", "content": "void init() {\n  nextid = 1;\n  bids = new_list();\n  asks = new_list();\n}", "item_id": 5, "repo": "rubik/lobster", "file": "quantcup/_engine.c", "last_update_at": "2022-03-18T15:40:38+00:00", "question_id": "2bef69f6ec53d10418a5d563db3ae021677cfd94_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void init() {\n  nextid = 1;\n  bids = new_list();\n  asks = new_list();\n"]]}
{"hexsha": "190d049927fbdd643968cb95e4448b87b87f151a", "ext": "c", "lang": "C", "content": "void xmhf_smpguest_arch_x86vmx_initialize(VCPU *vcpu, u32 unmaplapic){\n  u32 eax, edx;\n\n  //read LAPIC base address from MSR\n  rdmsr(MSR_APIC_BASE, &eax, &edx);\n  HALT_ON_ERRORCOND( edx == 0 ); //APIC should be below 4G\n\n  g_vmx_lapic_base = eax & 0xFFFFF000UL;\n  //printf(\"\\nBSP(0x%02x): LAPIC base=0x%08x\", vcpu->id, g_vmx_lapic_base);\n\n  if (unmaplapic) {\n    //unmap LAPIC page\n    vmx_lapic_changemapping(vcpu, g_vmx_lapic_base, g_vmx_lapic_base, VMX_LAPIC_UNMAP);\n  }\n}", "item_id": 3, "repo": "lxylxy123456/uberxmhf", "file": "xmhf/src/xmhf-core/xmhf-runtime/xmhf-smpguest/arch/x86/vmx/smpg-x86vmx.c", "last_update_at": "2022-03-12T20:57:57+00:00", "question_id": "190d049927fbdd643968cb95e4448b87b87f151a_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void xmhf_smpguest_arch_x86vmx_initialize(VCPU *vcpu, u32 unmaplapic){\n  u32 eax, edx;\n  //read LAPIC base address from MSR\n  rdmsr(MSR_APIC_BASE, &eax, &edx);\n  HALT_ON_ERRORCOND( edx == 0 ); //APIC should be below 4G\n  g_vmx_lapic_base = eax & 0xFFFFF000UL;\n  //printf(\"\\nBSP(0x%02x): LAPIC base=0x%08x\", vcpu->id, g_vmx_lapic_base);\n  if (unmaplapic) {\n    //unmap LAPIC page\n    vmx_lapic_changemapping(vcpu, g_vmx_lapic_base, g_vmx_lapic_base, VMX_LAPIC_UNMAP);\n  }\n"]]}
{"hexsha": "66060a326c76398976637abbff57c7fcc3be2a11", "ext": "c", "lang": "C", "content": "int Si3226x_EnableInterrupts (proslicChanType_ptr pProslic){\n    WriteReg (pProHW,pProslic->channel,IRQEN1,Si3226x_General_Configuration.irqen1);\n    WriteReg (pProHW,pProslic->channel,IRQEN2,Si3226x_General_Configuration.irqen2);\n    WriteReg (pProHW,pProslic->channel,IRQEN3,Si3226x_General_Configuration.irqen3);\n    WriteReg (pProHW,pProslic->channel,IRQEN4,Si3226x_General_Configuration.irqen4);\n    return 0;\n}", "item_id": 26, "repo": "zhoutao0712/rtn11pb1", "file": "release/src-ra-4300/linux/linux-2.6.36.x/drivers/char/pcm/proslic_api/src/si3226x_intf.c", "last_update_at": "2022-03-19T06:38:01+00:00", "question_id": "66060a326c76398976637abbff57c7fcc3be2a11_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int Si3226x_EnableInterrupts (proslicChanType_ptr pProslic){\n    WriteReg (pProHW,pProslic->channel,IRQEN1,Si3226x_General_Configuration.irqen1);\n    WriteReg (pProHW,pProslic->channel,IRQEN2,Si3226x_General_Configuration.irqen2);\n    WriteReg (pProHW,pProslic->channel,IRQEN3,Si3226x_General_Configuration.irqen3);\n    WriteReg (pProHW,pProslic->channel,IRQEN4,Si3226x_General_Configuration.irqen4);\n    return 0;\n"]]}
{"hexsha": "c65448eb3e839a5c6b0e612f182d0e1143e6e2e9", "ext": "c", "lang": "C", "content": "static PyObject *Qd_OpenPoly(PyObject *_self, PyObject *_args)\n{\n\tPyObject *_res = NULL;\n\tPolyHandle _rv;\n\tif (!PyArg_ParseTuple(_args, \"\"))\n\t\treturn NULL;\n\t_rv = OpenPoly();\n\t_res = Py_BuildValue(\"O&\",\n\t                     ResObj_New, _rv);\n\treturn _res;\n}", "item_id": 97, "repo": "SaadBazaz/ChinesePython", "file": "Mac/Modules/qd/Qdmodule.c", "last_update_at": "2022-02-12T08:51:12+00:00", "question_id": "c65448eb3e839a5c6b0e612f182d0e1143e6e2e9_97", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static PyObject *Qd_OpenPoly(PyObject *_self, PyObject *_args)\n{\n\tPyObject *_res = NULL;\n\tPolyHandle _rv;\n\tif (!PyArg_ParseTuple(_args, \"\"))\n\t\treturn NULL;\n\t_rv = OpenPoly();\n\t_res = Py_BuildValue(\"O&\",\n\t                     ResObj_New, _rv);\n\treturn _res;\n"]]}
{"hexsha": "581e6e55dc290f2fb40c38a484160f44a36c07c5", "ext": "h", "lang": "C", "content": "namespace PlayFab\n{\n    typedef std::shared_ptr<void> SharedVoidPointer;\n\n    struct HttpRequest // TODO: Rename to CallRequestContainer to match other sdks\n    {\n        HttpRequest(std::string method, std::string url);\n        ~HttpRequest();\n\n        void SetBody(std::string body);\n        void CompressBody(int level = -1);\n        int GetCompressionLevel() const;\n\n        void SetResultCallback(SharedVoidPointer callback);\n        SharedVoidPointer GetResultCallback() const;\n\n        void SetErrorCallback(ErrorCallback callback);\n        ErrorCallback GetErrorCallback() const;\n\n        void SetUserData(void* data);\n        void* GetUserData() const;\n\n        void AcceptGZip(bool accept = true);\n        bool GetAcceptGZip() const;\n\n        void SetHeader(std::string key, std::string value);\n        bool GetHeader(size_t index, std::string& header) const;\n        size_t GetHeaderCount() const;\n\n        void AppendToResponse(std::string text);\n        std::string GetReponse() const;\n\n        bool mAcceptGZip;\n        int mCompression;\n        std::string mUrl;\n        cocos2d::network::HttpRequest::Type mMethod;\n        std::string mBody;\n        std::vector<std::string> mHeaders;\n\n        SharedVoidPointer mResultCallbackFunc = nullptr;\n        ErrorCallback mErrorCallback;\n        void* mUserData;\n\n        std::string mResponse;\n    };\n\n}", "item_id": 0, "repo": "arturogutierrez/SDKGenerator", "file": "targets/cpp-cocos2dx/source/HttpRequest.h", "last_update_at": "2022-03-22T01:25:47+00:00", "question_id": "581e6e55dc290f2fb40c38a484160f44a36c07c5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace PlayFab\n{\n    typedef std::shared_ptr<void> SharedVoidPointer;\n    struct HttpRequest // TODO: Rename to CallRequestContainer to match other sdks\n    {\n        HttpRequest(std::string method, std::string url);\n        ~HttpRequest();\n        void SetBody(std::string body);\n        void CompressBody(int level = -1);\n        int GetCompressionLevel() const;\n        void SetResultCallback(SharedVoidPointer callback);\n        SharedVoidPointer GetResultCallback() const;\n        void SetErrorCallback(ErrorCallback callback);\n        ErrorCallback GetErrorCallback() const;\n        void SetUserData(void* data);\n        void* GetUserData() const;\n        void AcceptGZip(bool accept = true);\n        bool GetAcceptGZip() const;\n        void SetHeader(std::string key, std::string value);\n        bool GetHeader(size_t index, std::string& header) const;\n        size_t GetHeaderCount() const;\n        void AppendToResponse(std::string text);\n        std::string GetReponse() const;\n        bool mAcceptGZip;\n        int mCompression;\n        std::string mUrl;\n        cocos2d::network::HttpRequest::Type mMethod;\n        std::string mBody;\n        std::vector<std::string> mHeaders;\n        SharedVoidPointer mResultCallbackFunc = nullptr;\n        ErrorCallback mErrorCallback;\n        void* mUserData;\n        std::string mResponse;\n    };\n"]]}
{"hexsha": "9a4d1bcb881d26add58c98d1fb6be69723fcac74", "ext": "c", "lang": "C", "content": "static void _rtl92e_hw_sleep(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&priv->rf_ps_lock, flags);\n\tif (priv->RFChangeInProgress) {\n\t\tspin_unlock_irqrestore(&priv->rf_ps_lock, flags);\n\t\tRT_TRACE(COMP_DBG,\n\t\t\t \"_rtl92e_hw_sleep(): RF Change in progress!\\n\");\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&priv->rf_ps_lock, flags);\n\tRT_TRACE(COMP_DBG, \"%s()============>come to sleep down\\n\", __func__);\n\n\trtl92e_set_rf_state(dev, eRfSleep, RF_CHANGE_BY_PS);\n}", "item_id": 0, "repo": "mikedlowis-prototypes/albase", "file": "source/kernel/drivers/staging/rtl8192e/rtl8192e/rtl_ps.c", "last_update_at": "2022-02-07T15:58:16+00:00", "question_id": "9a4d1bcb881d26add58c98d1fb6be69723fcac74_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void _rtl92e_hw_sleep(struct net_device *dev)\n{\n\tstruct r8192_priv *priv = rtllib_priv(dev);\n\tunsigned long flags = 0;\n\tspin_lock_irqsave(&priv->rf_ps_lock, flags);\n\tif (priv->RFChangeInProgress) {\n\t\tspin_unlock_irqrestore(&priv->rf_ps_lock, flags);\n\t\tRT_TRACE(COMP_DBG,\n\t\t\t \"_rtl92e_hw_sleep(): RF Change in progress!\\n\");\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&priv->rf_ps_lock, flags);\n\tRT_TRACE(COMP_DBG, \"%s()============>come to sleep down\\n\", __func__);\n\trtl92e_set_rf_state(dev, eRfSleep, RF_CHANGE_BY_PS);\n"]]}
{"hexsha": "d270d42351e8ad95b2c520d8697dacdb30d633bc", "ext": "c", "lang": "C", "content": "static void copy_flags(BIO *bio)\n{\n    int flags;\n    BIO *next = BIO_next(bio);\n\n    flags = BIO_test_flags(next, BIO_FLAGS_SHOULD_RETRY | BIO_FLAGS_RWS);\n    BIO_clear_flags(bio, BIO_FLAGS_SHOULD_RETRY | BIO_FLAGS_RWS);\n    BIO_set_flags(bio, flags);\n}", "item_id": 0, "repo": "jhallf5/openssl", "file": "test/sslcorrupttest.c", "last_update_at": "2022-03-28T10:58:40+00:00", "question_id": "d270d42351e8ad95b2c520d8697dacdb30d633bc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void copy_flags(BIO *bio)\n{\n    int flags;\n    BIO *next = BIO_next(bio);\n    flags = BIO_test_flags(next, BIO_FLAGS_SHOULD_RETRY | BIO_FLAGS_RWS);\n    BIO_clear_flags(bio, BIO_FLAGS_SHOULD_RETRY | BIO_FLAGS_RWS);\n    BIO_set_flags(bio, flags);\n"]]}
{"hexsha": "8f8a74aa0650db15ac8a348b715127ca832c0e8e", "ext": "h", "lang": "C", "content": "char *get_file_content(const char *filename) {\n  char *buffer = NULL;\n  long length;\n\n  FILE *f = fopen(filename, \"rb\");\n  if (f) {\n    fseek(f, 0, SEEK_END);\n    length = ftell(f);\n    fseek(f, 0, SEEK_SET);\n    buffer = malloc(length + 1);\n    if (buffer) {\n      size_t n = fread(buffer, 1, length, f);\n      if (n != length) {\n        free(buffer);\n        return NULL;\n      }\n      buffer[length] = 0;\n    }\n    fclose(f);\n  }\n  return buffer;\n}", "item_id": 0, "repo": "victorhu3/webots", "file": "tests/lib/file_utils.h", "last_update_at": "2022-03-31T18:00:09+00:00", "question_id": "8f8a74aa0650db15ac8a348b715127ca832c0e8e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char *get_file_content(const char *filename) {\n  char *buffer = NULL;\n  long length;\n  FILE *f = fopen(filename, \"rb\");\n  if (f) {\n    fseek(f, 0, SEEK_END);\n    length = ftell(f);\n    fseek(f, 0, SEEK_SET);\n    buffer = malloc(length + 1);\n    if (buffer) {\n      size_t n = fread(buffer, 1, length, f);\n      if (n != length) {\n        free(buffer);\n        return NULL;\n      }\n      buffer[length] = 0;\n    }\n    fclose(f);\n  }\n  return buffer;\n"]]}
{"hexsha": "ec741a128f004dbcf676495fce59b2763366e11e", "ext": "c", "lang": "C", "content": "TEST test_zinterstore() {\n\trliteContext *context = rliteConnect(\":memory:\", 0);\n\n\trliteReply* reply;\n\tchar* argv[100] = {\"ZADD\", \"key1\", \"1\", \"one\", \"2\", \"two\", \"3\", \"three\", NULL};\n\tsize_t argvlen[100];\n\n\treply = rliteCommandArgv(context, populateArgvlen(argv, argvlen), argv, argvlen);\n\trliteFreeReplyObject(reply);\n\n\tchar *argv2[100] = {\"ZADD\", \"key2\", \"1\", \"one\", \"2\", \"two\", NULL};\n\treply = rliteCommandArgv(context, populateArgvlen(argv2, argvlen), argv2, argvlen);\n\trliteFreeReplyObject(reply);\n\n\tchar *argv3[100] = {\"ZINTERSTORE\", \"out\", \"2\", \"key1\", \"key2\", NULL};\n\treply = rliteCommandArgv(context, populateArgvlen(argv3, argvlen), argv3, argvlen);\n\tEXPECT_REPLY_INTEGER(reply, 2);\n\trliteFreeReplyObject(reply);\n\n\trliteFree(context);\n\tPASS();\n}", "item_id": 8, "repo": "luxaviar/rlite", "file": "tests/zset-test.c", "last_update_at": "2022-03-16T14:06:46+00:00", "question_id": "ec741a128f004dbcf676495fce59b2763366e11e_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TEST test_zinterstore() {\n\trliteContext *context = rliteConnect(\":memory:\", 0);\n\trliteReply* reply;\n\tchar* argv[100] = {\"ZADD\", \"key1\", \"1\", \"one\", \"2\", \"two\", \"3\", \"three\", NULL};\n\tsize_t argvlen[100];\n\treply = rliteCommandArgv(context, populateArgvlen(argv, argvlen), argv, argvlen);\n\trliteFreeReplyObject(reply);\n\tchar *argv2[100] = {\"ZADD\", \"key2\", \"1\", \"one\", \"2\", \"two\", NULL};\n\treply = rliteCommandArgv(context, populateArgvlen(argv2, argvlen), argv2, argvlen);\n\trliteFreeReplyObject(reply);\n\tchar *argv3[100] = {\"ZINTERSTORE\", \"out\", \"2\", \"key1\", \"key2\", NULL};\n\treply = rliteCommandArgv(context, populateArgvlen(argv3, argvlen), argv3, argvlen);\n\tEXPECT_REPLY_INTEGER(reply, 2);\n\trliteFreeReplyObject(reply);\n\trliteFree(context);\n\tPASS();\n"]]}
{"hexsha": "cef2866da875a5bf04d698ce39170adc335671de", "ext": "c", "lang": "C", "content": "struct obj *toheap_env(struct obj *env_obj, struct gc_context *ctx) {\n  struct env_obj *env = (struct env_obj *)env_obj;\n  struct env_obj *orig_env = env;\n\n  if (env->base.on_stack) {\n    TOUCH_OBJECT(env, \"toheap_env\");\n    struct env_obj *heap_env =\n        gc_malloc(sizeof(struct env_obj) + env->len * sizeof(struct obj *));\n\n    heap_env->base = env->base;\n    heap_env->len = env->len;\n    memset(&heap_env->env, 0, env->len * sizeof(struct obj *));\n    env = heap_env;\n  }\n\n  for (size_t i = 0; i < env->len; i++) {\n    struct obj *obj_ptr = orig_env->env[i];\n\n    if (!obj_ptr)\n      continue;\n\n    struct ptr_toupdate_pair p = {.toupdate = &env->env[i],\n                                  .on_stack = obj_ptr};\n    queue_ptr_toupdate_pair_enqueue(&ctx->pointers_toupdate, p);\n  }\n\n  return (struct obj *)env;\n}", "item_id": 4, "repo": "simmsb/some-scheme-compiler", "file": "src/core/gc.c", "last_update_at": "2022-01-04T01:09:47+00:00", "question_id": "cef2866da875a5bf04d698ce39170adc335671de_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct obj *toheap_env(struct obj *env_obj, struct gc_context *ctx) {\n  struct env_obj *env = (struct env_obj *)env_obj;\n  struct env_obj *orig_env = env;\n  if (env->base.on_stack) {\n    TOUCH_OBJECT(env, \"toheap_env\");\n    struct env_obj *heap_env =\n        gc_malloc(sizeof(struct env_obj) + env->len * sizeof(struct obj *));\n    heap_env->base = env->base;\n    heap_env->len = env->len;\n    memset(&heap_env->env, 0, env->len * sizeof(struct obj *));\n    env = heap_env;\n  }\n  for (size_t i = 0; i < env->len; i++) {\n    struct obj *obj_ptr = orig_env->env[i];\n    if (!obj_ptr)\n      continue;\n    struct ptr_toupdate_pair p = {.toupdate = &env->env[i],\n                                  .on_stack = obj_ptr};\n    queue_ptr_toupdate_pair_enqueue(&ctx->pointers_toupdate, p);\n  }\n  return (struct obj *)env;\n"]]}
{"hexsha": "134699eb794873fb79330a4c065ffab535eb07b7", "ext": "h", "lang": "C", "content": "class StageSetup : public QDialog\n{\n    Q_OBJECT\npublic:\n    explicit StageSetup(AppState *appState, QWidget *parent = 0);\n    virtual ~StageSetup();\n\n    virtual void keyPressEvent(QKeyEvent *e);\n\nsignals:\n\npublic slots:\n    virtual void accept();\n    virtual void reject();\n    void onInitialized();\n    void onFailed();\n    void onStageStarted();\n    void onStageFinished();\n    void onInitStageFinished();\n    void onGoToLimStageFinished();\n    void onGoToPosStageFinished();\n    void onCurrPosChanged(int pos);\n    void onLowerLimChanged(int lim);\n    void onUpperLimChanged(int lim);\n\nprivate slots:\n    void onInitButtonReleased();\n    void onStopButtonReleased();\n    void onInitComboboxCurrentIndexChanged(int index);\n    void onPosRefComboboxCurrentIndexChanged(int index);\n    void onGoUpLimButtonReleased();\n    void onGoLowLimButtonReleased();\n    void onMeasGoButtonReleased();\n    void onCalGoButtonReleased();\n\nprivate:\n    QPushButton *initButton;\n    QPushButton *goUpLimButton;\n    QPushButton *goLowLimButton;\n    QPushButton *stopButton;\n    QGroupBox *posGroupBox;\n    QComboBox *posRefComboBox;\n    QLabel *upperLimitLabel;\n    QLabel *lowerLimitLabel;\n    QLabel *currPosLabel;\n    QGroupBox *initGroupBox;\n    QComboBox *initComboBox;\n    QSpinBox *rangeSpinBox;\n    QGroupBox *measGroupBox;\n    QSpinBox *measPosSpinBox;\n    QComboBox *measRefComboBox;\n//    QComboBox *measInitComboBox;\n    QPushButton *measGoButton;\n    QGroupBox *calGroupBox;\n    QSpinBox *calPosSpinBox;\n    QComboBox *calRefComboBox;\n//    QComboBox *calInitComboBox;\n    QPushButton *calGoButton;\n    QDialogButtonBox *dialogButtonBox;\n\n    AppState *appState_;\n    StageControl *stageControl_;\n    StageControlTraits::Params *params_;\n    StageTasks::Initialize *initStage;\n    StageTasks::GoToLimWaitList *goToLimStage;\n    StageTasks::GoToPos *goToPosStage;\n\n    int absoluteLowerLim;\n    int absoluteUpperLim;\n    int absoluteCurrPos;\n}", "item_id": 1, "repo": "biomolecules/spexpert", "file": "src/biomolecules/spexpert/stagesetup.h", "last_update_at": "2022-01-14T17:58:56+00:00", "question_id": "134699eb794873fb79330a4c065ffab535eb07b7_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class StageSetup : public QDialog\n{\n    Q_OBJECT\npublic:\n    explicit StageSetup(AppState *appState, QWidget *parent = 0);\n    virtual ~StageSetup();\n    virtual void keyPressEvent(QKeyEvent *e);\nsignals:\npublic slots:\n    virtual void accept();\n    virtual void reject();\n    void onInitialized();\n    void onFailed();\n    void onStageStarted();\n    void onStageFinished();\n    void onInitStageFinished();\n    void onGoToLimStageFinished();\n    void onGoToPosStageFinished();\n    void onCurrPosChanged(int pos);\n    void onLowerLimChanged(int lim);\n    void onUpperLimChanged(int lim);\nprivate slots:\n    void onInitButtonReleased();\n    void onStopButtonReleased();\n    void onInitComboboxCurrentIndexChanged(int index);\n    void onPosRefComboboxCurrentIndexChanged(int index);\n    void onGoUpLimButtonReleased();\n    void onGoLowLimButtonReleased();\n    void onMeasGoButtonReleased();\n    void onCalGoButtonReleased();\nprivate:\n    QPushButton *initButton;\n    QPushButton *goUpLimButton;\n    QPushButton *goLowLimButton;\n    QPushButton *stopButton;\n    QGroupBox *posGroupBox;\n    QComboBox *posRefComboBox;\n    QLabel *upperLimitLabel;\n    QLabel *lowerLimitLabel;\n    QLabel *currPosLabel;\n    QGroupBox *initGroupBox;\n    QComboBox *initComboBox;\n    QSpinBox *rangeSpinBox;\n    QGroupBox *measGroupBox;\n    QSpinBox *measPosSpinBox;\n    QComboBox *measRefComboBox;\n//    QComboBox *measInitComboBox;\n    QPushButton *measGoButton;\n    QGroupBox *calGroupBox;\n    QSpinBox *calPosSpinBox;\n    QComboBox *calRefComboBox;\n//    QComboBox *calInitComboBox;\n    QPushButton *calGoButton;\n    QDialogButtonBox *dialogButtonBox;\n    AppState *appState_;\n    StageControl *stageControl_;\n    StageControlTraits::Params *params_;\n    StageTasks::Initialize *initStage;\n    StageTasks::GoToLimWaitList *goToLimStage;\n    StageTasks::GoToPos *goToPosStage;\n    int absoluteLowerLim;\n    int absoluteUpperLim;\n    int absoluteCurrPos;\n"]]}
{"hexsha": "0efa7dc6ffc67bb4ee0b8477bc744231299631b5", "ext": "c", "lang": "C", "content": "BOOL\tEdBBar_Init (void)\r\n{\r\n    char\tmyButtonBarWindowClassName [256];\r\n    char\tmyRaisedFrameWindowClassName [256];\r\n    int\t\tmyResult;\r\n    WNDCLASSEX\tmyWindowClass, myRaisedFrameClass;\r\n\r\n    // Get the background brush\r\n    stBackgroundBrush = GetSysColorBrush (COLOR_BTNFACE);\r\n    if (stBackgroundBrush == NULL)\t  \r\n    {\r\n    \tEdFail_Warn (IDS_CREATEBRUSHFAIL, __FILE__, __LINE__, GetLastError ());\r\n    \treturn FALSE;\r\n    }\r\n\r\n    stButtonFont = (HFONT) GetStockObject (DEFAULT_GUI_FONT);\r\n\r\n    // Get the class name\r\n    EdGUI_LoadString (IDS_BBAR_WINDOW_NAME, myButtonBarWindowClassName, \r\n\tsizeof (myButtonBarWindowClassName));\r\n\t\t     \r\n    //\r\n    // Register the status window class\r\n    //\r\n    myWindowClass.cbSize = \t  sizeof (myWindowClass);\r\n    // Set window class to redraw when window size changes\r\n    myWindowClass.style = \t  CS_HREDRAW | CS_VREDRAW;\r\n    // Procedure to be called with messages for this window class\r\n    myWindowClass.lpfnWndProc =   MyButtonBarWindowProcedure;\r\n    // The extra space in class struct\r\n    myWindowClass.cbClsExtra = \t  0;\r\n    // The extra space in window struct for the pointer to text data\r\n    // and editor window\r\n    myWindowClass.cbWndExtra = \t  WINDOW_EXTRA_MEMORY;\r\n    // The application's handle\r\n    myWindowClass.hInstance = \t  gProgram.applicationInstance;\r\n    // Set the icon for this window class\r\n    myWindowClass.hIcon = \t  NULL;\r\n    // Set the cursor for this window class\r\n    myWindowClass.hCursor = \t  LoadCursor (NULL, IDC_ARROW);\r\n    // Set the background colour for this window\r\n    myWindowClass.hbrBackground = stBackgroundBrush;\r\n    // Set the menu for this window class\r\n    myWindowClass.lpszMenuName =  NULL;\r\n    // Name of the window class\r\n    myWindowClass.lpszClassName = myButtonBarWindowClassName; \r\n    // Set the icon for this class.\r\n    myWindowClass.hIconSm = \t  NULL;\r\n    \r\n    myResult = RegisterClassEx (&myWindowClass);\r\n    if (myResult == 0)\r\n    {\r\n    \tEdFail_Warn (IDS_REGISTERCLASSFAIL, __FILE__, __LINE__, \r\n    \t\t\t  GetLastError ());\r\n    \treturn FALSE;\r\n    }\r\n    \r\n    // Get the class name\r\n    EdGUI_LoadString (IDS_RAISED_FRAME_WINDOW_NAME, myRaisedFrameWindowClassName, \r\n\tsizeof (myRaisedFrameWindowClassName));\r\n\t\t     \r\n    /************************************/\r\n    /* Register the raised window class */\r\n    /************************************/\r\n    myRaisedFrameClass.cbSize =        sizeof (myRaisedFrameClass);\r\n    // Set window class to redraw when window size changes\r\n    myRaisedFrameClass.style =\t       CS_HREDRAW | CS_VREDRAW;\r\n    // Procedure to be called with messages for this window class\r\n    myRaisedFrameClass.lpfnWndProc =   MyRaisedFrameWindowProcedure;\r\n    // The extra space in class struct\r\n    myRaisedFrameClass.cbClsExtra =    0;\r\n    // The extra space in window struct\r\n    myRaisedFrameClass.cbWndExtra =    0;\r\n    // The application's handle\r\n    myRaisedFrameClass.hInstance =     gProgram.applicationInstance;\r\n    // Set the icon for this window class\r\n    myRaisedFrameClass.hIcon =\t       NULL;\r\n    // Set the cursor for this window class\r\n    myRaisedFrameClass.hCursor =       LoadCursor (NULL, IDC_ARROW);\r\n    // Set the background colour for this window\r\n    myRaisedFrameClass.hbrBackground = stBackgroundBrush;\r\n    // Set the menu for this window class\r\n    myRaisedFrameClass.lpszMenuName =  NULL;\r\n    // Name of the window class\r\n    myRaisedFrameClass.lpszClassName = myRaisedFrameWindowClassName; \r\n    // Set the icon for this class.\r\n    myRaisedFrameClass.hIconSm =       NULL;\r\n    \r\n    myResult = RegisterClassEx (&myRaisedFrameClass);\r\n    if (myResult == 0)\r\n    {\r\n    \tEdFail_Warn (IDS_REGISTERCLASSFAIL, __FILE__, __LINE__, \r\n    \t\t\t  GetLastError ());\r\n    \treturn FALSE;\r\n    }\r\n\r\n    // Load the resource containing all the button positions    \r\n    if (!EdGUI_LoadResource (NULL, TOP_BUTTON_DATA, &stButtonBarData, \r\n    \t\t\t     sizeof (ButtonBarData)))\r\n    {\r\n    \treturn FALSE;\r\n    }    \t\t\t     \r\n    return TRUE;\r\n}", "item_id": 0, "repo": "ttracx/OpenTuring", "file": "ready/src/edbbar.c", "last_update_at": "2022-02-10T03:54:52+00:00", "question_id": "0efa7dc6ffc67bb4ee0b8477bc744231299631b5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["BOOL\tEdBBar_Init (void)\r\n{\r\n    char\tmyButtonBarWindowClassName [256];\r\n    char\tmyRaisedFrameWindowClassName [256];\r\n    int\t\tmyResult;\r\n    WNDCLASSEX\tmyWindowClass, myRaisedFrameClass;\r\n\r\n    // Get the background brush\r\n    stBackgroundBrush = GetSysColorBrush (COLOR_BTNFACE);\r\n    if (stBackgroundBrush == NULL)\t  \r\n    {\r\n    \tEdFail_Warn (IDS_CREATEBRUSHFAIL, __FILE__, __LINE__, GetLastError ());\r\n    \treturn FALSE;\r\n    }\r\n\r\n    stButtonFont = (HFONT) GetStockObject (DEFAULT_GUI_FONT);\r\n\r\n    // Get the class name\r\n    EdGUI_LoadString (IDS_BBAR_WINDOW_NAME, myButtonBarWindowClassName, \r\n\tsizeof (myButtonBarWindowClassName));\r\n\t\t     \r\n    //\r\n    // Register the status window class\r\n    //\r\n    myWindowClass.cbSize = \t  sizeof (myWindowClass);\r\n    // Set window class to redraw when window size changes\r\n    myWindowClass.style = \t  CS_HREDRAW | CS_VREDRAW;\r\n    // Procedure to be called with messages for this window class\r\n    myWindowClass.lpfnWndProc =   MyButtonBarWindowProcedure;\r\n    // The extra space in class struct\r\n    myWindowClass.cbClsExtra = \t  0;\r\n    // The extra space in window struct for the pointer to text data\r\n    // and editor window\r\n    myWindowClass.cbWndExtra = \t  WINDOW_EXTRA_MEMORY;\r\n    // The application's handle\r\n    myWindowClass.hInstance = \t  gProgram.applicationInstance;\r\n    // Set the icon for this window class\r\n    myWindowClass.hIcon = \t  NULL;\r\n    // Set the cursor for this window class\r\n    myWindowClass.hCursor = \t  LoadCursor (NULL, IDC_ARROW);\r\n    // Set the background colour for this window\r\n    myWindowClass.hbrBackground = stBackgroundBrush;\r\n    // Set the menu for this window class\r\n    myWindowClass.lpszMenuName =  NULL;\r\n    // Name of the window class\r\n    myWindowClass.lpszClassName = myButtonBarWindowClassName; \r\n    // Set the icon for this class.\r\n    myWindowClass.hIconSm = \t  NULL;\r\n    \r\n    myResult = RegisterClassEx (&myWindowClass);\r\n    if (myResult == 0)\r\n    {\r\n    \tEdFail_Warn (IDS_REGISTERCLASSFAIL, __FILE__, __LINE__, \r\n    \t\t\t  GetLastError ());\r\n    \treturn FALSE;\r\n    }\r\n    \r\n    // Get the class name\r\n    EdGUI_LoadString (IDS_RAISED_FRAME_WINDOW_NAME, myRaisedFrameWindowClassName, \r\n\tsizeof (myRaisedFrameWindowClassName));\r\n\t\t     \r\n    /************************************/\r\n    /* Register the raised window class */\r\n    /************************************/\r\n    myRaisedFrameClass.cbSize =        sizeof (myRaisedFrameClass);\r\n    // Set window class to redraw when window size changes\r\n    myRaisedFrameClass.style =\t       CS_HREDRAW | CS_VREDRAW;\r\n    // Procedure to be called with messages for this window class\r\n    myRaisedFrameClass.lpfnWndProc =   MyRaisedFrameWindowProcedure;\r\n    // The extra space in class struct\r\n    myRaisedFrameClass.cbClsExtra =    0;\r\n    // The extra space in window struct\r\n    myRaisedFrameClass.cbWndExtra =    0;\r\n    // The application's handle\r\n    myRaisedFrameClass.hInstance =     gProgram.applicationInstance;\r\n    // Set the icon for this window class\r\n    myRaisedFrameClass.hIcon =\t       NULL;\r\n    // Set the cursor for this window class\r\n    myRaisedFrameClass.hCursor =       LoadCursor (NULL, IDC_ARROW);\r\n    // Set the background colour for this window\r\n    myRaisedFrameClass.hbrBackground = stBackgroundBrush;\r\n    // Set the menu for this window class\r\n    myRaisedFrameClass.lpszMenuName =  NULL;\r\n    // Name of the window class\r\n    myRaisedFrameClass.lpszClassName = myRaisedFrameWindowClassName; \r\n    // Set the icon for this class.\r\n    myRaisedFrameClass.hIconSm =       NULL;\r\n    \r\n    myResult = RegisterClassEx (&myRaisedFrameClass);\r\n    if (myResult == 0)\r\n    {\r\n    \tEdFail_Warn (IDS_REGISTERCLASSFAIL, __FILE__, __LINE__, \r\n    \t\t\t  GetLastError ());\r\n    \treturn FALSE;\r\n    }\r\n\r\n    // Load the resource containing all the button positions    \r\n    if (!EdGUI_LoadResource (NULL, TOP_BUTTON_DATA, &stButtonBarData, \r\n    \t\t\t     sizeof (ButtonBarData)))\r\n    {\r\n    \treturn FALSE;\r\n    }    \t\t\t     \r\n    return TRUE;\r\n"]]}
{"hexsha": "1795741c4ba3d01d8a06ad719710ed61dc48da9c", "ext": "c", "lang": "C", "content": "OP(_051) { int tmp; H6280_CYCLES(7); RD_IDY; EOR;\t\t   }", "item_id": 14, "repo": "seleuco/MAME4droid_Native", "file": "src/emu/cpu/h6280/tblh6280.c", "last_update_at": "2022-03-22T04:44:14+00:00", "question_id": "1795741c4ba3d01d8a06ad719710ed61dc48da9c_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["OP(_051) { int tmp; H6280_CYCLES(7); RD_IDY; EOR;\t\t   }\n"]]}
{"hexsha": "9b42c8b80a5859ea887602c240a9824e10e40697", "ext": "h", "lang": "C", "content": "static inline unsigned int\nnum_online_cpus(void)\n{\n    long nprocs;\n\n    nprocs = sysconf(_SC_NPROCESSORS_ONLN);\n\n    assert(nprocs > 0);\n\n    return nprocs < 1 ? 1 : nprocs;\n}", "item_id": 2, "repo": "twblamer/hse", "file": "src/util/include/hse_util/timing.h", "last_update_at": "2022-03-20T11:47:02+00:00", "question_id": "9b42c8b80a5859ea887602c240a9824e10e40697_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline unsigned int\nnum_online_cpus(void)\n{\n    long nprocs;\n    nprocs = sysconf(_SC_NPROCESSORS_ONLN);\n    assert(nprocs > 0);\n    return nprocs < 1 ? 1 : nprocs;\n"]]}
{"hexsha": "b38756623040a50d9e62930dd540e36501b71d97", "ext": "c", "lang": "C", "content": "NTSTATUS KDispatchClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)\n{\n    Irp->IoStatus.Status = STATUS_SUCCESS;\n    Irp->IoStatus.Information=0;\n    IoCompleteRequest(Irp, IO_NO_INCREMENT);\n    return STATUS_SUCCESS;\n}", "item_id": 8, "repo": "redplait/libecc", "file": "src/drv/drv.c", "last_update_at": "2022-03-08T08:16:06+00:00", "question_id": "b38756623040a50d9e62930dd540e36501b71d97_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["NTSTATUS KDispatchClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)\n{\n    Irp->IoStatus.Status = STATUS_SUCCESS;\n    Irp->IoStatus.Information=0;\n    IoCompleteRequest(Irp, IO_NO_INCREMENT);\n    return STATUS_SUCCESS;\n"]]}
{"hexsha": "50f9220017eb2fbe308508f766a1f98da5c7c8c0", "ext": "c", "lang": "C", "content": "static int\nActivateOper(graphPtr, interp, argc, argv)\n    Graph *graphPtr;\t\t/* Graph widget */\n    Tcl_Interp *interp;\t\t/* Interpreter to report errors to */\n    int argc;\t\t\t/* Number of element names */\n    char **argv;\t\t/* List of element names */\n{\n    Element *elemPtr;\n    register int i;\n    int *activeArr;\n    int numActiveIndices;\n\n    if (Blt_GetElement(graphPtr, argv[3], &elemPtr) != TCL_OK) {\n\treturn TCL_ERROR;\t/* Can't find named element */\n    }\n    elemPtr->flags |= ELEM_ACTIVE;\n\n    activeArr = NULL;\n    numActiveIndices = -1;\n    if (argc > 4) {\n\tregister int *activePtr;\n\n\tnumActiveIndices = argc - 4;\n\tactiveArr = (int *)ckalloc(sizeof(int) * numActiveIndices);\n\tif (activeArr == NULL) {\n\t    Panic(\"can't allocate active element index array\");\n\t}\n\tactivePtr = activeArr;\n\tfor (i = 4; i < argc; i++) {\n\t    if (GetIndex(interp, elemPtr, argv[i], activePtr) != TCL_OK) {\n\t\treturn TCL_ERROR;\n\t    }\n\t    activePtr++;\n\t}\n    }\n    if (elemPtr->activeIndexArr != NULL) {\n\tckfree((char *)elemPtr->activeIndexArr);\n    }\n    elemPtr->numActiveIndices = numActiveIndices;\n    elemPtr->activeIndexArr = activeArr;\n    Blt_RedrawGraph(graphPtr);\n    return TCL_OK;\n}", "item_id": 18, "repo": "crazy-max/expect-nt", "file": "blt/generic/bltGrElem.c", "last_update_at": "2022-03-10T13:11:07+00:00", "question_id": "50f9220017eb2fbe308508f766a1f98da5c7c8c0_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nActivateOper(graphPtr, interp, argc, argv)\n    Graph *graphPtr;\t\t/* Graph widget */\n    Tcl_Interp *interp;\t\t/* Interpreter to report errors to */\n    int argc;\t\t\t/* Number of element names */\n    char **argv;\t\t/* List of element names */\n{\n    Element *elemPtr;\n    register int i;\n    int *activeArr;\n    int numActiveIndices;\n    if (Blt_GetElement(graphPtr, argv[3], &elemPtr) != TCL_OK) {\n\treturn TCL_ERROR;\t/* Can't find named element */\n    }\n    elemPtr->flags |= ELEM_ACTIVE;\n    activeArr = NULL;\n    numActiveIndices = -1;\n    if (argc > 4) {\n\tregister int *activePtr;\n\tnumActiveIndices = argc - 4;\n\tactiveArr = (int *)ckalloc(sizeof(int) * numActiveIndices);\n\tif (activeArr == NULL) {\n\t    Panic(\"can't allocate active element index array\");\n\t}\n\tactivePtr = activeArr;\n\tfor (i = 4; i < argc; i++) {\n\t    if (GetIndex(interp, elemPtr, argv[i], activePtr) != TCL_OK) {\n\t\treturn TCL_ERROR;\n\t    }\n\t    activePtr++;\n\t}\n    }\n    if (elemPtr->activeIndexArr != NULL) {\n\tckfree((char *)elemPtr->activeIndexArr);\n    }\n    elemPtr->numActiveIndices = numActiveIndices;\n    elemPtr->activeIndexArr = activeArr;\n    Blt_RedrawGraph(graphPtr);\n    return TCL_OK;\n"]]}
{"hexsha": "7000115bb64b2c3dd3a846d2d4ac6055d9dfab3d", "ext": "c", "lang": "C", "content": "void NOINLINE check_equal32(void *vgot, void *vexpected, void *vexpected_orig,\n                            int mask, char *banner) {\n  int i;\n  V512 *got = (V512 *)vgot;\n  V512 *expected = (V512 *)vexpected;\n  V512 *orig = (V512 *)vexpected_orig;\n\n  for (i = 0; i < 16; i++) {\n    int ans = (mask & (1 << i)) ? expected->u32[i] : orig->u32[i];\n    if (got->u32[i] != ans) {\n      printf(\"ERROR: %s failed -- 0x%0.8x != 0x%0.8x at element [%d]\\n\",\n             banner ? banner : \"\", got->u32[i], ans, i);\n      n_errs++;\n      break;\n    }\n  }\n}", "item_id": 1, "repo": "gmlueck/llvm-test-suite", "file": "SingleSource/UnitTests/Vector/AVX512F/movedup.c", "last_update_at": "2022-03-28T02:16:13+00:00", "question_id": "7000115bb64b2c3dd3a846d2d4ac6055d9dfab3d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void NOINLINE check_equal32(void *vgot, void *vexpected, void *vexpected_orig,\n                            int mask, char *banner) {\n  int i;\n  V512 *got = (V512 *)vgot;\n  V512 *expected = (V512 *)vexpected;\n  V512 *orig = (V512 *)vexpected_orig;\n  for (i = 0; i < 16; i++) {\n    int ans = (mask & (1 << i)) ? expected->u32[i] : orig->u32[i];\n    if (got->u32[i] != ans) {\n      printf(\"ERROR: %s failed -- 0x%0.8x != 0x%0.8x at element [%d]\\n\",\n             banner ? banner : \"\", got->u32[i], ans, i);\n      n_errs++;\n      break;\n    }\n  }\n"]]}
{"hexsha": "6502d56384e96c34deac300dc880a010a2a531d1", "ext": "c", "lang": "C", "content": "static void lst(void)\n{\n\t\tR.opcode.b.l &= 0xf7;\t\t/* Must ignore next ARP */\n\t\tGETDATA(0,0);\n\t\tR.ALU.w.l &= (~INTM_FLAG);\n\t\tR.STR0 &= INTM_FLAG;\n\t\tR.STR0 |= R.ALU.w.l;\t\t/* Must not affect INTM */\n\t\tR.STR0 |= 0x0400;\n}", "item_id": 23, "repo": "rsn8887/mame2003-plus-libretro", "file": "src/cpu/tms32025/tms32025.c", "last_update_at": "2022-03-27T17:39:03+00:00", "question_id": "6502d56384e96c34deac300dc880a010a2a531d1_23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void lst(void)\n{\n\t\tR.opcode.b.l &= 0xf7;\t\t/* Must ignore next ARP */\n\t\tGETDATA(0,0);\n\t\tR.ALU.w.l &= (~INTM_FLAG);\n\t\tR.STR0 &= INTM_FLAG;\n\t\tR.STR0 |= R.ALU.w.l;\t\t/* Must not affect INTM */\n\t\tR.STR0 |= 0x0400;\n"]]}
{"hexsha": "3c272f95a015c2d9d74989056af9a9921a492cc8", "ext": "c", "lang": "C", "content": "int main() {\n  char *buf = (char *)mmap(0, 100000, PROT_READ | PROT_WRITE,\n                           MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n  assert(buf);\n  munmap(buf, 100000);\n}", "item_id": 0, "repo": "medismailben/llvm-project", "file": "compiler-rt/test/sanitizer_common/TestCases/Posix/mmap_test.c", "last_update_at": "2022-03-31T11:00:37+00:00", "question_id": "3c272f95a015c2d9d74989056af9a9921a492cc8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main() {\n  char *buf = (char *)mmap(0, 100000, PROT_READ | PROT_WRITE,\n                           MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n  assert(buf);\n  munmap(buf, 100000);\n"]]}
{"hexsha": "6ceb4de1f0f85ce8f468f4fa0710ea0d26594591", "ext": "c", "lang": "C", "content": "void smk_hid_usb_init()\n{\n    usbd_hid_add_interface(&hid_class, &hid_intf_kb);\n    usbd_interface_add_endpoint(&hid_intf_kb, &hid_kb_in_ep);\n    usbd_hid_callback_register(hid_intf_kb.intf_num,keyboard_led_cb,NULL,kb_set_idle_callback,NULL,NULL,kb_set_protocol_callback,smk_reset_callback,smk_configured_callback);\n    usbd_hid_report_descriptor_register(hid_intf_kb.intf_num, hid_keyboard_report_desc, HID_KEYBOARD_REPORT_DESC_SIZE);\n\n    usbd_hid_add_interface(&hid_class, &hid_intf_data);\n    usbd_interface_add_endpoint(&hid_intf_data, &hid_data_in_ep);\n    usbd_interface_add_endpoint(&hid_intf_data, &hid_data_out_ep);\n    usbd_hid_report_descriptor_register(hid_intf_data.intf_num, hid_data_report_desc, HID_DATA_REPORT_DESC_SIZE);\n\n    usbd_hid_add_interface(&hid_class, &hid_intf_nkro);\n    usbd_interface_add_endpoint(&hid_intf_nkro, &hid_nkro_in_ep);\n    usbd_hid_callback_register(hid_intf_nkro.intf_num,keyboard_led_cb,NULL,nkro_set_idle_callback,NULL,NULL,kb_set_protocol_callback,smk_reset_callback,NULL);\n    usbd_hid_report_descriptor_register(hid_intf_nkro.intf_num, hid_nkro_report_desc, HID_NKRO_REPORT_DESC_SIZE);\n\n    hid_data_protocol_init();\n\n    // Set daemon task to handle keyscan periodically\n    hid_timer = xTimerCreate(\n            \"hid report timer\",                              // pcTimerName\n            pdMS_TO_TICKS(1), // xTimerPeriodInTicks\n            pdTRUE,                                             // uxAutoReload\n            xTaskGetCurrentTaskHandle(),                        // pvTimerID\n            smk_hidreport_update                          // pxCallbackFunction\n    );\n\n    // Start timer\n    xTimerStart(\n            hid_timer,       // xTimer\n            portMAX_DELAY // xTicksToWait\n    );\n\n}", "item_id": 8, "repo": "Neutree/sipeed_keyboard", "file": "firmware/keyboard/sipeed_keyboard_68/smk_hid.c", "last_update_at": "2022-03-27T14:58:48+00:00", "question_id": "6ceb4de1f0f85ce8f468f4fa0710ea0d26594591_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void smk_hid_usb_init()\n{\n    usbd_hid_add_interface(&hid_class, &hid_intf_kb);\n    usbd_interface_add_endpoint(&hid_intf_kb, &hid_kb_in_ep);\n    usbd_hid_callback_register(hid_intf_kb.intf_num,keyboard_led_cb,NULL,kb_set_idle_callback,NULL,NULL,kb_set_protocol_callback,smk_reset_callback,smk_configured_callback);\n    usbd_hid_report_descriptor_register(hid_intf_kb.intf_num, hid_keyboard_report_desc, HID_KEYBOARD_REPORT_DESC_SIZE);\n    usbd_hid_add_interface(&hid_class, &hid_intf_data);\n    usbd_interface_add_endpoint(&hid_intf_data, &hid_data_in_ep);\n    usbd_interface_add_endpoint(&hid_intf_data, &hid_data_out_ep);\n    usbd_hid_report_descriptor_register(hid_intf_data.intf_num, hid_data_report_desc, HID_DATA_REPORT_DESC_SIZE);\n    usbd_hid_add_interface(&hid_class, &hid_intf_nkro);\n    usbd_interface_add_endpoint(&hid_intf_nkro, &hid_nkro_in_ep);\n    usbd_hid_callback_register(hid_intf_nkro.intf_num,keyboard_led_cb,NULL,nkro_set_idle_callback,NULL,NULL,kb_set_protocol_callback,smk_reset_callback,NULL);\n    usbd_hid_report_descriptor_register(hid_intf_nkro.intf_num, hid_nkro_report_desc, HID_NKRO_REPORT_DESC_SIZE);\n    hid_data_protocol_init();\n    // Set daemon task to handle keyscan periodically\n    hid_timer = xTimerCreate(\n            \"hid report timer\",                              // pcTimerName\n            pdMS_TO_TICKS(1), // xTimerPeriodInTicks\n            pdTRUE,                                             // uxAutoReload\n            xTaskGetCurrentTaskHandle(),                        // pvTimerID\n            smk_hidreport_update                          // pxCallbackFunction\n    );\n    // Start timer\n    xTimerStart(\n            hid_timer,       // xTimer\n            portMAX_DELAY // xTicksToWait\n    );\n"]]}
{"hexsha": "d0391bcaed60a9de64d09807a1b66695f2155787", "ext": "c", "lang": "C", "content": "static void\n_HMAC_SHA256_Final(uint8_t digest[32], HMAC_SHA256_CTX * ctx,\n    uint32_t tmp32[static restrict 72], uint8_t ihash[static restrict 32])\n{\n\n\t/* Finish the inner SHA256 operation. */\n\t_SHA256_Final(ihash, &ctx->ictx, tmp32);\n\n\t/* Feed the inner hash to the outer SHA256 operation. */\n\t_SHA256_Update(&ctx->octx, ihash, 32, tmp32);\n\n\t/* Finish the outer SHA256 operation. */\n\t_SHA256_Final(digest, &ctx->octx, tmp32);\n}", "item_id": 11, "repo": "onehomedev/stratum-lowdiff", "file": "algos/yespower/yespower-combined.c", "last_update_at": "2022-03-22T01:33:32+00:00", "question_id": "d0391bcaed60a9de64d09807a1b66695f2155787_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\n_HMAC_SHA256_Final(uint8_t digest[32], HMAC_SHA256_CTX * ctx,\n    uint32_t tmp32[static restrict 72], uint8_t ihash[static restrict 32])\n{\n\t/* Finish the inner SHA256 operation. */\n\t_SHA256_Final(ihash, &ctx->ictx, tmp32);\n\t/* Feed the inner hash to the outer SHA256 operation. */\n\t_SHA256_Update(&ctx->octx, ihash, 32, tmp32);\n\t/* Finish the outer SHA256 operation. */\n\t_SHA256_Final(digest, &ctx->octx, tmp32);\n"]]}
{"hexsha": "32f4451880b461c14bfdd0bd03e5fe4706d48819", "ext": "h", "lang": "C", "content": "static inline uint16_t fp_fold(uint64_t sum64)\n{\n    uint32_t sum32;\n\n    /* now fold */\n    sum64 = (u32)sum64 + (sum64 >> 32); /* could have overflow on bit 32 */\n    sum32 = sum64 + (sum64 >> 32);    /* add the overflow */\n    sum32 = (u16)sum32 + (sum32 >> 16); /* could have overflow on bit 16 */\n    return ~((u16)sum32 + (u16)(sum32 >> 16)); /* add the overflow */\n}", "item_id": 4, "repo": "yonch/fastpass", "file": "src/protocol/platform/generic.h", "last_update_at": "2022-01-25T03:05:56+00:00", "question_id": "32f4451880b461c14bfdd0bd03e5fe4706d48819_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline uint16_t fp_fold(uint64_t sum64)\n{\n    uint32_t sum32;\n    /* now fold */\n    sum64 = (u32)sum64 + (sum64 >> 32); /* could have overflow on bit 32 */\n    sum32 = sum64 + (sum64 >> 32);    /* add the overflow */\n    sum32 = (u16)sum32 + (sum32 >> 16); /* could have overflow on bit 16 */\n    return ~((u16)sum32 + (u16)(sum32 >> 16)); /* add the overflow */\n"]]}
{"hexsha": "7f4241bfb9c437dcadf63f21913f803cccfdbae7", "ext": "c", "lang": "C", "content": "static int orc_reset_scsi_bus(ORC_HCS * pHCB)\n{\t\t\t\t/* I need Host Control Block Information */\n\tULONG flags;\n\n\tspin_lock_irqsave(&(pHCB->BitAllocFlagLock), flags);\n\n\tinitAFlag(pHCB);\n\t/* reset scsi bus */\n\tORC_WR(pHCB->HCS_Base + ORC_HCTRL, SCSIRST);\n\tif (waitSCSIRSTdone(pHCB) == 0) {\n\t\tspin_unlock_irqrestore(&(pHCB->BitAllocFlagLock), flags);\n\t\treturn FAILED;\n\t} else {\n\t\tspin_unlock_irqrestore(&(pHCB->BitAllocFlagLock), flags);\n\t\treturn SUCCESS;\n\t}\n}", "item_id": 14, "repo": "ghsecuritylab/tomato_egg", "file": "release/src-rt/linux/linux-2.6/drivers/scsi/a100u2w.c", "last_update_at": "2022-01-20T18:21:05+00:00", "question_id": "7f4241bfb9c437dcadf63f21913f803cccfdbae7_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int orc_reset_scsi_bus(ORC_HCS * pHCB)\n{\t\t\t\t/* I need Host Control Block Information */\n\tULONG flags;\n\tspin_lock_irqsave(&(pHCB->BitAllocFlagLock), flags);\n\tinitAFlag(pHCB);\n\t/* reset scsi bus */\n\tORC_WR(pHCB->HCS_Base + ORC_HCTRL, SCSIRST);\n\tif (waitSCSIRSTdone(pHCB) == 0) {\n\t\tspin_unlock_irqrestore(&(pHCB->BitAllocFlagLock), flags);\n\t\treturn FAILED;\n\t} else {\n\t\tspin_unlock_irqrestore(&(pHCB->BitAllocFlagLock), flags);\n\t\treturn SUCCESS;\n\t}\n"]]}
{"hexsha": "3b56106e0a9f0fcecbea7a4961f78254d35150b4", "ext": "h", "lang": "C", "content": "namespace Selas\n{\n    struct ImageBasedLightResourceData;\n    struct BuildProcessorContext;\n\n    //=============================================================================================================================\n    Error BakeImageBasedLight(BuildProcessorContext* context, ImageBasedLightResourceData* data);\n}", "item_id": 0, "repo": "schuttejoe/ShootyEngine", "file": "Source/Core/BuildCommon/BakeImageBasedLight.h", "last_update_at": "2022-03-03T09:24:22+00:00", "question_id": "3b56106e0a9f0fcecbea7a4961f78254d35150b4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace Selas\n{\n    struct ImageBasedLightResourceData;\n    struct BuildProcessorContext;\n    //=============================================================================================================================\n    Error BakeImageBasedLight(BuildProcessorContext* context, ImageBasedLightResourceData* data);\n"]]}
{"hexsha": "4edbeff7bbf46c6f8a91d4c37a6feba1a7d45a50", "ext": "c", "lang": "C", "content": "static float IO_FLOAT(void)\n{\n    union { float f; uint32 ui32; } cvt;\n    cvt.ui32 = readle32();\n    return cvt.f;\n}", "item_id": 3, "repo": "sulix/altrace", "file": "altrace_playback.c", "last_update_at": "2022-02-07T03:37:23+00:00", "question_id": "4edbeff7bbf46c6f8a91d4c37a6feba1a7d45a50_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static float IO_FLOAT(void)\n{\n    union { float f; uint32 ui32; } cvt;\n    cvt.ui32 = readle32();\n    return cvt.f;\n"]]}
{"hexsha": "4fa9bedd1bae9f48715ba2377a00f10e439cf58f", "ext": "h", "lang": "C", "content": "static inline void VP8YuvToRgba4444KeepA(uint8_t y, uint8_t u, uint8_t v,\n                                         uint8_t* const argb) {\n  const int r_off = VP8kVToR[v];\n  const int g_off = (VP8kVToG[v] + VP8kUToG[u]) >> YUV_FIX;\n  const int b_off = VP8kUToB[u];\n  // Don't update Aplha (last 4 bits of argb[1])\n  argb[0] = ((VP8kClip4Bits[y + r_off - YUV_RANGE_MIN] << 4) |\n             VP8kClip4Bits[y + g_off - YUV_RANGE_MIN]);\n  argb[1] = (argb[1] & 0x0f) | (VP8kClip4Bits[y + b_off - YUV_RANGE_MIN] << 4);\n}", "item_id": 2, "repo": "Scopetta197/chromium", "file": "third_party/libwebp/dsp/yuv.h", "last_update_at": "2022-02-22T06:35:11+00:00", "question_id": "4fa9bedd1bae9f48715ba2377a00f10e439cf58f_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void VP8YuvToRgba4444KeepA(uint8_t y, uint8_t u, uint8_t v,\n                                         uint8_t* const argb) {\n  const int r_off = VP8kVToR[v];\n  const int g_off = (VP8kVToG[v] + VP8kUToG[u]) >> YUV_FIX;\n  const int b_off = VP8kUToB[u];\n  // Don't update Aplha (last 4 bits of argb[1])\n  argb[0] = ((VP8kClip4Bits[y + r_off - YUV_RANGE_MIN] << 4) |\n             VP8kClip4Bits[y + g_off - YUV_RANGE_MIN]);\n  argb[1] = (argb[1] & 0x0f) | (VP8kClip4Bits[y + b_off - YUV_RANGE_MIN] << 4);\n"]]}
{"hexsha": "9e4408e16499f77245cc97e399f4522aeda068ad", "ext": "c", "lang": "C", "content": "static int _do_def_check(struct config_def_tree_spec *spec,\n\t\t\t struct dm_config_tree *cft,\n\t\t\t struct cft_check_handle **cft_check_handle)\n{\n\tstruct cft_check_handle *handle;\n\n\tif (!(handle = get_config_tree_check_handle(spec->cmd, cft)))\n\t\treturn 0;\n\n\thandle->force_check = 1;\n\thandle->suppress_messages = 1;\n\n\tif (spec->type == CFG_DEF_TREE_DIFF) {\n\t\tif (!handle->check_diff)\n\t\t\thandle->skip_if_checked = 0;\n\t\thandle->check_diff = 1;\n\t} else {\n\t\thandle->skip_if_checked = 1;\n\t\thandle->check_diff = 0;\n\t}\n\n\thandle->ignoreunsupported = spec->ignoreunsupported;\n\thandle->ignoreadvanced = spec->ignoreadvanced;\n\n\tconfig_def_check(handle);\n\t*cft_check_handle = handle;\n\n\treturn 1;\n}", "item_id": 1, "repo": "dawmlight/vendor_oh_fun", "file": "hihope_neptune-oh_hid/00_src/v0.1/third_party/LVM2/tools/dumpconfig.c", "last_update_at": "2022-02-15T08:51:55+00:00", "question_id": "9e4408e16499f77245cc97e399f4522aeda068ad_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int _do_def_check(struct config_def_tree_spec *spec,\n\t\t\t struct dm_config_tree *cft,\n\t\t\t struct cft_check_handle **cft_check_handle)\n{\n\tstruct cft_check_handle *handle;\n\tif (!(handle = get_config_tree_check_handle(spec->cmd, cft)))\n\t\treturn 0;\n\thandle->force_check = 1;\n\thandle->suppress_messages = 1;\n\tif (spec->type == CFG_DEF_TREE_DIFF) {\n\t\tif (!handle->check_diff)\n\t\t\thandle->skip_if_checked = 0;\n\t\thandle->check_diff = 1;\n\t} else {\n\t\thandle->skip_if_checked = 1;\n\t\thandle->check_diff = 0;\n\t}\n\thandle->ignoreunsupported = spec->ignoreunsupported;\n\thandle->ignoreadvanced = spec->ignoreadvanced;\n\tconfig_def_check(handle);\n\t*cft_check_handle = handle;\n\treturn 1;\n"]]}
{"hexsha": "afb95d67121a0995b2f7cd3ecf29df0d92f9d0e1", "ext": "c", "lang": "C", "content": "int EC_KEY_print(BIO *bp, const EC_KEY *x, int off)\n\t{\n\tunsigned char *buffer=NULL;\n\tsize_t\tbuf_len=0, i;\n\tint     ret=0, reason=ERR_R_BIO_LIB;\n\tBIGNUM  *pub_key=NULL, *order=NULL;\n\tBN_CTX  *ctx=NULL;\n\tconst EC_GROUP *group;\n\tconst EC_POINT *public_key;\n\tconst BIGNUM *priv_key;\n \n\tif (x == NULL || (group = EC_KEY_get0_group(x)) == NULL)\n\t\t{\n\t\treason = ERR_R_PASSED_NULL_PARAMETER;\n\t\tgoto err;\n\t\t}\n\n\tpublic_key = EC_KEY_get0_public_key(x);\n\tif ((pub_key = EC_POINT_point2bn(group, public_key,\n\t\tEC_KEY_get_conv_form(x), NULL, ctx)) == NULL)\n\t\t{\n\t\treason = ERR_R_EC_LIB;\n\t\tgoto err;\n\t\t}\n\n\tbuf_len = (size_t)BN_num_bytes(pub_key);\n\tpriv_key = EC_KEY_get0_private_key(x);\n\tif (priv_key != NULL)\n\t\t{\n\t\tif ((i = (size_t)BN_num_bytes(priv_key)) > buf_len)\n\t\t\tbuf_len = i;\n\t\t}\n\n\tbuf_len += 10;\n\tif ((buffer = OPENSSL_malloc(buf_len)) == NULL)\n\t\t{\n\t\treason = ERR_R_MALLOC_FAILURE;\n\t\tgoto err;\n\t\t}\n\n\tif (priv_key != NULL)\n\t\t{\n\t\tif (!BIO_indent(bp, off, 128))\n\t\t\tgoto err;\n\t\tif ((order = BN_new()) == NULL)\n\t\t\tgoto err;\n\t\tif (!EC_GROUP_get_order(group, order, NULL))\n\t\t\tgoto err;\n\t\tif (BIO_printf(bp, \"Private-Key: (%d bit)\\n\", \n\t\t\tBN_num_bits(order)) <= 0) goto err;\n\t\t}\n  \n\tif ((priv_key != NULL) && !print(bp, \"priv:\", priv_key, \n\t\tbuffer, off))\n\t\tgoto err;\n\tif ((pub_key != NULL) && !print(bp, \"pub: \", pub_key,\n\t\tbuffer, off))\n\t\tgoto err;\n\tif (!ECPKParameters_print(bp, group, off))\n\t\tgoto err;\n\tret=1;\nerr:\n\tif (!ret)\n \t\tECerr(EC_F_EC_KEY_PRINT, reason);\n\tif (pub_key) \n\t\tBN_free(pub_key);\n\tif (order)\n\t\tBN_free(order);\n\tif (ctx)\n\t\tBN_CTX_free(ctx);\n\tif (buffer != NULL)\n\t\tOPENSSL_free(buffer);\n\treturn(ret);\n\t}", "item_id": 7, "repo": "vlinhd11/vlinhd11-android-scripting", "file": "python-build/openssl/crypto/asn1/t_pkey.c", "last_update_at": "2022-03-29T09:45:43+00:00", "question_id": "afb95d67121a0995b2f7cd3ecf29df0d92f9d0e1_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int EC_KEY_print(BIO *bp, const EC_KEY *x, int off)\n\t{\n\tunsigned char *buffer=NULL;\n\tsize_t\tbuf_len=0, i;\n\tint     ret=0, reason=ERR_R_BIO_LIB;\n\tBIGNUM  *pub_key=NULL, *order=NULL;\n\tBN_CTX  *ctx=NULL;\n\tconst EC_GROUP *group;\n\tconst EC_POINT *public_key;\n\tconst BIGNUM *priv_key;\n\tif (x == NULL || (group = EC_KEY_get0_group(x)) == NULL)\n\t\t{\n\t\treason = ERR_R_PASSED_NULL_PARAMETER;\n\t\tgoto err;\n\t\t}\n\tpublic_key = EC_KEY_get0_public_key(x);\n\tif ((pub_key = EC_POINT_point2bn(group, public_key,\n\t\tEC_KEY_get_conv_form(x), NULL, ctx)) == NULL)\n\t\t{\n\t\treason = ERR_R_EC_LIB;\n\t\tgoto err;\n\t\t}\n\tbuf_len = (size_t)BN_num_bytes(pub_key);\n\tpriv_key = EC_KEY_get0_private_key(x);\n\tif (priv_key != NULL)\n\t\t{\n\t\tif ((i = (size_t)BN_num_bytes(priv_key)) > buf_len)\n\t\t\tbuf_len = i;\n\t\t}\n\tbuf_len += 10;\n\tif ((buffer = OPENSSL_malloc(buf_len)) == NULL)\n\t\t{\n\t\treason = ERR_R_MALLOC_FAILURE;\n\t\tgoto err;\n\t\t}\n\tif (priv_key != NULL)\n\t\t{\n\t\tif (!BIO_indent(bp, off, 128))\n\t\t\tgoto err;\n\t\tif ((order = BN_new()) == NULL)\n\t\t\tgoto err;\n\t\tif (!EC_GROUP_get_order(group, order, NULL))\n\t\t\tgoto err;\n\t\tif (BIO_printf(bp, \"Private-Key: (%d bit)\\n\", \n\t\t\tBN_num_bits(order)) <= 0) goto err;\n\t\t}\n\tif ((priv_key != NULL) && !print(bp, \"priv:\", priv_key, \n\t\tbuffer, off))\n\t\tgoto err;\n\tif ((pub_key != NULL) && !print(bp, \"pub: \", pub_key,\n\t\tbuffer, off))\n\t\tgoto err;\n\tif (!ECPKParameters_print(bp, group, off))\n\t\tgoto err;\n\tret=1;\nerr:\n\tif (!ret)\n \t\tECerr(EC_F_EC_KEY_PRINT, reason);\n\tif (pub_key) \n\t\tBN_free(pub_key);\n\tif (order)\n\t\tBN_free(order);\n\tif (ctx)\n\t\tBN_CTX_free(ctx);\n\tif (buffer != NULL)\n\t\tOPENSSL_free(buffer);\n\treturn(ret);\n"]]}
{"hexsha": "d59b4d153dd3a9335d2e865174ebfae325960992", "ext": "c", "lang": "C", "content": "decl *decl_impl(decl *const d, enum decl_impl_flags flags)\n{\n\tdecl *i;\n\n\tassert(type_is(d->ref, type_func));\n\n\tfor(i = d; i; i = i->proto)\n\t\tif(i->bits.func.code)\n\t\t\treturn i;\n\n\tfor(i = d; i; i = i->impl)\n\t\tif(i->bits.func.code)\n\t\t\treturn i;\n\n\tif(flags & DECL_INCLUDE_ALIAS){\n\t\tdecl *alias = decl_alias(d, d);\n\n\t\tif(type_is(alias->ref, type_func) && alias->bits.func.code)\n\t\t\treturn alias;\n\t}\n\n\treturn d;\n}", "item_id": 16, "repo": "bocke/ucc", "file": "src/cc1/decl.c", "last_update_at": "2022-02-19T15:25:02+00:00", "question_id": "d59b4d153dd3a9335d2e865174ebfae325960992_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["decl *decl_impl(decl *const d, enum decl_impl_flags flags)\n{\n\tdecl *i;\n\tassert(type_is(d->ref, type_func));\n\tfor(i = d; i; i = i->proto)\n\t\tif(i->bits.func.code)\n\t\t\treturn i;\n\tfor(i = d; i; i = i->impl)\n\t\tif(i->bits.func.code)\n\t\t\treturn i;\n\tif(flags & DECL_INCLUDE_ALIAS){\n\t\tdecl *alias = decl_alias(d, d);\n\t\tif(type_is(alias->ref, type_func) && alias->bits.func.code)\n\t\t\treturn alias;\n\t}\n\treturn d;\n"]]}
{"hexsha": "b8b6daf5a507656f03fb9c81ae80390d8cab8b5c", "ext": "h", "lang": "C", "content": "static inline char *strnWtoU( const WCHAR *str, DWORD in_len, DWORD *out_len )\n{\n    char *ret = NULL;\n    *out_len = 0;\n    if (str)\n    {\n        DWORD len = WideCharToMultiByte( CP_UTF8, 0, str, in_len, NULL, 0, NULL, NULL );\n        if ((ret = malloc( len + 1 )))\n        {\n            WideCharToMultiByte( CP_UTF8, 0, str, in_len, ret, len, NULL, NULL );\n            ret[len] = 0;\n            *out_len = len;\n        }\n    }\n    return ret;\n}", "item_id": 3, "repo": "Heersin/wine", "file": "dlls/wldap32/winldap_private.h", "last_update_at": "2022-03-31T18:52:48+00:00", "question_id": "b8b6daf5a507656f03fb9c81ae80390d8cab8b5c_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline char *strnWtoU( const WCHAR *str, DWORD in_len, DWORD *out_len )\n{\n    char *ret = NULL;\n    *out_len = 0;\n    if (str)\n    {\n        DWORD len = WideCharToMultiByte( CP_UTF8, 0, str, in_len, NULL, 0, NULL, NULL );\n        if ((ret = malloc( len + 1 )))\n        {\n            WideCharToMultiByte( CP_UTF8, 0, str, in_len, ret, len, NULL, NULL );\n            ret[len] = 0;\n            *out_len = len;\n        }\n    }\n    return ret;\n"]]}
{"hexsha": "fda5c8a68681f39acf5db19081a90755f94819ce", "ext": "c", "lang": "C", "content": "int32_t bt_host_store_link_key(struct bt_hci_evt_link_key_notify *link_key_notify) {\n    int32_t ret = -1;\n    uint32_t index = bt_host_link_keys.index;\n    for (uint32_t i = 0; i < ARRAY_SIZE(bt_host_link_keys.link_keys); i++) {\n        if (memcmp((void *)&link_key_notify->bdaddr, (void *)&bt_host_link_keys.link_keys[i].bdaddr, sizeof(link_key_notify->bdaddr)) == 0) {\n            index = i;\n        }\n    }\n    memcpy((void *)&bt_host_link_keys.link_keys[index], (void *)link_key_notify, sizeof(bt_host_link_keys.link_keys[0]));\n    if (index == bt_host_link_keys.index) {\n        bt_host_link_keys.index++;\n        bt_host_link_keys.index &= 0xF;\n    }\n    ret = bt_host_store_keys_on_file(&bt_host_link_keys);\n    return ret;\n}", "item_id": 13, "repo": "darthcloud/BlueRetro", "file": "main/bluetooth/host.c", "last_update_at": "2022-03-30T21:45:00+00:00", "question_id": "fda5c8a68681f39acf5db19081a90755f94819ce_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int32_t bt_host_store_link_key(struct bt_hci_evt_link_key_notify *link_key_notify) {\n    int32_t ret = -1;\n    uint32_t index = bt_host_link_keys.index;\n    for (uint32_t i = 0; i < ARRAY_SIZE(bt_host_link_keys.link_keys); i++) {\n        if (memcmp((void *)&link_key_notify->bdaddr, (void *)&bt_host_link_keys.link_keys[i].bdaddr, sizeof(link_key_notify->bdaddr)) == 0) {\n            index = i;\n        }\n    }\n    memcpy((void *)&bt_host_link_keys.link_keys[index], (void *)link_key_notify, sizeof(bt_host_link_keys.link_keys[0]));\n    if (index == bt_host_link_keys.index) {\n        bt_host_link_keys.index++;\n        bt_host_link_keys.index &= 0xF;\n    }\n    ret = bt_host_store_keys_on_file(&bt_host_link_keys);\n    return ret;\n"]]}
{"hexsha": "9d09e9fd8e182edece0445d7c990b708588ae400", "ext": "c", "lang": "C", "content": "void CARDvUpdateBasicTopRate(void *pDeviceHandler)\n{\nPSDevice    pDevice = (PSDevice) pDeviceHandler;\nBYTE byTopOFDM = RATE_24M, byTopCCK = RATE_1M;\nBYTE ii;\n\n     //Determines the highest basic rate.\n     for (ii = RATE_54M; ii >= RATE_6M; ii --) {\n         if ( (pDevice->wBasicRate) & ((WORD)(1<<ii)) ) {\n             byTopOFDM = ii;\n             break;\n         }\n     }\n     pDevice->byTopOFDMBasicRate = byTopOFDM;\n\n     for (ii = RATE_11M;; ii --) {\n         if ( (pDevice->wBasicRate) & ((WORD)(1<<ii)) ) {\n             byTopCCK = ii;\n             break;\n         }\n         if (ii == RATE_1M)\n            break;\n     }\n     pDevice->byTopCCKBasicRate = byTopCCK;\n }", "item_id": 5, "repo": "usenixatc2021/SoftRefresh_Scheduling", "file": "linsched-linsched-alpha/drivers/staging/vt6656/card.c", "last_update_at": "2022-02-17T01:04:14+00:00", "question_id": "9d09e9fd8e182edece0445d7c990b708588ae400_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void CARDvUpdateBasicTopRate(void *pDeviceHandler)\n{\nPSDevice    pDevice = (PSDevice) pDeviceHandler;\nBYTE byTopOFDM = RATE_24M, byTopCCK = RATE_1M;\nBYTE ii;\n     //Determines the highest basic rate.\n     for (ii = RATE_54M; ii >= RATE_6M; ii --) {\n         if ( (pDevice->wBasicRate) & ((WORD)(1<<ii)) ) {\n             byTopOFDM = ii;\n             break;\n         }\n     }\n     pDevice->byTopOFDMBasicRate = byTopOFDM;\n     for (ii = RATE_11M;; ii --) {\n         if ( (pDevice->wBasicRate) & ((WORD)(1<<ii)) ) {\n             byTopCCK = ii;\n             break;\n         }\n         if (ii == RATE_1M)\n            break;\n     }\n     pDevice->byTopCCKBasicRate = byTopCCK;\n"]]}
{"hexsha": "ee8117fa968bfd16fe38d3e960abb33dd73bef0b", "ext": "h", "lang": "C", "content": "extern inline int\n__gai_create_helper_thread (pthread_t *threadp, void *(*tf) (void *),\n\t\t\t    void *arg)\n{\n  pthread_attr_t attr;\n\n  /* Make sure the thread is created detached.  */\n  pthread_attr_init (&attr);\n  pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);\n\n  /* The helper thread needs only very little resources.  */\n  (void) pthread_attr_setstacksize (&attr, 0x10000);\n\n  /* Block all signals in the helper thread.  To do this thoroughly we\n     temporarily have to block all signals here.  */\n  sigset_t ss;\n  sigset_t oss;\n  sigfillset (&ss);\n  sigprocmask(SIG_SETMASK, &ss, &oss);\n\n  int ret = pthread_create (threadp, &attr, tf, arg);\n\n  /* Restore the signal mask.  */\n  sigprocmask(SIG_SETMASK, &oss, NULL);\n\n  (void) pthread_attr_destroy (&attr);\n  return ret;\n}", "item_id": 1, "repo": "wwkenwong/piecewise", "file": "src/glibc-2.23/sysdeps/mach/hurd/gai_misc.h", "last_update_at": "2022-01-18T15:31:41+00:00", "question_id": "ee8117fa968bfd16fe38d3e960abb33dd73bef0b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["extern inline int\n__gai_create_helper_thread (pthread_t *threadp, void *(*tf) (void *),\n\t\t\t    void *arg)\n{\n  pthread_attr_t attr;\n  /* Make sure the thread is created detached.  */\n  pthread_attr_init (&attr);\n  pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);\n  /* The helper thread needs only very little resources.  */\n  (void) pthread_attr_setstacksize (&attr, 0x10000);\n  /* Block all signals in the helper thread.  To do this thoroughly we\n     temporarily have to block all signals here.  */\n  sigset_t ss;\n  sigset_t oss;\n  sigfillset (&ss);\n  sigprocmask(SIG_SETMASK, &ss, &oss);\n  int ret = pthread_create (threadp, &attr, tf, arg);\n  /* Restore the signal mask.  */\n  sigprocmask(SIG_SETMASK, &oss, NULL);\n  (void) pthread_attr_destroy (&attr);\n  return ret;\n"]]}
{"hexsha": "fcf03d927f96bb5de77dbb55fe5c0257bf532a7a", "ext": "c", "lang": "C", "content": "DCulonglong dcbArgULongLong(DCArgs* p)\n{\n  DCulonglong value;\n  p->reg_count.i += (p->reg_count.i & 1);         /* Skip one reg if not aligned. */\n  p->stackptr += ((DCulong)p->stackptr & 4) & -4; /* 64bit values are also always aligned on stack */\n#if defined(DC__Endian_LITTLE)\n  value  = dcbArgUInt(p);\n  value |= ((DCulonglong)dcbArgUInt(p)) << 32;\n#else\n  value  = ((DCulonglong)dcbArgUInt(p)) << 32;\n  value |= dcbArgUInt(p);\n#endif\n  return value;\n}", "item_id": 1, "repo": "can1357/sbffi", "file": "deps/dyncall/dyncallback/dyncall_args_mips.c", "last_update_at": "2022-01-25T12:37:24+00:00", "question_id": "fcf03d927f96bb5de77dbb55fe5c0257bf532a7a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["DCulonglong dcbArgULongLong(DCArgs* p)\n{\n  DCulonglong value;\n  p->reg_count.i += (p->reg_count.i & 1);         /* Skip one reg if not aligned. */\n  p->stackptr += ((DCulong)p->stackptr & 4) & -4; /* 64bit values are also always aligned on stack */\n#if defined(DC__Endian_LITTLE)\n  value  = dcbArgUInt(p);\n  value |= ((DCulonglong)dcbArgUInt(p)) << 32;\n#else\n  value  = ((DCulonglong)dcbArgUInt(p)) << 32;\n  value |= dcbArgUInt(p);\n#endif\n  return value;\n"]]}
{"hexsha": "05a5eedb8f3bf62ab891fb060945ca66f61499d1", "ext": "c", "lang": "C", "content": "uint64_t rdtsc() {\n  uint64_t a, d;\n  asm volatile(\"mfence\");\n#if USE_RDTSCP\n  asm volatile(\"rdtscp\" : \"=a\"(a), \"=d\"(d) :: \"rcx\");\n#else\n  asm volatile(\"rdtsc\" : \"=a\"(a), \"=d\"(d));\n#endif\n  a = (d << 32) | a;\n  asm volatile(\"mfence\");\n  return a;\n}", "item_id": 1, "repo": "pietroborrello/constantine", "file": "src/lib/dfl/tests/test.c", "last_update_at": "2022-03-24T20:11:10+00:00", "question_id": "05a5eedb8f3bf62ab891fb060945ca66f61499d1_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint64_t rdtsc() {\n  uint64_t a, d;\n  asm volatile(\"mfence\");\n#if USE_RDTSCP\n  asm volatile(\"rdtscp\" : \"=a\"(a), \"=d\"(d) :: \"rcx\");\n#else\n  asm volatile(\"rdtsc\" : \"=a\"(a), \"=d\"(d));\n#endif\n  a = (d << 32) | a;\n  asm volatile(\"mfence\");\n  return a;\n"]]}
{"hexsha": "d22f4d10413fece73cd4bf5f0427e6ac34eac4e8", "ext": "c", "lang": "C", "content": "static int tegra_spi_start_dma_based_transfer(\n\t\tstruct tegra_spi_data *tspi, struct spi_transfer *t)\n{\n\tu32 val;\n\tunsigned int len;\n\tint ret = 0;\n\tu8 dma_burst;\n\tstruct dma_slave_config dma_sconfig = {0};\n\n\tval = SPI_DMA_BLK_SET(tspi->curr_dma_words - 1);\n\ttegra_spi_writel(tspi, val, SPI_DMA_BLK);\n\n\tif (tspi->is_packed)\n\t\tlen = DIV_ROUND_UP(tspi->curr_dma_words * tspi->bytes_per_word,\n\t\t\t\t\t4) * 4;\n\telse\n\t\tlen = tspi->curr_dma_words * 4;\n\n\t/* Set attention level based on length of transfer */\n\tif (len & 0xF) {\n\t\tval |= SPI_TX_TRIG_1 | SPI_RX_TRIG_1;\n\t\tdma_burst = 1;\n\t} else if (((len) >> 4) & 0x1) {\n\t\tval |= SPI_TX_TRIG_4 | SPI_RX_TRIG_4;\n\t\tdma_burst = 4;\n\t} else {\n\t\tval |= SPI_TX_TRIG_8 | SPI_RX_TRIG_8;\n\t\tdma_burst = 8;\n\t}\n\n\tif (!tspi->soc_data->has_intr_mask_reg) {\n\t\tif (tspi->cur_direction & DATA_DIR_TX)\n\t\t\tval |= SPI_IE_TX;\n\n\t\tif (tspi->cur_direction & DATA_DIR_RX)\n\t\t\tval |= SPI_IE_RX;\n\t}\n\n\ttegra_spi_writel(tspi, val, SPI_DMA_CTL);\n\ttspi->dma_control_reg = val;\n\n\tdma_sconfig.device_fc = true;\n\tif (tspi->cur_direction & DATA_DIR_TX) {\n\t\tdma_sconfig.dst_addr = tspi->phys + SPI_TX_FIFO;\n\t\tdma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tdma_sconfig.dst_maxburst = dma_burst;\n\t\tret = dmaengine_slave_config(tspi->tx_dma_chan, &dma_sconfig);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tspi->dev,\n\t\t\t\t\"DMA slave config failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\ttegra_spi_copy_client_txbuf_to_spi_txbuf(tspi, t);\n\t\tret = tegra_spi_start_tx_dma(tspi, len);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tspi->dev,\n\t\t\t\t\"Starting tx dma failed, err %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (tspi->cur_direction & DATA_DIR_RX) {\n\t\tdma_sconfig.src_addr = tspi->phys + SPI_RX_FIFO;\n\t\tdma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tdma_sconfig.src_maxburst = dma_burst;\n\t\tret = dmaengine_slave_config(tspi->rx_dma_chan, &dma_sconfig);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tspi->dev,\n\t\t\t\t\"DMA slave config failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* Make the dma buffer to read by dma */\n\t\tdma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,\n\t\t\t\ttspi->dma_buf_size, DMA_FROM_DEVICE);\n\n\t\tret = tegra_spi_start_rx_dma(tspi, len);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tspi->dev,\n\t\t\t\t\"Starting rx dma failed, err %d\\n\", ret);\n\t\t\tif (tspi->cur_direction & DATA_DIR_TX)\n\t\t\t\tdmaengine_terminate_all(tspi->tx_dma_chan);\n\t\t\treturn ret;\n\t\t}\n\t}\n\ttspi->is_curr_dma_xfer = true;\n\ttspi->dma_control_reg = val;\n\n\tval |= SPI_DMA_EN;\n\ttegra_spi_writel(tspi, val, SPI_DMA_CTL);\n\treturn ret;\n}", "item_id": 10, "repo": "TakuKitamura/expirefile-syscall", "file": "linux-5.2/drivers/spi/spi-tegra114.c", "last_update_at": "2022-01-30T20:01:25+00:00", "question_id": "d22f4d10413fece73cd4bf5f0427e6ac34eac4e8_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int tegra_spi_start_dma_based_transfer(\n\t\tstruct tegra_spi_data *tspi, struct spi_transfer *t)\n{\n\tu32 val;\n\tunsigned int len;\n\tint ret = 0;\n\tu8 dma_burst;\n\tstruct dma_slave_config dma_sconfig = {0};\n\tval = SPI_DMA_BLK_SET(tspi->curr_dma_words - 1);\n\ttegra_spi_writel(tspi, val, SPI_DMA_BLK);\n\tif (tspi->is_packed)\n\t\tlen = DIV_ROUND_UP(tspi->curr_dma_words * tspi->bytes_per_word,\n\t\t\t\t\t4) * 4;\n\telse\n\t\tlen = tspi->curr_dma_words * 4;\n\t/* Set attention level based on length of transfer */\n\tif (len & 0xF) {\n\t\tval |= SPI_TX_TRIG_1 | SPI_RX_TRIG_1;\n\t\tdma_burst = 1;\n\t} else if (((len) >> 4) & 0x1) {\n\t\tval |= SPI_TX_TRIG_4 | SPI_RX_TRIG_4;\n\t\tdma_burst = 4;\n\t} else {\n\t\tval |= SPI_TX_TRIG_8 | SPI_RX_TRIG_8;\n\t\tdma_burst = 8;\n\t}\n\tif (!tspi->soc_data->has_intr_mask_reg) {\n\t\tif (tspi->cur_direction & DATA_DIR_TX)\n\t\t\tval |= SPI_IE_TX;\n\t\tif (tspi->cur_direction & DATA_DIR_RX)\n\t\t\tval |= SPI_IE_RX;\n\t}\n\ttegra_spi_writel(tspi, val, SPI_DMA_CTL);\n\ttspi->dma_control_reg = val;\n\tdma_sconfig.device_fc = true;\n\tif (tspi->cur_direction & DATA_DIR_TX) {\n\t\tdma_sconfig.dst_addr = tspi->phys + SPI_TX_FIFO;\n\t\tdma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tdma_sconfig.dst_maxburst = dma_burst;\n\t\tret = dmaengine_slave_config(tspi->tx_dma_chan, &dma_sconfig);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tspi->dev,\n\t\t\t\t\"DMA slave config failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\ttegra_spi_copy_client_txbuf_to_spi_txbuf(tspi, t);\n\t\tret = tegra_spi_start_tx_dma(tspi, len);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tspi->dev,\n\t\t\t\t\"Starting tx dma failed, err %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (tspi->cur_direction & DATA_DIR_RX) {\n\t\tdma_sconfig.src_addr = tspi->phys + SPI_RX_FIFO;\n\t\tdma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tdma_sconfig.src_maxburst = dma_burst;\n\t\tret = dmaengine_slave_config(tspi->rx_dma_chan, &dma_sconfig);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tspi->dev,\n\t\t\t\t\"DMA slave config failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\t/* Make the dma buffer to read by dma */\n\t\tdma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,\n\t\t\t\ttspi->dma_buf_size, DMA_FROM_DEVICE);\n\t\tret = tegra_spi_start_rx_dma(tspi, len);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tspi->dev,\n\t\t\t\t\"Starting rx dma failed, err %d\\n\", ret);\n\t\t\tif (tspi->cur_direction & DATA_DIR_TX)\n\t\t\t\tdmaengine_terminate_all(tspi->tx_dma_chan);\n\t\t\treturn ret;\n\t\t}\n\t}\n\ttspi->is_curr_dma_xfer = true;\n\ttspi->dma_control_reg = val;\n\tval |= SPI_DMA_EN;\n\ttegra_spi_writel(tspi, val, SPI_DMA_CTL);\n\treturn ret;\n"]]}
{"hexsha": "8683f853c4e1ce2ed06aea4dd74aab3e46a52a68", "ext": "c", "lang": "C", "content": "void loopFrontEnd(void)\n{\n  loopVolumeSource();                 //Check if volume source(SD/U disk) insert\n\n  loopToast();\n\n  loopReminderClear();                //If there is a message in the status bar, timed clear\n\n  loopVolumeReminderClear();\n\n  loopBusySignClear();                //Busy Indicator clear\n\n  loopTemperatureStatus();\n\n#ifdef FIL_RUNOUT_PIN\n  loopFrontEndFILRunoutDetect();\n#endif\n\n  loopPopup();\n}", "item_id": 18, "repo": "Ejay-3D/Marlin-Biqu", "file": "Marlin-BIQUBX_ALMOST_STOCK/Marlin/src/lcd/extui/lib/btt_ui/API/menu.c", "last_update_at": "2022-02-02T20:49:45+00:00", "question_id": "8683f853c4e1ce2ed06aea4dd74aab3e46a52a68_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void loopFrontEnd(void)\n{\n  loopVolumeSource();                 //Check if volume source(SD/U disk) insert\n  loopToast();\n  loopReminderClear();                //If there is a message in the status bar, timed clear\n  loopVolumeReminderClear();\n  loopBusySignClear();                //Busy Indicator clear\n  loopTemperatureStatus();\n#ifdef FIL_RUNOUT_PIN\n  loopFrontEndFILRunoutDetect();\n#endif\n  loopPopup();\n"]]}
{"hexsha": "89c63dbc75c5371dfc23a384a317e06219cf2614", "ext": "c", "lang": "C", "content": "FBCALL FBTHREAD *fb_ThreadCreate( FB_THREADPROC proc, void *param, ssize_t stack_size )\n{\n\tNTSTATUS status;\n\tFBTHREAD *thread;\n\tFBTHREADINFO *info;\n\n\tthread = (FBTHREAD *)malloc( sizeof( FBTHREAD ) );\n\tif( thread == NULL ) {\n\t\treturn NULL;\n\t}\n\n\tinfo = (FBTHREADINFO *)malloc( sizeof( FBTHREADINFO ) );\n\tif( info == NULL ) {\n\t\tfree( thread );\n\t\treturn NULL;\n\t}\n\n\tinfo->proc = proc;\n\tinfo->param = param;\n\tinfo->thread = thread;\n\tthread->flags = 0;\n\n\tstatus = PsCreateSystemThreadEx( &thread->id, /* ThreadHandle */\n\t                                 0,           /* ThreadExtraSize */\n\t                                 /* stack_size??? */ 65536,       /* KernelStackSize */\n\t                                 0,           /* TlsDataSize */\n\t                                 NULL,        /* ThreadId */\n\t                                 info,        /* StartContext1 */\n\t                                 NULL,        /* StartContext2 */\n\t                                 FALSE,       /* CreateSuspended */\n\t                                 FALSE,       /* DebugStack */\n\t                                 threadproc); /* StartRoutine */\n\n\tif( status != STATUS_SUCCESS ) {\n\t\tfree( thread );\n\t\tfree( info );\n\t\treturn NULL;\n\t}\n\n\treturn thread;\n}", "item_id": 1, "repo": "tajmone/fbc", "file": "src/rtlib/xbox/thread_core.c", "last_update_at": "2022-03-24T19:13:18+00:00", "question_id": "89c63dbc75c5371dfc23a384a317e06219cf2614_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["FBCALL FBTHREAD *fb_ThreadCreate( FB_THREADPROC proc, void *param, ssize_t stack_size )\n{\n\tNTSTATUS status;\n\tFBTHREAD *thread;\n\tFBTHREADINFO *info;\n\tthread = (FBTHREAD *)malloc( sizeof( FBTHREAD ) );\n\tif( thread == NULL ) {\n\t\treturn NULL;\n\t}\n\tinfo = (FBTHREADINFO *)malloc( sizeof( FBTHREADINFO ) );\n\tif( info == NULL ) {\n\t\tfree( thread );\n\t\treturn NULL;\n\t}\n\tinfo->proc = proc;\n\tinfo->param = param;\n\tinfo->thread = thread;\n\tthread->flags = 0;\n\tstatus = PsCreateSystemThreadEx( &thread->id, /* ThreadHandle */\n\t                                 0,           /* ThreadExtraSize */\n\t                                 /* stack_size??? */ 65536,       /* KernelStackSize */\n\t                                 0,           /* TlsDataSize */\n\t                                 NULL,        /* ThreadId */\n\t                                 info,        /* StartContext1 */\n\t                                 NULL,        /* StartContext2 */\n\t                                 FALSE,       /* CreateSuspended */\n\t                                 FALSE,       /* DebugStack */\n\t                                 threadproc); /* StartRoutine */\n\tif( status != STATUS_SUCCESS ) {\n\t\tfree( thread );\n\t\tfree( info );\n\t\treturn NULL;\n\t}\n\treturn thread;\n"]]}
{"hexsha": "c5cb490c535d78eae6648fb330a59363f2a052ed", "ext": "c", "lang": "C", "content": "static int64_t  func_28(int32_t  p_29, int64_t  p_30, int8_t  p_31, uint16_t  p_32)\n{ \n    int64_t l_256 = 0x6E68338B46DE65A4LL;\n    int32_t l_270 = 3L;\n    int8_t l_275 = 0L;\n    for (g_233 = 0; (g_233 <= 2); g_233 += 1)\n    { \n        int32_t l_255 = (-7L);\n        int32_t l_269[1];\n        int i;\n        for (i = 0; i < 1; i++)\n            l_269[i] = 0x4A06BE4AL;\n        p_29 = (safe_div_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u((safe_sub_func_int64_t_s_s(0x6587CEBA9940DB3FLL, ((safe_div_func_int16_t_s_s(0x7F1AL, 65529UL)) >= 0x7BL))), 7)), 0x5A23L));\n        l_255 = g_236[g_233];\n        if (g_236[0])\n            continue;\n        l_256 = (-1L);\n        g_65 = p_29;\n        l_270 = (safe_sub_func_int32_t_s_s((~(0xE7B200155B8B4CAALL <= 4L)), ((((p_30 = (~((safe_div_func_int64_t_s_s(((safe_add_func_uint32_t_u_u((safe_lshift_func_int16_t_s_s((l_255 = (safe_mul_func_uint8_t_u_u(0x37L, 0x2EL))), 8)), g_119[1])) , l_256), g_141[2])) >= 0x4AD5A420L))) == l_256) & 0x57C4L) || l_269[0])));\n    }\n    for (g_234 = 2; (g_234 >= 0); g_234 -= 1)\n    { \n        uint64_t l_272 = 0UL;\n        int32_t l_276 = 1L;\n        int32_t l_277 = 0xEFA478FCL;\n        ++l_272;\n        g_278--;\n        l_276 ^= g_231;\n        g_63 = (g_66 > (safe_mod_func_int16_t_s_s(((safe_rshift_func_uint8_t_u_u((l_272 ^ (safe_rshift_func_uint16_t_u_s(p_30, 14))), g_77)) , 0x9ED6L), p_30)));\n        if (l_276)\n            break;\n        return l_270;\n    }\n    return p_32;\n}", "item_id": 4, "repo": "talsewell/cerberus", "file": "tests/csmith/small_arrays/csmith_214.c", "last_update_at": "2022-01-28T04:28:00+00:00", "question_id": "c5cb490c535d78eae6648fb330a59363f2a052ed_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int64_t  func_28(int32_t  p_29, int64_t  p_30, int8_t  p_31, uint16_t  p_32)\n{ \n    int64_t l_256 = 0x6E68338B46DE65A4LL;\n    int32_t l_270 = 3L;\n    int8_t l_275 = 0L;\n    for (g_233 = 0; (g_233 <= 2); g_233 += 1)\n    { \n        int32_t l_255 = (-7L);\n        int32_t l_269[1];\n        int i;\n        for (i = 0; i < 1; i++)\n            l_269[i] = 0x4A06BE4AL;\n        p_29 = (safe_div_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u((safe_sub_func_int64_t_s_s(0x6587CEBA9940DB3FLL, ((safe_div_func_int16_t_s_s(0x7F1AL, 65529UL)) >= 0x7BL))), 7)), 0x5A23L));\n        l_255 = g_236[g_233];\n        if (g_236[0])\n            continue;\n        l_256 = (-1L);\n        g_65 = p_29;\n        l_270 = (safe_sub_func_int32_t_s_s((~(0xE7B200155B8B4CAALL <= 4L)), ((((p_30 = (~((safe_div_func_int64_t_s_s(((safe_add_func_uint32_t_u_u((safe_lshift_func_int16_t_s_s((l_255 = (safe_mul_func_uint8_t_u_u(0x37L, 0x2EL))), 8)), g_119[1])) , l_256), g_141[2])) >= 0x4AD5A420L))) == l_256) & 0x57C4L) || l_269[0])));\n    }\n    for (g_234 = 2; (g_234 >= 0); g_234 -= 1)\n    { \n        uint64_t l_272 = 0UL;\n        int32_t l_276 = 1L;\n        int32_t l_277 = 0xEFA478FCL;\n        ++l_272;\n        g_278--;\n        l_276 ^= g_231;\n        g_63 = (g_66 > (safe_mod_func_int16_t_s_s(((safe_rshift_func_uint8_t_u_u((l_272 ^ (safe_rshift_func_uint16_t_u_s(p_30, 14))), g_77)) , 0x9ED6L), p_30)));\n        if (l_276)\n            break;\n        return l_270;\n    }\n    return p_32;\n"]]}
{"hexsha": "36df6c7d7681661367e8b641b1afe9a66416636d", "ext": "c", "lang": "C", "content": "int32_t ATCmd_okResult(void)\n{    \n    ATCmd_Event_t eventMsg;\n    \n    eventMsg.callback = NULL;\n    eventMsg.args = (void *)(ATCmd_okStr);\n    ATCmd_signalEvent(&eventMsg);\n    return 0;\n}", "item_id": 2, "repo": "lagerdata/unit-test_templates", "file": "cc3235sf/ti_sdk/simplelink_cc32xx_sdk_4_10_00_07/source/ti/net/atcmd/atcmd_gen.c", "last_update_at": "2022-02-08T14:23:04+00:00", "question_id": "36df6c7d7681661367e8b641b1afe9a66416636d_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int32_t ATCmd_okResult(void)\n{    \n    ATCmd_Event_t eventMsg;\n    eventMsg.callback = NULL;\n    eventMsg.args = (void *)(ATCmd_okStr);\n    ATCmd_signalEvent(&eventMsg);\n    return 0;\n"]]}
{"hexsha": "d336276769d4f6a40f34014279d12a46fa43731e", "ext": "c", "lang": "C", "content": "STATIC_OVL int\ntry_disarm(ttmp, force_failure)\nstruct trap *ttmp;\nboolean force_failure;\n{\n\tstruct monst *mtmp = m_at(ttmp->tx,ttmp->ty);\n\tint ttype = ttmp->ttyp;\n\tboolean under_u = (!u.dx && !u.dy);\n\tboolean holdingtrap = (ttype == BEAR_TRAP || ttype == WEB);\n\t\n\t/* Test for monster first, monsters are displayed instead of trap. */\n\tif (mtmp && (!mtmp->mtrapped || !holdingtrap)) {\n\t\tpline(\"%s is in the way.\", Monnam(mtmp));\n\t\treturn 0;\n\t}\n\t/* We might be forced to move onto the trap's location. */\n\tif (sobj_at(BOULDER, ttmp->tx, ttmp->ty)\n\t\t\t\t&& !Passes_walls && !under_u) {\n\t\tThere(\"is a boulder in your way.\");\n\t\treturn 0;\n\t}\n\t/* duplicate tight-space checks from test_move */\n\tif (u.dx && u.dy &&\n\t    bad_rock(youmonst.data,u.ux,ttmp->ty) &&\n\t    bad_rock(youmonst.data,ttmp->tx,u.uy)) {\n\t    if ((invent && (inv_weight() + weight_cap() > 600)) ||\n\t\tbigmonst(youmonst.data)) {\n\t\t/* don't allow untrap if they can't get thru to it */\n\t\tYou(\"are unable to reach the %s!\",\n\t\t    defsyms[trap_to_defsym(ttype)].explanation);\n\t\treturn 0;\n\t    }\n\t}\n\t/* untrappable traps are located on the ground. */\n\tif (!can_reach_floor()) {\n#ifdef STEED\n\t\tif (u.usteed && P_SKILL(P_RIDING) < P_BASIC)\n\t\t\tYou(\"aren't skilled enough to reach from %s.\",\n\t\t\t\tmon_nam(u.usteed));\n\t\telse\n#endif\n\t\tYou(\"are unable to reach the %s!\",\n\t\t\tdefsyms[trap_to_defsym(ttype)].explanation);\n\t\treturn 0;\n\t}\n\n\t/* Will our hero succeed? */\n\tif (force_failure || untrap_prob(ttmp)) {\n\t\tif (rnl(5)) {\n\t\t    pline(\"Whoops...\");\n\t\t    if (mtmp) {\t\t/* must be a trap that holds monsters */\n\t\t\tif (ttype == BEAR_TRAP) {\n\t\t\t    if (mtmp->mtame) abuse_dog(mtmp);\n\t\t\t    if ((mtmp->mhp -= rnd(4)) <= 0) killed(mtmp);\n\t\t\t} else if (ttype == WEB) {\n\t\t\t    if (!webmaker(youmonst.data)) {\n\t\t\t\tstruct trap *ttmp2 = maketrap(u.ux, u.uy, WEB);\n\t\t\t\tif (ttmp2) {\n\t\t\t\t    pline_The(\"webbing sticks to you. You're caught too!\");\n\t\t\t\t    dotrap(ttmp2, NOWEBMSG);\n#ifdef STEED\n\t\t\t\t    if (u.usteed && u.utrap) {\n\t\t\t\t\t/* you, not steed, are trapped */\n\t\t\t\t\tdismount_steed(DISMOUNT_FELL);\n\t\t\t\t    }\n#endif\n\t\t\t\t}\n\t\t\t    } else\n\t\t\t\tpline(\"%s remains entangled.\", Monnam(mtmp));\n\t\t\t}\n\t\t    } else if (under_u) {\n\t\t\tdotrap(ttmp, 0);\n\t\t    } else {\n\t\t\tmove_into_trap(ttmp);\n\t\t    }\n\t\t} else {\n\t\t    pline(\"%s %s is difficult to %s.\",\n\t\t\t  ttmp->madeby_u ? \"Your\" : under_u ? \"This\" : \"That\",\n\t\t\t  defsyms[trap_to_defsym(ttype)].explanation,\n\t\t\t  (ttype == WEB) ? \"remove\" : \"disarm\");\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 2;\n}", "item_id": 28, "repo": "Bam4d/BrowserHack", "file": "src/trap.c", "last_update_at": "2022-03-24T21:16:43+00:00", "question_id": "d336276769d4f6a40f34014279d12a46fa43731e_28", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["STATIC_OVL int\ntry_disarm(ttmp, force_failure)\nstruct trap *ttmp;\nboolean force_failure;\n{\n\tstruct monst *mtmp = m_at(ttmp->tx,ttmp->ty);\n\tint ttype = ttmp->ttyp;\n\tboolean under_u = (!u.dx && !u.dy);\n\tboolean holdingtrap = (ttype == BEAR_TRAP || ttype == WEB);\n\t\n\t/* Test for monster first, monsters are displayed instead of trap. */\n\tif (mtmp && (!mtmp->mtrapped || !holdingtrap)) {\n\t\tpline(\"%s is in the way.\", Monnam(mtmp));\n\t\treturn 0;\n\t}\n\t/* We might be forced to move onto the trap's location. */\n\tif (sobj_at(BOULDER, ttmp->tx, ttmp->ty)\n\t\t\t\t&& !Passes_walls && !under_u) {\n\t\tThere(\"is a boulder in your way.\");\n\t\treturn 0;\n\t}\n\t/* duplicate tight-space checks from test_move */\n\tif (u.dx && u.dy &&\n\t    bad_rock(youmonst.data,u.ux,ttmp->ty) &&\n\t    bad_rock(youmonst.data,ttmp->tx,u.uy)) {\n\t    if ((invent && (inv_weight() + weight_cap() > 600)) ||\n\t\tbigmonst(youmonst.data)) {\n\t\t/* don't allow untrap if they can't get thru to it */\n\t\tYou(\"are unable to reach the %s!\",\n\t\t    defsyms[trap_to_defsym(ttype)].explanation);\n\t\treturn 0;\n\t    }\n\t}\n\t/* untrappable traps are located on the ground. */\n\tif (!can_reach_floor()) {\n#ifdef STEED\n\t\tif (u.usteed && P_SKILL(P_RIDING) < P_BASIC)\n\t\t\tYou(\"aren't skilled enough to reach from %s.\",\n\t\t\t\tmon_nam(u.usteed));\n\t\telse\n#endif\n\t\tYou(\"are unable to reach the %s!\",\n\t\t\tdefsyms[trap_to_defsym(ttype)].explanation);\n\t\treturn 0;\n\t}\n\t/* Will our hero succeed? */\n\tif (force_failure || untrap_prob(ttmp)) {\n\t\tif (rnl(5)) {\n\t\t    pline(\"Whoops...\");\n\t\t    if (mtmp) {\t\t/* must be a trap that holds monsters */\n\t\t\tif (ttype == BEAR_TRAP) {\n\t\t\t    if (mtmp->mtame) abuse_dog(mtmp);\n\t\t\t    if ((mtmp->mhp -= rnd(4)) <= 0) killed(mtmp);\n\t\t\t} else if (ttype == WEB) {\n\t\t\t    if (!webmaker(youmonst.data)) {\n\t\t\t\tstruct trap *ttmp2 = maketrap(u.ux, u.uy, WEB);\n\t\t\t\tif (ttmp2) {\n\t\t\t\t    pline_The(\"webbing sticks to you. You're caught too!\");\n\t\t\t\t    dotrap(ttmp2, NOWEBMSG);\n#ifdef STEED\n\t\t\t\t    if (u.usteed && u.utrap) {\n\t\t\t\t\t/* you, not steed, are trapped */\n\t\t\t\t\tdismount_steed(DISMOUNT_FELL);\n\t\t\t\t    }\n#endif\n\t\t\t\t}\n\t\t\t    } else\n\t\t\t\tpline(\"%s remains entangled.\", Monnam(mtmp));\n\t\t\t}\n\t\t    } else if (under_u) {\n\t\t\tdotrap(ttmp, 0);\n\t\t    } else {\n\t\t\tmove_into_trap(ttmp);\n\t\t    }\n\t\t} else {\n\t\t    pline(\"%s %s is difficult to %s.\",\n\t\t\t  ttmp->madeby_u ? \"Your\" : under_u ? \"This\" : \"That\",\n\t\t\t  defsyms[trap_to_defsym(ttype)].explanation,\n\t\t\t  (ttype == WEB) ? \"remove\" : \"disarm\");\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 2;\n"]]}
{"hexsha": "5a591ba9e98cd9f691fd1ea62d63b1c675387443", "ext": "h", "lang": "C", "content": "class Mapper\n{\npublic:\n    Mapper();\n    ~Mapper();\n\npublic:\n    static int StringToFormat(const std::string& format);\n    void SetIFilter(int ifilter);\n\n    void SphPointFromImg(const Image& img, int format, const Vec2f& sphPoints, Vec1d& pixels);\n\nprivate:\n    void SphToCart(const cv::Point2f& in, cv::Point3f& out);  // Spherical coordinates to Cartesian coordinates\n    void CartToRect(const Image& img, const cv::Point3f& in, cv::Point2f& out);\n    void CartToCube(const Image& img, const cv::Point3f& in, cv::Point2f& out, int& faceIdx);\n    std::vector<Image> ExtractCubeFace(const Image& cmp);\n\n    unsigned char IFilterNearest(const Image& img, const cv::Point2f& in);\n    void InitLanczosCoef();\n    double IFilterLanczos(const cv::Mat& img, const cv::Point2d& in) const;\n\nprivate:\n    float Clamp(float v, float low, float high);\n\nprivate:\n    int m_ifilter;\n    std::vector<double> m_lanczosCoef;\n}", "item_id": 0, "repo": "I2-Multimedia-Lab/360-video-experimental-platform", "file": "s-psnr/mapper.h", "last_update_at": "2022-03-24T12:28:59+00:00", "question_id": "5a591ba9e98cd9f691fd1ea62d63b1c675387443_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Mapper\n{\npublic:\n    Mapper();\n    ~Mapper();\npublic:\n    static int StringToFormat(const std::string& format);\n    void SetIFilter(int ifilter);\n    void SphPointFromImg(const Image& img, int format, const Vec2f& sphPoints, Vec1d& pixels);\nprivate:\n    void SphToCart(const cv::Point2f& in, cv::Point3f& out);  // Spherical coordinates to Cartesian coordinates\n    void CartToRect(const Image& img, const cv::Point3f& in, cv::Point2f& out);\n    void CartToCube(const Image& img, const cv::Point3f& in, cv::Point2f& out, int& faceIdx);\n    std::vector<Image> ExtractCubeFace(const Image& cmp);\n    unsigned char IFilterNearest(const Image& img, const cv::Point2f& in);\n    void InitLanczosCoef();\n    double IFilterLanczos(const cv::Mat& img, const cv::Point2d& in) const;\nprivate:\n    float Clamp(float v, float low, float high);\nprivate:\n    int m_ifilter;\n    std::vector<double> m_lanczosCoef;\n"]]}
{"hexsha": "fa9582e015dba7bedaff9ad6ce18dc7539a4d376", "ext": "c", "lang": "C", "content": "int hweight64(uint64_t w)\n{\n\tw = w - ((w >> 1) & 0x5555555555555555ull);\n\tw = (w & 0x3333333333333333ull) + ((w >> 2) & 0x3333333333333333ull);\n\tw = (w + (w >> 4)) & 0x0F0F0F0F0F0F0F0Full;\n\tw = (w + (w >> 8));\n\tw = (w + (w >> 16));\n\treturn (w + (w >> 32)) & 0x00000000000000FFull;\n}", "item_id": 3, "repo": "openfree01/sdk", "file": "source/hweight.c", "last_update_at": "2022-03-29T16:34:12+00:00", "question_id": "fa9582e015dba7bedaff9ad6ce18dc7539a4d376_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int hweight64(uint64_t w)\n{\n\tw = w - ((w >> 1) & 0x5555555555555555ull);\n\tw = (w & 0x3333333333333333ull) + ((w >> 2) & 0x3333333333333333ull);\n\tw = (w + (w >> 4)) & 0x0F0F0F0F0F0F0F0Full;\n\tw = (w + (w >> 8));\n\tw = (w + (w >> 16));\n\treturn (w + (w >> 32)) & 0x00000000000000FFull;\n"]]}
{"hexsha": "313054a860cdfc6cf366ec38d7c419c197e1a215", "ext": "c", "lang": "C", "content": "int\nmain(\n    int   argc,\n    char* argv[]\n    )\n{\n    DWORD dwError = 0;\n    BOOLEAN bShutdown = FALSE;\n    PLW_SHARE_MIGRATION_CONTEXT pContext = NULL;\n\n    if (argc == 2 && (!strcmp(argv[1], \"--help\") || !strcmp(argv[1], \"-h\")))\n    {\n        ShowUsage();\n        goto cleanup;\n    }\n\n    if (argc < 5)\n    {\n        dwError = ERROR_BAD_ARGUMENTS;\n        BAIL_ON_LW_TASK_ERROR(dwError);\n    }\n\n    dwError = LwTaskMigrateInit();\n    BAIL_ON_LW_TASK_ERROR(dwError);\n\n    bShutdown = TRUE;\n\n    dwError = LwTaskMigrateCreateContext(\n                    argv[3], /* User name   */\n                    argv[4], /* Password    */\n                    &pContext);\n    BAIL_ON_LW_TASK_ERROR(dwError);\n\n    dwError = LwTaskMigrateShareA(\n                    pContext,\n                    argv[1], /* Server name */\n                    argv[2], /* Share name  */\n                    0        /* Flags       */\n                    );\n    BAIL_ON_LW_TASK_ERROR(dwError);\n\ncleanup:\n\n    if (pContext)\n    {\n        LwTaskMigrateCloseContext(pContext);\n    }\n\n    if (bShutdown)\n    {\n        LwTaskMigrateShutdown();\n    }\n\n    return dwError;\n\nerror:\n\n    switch (dwError)\n    {\n        case ERROR_BAD_ARGUMENTS:\n\n            ShowUsage();\n\n            break;\n\n        default:\n\n            fprintf(stderr, \"Error migrating share. Code %u\\n\", dwError);\n\n            break;\n    }\n\n    goto cleanup;\n}", "item_id": 0, "repo": "kbore/pbis-open", "file": "lwtask/tests/lwmigrate/main.c", "last_update_at": "2022-03-18T19:54:37+00:00", "question_id": "313054a860cdfc6cf366ec38d7c419c197e1a215_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nmain(\n    int   argc,\n    char* argv[]\n    )\n{\n    DWORD dwError = 0;\n    BOOLEAN bShutdown = FALSE;\n    PLW_SHARE_MIGRATION_CONTEXT pContext = NULL;\n    if (argc == 2 && (!strcmp(argv[1], \"--help\") || !strcmp(argv[1], \"-h\")))\n    {\n        ShowUsage();\n        goto cleanup;\n    }\n    if (argc < 5)\n    {\n        dwError = ERROR_BAD_ARGUMENTS;\n        BAIL_ON_LW_TASK_ERROR(dwError);\n    }\n    dwError = LwTaskMigrateInit();\n    BAIL_ON_LW_TASK_ERROR(dwError);\n    bShutdown = TRUE;\n    dwError = LwTaskMigrateCreateContext(\n                    argv[3], /* User name   */\n                    argv[4], /* Password    */\n                    &pContext);\n    BAIL_ON_LW_TASK_ERROR(dwError);\n    dwError = LwTaskMigrateShareA(\n                    pContext,\n                    argv[1], /* Server name */\n                    argv[2], /* Share name  */\n                    0        /* Flags       */\n                    );\n    BAIL_ON_LW_TASK_ERROR(dwError);\ncleanup:\n    if (pContext)\n    {\n        LwTaskMigrateCloseContext(pContext);\n    }\n    if (bShutdown)\n    {\n        LwTaskMigrateShutdown();\n    }\n    return dwError;\nerror:\n    switch (dwError)\n    {\n        case ERROR_BAD_ARGUMENTS:\n            ShowUsage();\n            break;\n        default:\n            fprintf(stderr, \"Error migrating share. Code %u\\n\", dwError);\n            break;\n    }\n    goto cleanup;\n"]]}
{"hexsha": "148268cc6dc829abb05c48b605f1306ccfb6d6a5", "ext": "c", "lang": "C", "content": "int sam_hdr_remove_line_id(sam_hdr_t *bh, const char *type, const char *ID_key, const char *ID_value) {\n    sam_hrecs_t *hrecs;\n    if (!bh || !type)\n        return -1;\n\n    if (!(hrecs = bh->hrecs)) {\n        if (sam_hdr_fill_hrecs(bh) != 0)\n            return -1;\n        hrecs = bh->hrecs;\n    }\n\n    if (!strncmp(type, \"PG\", 2)) {\n        hts_log_warning(\"Removing PG lines is not supported!\");\n        return -1;\n    }\n\n    sam_hrec_type_t *type_found = sam_hrecs_find_type_id(hrecs, type, ID_key, ID_value);\n    if (!type_found)\n        return 0;\n\n    int ret = sam_hrecs_remove_line(hrecs, type, type_found);\n    if (ret == 0) {\n        if (hrecs->refs_changed >= 0 && rebuild_target_arrays(bh) != 0)\n            return -1;\n\n        if (hrecs->dirty)\n            redact_header_text(bh);\n    }\n\n    return ret;\n}", "item_id": 26, "repo": "abjonnes/pysam", "file": "htslib/header.c", "last_update_at": "2022-03-11T12:33:39+00:00", "question_id": "148268cc6dc829abb05c48b605f1306ccfb6d6a5_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int sam_hdr_remove_line_id(sam_hdr_t *bh, const char *type, const char *ID_key, const char *ID_value) {\n    sam_hrecs_t *hrecs;\n    if (!bh || !type)\n        return -1;\n    if (!(hrecs = bh->hrecs)) {\n        if (sam_hdr_fill_hrecs(bh) != 0)\n            return -1;\n        hrecs = bh->hrecs;\n    }\n    if (!strncmp(type, \"PG\", 2)) {\n        hts_log_warning(\"Removing PG lines is not supported!\");\n        return -1;\n    }\n    sam_hrec_type_t *type_found = sam_hrecs_find_type_id(hrecs, type, ID_key, ID_value);\n    if (!type_found)\n        return 0;\n    int ret = sam_hrecs_remove_line(hrecs, type, type_found);\n    if (ret == 0) {\n        if (hrecs->refs_changed >= 0 && rebuild_target_arrays(bh) != 0)\n            return -1;\n        if (hrecs->dirty)\n            redact_header_text(bh);\n    }\n    return ret;\n"]]}
{"hexsha": "905ae77855e8eb677a4215a98d0822fd8711d22c", "ext": "h", "lang": "C", "content": "class BankAction : public InventoryAction\n{\n    public:\n        BankAction(PlayerbotAI* botAI) : InventoryAction(botAI, \"bank\") { }\n\n        bool Execute(Event event) override;\n\n    private:\n        bool ExecuteBank(std::string const text, Unit* bank);\n        void ListItems();\n        bool Withdraw(uint32 itemid);\n        bool Deposit(Item* pItem);\n        Item* FindItemInBank(uint32 ItemId);\n}", "item_id": 0, "repo": "htc16/mod-playerbots", "file": "src/strategy/actions/BankAction.h", "last_update_at": "2022-03-30T12:12:58+00:00", "question_id": "905ae77855e8eb677a4215a98d0822fd8711d22c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class BankAction : public InventoryAction\n{\n    public:\n        BankAction(PlayerbotAI* botAI) : InventoryAction(botAI, \"bank\") { }\n        bool Execute(Event event) override;\n    private:\n        bool ExecuteBank(std::string const text, Unit* bank);\n        void ListItems();\n        bool Withdraw(uint32 itemid);\n        bool Deposit(Item* pItem);\n        Item* FindItemInBank(uint32 ItemId);\n"]]}
{"hexsha": "1d24af86426dae538048057a878f5ce53f22074f", "ext": "c", "lang": "C", "content": "struct dev_filter *persistent_filter_create(struct dev_types *dt,\n\t\t\t\t\t    struct dev_filter *real,\n\t\t\t\t\t    const char *file)\n{\n\tstruct pfilter *pf;\n\tstruct dev_filter *f = NULL;\n\tstruct stat info;\n\n\tif (!(pf = dm_zalloc(sizeof(*pf)))) {\n\t\tlog_error(\"Allocation of persistent filter failed.\");\n\t\treturn NULL;\n\t}\n\n\tpf->dt = dt;\n\n\tif (!(pf->file = dm_strdup(file))) {\n\t\tlog_error(\"Filename duplication for persistent filter failed.\");\n\t\tgoto bad;\n\t}\n\n\tpf->real = real;\n\n\tif (!(_init_hash(pf))) {\n\t\tlog_error(\"Couldn't create hash table for persistent filter.\");\n\t\tgoto bad;\n\t}\n\n\tif (!(f = dm_zalloc(sizeof(*f)))) {\n\t\tlog_error(\"Allocation of device filter for persistent filter failed.\");\n\t\tgoto bad;\n\t}\n\n\t/* Only merge cache file before dumping it if it changed externally. */\n\tif (!stat(pf->file, &info))\n\t\tlvm_stat_ctim(&pf->ctime, &info);\n\n\tf->passes_filter = _lookup_p;\n\tf->destroy = _persistent_destroy;\n\tf->use_count = 0;\n\tf->private = pf;\n\tf->wipe = _persistent_filter_wipe;\n\tf->dump = _persistent_filter_dump;\n\n\tlog_debug_devs(\"Persistent filter initialised.\");\n\n\treturn f;\n\n      bad:\n\tdm_free(pf->file);\n\tif (pf->devices)\n\t\tdm_hash_destroy(pf->devices);\n\tdm_free(pf);\n\tdm_free(f);\n\treturn NULL;\n}", "item_id": 7, "repo": "dawmlight/vendor_oh_fun", "file": "hihope_neptune-oh_hid/00_src/v0.1/third_party/LVM2/lib/filters/filter-persistent.c", "last_update_at": "2022-02-15T08:51:55+00:00", "question_id": "1d24af86426dae538048057a878f5ce53f22074f_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct dev_filter *persistent_filter_create(struct dev_types *dt,\n\t\t\t\t\t    struct dev_filter *real,\n\t\t\t\t\t    const char *file)\n{\n\tstruct pfilter *pf;\n\tstruct dev_filter *f = NULL;\n\tstruct stat info;\n\tif (!(pf = dm_zalloc(sizeof(*pf)))) {\n\t\tlog_error(\"Allocation of persistent filter failed.\");\n\t\treturn NULL;\n\t}\n\tpf->dt = dt;\n\tif (!(pf->file = dm_strdup(file))) {\n\t\tlog_error(\"Filename duplication for persistent filter failed.\");\n\t\tgoto bad;\n\t}\n\tpf->real = real;\n\tif (!(_init_hash(pf))) {\n\t\tlog_error(\"Couldn't create hash table for persistent filter.\");\n\t\tgoto bad;\n\t}\n\tif (!(f = dm_zalloc(sizeof(*f)))) {\n\t\tlog_error(\"Allocation of device filter for persistent filter failed.\");\n\t\tgoto bad;\n\t}\n\t/* Only merge cache file before dumping it if it changed externally. */\n\tif (!stat(pf->file, &info))\n\t\tlvm_stat_ctim(&pf->ctime, &info);\n\tf->passes_filter = _lookup_p;\n\tf->destroy = _persistent_destroy;\n\tf->use_count = 0;\n\tf->private = pf;\n\tf->wipe = _persistent_filter_wipe;\n\tf->dump = _persistent_filter_dump;\n\tlog_debug_devs(\"Persistent filter initialised.\");\n\treturn f;\n      bad:\n\tdm_free(pf->file);\n\tif (pf->devices)\n\t\tdm_hash_destroy(pf->devices);\n\tdm_free(pf);\n\tdm_free(f);\n\treturn NULL;\n"]]}
{"hexsha": "6c4131666ff81ab4673d2d4f32ba427d6a6c8f70", "ext": "c", "lang": "C", "content": "static uint64_t\nkblgt3__compute_l3_cache__gti_write_throughput__read(struct brw_context *brw,\n                                                     const struct brw_perf_query_info *query,\n                                                     uint64_t *accumulator)\n{\n   /* RPN equation: C 7 READ 64 UMUL */\n   uint64_t tmp0 = accumulator[query->c_offset + 7];\n   uint64_t tmp1 = tmp0 * 64;\n\n   return tmp1;\n}", "item_id": 307, "repo": "VincentWei/mg-mesa3d", "file": "src/mesa/drivers/dri/i965/brw_oa_kblgt3.c", "last_update_at": "2022-03-26T08:39:34+00:00", "question_id": "6c4131666ff81ab4673d2d4f32ba427d6a6c8f70_307", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static uint64_t\nkblgt3__compute_l3_cache__gti_write_throughput__read(struct brw_context *brw,\n                                                     const struct brw_perf_query_info *query,\n                                                     uint64_t *accumulator)\n{\n   /* RPN equation: C 7 READ 64 UMUL */\n   uint64_t tmp0 = accumulator[query->c_offset + 7];\n   uint64_t tmp1 = tmp0 * 64;\n   return tmp1;\n"]]}
{"hexsha": "963290318e6c58dcad19442d22b9247cf51783c5", "ext": "c", "lang": "C", "content": "static int ble_cmd_gatt_notify_change_by_uuid(int argc, char *argv[])\n{\n    uint16_t conn_handle;\n    uint32_t uuidint;\n    rw007_ble_uuid_t uuid;\n    int rc;\n    int value;\n    int uuidlen;\n\n    if (argc < 5)\n    {\n        rt_kprintf(\"argc < 5\\n\");\n        return -1;\n    }\n\n    conn_handle = atoi(argv[2]);\n\n    uuidlen = strlen(argv[3]);\n\n    if (4 == uuidlen) {\n        uuid.type = BLE_UUID_TYPE_16;\n        sscanf(argv[3], \"%x\", &uuidint);\n        uuid.uuid.uuid16 = uuidint & 0xFFFFu;\n    }\n    else if (8 == uuidlen) {\n        uuid.type = BLE_UUID_TYPE_32;\n        sscanf(argv[3], \"%x\", &uuidint);\n        uuid.uuid.uuid32 = uuidint & 0xFFFFFFFFu;\n    }\n    else if (32 == uuidlen) {\n        int i;\n\n        uuid.type = BLE_UUID_TYPE_128;\n        for (i = 0; i < 16; i++) {\n            sscanf(&argv[3][i * 2], \"%02x\", &uuidint);\n            uuid.uuid.uuid128[15 - i] = uuidint & 0xFFu;\n        }\n    }\n    else {\n        rt_kprintf(\"uuid:%s input error\\n\", argv[3]);\n        return -1;\n    }\n\n    value = atoi(argv[4]);\n    rt_kprintf(\"notifychange conn_hanle:%d uuid:%s value:%02x\\n\", conn_handle, argv[3], value);\n\n    rc = rw007_ble_gatt_notify_change_by_uuid(conn_handle, &uuid, value);\n\n    rt_kprintf(\"notifychange rc:%d\\n\", rc);\n    return rc;\n}", "item_id": 12, "repo": "zhangjun1992/rtt-bsp-hpm6750evkmini", "file": "projects/rw007_wifi/packages/rw007-latest/src/ble_cmd_rw007.c", "last_update_at": "2022-03-22T06:19:59+00:00", "question_id": "963290318e6c58dcad19442d22b9247cf51783c5_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int ble_cmd_gatt_notify_change_by_uuid(int argc, char *argv[])\n{\n    uint16_t conn_handle;\n    uint32_t uuidint;\n    rw007_ble_uuid_t uuid;\n    int rc;\n    int value;\n    int uuidlen;\n    if (argc < 5)\n    {\n        rt_kprintf(\"argc < 5\\n\");\n        return -1;\n    }\n    conn_handle = atoi(argv[2]);\n    uuidlen = strlen(argv[3]);\n    if (4 == uuidlen) {\n        uuid.type = BLE_UUID_TYPE_16;\n        sscanf(argv[3], \"%x\", &uuidint);\n        uuid.uuid.uuid16 = uuidint & 0xFFFFu;\n    }\n    else if (8 == uuidlen) {\n        uuid.type = BLE_UUID_TYPE_32;\n        sscanf(argv[3], \"%x\", &uuidint);\n        uuid.uuid.uuid32 = uuidint & 0xFFFFFFFFu;\n    }\n    else if (32 == uuidlen) {\n        int i;\n        uuid.type = BLE_UUID_TYPE_128;\n        for (i = 0; i < 16; i++) {\n            sscanf(&argv[3][i * 2], \"%02x\", &uuidint);\n            uuid.uuid.uuid128[15 - i] = uuidint & 0xFFu;\n        }\n    }\n    else {\n        rt_kprintf(\"uuid:%s input error\\n\", argv[3]);\n        return -1;\n    }\n    value = atoi(argv[4]);\n    rt_kprintf(\"notifychange conn_hanle:%d uuid:%s value:%02x\\n\", conn_handle, argv[3], value);\n    rc = rw007_ble_gatt_notify_change_by_uuid(conn_handle, &uuid, value);\n    rt_kprintf(\"notifychange rc:%d\\n\", rc);\n    return rc;\n"]]}
{"hexsha": "7f50cb4ac97bcc72cbb91857626c04307a7ea9f3", "ext": "c", "lang": "C", "content": "static HRESULT WINAPI HTMLStyle_get_paddingTop(IHTMLStyle *iface, VARIANT *p)\n{\n    HTMLStyle *This = impl_from_IHTMLStyle(iface);\n\n    TRACE(\"(%p)->(%p)\\n\", This, p);\n\n    return get_style_property_var(&This->css_style, STYLEID_PADDING_TOP, p);\n}", "item_id": 84, "repo": "SoulMelody/wine-mtc", "file": "dlls/mshtml/htmlstyle.c", "last_update_at": "2022-02-08T20:32:21+00:00", "question_id": "7f50cb4ac97bcc72cbb91857626c04307a7ea9f3_84", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static HRESULT WINAPI HTMLStyle_get_paddingTop(IHTMLStyle *iface, VARIANT *p)\n{\n    HTMLStyle *This = impl_from_IHTMLStyle(iface);\n    TRACE(\"(%p)->(%p)\\n\", This, p);\n    return get_style_property_var(&This->css_style, STYLEID_PADDING_TOP, p);\n"]]}
{"hexsha": "303980b71aae26f2a750c2f1bfe96ebe1046148e", "ext": "c", "lang": "C", "content": "int v4l2_pipeline_link_notify(struct media_link *link, u32 flags,\n\t\t\t      unsigned int notification)\n{\n\tstruct media_graph *graph = &link->graph_obj.mdev->pm_count_walk;\n\tstruct media_entity *source = link->source->entity;\n\tstruct media_entity *sink = link->sink->entity;\n\tint source_use;\n\tint sink_use;\n\tint ret = 0;\n\n\tsource_use = pipeline_pm_use_count(source, graph);\n\tsink_use = pipeline_pm_use_count(sink, graph);\n\n\tif (notification == MEDIA_DEV_NOTIFY_POST_LINK_CH &&\n\t    !(flags & MEDIA_LNK_FL_ENABLED)) {\n\t\t/* Powering off entities is assumed to never fail. */\n\t\tpipeline_pm_power(source, -sink_use, graph);\n\t\tpipeline_pm_power(sink, -source_use, graph);\n\t\treturn 0;\n\t}\n\n\tif (notification == MEDIA_DEV_NOTIFY_PRE_LINK_CH &&\n\t\t(flags & MEDIA_LNK_FL_ENABLED)) {\n\n\t\tret = pipeline_pm_power(source, sink_use, graph);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = pipeline_pm_power(sink, source_use, graph);\n\t\tif (ret < 0)\n\t\t\tpipeline_pm_power(source, -sink_use, graph);\n\t}\n\n\treturn ret;\n}", "item_id": 7, "repo": "bingchunjin/1806_SDK", "file": "linux-4.14.90-dev/linux-4.14.90/drivers/media/v4l2-core/v4l2-mc.c", "last_update_at": "2022-03-07T12:09:00+00:00", "question_id": "303980b71aae26f2a750c2f1bfe96ebe1046148e_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int v4l2_pipeline_link_notify(struct media_link *link, u32 flags,\n\t\t\t      unsigned int notification)\n{\n\tstruct media_graph *graph = &link->graph_obj.mdev->pm_count_walk;\n\tstruct media_entity *source = link->source->entity;\n\tstruct media_entity *sink = link->sink->entity;\n\tint source_use;\n\tint sink_use;\n\tint ret = 0;\n\tsource_use = pipeline_pm_use_count(source, graph);\n\tsink_use = pipeline_pm_use_count(sink, graph);\n\tif (notification == MEDIA_DEV_NOTIFY_POST_LINK_CH &&\n\t    !(flags & MEDIA_LNK_FL_ENABLED)) {\n\t\t/* Powering off entities is assumed to never fail. */\n\t\tpipeline_pm_power(source, -sink_use, graph);\n\t\tpipeline_pm_power(sink, -source_use, graph);\n\t\treturn 0;\n\t}\n\tif (notification == MEDIA_DEV_NOTIFY_PRE_LINK_CH &&\n\t\t(flags & MEDIA_LNK_FL_ENABLED)) {\n\t\tret = pipeline_pm_power(source, sink_use, graph);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = pipeline_pm_power(sink, source_use, graph);\n\t\tif (ret < 0)\n\t\t\tpipeline_pm_power(source, -sink_use, graph);\n\t}\n\treturn ret;\n"]]}
{"hexsha": "1119414f65a6df1bc9e3cfd8bfa7a25dc35398aa", "ext": "c", "lang": "C", "content": "void bftraversal(int adj[MAX][MAX], int n, int state[], int queue[], int front, int rear)\n{\n\tint v;\n\tfor (v=0;v<n;v++)\n\t\tstate[v]=initial;\n\tprintf(\"Enter starting vertex for bfs: \");\n\tscanf(\"%d\",&v);\n\tbfs(v,adj,n,state,queue,front,rear);\n\t/* // Add code to print all vertices (unreachable from starting vertex)\n\tfor (v=0;v<n;v++)\n\t{\n\t\tif (state[v]==initial)\n\t\t\tbfs(v,adj,n,state,queue,front,rear);\n\t}\n\t*/\n}", "item_id": 4, "repo": "patres270/AlgoLib", "file": "C/BFSTraversal.c", "last_update_at": "2022-03-01T01:28:23+00:00", "question_id": "1119414f65a6df1bc9e3cfd8bfa7a25dc35398aa_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void bftraversal(int adj[MAX][MAX], int n, int state[], int queue[], int front, int rear)\n{\n\tint v;\n\tfor (v=0;v<n;v++)\n\t\tstate[v]=initial;\n\tprintf(\"Enter starting vertex for bfs: \");\n\tscanf(\"%d\",&v);\n\tbfs(v,adj,n,state,queue,front,rear);\n\t/* // Add code to print all vertices (unreachable from starting vertex)\n\tfor (v=0;v<n;v++)\n\t{\n\t\tif (state[v]==initial)\n\t\t\tbfs(v,adj,n,state,queue,front,rear);\n\t}\n\t*/\n"]]}
{"hexsha": "7248c8f9ee3c68eea49963a9eb7771caf2ff98e8", "ext": "c", "lang": "C", "content": "static void node_composit_exec_dilateerode(void *UNUSED(data), bNode *node, bNodeStack **in, bNodeStack **out)\n{\n\t/* stack order in: mask */\n\t/* stack order out: mask */\n\tif(out[0]->hasoutput==0) \n\t\treturn;\n\t\n\t/* input no image? then only color operation */\n\tif(in[0]->data==NULL) {\n\t\tout[0]->vec[0] = out[0]->vec[1] = out[0]->vec[2] = 0.0f;\n\t\tout[0]->vec[3] = 0.0f;\n\t}\n\telse {\n\t\t/* make output size of input image */\n\t\tCompBuf *cbuf= typecheck_compbuf(in[0]->data, CB_VAL);\n\t\tCompBuf *stackbuf= dupalloc_compbuf(cbuf);\n\t\tshort i;\n\t\t\n\t\tif (node->custom2 > 0) { // positive, dilate\n\t\t\tfor (i = 0; i < node->custom2; i++)\n\t\t\t\tmorpho_dilate(stackbuf);\n\t\t} else if (node->custom2 < 0) { // negative, erode\n\t\t\tfor (i = 0; i > node->custom2; i--)\n\t\t\t\tmorpho_erode(stackbuf);\n\t\t}\n\t\t\n\t\tif(cbuf!=in[0]->data)\n\t\t\tfree_compbuf(cbuf);\n\t\t\n\t\tout[0]->data= stackbuf;\n\t}\n}", "item_id": 2, "repo": "wycivil08/blendocv", "file": "source/blender/nodes/composite/nodes/node_composite_dilate.c", "last_update_at": "2022-01-10T07:47:29+00:00", "question_id": "7248c8f9ee3c68eea49963a9eb7771caf2ff98e8_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void node_composit_exec_dilateerode(void *UNUSED(data), bNode *node, bNodeStack **in, bNodeStack **out)\n{\n\t/* stack order in: mask */\n\t/* stack order out: mask */\n\tif(out[0]->hasoutput==0) \n\t\treturn;\n\t\n\t/* input no image? then only color operation */\n\tif(in[0]->data==NULL) {\n\t\tout[0]->vec[0] = out[0]->vec[1] = out[0]->vec[2] = 0.0f;\n\t\tout[0]->vec[3] = 0.0f;\n\t}\n\telse {\n\t\t/* make output size of input image */\n\t\tCompBuf *cbuf= typecheck_compbuf(in[0]->data, CB_VAL);\n\t\tCompBuf *stackbuf= dupalloc_compbuf(cbuf);\n\t\tshort i;\n\t\t\n\t\tif (node->custom2 > 0) { // positive, dilate\n\t\t\tfor (i = 0; i < node->custom2; i++)\n\t\t\t\tmorpho_dilate(stackbuf);\n\t\t} else if (node->custom2 < 0) { // negative, erode\n\t\t\tfor (i = 0; i > node->custom2; i--)\n\t\t\t\tmorpho_erode(stackbuf);\n\t\t}\n\t\t\n\t\tif(cbuf!=in[0]->data)\n\t\t\tfree_compbuf(cbuf);\n\t\t\n\t\tout[0]->data= stackbuf;\n\t}\n"]]}
{"hexsha": "e40b8fb60a8a6f5b3da8439e855e8cb7e356ca59", "ext": "h", "lang": "C", "content": "static inline void hri_pio_set_ABCDSR_P7_bit(const void *const hw, uint8_t index)\n{\n\tPIO_CRITICAL_SECTION_ENTER();\n\t((Pio *)hw)->PIO_ABCDSR[index] |= PIO_ABCDSR_P7;\n\tPIO_CRITICAL_SECTION_LEAVE();\n}", "item_id": 55, "repo": "BreederBai/rt-thread", "file": "bsp/microchip/same70/bsp/hri/hri_pio_e70b.h", "last_update_at": "2022-03-02T12:48:01+00:00", "question_id": "e40b8fb60a8a6f5b3da8439e855e8cb7e356ca59_55", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void hri_pio_set_ABCDSR_P7_bit(const void *const hw, uint8_t index)\n{\n\tPIO_CRITICAL_SECTION_ENTER();\n\t((Pio *)hw)->PIO_ABCDSR[index] |= PIO_ABCDSR_P7;\n\tPIO_CRITICAL_SECTION_LEAVE();\n"]]}
{"hexsha": "23963e9ef99b6c5865a9b907b3abd5b6ae63f87b", "ext": "h", "lang": "C", "content": "namespace dlib\n{\n\n// ----------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------\n//                                   Simple matrix utilities \n// ----------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp diag (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns a column vector R that contains the elements from the diagonal \n              of m in the order R(0)==m(0,0), R(1)==m(1,1), R(2)==m(2,2) and so on.\n    !*/\n\n    template <typename EXP>\n    struct diag_exp\n    {\n        /*!\n            WHAT THIS OBJECT REPRESENTS\n                This struct allows you to determine the type of matrix expression \n                object returned from the diag() function.  An example makes its\n                use clear:\n\n                template <typename EXP>\n                void do_something( const matrix_exp<EXP>& mat)\n                {\n                    // d is a matrix expression that aliases mat.\n                    typename diag_exp<EXP>::type d = diag(mat);\n\n                    // Print the diagonal of mat.  So we see that by using\n                    // diag_exp we can save the object returned by diag() in\n                    // a local variable.    \n                    cout << d << endl;\n\n                    // Note that you can only save the return value of diag() to\n                    // a local variable if the argument to diag() has a lifetime\n                    // beyond the diag() expression.  The example shown above is\n                    // OK but the following would result in undefined behavior:\n                    typename diag_exp<EXP>::type bad = diag(mat + mat);\n                }\n        !*/\n        typedef type_of_expression_returned_by_diag type;\n    };\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp diagm (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_vector(m) == true\n              (i.e. m is a row or column matrix)\n        ensures\n            - returns a square matrix M such that:\n                - diag(M) == m\n                - non diagonal elements of M are 0\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp trans (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns the transpose of the matrix m\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_type::type dot (\n        const matrix_exp& m1,\n        const matrix_exp& m2\n    );\n    /*!\n        requires\n            - is_vector(m1) == true\n            - is_vector(m2) == true\n            - m1.size() == m2.size()\n            - m1.size() > 0\n        ensures\n            - returns the dot product between m1 and m2. That is, this function \n              computes and returns the sum, for all i, of m1(i)*m2(i).\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp lowerm (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns a matrix M such that:\n                - M::type == the same type that was in m\n                - M has the same dimensions as m\n                - M is the lower triangular part of m.  That is:\n                    - if (r >= c) then\n                        - M(r,c) == m(r,c)\n                    - else\n                        - M(r,c) == 0\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp lowerm (\n        const matrix_exp& m,\n        const matrix_exp::type scalar_value\n    );\n    /*!\n        ensures\n            - returns a matrix M such that:\n                - M::type == the same type that was in m\n                - M has the same dimensions as m\n                - M is the lower triangular part of m except that the diagonal has\n                  been set to scalar_value.  That is:\n                    - if (r > c) then\n                        - M(r,c) == m(r,c)\n                    - else if (r == c) then\n                        - M(r,c) == scalar_value \n                    - else\n                        - M(r,c) == 0\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp upperm (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns a matrix M such that:\n                - M::type == the same type that was in m\n                - M has the same dimensions as m\n                - M is the upper triangular part of m.  That is:\n                    - if (r <= c) then\n                        - M(r,c) == m(r,c)\n                    - else\n                        - M(r,c) == 0\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp upperm (\n        const matrix_exp& m,\n        const matrix_exp::type scalar_value\n    );\n    /*!\n        ensures\n            - returns a matrix M such that:\n                - M::type == the same type that was in m\n                - M has the same dimensions as m\n                - M is the upper triangular part of m except that the diagonal has\n                  been set to scalar_value.  That is:\n                    - if (r < c) then\n                        - M(r,c) == m(r,c)\n                    - else if (r == c) then\n                        - M(r,c) == scalar_value \n                    - else\n                        - M(r,c) == 0\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp make_symmetric (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.nr() == m.nc()\n              (i.e. m must be a square matrix)\n        ensures\n            - returns a matrix M such that:\n                - M::type == the same type that was in m\n                - M has the same dimensions as m\n                - M is a symmetric matrix, that is, M == trans(M) and\n                  it is constructed from the lower triangular part of m.  Specifically,\n                  we have:\n                    - lowerm(M) == lowerm(m)\n                    - upperm(M) == trans(lowerm(m))\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <\n        typename T, \n        long NR, \n        long NC, \n        T val\n        >\n    const matrix_exp uniform_matrix (\n    );\n    /*!\n        requires\n            - NR > 0 && NC > 0\n        ensures\n            - returns an NR by NC matrix with elements of type T and all set to val.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <\n        typename T,\n        long NR, \n        long NC\n        >\n    const matrix_exp uniform_matrix (\n        const T& val\n    );\n    /*!\n        requires\n            - NR > 0 && NC > 0\n        ensures\n            - returns an NR by NC matrix with elements of type T and all set to val.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <\n        typename T\n        >\n    const matrix_exp uniform_matrix (\n        long nr,\n        long nc,\n        const T& val\n    );\n    /*!\n        requires\n            - nr >= 0 && nc >= 0\n        ensures\n            - returns an nr by nc matrix with elements of type T and all set to val.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp ones_matrix (\n        const matrix_exp& mat\n    );\n    /*!\n        requires\n            - mat.nr() >= 0 && mat.nc() >= 0\n        ensures\n            - Let T denote the type of element in mat. Then this function\n              returns uniform_matrix<T>(mat.nr(), mat.nc(), 1)\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <\n        typename T\n        >\n    const matrix_exp ones_matrix (\n        long nr,\n        long nc\n    );\n    /*!\n        requires\n            - nr >= 0 && nc >= 0\n        ensures\n            - returns uniform_matrix<T>(nr, nc, 1)\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp zeros_matrix (\n        const matrix_exp& mat\n    );\n    /*!\n        requires\n            - mat.nr() >= 0 && mat.nc() >= 0\n        ensures\n            - Let T denote the type of element in mat. Then this function\n              returns uniform_matrix<T>(mat.nr(), mat.nc(), 0)\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <\n        typename T\n        >\n    const matrix_exp zeros_matrix (\n        long nr,\n        long nc\n    );\n    /*!\n        requires\n            - nr >= 0 && nc >= 0\n        ensures\n            - returns uniform_matrix<T>(nr, nc, 0)\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp identity_matrix (\n        const matrix_exp& mat\n    );\n    /*!\n        requires\n            - mat.nr() == mat.nc()\n        ensures\n            - returns an identity matrix with the same dimensions as mat and\n              containing the same type of elements as mat.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <\n        typename T\n        >\n    const matrix_exp identity_matrix (\n        long N\n    );\n    /*!\n        requires\n            - N > 0\n        ensures\n            - returns an N by N identity matrix with elements of type T.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <\n        typename T, \n        long N\n        >\n    const matrix_exp identity_matrix (\n    );\n    /*!\n        requires\n            - N > 0\n        ensures\n            - returns an N by N identity matrix with elements of type T.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp linspace (\n        double start,\n        double end,\n        long num\n    );\n    /*!\n        requires\n            - num >= 0\n        ensures\n            - returns a matrix M such that:\n                - M::type == double \n                - is_row_vector(M) == true\n                - M.size() == num\n                - M == a row vector with num linearly spaced values beginning with start\n                  and stopping with end.  \n                - M(num-1) == end \n                - if (num > 1) then\n                    - M(0) == start\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp logspace (\n        double start,\n        double end,\n        long num\n    );\n    /*!\n        requires\n            - num >= 0\n        ensures\n            - returns a matrix M such that:\n                - M::type == double \n                - is_row_vector(M) == true\n                - M.size() == num\n                - M == a row vector with num logarithmically spaced values beginning with \n                  10^start and stopping with 10^end.  \n                  (i.e. M == pow(10, linspace(start, end, num)))\n                - M(num-1) == 10^end\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp linpiece (\n        const double val,\n        const matrix_exp& joints\n    );\n    /*!\n        requires\n            - is_vector(joints) == true\n            - joints.size() >= 2\n            - for all valid i < j:\n                - joints(i) < joints(j)\n        ensures\n            - linpiece() is useful for creating piecewise linear functions of val.  For\n              example, if w is a parameter vector then you can represent a piecewise linear\n              function of val as: f(val) = dot(w, linpiece(val, linspace(0,100,5))).  In\n              this case, f(val) is piecewise linear on the intervals [0,25], [25,50],\n              [50,75], [75,100].  Moreover, w(i) defines the derivative of f(val) in the\n              i-th interval.  Finally, outside the interval [0,100] f(val) has a derivative\n              of zero and f(0) == 0.\n            - To be precise, this function returns a column vector L such that:\n                - L.size() == joints.size()-1\n                - is_col_vector(L) == true\n                - L contains the same type of elements as joints.\n                - for all valid i:\n                - if (joints(i) < val)\n                    - L(i) == min(val,joints(i+1)) - joints(i)\n                - else\n                    - L(i) == 0\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <\n        long R,\n        long C\n        >\n    const matrix_exp rotate (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m\n                - R has the same dimensions as m\n                - for all valid r and c:\n                  R( (r+R)%m.nr() , (c+C)%m.nc() ) == m(r,c)\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp fliplr (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - flips the matrix m from left to right and returns the result.  \n              I.e. reverses the order of the columns.\n            - returns a matrix M such that:\n                - M::type == the same type that was in m\n                - M has the same dimensions as m\n                - for all valid r and c:\n                  M(r,c) == m(r, m.nc()-c-1)\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp flipud (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - flips the matrix m from up to down and returns the result.  \n              I.e. reverses the order of the rows.\n            - returns a matrix M such that:\n                - M::type == the same type that was in m\n                - M has the same dimensions as m\n                - for all valid r and c:\n                  M(r,c) == m(m.nr()-r-1, c)\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp flip (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - flips the matrix m from up to down and left to right and returns the \n              result.  I.e. returns flipud(fliplr(m)).\n            - returns a matrix M such that:\n                - M::type == the same type that was in m\n                - M has the same dimensions as m\n                - for all valid r and c:\n                  M(r,c) == m(m.nr()-r-1, m.nc()-c-1)\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp reshape (\n        const matrix_exp& m,\n        long rows,\n        long cols\n    );\n    /*!\n        requires\n            - m.size() == rows*cols\n            - rows > 0\n            - cols > 0\n        ensures\n            - returns a matrix M such that: \n                - M.nr() == rows\n                - M.nc() == cols\n                - M.size() == m.size()\n                - for all valid r and c:\n                    - let IDX = r*cols + c\n                    - M(r,c) == m(IDX/m.nc(), IDX%m.nc())\n\n            - i.e. The matrix m is reshaped into a new matrix of rows by cols\n              dimension.  Additionally, the elements of m are laid into M in row major \n              order.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp reshape_to_column_vector (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns a matrix M such that: \n                - is_col_vector(M) == true\n                - M.size() == m.size()\n                - for all valid r and c:\n                    - m(r,c) == M(r*m.nc() + c)\n\n            - i.e. The matrix m is reshaped into a column vector.  Note that\n              the elements are pulled out in row major order.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <\n        long R,\n        long C\n        >\n    const matrix_exp removerc (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.nr() > R >= 0\n            - m.nc() > C >= 0\n        ensures\n            - returns a matrix M such that:\n                - M.nr() == m.nr() - 1\n                - M.nc() == m.nc() - 1\n                - M == m with its R row and C column removed\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp removerc (\n        const matrix_exp& m,\n        long R,\n        long C\n    );\n    /*!\n        requires\n            - m.nr() > R >= 0\n            - m.nc() > C >= 0\n        ensures\n            - returns a matrix M such that:\n                - M.nr() == m.nr() - 1\n                - M.nc() == m.nc() - 1\n                - M == m with its R row and C column removed\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <\n        long R\n        >\n    const matrix_exp remove_row (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.nr() > R >= 0\n        ensures\n            - returns a matrix M such that:\n                - M.nr() == m.nr() - 1\n                - M.nc() == m.nc() \n                - M == m with its R row removed\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp remove_row (\n        const matrix_exp& m,\n        long R\n    );\n    /*!\n        requires\n            - m.nr() > R >= 0\n        ensures\n            - returns a matrix M such that:\n                - M.nr() == m.nr() - 1\n                - M.nc() == m.nc() \n                - M == m with its R row removed\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <\n        long C\n        >\n    const matrix_exp remove_col (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.nc() > C >= 0\n        ensures\n            - returns a matrix M such that:\n                - M.nr() == m.nr() \n                - M.nc() == m.nc() - 1 \n                - M == m with its C column removed\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp remove_col (\n        const matrix_exp& m,\n        long C\n    );\n    /*!\n        requires\n            - m.nc() > C >= 0\n        ensures\n            - returns a matrix M such that:\n                - M.nr() == m.nr() \n                - M.nc() == m.nc() - 1 \n                - M == m with its C column removed\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <\n       typename target_type\n       >\n    const matrix_exp matrix_cast (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns a matrix R where for all valid r and c:\n              R(r,c) == static_cast<target_type>(m(r,c))\n              also, R has the same dimensions as m.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <\n        typename T,\n        long NR,\n        long NC,\n        typename MM,\n        typename U,\n        typename L\n        >\n    void set_all_elements (\n        matrix<T,NR,NC,MM,L>& m,\n        U value\n    );\n    /*!\n        ensures\n            - for all valid r and c:\n              m(r,c) == value\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp::matrix_type tmp (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns a temporary matrix object that is a copy of m. \n              (This allows you to easily force a matrix_exp to fully evaluate)\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <\n        typename T, \n        long NR, \n        long NC, \n        typename MM, \n        typename L\n        >\n    uint32 hash (\n        const matrix<T,NR,NC,MM,L>& item,\n        uint32 seed = 0\n    );\n    /*!\n        requires\n            - T is a standard layout type (e.g. a POD type like int, float, \n              or a simple struct).\n        ensures\n            - returns a 32bit hash of the data stored in item.  \n            - Each value of seed results in a different hash function being used.  \n              (e.g. hash(item,0) should generally not be equal to hash(item,1))\n            - uses the murmur_hash3() routine to compute the actual hash.\n            - Note that if the memory layout of the elements in item change between\n              hardware platforms then hash() will give different outputs.  If you want\n              hash() to always give the same output for the same input then you must \n              ensure that elements of item always have the same layout in memory.\n              Typically this means using fixed width types and performing byte swapping\n              to account for endianness before passing item to hash().\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    // if matrix_exp contains non-complex types (e.g. float, double)\n    bool equal (\n        const matrix_exp& a,\n        const matrix_exp& b,\n        const matrix_exp::type epsilon = 100*std::numeric_limits<matrix_exp::type>::epsilon()\n    );\n    /*!\n        ensures\n            - if (a and b don't have the same dimensions) then\n                - returns false\n            - else if (there exists an r and c such that abs(a(r,c)-b(r,c)) > epsilon) then\n                - returns false\n            - else\n                - returns true\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    // if matrix_exp contains std::complex types \n    bool equal (\n        const matrix_exp& a,\n        const matrix_exp& b,\n        const matrix_exp::type::value_type epsilon = 100*std::numeric_limits<matrix_exp::type::value_type>::epsilon()\n    );\n    /*!\n        ensures\n            - if (a and b don't have the same dimensions) then\n                - returns false\n            - else if (there exists an r and c such that abs(real(a(r,c)-b(r,c))) > epsilon \n              or abs(imag(a(r,c)-b(r,c))) > epsilon) then\n                - returns false\n            - else\n                - returns true\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp pointwise_multiply (\n        const matrix_exp& a,\n        const matrix_exp& b \n    );\n    /*!\n        requires\n            - a.nr() == b.nr()\n            - a.nc() == b.nc()\n            - a and b both contain the same type of element (one or both\n              can also be of type std::complex so long as the underlying type\n              in them is the same)\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in a and b.\n                - R has the same dimensions as a and b. \n                - for all valid r and c:\n                  R(r,c) == a(r,c) * b(r,c)\n    !*/\n\n    const matrix_exp pointwise_multiply (\n        const matrix_exp& a,\n        const matrix_exp& b,\n        const matrix_exp& c \n    );\n    /*!\n        performs pointwise_multiply(a,pointwise_multiply(b,c));\n    !*/\n\n    const matrix_exp pointwise_multiply (\n        const matrix_exp& a,\n        const matrix_exp& b,\n        const matrix_exp& c,\n        const matrix_exp& d \n    );\n    /*!\n        performs pointwise_multiply(pointwise_multiply(a,b),pointwise_multiply(c,d));\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp join_rows (\n        const matrix_exp& a,\n        const matrix_exp& b \n    );\n    /*!\n        requires\n            - a.nr() == b.nr() || a.size() == 0 || b.size() == 0\n            - a and b both contain the same type of element\n        ensures\n            - This function joins two matrices together by concatenating their rows.\n            - returns a matrix R such that:\n                - R::type == the same type that was in a and b.\n                - R.nr() == a.nr() == b.nr()\n                - R.nc() == a.nc() + b.nc()\n                - for all valid r and c:\n                    - if (c < a.nc()) then\n                        - R(r,c) == a(r,c) \n                    - else\n                        - R(r,c) == b(r, c-a.nc()) \n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp join_cols (\n        const matrix_exp& a,\n        const matrix_exp& b \n    );\n    /*!\n        requires\n            - a.nc() == b.nc() || a.size() == 0 || b.size() == 0\n            - a and b both contain the same type of element\n        ensures\n            - This function joins two matrices together by concatenating their columns.\n            - returns a matrix R such that:\n                - R::type == the same type that was in a and b.\n                - R.nr() == a.nr() + b.nr()\n                - R.nc() == a.nc() == b.nc()\n                - for all valid r and c:\n                    - if (r < a.nr()) then\n                        - R(r,c) == a(r,c) \n                    - else\n                        - R(r,c) == b(r-a.nr(), c) \n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp tensor_product (\n        const matrix_exp& a,\n        const matrix_exp& b \n    );\n    /*!\n        requires\n            - a and b both contain the same type of element\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in a and b.\n                - R.nr() == a.nr() * b.nr()  \n                - R.nc() == a.nc() * b.nc()  \n                - for all valid r and c:\n                  R(r,c) == a(r/b.nr(), c/b.nc()) * b(r%b.nr(), c%b.nc())\n                - I.e. R is the tensor product of matrix a with matrix b\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp cartesian_product (\n        const matrix_exp& A,\n        const matrix_exp& B \n    );\n    /*!\n        requires\n            - A and B both contain the same type of element\n        ensures\n            - Think of A and B as sets of column vectors.  Then this function \n              returns a matrix that contains a set of column vectors that is\n              the Cartesian product of the sets A and B.  That is, the resulting\n              matrix contains every possible combination of vectors from both A and\n              B.\n            - returns a matrix R such that:\n                - R::type == the same type that was in A and B.\n                - R.nr() == A.nr() + B.nr()  \n                - R.nc() == A.nc() * B.nc()  \n                - Each column of R is the concatenation of a column vector\n                  from A with a column vector from B.  \n                - for all valid r and c:\n                    - if (r < A.nr()) then\n                        - R(r,c) == A(r, c/B.nc())\n                    - else\n                        - R(r,c) == B(r-A.nr(), c%B.nc())\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp scale_columns (\n        const matrix_exp& m,\n        const matrix_exp& v\n    );\n    /*!\n        requires\n            - is_vector(v) == true\n            - v.size() == m.nc()\n            - m and v both contain the same type of element\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m and v.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                  R(r,c) == m(r,c) * v(c)\n                - i.e. R is the result of multiplying each of m's columns by\n                  the corresponding scalar in v.\n\n            - Note that this function is identical to the expression m*diagm(v).  \n              That is, the * operator is overloaded for this case and will invoke\n              scale_columns() automatically as appropriate.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp scale_rows (\n        const matrix_exp& m,\n        const matrix_exp& v\n    );\n    /*!\n        requires\n            - is_vector(v) == true\n            - v.size() == m.nr()\n            - m and v both contain the same type of element\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m and v.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                  R(r,c) == m(r,c) * v(r)\n                - i.e. R is the result of multiplying each of m's rows by\n                  the corresponding scalar in v.\n\n            - Note that this function is identical to the expression diagm(v)*m.  \n              That is, the * operator is overloaded for this case and will invoke\n              scale_rows() automatically as appropriate.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <typename T>\n    void sort_columns (\n        matrix<T>& m,\n        matrix<T>& v\n    );\n    /*!\n        requires\n            - is_col_vector(v) == true\n            - v.size() == m.nc()\n            - m and v both contain the same type of element\n        ensures\n            - the dimensions for m and v are not changed\n            - sorts the columns of m according to the values in v.\n              i.e. \n                - #v == the contents of v but in sorted order according to\n                  operator<.  So smaller elements come first.\n                - Let #v(new(i)) == v(i) (i.e. new(i) is the index element i moved to)\n                - colm(#m,new(i)) == colm(m,i) \n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <typename T>\n    void rsort_columns (\n        matrix<T>& m,\n        matrix<T>& v\n    );\n    /*!\n        requires\n            - is_col_vector(v) == true\n            - v.size() == m.nc()\n            - m and v both contain the same type of element\n        ensures\n            - the dimensions for m and v are not changed\n            - sorts the columns of m according to the values in v.\n              i.e. \n                - #v == the contents of v but in sorted order according to\n                  operator>.  So larger elements come first.\n                - Let #v(new(i)) == v(i) (i.e. new(i) is the index element i moved to)\n                - colm(#m,new(i)) == colm(m,i) \n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp::type length_squared (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_vector(m) == true\n        ensures\n            - returns sum(squared(m))\n              (i.e. returns the square of the length of the vector m)\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp::type length (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_vector(m) == true\n        ensures\n            - returns sqrt(sum(squared(m)))\n              (i.e. returns the length of the vector m)\n            - if (m contains integer valued elements) then  \n                - The return type is a double that represents the length.  Therefore, the\n                  return value of length() is always represented using a floating point\n                  type. \n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    bool is_row_vector (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - if (m.nr() == 1) then\n                - return true\n            - else\n                - returns false\n    !*/\n\n    bool is_col_vector (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - if (m.nc() == 1) then\n                - return true\n            - else\n                - returns false\n    !*/\n\n    bool is_vector (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - if (is_row_vector(m) || is_col_vector(m)) then\n                - return true\n            - else\n                - returns false\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    bool is_finite (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns true if all the values in m are finite values and also not any kind\n              of NaN value.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------\n//                      Thresholding relational operators \n// ----------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------\n\n    template <typename S>\n    const matrix_exp operator< (\n        const matrix_exp& m,\n        const S& s\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (m(r,c) < s) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <typename S>\n    const matrix_exp operator< (\n        const S& s,\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (s < m(r,c)) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <typename S>\n    const matrix_exp operator<= (\n        const matrix_exp& m,\n        const S& s\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (m(r,c) <= s) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <typename S>\n    const matrix_exp operator<= (\n        const S& s,\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (s <= m(r,c)) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <typename S>\n    const matrix_exp operator> (\n        const matrix_exp& m,\n        const S& s\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (m(r,c) > s) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <typename S>\n    const matrix_exp operator> (\n        const S& s,\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (s > m(r,c)) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <typename S>\n    const matrix_exp operator>= (\n        const matrix_exp& m,\n        const S& s\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (m(r,c) >= s) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <typename S>\n    const matrix_exp operator>= (\n        const S& s,\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (s >= m(r,c)) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <typename S>\n    const matrix_exp operator== (\n        const matrix_exp& m,\n        const S& s\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (m(r,c) == s) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <typename S>\n    const matrix_exp operator== (\n        const S& s,\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (s == m(r,c)) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <typename S>\n    const matrix_exp operator!= (\n        const matrix_exp& m,\n        const S& s\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (m(r,c) != s) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <typename S>\n    const matrix_exp operator!= (\n        const S& s,\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (s != m(r,c)) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------\n//                              Statistics\n// ----------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp::type min (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.size() > 0\n        ensures\n            - returns the value of the smallest element of m.  If m contains complex\n              elements then the element returned is the one with the smallest norm\n              according to std::norm().\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp::type max (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.size() > 0\n        ensures\n            - returns the value of the biggest element of m.  If m contains complex\n              elements then the element returned is the one with the largest norm\n              according to std::norm().\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    void find_min_and_max (\n        const matrix_exp& m,\n        matrix_exp::type& min_val,\n        matrix_exp::type& max_val\n    );\n    /*!\n        requires\n            - m.size() > 0\n        ensures\n            - #min_val == min(m)\n            - #max_val == max(m)\n            - This function computes both the min and max in just one pass\n              over the elements of the matrix m.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    long index_of_max (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_vector(m) == true\n            - m.size() > 0 \n        ensures\n            - returns the index of the largest element in m.  \n              (i.e. m(index_of_max(m)) == max(m))\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    long index_of_min (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_vector(m) == true\n            - m.size() > 0 \n        ensures\n            - returns the index of the smallest element in m.  \n              (i.e. m(index_of_min(m)) == min(m))\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    point max_point (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.size() > 0\n        ensures\n            - returns the location of the maximum element of the array, that is, if the\n              returned point is P then it will be the case that: m(P.y(),P.x()) == max(m).\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    dlib::vector<double,2> max_point_interpolated (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.size() > 0\n        ensures\n            - Like max_point(), this function finds the location in m with the largest\n              value.  However, we additionally use some quadratic interpolation to find the\n              location of the maximum point with sub-pixel accuracy.  Therefore, the\n              returned point is equal to max_point(m) + some small sub-pixel delta.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    point min_point (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.size() > 0\n        ensures\n            - returns the location of the minimum element of the array, that is, if the\n              returned point is P then it will be the case that: m(P.y(),P.x()) == min(m).\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp::type sum (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns the sum of all elements in m\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp sum_rows (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.size() > 0\n        ensures\n            - returns a row matrix that contains the sum of all the rows in m. \n            - returns a matrix M such that\n                - M::type == the same type that was in m\n                - M.nr() == 1\n                - M.nc() == m.nc()\n                - for all valid i:\n                    - M(i) == sum(colm(m,i)) \n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp sum_cols (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.size() > 0\n        ensures\n            - returns a column matrix that contains the sum of all the columns in m. \n            - returns a matrix M such that\n                - M::type == the same type that was in m\n                - M.nr() == m.nr() \n                - M.nc() == 1\n                - for all valid i:\n                    - M(i) == sum(rowm(m,i)) \n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp::type prod (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns the results of multiplying all elements of m together. \n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp::type mean (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns the mean of all elements in m. \n              (i.e. returns sum(m)/(m.nr()*m.nc()))\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp::type variance (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns the unbiased sample variance of all elements in m \n              (i.e. 1.0/(m.nr()*m.nc() - 1)*(sum of all pow(m(i,j) - mean(m),2)))\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp::type stddev (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns sqrt(variance(m))\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix covariance (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - matrix_exp::type == a dlib::matrix object\n            - is_col_vector(m) == true\n            - m.size() > 1\n            - for all valid i, j:\n                - is_col_vector(m(i)) == true \n                - m(i).size() > 0\n                - m(i).size() == m(j).size() \n                - i.e. m contains only column vectors and all the column vectors\n                  have the same non-zero length\n        ensures\n            - returns the unbiased sample covariance matrix for the set of samples\n              in m.  \n              (i.e. 1.0/(m.nr()-1)*(sum of all (m(i) - mean(m))*trans(m(i) - mean(m))))\n            - the returned matrix will contain elements of type matrix_exp::type::type.\n            - the returned matrix will have m(0).nr() rows and columns.\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <typename rand_gen>\n    const matrix<double> randm( \n        long nr,\n        long nc,\n        rand_gen& rnd\n    );\n    /*!\n        requires\n            - nr >= 0\n            - nc >= 0\n            - rand_gen == an object that implements the rand/rand_float_abstract.h interface\n        ensures\n            - generates a random matrix using the given rnd random number generator\n            - returns a matrix M such that\n                - M::type == double\n                - M.nr() == nr\n                - M.nc() == nc\n                - for all valid i, j:\n                    - M(i,j) == a random number such that 0 <= M(i,j) < 1\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    inline const matrix<double> randm( \n        long nr,\n        long nc\n    );\n    /*!\n        requires\n            - nr >= 0\n            - nc >= 0\n        ensures\n            - generates a random matrix using std::rand() \n            - returns a matrix M such that\n                - M::type == double\n                - M.nr() == nr\n                - M.nc() == nc\n                - for all valid i, j:\n                    - M(i,j) == a random number such that 0 <= M(i,j) < 1\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    inline const matrix_exp gaussian_randm (\n        long nr,\n        long nc,\n        unsigned long seed = 0\n    );\n    /*!\n        requires\n            - nr >= 0\n            - nc >= 0\n        ensures\n            - returns a matrix with its values filled with 0 mean unit variance Gaussian\n              random numbers.  \n            - Each setting of the seed results in a different random matrix.\n            - The returned matrix is lazily evaluated using the expression templates\n              technique.  This means that the returned matrix doesn't take up any memory\n              and is only an expression template.  The values themselves are computed on\n              demand using the gaussian_random_hash() routine.  \n            - returns a matrix M such that\n                - M::type == double\n                - M.nr() == nr\n                - M.nc() == nc\n                - for all valid i, j:\n                    - M(i,j) == gaussian_random_hash(i,j,seed) \n    !*/\n\n// ----------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------\n//                                 Pixel and Image Utilities\n// ----------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------\n\n    template <\n        typename T,\n        typename P\n        >\n    const matrix<T,pixel_traits<P>::num,1> pixel_to_vector (\n        const P& pixel\n    );\n    /*!\n        requires\n            - pixel_traits<P> must be defined\n        ensures\n            - returns a matrix M such that:\n                - M::type == T\n                - M::NC == 1 \n                - M::NR == pixel_traits<P>::num\n                - if (pixel_traits<P>::grayscale) then\n                    - M(0) == pixel \n                - if (pixel_traits<P>::rgb) then\n                    - M(0) == pixel.red \n                    - M(1) == pixel.green \n                    - M(2) == pixel.blue \n                - if (pixel_traits<P>::hsi) then\n                    - M(0) == pixel.h \n                    - M(1) == pixel.s \n                    - M(2) == pixel.i \n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <\n        typename P\n        >\n    void vector_to_pixel (\n        P& pixel,\n        const matrix_exp& vector \n    );\n    /*!\n        requires\n            - vector::NR == pixel_traits<P>::num\n            - vector::NC == 1 \n              (i.e. you have to use a statically dimensioned vector)\n        ensures\n            - if (pixel_traits<P>::grayscale) then\n                - pixel == M(0) \n            - if (pixel_traits<P>::rgb) then\n                - pixel.red   == M(0)  \n                - pixel.green == M(1) \n                - pixel.blue  == M(2)  \n            - if (pixel_traits<P>::hsi) then\n                - pixel.h == M(0)\n                - pixel.s == M(1)\n                - pixel.i == M(2)\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    template <\n        long lower,\n        long upper \n        >\n    const matrix_exp clamp (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m\n                - R has the same dimensions as m\n                - for all valid r and c:\n                    - if (m(r,c) > upper) then\n                        - R(r,c) == upper\n                    - else if (m(r,c) < lower) then\n                        - R(r,c) == lower\n                    - else\n                        - R(r,c) == m(r,c)\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp clamp (\n        const matrix_exp& m,\n        const matrix_exp::type& lower,\n        const matrix_exp::type& upper\n    );\n    /*!\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m\n                - R has the same dimensions as m\n                - for all valid r and c:\n                    - if (m(r,c) > upper) then\n                        - R(r,c) == upper\n                    - else if (m(r,c) < lower) then\n                        - R(r,c) == lower\n                    - else\n                        - R(r,c) == m(r,c)\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp clamp (\n        const matrix_exp& m,\n        const matrix_exp& lower,\n        const matrix_exp& upper\n    );\n    /*!\n        requires\n            - m.nr() == lower.nr()\n            - m.nc() == lower.nc()\n            - m.nr() == upper.nr()\n            - m.nc() == upper.nc()\n            - m, lower, and upper all contain the same type of elements. \n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m\n                - R has the same dimensions as m\n                - for all valid r and c:\n                    - if (m(r,c) > upper(r,c)) then\n                        - R(r,c) == upper(r,c)\n                    - else if (m(r,c) < lower(r,c)) then\n                        - R(r,c) == lower(r,c)\n                    - else\n                        - R(r,c) == m(r,c)\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp lowerbound (\n        const matrix_exp& m,\n        const matrix_exp::type& thresh \n    );\n    /*!\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m\n                - R has the same dimensions as m\n                - for all valid r and c:\n                    - if (m(r,c) >= thresh) then\n                        - R(r,c) == m(r,c)\n                    - else\n                        - R(r,c) == thresh\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n    const matrix_exp upperbound (\n        const matrix_exp& m,\n        const matrix_exp::type& thresh \n    );\n    /*!\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m\n                - R has the same dimensions as m\n                - for all valid r and c:\n                    - if (m(r,c) <= thresh) then\n                        - R(r,c) == m(r,c)\n                    - else\n                        - R(r,c) == thresh\n    !*/\n\n// ----------------------------------------------------------------------------------------\n\n}", "item_id": 0, "repo": "yatonon/dlib-face", "file": "dlib/matrix/matrix_utilities_abstract.h", "last_update_at": "2022-03-30T02:18:24+00:00", "question_id": "23963e9ef99b6c5865a9b907b3abd5b6ae63f87b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace dlib\n{\n// ----------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------\n//                                   Simple matrix utilities \n// ----------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------\n    const matrix_exp diag (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns a column vector R that contains the elements from the diagonal \n              of m in the order R(0)==m(0,0), R(1)==m(1,1), R(2)==m(2,2) and so on.\n    !*/\n    template <typename EXP>\n    struct diag_exp\n    {\n        /*!\n            WHAT THIS OBJECT REPRESENTS\n                This struct allows you to determine the type of matrix expression \n                object returned from the diag() function.  An example makes its\n                use clear:\n                template <typename EXP>\n                void do_something( const matrix_exp<EXP>& mat)\n                {\n                    // d is a matrix expression that aliases mat.\n                    typename diag_exp<EXP>::type d = diag(mat);\n                    // Print the diagonal of mat.  So we see that by using\n                    // diag_exp we can save the object returned by diag() in\n                    // a local variable.    \n                    cout << d << endl;\n                    // Note that you can only save the return value of diag() to\n                    // a local variable if the argument to diag() has a lifetime\n                    // beyond the diag() expression.  The example shown above is\n                    // OK but the following would result in undefined behavior:\n                    typename diag_exp<EXP>::type bad = diag(mat + mat);\n                }\n        !*/\n        typedef type_of_expression_returned_by_diag type;\n    };\n// ----------------------------------------------------------------------------------------\n    const matrix_exp diagm (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_vector(m) == true\n              (i.e. m is a row or column matrix)\n        ensures\n            - returns a square matrix M such that:\n                - diag(M) == m\n                - non diagonal elements of M are 0\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp trans (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns the transpose of the matrix m\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_type::type dot (\n        const matrix_exp& m1,\n        const matrix_exp& m2\n    );\n    /*!\n        requires\n            - is_vector(m1) == true\n            - is_vector(m2) == true\n            - m1.size() == m2.size()\n            - m1.size() > 0\n        ensures\n            - returns the dot product between m1 and m2. That is, this function \n              computes and returns the sum, for all i, of m1(i)*m2(i).\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp lowerm (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns a matrix M such that:\n                - M::type == the same type that was in m\n                - M has the same dimensions as m\n                - M is the lower triangular part of m.  That is:\n                    - if (r >= c) then\n                        - M(r,c) == m(r,c)\n                    - else\n                        - M(r,c) == 0\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp lowerm (\n        const matrix_exp& m,\n        const matrix_exp::type scalar_value\n    );\n    /*!\n        ensures\n            - returns a matrix M such that:\n                - M::type == the same type that was in m\n                - M has the same dimensions as m\n                - M is the lower triangular part of m except that the diagonal has\n                  been set to scalar_value.  That is:\n                    - if (r > c) then\n                        - M(r,c) == m(r,c)\n                    - else if (r == c) then\n                        - M(r,c) == scalar_value \n                    - else\n                        - M(r,c) == 0\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp upperm (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns a matrix M such that:\n                - M::type == the same type that was in m\n                - M has the same dimensions as m\n                - M is the upper triangular part of m.  That is:\n                    - if (r <= c) then\n                        - M(r,c) == m(r,c)\n                    - else\n                        - M(r,c) == 0\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp upperm (\n        const matrix_exp& m,\n        const matrix_exp::type scalar_value\n    );\n    /*!\n        ensures\n            - returns a matrix M such that:\n                - M::type == the same type that was in m\n                - M has the same dimensions as m\n                - M is the upper triangular part of m except that the diagonal has\n                  been set to scalar_value.  That is:\n                    - if (r < c) then\n                        - M(r,c) == m(r,c)\n                    - else if (r == c) then\n                        - M(r,c) == scalar_value \n                    - else\n                        - M(r,c) == 0\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp make_symmetric (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.nr() == m.nc()\n              (i.e. m must be a square matrix)\n        ensures\n            - returns a matrix M such that:\n                - M::type == the same type that was in m\n                - M has the same dimensions as m\n                - M is a symmetric matrix, that is, M == trans(M) and\n                  it is constructed from the lower triangular part of m.  Specifically,\n                  we have:\n                    - lowerm(M) == lowerm(m)\n                    - upperm(M) == trans(lowerm(m))\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <\n        typename T, \n        long NR, \n        long NC, \n        T val\n        >\n    const matrix_exp uniform_matrix (\n    );\n    /*!\n        requires\n            - NR > 0 && NC > 0\n        ensures\n            - returns an NR by NC matrix with elements of type T and all set to val.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <\n        typename T,\n        long NR, \n        long NC\n        >\n    const matrix_exp uniform_matrix (\n        const T& val\n    );\n    /*!\n        requires\n            - NR > 0 && NC > 0\n        ensures\n            - returns an NR by NC matrix with elements of type T and all set to val.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <\n        typename T\n        >\n    const matrix_exp uniform_matrix (\n        long nr,\n        long nc,\n        const T& val\n    );\n    /*!\n        requires\n            - nr >= 0 && nc >= 0\n        ensures\n            - returns an nr by nc matrix with elements of type T and all set to val.\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp ones_matrix (\n        const matrix_exp& mat\n    );\n    /*!\n        requires\n            - mat.nr() >= 0 && mat.nc() >= 0\n        ensures\n            - Let T denote the type of element in mat. Then this function\n              returns uniform_matrix<T>(mat.nr(), mat.nc(), 1)\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <\n        typename T\n        >\n    const matrix_exp ones_matrix (\n        long nr,\n        long nc\n    );\n    /*!\n        requires\n            - nr >= 0 && nc >= 0\n        ensures\n            - returns uniform_matrix<T>(nr, nc, 1)\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp zeros_matrix (\n        const matrix_exp& mat\n    );\n    /*!\n        requires\n            - mat.nr() >= 0 && mat.nc() >= 0\n        ensures\n            - Let T denote the type of element in mat. Then this function\n              returns uniform_matrix<T>(mat.nr(), mat.nc(), 0)\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <\n        typename T\n        >\n    const matrix_exp zeros_matrix (\n        long nr,\n        long nc\n    );\n    /*!\n        requires\n            - nr >= 0 && nc >= 0\n        ensures\n            - returns uniform_matrix<T>(nr, nc, 0)\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp identity_matrix (\n        const matrix_exp& mat\n    );\n    /*!\n        requires\n            - mat.nr() == mat.nc()\n        ensures\n            - returns an identity matrix with the same dimensions as mat and\n              containing the same type of elements as mat.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <\n        typename T\n        >\n    const matrix_exp identity_matrix (\n        long N\n    );\n    /*!\n        requires\n            - N > 0\n        ensures\n            - returns an N by N identity matrix with elements of type T.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <\n        typename T, \n        long N\n        >\n    const matrix_exp identity_matrix (\n    );\n    /*!\n        requires\n            - N > 0\n        ensures\n            - returns an N by N identity matrix with elements of type T.\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp linspace (\n        double start,\n        double end,\n        long num\n    );\n    /*!\n        requires\n            - num >= 0\n        ensures\n            - returns a matrix M such that:\n                - M::type == double \n                - is_row_vector(M) == true\n                - M.size() == num\n                - M == a row vector with num linearly spaced values beginning with start\n                  and stopping with end.  \n                - M(num-1) == end \n                - if (num > 1) then\n                    - M(0) == start\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp logspace (\n        double start,\n        double end,\n        long num\n    );\n    /*!\n        requires\n            - num >= 0\n        ensures\n            - returns a matrix M such that:\n                - M::type == double \n                - is_row_vector(M) == true\n                - M.size() == num\n                - M == a row vector with num logarithmically spaced values beginning with \n                  10^start and stopping with 10^end.  \n                  (i.e. M == pow(10, linspace(start, end, num)))\n                - M(num-1) == 10^end\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp linpiece (\n        const double val,\n        const matrix_exp& joints\n    );\n    /*!\n        requires\n            - is_vector(joints) == true\n            - joints.size() >= 2\n            - for all valid i < j:\n                - joints(i) < joints(j)\n        ensures\n            - linpiece() is useful for creating piecewise linear functions of val.  For\n              example, if w is a parameter vector then you can represent a piecewise linear\n              function of val as: f(val) = dot(w, linpiece(val, linspace(0,100,5))).  In\n              this case, f(val) is piecewise linear on the intervals [0,25], [25,50],\n              [50,75], [75,100].  Moreover, w(i) defines the derivative of f(val) in the\n              i-th interval.  Finally, outside the interval [0,100] f(val) has a derivative\n              of zero and f(0) == 0.\n            - To be precise, this function returns a column vector L such that:\n                - L.size() == joints.size()-1\n                - is_col_vector(L) == true\n                - L contains the same type of elements as joints.\n                - for all valid i:\n                - if (joints(i) < val)\n                    - L(i) == min(val,joints(i+1)) - joints(i)\n                - else\n                    - L(i) == 0\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <\n        long R,\n        long C\n        >\n    const matrix_exp rotate (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m\n                - R has the same dimensions as m\n                - for all valid r and c:\n                  R( (r+R)%m.nr() , (c+C)%m.nc() ) == m(r,c)\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp fliplr (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - flips the matrix m from left to right and returns the result.  \n              I.e. reverses the order of the columns.\n            - returns a matrix M such that:\n                - M::type == the same type that was in m\n                - M has the same dimensions as m\n                - for all valid r and c:\n                  M(r,c) == m(r, m.nc()-c-1)\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp flipud (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - flips the matrix m from up to down and returns the result.  \n              I.e. reverses the order of the rows.\n            - returns a matrix M such that:\n                - M::type == the same type that was in m\n                - M has the same dimensions as m\n                - for all valid r and c:\n                  M(r,c) == m(m.nr()-r-1, c)\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp flip (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - flips the matrix m from up to down and left to right and returns the \n              result.  I.e. returns flipud(fliplr(m)).\n            - returns a matrix M such that:\n                - M::type == the same type that was in m\n                - M has the same dimensions as m\n                - for all valid r and c:\n                  M(r,c) == m(m.nr()-r-1, m.nc()-c-1)\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp reshape (\n        const matrix_exp& m,\n        long rows,\n        long cols\n    );\n    /*!\n        requires\n            - m.size() == rows*cols\n            - rows > 0\n            - cols > 0\n        ensures\n            - returns a matrix M such that: \n                - M.nr() == rows\n                - M.nc() == cols\n                - M.size() == m.size()\n                - for all valid r and c:\n                    - let IDX = r*cols + c\n                    - M(r,c) == m(IDX/m.nc(), IDX%m.nc())\n            - i.e. The matrix m is reshaped into a new matrix of rows by cols\n              dimension.  Additionally, the elements of m are laid into M in row major \n              order.\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp reshape_to_column_vector (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns a matrix M such that: \n                - is_col_vector(M) == true\n                - M.size() == m.size()\n                - for all valid r and c:\n                    - m(r,c) == M(r*m.nc() + c)\n            - i.e. The matrix m is reshaped into a column vector.  Note that\n              the elements are pulled out in row major order.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <\n        long R,\n        long C\n        >\n    const matrix_exp removerc (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.nr() > R >= 0\n            - m.nc() > C >= 0\n        ensures\n            - returns a matrix M such that:\n                - M.nr() == m.nr() - 1\n                - M.nc() == m.nc() - 1\n                - M == m with its R row and C column removed\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp removerc (\n        const matrix_exp& m,\n        long R,\n        long C\n    );\n    /*!\n        requires\n            - m.nr() > R >= 0\n            - m.nc() > C >= 0\n        ensures\n            - returns a matrix M such that:\n                - M.nr() == m.nr() - 1\n                - M.nc() == m.nc() - 1\n                - M == m with its R row and C column removed\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <\n        long R\n        >\n    const matrix_exp remove_row (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.nr() > R >= 0\n        ensures\n            - returns a matrix M such that:\n                - M.nr() == m.nr() - 1\n                - M.nc() == m.nc() \n                - M == m with its R row removed\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp remove_row (\n        const matrix_exp& m,\n        long R\n    );\n    /*!\n        requires\n            - m.nr() > R >= 0\n        ensures\n            - returns a matrix M such that:\n                - M.nr() == m.nr() - 1\n                - M.nc() == m.nc() \n                - M == m with its R row removed\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <\n        long C\n        >\n    const matrix_exp remove_col (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.nc() > C >= 0\n        ensures\n            - returns a matrix M such that:\n                - M.nr() == m.nr() \n                - M.nc() == m.nc() - 1 \n                - M == m with its C column removed\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp remove_col (\n        const matrix_exp& m,\n        long C\n    );\n    /*!\n        requires\n            - m.nc() > C >= 0\n        ensures\n            - returns a matrix M such that:\n                - M.nr() == m.nr() \n                - M.nc() == m.nc() - 1 \n                - M == m with its C column removed\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <\n       typename target_type\n       >\n    const matrix_exp matrix_cast (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns a matrix R where for all valid r and c:\n              R(r,c) == static_cast<target_type>(m(r,c))\n              also, R has the same dimensions as m.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <\n        typename T,\n        long NR,\n        long NC,\n        typename MM,\n        typename U,\n        typename L\n        >\n    void set_all_elements (\n        matrix<T,NR,NC,MM,L>& m,\n        U value\n    );\n    /*!\n        ensures\n            - for all valid r and c:\n              m(r,c) == value\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp::matrix_type tmp (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns a temporary matrix object that is a copy of m. \n              (This allows you to easily force a matrix_exp to fully evaluate)\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <\n        typename T, \n        long NR, \n        long NC, \n        typename MM, \n        typename L\n        >\n    uint32 hash (\n        const matrix<T,NR,NC,MM,L>& item,\n        uint32 seed = 0\n    );\n    /*!\n        requires\n            - T is a standard layout type (e.g. a POD type like int, float, \n              or a simple struct).\n        ensures\n            - returns a 32bit hash of the data stored in item.  \n            - Each value of seed results in a different hash function being used.  \n              (e.g. hash(item,0) should generally not be equal to hash(item,1))\n            - uses the murmur_hash3() routine to compute the actual hash.\n            - Note that if the memory layout of the elements in item change between\n              hardware platforms then hash() will give different outputs.  If you want\n              hash() to always give the same output for the same input then you must \n              ensure that elements of item always have the same layout in memory.\n              Typically this means using fixed width types and performing byte swapping\n              to account for endianness before passing item to hash().\n    !*/\n// ----------------------------------------------------------------------------------------\n    // if matrix_exp contains non-complex types (e.g. float, double)\n    bool equal (\n        const matrix_exp& a,\n        const matrix_exp& b,\n        const matrix_exp::type epsilon = 100*std::numeric_limits<matrix_exp::type>::epsilon()\n    );\n    /*!\n        ensures\n            - if (a and b don't have the same dimensions) then\n                - returns false\n            - else if (there exists an r and c such that abs(a(r,c)-b(r,c)) > epsilon) then\n                - returns false\n            - else\n                - returns true\n    !*/\n// ----------------------------------------------------------------------------------------\n    // if matrix_exp contains std::complex types \n    bool equal (\n        const matrix_exp& a,\n        const matrix_exp& b,\n        const matrix_exp::type::value_type epsilon = 100*std::numeric_limits<matrix_exp::type::value_type>::epsilon()\n    );\n    /*!\n        ensures\n            - if (a and b don't have the same dimensions) then\n                - returns false\n            - else if (there exists an r and c such that abs(real(a(r,c)-b(r,c))) > epsilon \n              or abs(imag(a(r,c)-b(r,c))) > epsilon) then\n                - returns false\n            - else\n                - returns true\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp pointwise_multiply (\n        const matrix_exp& a,\n        const matrix_exp& b \n    );\n    /*!\n        requires\n            - a.nr() == b.nr()\n            - a.nc() == b.nc()\n            - a and b both contain the same type of element (one or both\n              can also be of type std::complex so long as the underlying type\n              in them is the same)\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in a and b.\n                - R has the same dimensions as a and b. \n                - for all valid r and c:\n                  R(r,c) == a(r,c) * b(r,c)\n    !*/\n    const matrix_exp pointwise_multiply (\n        const matrix_exp& a,\n        const matrix_exp& b,\n        const matrix_exp& c \n    );\n    /*!\n        performs pointwise_multiply(a,pointwise_multiply(b,c));\n    !*/\n    const matrix_exp pointwise_multiply (\n        const matrix_exp& a,\n        const matrix_exp& b,\n        const matrix_exp& c,\n        const matrix_exp& d \n    );\n    /*!\n        performs pointwise_multiply(pointwise_multiply(a,b),pointwise_multiply(c,d));\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp join_rows (\n        const matrix_exp& a,\n        const matrix_exp& b \n    );\n    /*!\n        requires\n            - a.nr() == b.nr() || a.size() == 0 || b.size() == 0\n            - a and b both contain the same type of element\n        ensures\n            - This function joins two matrices together by concatenating their rows.\n            - returns a matrix R such that:\n                - R::type == the same type that was in a and b.\n                - R.nr() == a.nr() == b.nr()\n                - R.nc() == a.nc() + b.nc()\n                - for all valid r and c:\n                    - if (c < a.nc()) then\n                        - R(r,c) == a(r,c) \n                    - else\n                        - R(r,c) == b(r, c-a.nc()) \n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp join_cols (\n        const matrix_exp& a,\n        const matrix_exp& b \n    );\n    /*!\n        requires\n            - a.nc() == b.nc() || a.size() == 0 || b.size() == 0\n            - a and b both contain the same type of element\n        ensures\n            - This function joins two matrices together by concatenating their columns.\n            - returns a matrix R such that:\n                - R::type == the same type that was in a and b.\n                - R.nr() == a.nr() + b.nr()\n                - R.nc() == a.nc() == b.nc()\n                - for all valid r and c:\n                    - if (r < a.nr()) then\n                        - R(r,c) == a(r,c) \n                    - else\n                        - R(r,c) == b(r-a.nr(), c) \n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp tensor_product (\n        const matrix_exp& a,\n        const matrix_exp& b \n    );\n    /*!\n        requires\n            - a and b both contain the same type of element\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in a and b.\n                - R.nr() == a.nr() * b.nr()  \n                - R.nc() == a.nc() * b.nc()  \n                - for all valid r and c:\n                  R(r,c) == a(r/b.nr(), c/b.nc()) * b(r%b.nr(), c%b.nc())\n                - I.e. R is the tensor product of matrix a with matrix b\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp cartesian_product (\n        const matrix_exp& A,\n        const matrix_exp& B \n    );\n    /*!\n        requires\n            - A and B both contain the same type of element\n        ensures\n            - Think of A and B as sets of column vectors.  Then this function \n              returns a matrix that contains a set of column vectors that is\n              the Cartesian product of the sets A and B.  That is, the resulting\n              matrix contains every possible combination of vectors from both A and\n              B.\n            - returns a matrix R such that:\n                - R::type == the same type that was in A and B.\n                - R.nr() == A.nr() + B.nr()  \n                - R.nc() == A.nc() * B.nc()  \n                - Each column of R is the concatenation of a column vector\n                  from A with a column vector from B.  \n                - for all valid r and c:\n                    - if (r < A.nr()) then\n                        - R(r,c) == A(r, c/B.nc())\n                    - else\n                        - R(r,c) == B(r-A.nr(), c%B.nc())\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp scale_columns (\n        const matrix_exp& m,\n        const matrix_exp& v\n    );\n    /*!\n        requires\n            - is_vector(v) == true\n            - v.size() == m.nc()\n            - m and v both contain the same type of element\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m and v.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                  R(r,c) == m(r,c) * v(c)\n                - i.e. R is the result of multiplying each of m's columns by\n                  the corresponding scalar in v.\n            - Note that this function is identical to the expression m*diagm(v).  \n              That is, the * operator is overloaded for this case and will invoke\n              scale_columns() automatically as appropriate.\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp scale_rows (\n        const matrix_exp& m,\n        const matrix_exp& v\n    );\n    /*!\n        requires\n            - is_vector(v) == true\n            - v.size() == m.nr()\n            - m and v both contain the same type of element\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m and v.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                  R(r,c) == m(r,c) * v(r)\n                - i.e. R is the result of multiplying each of m's rows by\n                  the corresponding scalar in v.\n            - Note that this function is identical to the expression diagm(v)*m.  \n              That is, the * operator is overloaded for this case and will invoke\n              scale_rows() automatically as appropriate.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <typename T>\n    void sort_columns (\n        matrix<T>& m,\n        matrix<T>& v\n    );\n    /*!\n        requires\n            - is_col_vector(v) == true\n            - v.size() == m.nc()\n            - m and v both contain the same type of element\n        ensures\n            - the dimensions for m and v are not changed\n            - sorts the columns of m according to the values in v.\n              i.e. \n                - #v == the contents of v but in sorted order according to\n                  operator<.  So smaller elements come first.\n                - Let #v(new(i)) == v(i) (i.e. new(i) is the index element i moved to)\n                - colm(#m,new(i)) == colm(m,i) \n    !*/\n// ----------------------------------------------------------------------------------------\n    template <typename T>\n    void rsort_columns (\n        matrix<T>& m,\n        matrix<T>& v\n    );\n    /*!\n        requires\n            - is_col_vector(v) == true\n            - v.size() == m.nc()\n            - m and v both contain the same type of element\n        ensures\n            - the dimensions for m and v are not changed\n            - sorts the columns of m according to the values in v.\n              i.e. \n                - #v == the contents of v but in sorted order according to\n                  operator>.  So larger elements come first.\n                - Let #v(new(i)) == v(i) (i.e. new(i) is the index element i moved to)\n                - colm(#m,new(i)) == colm(m,i) \n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp::type length_squared (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_vector(m) == true\n        ensures\n            - returns sum(squared(m))\n              (i.e. returns the square of the length of the vector m)\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp::type length (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_vector(m) == true\n        ensures\n            - returns sqrt(sum(squared(m)))\n              (i.e. returns the length of the vector m)\n            - if (m contains integer valued elements) then  \n                - The return type is a double that represents the length.  Therefore, the\n                  return value of length() is always represented using a floating point\n                  type. \n    !*/\n// ----------------------------------------------------------------------------------------\n    bool is_row_vector (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - if (m.nr() == 1) then\n                - return true\n            - else\n                - returns false\n    !*/\n    bool is_col_vector (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - if (m.nc() == 1) then\n                - return true\n            - else\n                - returns false\n    !*/\n    bool is_vector (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - if (is_row_vector(m) || is_col_vector(m)) then\n                - return true\n            - else\n                - returns false\n    !*/\n// ----------------------------------------------------------------------------------------\n    bool is_finite (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns true if all the values in m are finite values and also not any kind\n              of NaN value.\n    !*/\n// ----------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------\n//                      Thresholding relational operators \n// ----------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------\n    template <typename S>\n    const matrix_exp operator< (\n        const matrix_exp& m,\n        const S& s\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (m(r,c) < s) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <typename S>\n    const matrix_exp operator< (\n        const S& s,\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (s < m(r,c)) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <typename S>\n    const matrix_exp operator<= (\n        const matrix_exp& m,\n        const S& s\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (m(r,c) <= s) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <typename S>\n    const matrix_exp operator<= (\n        const S& s,\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (s <= m(r,c)) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <typename S>\n    const matrix_exp operator> (\n        const matrix_exp& m,\n        const S& s\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (m(r,c) > s) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <typename S>\n    const matrix_exp operator> (\n        const S& s,\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (s > m(r,c)) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <typename S>\n    const matrix_exp operator>= (\n        const matrix_exp& m,\n        const S& s\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (m(r,c) >= s) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <typename S>\n    const matrix_exp operator>= (\n        const S& s,\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (s >= m(r,c)) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <typename S>\n    const matrix_exp operator== (\n        const matrix_exp& m,\n        const S& s\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (m(r,c) == s) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <typename S>\n    const matrix_exp operator== (\n        const S& s,\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (s == m(r,c)) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <typename S>\n    const matrix_exp operator!= (\n        const matrix_exp& m,\n        const S& s\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (m(r,c) != s) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <typename S>\n    const matrix_exp operator!= (\n        const S& s,\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_built_in_scalar_type<S>::value == true \n            - is_built_in_scalar_type<matrix_exp::type>::value == true\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m.\n                - R has the same dimensions as m. \n                - for all valid r and c:\n                    - if (s != m(r,c)) then\n                        - R(r,c) == 1\n                    - else\n                        - R(r,c) == 0\n                - i.e. R is a binary matrix of all 1s or 0s.\n    !*/\n// ----------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------\n//                              Statistics\n// ----------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------\n    const matrix_exp::type min (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.size() > 0\n        ensures\n            - returns the value of the smallest element of m.  If m contains complex\n              elements then the element returned is the one with the smallest norm\n              according to std::norm().\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp::type max (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.size() > 0\n        ensures\n            - returns the value of the biggest element of m.  If m contains complex\n              elements then the element returned is the one with the largest norm\n              according to std::norm().\n    !*/\n// ----------------------------------------------------------------------------------------\n    void find_min_and_max (\n        const matrix_exp& m,\n        matrix_exp::type& min_val,\n        matrix_exp::type& max_val\n    );\n    /*!\n        requires\n            - m.size() > 0\n        ensures\n            - #min_val == min(m)\n            - #max_val == max(m)\n            - This function computes both the min and max in just one pass\n              over the elements of the matrix m.\n    !*/\n// ----------------------------------------------------------------------------------------\n    long index_of_max (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_vector(m) == true\n            - m.size() > 0 \n        ensures\n            - returns the index of the largest element in m.  \n              (i.e. m(index_of_max(m)) == max(m))\n    !*/\n// ----------------------------------------------------------------------------------------\n    long index_of_min (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - is_vector(m) == true\n            - m.size() > 0 \n        ensures\n            - returns the index of the smallest element in m.  \n              (i.e. m(index_of_min(m)) == min(m))\n    !*/\n// ----------------------------------------------------------------------------------------\n    point max_point (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.size() > 0\n        ensures\n            - returns the location of the maximum element of the array, that is, if the\n              returned point is P then it will be the case that: m(P.y(),P.x()) == max(m).\n    !*/\n// ----------------------------------------------------------------------------------------\n    dlib::vector<double,2> max_point_interpolated (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.size() > 0\n        ensures\n            - Like max_point(), this function finds the location in m with the largest\n              value.  However, we additionally use some quadratic interpolation to find the\n              location of the maximum point with sub-pixel accuracy.  Therefore, the\n              returned point is equal to max_point(m) + some small sub-pixel delta.\n    !*/\n// ----------------------------------------------------------------------------------------\n    point min_point (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.size() > 0\n        ensures\n            - returns the location of the minimum element of the array, that is, if the\n              returned point is P then it will be the case that: m(P.y(),P.x()) == min(m).\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp::type sum (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns the sum of all elements in m\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp sum_rows (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.size() > 0\n        ensures\n            - returns a row matrix that contains the sum of all the rows in m. \n            - returns a matrix M such that\n                - M::type == the same type that was in m\n                - M.nr() == 1\n                - M.nc() == m.nc()\n                - for all valid i:\n                    - M(i) == sum(colm(m,i)) \n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp sum_cols (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - m.size() > 0\n        ensures\n            - returns a column matrix that contains the sum of all the columns in m. \n            - returns a matrix M such that\n                - M::type == the same type that was in m\n                - M.nr() == m.nr() \n                - M.nc() == 1\n                - for all valid i:\n                    - M(i) == sum(rowm(m,i)) \n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp::type prod (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns the results of multiplying all elements of m together. \n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp::type mean (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns the mean of all elements in m. \n              (i.e. returns sum(m)/(m.nr()*m.nc()))\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp::type variance (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns the unbiased sample variance of all elements in m \n              (i.e. 1.0/(m.nr()*m.nc() - 1)*(sum of all pow(m(i,j) - mean(m),2)))\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp::type stddev (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns sqrt(variance(m))\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix covariance (\n        const matrix_exp& m\n    );\n    /*!\n        requires\n            - matrix_exp::type == a dlib::matrix object\n            - is_col_vector(m) == true\n            - m.size() > 1\n            - for all valid i, j:\n                - is_col_vector(m(i)) == true \n                - m(i).size() > 0\n                - m(i).size() == m(j).size() \n                - i.e. m contains only column vectors and all the column vectors\n                  have the same non-zero length\n        ensures\n            - returns the unbiased sample covariance matrix for the set of samples\n              in m.  \n              (i.e. 1.0/(m.nr()-1)*(sum of all (m(i) - mean(m))*trans(m(i) - mean(m))))\n            - the returned matrix will contain elements of type matrix_exp::type::type.\n            - the returned matrix will have m(0).nr() rows and columns.\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <typename rand_gen>\n    const matrix<double> randm( \n        long nr,\n        long nc,\n        rand_gen& rnd\n    );\n    /*!\n        requires\n            - nr >= 0\n            - nc >= 0\n            - rand_gen == an object that implements the rand/rand_float_abstract.h interface\n        ensures\n            - generates a random matrix using the given rnd random number generator\n            - returns a matrix M such that\n                - M::type == double\n                - M.nr() == nr\n                - M.nc() == nc\n                - for all valid i, j:\n                    - M(i,j) == a random number such that 0 <= M(i,j) < 1\n    !*/\n// ----------------------------------------------------------------------------------------\n    inline const matrix<double> randm( \n        long nr,\n        long nc\n    );\n    /*!\n        requires\n            - nr >= 0\n            - nc >= 0\n        ensures\n            - generates a random matrix using std::rand() \n            - returns a matrix M such that\n                - M::type == double\n                - M.nr() == nr\n                - M.nc() == nc\n                - for all valid i, j:\n                    - M(i,j) == a random number such that 0 <= M(i,j) < 1\n    !*/\n// ----------------------------------------------------------------------------------------\n    inline const matrix_exp gaussian_randm (\n        long nr,\n        long nc,\n        unsigned long seed = 0\n    );\n    /*!\n        requires\n            - nr >= 0\n            - nc >= 0\n        ensures\n            - returns a matrix with its values filled with 0 mean unit variance Gaussian\n              random numbers.  \n            - Each setting of the seed results in a different random matrix.\n            - The returned matrix is lazily evaluated using the expression templates\n              technique.  This means that the returned matrix doesn't take up any memory\n              and is only an expression template.  The values themselves are computed on\n              demand using the gaussian_random_hash() routine.  \n            - returns a matrix M such that\n                - M::type == double\n                - M.nr() == nr\n                - M.nc() == nc\n                - for all valid i, j:\n                    - M(i,j) == gaussian_random_hash(i,j,seed) \n    !*/\n// ----------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------\n//                                 Pixel and Image Utilities\n// ----------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------\n    template <\n        typename T,\n        typename P\n        >\n    const matrix<T,pixel_traits<P>::num,1> pixel_to_vector (\n        const P& pixel\n    );\n    /*!\n        requires\n            - pixel_traits<P> must be defined\n        ensures\n            - returns a matrix M such that:\n                - M::type == T\n                - M::NC == 1 \n                - M::NR == pixel_traits<P>::num\n                - if (pixel_traits<P>::grayscale) then\n                    - M(0) == pixel \n                - if (pixel_traits<P>::rgb) then\n                    - M(0) == pixel.red \n                    - M(1) == pixel.green \n                    - M(2) == pixel.blue \n                - if (pixel_traits<P>::hsi) then\n                    - M(0) == pixel.h \n                    - M(1) == pixel.s \n                    - M(2) == pixel.i \n    !*/\n// ----------------------------------------------------------------------------------------\n    template <\n        typename P\n        >\n    void vector_to_pixel (\n        P& pixel,\n        const matrix_exp& vector \n    );\n    /*!\n        requires\n            - vector::NR == pixel_traits<P>::num\n            - vector::NC == 1 \n              (i.e. you have to use a statically dimensioned vector)\n        ensures\n            - if (pixel_traits<P>::grayscale) then\n                - pixel == M(0) \n            - if (pixel_traits<P>::rgb) then\n                - pixel.red   == M(0)  \n                - pixel.green == M(1) \n                - pixel.blue  == M(2)  \n            - if (pixel_traits<P>::hsi) then\n                - pixel.h == M(0)\n                - pixel.s == M(1)\n                - pixel.i == M(2)\n    !*/\n// ----------------------------------------------------------------------------------------\n    template <\n        long lower,\n        long upper \n        >\n    const matrix_exp clamp (\n        const matrix_exp& m\n    );\n    /*!\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m\n                - R has the same dimensions as m\n                - for all valid r and c:\n                    - if (m(r,c) > upper) then\n                        - R(r,c) == upper\n                    - else if (m(r,c) < lower) then\n                        - R(r,c) == lower\n                    - else\n                        - R(r,c) == m(r,c)\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp clamp (\n        const matrix_exp& m,\n        const matrix_exp::type& lower,\n        const matrix_exp::type& upper\n    );\n    /*!\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m\n                - R has the same dimensions as m\n                - for all valid r and c:\n                    - if (m(r,c) > upper) then\n                        - R(r,c) == upper\n                    - else if (m(r,c) < lower) then\n                        - R(r,c) == lower\n                    - else\n                        - R(r,c) == m(r,c)\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp clamp (\n        const matrix_exp& m,\n        const matrix_exp& lower,\n        const matrix_exp& upper\n    );\n    /*!\n        requires\n            - m.nr() == lower.nr()\n            - m.nc() == lower.nc()\n            - m.nr() == upper.nr()\n            - m.nc() == upper.nc()\n            - m, lower, and upper all contain the same type of elements. \n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m\n                - R has the same dimensions as m\n                - for all valid r and c:\n                    - if (m(r,c) > upper(r,c)) then\n                        - R(r,c) == upper(r,c)\n                    - else if (m(r,c) < lower(r,c)) then\n                        - R(r,c) == lower(r,c)\n                    - else\n                        - R(r,c) == m(r,c)\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp lowerbound (\n        const matrix_exp& m,\n        const matrix_exp::type& thresh \n    );\n    /*!\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m\n                - R has the same dimensions as m\n                - for all valid r and c:\n                    - if (m(r,c) >= thresh) then\n                        - R(r,c) == m(r,c)\n                    - else\n                        - R(r,c) == thresh\n    !*/\n// ----------------------------------------------------------------------------------------\n    const matrix_exp upperbound (\n        const matrix_exp& m,\n        const matrix_exp::type& thresh \n    );\n    /*!\n        ensures\n            - returns a matrix R such that:\n                - R::type == the same type that was in m\n                - R has the same dimensions as m\n                - for all valid r and c:\n                    - if (m(r,c) <= thresh) then\n                        - R(r,c) == m(r,c)\n                    - else\n                        - R(r,c) == thresh\n    !*/\n// ----------------------------------------------------------------------------------------\n"]]}
{"hexsha": "7fce391818d30a183962b7888a8bfd275b10423c", "ext": "c", "lang": "C", "content": "static ssize_t fan_proc_write(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *pos)\n{\n\tstruct toshiba_acpi_dev *dev = PDE_DATA(file_inode(file));\n\tchar cmd[42];\n\tsize_t len;\n\tint value;\n\tu32 hci_result;\n\n\tlen = min(count, sizeof(cmd) - 1);\n\tif (copy_from_user(cmd, buf, len))\n\t\treturn -EFAULT;\n\tcmd[len] = '\\0';\n\n\tif (sscanf(cmd, \" force_on : %i\", &value) == 1 &&\n\t    value >= 0 && value <= 1) {\n\t\thci_write1(dev, HCI_FAN, value, &hci_result);\n\t\tif (hci_result != HCI_SUCCESS)\n\t\t\treturn -EIO;\n\t\telse\n\t\t\tdev->force_fan = value;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}", "item_id": 24, "repo": "Albocoder/KOOBE", "file": "s2e/source/s2e-linux-kernel/decree-cgc-cfe/drivers/platform/x86/toshiba_acpi.c", "last_update_at": "2022-01-16T07:19:47+00:00", "question_id": "7fce391818d30a183962b7888a8bfd275b10423c_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static ssize_t fan_proc_write(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *pos)\n{\n\tstruct toshiba_acpi_dev *dev = PDE_DATA(file_inode(file));\n\tchar cmd[42];\n\tsize_t len;\n\tint value;\n\tu32 hci_result;\n\tlen = min(count, sizeof(cmd) - 1);\n\tif (copy_from_user(cmd, buf, len))\n\t\treturn -EFAULT;\n\tcmd[len] = '\\0';\n\tif (sscanf(cmd, \" force_on : %i\", &value) == 1 &&\n\t    value >= 0 && value <= 1) {\n\t\thci_write1(dev, HCI_FAN, value, &hci_result);\n\t\tif (hci_result != HCI_SUCCESS)\n\t\t\treturn -EIO;\n\t\telse\n\t\t\tdev->force_fan = value;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn count;\n"]]}
{"hexsha": "aa1e8f49adcc27c4b077c6a347efe8ce3c103514", "ext": "c", "lang": "C", "content": "void guac_terminal_scrollbar_set_value(guac_terminal_scrollbar* scrollbar,\n        int value) {\n\n    /* Fit value within bounds */\n    if (value > scrollbar->max)\n        value = scrollbar->max;\n    else if (value < scrollbar->min)\n        value = scrollbar->min;\n\n    /* Update value */\n    scrollbar->value = value;\n\n}", "item_id": 8, "repo": "changkun/occamy", "file": "guacamole/src/protocols/ssh/terminal_scrollbar.c", "last_update_at": "2022-03-28T02:19:29+00:00", "question_id": "aa1e8f49adcc27c4b077c6a347efe8ce3c103514_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void guac_terminal_scrollbar_set_value(guac_terminal_scrollbar* scrollbar,\n        int value) {\n    /* Fit value within bounds */\n    if (value > scrollbar->max)\n        value = scrollbar->max;\n    else if (value < scrollbar->min)\n        value = scrollbar->min;\n    /* Update value */\n    scrollbar->value = value;\n"]]}
{"hexsha": "f071678d15eca065c3ace06d695fef19ac9cb468", "ext": "c", "lang": "C", "content": "int\nmain(int argc, char *argv[])\n{\n    LongBowRunner *testRunner = LONGBOW_TEST_RUNNER_CREATE(Example1);\n    int status = longBowMain(argc, argv, testRunner, NULL);\n    longBowTestRunner_Destroy(&testRunner);\n\n    exit(status);\n}", "item_id": 0, "repo": "cherouvim/cicn-nrs", "file": "cframework/longbow/src/examples/testRunnerSkipped.c", "last_update_at": "2022-02-18T00:26:34+00:00", "question_id": "f071678d15eca065c3ace06d695fef19ac9cb468_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nmain(int argc, char *argv[])\n{\n    LongBowRunner *testRunner = LONGBOW_TEST_RUNNER_CREATE(Example1);\n    int status = longBowMain(argc, argv, testRunner, NULL);\n    longBowTestRunner_Destroy(&testRunner);\n    exit(status);\n"]]}
{"hexsha": "c0d9c9bd97eb3fa5a324959b98747680fc9c9294", "ext": "c", "lang": "C", "content": "static void test_pack_URL_COMPONENTSA(void)\n{\n    /* URL_COMPONENTSA */\n    TEST_FIELD_SIZE  (URL_COMPONENTSA, dwStructSize, 4)\n    TEST_FIELD_ALIGN (URL_COMPONENTSA, dwStructSize, 4)\n    TEST_FIELD_OFFSET(URL_COMPONENTSA, dwStructSize, 0)\n    TEST_FIELD_SIZE  (URL_COMPONENTSA, lpszScheme, 4)\n    TEST_FIELD_ALIGN (URL_COMPONENTSA, lpszScheme, 4)\n    TEST_FIELD_OFFSET(URL_COMPONENTSA, lpszScheme, 4)\n    TEST_FIELD_SIZE  (URL_COMPONENTSA, dwSchemeLength, 4)\n    TEST_FIELD_ALIGN (URL_COMPONENTSA, dwSchemeLength, 4)\n    TEST_FIELD_OFFSET(URL_COMPONENTSA, dwSchemeLength, 8)\n}", "item_id": 202, "repo": "Heersin/wine", "file": "dlls/wininet/tests/generated.c", "last_update_at": "2022-03-31T18:52:48+00:00", "question_id": "c0d9c9bd97eb3fa5a324959b98747680fc9c9294_202", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void test_pack_URL_COMPONENTSA(void)\n{\n    /* URL_COMPONENTSA */\n    TEST_FIELD_SIZE  (URL_COMPONENTSA, dwStructSize, 4)\n    TEST_FIELD_ALIGN (URL_COMPONENTSA, dwStructSize, 4)\n    TEST_FIELD_OFFSET(URL_COMPONENTSA, dwStructSize, 0)\n    TEST_FIELD_SIZE  (URL_COMPONENTSA, lpszScheme, 4)\n    TEST_FIELD_ALIGN (URL_COMPONENTSA, lpszScheme, 4)\n    TEST_FIELD_OFFSET(URL_COMPONENTSA, lpszScheme, 4)\n    TEST_FIELD_SIZE  (URL_COMPONENTSA, dwSchemeLength, 4)\n    TEST_FIELD_ALIGN (URL_COMPONENTSA, dwSchemeLength, 4)\n    TEST_FIELD_OFFSET(URL_COMPONENTSA, dwSchemeLength, 8)\n"]]}
{"hexsha": "ed56841d301fbbdb7b5ac425d6dc4d9f540e2004", "ext": "c", "lang": "C", "content": "void\nxqc_test_id_hash()\n{\n    xqc_id_hash_table_t hash_tab;\n    xqc_id_hash_init(&hash_tab, xqc_default_allocator, 100);\n\n    xqc_id_hash_element_t e1 = {1, \"hello\"};\n    xqc_id_hash_add(&hash_tab, e1);\n\n    xqc_id_hash_element_t e2 = {3, \"world\"};\n    xqc_id_hash_add(&hash_tab, e2);\n\n    xqc_id_hash_element_t e3 = {5, \"!\"};\n    xqc_id_hash_add(&hash_tab, e3);\n\n    char *p1 = xqc_id_hash_find(&hash_tab, 3);\n    CU_ASSERT(p1 != NULL);\n\n    void *p2 = xqc_id_hash_find(&hash_tab, 4);\n    CU_ASSERT(p2 == NULL);\n\n    int ret = xqc_id_hash_delete(&hash_tab, 3);\n    CU_ASSERT(ret == XQC_OK);\n\n    void *p3 = xqc_id_hash_find(&hash_tab, 3);\n    CU_ASSERT(p3 == NULL);\n\n    ret = xqc_id_hash_delete(&hash_tab, 4);\n    CU_ASSERT(ret != XQC_OK);\n\n\n    xqc_id_hash_release(&hash_tab);\n}", "item_id": 0, "repo": "Mihir-Bhasin/xquic", "file": "tests/unittest/xqc_id_hash_test.c", "last_update_at": "2022-03-31T07:35:56+00:00", "question_id": "ed56841d301fbbdb7b5ac425d6dc4d9f540e2004_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nxqc_test_id_hash()\n{\n    xqc_id_hash_table_t hash_tab;\n    xqc_id_hash_init(&hash_tab, xqc_default_allocator, 100);\n    xqc_id_hash_element_t e1 = {1, \"hello\"};\n    xqc_id_hash_add(&hash_tab, e1);\n    xqc_id_hash_element_t e2 = {3, \"world\"};\n    xqc_id_hash_add(&hash_tab, e2);\n    xqc_id_hash_element_t e3 = {5, \"!\"};\n    xqc_id_hash_add(&hash_tab, e3);\n    char *p1 = xqc_id_hash_find(&hash_tab, 3);\n    CU_ASSERT(p1 != NULL);\n    void *p2 = xqc_id_hash_find(&hash_tab, 4);\n    CU_ASSERT(p2 == NULL);\n    int ret = xqc_id_hash_delete(&hash_tab, 3);\n    CU_ASSERT(ret == XQC_OK);\n    void *p3 = xqc_id_hash_find(&hash_tab, 3);\n    CU_ASSERT(p3 == NULL);\n    ret = xqc_id_hash_delete(&hash_tab, 4);\n    CU_ASSERT(ret != XQC_OK);\n    xqc_id_hash_release(&hash_tab);\n"]]}
{"hexsha": "ca8b23f8c525e7b0c1f510ca8f647d607f537b12", "ext": "c", "lang": "C", "content": "static void mmp_sspa_rx_enable(struct ssp_device *sspa)\n{\n\tunsigned int sspa_sp;\n\n\tsspa_sp = mmp_sspa_read_reg(sspa, SSPA_RXSP);\n\tsspa_sp |= SSPA_SP_S_EN;\n\tsspa_sp |= SSPA_SP_WEN;\n\tmmp_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);\n}", "item_id": 2, "repo": "rubedos/l4t_R32.5.1_viper", "file": "kernel/kernel-4.9/sound/soc/pxa/mmp-sspa.c", "last_update_at": "2022-01-16T07:19:47+00:00", "question_id": "ca8b23f8c525e7b0c1f510ca8f647d607f537b12_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void mmp_sspa_rx_enable(struct ssp_device *sspa)\n{\n\tunsigned int sspa_sp;\n\tsspa_sp = mmp_sspa_read_reg(sspa, SSPA_RXSP);\n\tsspa_sp |= SSPA_SP_S_EN;\n\tsspa_sp |= SSPA_SP_WEN;\n\tmmp_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);\n"]]}
{"hexsha": "11bc3281838e95a617c165e3274baf948a72359e", "ext": "h", "lang": "C", "content": "double CamState(double time, double rpm, double& CamPosition, double& CamVelocity, double& CamAcceleration)\n{\n  double t = time;\n  //  double rpm = *param;\n  double res = -0.0;\n  double w, beta, hc, hcp, hcpp, mass, kspring, cfriction, phio;\n  double PI = 3.14159265;\n  double Rb = 0.40;\n  double k1 = 0.45;\n  double k2 = 0.40393320723821;\n  double rho1 = 0.85;\n  double rho3 = 0.15;\n  double rho2 = 0.55393320723821;\n  double dBetadt, tmp1;\n  double beta1 = 0;\n  double beta2 = 1.050328174371336;\n  double beta3 = 1.22173047639603;\n\n\n  // char str [80],comando[80];\n  //   float f;\n  //   FILE * pFile;\n\n  //   pFile = fopen (\"parameters.txt\",\"r\");\n  //   rewind (pFile);\n  //   fscanf (pFile, \"%f\", &f);\n  //   fclose (pFile);\n  // printf (\"%f\\n\",f);\n  //rpm=(double)(f);\n\n  phio = PI / 2;\n  //  rpm=358;\n\n  //  printf (\"%f\\n\",rpm);\n  //  rpm=150;\n  w = 2 * PI * rpm / 60;\n  mass = 1.221;\n  kspring = 1430.8;\n  cfriction = 0;\n\n  beta = w * t;\n  beta = fmod(beta + phio, 2 * PI);\n\n  //hc=sin(beta)-0.9;\n  //hp=w*cos(beta);\n  //hpp=-w*w*sin(beta);\n\n  if (beta > PI)\n  {\n    beta = 2 * PI - beta;\n    w = -w;\n  }\n  dBetadt = w;\n  if (beta <= (PI / 2 - beta1))\n  {\n    hc = Rb;\n    hcp = 0;\n    hcpp = 0;\n  }\n  else if (beta <= (PI / 2 + beta2))\n  {\n    hc = -k1 * sin(beta) + rho1 * sqrt(1 - pow((cos(beta)) * (k1 / rho1), 2)) ;\n    hcp = (-k1 * cos(beta) + (pow(k1, 2) * sin(beta) * cos(beta)) / (rho1 * sqrt(1 - pow((cos(beta)) * (k1 / rho1), 2)))) * dBetadt;\n    tmp1 = pow(cos(beta - beta1), 2) - pow(sin(beta - beta1), 2) - (pow(k1 * sin(beta - beta1) * cos(beta - beta1), 2)) / (pow(rho1, 2) * (1 - pow((cos(beta - beta1)) * (k1 / rho1), 2)));\n    hcpp = (k1 * sin(beta - beta1) + (pow(k1, 2) / (rho1 * sqrt(1 - pow((cos(beta - beta1)) * (k1 / rho1), 2)))) * tmp1) * (pow(dBetadt, 2));\n  }\n  else if (beta <= (PI / 2 + beta3))\n  {\n    hc = -k2 * cos(beta + PI / 9) + rho3 * sqrt(1 - pow((sin(beta + PI / 9)) * (k2 / rho3), 2)) ;\n    hcp = (k2 * sin(beta + PI / 9) - (pow(k2, 2) * sin(beta + PI / 9) * cos(beta + PI / 9)) / (rho3 * sqrt(1 - pow((sin(beta + PI / 9)) * (k2 / rho3), 2)))) * dBetadt;\n    tmp1 = pow(cos(beta - beta3), 2) - pow(sin(beta - beta3), 2) - (pow(k2 * sin(beta - beta3) * cos(beta - beta3), 2)) / (pow(rho3, 2) * (1 - pow((cos(beta - beta3)) * (k2 / rho3), 2)));\n    hcpp = (-k2 * sin(beta - beta3) + (pow(k2, 2) / (rho3 * sqrt(1 - pow((cos(beta - beta3)) * (k2 / rho3), 2)))) * tmp1) * pow(dBetadt, 2);\n  }\n  else\n  {\n    hc = rho2;\n    hcp = 0;\n    hcpp = 0;\n  }\n\n  hc = hc - 0.3;\n\n  CamPosition = hc;\n  CamVelocity = hcp;\n  CamAcceleration = hcpp;\n  res = -(mass * hcpp + cfriction * hcp + kspring * hc);\n  //res=0;\n  return res;\n}", "item_id": 0, "repo": "ljktest/siconos", "file": "kernel/swig/tests/plugins/CamState.h", "last_update_at": "2022-03-26T06:01:59+00:00", "question_id": "11bc3281838e95a617c165e3274baf948a72359e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["double CamState(double time, double rpm, double& CamPosition, double& CamVelocity, double& CamAcceleration)\n{\n  double t = time;\n  //  double rpm = *param;\n  double res = -0.0;\n  double w, beta, hc, hcp, hcpp, mass, kspring, cfriction, phio;\n  double PI = 3.14159265;\n  double Rb = 0.40;\n  double k1 = 0.45;\n  double k2 = 0.40393320723821;\n  double rho1 = 0.85;\n  double rho3 = 0.15;\n  double rho2 = 0.55393320723821;\n  double dBetadt, tmp1;\n  double beta1 = 0;\n  double beta2 = 1.050328174371336;\n  double beta3 = 1.22173047639603;\n  // char str [80],comando[80];\n  //   float f;\n  //   FILE * pFile;\n  //   pFile = fopen (\"parameters.txt\",\"r\");\n  //   rewind (pFile);\n  //   fscanf (pFile, \"%f\", &f);\n  //   fclose (pFile);\n  // printf (\"%f\\n\",f);\n  //rpm=(double)(f);\n  phio = PI / 2;\n  //  rpm=358;\n  //  printf (\"%f\\n\",rpm);\n  //  rpm=150;\n  w = 2 * PI * rpm / 60;\n  mass = 1.221;\n  kspring = 1430.8;\n  cfriction = 0;\n  beta = w * t;\n  beta = fmod(beta + phio, 2 * PI);\n  //hc=sin(beta)-0.9;\n  //hp=w*cos(beta);\n  //hpp=-w*w*sin(beta);\n  if (beta > PI)\n  {\n    beta = 2 * PI - beta;\n    w = -w;\n  }\n  dBetadt = w;\n  if (beta <= (PI / 2 - beta1))\n  {\n    hc = Rb;\n    hcp = 0;\n    hcpp = 0;\n  }\n  else if (beta <= (PI / 2 + beta2))\n  {\n    hc = -k1 * sin(beta) + rho1 * sqrt(1 - pow((cos(beta)) * (k1 / rho1), 2)) ;\n    hcp = (-k1 * cos(beta) + (pow(k1, 2) * sin(beta) * cos(beta)) / (rho1 * sqrt(1 - pow((cos(beta)) * (k1 / rho1), 2)))) * dBetadt;\n    tmp1 = pow(cos(beta - beta1), 2) - pow(sin(beta - beta1), 2) - (pow(k1 * sin(beta - beta1) * cos(beta - beta1), 2)) / (pow(rho1, 2) * (1 - pow((cos(beta - beta1)) * (k1 / rho1), 2)));\n    hcpp = (k1 * sin(beta - beta1) + (pow(k1, 2) / (rho1 * sqrt(1 - pow((cos(beta - beta1)) * (k1 / rho1), 2)))) * tmp1) * (pow(dBetadt, 2));\n  }\n  else if (beta <= (PI / 2 + beta3))\n  {\n    hc = -k2 * cos(beta + PI / 9) + rho3 * sqrt(1 - pow((sin(beta + PI / 9)) * (k2 / rho3), 2)) ;\n    hcp = (k2 * sin(beta + PI / 9) - (pow(k2, 2) * sin(beta + PI / 9) * cos(beta + PI / 9)) / (rho3 * sqrt(1 - pow((sin(beta + PI / 9)) * (k2 / rho3), 2)))) * dBetadt;\n    tmp1 = pow(cos(beta - beta3), 2) - pow(sin(beta - beta3), 2) - (pow(k2 * sin(beta - beta3) * cos(beta - beta3), 2)) / (pow(rho3, 2) * (1 - pow((cos(beta - beta3)) * (k2 / rho3), 2)));\n    hcpp = (-k2 * sin(beta - beta3) + (pow(k2, 2) / (rho3 * sqrt(1 - pow((cos(beta - beta3)) * (k2 / rho3), 2)))) * tmp1) * pow(dBetadt, 2);\n  }\n  else\n  {\n    hc = rho2;\n    hcp = 0;\n    hcpp = 0;\n  }\n  hc = hc - 0.3;\n  CamPosition = hc;\n  CamVelocity = hcp;\n  CamAcceleration = hcpp;\n  res = -(mass * hcpp + cfriction * hcp + kspring * hc);\n  //res=0;\n  return res;\n"]]}
{"hexsha": "a93ad6d1e7d052818bad970e6163171cf95f43d0", "ext": "c", "lang": "C", "content": "int\nbtc_hdpriv_import(btc_hdnode_t *node,\n                  const uint8_t *data,\n                  const btc_network_t *network) {\n  uint32_t prefix = btc_read32be(data + 0);\n  int type = find_prefix(network->key.xprvkey, prefix);\n\n  if (type < 0)\n    return 0;\n\n  node->type = (enum btc_bip32_type)type;\n  node->depth = data[4];\n  node->parent = btc_read32be(data + 5);\n  node->index = btc_read32be(data + 9);\n\n  memcpy(node->chain, data + 13, 32);\n\n  if (data[45] != 0)\n    return 0;\n\n  memcpy(node->seckey, data + 46, 32);\n\n  if (btc_read32le(data + 78) != btc_checksum(data, 78))\n    return 0;\n\n  if (!btc_ecdsa_pubkey_create(node->pubkey, node->seckey, 1))\n    return 0;\n\n  return 1;\n}", "item_id": 13, "repo": "chjj/mako", "file": "src/bip32.c", "last_update_at": "2022-03-28T17:26:23+00:00", "question_id": "a93ad6d1e7d052818bad970e6163171cf95f43d0_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nbtc_hdpriv_import(btc_hdnode_t *node,\n                  const uint8_t *data,\n                  const btc_network_t *network) {\n  uint32_t prefix = btc_read32be(data + 0);\n  int type = find_prefix(network->key.xprvkey, prefix);\n  if (type < 0)\n    return 0;\n  node->type = (enum btc_bip32_type)type;\n  node->depth = data[4];\n  node->parent = btc_read32be(data + 5);\n  node->index = btc_read32be(data + 9);\n  memcpy(node->chain, data + 13, 32);\n  if (data[45] != 0)\n    return 0;\n  memcpy(node->seckey, data + 46, 32);\n  if (btc_read32le(data + 78) != btc_checksum(data, 78))\n    return 0;\n  if (!btc_ecdsa_pubkey_create(node->pubkey, node->seckey, 1))\n    return 0;\n  return 1;\n"]]}
{"hexsha": "7f77db5d12789fce8a012bb0b3048f1a9c82558f", "ext": "c", "lang": "C", "content": "static void srr_dqp_index_advc(struct bdc *bdc, u32 srr_num)\n{\n\tstruct srr *srr;\n\n\tsrr = &bdc->srr;\n\tdev_dbg_ratelimited(bdc->dev, \"srr->dqp_index:%d\\n\", srr->dqp_index);\n\tsrr->dqp_index++;\n\t/* rollback to 0 if we are past the last */\n\tif (srr->dqp_index == NUM_SR_ENTRIES)\n\t\tsrr->dqp_index = 0;\n}", "item_id": 0, "repo": "bradchesney79/illacceptanything", "file": "linux/drivers/usb/gadget/udc/bdc/bdc_udc.c", "last_update_at": "2022-02-07T15:58:16+00:00", "question_id": "7f77db5d12789fce8a012bb0b3048f1a9c82558f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void srr_dqp_index_advc(struct bdc *bdc, u32 srr_num)\n{\n\tstruct srr *srr;\n\tsrr = &bdc->srr;\n\tdev_dbg_ratelimited(bdc->dev, \"srr->dqp_index:%d\\n\", srr->dqp_index);\n\tsrr->dqp_index++;\n\t/* rollback to 0 if we are past the last */\n\tif (srr->dqp_index == NUM_SR_ENTRIES)\n\t\tsrr->dqp_index = 0;\n"]]}
{"hexsha": "a6d25d49bf956f8ce1390a402559e396125bfb88", "ext": "c", "lang": "C", "content": "int scp_bootloader_transfer(void *image, unsigned int image_size)\n{\n\tuintptr_t offset = (uintptr_t)image - MHU_SECURE_BASE;\n\tuintptr_t end = offset + image_size;\n\tuint32_t response;\n\n\tmhu_secure_init();\n\n\t/* Initiate communications with SCP */\n\tdo {\n\t\tcmd_start_payload *cmd_start = scp_boot_message_start();\n\t\tcmd_start->image_size = image_size;\n\n\t\tscp_boot_message_send(BOOT_CMD_START, sizeof(*cmd_start));\n\n\t\tresponse = scp_boot_message_wait(0);\n\n\t\tscp_boot_message_end();\n\t} while (response != BOOT_CMD_ACK);\n\n\t/* Transfer image to SCP a block at a time */\n\tuint32_t sequence_num = 1;\n\tsize_t size;\n\twhile ((size = end - offset) != 0) {\n\t\tif (size > BOOT_DATA_MAX_SIZE)\n\t\t\tsize = BOOT_DATA_MAX_SIZE;\n\t\twhile (!transfer_block(sequence_num, offset, size))\n\t\t\t; /* Retry forever */\n\t\toffset += size;\n\t\tsequence_num++;\n\t}\n\n\t/* Wait for SCP to signal it's ready */\n\treturn scpi_wait_ready();\n}", "item_id": 3, "repo": "yatharth-arm/arm-trusted-firmware", "file": "plat/juno/scp_bootloader.c", "last_update_at": "2022-03-04T12:10:19+00:00", "question_id": "a6d25d49bf956f8ce1390a402559e396125bfb88_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int scp_bootloader_transfer(void *image, unsigned int image_size)\n{\n\tuintptr_t offset = (uintptr_t)image - MHU_SECURE_BASE;\n\tuintptr_t end = offset + image_size;\n\tuint32_t response;\n\tmhu_secure_init();\n\t/* Initiate communications with SCP */\n\tdo {\n\t\tcmd_start_payload *cmd_start = scp_boot_message_start();\n\t\tcmd_start->image_size = image_size;\n\t\tscp_boot_message_send(BOOT_CMD_START, sizeof(*cmd_start));\n\t\tresponse = scp_boot_message_wait(0);\n\t\tscp_boot_message_end();\n\t} while (response != BOOT_CMD_ACK);\n\t/* Transfer image to SCP a block at a time */\n\tuint32_t sequence_num = 1;\n\tsize_t size;\n\twhile ((size = end - offset) != 0) {\n\t\tif (size > BOOT_DATA_MAX_SIZE)\n\t\t\tsize = BOOT_DATA_MAX_SIZE;\n\t\twhile (!transfer_block(sequence_num, offset, size))\n\t\t\t; /* Retry forever */\n\t\toffset += size;\n\t\tsequence_num++;\n\t}\n\t/* Wait for SCP to signal it's ready */\n\treturn scpi_wait_ready();\n"]]}
{"hexsha": "49758901196d6577f060fd566c4ce6ae41eac99d", "ext": "c", "lang": "C", "content": "void g2dSetCoordXYRelative(float x, float y)\n{\n    float inc_x = x;\n    float inc_y = y;\n\n    if (rctx.cur_obj.rot_cos != 1.f)\n    {\n        inc_x = -rctx.cur_obj.rot_sin*y + rctx.cur_obj.rot_cos*x;\n        inc_y =  rctx.cur_obj.rot_cos*y + rctx.cur_obj.rot_sin*x;\n    }\n\n    rctx.cur_obj.x += inc_x * global_scale;\n    rctx.cur_obj.y += inc_y * global_scale;\n}", "item_id": 21, "repo": "Manolomon/blind-jump-portable", "file": "source/platform/psp/glib2d.c", "last_update_at": "2022-03-25T12:38:23+00:00", "question_id": "49758901196d6577f060fd566c4ce6ae41eac99d_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void g2dSetCoordXYRelative(float x, float y)\n{\n    float inc_x = x;\n    float inc_y = y;\n    if (rctx.cur_obj.rot_cos != 1.f)\n    {\n        inc_x = -rctx.cur_obj.rot_sin*y + rctx.cur_obj.rot_cos*x;\n        inc_y =  rctx.cur_obj.rot_cos*y + rctx.cur_obj.rot_sin*x;\n    }\n    rctx.cur_obj.x += inc_x * global_scale;\n    rctx.cur_obj.y += inc_y * global_scale;\n"]]}
{"hexsha": "b4de00b240618e58dd42710f5caf2e5b3cc73b1e", "ext": "c", "lang": "C", "content": "static grn_rc\nget_identifier(grn_ctx *ctx, efs_info *q, grn_obj *name_resolve_context)\n{\n  const char *s;\n  unsigned int len;\n  grn_rc rc = GRN_SUCCESS;\n  for (s = q->cur; s < q->str_end; s += len) {\n    if (!(len = grn_charlen(ctx, s, q->str_end))) {\n      rc = GRN_END_OF_DATA;\n      goto exit;\n    }\n    if (grn_isspace(s, ctx->encoding)) { goto done; }\n    if (len == 1) {\n      switch (*s) {\n      case '\\0' : case '(' : case ')' : case '{' : case '}' :\n      case '[' : case ']' : case ',' : case ':' : case '@' :\n      case '?' : case '\"' : case '*' : case '+' : case '-' :\n      case '|' : case '/' : case '%' : case '!' : case '^' :\n      case '&' : case '>' : case '<' : case '=' : case '~' :\n        /* case '.' : */\n        goto done;\n        break;\n      }\n    }\n  }\ndone :\n  len = s - q->cur;\n  switch (*q->cur) {\n  case 'd' :\n    if (len == 6 && !memcmp(q->cur, \"delete\", 6)) {\n      PARSE(GRN_EXPR_TOKEN_DELETE);\n      goto exit;\n    }\n    break;\n  case 'f' :\n    if (len == 5 && !memcmp(q->cur, \"false\", 5)) {\n      grn_obj buf;\n      PARSE(GRN_EXPR_TOKEN_BOOLEAN);\n      GRN_BOOL_INIT(&buf, 0);\n      GRN_BOOL_SET(ctx, &buf, 0);\n      grn_expr_append_const(ctx, q->e, &buf, GRN_OP_PUSH, 1);\n      GRN_OBJ_FIN(ctx, &buf);\n      goto exit;\n    }\n    break;\n  case 'i' :\n    if (len == 2 && !memcmp(q->cur, \"in\", 2)) {\n      PARSE(GRN_EXPR_TOKEN_IN);\n      goto exit;\n    }\n    break;\n  case 'n' :\n    if (len == 4 && !memcmp(q->cur, \"null\", 4)) {\n      grn_obj buf;\n      PARSE(GRN_EXPR_TOKEN_NULL);\n      GRN_VOID_INIT(&buf);\n      grn_expr_append_const(ctx, q->e, &buf, GRN_OP_PUSH, 1);\n      GRN_OBJ_FIN(ctx, &buf);\n      goto exit;\n    }\n    break;\n  case 't' :\n    if (len == 4 && !memcmp(q->cur, \"true\", 4)) {\n      grn_obj buf;\n      PARSE(GRN_EXPR_TOKEN_BOOLEAN);\n      GRN_BOOL_INIT(&buf, 0);\n      GRN_BOOL_SET(ctx, &buf, 1);\n      grn_expr_append_const(ctx, q->e, &buf, GRN_OP_PUSH, 1);\n      GRN_OBJ_FIN(ctx, &buf);\n      goto exit;\n    }\n    break;\n  }\n  {\n    grn_obj *obj;\n    const char *name = q->cur;\n    unsigned int name_size = s - q->cur;\n    if (name_resolve_context) {\n      if ((obj = grn_obj_column(ctx, name_resolve_context, name, name_size))) {\n        if (obj->header.type == GRN_ACCESSOR) {\n          grn_expr_take_obj(ctx, q->e, obj);\n        }\n        PARSE(GRN_EXPR_TOKEN_IDENTIFIER);\n        grn_expr_append_obj(ctx, q->e, obj, GRN_OP_GET_VALUE, 2);\n        goto exit;\n      }\n    }\n    if ((obj = grn_expr_get_var(ctx, q->e, name, name_size))) {\n      PARSE(GRN_EXPR_TOKEN_IDENTIFIER);\n      grn_expr_append_obj(ctx, q->e, obj, GRN_OP_PUSH, 1);\n      goto exit;\n    }\n    if ((obj = grn_obj_column(ctx, q->table, name, name_size))) {\n      if (obj->header.type == GRN_ACCESSOR) {\n        grn_expr_take_obj(ctx, q->e, obj);\n      }\n      PARSE(GRN_EXPR_TOKEN_IDENTIFIER);\n      grn_expr_append_obj(ctx, q->e, obj, GRN_OP_GET_VALUE, 1);\n      goto exit;\n    }\n    if ((obj = resolve_top_level_name(ctx, name, name_size))) {\n      if (obj->header.type == GRN_ACCESSOR) {\n        grn_expr_take_obj(ctx, q->e, obj);\n      }\n      PARSE(GRN_EXPR_TOKEN_IDENTIFIER);\n      grn_expr_append_obj(ctx, q->e, obj, GRN_OP_PUSH, 1);\n      goto exit;\n    }\n    if (q->flags & GRN_EXPR_SYNTAX_OUTPUT_COLUMNS) {\n      PARSE(GRN_EXPR_TOKEN_NONEXISTENT_COLUMN);\n    } else {\n      rc = GRN_SYNTAX_ERROR;\n      ERR(rc,\n          \"[expr][parse] unknown identifier: <%.*s>\",\n          (int)name_size,\n          name);\n    }\n  }\nexit :\n  q->cur = s;\n  return rc;\n}", "item_id": 81, "repo": "zettadb/zettalib", "file": "src/vendor/mariadb-10.6.7/storage/mroonga/vendor/groonga/lib/expr.c", "last_update_at": "2022-03-31T06:24:22+00:00", "question_id": "b4de00b240618e58dd42710f5caf2e5b3cc73b1e_81", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static grn_rc\nget_identifier(grn_ctx *ctx, efs_info *q, grn_obj *name_resolve_context)\n{\n  const char *s;\n  unsigned int len;\n  grn_rc rc = GRN_SUCCESS;\n  for (s = q->cur; s < q->str_end; s += len) {\n    if (!(len = grn_charlen(ctx, s, q->str_end))) {\n      rc = GRN_END_OF_DATA;\n      goto exit;\n    }\n    if (grn_isspace(s, ctx->encoding)) { goto done; }\n    if (len == 1) {\n      switch (*s) {\n      case '\\0' : case '(' : case ')' : case '{' : case '}' :\n      case '[' : case ']' : case ',' : case ':' : case '@' :\n      case '?' : case '\"' : case '*' : case '+' : case '-' :\n      case '|' : case '/' : case '%' : case '!' : case '^' :\n      case '&' : case '>' : case '<' : case '=' : case '~' :\n        /* case '.' : */\n        goto done;\n        break;\n      }\n    }\n  }\ndone :\n  len = s - q->cur;\n  switch (*q->cur) {\n  case 'd' :\n    if (len == 6 && !memcmp(q->cur, \"delete\", 6)) {\n      PARSE(GRN_EXPR_TOKEN_DELETE);\n      goto exit;\n    }\n    break;\n  case 'f' :\n    if (len == 5 && !memcmp(q->cur, \"false\", 5)) {\n      grn_obj buf;\n      PARSE(GRN_EXPR_TOKEN_BOOLEAN);\n      GRN_BOOL_INIT(&buf, 0);\n      GRN_BOOL_SET(ctx, &buf, 0);\n      grn_expr_append_const(ctx, q->e, &buf, GRN_OP_PUSH, 1);\n      GRN_OBJ_FIN(ctx, &buf);\n      goto exit;\n    }\n    break;\n  case 'i' :\n    if (len == 2 && !memcmp(q->cur, \"in\", 2)) {\n      PARSE(GRN_EXPR_TOKEN_IN);\n      goto exit;\n    }\n    break;\n  case 'n' :\n    if (len == 4 && !memcmp(q->cur, \"null\", 4)) {\n      grn_obj buf;\n      PARSE(GRN_EXPR_TOKEN_NULL);\n      GRN_VOID_INIT(&buf);\n      grn_expr_append_const(ctx, q->e, &buf, GRN_OP_PUSH, 1);\n      GRN_OBJ_FIN(ctx, &buf);\n      goto exit;\n    }\n    break;\n  case 't' :\n    if (len == 4 && !memcmp(q->cur, \"true\", 4)) {\n      grn_obj buf;\n      PARSE(GRN_EXPR_TOKEN_BOOLEAN);\n      GRN_BOOL_INIT(&buf, 0);\n      GRN_BOOL_SET(ctx, &buf, 1);\n      grn_expr_append_const(ctx, q->e, &buf, GRN_OP_PUSH, 1);\n      GRN_OBJ_FIN(ctx, &buf);\n      goto exit;\n    }\n    break;\n  }\n  {\n    grn_obj *obj;\n    const char *name = q->cur;\n    unsigned int name_size = s - q->cur;\n    if (name_resolve_context) {\n      if ((obj = grn_obj_column(ctx, name_resolve_context, name, name_size))) {\n        if (obj->header.type == GRN_ACCESSOR) {\n          grn_expr_take_obj(ctx, q->e, obj);\n        }\n        PARSE(GRN_EXPR_TOKEN_IDENTIFIER);\n        grn_expr_append_obj(ctx, q->e, obj, GRN_OP_GET_VALUE, 2);\n        goto exit;\n      }\n    }\n    if ((obj = grn_expr_get_var(ctx, q->e, name, name_size))) {\n      PARSE(GRN_EXPR_TOKEN_IDENTIFIER);\n      grn_expr_append_obj(ctx, q->e, obj, GRN_OP_PUSH, 1);\n      goto exit;\n    }\n    if ((obj = grn_obj_column(ctx, q->table, name, name_size))) {\n      if (obj->header.type == GRN_ACCESSOR) {\n        grn_expr_take_obj(ctx, q->e, obj);\n      }\n      PARSE(GRN_EXPR_TOKEN_IDENTIFIER);\n      grn_expr_append_obj(ctx, q->e, obj, GRN_OP_GET_VALUE, 1);\n      goto exit;\n    }\n    if ((obj = resolve_top_level_name(ctx, name, name_size))) {\n      if (obj->header.type == GRN_ACCESSOR) {\n        grn_expr_take_obj(ctx, q->e, obj);\n      }\n      PARSE(GRN_EXPR_TOKEN_IDENTIFIER);\n      grn_expr_append_obj(ctx, q->e, obj, GRN_OP_PUSH, 1);\n      goto exit;\n    }\n    if (q->flags & GRN_EXPR_SYNTAX_OUTPUT_COLUMNS) {\n      PARSE(GRN_EXPR_TOKEN_NONEXISTENT_COLUMN);\n    } else {\n      rc = GRN_SYNTAX_ERROR;\n      ERR(rc,\n          \"[expr][parse] unknown identifier: <%.*s>\",\n          (int)name_size,\n          name);\n    }\n  }\nexit :\n  q->cur = s;\n  return rc;\n"]]}
{"hexsha": "53fca1f05a5c3e62f8307af96ea2e635f368a4b7", "ext": "c", "lang": "C", "content": "const struct Nif *ledc_nif_get_nif(const char *nifname)\n{\n    if (strcmp(\"ledc:timer_config/1\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_timer_config_nif;\n    }\n    if (strcmp(\"ledc:channel_config/1\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_channel_config_nif;\n    }\n    if (strcmp(\"ledc:fade_func_install/1\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_fade_func_install_nif;\n    }\n    if (strcmp(\"ledc:fade_func_uninstall/0\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_fade_func_uninstall_nif;\n    }\n    if (strcmp(\"ledc:set_fade_with_time/4\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_set_fade_with_time_nif;\n    }\n    if (strcmp(\"ledc:set_fade_with_step/5\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_set_fade_with_step_nif;\n    }\n    if (strcmp(\"ledc:fade_start/3\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_fade_start_nif;\n    }\n    if (strcmp(\"ledc:get_duty/2\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_get_duty_nif;\n    }\n    if (strcmp(\"ledc:set_duty/3\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_set_duty_nif;\n    }\n    if (strcmp(\"ledc:update_duty/2\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_update_duty_nif;\n    }\n    if (strcmp(\"ledc:get_freq/2\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_get_freq_nif;\n    }\n    if (strcmp(\"ledc:set_freq/3\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_set_freq_nif;\n    }\n    if (strcmp(\"ledc:stop/3\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_stop_nif;\n    }\n    return NULL;\n}", "item_id": 13, "repo": "UncleGrumpy/AtomVM", "file": "src/platforms/esp32/main/ledc_nif.c", "last_update_at": "2022-03-31T19:30:14+00:00", "question_id": "53fca1f05a5c3e62f8307af96ea2e635f368a4b7_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const struct Nif *ledc_nif_get_nif(const char *nifname)\n{\n    if (strcmp(\"ledc:timer_config/1\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_timer_config_nif;\n    }\n    if (strcmp(\"ledc:channel_config/1\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_channel_config_nif;\n    }\n    if (strcmp(\"ledc:fade_func_install/1\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_fade_func_install_nif;\n    }\n    if (strcmp(\"ledc:fade_func_uninstall/0\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_fade_func_uninstall_nif;\n    }\n    if (strcmp(\"ledc:set_fade_with_time/4\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_set_fade_with_time_nif;\n    }\n    if (strcmp(\"ledc:set_fade_with_step/5\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_set_fade_with_step_nif;\n    }\n    if (strcmp(\"ledc:fade_start/3\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_fade_start_nif;\n    }\n    if (strcmp(\"ledc:get_duty/2\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_get_duty_nif;\n    }\n    if (strcmp(\"ledc:set_duty/3\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_set_duty_nif;\n    }\n    if (strcmp(\"ledc:update_duty/2\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_update_duty_nif;\n    }\n    if (strcmp(\"ledc:get_freq/2\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_get_freq_nif;\n    }\n    if (strcmp(\"ledc:set_freq/3\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_set_freq_nif;\n    }\n    if (strcmp(\"ledc:stop/3\", nifname) == 0) {\n        TRACE(\"Resolved platform nif %s ...\\n\", nifname);\n        return &ledc_stop_nif;\n    }\n    return NULL;\n"]]}
{"hexsha": "7a0b0daf128a40f13dc3715c88b0211ff932cf80", "ext": "c", "lang": "C", "content": "static uint32_t calc_checksum(KOS_OBJ_ID obj)\n{\n    CHECKSUMMED_OPAQUE *opaque = (CHECKSUMMED_OPAQUE *)OBJPTR(OPAQUE, obj);\n    uint8_t            *ptr    = &opaque->data[0];\n    uint8_t            *end;\n    uint32_t            size;\n    uint32_t            checksum = ~0U;\n\n    size = kos_get_object_size(opaque->header) - sizeof(CHECKSUMMED_OPAQUE) + 1;\n    end  = ptr + size;\n\n    do {\n        const uint32_t b = *(ptr++);\n        checksum -= b;\n    } while (ptr != end);\n\n    return checksum;\n}", "item_id": 48, "repo": "kos-lang/kos", "file": "tests/kos_gc_test.c", "last_update_at": "2022-03-29T21:03:11+00:00", "question_id": "7a0b0daf128a40f13dc3715c88b0211ff932cf80_48", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static uint32_t calc_checksum(KOS_OBJ_ID obj)\n{\n    CHECKSUMMED_OPAQUE *opaque = (CHECKSUMMED_OPAQUE *)OBJPTR(OPAQUE, obj);\n    uint8_t            *ptr    = &opaque->data[0];\n    uint8_t            *end;\n    uint32_t            size;\n    uint32_t            checksum = ~0U;\n    size = kos_get_object_size(opaque->header) - sizeof(CHECKSUMMED_OPAQUE) + 1;\n    end  = ptr + size;\n    do {\n        const uint32_t b = *(ptr++);\n        checksum -= b;\n    } while (ptr != end);\n    return checksum;\n"]]}
{"hexsha": "6c9c8501562aeba79d73e12ac5a41ed4eae6678d", "ext": "c", "lang": "C", "content": "static int test_linkable(struct dentry *h_root)\n{\n\tstruct inode *h_dir = d_inode(h_root);\n\n\tif (h_dir->i_op->link)\n\t\treturn 0;\n\n\tpr_err(\"%pd (%s) doesn't support link(2), use noplink and rw+nolwh\\n\",\n\t       h_root, au_sbtype(h_root->d_sb));\n\treturn -ENOSYS;\n}", "item_id": 9, "repo": "Akh1lesh/Object_Detection_using_Intel_Realsense", "file": "ubuntu-bionic-hwe-edge/fs/aufs/whout.c", "last_update_at": "2022-01-30T20:01:25+00:00", "question_id": "6c9c8501562aeba79d73e12ac5a41ed4eae6678d_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int test_linkable(struct dentry *h_root)\n{\n\tstruct inode *h_dir = d_inode(h_root);\n\tif (h_dir->i_op->link)\n\t\treturn 0;\n\tpr_err(\"%pd (%s) doesn't support link(2), use noplink and rw+nolwh\\n\",\n\t       h_root, au_sbtype(h_root->d_sb));\n\treturn -ENOSYS;\n"]]}
{"hexsha": "a8da05331d743355f21e9d71e9dd0931f1c3a26a", "ext": "c", "lang": "C", "content": "void print_ingame_header(uint32_t score, bool game_over)\n{\n    clear_screen_area(&glibContext,\n                      0,\n                      SL_MEMLCD_DISPLAY_WIDTH - 1,\n                      0,\n                      INGAME_HEADER_DELIMITER);\n\n    // print header delimiter\n    GLIB_drawLineH(&glibContext, 0,\n                   INGAME_HEADER_DELIMITER - 1,\n                   SL_MEMLCD_DISPLAY_WIDTH - 1);\n\n    // print game over if present\n    if (game_over) {\n      GLIB_setFont(&glibContext, (GLIB_Font_t *) &GLIB_FontNormal8x8);\n      GLIB_drawStringOnLine(&glibContext,\n                            \"Game Over\",\n                            0,\n                            GLIB_ALIGN_LEFT,\n                            1,\n                            1,\n                            true);\n      GLIB_setFont(&glibContext, (GLIB_Font_t *) &GLIB_FontNarrow6x8);\n    }\n\n    // print score\n    char score_str[sizeof(uint32_t)*8+1];\n    sprintf(score_str, \"%d\", (int)score);\n    GLIB_drawStringOnLine(&glibContext,\n                          score_str,\n                          0,\n                          GLIB_ALIGN_RIGHT,\n                          -1,\n                          1,\n                          true);\n\n    DMD_updateDisplay();\n}", "item_id": 4, "repo": "SiliconLabs/platform_applications", "file": "platform_sisnake/src/graphics.c", "last_update_at": "2022-02-08T19:53:44+00:00", "question_id": "a8da05331d743355f21e9d71e9dd0931f1c3a26a_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void print_ingame_header(uint32_t score, bool game_over)\n{\n    clear_screen_area(&glibContext,\n                      0,\n                      SL_MEMLCD_DISPLAY_WIDTH - 1,\n                      0,\n                      INGAME_HEADER_DELIMITER);\n    // print header delimiter\n    GLIB_drawLineH(&glibContext, 0,\n                   INGAME_HEADER_DELIMITER - 1,\n                   SL_MEMLCD_DISPLAY_WIDTH - 1);\n    // print game over if present\n    if (game_over) {\n      GLIB_setFont(&glibContext, (GLIB_Font_t *) &GLIB_FontNormal8x8);\n      GLIB_drawStringOnLine(&glibContext,\n                            \"Game Over\",\n                            0,\n                            GLIB_ALIGN_LEFT,\n                            1,\n                            1,\n                            true);\n      GLIB_setFont(&glibContext, (GLIB_Font_t *) &GLIB_FontNarrow6x8);\n    }\n    // print score\n    char score_str[sizeof(uint32_t)*8+1];\n    sprintf(score_str, \"%d\", (int)score);\n    GLIB_drawStringOnLine(&glibContext,\n                          score_str,\n                          0,\n                          GLIB_ALIGN_RIGHT,\n                          -1,\n                          1,\n                          true);\n    DMD_updateDisplay();\n"]]}
{"hexsha": "26b74c2f94968de7f56ead9227fe46751c6b67b6", "ext": "c", "lang": "C", "content": "static int __init sh7724_devices_setup(void)\n{\n\tplatform_resource_setup_memory(&vpu_device, \"vpu\", 2 << 20);\n\tplatform_resource_setup_memory(&veu0_device, \"veu0\", 2 << 20);\n\tplatform_resource_setup_memory(&veu1_device, \"veu1\", 2 << 20);\n\tplatform_resource_setup_memory(&jpu_device,  \"jpu\",  2 << 20);\n\tplatform_resource_setup_memory(&spu0_device, \"spu0\", 2 << 20);\n\tplatform_resource_setup_memory(&spu1_device, \"spu1\", 2 << 20);\n\n\treturn platform_add_devices(sh7724_devices,\n\t\t\t\t    ARRAY_SIZE(sh7724_devices));\n}", "item_id": 0, "repo": "xloem/DIY-LAPTOP", "file": "SOFTWARE/A64-TERES/linux-a64/arch/sh/kernel/cpu/sh4a/setup-sh7724.c", "last_update_at": "2022-01-16T07:19:47+00:00", "question_id": "26b74c2f94968de7f56ead9227fe46751c6b67b6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int __init sh7724_devices_setup(void)\n{\n\tplatform_resource_setup_memory(&vpu_device, \"vpu\", 2 << 20);\n\tplatform_resource_setup_memory(&veu0_device, \"veu0\", 2 << 20);\n\tplatform_resource_setup_memory(&veu1_device, \"veu1\", 2 << 20);\n\tplatform_resource_setup_memory(&jpu_device,  \"jpu\",  2 << 20);\n\tplatform_resource_setup_memory(&spu0_device, \"spu0\", 2 << 20);\n\tplatform_resource_setup_memory(&spu1_device, \"spu1\", 2 << 20);\n\treturn platform_add_devices(sh7724_devices,\n\t\t\t\t    ARRAY_SIZE(sh7724_devices));\n"]]}
{"hexsha": "e7a98ba1c3f68b50b1d95217e4b8c85956e1e93d", "ext": "c", "lang": "C", "content": "bool BKE_autotrack_context_step(AutoTrackContext *context)\n{\n  const int frame_delta = context->backwards ? -1 : 1;\n  context->step_ok = false;\n\n  TaskParallelSettings settings;\n  BLI_parallel_range_settings_defaults(&settings);\n  settings.use_threading = (context->num_tracks > 1);\n  BLI_task_parallel_range(0, context->num_tracks, context, autotrack_context_step_cb, &settings);\n\n  /* Advance the frame. */\n  BLI_spin_lock(&context->spin_lock);\n  context->user.framenr += frame_delta;\n  BLI_spin_unlock(&context->spin_lock);\n  return context->step_ok;\n}", "item_id": 7, "repo": "SBCV/blender", "file": "source/blender/blenkernel/intern/tracking_auto.c", "last_update_at": "2022-03-24T04:46:31+00:00", "question_id": "e7a98ba1c3f68b50b1d95217e4b8c85956e1e93d_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool BKE_autotrack_context_step(AutoTrackContext *context)\n{\n  const int frame_delta = context->backwards ? -1 : 1;\n  context->step_ok = false;\n  TaskParallelSettings settings;\n  BLI_parallel_range_settings_defaults(&settings);\n  settings.use_threading = (context->num_tracks > 1);\n  BLI_task_parallel_range(0, context->num_tracks, context, autotrack_context_step_cb, &settings);\n  /* Advance the frame. */\n  BLI_spin_lock(&context->spin_lock);\n  context->user.framenr += frame_delta;\n  BLI_spin_unlock(&context->spin_lock);\n  return context->step_ok;\n"]]}
{"hexsha": "82855af1a9c6fb71bcc45539ab563867e17eeecb", "ext": "c", "lang": "C", "content": "void i2c_dir_fill_inode(struct inode *inode, int fill)\n{\n\tint i;\n\tstruct i2c_client *client;\n\n#ifdef DEBUG\n\tif (!inode) {\n\t\tprintk(\"i2c-proc.o: Warning: inode NULL in fill_inode()\\n\");\n\t\treturn;\n\t}\n#endif\t\t\t\t/* def DEBUG */\n\n\tfor (i = 0; i < SENSORS_ENTRY_MAX; i++)\n\t\tif (i2c_clients[i]\n\t\t    && (i2c_inodes[i] == inode->i_ino)) break;\n#ifdef DEBUG\n\tif (i == SENSORS_ENTRY_MAX) {\n\t\tprintk\n\t\t    (\"i2c-proc.o: Warning: inode (%ld) not found in fill_inode()\\n\",\n\t\t     inode->i_ino);\n\t\treturn;\n\t}\n#endif\t\t\t\t/* def DEBUG */\n\tclient = i2c_clients[i];\n\tif (fill)\n\t\tclient->driver->inc_use(client);\n\telse\n\t\tclient->driver->dec_use(client);\n}", "item_id": 3, "repo": "ghsecuritylab/tomato_egg", "file": "release/src/linux/linux/drivers/i2c/i2c-proc.c", "last_update_at": "2022-01-20T18:21:05+00:00", "question_id": "82855af1a9c6fb71bcc45539ab563867e17eeecb_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void i2c_dir_fill_inode(struct inode *inode, int fill)\n{\n\tint i;\n\tstruct i2c_client *client;\n#ifdef DEBUG\n\tif (!inode) {\n\t\tprintk(\"i2c-proc.o: Warning: inode NULL in fill_inode()\\n\");\n\t\treturn;\n\t}\n#endif\t\t\t\t/* def DEBUG */\n\tfor (i = 0; i < SENSORS_ENTRY_MAX; i++)\n\t\tif (i2c_clients[i]\n\t\t    && (i2c_inodes[i] == inode->i_ino)) break;\n#ifdef DEBUG\n\tif (i == SENSORS_ENTRY_MAX) {\n\t\tprintk\n\t\t    (\"i2c-proc.o: Warning: inode (%ld) not found in fill_inode()\\n\",\n\t\t     inode->i_ino);\n\t\treturn;\n\t}\n#endif\t\t\t\t/* def DEBUG */\n\tclient = i2c_clients[i];\n\tif (fill)\n\t\tclient->driver->inc_use(client);\n\telse\n\t\tclient->driver->dec_use(client);\n"]]}
{"hexsha": "9efe2897e0d5cacb3908d65938f5a07c61c992f9", "ext": "c", "lang": "C", "content": "static BOOL fastpath_recv_input_event_scancode(rdpFastPath* fastpath, wStream* s, BYTE eventFlags)\n{\n\tUINT16 flags;\n\tUINT16 code;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, code); /* keyCode (1 byte) */\n\n\tflags = 0;\n\n\tif ((eventFlags & FASTPATH_INPUT_KBDFLAGS_RELEASE))\n\t\tflags |= KBD_FLAGS_RELEASE;\n\telse\n\t\tflags |= KBD_FLAGS_DOWN;\n\n\tif ((eventFlags & FASTPATH_INPUT_KBDFLAGS_EXTENDED))\n\t\tflags |= KBD_FLAGS_EXTENDED;\n\n\tIFCALL(fastpath->rdp->input->KeyboardEvent, fastpath->rdp->input, flags, code);\n\n\treturn TRUE;\n}", "item_id": 14, "repo": "vdsicinn/FreeRDP", "file": "libfreerdp/core/fastpath.c", "last_update_at": "2022-01-15T21:49:43+00:00", "question_id": "9efe2897e0d5cacb3908d65938f5a07c61c992f9_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static BOOL fastpath_recv_input_event_scancode(rdpFastPath* fastpath, wStream* s, BYTE eventFlags)\n{\n\tUINT16 flags;\n\tUINT16 code;\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\tStream_Read_UINT8(s, code); /* keyCode (1 byte) */\n\tflags = 0;\n\tif ((eventFlags & FASTPATH_INPUT_KBDFLAGS_RELEASE))\n\t\tflags |= KBD_FLAGS_RELEASE;\n\telse\n\t\tflags |= KBD_FLAGS_DOWN;\n\tif ((eventFlags & FASTPATH_INPUT_KBDFLAGS_EXTENDED))\n\t\tflags |= KBD_FLAGS_EXTENDED;\n\tIFCALL(fastpath->rdp->input->KeyboardEvent, fastpath->rdp->input, flags, code);\n\treturn TRUE;\n"]]}
{"hexsha": "d6670c30bc7f8d1576a0a74cded7e902823c4440", "ext": "h", "lang": "C", "content": "void\np448_weak_reduce (\n    p448_t *a\n) {\n    uint64_t mask = (1ull<<56) - 1;\n    uint64_t tmp = a->limb[7] >> 56;\n    int i;\n    a->limb[4] += tmp;\n    for (i=7; i>0; i--) {\n        a->limb[i] = (a->limb[i] & mask) + (a->limb[i-1]>>56);\n    }\n    a->limb[0] = (a->limb[0] & mask) + tmp;\n}", "item_id": 7, "repo": "ejfitzgerald/noise-c", "file": "src/crypto/goldilocks/src/p448/arch_ref64/p448.h", "last_update_at": "2022-03-23T01:24:49+00:00", "question_id": "d6670c30bc7f8d1576a0a74cded7e902823c4440_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\np448_weak_reduce (\n    p448_t *a\n) {\n    uint64_t mask = (1ull<<56) - 1;\n    uint64_t tmp = a->limb[7] >> 56;\n    int i;\n    a->limb[4] += tmp;\n    for (i=7; i>0; i--) {\n        a->limb[i] = (a->limb[i] & mask) + (a->limb[i-1]>>56);\n    }\n    a->limb[0] = (a->limb[0] & mask) + tmp;\n"]]}
{"hexsha": "f334a343438bfbafc37dc71b45a7bdfb153fc8b1", "ext": "c", "lang": "C", "content": "static void MT6616_RDS_RetrieveGroup2(struct i2c_client *client, uint16_t *block_data, uint8_t SubType, RDSData_Struct *pstRDSData)\n{\n    uint8_t TextAddr, indx, indx2, space, byte0, byte1;\n\tuint16_t addrcnt;\n\tTextAddr = (uint8_t)block_data[1]&0x0F;\n\t\n\tif(pstRDSData->RDSFlag.Text_AB != ((block_data[1]&0x0010)>>4))\n\t{\n\t\tpstRDSData->RDSFlag.Text_AB = (block_data[1]&0x0010)>>4;\n\t\tpstRDSData->event_status |= RDS_EVENT_FLAGS;\n\t\tpstRDSData->RDSFlag.flag_status |= RDS_FLAG_TEXT_AB;\n\t\tWCN_DBG(L6|D_G2, \"RT RetrieveGroup2 TextABFlag: %x --> %x\\n\", PreTextABFlag, pstRDSData->RDSFlag.Text_AB);\n\t}\n\n\tif(PreTextABFlag != pstRDSData->RDSFlag.Text_AB)\n\t{\n\t\t/*DDB:Some station don't send 0x0D, it just switch TextAB if it want to send next message.*/\n\t\taddrcnt = 0xFFFF>>(0x0F-indx);\n\t\tif (pstRDSData->RT_Data.isRTDisplay == 0)// && (((pstRDSData->RT_Data.Addr_Cnt)&addrcnt) == addrcnt)) \n\t\t{\n\t\t\tWCN_DBG(L6|D_G2, \"RT TextAB changed and RT has not been show.\\n\");\n\t\t\tpstRDSData->event_status |= RDS_EVENT_LAST_RADIOTEXT; \n\t\t\tspace = 0;\n\t\t\tfor(indx = 0; indx < 64; indx++)\n\t\t\t{\n\t\t\t\tif(pstRDSData->RT_Data.TextData[1][indx] == 0x20)\n\t\t\t\t\tspace++;\n\t\t\t}\t\n\t\t\tif(space == 64)\n\t\t\t\tpstRDSData->event_status &= (~RDS_EVENT_LAST_RADIOTEXT);\n\n\t\t\tif (pstRDSData->event_status & RDS_EVENT_LAST_RADIOTEXT) {\n\t\t\t\t/*DDB:Why TextData[1][0] NOT TextData[2][0],  Because some station just send a message one time, and then change TextAB, send another message, SUCH As Beijing 90.0*/\n\t\t\t\tmemcpy(&(pstRDSData->RT_Data.TextData[3][0]), &(pstRDSData->RT_Data.TextData[1][0]), sizeof(pstRDSData->RT_Data.TextData[3]));\n\n\t\t\t\tuint8_t tmp[66] = {0};\n\t\t\t\ttmp[64] = 'E';\n\t\t\t\tmemcpy(tmp, pstRDSData->RT_Data.TextData[1], 64);\n\t\t\t\n\t\t\t\tWCN_DBG(L6|D_G2, \"RT Radio text---%s\\n\", tmp);\n\t\t\t\tWCN_DBG(L6|D_G2, \"RT set RDS_EVENT_LAST_RADIOTEXT flag, no 0x0D case.\\n\");\n\t\t\t\tpstRDSData->RT_Data.isRTDisplay = 1;\n\t\t\t}\n\t\t}\n\t\t/*DDB, end*/\n\t    memset(&(pstRDSData->RT_Data.TextData[0][0]), 0x20, sizeof(pstRDSData->RT_Data.TextData[0]));\n\t\tmemset(&(pstRDSData->RT_Data.TextData[1][0]), 0x20, sizeof(pstRDSData->RT_Data.TextData[1]));\n\t\tmemset(&(pstRDSData->RT_Data.TextData[2][0]), 0x20, sizeof(pstRDSData->RT_Data.TextData[2]));\n\t\tPreTextABFlag = pstRDSData->RDSFlag.Text_AB;\n  \t\tpstRDSData->RT_Data.TextLength =  0;\n\t\tpstRDSData->RT_Data.GetLength = 0;\n\t\tpstRDSData->RT_Data.Addr_Cnt = 0;\n\t\t//pstRDSData->RT_Data.isRTDisplay = 0;\n\t}\n\t\n\tif(!SubType) //Type A\n\t{\n\t\tpstRDSData->RT_Data.isTypeA = 1;\n\t  \tif(block_data[4]&(FM_RDS_GDBK_IND_C|FM_RDS_GDBK_IND_D))\n        {\n  \t\t\tpstRDSData->RT_Data.TextData[0][4*TextAddr] = block_data[2]>>8;\n\t\t\tpstRDSData->RT_Data.TextData[0][4*TextAddr+1] = block_data[2]&0xFF;\n  \t\t\tpstRDSData->RT_Data.TextData[0][4*TextAddr+2] = block_data[3]>>8;\n\t\t\tpstRDSData->RT_Data.TextData[0][4*TextAddr+3] = block_data[3]&0xFF;\n\t\t\tspace = 0;\n\n            for(indx = 0; indx < 4;indx++)\n\t  \t    {\n\t  \t\t    byte0 = pstRDSData->RT_Data.TextData[0][4*TextAddr+indx];\n\t\t\t    byte1 = pstRDSData->RT_Data.TextData[1][4*TextAddr+indx];\n\t\t\t\tif (TextAddr == 0 && indx == 0) {\t//if the first block lost?\n\t\t\t\t\tWCN_DBG(L6|D_G2, \"RT Received the first block.\\n\");\n\t\t\t\t\tpstRDSData->RT_Data.isRTDisplay = 0;\n\t\t\t\t}\n\n\t\t\t\tif((!(pstRDSData->event_status&RDS_EVENT_LAST_RADIOTEXT))&&(byte0 == byte1)) //get the same byte 2 times\n\t\t\t\t{\n\t\t\t\t\tWCN_DBG(L7|D_G2, \"RT put to TextData[2] %d 0x%x(%c)\", 4*TextAddr+indx, byte0, byte0);\n\t\t\t\t\tspace++;\n\t\t\t\t\tpstRDSData->RT_Data.TextData[2][4*TextAddr+indx] = byte0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tWCN_DBG(L7|D_G2, \"RT put to TextData[1] %d 0x%x(%c)\", 4*TextAddr+indx, byte0, byte0);\n\t\t\t\t\tpstRDSData->RT_Data.TextData[1][4*TextAddr+indx] = byte0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(space == 4)\n\t\t\t{\n                addrcnt = pstRDSData->RT_Data.Addr_Cnt;\n\t\t\t\tpstRDSData->RT_Data.Addr_Cnt |= (1<<TextAddr);\n\t\t\t\t//WCN_DBG(L7|D_G2, \"RT RetrieveGroup2 RT addrcnt: 0x%x, RT_Data.Addr_Cnt: 0x%x\\n\", addrcnt, pstRDSData->RT_Data.Addr_Cnt);\n\t\t\t\t\n\t\t\t\tif(addrcnt == pstRDSData->RT_Data.Addr_Cnt)\n\t\t\t\t{\n\t\t\t\t    pstRDSData->RT_Data.BufCnt++;\n\t\t\t\t}\n\t\t\t\telse if(pstRDSData->RT_Data.BufCnt > 0)\n\t\t\t\t{\n\t\t\t\t\tpstRDSData->RT_Data.BufCnt--;\n\t  \t        }\n\t\t\t}\n\t  \t} else {\n\t\t\tWCN_DBG(L7|D_G2, \"RT %04x %04x %04x %04x %04x CRC error.\", block_data[0], block_data[1], block_data[2], block_data[3], block_data[4]);\n\t\t}\n\t  \tfor(indx = 0; indx < 4; indx++)\n\t  \t{\n\t  \t\tif(pstRDSData->RT_Data.TextData[2][4*TextAddr+indx] == 0x0D)\n\t        {\n\t\t\t\tWCN_DBG(L6|D_G2, \"RT ---buffer[2] received 0x0D.\\n\");\n\t            pstRDSData->RT_Data.TextLength = 4*TextAddr+indx+1; //Add terminate charater\n\t\t\t\tpstRDSData->RT_Data.TextData[2][4*TextAddr+indx] = '\\0';\n\t\t\t\tpstRDSData->RT_Data.GetLength = 1;\n\t        }\n\t\t\telse if((4*TextAddr+indx) == 63 && pstRDSData->RT_Data.Addr_Cnt == 0xffff) //type A full data. /*add by dongbo, make sure it's TextData[2], Not TextData[1]*/\n\t\t\t{\n\t\t\t\tWCN_DBG(L6|D_G2, \"RT ---The 63 byte received.\\n\");\n\t\t\t    pstRDSData->RT_Data.TextLength = 4*TextAddr+indx+1;  //no terminal character\n\t\t\t\tpstRDSData->RT_Data.GetLength = 1;\n\t\t\t}\n        }\n\t}\n\telse\n\t{\n\t    //FM_DEBUG(\"RetrieveGroup2 Type B RT NUM: 0x%x Text: 0x%x\", TextAddr, block_data[3]);\n\t\tWCN_DBG(L7|D_G2, \"RT %04x %04x %04x %04x %04x\", block_data[0], block_data[1], block_data[2], block_data[3], block_data[4]);\n\t\tpstRDSData->RT_Data.isTypeA = 0;\n\t\tif(block_data[4]&FM_RDS_GDBK_IND_D)\n\t\t{\n            pstRDSData->RT_Data.TextData[0][2*TextAddr] = block_data[3]>>8;\n\t\t    pstRDSData->RT_Data.TextData[0][2*TextAddr+1] = block_data[3]&0xFF;\n\t\t\tspace = 0;\n\t\t\t\n\t  \t    for(indx = 0; indx < 2; indx++)\n\t  \t    {\n\t  \t        byte0 = pstRDSData->RT_Data.TextData[0][2*TextAddr+indx];\n\t\t\t    byte1 = pstRDSData->RT_Data.TextData[1][2*TextAddr+indx];\n\t\t\t\t\n\t\t\t\tif((!((pstRDSData->event_status)&RDS_EVENT_LAST_RADIOTEXT))&&(byte0 == byte1))\n\t\t\t\t{\n\t\t\t\t\tspace++;\n\t\t\t\t\tpstRDSData->RT_Data.TextData[2][2*TextAddr+indx] = byte0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpstRDSData->RT_Data.TextData[1][2*TextAddr+indx] = byte0;\n\t\t\t\t}\n\t  \t\t}\n\t\t\tif(space == 2)\n\t\t\t{\n\t\t\t    addrcnt = pstRDSData->RT_Data.Addr_Cnt;\n\t\t\t\tpstRDSData->RT_Data.Addr_Cnt |= (1<<TextAddr);\n\t\t\t\tWCN_DBG(L7|D_G2, \"RT RetrieveGroup2 RT B addrcnt: 0x%x, RT_Data.Addr_Cnt: 0x%x\\n\", addrcnt, pstRDSData->RT_Data.Addr_Cnt);\n\t\t\t\t\n                if(addrcnt == pstRDSData->RT_Data.Addr_Cnt)\n\t\t\t\t{\n\t\t\t\t    pstRDSData->RT_Data.BufCnt++;\n\t\t\t\t}\n\t\t\t\telse if(pstRDSData->RT_Data.BufCnt > 0)\n\t\t\t\t{\n\t\t\t\t\tpstRDSData->RT_Data.BufCnt--;\n\t\t\t\t}\n            }\n\t\t} else {\n\t\t\tWCN_DBG(L7|D_G2, \"RT %04x %04x %04x %04x %04x CRC error.\", block_data[0], block_data[1], block_data[2], block_data[3], block_data[4]);\n\t\t}\n\t\t\n\t \tfor(indx = 0; indx < 2; indx++)\n\t  \t{\n\t  \t\tif((pstRDSData->RT_Data.TextData[2][2*TextAddr+indx]) == 0x0D) //0x0D=end code\n\t  \t\t{\n\t  \t\t    pstRDSData->RT_Data.TextLength = 2*TextAddr+indx+1;  //Add terminate charater\n\t\t\t\tpstRDSData->RT_Data.TextData[2][2*TextAddr+indx] = '\\0';\n\t\t\t\tpstRDSData->RT_Data.GetLength = 1;\n\t  \t\t}\n\t\t\telse if((2*TextAddr+indx) == 31) //full data\n\t\t\t{\n\t\t\t    pstRDSData->RT_Data.TextLength = 2*TextAddr+indx+1;  //Add terminate charater\n                pstRDSData->RT_Data.TextData[2][2*TextAddr+indx] = '\\0';\n\t\t\t\tpstRDSData->RT_Data.GetLength = 1;\n\t\t\t}\n\t  \t}\t\t\n\t}\n\n    //Check if text is fully received\n\tindx = TextAddr;\n\tif(pstRDSData->RT_Data.GetLength == 1)\n\t{\n\t\taddrcnt = 0xFFFF>>(0x0F-indx);\n\t}\n\telse if(pstRDSData->RT_Data.BufCnt > 100)\n\t{\n\t    pstRDSData->RT_Data.BufCnt = 0;\n\t    for(indx = 15; indx >= 0; indx--)\n\t    {\n\t        addrcnt = (pstRDSData->RT_Data.Addr_Cnt)&(1<<indx);\n\t        if(addrcnt)\n\t            break;\n\t\t}\n\t\t\n\t\t//get valid radio text length\n\t\tif (pstRDSData->RT_Data.isTypeA)\n\t\t{\n\t\t    for(indx2 = 0; indx2 < 4; indx2++)\n\t\t    {\n\t\t        if(pstRDSData->RT_Data.TextData[2][4*indx+indx2] == 0x0D)\n\t            {\n\t  \t\t\t    pstRDSData->RT_Data.TextLength = 4*indx+indx2+1;\n\t\t\t\t\tpstRDSData->RT_Data.TextData[2][4*indx+indx2] = '\\0';\n\t            }\n\t\t    }\n\t    }\n\t    else\n\t    {\n\t        for(indx2 = 0; indx2 < 2; indx2++)\n\t\t    {\n\t\t        if(pstRDSData->RT_Data.TextData[2][2*indx+indx2] == 0x0D)\n\t            {\n\t  \t\t\t    pstRDSData->RT_Data.TextLength = 2*indx+indx2+1;\n\t\t\t\t\tpstRDSData->RT_Data.TextData[2][2*indx+indx2] = '\\0';\n\t            }\n\t\t    }\n\t        \n\t    }\n\t\taddrcnt = 0xFFFF>>(0x0F-indx);\n\t}\n\telse\n\t{\n\t\tpstRDSData->RT_Data.TextLength = 0x0F;\n\t\taddrcnt = 0xFFFF;\n\t}\n\t\n    WCN_DBG(L7|D_G2, \"RetrieveGroup2 RDS RT: Addr_Cnt: 0x%x Length: 0x%x addrcnt: 0x%x\\n\", pstRDSData->RT_Data.Addr_Cnt, pstRDSData->RT_Data.TextLength, addrcnt);\n\n\tif(((((pstRDSData->RT_Data.Addr_Cnt)&addrcnt) == addrcnt)||((TextAddr == 0x0f) && (pstRDSData->RT_Data.Addr_Cnt == 0xffff))))//&&(pstRDSData->RT_Data.isRTDisplay == 0))\n\t{\t\t\n\t\tpstRDSData->RT_Data.Addr_Cnt = 0;\n\t\t//pstRDSData->RT_Data.isRTDisplay = 1;\n\n\t\tpstRDSData->event_status |= RDS_EVENT_LAST_RADIOTEXT; \n\t\tspace = 0;\n\t\tfor(indx = 0; indx < 64; indx++)\n\t\t{\n\t\t\tif(pstRDSData->RT_Data.TextData[2][indx] == 0x20)\n\t\t\t\tspace++;\n\t    }\t\n\t    if(space == 64)\n            pstRDSData->event_status &= (~RDS_EVENT_LAST_RADIOTEXT);\n\n\t\tmemset(&(pstRDSData->RT_Data.TextData[1][0]), 0x20, sizeof(pstRDSData->RT_Data.TextData[1]));\n\t\tmemset(&(pstRDSData->RT_Data.TextData[0][0]), 0x20, sizeof(pstRDSData->RT_Data.TextData[0]));\n\n\t\tif (pstRDSData->event_status & RDS_EVENT_LAST_RADIOTEXT) {\n\t\t\tmemcpy(&(pstRDSData->RT_Data.TextData[3][0]), &(pstRDSData->RT_Data.TextData[2][0]), sizeof(pstRDSData->RT_Data.TextData[3]));\n\n\t\t\tuint8_t tmp[66] = {0};\n\t\t\ttmp[64] = 'E';\n\t\t\tmemcpy(tmp, pstRDSData->RT_Data.TextData[3], 64);\n\t\t\n\t\t\tWCN_DBG(L6|D_G2, \"RT Radio text---%s\\n\", tmp);\n\t\t\tWCN_DBG(L6|D_G2, \"RT set RDS_EVENT_LAST_RADIOTEXT flag, +++0x0D case.\\n\");\n\t\t\tpstRDSData->RT_Data.isRTDisplay = 1;\n\t\t}\n    }\n}", "item_id": 10, "repo": "touxiong88/92_mediatek", "file": "custom/common/kernel/fm/mt6616/mt6616_rds.c", "last_update_at": "2022-01-07T01:53:19+00:00", "question_id": "f334a343438bfbafc37dc71b45a7bdfb153fc8b1_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void MT6616_RDS_RetrieveGroup2(struct i2c_client *client, uint16_t *block_data, uint8_t SubType, RDSData_Struct *pstRDSData)\n{\n    uint8_t TextAddr, indx, indx2, space, byte0, byte1;\n\tuint16_t addrcnt;\n\tTextAddr = (uint8_t)block_data[1]&0x0F;\n\t\n\tif(pstRDSData->RDSFlag.Text_AB != ((block_data[1]&0x0010)>>4))\n\t{\n\t\tpstRDSData->RDSFlag.Text_AB = (block_data[1]&0x0010)>>4;\n\t\tpstRDSData->event_status |= RDS_EVENT_FLAGS;\n\t\tpstRDSData->RDSFlag.flag_status |= RDS_FLAG_TEXT_AB;\n\t\tWCN_DBG(L6|D_G2, \"RT RetrieveGroup2 TextABFlag: %x --> %x\\n\", PreTextABFlag, pstRDSData->RDSFlag.Text_AB);\n\t}\n\tif(PreTextABFlag != pstRDSData->RDSFlag.Text_AB)\n\t{\n\t\t/*DDB:Some station don't send 0x0D, it just switch TextAB if it want to send next message.*/\n\t\taddrcnt = 0xFFFF>>(0x0F-indx);\n\t\tif (pstRDSData->RT_Data.isRTDisplay == 0)// && (((pstRDSData->RT_Data.Addr_Cnt)&addrcnt) == addrcnt)) \n\t\t{\n\t\t\tWCN_DBG(L6|D_G2, \"RT TextAB changed and RT has not been show.\\n\");\n\t\t\tpstRDSData->event_status |= RDS_EVENT_LAST_RADIOTEXT; \n\t\t\tspace = 0;\n\t\t\tfor(indx = 0; indx < 64; indx++)\n\t\t\t{\n\t\t\t\tif(pstRDSData->RT_Data.TextData[1][indx] == 0x20)\n\t\t\t\t\tspace++;\n\t\t\t}\t\n\t\t\tif(space == 64)\n\t\t\t\tpstRDSData->event_status &= (~RDS_EVENT_LAST_RADIOTEXT);\n\t\t\tif (pstRDSData->event_status & RDS_EVENT_LAST_RADIOTEXT) {\n\t\t\t\t/*DDB:Why TextData[1][0] NOT TextData[2][0],  Because some station just send a message one time, and then change TextAB, send another message, SUCH As Beijing 90.0*/\n\t\t\t\tmemcpy(&(pstRDSData->RT_Data.TextData[3][0]), &(pstRDSData->RT_Data.TextData[1][0]), sizeof(pstRDSData->RT_Data.TextData[3]));\n\t\t\t\tuint8_t tmp[66] = {0};\n\t\t\t\ttmp[64] = 'E';\n\t\t\t\tmemcpy(tmp, pstRDSData->RT_Data.TextData[1], 64);\n\t\t\t\n\t\t\t\tWCN_DBG(L6|D_G2, \"RT Radio text---%s\\n\", tmp);\n\t\t\t\tWCN_DBG(L6|D_G2, \"RT set RDS_EVENT_LAST_RADIOTEXT flag, no 0x0D case.\\n\");\n\t\t\t\tpstRDSData->RT_Data.isRTDisplay = 1;\n\t\t\t}\n\t\t}\n\t\t/*DDB, end*/\n\t    memset(&(pstRDSData->RT_Data.TextData[0][0]), 0x20, sizeof(pstRDSData->RT_Data.TextData[0]));\n\t\tmemset(&(pstRDSData->RT_Data.TextData[1][0]), 0x20, sizeof(pstRDSData->RT_Data.TextData[1]));\n\t\tmemset(&(pstRDSData->RT_Data.TextData[2][0]), 0x20, sizeof(pstRDSData->RT_Data.TextData[2]));\n\t\tPreTextABFlag = pstRDSData->RDSFlag.Text_AB;\n  \t\tpstRDSData->RT_Data.TextLength =  0;\n\t\tpstRDSData->RT_Data.GetLength = 0;\n\t\tpstRDSData->RT_Data.Addr_Cnt = 0;\n\t\t//pstRDSData->RT_Data.isRTDisplay = 0;\n\t}\n\t\n\tif(!SubType) //Type A\n\t{\n\t\tpstRDSData->RT_Data.isTypeA = 1;\n\t  \tif(block_data[4]&(FM_RDS_GDBK_IND_C|FM_RDS_GDBK_IND_D))\n        {\n  \t\t\tpstRDSData->RT_Data.TextData[0][4*TextAddr] = block_data[2]>>8;\n\t\t\tpstRDSData->RT_Data.TextData[0][4*TextAddr+1] = block_data[2]&0xFF;\n  \t\t\tpstRDSData->RT_Data.TextData[0][4*TextAddr+2] = block_data[3]>>8;\n\t\t\tpstRDSData->RT_Data.TextData[0][4*TextAddr+3] = block_data[3]&0xFF;\n\t\t\tspace = 0;\n            for(indx = 0; indx < 4;indx++)\n\t  \t    {\n\t  \t\t    byte0 = pstRDSData->RT_Data.TextData[0][4*TextAddr+indx];\n\t\t\t    byte1 = pstRDSData->RT_Data.TextData[1][4*TextAddr+indx];\n\t\t\t\tif (TextAddr == 0 && indx == 0) {\t//if the first block lost?\n\t\t\t\t\tWCN_DBG(L6|D_G2, \"RT Received the first block.\\n\");\n\t\t\t\t\tpstRDSData->RT_Data.isRTDisplay = 0;\n\t\t\t\t}\n\t\t\t\tif((!(pstRDSData->event_status&RDS_EVENT_LAST_RADIOTEXT))&&(byte0 == byte1)) //get the same byte 2 times\n\t\t\t\t{\n\t\t\t\t\tWCN_DBG(L7|D_G2, \"RT put to TextData[2] %d 0x%x(%c)\", 4*TextAddr+indx, byte0, byte0);\n\t\t\t\t\tspace++;\n\t\t\t\t\tpstRDSData->RT_Data.TextData[2][4*TextAddr+indx] = byte0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tWCN_DBG(L7|D_G2, \"RT put to TextData[1] %d 0x%x(%c)\", 4*TextAddr+indx, byte0, byte0);\n\t\t\t\t\tpstRDSData->RT_Data.TextData[1][4*TextAddr+indx] = byte0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(space == 4)\n\t\t\t{\n                addrcnt = pstRDSData->RT_Data.Addr_Cnt;\n\t\t\t\tpstRDSData->RT_Data.Addr_Cnt |= (1<<TextAddr);\n\t\t\t\t//WCN_DBG(L7|D_G2, \"RT RetrieveGroup2 RT addrcnt: 0x%x, RT_Data.Addr_Cnt: 0x%x\\n\", addrcnt, pstRDSData->RT_Data.Addr_Cnt);\n\t\t\t\t\n\t\t\t\tif(addrcnt == pstRDSData->RT_Data.Addr_Cnt)\n\t\t\t\t{\n\t\t\t\t    pstRDSData->RT_Data.BufCnt++;\n\t\t\t\t}\n\t\t\t\telse if(pstRDSData->RT_Data.BufCnt > 0)\n\t\t\t\t{\n\t\t\t\t\tpstRDSData->RT_Data.BufCnt--;\n\t  \t        }\n\t\t\t}\n\t  \t} else {\n\t\t\tWCN_DBG(L7|D_G2, \"RT %04x %04x %04x %04x %04x CRC error.\", block_data[0], block_data[1], block_data[2], block_data[3], block_data[4]);\n\t\t}\n\t  \tfor(indx = 0; indx < 4; indx++)\n\t  \t{\n\t  \t\tif(pstRDSData->RT_Data.TextData[2][4*TextAddr+indx] == 0x0D)\n\t        {\n\t\t\t\tWCN_DBG(L6|D_G2, \"RT ---buffer[2] received 0x0D.\\n\");\n\t            pstRDSData->RT_Data.TextLength = 4*TextAddr+indx+1; //Add terminate charater\n\t\t\t\tpstRDSData->RT_Data.TextData[2][4*TextAddr+indx] = '\\0';\n\t\t\t\tpstRDSData->RT_Data.GetLength = 1;\n\t        }\n\t\t\telse if((4*TextAddr+indx) == 63 && pstRDSData->RT_Data.Addr_Cnt == 0xffff) //type A full data. /*add by dongbo, make sure it's TextData[2], Not TextData[1]*/\n\t\t\t{\n\t\t\t\tWCN_DBG(L6|D_G2, \"RT ---The 63 byte received.\\n\");\n\t\t\t    pstRDSData->RT_Data.TextLength = 4*TextAddr+indx+1;  //no terminal character\n\t\t\t\tpstRDSData->RT_Data.GetLength = 1;\n\t\t\t}\n        }\n\t}\n\telse\n\t{\n\t    //FM_DEBUG(\"RetrieveGroup2 Type B RT NUM: 0x%x Text: 0x%x\", TextAddr, block_data[3]);\n\t\tWCN_DBG(L7|D_G2, \"RT %04x %04x %04x %04x %04x\", block_data[0], block_data[1], block_data[2], block_data[3], block_data[4]);\n\t\tpstRDSData->RT_Data.isTypeA = 0;\n\t\tif(block_data[4]&FM_RDS_GDBK_IND_D)\n\t\t{\n            pstRDSData->RT_Data.TextData[0][2*TextAddr] = block_data[3]>>8;\n\t\t    pstRDSData->RT_Data.TextData[0][2*TextAddr+1] = block_data[3]&0xFF;\n\t\t\tspace = 0;\n\t\t\t\n\t  \t    for(indx = 0; indx < 2; indx++)\n\t  \t    {\n\t  \t        byte0 = pstRDSData->RT_Data.TextData[0][2*TextAddr+indx];\n\t\t\t    byte1 = pstRDSData->RT_Data.TextData[1][2*TextAddr+indx];\n\t\t\t\t\n\t\t\t\tif((!((pstRDSData->event_status)&RDS_EVENT_LAST_RADIOTEXT))&&(byte0 == byte1))\n\t\t\t\t{\n\t\t\t\t\tspace++;\n\t\t\t\t\tpstRDSData->RT_Data.TextData[2][2*TextAddr+indx] = byte0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpstRDSData->RT_Data.TextData[1][2*TextAddr+indx] = byte0;\n\t\t\t\t}\n\t  \t\t}\n\t\t\tif(space == 2)\n\t\t\t{\n\t\t\t    addrcnt = pstRDSData->RT_Data.Addr_Cnt;\n\t\t\t\tpstRDSData->RT_Data.Addr_Cnt |= (1<<TextAddr);\n\t\t\t\tWCN_DBG(L7|D_G2, \"RT RetrieveGroup2 RT B addrcnt: 0x%x, RT_Data.Addr_Cnt: 0x%x\\n\", addrcnt, pstRDSData->RT_Data.Addr_Cnt);\n\t\t\t\t\n                if(addrcnt == pstRDSData->RT_Data.Addr_Cnt)\n\t\t\t\t{\n\t\t\t\t    pstRDSData->RT_Data.BufCnt++;\n\t\t\t\t}\n\t\t\t\telse if(pstRDSData->RT_Data.BufCnt > 0)\n\t\t\t\t{\n\t\t\t\t\tpstRDSData->RT_Data.BufCnt--;\n\t\t\t\t}\n            }\n\t\t} else {\n\t\t\tWCN_DBG(L7|D_G2, \"RT %04x %04x %04x %04x %04x CRC error.\", block_data[0], block_data[1], block_data[2], block_data[3], block_data[4]);\n\t\t}\n\t\t\n\t \tfor(indx = 0; indx < 2; indx++)\n\t  \t{\n\t  \t\tif((pstRDSData->RT_Data.TextData[2][2*TextAddr+indx]) == 0x0D) //0x0D=end code\n\t  \t\t{\n\t  \t\t    pstRDSData->RT_Data.TextLength = 2*TextAddr+indx+1;  //Add terminate charater\n\t\t\t\tpstRDSData->RT_Data.TextData[2][2*TextAddr+indx] = '\\0';\n\t\t\t\tpstRDSData->RT_Data.GetLength = 1;\n\t  \t\t}\n\t\t\telse if((2*TextAddr+indx) == 31) //full data\n\t\t\t{\n\t\t\t    pstRDSData->RT_Data.TextLength = 2*TextAddr+indx+1;  //Add terminate charater\n                pstRDSData->RT_Data.TextData[2][2*TextAddr+indx] = '\\0';\n\t\t\t\tpstRDSData->RT_Data.GetLength = 1;\n\t\t\t}\n\t  \t}\t\t\n\t}\n    //Check if text is fully received\n\tindx = TextAddr;\n\tif(pstRDSData->RT_Data.GetLength == 1)\n\t{\n\t\taddrcnt = 0xFFFF>>(0x0F-indx);\n\t}\n\telse if(pstRDSData->RT_Data.BufCnt > 100)\n\t{\n\t    pstRDSData->RT_Data.BufCnt = 0;\n\t    for(indx = 15; indx >= 0; indx--)\n\t    {\n\t        addrcnt = (pstRDSData->RT_Data.Addr_Cnt)&(1<<indx);\n\t        if(addrcnt)\n\t            break;\n\t\t}\n\t\t\n\t\t//get valid radio text length\n\t\tif (pstRDSData->RT_Data.isTypeA)\n\t\t{\n\t\t    for(indx2 = 0; indx2 < 4; indx2++)\n\t\t    {\n\t\t        if(pstRDSData->RT_Data.TextData[2][4*indx+indx2] == 0x0D)\n\t            {\n\t  \t\t\t    pstRDSData->RT_Data.TextLength = 4*indx+indx2+1;\n\t\t\t\t\tpstRDSData->RT_Data.TextData[2][4*indx+indx2] = '\\0';\n\t            }\n\t\t    }\n\t    }\n\t    else\n\t    {\n\t        for(indx2 = 0; indx2 < 2; indx2++)\n\t\t    {\n\t\t        if(pstRDSData->RT_Data.TextData[2][2*indx+indx2] == 0x0D)\n\t            {\n\t  \t\t\t    pstRDSData->RT_Data.TextLength = 2*indx+indx2+1;\n\t\t\t\t\tpstRDSData->RT_Data.TextData[2][2*indx+indx2] = '\\0';\n\t            }\n\t\t    }\n\t        \n\t    }\n\t\taddrcnt = 0xFFFF>>(0x0F-indx);\n\t}\n\telse\n\t{\n\t\tpstRDSData->RT_Data.TextLength = 0x0F;\n\t\taddrcnt = 0xFFFF;\n\t}\n\t\n    WCN_DBG(L7|D_G2, \"RetrieveGroup2 RDS RT: Addr_Cnt: 0x%x Length: 0x%x addrcnt: 0x%x\\n\", pstRDSData->RT_Data.Addr_Cnt, pstRDSData->RT_Data.TextLength, addrcnt);\n\tif(((((pstRDSData->RT_Data.Addr_Cnt)&addrcnt) == addrcnt)||((TextAddr == 0x0f) && (pstRDSData->RT_Data.Addr_Cnt == 0xffff))))//&&(pstRDSData->RT_Data.isRTDisplay == 0))\n\t{\t\t\n\t\tpstRDSData->RT_Data.Addr_Cnt = 0;\n\t\t//pstRDSData->RT_Data.isRTDisplay = 1;\n\t\tpstRDSData->event_status |= RDS_EVENT_LAST_RADIOTEXT; \n\t\tspace = 0;\n\t\tfor(indx = 0; indx < 64; indx++)\n\t\t{\n\t\t\tif(pstRDSData->RT_Data.TextData[2][indx] == 0x20)\n\t\t\t\tspace++;\n\t    }\t\n\t    if(space == 64)\n            pstRDSData->event_status &= (~RDS_EVENT_LAST_RADIOTEXT);\n\t\tmemset(&(pstRDSData->RT_Data.TextData[1][0]), 0x20, sizeof(pstRDSData->RT_Data.TextData[1]));\n\t\tmemset(&(pstRDSData->RT_Data.TextData[0][0]), 0x20, sizeof(pstRDSData->RT_Data.TextData[0]));\n\t\tif (pstRDSData->event_status & RDS_EVENT_LAST_RADIOTEXT) {\n\t\t\tmemcpy(&(pstRDSData->RT_Data.TextData[3][0]), &(pstRDSData->RT_Data.TextData[2][0]), sizeof(pstRDSData->RT_Data.TextData[3]));\n\t\t\tuint8_t tmp[66] = {0};\n\t\t\ttmp[64] = 'E';\n\t\t\tmemcpy(tmp, pstRDSData->RT_Data.TextData[3], 64);\n\t\t\n\t\t\tWCN_DBG(L6|D_G2, \"RT Radio text---%s\\n\", tmp);\n\t\t\tWCN_DBG(L6|D_G2, \"RT set RDS_EVENT_LAST_RADIOTEXT flag, +++0x0D case.\\n\");\n\t\t\tpstRDSData->RT_Data.isRTDisplay = 1;\n\t\t}\n    }\n"]]}
{"hexsha": "d8dcc9678735a11a2887fc2e14ed671bbd7c66d3", "ext": "c", "lang": "C", "content": "void SystemInit(void)\n{\n  uint32_t i,nCount,nValue,nAddress,nChecksum;\n  \n  nCount = *(__IO uint32_t *)NVR_REGINFOCOUNT1;\n  nChecksum = nCount;\n  nChecksum = ~nChecksum;\n  if(nChecksum != *(__IO uint32_t *)(NVR_REGINFOCOUNT1+4))\n  {\n    nCount = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET);\n    nChecksum = nCount;\n    nChecksum = ~nChecksum;\n    if(nChecksum != *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET+4))\n    {\n      while(1);\n    }\n  }\n  \n  for(i=0; i<nCount; i++)\n  {\n    nAddress = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+8+i*12);\n    nValue = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+12+i*12);\n    nChecksum = nAddress + nValue;\n    nChecksum = ~nChecksum;\n    if(nChecksum != *(__IO uint32_t *)(NVR_REGINFOCOUNT1+16+i*12))\n    {\n      nAddress = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET+8+i*12);\n      nValue = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET+12+i*12);\n      nChecksum = nAddress + nValue;\n      nChecksum = ~nChecksum;\n      if(nChecksum != *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET+16+i*12))\n      {\n        while(1);\n      }\n    }\n    if((nAddress>=0x40014800) && (nAddress<=0x40015000))\n    {\n      RTC_WriteRegisters(nAddress, &nValue, 1);\n    }\n    else\n    {\n      *(__IO uint32_t *)(nAddress) = nValue;\n    }\n  }\n}", "item_id": 0, "repo": "BreederBai/rt-thread", "file": "bsp/Vango/v85xx/Libraries/CMSIS/Vango/V85xx/Source/system_target.c", "last_update_at": "2022-03-31T19:34:05+00:00", "question_id": "d8dcc9678735a11a2887fc2e14ed671bbd7c66d3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void SystemInit(void)\n{\n  uint32_t i,nCount,nValue,nAddress,nChecksum;\n  nCount = *(__IO uint32_t *)NVR_REGINFOCOUNT1;\n  nChecksum = nCount;\n  nChecksum = ~nChecksum;\n  if(nChecksum != *(__IO uint32_t *)(NVR_REGINFOCOUNT1+4))\n  {\n    nCount = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET);\n    nChecksum = nCount;\n    nChecksum = ~nChecksum;\n    if(nChecksum != *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET+4))\n    {\n      while(1);\n    }\n  }\n  for(i=0; i<nCount; i++)\n  {\n    nAddress = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+8+i*12);\n    nValue = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+12+i*12);\n    nChecksum = nAddress + nValue;\n    nChecksum = ~nChecksum;\n    if(nChecksum != *(__IO uint32_t *)(NVR_REGINFOCOUNT1+16+i*12))\n    {\n      nAddress = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET+8+i*12);\n      nValue = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET+12+i*12);\n      nChecksum = nAddress + nValue;\n      nChecksum = ~nChecksum;\n      if(nChecksum != *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET+16+i*12))\n      {\n        while(1);\n      }\n    }\n    if((nAddress>=0x40014800) && (nAddress<=0x40015000))\n    {\n      RTC_WriteRegisters(nAddress, &nValue, 1);\n    }\n    else\n    {\n      *(__IO uint32_t *)(nAddress) = nValue;\n    }\n  }\n"]]}
{"hexsha": "1c3ce67a283e259a2edc25fedbfaa303a04db6f2", "ext": "c", "lang": "C", "content": "static intptr_t i_lchar(intptr_t s, intptr_t n, intptr_t c)\n{\n    char* p = (char*)(s<<SHIFT);\n    p[n] = c;\n\treturn c;\n}", "item_id": 0, "repo": "wyan/ack", "file": "lang/b/lib/main.c", "last_update_at": "2022-03-31T02:14:30+00:00", "question_id": "1c3ce67a283e259a2edc25fedbfaa303a04db6f2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static intptr_t i_lchar(intptr_t s, intptr_t n, intptr_t c)\n{\n    char* p = (char*)(s<<SHIFT);\n    p[n] = c;\n\treturn c;\n"]]}
{"hexsha": "369f69aa446473482c4061d3a49e9d036fd85bc2", "ext": "c", "lang": "C", "content": "__DEVICE__ float noise (in float2 _st) {\n    float2 i = _floor(_st);\n    float2 f = fract_f2(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + to_float2(1.0f, 0.0f));\n    float c = random(i + to_float2(0.0f, 1.0f));\n    float d = random(i + to_float2(1.0f, 1.0f));\n\n    float2 u = f * f * (3.0f - 2.0f * f);\n\n    return _mix(a, b, u.x) +\n           (c - a)* u.y * (1.0f - u.x) +\n           (d - b) * u.x * u.y;\n}", "item_id": 1, "repo": "nmbr73/Fetch-n-Fuse", "file": "Conversions/RotationL.slGXWD.c", "last_update_at": "2022-01-29T11:10:03+00:00", "question_id": "369f69aa446473482c4061d3a49e9d036fd85bc2_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["__DEVICE__ float noise (in float2 _st) {\n    float2 i = _floor(_st);\n    float2 f = fract_f2(_st);\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + to_float2(1.0f, 0.0f));\n    float c = random(i + to_float2(0.0f, 1.0f));\n    float d = random(i + to_float2(1.0f, 1.0f));\n    float2 u = f * f * (3.0f - 2.0f * f);\n    return _mix(a, b, u.x) +\n           (c - a)* u.y * (1.0f - u.x) +\n           (d - b) * u.x * u.y;\n"]]}
{"hexsha": "3a8ab63c2865dcb937fe0d930336646bf6f37532", "ext": "c", "lang": "C", "content": "int CheckParm (char *check)\n{\n\tint             i;\n\n\tfor (i = 1;i<myargc;i++)\n\t{\n\t\tif ( !Q_strcasecmp(check, myargv[i]) )\n\t\t\treturn i;\n\t}\n\n\treturn 0;\n}", "item_id": 20, "repo": "arbaazkhan2/act_unreal", "file": "engine/code/bspc/l_cmd.c", "last_update_at": "2022-03-31T12:19:09+00:00", "question_id": "3a8ab63c2865dcb937fe0d930336646bf6f37532_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int CheckParm (char *check)\n{\n\tint             i;\n\tfor (i = 1;i<myargc;i++)\n\t{\n\t\tif ( !Q_strcasecmp(check, myargv[i]) )\n\t\t\treturn i;\n\t}\n\treturn 0;\n"]]}
{"hexsha": "583acd4f3c34a0d2535d7a45a0426db50a6e7cb8", "ext": "c", "lang": "C", "content": "__attribute__((always_inline)) static inline int32_t __QSUB( int32_t op1, int32_t op2)\n{\n  int32_t result;\n\n  __asm volatile (\"qsub %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );\n  return(result);\n}", "item_id": 80, "repo": "RAKWireless/RAK-STM32-RUI", "file": "cores/STM32WLE/external/STM32CubeWL/Utilities/misc/stm32_mem.c", "last_update_at": "2022-03-30T09:53:52+00:00", "question_id": "583acd4f3c34a0d2535d7a45a0426db50a6e7cb8_80", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["__attribute__((always_inline)) static inline int32_t __QSUB( int32_t op1, int32_t op2)\n{\n  int32_t result;\n  __asm volatile (\"qsub %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );\n  return(result);\n"]]}
{"hexsha": "9effcf55ef60167a71aefc773ff3946952f6fef0", "ext": "c", "lang": "C", "content": "static int virtio_ccw_online(struct ccw_device *cdev)\n{\n\tint ret;\n\tstruct virtio_ccw_device *vcdev;\n\n\tvcdev = kzalloc(sizeof(*vcdev), GFP_KERNEL);\n\tif (!vcdev) {\n\t\tdev_warn(&cdev->dev, \"Could not get memory for virtio\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tvcdev->config_block = kzalloc(sizeof(*vcdev->config_block),\n\t\t\t\t   GFP_DMA | GFP_KERNEL);\n\tif (!vcdev->config_block) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tvcdev->status = kzalloc(sizeof(*vcdev->status), GFP_DMA | GFP_KERNEL);\n\tif (!vcdev->status) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tvcdev->vdev.dev.parent = &cdev->dev;\n\tvcdev->vdev.dev.release = virtio_ccw_release_dev;\n\tvcdev->vdev.config = &virtio_ccw_config_ops;\n\tvcdev->cdev = cdev;\n\tinit_waitqueue_head(&vcdev->wait_q);\n\tINIT_LIST_HEAD(&vcdev->virtqueues);\n\tspin_lock_init(&vcdev->lock);\n\n\tdev_set_drvdata(&cdev->dev, vcdev);\n\tvcdev->vdev.id.vendor = cdev->id.cu_type;\n\tvcdev->vdev.id.device = cdev->id.cu_model;\n\tret = register_virtio_device(&vcdev->vdev);\n\tif (ret) {\n\t\tdev_warn(&cdev->dev, \"Failed to register virtio device: %d\\n\",\n\t\t\t ret);\n\t\tgoto out_put;\n\t}\n\treturn 0;\nout_put:\n\tdev_set_drvdata(&cdev->dev, NULL);\n\tput_device(&vcdev->vdev.dev);\n\treturn ret;\nout_free:\n\tif (vcdev) {\n\t\tkfree(vcdev->status);\n\t\tkfree(vcdev->config_block);\n\t}\n\tkfree(vcdev);\n\treturn ret;\n}", "item_id": 24, "repo": "Albocoder/KOOBE", "file": "s2e/source/s2e-linux-kernel/decree-cgc-cfe/drivers/s390/kvm/virtio_ccw.c", "last_update_at": "2022-01-16T07:19:47+00:00", "question_id": "9effcf55ef60167a71aefc773ff3946952f6fef0_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int virtio_ccw_online(struct ccw_device *cdev)\n{\n\tint ret;\n\tstruct virtio_ccw_device *vcdev;\n\tvcdev = kzalloc(sizeof(*vcdev), GFP_KERNEL);\n\tif (!vcdev) {\n\t\tdev_warn(&cdev->dev, \"Could not get memory for virtio\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tvcdev->config_block = kzalloc(sizeof(*vcdev->config_block),\n\t\t\t\t   GFP_DMA | GFP_KERNEL);\n\tif (!vcdev->config_block) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tvcdev->status = kzalloc(sizeof(*vcdev->status), GFP_DMA | GFP_KERNEL);\n\tif (!vcdev->status) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tvcdev->vdev.dev.parent = &cdev->dev;\n\tvcdev->vdev.dev.release = virtio_ccw_release_dev;\n\tvcdev->vdev.config = &virtio_ccw_config_ops;\n\tvcdev->cdev = cdev;\n\tinit_waitqueue_head(&vcdev->wait_q);\n\tINIT_LIST_HEAD(&vcdev->virtqueues);\n\tspin_lock_init(&vcdev->lock);\n\tdev_set_drvdata(&cdev->dev, vcdev);\n\tvcdev->vdev.id.vendor = cdev->id.cu_type;\n\tvcdev->vdev.id.device = cdev->id.cu_model;\n\tret = register_virtio_device(&vcdev->vdev);\n\tif (ret) {\n\t\tdev_warn(&cdev->dev, \"Failed to register virtio device: %d\\n\",\n\t\t\t ret);\n\t\tgoto out_put;\n\t}\n\treturn 0;\nout_put:\n\tdev_set_drvdata(&cdev->dev, NULL);\n\tput_device(&vcdev->vdev.dev);\n\treturn ret;\nout_free:\n\tif (vcdev) {\n\t\tkfree(vcdev->status);\n\t\tkfree(vcdev->config_block);\n\t}\n\tkfree(vcdev);\n\treturn ret;\n"]]}
{"hexsha": "d7ba155cd489d5528ac8b7d0643b7e5f883869d5", "ext": "h", "lang": "C", "content": "static inline size_t sbp_u64_encode(sbp_encode_ctx_t *ctx, const u64 *v) {\n  if (!SBP_CAN_PACK(ctx, u64)) {\n    return false;\n  }\n  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x00000000000000ff) >> (8U * 0U));\n  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x000000000000ff00) >> (8U * 1U));\n  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x0000000000ff0000) >> (8U * 2U));\n  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x00000000ff000000) >> (8U * 3U));\n  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x000000ff00000000) >> (8U * 4U));\n  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x0000ff0000000000) >> (8U * 5U));\n  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x00ff000000000000) >> (8U * 6U));\n  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0xff00000000000000) >> (8U * 7U));\n  return true;\n}", "item_id": 3, "repo": "Patrick-Luo-THR/libsbp", "file": "c/src/include/libsbp/internal/v4/common.h", "last_update_at": "2022-02-24T12:36:49+00:00", "question_id": "d7ba155cd489d5528ac8b7d0643b7e5f883869d5_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline size_t sbp_u64_encode(sbp_encode_ctx_t *ctx, const u64 *v) {\n  if (!SBP_CAN_PACK(ctx, u64)) {\n    return false;\n  }\n  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x00000000000000ff) >> (8U * 0U));\n  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x000000000000ff00) >> (8U * 1U));\n  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x0000000000ff0000) >> (8U * 2U));\n  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x00000000ff000000) >> (8U * 3U));\n  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x000000ff00000000) >> (8U * 4U));\n  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x0000ff0000000000) >> (8U * 5U));\n  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x00ff000000000000) >> (8U * 6U));\n  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0xff00000000000000) >> (8U * 7U));\n  return true;\n"]]}
{"hexsha": "bed4cbbc9b46a4cd831e842bbb442e7aae76bf46", "ext": "c", "lang": "C", "content": "void _endthreadex(unsigned retval)\r\n{\r\n    char * env;\r\n    struct THREAD *thd;\r\n    int i;\r\n\r\n    thd = _getthreaddata();\r\n    env = thd->t_envptr;\r\n    if (env != 0)\r\n        _free_crt (env);\r\n\r\n    for (i = 0; i < THREADMAX; i++) \r\n    {\r\n        if (__thdtbl[i] == thd)\r\n        {\r\n            __thdtbl[i] = 0;\r\n            break;\r\n        }\r\n    }\r\n    _free_crt (thd);\r\n    ExitThread (retval);\r\n}", "item_id": 2, "repo": "masscry/dmc", "file": "src/WIN32/threadex.c", "last_update_at": "2022-03-13T03:01:25+00:00", "question_id": "bed4cbbc9b46a4cd831e842bbb442e7aae76bf46_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void _endthreadex(unsigned retval)\r\n{\r\n    char * env;\r\n    struct THREAD *thd;\r\n    int i;\r\n\r\n    thd = _getthreaddata();\r\n    env = thd->t_envptr;\r\n    if (env != 0)\r\n        _free_crt (env);\r\n\r\n    for (i = 0; i < THREADMAX; i++) \r\n    {\r\n        if (__thdtbl[i] == thd)\r\n        {\r\n            __thdtbl[i] = 0;\r\n            break;\r\n        }\r\n    }\r\n    _free_crt (thd);\r\n    ExitThread (retval);\r\n"]]}
{"hexsha": "149cf3c2abe4f09ef9e258d34cca68c8b05a47ba", "ext": "c", "lang": "C", "content": "static void NandWriteAddress5B(void)\r\n\t{\r\n\t\tFLASH_ALE = 1;\t\t\t// Address latch enable\r\n\t    NandWriteRaw(0);HSPSPWait(); \t// Only write zeros\r\n\t    NandWriteRaw(0);HSPSPWait(); \t// to these two bytes\r\n\t    NandWriteRaw(AddBytes[0]);HSPSPWait(); //  The next 3 bytes\r\n\t    NandWriteRaw(AddBytes[1]);HSPSPWait();//\tare the page and\r\n\t    NandWriteRaw(AddBytes[2]);\t\t\t//\tblock addresses\r\n\t\tFLASH_ALE = 0;\t\t\t// Address latch disable\r\n\t\treturn;\r\n\t}", "item_id": 2, "repo": "digitalinteraction/openmovement", "file": "Firmware/Flux.AX3/src/Peripherals/Nand.c", "last_update_at": "2022-02-08T14:51:24+00:00", "question_id": "149cf3c2abe4f09ef9e258d34cca68c8b05a47ba_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void NandWriteAddress5B(void)\r\n\t{\r\n\t\tFLASH_ALE = 1;\t\t\t// Address latch enable\r\n\t    NandWriteRaw(0);HSPSPWait(); \t// Only write zeros\r\n\t    NandWriteRaw(0);HSPSPWait(); \t// to these two bytes\r\n\t    NandWriteRaw(AddBytes[0]);HSPSPWait(); //  The next 3 bytes\r\n\t    NandWriteRaw(AddBytes[1]);HSPSPWait();//\tare the page and\r\n\t    NandWriteRaw(AddBytes[2]);\t\t\t//\tblock addresses\r\n\t\tFLASH_ALE = 0;\t\t\t// Address latch disable\r\n\t\treturn;\r\n"]]}
{"hexsha": "6541816868ed186ed44d0daed3d9aadd313dda23", "ext": "h", "lang": "C", "content": "extern __inline__ void skb_insert(struct sk_buff *old, struct sk_buff *newsk)\n{\n\tunsigned long flags;\n\n\tsave_flags(flags);\n\tcli();\n\t__skb_insert(old, newsk);\n\trestore_flags(flags);\n}", "item_id": 9, "repo": "eyadhamdan4/xMach", "file": "kernel/kernel/i386at/gpl/linux/include/linux/skbuff.h", "last_update_at": "2022-01-24T05:30:29+00:00", "question_id": "6541816868ed186ed44d0daed3d9aadd313dda23_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["extern __inline__ void skb_insert(struct sk_buff *old, struct sk_buff *newsk)\n{\n\tunsigned long flags;\n\tsave_flags(flags);\n\tcli();\n\t__skb_insert(old, newsk);\n\trestore_flags(flags);\n"]]}
{"hexsha": "c8a02cd10b4fb285c7c9f2c39fc1c20b2981a4b6", "ext": "c", "lang": "C", "content": "REAL PrintTorsionEnergyStatus(int nr,char *string,int TorsionType,REAL *parms,REAL Phi)\n{\n  REAL U,CosPhi,CosPhi2;\n\n  CosPhi=cos(Phi);\n  CosPhi2=SQR(CosPhi);\n  switch(TorsionType)\n  {\n    case HARMONIC_DIHEDRAL:\n      // (1/2)*p_0*(phi-p_1)^2\n      // ===============================================\n      // p_0/k_B [K/rad^2]\n      // p_1     [degrees]\n      // potential defined in terms of 'phi' and therefore contains a singularity\n      // the sign of the angle-phi is positive if (Rab x Rbc) x (Rbc x Rcd) is in the\n      // same direction as Rbc, and negative otherwise\n      Phi-=parms[1];\n      Phi-=NINT(Phi/(2.0*M_PI))*2.0*M_PI;\n      U=0.5*parms[0]*SQR(Phi);\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d HARMONIC_DIHEDRAL %s, p_0/k_B=%8.5f [K/rad^2],  p_1=%8.5f [A], \"\n                                           \"Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1]*RAD2DEG,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case HARMONIC_COSINE_DIHEDRAL:\n      // (1/2)*p_0*(cos(phi)-cos(p_1))^2\n      // ===============================================\n      // p_0/k_B [K]\n      // p_1     [degrees]\n      U=0.5*parms[0]*SQR(CosPhi-cos(parms[1]));\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d HARMONIC_COSINE_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1=%8.5f [degrees], \"\n                                           \"Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                acos(parms[1])*RAD2DEG,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case THREE_COSINE_DIHEDRAL:\n      // (1/2)*p_0*(1+cos(phi))+(1/2)*p_1*(1-cos(2*phi))+(1/2)*p_2*(1+cos(3*phi))\n      // ========================================================================\n      // p_0/k_B [K]\n      // p_1/k_B [K]\n      // p_2/k_B [K]\n      U=0.5*parms[0]*(1.0+CosPhi)+parms[1]*(1.0-CosPhi2)+0.5*parms[2]*(1.0-3.0*CosPhi+4.0*CosPhi*CosPhi2);\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d THREE_COSINE_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], \"\n                                           \"Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1]*ENERGY_TO_KELVIN,\n                parms[2]*ENERGY_TO_KELVIN,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case MM3_DIHEDRAL:\n      // (1/2)*p_0*(1+cos(phi))+(1/2)*p_1*(1-cos(2*phi))+(1/2)*p_2*(1+cos(3*phi))\n      // ========================================================================\n      // p_0     [kcal/mol]\n      // p_1     [kcal/mol]\n      // p_2     [kcal/mol]\n      U=0.5*parms[0]*(1.0+CosPhi)+parms[1]*(1.0-CosPhi2)+0.5*parms[2]*(1.0-3.0*CosPhi+4.0*CosPhi*CosPhi2);\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d MM3_DIHEDRAL %s, p_0=%8.5f [kcal/mol], p_1=%8.5f [kcal/mol], p_2=%8.5f [kcal/mol], \"\n                                           \"Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]/KCAL_PER_MOL_TO_ENERGY,\n                parms[1]/KCAL_PER_MOL_TO_ENERGY,\n                parms[2]/KCAL_PER_MOL_TO_ENERGY,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case CVFF_BLOCKED_DIHEDRAL:\n      //\n      // ========================================================================\n      // p_0     [rad]\n      // p_1     [K]\n      // p_2     [-]\n      // p_3     [rad]\n      // p_4     [rad]\n      U=0;\n      break;\n    case CFF_DIHEDRAL:\n      // p_0*(1-cos(phi))+p_1*(1-cos(2*phi))+p_2*(1-cos(3*phi))\n      // ======================================================\n      // p_0/k_B [K]\n      // p_1/k_B [K]\n      // p_2/k_B [K]\n      U=parms[0]*(1.0-CosPhi)+2.0*parms[1]*(1.0-CosPhi2)+parms[2]*(1.0+3.0*CosPhi-4.0*CosPhi*CosPhi2);\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d CFF_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], \"\n                                           \"Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1]*ENERGY_TO_KELVIN,\n                parms[2]*ENERGY_TO_KELVIN,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case CFF_DIHEDRAL2:\n      // p_0*(1+cos(phi))+p_1*(1+cos(2*phi))+p_2*(1+cos(3*phi))\n      // ======================================================\n      // p_0/k_B [K]\n      // p_1/k_B [K]\n      // p_2/k_B [K]\n      U=parms[0]*(1.0+CosPhi)+parms[2]+CosPhi*(-3.0*parms[2]+2.0*CosPhi*(parms[1]+2.0*parms[2]*CosPhi));\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d CFF_DIHEDRAL2 %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], \"\n                                           \"Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1]*ENERGY_TO_KELVIN,\n                parms[2]*ENERGY_TO_KELVIN,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case SIX_COSINE_DIHEDRAL:\n      // Prod_i=0^5 p_i*cos(phi)^i\n      // =========================\n      // p_0/k_B [K]\n      // p_1/k_B [K]\n      // p_2/k_B [K]\n      // p_3/k_B [K]\n      // p_4/k_B [K]\n      // p_5/k_B [K]\n      // the Ryckaert-Bellemans potentials is often used for alkanes, the use implies exclusion of VDW-interactions\n      // between the first and last atoms of the dihedral, and Phi'=Phi-pi is defined accoording to the\n      // polymer convention Phi'(trans)=0.\n      U=parms[0]-parms[1]*CosPhi+parms[2]*CosPhi2-parms[3]*CosPhi*CosPhi2+\n             parms[4]*SQR(CosPhi2)-parms[5]*SQR(CosPhi2)*CosPhi;\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d SIX_COSINE_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], \"\n                                           \"p_3/k_B=%8.5f [K], p_4/k_B=%8.5f [K], p_5/k_B=%8.5f [K], Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1]*ENERGY_TO_KELVIN,\n                parms[2]*ENERGY_TO_KELVIN,\n                parms[3]*ENERGY_TO_KELVIN,\n                parms[4]*ENERGY_TO_KELVIN,\n                parms[5]*ENERGY_TO_KELVIN,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case TRAPPE_DIHEDRAL:\n      // p_0[0]+p_1*(1+cos(phi))+p_2*(1-cos(2*phi))+p_3*(1+cos(3*phi))\n      // =============================================================\n      // p_0/k_B [K]\n      // p_1/k_B [K]\n      // p_2/k_B [K]\n      // p_3/k_B [K]\n      U=parms[0]+(1.0+CosPhi)*(parms[1]+parms[3]-2.0*(CosPhi-1.0)*(parms[2]-2.0*parms[3]*CosPhi));\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d TRAPPE_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], \"\n                                           \"p_3/k_B=%8.5f [K], Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1]*ENERGY_TO_KELVIN,\n                parms[2]*ENERGY_TO_KELVIN,\n                parms[3]*ENERGY_TO_KELVIN,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case CVFF_DIHEDRAL:\n      // p_0*(1+cos(p_1*phi-p_2))\n      // ========================\n      // p_0/k_B [K]\n      // p_1     [-]\n      // p_2     [degrees]\n      U=parms[0]*(1.0+cos(parms[1]*Phi-parms[2]));\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d CVFF_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1=%8.5f [-], p_2=%8.5f [degrees], \"\n                                           \"Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1],\n                parms[2]*RAD2DEG,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case OPLS_DIHEDRAL:\n      // (1/2)p_0[0]+(1/2)p_1*(1+cos(phi))+(1/2)p_2*(1-cos(2*phi))+(1/2)p_3*(1+cos(3*phi))\n      // =================================================================================\n      // p_0/k_B [K]\n      // p_1/k_B [K]\n      // p_2/k_B [K]\n      // p_3/k_B [K]\n      U=0.5*(parms[0]+(1.0+CosPhi)*(parms[1]+parms[3]-2.0*(CosPhi-1.0)*(parms[2]-2.0*parms[3]*CosPhi)));\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d OPLS_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], \"\n                                           \"p_3/k_B=%8.5f [K], Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1]*ENERGY_TO_KELVIN,\n                parms[2]*ENERGY_TO_KELVIN,\n                parms[3]*ENERGY_TO_KELVIN,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case FOURIER_SERIES_DIHEDRAL:\n      // (1/2)p_0*(1+cos(phi))+(1/2)p_1(1-cos(2*phi))+(1/2)*p2_2*(1+cos(3*phi))+\n      // (1/2)p_3*(1-cos(4*phi))+(1/2)p_4*(1+cos(5*phi))+(1/2)p_5*(1+cos(6*phi))\n      // =======================================================================\n      // p_0/k_B [K]\n      // p_1/k_B [K]\n      // p_2/k_B [K]\n      // p_3/k_B [K]\n      // p_4/k_B [K]\n      // p_5/k_B [K]\n      U=0.5*(parms[0]+2.0*parms[1]+parms[2]+parms[4]+2.0*parms[5]+(parms[0]-3.0*parms[2]+5.0*parms[4])*CosPhi-\n             2.0*(parms[1]-4.0*parms[3]+9.0*parms[5])*CosPhi2+4.0*(parms[2]-5.0*parms[4])*CosPhi2*CosPhi-\n             8.0*(parms[3]-6.0*parms[5])*SQR(CosPhi2)+16.0*parms[4]*SQR(CosPhi2)*CosPhi-32.0*parms[5]*CUBE(CosPhi2));\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d FOURIER_SERIES_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], \"\n                                           \"p_3/k_B=%8.5f [K], p_4/k_B=%8.5f [K], p_5/k_B=%8.5f [K], Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1]*ENERGY_TO_KELVIN,\n                parms[2]*ENERGY_TO_KELVIN,\n                parms[3]*ENERGY_TO_KELVIN,\n                parms[4]*ENERGY_TO_KELVIN,\n                parms[5]*ENERGY_TO_KELVIN,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case FOURIER_SERIES_DIHEDRAL2:\n      // (1/2)p_0*(1+cos(phi))+(1/2)p_1(1-cos(2*phi))+(1/2)*p2_2*(1+cos(3*phi))+\n      // (1/2)p_3*(1+cos(4*phi))+(1/2)p_4*(1+cos(5*phi))+(1/2)p_5*(1+cos(6*phi))\n      // =======================================================================\n      // p_0/k_B [K]\n      // p_1/k_B [K]\n      // p_2/k_B [K]\n      // p_3/k_B [K]\n      // p_4/k_B [K]\n      // p_5/k_B [K]\n      U=0.5*(parms[2]+2.0*parms[3]+parms[4]-3.0*parms[2]*CosPhi+5.0*parms[4]*CosPhi+parms[0]*(1.0+CosPhi)+\n        2.0*(parms[1]-parms[1]*CosPhi2+CosPhi2*(parms[5]*SQR(3.0-4.0*CosPhi2)+4.0*parms[3]*(CosPhi2-1.0)+\n        2.0*CosPhi*(parms[2]+parms[4]*(4.0*CosPhi2-5.0)))));\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d FOURIER_SERIES_DIHEDRAL2 %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], \"\n                                           \"p_3/k_B=%8.5f [K], p_4/k_B=%8.5f [K], p_5/k_B=%8.5f [K], Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1]*ENERGY_TO_KELVIN,\n                parms[2]*ENERGY_TO_KELVIN,\n                parms[3]*ENERGY_TO_KELVIN,\n                parms[4]*ENERGY_TO_KELVIN,\n                parms[5]*ENERGY_TO_KELVIN,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    default:\n      fprintf(stderr, \"Undefined Torsion potential in routine 'CalculateFrameworkTorsionEnergy' ('framework_energy.c')\\n\");\n      exit(0);\n      break;\n  }\n  return U;\n}", "item_id": 5, "repo": "benjaminbolbrinker/RASPA2", "file": "src/status.c", "last_update_at": "2022-03-10T22:14:06+00:00", "question_id": "c8a02cd10b4fb285c7c9f2c39fc1c20b2981a4b6_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["REAL PrintTorsionEnergyStatus(int nr,char *string,int TorsionType,REAL *parms,REAL Phi)\n{\n  REAL U,CosPhi,CosPhi2;\n  CosPhi=cos(Phi);\n  CosPhi2=SQR(CosPhi);\n  switch(TorsionType)\n  {\n    case HARMONIC_DIHEDRAL:\n      // (1/2)*p_0*(phi-p_1)^2\n      // ===============================================\n      // p_0/k_B [K/rad^2]\n      // p_1     [degrees]\n      // potential defined in terms of 'phi' and therefore contains a singularity\n      // the sign of the angle-phi is positive if (Rab x Rbc) x (Rbc x Rcd) is in the\n      // same direction as Rbc, and negative otherwise\n      Phi-=parms[1];\n      Phi-=NINT(Phi/(2.0*M_PI))*2.0*M_PI;\n      U=0.5*parms[0]*SQR(Phi);\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d HARMONIC_DIHEDRAL %s, p_0/k_B=%8.5f [K/rad^2],  p_1=%8.5f [A], \"\n                                           \"Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1]*RAD2DEG,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case HARMONIC_COSINE_DIHEDRAL:\n      // (1/2)*p_0*(cos(phi)-cos(p_1))^2\n      // ===============================================\n      // p_0/k_B [K]\n      // p_1     [degrees]\n      U=0.5*parms[0]*SQR(CosPhi-cos(parms[1]));\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d HARMONIC_COSINE_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1=%8.5f [degrees], \"\n                                           \"Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                acos(parms[1])*RAD2DEG,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case THREE_COSINE_DIHEDRAL:\n      // (1/2)*p_0*(1+cos(phi))+(1/2)*p_1*(1-cos(2*phi))+(1/2)*p_2*(1+cos(3*phi))\n      // ========================================================================\n      // p_0/k_B [K]\n      // p_1/k_B [K]\n      // p_2/k_B [K]\n      U=0.5*parms[0]*(1.0+CosPhi)+parms[1]*(1.0-CosPhi2)+0.5*parms[2]*(1.0-3.0*CosPhi+4.0*CosPhi*CosPhi2);\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d THREE_COSINE_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], \"\n                                           \"Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1]*ENERGY_TO_KELVIN,\n                parms[2]*ENERGY_TO_KELVIN,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case MM3_DIHEDRAL:\n      // (1/2)*p_0*(1+cos(phi))+(1/2)*p_1*(1-cos(2*phi))+(1/2)*p_2*(1+cos(3*phi))\n      // ========================================================================\n      // p_0     [kcal/mol]\n      // p_1     [kcal/mol]\n      // p_2     [kcal/mol]\n      U=0.5*parms[0]*(1.0+CosPhi)+parms[1]*(1.0-CosPhi2)+0.5*parms[2]*(1.0-3.0*CosPhi+4.0*CosPhi*CosPhi2);\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d MM3_DIHEDRAL %s, p_0=%8.5f [kcal/mol], p_1=%8.5f [kcal/mol], p_2=%8.5f [kcal/mol], \"\n                                           \"Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]/KCAL_PER_MOL_TO_ENERGY,\n                parms[1]/KCAL_PER_MOL_TO_ENERGY,\n                parms[2]/KCAL_PER_MOL_TO_ENERGY,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case CVFF_BLOCKED_DIHEDRAL:\n      //\n      // ========================================================================\n      // p_0     [rad]\n      // p_1     [K]\n      // p_2     [-]\n      // p_3     [rad]\n      // p_4     [rad]\n      U=0;\n      break;\n    case CFF_DIHEDRAL:\n      // p_0*(1-cos(phi))+p_1*(1-cos(2*phi))+p_2*(1-cos(3*phi))\n      // ======================================================\n      // p_0/k_B [K]\n      // p_1/k_B [K]\n      // p_2/k_B [K]\n      U=parms[0]*(1.0-CosPhi)+2.0*parms[1]*(1.0-CosPhi2)+parms[2]*(1.0+3.0*CosPhi-4.0*CosPhi*CosPhi2);\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d CFF_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], \"\n                                           \"Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1]*ENERGY_TO_KELVIN,\n                parms[2]*ENERGY_TO_KELVIN,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case CFF_DIHEDRAL2:\n      // p_0*(1+cos(phi))+p_1*(1+cos(2*phi))+p_2*(1+cos(3*phi))\n      // ======================================================\n      // p_0/k_B [K]\n      // p_1/k_B [K]\n      // p_2/k_B [K]\n      U=parms[0]*(1.0+CosPhi)+parms[2]+CosPhi*(-3.0*parms[2]+2.0*CosPhi*(parms[1]+2.0*parms[2]*CosPhi));\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d CFF_DIHEDRAL2 %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], \"\n                                           \"Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1]*ENERGY_TO_KELVIN,\n                parms[2]*ENERGY_TO_KELVIN,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case SIX_COSINE_DIHEDRAL:\n      // Prod_i=0^5 p_i*cos(phi)^i\n      // =========================\n      // p_0/k_B [K]\n      // p_1/k_B [K]\n      // p_2/k_B [K]\n      // p_3/k_B [K]\n      // p_4/k_B [K]\n      // p_5/k_B [K]\n      // the Ryckaert-Bellemans potentials is often used for alkanes, the use implies exclusion of VDW-interactions\n      // between the first and last atoms of the dihedral, and Phi'=Phi-pi is defined accoording to the\n      // polymer convention Phi'(trans)=0.\n      U=parms[0]-parms[1]*CosPhi+parms[2]*CosPhi2-parms[3]*CosPhi*CosPhi2+\n             parms[4]*SQR(CosPhi2)-parms[5]*SQR(CosPhi2)*CosPhi;\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d SIX_COSINE_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], \"\n                                           \"p_3/k_B=%8.5f [K], p_4/k_B=%8.5f [K], p_5/k_B=%8.5f [K], Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1]*ENERGY_TO_KELVIN,\n                parms[2]*ENERGY_TO_KELVIN,\n                parms[3]*ENERGY_TO_KELVIN,\n                parms[4]*ENERGY_TO_KELVIN,\n                parms[5]*ENERGY_TO_KELVIN,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case TRAPPE_DIHEDRAL:\n      // p_0[0]+p_1*(1+cos(phi))+p_2*(1-cos(2*phi))+p_3*(1+cos(3*phi))\n      // =============================================================\n      // p_0/k_B [K]\n      // p_1/k_B [K]\n      // p_2/k_B [K]\n      // p_3/k_B [K]\n      U=parms[0]+(1.0+CosPhi)*(parms[1]+parms[3]-2.0*(CosPhi-1.0)*(parms[2]-2.0*parms[3]*CosPhi));\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d TRAPPE_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], \"\n                                           \"p_3/k_B=%8.5f [K], Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1]*ENERGY_TO_KELVIN,\n                parms[2]*ENERGY_TO_KELVIN,\n                parms[3]*ENERGY_TO_KELVIN,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case CVFF_DIHEDRAL:\n      // p_0*(1+cos(p_1*phi-p_2))\n      // ========================\n      // p_0/k_B [K]\n      // p_1     [-]\n      // p_2     [degrees]\n      U=parms[0]*(1.0+cos(parms[1]*Phi-parms[2]));\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d CVFF_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1=%8.5f [-], p_2=%8.5f [degrees], \"\n                                           \"Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1],\n                parms[2]*RAD2DEG,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case OPLS_DIHEDRAL:\n      // (1/2)p_0[0]+(1/2)p_1*(1+cos(phi))+(1/2)p_2*(1-cos(2*phi))+(1/2)p_3*(1+cos(3*phi))\n      // =================================================================================\n      // p_0/k_B [K]\n      // p_1/k_B [K]\n      // p_2/k_B [K]\n      // p_3/k_B [K]\n      U=0.5*(parms[0]+(1.0+CosPhi)*(parms[1]+parms[3]-2.0*(CosPhi-1.0)*(parms[2]-2.0*parms[3]*CosPhi)));\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d OPLS_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], \"\n                                           \"p_3/k_B=%8.5f [K], Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1]*ENERGY_TO_KELVIN,\n                parms[2]*ENERGY_TO_KELVIN,\n                parms[3]*ENERGY_TO_KELVIN,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case FOURIER_SERIES_DIHEDRAL:\n      // (1/2)p_0*(1+cos(phi))+(1/2)p_1(1-cos(2*phi))+(1/2)*p2_2*(1+cos(3*phi))+\n      // (1/2)p_3*(1-cos(4*phi))+(1/2)p_4*(1+cos(5*phi))+(1/2)p_5*(1+cos(6*phi))\n      // =======================================================================\n      // p_0/k_B [K]\n      // p_1/k_B [K]\n      // p_2/k_B [K]\n      // p_3/k_B [K]\n      // p_4/k_B [K]\n      // p_5/k_B [K]\n      U=0.5*(parms[0]+2.0*parms[1]+parms[2]+parms[4]+2.0*parms[5]+(parms[0]-3.0*parms[2]+5.0*parms[4])*CosPhi-\n             2.0*(parms[1]-4.0*parms[3]+9.0*parms[5])*CosPhi2+4.0*(parms[2]-5.0*parms[4])*CosPhi2*CosPhi-\n             8.0*(parms[3]-6.0*parms[5])*SQR(CosPhi2)+16.0*parms[4]*SQR(CosPhi2)*CosPhi-32.0*parms[5]*CUBE(CosPhi2));\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d FOURIER_SERIES_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], \"\n                                           \"p_3/k_B=%8.5f [K], p_4/k_B=%8.5f [K], p_5/k_B=%8.5f [K], Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1]*ENERGY_TO_KELVIN,\n                parms[2]*ENERGY_TO_KELVIN,\n                parms[3]*ENERGY_TO_KELVIN,\n                parms[4]*ENERGY_TO_KELVIN,\n                parms[5]*ENERGY_TO_KELVIN,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    case FOURIER_SERIES_DIHEDRAL2:\n      // (1/2)p_0*(1+cos(phi))+(1/2)p_1(1-cos(2*phi))+(1/2)*p2_2*(1+cos(3*phi))+\n      // (1/2)p_3*(1+cos(4*phi))+(1/2)p_4*(1+cos(5*phi))+(1/2)p_5*(1+cos(6*phi))\n      // =======================================================================\n      // p_0/k_B [K]\n      // p_1/k_B [K]\n      // p_2/k_B [K]\n      // p_3/k_B [K]\n      // p_4/k_B [K]\n      // p_5/k_B [K]\n      U=0.5*(parms[2]+2.0*parms[3]+parms[4]-3.0*parms[2]*CosPhi+5.0*parms[4]*CosPhi+parms[0]*(1.0+CosPhi)+\n        2.0*(parms[1]-parms[1]*CosPhi2+CosPhi2*(parms[5]*SQR(3.0-4.0*CosPhi2)+4.0*parms[3]*(CosPhi2-1.0)+\n        2.0*CosPhi*(parms[2]+parms[4]*(4.0*CosPhi2-5.0)))));\n      fprintf(OutputFilePtr[CurrentSystem],\"%4d FOURIER_SERIES_DIHEDRAL2 %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], \"\n                                           \"p_3/k_B=%8.5f [K], p_4/k_B=%8.5f [K], p_5/k_B=%8.5f [K], Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\\n\",\n                nr,\n                string,\n                parms[0]*ENERGY_TO_KELVIN,\n                parms[1]*ENERGY_TO_KELVIN,\n                parms[2]*ENERGY_TO_KELVIN,\n                parms[3]*ENERGY_TO_KELVIN,\n                parms[4]*ENERGY_TO_KELVIN,\n                parms[5]*ENERGY_TO_KELVIN,\n                Phi*RAD2DEG,\n                U*ENERGY_TO_KELVIN,\n                U*ENERGY_TO_KJ_PER_MOL,\n                U*ENERGY_TO_KCAL_PER_MOL);\n      break;\n    default:\n      fprintf(stderr, \"Undefined Torsion potential in routine 'CalculateFrameworkTorsionEnergy' ('framework_energy.c')\\n\");\n      exit(0);\n      break;\n  }\n  return U;\n"]]}
{"hexsha": "6576afb09c5bb247db9429cbb728ce0ea48e2d15", "ext": "c", "lang": "C", "content": "void power_init(void)\n{\n    /* Configure GPA6 as input and wait a short while */\n    GPIOA_DIR &= ~(1<<6);\n\n    udelay(10);\n\n    /* Value of GPA6 determines PMU chip type */\n    if (GPIOA & (1<<6))\n    {\n        pmu = PCF50635;\n\n        pcf50635_init();\n        \n        /* Clear pending interrupts from pcf50635 */\n        unsigned char data[5]; /* 0 = INT1, 1 = INT2, 2 = INT3, ... 4 = INT5 */\n        pcf50635_read_multiple(PCF5063X_REG_INT1, data, 5);\n    }\n    else\n    {\n        pmu = PCF50606;\n\n        /* Configure GPA6 for output (backlight enable) */\n        GPIOA_DIR |= (1<<6);\n\n        pcf50606_init();\n\n        /* Clear pending interrupts */\n        unsigned char data[3]; /* 0 = INT1, 1 = INT2, 2 = INT3 */\n        pcf50606_read_multiple(0x02, data, 3);\n    }\n\n#ifndef BOOTLOADER\n        IEN |= EXT3_IRQ_MASK;   /* Unmask EXT3 */\n#endif\n}", "item_id": 0, "repo": "Rockbox-Chinese-Community/Rockbox-RCC", "file": "firmware/target/arm/tcc780x/cowond2/power-cowond2.c", "last_update_at": "2022-01-05T14:09:46+00:00", "question_id": "6576afb09c5bb247db9429cbb728ce0ea48e2d15_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void power_init(void)\n{\n    /* Configure GPA6 as input and wait a short while */\n    GPIOA_DIR &= ~(1<<6);\n    udelay(10);\n    /* Value of GPA6 determines PMU chip type */\n    if (GPIOA & (1<<6))\n    {\n        pmu = PCF50635;\n        pcf50635_init();\n        /* Clear pending interrupts from pcf50635 */\n        unsigned char data[5]; /* 0 = INT1, 1 = INT2, 2 = INT3, ... 4 = INT5 */\n        pcf50635_read_multiple(PCF5063X_REG_INT1, data, 5);\n    }\n    else\n    {\n        pmu = PCF50606;\n        /* Configure GPA6 for output (backlight enable) */\n        GPIOA_DIR |= (1<<6);\n        pcf50606_init();\n        /* Clear pending interrupts */\n        unsigned char data[3]; /* 0 = INT1, 1 = INT2, 2 = INT3 */\n        pcf50606_read_multiple(0x02, data, 3);\n    }\n#ifndef BOOTLOADER\n        IEN |= EXT3_IRQ_MASK;   /* Unmask EXT3 */\n#endif\n"]]}
{"hexsha": "914a5204fa270f692f4b80ed641d7c4f9d9011e3", "ext": "c", "lang": "C", "content": "int __sem_down_timed(semaphore_t* sem, char* file, int line, u32 timeout) {\n    sem_down_timed_called++;\n    last_timeout = timeout;\n    return 0;\n}", "item_id": 1, "repo": "christianb93/ctOS", "file": "test/test_fs.c", "last_update_at": "2022-01-19T10:21:50+00:00", "question_id": "914a5204fa270f692f4b80ed641d7c4f9d9011e3_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int __sem_down_timed(semaphore_t* sem, char* file, int line, u32 timeout) {\n    sem_down_timed_called++;\n    last_timeout = timeout;\n    return 0;\n"]]}
{"hexsha": "c5eea1e477ed4a9680cd584ee6a35964a89dd10e", "ext": "h", "lang": "C", "content": "static void memcpy_wide_bus_read_int(int *a_buf, MARS_WIDE_BUS_TYPE *a,\n                                            size_t offset_byte,\n                                            size_t size_byte) {\n#pragma HLS inline self\n  const size_t data_width = sizeof(int);\n  const size_t bus_width = BUS_WIDTH;\n  const size_t num_elements = bus_width / data_width;\n  size_t buf_size = size_byte / data_width;\n  size_t offset = offset_byte / data_width;\n  size_t head_align = offset & (num_elements - 1);\n  size_t new_offset = offset + buf_size;\n  size_t tail_align = (new_offset - 1) & (num_elements - 1);\n  size_t start = offset / num_elements;\n  size_t end = (offset + buf_size + num_elements - 1) / num_elements;\n  //MARS_WIDE_BUS_TYPE *a_offset = a + start;\n  size_t i, j;\n  int len = end - start;\n  assert(len <= buf_size / num_elements + 2);\n  assert(len >= buf_size / num_elements);\n  if (1 == len) {\n#ifdef __cplusplus\n    MARS_WIDE_BUS_TYPE tmp(a[start]);\n#else\n    MARS_WIDE_BUS_TYPE tmp = a[start];\n#endif\n    for (j = 0; j < num_elements; ++j) {\n       if (j < head_align || j > tail_align)\n         continue;\n        a_buf[j - head_align] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n    }\n    return;\n  }\n\n  for (i = 0; i < len; ++i) {\n#pragma HLS pipeline\n#ifdef __cplusplus\n    MARS_WIDE_BUS_TYPE tmp(a[i + start]);\n#else\n    MARS_WIDE_BUS_TYPE tmp = a[i + start];\n#endif\n    if (head_align == 0) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 0] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n\n    else if (head_align == 1) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 1)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 1] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n\n    else if (head_align == 2) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 2)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 2] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n\n    else if (head_align == 3) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 3)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 3] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n\n    else if (head_align == 4) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 4)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 4] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n\n    else if (head_align == 5) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 5)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 5] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n\n    else if (head_align == 6) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 6)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 6] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n\n    else if (head_align == 7) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 7)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 7] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n\n    else if (head_align == 8) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 8)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 8] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n\n    else if (head_align == 9) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 9)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 9] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n\n    else if (head_align == 10) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 10)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 10] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n\n    else if (head_align == 11) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 11)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 11] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n\n    else if (head_align == 12) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 12)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 12] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n\n    else if (head_align == 13) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 13)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 13] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n\n    else if (head_align == 14) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 14)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 14] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n\n    else {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 15)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 15] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n  }\n}", "item_id": 8, "repo": "LemonAndRabbit/rodinia-hls", "file": "Benchmarks/common/mars_wide_bus.h", "last_update_at": "2022-02-16T08:55:40+00:00", "question_id": "c5eea1e477ed4a9680cd584ee6a35964a89dd10e_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void memcpy_wide_bus_read_int(int *a_buf, MARS_WIDE_BUS_TYPE *a,\n                                            size_t offset_byte,\n                                            size_t size_byte) {\n#pragma HLS inline self\n  const size_t data_width = sizeof(int);\n  const size_t bus_width = BUS_WIDTH;\n  const size_t num_elements = bus_width / data_width;\n  size_t buf_size = size_byte / data_width;\n  size_t offset = offset_byte / data_width;\n  size_t head_align = offset & (num_elements - 1);\n  size_t new_offset = offset + buf_size;\n  size_t tail_align = (new_offset - 1) & (num_elements - 1);\n  size_t start = offset / num_elements;\n  size_t end = (offset + buf_size + num_elements - 1) / num_elements;\n  //MARS_WIDE_BUS_TYPE *a_offset = a + start;\n  size_t i, j;\n  int len = end - start;\n  assert(len <= buf_size / num_elements + 2);\n  assert(len >= buf_size / num_elements);\n  if (1 == len) {\n#ifdef __cplusplus\n    MARS_WIDE_BUS_TYPE tmp(a[start]);\n#else\n    MARS_WIDE_BUS_TYPE tmp = a[start];\n#endif\n    for (j = 0; j < num_elements; ++j) {\n       if (j < head_align || j > tail_align)\n         continue;\n        a_buf[j - head_align] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n    }\n    return;\n  }\n  for (i = 0; i < len; ++i) {\n#pragma HLS pipeline\n#ifdef __cplusplus\n    MARS_WIDE_BUS_TYPE tmp(a[i + start]);\n#else\n    MARS_WIDE_BUS_TYPE tmp = a[i + start];\n#endif\n    if (head_align == 0) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 0] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n    else if (head_align == 1) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 1)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 1] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n    else if (head_align == 2) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 2)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 2] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n    else if (head_align == 3) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 3)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 3] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n    else if (head_align == 4) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 4)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 4] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n    else if (head_align == 5) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 5)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 5] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n    else if (head_align == 6) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 6)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 6] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n    else if (head_align == 7) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 7)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 7] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n    else if (head_align == 8) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 8)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 8] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n    else if (head_align == 9) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 9)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 9] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n    else if (head_align == 10) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 10)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 10] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n    else if (head_align == 11) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 11)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 11] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n    else if (head_align == 12) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 12)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 12] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n    else if (head_align == 13) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 13)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 13] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n    else if (head_align == 14) {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 14)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 14] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n    else {\n      for (j = 0; j < num_elements; ++j) {\n        if (i == 0 && j < 15)\n          continue;\n        if (i == end - start - 1 && j > tail_align)\n          continue;\n        a_buf[i * num_elements + j - 15] =\n            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));\n      }\n    }\n  }\n"]]}
{"hexsha": "67a5f779f37878094cd05174d16f4de26f743551", "ext": "h", "lang": "C", "content": "class CoolDownManager : public cocos2d::Ref\r\n{\r\npublic:\r\n\tCoolDownManager();\r\n\t~CoolDownManager();\r\n\r\n\tvoid coolDown(Button* target, float cd, const  std::function<void()>& callback = nullptr);\r\n\r\n\tvoid pause();\r\n\tvoid resume();\t\r\n\r\n\t// don't call this function manually.\r\n\tvoid update(float dt);\r\n\r\n\tvoid cleanup(void);\r\n\r\n\tbool hasTheBtn( Button* btn);\r\nprivate:\r\n\r\n\tcocos2d::Scheduler* scheduler;\r\n\r\n\tcocos2d::Vector<Button*> waitings;\r\n\r\n\tstd::map<Button*, std::function<void()> > callFun;\r\n}", "item_id": 0, "repo": "xubingyue/libxstudio365", "file": "purelib/CoolDownManager.h", "last_update_at": "2022-01-01T06:21:49+00:00", "question_id": "67a5f779f37878094cd05174d16f4de26f743551_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class CoolDownManager : public cocos2d::Ref\r\n{\r\npublic:\r\n\tCoolDownManager();\r\n\t~CoolDownManager();\r\n\r\n\tvoid coolDown(Button* target, float cd, const  std::function<void()>& callback = nullptr);\r\n\r\n\tvoid pause();\r\n\tvoid resume();\t\r\n\r\n\t// don't call this function manually.\r\n\tvoid update(float dt);\r\n\r\n\tvoid cleanup(void);\r\n\r\n\tbool hasTheBtn( Button* btn);\r\nprivate:\r\n\r\n\tcocos2d::Scheduler* scheduler;\r\n\r\n\tcocos2d::Vector<Button*> waitings;\r\n\r\n\tstd::map<Button*, std::function<void()> > callFun;\r\n"]]}
{"hexsha": "00589654985084cd135dce9b946cc82b4d517e2a", "ext": "c", "lang": "C", "content": "JNICALL \nJava_org_openafs_jafs_Server_getServerInfo (JNIEnv *env, jclass cls, \n\t\t\t\t\t       jlong cellHandle, jstring jname, \n\t\t\t\t\t       jobject server) {\n\n  const char *name;\n  afs_status_t ast;\n  afs_serverEntry_t servEntry;\n\n  if( jname != NULL ) {\n    name = (*env)->GetStringUTFChars(env, jname, 0);\n    if( !name ) {\n\tthrowAFSException( env, JAFSADMNOMEM );\n\treturn;    \n    }\n  } else {\n    name = NULL;\n  }\n\n  // get the server entry\n  if ( !afsclient_AFSServerGet( (void *) cellHandle, name, \n\t\t\t\t&servEntry, &ast ) ) {\n    if( name != NULL ) {\n      (*env)->ReleaseStringUTFChars(env, jname, name);\n    }\n    throwAFSException( env, ast );\n    return;\n  }\n\n  fillServerInfo( env, cellHandle, server, servEntry );\n\n  if( name != NULL ) {\n    (*env)->ReleaseStringUTFChars(env, jname, name);\n  }\n\n}", "item_id": 1, "repo": "jakllsch/openafs", "file": "src/JAVA/libjafs/Server.c", "last_update_at": "2022-02-09T07:00:34+00:00", "question_id": "00589654985084cd135dce9b946cc82b4d517e2a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["JNICALL \nJava_org_openafs_jafs_Server_getServerInfo (JNIEnv *env, jclass cls, \n\t\t\t\t\t       jlong cellHandle, jstring jname, \n\t\t\t\t\t       jobject server) {\n  const char *name;\n  afs_status_t ast;\n  afs_serverEntry_t servEntry;\n  if( jname != NULL ) {\n    name = (*env)->GetStringUTFChars(env, jname, 0);\n    if( !name ) {\n\tthrowAFSException( env, JAFSADMNOMEM );\n\treturn;    \n    }\n  } else {\n    name = NULL;\n  }\n  // get the server entry\n  if ( !afsclient_AFSServerGet( (void *) cellHandle, name, \n\t\t\t\t&servEntry, &ast ) ) {\n    if( name != NULL ) {\n      (*env)->ReleaseStringUTFChars(env, jname, name);\n    }\n    throwAFSException( env, ast );\n    return;\n  }\n  fillServerInfo( env, cellHandle, server, servEntry );\n  if( name != NULL ) {\n    (*env)->ReleaseStringUTFChars(env, jname, name);\n  }\n"]]}
{"hexsha": "7e3aeb6df37db00265bec7e47a3f7331c0de9d87", "ext": "c", "lang": "C", "content": "DWORD\nMemCacheClearExistingObjectKeys(\n    IN PMEM_DB_CONNECTION pConn,\n    IN PLSA_SECURITY_OBJECT pObject\n    )\n{\n    DWORD dwError = 0;\n    PSTR pszKey = NULL;\n    PLW_DLINKED_LIST pListEntry = NULL;\n\n    if (!LW_IS_NULL_OR_EMPTY_STR(pObject->pszDN))\n    {\n        dwError = MemCacheRemoveObjectByHashKey(\n                        pConn,\n                        pConn->pDNToSecurityObject,\n                        pObject->pszDN);\n        BAIL_ON_LSA_ERROR(dwError);\n    }\n\n    dwError = LwAllocateStringPrintf(\n                    &pszKey,\n                    \"%s\\\\%s\",\n                    pObject->pszNetbiosDomainName ?\n                        pObject->pszNetbiosDomainName : \"\",\n                    pObject->pszSamAccountName ?\n                        pObject->pszSamAccountName : \"\");\n    BAIL_ON_LSA_ERROR(dwError);\n\n    dwError = MemCacheRemoveObjectByHashKey(\n                    pConn,\n                    pConn->pNT4ToSecurityObject,\n                    pszKey);\n    BAIL_ON_LSA_ERROR(dwError);\n\n    dwError = MemCacheRemoveObjectByHashKey(\n                    pConn,\n                    pConn->pSIDToSecurityObject,\n                    pObject->pszObjectSid);\n    BAIL_ON_LSA_ERROR(dwError);\n\n    if (pObject->type == LSA_OBJECT_TYPE_USER)\n    {\n        if (pObject->enabled)\n        {\n            dwError = LwHashGetValue(\n                            pConn->pUIDToSecurityObject,\n                            (PVOID)(size_t)pObject->userInfo.uid,\n                            (PVOID*)&pListEntry);\n            if (dwError == ERROR_NOT_FOUND)\n            {\n                // The key does not exist\n                dwError = 0;\n            }\n            else\n            {\n                char oldTimeBuf[128] = { 0 };\n                char newTimeBuf[128] = { 0 };\n                struct tm oldTmBuf = { 0 };\n                struct tm newTmBuf = { 0 };\n                PLSA_SECURITY_OBJECT pDuplicateObject = NULL;\n\n                BAIL_ON_LSA_ERROR(dwError);\n\n                pDuplicateObject = (PLSA_SECURITY_OBJECT)pListEntry->pItem;\n                localtime_r(&pDuplicateObject->version.tLastUpdated, &oldTmBuf);\n                localtime_r(&pObject->version.tLastUpdated, &newTmBuf);\n                strftime(\n                        oldTimeBuf,\n                        sizeof(oldTimeBuf),\n                        \"%Y/%m/%d %H:%M:%S\",\n                        &oldTmBuf);\n                strftime(\n                        newTimeBuf,\n                        sizeof(newTimeBuf),\n                        \"%Y/%m/%d %H:%M:%S\",\n                        &newTmBuf);\n\n                LSA_LOG_ERROR(\"Conflict discovered for UID %d. User %s\\\\%s had this UID at time %s, but now (%s) user %s\\\\%s has the UID. Please check that these users are not currently conflicting in Active Directory. This could also happen (safely) if the UIDs were swapped between these users.\",\n                            (int)pObject->userInfo.uid,\n                            LSA_SAFE_LOG_STRING(\n                                pDuplicateObject->pszNetbiosDomainName),\n                            LSA_SAFE_LOG_STRING(\n                                pDuplicateObject->pszSamAccountName),\n                            oldTimeBuf,\n                            newTimeBuf,\n                            LSA_SAFE_LOG_STRING(pObject->pszNetbiosDomainName),\n                            LSA_SAFE_LOG_STRING(pObject->pszSamAccountName));\n                LsaSrvLogUserIDConflictEvent(\n                    (int)pObject->userInfo.uid,\n                    gpszADProviderName,\n                    LSASS_EVENT_WARNING_CONFIGURATION_ID_CONFLICT);\n\n            }\n\n            dwError = MemCacheRemoveObjectByHashKey(\n                            pConn,\n                            pConn->pUIDToSecurityObject,\n                            (PVOID)(size_t)pObject->userInfo.uid);\n            BAIL_ON_LSA_ERROR(dwError);\n\n            dwError = MemCacheRemoveObjectByHashKey(\n                            pConn,\n                            pConn->pUserAliasToSecurityObject,\n                            pObject->userInfo.pszAliasName);\n            BAIL_ON_LSA_ERROR(dwError);\n        }\n\n        dwError = MemCacheRemoveObjectByHashKey(\n                        pConn,\n                        pConn->pUPNToSecurityObject,\n                        pObject->userInfo.pszUPN);\n        BAIL_ON_LSA_ERROR(dwError);\n    }\n    else if (pObject->enabled && pObject->type == LSA_OBJECT_TYPE_GROUP)\n    {\n        dwError = LwHashGetValue(\n                        pConn->pGIDToSecurityObject,\n                        (PVOID)(size_t)pObject->groupInfo.gid,\n                        (PVOID*)&pListEntry);\n        if (dwError == ERROR_NOT_FOUND)\n        {\n            // The key does not exist\n            dwError = 0;\n        }\n        else\n        {\n            char oldTimeBuf[128] = { 0 };\n            char newTimeBuf[128] = { 0 };\n            struct tm oldTmBuf = { 0 };\n            struct tm newTmBuf = { 0 };\n            PLSA_SECURITY_OBJECT pDuplicateObject = NULL;\n\n            BAIL_ON_LSA_ERROR(dwError);\n\n            pDuplicateObject = (PLSA_SECURITY_OBJECT)pListEntry->pItem;\n            localtime_r(&pDuplicateObject->version.tLastUpdated, &oldTmBuf);\n            localtime_r(&pObject->version.tLastUpdated, &newTmBuf);\n            strftime(\n                    oldTimeBuf,\n                    sizeof(oldTimeBuf),\n                    \"%Y/%m/%d %H:%M:%S\",\n                    &oldTmBuf);\n            strftime(\n                    newTimeBuf,\n                    sizeof(newTimeBuf),\n                    \"%Y/%m/%d %H:%M:%S\",\n                    &newTmBuf);\n\n            LSA_LOG_ERROR(\"Conflict discovered for GID %d. Group %s\\\\%s had this GID at time %s, but now (%s) group %s\\\\%s has the GID. Please check that these groups are not currently conflicting in Active Directory. This could also happen (safely) if the GIDs were swapped between these groups.\",\n                        (int)pObject->groupInfo.gid,\n                        LSA_SAFE_LOG_STRING(\n                            pDuplicateObject->pszNetbiosDomainName),\n                        LSA_SAFE_LOG_STRING(\n                            pDuplicateObject->pszSamAccountName),\n                        oldTimeBuf,\n                        newTimeBuf,\n                        LSA_SAFE_LOG_STRING(pObject->pszNetbiosDomainName),\n                        LSA_SAFE_LOG_STRING(pObject->pszSamAccountName));\n            LsaSrvLogUserGIDConflictEvent(\n                (int)pObject->userInfo.gid,\n                gpszADProviderName,\n                LSASS_EVENT_WARNING_CONFIGURATION_ID_CONFLICT);\n        }\n        dwError = MemCacheRemoveObjectByHashKey(\n                        pConn,\n                        pConn->pGIDToSecurityObject,\n                        (PVOID)(size_t)pObject->groupInfo.gid);\n        BAIL_ON_LSA_ERROR(dwError);\n\n        dwError = MemCacheRemoveObjectByHashKey(\n                        pConn,\n                        pConn->pGroupAliasToSecurityObject,\n                        pObject->groupInfo.pszAliasName);\n        BAIL_ON_LSA_ERROR(dwError);\n    }\n\ncleanup:\n    LW_SAFE_FREE_STRING(pszKey);\n    return dwError;\n\nerror:\n    goto cleanup;\n}", "item_id": 15, "repo": "kbore/pbis-open", "file": "lsass/server/auth-providers/ad-open-provider/memcache.c", "last_update_at": "2022-03-18T19:54:37+00:00", "question_id": "7e3aeb6df37db00265bec7e47a3f7331c0de9d87_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["DWORD\nMemCacheClearExistingObjectKeys(\n    IN PMEM_DB_CONNECTION pConn,\n    IN PLSA_SECURITY_OBJECT pObject\n    )\n{\n    DWORD dwError = 0;\n    PSTR pszKey = NULL;\n    PLW_DLINKED_LIST pListEntry = NULL;\n    if (!LW_IS_NULL_OR_EMPTY_STR(pObject->pszDN))\n    {\n        dwError = MemCacheRemoveObjectByHashKey(\n                        pConn,\n                        pConn->pDNToSecurityObject,\n                        pObject->pszDN);\n        BAIL_ON_LSA_ERROR(dwError);\n    }\n    dwError = LwAllocateStringPrintf(\n                    &pszKey,\n                    \"%s\\\\%s\",\n                    pObject->pszNetbiosDomainName ?\n                        pObject->pszNetbiosDomainName : \"\",\n                    pObject->pszSamAccountName ?\n                        pObject->pszSamAccountName : \"\");\n    BAIL_ON_LSA_ERROR(dwError);\n    dwError = MemCacheRemoveObjectByHashKey(\n                    pConn,\n                    pConn->pNT4ToSecurityObject,\n                    pszKey);\n    BAIL_ON_LSA_ERROR(dwError);\n    dwError = MemCacheRemoveObjectByHashKey(\n                    pConn,\n                    pConn->pSIDToSecurityObject,\n                    pObject->pszObjectSid);\n    BAIL_ON_LSA_ERROR(dwError);\n    if (pObject->type == LSA_OBJECT_TYPE_USER)\n    {\n        if (pObject->enabled)\n        {\n            dwError = LwHashGetValue(\n                            pConn->pUIDToSecurityObject,\n                            (PVOID)(size_t)pObject->userInfo.uid,\n                            (PVOID*)&pListEntry);\n            if (dwError == ERROR_NOT_FOUND)\n            {\n                // The key does not exist\n                dwError = 0;\n            }\n            else\n            {\n                char oldTimeBuf[128] = { 0 };\n                char newTimeBuf[128] = { 0 };\n                struct tm oldTmBuf = { 0 };\n                struct tm newTmBuf = { 0 };\n                PLSA_SECURITY_OBJECT pDuplicateObject = NULL;\n                BAIL_ON_LSA_ERROR(dwError);\n                pDuplicateObject = (PLSA_SECURITY_OBJECT)pListEntry->pItem;\n                localtime_r(&pDuplicateObject->version.tLastUpdated, &oldTmBuf);\n                localtime_r(&pObject->version.tLastUpdated, &newTmBuf);\n                strftime(\n                        oldTimeBuf,\n                        sizeof(oldTimeBuf),\n                        \"%Y/%m/%d %H:%M:%S\",\n                        &oldTmBuf);\n                strftime(\n                        newTimeBuf,\n                        sizeof(newTimeBuf),\n                        \"%Y/%m/%d %H:%M:%S\",\n                        &newTmBuf);\n                LSA_LOG_ERROR(\"Conflict discovered for UID %d. User %s\\\\%s had this UID at time %s, but now (%s) user %s\\\\%s has the UID. Please check that these users are not currently conflicting in Active Directory. This could also happen (safely) if the UIDs were swapped between these users.\",\n                            (int)pObject->userInfo.uid,\n                            LSA_SAFE_LOG_STRING(\n                                pDuplicateObject->pszNetbiosDomainName),\n                            LSA_SAFE_LOG_STRING(\n                                pDuplicateObject->pszSamAccountName),\n                            oldTimeBuf,\n                            newTimeBuf,\n                            LSA_SAFE_LOG_STRING(pObject->pszNetbiosDomainName),\n                            LSA_SAFE_LOG_STRING(pObject->pszSamAccountName));\n                LsaSrvLogUserIDConflictEvent(\n                    (int)pObject->userInfo.uid,\n                    gpszADProviderName,\n                    LSASS_EVENT_WARNING_CONFIGURATION_ID_CONFLICT);\n            }\n            dwError = MemCacheRemoveObjectByHashKey(\n                            pConn,\n                            pConn->pUIDToSecurityObject,\n                            (PVOID)(size_t)pObject->userInfo.uid);\n            BAIL_ON_LSA_ERROR(dwError);\n            dwError = MemCacheRemoveObjectByHashKey(\n                            pConn,\n                            pConn->pUserAliasToSecurityObject,\n                            pObject->userInfo.pszAliasName);\n            BAIL_ON_LSA_ERROR(dwError);\n        }\n        dwError = MemCacheRemoveObjectByHashKey(\n                        pConn,\n                        pConn->pUPNToSecurityObject,\n                        pObject->userInfo.pszUPN);\n        BAIL_ON_LSA_ERROR(dwError);\n    }\n    else if (pObject->enabled && pObject->type == LSA_OBJECT_TYPE_GROUP)\n    {\n        dwError = LwHashGetValue(\n                        pConn->pGIDToSecurityObject,\n                        (PVOID)(size_t)pObject->groupInfo.gid,\n                        (PVOID*)&pListEntry);\n        if (dwError == ERROR_NOT_FOUND)\n        {\n            // The key does not exist\n            dwError = 0;\n        }\n        else\n        {\n            char oldTimeBuf[128] = { 0 };\n            char newTimeBuf[128] = { 0 };\n            struct tm oldTmBuf = { 0 };\n            struct tm newTmBuf = { 0 };\n            PLSA_SECURITY_OBJECT pDuplicateObject = NULL;\n            BAIL_ON_LSA_ERROR(dwError);\n            pDuplicateObject = (PLSA_SECURITY_OBJECT)pListEntry->pItem;\n            localtime_r(&pDuplicateObject->version.tLastUpdated, &oldTmBuf);\n            localtime_r(&pObject->version.tLastUpdated, &newTmBuf);\n            strftime(\n                    oldTimeBuf,\n                    sizeof(oldTimeBuf),\n                    \"%Y/%m/%d %H:%M:%S\",\n                    &oldTmBuf);\n            strftime(\n                    newTimeBuf,\n                    sizeof(newTimeBuf),\n                    \"%Y/%m/%d %H:%M:%S\",\n                    &newTmBuf);\n            LSA_LOG_ERROR(\"Conflict discovered for GID %d. Group %s\\\\%s had this GID at time %s, but now (%s) group %s\\\\%s has the GID. Please check that these groups are not currently conflicting in Active Directory. This could also happen (safely) if the GIDs were swapped between these groups.\",\n                        (int)pObject->groupInfo.gid,\n                        LSA_SAFE_LOG_STRING(\n                            pDuplicateObject->pszNetbiosDomainName),\n                        LSA_SAFE_LOG_STRING(\n                            pDuplicateObject->pszSamAccountName),\n                        oldTimeBuf,\n                        newTimeBuf,\n                        LSA_SAFE_LOG_STRING(pObject->pszNetbiosDomainName),\n                        LSA_SAFE_LOG_STRING(pObject->pszSamAccountName));\n            LsaSrvLogUserGIDConflictEvent(\n                (int)pObject->userInfo.gid,\n                gpszADProviderName,\n                LSASS_EVENT_WARNING_CONFIGURATION_ID_CONFLICT);\n        }\n        dwError = MemCacheRemoveObjectByHashKey(\n                        pConn,\n                        pConn->pGIDToSecurityObject,\n                        (PVOID)(size_t)pObject->groupInfo.gid);\n        BAIL_ON_LSA_ERROR(dwError);\n        dwError = MemCacheRemoveObjectByHashKey(\n                        pConn,\n                        pConn->pGroupAliasToSecurityObject,\n                        pObject->groupInfo.pszAliasName);\n        BAIL_ON_LSA_ERROR(dwError);\n    }\ncleanup:\n    LW_SAFE_FREE_STRING(pszKey);\n    return dwError;\nerror:\n    goto cleanup;\n"]]}
{"hexsha": "d734f53c54e815ba4c2698c042f853429deb3600", "ext": "c", "lang": "C", "content": "trble_result_e rtw_ble_client_read_connected_device_list(trble_connected_list* out_connected_list)\n{ \n    if (out_connected_list == NULL)\n    {\n        return TRBLE_FAIL;\n    }\n    \n    memset(out_connected_list, 0, sizeof(trble_connected_list));\n    for(uint16_t i = 0; i < ble_app_link_table_size; i++)\n    {\n        if(ble_app_link_table[i].conn_state == GAP_CONN_STATE_CONNECTED)\n        {\n            out_connected_list->connected_count++;\n            out_connected_list->conn_handle[i] =  ble_app_link_table[i].conn_id;\n        }\n    }\n    return TRBLE_SUCCESS; \n}", "item_id": 9, "repo": "Wuth5/TizenRT", "file": "os/board/rtl8721csm/src/component/common/bluetooth/realtek/sdk/example/ble_central/ble_tizenrt_client.c", "last_update_at": "2022-03-30T23:10:29+00:00", "question_id": "d734f53c54e815ba4c2698c042f853429deb3600_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["trble_result_e rtw_ble_client_read_connected_device_list(trble_connected_list* out_connected_list)\n{ \n    if (out_connected_list == NULL)\n    {\n        return TRBLE_FAIL;\n    }\n    memset(out_connected_list, 0, sizeof(trble_connected_list));\n    for(uint16_t i = 0; i < ble_app_link_table_size; i++)\n    {\n        if(ble_app_link_table[i].conn_state == GAP_CONN_STATE_CONNECTED)\n        {\n            out_connected_list->connected_count++;\n            out_connected_list->conn_handle[i] =  ble_app_link_table[i].conn_id;\n        }\n    }\n    return TRBLE_SUCCESS; \n"]]}
{"hexsha": "172cc980858d45910c99837ea1f8727cf3bd043a", "ext": "c", "lang": "C", "content": "void xor (char *str1, char *str2) {\n  \n  unsigned long int i;\n\n  if (strlen(str1) != strlen(str2)) {\n    printf(\"Error: xor operation does not support different string lengths.\\n\");\n    exit(0);\n  }\n\n  for (i = 0; i < strlen(str1); i++) {\n    if (str1[i] == str2[i]) {\n      output[i] = '0';\n    }\n    else output[i] = '1';\n  }\n  output[i] = '\\0';\n}", "item_id": 8, "repo": "stineje/DES", "file": "S-DES/C/sdes.c", "last_update_at": "2022-03-01T04:30:51+00:00", "question_id": "172cc980858d45910c99837ea1f8727cf3bd043a_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void xor (char *str1, char *str2) {\n  unsigned long int i;\n  if (strlen(str1) != strlen(str2)) {\n    printf(\"Error: xor operation does not support different string lengths.\\n\");\n    exit(0);\n  }\n  for (i = 0; i < strlen(str1); i++) {\n    if (str1[i] == str2[i]) {\n      output[i] = '0';\n    }\n    else output[i] = '1';\n  }\n  output[i] = '\\0';\n"]]}
{"hexsha": "d0c6ec75a3c719f64cb19f6a42cb91b2c7c2af34", "ext": "c", "lang": "C", "content": "static struct drm_framebuffer *vbox_user_framebuffer_create(\n\t\tstruct drm_device *dev,\n\t\tstruct drm_file *filp,\n\t\tconst struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tstruct drm_gem_object *obj;\n\tstruct vbox_framebuffer *vbox_fb;\n\tint ret = -ENOMEM;\n\n\tobj = drm_gem_object_lookup(filp, mode_cmd->handles[0]);\n\tif (!obj)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tvbox_fb = kzalloc(sizeof(*vbox_fb), GFP_KERNEL);\n\tif (!vbox_fb)\n\t\tgoto err_unref_obj;\n\n\tret = vbox_framebuffer_init(dev, vbox_fb, mode_cmd, obj);\n\tif (ret)\n\t\tgoto err_free_vbox_fb;\n\n\treturn &vbox_fb->base;\n\nerr_free_vbox_fb:\n\tkfree(vbox_fb);\nerr_unref_obj:\n\tdrm_gem_object_unreference_unlocked(obj);\n\treturn ERR_PTR(ret);\n}", "item_id": 5, "repo": "ShawnZhong/SplitFS", "file": "kernel/linux-4.13/drivers/staging/vboxvideo/vbox_main.c", "last_update_at": "2022-03-16T13:51:24+00:00", "question_id": "d0c6ec75a3c719f64cb19f6a42cb91b2c7c2af34_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct drm_framebuffer *vbox_user_framebuffer_create(\n\t\tstruct drm_device *dev,\n\t\tstruct drm_file *filp,\n\t\tconst struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tstruct drm_gem_object *obj;\n\tstruct vbox_framebuffer *vbox_fb;\n\tint ret = -ENOMEM;\n\tobj = drm_gem_object_lookup(filp, mode_cmd->handles[0]);\n\tif (!obj)\n\t\treturn ERR_PTR(-ENOENT);\n\tvbox_fb = kzalloc(sizeof(*vbox_fb), GFP_KERNEL);\n\tif (!vbox_fb)\n\t\tgoto err_unref_obj;\n\tret = vbox_framebuffer_init(dev, vbox_fb, mode_cmd, obj);\n\tif (ret)\n\t\tgoto err_free_vbox_fb;\n\treturn &vbox_fb->base;\nerr_free_vbox_fb:\n\tkfree(vbox_fb);\nerr_unref_obj:\n\tdrm_gem_object_unreference_unlocked(obj);\n\treturn ERR_PTR(ret);\n"]]}
{"hexsha": "5cdea3f1e7afc2095e4923f26ed0e83e098260e7", "ext": "c", "lang": "C", "content": "void InitialTimer(void)\n{\n    /*\ufffd\u0631\ufffd\u02b1\ufffd\ufffd*/\n    TR0  = OFF;\n\tTR1  = OFF;\n\t\n    /*T0 T1 \u0123\u02bd\ufffd\ufffd\ufffd\ufffd*/\n    TMOD = 0x11;              //\ufffd\ufffd\u02b1\ufffd\ufffd0\ufffd\ufffd\u02bd1\ufffd\ufffd16\u03bb\ufffd\ufffd\ufffd\ufffd ,\ufffd\ufffd\u02b1\ufffd\ufffd1 \ufffd\ufffd\u02bd1 16\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u02bd\n\tSetTimer0(_us(560));\n\tSetTimer1(_ms(5));\n    SetTimer3(0);\n\tSetTimer4(0);\n\n\t/*T0 T1\ufffd\u0436\u03ff\ufffd\ufffd\ufffd*/\n    ET0  = OFF;           //TO\ufffd\u0436\ufffd\ufffd\ufffd\ufffd\ufffd\n    ET1  = ON;\t\t     //T1\ufffd\u0436\ufffd\ufffd\ufffd\ufffd\ufffd\n\n\t/*\ufffd\ufffd\u02b1\ufffd\ufffd/\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd*/ \n    TR0  = OFF;\n\tTR1  = ON;\n}", "item_id": 1, "repo": "r315/AMT630A-car-tftm-monitor", "file": "Device driver/Mcu/Mcu.c", "last_update_at": "2022-03-19T07:51:04+00:00", "question_id": "5cdea3f1e7afc2095e4923f26ed0e83e098260e7_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void InitialTimer(void)\n{\n    /*\ufffd\u0631\ufffd\u02b1\ufffd\ufffd*/\n    TR0  = OFF;\n\tTR1  = OFF;\n\t\n    /*T0 T1 \u0123\u02bd\ufffd\ufffd\ufffd\ufffd*/\n    TMOD = 0x11;              //\ufffd\ufffd\u02b1\ufffd\ufffd0\ufffd\ufffd\u02bd1\ufffd\ufffd16\u03bb\ufffd\ufffd\ufffd\ufffd ,\ufffd\ufffd\u02b1\ufffd\ufffd1 \ufffd\ufffd\u02bd1 16\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u02bd\n\tSetTimer0(_us(560));\n\tSetTimer1(_ms(5));\n    SetTimer3(0);\n\tSetTimer4(0);\n\t/*T0 T1\ufffd\u0436\u03ff\ufffd\ufffd\ufffd*/\n    ET0  = OFF;           //TO\ufffd\u0436\ufffd\ufffd\ufffd\ufffd\ufffd\n    ET1  = ON;\t\t     //T1\ufffd\u0436\ufffd\ufffd\ufffd\ufffd\ufffd\n\t/*\ufffd\ufffd\u02b1\ufffd\ufffd/\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd*/ \n    TR0  = OFF;\n\tTR1  = ON;\n"]]}
{"hexsha": "761d670bad27e2e427dbe4e2e5222f5214ebf4ee", "ext": "c", "lang": "C", "content": "static void mdss_dsi_parse_trigger(struct device_node *np, char *trigger,\n\t\tchar *trigger_key)\n{\n\tconst char *data;\n\n\t*trigger = DSI_CMD_TRIGGER_SW;\n\tdata = of_get_property(np, trigger_key, NULL);\n\tif (data) {\n\t\tif (!strcmp(data, \"none\"))\n\t\t\t*trigger = DSI_CMD_TRIGGER_NONE;\n\t\telse if (!strcmp(data, \"trigger_te\"))\n\t\t\t*trigger = DSI_CMD_TRIGGER_TE;\n\t\telse if (!strcmp(data, \"trigger_sw_seof\"))\n\t\t\t*trigger = DSI_CMD_TRIGGER_SW_SEOF;\n\t\telse if (!strcmp(data, \"trigger_sw_te\"))\n\t\t\t*trigger = DSI_CMD_TRIGGER_SW_TE;\n\t}\n}", "item_id": 17, "repo": "eliot-shao/qcom", "file": "display/dual_dsi/mdss_dsi_panel.c", "last_update_at": "2022-03-12T14:11:42+00:00", "question_id": "761d670bad27e2e427dbe4e2e5222f5214ebf4ee_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void mdss_dsi_parse_trigger(struct device_node *np, char *trigger,\n\t\tchar *trigger_key)\n{\n\tconst char *data;\n\t*trigger = DSI_CMD_TRIGGER_SW;\n\tdata = of_get_property(np, trigger_key, NULL);\n\tif (data) {\n\t\tif (!strcmp(data, \"none\"))\n\t\t\t*trigger = DSI_CMD_TRIGGER_NONE;\n\t\telse if (!strcmp(data, \"trigger_te\"))\n\t\t\t*trigger = DSI_CMD_TRIGGER_TE;\n\t\telse if (!strcmp(data, \"trigger_sw_seof\"))\n\t\t\t*trigger = DSI_CMD_TRIGGER_SW_SEOF;\n\t\telse if (!strcmp(data, \"trigger_sw_te\"))\n\t\t\t*trigger = DSI_CMD_TRIGGER_SW_TE;\n\t}\n"]]}
{"hexsha": "187f654c4a0e5de9becf9d1f938e6468320e87a3", "ext": "c", "lang": "C", "content": "int processx_c_pollable_from_connection(\n  processx_pollable_t *pollable,\n  processx_connection_t *ccon) {\n\n  pollable->pre_poll_func = processx_i_pre_poll_func_connection;\n  pollable->object = ccon;\n  pollable->free = 0;\n  pollable->fds = R_NilValue;\n  return 0;\n}", "item_id": 25, "repo": "pekkarr/processx", "file": "src/processx-connection.c", "last_update_at": "2022-03-30T10:27:43+00:00", "question_id": "187f654c4a0e5de9becf9d1f938e6468320e87a3_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int processx_c_pollable_from_connection(\n  processx_pollable_t *pollable,\n  processx_connection_t *ccon) {\n  pollable->pre_poll_func = processx_i_pre_poll_func_connection;\n  pollable->object = ccon;\n  pollable->free = 0;\n  pollable->fds = R_NilValue;\n  return 0;\n"]]}
{"hexsha": "851d46b398c475265ed2f5dd288fe0b5efeedada", "ext": "c", "lang": "C", "content": "static int wifi_debug(int argc, char *argv[])\n{\n    int i;\n    int result = 0;\n    \n    const struct wifi_cmd_des *run_cmd = OS_NULL;\n\n    if (argc < 3)\n    {\n        wifi_debug_help(0, OS_NULL);\n        return 0;\n    }\n\n    for (i = 0; i < sizeof(debug_tab) / sizeof(debug_tab[0]); i++)\n    {\n        if (strcmp(debug_tab[i].cmd, argv[2]) == 0)\n        {\n            run_cmd = &debug_tab[i];\n            break;\n        }\n    }\n\n    if (run_cmd == OS_NULL)\n    {\n        wifi_debug_help(0, OS_NULL);\n        return 0;\n    }\n\n    if (run_cmd->fun != OS_NULL)\n    {\n        result = run_cmd->fun(argc - 2, &argv[2]);\n    }\n\n    if (result)\n    {\n        wifi_debug_help(argc - 2, &argv[2]);\n    }\n    return 0;\n}", "item_id": 12, "repo": "shangliyun/lu_xing_xiang_one_os", "file": "drivers/wlan/wlan_cmd.c", "last_update_at": "2022-01-18T15:22:41+00:00", "question_id": "851d46b398c475265ed2f5dd288fe0b5efeedada_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int wifi_debug(int argc, char *argv[])\n{\n    int i;\n    int result = 0;\n    const struct wifi_cmd_des *run_cmd = OS_NULL;\n    if (argc < 3)\n    {\n        wifi_debug_help(0, OS_NULL);\n        return 0;\n    }\n    for (i = 0; i < sizeof(debug_tab) / sizeof(debug_tab[0]); i++)\n    {\n        if (strcmp(debug_tab[i].cmd, argv[2]) == 0)\n        {\n            run_cmd = &debug_tab[i];\n            break;\n        }\n    }\n    if (run_cmd == OS_NULL)\n    {\n        wifi_debug_help(0, OS_NULL);\n        return 0;\n    }\n    if (run_cmd->fun != OS_NULL)\n    {\n        result = run_cmd->fun(argc - 2, &argv[2]);\n    }\n    if (result)\n    {\n        wifi_debug_help(argc - 2, &argv[2]);\n    }\n    return 0;\n"]]}
{"hexsha": "cf53170d6349a45af5bce401dc26c90aed3b756c", "ext": "c", "lang": "C", "content": "void usb_handle_config_descriptor(volatile struct usb_setup_packet *pkt) {\n    uint8_t *buf = &ep0_buf[0];\n\n    // First request will want just the config descriptor\n    const struct usb_configuration_descriptor *d = dev_config.config_descriptor;\n    memcpy((void *) buf, d, sizeof(struct usb_configuration_descriptor));\n    buf += sizeof(struct usb_configuration_descriptor);\n\n    // If we more than just the config descriptor copy it all\n    if (pkt->wLength >= d->wTotalLength) {\n        memcpy((void *) buf, dev_config.interface_descriptor, sizeof(struct usb_interface_descriptor));\n        buf += sizeof(struct usb_interface_descriptor);\n        const struct usb_endpoint_configuration *ep = dev_config.endpoints;\n\n        // Copy all the endpoint descriptors starting from EP1\n        for (uint i = 2; i < USB_NUM_ENDPOINTS; i++) {\n            if (ep[i].descriptor) {\n                memcpy((void *) buf, ep[i].descriptor, sizeof(struct usb_endpoint_descriptor));\n                buf += sizeof(struct usb_endpoint_descriptor);\n            }\n        }\n\n    }\n\n    // Send data\n    // Get len by working out end of buffer subtract start of buffer\n    uint32_t len = (uint32_t) buf - (uint32_t) &ep0_buf[0];\n    usb_start_transfer(usb_get_endpoint_configuration(EP0_IN_ADDR), &ep0_buf[0], len);\n}", "item_id": 6, "repo": "sbehnke/pico-examples", "file": "usb/device/dev_lowlevel/dev_lowlevel.c", "last_update_at": "2022-03-15T00:10:51+00:00", "question_id": "cf53170d6349a45af5bce401dc26c90aed3b756c_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void usb_handle_config_descriptor(volatile struct usb_setup_packet *pkt) {\n    uint8_t *buf = &ep0_buf[0];\n    // First request will want just the config descriptor\n    const struct usb_configuration_descriptor *d = dev_config.config_descriptor;\n    memcpy((void *) buf, d, sizeof(struct usb_configuration_descriptor));\n    buf += sizeof(struct usb_configuration_descriptor);\n    // If we more than just the config descriptor copy it all\n    if (pkt->wLength >= d->wTotalLength) {\n        memcpy((void *) buf, dev_config.interface_descriptor, sizeof(struct usb_interface_descriptor));\n        buf += sizeof(struct usb_interface_descriptor);\n        const struct usb_endpoint_configuration *ep = dev_config.endpoints;\n        // Copy all the endpoint descriptors starting from EP1\n        for (uint i = 2; i < USB_NUM_ENDPOINTS; i++) {\n            if (ep[i].descriptor) {\n                memcpy((void *) buf, ep[i].descriptor, sizeof(struct usb_endpoint_descriptor));\n                buf += sizeof(struct usb_endpoint_descriptor);\n            }\n        }\n    }\n    // Send data\n    // Get len by working out end of buffer subtract start of buffer\n    uint32_t len = (uint32_t) buf - (uint32_t) &ep0_buf[0];\n    usb_start_transfer(usb_get_endpoint_configuration(EP0_IN_ADDR), &ep0_buf[0], len);\n"]]}
{"hexsha": "d2ed32a3236fc07742579275c0fbb70032ea28f9", "ext": "h", "lang": "C", "content": "static inline void hri_pm_set_APBBMASK_NVMCTRL_bit(const void *const hw)\n{\n\tPM_CRITICAL_SECTION_ENTER();\n\t((Pm *)hw)->APBBMASK.reg |= PM_APBBMASK_NVMCTRL;\n\tPM_CRITICAL_SECTION_LEAVE();\n}", "item_id": 167, "repo": "jaydcarlson/microcontroller-test-code", "file": "SAMD10/toggle/hri/hri_pm_d10.h", "last_update_at": "2022-03-06T13:32:17+00:00", "question_id": "d2ed32a3236fc07742579275c0fbb70032ea28f9_167", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void hri_pm_set_APBBMASK_NVMCTRL_bit(const void *const hw)\n{\n\tPM_CRITICAL_SECTION_ENTER();\n\t((Pm *)hw)->APBBMASK.reg |= PM_APBBMASK_NVMCTRL;\n\tPM_CRITICAL_SECTION_LEAVE();\n"]]}
{"hexsha": "a447a2173efd236064b5c4d21b56e7dd735a0061", "ext": "c", "lang": "C", "content": "INLINE void set_sl_rr(FM_SLOT *SLOT,int v,signed int *dr_table)\n{\n    SLOT->SL = SL_TABLE[(v>>4)];\n    SLOT->RR = &dr_table[((v&0x0f)<<2)|2];\n    SLOT->evsr = SLOT->RR[SLOT->ksr];\n    if( SLOT->evm == ENV_MOD_RR ) SLOT->evs = SLOT->evsr;\n}", "item_id": 11, "repo": "Megadrive-Vault/dgen-sdl", "file": "fm.c", "last_update_at": "2022-01-17T16:10:48+00:00", "question_id": "a447a2173efd236064b5c4d21b56e7dd735a0061_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["INLINE void set_sl_rr(FM_SLOT *SLOT,int v,signed int *dr_table)\n{\n    SLOT->SL = SL_TABLE[(v>>4)];\n    SLOT->RR = &dr_table[((v&0x0f)<<2)|2];\n    SLOT->evsr = SLOT->RR[SLOT->ksr];\n    if( SLOT->evm == ENV_MOD_RR ) SLOT->evs = SLOT->evsr;\n"]]}
{"hexsha": "e5093a52359713a65bc5e87b189415cbe3bfd91c", "ext": "c", "lang": "C", "content": "int main(void)\n{\n  // trivial bug\n  assert(false);\n\n  struct Hardware hardware;\n  struct Hardware* hw = &hardware;\n\n  struct Firmware firmware;\n  struct Firmware* fw = &firmware;\n\n  firmware.hw = hw;\n  hardware.fw = fw;\n\n  __CPROVER_ASYNC_1: write_reg_a(hw);\n\n  return 0;\n}", "item_id": 2, "repo": "mauguignard/cbmc", "file": "regression/cbmc-concurrency/dirty_local2/main.c", "last_update_at": "2022-03-27T09:24:09+00:00", "question_id": "e5093a52359713a65bc5e87b189415cbe3bfd91c_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(void)\n{\n  // trivial bug\n  assert(false);\n  struct Hardware hardware;\n  struct Hardware* hw = &hardware;\n  struct Firmware firmware;\n  struct Firmware* fw = &firmware;\n  firmware.hw = hw;\n  hardware.fw = fw;\n  __CPROVER_ASYNC_1: write_reg_a(hw);\n  return 0;\n"]]}
{"hexsha": "3ed3d8feaa49dee26144ea253bddf90ca12dc510", "ext": "c", "lang": "C", "content": "static void print_other_info(const struct exfat_super_block* sb)\n{\n\tprintf(\"First sector              %10\"PRIu64\"\\n\",\n\t\t\tle64_to_cpu(sb->sector_start));\n\tprintf(\"FAT first sector          %10u\\n\",\n\t\t\tle32_to_cpu(sb->fat_sector_start));\n\tprintf(\"FAT sectors count         %10u\\n\",\n\t\t\tle32_to_cpu(sb->fat_sector_count));\n\tprintf(\"First cluster sector      %10u\\n\",\n\t\t\tle32_to_cpu(sb->cluster_sector_start));\n\tprintf(\"Root directory cluster    %10u\\n\",\n\t\t\tle32_to_cpu(sb->rootdir_cluster));\n\tprintf(\"Volume state                  0x%04hx\\n\",\n\t\t\tle16_to_cpu(sb->volume_state));\n\tprintf(\"FATs count                %10hhu\\n\",\n\t\t\tsb->fat_count);\n\tprintf(\"Drive number                    0x%02hhx\\n\",\n\t\t\tsb->drive_no);\n\tprintf(\"Allocated space           %9hhu%%\\n\",\n\t\t\tsb->allocated_percent);\n}", "item_id": 1, "repo": "imranpopz/android_bootable_recovery-1", "file": "exfat/dump/main.c", "last_update_at": "2022-03-20T21:30:48+00:00", "question_id": "3ed3d8feaa49dee26144ea253bddf90ca12dc510_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void print_other_info(const struct exfat_super_block* sb)\n{\n\tprintf(\"First sector              %10\"PRIu64\"\\n\",\n\t\t\tle64_to_cpu(sb->sector_start));\n\tprintf(\"FAT first sector          %10u\\n\",\n\t\t\tle32_to_cpu(sb->fat_sector_start));\n\tprintf(\"FAT sectors count         %10u\\n\",\n\t\t\tle32_to_cpu(sb->fat_sector_count));\n\tprintf(\"First cluster sector      %10u\\n\",\n\t\t\tle32_to_cpu(sb->cluster_sector_start));\n\tprintf(\"Root directory cluster    %10u\\n\",\n\t\t\tle32_to_cpu(sb->rootdir_cluster));\n\tprintf(\"Volume state                  0x%04hx\\n\",\n\t\t\tle16_to_cpu(sb->volume_state));\n\tprintf(\"FATs count                %10hhu\\n\",\n\t\t\tsb->fat_count);\n\tprintf(\"Drive number                    0x%02hhx\\n\",\n\t\t\tsb->drive_no);\n\tprintf(\"Allocated space           %9hhu%%\\n\",\n\t\t\tsb->allocated_percent);\n"]]}
{"hexsha": "d6979e11a67b2b1f73feeb3bbda5394d6dd66827", "ext": "c", "lang": "C", "content": "int sun4i_csi_dma_register(struct sun4i_csi *csi, int irq)\n{\n\tstruct vb2_queue *q = &csi->queue;\n\tint ret;\n\tint i;\n\n\tspin_lock_init(&csi->qlock);\n\tmutex_init(&csi->lock);\n\n\tINIT_LIST_HEAD(&csi->buf_list);\n\tfor (i = 0; i < CSI_MAX_BUFFER; i++)\n\t\tcsi->current_buf[i] = NULL;\n\n\tq->min_buffers_needed = 3;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tq->io_modes = VB2_MMAP;\n\tq->lock = &csi->lock;\n\tq->drv_priv = csi;\n\tq->buf_struct_size = sizeof(struct sun4i_csi_buffer);\n\tq->ops = &sun4i_csi_qops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->dev = csi->dev;\n\n\tret = vb2_queue_init(q);\n\tif (ret < 0) {\n\t\tdev_err(csi->dev, \"failed to initialize VB2 queue\\n\");\n\t\tgoto err_free_mutex;\n\t}\n\n\tret = v4l2_device_register(csi->dev, &csi->v4l);\n\tif (ret) {\n\t\tdev_err(csi->dev, \"Couldn't register the v4l2 device\\n\");\n\t\tgoto err_free_queue;\n\t}\n\n\tret = devm_request_irq(csi->dev, irq, sun4i_csi_irq, 0,\n\t\t\t       dev_name(csi->dev), csi);\n\tif (ret) {\n\t\tdev_err(csi->dev, \"Couldn't register our interrupt\\n\");\n\t\tgoto err_unregister_device;\n\t}\n\n\treturn 0;\n\nerr_unregister_device:\n\tv4l2_device_unregister(&csi->v4l);\n\nerr_free_queue:\n\tvb2_queue_release(q);\n\nerr_free_mutex:\n\tmutex_destroy(&csi->lock);\n\treturn ret;\n}", "item_id": 12, "repo": "josehu07/SplitFS", "file": "kernel/linux-5.4/drivers/media/platform/sunxi/sun4i-csi/sun4i_dma.c", "last_update_at": "2022-03-28T08:23:06+00:00", "question_id": "d6979e11a67b2b1f73feeb3bbda5394d6dd66827_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int sun4i_csi_dma_register(struct sun4i_csi *csi, int irq)\n{\n\tstruct vb2_queue *q = &csi->queue;\n\tint ret;\n\tint i;\n\tspin_lock_init(&csi->qlock);\n\tmutex_init(&csi->lock);\n\tINIT_LIST_HEAD(&csi->buf_list);\n\tfor (i = 0; i < CSI_MAX_BUFFER; i++)\n\t\tcsi->current_buf[i] = NULL;\n\tq->min_buffers_needed = 3;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tq->io_modes = VB2_MMAP;\n\tq->lock = &csi->lock;\n\tq->drv_priv = csi;\n\tq->buf_struct_size = sizeof(struct sun4i_csi_buffer);\n\tq->ops = &sun4i_csi_qops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->dev = csi->dev;\n\tret = vb2_queue_init(q);\n\tif (ret < 0) {\n\t\tdev_err(csi->dev, \"failed to initialize VB2 queue\\n\");\n\t\tgoto err_free_mutex;\n\t}\n\tret = v4l2_device_register(csi->dev, &csi->v4l);\n\tif (ret) {\n\t\tdev_err(csi->dev, \"Couldn't register the v4l2 device\\n\");\n\t\tgoto err_free_queue;\n\t}\n\tret = devm_request_irq(csi->dev, irq, sun4i_csi_irq, 0,\n\t\t\t       dev_name(csi->dev), csi);\n\tif (ret) {\n\t\tdev_err(csi->dev, \"Couldn't register our interrupt\\n\");\n\t\tgoto err_unregister_device;\n\t}\n\treturn 0;\nerr_unregister_device:\n\tv4l2_device_unregister(&csi->v4l);\nerr_free_queue:\n\tvb2_queue_release(q);\nerr_free_mutex:\n\tmutex_destroy(&csi->lock);\n\treturn ret;\n"]]}
{"hexsha": "e94a56f5e8ba92c1046832a257da99b7946e9743", "ext": "c", "lang": "C", "content": "int main(void)\n{\n    test_reduce_1();\n\n    test_multx_1();\n    test_multx_2();\n    test_multx_3();\n\n    test_swap_1();\n\n    test_clmul_1();\n    test_clmul_2();\n    return 0;\n}", "item_id": 7, "repo": "jestinepaul/pycryptodome", "file": "src/test/test_clmul.c", "last_update_at": "2022-03-31T07:38:22+00:00", "question_id": "e94a56f5e8ba92c1046832a257da99b7946e9743_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(void)\n{\n    test_reduce_1();\n    test_multx_1();\n    test_multx_2();\n    test_multx_3();\n    test_swap_1();\n    test_clmul_1();\n    test_clmul_2();\n    return 0;\n"]]}
{"hexsha": "e9996462c3f817cb23890d71b9eac7e364e02cda", "ext": "h", "lang": "C", "content": "struct SpaceSalvo{\n\n    int n;\n    //Vec3d pos,vel;\n    ProjectileType* shotType;\n    // derived properties\n    double speed;     // [m/s],   299792458 m/s for laser\n    //double Energy;\n    double scatter0;  //\n    double delay;\n\n    inline double timeToTarget(double dist){ return dist/speed; }\n    double getSpread(double dist, double aDelta, double& t ){\n        double tof = timeToTarget( dist );\n        t   = delay + tof;\n        double scatter = scatter0*dist  +  aDelta*t*t*0.5;\n        //printf( \"getSpread : t %g(tof %g, t0 %g)[s] scatter %g(d %g ,d^2 %g)[m] \\n\",  t, tof, delay,      scatter, scatter0*dist, aDelta*t*t*0.5 );\n        return scatter;\n    }", "item_id": 9, "repo": "ProkopHapala/SimpleSimulationEngine", "file": "cpp/apps/OrbitalWar/spaceCombat.h", "last_update_at": "2022-03-24T09:39:28+00:00", "question_id": "e9996462c3f817cb23890d71b9eac7e364e02cda_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct SpaceSalvo{\n    int n;\n    //Vec3d pos,vel;\n    ProjectileType* shotType;\n    // derived properties\n    double speed;     // [m/s],   299792458 m/s for laser\n    //double Energy;\n    double scatter0;  //\n    double delay;\n    inline double timeToTarget(double dist){ return dist/speed; }\n    double getSpread(double dist, double aDelta, double& t ){\n        double tof = timeToTarget( dist );\n        t   = delay + tof;\n        double scatter = scatter0*dist  +  aDelta*t*t*0.5;\n        //printf( \"getSpread : t %g(tof %g, t0 %g)[s] scatter %g(d %g ,d^2 %g)[m] \\n\",  t, tof, delay,      scatter, scatter0*dist, aDelta*t*t*0.5 );\n        return scatter;\n"]]}
{"hexsha": "a22b4392100d0a6a7e74c2e38a35b1fbaa91beae", "ext": "c", "lang": "C", "content": "DIGIT_T spDivide(DIGIT_T *q, DIGIT_T *r, const DIGIT_T u[2], DIGIT_T v) {    /*\tComputes quotient q = u / v, remainder r = u mod v\r\n\t\twhere u is a double digit\r\n\t\tand q, v, r are single precision digits.\r\n\t\tReturns high digit of quotient (max value is 1)\r\n\t\tCAUTION: Assumes normalised such that v1 >= b/2\r\n\t\twhere b is size of HALF_DIGIT\r\n\t\ti.e. the most significant bit of v should be one\r\n\r\n\t\tIn terms of half-digits in Knuth notation:\r\n\t\t(q2q1q0) = (u4u3u2u1u0) / (v1v0)\r\n\t\t(r1r0) = (u4u3u2u1u0) mod (v1v0)\r\n\t\tfor m = 2, n = 2 where u4 = 0\r\n\t\tq2 is either 0 or 1.\r\n\t\tWe set q = (q1q0) and return q2 as \"overflow\"\r\n\t*/\r\n    DIGIT_T qhat, rhat, t, v0, v1, u0, u1, u2, u3;\r\n    DIGIT_T uu[2], q2;\r\n\r\n    /* Check for normalisation */\r\n    if (!(v & HIBITMASK)) {    /* Stop if assert is working, else return error */\r\n        assert(v & HIBITMASK);\r\n        *q = *r = 0;\r\n        return MAX_DIGIT;\r\n    }\r\n\r\n    /* Split up into half-digits */\r\n    v0 = LOHALF(v);\r\n    v1 = HIHALF(v);\r\n    u0 = LOHALF(u[0]);\r\n    u1 = HIHALF(u[0]);\r\n    u2 = LOHALF(u[1]);\r\n    u3 = HIHALF(u[1]);\r\n\r\n    /* Do three rounds of Knuth Algorithm D Vol 2 p272 */\r\n\r\n    /*\tROUND 1. Set j = 2 and calculate q2 */\r\n    /*\tEstimate qhat = (u4u3)/v1  = 0 or 1\r\n        then set (u4u3u2) -= qhat(v1v0)\r\n        where u4 = 0.\r\n    */\r\n/* [Replaced in Version 2] -->\r\n\tqhat = u3 / v1;\r\n\tif (qhat > 0)\r\n\t{\r\n\t\trhat = u3 - qhat * v1;\r\n\t\tt = TOHIGH(rhat) | u2;\r\n\t\tif (qhat * v0 > t)\r\n\t\t\tqhat--;\r\n\t}\r\n<-- */\r\n    qhat = (u3 < v1 ? 0 : 1);\r\n    if (qhat > 0) {    /* qhat is one, so no need to mult */\r\n        rhat = u3 - v1;\r\n        /* t = r.b + u2 */\r\n        t = TOHIGH(rhat) | u2;\r\n        if (v0 > t)\r\n            qhat--;\r\n    }\r\n\r\n    uu[1] = 0;        /* (u4) */\r\n    uu[0] = u[1];    /* (u3u2) */\r\n    if (qhat > 0) {\r\n        /* (u4u3u2) -= qhat(v1v0) where u4 = 0 */\r\n        spMultSub(uu, qhat, v1, v0);\r\n        if (HIHALF(uu[1]) != 0) {    /* Add back */\r\n            qhat--;\r\n            uu[0] += v;\r\n            uu[1] = 0;\r\n        }\r\n    }\r\n    q2 = qhat;\r\n\r\n    /*\tROUND 2. Set j = 1 and calculate q1 */\r\n    /*\tEstimate qhat = (u3u2) / v1\r\n        then set (u3u2u1) -= qhat(v1v0)\r\n    */\r\n    t = uu[0];\r\n    qhat = t / v1;\r\n    rhat = t - qhat * v1;\r\n    /* Test on v0 */\r\n    t = TOHIGH(rhat) | u1;\r\n    if ((qhat == B) || (qhat * v0 > t)) {\r\n        qhat--;\r\n        rhat += v1;\r\n        t = TOHIGH(rhat) | u1;\r\n        if ((rhat < B) && (qhat * v0 > t))\r\n            qhat--;\r\n    }\r\n\r\n    /*\tMultiply and subtract\r\n        (u3u2u1)' = (u3u2u1) - qhat(v1v0)\r\n    */\r\n    uu[1] = HIHALF(uu[0]);    /* (0u3) */\r\n    uu[0] = TOHIGH(LOHALF(uu[0])) | u1;    /* (u2u1) */\r\n    spMultSub(uu, qhat, v1, v0);\r\n    if (HIHALF(uu[1]) != 0) {    /* Add back */\r\n        qhat--;\r\n        uu[0] += v;\r\n        uu[1] = 0;\r\n    }\r\n\r\n    /* q1 = qhat */\r\n    *q = TOHIGH(qhat);\r\n\r\n    /* ROUND 3. Set j = 0 and calculate q0 */\r\n    /*\tEstimate qhat = (u2u1) / v1\r\n        then set (u2u1u0) -= qhat(v1v0)\r\n    */\r\n    t = uu[0];\r\n    qhat = t / v1;\r\n    rhat = t - qhat * v1;\r\n    /* Test on v0 */\r\n    t = TOHIGH(rhat) | u0;\r\n    if ((qhat == B) || (qhat * v0 > t)) {\r\n        qhat--;\r\n        rhat += v1;\r\n        t = TOHIGH(rhat) | u0;\r\n        if ((rhat < B) && (qhat * v0 > t))\r\n            qhat--;\r\n    }\r\n\r\n    /*\tMultiply and subtract\r\n        (u2u1u0)\" = (u2u1u0)' - qhat(v1v0)\r\n    */\r\n    uu[1] = HIHALF(uu[0]);    /* (0u2) */\r\n    uu[0] = TOHIGH(LOHALF(uu[0])) | u0;    /* (u1u0) */\r\n    spMultSub(uu, qhat, v1, v0);\r\n    if (HIHALF(uu[1]) != 0) {    /* Add back */\r\n        qhat--;\r\n        uu[0] += v;\r\n        uu[1] = 0;\r\n    }\r\n\r\n    /* q0 = qhat */\r\n    *q |= LOHALF(qhat);\r\n\r\n    /* Remainder is in (u1u0) i.e. uu[0] */\r\n    *r = uu[0];\r\n    return q2;\r\n}", "item_id": 6, "repo": "ssavvides/homomorphic-c", "file": "src/bigdigits.c", "last_update_at": "2022-01-21T14:02:15+00:00", "question_id": "a22b4392100d0a6a7e74c2e38a35b1fbaa91beae_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["DIGIT_T spDivide(DIGIT_T *q, DIGIT_T *r, const DIGIT_T u[2], DIGIT_T v) {    /*\tComputes quotient q = u / v, remainder r = u mod v\r\n\t\twhere u is a double digit\r\n\t\tand q, v, r are single precision digits.\r\n\t\tReturns high digit of quotient (max value is 1)\r\n\t\tCAUTION: Assumes normalised such that v1 >= b/2\r\n\t\twhere b is size of HALF_DIGIT\r\n\t\ti.e. the most significant bit of v should be one\r\n\r\n\t\tIn terms of half-digits in Knuth notation:\r\n\t\t(q2q1q0) = (u4u3u2u1u0) / (v1v0)\r\n\t\t(r1r0) = (u4u3u2u1u0) mod (v1v0)\r\n\t\tfor m = 2, n = 2 where u4 = 0\r\n\t\tq2 is either 0 or 1.\r\n\t\tWe set q = (q1q0) and return q2 as \"overflow\"\r\n\t*/\r\n    DIGIT_T qhat, rhat, t, v0, v1, u0, u1, u2, u3;\r\n    DIGIT_T uu[2], q2;\r\n\r\n    /* Check for normalisation */\r\n    if (!(v & HIBITMASK)) {    /* Stop if assert is working, else return error */\r\n        assert(v & HIBITMASK);\r\n        *q = *r = 0;\r\n        return MAX_DIGIT;\r\n    }\r\n\r\n    /* Split up into half-digits */\r\n    v0 = LOHALF(v);\r\n    v1 = HIHALF(v);\r\n    u0 = LOHALF(u[0]);\r\n    u1 = HIHALF(u[0]);\r\n    u2 = LOHALF(u[1]);\r\n    u3 = HIHALF(u[1]);\r\n\r\n    /* Do three rounds of Knuth Algorithm D Vol 2 p272 */\r\n\r\n    /*\tROUND 1. Set j = 2 and calculate q2 */\r\n    /*\tEstimate qhat = (u4u3)/v1  = 0 or 1\r\n        then set (u4u3u2) -= qhat(v1v0)\r\n        where u4 = 0.\r\n    */\r\n/* [Replaced in Version 2] -->\r\n\tqhat = u3 / v1;\r\n\tif (qhat > 0)\r\n\t{\r\n\t\trhat = u3 - qhat * v1;\r\n\t\tt = TOHIGH(rhat) | u2;\r\n\t\tif (qhat * v0 > t)\r\n\t\t\tqhat--;\r\n\t}\r\n<-- */\r\n    qhat = (u3 < v1 ? 0 : 1);\r\n    if (qhat > 0) {    /* qhat is one, so no need to mult */\r\n        rhat = u3 - v1;\r\n        /* t = r.b + u2 */\r\n        t = TOHIGH(rhat) | u2;\r\n        if (v0 > t)\r\n            qhat--;\r\n    }\r\n\r\n    uu[1] = 0;        /* (u4) */\r\n    uu[0] = u[1];    /* (u3u2) */\r\n    if (qhat > 0) {\r\n        /* (u4u3u2) -= qhat(v1v0) where u4 = 0 */\r\n        spMultSub(uu, qhat, v1, v0);\r\n        if (HIHALF(uu[1]) != 0) {    /* Add back */\r\n            qhat--;\r\n            uu[0] += v;\r\n            uu[1] = 0;\r\n        }\r\n    }\r\n    q2 = qhat;\r\n\r\n    /*\tROUND 2. Set j = 1 and calculate q1 */\r\n    /*\tEstimate qhat = (u3u2) / v1\r\n        then set (u3u2u1) -= qhat(v1v0)\r\n    */\r\n    t = uu[0];\r\n    qhat = t / v1;\r\n    rhat = t - qhat * v1;\r\n    /* Test on v0 */\r\n    t = TOHIGH(rhat) | u1;\r\n    if ((qhat == B) || (qhat * v0 > t)) {\r\n        qhat--;\r\n        rhat += v1;\r\n        t = TOHIGH(rhat) | u1;\r\n        if ((rhat < B) && (qhat * v0 > t))\r\n            qhat--;\r\n    }\r\n\r\n    /*\tMultiply and subtract\r\n        (u3u2u1)' = (u3u2u1) - qhat(v1v0)\r\n    */\r\n    uu[1] = HIHALF(uu[0]);    /* (0u3) */\r\n    uu[0] = TOHIGH(LOHALF(uu[0])) | u1;    /* (u2u1) */\r\n    spMultSub(uu, qhat, v1, v0);\r\n    if (HIHALF(uu[1]) != 0) {    /* Add back */\r\n        qhat--;\r\n        uu[0] += v;\r\n        uu[1] = 0;\r\n    }\r\n\r\n    /* q1 = qhat */\r\n    *q = TOHIGH(qhat);\r\n\r\n    /* ROUND 3. Set j = 0 and calculate q0 */\r\n    /*\tEstimate qhat = (u2u1) / v1\r\n        then set (u2u1u0) -= qhat(v1v0)\r\n    */\r\n    t = uu[0];\r\n    qhat = t / v1;\r\n    rhat = t - qhat * v1;\r\n    /* Test on v0 */\r\n    t = TOHIGH(rhat) | u0;\r\n    if ((qhat == B) || (qhat * v0 > t)) {\r\n        qhat--;\r\n        rhat += v1;\r\n        t = TOHIGH(rhat) | u0;\r\n        if ((rhat < B) && (qhat * v0 > t))\r\n            qhat--;\r\n    }\r\n\r\n    /*\tMultiply and subtract\r\n        (u2u1u0)\" = (u2u1u0)' - qhat(v1v0)\r\n    */\r\n    uu[1] = HIHALF(uu[0]);    /* (0u2) */\r\n    uu[0] = TOHIGH(LOHALF(uu[0])) | u0;    /* (u1u0) */\r\n    spMultSub(uu, qhat, v1, v0);\r\n    if (HIHALF(uu[1]) != 0) {    /* Add back */\r\n        qhat--;\r\n        uu[0] += v;\r\n        uu[1] = 0;\r\n    }\r\n\r\n    /* q0 = qhat */\r\n    *q |= LOHALF(qhat);\r\n\r\n    /* Remainder is in (u1u0) i.e. uu[0] */\r\n    *r = uu[0];\r\n    return q2;\r\n"]]}
{"hexsha": "65f8d457dbffee199a82478c5016c3509ae76f18", "ext": "c", "lang": "C", "content": "static void outflush()\n\n#endif\n{\n    char           *buf;\n    int             got;\n    uint            len;\n\n    /* if (bufidx - buf > 0) */\n\tfor (buf = bufstart; len = bufidx - buf;) {\n\t    if ((got = write(archivefd, buf, MIN(len, blocksize))) > 0) {\n\t\tbuf += got;\n\t    } else if (got < 0) {\n\t\tnext(AR_WRITE);\n\t    }\n\t}\n    bufend = (bufidx = bufstart) + blocksize;\n}", "item_id": 9, "repo": "gspu/Coherent", "file": "mwc/romana/relic/g/usr/bin/pax/buffer.c", "last_update_at": "2022-02-24T02:54:38+00:00", "question_id": "65f8d457dbffee199a82478c5016c3509ae76f18_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void outflush()\n#endif\n{\n    char           *buf;\n    int             got;\n    uint            len;\n    /* if (bufidx - buf > 0) */\n\tfor (buf = bufstart; len = bufidx - buf;) {\n\t    if ((got = write(archivefd, buf, MIN(len, blocksize))) > 0) {\n\t\tbuf += got;\n\t    } else if (got < 0) {\n\t\tnext(AR_WRITE);\n\t    }\n\t}\n    bufend = (bufidx = bufstart) + blocksize;\n"]]}
{"hexsha": "89c42ae9353f9e3ebe56f2ae40d58707c6662eaf", "ext": "h", "lang": "C", "content": "interface _SYQuiescenceObserver : NSObject {\n    NSObject<OS_dispatch_group> * _allocationGroup;\n    NSMutableSet * _allocations;\n    NSPointerArray * _quiescenceQueues;\n}", "item_id": 0, "repo": "onmyway133/Runtime-Headers", "file": "iOS/10.0.2/PrivateFrameworks/CompanionSync.framework/_SYQuiescenceObserver.h", "last_update_at": "2022-01-24T04:14:57+00:00", "question_id": "89c42ae9353f9e3ebe56f2ae40d58707c6662eaf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface _SYQuiescenceObserver : NSObject {\n    NSObject<OS_dispatch_group> * _allocationGroup;\n    NSMutableSet * _allocations;\n    NSPointerArray * _quiescenceQueues;\n"]]}
{"hexsha": "e2d2b3a4b86803b049c9113328660db55f4dc66a", "ext": "c", "lang": "C", "content": "struct dyn_array *\ndyn_array_create(size_t elm_size, intmax_t chunk, intmax_t start_elm_count, bool zeroize)\n{\n    struct dyn_array *ret;\t\t/* Created dynamic array to return */\n    intmax_t number_of_bytes;\t\t/* Total number of bytes occupied by the initialized array */\n\n    /*\n     * Check preconditions (firewall) - sanity check args\n     */\n    if (elm_size <= 0) {\n\terr(58, __func__, \"elm_size must be > 0: %ju\", (uintmax_t)elm_size);\n\tnot_reached();\n    }\n    if (chunk <= 0) {\n\terr(59, __func__, \"chunk must be > 0: %jd\", chunk);\n\tnot_reached();\n    }\n    if (start_elm_count <= 0) {\n\terr(60, __func__, \"start_elm_count must be > 0: %jd\", start_elm_count);\n\tnot_reached();\n    }\n\n    /*\n     * Allocate new dynamic array\n     */\n    errno = 0;\t\t\t/* pre-clear errno for errp() */\n    ret = calloc(1, sizeof(struct dyn_array));\n    if (ret == NULL) {\n\terrp(61, __func__, \"cannot calloc %ju bytes for a struct dyn_array\",\n\t\t\t   (uintmax_t)sizeof(struct dyn_array));\n\tnot_reached();\n    }\n\n    /*\n     * Initialize empty dynamic array\n     * Start with a dynamic array with allocated enough chunks to hold at least start_elm_count elements\n     */\n    ret->elm_size = elm_size;\n    ret->zeroize = zeroize;\n    /* Allocated array is empty */\n    ret->count = 0;\n    /* Allocate a number of elements multiple of chunk */\n    ret->allocated = chunk * ((start_elm_count + (chunk - 1)) / chunk);\n    ret->chunk = chunk;\n\n    /*\n     * determine the size of the allocated area\n     */\n    /* +chunk for guard chunk */\n    number_of_bytes = (ret->allocated+chunk) * elm_size;\n\n    errno = 0;\t\t\t/* pre-clear errno for errp() */\n    ret->data = malloc((size_t)number_of_bytes);\n    if (ret->data == NULL) {\n\t/* +chunk for guard chunk */\n\terrp(62, __func__, \"cannot malloc of %jd elements of %ju bytes each for dyn_array->data\",\n\t\t\t   (ret->allocated+chunk), (uintmax_t)elm_size);\n\tnot_reached();\n    }\n\n    /*\n     * Zeroize allocated data\n     */\n    if (ret->zeroize == true) {\n\tmemset(ret->data, 0, number_of_bytes);\n    }\n\n    /*\n     * Return newly allocated array\n     */\n    dbg(DBG_VVHIGH, \"%s(%ju, %jd, %jd, %s): initialized empty dynamic array, allocated: %jd elements of size: %ju\",\n\t\t    __func__, (uintmax_t)elm_size, chunk, start_elm_count,\n\t\t    booltostr(zeroize),\n\t\t    dyn_array_alloced(ret), (uintmax_t)ret->elm_size);\n    return ret;\n}", "item_id": 1, "repo": "ioccc-src/mkiocccentry", "file": "dyn_array.c", "last_update_at": "2022-02-27T10:12:35+00:00", "question_id": "e2d2b3a4b86803b049c9113328660db55f4dc66a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct dyn_array *\ndyn_array_create(size_t elm_size, intmax_t chunk, intmax_t start_elm_count, bool zeroize)\n{\n    struct dyn_array *ret;\t\t/* Created dynamic array to return */\n    intmax_t number_of_bytes;\t\t/* Total number of bytes occupied by the initialized array */\n    /*\n     * Check preconditions (firewall) - sanity check args\n     */\n    if (elm_size <= 0) {\n\terr(58, __func__, \"elm_size must be > 0: %ju\", (uintmax_t)elm_size);\n\tnot_reached();\n    }\n    if (chunk <= 0) {\n\terr(59, __func__, \"chunk must be > 0: %jd\", chunk);\n\tnot_reached();\n    }\n    if (start_elm_count <= 0) {\n\terr(60, __func__, \"start_elm_count must be > 0: %jd\", start_elm_count);\n\tnot_reached();\n    }\n    /*\n     * Allocate new dynamic array\n     */\n    errno = 0;\t\t\t/* pre-clear errno for errp() */\n    ret = calloc(1, sizeof(struct dyn_array));\n    if (ret == NULL) {\n\terrp(61, __func__, \"cannot calloc %ju bytes for a struct dyn_array\",\n\t\t\t   (uintmax_t)sizeof(struct dyn_array));\n\tnot_reached();\n    }\n    /*\n     * Initialize empty dynamic array\n     * Start with a dynamic array with allocated enough chunks to hold at least start_elm_count elements\n     */\n    ret->elm_size = elm_size;\n    ret->zeroize = zeroize;\n    /* Allocated array is empty */\n    ret->count = 0;\n    /* Allocate a number of elements multiple of chunk */\n    ret->allocated = chunk * ((start_elm_count + (chunk - 1)) / chunk);\n    ret->chunk = chunk;\n    /*\n     * determine the size of the allocated area\n     */\n    /* +chunk for guard chunk */\n    number_of_bytes = (ret->allocated+chunk) * elm_size;\n    errno = 0;\t\t\t/* pre-clear errno for errp() */\n    ret->data = malloc((size_t)number_of_bytes);\n    if (ret->data == NULL) {\n\t/* +chunk for guard chunk */\n\terrp(62, __func__, \"cannot malloc of %jd elements of %ju bytes each for dyn_array->data\",\n\t\t\t   (ret->allocated+chunk), (uintmax_t)elm_size);\n\tnot_reached();\n    }\n    /*\n     * Zeroize allocated data\n     */\n    if (ret->zeroize == true) {\n\tmemset(ret->data, 0, number_of_bytes);\n    }\n    /*\n     * Return newly allocated array\n     */\n    dbg(DBG_VVHIGH, \"%s(%ju, %jd, %jd, %s): initialized empty dynamic array, allocated: %jd elements of size: %ju\",\n\t\t    __func__, (uintmax_t)elm_size, chunk, start_elm_count,\n\t\t    booltostr(zeroize),\n\t\t    dyn_array_alloced(ret), (uintmax_t)ret->elm_size);\n    return ret;\n"]]}
{"hexsha": "d99c4bf6d21bb55e87e615a6555555881994225f", "ext": "c", "lang": "C", "content": "int lsh_com_err_proc (LPSTR whoami, long code,\n                              LPSTR fmt, va_list args)\n{\n    int retval;\n    HWND hOldFocus;\n    char buf[1024], *cp;\n    WORD mbformat = MB_OK | MB_ICONEXCLAMATION;\n\n    cp = buf;\n    memset(buf, '\\0', sizeof(buf));\n    cp[0] = '\\0';\n\n    if (code)\n    {\n        err_describe(buf, code);\n        while (*cp)\n            cp++;\n    }\n\n    if (fmt)\n    {\n        if (fmt[0] == '%' && fmt[1] == 'b')\n\t{\n            fmt += 2;\n            mbformat = va_arg(args, WORD);\n            /* if the first arg is a %b, we use it for the message\n               box MB_??? flags. */\n\t}\n        if (code)\n\t{\n            *cp++ = '\\n';\n            *cp++ = '\\n';\n\t}\n        wvsprintfA((LPSTR)cp, fmt, args);\n    }\n    hOldFocus = GetFocus();\n    retval = MessageBoxA(/*GetRootParent(hOldFocus)*/NULL, buf, whoami,\n                        mbformat | MB_ICONHAND | MB_TASKMODAL);\n    SetFocus(hOldFocus);\n    return retval;\n}", "item_id": 2, "repo": "kbore/pbis-open", "file": "krb5/src/windows/identity/plugins/krb5/errorfuncs.c", "last_update_at": "2022-03-18T19:54:37+00:00", "question_id": "d99c4bf6d21bb55e87e615a6555555881994225f_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int lsh_com_err_proc (LPSTR whoami, long code,\n                              LPSTR fmt, va_list args)\n{\n    int retval;\n    HWND hOldFocus;\n    char buf[1024], *cp;\n    WORD mbformat = MB_OK | MB_ICONEXCLAMATION;\n    cp = buf;\n    memset(buf, '\\0', sizeof(buf));\n    cp[0] = '\\0';\n    if (code)\n    {\n        err_describe(buf, code);\n        while (*cp)\n            cp++;\n    }\n    if (fmt)\n    {\n        if (fmt[0] == '%' && fmt[1] == 'b')\n\t{\n            fmt += 2;\n            mbformat = va_arg(args, WORD);\n            /* if the first arg is a %b, we use it for the message\n               box MB_??? flags. */\n\t}\n        if (code)\n\t{\n            *cp++ = '\\n';\n            *cp++ = '\\n';\n\t}\n        wvsprintfA((LPSTR)cp, fmt, args);\n    }\n    hOldFocus = GetFocus();\n    retval = MessageBoxA(/*GetRootParent(hOldFocus)*/NULL, buf, whoami,\n                        mbformat | MB_ICONHAND | MB_TASKMODAL);\n    SetFocus(hOldFocus);\n    return retval;\n"]]}
{"hexsha": "dc184261603664763c05aff15a93a7b540674da9", "ext": "c", "lang": "C", "content": "int\nmain(int argc, char *argv[])\n{\n    int       i, driver = DB_PDB;\n    double    time;\n    int       cycle;\n    int       show_all_errors = FALSE;\n\n    for (i=1; i<argc; i++) {\n        if (!strncmp(argv[i], \"DB_PDB\", 6)) {\n            driver = StringToDriver(argv[i]);\n        } else if (!strncmp(argv[i], \"DB_HDF5\", 7)) {\n            driver = StringToDriver(argv[i]);\n        } else if (!strcmp(argv[i], \"hzip\")) {\n            DBSetCompression(\"METHOD=HZIP\");\n            driver = DB_HDF5;\n        } else if (!strcmp(argv[i], \"fpzip\")) {\n            DBSetCompression(\"METHOD=FPZIP\");\n            driver = DB_HDF5;\n        } else if (!strcmp(argv[i], \"zfp\")) {\n            char msg[256];\n            double rate = strtod(argv[++i],0);\n            snprintf(msg, sizeof(msg), \"METHOD=ZFP RATE=%g\", rate);\n            DBSetCompression(msg);\n            driver = DB_HDF5;\n        } else if (!strcmp(argv[i], \"show-all-errors\")) {\n            show_all_errors = 1;\n\t} else if (argv[i][0] != '\\0') {\n            fprintf(stderr, \"%s: ignored argument `%s'\\n\", argv[0], argv[i]);\n        }\n    }\n\n    if (show_all_errors) DBShowErrors(DB_ALL_AND_DRVR, 0);\n\n    for (i = 0; i < NT + 1; i++)\n    {\n        time = T0 + ((double)i / (double)NT) * DT;\n        cycle = i * 10;\n        SWriteFile (time, cycle, driver);\n    }\n\n    DBSetCompression(0);\n    CleanupDriverStuff();\n    return 0;\n}", "item_id": 0, "repo": "EMinsight/Silo", "file": "tests/wave.c", "last_update_at": "2022-03-21T02:17:31+00:00", "question_id": "dc184261603664763c05aff15a93a7b540674da9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nmain(int argc, char *argv[])\n{\n    int       i, driver = DB_PDB;\n    double    time;\n    int       cycle;\n    int       show_all_errors = FALSE;\n    for (i=1; i<argc; i++) {\n        if (!strncmp(argv[i], \"DB_PDB\", 6)) {\n            driver = StringToDriver(argv[i]);\n        } else if (!strncmp(argv[i], \"DB_HDF5\", 7)) {\n            driver = StringToDriver(argv[i]);\n        } else if (!strcmp(argv[i], \"hzip\")) {\n            DBSetCompression(\"METHOD=HZIP\");\n            driver = DB_HDF5;\n        } else if (!strcmp(argv[i], \"fpzip\")) {\n            DBSetCompression(\"METHOD=FPZIP\");\n            driver = DB_HDF5;\n        } else if (!strcmp(argv[i], \"zfp\")) {\n            char msg[256];\n            double rate = strtod(argv[++i],0);\n            snprintf(msg, sizeof(msg), \"METHOD=ZFP RATE=%g\", rate);\n            DBSetCompression(msg);\n            driver = DB_HDF5;\n        } else if (!strcmp(argv[i], \"show-all-errors\")) {\n            show_all_errors = 1;\n\t} else if (argv[i][0] != '\\0') {\n            fprintf(stderr, \"%s: ignored argument `%s'\\n\", argv[0], argv[i]);\n        }\n    }\n    if (show_all_errors) DBShowErrors(DB_ALL_AND_DRVR, 0);\n    for (i = 0; i < NT + 1; i++)\n    {\n        time = T0 + ((double)i / (double)NT) * DT;\n        cycle = i * 10;\n        SWriteFile (time, cycle, driver);\n    }\n    DBSetCompression(0);\n    CleanupDriverStuff();\n    return 0;\n"]]}
{"hexsha": "8ad3ba01506f2d09a580efb1d0a472cf389b5a6f", "ext": "c", "lang": "C", "content": "int main(int argc, char *argv[]) {\n\n    // \u8af8\u3005\u306e\u5909\u6570\u3092\u5b9a\u7fa9\n    int i, data_count, transition_count;\n    FILE *fp;\n    char file_name[50];\n    strcpy(file_name, argv[1]);\n    Csv csv[DATA_MAX];\n\n    // csv\u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u3080\uff0e\u8aad\u307f\u8fbc\u3081\u306a\u3044\u3068\u30a8\u30e9\u30fc\u3092\u66f8\u304d\u8fbc\u307f\uff08\u30a8\u30e9\u30fc\u304c\u8d77\u3053\u3063\u305f\u30d5\u30a1\u30a4\u30eb\u3092\u7279\u5b9a\u3059\u308b\u305f\u3081\uff09\n    if ((fp = fopen(file_name, \"r\")) == NULL) {\n        fprintf(stderr, \"%s\\n\", \"error: cant't read file.\");\n        return -1;\n    }\n\n    // \u30c7\u30fc\u30bf\u6570\u3092\u6570\u3048\u308b\n    i = 0;\n    while (fscanf(fp, \"%lf, %lf, %lf\", &csv[i].x, &csv[i].y, &csv[i].t) != EOF) {\n        i++;\n    }\n    data_count = i;\n\n    // \u30d5\u30a1\u30a4\u30eb\u3092\u30af\u30ed\u30fc\u30ba\u3059\u308b\n    fclose(fp);\n\n    // \u9077\u79fb\u56de\u6570\u683c\u7d0d\u7528\u306e\u5909\u6570\u306e\u521d\u671f\u5316\n    int transition_count_of_into_front = 0, transition_count_of_into_plan = 0, transition_count_of_into_right_side = 0;\n\n    // \u8996\u7dda\u304c\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u5185\u306b\u5b58\u5728\u3057\u3066\uff0c\u5c1a\u4e14\u3064\uff0c\u524d\u306e\u8996\u7dda\u304c\u9055\u3046\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u4e0a\u306b\u3042\u3063\u305f\u5834\u5408\u306b\u30ab\u30a6\u30f3\u30c8\n    for (i = 1; i < data_count; i++) {\n\n        if (((FRONT_VIEW_LEFT < csv[i].x) && (csv[i].x < FRONT_VIEW_RIGHT)) && ((FRONT_VIEW_TOP < csv[i].y) && (csv[i].y < FRONT_VIEW_BOTTOM))) \n            if (!(((FRONT_VIEW_LEFT < csv[i-1].x) && (csv[i-1].x < FRONT_VIEW_RIGHT)) && ((FRONT_VIEW_TOP < csv[i-1].y) && (csv[i-1].y < FRONT_VIEW_BOTTOM)))) \n                transition_count_of_into_front++;\n        \n        if (((PLAN_VIEW_LEFT < csv[i].x) && (csv[i].x < PLAN_VIEW_RIGHT)) && ((PLAN_VIEW_TOP < csv[i].y) && (csv[i].y < PLAN_VIEW_BOTTOM))) \n            if (!(((PLAN_VIEW_LEFT < csv[i-1].x) && (csv[i-1].x < PLAN_VIEW_RIGHT)) && ((PLAN_VIEW_TOP < csv[i-1].y) && (csv[i-1].y < PLAN_VIEW_BOTTOM))))\n                transition_count_of_into_plan++;\n        \n        if (((RIGHT_SIDE_VIEW_LEFT < csv[i].x) && (csv[i].x < RIGHT_SIDE_VIEW_RIGHT)) && ((RIGHT_SIDE_VIEW_TOP < csv[i].y) && (csv[i].y < RIGHT_SIDE_VIEW_BOTTOM)))\n            if ((((RIGHT_SIDE_VIEW_LEFT < csv[i-1].x) && (csv[i-1].x < RIGHT_SIDE_VIEW_RIGHT)) && ((RIGHT_SIDE_VIEW_TOP < csv[i-1].y) && (csv[i-1].y < RIGHT_SIDE_VIEW_BOTTOM))))\n                transition_count_of_into_right_side++;\n    }\n\n    // \u7dcf\u9077\u79fb\u56de\u6570\u3092\u5c0e\u51fa\n    transition_count = transition_count_of_into_front + transition_count_of_into_plan + transition_count_of_into_right_side;\n\n    FILE *resfp;\n    char res_file_name[50];\n    strcpy(res_file_name, argv[2]);\n    resfp = fopen(res_file_name, \"w\");\n    fprintf(resfp, \"transition_count_of_into_front,transition_count_of_into_plan,transition_count_of_into_right_side,transition_count\\n\");\n    fprintf(resfp, \"%d,%d,%d,%d\\n\",transition_count_of_into_front,transition_count_of_into_plan,transition_count_of_into_right_side,transition_count);\n\n    fclose(resfp);\n\n    // \u30c7\u30fc\u30bf\u51fa\u529b\n    /*\n    for (i = 0; i < data_count; i++) {\n        printf(\"%.2f, %.2f, %.2f\\n\", csv[i].x, csv[i].y, csv[i].t);\n    }\n    */\n    printf(\"the number of data: %d\\n\", data_count);\n    printf(\"the number of transition into frnot: %d\\n\", transition_count_of_into_front);\n    printf(\"the number of transition into plan: %d\\n\", transition_count_of_into_plan);\n    printf(\"the number of transition into right side: %d\\n\", transition_count_of_into_right_side);\n    printf(\"the number of transition: %d\\n\", transition_count);\n\n    return 1;\n}", "item_id": 0, "repo": "ry0y4n/analysisOnElectron", "file": "countTransition.c", "last_update_at": "2022-03-25T19:00:25+00:00", "question_id": "8ad3ba01506f2d09a580efb1d0a472cf389b5a6f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char *argv[]) {\n    // \u8af8\u3005\u306e\u5909\u6570\u3092\u5b9a\u7fa9\n    int i, data_count, transition_count;\n    FILE *fp;\n    char file_name[50];\n    strcpy(file_name, argv[1]);\n    Csv csv[DATA_MAX];\n    // csv\u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u3080\uff0e\u8aad\u307f\u8fbc\u3081\u306a\u3044\u3068\u30a8\u30e9\u30fc\u3092\u66f8\u304d\u8fbc\u307f\uff08\u30a8\u30e9\u30fc\u304c\u8d77\u3053\u3063\u305f\u30d5\u30a1\u30a4\u30eb\u3092\u7279\u5b9a\u3059\u308b\u305f\u3081\uff09\n    if ((fp = fopen(file_name, \"r\")) == NULL) {\n        fprintf(stderr, \"%s\\n\", \"error: cant't read file.\");\n        return -1;\n    }\n    // \u30c7\u30fc\u30bf\u6570\u3092\u6570\u3048\u308b\n    i = 0;\n    while (fscanf(fp, \"%lf, %lf, %lf\", &csv[i].x, &csv[i].y, &csv[i].t) != EOF) {\n        i++;\n    }\n    data_count = i;\n    // \u30d5\u30a1\u30a4\u30eb\u3092\u30af\u30ed\u30fc\u30ba\u3059\u308b\n    fclose(fp);\n    // \u9077\u79fb\u56de\u6570\u683c\u7d0d\u7528\u306e\u5909\u6570\u306e\u521d\u671f\u5316\n    int transition_count_of_into_front = 0, transition_count_of_into_plan = 0, transition_count_of_into_right_side = 0;\n    // \u8996\u7dda\u304c\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u5185\u306b\u5b58\u5728\u3057\u3066\uff0c\u5c1a\u4e14\u3064\uff0c\u524d\u306e\u8996\u7dda\u304c\u9055\u3046\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u4e0a\u306b\u3042\u3063\u305f\u5834\u5408\u306b\u30ab\u30a6\u30f3\u30c8\n    for (i = 1; i < data_count; i++) {\n        if (((FRONT_VIEW_LEFT < csv[i].x) && (csv[i].x < FRONT_VIEW_RIGHT)) && ((FRONT_VIEW_TOP < csv[i].y) && (csv[i].y < FRONT_VIEW_BOTTOM))) \n            if (!(((FRONT_VIEW_LEFT < csv[i-1].x) && (csv[i-1].x < FRONT_VIEW_RIGHT)) && ((FRONT_VIEW_TOP < csv[i-1].y) && (csv[i-1].y < FRONT_VIEW_BOTTOM)))) \n                transition_count_of_into_front++;\n        if (((PLAN_VIEW_LEFT < csv[i].x) && (csv[i].x < PLAN_VIEW_RIGHT)) && ((PLAN_VIEW_TOP < csv[i].y) && (csv[i].y < PLAN_VIEW_BOTTOM))) \n            if (!(((PLAN_VIEW_LEFT < csv[i-1].x) && (csv[i-1].x < PLAN_VIEW_RIGHT)) && ((PLAN_VIEW_TOP < csv[i-1].y) && (csv[i-1].y < PLAN_VIEW_BOTTOM))))\n                transition_count_of_into_plan++;\n        if (((RIGHT_SIDE_VIEW_LEFT < csv[i].x) && (csv[i].x < RIGHT_SIDE_VIEW_RIGHT)) && ((RIGHT_SIDE_VIEW_TOP < csv[i].y) && (csv[i].y < RIGHT_SIDE_VIEW_BOTTOM)))\n            if ((((RIGHT_SIDE_VIEW_LEFT < csv[i-1].x) && (csv[i-1].x < RIGHT_SIDE_VIEW_RIGHT)) && ((RIGHT_SIDE_VIEW_TOP < csv[i-1].y) && (csv[i-1].y < RIGHT_SIDE_VIEW_BOTTOM))))\n                transition_count_of_into_right_side++;\n    }\n    // \u7dcf\u9077\u79fb\u56de\u6570\u3092\u5c0e\u51fa\n    transition_count = transition_count_of_into_front + transition_count_of_into_plan + transition_count_of_into_right_side;\n    FILE *resfp;\n    char res_file_name[50];\n    strcpy(res_file_name, argv[2]);\n    resfp = fopen(res_file_name, \"w\");\n    fprintf(resfp, \"transition_count_of_into_front,transition_count_of_into_plan,transition_count_of_into_right_side,transition_count\\n\");\n    fprintf(resfp, \"%d,%d,%d,%d\\n\",transition_count_of_into_front,transition_count_of_into_plan,transition_count_of_into_right_side,transition_count);\n    fclose(resfp);\n    // \u30c7\u30fc\u30bf\u51fa\u529b\n    /*\n    for (i = 0; i < data_count; i++) {\n        printf(\"%.2f, %.2f, %.2f\\n\", csv[i].x, csv[i].y, csv[i].t);\n    }\n    */\n    printf(\"the number of data: %d\\n\", data_count);\n    printf(\"the number of transition into frnot: %d\\n\", transition_count_of_into_front);\n    printf(\"the number of transition into plan: %d\\n\", transition_count_of_into_plan);\n    printf(\"the number of transition into right side: %d\\n\", transition_count_of_into_right_side);\n    printf(\"the number of transition: %d\\n\", transition_count);\n    return 1;\n"]]}
{"hexsha": "3e48183360b39b649783216ac1a862953b500294", "ext": "c", "lang": "C", "content": "static void recovery_image_observer_pcr_test_init_null (CuTest *test)\n{\n\tHASH_TESTING_ENGINE hash;\n\tstruct pcr_store store;\n\tuint8_t num_pcr_measurements[] = {6, 6};\n\tstruct recovery_image_observer_pcr observer;\n\tint status;\n\n\tTEST_START;\n\n\tstatus = HASH_TESTING_ENGINE_INIT (&hash);\n\tCuAssertIntEquals (test, 0, status);\n\n\tstatus = pcr_store_init (&store, num_pcr_measurements, sizeof (num_pcr_measurements));\n\tCuAssertIntEquals (test, 0, status);\n\n\tstatus = recovery_image_observer_pcr_init (NULL, &hash.base, &store, PCR_MEASUREMENT (0, 0));\n\tCuAssertIntEquals (test, RECOVERY_IMAGE_OBSERVER_INVALID_ARGUMENT, status);\n\n\tstatus = recovery_image_observer_pcr_init (&observer, NULL, &store, PCR_MEASUREMENT (0, 0));\n\tCuAssertIntEquals (test, RECOVERY_IMAGE_OBSERVER_INVALID_ARGUMENT, status);\n\n\tstatus = recovery_image_observer_pcr_init (&observer, &hash.base, NULL, PCR_MEASUREMENT (0, 0));\n\tCuAssertIntEquals (test, RECOVERY_IMAGE_OBSERVER_INVALID_ARGUMENT, status);\n\n\tpcr_store_release (&store);\n\tHASH_TESTING_ENGINE_RELEASE (&hash);\n}", "item_id": 1, "repo": "KameleonSec/Project-Cerberus", "file": "core/testing/recovery_image_observer_pcr_test.c", "last_update_at": "2022-03-11T00:14:45+00:00", "question_id": "3e48183360b39b649783216ac1a862953b500294_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void recovery_image_observer_pcr_test_init_null (CuTest *test)\n{\n\tHASH_TESTING_ENGINE hash;\n\tstruct pcr_store store;\n\tuint8_t num_pcr_measurements[] = {6, 6};\n\tstruct recovery_image_observer_pcr observer;\n\tint status;\n\tTEST_START;\n\tstatus = HASH_TESTING_ENGINE_INIT (&hash);\n\tCuAssertIntEquals (test, 0, status);\n\tstatus = pcr_store_init (&store, num_pcr_measurements, sizeof (num_pcr_measurements));\n\tCuAssertIntEquals (test, 0, status);\n\tstatus = recovery_image_observer_pcr_init (NULL, &hash.base, &store, PCR_MEASUREMENT (0, 0));\n\tCuAssertIntEquals (test, RECOVERY_IMAGE_OBSERVER_INVALID_ARGUMENT, status);\n\tstatus = recovery_image_observer_pcr_init (&observer, NULL, &store, PCR_MEASUREMENT (0, 0));\n\tCuAssertIntEquals (test, RECOVERY_IMAGE_OBSERVER_INVALID_ARGUMENT, status);\n\tstatus = recovery_image_observer_pcr_init (&observer, &hash.base, NULL, PCR_MEASUREMENT (0, 0));\n\tCuAssertIntEquals (test, RECOVERY_IMAGE_OBSERVER_INVALID_ARGUMENT, status);\n\tpcr_store_release (&store);\n\tHASH_TESTING_ENGINE_RELEASE (&hash);\n"]]}
{"hexsha": "5c4f2822f01ba76df480884fc4b7b1ffe90f65af", "ext": "c", "lang": "C", "content": "void vm_page_more_fictitious(void)\n{\n\tregister vm_page_t m;\n\tint i;\n\n\tfor (i = 0; i < vm_page_fictitious_quantum; i++) {\n\t\tm = (vm_page_t) zalloc(vm_page_zone);\n\t\tif (m == VM_PAGE_NULL)\n\t\t\tpanic(\"vm_page_more_fictitious\");\n\n\t\tvm_page_init(m, vm_page_fictitious_addr);\n\t\tm->fictitious = TRUE;\n\t\tvm_page_release_fictitious(m);\n\t}\n}", "item_id": 11, "repo": "eyadhamdan4/xMach", "file": "kernel/generic/kernel/vm/vm_resident.c", "last_update_at": "2022-01-24T05:30:29+00:00", "question_id": "5c4f2822f01ba76df480884fc4b7b1ffe90f65af_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void vm_page_more_fictitious(void)\n{\n\tregister vm_page_t m;\n\tint i;\n\tfor (i = 0; i < vm_page_fictitious_quantum; i++) {\n\t\tm = (vm_page_t) zalloc(vm_page_zone);\n\t\tif (m == VM_PAGE_NULL)\n\t\t\tpanic(\"vm_page_more_fictitious\");\n\t\tvm_page_init(m, vm_page_fictitious_addr);\n\t\tm->fictitious = TRUE;\n\t\tvm_page_release_fictitious(m);\n\t}\n"]]}
{"hexsha": "7f8079ba2a17dac5dfdf1140f52c2102fa7a9aca", "ext": "c", "lang": "C", "content": "int main(int argc, char **argv) {\n  // MU_RUN_TEST(testTagFunc);\n  RedisModule_Alloc = malloc;\n  RedisModule_Calloc = calloc;\n  RedisModule_Realloc = realloc;\n  RedisModule_Free = free;\n  IndexAlias_InitGlobal();\n  MU_RUN_TEST(testCommandMux);\n\n  MU_REPORT();\n  return minunit_status;\n}", "item_id": 1, "repo": "rrelledge/RediSearch", "file": "coord/tests/unit/test_searchcluster.c", "last_update_at": "2022-03-31T06:24:50+00:00", "question_id": "7f8079ba2a17dac5dfdf1140f52c2102fa7a9aca_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char **argv) {\n  // MU_RUN_TEST(testTagFunc);\n  RedisModule_Alloc = malloc;\n  RedisModule_Calloc = calloc;\n  RedisModule_Realloc = realloc;\n  RedisModule_Free = free;\n  IndexAlias_InitGlobal();\n  MU_RUN_TEST(testCommandMux);\n  MU_REPORT();\n  return minunit_status;\n"]]}
{"hexsha": "37be5fc44c8bc4e6074c8e135b50c33776935c9e", "ext": "c", "lang": "C", "content": "PUBLIC void do_kcall2(void)\n{\n\tint coreid = 0;\n\tint ret = -ENOSYS;\n\n\tsemaphore_down(&syssem);\n\n\t\t/* Sweeps the cores in a circular fashion. */\n\t\tfor (int i = 0; i < CORES_NUM; i++)\n\t\t{\n\t\t\tif (sysboard[sys_next_coreid].pending)\n\t\t\t{\n\t\t\t\tcoreid = sys_next_coreid;\n\t\t\t\tsys_next_coreid = (sys_next_coreid + 1) % CORES_NUM;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsys_next_coreid = (sys_next_coreid + 1) % CORES_NUM;\n\t\t}\n\n\t\t/* Invalid system call number. */\n\t\tif (sysboard[coreid].syscall_nr >= NR_SYSCALLS)\n\t\t{\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Parse system call number. */\n\t\tswitch (sysboard[coreid].syscall_nr)\n\t\t{\n\t\t\tcase NR_shutdown:\n\t\t\t\tret = kernel_shutdown();\n\t\t\t\tbreak;\n\n\t\t\tcase NR__exit:\n\t\t\t\tkernel_exit((int)(long) sysboard[coreid].arg0);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_write:\n\t\t\t\tret = kernel_write(\n\t\t\t\t\t(int)(long) sysboard[coreid].arg0,\n\t\t\t\t\t(const char *)(long) sysboard[coreid].arg1,\n\t\t\t\t\t(size_t)(long) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\n#if (THREAD_MAX > 1)\n\n\t\t\tcase NR_thread_create:\n\t\t\t\tret = kernel_thread_create(\n\t\t\t\t\t(int *)(long) sysboard[coreid].arg0,\n\t\t\t\t\t(void *(*)(void *))(long) sysboard[coreid].arg1,\n\t\t\t\t\t(void *)(long) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_wakeup:\n\t\t\t\tret = kernel_wakeup(\n\t\t\t\t\t(int)(long) sysboard[coreid].arg0\n\t\t\t\t);\n\t\t\t\tbreak;\n\n#endif\n\n\t\t\tcase NR_sigctl:\n\t\t\t\tret = kernel_sigctl(\n\t\t\t\t\t(int)(long) sysboard[coreid].arg0,\n\t\t\t\t\t(struct ksigaction *)(long) sysboard[coreid].arg1\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_node_get_num:\n\t\t\t\tret = kernel_node_get_num();\n\t\t\t\tbreak;\n\n\t\t\tcase NR_cluster_get_num:\n\t\t\t\tret = kernel_cluster_get_num();\n\t\t\t\tbreak;\n\n#if __TARGET_HAS_SYNC\n\t\t\tcase NR_sync_create:\n\t\t\t\tret = kernel_sync_create(\n\t\t\t\t\t(const int *)(long) sysboard[coreid].arg0,\n\t\t\t\t\t(int) sysboard[coreid].arg1,\n\t\t\t\t\t(int) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_sync_open:\n\t\t\t\tret = kernel_sync_open(\n\t\t\t\t\t(const int *)(long) sysboard[coreid].arg0,\n\t\t\t\t\t(int) sysboard[coreid].arg1,\n\t\t\t\t\t(int) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_sync_unlink:\n\t\t\t\tret = kernel_sync_unlink(\n\t\t\t\t\t(int) sysboard[coreid].arg0\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_sync_close:\n\t\t\t\tret = kernel_sync_close(\n\t\t\t\t\t(int) sysboard[coreid].arg0\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_sync_signal:\n\t\t\t\tret = kernel_sync_signal(\n\t\t\t\t\t(int) sysboard[coreid].arg0\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_sync_ioctl:\n\t\t\t\tret = kernel_sync_ioctl(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(unsigned) sysboard[coreid].arg1,\n\t\t\t\t\t(va_list *) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n#endif /* __TARGET_HAS_SYNC */\n\n#if __TARGET_HAS_MAILBOX\n\t\t\tcase NR_mailbox_create:\n\t\t\t\tret = kernel_mailbox_create(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(int) sysboard[coreid].arg1\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_mailbox_open:\n\t\t\t\tret = kernel_mailbox_open(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(int) sysboard[coreid].arg1\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_mailbox_unlink:\n\t\t\t\tret = kernel_mailbox_unlink(\n\t\t\t\t\t(int) sysboard[coreid].arg0\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_mailbox_close:\n\t\t\t\tret = kernel_mailbox_close(\n\t\t\t\t\t(int) sysboard[coreid].arg0\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_mailbox_aread:\n\t\t\t\tret = kernel_mailbox_aread(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(void *)(long) sysboard[coreid].arg1,\n\t\t\t\t\t(size_t) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_mailbox_awrite:\n\t\t\t\tret = kernel_mailbox_awrite(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(const void *)(long) sysboard[coreid].arg1,\n\t\t\t\t\t(size_t) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_mailbox_ioctl:\n\t\t\t\tret = kernel_mailbox_ioctl(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(unsigned) sysboard[coreid].arg1,\n\t\t\t\t\t(va_list *) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n#endif /* __TARGET_HAS_MAILBOX */\n\n#if __TARGET_HAS_PORTAL\n\t\t\tcase NR_portal_create:\n\t\t\t\tret = kernel_portal_create(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(int) sysboard[coreid].arg1\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_portal_allow:\n\t\t\t\tret = kernel_portal_allow(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(int) sysboard[coreid].arg1,\n\t\t\t\t\t(int) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_portal_open:\n\t\t\t\tret = kernel_portal_open(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(int) sysboard[coreid].arg1,\n\t\t\t\t\t(int) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_portal_unlink:\n\t\t\t\tret = kernel_portal_unlink(\n\t\t\t\t\t(int) sysboard[coreid].arg0\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_portal_close:\n\t\t\t\tret = kernel_portal_close(\n\t\t\t\t\t(int) sysboard[coreid].arg0\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_portal_aread:\n\t\t\t\tret = kernel_portal_aread(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(void *)(long) sysboard[coreid].arg1,\n\t\t\t\t\t(size_t) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_portal_awrite:\n\t\t\t\tret = kernel_portal_awrite(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(const void *)(long) sysboard[coreid].arg1,\n\t\t\t\t\t(size_t) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase NR_portal_ioctl:\n\t\t\t\tret = kernel_portal_ioctl(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(unsigned) sysboard[coreid].arg1,\n\t\t\t\t\t(va_list *) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n#endif /* __TARGET_HAS_PORTAL */\n\n\t\tcase NR_stats:\n\t\t\tkernel_stats(\n\t\t\t\t(uint64_t *) sysboard[coreid].arg0,\n\t\t\t\t(int) sysboard[coreid].arg1\n\t\t\t);\n\t\t\tbreak;\n\n\t\tcase NR_frame_alloc:\n\t\t\tret = kernel_frame_alloc();\n\t\t\tbreak;\n\n\t\tcase NR_frame_free:\n\t\t\tret = kernel_frame_free(\n\t\t\t\t(vaddr_t) sysboard[coreid].arg0\n\t\t\t);\n\t\t\tbreak;\n\n\t\tcase NR_upage_alloc:\n\t\t\tret = kernel_upage_alloc(\n\t\t\t\t(vaddr_t) sysboard[coreid].arg0\n\t\t\t);\n\t\t\tbreak;\n\n\t\tcase NR_upage_free:\n\t\t\tret = kernel_upage_free(\n\t\t\t\t(vaddr_t) sysboard[coreid].arg0\n\t\t\t);\n\t\t\tbreak;\n\n\t\tcase NR_upage_map:\n\t\t\tret = kernel_upage_map(\n\t\t\t\t(vaddr_t) sysboard[coreid].arg0,\n\t\t\t\t(frame_t) sysboard[coreid].arg1\n\t\t\t);\n\t\t\tbreak;\n\n\t\tcase NR_upage_unmap:\n\t\t\tret = kernel_upage_unmap(\n\t\t\t\t(vaddr_t) sysboard[coreid].arg0\n\t\t\t);\n\t\t\tbreak;\n\n\t\tcase NR_upage_link:\n\t\t\tret = kernel_upage_link(\n\t\t\t\t(vaddr_t) sysboard[coreid].arg0,\n\t\t\t\t(vaddr_t) sysboard[coreid].arg1\n\t\t\t);\n\t\t\tbreak;\n\n#if (THREAD_MAX > 1)\n\n\t\tcase NR_excp_ctrl:\n\t\t\tret = kernel_excp_ctrl(\n\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t(int) sysboard[coreid].arg1\n\t\t\t);\n\t\t\tbreak;\n\n\t\tcase NR_excp_resume:\n\t\t\tret = kernel_excp_resume();\n\t\t\tbreak;\n\n#endif\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\tout:\n\n\t\tsysboard[coreid].pending = 0;\n\t\tsysboard[coreid].ret = ret;\n\n\tsemaphore_up(&sysboard[coreid].syssem);\n}", "item_id": 1, "repo": "nanvix/microkernel", "file": "src/kernel/sys/syscalls.c", "last_update_at": "2022-03-23T10:07:06+00:00", "question_id": "37be5fc44c8bc4e6074c8e135b50c33776935c9e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["PUBLIC void do_kcall2(void)\n{\n\tint coreid = 0;\n\tint ret = -ENOSYS;\n\tsemaphore_down(&syssem);\n\t\t/* Sweeps the cores in a circular fashion. */\n\t\tfor (int i = 0; i < CORES_NUM; i++)\n\t\t{\n\t\t\tif (sysboard[sys_next_coreid].pending)\n\t\t\t{\n\t\t\t\tcoreid = sys_next_coreid;\n\t\t\t\tsys_next_coreid = (sys_next_coreid + 1) % CORES_NUM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsys_next_coreid = (sys_next_coreid + 1) % CORES_NUM;\n\t\t}\n\t\t/* Invalid system call number. */\n\t\tif (sysboard[coreid].syscall_nr >= NR_SYSCALLS)\n\t\t{\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Parse system call number. */\n\t\tswitch (sysboard[coreid].syscall_nr)\n\t\t{\n\t\t\tcase NR_shutdown:\n\t\t\t\tret = kernel_shutdown();\n\t\t\t\tbreak;\n\t\t\tcase NR__exit:\n\t\t\t\tkernel_exit((int)(long) sysboard[coreid].arg0);\n\t\t\t\tbreak;\n\t\t\tcase NR_write:\n\t\t\t\tret = kernel_write(\n\t\t\t\t\t(int)(long) sysboard[coreid].arg0,\n\t\t\t\t\t(const char *)(long) sysboard[coreid].arg1,\n\t\t\t\t\t(size_t)(long) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n#if (THREAD_MAX > 1)\n\t\t\tcase NR_thread_create:\n\t\t\t\tret = kernel_thread_create(\n\t\t\t\t\t(int *)(long) sysboard[coreid].arg0,\n\t\t\t\t\t(void *(*)(void *))(long) sysboard[coreid].arg1,\n\t\t\t\t\t(void *)(long) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_wakeup:\n\t\t\t\tret = kernel_wakeup(\n\t\t\t\t\t(int)(long) sysboard[coreid].arg0\n\t\t\t\t);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase NR_sigctl:\n\t\t\t\tret = kernel_sigctl(\n\t\t\t\t\t(int)(long) sysboard[coreid].arg0,\n\t\t\t\t\t(struct ksigaction *)(long) sysboard[coreid].arg1\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_node_get_num:\n\t\t\t\tret = kernel_node_get_num();\n\t\t\t\tbreak;\n\t\t\tcase NR_cluster_get_num:\n\t\t\t\tret = kernel_cluster_get_num();\n\t\t\t\tbreak;\n#if __TARGET_HAS_SYNC\n\t\t\tcase NR_sync_create:\n\t\t\t\tret = kernel_sync_create(\n\t\t\t\t\t(const int *)(long) sysboard[coreid].arg0,\n\t\t\t\t\t(int) sysboard[coreid].arg1,\n\t\t\t\t\t(int) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_sync_open:\n\t\t\t\tret = kernel_sync_open(\n\t\t\t\t\t(const int *)(long) sysboard[coreid].arg0,\n\t\t\t\t\t(int) sysboard[coreid].arg1,\n\t\t\t\t\t(int) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_sync_unlink:\n\t\t\t\tret = kernel_sync_unlink(\n\t\t\t\t\t(int) sysboard[coreid].arg0\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_sync_close:\n\t\t\t\tret = kernel_sync_close(\n\t\t\t\t\t(int) sysboard[coreid].arg0\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_sync_signal:\n\t\t\t\tret = kernel_sync_signal(\n\t\t\t\t\t(int) sysboard[coreid].arg0\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_sync_ioctl:\n\t\t\t\tret = kernel_sync_ioctl(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(unsigned) sysboard[coreid].arg1,\n\t\t\t\t\t(va_list *) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n#endif /* __TARGET_HAS_SYNC */\n#if __TARGET_HAS_MAILBOX\n\t\t\tcase NR_mailbox_create:\n\t\t\t\tret = kernel_mailbox_create(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(int) sysboard[coreid].arg1\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_mailbox_open:\n\t\t\t\tret = kernel_mailbox_open(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(int) sysboard[coreid].arg1\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_mailbox_unlink:\n\t\t\t\tret = kernel_mailbox_unlink(\n\t\t\t\t\t(int) sysboard[coreid].arg0\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_mailbox_close:\n\t\t\t\tret = kernel_mailbox_close(\n\t\t\t\t\t(int) sysboard[coreid].arg0\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_mailbox_aread:\n\t\t\t\tret = kernel_mailbox_aread(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(void *)(long) sysboard[coreid].arg1,\n\t\t\t\t\t(size_t) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_mailbox_awrite:\n\t\t\t\tret = kernel_mailbox_awrite(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(const void *)(long) sysboard[coreid].arg1,\n\t\t\t\t\t(size_t) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_mailbox_ioctl:\n\t\t\t\tret = kernel_mailbox_ioctl(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(unsigned) sysboard[coreid].arg1,\n\t\t\t\t\t(va_list *) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n#endif /* __TARGET_HAS_MAILBOX */\n#if __TARGET_HAS_PORTAL\n\t\t\tcase NR_portal_create:\n\t\t\t\tret = kernel_portal_create(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(int) sysboard[coreid].arg1\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_portal_allow:\n\t\t\t\tret = kernel_portal_allow(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(int) sysboard[coreid].arg1,\n\t\t\t\t\t(int) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_portal_open:\n\t\t\t\tret = kernel_portal_open(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(int) sysboard[coreid].arg1,\n\t\t\t\t\t(int) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_portal_unlink:\n\t\t\t\tret = kernel_portal_unlink(\n\t\t\t\t\t(int) sysboard[coreid].arg0\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_portal_close:\n\t\t\t\tret = kernel_portal_close(\n\t\t\t\t\t(int) sysboard[coreid].arg0\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_portal_aread:\n\t\t\t\tret = kernel_portal_aread(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(void *)(long) sysboard[coreid].arg1,\n\t\t\t\t\t(size_t) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_portal_awrite:\n\t\t\t\tret = kernel_portal_awrite(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(const void *)(long) sysboard[coreid].arg1,\n\t\t\t\t\t(size_t) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase NR_portal_ioctl:\n\t\t\t\tret = kernel_portal_ioctl(\n\t\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t\t(unsigned) sysboard[coreid].arg1,\n\t\t\t\t\t(va_list *) sysboard[coreid].arg2\n\t\t\t\t);\n\t\t\t\tbreak;\n#endif /* __TARGET_HAS_PORTAL */\n\t\tcase NR_stats:\n\t\t\tkernel_stats(\n\t\t\t\t(uint64_t *) sysboard[coreid].arg0,\n\t\t\t\t(int) sysboard[coreid].arg1\n\t\t\t);\n\t\t\tbreak;\n\t\tcase NR_frame_alloc:\n\t\t\tret = kernel_frame_alloc();\n\t\t\tbreak;\n\t\tcase NR_frame_free:\n\t\t\tret = kernel_frame_free(\n\t\t\t\t(vaddr_t) sysboard[coreid].arg0\n\t\t\t);\n\t\t\tbreak;\n\t\tcase NR_upage_alloc:\n\t\t\tret = kernel_upage_alloc(\n\t\t\t\t(vaddr_t) sysboard[coreid].arg0\n\t\t\t);\n\t\t\tbreak;\n\t\tcase NR_upage_free:\n\t\t\tret = kernel_upage_free(\n\t\t\t\t(vaddr_t) sysboard[coreid].arg0\n\t\t\t);\n\t\t\tbreak;\n\t\tcase NR_upage_map:\n\t\t\tret = kernel_upage_map(\n\t\t\t\t(vaddr_t) sysboard[coreid].arg0,\n\t\t\t\t(frame_t) sysboard[coreid].arg1\n\t\t\t);\n\t\t\tbreak;\n\t\tcase NR_upage_unmap:\n\t\t\tret = kernel_upage_unmap(\n\t\t\t\t(vaddr_t) sysboard[coreid].arg0\n\t\t\t);\n\t\t\tbreak;\n\t\tcase NR_upage_link:\n\t\t\tret = kernel_upage_link(\n\t\t\t\t(vaddr_t) sysboard[coreid].arg0,\n\t\t\t\t(vaddr_t) sysboard[coreid].arg1\n\t\t\t);\n\t\t\tbreak;\n#if (THREAD_MAX > 1)\n\t\tcase NR_excp_ctrl:\n\t\t\tret = kernel_excp_ctrl(\n\t\t\t\t(int) sysboard[coreid].arg0,\n\t\t\t\t(int) sysboard[coreid].arg1\n\t\t\t);\n\t\t\tbreak;\n\t\tcase NR_excp_resume:\n\t\t\tret = kernel_excp_resume();\n\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\tout:\n\t\tsysboard[coreid].pending = 0;\n\t\tsysboard[coreid].ret = ret;\n\tsemaphore_up(&sysboard[coreid].syssem);\n"]]}
{"hexsha": "004c42274e48705a997822a46e743ce9087f7b91", "ext": "c", "lang": "C", "content": "static struct mlxsw_sp_fid *mlxsw_sp_fid_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\tenum mlxsw_sp_fid_type type,\n\t\t\t\t\t\tconst void *arg)\n{\n\tstruct mlxsw_sp_fid_family *fid_family;\n\tstruct mlxsw_sp_fid *fid;\n\n\tfid_family = mlxsw_sp->fid_core->fid_family_arr[type];\n\tlist_for_each_entry(fid, &fid_family->fids_list, list) {\n\t\tif (!fid->fid_family->ops->compare(fid, arg))\n\t\t\tcontinue;\n\t\trefcount_inc(&fid->ref_count);\n\t\treturn fid;\n\t}\n\n\treturn NULL;\n}", "item_id": 24, "repo": "jainsakshi2395/linux", "file": "drivers/net/ethernet/mellanox/mlxsw/spectrum_fid.c", "last_update_at": "2022-03-01T02:26:21+00:00", "question_id": "004c42274e48705a997822a46e743ce9087f7b91_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct mlxsw_sp_fid *mlxsw_sp_fid_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\tenum mlxsw_sp_fid_type type,\n\t\t\t\t\t\tconst void *arg)\n{\n\tstruct mlxsw_sp_fid_family *fid_family;\n\tstruct mlxsw_sp_fid *fid;\n\tfid_family = mlxsw_sp->fid_core->fid_family_arr[type];\n\tlist_for_each_entry(fid, &fid_family->fids_list, list) {\n\t\tif (!fid->fid_family->ops->compare(fid, arg))\n\t\t\tcontinue;\n\t\trefcount_inc(&fid->ref_count);\n\t\treturn fid;\n\t}\n\treturn NULL;\n"]]}
{"hexsha": "75bb0e1f4f78fa338d3d57bdd7f9a074ff9f32a4", "ext": "c", "lang": "C", "content": "static inline __attribute__((always_inline))\nvoid core_enqueue_to_q_spent(struct seq_admission_core_state *core,\n\t\tstruct fp_ring *queue_spent, struct fp_mempool *bin_mempool,\n\t\tuint16_t src, uint16_t dst, uint32_t metric)\n{\n\t/* add to status->new_demands */\n\tenqueue_bin(core->spent_bin, src, dst, 0, metric);\n\n\tif (unlikely(bin_size(core->spent_bin) == SMALL_BIN_SIZE)) {\n\t\tadm_log_q_spent_flush_bin_full(&core->stat);\n\t\tcore_flush_q_spent(core, queue_spent, bin_mempool);\n\t}\n}", "item_id": 1, "repo": "yonch/fastpass", "file": "src/graph-algo/admissible_traffic.c", "last_update_at": "2022-01-25T03:05:56+00:00", "question_id": "75bb0e1f4f78fa338d3d57bdd7f9a074ff9f32a4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline __attribute__((always_inline))\nvoid core_enqueue_to_q_spent(struct seq_admission_core_state *core,\n\t\tstruct fp_ring *queue_spent, struct fp_mempool *bin_mempool,\n\t\tuint16_t src, uint16_t dst, uint32_t metric)\n{\n\t/* add to status->new_demands */\n\tenqueue_bin(core->spent_bin, src, dst, 0, metric);\n\tif (unlikely(bin_size(core->spent_bin) == SMALL_BIN_SIZE)) {\n\t\tadm_log_q_spent_flush_bin_full(&core->stat);\n\t\tcore_flush_q_spent(core, queue_spent, bin_mempool);\n\t}\n"]]}
{"hexsha": "9e3f455c80da14c39e378d8b8ba9eea241191ecd", "ext": "h", "lang": "C", "content": "const char *repeatTypeName(u8 type) {\n    switch ((enum RepeatType)type) {\n    case REPEAT_RING:\n        return \"RING\";\n    case REPEAT_FIRST:\n        return \"FIRST\";\n    case REPEAT_LAST:\n        return \"LAST\";\n    case REPEAT_RANGE:\n        return \"RANGE\";\n    case REPEAT_BITMAP:\n        return \"BITMAP\";\n    case REPEAT_SPARSE_OPTIMAL_P:\n        return \"SPARSE_OPTIMAL_P\";\n    case REPEAT_TRAILER:\n        return \"TRAILER\";\n    case REPEAT_ALWAYS:\n        return \"ALWAYS\";\n    }\n    assert(0);\n    return \"UNKNOWN\";\n}", "item_id": 0, "repo": "jtravee/neuvector", "file": "dp/third-party/hyperscan/src/nfa/repeat_internal.h", "last_update_at": "2022-03-31T23:24:16+00:00", "question_id": "9e3f455c80da14c39e378d8b8ba9eea241191ecd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const char *repeatTypeName(u8 type) {\n    switch ((enum RepeatType)type) {\n    case REPEAT_RING:\n        return \"RING\";\n    case REPEAT_FIRST:\n        return \"FIRST\";\n    case REPEAT_LAST:\n        return \"LAST\";\n    case REPEAT_RANGE:\n        return \"RANGE\";\n    case REPEAT_BITMAP:\n        return \"BITMAP\";\n    case REPEAT_SPARSE_OPTIMAL_P:\n        return \"SPARSE_OPTIMAL_P\";\n    case REPEAT_TRAILER:\n        return \"TRAILER\";\n    case REPEAT_ALWAYS:\n        return \"ALWAYS\";\n    }\n    assert(0);\n    return \"UNKNOWN\";\n"]]}
{"hexsha": "48e848931811ca7acb55a0fa8e086dc14fb2c89d", "ext": "c", "lang": "C", "content": "ACPI_STATUS\nAcpiOsEnterSleep(\n    UINT8                   SleepState,\n    UINT32                  RegaValue,\n    UINT32                  RegbValue)\n{\n   ACPI_FUNCTION_TRACE(__FUNC__);\n   printk(\"ACPI sleep: %u, 0x%x, 0x%x\\n\", SleepState, RegaValue, RegaValue);\n   return_ACPI_STATUS(AE_OK);\n}", "item_id": 3, "repo": "CyberFlameGO/tilck", "file": "modules/acpi/osl_misc.c", "last_update_at": "2022-03-30T19:54:49+00:00", "question_id": "48e848931811ca7acb55a0fa8e086dc14fb2c89d_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ACPI_STATUS\nAcpiOsEnterSleep(\n    UINT8                   SleepState,\n    UINT32                  RegaValue,\n    UINT32                  RegbValue)\n{\n   ACPI_FUNCTION_TRACE(__FUNC__);\n   printk(\"ACPI sleep: %u, 0x%x, 0x%x\\n\", SleepState, RegaValue, RegaValue);\n   return_ACPI_STATUS(AE_OK);\n"]]}
{"hexsha": "3a4fc751018ab55c16c07b9fd757022fd64eabc8", "ext": "c", "lang": "C", "content": "static void event_net_change(void *arg)\n{\n\tsys_mqtt_t *s = arg;\n\n\tif (a_network_is_up()) {\n\t\tif (s->mqtt_connected) {\n\t\t\ts->mqtt_connected = WICED_FALSE;\n\t\t\tmqtt_app_close(s);\n\t\t}\n\n\t\tif (mqtt_app_open(s) == WICED_SUCCESS) {\n\t\t\ts->mqtt_connected = WICED_TRUE;\n\t\t} else {\n\t\t\tuint32_t tout = MQTT_RECONNECT_TIMEOUT +\n\t\t\t\t((uint32_t)rand() % MQTT_RECONNECT_RANDOM_WINDOW);\n\t\t\twiced_log_msg(WLF_DEF, WICED_LOG_INFO, \"Retry after %d ms\\n\", tout);\n\t\t\ta_eventloop_register_timer(s->evt, &s->retry_timer_node,\n\t\t\t\t\t\t   mqtt_retry_cb, tout, s);\n\t\t}\n\t} else {\n\t\ta_eventloop_deregister_timer(s->evt, &s->retry_timer_node);\n\t\tif (s->mqtt_connected) {\n\t\t\ts->mqtt_connected = WICED_FALSE;\n\t\t\tmqtt_app_close(s);\n\t\t}\n\t}\n\n\tif (s->net_event_cb)\n\t\t(*s->net_event_cb)(a_network_is_up(), s->mqtt_connected, s->arg);\n}", "item_id": 7, "repo": "humminglab/wiced-eventloop", "file": "common/sys_mqtt.c", "last_update_at": "2022-01-11T10:46:19+00:00", "question_id": "3a4fc751018ab55c16c07b9fd757022fd64eabc8_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void event_net_change(void *arg)\n{\n\tsys_mqtt_t *s = arg;\n\tif (a_network_is_up()) {\n\t\tif (s->mqtt_connected) {\n\t\t\ts->mqtt_connected = WICED_FALSE;\n\t\t\tmqtt_app_close(s);\n\t\t}\n\t\tif (mqtt_app_open(s) == WICED_SUCCESS) {\n\t\t\ts->mqtt_connected = WICED_TRUE;\n\t\t} else {\n\t\t\tuint32_t tout = MQTT_RECONNECT_TIMEOUT +\n\t\t\t\t((uint32_t)rand() % MQTT_RECONNECT_RANDOM_WINDOW);\n\t\t\twiced_log_msg(WLF_DEF, WICED_LOG_INFO, \"Retry after %d ms\\n\", tout);\n\t\t\ta_eventloop_register_timer(s->evt, &s->retry_timer_node,\n\t\t\t\t\t\t   mqtt_retry_cb, tout, s);\n\t\t}\n\t} else {\n\t\ta_eventloop_deregister_timer(s->evt, &s->retry_timer_node);\n\t\tif (s->mqtt_connected) {\n\t\t\ts->mqtt_connected = WICED_FALSE;\n\t\t\tmqtt_app_close(s);\n\t\t}\n\t}\n\tif (s->net_event_cb)\n\t\t(*s->net_event_cb)(a_network_is_up(), s->mqtt_connected, s->arg);\n"]]}
{"hexsha": "8254d2c68cc5daced7f7051d75c33a44571915ed", "ext": "c", "lang": "C", "content": "static void c3dhall5_i2c_write ( c3dhall5_t *ctx, uint8_t reg, uint8_t *data_buf, uint8_t len )\n{\n   uint8_t tx_buf[ 256 ];\n    uint8_t cnt;\n    \n    tx_buf[ 0 ] = reg;\n\n    for ( cnt = 1; cnt <= len; cnt++ )\n    {\n        tx_buf[ cnt ] = data_buf[ cnt - 1 ]; \n    }\n\n    i2c_master_write( &ctx->i2c, tx_buf, len + 1 ); \n}", "item_id": 7, "repo": "StrahinjaJacimovic/mikrosdk_click_v2", "file": "clicks/3dhall5/lib/src/c3dhall5.c", "last_update_at": "2022-03-24T08:33:21+00:00", "question_id": "8254d2c68cc5daced7f7051d75c33a44571915ed_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void c3dhall5_i2c_write ( c3dhall5_t *ctx, uint8_t reg, uint8_t *data_buf, uint8_t len )\n{\n   uint8_t tx_buf[ 256 ];\n    uint8_t cnt;\n    tx_buf[ 0 ] = reg;\n    for ( cnt = 1; cnt <= len; cnt++ )\n    {\n        tx_buf[ cnt ] = data_buf[ cnt - 1 ]; \n    }\n    i2c_master_write( &ctx->i2c, tx_buf, len + 1 ); \n"]]}
{"hexsha": "8c6ca9bc2d19477669e05c93f4293cd134420f9a", "ext": "c", "lang": "C", "content": "static int countTombStones(HashTable* pHashTable)\n{\n    int i, count;\n\n    for (count = i = 0; i < pHashTable->tableSize; i++) {\n        if (pHashTable->pEntries[i].data == HASH_TOMBSTONE)\n            count++;\n    }\n    return count;\n}", "item_id": 4, "repo": "thenameisnigel/miui_recovery", "file": "minzip/Hash.c", "last_update_at": "2022-02-22T14:01:28+00:00", "question_id": "8c6ca9bc2d19477669e05c93f4293cd134420f9a_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int countTombStones(HashTable* pHashTable)\n{\n    int i, count;\n    for (count = i = 0; i < pHashTable->tableSize; i++) {\n        if (pHashTable->pEntries[i].data == HASH_TOMBSTONE)\n            count++;\n    }\n    return count;\n"]]}
{"hexsha": "8d543266af504d97e999e1e9a57dda0e4ea9581a", "ext": "c", "lang": "C", "content": "int wfaSetEncryptionZeroConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)\r\n{\r\n\tcaStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;\r\n\tdutCmdResponse_t *setEncrypResp = &wfaDutAgentData.gGenericResp;\r\n\r\n\tFILE *file,*tmpfd;\r\n\tchar string[256],Interfacename[64], pfile[128], intfile[128];\r\n\r\n\tDPRINT_INFOL(WFA_OUT, \"Entering wfaSetEncryptionZeroConfig ...\\n\"); \r\n\r\n\tsprintf(pfile, \"%s\\\\Temp\\\\tmp.xml\", wtsPath);\r\n\tsprintf(wfaDutAgentData.gCmdStr, \"del /F /Q %s\", pfile);\r\n\tDPRINT_INFOL(WFA_OUT, \"RUN-> %s\\n\", wfaDutAgentData.gCmdStr);\r\n\tsystem(wfaDutAgentData.gCmdStr);\r\n\r\n\tfile = fopen(pfile, \"w+\");\r\n\tif(file==NULL) \r\n\t{\r\n\t\tDPRINT_ERR(WFA_ERR, \"Error: can't create file.\\n\");\r\n\t\tsetEncrypResp->status = STATUS_ERROR;\r\n\t\twfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);\r\n\t\t*respLen = WFA_TLV_HDR_LEN + 4;\r\n\r\n\t\treturn WFA_FAILURE;\r\n\t}\r\n\telse \r\n\t{\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"<?xml version=\\\"1.0\\\"?>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"<WLANProfile xmlns=\\\"http://www.microsoft.com/networking/WLAN/profile/v1\\\">\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t<name>%s</name>\\n\",setEncryp->ssid);\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t<SSIDConfig>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t<SSID>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t<name>%s</name>\\n\",setEncryp->ssid);\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t</SSID>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t</SSIDConfig>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t<connectionType>ESS</connectionType>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t<connectionMode>auto</connectionMode>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t<autoSwitch>true</autoSwitch>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t<MSM>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t<security>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t<authEncryption>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t<authentication>open</authentication>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\r\n\t\tif(setEncryp->encpType == 1)\r\n\t\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t<encryption>WEP</encryption>\\n\");\r\n\t\telse\r\n\t\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t<encryption>none</encryption>\\n\");\r\n\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t <useOneX>false</useOneX>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t</authEncryption>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\r\n\t\tif(setEncryp->encpType == 1)\r\n\t\t{\r\n\t\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t\\t<sharedKey>\\n\");\r\n\t\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t\\t\\t<keyType>networkKey</keyType>\\n\");\r\n\t\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t\\t\\t<protected>false</protected>\\n\");\r\n\t\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t\\t\\t<keyMaterial>%s</keyMaterial>\\n\",setEncryp->keys[0]);\r\n\t\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t\\t</sharedKey>\\n\");\r\n\t\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\t}\r\n\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t</security>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t</MSM>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"</WLANProfile>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t}\r\n\tfclose(file);\r\n\r\n\tsprintf(intfile, \"%s\\\\WfaEndpoint\\\\Interface.txt\", wtsPath);\r\n\ttmpfd = fopen(intfile, \"r\");\r\n\tif(tmpfd == NULL)\r\n\t{\r\n\t\tDPRINT_ERR(WFA_ERR, \"Error opening the interface file \\n\");\r\n\t\tsetEncrypResp->status = STATUS_ERROR;\r\n\t\twfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);\r\n\t\t*respLen = WFA_TLV_HDR_LEN + 4;\r\n\r\n\t\treturn WFA_FAILURE;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfor(;;)\r\n\t\t{\r\n\t\t\tif(fgets(string, 256, tmpfd) == NULL)\r\n\t\t\t\tbreak; \r\n\t\t}\r\n\t\tfclose(tmpfd);\r\n\r\n\t\tif(strncmp(string, \"IFNAME\", 6) == 0)\r\n\t\t{\r\n\t\t\tchar *str;\r\n\t\t\tstr = strtok(string, \"\\\"\");\r\n\t\t\tstr = strtok(NULL, \"\\\"\");\r\n\t\t\tif(str != NULL)\r\n\t\t\t{\r\n\t\t\t\tstrcpy(&Interfacename[0],str);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tsprintf(wfaDutAgentData.gCmdStr, \"netsh wlan add profile filename=\\\"%s\\\" interface=\\\"%s\\\" user=all\", pfile,&Interfacename[0]);\r\n\r\n\tDPRINT_INFOL(WFA_OUT, \"RUN-> %s\\n\", wfaDutAgentData.gCmdStr);\r\n\tsystem(wfaDutAgentData.gCmdStr);\r\n\r\n\tsetEncrypResp->status = STATUS_COMPLETE;\r\n\twfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);\r\n\t*respLen = WFA_TLV_HDR_LEN + 4;\r\n\r\n\tDPRINT_INFOL(WFA_OUT, \"Completing ...\\n\");\r\n\treturn WFA_SUCCESS;\r\n}", "item_id": 9, "repo": "ASHASKEY/WFTS", "file": "win_lib/wfa_cs.c", "last_update_at": "2022-02-18T09:25:20+00:00", "question_id": "8d543266af504d97e999e1e9a57dda0e4ea9581a_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int wfaSetEncryptionZeroConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)\r\n{\r\n\tcaStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;\r\n\tdutCmdResponse_t *setEncrypResp = &wfaDutAgentData.gGenericResp;\r\n\r\n\tFILE *file,*tmpfd;\r\n\tchar string[256],Interfacename[64], pfile[128], intfile[128];\r\n\r\n\tDPRINT_INFOL(WFA_OUT, \"Entering wfaSetEncryptionZeroConfig ...\\n\"); \r\n\r\n\tsprintf(pfile, \"%s\\\\Temp\\\\tmp.xml\", wtsPath);\r\n\tsprintf(wfaDutAgentData.gCmdStr, \"del /F /Q %s\", pfile);\r\n\tDPRINT_INFOL(WFA_OUT, \"RUN-> %s\\n\", wfaDutAgentData.gCmdStr);\r\n\tsystem(wfaDutAgentData.gCmdStr);\r\n\r\n\tfile = fopen(pfile, \"w+\");\r\n\tif(file==NULL) \r\n\t{\r\n\t\tDPRINT_ERR(WFA_ERR, \"Error: can't create file.\\n\");\r\n\t\tsetEncrypResp->status = STATUS_ERROR;\r\n\t\twfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);\r\n\t\t*respLen = WFA_TLV_HDR_LEN + 4;\r\n\r\n\t\treturn WFA_FAILURE;\r\n\t}\r\n\telse \r\n\t{\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"<?xml version=\\\"1.0\\\"?>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"<WLANProfile xmlns=\\\"http://www.microsoft.com/networking/WLAN/profile/v1\\\">\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t<name>%s</name>\\n\",setEncryp->ssid);\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t<SSIDConfig>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t<SSID>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t<name>%s</name>\\n\",setEncryp->ssid);\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t</SSID>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t</SSIDConfig>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t<connectionType>ESS</connectionType>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t<connectionMode>auto</connectionMode>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t<autoSwitch>true</autoSwitch>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t<MSM>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t<security>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t<authEncryption>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t<authentication>open</authentication>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\r\n\t\tif(setEncryp->encpType == 1)\r\n\t\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t<encryption>WEP</encryption>\\n\");\r\n\t\telse\r\n\t\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t<encryption>none</encryption>\\n\");\r\n\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t <useOneX>false</useOneX>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t</authEncryption>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\r\n\t\tif(setEncryp->encpType == 1)\r\n\t\t{\r\n\t\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t\\t<sharedKey>\\n\");\r\n\t\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t\\t\\t<keyType>networkKey</keyType>\\n\");\r\n\t\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t\\t\\t<protected>false</protected>\\n\");\r\n\t\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t\\t\\t<keyMaterial>%s</keyMaterial>\\n\",setEncryp->keys[0]);\r\n\t\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t\\t\\t</sharedKey>\\n\");\r\n\t\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\t}\r\n\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t\\t</security>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"\\t</MSM>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t\tsprintf(wfaDutAgentData.gCmdStr,\"</WLANProfile>\\n\");\r\n\t\tfputs(wfaDutAgentData.gCmdStr, file);\r\n\t}\r\n\tfclose(file);\r\n\r\n\tsprintf(intfile, \"%s\\\\WfaEndpoint\\\\Interface.txt\", wtsPath);\r\n\ttmpfd = fopen(intfile, \"r\");\r\n\tif(tmpfd == NULL)\r\n\t{\r\n\t\tDPRINT_ERR(WFA_ERR, \"Error opening the interface file \\n\");\r\n\t\tsetEncrypResp->status = STATUS_ERROR;\r\n\t\twfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);\r\n\t\t*respLen = WFA_TLV_HDR_LEN + 4;\r\n\r\n\t\treturn WFA_FAILURE;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfor(;;)\r\n\t\t{\r\n\t\t\tif(fgets(string, 256, tmpfd) == NULL)\r\n\t\t\t\tbreak; \r\n\t\t}\r\n\t\tfclose(tmpfd);\r\n\r\n\t\tif(strncmp(string, \"IFNAME\", 6) == 0)\r\n\t\t{\r\n\t\t\tchar *str;\r\n\t\t\tstr = strtok(string, \"\\\"\");\r\n\t\t\tstr = strtok(NULL, \"\\\"\");\r\n\t\t\tif(str != NULL)\r\n\t\t\t{\r\n\t\t\t\tstrcpy(&Interfacename[0],str);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tsprintf(wfaDutAgentData.gCmdStr, \"netsh wlan add profile filename=\\\"%s\\\" interface=\\\"%s\\\" user=all\", pfile,&Interfacename[0]);\r\n\r\n\tDPRINT_INFOL(WFA_OUT, \"RUN-> %s\\n\", wfaDutAgentData.gCmdStr);\r\n\tsystem(wfaDutAgentData.gCmdStr);\r\n\r\n\tsetEncrypResp->status = STATUS_COMPLETE;\r\n\twfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);\r\n\t*respLen = WFA_TLV_HDR_LEN + 4;\r\n\r\n\tDPRINT_INFOL(WFA_OUT, \"Completing ...\\n\");\r\n\treturn WFA_SUCCESS;\r\n"]]}
{"hexsha": "63cd605b6abd6f155280daca22791bafd53a1cfb", "ext": "c", "lang": "C", "content": "int board_phy_config(struct phy_device *phydev)\n{\n\tphy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);\n\tphy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);\n\n\tphy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);\n\tphy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);\n\n\tif (phydev->drv->config)\n\t\tphydev->drv->config(phydev);\n\n\treturn 0;\n}", "item_id": 2, "repo": "openharmony-gitee-mirror/device_bearpi_bearpi_hm_nano", "file": "sdk_liteos/third_party/u-boot-v2019.07/u-boot-v2019.07/board/freescale/imx8qxp_mek/imx8qxp_mek.c", "last_update_at": "2022-02-15T08:51:55+00:00", "question_id": "63cd605b6abd6f155280daca22791bafd53a1cfb_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int board_phy_config(struct phy_device *phydev)\n{\n\tphy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);\n\tphy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);\n\tphy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);\n\tphy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);\n\tif (phydev->drv->config)\n\t\tphydev->drv->config(phydev);\n\treturn 0;\n"]]}
{"hexsha": "f61df6f906d47708ec40ee63fea897f3952f8d9c", "ext": "c", "lang": "C", "content": "void BIG_384_29_fromBytesLen(BIG_384_29 a, char *b, int s)\n{\n    int i, len = s;\n    BIG_384_29_zero(a);\n\n    if (len > MODBYTES_384_29) len = MODBYTES_384_29;\n    for (i = 0; i < len; i++)\n    {\n        BIG_384_29_fshl(a, 8);\n        a[0] += (int)(unsigned char)b[i];\n    }\n#ifdef DEBUG_NORM\n    a[MPV_384_29] = 1;\n    a[MNV_384_29] = 0;\n#endif\n}", "item_id": 10, "repo": "asanso/nim-blscurve", "file": "blscurve/miracl/csources/32/big_384_29.c", "last_update_at": "2022-03-13T17:26:44+00:00", "question_id": "f61df6f906d47708ec40ee63fea897f3952f8d9c_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void BIG_384_29_fromBytesLen(BIG_384_29 a, char *b, int s)\n{\n    int i, len = s;\n    BIG_384_29_zero(a);\n    if (len > MODBYTES_384_29) len = MODBYTES_384_29;\n    for (i = 0; i < len; i++)\n    {\n        BIG_384_29_fshl(a, 8);\n        a[0] += (int)(unsigned char)b[i];\n    }\n#ifdef DEBUG_NORM\n    a[MPV_384_29] = 1;\n    a[MNV_384_29] = 0;\n#endif\n"]]}
{"hexsha": "a99e4d7e89c2eb3a1a38024b50f3c3d0ccdbfe4e", "ext": "c", "lang": "C", "content": "static void\ncheck_simple(struct sol_fbp_graph *g)\n{\n    struct sol_fbp_node *a, *b;\n\n    ASSERT_INT_EQ(g->nodes.len, 2);\n\n    a = find_node(g, \"a\");\n    ASSERT(a);\n\n    b = find_node(g, \"b\");\n    ASSERT(b);\n\n    ASSERT_INT_EQ(a->in_ports.len, 0);\n    ASSERT_INT_EQ(a->out_ports.len, 1);\n    ASSERT_INT_EQ(b->in_ports.len, 1);\n    ASSERT_INT_EQ(b->out_ports.len, 0);\n\n    ASSERT(find_out_port(a, \"OUT\"));\n    ASSERT(find_in_port(b, \"IN\"));\n\n    ASSERT_INT_EQ(g->conns.len, 1);\n\n    ASSERT(find_conn(g, \"a\", \"OUT\", \"IN\", \"b\"));\n}", "item_id": 8, "repo": "undeadinu/soletta", "file": "src/test/test-fbp.c", "last_update_at": "2022-03-27T20:45:17+00:00", "question_id": "a99e4d7e89c2eb3a1a38024b50f3c3d0ccdbfe4e_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\ncheck_simple(struct sol_fbp_graph *g)\n{\n    struct sol_fbp_node *a, *b;\n    ASSERT_INT_EQ(g->nodes.len, 2);\n    a = find_node(g, \"a\");\n    ASSERT(a);\n    b = find_node(g, \"b\");\n    ASSERT(b);\n    ASSERT_INT_EQ(a->in_ports.len, 0);\n    ASSERT_INT_EQ(a->out_ports.len, 1);\n    ASSERT_INT_EQ(b->in_ports.len, 1);\n    ASSERT_INT_EQ(b->out_ports.len, 0);\n    ASSERT(find_out_port(a, \"OUT\"));\n    ASSERT(find_in_port(b, \"IN\"));\n    ASSERT_INT_EQ(g->conns.len, 1);\n    ASSERT(find_conn(g, \"a\", \"OUT\", \"IN\", \"b\"));\n"]]}
{"hexsha": "90a9c92eb6ebb6f3b409bed27e1f1e0f6df13b25", "ext": "h", "lang": "C", "content": "interface EditImageTextBgView : UIView\n{\n    double _maxWidth;\n    NSMutableArray *_backgroundRects;\n    UIColor *_textBgColor;\n    double _scale;\n    double _cornerRadius;\n}", "item_id": 0, "repo": "ceekay1991/CallTraceForWeChat", "file": "CallTraceForWeChat/CallTraceForWeChat/WeChat_Headers/EditImageTextBgView.h", "last_update_at": "2022-02-09T08:49:13+00:00", "question_id": "90a9c92eb6ebb6f3b409bed27e1f1e0f6df13b25_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface EditImageTextBgView : UIView\n{\n    double _maxWidth;\n    NSMutableArray *_backgroundRects;\n    UIColor *_textBgColor;\n    double _scale;\n    double _cornerRadius;\n"]]}
{"hexsha": "154551f22c3aeadf7002e3f870bece372aa67a80", "ext": "c", "lang": "C", "content": "void Sin_AddLump (int lumpnum, void *data, int len, int size, int maxsize)\n{\n\tsin_lump_t *lump;\n\tint totallength;\n\n\ttotallength = len*size;\n\n\tif (len > maxsize)\n\t\tError (\"Sin_WriteBSPFile: exceeded max size for lump %d size %d > maxsize %d\\n\", lumpnum, len, maxsize );\n\n\tlump = &sin_header->lumps[lumpnum];\n\t\n\tlump->fileofs = LittleLong( ftell(sin_wadfile) );\n\tlump->filelen = LittleLong(totallength);\n\tSafeWrite (sin_wadfile, data, (totallength+3)&~3);\n}", "item_id": 13, "repo": "xuyanbo03/lab", "file": "engine/code/bspc/l_bsp_sin.c", "last_update_at": "2022-03-31T12:19:09+00:00", "question_id": "154551f22c3aeadf7002e3f870bece372aa67a80_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void Sin_AddLump (int lumpnum, void *data, int len, int size, int maxsize)\n{\n\tsin_lump_t *lump;\n\tint totallength;\n\ttotallength = len*size;\n\tif (len > maxsize)\n\t\tError (\"Sin_WriteBSPFile: exceeded max size for lump %d size %d > maxsize %d\\n\", lumpnum, len, maxsize );\n\tlump = &sin_header->lumps[lumpnum];\n\t\n\tlump->fileofs = LittleLong( ftell(sin_wadfile) );\n\tlump->filelen = LittleLong(totallength);\n\tSafeWrite (sin_wadfile, data, (totallength+3)&~3);\n"]]}
{"hexsha": "36ff9541c518337e461f309f9ed9269e7c3801ef", "ext": "c", "lang": "C", "content": "int\nmain(int argc, const char **argv) {\n  int i, ret;\n  const char *me;\n  char *argv0 = NULL, *err;\n  hestParm *hparm;\n  airArray *mop;\n\n  me = argv[0];\n  /* no harm done in making sure we're sane */\n  if (!nrrdSanity()) {\n    fprintf(stderr, \"******************************************\\n\");\n    fprintf(stderr, \"******************************************\\n\");\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"  %s: nrrd sanity check FAILED.\\n\", me);\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"  This means that either nrrd can't work on this \"\n            \"platform, or (more likely)\\n\");\n    fprintf(stderr, \"  there was an error in the compilation options \"\n            \"and variable definitions\\n\");\n    fprintf(stderr, \"  for Teem.\\n\");\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"  %s\\n\", err = biffGetDone(NRRD));\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"******************************************\\n\");\n    fprintf(stderr, \"******************************************\\n\");\n    free(err);\n    return 1;\n  }\n\n  mop = airMopNew();\n  hparm = hestParmNew();\n  airMopAdd(mop, hparm, (airMopper)hestParmFree, airMopAlways);\n  hparm->elideSingleEnumType = AIR_TRUE;\n  hparm->elideSingleOtherType = AIR_TRUE;\n  hparm->elideSingleOtherDefault = AIR_FALSE;\n  hparm->elideSingleNonExistFloatDefault = AIR_TRUE;\n  hparm->elideMultipleNonExistFloatDefault = AIR_TRUE;\n  hparm->elideSingleEmptyStringDefault = AIR_TRUE;\n  hparm->elideMultipleEmptyStringDefault = AIR_TRUE;\n  hparm->cleverPluralizeOtherY = AIR_TRUE;\n  hparm->columns = 78;\n\n  /* if there are no arguments, then we give general usage information */\n  if (1 >= argc) {\n    baneGkmsUsage(GKMS, hparm);\n    airMopError(mop);\n    exit(1);\n  }\n  /* else, we should see if they're asking for a command we know about */  \n  /* baneGkmsCmdList[] is NULL-terminated */\n  for (i=0; baneGkmsCmdList[i]; i++) {\n    if (!strcmp(argv[1], baneGkmsCmdList[i]->name))\n      break;\n  }\n  if (baneGkmsCmdList[i]) {\n    /* yes, we have that command */\n    /* initialize variables used by the various commands */\n    argv0 = AIR_CAST(char*, malloc(strlen(GKMS) + strlen(argv[1]) + 2));\n    airMopMem(mop, &argv0, airMopAlways);\n    sprintf(argv0, \"%s %s\", GKMS, argv[1]);\n\n    /* run the individual unu program, saving its exit status */\n    ret = baneGkmsCmdList[i]->main(argc-2, argv+2, argv0, hparm);\n    if (1 == ret) {\n      airMopAdd(mop, err=biffGetDone(BANE), airFree, airMopAlways);\n      fprintf(stderr, \"%s: error:\\n%s\", argv0, err);\n    } else if (2 == ret) {\n      /* gkms command has already handled printing error messages */\n      ret = 1;\n    }\n  } else {\n    fprintf(stderr, \"%s: unrecognized command: \\\"%s\\\"; type \\\"%s\\\" for \"\n            \"complete list\\n\", me, argv[1], me);\n    ret = 1;\n  }\n\n  airMopDone(mop, ret);\n  return ret;\n}", "item_id": 0, "repo": "TomographyLab/NiftyRec", "file": "teem/src/bin/gkms.c", "last_update_at": "2022-02-07T21:58:49+00:00", "question_id": "36ff9541c518337e461f309f9ed9269e7c3801ef_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nmain(int argc, const char **argv) {\n  int i, ret;\n  const char *me;\n  char *argv0 = NULL, *err;\n  hestParm *hparm;\n  airArray *mop;\n  me = argv[0];\n  /* no harm done in making sure we're sane */\n  if (!nrrdSanity()) {\n    fprintf(stderr, \"******************************************\\n\");\n    fprintf(stderr, \"******************************************\\n\");\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"  %s: nrrd sanity check FAILED.\\n\", me);\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"  This means that either nrrd can't work on this \"\n            \"platform, or (more likely)\\n\");\n    fprintf(stderr, \"  there was an error in the compilation options \"\n            \"and variable definitions\\n\");\n    fprintf(stderr, \"  for Teem.\\n\");\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"  %s\\n\", err = biffGetDone(NRRD));\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"******************************************\\n\");\n    fprintf(stderr, \"******************************************\\n\");\n    free(err);\n    return 1;\n  }\n  mop = airMopNew();\n  hparm = hestParmNew();\n  airMopAdd(mop, hparm, (airMopper)hestParmFree, airMopAlways);\n  hparm->elideSingleEnumType = AIR_TRUE;\n  hparm->elideSingleOtherType = AIR_TRUE;\n  hparm->elideSingleOtherDefault = AIR_FALSE;\n  hparm->elideSingleNonExistFloatDefault = AIR_TRUE;\n  hparm->elideMultipleNonExistFloatDefault = AIR_TRUE;\n  hparm->elideSingleEmptyStringDefault = AIR_TRUE;\n  hparm->elideMultipleEmptyStringDefault = AIR_TRUE;\n  hparm->cleverPluralizeOtherY = AIR_TRUE;\n  hparm->columns = 78;\n  /* if there are no arguments, then we give general usage information */\n  if (1 >= argc) {\n    baneGkmsUsage(GKMS, hparm);\n    airMopError(mop);\n    exit(1);\n  }\n  /* else, we should see if they're asking for a command we know about */  \n  /* baneGkmsCmdList[] is NULL-terminated */\n  for (i=0; baneGkmsCmdList[i]; i++) {\n    if (!strcmp(argv[1], baneGkmsCmdList[i]->name))\n      break;\n  }\n  if (baneGkmsCmdList[i]) {\n    /* yes, we have that command */\n    /* initialize variables used by the various commands */\n    argv0 = AIR_CAST(char*, malloc(strlen(GKMS) + strlen(argv[1]) + 2));\n    airMopMem(mop, &argv0, airMopAlways);\n    sprintf(argv0, \"%s %s\", GKMS, argv[1]);\n    /* run the individual unu program, saving its exit status */\n    ret = baneGkmsCmdList[i]->main(argc-2, argv+2, argv0, hparm);\n    if (1 == ret) {\n      airMopAdd(mop, err=biffGetDone(BANE), airFree, airMopAlways);\n      fprintf(stderr, \"%s: error:\\n%s\", argv0, err);\n    } else if (2 == ret) {\n      /* gkms command has already handled printing error messages */\n      ret = 1;\n    }\n  } else {\n    fprintf(stderr, \"%s: unrecognized command: \\\"%s\\\"; type \\\"%s\\\" for \"\n            \"complete list\\n\", me, argv[1], me);\n    ret = 1;\n  }\n  airMopDone(mop, ret);\n  return ret;\n"]]}
{"hexsha": "7f3dcc028fadbd7b804583469b7c480736d89f77", "ext": "c", "lang": "C", "content": "void* list_pop_node(list_t* list, node_t* node)\n{\n  void* element;\n  \n  if (!node) {\n    return (NULL);\n  }\n  element = node->element;\n  list_remove_node(list, node);\n  return (element);\n}", "item_id": 6, "repo": "HQarroum/circular-linked-list", "file": "linked-list.c", "last_update_at": "2022-03-23T18:48:52+00:00", "question_id": "7f3dcc028fadbd7b804583469b7c480736d89f77_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void* list_pop_node(list_t* list, node_t* node)\n{\n  void* element;\n  if (!node) {\n    return (NULL);\n  }\n  element = node->element;\n  list_remove_node(list, node);\n  return (element);\n"]]}
{"hexsha": "5c510267237f6c02f5175550e6f236ecb66f42bd", "ext": "h", "lang": "C", "content": "class Branches {\npublic:\n\tBranches(void) { }\n\t~Branches(void) { }\n\tconst Branch *operator[](const std::string &ID) const;\n\tBranch *operator[](const std::string &ID);\n\tconst Branch *get_by_name(const std::string &Name) const;\n\tBranch *get_by_name(const std::string &Name);\n\tint AddBranch(Branch *);\nprotected:\n\tstd::map<std::string,Branch *> ID_to_Branch;\n}", "item_id": 0, "repo": "endolith/Truthcoin", "file": "lib-other/cpplib/tc_data.h", "last_update_at": "2022-02-14T04:44:13+00:00", "question_id": "5c510267237f6c02f5175550e6f236ecb66f42bd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Branches {\npublic:\n\tBranches(void) { }\n\t~Branches(void) { }\n\tconst Branch *operator[](const std::string &ID) const;\n\tBranch *operator[](const std::string &ID);\n\tconst Branch *get_by_name(const std::string &Name) const;\n\tBranch *get_by_name(const std::string &Name);\n\tint AddBranch(Branch *);\nprotected:\n\tstd::map<std::string,Branch *> ID_to_Branch;\n"]]}
{"hexsha": "f5f104b73879169634ca864353ce8f598439ca5d", "ext": "c", "lang": "C", "content": "void config_entity_set_value(ConfigEntity *entity, char *key, char *value) {\n\t// Add a new key-value pair to the entity\n\n\tif (entity->keyValuePairs == NULL) {\n\t\tentity->keyValuePairs = list_new(free);\n\t}\n\n\tConfigKeyValuePair *kv = calloc(1, sizeof(ConfigKeyValuePair));\n\tkv->key = strdup(key);\n\tkv->value = strdup(value);\n\n\tlist_insert_after(entity->keyValuePairs, list_tail(entity->keyValuePairs), kv);\n}", "item_id": 2, "repo": "pdetagyos/DarkCaverns", "file": "config.c", "last_update_at": "2022-03-07T21:37:39+00:00", "question_id": "f5f104b73879169634ca864353ce8f598439ca5d_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void config_entity_set_value(ConfigEntity *entity, char *key, char *value) {\n\t// Add a new key-value pair to the entity\n\tif (entity->keyValuePairs == NULL) {\n\t\tentity->keyValuePairs = list_new(free);\n\t}\n\tConfigKeyValuePair *kv = calloc(1, sizeof(ConfigKeyValuePair));\n\tkv->key = strdup(key);\n\tkv->value = strdup(value);\n\tlist_insert_after(entity->keyValuePairs, list_tail(entity->keyValuePairs), kv);\n"]]}
{"hexsha": "9915603ed10babaeac41daefa89ed1479b0b3faf", "ext": "c", "lang": "C", "content": "static void ipa_shutdown(struct platform_device *pdev)\n{\n\tint ret;\n\n\tret = ipa_remove(pdev);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"shutdown: remove returned %d\\n\", ret);\n}", "item_id": 13, "repo": "SFIP/SFIP", "file": "kernel/drivers/net/ipa/ipa_main.c", "last_update_at": "2022-03-14T18:04:48+00:00", "question_id": "9915603ed10babaeac41daefa89ed1479b0b3faf_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void ipa_shutdown(struct platform_device *pdev)\n{\n\tint ret;\n\tret = ipa_remove(pdev);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"shutdown: remove returned %d\\n\", ret);\n"]]}
{"hexsha": "83431b559034ba5c869ca57192d94aba0a4c3c40", "ext": "c", "lang": "C", "content": "static xrt_result_t\nmulti_compositor_layer_begin(struct xrt_compositor *xc,\n                             int64_t frame_id,\n                             uint64_t display_time_ns,\n                             enum xrt_blend_mode env_blend_mode)\n{\n\tstruct multi_compositor *mc = multi_compositor(xc);\n\n\tassert(mc->progress.num_layers == 0);\n\tU_ZERO(&mc->progress);\n\n\tmc->progress.active = true;\n\tmc->progress.display_time_ns = display_time_ns;\n\tmc->progress.env_blend_mode = env_blend_mode;\n\n\treturn XRT_SUCCESS;\n}", "item_id": 13, "repo": "SimulaVR/monado", "file": "src/xrt/compositor/multi/comp_multi_compositor.c", "last_update_at": "2022-01-24T12:50:59+00:00", "question_id": "83431b559034ba5c869ca57192d94aba0a4c3c40_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static xrt_result_t\nmulti_compositor_layer_begin(struct xrt_compositor *xc,\n                             int64_t frame_id,\n                             uint64_t display_time_ns,\n                             enum xrt_blend_mode env_blend_mode)\n{\n\tstruct multi_compositor *mc = multi_compositor(xc);\n\tassert(mc->progress.num_layers == 0);\n\tU_ZERO(&mc->progress);\n\tmc->progress.active = true;\n\tmc->progress.display_time_ns = display_time_ns;\n\tmc->progress.env_blend_mode = env_blend_mode;\n\treturn XRT_SUCCESS;\n"]]}
{"hexsha": "787a9bf8b624a39c223c912d92f4770953fb9d2d", "ext": "c", "lang": "C", "content": "void Delay100ms() {\n  unsigned char i, j, k;\n\n  i = 10;\n  j = 153;\n  k = 44;\n  do {\n    do {\n      while (--k) {};\n    } while (--j);\n  } while (--i);\n}", "item_id": 8, "repo": "mogoreanu/8x16", "file": "hw_driver.c", "last_update_at": "2022-03-04T12:55:40+00:00", "question_id": "787a9bf8b624a39c223c912d92f4770953fb9d2d_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void Delay100ms() {\n  unsigned char i, j, k;\n  i = 10;\n  j = 153;\n  k = 44;\n  do {\n    do {\n      while (--k) {};\n    } while (--j);\n  } while (--i);\n"]]}
{"hexsha": "d21e1284604f6a2e391ce37c8a6c85a1b06c91ca", "ext": "c", "lang": "C", "content": "static int setup_clone(struct request *clone, struct request *rq,\n\t\t       struct dm_rq_target_io *tio)\n{\n\tint r;\n\n\tif (dm_rq_is_flush_request(rq)) {\n\t\tblk_rq_init(NULL, clone);\n\t\tclone->cmd_type = REQ_TYPE_FS;\n\t\tclone->cmd_flags |= (REQ_HARDBARRIER | WRITE);\n\t} else {\n\t\tr = blk_rq_prep_clone(clone, rq, tio->md->bs, GFP_ATOMIC,\n\t\t\t\t      dm_rq_bio_constructor, tio);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tclone->cmd = rq->cmd;\n\t\tclone->cmd_len = rq->cmd_len;\n\t\tclone->sense = rq->sense;\n\t\tclone->buffer = rq->buffer;\n\t}\n\n\tclone->end_io = end_clone_request;\n\tclone->end_io_data = tio;\n\n\treturn 0;\n}", "item_id": 44, "repo": "wangyan98/linux-lib", "file": "src/linux/drivers/md/dm.c", "last_update_at": "2022-03-20T14:24:29+00:00", "question_id": "d21e1284604f6a2e391ce37c8a6c85a1b06c91ca_44", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int setup_clone(struct request *clone, struct request *rq,\n\t\t       struct dm_rq_target_io *tio)\n{\n\tint r;\n\tif (dm_rq_is_flush_request(rq)) {\n\t\tblk_rq_init(NULL, clone);\n\t\tclone->cmd_type = REQ_TYPE_FS;\n\t\tclone->cmd_flags |= (REQ_HARDBARRIER | WRITE);\n\t} else {\n\t\tr = blk_rq_prep_clone(clone, rq, tio->md->bs, GFP_ATOMIC,\n\t\t\t\t      dm_rq_bio_constructor, tio);\n\t\tif (r)\n\t\t\treturn r;\n\t\tclone->cmd = rq->cmd;\n\t\tclone->cmd_len = rq->cmd_len;\n\t\tclone->sense = rq->sense;\n\t\tclone->buffer = rq->buffer;\n\t}\n\tclone->end_io = end_clone_request;\n\tclone->end_io_data = tio;\n\treturn 0;\n"]]}
{"hexsha": "1e939300fa0ed3ea4f66f806e31d7c9db5679e41", "ext": "c", "lang": "C", "content": "static int __init\nacpi_parse_lapic_addr_ovr (acpi_table_entry_header *header)\n{\n\tstruct acpi_table_lapic_addr_ovr *lapic;\n\n\tlapic = (struct acpi_table_lapic_addr_ovr *) header;\n\tif (!lapic)\n\t\treturn -EINVAL;\n\n\tacpi_table_print_madt_entry(header);\n\n\tif (lapic->address) {\n\t\tiounmap((void *) ipi_base_addr);\n\t\tipi_base_addr = (unsigned long) ioremap(lapic->address, 0);\n\t}\n\treturn 0;\n}", "item_id": 4, "repo": "ghsecuritylab/tomato_egg", "file": "release/src/linux/linux/arch/ia64/kernel/acpi.c", "last_update_at": "2022-01-20T18:21:05+00:00", "question_id": "1e939300fa0ed3ea4f66f806e31d7c9db5679e41_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int __init\nacpi_parse_lapic_addr_ovr (acpi_table_entry_header *header)\n{\n\tstruct acpi_table_lapic_addr_ovr *lapic;\n\tlapic = (struct acpi_table_lapic_addr_ovr *) header;\n\tif (!lapic)\n\t\treturn -EINVAL;\n\tacpi_table_print_madt_entry(header);\n\tif (lapic->address) {\n\t\tiounmap((void *) ipi_base_addr);\n\t\tipi_base_addr = (unsigned long) ioremap(lapic->address, 0);\n\t}\n\treturn 0;\n"]]}
{"hexsha": "84398799ebc5e1ae4b1a951459f3e627929aa94c", "ext": "h", "lang": "C", "content": "class CBreakShipController: public CShipController {\n\n    public:\n        CBreakShipController( CShip* ship );\n        ~CBreakShipController();\n\n        void run();\n\n        bool done();\n\n    private:\n        bool mDone;\n\n}", "item_id": 0, "repo": "madeso/hopper", "file": "devel/game/AIShipControllers.h", "last_update_at": "2022-01-04T17:36:28+00:00", "question_id": "84398799ebc5e1ae4b1a951459f3e627929aa94c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class CBreakShipController: public CShipController {\n    public:\n        CBreakShipController( CShip* ship );\n        ~CBreakShipController();\n        void run();\n        bool done();\n    private:\n        bool mDone;\n"]]}
{"hexsha": "7bd53967a04c9edc4a72d0f06521b5cef7e321ae", "ext": "c", "lang": "C", "content": "void\nSetNetTrace (register char *file)\n{\n  if (NetTrace && NetTrace != stdout)\n    fclose (NetTrace);\n  if (file && (strcmp (file, \"-\") != 0))\n    {\n      NetTrace = fopen (file, \"w\");\n      if (NetTrace)\n\t{\n\t  strncpy ((char *) NetTraceFile, file, sizeof (NetTraceFile));\n\t  NetTraceFile[sizeof (NetTraceFile) - 1] = 0;\n\t  return;\n\t}\n      fprintf (stderr, \"Cannot open %s.\\n\", file);\n    }\n  NetTrace = stdout;\n  strcpy ((char *) NetTraceFile, \"(standard output)\");\n}", "item_id": 0, "repo": "kupl/starlab-benchmarks", "file": "Benchmarks_with_Safety_Bugs/C/inetutils-1.9.4/src/telnet/utilities.c", "last_update_at": "2022-03-20T02:12:55+00:00", "question_id": "7bd53967a04c9edc4a72d0f06521b5cef7e321ae_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nSetNetTrace (register char *file)\n{\n  if (NetTrace && NetTrace != stdout)\n    fclose (NetTrace);\n  if (file && (strcmp (file, \"-\") != 0))\n    {\n      NetTrace = fopen (file, \"w\");\n      if (NetTrace)\n\t{\n\t  strncpy ((char *) NetTraceFile, file, sizeof (NetTraceFile));\n\t  NetTraceFile[sizeof (NetTraceFile) - 1] = 0;\n\t  return;\n\t}\n      fprintf (stderr, \"Cannot open %s.\\n\", file);\n    }\n  NetTrace = stdout;\n  strcpy ((char *) NetTraceFile, \"(standard output)\");\n"]]}
{"hexsha": "409d18bedbba6fa78a52855b88fc3ee9b10a020a", "ext": "c", "lang": "C", "content": "void dt_reg_init(struct dt_reg *reg, u32 nr_address_cells, u32 nr_size_cells)\n{\n\tmemset(reg, 0, sizeof(struct dt_reg));\n\treg->nr_address_cells = nr_address_cells;\n\treg->nr_size_cells = nr_size_cells;\n}", "item_id": 1, "repo": "wtliang110/lk_hv", "file": "hv/test/kvm-unit-tests/lib/devicetree.c", "last_update_at": "2022-02-24T23:49:29+00:00", "question_id": "409d18bedbba6fa78a52855b88fc3ee9b10a020a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void dt_reg_init(struct dt_reg *reg, u32 nr_address_cells, u32 nr_size_cells)\n{\n\tmemset(reg, 0, sizeof(struct dt_reg));\n\treg->nr_address_cells = nr_address_cells;\n\treg->nr_size_cells = nr_size_cells;\n"]]}
{"hexsha": "149a72dc1074dd8a92f47541ad49f4f009b30466", "ext": "c", "lang": "C", "content": "int main()\n{\n    int exited = 0;\n    int user = USER;\n\n    init_movies();\n    printf(\"========= Movie Rental Service v0.1 =========\\n\");\n    printf(\"   . . . Initializing the inventory . . .\\n\");\n    printf(\"         (movie info from IMDb.com)\\n\");\n    printf(\"=============================================\\n\");\n\n\n    while (!exited) {\n        if (user == USER)\n            exited = run_user_mode(&user);\n        else if(user == ADMIN)\n        {\n            if (run_admin_mode(&user) < 0)\n                exited = 1;\n        }\n        else if(user == DEBUG)\n            run_debug_mode(&user);\n\n        if (!exited)\n            printf(\"\\n\");\n    }\n    printf(\"Bye!\\n\");\n}", "item_id": 0, "repo": "li-xin-yi/cgc-cbs", "file": "cqe-challenges/KPRCA_00042/src/main.c", "last_update_at": "2022-02-21T15:37:22+00:00", "question_id": "149a72dc1074dd8a92f47541ad49f4f009b30466_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main()\n{\n    int exited = 0;\n    int user = USER;\n    init_movies();\n    printf(\"========= Movie Rental Service v0.1 =========\\n\");\n    printf(\"   . . . Initializing the inventory . . .\\n\");\n    printf(\"         (movie info from IMDb.com)\\n\");\n    printf(\"=============================================\\n\");\n    while (!exited) {\n        if (user == USER)\n            exited = run_user_mode(&user);\n        else if(user == ADMIN)\n        {\n            if (run_admin_mode(&user) < 0)\n                exited = 1;\n        }\n        else if(user == DEBUG)\n            run_debug_mode(&user);\n        if (!exited)\n            printf(\"\\n\");\n    }\n    printf(\"Bye!\\n\");\n"]]}
{"hexsha": "b8b09b497ac1655421e82237a1c44dbb703e4cbc", "ext": "c", "lang": "C", "content": "int RLE4CmprLine(char *src, char *dst, int n)\r\n   {\r\n   int i,count=2/*,absolute=1*/;\r\n   BYTE c;\r\n   char *t=dst/*,*tmp*/;\r\n\r\n   c = (BYTE)*src;\r\n\r\n   for (i=1;i<n;i++)\r\n       {\r\n       if ((BYTE)src[i]==c)\r\n           {\r\n\r\n           if (count >= 0xFE)  /* make sure the repeat counter does not */\r\n               {               /* overflow. Flush the buffer if needed  */\r\n               *t++ = count;\r\n               *t++ = c;\r\n               count= 2;       /* reset repeat counter */\r\n               }\r\n           else\r\n               count+=2;       /* increment the repeat counter */\r\n\r\n           continue;\r\n           }\r\n       else\r\n           {\r\n           if (count > 2)      /* write out repeated run if any */\r\n               {\r\n               *t++ = count;\r\n               *t++ = c;\r\n               count= 2;       /* reset repeat counter */\r\n               c = (BYTE)src[i];\r\n               continue;\r\n               }\r\n\r\n           *t++ = 2;\r\n           *t++ = c;\r\n           c = (BYTE)src[i];\r\n           }\r\n       }\r\n\r\n   if (count>2)        /* write out repeated run if any */\r\n       {\r\n       *t++ = count;\r\n       *t++ = c;\r\n       }\r\n   else\r\n       {\r\n       *t++=2;\r\n       *t++=c;\r\n       }\r\n\r\n   *t++ = 0;   /* end-of-line record */\r\n   *t++ = 0;\r\n\r\n   return (int)(t-dst);\r\n   }", "item_id": 7, "repo": "steakknife/pcgeos", "file": "Library/Trans/Graphics/Bitmap/Bmp/ExportC/dibsave.c", "last_update_at": "2022-03-29T01:02:51+00:00", "question_id": "b8b09b497ac1655421e82237a1c44dbb703e4cbc_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int RLE4CmprLine(char *src, char *dst, int n)\r\n   {\r\n   int i,count=2/*,absolute=1*/;\r\n   BYTE c;\r\n   char *t=dst/*,*tmp*/;\r\n\r\n   c = (BYTE)*src;\r\n\r\n   for (i=1;i<n;i++)\r\n       {\r\n       if ((BYTE)src[i]==c)\r\n           {\r\n\r\n           if (count >= 0xFE)  /* make sure the repeat counter does not */\r\n               {               /* overflow. Flush the buffer if needed  */\r\n               *t++ = count;\r\n               *t++ = c;\r\n               count= 2;       /* reset repeat counter */\r\n               }\r\n           else\r\n               count+=2;       /* increment the repeat counter */\r\n\r\n           continue;\r\n           }\r\n       else\r\n           {\r\n           if (count > 2)      /* write out repeated run if any */\r\n               {\r\n               *t++ = count;\r\n               *t++ = c;\r\n               count= 2;       /* reset repeat counter */\r\n               c = (BYTE)src[i];\r\n               continue;\r\n               }\r\n\r\n           *t++ = 2;\r\n           *t++ = c;\r\n           c = (BYTE)src[i];\r\n           }\r\n       }\r\n\r\n   if (count>2)        /* write out repeated run if any */\r\n       {\r\n       *t++ = count;\r\n       *t++ = c;\r\n       }\r\n   else\r\n       {\r\n       *t++=2;\r\n       *t++=c;\r\n       }\r\n\r\n   *t++ = 0;   /* end-of-line record */\r\n   *t++ = 0;\r\n\r\n   return (int)(t-dst);\r\n"]]}
{"hexsha": "cc5bdb8c54d62da69e3cebfec86d776382383f91", "ext": "c", "lang": "C", "content": "char *make_HLSL_swizzle_string(char *swiz_str, const size_t strsize,\n                               const int swizzle, const int writemask)\n{\n    size_t i = 0;\n    if ( (!no_swizzle(swizzle)) || (!writemask_xyzw(writemask)) )\n    {\n        const int writemask0 = (writemask >> 0) & 0x1;\n        const int writemask1 = (writemask >> 1) & 0x1;\n        const int writemask2 = (writemask >> 2) & 0x1;\n        const int writemask3 = (writemask >> 3) & 0x1;\n\n        const int swizzle_x = (swizzle >> 0) & 0x3;\n        const int swizzle_y = (swizzle >> 2) & 0x3;\n        const int swizzle_z = (swizzle >> 4) & 0x3;\n        const int swizzle_w = (swizzle >> 6) & 0x3;\n\n        swiz_str[i++] = '.';\n        if (writemask0) swiz_str[i++] = swizzle_channels[swizzle_x];\n        if (writemask1) swiz_str[i++] = swizzle_channels[swizzle_y];\n        if (writemask2) swiz_str[i++] = swizzle_channels[swizzle_z];\n        if (writemask3) swiz_str[i++] = swizzle_channels[swizzle_w];\n    } // if\n    assert(i < strsize);\n    swiz_str[i] = '\\0';\n    return swiz_str;\n}", "item_id": 7, "repo": "YoYoGames/mojoshader", "file": "profiles/mojoshader_profile_hlsl.c", "last_update_at": "2022-03-29T08:51:26+00:00", "question_id": "cc5bdb8c54d62da69e3cebfec86d776382383f91_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char *make_HLSL_swizzle_string(char *swiz_str, const size_t strsize,\n                               const int swizzle, const int writemask)\n{\n    size_t i = 0;\n    if ( (!no_swizzle(swizzle)) || (!writemask_xyzw(writemask)) )\n    {\n        const int writemask0 = (writemask >> 0) & 0x1;\n        const int writemask1 = (writemask >> 1) & 0x1;\n        const int writemask2 = (writemask >> 2) & 0x1;\n        const int writemask3 = (writemask >> 3) & 0x1;\n        const int swizzle_x = (swizzle >> 0) & 0x3;\n        const int swizzle_y = (swizzle >> 2) & 0x3;\n        const int swizzle_z = (swizzle >> 4) & 0x3;\n        const int swizzle_w = (swizzle >> 6) & 0x3;\n        swiz_str[i++] = '.';\n        if (writemask0) swiz_str[i++] = swizzle_channels[swizzle_x];\n        if (writemask1) swiz_str[i++] = swizzle_channels[swizzle_y];\n        if (writemask2) swiz_str[i++] = swizzle_channels[swizzle_z];\n        if (writemask3) swiz_str[i++] = swizzle_channels[swizzle_w];\n    } // if\n    assert(i < strsize);\n    swiz_str[i] = '\\0';\n    return swiz_str;\n"]]}
{"hexsha": "6aa035aa0476432604c14d9530d43f27b50b128c", "ext": "h", "lang": "C", "content": "class RangeWrapper : public Nan::ObjectWrap {\npublic:\n  static void init();\n  static v8::Local<v8::Value> from_range(Range);\n  static optional<Range> range_from_js(v8::Local<v8::Value>);\n\nprivate:\n  explicit RangeWrapper(Range);\n\n  static void construct(const Nan::FunctionCallbackInfo<v8::Value> &);\n  static void get_start(v8::Local<v8::String>, const Nan::PropertyCallbackInfo<v8::Value> &);\n  static void get_end(v8::Local<v8::String>, const Nan::PropertyCallbackInfo<v8::Value> &);\n\n  Range range;\n}", "item_id": 0, "repo": "aminya/superstring", "file": "src/bindings/range-wrapper.h", "last_update_at": "2022-03-20T15:45:24+00:00", "question_id": "6aa035aa0476432604c14d9530d43f27b50b128c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class RangeWrapper : public Nan::ObjectWrap {\npublic:\n  static void init();\n  static v8::Local<v8::Value> from_range(Range);\n  static optional<Range> range_from_js(v8::Local<v8::Value>);\nprivate:\n  explicit RangeWrapper(Range);\n  static void construct(const Nan::FunctionCallbackInfo<v8::Value> &);\n  static void get_start(v8::Local<v8::String>, const Nan::PropertyCallbackInfo<v8::Value> &);\n  static void get_end(v8::Local<v8::String>, const Nan::PropertyCallbackInfo<v8::Value> &);\n  Range range;\n"]]}
{"hexsha": "38f25cb921dc154a1aebdafa0c46a15e9c7f95ff", "ext": "h", "lang": "C", "content": "namespace nasoq {\n#ifdef CHOLROWMOD\n#include \"cholmod_utils.h\"\n //using namespace nasoq_cholmod;\n#endif\n\n/*\n * Class for passing setting to a QP solver. It is a superset of all\n * important input parameters of a QP solver.\n */\n struct QPSettings {\n  double eps; // one threshold for all\n  double eps_primal, eps_dual, eps_slack, eps_nn; // If thresholds are requested per KKT conditions\n  double diag_perturb;\n  int batch_size;\n  double eps_rel;\n  int scaling;\n  double zero_thresh;\n  int inner_iter_ref;\n  int outer_iter_ref;\n  int max_iter;\n  double stop_tol;\n  int max_iter_nas;\n  std::string nasoq_variant;\n\n  QPSettings();\n };\n\n enum nasoq_mode {\n  Fixed = 0, AUTO, Tuned, PREDET\n };\n enum nasoq_status {\n  Optimal = 1, Inaccurate = 2, NotConverged = 3, Infeasible=0, NotFinished=4\n };\n\n struct nasoq_config {\n  int inner_iter, outer_iter;\n  double pert_diag, stop_tol;\n\n  nasoq_config(int a, int b, double c, double d);;\n };\n\n/*\n* min 0.5*xHx + qx s.t. Ax=a and Bx\u2264b\n*/\n struct Nasoq {\n  std::string sol_name;\n  int hessian_size, eq_const_size, ineq_const_size;\n  CSC *H, *HT, *A, *AT, *B, *BT;\n\n  double *q, *a, *b;\n  int n_active;\n  double diag_perturb, zero_thresh, eps_abs, eps_rel;\n  double primal_obj, dual_obj, objective;\n  double non_negativity_infn, complementarity_infn;\n  int inner_iter_ref, outer_iter_ref, max_iter;\n  double stop_tol;\n\n/// Symbolic info\n  int *eTree; //skkt_size\n  int *col2const, *const2col;\n  int *used_const;\n\n/// Super KKT\n  CSC *sKKT, *sKKTt;\n  double *sKKTrhs;\n  int *etree;\n  int *pinv;\n  int *col2sup;\n  size_t skkt_col;\n\n  int scaling;\n  double *D, *E, *F, *Dinv, *Einv, *Finv;\n  double c, cinv;\n\n  double *rec_length;\n\n  double *dual_vars, *dual_vars_eq; //size of ineq_const_size\n  double *primal_vars;\n//double *x0; // Initial solution, warm-start\n  double *kkt_solution, *lagrange_mult, *lagrange_mult_eq, *descent;\n  std::vector<int> active_set;\n  int *as0;// Initial active set, warm-start\n  int is_converged; // 0/1\n  int num_iter, max_iter_nas;\n  int used_constraints, num_active; //\n  int auto_reg_en;\n  int warm_start;\n  int batch_size;\n  double *workspace;\n  double qp_scalar, inv_qp_scalar;\n  nasoq_mode variant;\n  nasoq_status ret_val;\n  SolverSettings *ss;\n\n/// Profiling\n  qp_info *qi;\n  double *dual_FB_a, *dual_FB_b, *dual_FB;\n  double *primal_FB_a, *primal_FB_b, *primal_FB;\n  double lag_res, cons_sat_norm;\n\n#ifdef CHOLROWMOD\n  cholmod_factor *L ;\n  cholmod_sparse *kkt;\n  CSC *kkt_updated;\n  cholmod_common Common, *cm;\n  size_t k_size;\n#endif\n\n  Nasoq(size_t H_size, int *Hp, int *Hi, double *Hx, double *q_in,\n        size_t B_row, size_t B_col, int *Bp, int *Bi,\n        double *Bx, double *b_ineq);\n\n  Nasoq(size_t H_size, int *Hp, int *Hi, double *Hx, double *q_in,\n        size_t A_size1, size_t A_size2, int *Ap, int *Ai, double *Ax,\n        double *a_eq,\n        size_t B_size1, size_t B_size2, int *Bp, int *Bi, double *Bx,\n        double *b_ineq);\n\n  ~Nasoq();\n\n/*\n* Setting default setting for QP\n*/\n  void default_setting();\n\n#ifdef CHOLROWMOD\n  int symbolic_QP_cholmod(){\n   int status =  0;\n   transpose_unsym(B->nrow,B->ncol,B->p,B->i,B->x,\n                   BT->nrow,BT->ncol,BT->p,BT->i,BT->x);\n   BT->nzmax=B->nzmax;\n   //print_csc(\"BT:\\n\",BT->ncol,BT->p,BT->i,BT->x);\n   //build_super_kkt();\n   //Creates a new solver instance\n   if(A->nrow>0){\n    transpose_unsym(A->nrow,A->ncol,A->p,A->i,A->x,\n                    AT->nrow,AT->ncol,AT->p,AT->i,AT->x);\n    AT->nzmax=A->nzmax;\n   }\n\n   /*ss->ldl_variant =4;\n   ss->ldl_update_variant=2;\n   ss->solver_mode = 1;\n   ss->req_ref_iter=outer_iter_ref;\n   if(outer_iter_ref>0 && inner_iter_ref ==0){\n    ss->max_inner_iter = 1; // will be wrong if it is zero\n   }else{\n    ss->max_inner_iter = inner_iter_ref;\n   }*/\n\n   size_t total_nnz = H->nzmax + B->nzmax;\n   double min_v,max_v;\n   //max_min_spmat(H->ncol, H->p, H->i, H->x,max_v,min_v);\n   //setting perturbation\n   if(auto_reg_en==2){\n    double H_norm2 = norm_sparse_int(H->ncol, H->p, H->i, H->x, -1, 2);\n    auto_perturbation2(H->ncol, total_nnz,H_norm2, max_v-min_v,\n                       B->nrow, B->nrow/double(H->ncol), eps_abs,\n                       diag_perturb,\n                       outer_iter_ref,inner_iter_ref,stop_tol);\n   } else if(auto_reg_en==1){\n    determine_iterations(total_nnz, eps_abs,outer_iter_ref,inner_iter_ref);\n    stop_tol = 1e-15;\n   }\n    diag_perturb = pow(10, -6);\n   /*ss->tol_abs = ss->tol_rel = stop_tol;\n   ss->req_ref_iter = outer_iter_ref ;\n   ss->max_inner_iter = inner_iter_ref ;\n   ss->diag_perturb=diag_perturb;*/\n   zero_thresh = diag_perturb;\n   //status = analyze_kkt();\n   //ss->symbolic_analysis();\n   k_size = H->ncol + B->nrow + A->nrow;\n   skkt_col = k_size;\n   sKKTrhs = new double[k_size]();\n   kkt_solution = new double[k_size]();\n   //diag_perturb = pow(10, -6);\n\n   descent = kkt_solution;\n   lagrange_mult_eq = kkt_solution + H->ncol;\n   lagrange_mult = kkt_solution + H->ncol + A->nrow;\n   //sKKT = ss->A_ord;\n\n   return status;\n  }", "item_id": 0, "repo": "mmurooka/nasoq", "file": "include/nasoq/nasoq.h", "last_update_at": "2022-03-24T22:22:50+00:00", "question_id": "38f25cb921dc154a1aebdafa0c46a15e9c7f95ff_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace nasoq {\n#ifdef CHOLROWMOD\n#include \"cholmod_utils.h\"\n //using namespace nasoq_cholmod;\n#endif\n/*\n * Class for passing setting to a QP solver. It is a superset of all\n * important input parameters of a QP solver.\n */\n struct QPSettings {\n  double eps; // one threshold for all\n  double eps_primal, eps_dual, eps_slack, eps_nn; // If thresholds are requested per KKT conditions\n  double diag_perturb;\n  int batch_size;\n  double eps_rel;\n  int scaling;\n  double zero_thresh;\n  int inner_iter_ref;\n  int outer_iter_ref;\n  int max_iter;\n  double stop_tol;\n  int max_iter_nas;\n  std::string nasoq_variant;\n  QPSettings();\n };\n enum nasoq_mode {\n  Fixed = 0, AUTO, Tuned, PREDET\n };\n enum nasoq_status {\n  Optimal = 1, Inaccurate = 2, NotConverged = 3, Infeasible=0, NotFinished=4\n };\n struct nasoq_config {\n  int inner_iter, outer_iter;\n  double pert_diag, stop_tol;\n  nasoq_config(int a, int b, double c, double d);;\n };\n/*\n* min 0.5*xHx + qx s.t. Ax=a and Bx\u2264b\n*/\n struct Nasoq {\n  std::string sol_name;\n  int hessian_size, eq_const_size, ineq_const_size;\n  CSC *H, *HT, *A, *AT, *B, *BT;\n  double *q, *a, *b;\n  int n_active;\n  double diag_perturb, zero_thresh, eps_abs, eps_rel;\n  double primal_obj, dual_obj, objective;\n  double non_negativity_infn, complementarity_infn;\n  int inner_iter_ref, outer_iter_ref, max_iter;\n  double stop_tol;\n/// Symbolic info\n  int *eTree; //skkt_size\n  int *col2const, *const2col;\n  int *used_const;\n/// Super KKT\n  CSC *sKKT, *sKKTt;\n  double *sKKTrhs;\n  int *etree;\n  int *pinv;\n  int *col2sup;\n  size_t skkt_col;\n  int scaling;\n  double *D, *E, *F, *Dinv, *Einv, *Finv;\n  double c, cinv;\n  double *rec_length;\n  double *dual_vars, *dual_vars_eq; //size of ineq_const_size\n  double *primal_vars;\n//double *x0; // Initial solution, warm-start\n  double *kkt_solution, *lagrange_mult, *lagrange_mult_eq, *descent;\n  std::vector<int> active_set;\n  int *as0;// Initial active set, warm-start\n  int is_converged; // 0/1\n  int num_iter, max_iter_nas;\n  int used_constraints, num_active; //\n  int auto_reg_en;\n  int warm_start;\n  int batch_size;\n  double *workspace;\n  double qp_scalar, inv_qp_scalar;\n  nasoq_mode variant;\n  nasoq_status ret_val;\n  SolverSettings *ss;\n/// Profiling\n  qp_info *qi;\n  double *dual_FB_a, *dual_FB_b, *dual_FB;\n  double *primal_FB_a, *primal_FB_b, *primal_FB;\n  double lag_res, cons_sat_norm;\n#ifdef CHOLROWMOD\n  cholmod_factor *L ;\n  cholmod_sparse *kkt;\n  CSC *kkt_updated;\n  cholmod_common Common, *cm;\n  size_t k_size;\n#endif\n  Nasoq(size_t H_size, int *Hp, int *Hi, double *Hx, double *q_in,\n        size_t B_row, size_t B_col, int *Bp, int *Bi,\n        double *Bx, double *b_ineq);\n  Nasoq(size_t H_size, int *Hp, int *Hi, double *Hx, double *q_in,\n        size_t A_size1, size_t A_size2, int *Ap, int *Ai, double *Ax,\n        double *a_eq,\n        size_t B_size1, size_t B_size2, int *Bp, int *Bi, double *Bx,\n        double *b_ineq);\n  ~Nasoq();\n/*\n* Setting default setting for QP\n*/\n  void default_setting();\n#ifdef CHOLROWMOD\n  int symbolic_QP_cholmod(){\n   int status =  0;\n   transpose_unsym(B->nrow,B->ncol,B->p,B->i,B->x,\n                   BT->nrow,BT->ncol,BT->p,BT->i,BT->x);\n   BT->nzmax=B->nzmax;\n   //print_csc(\"BT:\\n\",BT->ncol,BT->p,BT->i,BT->x);\n   //build_super_kkt();\n   //Creates a new solver instance\n   if(A->nrow>0){\n    transpose_unsym(A->nrow,A->ncol,A->p,A->i,A->x,\n                    AT->nrow,AT->ncol,AT->p,AT->i,AT->x);\n    AT->nzmax=A->nzmax;\n   }\n   /*ss->ldl_variant =4;\n   ss->ldl_update_variant=2;\n   ss->solver_mode = 1;\n   ss->req_ref_iter=outer_iter_ref;\n   if(outer_iter_ref>0 && inner_iter_ref ==0){\n    ss->max_inner_iter = 1; // will be wrong if it is zero\n   }else{\n    ss->max_inner_iter = inner_iter_ref;\n   }*/\n   size_t total_nnz = H->nzmax + B->nzmax;\n   double min_v,max_v;\n   //max_min_spmat(H->ncol, H->p, H->i, H->x,max_v,min_v);\n   //setting perturbation\n   if(auto_reg_en==2){\n    double H_norm2 = norm_sparse_int(H->ncol, H->p, H->i, H->x, -1, 2);\n    auto_perturbation2(H->ncol, total_nnz,H_norm2, max_v-min_v,\n                       B->nrow, B->nrow/double(H->ncol), eps_abs,\n                       diag_perturb,\n                       outer_iter_ref,inner_iter_ref,stop_tol);\n   } else if(auto_reg_en==1){\n    determine_iterations(total_nnz, eps_abs,outer_iter_ref,inner_iter_ref);\n    stop_tol = 1e-15;\n   }\n    diag_perturb = pow(10, -6);\n   /*ss->tol_abs = ss->tol_rel = stop_tol;\n   ss->req_ref_iter = outer_iter_ref ;\n   ss->max_inner_iter = inner_iter_ref ;\n   ss->diag_perturb=diag_perturb;*/\n   zero_thresh = diag_perturb;\n   //status = analyze_kkt();\n   //ss->symbolic_analysis();\n   k_size = H->ncol + B->nrow + A->nrow;\n   skkt_col = k_size;\n   sKKTrhs = new double[k_size]();\n   kkt_solution = new double[k_size]();\n   //diag_perturb = pow(10, -6);\n   descent = kkt_solution;\n   lagrange_mult_eq = kkt_solution + H->ncol;\n   lagrange_mult = kkt_solution + H->ncol + A->nrow;\n   //sKKT = ss->A_ord;\n   return status;\n"]]}
{"hexsha": "68aecd43c1c7efbee3e56fd36af99e5168a2f403", "ext": "c", "lang": "C", "content": "void pf_autonomousadcs_attitudemodetargettrackinglinear_list_test(bool verbose)\n{\n  printf(\" * list of pf_autonomousadcs_attitudemodetargettrackinglinear: \");\n  if (verbose)\n    printf(\"\\n\");\n  printf(\"OK\\n\");\n}", "item_id": 5, "repo": "georgeslabreche/ccsdsmo-malc", "file": "apps/generated_areas/src/pf_autonomousadcs_attitudemodetargettrackinglinear_list.c", "last_update_at": "2022-03-27T19:50:33+00:00", "question_id": "68aecd43c1c7efbee3e56fd36af99e5168a2f403_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void pf_autonomousadcs_attitudemodetargettrackinglinear_list_test(bool verbose)\n{\n  printf(\" * list of pf_autonomousadcs_attitudemodetargettrackinglinear: \");\n  if (verbose)\n    printf(\"\\n\");\n  printf(\"OK\\n\");\n"]]}
{"hexsha": "4a246631931890fc4ff13200e636e185a81012f1", "ext": "h", "lang": "C", "content": "namespace bn\n{\n    /**\n     * @brief To be part of a intrusive_list, values must inherit this class.\n     *\n     * @ingroup intrusive_list\n     */\n    class intrusive_list_node_type;\n\n    /**\n     * @brief Intrusive list implementation.\n     *\n     * @tparam Type Element type (it must inherit intrusive_list_node_type class).\n     *\n     * @ingroup intrusive_list\n     */\n    template<class Type>\n    class intrusive_list;\n}", "item_id": 0, "repo": "taellinglin/butano", "file": "butano/include/bn_intrusive_list_fwd.h", "last_update_at": "2022-03-29T05:03:53+00:00", "question_id": "4a246631931890fc4ff13200e636e185a81012f1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace bn\n{\n    /**\n     * @brief To be part of a intrusive_list, values must inherit this class.\n     *\n     * @ingroup intrusive_list\n     */\n    class intrusive_list_node_type;\n    /**\n     * @brief Intrusive list implementation.\n     *\n     * @tparam Type Element type (it must inherit intrusive_list_node_type class).\n     *\n     * @ingroup intrusive_list\n     */\n    template<class Type>\n    class intrusive_list;\n"]]}
{"hexsha": "d0ae4392a976e900cb608e727bce42c8c4a3b334", "ext": "c", "lang": "C", "content": "ALT_STATUS_CODE alt_dma_event_int_select(ALT_DMA_EVENT_t evt_num,\r\n                                         ALT_DMA_EVENT_SELECT_t opt)\r\n{\r\n    // Validate evt_num\r\n    switch (evt_num)\r\n    {\r\n    case ALT_DMA_EVENT_0:\r\n    case ALT_DMA_EVENT_1:\r\n    case ALT_DMA_EVENT_2:\r\n    case ALT_DMA_EVENT_3:\r\n    case ALT_DMA_EVENT_4:\r\n    case ALT_DMA_EVENT_5:\r\n    case ALT_DMA_EVENT_6:\r\n    case ALT_DMA_EVENT_7:\r\n    case ALT_DMA_EVENT_ABORT:\r\n        break;\r\n    default:\r\n        return ALT_E_BAD_ARG;\r\n    }\r\n\r\n    // For information on INTEN, see PL330, section 3.3.3.\r\n\r\n    switch (opt)\r\n    {\r\n    case ALT_DMA_EVENT_SELECT_SEND_EVT:\r\n        alt_clrbits_word(ALT_DMA_INTEN_ADDR(ALT_DMASECURE_ADDR), 1 << evt_num);\r\n        break;\r\n    case ALT_DMA_EVENT_SELECT_SIG_IRQ:\r\n        alt_setbits_word(ALT_DMA_INTEN_ADDR(ALT_DMASECURE_ADDR), 1 << evt_num);\r\n        break;\r\n    default:\r\n        return ALT_E_BAD_ARG;\r\n    }\r\n\r\n    return ALT_E_SUCCESS;\r\n}", "item_id": 13, "repo": "JVVJV/FreeRTOS", "file": "FreeRTOS/Demo/CORTEX_A9_Cyclone_V_SoC_DK/Altera_Code/HardwareLibrary/alt_dma.c", "last_update_at": "2022-03-31T13:59:08+00:00", "question_id": "d0ae4392a976e900cb608e727bce42c8c4a3b334_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ALT_STATUS_CODE alt_dma_event_int_select(ALT_DMA_EVENT_t evt_num,\r\n                                         ALT_DMA_EVENT_SELECT_t opt)\r\n{\r\n    // Validate evt_num\r\n    switch (evt_num)\r\n    {\r\n    case ALT_DMA_EVENT_0:\r\n    case ALT_DMA_EVENT_1:\r\n    case ALT_DMA_EVENT_2:\r\n    case ALT_DMA_EVENT_3:\r\n    case ALT_DMA_EVENT_4:\r\n    case ALT_DMA_EVENT_5:\r\n    case ALT_DMA_EVENT_6:\r\n    case ALT_DMA_EVENT_7:\r\n    case ALT_DMA_EVENT_ABORT:\r\n        break;\r\n    default:\r\n        return ALT_E_BAD_ARG;\r\n    }\r\n\r\n    // For information on INTEN, see PL330, section 3.3.3.\r\n\r\n    switch (opt)\r\n    {\r\n    case ALT_DMA_EVENT_SELECT_SEND_EVT:\r\n        alt_clrbits_word(ALT_DMA_INTEN_ADDR(ALT_DMASECURE_ADDR), 1 << evt_num);\r\n        break;\r\n    case ALT_DMA_EVENT_SELECT_SIG_IRQ:\r\n        alt_setbits_word(ALT_DMA_INTEN_ADDR(ALT_DMASECURE_ADDR), 1 << evt_num);\r\n        break;\r\n    default:\r\n        return ALT_E_BAD_ARG;\r\n    }\r\n\r\n    return ALT_E_SUCCESS;\r\n"]]}
{"hexsha": "9eff40876ed2ed2cd2eaf7064983bcd983c20ad2", "ext": "c", "lang": "C", "content": "int rdpei_add_contact(RdpeiClientContext* context, RDPINPUT_CONTACT_DATA* contact)\n{\n\tRDPINPUT_CONTACT_POINT* contactPoint;\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*) context->handle;\n\n\tEnterCriticalSection(&rdpei->lock);\n\n\tcontactPoint = (RDPINPUT_CONTACT_POINT*) &rdpei->contactPoints[contact->contactId];\n\tCopyMemory(&(contactPoint->data), contact, sizeof(RDPINPUT_CONTACT_DATA));\n\tcontactPoint->dirty = TRUE;\n\n\tSetEvent(rdpei->event);\n\n\tLeaveCriticalSection(&rdpei->lock);\n\n\treturn 1;\n}", "item_id": 17, "repo": "vdsicinn/FreeRDP", "file": "channels/rdpei/client/rdpei_main.c", "last_update_at": "2022-01-15T21:49:43+00:00", "question_id": "9eff40876ed2ed2cd2eaf7064983bcd983c20ad2_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int rdpei_add_contact(RdpeiClientContext* context, RDPINPUT_CONTACT_DATA* contact)\n{\n\tRDPINPUT_CONTACT_POINT* contactPoint;\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*) context->handle;\n\tEnterCriticalSection(&rdpei->lock);\n\tcontactPoint = (RDPINPUT_CONTACT_POINT*) &rdpei->contactPoints[contact->contactId];\n\tCopyMemory(&(contactPoint->data), contact, sizeof(RDPINPUT_CONTACT_DATA));\n\tcontactPoint->dirty = TRUE;\n\tSetEvent(rdpei->event);\n\tLeaveCriticalSection(&rdpei->lock);\n\treturn 1;\n"]]}
{"hexsha": "1b44bba515039f323b69b64c6f870027c3529b03", "ext": "c", "lang": "C", "content": "void test_extensions_v1beta1_deployment(int include_optional) {\n    extensions_v1beta1_deployment_t* extensions_v1beta1_deployment_1 = instantiate_extensions_v1beta1_deployment(include_optional);\n\n\tcJSON* jsonextensions_v1beta1_deployment_1 = extensions_v1beta1_deployment_convertToJSON(extensions_v1beta1_deployment_1);\n\tprintf(\"extensions_v1beta1_deployment :\\n%s\\n\", cJSON_Print(jsonextensions_v1beta1_deployment_1));\n\textensions_v1beta1_deployment_t* extensions_v1beta1_deployment_2 = extensions_v1beta1_deployment_parseFromJSON(jsonextensions_v1beta1_deployment_1);\n\tcJSON* jsonextensions_v1beta1_deployment_2 = extensions_v1beta1_deployment_convertToJSON(extensions_v1beta1_deployment_2);\n\tprintf(\"repeating extensions_v1beta1_deployment:\\n%s\\n\", cJSON_Print(jsonextensions_v1beta1_deployment_2));\n}", "item_id": 1, "repo": "minerba/c", "file": "kubernetes/unit-test/test_extensions_v1beta1_deployment.c", "last_update_at": "2022-03-30T08:25:05+00:00", "question_id": "1b44bba515039f323b69b64c6f870027c3529b03_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void test_extensions_v1beta1_deployment(int include_optional) {\n    extensions_v1beta1_deployment_t* extensions_v1beta1_deployment_1 = instantiate_extensions_v1beta1_deployment(include_optional);\n\tcJSON* jsonextensions_v1beta1_deployment_1 = extensions_v1beta1_deployment_convertToJSON(extensions_v1beta1_deployment_1);\n\tprintf(\"extensions_v1beta1_deployment :\\n%s\\n\", cJSON_Print(jsonextensions_v1beta1_deployment_1));\n\textensions_v1beta1_deployment_t* extensions_v1beta1_deployment_2 = extensions_v1beta1_deployment_parseFromJSON(jsonextensions_v1beta1_deployment_1);\n\tcJSON* jsonextensions_v1beta1_deployment_2 = extensions_v1beta1_deployment_convertToJSON(extensions_v1beta1_deployment_2);\n\tprintf(\"repeating extensions_v1beta1_deployment:\\n%s\\n\", cJSON_Print(jsonextensions_v1beta1_deployment_2));\n"]]}
{"hexsha": "f0e9048cd1e615ea355e4c8f6ea91cc9027f4eb1", "ext": "c", "lang": "C", "content": "void\nlws_tls_err_describe(void)\n{\n\tchar buf[128];\n\tunsigned long l;\n\n\tdo {\n\t\tl = ERR_get_error();\n\t\tif (!l)\n\t\t\tbreak;\n\t\tERR_error_string_n(l, buf, sizeof(buf));\n\t\tlwsl_info(\"   openssl error: %s\\n\", buf);\n\t} while (l);\n\tlwsl_info(\"\\n\");\n}", "item_id": 0, "repo": "RomanValov/ArmoryDB", "file": "libwebsockets/lib/tls/openssl/tls.c", "last_update_at": "2022-02-17T07:26:01+00:00", "question_id": "f0e9048cd1e615ea355e4c8f6ea91cc9027f4eb1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nlws_tls_err_describe(void)\n{\n\tchar buf[128];\n\tunsigned long l;\n\tdo {\n\t\tl = ERR_get_error();\n\t\tif (!l)\n\t\t\tbreak;\n\t\tERR_error_string_n(l, buf, sizeof(buf));\n\t\tlwsl_info(\"   openssl error: %s\\n\", buf);\n\t} while (l);\n\tlwsl_info(\"\\n\");\n"]]}
{"hexsha": "13a4c17f8fb7428bdddbbf219d5607a39603fbd7", "ext": "c", "lang": "C", "content": "void initBaxNames(BaxData *b, char *fname)\n  {\n// set pointer from fname to b->fullname\n    b->fullName = fname;\n\n    char *c;\n    int epos;\n\n    c = strrchr(fname, '/');\n    if (c != NULL)\n      b->shortNameBeg = c - fname + 1;\n    else\n      b->shortNameBeg = 0;\n\n    epos = strlen(fname);\n\n    if ((epos >= 9) && ((strcasecmp(fname + (epos - 9), \".1.bax.h5\") == 0) || (strcasecmp(fname + (epos - 9), \".2.bax.h5\") == 0) || (strcasecmp(fname + (epos - 9), \".3.bax.h5\") == 0)))\n      b->shortNameEnd = epos - 9;\n    else\n      b->shortNameEnd = epos;\n  }", "item_id": 16, "repo": "MartinPippel/DAmar", "file": "utils/H5dextractUtils.c", "last_update_at": "2022-03-31T03:42:00+00:00", "question_id": "13a4c17f8fb7428bdddbbf219d5607a39603fbd7_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void initBaxNames(BaxData *b, char *fname)\n  {\n// set pointer from fname to b->fullname\n    b->fullName = fname;\n    char *c;\n    int epos;\n    c = strrchr(fname, '/');\n    if (c != NULL)\n      b->shortNameBeg = c - fname + 1;\n    else\n      b->shortNameBeg = 0;\n    epos = strlen(fname);\n    if ((epos >= 9) && ((strcasecmp(fname + (epos - 9), \".1.bax.h5\") == 0) || (strcasecmp(fname + (epos - 9), \".2.bax.h5\") == 0) || (strcasecmp(fname + (epos - 9), \".3.bax.h5\") == 0)))\n      b->shortNameEnd = epos - 9;\n    else\n      b->shortNameEnd = epos;\n"]]}
{"hexsha": "108d6a71c5c5a6577a8a0a6293df3522c00bb605", "ext": "c", "lang": "C", "content": "struct apartment * apartment_get_current_or_mta(void)\n{\n    struct apartment *apt = com_get_current_apt();\n    if (apt)\n    {\n        apartment_addref(apt);\n        return apt;\n    }\n    return apartment_get_mta();\n}", "item_id": 14, "repo": "mirkobrombin/wine", "file": "dlls/combase/apartment.c", "last_update_at": "2022-03-31T14:49:36+00:00", "question_id": "108d6a71c5c5a6577a8a0a6293df3522c00bb605_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct apartment * apartment_get_current_or_mta(void)\n{\n    struct apartment *apt = com_get_current_apt();\n    if (apt)\n    {\n        apartment_addref(apt);\n        return apt;\n    }\n    return apartment_get_mta();\n"]]}
{"hexsha": "35aa95b5e0fa351da62b57a02765d0b91be24050", "ext": "h", "lang": "C", "content": "CVoid SetVector( CVec4f vec ) { m_vector.x = vec.x; m_vector.y = vec.y; m_vector.z = vec.z; m_vector.w = vec.w; }", "item_id": 1, "repo": "ehsankamrani/vandaengine", "file": "editor/VandaEngine1/GraphicsEngine/Transform.h", "last_update_at": "2022-03-21T00:56:33+00:00", "question_id": "35aa95b5e0fa351da62b57a02765d0b91be24050_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["CVoid SetVector( CVec4f vec ) { m_vector.x = vec.x; m_vector.y = vec.y; m_vector.z = vec.z; m_vector.w = vec.w; }\n"]]}
{"hexsha": "c6e789c41ffb687b8d0f30012e9b3c2459edb11f", "ext": "c", "lang": "C", "content": "void progress_update ()\n{\n  static uint64_t counter = 0;  // counter to perform one step\n  static int progress = 1;      // steps taken\n  static char progressBar[21] = \"====================\"; // progress done\n  static char progressBlank[21] = \"--------------------\"; // progress open\n\n  if (glbl_verboseMode && !glbl_endlessMode)\n  {\n    counter++;\n    if (counter == glbl_progressStep)\n    {\n      counter = 0;\n      if (glbl_simulatedAttMode)\n      {\n        printf (\"\\r<%s%s> %3i %% created (%.1f %% cracked)\", progressBar + (20 - (int) (progress / 5)), progressBlank + (int) (progress / 5), progress, glbl_crackedRatio * 100);\n      }\n      else\n      {\n        printf (\"\\r<%s%s> %3i %% created\", progressBar + (20 - (int) (progress / 5)), progressBlank + (int) (progress / 5), progress);\n      }\n      progress++;\n    }\n  }\n}", "item_id": 6, "repo": "84KaliPleXon3/OMEN", "file": "src/enumNG.c", "last_update_at": "2022-03-31T20:46:34+00:00", "question_id": "c6e789c41ffb687b8d0f30012e9b3c2459edb11f_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void progress_update ()\n{\n  static uint64_t counter = 0;  // counter to perform one step\n  static int progress = 1;      // steps taken\n  static char progressBar[21] = \"====================\"; // progress done\n  static char progressBlank[21] = \"--------------------\"; // progress open\n  if (glbl_verboseMode && !glbl_endlessMode)\n  {\n    counter++;\n    if (counter == glbl_progressStep)\n    {\n      counter = 0;\n      if (glbl_simulatedAttMode)\n      {\n        printf (\"\\r<%s%s> %3i %% created (%.1f %% cracked)\", progressBar + (20 - (int) (progress / 5)), progressBlank + (int) (progress / 5), progress, glbl_crackedRatio * 100);\n      }\n      else\n      {\n        printf (\"\\r<%s%s> %3i %% created\", progressBar + (20 - (int) (progress / 5)), progressBlank + (int) (progress / 5), progress);\n      }\n      progress++;\n    }\n  }\n"]]}
{"hexsha": "5dbed81eb340ffac294e47db30c46251da294323", "ext": "c", "lang": "C", "content": "void fun_eval(char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)\n{\n\tif (!fn_range_check(((FUN *)fargs[-1])->name, nfargs, 1, 2, buff, bufc))\n\t{\n\t\treturn;\n\t}\n\n\tif (nfargs == 1)\n\t{\n\t\tchar *str = fargs[0];\n\t\texec(buff, bufc, player, caller, cause, EV_EVAL | EV_FCHECK, &str, (char **)NULL, 0);\n\t\treturn;\n\t}\n\n\tperform_get(buff, bufc, player, caller, cause, fargs, nfargs, cargs, ncargs);\n}", "item_id": 37, "repo": "Terkwood/TinyMUSH", "file": "src/funobj.c", "last_update_at": "2022-03-20T20:28:45+00:00", "question_id": "5dbed81eb340ffac294e47db30c46251da294323_37", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void fun_eval(char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)\n{\n\tif (!fn_range_check(((FUN *)fargs[-1])->name, nfargs, 1, 2, buff, bufc))\n\t{\n\t\treturn;\n\t}\n\tif (nfargs == 1)\n\t{\n\t\tchar *str = fargs[0];\n\t\texec(buff, bufc, player, caller, cause, EV_EVAL | EV_FCHECK, &str, (char **)NULL, 0);\n\t\treturn;\n\t}\n\tperform_get(buff, bufc, player, caller, cause, fargs, nfargs, cargs, ncargs);\n"]]}
{"hexsha": "5e663a62dd6fc9ad3b09570386d376b277c2fca7", "ext": "c", "lang": "C", "content": "static int\nacc100_queue_intr_disable(struct rte_bbdev *dev, uint16_t queue_id)\n{\n\tstruct acc100_queue *q = dev->data->queues[queue_id].queue_private;\n\n\tif (dev->intr_handle->type != RTE_INTR_HANDLE_VFIO_MSI &&\n\t\t\tdev->intr_handle->type != RTE_INTR_HANDLE_UIO)\n\t\treturn -ENOTSUP;\n\n\tq->irq_enable = 0;\n\treturn 0;\n}", "item_id": 25, "repo": "ajitkhaparde/trex-core", "file": "src/dpdk/drivers/baseband/acc100/rte_acc100_pmd.c", "last_update_at": "2022-03-30T06:25:04+00:00", "question_id": "5e663a62dd6fc9ad3b09570386d376b277c2fca7_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nacc100_queue_intr_disable(struct rte_bbdev *dev, uint16_t queue_id)\n{\n\tstruct acc100_queue *q = dev->data->queues[queue_id].queue_private;\n\tif (dev->intr_handle->type != RTE_INTR_HANDLE_VFIO_MSI &&\n\t\t\tdev->intr_handle->type != RTE_INTR_HANDLE_UIO)\n\t\treturn -ENOTSUP;\n\tq->irq_enable = 0;\n\treturn 0;\n"]]}
{"hexsha": "fdc97807f90662bcdf1385ca1d546734a08b92db", "ext": "c", "lang": "C", "content": "static void init_fixtures(void)\n{\n\tdfix_empty.init = ptu_dfix_init;\n\tdfix_empty.fini = ptu_dfix_fini;\n\n\tdfix_indir = dfix_empty;\n\tdfix_indir.header = ptu_dfix_header_indir;\n\n\tdfix_cond = dfix_empty;\n\tdfix_cond.header = ptu_dfix_header_cond;\n\n\tdfix_event = dfix_empty;\n\tdfix_event.header = ptu_dfix_header_event;\n\n\tdfix_event_psb = dfix_empty;\n\tdfix_event_psb.header = ptu_dfix_header_event_psb;\n}", "item_id": 82, "repo": "fengjixuchui/libipt", "file": "libipt/test/src/ptunit-query.c", "last_update_at": "2022-03-08T08:31:26+00:00", "question_id": "fdc97807f90662bcdf1385ca1d546734a08b92db_82", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void init_fixtures(void)\n{\n\tdfix_empty.init = ptu_dfix_init;\n\tdfix_empty.fini = ptu_dfix_fini;\n\tdfix_indir = dfix_empty;\n\tdfix_indir.header = ptu_dfix_header_indir;\n\tdfix_cond = dfix_empty;\n\tdfix_cond.header = ptu_dfix_header_cond;\n\tdfix_event = dfix_empty;\n\tdfix_event.header = ptu_dfix_header_event;\n\tdfix_event_psb = dfix_empty;\n\tdfix_event_psb.header = ptu_dfix_header_event_psb;\n"]]}
{"hexsha": "30221701614c599d380229c69b83558537c69de8", "ext": "c", "lang": "C", "content": "int mr_dump(struct net *net, struct notifier_block *nb, unsigned short family,\n\t    int (*rules_dump)(struct net *net,\n\t\t\t      struct notifier_block *nb),\n\t    struct mr_table *(*mr_iter)(struct net *net,\n\t\t\t\t\tstruct mr_table *mrt),\n\t    rwlock_t *mrt_lock)\n{\n\tstruct mr_table *mrt;\n\tint err;\n\n\terr = rules_dump(net, nb);\n\tif (err)\n\t\treturn err;\n\n\tfor (mrt = mr_iter(net, NULL); mrt; mrt = mr_iter(net, mrt)) {\n\t\tstruct vif_device *v = &mrt->vif_table[0];\n\t\tstruct mr_mfc *mfc;\n\t\tint vifi;\n\n\t\t/* Notifiy on table VIF entries */\n\t\tread_lock(mrt_lock);\n\t\tfor (vifi = 0; vifi < mrt->maxvif; vifi++, v++) {\n\t\t\tif (!v->dev)\n\t\t\t\tcontinue;\n\n\t\t\tmr_call_vif_notifier(nb, net, family,\n\t\t\t\t\t     FIB_EVENT_VIF_ADD,\n\t\t\t\t\t     v, vifi, mrt->id);\n\t\t}\n\t\tread_unlock(mrt_lock);\n\n\t\t/* Notify on table MFC entries */\n\t\tlist_for_each_entry_rcu(mfc, &mrt->mfc_cache_list, list)\n\t\t\tmr_call_mfc_notifier(nb, net, family,\n\t\t\t\t\t     FIB_EVENT_ENTRY_ADD,\n\t\t\t\t\t     mfc, mrt->id);\n\t}\n\n\treturn 0;\n}", "item_id": 11, "repo": "dme26/intravisor", "file": "runtime/musl-lkl/lkl/net/ipv4/ipmr_base.c", "last_update_at": "2022-03-08T08:09:08+00:00", "question_id": "30221701614c599d380229c69b83558537c69de8_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int mr_dump(struct net *net, struct notifier_block *nb, unsigned short family,\n\t    int (*rules_dump)(struct net *net,\n\t\t\t      struct notifier_block *nb),\n\t    struct mr_table *(*mr_iter)(struct net *net,\n\t\t\t\t\tstruct mr_table *mrt),\n\t    rwlock_t *mrt_lock)\n{\n\tstruct mr_table *mrt;\n\tint err;\n\terr = rules_dump(net, nb);\n\tif (err)\n\t\treturn err;\n\tfor (mrt = mr_iter(net, NULL); mrt; mrt = mr_iter(net, mrt)) {\n\t\tstruct vif_device *v = &mrt->vif_table[0];\n\t\tstruct mr_mfc *mfc;\n\t\tint vifi;\n\t\t/* Notifiy on table VIF entries */\n\t\tread_lock(mrt_lock);\n\t\tfor (vifi = 0; vifi < mrt->maxvif; vifi++, v++) {\n\t\t\tif (!v->dev)\n\t\t\t\tcontinue;\n\t\t\tmr_call_vif_notifier(nb, net, family,\n\t\t\t\t\t     FIB_EVENT_VIF_ADD,\n\t\t\t\t\t     v, vifi, mrt->id);\n\t\t}\n\t\tread_unlock(mrt_lock);\n\t\t/* Notify on table MFC entries */\n\t\tlist_for_each_entry_rcu(mfc, &mrt->mfc_cache_list, list)\n\t\t\tmr_call_mfc_notifier(nb, net, family,\n\t\t\t\t\t     FIB_EVENT_ENTRY_ADD,\n\t\t\t\t\t     mfc, mrt->id);\n\t}\n\treturn 0;\n"]]}
{"hexsha": "0c03bfc52b4bf8cfecfc305e0c57afc3049e4d2e", "ext": "c", "lang": "C", "content": "VPVOID LocalLock16(HANDLE hMem)\r\n{\r\n    WORD    h16;\r\n    LONG    retval;\r\n\r\n    if (HIWORD(hMem) == 0) {\r\n        WOW32ASSERT(HIWORD(hMem) != 0);\r\n        return (VPVOID)0;\r\n    }\r\n\r\n    h16 = LOWORD(hMem);\r\n    retval = (VPVOID)hMem;\r\n\r\n    if (h16 & LA_MOVEABLE) {\r\n        PLOCALHANDLEENTRY plhe;\r\n\r\n        GETVDMPTR(hMem, sizeof(*plhe), plhe);\r\n\r\n        if (plhe->lhe_flags & LHE_DISCARDED) {\r\n            goto LOCK1;\r\n        }\r\n\r\n        plhe->lhe_count++;\r\n        if (!plhe->lhe_count)\r\n            plhe->lhe_count--;\r\n\r\nLOCK1:\r\n        LOW(retval) = plhe->lhe_address;\r\n        FLUSHVDMPTR((ULONG)hMem, sizeof(*plhe), plhe);\r\n        FREEVDMPTR(plhe);\r\n    }\r\n\r\n    if (LOWORD(retval) == 0)\r\n        retval = 0;\r\n\r\n    return retval;\r\n}", "item_id": 4, "repo": "King0987654/windows2000", "file": "private/mvdm/wow32/wcall16.c", "last_update_at": "2022-01-02T15:25:24+00:00", "question_id": "0c03bfc52b4bf8cfecfc305e0c57afc3049e4d2e_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["VPVOID LocalLock16(HANDLE hMem)\r\n{\r\n    WORD    h16;\r\n    LONG    retval;\r\n\r\n    if (HIWORD(hMem) == 0) {\r\n        WOW32ASSERT(HIWORD(hMem) != 0);\r\n        return (VPVOID)0;\r\n    }\r\n\r\n    h16 = LOWORD(hMem);\r\n    retval = (VPVOID)hMem;\r\n\r\n    if (h16 & LA_MOVEABLE) {\r\n        PLOCALHANDLEENTRY plhe;\r\n\r\n        GETVDMPTR(hMem, sizeof(*plhe), plhe);\r\n\r\n        if (plhe->lhe_flags & LHE_DISCARDED) {\r\n            goto LOCK1;\r\n        }\r\n\r\n        plhe->lhe_count++;\r\n        if (!plhe->lhe_count)\r\n            plhe->lhe_count--;\r\n\r\nLOCK1:\r\n        LOW(retval) = plhe->lhe_address;\r\n        FLUSHVDMPTR((ULONG)hMem, sizeof(*plhe), plhe);\r\n        FREEVDMPTR(plhe);\r\n    }\r\n\r\n    if (LOWORD(retval) == 0)\r\n        retval = 0;\r\n\r\n    return retval;\r\n"]]}
{"hexsha": "31537c291d835ccea4546264aa4c0efa9b303b8b", "ext": "c", "lang": "C", "content": "static cleri_node_t * keyword__parse(\n        cleri_parse_t * pr,\n        cleri_node_t * parent,\n        cleri_t * cl_obj,\n        cleri_rule_store_t * rule __attribute__((unused)))\n{\n    ssize_t match_len;\n    cleri_node_t * node = NULL;\n    const char * str = parent->str + parent->len;\n\n    if ((match_len = cleri__kwcache_match(pr, str)) < 0)\n    {\n        pr->is_valid = -1; /* error occurred */\n        return NULL;\n    }\n\n    if (match_len == (ssize_t) cl_obj->via.keyword->len &&\n       (\n           strncmp(cl_obj->via.keyword->keyword, str, match_len) == 0 ||\n           (\n               cl_obj->via.keyword->ign_case &&\n               strncasecmp(cl_obj->via.keyword->keyword, str, match_len) == 0\n           )\n       ))\n    {\n        if ((node = cleri__node_new(cl_obj, str, match_len)) != NULL)\n        {\n            parent->len += node->len;\n            cleri__children_add(&parent->children, node);\n        }\n    }\n    else\n    {\n        /* Update expecting */\n        if (cleri__expecting_update(pr->expecting, cl_obj, str) == -1)\n        {\n            /* error occurred, node is already NULL */\n            pr->is_valid = -1;\n        }\n    }\n    return node;\n}", "item_id": 1, "repo": "kooiot/libcleri", "file": "src/keyword.c", "last_update_at": "2022-01-14T17:36:56+00:00", "question_id": "31537c291d835ccea4546264aa4c0efa9b303b8b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static cleri_node_t * keyword__parse(\n        cleri_parse_t * pr,\n        cleri_node_t * parent,\n        cleri_t * cl_obj,\n        cleri_rule_store_t * rule __attribute__((unused)))\n{\n    ssize_t match_len;\n    cleri_node_t * node = NULL;\n    const char * str = parent->str + parent->len;\n    if ((match_len = cleri__kwcache_match(pr, str)) < 0)\n    {\n        pr->is_valid = -1; /* error occurred */\n        return NULL;\n    }\n    if (match_len == (ssize_t) cl_obj->via.keyword->len &&\n       (\n           strncmp(cl_obj->via.keyword->keyword, str, match_len) == 0 ||\n           (\n               cl_obj->via.keyword->ign_case &&\n               strncasecmp(cl_obj->via.keyword->keyword, str, match_len) == 0\n           )\n       ))\n    {\n        if ((node = cleri__node_new(cl_obj, str, match_len)) != NULL)\n        {\n            parent->len += node->len;\n            cleri__children_add(&parent->children, node);\n        }\n    }\n    else\n    {\n        /* Update expecting */\n        if (cleri__expecting_update(pr->expecting, cl_obj, str) == -1)\n        {\n            /* error occurred, node is already NULL */\n            pr->is_valid = -1;\n        }\n    }\n    return node;\n"]]}
{"hexsha": "f8cef715651a42063216dc3b76c716ee89e4dc42", "ext": "c", "lang": "C", "content": "void test_cil_gen_category_currnull_neg(CuTest *tc) {\n\tchar *line[] = {\"(\", \"category\", \"c0\", \")\", NULL};\n\n\tstruct cil_tree *test_tree;\n\tgen_test_tree(&test_tree, line);\n\n\tstruct cil_db *test_db;\n\tcil_db_init(&test_db);\n\n\tstruct cil_tree_node *test_ast_node;\n\tcil_tree_node_init(&test_ast_node);\n\n\ttest_ast_node->parent = test_db->ast->root;\n\ttest_ast_node->line = 1;\n\n\tint rc = cil_gen_category(test_db, NULL, test_ast_node);\n\tCuAssertIntEquals(tc, SEPOL_ERR, rc);\n}", "item_id": 486, "repo": "Joyoe/Magisk-nosbin_magisk-nohide", "file": "native/jni/external/selinux/libsepol/cil/test/unit/test_cil_build_ast.c", "last_update_at": "2022-02-09T12:00:48+00:00", "question_id": "f8cef715651a42063216dc3b76c716ee89e4dc42_486", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void test_cil_gen_category_currnull_neg(CuTest *tc) {\n\tchar *line[] = {\"(\", \"category\", \"c0\", \")\", NULL};\n\tstruct cil_tree *test_tree;\n\tgen_test_tree(&test_tree, line);\n\tstruct cil_db *test_db;\n\tcil_db_init(&test_db);\n\tstruct cil_tree_node *test_ast_node;\n\tcil_tree_node_init(&test_ast_node);\n\ttest_ast_node->parent = test_db->ast->root;\n\ttest_ast_node->line = 1;\n\tint rc = cil_gen_category(test_db, NULL, test_ast_node);\n\tCuAssertIntEquals(tc, SEPOL_ERR, rc);\n"]]}
{"hexsha": "3ad3f9f4f73f718f0da29610fff7e6542840d729", "ext": "h", "lang": "C", "content": "class DefaultWindowBehaviour : public WindowBehaviour {\npublic:\n\t\t\t\t\t\t\t\tDefaultWindowBehaviour(Window* window);\n\tvirtual\t\t\t\t\t\t~DefaultWindowBehaviour();\n\n\tvirtual\tbool\t\t\t\tMouseDown(BMessage* message, BPoint where,\n\t\t\t\t\t\t\t\t\tint32 lastHitRegion, int32& clickCount,\n\t\t\t\t\t\t\t\t\tint32& _hitRegion);\n\tvirtual\tvoid\t\t\t\tMouseUp(BMessage* message, BPoint where);\n\tvirtual\tvoid\t\t\t\tMouseMoved(BMessage *message, BPoint where,\n\t\t\t\t\t\t\t\t\tbool isFake);\n\n\tvirtual\tvoid\t\t\t\tModifiersChanged(int32 modifiers);\n\nprotected:\n\tvirtual bool\t\t\t\tAlterDeltaForSnap(Window* window, BPoint& delta,\n\t\t\t\t\t\t\t\t\tbigtime_t now);\nprivate:\n\t\t\tenum Action {\n\t\t\t\tACTION_NONE,\n\t\t\t\tACTION_ZOOM,\n\t\t\t\tACTION_CLOSE,\n\t\t\t\tACTION_MINIMIZE,\n\t\t\t\tACTION_TAB,\n\t\t\t\tACTION_DRAG,\n\t\t\t\tACTION_SLIDE_TAB,\n\t\t\t\tACTION_RESIZE,\n\t\t\t\tACTION_RESIZE_BORDER\n\t\t\t};\n\n\t\t\tenum {\n\t\t\t\t// 1 for the \"natural\" resize border, -1 for the opposite, so\n\t\t\t\t// multiplying the movement delta by that value results in the\n\t\t\t\t// size change.\n\t\t\t\tLEFT\t= -1,\n\t\t\t\tTOP\t\t= -1,\n\t\t\t\tNONE\t= 0,\n\t\t\t\tRIGHT\t= 1,\n\t\t\t\tBOTTOM\t= 1\n\t\t\t};\n\n\t\t\tstruct State;\n\t\t\tstruct MouseTrackingState;\n\t\t\tstruct DragState;\n\t\t\tstruct ResizeState;\n\t\t\tstruct SlideTabState;\n\t\t\tstruct ResizeBorderState;\n\t\t\tstruct DecoratorButtonState;\n\t\t\tstruct ManageWindowState;\n\n\t\t\t// to keep gcc 2 happy\n\t\t\tfriend struct State;\n\t\t\tfriend struct MouseTrackingState;\n\t\t\tfriend struct DragState;\n\t\t\tfriend struct ResizeState;\n\t\t\tfriend struct SlideTabState;\n\t\t\tfriend struct ResizeBorderState;\n\t\t\tfriend struct DecoratorButtonState;\n\t\t\tfriend struct ManageWindowState;\n\nprivate:\n\t\t\tbool\t\t\t\t_IsWindowModifier(int32 modifiers) const;\n\t\t\tDecorator::Region\t_RegionFor(const BMessage* message,\n\t\t\t\t\t\t\t\t\tint32& tab) const;\n\n\t\t\tvoid\t\t\t\t_SetBorderHighlights(int8 horizontal,\n\t\t\t\t\t\t\t\t\tint8 vertical, bool active);\n\n\t\t\tServerCursor*\t\t_ResizeCursorFor(int8 horizontal,\n\t\t\t\t\t\t\t\t\tint8 vertical);\n\t\t\tvoid\t\t\t\t_SetResizeCursor(int8 horizontal,\n\t\t\t\t\t\t\t\t\tint8 vertical);\n\t\t\tvoid\t\t\t\t_ResetResizeCursor();\n\tstatic\tvoid\t\t\t\t_ComputeResizeDirection(float x, float y,\n\t\t\t\t\t\t\t\t\tint8& _horizontal, int8& _vertical);\n\n\t\t\tvoid\t\t\t\t_NextState(State* state);\n\nprotected:\n\t\t\tWindow*\t\t\t\tfWindow;\n\t\t\tDesktop*\t\t\tfDesktop;\n\t\t\tState*\t\t\t\tfState;\n\t\t\tint32\t\t\t\tfLastModifiers;\n\n\t\t\tMagneticBorder\t\tfMagneticBorder;\n}", "item_id": 0, "repo": "Kirishikesan/haiku", "file": "src/servers/app/decorator/DefaultWindowBehaviour.h", "last_update_at": "2022-02-13T04:19:34+00:00", "question_id": "3ad3f9f4f73f718f0da29610fff7e6542840d729_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class DefaultWindowBehaviour : public WindowBehaviour {\npublic:\n\t\t\t\t\t\t\t\tDefaultWindowBehaviour(Window* window);\n\tvirtual\t\t\t\t\t\t~DefaultWindowBehaviour();\n\tvirtual\tbool\t\t\t\tMouseDown(BMessage* message, BPoint where,\n\t\t\t\t\t\t\t\t\tint32 lastHitRegion, int32& clickCount,\n\t\t\t\t\t\t\t\t\tint32& _hitRegion);\n\tvirtual\tvoid\t\t\t\tMouseUp(BMessage* message, BPoint where);\n\tvirtual\tvoid\t\t\t\tMouseMoved(BMessage *message, BPoint where,\n\t\t\t\t\t\t\t\t\tbool isFake);\n\tvirtual\tvoid\t\t\t\tModifiersChanged(int32 modifiers);\nprotected:\n\tvirtual bool\t\t\t\tAlterDeltaForSnap(Window* window, BPoint& delta,\n\t\t\t\t\t\t\t\t\tbigtime_t now);\nprivate:\n\t\t\tenum Action {\n\t\t\t\tACTION_NONE,\n\t\t\t\tACTION_ZOOM,\n\t\t\t\tACTION_CLOSE,\n\t\t\t\tACTION_MINIMIZE,\n\t\t\t\tACTION_TAB,\n\t\t\t\tACTION_DRAG,\n\t\t\t\tACTION_SLIDE_TAB,\n\t\t\t\tACTION_RESIZE,\n\t\t\t\tACTION_RESIZE_BORDER\n\t\t\t};\n\t\t\tenum {\n\t\t\t\t// 1 for the \"natural\" resize border, -1 for the opposite, so\n\t\t\t\t// multiplying the movement delta by that value results in the\n\t\t\t\t// size change.\n\t\t\t\tLEFT\t= -1,\n\t\t\t\tTOP\t\t= -1,\n\t\t\t\tNONE\t= 0,\n\t\t\t\tRIGHT\t= 1,\n\t\t\t\tBOTTOM\t= 1\n\t\t\t};\n\t\t\tstruct State;\n\t\t\tstruct MouseTrackingState;\n\t\t\tstruct DragState;\n\t\t\tstruct ResizeState;\n\t\t\tstruct SlideTabState;\n\t\t\tstruct ResizeBorderState;\n\t\t\tstruct DecoratorButtonState;\n\t\t\tstruct ManageWindowState;\n\t\t\t// to keep gcc 2 happy\n\t\t\tfriend struct State;\n\t\t\tfriend struct MouseTrackingState;\n\t\t\tfriend struct DragState;\n\t\t\tfriend struct ResizeState;\n\t\t\tfriend struct SlideTabState;\n\t\t\tfriend struct ResizeBorderState;\n\t\t\tfriend struct DecoratorButtonState;\n\t\t\tfriend struct ManageWindowState;\nprivate:\n\t\t\tbool\t\t\t\t_IsWindowModifier(int32 modifiers) const;\n\t\t\tDecorator::Region\t_RegionFor(const BMessage* message,\n\t\t\t\t\t\t\t\t\tint32& tab) const;\n\t\t\tvoid\t\t\t\t_SetBorderHighlights(int8 horizontal,\n\t\t\t\t\t\t\t\t\tint8 vertical, bool active);\n\t\t\tServerCursor*\t\t_ResizeCursorFor(int8 horizontal,\n\t\t\t\t\t\t\t\t\tint8 vertical);\n\t\t\tvoid\t\t\t\t_SetResizeCursor(int8 horizontal,\n\t\t\t\t\t\t\t\t\tint8 vertical);\n\t\t\tvoid\t\t\t\t_ResetResizeCursor();\n\tstatic\tvoid\t\t\t\t_ComputeResizeDirection(float x, float y,\n\t\t\t\t\t\t\t\t\tint8& _horizontal, int8& _vertical);\n\t\t\tvoid\t\t\t\t_NextState(State* state);\nprotected:\n\t\t\tWindow*\t\t\t\tfWindow;\n\t\t\tDesktop*\t\t\tfDesktop;\n\t\t\tState*\t\t\t\tfState;\n\t\t\tint32\t\t\t\tfLastModifiers;\n\t\t\tMagneticBorder\t\tfMagneticBorder;\n"]]}
{"hexsha": "4fd9cba745566b0594dd690568ff8889d3d21c76", "ext": "c", "lang": "C", "content": "void C_covMatern3_2_hao(const double *dist, const int n,  const int d, const double *param, double* ans) {\n  \n  double scaling_factor = sqrt(3.);\n  double s;\n  for (int i = 0; i < n; i++) {\n\t  s = 0;\n\t  for (int k = 0; k < d; k++) {\n\t\t  s += SQUARE(dist[k + i * d]) * param[k];\n  \t  }\n  \t  s = sqrt(s) * scaling_factor;\n\t  ans[i] = exp(-s) * (1.0 + s);\n  }\n}", "item_id": 4, "repo": "zacheberhart-kd/Squirrel-Optimizer-BBO-NeurIPS20-automlorg", "file": "squirrel/GaussianProcess/src/CovFuns.c", "last_update_at": "2022-01-18T06:03:07+00:00", "question_id": "4fd9cba745566b0594dd690568ff8889d3d21c76_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void C_covMatern3_2_hao(const double *dist, const int n,  const int d, const double *param, double* ans) {\n  double scaling_factor = sqrt(3.);\n  double s;\n  for (int i = 0; i < n; i++) {\n\t  s = 0;\n\t  for (int k = 0; k < d; k++) {\n\t\t  s += SQUARE(dist[k + i * d]) * param[k];\n  \t  }\n  \t  s = sqrt(s) * scaling_factor;\n\t  ans[i] = exp(-s) * (1.0 + s);\n  }\n"]]}
{"hexsha": "56ad885762aec692d4e27f5426fde4dffabfd8f0", "ext": "c", "lang": "C", "content": "int vms_copy(char *vms1,char *vms2,COP_PARAM *cop_param)\r\n{\r\n    int     bFailIfExists   = FALSE;\r\n    int     nError          = 0;\r\n    char    dos1[MAX_TOKEN];\r\n    char    dos2[MAX_TOKEN];\r\n    char    vms0[MAX_TOKEN];\r\n    char    directory1[_MAX_PATH];\r\n    char    directory2[_MAX_PATH];\r\n    char    drive1[_MAX_DRIVE];\r\n    char    dir1[_MAX_DIR];\r\n    char    file1[_MAX_FNAME];\r\n    char    ext1[_MAX_EXT];\r\n    char    drive2[_MAX_DRIVE];\r\n    char    dir2[_MAX_DIR];\r\n    char    file2[_MAX_FNAME];\r\n    char    ext2[_MAX_EXT];\r\n    size_t  i = 0;\r\n    int    retcod = DCL_OK;\r\n\r\n    *dos1 = 0; *drive1 = 0; *dir1 = 0; *file1 = 0; *ext1 =0; *directory1 = 0;\r\n    *dos2 = 0; *drive2 = 0; *dir2 = 0; *file2 = 0; *ext2 =0; *directory2 = 0;\r\n\r\n    cvfs_vms_to_dos(vms1,dos1,(int *)&i);\r\n    _splitpath(dos1,drive1,dir1,file1,ext1);\r\n    cvfs_vms_to_dos(vms2,dos2,(int *)&i);\r\n    if (isdir(dos2) && dos2[strlen(dos2)-1] != SLASH_CHR)\r\n            strcat(dos2,SLASH_STR);\r\n    if (dos1[strlen(dos1)-1] == SLASH_CHR)\r\n        dos1[strlen(dos1)-1] = '\\0';\r\n    if (!cvfs_check_device(dos2)) {\r\n        _splitpath(dos2,drive2,dir2,file2,ext2);\r\n        if (!*file2)\r\n            strcpy(file2,file1);\r\n        if (*file2 == '*')\r\n            strcpy(file2,file1);\r\n        if (!*ext2)\r\n            strcpy(ext2,ext1);\r\n        if (strncmp(ext2,\".*\",2)==0)\r\n            strcpy(ext2,ext1);\r\n        for (i = 0;i < strlen(file2); i++)\r\n            if (file2[i] == '?') file2[i] = file1[i];\r\n        for (i = 0;i < strlen(ext2); i++)\r\n            if (ext2[i] == '?') ext2[i] = ext1[i];\r\n        _makepath(dos2,drive2,dir2,file2,ext2);\r\n        cvfs_dos_to_vms(dos2,vms2);\r\n\r\n        if (cop_param->fnew) {\r\n            if (filetstamp(dos1) <= filetstamp(dos2)) {\r\n                goto exit_label;\r\n            }\r\n        }\r\n    }\r\n\r\n    _makepath(directory1,drive1,dir1,NULL,NULL);\r\n    if (SUBDIR) {\r\n        for(i = 1; i < strlen(dir1) && dir1[i] != SLASH_CHR; i++) ;\r\n        if (dir1[i] == SLASH_CHR) i++;\r\n        strcat(dir2, &dir1[i]);\r\n        _makepath(dos2,drive2,dir2,file2,ext2);\r\n    }\r\n    _makepath(directory2,drive2,dir2,NULL,NULL);\r\n\r\n    bFailIfExists = cop_param->replace ? FALSE : TRUE;\r\n    \r\n    (void)_mkdir(directory2);\r\n    if (*file2) {\r\n        nError = filecopy(dos1, dos2, bFailIfExists);\r\n    }\r\n    \r\n    if (nError) {\r\n        (void)dcl_printf(dcl[D].SYS_OUTPUT,\"%s: %s\\n\",vms1,strerror(errno));\r\n        _STATUS = nError;\r\n        _SEVERITY = 2;\r\n        retcod = DCL_ERROR;\r\n    }\r\n    else {\r\n        cop_param->file_copied++;\r\n        if (cop_param->log) {\r\n            cvfs_dos_to_vms(dos2,vms0);\r\n            (void)dcl_printf(dcl[D].SYS_OUTPUT,\"%s copied to %s.\\n\",vms1,vms0);\r\n        }\r\n    }\r\n\r\nexit_label:\r\n    return(retcod);\r\n}", "item_id": 2, "repo": "MichelValentin/PC-DCL", "file": "sources/copy.c", "last_update_at": "2022-03-30T03:41:37+00:00", "question_id": "56ad885762aec692d4e27f5426fde4dffabfd8f0_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int vms_copy(char *vms1,char *vms2,COP_PARAM *cop_param)\r\n{\r\n    int     bFailIfExists   = FALSE;\r\n    int     nError          = 0;\r\n    char    dos1[MAX_TOKEN];\r\n    char    dos2[MAX_TOKEN];\r\n    char    vms0[MAX_TOKEN];\r\n    char    directory1[_MAX_PATH];\r\n    char    directory2[_MAX_PATH];\r\n    char    drive1[_MAX_DRIVE];\r\n    char    dir1[_MAX_DIR];\r\n    char    file1[_MAX_FNAME];\r\n    char    ext1[_MAX_EXT];\r\n    char    drive2[_MAX_DRIVE];\r\n    char    dir2[_MAX_DIR];\r\n    char    file2[_MAX_FNAME];\r\n    char    ext2[_MAX_EXT];\r\n    size_t  i = 0;\r\n    int    retcod = DCL_OK;\r\n\r\n    *dos1 = 0; *drive1 = 0; *dir1 = 0; *file1 = 0; *ext1 =0; *directory1 = 0;\r\n    *dos2 = 0; *drive2 = 0; *dir2 = 0; *file2 = 0; *ext2 =0; *directory2 = 0;\r\n\r\n    cvfs_vms_to_dos(vms1,dos1,(int *)&i);\r\n    _splitpath(dos1,drive1,dir1,file1,ext1);\r\n    cvfs_vms_to_dos(vms2,dos2,(int *)&i);\r\n    if (isdir(dos2) && dos2[strlen(dos2)-1] != SLASH_CHR)\r\n            strcat(dos2,SLASH_STR);\r\n    if (dos1[strlen(dos1)-1] == SLASH_CHR)\r\n        dos1[strlen(dos1)-1] = '\\0';\r\n    if (!cvfs_check_device(dos2)) {\r\n        _splitpath(dos2,drive2,dir2,file2,ext2);\r\n        if (!*file2)\r\n            strcpy(file2,file1);\r\n        if (*file2 == '*')\r\n            strcpy(file2,file1);\r\n        if (!*ext2)\r\n            strcpy(ext2,ext1);\r\n        if (strncmp(ext2,\".*\",2)==0)\r\n            strcpy(ext2,ext1);\r\n        for (i = 0;i < strlen(file2); i++)\r\n            if (file2[i] == '?') file2[i] = file1[i];\r\n        for (i = 0;i < strlen(ext2); i++)\r\n            if (ext2[i] == '?') ext2[i] = ext1[i];\r\n        _makepath(dos2,drive2,dir2,file2,ext2);\r\n        cvfs_dos_to_vms(dos2,vms2);\r\n\r\n        if (cop_param->fnew) {\r\n            if (filetstamp(dos1) <= filetstamp(dos2)) {\r\n                goto exit_label;\r\n            }\r\n        }\r\n    }\r\n\r\n    _makepath(directory1,drive1,dir1,NULL,NULL);\r\n    if (SUBDIR) {\r\n        for(i = 1; i < strlen(dir1) && dir1[i] != SLASH_CHR; i++) ;\r\n        if (dir1[i] == SLASH_CHR) i++;\r\n        strcat(dir2, &dir1[i]);\r\n        _makepath(dos2,drive2,dir2,file2,ext2);\r\n    }\r\n    _makepath(directory2,drive2,dir2,NULL,NULL);\r\n\r\n    bFailIfExists = cop_param->replace ? FALSE : TRUE;\r\n    \r\n    (void)_mkdir(directory2);\r\n    if (*file2) {\r\n        nError = filecopy(dos1, dos2, bFailIfExists);\r\n    }\r\n    \r\n    if (nError) {\r\n        (void)dcl_printf(dcl[D].SYS_OUTPUT,\"%s: %s\\n\",vms1,strerror(errno));\r\n        _STATUS = nError;\r\n        _SEVERITY = 2;\r\n        retcod = DCL_ERROR;\r\n    }\r\n    else {\r\n        cop_param->file_copied++;\r\n        if (cop_param->log) {\r\n            cvfs_dos_to_vms(dos2,vms0);\r\n            (void)dcl_printf(dcl[D].SYS_OUTPUT,\"%s copied to %s.\\n\",vms1,vms0);\r\n        }\r\n    }\r\n\r\nexit_label:\r\n    return(retcod);\r\n"]]}
{"hexsha": "97fbab78f01e25d53e03944d258948154eb55da1", "ext": "c", "lang": "C", "content": "int zpicscale(sbuf,data,mp,mptype,sclat,sclon,nl,ns,pbuf,line,samp)\ndouble *sbuf;\t\t/* input SPICE buffer */\nfloat  *data;           /* input 40-word geometry buffer for PPROJ call */\nMP      mp;\t\t/* Pointer to map projection data */\nint     mptype;         /* Map projection type */\ndouble  sclat,sclon;\t/* spacecraft latitude/longitude */\nint     nl,ns;\t\t/* size of input image */\nfloat  *pbuf;\t\t/* output buffer */\ndouble *line,*samp;\t/* output coordinates at which scale applies */\n{\n\n   double  fl,oal,oas,scale;\n   float  srange;\n   double scrange,sunrange;\t/* spacecraft and sun range from targ center */\n   double vsc[3],vsun[3];\t/* spacecraft and solar vectors */\n   double om[3][3];\t\t/* tranformation from target to camera coords */\n   double ra,rb,rc;\t/* radii for triaxial ellipse */\n   double re,rp;\t/* equatorial and polar radius */\n   double pcl,pcs;\t/* line,rsamp of planet center */\n   double rnl,rns;\t/* number of lines and samples in image */\n   double rsamp,rline;\n   double rlat,rlon,rlat2,rlon2;\n   double p[3],na,noraz,sunaz,scaz,sunlat,sunlon;\n   double hscale,vscale,hscale_pc,vscale_pc;\n   double lora;\t\t/* longitude of semi-major axis (unknown) */\n   double gcr;\t\t/* geocentric radius */\n   double x,y,z,d;\n   int    inc,ind,ind1,ind2,ind3,ind4;\n   int    ibeg,iend,i,use_pc;\n   char   projection[mpMAX_KEYWD_LENGTH];\n   char   direction[mpMAX_KEYWD_LENGTH];\n\t   /*  INITIALIZE VARIABLES */\n   for (i=0; i<6; i++) *(pbuf+i) = -999.0; \n   hscale = 1.0e+20;\t\t/* initialize as invalid scale */\n   vscale = 1.0e+20;\n   rnl = (double) nl; \n   rns = (double) ns; \n\n   if (mptype!=7 && mptype!=8) {\n      ind = mpGetValues(mp,\"MAP_PROJECTION_TYPE\",projection,\"\");   \n      if (strncmp(projection,\"POINT_PERSPECTIVE\",17)==0) {\n         mptype = 16;\n         mpMpo2Buf(mp,data);\n         sclat = data[30];\n         sclon = data[31];\n      }\n   }\n\t/* If image is map projected, compute scale at center of image */\n   if (mptype != 7 && mptype != 8 && mptype != 16) {\n      ind = mpGetValues(mp,\"A_AXIS_RADIUS\",&ra,\"\");   \n      if (ind != mpSUCCESS) goto ERROR1;\n      ind = mpGetValues(mp,\"B_AXIS_RADIUS\",&rb,\"\");   \n      if (ind != mpSUCCESS) goto ERROR1;\n      ind = mpGetValues(mp,\"C_AXIS_RADIUS\",&rc,\"\");   \n      if (ind != mpSUCCESS) goto ERROR1;\n      ind = mpGetValues(mp,\"POSITIVE_LONGITUDE_DIRECTION\",direction,\"\");\n      *line = (double) nl/2.0;\t\t/* line,samp at center of image */\n      *samp = (double) ns/2.0;\n      rline = (double) *line; \n      rsamp = (double) *samp;\n      ind = mpxy2ll(mp,rline,rsamp,&rlat,&rlon,1);\n      if (ind != mpSUCCESS) goto ERROR2;\n      if (strncmp(direction,\"WEST\",4)==0) rlon=360.-rlon;\n      ind = mpxy2ll(mp,rline,rsamp+1.0,&rlat2,&rlon2,1);\n      if (ind == mpSUCCESS) {\n         if (strncmp(direction,\"WEST\",4)==0) rlon2=360.-rlon2;\n         picscal3(rlat,rlon,rlat2,rlon2,ra,rb,rc,&hscale);\n         pbuf[0] = (float) hscale;\n      }\n      ind = mpxy2ll(mp,rline+1.0,rsamp,&rlat2,&rlon2,1);\n      if (ind == mpSUCCESS) {\n         if (strncmp(direction,\"WEST\",4)==0) rlon2=360.-rlon2;\n         picscal3(rlat,rlon,rlat2,rlon2,ra,rb,rc,&vscale);\n         pbuf[1]=(float) vscale;\n      }\n      return ind;\n   }\n\n/* Here if mptype=7, 8, or 16 (image or object space).  Geometric camera\n   distortions will be ignored (image is treated as object-space frame). */\n\n   zmve(8,9,(sbuf+58),om,1,1);\n   zmve(8,3,(sbuf+21),vsc,1,1);\n   ra = *(sbuf+12);\n   rb = *(sbuf+13);\n   rc = *(sbuf+14);\n   fl = data[26];\n   oal = data[27];\n   oas = data[28];\n   scale = data[29];\n   re = (double) data[25];\t\t/* equitorial radius (km) */\n   rp = (double) data[24];\t\t/* polar radius */\n\t/* See if all four corners are on the target body... */\n   ind1 = psxy2ll(data,1.,1.,&rlat,&rlon,&srange);  /* upper left corner */\n   ind2 = psxy2ll(data,1.,rns,&rlat,&rlon,&srange); /* upper right corner */\n   ind3 = psxy2ll(data,rnl,1.,&rlat,&rlon,&srange); /* lower left corner */\n   ind4 = psxy2ll(data,rnl,rns,&rlat,&rlon,&srange);/* lower right corner */\n   use_pc = 0; \n\t/* If all 4 corners are on planet, image is high-resolution */\n\t/* compute scale at center of image */\n   if (ind1==1 && ind2==1 && ind3==1 && ind4==1) { \n      *line = (double) nl/2.0;\t\t/* line,samp at center of image */\n      *samp = (double) ns/2.0;\n      rline = (double) *line; \n      rsamp = (double) *samp;\n      ind1 = psxy2ll(data,rline,rsamp,&rlat,&rlon,&srange);\n      ind2 = psxy2ll(data,rline,rsamp+1.,&rlat2,&rlon2,&srange);\n      picscal2(rlat,rlon,rlat2,rlon2,re,rp,&hscale); \n      ind3 = psxy2ll(data,rline+1.,rsamp,&rlat2,&rlon2,&srange);\n      picscal2(rlat,rlon,rlat2,rlon2,re,rp,&vscale); \n      goto COMPUTE_AZIMUTHS;\n   }\n\t/* Here if 4 corners not on planet (low-resolution image */\n\t/* Calculate scale at planet center */\n   ind = psll2xy(data,sclat,sclon,&pcl,&pcs);\n   if (ind != 1) return ind;\n   ind = psxy2ll(data,pcl,pcs+0.1,&rlat2,&rlon2,&srange);\n   if (ind != 1) return ind;\n   picscal2(sclat,sclon,rlat2,rlon2,re,rp,&hscale_pc);\t/* horizontal scale */\n   hscale_pc*=10.0; /* To accomodate for pcl+0.1 */\n   ind = psxy2ll(data,pcl+0.1,pcs,&rlat2,&rlon2,&srange);\n   if (ind != 1) return ind;\n   picscal2(sclat,sclon,rlat2,rlon2,re,rp,&vscale_pc); \t/* vertical scale */\n   vscale_pc*=10.0; /* To accomodate for pcl+0.1 */\n   use_pc = 1;\n\t/* If PC is in the image, use scale at PC */\n   if (pcl>0 && pcs>0 && pcl<=rnl && pcs<rns) goto COMPUTE_AZIMUTHS;\n\t/* If the target is smaller than the width of image, use scale at PC */\n   if (1000.*re/hscale > rnl) goto COMPUTE_AZIMUTHS;\n\n\t/* Search margin of image for point on planet with the\n\t   largest scale */\n   inc = 20;\t\t\t/* margin search increment is 20 pixels */\n   if (pcl < pcs) {\t\t/* top or right margin */\n      if (pcl < rns-pcs) {\t/* top margin */\n         *line = 1; \n         if (pcs < 1.0) {\t/* top-left corner */\n            ibeg = 1; \n            iend = 1; \n         } \n         else if (pcs > rns) {  /* top-right corner */\n            ibeg = ns; \n            iend = ns; \n         } \n         else {\t\t\t/* entire top margin */\n            ibeg = 1; \n            iend = ns; \n         } \n             /* Search for smallest scale along margin */\n         rline = 1.0;\n         for (i=ibeg; i<=iend; i+=inc) { \n             rsamp = (double) i; \n             ind = picscal1(data,rline,rsamp,re,rp,&hscale);\n             if (ind == 1) *samp = i;\n         } \n      }\n\n      else {\t\t\t/* Right margin */\n         *samp = ns;\n         if (pcl < 1.0) {\t/* top-right corner */\n            ibeg = 1; \n            iend = 1; \n         } \n         else if (pcl > rnl) {\t/* bottom-right corner */\n            ibeg = nl; \n            iend = nl; \n         } \n         else { \t\t/* entire right margin */\n            ibeg = 1; \n            iend = nl; \n         } \n\n            /* Search for smallest scale along margin */\n         rsamp = rns;\n         for (i=ibeg; i<=iend; i+=inc) { \n            rline = (double) i; \n            ind = picscal1(data,rline,rsamp,re,rp,&hscale);\n            if (ind == 1) *line = i;\n         } \n      } \n   }\n\n   else {                     /* left or bottom margins */\n       if (pcs < rnl-pcl) {   /* left margin */\n          *samp = 1; \n          if (pcl < 1.0) {        /* top-left corner */\n             ibeg = 1; \n             iend = 1; \n          }\n          else if (pcl > rnl) {    /* bottom-left corner */\n             ibeg = nl; \n             iend = nl; \n          }\n          else { \n             ibeg = 1; \n             iend = nl; \n          } \n                    /* search for smallest scale along margin */\n          rsamp = 1.0;\n          for (i=ibeg; i<=iend; i+=inc) { \n             rline = (double) i; \n             ind = picscal1(data,rline,rsamp,re,rp,&hscale);\n             if (ind == 1) *line = i; \n          } \n       }\n       else { \n           *line = nl; \n           if (pcs < 1.0) {         /* bottom-left corner */\n              ibeg = 1; \n              iend = 1; \n           } \n           else if (pcs > rns) {  /* bottom-right corner */\n               ibeg = ns; \n               iend = ns; \n           } \n           else { \n               ibeg = 1; \n               iend = ns; \n           } \n\n                   /* search for smallest scale along margin */\n           rline = rnl;\n           for (i=ibeg; i<=iend; i+=inc) { \n              rsamp =(double) i; \n              ind = picscal1(data,rline,rsamp,re,rp,&hscale);\n              if(ind == 1) *samp = i;\n           } \n        } \n     } \n\n   if (hscale < 1.0e+20) {\n      rline = (double) *line; \n      rsamp = (double) *samp; \n      ind = psxy2ll(data,rline,rsamp,&rlat,&rlon,&srange);\n      if (ind != 1) return ind;\n      ind = psxy2ll(data,rline+1.,rsamp,&rlat2,&rlon2,&srange); \n      if (ind != 1) return ind;\n      picscal2(rlat,rlon,rlat2,rlon2,re,rp,&vscale); \n      use_pc = 0;\n   }\n\nCOMPUTE_AZIMUTHS:\n   if (use_pc==1) {\n      *line = pcl; \n      *samp = pcs; \n      hscale = hscale_pc;\n      vscale = vscale_pc;\n      zvmessage(\"Picture scale calculated at target center\",\"\");\n   }\n   *(pbuf+0) = (float) hscale;\t/* horizontal scale in meters/pixel */\n   *(pbuf+1) = (float) vscale;  /* vertical scale in meters/pixel */\n\n\t/* Compute north angle */\n   na = atan2(om[2][1],om[2][0])*zdpr();\n   if (na < 0.) na=na+360.;\n   *(pbuf+2) =(float) na;\n\n\t/* Compute vector to surface point */\n   rline = *line;\n   rsamp = *samp;\n   if (use_pc==1) {\n      rline = pcl; \n      rsamp = pcs; \n   }\n   ind = zellipse_inv(om,vsc,fl,oal,oas,scale,ra,rb,rc,rline,rsamp,p);\n\n\t/* Compute solar vector */\n   sunrange = *(sbuf+24);\t\t/* sun distance to target center */\n   sunlat = *(sbuf+27)*zrpd();\t\t/* Subsolar geocentric latitude */\n   sunlon = (360.0 - *(sbuf+28))*zrpd(); /* Subsolar east longitude */\n   vsun[0] = sunrange*cos(sunlat)*cos(sunlon);\n   vsun[1] = sunrange*cos(sunlat)*sin(sunlon);\n   vsun[2] = sunrange*sin(sunlat);\n\n   zazimuth(om,p,vsc,vsun,ra,rb,rc,use_pc,&noraz,&scaz,&sunaz);\n   *(pbuf+3) = (float) sunaz;\n   *(pbuf+4) = (float) scaz;\n   *(pbuf+5) = srange;\n   *(pbuf+6) =(float) noraz;\n\n\t/* Compute lat,lon at surface point */\n   x = p[0];\n   y = p[1];\n   z = p[2];\n   d = sqrt(x*x + y*y);\n   rlat = atan2(z,d)*zdpr();\n   rlon = - atan2(y,x)*zdpr();\n   if (rlon < 0.) rlon=rlon+360.;\n   *(pbuf+7) = (float) rlat;\n   *(pbuf+8) = (float) rlon;\n   return ind;\n\nERROR1:\n   zvmessage(\"***Error calling mpGetValues\",\"PICSCALE\");\n   return ind;   \n\nERROR2:\n   zvmessage(\"***Error calling mpxy2ll\",\"PICSCALE\");\n   return ind;\n}", "item_id": 0, "repo": "NASA-AMMOS/VICAR", "file": "vos/p2/sub/picscale/picscale.c", "last_update_at": "2022-03-31T10:02:01+00:00", "question_id": "97fbab78f01e25d53e03944d258948154eb55da1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int zpicscale(sbuf,data,mp,mptype,sclat,sclon,nl,ns,pbuf,line,samp)\ndouble *sbuf;\t\t/* input SPICE buffer */\nfloat  *data;           /* input 40-word geometry buffer for PPROJ call */\nMP      mp;\t\t/* Pointer to map projection data */\nint     mptype;         /* Map projection type */\ndouble  sclat,sclon;\t/* spacecraft latitude/longitude */\nint     nl,ns;\t\t/* size of input image */\nfloat  *pbuf;\t\t/* output buffer */\ndouble *line,*samp;\t/* output coordinates at which scale applies */\n{\n   double  fl,oal,oas,scale;\n   float  srange;\n   double scrange,sunrange;\t/* spacecraft and sun range from targ center */\n   double vsc[3],vsun[3];\t/* spacecraft and solar vectors */\n   double om[3][3];\t\t/* tranformation from target to camera coords */\n   double ra,rb,rc;\t/* radii for triaxial ellipse */\n   double re,rp;\t/* equatorial and polar radius */\n   double pcl,pcs;\t/* line,rsamp of planet center */\n   double rnl,rns;\t/* number of lines and samples in image */\n   double rsamp,rline;\n   double rlat,rlon,rlat2,rlon2;\n   double p[3],na,noraz,sunaz,scaz,sunlat,sunlon;\n   double hscale,vscale,hscale_pc,vscale_pc;\n   double lora;\t\t/* longitude of semi-major axis (unknown) */\n   double gcr;\t\t/* geocentric radius */\n   double x,y,z,d;\n   int    inc,ind,ind1,ind2,ind3,ind4;\n   int    ibeg,iend,i,use_pc;\n   char   projection[mpMAX_KEYWD_LENGTH];\n   char   direction[mpMAX_KEYWD_LENGTH];\n\t   /*  INITIALIZE VARIABLES */\n   for (i=0; i<6; i++) *(pbuf+i) = -999.0; \n   hscale = 1.0e+20;\t\t/* initialize as invalid scale */\n   vscale = 1.0e+20;\n   rnl = (double) nl; \n   rns = (double) ns; \n   if (mptype!=7 && mptype!=8) {\n      ind = mpGetValues(mp,\"MAP_PROJECTION_TYPE\",projection,\"\");   \n      if (strncmp(projection,\"POINT_PERSPECTIVE\",17)==0) {\n         mptype = 16;\n         mpMpo2Buf(mp,data);\n         sclat = data[30];\n         sclon = data[31];\n      }\n   }\n\t/* If image is map projected, compute scale at center of image */\n   if (mptype != 7 && mptype != 8 && mptype != 16) {\n      ind = mpGetValues(mp,\"A_AXIS_RADIUS\",&ra,\"\");   \n      if (ind != mpSUCCESS) goto ERROR1;\n      ind = mpGetValues(mp,\"B_AXIS_RADIUS\",&rb,\"\");   \n      if (ind != mpSUCCESS) goto ERROR1;\n      ind = mpGetValues(mp,\"C_AXIS_RADIUS\",&rc,\"\");   \n      if (ind != mpSUCCESS) goto ERROR1;\n      ind = mpGetValues(mp,\"POSITIVE_LONGITUDE_DIRECTION\",direction,\"\");\n      *line = (double) nl/2.0;\t\t/* line,samp at center of image */\n      *samp = (double) ns/2.0;\n      rline = (double) *line; \n      rsamp = (double) *samp;\n      ind = mpxy2ll(mp,rline,rsamp,&rlat,&rlon,1);\n      if (ind != mpSUCCESS) goto ERROR2;\n      if (strncmp(direction,\"WEST\",4)==0) rlon=360.-rlon;\n      ind = mpxy2ll(mp,rline,rsamp+1.0,&rlat2,&rlon2,1);\n      if (ind == mpSUCCESS) {\n         if (strncmp(direction,\"WEST\",4)==0) rlon2=360.-rlon2;\n         picscal3(rlat,rlon,rlat2,rlon2,ra,rb,rc,&hscale);\n         pbuf[0] = (float) hscale;\n      }\n      ind = mpxy2ll(mp,rline+1.0,rsamp,&rlat2,&rlon2,1);\n      if (ind == mpSUCCESS) {\n         if (strncmp(direction,\"WEST\",4)==0) rlon2=360.-rlon2;\n         picscal3(rlat,rlon,rlat2,rlon2,ra,rb,rc,&vscale);\n         pbuf[1]=(float) vscale;\n      }\n      return ind;\n   }\n/* Here if mptype=7, 8, or 16 (image or object space).  Geometric camera\n   distortions will be ignored (image is treated as object-space frame). */\n   zmve(8,9,(sbuf+58),om,1,1);\n   zmve(8,3,(sbuf+21),vsc,1,1);\n   ra = *(sbuf+12);\n   rb = *(sbuf+13);\n   rc = *(sbuf+14);\n   fl = data[26];\n   oal = data[27];\n   oas = data[28];\n   scale = data[29];\n   re = (double) data[25];\t\t/* equitorial radius (km) */\n   rp = (double) data[24];\t\t/* polar radius */\n\t/* See if all four corners are on the target body... */\n   ind1 = psxy2ll(data,1.,1.,&rlat,&rlon,&srange);  /* upper left corner */\n   ind2 = psxy2ll(data,1.,rns,&rlat,&rlon,&srange); /* upper right corner */\n   ind3 = psxy2ll(data,rnl,1.,&rlat,&rlon,&srange); /* lower left corner */\n   ind4 = psxy2ll(data,rnl,rns,&rlat,&rlon,&srange);/* lower right corner */\n   use_pc = 0; \n\t/* If all 4 corners are on planet, image is high-resolution */\n\t/* compute scale at center of image */\n   if (ind1==1 && ind2==1 && ind3==1 && ind4==1) { \n      *line = (double) nl/2.0;\t\t/* line,samp at center of image */\n      *samp = (double) ns/2.0;\n      rline = (double) *line; \n      rsamp = (double) *samp;\n      ind1 = psxy2ll(data,rline,rsamp,&rlat,&rlon,&srange);\n      ind2 = psxy2ll(data,rline,rsamp+1.,&rlat2,&rlon2,&srange);\n      picscal2(rlat,rlon,rlat2,rlon2,re,rp,&hscale); \n      ind3 = psxy2ll(data,rline+1.,rsamp,&rlat2,&rlon2,&srange);\n      picscal2(rlat,rlon,rlat2,rlon2,re,rp,&vscale); \n      goto COMPUTE_AZIMUTHS;\n   }\n\t/* Here if 4 corners not on planet (low-resolution image */\n\t/* Calculate scale at planet center */\n   ind = psll2xy(data,sclat,sclon,&pcl,&pcs);\n   if (ind != 1) return ind;\n   ind = psxy2ll(data,pcl,pcs+0.1,&rlat2,&rlon2,&srange);\n   if (ind != 1) return ind;\n   picscal2(sclat,sclon,rlat2,rlon2,re,rp,&hscale_pc);\t/* horizontal scale */\n   hscale_pc*=10.0; /* To accomodate for pcl+0.1 */\n   ind = psxy2ll(data,pcl+0.1,pcs,&rlat2,&rlon2,&srange);\n   if (ind != 1) return ind;\n   picscal2(sclat,sclon,rlat2,rlon2,re,rp,&vscale_pc); \t/* vertical scale */\n   vscale_pc*=10.0; /* To accomodate for pcl+0.1 */\n   use_pc = 1;\n\t/* If PC is in the image, use scale at PC */\n   if (pcl>0 && pcs>0 && pcl<=rnl && pcs<rns) goto COMPUTE_AZIMUTHS;\n\t/* If the target is smaller than the width of image, use scale at PC */\n   if (1000.*re/hscale > rnl) goto COMPUTE_AZIMUTHS;\n\t/* Search margin of image for point on planet with the\n\t   largest scale */\n   inc = 20;\t\t\t/* margin search increment is 20 pixels */\n   if (pcl < pcs) {\t\t/* top or right margin */\n      if (pcl < rns-pcs) {\t/* top margin */\n         *line = 1; \n         if (pcs < 1.0) {\t/* top-left corner */\n            ibeg = 1; \n            iend = 1; \n         } \n         else if (pcs > rns) {  /* top-right corner */\n            ibeg = ns; \n            iend = ns; \n         } \n         else {\t\t\t/* entire top margin */\n            ibeg = 1; \n            iend = ns; \n         } \n             /* Search for smallest scale along margin */\n         rline = 1.0;\n         for (i=ibeg; i<=iend; i+=inc) { \n             rsamp = (double) i; \n             ind = picscal1(data,rline,rsamp,re,rp,&hscale);\n             if (ind == 1) *samp = i;\n         } \n      }\n      else {\t\t\t/* Right margin */\n         *samp = ns;\n         if (pcl < 1.0) {\t/* top-right corner */\n            ibeg = 1; \n            iend = 1; \n         } \n         else if (pcl > rnl) {\t/* bottom-right corner */\n            ibeg = nl; \n            iend = nl; \n         } \n         else { \t\t/* entire right margin */\n            ibeg = 1; \n            iend = nl; \n         } \n            /* Search for smallest scale along margin */\n         rsamp = rns;\n         for (i=ibeg; i<=iend; i+=inc) { \n            rline = (double) i; \n            ind = picscal1(data,rline,rsamp,re,rp,&hscale);\n            if (ind == 1) *line = i;\n         } \n      } \n   }\n   else {                     /* left or bottom margins */\n       if (pcs < rnl-pcl) {   /* left margin */\n          *samp = 1; \n          if (pcl < 1.0) {        /* top-left corner */\n             ibeg = 1; \n             iend = 1; \n          }\n          else if (pcl > rnl) {    /* bottom-left corner */\n             ibeg = nl; \n             iend = nl; \n          }\n          else { \n             ibeg = 1; \n             iend = nl; \n          } \n                    /* search for smallest scale along margin */\n          rsamp = 1.0;\n          for (i=ibeg; i<=iend; i+=inc) { \n             rline = (double) i; \n             ind = picscal1(data,rline,rsamp,re,rp,&hscale);\n             if (ind == 1) *line = i; \n          } \n       }\n       else { \n           *line = nl; \n           if (pcs < 1.0) {         /* bottom-left corner */\n              ibeg = 1; \n              iend = 1; \n           } \n           else if (pcs > rns) {  /* bottom-right corner */\n               ibeg = ns; \n               iend = ns; \n           } \n           else { \n               ibeg = 1; \n               iend = ns; \n           } \n                   /* search for smallest scale along margin */\n           rline = rnl;\n           for (i=ibeg; i<=iend; i+=inc) { \n              rsamp =(double) i; \n              ind = picscal1(data,rline,rsamp,re,rp,&hscale);\n              if(ind == 1) *samp = i;\n           } \n        } \n     } \n   if (hscale < 1.0e+20) {\n      rline = (double) *line; \n      rsamp = (double) *samp; \n      ind = psxy2ll(data,rline,rsamp,&rlat,&rlon,&srange);\n      if (ind != 1) return ind;\n      ind = psxy2ll(data,rline+1.,rsamp,&rlat2,&rlon2,&srange); \n      if (ind != 1) return ind;\n      picscal2(rlat,rlon,rlat2,rlon2,re,rp,&vscale); \n      use_pc = 0;\n   }\nCOMPUTE_AZIMUTHS:\n   if (use_pc==1) {\n      *line = pcl; \n      *samp = pcs; \n      hscale = hscale_pc;\n      vscale = vscale_pc;\n      zvmessage(\"Picture scale calculated at target center\",\"\");\n   }\n   *(pbuf+0) = (float) hscale;\t/* horizontal scale in meters/pixel */\n   *(pbuf+1) = (float) vscale;  /* vertical scale in meters/pixel */\n\t/* Compute north angle */\n   na = atan2(om[2][1],om[2][0])*zdpr();\n   if (na < 0.) na=na+360.;\n   *(pbuf+2) =(float) na;\n\t/* Compute vector to surface point */\n   rline = *line;\n   rsamp = *samp;\n   if (use_pc==1) {\n      rline = pcl; \n      rsamp = pcs; \n   }\n   ind = zellipse_inv(om,vsc,fl,oal,oas,scale,ra,rb,rc,rline,rsamp,p);\n\t/* Compute solar vector */\n   sunrange = *(sbuf+24);\t\t/* sun distance to target center */\n   sunlat = *(sbuf+27)*zrpd();\t\t/* Subsolar geocentric latitude */\n   sunlon = (360.0 - *(sbuf+28))*zrpd(); /* Subsolar east longitude */\n   vsun[0] = sunrange*cos(sunlat)*cos(sunlon);\n   vsun[1] = sunrange*cos(sunlat)*sin(sunlon);\n   vsun[2] = sunrange*sin(sunlat);\n   zazimuth(om,p,vsc,vsun,ra,rb,rc,use_pc,&noraz,&scaz,&sunaz);\n   *(pbuf+3) = (float) sunaz;\n   *(pbuf+4) = (float) scaz;\n   *(pbuf+5) = srange;\n   *(pbuf+6) =(float) noraz;\n\t/* Compute lat,lon at surface point */\n   x = p[0];\n   y = p[1];\n   z = p[2];\n   d = sqrt(x*x + y*y);\n   rlat = atan2(z,d)*zdpr();\n   rlon = - atan2(y,x)*zdpr();\n   if (rlon < 0.) rlon=rlon+360.;\n   *(pbuf+7) = (float) rlat;\n   *(pbuf+8) = (float) rlon;\n   return ind;\nERROR1:\n   zvmessage(\"***Error calling mpGetValues\",\"PICSCALE\");\n   return ind;   \nERROR2:\n   zvmessage(\"***Error calling mpxy2ll\",\"PICSCALE\");\n   return ind;\n"]]}
{"hexsha": "bdcf0f0ae7f6d8f0f28db91e764eaa6ef976a7aa", "ext": "c", "lang": "C", "content": "int pa__get_n_used(pa_module *m) {\n    struct userdata *u;\n\n    pa_assert(m);\n    pa_assert_se(u = m->userdata);\n\n    return pa_sink_linked_by(u->sink);\n}", "item_id": 14, "repo": "AMDmi3/termux-packages", "file": "packages/pulseaudio/module-sles-sink.c", "last_update_at": "2022-03-31T23:52:53+00:00", "question_id": "bdcf0f0ae7f6d8f0f28db91e764eaa6ef976a7aa_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int pa__get_n_used(pa_module *m) {\n    struct userdata *u;\n    pa_assert(m);\n    pa_assert_se(u = m->userdata);\n    return pa_sink_linked_by(u->sink);\n"]]}
{"hexsha": "9e7b342880f8953d28f7cd2f82e7b327dfacdf71", "ext": "c", "lang": "C", "content": "static\nDWORD\nPrintToRegFile(\n    IN FILE* fp,\n    IN PCSTR pszKeyName,\n    IN OPTIONAL PCSTR pszSddlCString,\n    IN REG_DATA_TYPE dataType,\n    IN PCSTR pszValueName,\n    IN REG_DATA_TYPE type,\n    IN BOOLEAN bDefault,\n    IN PVOID value,\n    IN DWORD dwValueLen,\n    OUT PREG_DATA_TYPE pPrevType\n    )\n{\n    PSTR dumpString = NULL;\n    DWORD dumpStringLen = 0;\n    PSTR pszStart = NULL;\n    PSTR pszEnd = NULL;\n    PSTR pszComment = bDefault ? \"#\" : \"\";\n\n    RegExportEntry(pszKeyName,\n                   pszSddlCString,\n                   dataType,\n                   pszValueName,\n                   type,\n                   value,\n                   dwValueLen,\n                   &dumpString,\n                   &dumpStringLen);\n\n   if (dumpStringLen > 0 && dumpString)\n   {\n       switch (type)\n       {\n           case REG_KEY:\n               fprintf(fp, \"\\r\\n%s%.*s\\r\\n\", \n                       pszComment, dumpStringLen, dumpString);\n               break;\n\n           case REG_MULTI_SZ:\n               pszStart = dumpString;\n               pszEnd = strchr(pszStart, '\\n');\n               while (pszEnd)\n               {\n                   fprintf(fp, \"%s%.*s\\r\\n\", \n                           pszComment, (int) (pszEnd-pszStart), pszStart);\n                   pszStart = pszEnd+1;\n                   pszEnd = strchr(pszStart, '\\n');\n               }\n               if (pszStart && *pszStart)\n               {\n                   fprintf(fp, \"%s%s\\r\\n\", \n                           pszComment, pszStart);\n               }\n               break;\n\n           case REG_PLAIN_TEXT:\n               if (*pPrevType && *pPrevType != type)\n               {\n                   printf(\"\\n\");\n               }\n               fprintf(fp, \"%s%*s \", pszComment, dwValueLen, (PCHAR) value);\n               break;\n\n           default:\n               fprintf(fp, \"%s%.*s\\r\\n\", pszComment, dumpStringLen, dumpString);\n               break;\n       }\n   }\n   fflush(stdout);\n   *pPrevType = type;\n\n   if (dumpString)\n   {\n       RegMemoryFree(dumpString);\n       dumpString = NULL;\n   }\n\n   return 0;\n}", "item_id": 1, "repo": "kbore/pbis-open", "file": "lwreg/shell/export.c", "last_update_at": "2022-03-18T19:54:37+00:00", "question_id": "9e7b342880f8953d28f7cd2f82e7b327dfacdf71_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static\nDWORD\nPrintToRegFile(\n    IN FILE* fp,\n    IN PCSTR pszKeyName,\n    IN OPTIONAL PCSTR pszSddlCString,\n    IN REG_DATA_TYPE dataType,\n    IN PCSTR pszValueName,\n    IN REG_DATA_TYPE type,\n    IN BOOLEAN bDefault,\n    IN PVOID value,\n    IN DWORD dwValueLen,\n    OUT PREG_DATA_TYPE pPrevType\n    )\n{\n    PSTR dumpString = NULL;\n    DWORD dumpStringLen = 0;\n    PSTR pszStart = NULL;\n    PSTR pszEnd = NULL;\n    PSTR pszComment = bDefault ? \"#\" : \"\";\n    RegExportEntry(pszKeyName,\n                   pszSddlCString,\n                   dataType,\n                   pszValueName,\n                   type,\n                   value,\n                   dwValueLen,\n                   &dumpString,\n                   &dumpStringLen);\n   if (dumpStringLen > 0 && dumpString)\n   {\n       switch (type)\n       {\n           case REG_KEY:\n               fprintf(fp, \"\\r\\n%s%.*s\\r\\n\", \n                       pszComment, dumpStringLen, dumpString);\n               break;\n           case REG_MULTI_SZ:\n               pszStart = dumpString;\n               pszEnd = strchr(pszStart, '\\n');\n               while (pszEnd)\n               {\n                   fprintf(fp, \"%s%.*s\\r\\n\", \n                           pszComment, (int) (pszEnd-pszStart), pszStart);\n                   pszStart = pszEnd+1;\n                   pszEnd = strchr(pszStart, '\\n');\n               }\n               if (pszStart && *pszStart)\n               {\n                   fprintf(fp, \"%s%s\\r\\n\", \n                           pszComment, pszStart);\n               }\n               break;\n           case REG_PLAIN_TEXT:\n               if (*pPrevType && *pPrevType != type)\n               {\n                   printf(\"\\n\");\n               }\n               fprintf(fp, \"%s%*s \", pszComment, dwValueLen, (PCHAR) value);\n               break;\n           default:\n               fprintf(fp, \"%s%.*s\\r\\n\", pszComment, dumpStringLen, dumpString);\n               break;\n       }\n   }\n   fflush(stdout);\n   *pPrevType = type;\n   if (dumpString)\n   {\n       RegMemoryFree(dumpString);\n       dumpString = NULL;\n   }\n   return 0;\n"]]}
{"hexsha": "ef547420ae3d38f1d803a742cf1c9935a929f98b", "ext": "c", "lang": "C", "content": "uint32_t get_uart_clock(uint32_t instance)\n{\n    // LPUART1 clock has been configured to 20MHz in clock_configure\n    uint32_t lpuart_clock = 20000000UL;\n\n    return lpuart_clock;\n}", "item_id": 3, "repo": "xuji520123/imxrt-tool-flash-algo", "file": "boards/nxp_evkmimxrt1010_rev.c/flash_algo/Keil_JLink_ROM_API/Sources/rom/hardware_init_MIMXRT1011.c", "last_update_at": "2022-02-20T16:10:51+00:00", "question_id": "ef547420ae3d38f1d803a742cf1c9935a929f98b_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint32_t get_uart_clock(uint32_t instance)\n{\n    // LPUART1 clock has been configured to 20MHz in clock_configure\n    uint32_t lpuart_clock = 20000000UL;\n    return lpuart_clock;\n"]]}
{"hexsha": "5ed574a21718b3a426a0c4823e43e0807f8f198a", "ext": "c", "lang": "C", "content": "void socket_ConnectThread(void *argument)\n{\n    osiThreadSetFPUEnabled(true); //\u7ebf\u7a0b\u4f7f\u80fdFPU\n    int32_t retcode;\n    while(true)\n    {\n        if(socket_conSignal)\n        {\n            retcode = fibo_sock_connect(tempsocketid, &tempaddr); //\u6700\u5927\u963b\u585e36s\n            socket_conSignal = 0;\n            if(retcode != 0)\n            {\n                fibo_sock_close(tempsocketid);\n                data_getData()->isSocketConnect = 0;\n                LOG_ERROR(\"socket connect failed: %d\", retcode);\n            }\n            else\n            {\n                data_getData()->isSocketConnect = 1;\n                LOG_DEBUG(\"socket connect success :%d\", tempsocketid);\n                retcode = fibo_sock_lwip_fcntl(tempsocketid, F_SETFL, fibo_sock_lwip_fcntl(tempsocketid, F_GETFL, 0) | O_NONBLOCK);\n                if(retcode != 0)\n                {\n                    fibo_sock_close(tempsocketid);\n                    LOG_ERROR(\"socket set fcntl failed: %d\", retcode);\n                    return;\n                }\n                g_socket.socket_id = tempsocketid; //\u6b63\u5f0fconnect\u6210\u529f\n            }\n        }\n        fibo_taskSleep(500);\n    }\n    fibo_thread_delete();\n}", "item_id": 3, "repo": "moiify/llofo", "file": "src/driver/socket.c", "last_update_at": "2022-02-28T16:11:39+00:00", "question_id": "5ed574a21718b3a426a0c4823e43e0807f8f198a_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void socket_ConnectThread(void *argument)\n{\n    osiThreadSetFPUEnabled(true); //\u7ebf\u7a0b\u4f7f\u80fdFPU\n    int32_t retcode;\n    while(true)\n    {\n        if(socket_conSignal)\n        {\n            retcode = fibo_sock_connect(tempsocketid, &tempaddr); //\u6700\u5927\u963b\u585e36s\n            socket_conSignal = 0;\n            if(retcode != 0)\n            {\n                fibo_sock_close(tempsocketid);\n                data_getData()->isSocketConnect = 0;\n                LOG_ERROR(\"socket connect failed: %d\", retcode);\n            }\n            else\n            {\n                data_getData()->isSocketConnect = 1;\n                LOG_DEBUG(\"socket connect success :%d\", tempsocketid);\n                retcode = fibo_sock_lwip_fcntl(tempsocketid, F_SETFL, fibo_sock_lwip_fcntl(tempsocketid, F_GETFL, 0) | O_NONBLOCK);\n                if(retcode != 0)\n                {\n                    fibo_sock_close(tempsocketid);\n                    LOG_ERROR(\"socket set fcntl failed: %d\", retcode);\n                    return;\n                }\n                g_socket.socket_id = tempsocketid; //\u6b63\u5f0fconnect\u6210\u529f\n            }\n        }\n        fibo_taskSleep(500);\n    }\n    fibo_thread_delete();\n"]]}
{"hexsha": "fc979b203074aa7d050c4d94b74129233d2365fa", "ext": "c", "lang": "C", "content": "BOOL\r\nCheckBufferSize(\r\n    HWND hDlg,\r\n    UINT Item,\r\n    LPLINKDATA pld,\r\n    INT i\r\n    )\r\n/*++\r\n\r\n    Checks to make sure the buffer size is not smaller than the window size\r\n\r\n    Returns: TRUE if preview window should be updated\r\n             FALSE if not\r\n\r\n--*/\r\n{\r\n    BOOL fRet = FALSE;\r\n\r\n    if (!pld)\r\n     return fRet;\r\n\r\n    switch (Item)\r\n    {\r\n\r\n    case IDC_CNSL_SCRBUF_WIDTHSCROLL:\r\n    case IDC_CNSL_SCRBUF_WIDTH:\r\n        if (i >= 1)\r\n        {\r\n            pld->cpd.lpConsole->dwScreenBufferSize.X = (SHORT) i;\r\n            if (pld->cpd.lpConsole->dwWindowSize.X > i)\r\n            {\r\n                pld->cpd.lpConsole->dwWindowSize.X = (SHORT) i;\r\n                SetDlgItemInt( hDlg,\r\n                               IDC_CNSL_WINDOW_WIDTH,\r\n                               pld->cpd.lpConsole->dwWindowSize.X,\r\n                               TRUE\r\n                              );\r\n\r\n                fRet = TRUE;\r\n            }\r\n\r\n        }\r\n        break;\r\n\r\n    case IDC_CNSL_SCRBUF_HEIGHTSCROLL:\r\n    case IDC_CNSL_SCRBUF_HEIGHT:\r\n        if (i >= 1)\r\n        {\r\n            pld->cpd.lpConsole->dwScreenBufferSize.Y = (SHORT) i;\r\n            if (pld->cpd.lpConsole->dwWindowSize.Y > i)\r\n            {\r\n                pld->cpd.lpConsole->dwWindowSize.Y = (SHORT) i;\r\n                SetDlgItemInt( hDlg,\r\n                               IDC_CNSL_WINDOW_HEIGHT,\r\n                               pld->cpd.lpConsole->dwWindowSize.Y,\r\n                               TRUE\r\n                              );\r\n                fRet = TRUE;\r\n            }\r\n        }\r\n        break;\r\n\r\n    case IDC_CNSL_WINDOW_WIDTHSCROLL:\r\n    case IDC_CNSL_WINDOW_WIDTH:\r\n        if (i >= 1)\r\n        {\r\n            pld->cpd.lpConsole->dwWindowSize.X = (SHORT) i;\r\n            if (pld->cpd.lpConsole->dwScreenBufferSize.X < i)\r\n            {\r\n                pld->cpd.lpConsole->dwScreenBufferSize.X = (SHORT) i;\r\n                SetDlgItemInt( hDlg,\r\n                               IDC_CNSL_SCRBUF_WIDTH,\r\n                               pld->cpd.lpConsole->dwScreenBufferSize.X,\r\n                               TRUE\r\n                              );\r\n                fRet = TRUE;\r\n            }\r\n\r\n        }\r\n        break;\r\n\r\n    case IDC_CNSL_WINDOW_HEIGHTSCROLL:\r\n    case IDC_CNSL_WINDOW_HEIGHT:\r\n        if (i >= 1)\r\n        {\r\n            pld->cpd.lpConsole->dwWindowSize.Y = (SHORT) i;\r\n            if (pld->cpd.lpConsole->dwScreenBufferSize.Y < i)\r\n            {\r\n                pld->cpd.lpConsole->dwScreenBufferSize.Y = (SHORT) i;\r\n                SetDlgItemInt( hDlg,\r\n                               IDC_CNSL_SCRBUF_HEIGHT,\r\n                               pld->cpd.lpConsole->dwScreenBufferSize.Y,\r\n                               TRUE\r\n                              );\r\n                fRet = TRUE;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    return fRet;\r\n\r\n}", "item_id": 6, "repo": "King0987654/windows2000", "file": "private/shell/shell32/lnkcon.c", "last_update_at": "2022-01-02T15:25:24+00:00", "question_id": "fc979b203074aa7d050c4d94b74129233d2365fa_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["BOOL\r\nCheckBufferSize(\r\n    HWND hDlg,\r\n    UINT Item,\r\n    LPLINKDATA pld,\r\n    INT i\r\n    )\r\n/*++\r\n\r\n    Checks to make sure the buffer size is not smaller than the window size\r\n\r\n    Returns: TRUE if preview window should be updated\r\n             FALSE if not\r\n\r\n--*/\r\n{\r\n    BOOL fRet = FALSE;\r\n\r\n    if (!pld)\r\n     return fRet;\r\n\r\n    switch (Item)\r\n    {\r\n\r\n    case IDC_CNSL_SCRBUF_WIDTHSCROLL:\r\n    case IDC_CNSL_SCRBUF_WIDTH:\r\n        if (i >= 1)\r\n        {\r\n            pld->cpd.lpConsole->dwScreenBufferSize.X = (SHORT) i;\r\n            if (pld->cpd.lpConsole->dwWindowSize.X > i)\r\n            {\r\n                pld->cpd.lpConsole->dwWindowSize.X = (SHORT) i;\r\n                SetDlgItemInt( hDlg,\r\n                               IDC_CNSL_WINDOW_WIDTH,\r\n                               pld->cpd.lpConsole->dwWindowSize.X,\r\n                               TRUE\r\n                              );\r\n\r\n                fRet = TRUE;\r\n            }\r\n\r\n        }\r\n        break;\r\n\r\n    case IDC_CNSL_SCRBUF_HEIGHTSCROLL:\r\n    case IDC_CNSL_SCRBUF_HEIGHT:\r\n        if (i >= 1)\r\n        {\r\n            pld->cpd.lpConsole->dwScreenBufferSize.Y = (SHORT) i;\r\n            if (pld->cpd.lpConsole->dwWindowSize.Y > i)\r\n            {\r\n                pld->cpd.lpConsole->dwWindowSize.Y = (SHORT) i;\r\n                SetDlgItemInt( hDlg,\r\n                               IDC_CNSL_WINDOW_HEIGHT,\r\n                               pld->cpd.lpConsole->dwWindowSize.Y,\r\n                               TRUE\r\n                              );\r\n                fRet = TRUE;\r\n            }\r\n        }\r\n        break;\r\n\r\n    case IDC_CNSL_WINDOW_WIDTHSCROLL:\r\n    case IDC_CNSL_WINDOW_WIDTH:\r\n        if (i >= 1)\r\n        {\r\n            pld->cpd.lpConsole->dwWindowSize.X = (SHORT) i;\r\n            if (pld->cpd.lpConsole->dwScreenBufferSize.X < i)\r\n            {\r\n                pld->cpd.lpConsole->dwScreenBufferSize.X = (SHORT) i;\r\n                SetDlgItemInt( hDlg,\r\n                               IDC_CNSL_SCRBUF_WIDTH,\r\n                               pld->cpd.lpConsole->dwScreenBufferSize.X,\r\n                               TRUE\r\n                              );\r\n                fRet = TRUE;\r\n            }\r\n\r\n        }\r\n        break;\r\n\r\n    case IDC_CNSL_WINDOW_HEIGHTSCROLL:\r\n    case IDC_CNSL_WINDOW_HEIGHT:\r\n        if (i >= 1)\r\n        {\r\n            pld->cpd.lpConsole->dwWindowSize.Y = (SHORT) i;\r\n            if (pld->cpd.lpConsole->dwScreenBufferSize.Y < i)\r\n            {\r\n                pld->cpd.lpConsole->dwScreenBufferSize.Y = (SHORT) i;\r\n                SetDlgItemInt( hDlg,\r\n                               IDC_CNSL_SCRBUF_HEIGHT,\r\n                               pld->cpd.lpConsole->dwScreenBufferSize.Y,\r\n                               TRUE\r\n                              );\r\n                fRet = TRUE;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    return fRet;\r\n\r\n"]]}
{"hexsha": "33a1236db798561b21873901e7fbdbd7dcd0ed17", "ext": "c", "lang": "C", "content": "INLINE void OPM_OperatorPhase6(opm_t* const chip)\n{\n    //uint32_t slot = (chip->cycles + 27) & 31;\n    chip->op_atten = chip->op_logsin[2] + (chip->eg_out[1] << 2);\n    if (chip->op_atten & 4096)\n    {\n        chip->op_atten = 4095;\n    }\n}", "item_id": 16, "repo": "automation-club/pinmame", "file": "src/sound/ym2151_opm.c", "last_update_at": "2022-03-30T13:50:11+00:00", "question_id": "33a1236db798561b21873901e7fbdbd7dcd0ed17_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["INLINE void OPM_OperatorPhase6(opm_t* const chip)\n{\n    //uint32_t slot = (chip->cycles + 27) & 31;\n    chip->op_atten = chip->op_logsin[2] + (chip->eg_out[1] << 2);\n    if (chip->op_atten & 4096)\n    {\n        chip->op_atten = 4095;\n    }\n"]]}
{"hexsha": "1f78d5108175fa60bf869fde5486b5c3f282c4c3", "ext": "c", "lang": "C", "content": "XcursorBool\nXcursorSetTheme (Display *dpy, const char *theme)\n{\n    XcursorDisplayInfo\t*info = _XcursorGetDisplayInfo (dpy);\n    char\t\t*copy;\n\n    if (!info)\n\treturn XcursorFalse;\n\n    if (!theme)\n\ttheme = info->theme_from_config;\n\n    if (theme)\n    {\n\tcopy = malloc (strlen (theme) + 1);\n\tif (!copy)\n\t    return XcursorFalse;\n\tstrcpy (copy, theme);\n    }\n    else\n\tcopy = 0;\n    if (info->theme)\n\tfree (info->theme);\n    info->theme = copy;\n    return XcursorTrue;\n}", "item_id": 6, "repo": "sourcecode-reloaded/Xming", "file": "lib/Xcursor/display.c", "last_update_at": "2022-01-15T11:26:11+00:00", "question_id": "1f78d5108175fa60bf869fde5486b5c3f282c4c3_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["XcursorBool\nXcursorSetTheme (Display *dpy, const char *theme)\n{\n    XcursorDisplayInfo\t*info = _XcursorGetDisplayInfo (dpy);\n    char\t\t*copy;\n    if (!info)\n\treturn XcursorFalse;\n    if (!theme)\n\ttheme = info->theme_from_config;\n    if (theme)\n    {\n\tcopy = malloc (strlen (theme) + 1);\n\tif (!copy)\n\t    return XcursorFalse;\n\tstrcpy (copy, theme);\n    }\n    else\n\tcopy = 0;\n    if (info->theme)\n\tfree (info->theme);\n    info->theme = copy;\n    return XcursorTrue;\n"]]}
{"hexsha": "648509c95ef66e09e1ff8055746543880639c0c2", "ext": "c", "lang": "C", "content": "static void inline do_trap(int trapnr, int signr, char *str, int vm86,\n\t\t\t   struct pt_regs * regs, long error_code, siginfo_t *info)\n{\n\tif (regs->eflags & VM_MASK) {\n\t\tif (vm86)\n\t\t\tgoto vm86_trap;\n\t\telse\n\t\t\tgoto trap_signal;\n\t}\n\n\tif (!(regs->xcs & 3))\n\t\tgoto kernel_trap;\n\n\ttrap_signal: {\n\t\tstruct task_struct *tsk = current;\n\t\ttsk->thread.error_code = error_code;\n\t\ttsk->thread.trap_no = trapnr;\n\t\tif (info)\n\t\t\tforce_sig_info(signr, info, tsk);\n\t\telse\n\t\t\tforce_sig(signr, tsk);\n\t\treturn;\n\t}\n\n\tkernel_trap: {\n\t\tunsigned long fixup = search_exception_table(regs->eip);\n\t\tif (fixup)\n\t\t\tregs->eip = fixup;\n\t\telse\t\n\t\t\tdie(str, regs, error_code);\n\t\treturn;\n\t}\n\n\tvm86_trap: {\n\t\tint ret = handle_vm86_trap((struct kernel_vm86_regs *) regs, error_code, trapnr);\n\t\tif (ret) goto trap_signal;\n\t\treturn;\n\t}\n}", "item_id": 8, "repo": "ghsecuritylab/tomato_egg", "file": "release/src/linux/linux/arch/i386/kernel/traps.c", "last_update_at": "2022-01-20T18:21:05+00:00", "question_id": "648509c95ef66e09e1ff8055746543880639c0c2_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void inline do_trap(int trapnr, int signr, char *str, int vm86,\n\t\t\t   struct pt_regs * regs, long error_code, siginfo_t *info)\n{\n\tif (regs->eflags & VM_MASK) {\n\t\tif (vm86)\n\t\t\tgoto vm86_trap;\n\t\telse\n\t\t\tgoto trap_signal;\n\t}\n\tif (!(regs->xcs & 3))\n\t\tgoto kernel_trap;\n\ttrap_signal: {\n\t\tstruct task_struct *tsk = current;\n\t\ttsk->thread.error_code = error_code;\n\t\ttsk->thread.trap_no = trapnr;\n\t\tif (info)\n\t\t\tforce_sig_info(signr, info, tsk);\n\t\telse\n\t\t\tforce_sig(signr, tsk);\n\t\treturn;\n\t}\n\tkernel_trap: {\n\t\tunsigned long fixup = search_exception_table(regs->eip);\n\t\tif (fixup)\n\t\t\tregs->eip = fixup;\n\t\telse\t\n\t\t\tdie(str, regs, error_code);\n\t\treturn;\n\t}\n\tvm86_trap: {\n\t\tint ret = handle_vm86_trap((struct kernel_vm86_regs *) regs, error_code, trapnr);\n\t\tif (ret) goto trap_signal;\n\t\treturn;\n\t}\n"]]}
{"hexsha": "0a77734b3c2ffab22ad3a19eade874ec28113b89", "ext": "c", "lang": "C", "content": "VG_API_ENTRY vgSetPaint(\n   VGPaint vg_handle,\n   VGbitfield paint_modes) VG_API_EXIT\n{\n   CLIENT_THREAD_STATE_T *thread = CLIENT_GET_THREAD_STATE();\n   VG_CLIENT_STATE_T *state = VG_GET_CLIENT_STATE(thread);\n   if (!state) {\n      return;\n   }\n\n   if (!is_paint_modes(paint_modes)) {\n      set_error(VG_ILLEGAL_ARGUMENT_ERROR);\n      return;\n   }\n\n   platform_mutex_acquire(&state->shared_state->mutex);\n   if ((vg_handle != VG_INVALID_HANDLE) &&\n      !lookup_object(state, vg_handle, VG_CLIENT_OBJECT_TYPE_PAINT)) {\n      set_error(VG_BAD_HANDLE_ERROR);\n      platform_mutex_release(&state->shared_state->mutex);\n      return;\n   }\n   platform_mutex_release(&state->shared_state->mutex);\n\n   if (((paint_modes & VG_FILL_PATH) && (state->fill_paint != vg_handle)) ||\n      ((paint_modes & VG_STROKE_PATH) && (state->stroke_paint != vg_handle))) {\n      if (paint_modes & VG_FILL_PATH) {\n         state->fill_paint = vg_handle;\n      }\n      if (paint_modes & VG_STROKE_PATH) {\n         state->stroke_paint = vg_handle;\n      }\n      RPC_CALL2(vgSetPaint_impl,\n                thread,\n                VGSETPAINT_ID,\n                RPC_HANDLE(vg_handle),\n                RPC_BITFIELD(paint_modes));\n   }\n}", "item_id": 74, "repo": "basharast/RetroArch-ARM", "file": "src/gfx/include/userland/interface/khronos/vg/vg_client.c", "last_update_at": "2022-03-05T11:17:16+00:00", "question_id": "0a77734b3c2ffab22ad3a19eade874ec28113b89_74", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["VG_API_ENTRY vgSetPaint(\n   VGPaint vg_handle,\n   VGbitfield paint_modes) VG_API_EXIT\n{\n   CLIENT_THREAD_STATE_T *thread = CLIENT_GET_THREAD_STATE();\n   VG_CLIENT_STATE_T *state = VG_GET_CLIENT_STATE(thread);\n   if (!state) {\n      return;\n   }\n   if (!is_paint_modes(paint_modes)) {\n      set_error(VG_ILLEGAL_ARGUMENT_ERROR);\n      return;\n   }\n   platform_mutex_acquire(&state->shared_state->mutex);\n   if ((vg_handle != VG_INVALID_HANDLE) &&\n      !lookup_object(state, vg_handle, VG_CLIENT_OBJECT_TYPE_PAINT)) {\n      set_error(VG_BAD_HANDLE_ERROR);\n      platform_mutex_release(&state->shared_state->mutex);\n      return;\n   }\n   platform_mutex_release(&state->shared_state->mutex);\n   if (((paint_modes & VG_FILL_PATH) && (state->fill_paint != vg_handle)) ||\n      ((paint_modes & VG_STROKE_PATH) && (state->stroke_paint != vg_handle))) {\n      if (paint_modes & VG_FILL_PATH) {\n         state->fill_paint = vg_handle;\n      }\n      if (paint_modes & VG_STROKE_PATH) {\n         state->stroke_paint = vg_handle;\n      }\n      RPC_CALL2(vgSetPaint_impl,\n                thread,\n                VGSETPAINT_ID,\n                RPC_HANDLE(vg_handle),\n                RPC_BITFIELD(paint_modes));\n   }\n"]]}
{"hexsha": "8d9976707e822ca4b0b3575c523acea3055ff1e6", "ext": "c", "lang": "C", "content": "bool downsampleBamChunkReadWithVcfEntrySubstringsViaFullReadLengthLikelihood(int64_t intendedDepth,\n                                                                             stList *chunkVcfEntries,\n                                                                             stList *inputReads,\n                                                                             stList *maintainedReads,\n                                                                             stList *discardedReads) {\n\n    // calculate depth, generate bcrwhs list\n    int64_t totalVcfEntries = 0;\n\n    int *readLengths = st_calloc(stList_length(inputReads), sizeof(int));\n    int *readFullLengths = st_calloc(stList_length(inputReads), sizeof(int));\n\n    for (int64_t i = 0; i < stList_length(inputReads); i++) {\n        BamChunkRead *bcr = stList_get(inputReads, i);\n        BamChunkReadVcfEntrySubstrings *bcrves = bcr->bamChunkReadVcfEntrySubstrings;\n        assert(bcrves != NULL);\n        totalVcfEntries += (int) stList_length(bcrves->vcfEntries);\n        readLengths[i] = (int) stList_length(bcrves->vcfEntries);\n        // give reads a pseudocount\n        readFullLengths[i] = (int) bcr->fullReadLength;\n    }\n    int64_t chunkSize = stList_length(chunkVcfEntries);\n    double averageDepth = 1.0 * totalVcfEntries / chunkSize;\n\n    // do we need to downsample?\n    if (averageDepth < intendedDepth) {\n        free(readLengths);\n        free(readFullLengths);\n        return FALSE;\n    }\n    char *logIdentifier = getLogIdentifier();\n\n    // is there something wrong with this chunk?\n    if (chunkSize == 0 || totalVcfEntries == 0) {\n        st_logInfo(\" %s Downsampling all reads in chunk with %\"PRId64\" reads (%\"PRId64\" incoming filtered), as it has %\"PRId64\" spanned variants (chunk has %\"PRId64\")\\n\",\n                   logIdentifier, stList_length(inputReads), stList_length(discardedReads), totalVcfEntries, chunkSize);\n\n        // \"filter\" everything and return\n        for (int64_t i = 0; i < stList_length(inputReads); i++) {\n            stList_append(discardedReads, stList_get(inputReads, i));\n        }\n        free(readLengths);\n        free(readFullLengths);\n        free(logIdentifier);\n        return TRUE;\n    }\n\n    // we do need to downsample\n    st_logInfo(\" %s Downsampling chunk with %\"PRId64\" reads via spanned variant count with average depth %.2fx to %dx.\\n\",\n               logIdentifier, stList_length(inputReads), averageDepth, intendedDepth);\n\n    // get likelihood of keeping each read\n    double *probs = computeReadProbsByLengthAndSecondMetric(readLengths, readFullLengths,\n                                                            (int) stList_length(inputReads),\n                                                            intendedDepth, (int) chunkSize);\n\n    // keep some ratio of reads\n    int64_t totalKeptVariants = 0;\n    for (int64_t i = 0; i < stList_length(inputReads); i++) {\n        BamChunkRead *bcr = stList_get(inputReads, i);\n        if (st_random() < probs[i]) {\n            stList_append(maintainedReads, stList_get(inputReads, i));\n            totalKeptVariants += stList_length(bcr->bamChunkReadVcfEntrySubstrings->readSubstrings);\n        } else {\n            stList_append(discardedReads, stList_get(inputReads, i));\n        }\n    }\n    st_logInfo(\" %s Downsampled chunk via spanned variant count with to average depth %.2fx (expected %dx)\\n\",\n               logIdentifier, 1.0 * totalKeptVariants / chunkSize, intendedDepth);\n\n    free(probs);\n    free(readLengths);\n    free(readFullLengths);\n    free(logIdentifier);\n    return TRUE;\n}", "item_id": 19, "repo": "UCSC-nanopore-cgl/margin", "file": "impl/htsIntegration.c", "last_update_at": "2022-02-03T23:54:19+00:00", "question_id": "8d9976707e822ca4b0b3575c523acea3055ff1e6_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool downsampleBamChunkReadWithVcfEntrySubstringsViaFullReadLengthLikelihood(int64_t intendedDepth,\n                                                                             stList *chunkVcfEntries,\n                                                                             stList *inputReads,\n                                                                             stList *maintainedReads,\n                                                                             stList *discardedReads) {\n    // calculate depth, generate bcrwhs list\n    int64_t totalVcfEntries = 0;\n    int *readLengths = st_calloc(stList_length(inputReads), sizeof(int));\n    int *readFullLengths = st_calloc(stList_length(inputReads), sizeof(int));\n    for (int64_t i = 0; i < stList_length(inputReads); i++) {\n        BamChunkRead *bcr = stList_get(inputReads, i);\n        BamChunkReadVcfEntrySubstrings *bcrves = bcr->bamChunkReadVcfEntrySubstrings;\n        assert(bcrves != NULL);\n        totalVcfEntries += (int) stList_length(bcrves->vcfEntries);\n        readLengths[i] = (int) stList_length(bcrves->vcfEntries);\n        // give reads a pseudocount\n        readFullLengths[i] = (int) bcr->fullReadLength;\n    }\n    int64_t chunkSize = stList_length(chunkVcfEntries);\n    double averageDepth = 1.0 * totalVcfEntries / chunkSize;\n    // do we need to downsample?\n    if (averageDepth < intendedDepth) {\n        free(readLengths);\n        free(readFullLengths);\n        return FALSE;\n    }\n    char *logIdentifier = getLogIdentifier();\n    // is there something wrong with this chunk?\n    if (chunkSize == 0 || totalVcfEntries == 0) {\n        st_logInfo(\" %s Downsampling all reads in chunk with %\"PRId64\" reads (%\"PRId64\" incoming filtered), as it has %\"PRId64\" spanned variants (chunk has %\"PRId64\")\\n\",\n                   logIdentifier, stList_length(inputReads), stList_length(discardedReads), totalVcfEntries, chunkSize);\n        // \"filter\" everything and return\n        for (int64_t i = 0; i < stList_length(inputReads); i++) {\n            stList_append(discardedReads, stList_get(inputReads, i));\n        }\n        free(readLengths);\n        free(readFullLengths);\n        free(logIdentifier);\n        return TRUE;\n    }\n    // we do need to downsample\n    st_logInfo(\" %s Downsampling chunk with %\"PRId64\" reads via spanned variant count with average depth %.2fx to %dx.\\n\",\n               logIdentifier, stList_length(inputReads), averageDepth, intendedDepth);\n    // get likelihood of keeping each read\n    double *probs = computeReadProbsByLengthAndSecondMetric(readLengths, readFullLengths,\n                                                            (int) stList_length(inputReads),\n                                                            intendedDepth, (int) chunkSize);\n    // keep some ratio of reads\n    int64_t totalKeptVariants = 0;\n    for (int64_t i = 0; i < stList_length(inputReads); i++) {\n        BamChunkRead *bcr = stList_get(inputReads, i);\n        if (st_random() < probs[i]) {\n            stList_append(maintainedReads, stList_get(inputReads, i));\n            totalKeptVariants += stList_length(bcr->bamChunkReadVcfEntrySubstrings->readSubstrings);\n        } else {\n            stList_append(discardedReads, stList_get(inputReads, i));\n        }\n    }\n    st_logInfo(\" %s Downsampled chunk via spanned variant count with to average depth %.2fx (expected %dx)\\n\",\n               logIdentifier, 1.0 * totalKeptVariants / chunkSize, intendedDepth);\n    free(probs);\n    free(readLengths);\n    free(readFullLengths);\n    free(logIdentifier);\n    return TRUE;\n"]]}
{"hexsha": "0c59deb5a8420feeaff1acbf22ad6823bbf91d2f", "ext": "c", "lang": "C", "content": "void Bluetooth_Stack_Task(void)\n{\n\tif (USB_HostState != HOST_STATE_Configured)\n\t  Bluetooth_HCIProcessingState = Bluetooth_Init;\n\t\t\n\tBluetooth_ProcessHCICommands();\n\tBluetooth_ProcessACLPackets();\n}", "item_id": 0, "repo": "tonghuanming/Pubg_Mouse_Aide", "file": "src/libraries/lufa-lib-master/Demos/Host/Incomplete/BluetoothHost/Lib/BluetoothStack.c", "last_update_at": "2022-03-03T20:13:51+00:00", "question_id": "0c59deb5a8420feeaff1acbf22ad6823bbf91d2f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void Bluetooth_Stack_Task(void)\n{\n\tif (USB_HostState != HOST_STATE_Configured)\n\t  Bluetooth_HCIProcessingState = Bluetooth_Init;\n\t\t\n\tBluetooth_ProcessHCICommands();\n\tBluetooth_ProcessACLPackets();\n"]]}
{"hexsha": "d346eea2a1567304e4cbde99d396206482ed54cd", "ext": "c", "lang": "C", "content": "static void timer_load(void) {\n\tFILE* f = fopen(ctx->get_datafile(), \"r\");\n\n\tstruct timer t = {};\n\tintmax_t expiry;\n\ttime_t now = time(0);\n\n\tint fck = 0;\n\twhile((fck = fscanf(f, \"%ms %ms %\" SCNiMAX \" %m[^\\n]\", &t.chan, &t.id, &expiry, &t.msg)) >= 3) {\n\t\tif(expiry <= now) {\n\t\t\ttimer_free(&t);\n\t\t} else {\n\t\t\tt.expiry = expiry;\n\t\t\tsb_push(timers, t);\n\t\t}\n\t}\n\n\tfclose(f);\n}", "item_id": 1, "repo": "baines/insobot", "file": "src/mod_timer.c", "last_update_at": "2022-01-25T12:43:29+00:00", "question_id": "d346eea2a1567304e4cbde99d396206482ed54cd_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void timer_load(void) {\n\tFILE* f = fopen(ctx->get_datafile(), \"r\");\n\tstruct timer t = {};\n\tintmax_t expiry;\n\ttime_t now = time(0);\n\tint fck = 0;\n\twhile((fck = fscanf(f, \"%ms %ms %\" SCNiMAX \" %m[^\\n]\", &t.chan, &t.id, &expiry, &t.msg)) >= 3) {\n\t\tif(expiry <= now) {\n\t\t\ttimer_free(&t);\n\t\t} else {\n\t\t\tt.expiry = expiry;\n\t\t\tsb_push(timers, t);\n\t\t}\n\t}\n\tfclose(f);\n"]]}
{"hexsha": "c0024a474648ca8c0d9e73d4675da9c6de8d9796", "ext": "c", "lang": "C", "content": "int tc_overflow_v(struct ut_suite *suite, struct ut_tcase *tcase)\n{\n    for (size_t i = ARRAY_SIZE(test_out1) - 1; i >= ARRAY_SIZE(out1); i--) {\n        ut_assert_msg(test_out1[i] == CANARY,\n                      \"p_xcorr_f32() Test 1: Output buffer overflow. Canary overwritten. Last index: %d\\n\",\n                      (unsigned int) i);\n    }\n\n    for (size_t i = ARRAY_SIZE(test_out2) - 1; i >= ARRAY_SIZE(out2); i--) {\n        ut_assert_msg(test_out2[i] == CANARY,\n                      \"p_xcorr_f32() Test 2: Output buffer overflow. Canary overwritten. Last index: %d\\n\",\n                      (unsigned int) i);\n    }\n\n    return 0;\n}", "item_id": 2, "repo": "duca/pal", "file": "tests/dsp/check_p_xcorr_f32.c", "last_update_at": "2022-03-26T20:53:38+00:00", "question_id": "c0024a474648ca8c0d9e73d4675da9c6de8d9796_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int tc_overflow_v(struct ut_suite *suite, struct ut_tcase *tcase)\n{\n    for (size_t i = ARRAY_SIZE(test_out1) - 1; i >= ARRAY_SIZE(out1); i--) {\n        ut_assert_msg(test_out1[i] == CANARY,\n                      \"p_xcorr_f32() Test 1: Output buffer overflow. Canary overwritten. Last index: %d\\n\",\n                      (unsigned int) i);\n    }\n    for (size_t i = ARRAY_SIZE(test_out2) - 1; i >= ARRAY_SIZE(out2); i--) {\n        ut_assert_msg(test_out2[i] == CANARY,\n                      \"p_xcorr_f32() Test 2: Output buffer overflow. Canary overwritten. Last index: %d\\n\",\n                      (unsigned int) i);\n    }\n    return 0;\n"]]}
{"hexsha": "67ac260055233eb8bfa4a5060e3a7035026602a2", "ext": "c", "lang": "C", "content": "static void setup_display(void)\n{\n\tstruct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;\n\tint reg;\n\n\tenable_ipu_clock();\n\n\treg = readl(&mxc_ccm->cs2cdr);\n\t/* select pll 5 clock */\n\treg &= MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK;\n\treg &= MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK;\n\twritel(reg, &mxc_ccm->cs2cdr);\n\n\timx_iomux_v3_setup_multiple_pads(backlight_pads,\n\t\t\t\t\t ARRAY_SIZE(backlight_pads));\n}", "item_id": 5, "repo": "rgomulin/aml_s905_uboot", "file": "u-boot/board/aristainetos/aristainetos.c", "last_update_at": "2022-03-30T11:37:06+00:00", "question_id": "67ac260055233eb8bfa4a5060e3a7035026602a2_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void setup_display(void)\n{\n\tstruct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;\n\tint reg;\n\tenable_ipu_clock();\n\treg = readl(&mxc_ccm->cs2cdr);\n\t/* select pll 5 clock */\n\treg &= MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK;\n\treg &= MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK;\n\twritel(reg, &mxc_ccm->cs2cdr);\n\timx_iomux_v3_setup_multiple_pads(backlight_pads,\n\t\t\t\t\t ARRAY_SIZE(backlight_pads));\n"]]}
{"hexsha": "56659d30f3fcb68f60460290a6be7431f34d0ddc", "ext": "c", "lang": "C", "content": "int main (int argc, char **argv)\n{\n\n    double Info [UMFPACK_INFO], Control [UMFPACK_CONTROL], *Ax, *Cx, *Lx, *Ux,\n\t*W, t [2], *Dx, rnorm, *Rb, *y, *Rs, my_t, *Aval ;\n    int *Ap, *Ai, *Cp, *Ci, row, col, p, lnz, unz, nr, nc, *Lp, *Li, *Ui, *Up,\n\t*P, *Q, *Lj, i, j, k, anz, nfr, nchains, *Qinit, fnpiv, lnz1, unz1, nz1,\n\tstatus, *Front_npivcol, *Front_parent, *Chain_start, *Wi, *Pinit, n1,\n\t*Chain_maxrows, *Chain_maxcols, *Front_1strow, *Front_leftmostdesc,\n\tnzud, do_recip, *Arow, *Acol ;\n    void *Symbolic, *Numeric ;\n\n    int n, nz;\n    double *b, *x, *r ;\n\n    /* ---------------------------------------------------------------------- */\n    /* initializations */\n    /* ---------------------------------------------------------------------- */\n\n    umfpack_tic (t) ;\n\n    printf (\"\\nUMFPACK V%d.%d (%s) demo: _di_ version\\n\",\n\t    UMFPACK_MAIN_VERSION, UMFPACK_SUB_VERSION, UMFPACK_DATE) ;\n\n    /* get the default control parameters */\n    umfpack_di_defaults (Control) ;\n\n    // Try no re-ordering to preserve L shape of the matrix\n    /* Control [UMFPACK_ORDERING] = UMFPACK_ORDERING_NONE ; */\n    // no iterative refinement, only single solve\n    Control [UMFPACK_IRSTEP] = 0;\n\n    /* change the default print level for this demo */\n    /* (otherwise, nothing will print) */\n    Control [UMFPACK_PRL] = 6 ;\n\n    /* print the license agreement */\n    umfpack_di_report_status (Control, UMFPACK_OK) ;\n    Control [UMFPACK_PRL] = 5 ;\n\n    /* print the control parameters */\n    umfpack_di_report_control (Control) ;\n\n    /* read matrix */\n      // args\n    int nrequired_args = 4;\n    if (argc != nrequired_args){\n        fprintf(stderr, \"improper arguments\");\n        exit(1);\n    }\n    /** parse arguments */\n    int iarg = 1;\n    char* strpathA = argv[iarg];    iarg++;\n    int nthreads = atoi(argv[iarg]);    iarg++;\n    int n_solve_iter = atoi(argv[iarg]);    iarg++;\n    assert(nrequired_args == iarg);\n    \n    FILE *fp= fopen(strpathA, \"r\");\n    problem *Prob= get_problem(fp, 0);\n    \n    n= (int) Prob->A->n;\n    nz= (int) Prob->A->nzmax;\n    b= Prob->b;\n    x= Prob->x;\n    r= Prob->resid;\n    Arow = Prob->Arow;\n    Acol = Prob->Acol;\n    Aval = Prob->Aval;\n\n    printf(\"# non-zeroes: %d\\n\", nz);\n\n    printf(\"%d, %d, %f\\n\", Arow[0], Acol[0], Aval[0]);\n    printf(\"%d, %d, %f\\n\", Arow[nz], Acol[nz], Aval[nz]);\n    /* status = umfpack_di_report_triplet (n, n, nz, Arow, Acol, Aval, Control) ; */\n    /* if (status < 0) */\n    /* { */\n    /*   umfpack_di_report_status (Control, status) ; */\n    /*   error (\"umfpack_di_report_triplet failed\") ; */\n    /* } */\n\n    /* convert to column form */\n    nz1 = MAX (nz,1) ;\t/* ensure arrays are not of size zero. */\n    Ap = (int *) malloc ((n+1) * sizeof (int)) ;\n    Ai = (int *) malloc (nz1 * sizeof (int)) ;\n    Ax = (double *) malloc (nz1 * sizeof (double)) ;\n    if (!Ap || !Ai || !Ax)\n    {\n\terror (\"out of memory\") ;\n    }\n\n    status = umfpack_di_triplet_to_col (n, n, nz, Arow, Acol, Aval,\n\tAp, Ai, Ax, (int *) NULL) ;\n    if (status < 0)\n    {\n\tumfpack_di_report_status (Control, status) ;\n\terror (\"umfpack_di_triplet_to_col failed\") ;\n    }\n\n    /* for (i = 0 ; i < n + 1 ; i++) Ap[i] = (int) Prob->A->p[i]; */\n    /* for (i = 0 ; i < nz; i++) Ai[i] = (int) Prob->A->i[i]; */\n    /* for (i = 0 ; i < nz; i++) Ax[i] = Prob->A->x[i]; */\n    if PRINT {\n      for (i = 0 ; i < n + 1 ; i++) printf(\"\\n Ap[%d]: %d, \", i, Ap[i]);\n      for (i = 0 ; i < nz ; i++) printf(\"\\n Ai[%d]: %d, \", i, Ai[i]);\n      for (i = 0 ; i < nz ; i++) printf(\"\\n Ax[%d]: %lf, \", i, Ax[i]);\n    }\n    \n    printf(\"Ap[0] : %d\\n\", Ap[0]);\n    printf(\"Ap[n] : %d\\n\", Ap[n]);\n    assert (Ap[0] == 0);\n    assert (Ap[n] >= 0);\n    for (i = 1 ; i < n + 1 ; i++) {\n      assert ( Ap[i] >= Ap[i-1] );\n      for (j = Ap [ i-1 ] ; j < Ap [ i ] ; j++) {\n        assert (Ai [ j ] < n);\n        if ( Ai[ j ] < i-1 ) {\n          printf(\"Ai[j]: %d,i: %d\", Ai[j], i-1 ); error( \"Not an L marix\" ) ;\n        }\n      }\n      for (j = Ap [ i-1 ] + 1 ; j < Ap [ i ] ; j++) {\n        if ( Ai [ j ] == Ai [ j-1 ] ) {\n          printf(\"Ai[j]: %d, Ai[j-1]: %d\", Ai[j], Ai[j-1] ); error( \"Duplicates\" ) ;\n        }\n      }\n    }\n    /* for (i = 0 ; i < nz ; i++) */\n    /* { */ \n    /*   if ( Ai[i] < i ) {printf(\"Ai[i]: %d,i: %d\", Ai[i], i ); error( \"Not an L marix\" ) ; } */\n    /* } // L matrix */\n    /* Ap= Prob->A->p; */\n    /* Ai= Prob->A->i; */\n    /* Ax= Prob->A->x; */\n\n    rhs (x, b, n) ;                             /* compute right-hand side */\n\n\n    /* ---------------------------------------------------------------------- */\n    /* symbolic factorization */\n    /* ---------------------------------------------------------------------- */\n\n    printf(\"Here\\n\");\n    status = umfpack_di_symbolic (n, n, Ap, Ai, Ax, &Symbolic,\n\tControl, Info) ;\n    if (status < 0)\n    {\n      umfpack_di_report_info (Control, Info) ;\n      umfpack_di_report_status (Control, status) ;\n      printf (\"umfpack_di_symbolic failed, error code: %d\", status) ;\n      error (\"umfpack_di_symbolic failed\") ;\n    }\n    printf(\"symbolic done\\n\");\n\n    /* ---------------------------------------------------------------------- */\n    /* numeric factorization */\n    /* ---------------------------------------------------------------------- */\n\n    status = umfpack_di_numeric (Ap, Ai, Ax, Symbolic, &Numeric,\n\tControl, Info) ;\n    if (status < 0)\n    {\n\tumfpack_di_report_info (Control, Info) ;\n\tumfpack_di_report_status (Control, status) ;\n\terror (\"umfpack_di_numeric failed\") ;\n    }\n\n    if PRINT {\n      /* print the numeric factorization */\n      printf (\"\\nNumeric factorization of A: \") ;\n      (void) umfpack_di_report_numeric (Numeric, Control) ;\n    }\n\n    if (umfpack_di_get_lunz (&lnz, &unz, &nr, &nc, &nzud, Numeric) < 0)\n    {\n      error (\"umfpack_di_get_lunz failed\") ;\n    }\n\n    printf(\"LU factor statistics: lnz: %d, unz: %d, nr: %d, nc: %d, n: %d, nzud: %d\\n\", lnz, unz, nr, nc, n, nzud);\n\n    /* ---------------------------------------------------------------------- */\n    /* solve Ax=b */\n    /* ---------------------------------------------------------------------- */\n    double tot_time=0.;\n  my_t = tic () ;\n    for (i = 0 ; i < n_solve_iter ; i++) {\n      status = umfpack_di_solve (UMFPACK_A, Ap, Ai, Ax, x, b,\n        Numeric, Control, Info) ;\n      tot_time += Info[UMFPACK_SOLVE_TIME];\n    }\n  my_t= toc(my_t);\n \n    umfpack_di_report_info (Control, Info) ;\n    /* umfpack_di_report_status (Control, status) ; */\n    if (status < 0)\n    {\n\terror (\"umfpack_di_solve failed\") ;\n    }\n    printf (\"\\nx (solution of Ax=b): \") ;\n    (void) umfpack_di_report_vector (MIN(10, n), x, Control) ;\n    rnorm = resid (FALSE, n, Ap, Ai, Ax, x, b, r) ;\n    printf (\"maxnorm of residual: %g\\n\\n\", rnorm) ;\n\n  printf(\"\\n UMFPACK_Info, iterative refinement steps take, %f, iterative refinement steps attempted + 1, %f , flops, %8.9f, time, %8.9f, avg reported time (seconds), %8.9f\\n\", Info[UMFPACK_IR_TAKEN], Info[UMFPACK_IR_ATTEMPTED] + 1, Info[UMFPACK_SOLVE_FLOPS], Info[UMFPACK_SOLVE_TIME], tot_time/n_solve_iter);\n  /* printf (\"\\n n_solve_iter : %d, solve_time (seconds), %8.9f, residual: %g\\n\", n_solve_iter, my_t, rnorm) ; */\n  printf (\"\\n n_solve_iter : %d, solve_time (seconds), %8.9f, residual, %g, flops, %g\\n\", n_solve_iter, tot_time, rnorm, Info[UMFPACK_SOLVE_FLOPS]) ;\n  free_problem(Prob);\n  return 0;\n}", "item_id": 6, "repo": "nimish15shah/GRAPHOPT", "file": "src/benchmark_other_works/suitesparse/umfpack.c", "last_update_at": "2022-03-17T19:07:51+00:00", "question_id": "56659d30f3fcb68f60460290a6be7431f34d0ddc_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main (int argc, char **argv)\n{\n    double Info [UMFPACK_INFO], Control [UMFPACK_CONTROL], *Ax, *Cx, *Lx, *Ux,\n\t*W, t [2], *Dx, rnorm, *Rb, *y, *Rs, my_t, *Aval ;\n    int *Ap, *Ai, *Cp, *Ci, row, col, p, lnz, unz, nr, nc, *Lp, *Li, *Ui, *Up,\n\t*P, *Q, *Lj, i, j, k, anz, nfr, nchains, *Qinit, fnpiv, lnz1, unz1, nz1,\n\tstatus, *Front_npivcol, *Front_parent, *Chain_start, *Wi, *Pinit, n1,\n\t*Chain_maxrows, *Chain_maxcols, *Front_1strow, *Front_leftmostdesc,\n\tnzud, do_recip, *Arow, *Acol ;\n    void *Symbolic, *Numeric ;\n    int n, nz;\n    double *b, *x, *r ;\n    /* ---------------------------------------------------------------------- */\n    /* initializations */\n    /* ---------------------------------------------------------------------- */\n    umfpack_tic (t) ;\n    printf (\"\\nUMFPACK V%d.%d (%s) demo: _di_ version\\n\",\n\t    UMFPACK_MAIN_VERSION, UMFPACK_SUB_VERSION, UMFPACK_DATE) ;\n    /* get the default control parameters */\n    umfpack_di_defaults (Control) ;\n    // Try no re-ordering to preserve L shape of the matrix\n    /* Control [UMFPACK_ORDERING] = UMFPACK_ORDERING_NONE ; */\n    // no iterative refinement, only single solve\n    Control [UMFPACK_IRSTEP] = 0;\n    /* change the default print level for this demo */\n    /* (otherwise, nothing will print) */\n    Control [UMFPACK_PRL] = 6 ;\n    /* print the license agreement */\n    umfpack_di_report_status (Control, UMFPACK_OK) ;\n    Control [UMFPACK_PRL] = 5 ;\n    /* print the control parameters */\n    umfpack_di_report_control (Control) ;\n    /* read matrix */\n      // args\n    int nrequired_args = 4;\n    if (argc != nrequired_args){\n        fprintf(stderr, \"improper arguments\");\n        exit(1);\n    }\n    /** parse arguments */\n    int iarg = 1;\n    char* strpathA = argv[iarg];    iarg++;\n    int nthreads = atoi(argv[iarg]);    iarg++;\n    int n_solve_iter = atoi(argv[iarg]);    iarg++;\n    assert(nrequired_args == iarg);\n    FILE *fp= fopen(strpathA, \"r\");\n    problem *Prob= get_problem(fp, 0);\n    n= (int) Prob->A->n;\n    nz= (int) Prob->A->nzmax;\n    b= Prob->b;\n    x= Prob->x;\n    r= Prob->resid;\n    Arow = Prob->Arow;\n    Acol = Prob->Acol;\n    Aval = Prob->Aval;\n    printf(\"# non-zeroes: %d\\n\", nz);\n    printf(\"%d, %d, %f\\n\", Arow[0], Acol[0], Aval[0]);\n    printf(\"%d, %d, %f\\n\", Arow[nz], Acol[nz], Aval[nz]);\n    /* status = umfpack_di_report_triplet (n, n, nz, Arow, Acol, Aval, Control) ; */\n    /* if (status < 0) */\n    /* { */\n    /*   umfpack_di_report_status (Control, status) ; */\n    /*   error (\"umfpack_di_report_triplet failed\") ; */\n    /* } */\n    /* convert to column form */\n    nz1 = MAX (nz,1) ;\t/* ensure arrays are not of size zero. */\n    Ap = (int *) malloc ((n+1) * sizeof (int)) ;\n    Ai = (int *) malloc (nz1 * sizeof (int)) ;\n    Ax = (double *) malloc (nz1 * sizeof (double)) ;\n    if (!Ap || !Ai || !Ax)\n    {\n\terror (\"out of memory\") ;\n    }\n    status = umfpack_di_triplet_to_col (n, n, nz, Arow, Acol, Aval,\n\tAp, Ai, Ax, (int *) NULL) ;\n    if (status < 0)\n    {\n\tumfpack_di_report_status (Control, status) ;\n\terror (\"umfpack_di_triplet_to_col failed\") ;\n    }\n    /* for (i = 0 ; i < n + 1 ; i++) Ap[i] = (int) Prob->A->p[i]; */\n    /* for (i = 0 ; i < nz; i++) Ai[i] = (int) Prob->A->i[i]; */\n    /* for (i = 0 ; i < nz; i++) Ax[i] = Prob->A->x[i]; */\n    if PRINT {\n      for (i = 0 ; i < n + 1 ; i++) printf(\"\\n Ap[%d]: %d, \", i, Ap[i]);\n      for (i = 0 ; i < nz ; i++) printf(\"\\n Ai[%d]: %d, \", i, Ai[i]);\n      for (i = 0 ; i < nz ; i++) printf(\"\\n Ax[%d]: %lf, \", i, Ax[i]);\n    }\n    printf(\"Ap[0] : %d\\n\", Ap[0]);\n    printf(\"Ap[n] : %d\\n\", Ap[n]);\n    assert (Ap[0] == 0);\n    assert (Ap[n] >= 0);\n    for (i = 1 ; i < n + 1 ; i++) {\n      assert ( Ap[i] >= Ap[i-1] );\n      for (j = Ap [ i-1 ] ; j < Ap [ i ] ; j++) {\n        assert (Ai [ j ] < n);\n        if ( Ai[ j ] < i-1 ) {\n          printf(\"Ai[j]: %d,i: %d\", Ai[j], i-1 ); error( \"Not an L marix\" ) ;\n        }\n      }\n      for (j = Ap [ i-1 ] + 1 ; j < Ap [ i ] ; j++) {\n        if ( Ai [ j ] == Ai [ j-1 ] ) {\n          printf(\"Ai[j]: %d, Ai[j-1]: %d\", Ai[j], Ai[j-1] ); error( \"Duplicates\" ) ;\n        }\n      }\n    }\n    /* for (i = 0 ; i < nz ; i++) */\n    /* { */ \n    /*   if ( Ai[i] < i ) {printf(\"Ai[i]: %d,i: %d\", Ai[i], i ); error( \"Not an L marix\" ) ; } */\n    /* } // L matrix */\n    /* Ap= Prob->A->p; */\n    /* Ai= Prob->A->i; */\n    /* Ax= Prob->A->x; */\n    rhs (x, b, n) ;                             /* compute right-hand side */\n    /* ---------------------------------------------------------------------- */\n    /* symbolic factorization */\n    /* ---------------------------------------------------------------------- */\n    printf(\"Here\\n\");\n    status = umfpack_di_symbolic (n, n, Ap, Ai, Ax, &Symbolic,\n\tControl, Info) ;\n    if (status < 0)\n    {\n      umfpack_di_report_info (Control, Info) ;\n      umfpack_di_report_status (Control, status) ;\n      printf (\"umfpack_di_symbolic failed, error code: %d\", status) ;\n      error (\"umfpack_di_symbolic failed\") ;\n    }\n    printf(\"symbolic done\\n\");\n    /* ---------------------------------------------------------------------- */\n    /* numeric factorization */\n    /* ---------------------------------------------------------------------- */\n    status = umfpack_di_numeric (Ap, Ai, Ax, Symbolic, &Numeric,\n\tControl, Info) ;\n    if (status < 0)\n    {\n\tumfpack_di_report_info (Control, Info) ;\n\tumfpack_di_report_status (Control, status) ;\n\terror (\"umfpack_di_numeric failed\") ;\n    }\n    if PRINT {\n      /* print the numeric factorization */\n      printf (\"\\nNumeric factorization of A: \") ;\n      (void) umfpack_di_report_numeric (Numeric, Control) ;\n    }\n    if (umfpack_di_get_lunz (&lnz, &unz, &nr, &nc, &nzud, Numeric) < 0)\n    {\n      error (\"umfpack_di_get_lunz failed\") ;\n    }\n    printf(\"LU factor statistics: lnz: %d, unz: %d, nr: %d, nc: %d, n: %d, nzud: %d\\n\", lnz, unz, nr, nc, n, nzud);\n    /* ---------------------------------------------------------------------- */\n    /* solve Ax=b */\n    /* ---------------------------------------------------------------------- */\n    double tot_time=0.;\n  my_t = tic () ;\n    for (i = 0 ; i < n_solve_iter ; i++) {\n      status = umfpack_di_solve (UMFPACK_A, Ap, Ai, Ax, x, b,\n        Numeric, Control, Info) ;\n      tot_time += Info[UMFPACK_SOLVE_TIME];\n    }\n  my_t= toc(my_t);\n    umfpack_di_report_info (Control, Info) ;\n    /* umfpack_di_report_status (Control, status) ; */\n    if (status < 0)\n    {\n\terror (\"umfpack_di_solve failed\") ;\n    }\n    printf (\"\\nx (solution of Ax=b): \") ;\n    (void) umfpack_di_report_vector (MIN(10, n), x, Control) ;\n    rnorm = resid (FALSE, n, Ap, Ai, Ax, x, b, r) ;\n    printf (\"maxnorm of residual: %g\\n\\n\", rnorm) ;\n  printf(\"\\n UMFPACK_Info, iterative refinement steps take, %f, iterative refinement steps attempted + 1, %f , flops, %8.9f, time, %8.9f, avg reported time (seconds), %8.9f\\n\", Info[UMFPACK_IR_TAKEN], Info[UMFPACK_IR_ATTEMPTED] + 1, Info[UMFPACK_SOLVE_FLOPS], Info[UMFPACK_SOLVE_TIME], tot_time/n_solve_iter);\n  /* printf (\"\\n n_solve_iter : %d, solve_time (seconds), %8.9f, residual: %g\\n\", n_solve_iter, my_t, rnorm) ; */\n  printf (\"\\n n_solve_iter : %d, solve_time (seconds), %8.9f, residual, %g, flops, %g\\n\", n_solve_iter, tot_time, rnorm, Info[UMFPACK_SOLVE_FLOPS]) ;\n  free_problem(Prob);\n  return 0;\n"]]}
{"hexsha": "e0b8bb7e849387069c81697f48cd76138e681886", "ext": "c", "lang": "C", "content": "int r1fgkf_f(int *ido, int *ip, int *l1, int *\n\tidl1, float *cc, float *c1, float *c2, int *in1, float *ch, float *ch2,\n\t int *in2, float *wa)\n{\n    /* System generated locals */\n    int ch_dim1, ch_dim2, ch_dim3, ch_offset, cc_dim1, cc_dim2, cc_dim3,\n\t    cc_offset, c1_dim1, c1_dim2, c1_dim3, c1_offset, c2_dim1, c2_dim2,\n\t     c2_offset, ch2_dim1, ch2_dim2, ch2_offset, i__1, i__2, i__3;\n\n    /* Builtin functions */\n\n    /* Local variables */\n     int i__, j, k, l, j2, ic, jc, lc, ik, is;\n     float dc2, ai1, ai2, ar1, ar2, ds2;\n     int nbd;\n     float dcp, arg, dsp, tpi, ar1h, ar2h;\n     int idp2, ipp2, idij, ipph;\n\n\n    /* Parameter adjustments */\n    --wa;\n    c2_dim1 = *in1;\n    c2_dim2 = *idl1;\n    c2_offset = 1 + c2_dim1 * (1 + c2_dim2);\n    c2 -= c2_offset;\n    c1_dim1 = *in1;\n    c1_dim2 = *ido;\n    c1_dim3 = *l1;\n    c1_offset = 1 + c1_dim1 * (1 + c1_dim2 * (1 + c1_dim3));\n    c1 -= c1_offset;\n    cc_dim1 = *in1;\n    cc_dim2 = *ido;\n    cc_dim3 = *ip;\n    cc_offset = 1 + cc_dim1 * (1 + cc_dim2 * (1 + cc_dim3));\n    cc -= cc_offset;\n    ch2_dim1 = *in2;\n    ch2_dim2 = *idl1;\n    ch2_offset = 1 + ch2_dim1 * (1 + ch2_dim2);\n    ch2 -= ch2_offset;\n    ch_dim1 = *in2;\n    ch_dim2 = *ido;\n    ch_dim3 = *l1;\n    ch_offset = 1 + ch_dim1 * (1 + ch_dim2 * (1 + ch_dim3));\n    ch -= ch_offset;\n\n    /* Function Body */\n    tpi = atanf(1.0f) * 8.0f;\n    arg = tpi / (float) (*ip);\n    dcp = cosf(arg);\n    dsp = sinf(arg);\n    ipph = (*ip + 1) / 2;\n    ipp2 = *ip + 2;\n    idp2 = *ido + 2;\n    nbd = (*ido - 1) / 2;\n    if (*ido == 1) {\n\tgoto L119;\n    }\n    i__1 = *idl1;\n    for (ik = 1; ik <= i__1; ++ik) {\n\tch2[(ik + ch2_dim2) * ch2_dim1 + 1] = c2[(ik + c2_dim2) * c2_dim1 + 1]\n\t\t;\n/* L101: */\n    }\n    i__1 = *ip;\n    for (j = 2; j <= i__1; ++j) {\n\ti__2 = *l1;\n\tfor (k = 1; k <= i__2; ++k) {\n\t    ch[((k + j * ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1] = c1[((k + j *\n\t\t     c1_dim3) * c1_dim2 + 1) * c1_dim1 + 1];\n/* L102: */\n\t}\n/* L103: */\n    }\n    if (nbd > *l1) {\n\tgoto L107;\n    }\n    is = -(*ido);\n    i__1 = *ip;\n    for (j = 2; j <= i__1; ++j) {\n\tis += *ido;\n\tidij = is;\n\ti__2 = *ido;\n\tfor (i__ = 3; i__ <= i__2; i__ += 2) {\n\t    idij += 2;\n\t    i__3 = *l1;\n\t    for (k = 1; k <= i__3; ++k) {\n\t\tch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] =\n\t\t\twa[idij - 1] * c1[(i__ - 1 + (k + j * c1_dim3) *\n\t\t\tc1_dim2) * c1_dim1 + 1] + wa[idij] * c1[(i__ + (k + j\n\t\t\t* c1_dim3) * c1_dim2) * c1_dim1 + 1];\n\t\tch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] = wa[\n\t\t\tidij - 1] * c1[(i__ + (k + j * c1_dim3) * c1_dim2) *\n\t\t\tc1_dim1 + 1] - wa[idij] * c1[(i__ - 1 + (k + j *\n\t\t\tc1_dim3) * c1_dim2) * c1_dim1 + 1];\n/* L104: */\n\t    }\n/* L105: */\n\t}\n/* L106: */\n    }\n    goto L111;\nL107:\n    is = -(*ido);\n    i__1 = *ip;\n    for (j = 2; j <= i__1; ++j) {\n\tis += *ido;\n\ti__2 = *l1;\n\tfor (k = 1; k <= i__2; ++k) {\n\t    idij = is;\n\t    i__3 = *ido;\n\t    for (i__ = 3; i__ <= i__3; i__ += 2) {\n\t\tidij += 2;\n\t\tch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] =\n\t\t\twa[idij - 1] * c1[(i__ - 1 + (k + j * c1_dim3) *\n\t\t\tc1_dim2) * c1_dim1 + 1] + wa[idij] * c1[(i__ + (k + j\n\t\t\t* c1_dim3) * c1_dim2) * c1_dim1 + 1];\n\t\tch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] = wa[\n\t\t\tidij - 1] * c1[(i__ + (k + j * c1_dim3) * c1_dim2) *\n\t\t\tc1_dim1 + 1] - wa[idij] * c1[(i__ - 1 + (k + j *\n\t\t\tc1_dim3) * c1_dim2) * c1_dim1 + 1];\n/* L108: */\n\t    }\n/* L109: */\n\t}\n/* L110: */\n    }\nL111:\n    if (nbd < *l1) {\n\tgoto L115;\n    }\n    i__1 = ipph;\n    for (j = 2; j <= i__1; ++j) {\n\tjc = ipp2 - j;\n\ti__2 = *l1;\n\tfor (k = 1; k <= i__2; ++k) {\n\t    i__3 = *ido;\n\t    for (i__ = 3; i__ <= i__3; i__ += 2) {\n\t\tc1[(i__ - 1 + (k + j * c1_dim3) * c1_dim2) * c1_dim1 + 1] =\n\t\t\tch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) * ch_dim1\n\t\t\t+ 1] + ch[(i__ - 1 + (k + jc * ch_dim3) * ch_dim2) *\n\t\t\tch_dim1 + 1];\n\t\tc1[(i__ - 1 + (k + jc * c1_dim3) * c1_dim2) * c1_dim1 + 1] =\n\t\t\tch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t- ch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 +\n\t\t\t1];\n\t\tc1[(i__ + (k + j * c1_dim3) * c1_dim2) * c1_dim1 + 1] = ch[(\n\t\t\ti__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] +\n\t\t\tch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t;\n\t\tc1[(i__ + (k + jc * c1_dim3) * c1_dim2) * c1_dim1 + 1] = ch[(\n\t\t\ti__ - 1 + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t - ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) *\n\t\t\tch_dim1 + 1];\n/* L112: */\n\t    }\n/* L113: */\n\t}\n/* L114: */\n    }\n    goto L121;\nL115:\n    i__1 = ipph;\n    for (j = 2; j <= i__1; ++j) {\n\tjc = ipp2 - j;\n\ti__2 = *ido;\n\tfor (i__ = 3; i__ <= i__2; i__ += 2) {\n\t    i__3 = *l1;\n\t    for (k = 1; k <= i__3; ++k) {\n\t\tc1[(i__ - 1 + (k + j * c1_dim3) * c1_dim2) * c1_dim1 + 1] =\n\t\t\tch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) * ch_dim1\n\t\t\t+ 1] + ch[(i__ - 1 + (k + jc * ch_dim3) * ch_dim2) *\n\t\t\tch_dim1 + 1];\n\t\tc1[(i__ - 1 + (k + jc * c1_dim3) * c1_dim2) * c1_dim1 + 1] =\n\t\t\tch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t- ch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 +\n\t\t\t1];\n\t\tc1[(i__ + (k + j * c1_dim3) * c1_dim2) * c1_dim1 + 1] = ch[(\n\t\t\ti__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] +\n\t\t\tch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t;\n\t\tc1[(i__ + (k + jc * c1_dim3) * c1_dim2) * c1_dim1 + 1] = ch[(\n\t\t\ti__ - 1 + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t - ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) *\n\t\t\tch_dim1 + 1];\n/* L116: */\n\t    }\n/* L117: */\n\t}\n/* L118: */\n    }\n    goto L121;\nL119:\n    i__1 = *idl1;\n    for (ik = 1; ik <= i__1; ++ik) {\n\tc2[(ik + c2_dim2) * c2_dim1 + 1] = ch2[(ik + ch2_dim2) * ch2_dim1 + 1]\n\t\t;\n/* L120: */\n    }\nL121:\n    i__1 = ipph;\n    for (j = 2; j <= i__1; ++j) {\n\tjc = ipp2 - j;\n\ti__2 = *l1;\n\tfor (k = 1; k <= i__2; ++k) {\n\t    c1[((k + j * c1_dim3) * c1_dim2 + 1) * c1_dim1 + 1] = ch[((k + j *\n\t\t     ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1] + ch[((k + jc *\n\t\t    ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1];\n\t    c1[((k + jc * c1_dim3) * c1_dim2 + 1) * c1_dim1 + 1] = ch[((k +\n\t\t    jc * ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1] - ch[((k + j *\n\t\t     ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1];\n/* L122: */\n\t}\n/* L123: */\n    }\n\n    ar1 = 1.0f;\n    ai1 = 0.0f;\n    i__1 = ipph;\n    for (l = 2; l <= i__1; ++l) {\n\tlc = ipp2 - l;\n\tar1h = dcp * ar1 - dsp * ai1;\n\tai1 = dcp * ai1 + dsp * ar1;\n\tar1 = ar1h;\n\ti__2 = *idl1;\n\tfor (ik = 1; ik <= i__2; ++ik) {\n\t    ch2[(ik + l * ch2_dim2) * ch2_dim1 + 1] = c2[(ik + c2_dim2) *\n\t\t    c2_dim1 + 1] + ar1 * c2[(ik + (c2_dim2 << 1)) * c2_dim1 +\n\t\t    1];\n\t    ch2[(ik + lc * ch2_dim2) * ch2_dim1 + 1] = ai1 * c2[(ik + *ip *\n\t\t    c2_dim2) * c2_dim1 + 1];\n/* L124: */\n\t}\n\tdc2 = ar1;\n\tds2 = ai1;\n\tar2 = ar1;\n\tai2 = ai1;\n\ti__2 = ipph;\n\tfor (j = 3; j <= i__2; ++j) {\n\t    jc = ipp2 - j;\n\t    ar2h = dc2 * ar2 - ds2 * ai2;\n\t    ai2 = dc2 * ai2 + ds2 * ar2;\n\t    ar2 = ar2h;\n\t    i__3 = *idl1;\n\t    for (ik = 1; ik <= i__3; ++ik) {\n\t\tch2[(ik + l * ch2_dim2) * ch2_dim1 + 1] += ar2 * c2[(ik + j *\n\t\t\tc2_dim2) * c2_dim1 + 1];\n\t\tch2[(ik + lc * ch2_dim2) * ch2_dim1 + 1] += ai2 * c2[(ik + jc\n\t\t\t* c2_dim2) * c2_dim1 + 1];\n/* L125: */\n\t    }\n/* L126: */\n\t}\n/* L127: */\n    }\n    i__1 = ipph;\n    for (j = 2; j <= i__1; ++j) {\n\ti__2 = *idl1;\n\tfor (ik = 1; ik <= i__2; ++ik) {\n\t    ch2[(ik + ch2_dim2) * ch2_dim1 + 1] += c2[(ik + j * c2_dim2) *\n\t\t    c2_dim1 + 1];\n/* L128: */\n\t}\n/* L129: */\n    }\n\n    if (*ido < *l1) {\n\tgoto L132;\n    }\n    i__1 = *l1;\n    for (k = 1; k <= i__1; ++k) {\n\ti__2 = *ido;\n\tfor (i__ = 1; i__ <= i__2; ++i__) {\n\t    cc[(i__ + (k * cc_dim3 + 1) * cc_dim2) * cc_dim1 + 1] = ch[(i__ +\n\t\t    (k + ch_dim3) * ch_dim2) * ch_dim1 + 1];\n/* L130: */\n\t}\n/* L131: */\n    }\n    goto L135;\nL132:\n    i__1 = *ido;\n    for (i__ = 1; i__ <= i__1; ++i__) {\n\ti__2 = *l1;\n\tfor (k = 1; k <= i__2; ++k) {\n\t    cc[(i__ + (k * cc_dim3 + 1) * cc_dim2) * cc_dim1 + 1] = ch[(i__ +\n\t\t    (k + ch_dim3) * ch_dim2) * ch_dim1 + 1];\n/* L133: */\n\t}\n/* L134: */\n    }\nL135:\n    i__1 = ipph;\n    for (j = 2; j <= i__1; ++j) {\n\tjc = ipp2 - j;\n\tj2 = j + j;\n\ti__2 = *l1;\n\tfor (k = 1; k <= i__2; ++k) {\n\t    cc[(*ido + (j2 - 2 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1] = ch[(\n\t\t    (k + j * ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1];\n\t    cc[((j2 - 1 + k * cc_dim3) * cc_dim2 + 1) * cc_dim1 + 1] = ch[((k\n\t\t    + jc * ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1];\n/* L136: */\n\t}\n/* L137: */\n    }\n    if (*ido == 1) {\n\treturn 0;\n    }\n    if (nbd < *l1) {\n\tgoto L141;\n    }\n    i__1 = ipph;\n    for (j = 2; j <= i__1; ++j) {\n\tjc = ipp2 - j;\n\tj2 = j + j;\n\ti__2 = *l1;\n\tfor (k = 1; k <= i__2; ++k) {\n\t    i__3 = *ido;\n\t    for (i__ = 3; i__ <= i__3; i__ += 2) {\n\t\tic = idp2 - i__;\n\t\tcc[(i__ - 1 + (j2 - 1 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1]\n\t\t\t = ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) *\n\t\t\tch_dim1 + 1] + ch[(i__ - 1 + (k + jc * ch_dim3) *\n\t\t\tch_dim2) * ch_dim1 + 1];\n\t\tcc[(ic - 1 + (j2 - 2 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1]\n\t\t\t= ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) *\n\t\t\tch_dim1 + 1] - ch[(i__ - 1 + (k + jc * ch_dim3) *\n\t\t\tch_dim2) * ch_dim1 + 1];\n\t\tcc[(i__ + (j2 - 1 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1] =\n\t\t\tch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t+ ch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 +\n\t\t\t1];\n\t\tcc[(ic + (j2 - 2 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1] =\n\t\t\tch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t - ch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 +\n\t\t\t1];\n/* L138: */\n\t    }\n/* L139: */\n\t}\n/* L140: */\n    }\n    return 0;\nL141:\n    i__1 = ipph;\n    for (j = 2; j <= i__1; ++j) {\n\tjc = ipp2 - j;\n\tj2 = j + j;\n\ti__2 = *ido;\n\tfor (i__ = 3; i__ <= i__2; i__ += 2) {\n\t    ic = idp2 - i__;\n\t    i__3 = *l1;\n\t    for (k = 1; k <= i__3; ++k) {\n\t\tcc[(i__ - 1 + (j2 - 1 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1]\n\t\t\t = ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) *\n\t\t\tch_dim1 + 1] + ch[(i__ - 1 + (k + jc * ch_dim3) *\n\t\t\tch_dim2) * ch_dim1 + 1];\n\t\tcc[(ic - 1 + (j2 - 2 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1]\n\t\t\t= ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) *\n\t\t\tch_dim1 + 1] - ch[(i__ - 1 + (k + jc * ch_dim3) *\n\t\t\tch_dim2) * ch_dim1 + 1];\n\t\tcc[(i__ + (j2 - 1 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1] =\n\t\t\tch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t+ ch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 +\n\t\t\t1];\n\t\tcc[(ic + (j2 - 2 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1] =\n\t\t\tch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t - ch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 +\n\t\t\t1];\n/* L142: */\n\t    }\n/* L143: */\n\t}\n/* L144: */\n    }\n    return 0;\n}", "item_id": 79, "repo": "forksnd/rouziclib", "file": "rouziclib/libraries/orig/fftpack_float.c", "last_update_at": "2022-01-18T20:54:05+00:00", "question_id": "e0b8bb7e849387069c81697f48cd76138e681886_79", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int r1fgkf_f(int *ido, int *ip, int *l1, int *\n\tidl1, float *cc, float *c1, float *c2, int *in1, float *ch, float *ch2,\n\t int *in2, float *wa)\n{\n    /* System generated locals */\n    int ch_dim1, ch_dim2, ch_dim3, ch_offset, cc_dim1, cc_dim2, cc_dim3,\n\t    cc_offset, c1_dim1, c1_dim2, c1_dim3, c1_offset, c2_dim1, c2_dim2,\n\t     c2_offset, ch2_dim1, ch2_dim2, ch2_offset, i__1, i__2, i__3;\n    /* Builtin functions */\n    /* Local variables */\n     int i__, j, k, l, j2, ic, jc, lc, ik, is;\n     float dc2, ai1, ai2, ar1, ar2, ds2;\n     int nbd;\n     float dcp, arg, dsp, tpi, ar1h, ar2h;\n     int idp2, ipp2, idij, ipph;\n    /* Parameter adjustments */\n    --wa;\n    c2_dim1 = *in1;\n    c2_dim2 = *idl1;\n    c2_offset = 1 + c2_dim1 * (1 + c2_dim2);\n    c2 -= c2_offset;\n    c1_dim1 = *in1;\n    c1_dim2 = *ido;\n    c1_dim3 = *l1;\n    c1_offset = 1 + c1_dim1 * (1 + c1_dim2 * (1 + c1_dim3));\n    c1 -= c1_offset;\n    cc_dim1 = *in1;\n    cc_dim2 = *ido;\n    cc_dim3 = *ip;\n    cc_offset = 1 + cc_dim1 * (1 + cc_dim2 * (1 + cc_dim3));\n    cc -= cc_offset;\n    ch2_dim1 = *in2;\n    ch2_dim2 = *idl1;\n    ch2_offset = 1 + ch2_dim1 * (1 + ch2_dim2);\n    ch2 -= ch2_offset;\n    ch_dim1 = *in2;\n    ch_dim2 = *ido;\n    ch_dim3 = *l1;\n    ch_offset = 1 + ch_dim1 * (1 + ch_dim2 * (1 + ch_dim3));\n    ch -= ch_offset;\n    /* Function Body */\n    tpi = atanf(1.0f) * 8.0f;\n    arg = tpi / (float) (*ip);\n    dcp = cosf(arg);\n    dsp = sinf(arg);\n    ipph = (*ip + 1) / 2;\n    ipp2 = *ip + 2;\n    idp2 = *ido + 2;\n    nbd = (*ido - 1) / 2;\n    if (*ido == 1) {\n\tgoto L119;\n    }\n    i__1 = *idl1;\n    for (ik = 1; ik <= i__1; ++ik) {\n\tch2[(ik + ch2_dim2) * ch2_dim1 + 1] = c2[(ik + c2_dim2) * c2_dim1 + 1]\n\t\t;\n/* L101: */\n    }\n    i__1 = *ip;\n    for (j = 2; j <= i__1; ++j) {\n\ti__2 = *l1;\n\tfor (k = 1; k <= i__2; ++k) {\n\t    ch[((k + j * ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1] = c1[((k + j *\n\t\t     c1_dim3) * c1_dim2 + 1) * c1_dim1 + 1];\n/* L102: */\n\t}\n/* L103: */\n    }\n    if (nbd > *l1) {\n\tgoto L107;\n    }\n    is = -(*ido);\n    i__1 = *ip;\n    for (j = 2; j <= i__1; ++j) {\n\tis += *ido;\n\tidij = is;\n\ti__2 = *ido;\n\tfor (i__ = 3; i__ <= i__2; i__ += 2) {\n\t    idij += 2;\n\t    i__3 = *l1;\n\t    for (k = 1; k <= i__3; ++k) {\n\t\tch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] =\n\t\t\twa[idij - 1] * c1[(i__ - 1 + (k + j * c1_dim3) *\n\t\t\tc1_dim2) * c1_dim1 + 1] + wa[idij] * c1[(i__ + (k + j\n\t\t\t* c1_dim3) * c1_dim2) * c1_dim1 + 1];\n\t\tch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] = wa[\n\t\t\tidij - 1] * c1[(i__ + (k + j * c1_dim3) * c1_dim2) *\n\t\t\tc1_dim1 + 1] - wa[idij] * c1[(i__ - 1 + (k + j *\n\t\t\tc1_dim3) * c1_dim2) * c1_dim1 + 1];\n/* L104: */\n\t    }\n/* L105: */\n\t}\n/* L106: */\n    }\n    goto L111;\nL107:\n    is = -(*ido);\n    i__1 = *ip;\n    for (j = 2; j <= i__1; ++j) {\n\tis += *ido;\n\ti__2 = *l1;\n\tfor (k = 1; k <= i__2; ++k) {\n\t    idij = is;\n\t    i__3 = *ido;\n\t    for (i__ = 3; i__ <= i__3; i__ += 2) {\n\t\tidij += 2;\n\t\tch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] =\n\t\t\twa[idij - 1] * c1[(i__ - 1 + (k + j * c1_dim3) *\n\t\t\tc1_dim2) * c1_dim1 + 1] + wa[idij] * c1[(i__ + (k + j\n\t\t\t* c1_dim3) * c1_dim2) * c1_dim1 + 1];\n\t\tch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] = wa[\n\t\t\tidij - 1] * c1[(i__ + (k + j * c1_dim3) * c1_dim2) *\n\t\t\tc1_dim1 + 1] - wa[idij] * c1[(i__ - 1 + (k + j *\n\t\t\tc1_dim3) * c1_dim2) * c1_dim1 + 1];\n/* L108: */\n\t    }\n/* L109: */\n\t}\n/* L110: */\n    }\nL111:\n    if (nbd < *l1) {\n\tgoto L115;\n    }\n    i__1 = ipph;\n    for (j = 2; j <= i__1; ++j) {\n\tjc = ipp2 - j;\n\ti__2 = *l1;\n\tfor (k = 1; k <= i__2; ++k) {\n\t    i__3 = *ido;\n\t    for (i__ = 3; i__ <= i__3; i__ += 2) {\n\t\tc1[(i__ - 1 + (k + j * c1_dim3) * c1_dim2) * c1_dim1 + 1] =\n\t\t\tch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) * ch_dim1\n\t\t\t+ 1] + ch[(i__ - 1 + (k + jc * ch_dim3) * ch_dim2) *\n\t\t\tch_dim1 + 1];\n\t\tc1[(i__ - 1 + (k + jc * c1_dim3) * c1_dim2) * c1_dim1 + 1] =\n\t\t\tch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t- ch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 +\n\t\t\t1];\n\t\tc1[(i__ + (k + j * c1_dim3) * c1_dim2) * c1_dim1 + 1] = ch[(\n\t\t\ti__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] +\n\t\t\tch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t;\n\t\tc1[(i__ + (k + jc * c1_dim3) * c1_dim2) * c1_dim1 + 1] = ch[(\n\t\t\ti__ - 1 + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t - ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) *\n\t\t\tch_dim1 + 1];\n/* L112: */\n\t    }\n/* L113: */\n\t}\n/* L114: */\n    }\n    goto L121;\nL115:\n    i__1 = ipph;\n    for (j = 2; j <= i__1; ++j) {\n\tjc = ipp2 - j;\n\ti__2 = *ido;\n\tfor (i__ = 3; i__ <= i__2; i__ += 2) {\n\t    i__3 = *l1;\n\t    for (k = 1; k <= i__3; ++k) {\n\t\tc1[(i__ - 1 + (k + j * c1_dim3) * c1_dim2) * c1_dim1 + 1] =\n\t\t\tch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) * ch_dim1\n\t\t\t+ 1] + ch[(i__ - 1 + (k + jc * ch_dim3) * ch_dim2) *\n\t\t\tch_dim1 + 1];\n\t\tc1[(i__ - 1 + (k + jc * c1_dim3) * c1_dim2) * c1_dim1 + 1] =\n\t\t\tch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t- ch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 +\n\t\t\t1];\n\t\tc1[(i__ + (k + j * c1_dim3) * c1_dim2) * c1_dim1 + 1] = ch[(\n\t\t\ti__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] +\n\t\t\tch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t;\n\t\tc1[(i__ + (k + jc * c1_dim3) * c1_dim2) * c1_dim1 + 1] = ch[(\n\t\t\ti__ - 1 + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t - ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) *\n\t\t\tch_dim1 + 1];\n/* L116: */\n\t    }\n/* L117: */\n\t}\n/* L118: */\n    }\n    goto L121;\nL119:\n    i__1 = *idl1;\n    for (ik = 1; ik <= i__1; ++ik) {\n\tc2[(ik + c2_dim2) * c2_dim1 + 1] = ch2[(ik + ch2_dim2) * ch2_dim1 + 1]\n\t\t;\n/* L120: */\n    }\nL121:\n    i__1 = ipph;\n    for (j = 2; j <= i__1; ++j) {\n\tjc = ipp2 - j;\n\ti__2 = *l1;\n\tfor (k = 1; k <= i__2; ++k) {\n\t    c1[((k + j * c1_dim3) * c1_dim2 + 1) * c1_dim1 + 1] = ch[((k + j *\n\t\t     ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1] + ch[((k + jc *\n\t\t    ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1];\n\t    c1[((k + jc * c1_dim3) * c1_dim2 + 1) * c1_dim1 + 1] = ch[((k +\n\t\t    jc * ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1] - ch[((k + j *\n\t\t     ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1];\n/* L122: */\n\t}\n/* L123: */\n    }\n    ar1 = 1.0f;\n    ai1 = 0.0f;\n    i__1 = ipph;\n    for (l = 2; l <= i__1; ++l) {\n\tlc = ipp2 - l;\n\tar1h = dcp * ar1 - dsp * ai1;\n\tai1 = dcp * ai1 + dsp * ar1;\n\tar1 = ar1h;\n\ti__2 = *idl1;\n\tfor (ik = 1; ik <= i__2; ++ik) {\n\t    ch2[(ik + l * ch2_dim2) * ch2_dim1 + 1] = c2[(ik + c2_dim2) *\n\t\t    c2_dim1 + 1] + ar1 * c2[(ik + (c2_dim2 << 1)) * c2_dim1 +\n\t\t    1];\n\t    ch2[(ik + lc * ch2_dim2) * ch2_dim1 + 1] = ai1 * c2[(ik + *ip *\n\t\t    c2_dim2) * c2_dim1 + 1];\n/* L124: */\n\t}\n\tdc2 = ar1;\n\tds2 = ai1;\n\tar2 = ar1;\n\tai2 = ai1;\n\ti__2 = ipph;\n\tfor (j = 3; j <= i__2; ++j) {\n\t    jc = ipp2 - j;\n\t    ar2h = dc2 * ar2 - ds2 * ai2;\n\t    ai2 = dc2 * ai2 + ds2 * ar2;\n\t    ar2 = ar2h;\n\t    i__3 = *idl1;\n\t    for (ik = 1; ik <= i__3; ++ik) {\n\t\tch2[(ik + l * ch2_dim2) * ch2_dim1 + 1] += ar2 * c2[(ik + j *\n\t\t\tc2_dim2) * c2_dim1 + 1];\n\t\tch2[(ik + lc * ch2_dim2) * ch2_dim1 + 1] += ai2 * c2[(ik + jc\n\t\t\t* c2_dim2) * c2_dim1 + 1];\n/* L125: */\n\t    }\n/* L126: */\n\t}\n/* L127: */\n    }\n    i__1 = ipph;\n    for (j = 2; j <= i__1; ++j) {\n\ti__2 = *idl1;\n\tfor (ik = 1; ik <= i__2; ++ik) {\n\t    ch2[(ik + ch2_dim2) * ch2_dim1 + 1] += c2[(ik + j * c2_dim2) *\n\t\t    c2_dim1 + 1];\n/* L128: */\n\t}\n/* L129: */\n    }\n    if (*ido < *l1) {\n\tgoto L132;\n    }\n    i__1 = *l1;\n    for (k = 1; k <= i__1; ++k) {\n\ti__2 = *ido;\n\tfor (i__ = 1; i__ <= i__2; ++i__) {\n\t    cc[(i__ + (k * cc_dim3 + 1) * cc_dim2) * cc_dim1 + 1] = ch[(i__ +\n\t\t    (k + ch_dim3) * ch_dim2) * ch_dim1 + 1];\n/* L130: */\n\t}\n/* L131: */\n    }\n    goto L135;\nL132:\n    i__1 = *ido;\n    for (i__ = 1; i__ <= i__1; ++i__) {\n\ti__2 = *l1;\n\tfor (k = 1; k <= i__2; ++k) {\n\t    cc[(i__ + (k * cc_dim3 + 1) * cc_dim2) * cc_dim1 + 1] = ch[(i__ +\n\t\t    (k + ch_dim3) * ch_dim2) * ch_dim1 + 1];\n/* L133: */\n\t}\n/* L134: */\n    }\nL135:\n    i__1 = ipph;\n    for (j = 2; j <= i__1; ++j) {\n\tjc = ipp2 - j;\n\tj2 = j + j;\n\ti__2 = *l1;\n\tfor (k = 1; k <= i__2; ++k) {\n\t    cc[(*ido + (j2 - 2 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1] = ch[(\n\t\t    (k + j * ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1];\n\t    cc[((j2 - 1 + k * cc_dim3) * cc_dim2 + 1) * cc_dim1 + 1] = ch[((k\n\t\t    + jc * ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1];\n/* L136: */\n\t}\n/* L137: */\n    }\n    if (*ido == 1) {\n\treturn 0;\n    }\n    if (nbd < *l1) {\n\tgoto L141;\n    }\n    i__1 = ipph;\n    for (j = 2; j <= i__1; ++j) {\n\tjc = ipp2 - j;\n\tj2 = j + j;\n\ti__2 = *l1;\n\tfor (k = 1; k <= i__2; ++k) {\n\t    i__3 = *ido;\n\t    for (i__ = 3; i__ <= i__3; i__ += 2) {\n\t\tic = idp2 - i__;\n\t\tcc[(i__ - 1 + (j2 - 1 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1]\n\t\t\t = ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) *\n\t\t\tch_dim1 + 1] + ch[(i__ - 1 + (k + jc * ch_dim3) *\n\t\t\tch_dim2) * ch_dim1 + 1];\n\t\tcc[(ic - 1 + (j2 - 2 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1]\n\t\t\t= ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) *\n\t\t\tch_dim1 + 1] - ch[(i__ - 1 + (k + jc * ch_dim3) *\n\t\t\tch_dim2) * ch_dim1 + 1];\n\t\tcc[(i__ + (j2 - 1 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1] =\n\t\t\tch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t+ ch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 +\n\t\t\t1];\n\t\tcc[(ic + (j2 - 2 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1] =\n\t\t\tch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t - ch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 +\n\t\t\t1];\n/* L138: */\n\t    }\n/* L139: */\n\t}\n/* L140: */\n    }\n    return 0;\nL141:\n    i__1 = ipph;\n    for (j = 2; j <= i__1; ++j) {\n\tjc = ipp2 - j;\n\tj2 = j + j;\n\ti__2 = *ido;\n\tfor (i__ = 3; i__ <= i__2; i__ += 2) {\n\t    ic = idp2 - i__;\n\t    i__3 = *l1;\n\t    for (k = 1; k <= i__3; ++k) {\n\t\tcc[(i__ - 1 + (j2 - 1 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1]\n\t\t\t = ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) *\n\t\t\tch_dim1 + 1] + ch[(i__ - 1 + (k + jc * ch_dim3) *\n\t\t\tch_dim2) * ch_dim1 + 1];\n\t\tcc[(ic - 1 + (j2 - 2 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1]\n\t\t\t= ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) *\n\t\t\tch_dim1 + 1] - ch[(i__ - 1 + (k + jc * ch_dim3) *\n\t\t\tch_dim2) * ch_dim1 + 1];\n\t\tcc[(i__ + (j2 - 1 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1] =\n\t\t\tch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t+ ch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 +\n\t\t\t1];\n\t\tcc[(ic + (j2 - 2 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1] =\n\t\t\tch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 + 1]\n\t\t\t - ch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 +\n\t\t\t1];\n/* L142: */\n\t    }\n/* L143: */\n\t}\n/* L144: */\n    }\n    return 0;\n"]]}
{"hexsha": "053259a02326bb61023ec6d1eef92febc8d166c4", "ext": "c", "lang": "C", "content": "void func_65(var uParam0)\r\n{\r\n\t*uParam0 = 0;\r\n\tuParam0->f_1 = 0;\r\n\tuParam0->f_2 = 0;\r\n\tuParam0->f_3 = 0;\r\n\tuParam0->f_4 = 0;\r\n\tuParam0->f_5 = 0;\r\n\tuParam0->f_6 = 0;\r\n\tuParam0->f_7 = 0;\r\n\tuParam0->f_8 = 0;\r\n\tuParam0->f_9 = 0;\r\n\tuParam0->f_10 = 0;\r\n\tuParam0->f_11 = 0;\r\n\tuParam0->f_12 = 0;\r\n}", "item_id": 25, "repo": "Sainan/GTA-V-Decompiled-Scripts", "file": "decompiled_scripts/valentinerpreward2.c", "last_update_at": "2022-03-31T13:05:47+00:00", "question_id": "053259a02326bb61023ec6d1eef92febc8d166c4_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void func_65(var uParam0)\r\n{\r\n\t*uParam0 = 0;\r\n\tuParam0->f_1 = 0;\r\n\tuParam0->f_2 = 0;\r\n\tuParam0->f_3 = 0;\r\n\tuParam0->f_4 = 0;\r\n\tuParam0->f_5 = 0;\r\n\tuParam0->f_6 = 0;\r\n\tuParam0->f_7 = 0;\r\n\tuParam0->f_8 = 0;\r\n\tuParam0->f_9 = 0;\r\n\tuParam0->f_10 = 0;\r\n\tuParam0->f_11 = 0;\r\n\tuParam0->f_12 = 0;\r\n"]]}
{"hexsha": "cf42e96b4f44c3879419e1fe162327cfc743ab91", "ext": "h", "lang": "C", "content": "static int _find_upper(int ch)  {\n\n\n\tint low = 0;\n\tint high = CAPS_LEN -1;\n\tint middle;\n\n\twhile( low <= high )\n\t{\n\t\tmiddle = ( low  + high ) / 2;\n\n\t\tif( ch < caps_table[ middle][0] ) {\n\t\t\thigh = middle - 1; //search low end of array\n\t\t} else if ( caps_table[middle][0] < ch) {\n\t\t\tlow = middle + 1; //search high end of array\n\t\t} else {\n\t\t\treturn caps_table[middle][1];\n\t\t}\n\t}\n\n\treturn ch;\n}", "item_id": 0, "repo": "leyyin/godot", "file": "core/ucaps.h", "last_update_at": "2022-01-15T06:39:17+00:00", "question_id": "cf42e96b4f44c3879419e1fe162327cfc743ab91_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int _find_upper(int ch)  {\n\tint low = 0;\n\tint high = CAPS_LEN -1;\n\tint middle;\n\twhile( low <= high )\n\t{\n\t\tmiddle = ( low  + high ) / 2;\n\t\tif( ch < caps_table[ middle][0] ) {\n\t\t\thigh = middle - 1; //search low end of array\n\t\t} else if ( caps_table[middle][0] < ch) {\n\t\t\tlow = middle + 1; //search high end of array\n\t\t} else {\n\t\t\treturn caps_table[middle][1];\n\t\t}\n\t}\n\treturn ch;\n"]]}
{"hexsha": "46b5da551db35711ad529639cf0ddf4f7abaaba0", "ext": "c", "lang": "C", "content": "static void\nnvc0_blit_set_dst(struct nvc0_context *nvc0,\n                  struct pipe_resource *res, unsigned level, unsigned layer)\n{\n   struct pipe_context *pipe = &nvc0->base.pipe;\n   struct pipe_surface templ;\n\n   if (util_format_is_depth_or_stencil(res->format))\n      templ.format = nvc0_blit_zeta_to_colour_format(res->format);\n   else\n      templ.format = res->format;\n\n   templ.usage = PIPE_USAGE_STREAM;\n   templ.u.tex.level = level;\n   templ.u.tex.first_layer = templ.u.tex.last_layer = layer;\n\n   nvc0->framebuffer.cbufs[0] = nvc0_miptree_surface_new(pipe, res, &templ);\n   nvc0->framebuffer.nr_cbufs = 1;\n   nvc0->framebuffer.zsbuf = NULL;\n   nvc0->framebuffer.width = nvc0->framebuffer.cbufs[0]->width;\n   nvc0->framebuffer.height = nvc0->framebuffer.cbufs[0]->height;\n}", "item_id": 10, "repo": "MauroArgentino/RSXGL", "file": "extsrc/mesa/src/gallium/drivers/nvc0/nvc0_surface.c", "last_update_at": "2022-03-26T04:14:16+00:00", "question_id": "46b5da551db35711ad529639cf0ddf4f7abaaba0_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nnvc0_blit_set_dst(struct nvc0_context *nvc0,\n                  struct pipe_resource *res, unsigned level, unsigned layer)\n{\n   struct pipe_context *pipe = &nvc0->base.pipe;\n   struct pipe_surface templ;\n   if (util_format_is_depth_or_stencil(res->format))\n      templ.format = nvc0_blit_zeta_to_colour_format(res->format);\n   else\n      templ.format = res->format;\n   templ.usage = PIPE_USAGE_STREAM;\n   templ.u.tex.level = level;\n   templ.u.tex.first_layer = templ.u.tex.last_layer = layer;\n   nvc0->framebuffer.cbufs[0] = nvc0_miptree_surface_new(pipe, res, &templ);\n   nvc0->framebuffer.nr_cbufs = 1;\n   nvc0->framebuffer.zsbuf = NULL;\n   nvc0->framebuffer.width = nvc0->framebuffer.cbufs[0]->width;\n   nvc0->framebuffer.height = nvc0->framebuffer.cbufs[0]->height;\n"]]}
{"hexsha": "206b812b6e7bf34b78a74a32e4cafdb0ea1a1c91", "ext": "c", "lang": "C", "content": "static int ramfs_write(int fd, int from_pid, fsinfo_t* info,\n\t\tconst void* buf, int size, int offset, void* p) {\n\t(void)fd;\n\t(void)from_pid;\n\t(void)p;\n\n\tif(offset < 0)\n\t\toffset = 0;\n\tif(size <= 0)\n\t\treturn size;\n\n\tchar* data = (char*)info->data;\n\tdata = (char*)realloc(data, size + offset);\n\tmemcpy(data+offset, buf, size);\n\tinfo->data = (uint32_t)data;\n\tinfo->size = size+offset;\n\tvfs_set(info);\n\treturn size;\n}", "item_id": 1, "repo": "karlzheng/EwokOS", "file": "system/basic/drivers/ramfsd/ramfsd.c", "last_update_at": "2022-03-15T08:25:16+00:00", "question_id": "206b812b6e7bf34b78a74a32e4cafdb0ea1a1c91_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int ramfs_write(int fd, int from_pid, fsinfo_t* info,\n\t\tconst void* buf, int size, int offset, void* p) {\n\t(void)fd;\n\t(void)from_pid;\n\t(void)p;\n\tif(offset < 0)\n\t\toffset = 0;\n\tif(size <= 0)\n\t\treturn size;\n\tchar* data = (char*)info->data;\n\tdata = (char*)realloc(data, size + offset);\n\tmemcpy(data+offset, buf, size);\n\tinfo->data = (uint32_t)data;\n\tinfo->size = size+offset;\n\tvfs_set(info);\n\treturn size;\n"]]}
{"hexsha": "415cfc30a4f6bc334dbd2ae41596e666b641748f", "ext": "c", "lang": "C", "content": "MM_API int mm_manage_fd(int new_fd, char* back, int manage, void* impl){\n\tbackend* b = backend_match(back);\n\tsize_t u;\n\n\tif(!b){\n\t\tLOGPF(\"Unknown backend %s registered for managed fd\", back);\n\t\treturn 1;\n\t}\n\n\t//find exact match\n\tfor(u = 0; u < fds.n; u++){\n\t\tif(fds.fd[u].fd == new_fd && fds.fd[u].backend == b){\n\t\t\tfds.fd[u].impl = impl;\n\t\t\tif(!manage){\n\t\t\t\tfds.fd[u].fd = -1;\n\t\t\t\tfds.fd[u].backend = NULL;\n\t\t\t\tfds.fd[u].impl = NULL;\n\t\t\t\tfd_set_dirty = 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif(!manage){\n\t\treturn 0;\n\t}\n\n\t//find free slot\n\tfor(u = 0; u < fds.n; u++){\n\t\tif(fds.fd[u].fd < 0){\n\t\t\tbreak;\n\t\t}\n\t}\n\t//if necessary expand\n\tif(u == fds.n){\n\t\tfds.fd = realloc(fds.fd, (fds.n + 1) * sizeof(managed_fd));\n\t\tif(!fds.fd){\n\t\t\tfree(fds.signaled);\n\t\t\tfds.signaled = NULL;\n\t\t\tfds.n = 0;\n\t\t\tLOG(\"Failed to allocate memory\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tfds.signaled = realloc(fds.signaled, (fds.n + 1) * sizeof(managed_fd));\n\t\tif(!fds.signaled){\n\t\t\tLOG(\"Failed to allocate memory\");\n\t\t\tfree(fds.fd);\n\t\t\tfds.fd = NULL;\n\t\t\tfds.n = 0;\n\t\t\treturn 1;\n\t\t}\n\t\tfds.n++;\n\t}\n\n\t//store new fd\n\tfds.fd[u].fd = new_fd;\n\tfds.fd[u].backend = b;\n\tfds.fd[u].impl = impl;\n\tfd_set_dirty = 1;\n\treturn 0;\n}", "item_id": 1, "repo": "neonkingfr/MIDImonster", "file": "core/core.c", "last_update_at": "2022-03-05T20:06:36+00:00", "question_id": "415cfc30a4f6bc334dbd2ae41596e666b641748f_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["MM_API int mm_manage_fd(int new_fd, char* back, int manage, void* impl){\n\tbackend* b = backend_match(back);\n\tsize_t u;\n\tif(!b){\n\t\tLOGPF(\"Unknown backend %s registered for managed fd\", back);\n\t\treturn 1;\n\t}\n\t//find exact match\n\tfor(u = 0; u < fds.n; u++){\n\t\tif(fds.fd[u].fd == new_fd && fds.fd[u].backend == b){\n\t\t\tfds.fd[u].impl = impl;\n\t\t\tif(!manage){\n\t\t\t\tfds.fd[u].fd = -1;\n\t\t\t\tfds.fd[u].backend = NULL;\n\t\t\t\tfds.fd[u].impl = NULL;\n\t\t\t\tfd_set_dirty = 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(!manage){\n\t\treturn 0;\n\t}\n\t//find free slot\n\tfor(u = 0; u < fds.n; u++){\n\t\tif(fds.fd[u].fd < 0){\n\t\t\tbreak;\n\t\t}\n\t}\n\t//if necessary expand\n\tif(u == fds.n){\n\t\tfds.fd = realloc(fds.fd, (fds.n + 1) * sizeof(managed_fd));\n\t\tif(!fds.fd){\n\t\t\tfree(fds.signaled);\n\t\t\tfds.signaled = NULL;\n\t\t\tfds.n = 0;\n\t\t\tLOG(\"Failed to allocate memory\");\n\t\t\treturn 1;\n\t\t}\n\t\tfds.signaled = realloc(fds.signaled, (fds.n + 1) * sizeof(managed_fd));\n\t\tif(!fds.signaled){\n\t\t\tLOG(\"Failed to allocate memory\");\n\t\t\tfree(fds.fd);\n\t\t\tfds.fd = NULL;\n\t\t\tfds.n = 0;\n\t\t\treturn 1;\n\t\t}\n\t\tfds.n++;\n\t}\n\t//store new fd\n\tfds.fd[u].fd = new_fd;\n\tfds.fd[u].backend = b;\n\tfds.fd[u].impl = impl;\n\tfd_set_dirty = 1;\n\treturn 0;\n"]]}
{"hexsha": "9659fcaa34ed5001f973f62ed600aebc4e314885", "ext": "c", "lang": "C", "content": "static int pci200_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings new_line;\n\tsync_serial_settings __user *line = ifr->ifr_settings.ifs_ifsu.sync;\n\tport_t *port = dev_to_port(dev);\n\n#ifdef DEBUG_RINGS\n\tif (cmd == SIOCDEVPRIVATE) {\n\t\tsca_dump_rings(dev);\n\t\treturn 0;\n\t}\n#endif\n\tif (cmd != SIOCWANDEV)\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\n\tswitch(ifr->ifr_settings.type) {\n\tcase IF_GET_IFACE:\n\t\tifr->ifr_settings.type = IF_IFACE_V35;\n\t\tif (ifr->ifr_settings.size < size) {\n\t\t\tifr->ifr_settings.size = size; /* data size wanted */\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tif (copy_to_user(line, &port->settings, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_IFACE_V35:\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&new_line, line, size))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_line.clock_type != CLOCK_EXT &&\n\t\t    new_line.clock_type != CLOCK_TXFROMRX &&\n\t\t    new_line.clock_type != CLOCK_INT &&\n\t\t    new_line.clock_type != CLOCK_TXINT)\n\t\t\treturn -EINVAL;\t/* No such clock setting */\n\n\t\tif (new_line.loopback != 0 && new_line.loopback != 1)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(&port->settings, &new_line, size); /* Update settings */\n\t\tpci200_set_iface(port);\n\t\tsca_flush(port->card);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\t}\n}", "item_id": 3, "repo": "zhiming-shen/Xen-Blanket-NG", "file": "linux-kernel/linux-3.4.53-blanket/drivers/net/wan/pci200syn.c", "last_update_at": "2022-02-17T01:04:14+00:00", "question_id": "9659fcaa34ed5001f973f62ed600aebc4e314885_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int pci200_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings new_line;\n\tsync_serial_settings __user *line = ifr->ifr_settings.ifs_ifsu.sync;\n\tport_t *port = dev_to_port(dev);\n#ifdef DEBUG_RINGS\n\tif (cmd == SIOCDEVPRIVATE) {\n\t\tsca_dump_rings(dev);\n\t\treturn 0;\n\t}\n#endif\n\tif (cmd != SIOCWANDEV)\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\tswitch(ifr->ifr_settings.type) {\n\tcase IF_GET_IFACE:\n\t\tifr->ifr_settings.type = IF_IFACE_V35;\n\t\tif (ifr->ifr_settings.size < size) {\n\t\t\tifr->ifr_settings.size = size; /* data size wanted */\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tif (copy_to_user(line, &port->settings, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase IF_IFACE_V35:\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&new_line, line, size))\n\t\t\treturn -EFAULT;\n\t\tif (new_line.clock_type != CLOCK_EXT &&\n\t\t    new_line.clock_type != CLOCK_TXFROMRX &&\n\t\t    new_line.clock_type != CLOCK_INT &&\n\t\t    new_line.clock_type != CLOCK_TXINT)\n\t\t\treturn -EINVAL;\t/* No such clock setting */\n\t\tif (new_line.loopback != 0 && new_line.loopback != 1)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&port->settings, &new_line, size); /* Update settings */\n\t\tpci200_set_iface(port);\n\t\tsca_flush(port->card);\n\t\treturn 0;\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\t}\n"]]}
{"hexsha": "bbe2b0cd148a1ee1cf15394ea0ed4a7c5d84bd9a", "ext": "c", "lang": "C", "content": "platform_result_t platform_ethernet_start( void )\n{\n    et_info_t*     et    = &et_instance;\n    wiced_mutex_t* mutex = &et->op_mutex;\n\n    if ( !PLATFORM_FEATURE_ENAB( GMAC ) )\n    {\n        return PLATFORM_UNSUPPORTED;\n    }\n\n    WICED_ETHERNET_CHECK_AND_RET( et->etc != NULL, PLATFORM_ERROR );\n    WICED_ETHERNET_CHECK_AND_RET( et->started == WICED_FALSE, PLATFORM_ERROR );\n\n    WICED_ETHERNET_CHECK_AND_RET( wiced_rtos_register_timed_event( &et->wd_event, WICED_ETHERNET_WATCHDOG_THREAD,\n        &ethernet_watchdog_event, et->cfg->wd_period_ms, et ) == WICED_SUCCESS, PLATFORM_ERROR );\n\n    wiced_rtos_lock_mutex( mutex );\n\n    et->etc->linkstate = FALSE; /* force watchdog to report if linkstate is up now */\n    et->started = WICED_TRUE;\n    platform_irq_enable_irq( GMAC_ExtIRQn );\n\n    wiced_rtos_unlock_mutex( mutex );\n\n    return PLATFORM_SUCCESS;\n}", "item_id": 21, "repo": "nateglims/amazon-freertos", "file": "vendors/cypress/WICED_SDK/WICED/platform/MCU/BCM4390x/peripherals/ethernet/platform_ethernet.c", "last_update_at": "2022-03-29T01:03:36+00:00", "question_id": "bbe2b0cd148a1ee1cf15394ea0ed4a7c5d84bd9a_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["platform_result_t platform_ethernet_start( void )\n{\n    et_info_t*     et    = &et_instance;\n    wiced_mutex_t* mutex = &et->op_mutex;\n    if ( !PLATFORM_FEATURE_ENAB( GMAC ) )\n    {\n        return PLATFORM_UNSUPPORTED;\n    }\n    WICED_ETHERNET_CHECK_AND_RET( et->etc != NULL, PLATFORM_ERROR );\n    WICED_ETHERNET_CHECK_AND_RET( et->started == WICED_FALSE, PLATFORM_ERROR );\n    WICED_ETHERNET_CHECK_AND_RET( wiced_rtos_register_timed_event( &et->wd_event, WICED_ETHERNET_WATCHDOG_THREAD,\n        &ethernet_watchdog_event, et->cfg->wd_period_ms, et ) == WICED_SUCCESS, PLATFORM_ERROR );\n    wiced_rtos_lock_mutex( mutex );\n    et->etc->linkstate = FALSE; /* force watchdog to report if linkstate is up now */\n    et->started = WICED_TRUE;\n    platform_irq_enable_irq( GMAC_ExtIRQn );\n    wiced_rtos_unlock_mutex( mutex );\n    return PLATFORM_SUCCESS;\n"]]}
{"hexsha": "dcd7fb5b9fb24ab21190d2769cb1238db1fdbc13", "ext": "c", "lang": "C", "content": "static int qcom_vadc_scale_hw_calib_therm(\n\t\t\t\tconst struct vadc_prescale_ratio *prescale,\n\t\t\t\tconst struct adc5_data *data,\n\t\t\t\tu16 adc_code, int *result_mdec)\n{\n\tint voltage;\n\n\tvoltage = qcom_vadc_scale_code_voltage_factor(adc_code,\n\t\t\t\tprescale, data, 1000);\n\n\t/* Map voltage to temperature from look-up table */\n\treturn qcom_vadc_map_voltage_temp(adcmap_100k_104ef_104fb_1875_vref,\n\t\t\t\t ARRAY_SIZE(adcmap_100k_104ef_104fb_1875_vref),\n\t\t\t\t voltage, result_mdec);\n}", "item_id": 7, "repo": "fergy/aplit_linux-5", "file": "drivers/iio/adc/qcom-vadc-common.c", "last_update_at": "2022-03-28T08:23:06+00:00", "question_id": "dcd7fb5b9fb24ab21190d2769cb1238db1fdbc13_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int qcom_vadc_scale_hw_calib_therm(\n\t\t\t\tconst struct vadc_prescale_ratio *prescale,\n\t\t\t\tconst struct adc5_data *data,\n\t\t\t\tu16 adc_code, int *result_mdec)\n{\n\tint voltage;\n\tvoltage = qcom_vadc_scale_code_voltage_factor(adc_code,\n\t\t\t\tprescale, data, 1000);\n\t/* Map voltage to temperature from look-up table */\n\treturn qcom_vadc_map_voltage_temp(adcmap_100k_104ef_104fb_1875_vref,\n\t\t\t\t ARRAY_SIZE(adcmap_100k_104ef_104fb_1875_vref),\n\t\t\t\t voltage, result_mdec);\n"]]}
{"hexsha": "12c67cafd3b8d794fd878a7e1ac8eab6438cbeaf", "ext": "c", "lang": "C", "content": "static PyObject *Qt_EnterMovies(PyObject *_self, PyObject *_args)\n{\n\tPyObject *_res = NULL;\n\tOSErr _err;\n\tif (!PyArg_ParseTuple(_args, \"\"))\n\t\treturn NULL;\n\t_err = EnterMovies();\n\tif (_err != noErr) return PyMac_Error(_err);\n\tPy_INCREF(Py_None);\n\t_res = Py_None;\n\treturn _res;\n}", "item_id": 293, "repo": "SaadBazaz/ChinesePython", "file": "Mac/Modules/qt/Qtmodule.c", "last_update_at": "2022-02-12T08:51:12+00:00", "question_id": "12c67cafd3b8d794fd878a7e1ac8eab6438cbeaf_293", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static PyObject *Qt_EnterMovies(PyObject *_self, PyObject *_args)\n{\n\tPyObject *_res = NULL;\n\tOSErr _err;\n\tif (!PyArg_ParseTuple(_args, \"\"))\n\t\treturn NULL;\n\t_err = EnterMovies();\n\tif (_err != noErr) return PyMac_Error(_err);\n\tPy_INCREF(Py_None);\n\t_res = Py_None;\n\treturn _res;\n"]]}
{"hexsha": "5ce709ddbeea6c6b275b62b41fd2823993eb007b", "ext": "c", "lang": "C", "content": "static void FLEXCAN_ExitFreezeMode(CAN_Type *base)\n{\n    /* Clear Freeze, Halt bits. */\n    base->MCR &= ~CAN_MCR_HALT_MASK;\n    base->MCR &= ~CAN_MCR_FRZ_MASK;\n\n    /* Wait until the FlexCAN Module exit freeze mode. */\n    while (base->MCR & CAN_MCR_FRZACK_MASK)\n    {\n    }\n}", "item_id": 2, "repo": "chen-png/zephyr", "file": "ext/hal/nxp/mcux/drivers/kinetis/fsl_flexcan.c", "last_update_at": "2022-03-31T19:34:05+00:00", "question_id": "5ce709ddbeea6c6b275b62b41fd2823993eb007b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void FLEXCAN_ExitFreezeMode(CAN_Type *base)\n{\n    /* Clear Freeze, Halt bits. */\n    base->MCR &= ~CAN_MCR_HALT_MASK;\n    base->MCR &= ~CAN_MCR_FRZ_MASK;\n    /* Wait until the FlexCAN Module exit freeze mode. */\n    while (base->MCR & CAN_MCR_FRZACK_MASK)\n    {\n    }\n"]]}
{"hexsha": "b5dc6d7c6b2d3d183735f59b13c1de25071b8eea", "ext": "c", "lang": "C", "content": "int snd_ctl_elem_tlv_write(snd_ctl_t * ctl, const snd_ctl_elem_id_t * id, const unsigned int * tlv) {\n    snd_ctl_elem_tlv_write_INDEXED packed_data;\n    packed_data.func = snd_ctl_elem_tlv_write_INDEX;\n    packed_data.args.a1 = (snd_ctl_t *)ctl;\n    packed_data.args.a2 = (snd_ctl_elem_id_t *)id;\n    packed_data.args.a3 = (unsigned int *)tlv;\n    int ret;\n    syscall(SYS_proxy, (void *)&packed_data, &ret);\n    return ret;\n}", "item_id": 731, "repo": "rzr/glshim", "file": "src/proxy/client/src/client.c", "last_update_at": "2022-01-08T01:18:22+00:00", "question_id": "b5dc6d7c6b2d3d183735f59b13c1de25071b8eea_731", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int snd_ctl_elem_tlv_write(snd_ctl_t * ctl, const snd_ctl_elem_id_t * id, const unsigned int * tlv) {\n    snd_ctl_elem_tlv_write_INDEXED packed_data;\n    packed_data.func = snd_ctl_elem_tlv_write_INDEX;\n    packed_data.args.a1 = (snd_ctl_t *)ctl;\n    packed_data.args.a2 = (snd_ctl_elem_id_t *)id;\n    packed_data.args.a3 = (unsigned int *)tlv;\n    int ret;\n    syscall(SYS_proxy, (void *)&packed_data, &ret);\n    return ret;\n"]]}
{"hexsha": "2ee9ca7a194a90438de0ebca2dbcf2509eda4768", "ext": "h", "lang": "C", "content": "class WebHistoryServiceFactory : public BrowserContextKeyedServiceFactory {\n public:\n  // Get the singleton instance of the factory.\n  static WebHistoryServiceFactory* GetInstance();\n\n  // Get the WebHistoryService for |profile|, creating one if needed.\n  static history::WebHistoryService* GetForProfile(Profile* profile);\n\n  WebHistoryServiceFactory(const WebHistoryServiceFactory&) = delete;\n  WebHistoryServiceFactory& operator=(const WebHistoryServiceFactory&) = delete;\n\n protected:\n  // Overridden from BrowserContextKeyedServiceFactory.\n  KeyedService* BuildServiceInstanceFor(\n      content::BrowserContext* context) const override;\n\n private:\n  friend struct base::DefaultSingletonTraits<WebHistoryServiceFactory>;\n\n  WebHistoryServiceFactory();\n  ~WebHistoryServiceFactory() override;\n}", "item_id": 0, "repo": "zealoussnow/chromium", "file": "chrome/browser/history/web_history_service_factory.h", "last_update_at": "2022-03-31T23:33:32+00:00", "question_id": "2ee9ca7a194a90438de0ebca2dbcf2509eda4768_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class WebHistoryServiceFactory : public BrowserContextKeyedServiceFactory {\n public:\n  // Get the singleton instance of the factory.\n  static WebHistoryServiceFactory* GetInstance();\n  // Get the WebHistoryService for |profile|, creating one if needed.\n  static history::WebHistoryService* GetForProfile(Profile* profile);\n  WebHistoryServiceFactory(const WebHistoryServiceFactory&) = delete;\n  WebHistoryServiceFactory& operator=(const WebHistoryServiceFactory&) = delete;\n protected:\n  // Overridden from BrowserContextKeyedServiceFactory.\n  KeyedService* BuildServiceInstanceFor(\n      content::BrowserContext* context) const override;\n private:\n  friend struct base::DefaultSingletonTraits<WebHistoryServiceFactory>;\n  WebHistoryServiceFactory();\n  ~WebHistoryServiceFactory() override;\n"]]}
{"hexsha": "d769c3e8fd36e4fab326bf3b070644089f4fa0d1", "ext": "c", "lang": "C", "content": "int main(void)\n{\n\tUSART_Printf_Init(115200);\n\tprintf(\"SystemClk:%d\\r\\n\",SystemCoreClock);\n\t\t\n\tOne_Pulse_Init( 200, 48000-1, 100 );\t\n\t\n\twhile(1);\n}", "item_id": 1, "repo": "IOsetting/StdPeriphLib_CH32F1", "file": "Examples/TIM/One_Pulse/Main.c", "last_update_at": "2022-01-25T10:24:51+00:00", "question_id": "d769c3e8fd36e4fab326bf3b070644089f4fa0d1_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(void)\n{\n\tUSART_Printf_Init(115200);\n\tprintf(\"SystemClk:%d\\r\\n\",SystemCoreClock);\n\t\t\n\tOne_Pulse_Init( 200, 48000-1, 100 );\t\n\t\n\twhile(1);\n"]]}
{"hexsha": "4fdc309bacb04abd35854060de2a590cbe39e762", "ext": "c", "lang": "C", "content": "char *itoa(unsigned int number)\n{\n    static char tmp[16];\n    char *ret;\n    int i;\n    int remaining;\n    ret = &tmp[15];\n\n    remaining = number;\n    bzero(tmp, 16);\n    do {\n        *--ret = '0' + (number % 10);\n        number = number / 10;\n    } while (number != 0);\n    return ret;\n}", "item_id": 2, "repo": "li-xin-yi/cgc-cbs", "file": "examples/CROMU_00046/lib/libc.c", "last_update_at": "2022-02-21T15:37:22+00:00", "question_id": "4fdc309bacb04abd35854060de2a590cbe39e762_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char *itoa(unsigned int number)\n{\n    static char tmp[16];\n    char *ret;\n    int i;\n    int remaining;\n    ret = &tmp[15];\n    remaining = number;\n    bzero(tmp, 16);\n    do {\n        *--ret = '0' + (number % 10);\n        number = number / 10;\n    } while (number != 0);\n    return ret;\n"]]}
{"hexsha": "0db763ca944c3901689601369d2359d69ec813d3", "ext": "h", "lang": "C", "content": "class Role {\r\npublic:\r\n\tRole(int type);\r\n\t~Role();\r\n\r\n\tvoid operator =(Role player);\r\n\r\n\tstring getName();\r\n\tint getType();\r\n\r\n\tint getHealth_max();\r\n\tvoid setHealth_max(int hp_m);\r\n\r\n\tint getHealth();\r\n\tvoid setHealth(int hp);\r\n\r\n\tint getMagic_max();\r\n\tvoid setMagic_max(int mp_m);\r\n\r\n\tint getMagic();\r\n\tvoid setMagic(int mp);\r\n\r\n\tint getAttack();\r\n\tvoid setAttack(int a);\r\n\r\n\tint getDefend();\r\n\tvoid setDefend(int d);\r\n\r\n\tint getExp();\r\n\tvoid setExp(int e);\r\n\tvoid setExpSave(int e);\r\n\tint getLevelExp_max(int whichLevel);\r\n\r\n\tint getLevel();\r\n\tvoid setLevel(int l);\r\n\tvoid setLevelSave(int l);\r\n\r\n\tint getMoney();\r\n\tvoid setMoney(int m);\r\n\r\n\tint getMapId();\r\n\tvoid setMapId(int NewMapId);\r\n\r\n\tint getStory();\r\n\tvoid setStory(int s);\r\n\r\n\tSkill getSkill();\r\n\tvoid setSkill(Skill &newSkill);\r\n\r\n\tvoid addSaveGoodsToBag(int goodId,int num);\r\n\r\n\tBag getBag();\r\n\tvoid showBag();\r\n\tint getBagWhichGoodsId(int whichGoods);\t\t\t//\u5f97\u5230\u80cc\u5305\u91cc\u7b2cwhichGoods\u4ef6\u7269\u54c1\r\n\tint getBagWhichGoodsNum(int whichGoods);\r\n\t//\u663e\u793a\u80cc\u5305\r\n\tvoid addGoodsToBag(int *goodsId, int* num);//\u52a0\u5165\u80cc\u5305,\u91cd\u8f7d\u5e94\u5bf9\u4e24\u79cd\u60c5\u51b5\r\n\tvoid addGoodsToBag(int goodsId, int num);\r\n\r\n\tbool subGoodsToBag(int goodsId, int num);\t//\u51cf\u5c11\u80cc\u5305\u91cc\u7684\u7269\u54c1\r\n\r\n\tvoid setBag(Bag bags);\r\n\r\n\tvoid savePlayerBag();\t\t//\u7528\u6765\u5355\u72ec\u4fdd\u5b58\u80cc\u5305\r\n\t//int** getBagSave();\r\n\tvoid newBag();\r\n\r\n\tvoid showRole();//\u4eba\u7269\u5c5e\u6027 \u5f53\u524d\u88c5\u5907\r\n\tbool showSkill();//\u663e\u793a\u6280\u80fd,\u8fd4\u56de\u662f\u5426\u53ef\u4ee5\u4f7f\u7528\u6280\u80fd\r\n\r\n\tdouble useSkill();\t\t//\u4f7f\u7528\u6280\u80fd,\u8fd4\u56de\u6280\u80fd\u7684\u653b\u51fb\u529b\u52a0\u6210\r\n\tvoid useDrug();\t\t\t//\u4f7f\u7528\u836f\u54c1\r\n\r\n\tint getWeapon();\r\n\tvoid setWeapon(int w);\r\n\tint getClothes();\r\n\tvoid setClothes(int c);\r\n\r\n\tvoid showEquip();//\u5c55\u793a\u5f53\u524d\u88c5\u5907\r\n\tvoid wearEquip(int id);//\u7a7f\u4e0a\u88c5\u5907\r\n\tvoid removeEquip(int id);//\u8131\u4e0b\u88c5\u5907\r\n\r\n\tint getTaskId();\r\n\tbool getTaskIsEnd();\r\n\tvoid setTask(Task newTask);\r\n\tvoid setTaskIsEnd();\r\n\tTask getTask();\r\n\tstring getTaskName();\r\n\tstring getTaskDesc();\r\n\tGoods getTaskGoods();\r\n\tvoid setTaskGoods(Goods newTaskGoods);\r\n\r\nprivate:\r\n\tstring name;\r\n\tint type;\r\n\tint health_max;\r\n\tint health;\r\n\tint magic_max;\r\n\tint magic;\r\n\tint attack;\r\n\tint exp;\r\n\t//\u6bcf\u4e2a\u7b49\u7ea7\u5bf9\u5e94\u7684\u6700\u9ad8\u7ecf\u9a8c\u503c\uff0c\u7ecf\u9a8c\u503c\u5927\u4e8e\u7b49\u4e8e\u5c31\u5347\u7ea7\r\n\tconst int levelExp_Max[29] = { 6,12,18,24,30,36,42,48,54,60,69,78,87,96,105,114,123,132,141,150,162,174,186,198,210,225,240,270,300 };\r\n\tint exp_Max;\t\t//\u7ebf\u6027\u7ecf\u9a8c\u503c\uff0c\u6682\u5b9a\u4e3a\u6700\u9ad8300\r\n\tint level;\r\n\tint defend;\t\t\t//\u9632\u5fa1\r\n\tint money;\r\n\tBag bag;\t\t\t//\u80cc\u5305\r\n\t//int bag[20];\r\n\tint mapId;\t\t\t//\u8bb0\u5f55\u73a9\u5bb6\u5f53\u524d\u6240\u5728\u5730\r\n\tSkill skill;\t\t//\u4ed6\u6240\u62e5\u6709\u7684\u6280\u80fd\r\n\tint skillLevel;\t\t//\u5347\u7ea7\u5e26\u6765\u7684\u6280\u80fd\u5347\u7ea7\u70b9\u6570\r\n\tint story = 0;//\u5267\u60c5\u8282\u70b9\r\n\tint weapon = -1;//\u5f53\u524d\u6b66\u5668id  \u9ed8\u8ba4-1\u4e3a\u65e0\r\n\tint clothes = -1; //\u5f53\u524d\u9632\u5177id\r\n\tTask task;\r\n\t\t\t\t  //\u7269\u54c1\u5b9e\u4f8b\u5316\r\n\tGoods goods[24] = { 0, 1, 2, 3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23 };\r\n\r\n}", "item_id": 0, "repo": "LiangJiQi/MUD-game--", "file": "Role.h", "last_update_at": "2022-02-16T08:59:00+00:00", "question_id": "0db763ca944c3901689601369d2359d69ec813d3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Role {\r\npublic:\r\n\tRole(int type);\r\n\t~Role();\r\n\r\n\tvoid operator =(Role player);\r\n\r\n\tstring getName();\r\n\tint getType();\r\n\r\n\tint getHealth_max();\r\n\tvoid setHealth_max(int hp_m);\r\n\r\n\tint getHealth();\r\n\tvoid setHealth(int hp);\r\n\r\n\tint getMagic_max();\r\n\tvoid setMagic_max(int mp_m);\r\n\r\n\tint getMagic();\r\n\tvoid setMagic(int mp);\r\n\r\n\tint getAttack();\r\n\tvoid setAttack(int a);\r\n\r\n\tint getDefend();\r\n\tvoid setDefend(int d);\r\n\r\n\tint getExp();\r\n\tvoid setExp(int e);\r\n\tvoid setExpSave(int e);\r\n\tint getLevelExp_max(int whichLevel);\r\n\r\n\tint getLevel();\r\n\tvoid setLevel(int l);\r\n\tvoid setLevelSave(int l);\r\n\r\n\tint getMoney();\r\n\tvoid setMoney(int m);\r\n\r\n\tint getMapId();\r\n\tvoid setMapId(int NewMapId);\r\n\r\n\tint getStory();\r\n\tvoid setStory(int s);\r\n\r\n\tSkill getSkill();\r\n\tvoid setSkill(Skill &newSkill);\r\n\r\n\tvoid addSaveGoodsToBag(int goodId,int num);\r\n\r\n\tBag getBag();\r\n\tvoid showBag();\r\n\tint getBagWhichGoodsId(int whichGoods);\t\t\t//\u5f97\u5230\u80cc\u5305\u91cc\u7b2cwhichGoods\u4ef6\u7269\u54c1\r\n\tint getBagWhichGoodsNum(int whichGoods);\r\n\t//\u663e\u793a\u80cc\u5305\r\n\tvoid addGoodsToBag(int *goodsId, int* num);//\u52a0\u5165\u80cc\u5305,\u91cd\u8f7d\u5e94\u5bf9\u4e24\u79cd\u60c5\u51b5\r\n\tvoid addGoodsToBag(int goodsId, int num);\r\n\r\n\tbool subGoodsToBag(int goodsId, int num);\t//\u51cf\u5c11\u80cc\u5305\u91cc\u7684\u7269\u54c1\r\n\r\n\tvoid setBag(Bag bags);\r\n\r\n\tvoid savePlayerBag();\t\t//\u7528\u6765\u5355\u72ec\u4fdd\u5b58\u80cc\u5305\r\n\t//int** getBagSave();\r\n\tvoid newBag();\r\n\r\n\tvoid showRole();//\u4eba\u7269\u5c5e\u6027 \u5f53\u524d\u88c5\u5907\r\n\tbool showSkill();//\u663e\u793a\u6280\u80fd,\u8fd4\u56de\u662f\u5426\u53ef\u4ee5\u4f7f\u7528\u6280\u80fd\r\n\r\n\tdouble useSkill();\t\t//\u4f7f\u7528\u6280\u80fd,\u8fd4\u56de\u6280\u80fd\u7684\u653b\u51fb\u529b\u52a0\u6210\r\n\tvoid useDrug();\t\t\t//\u4f7f\u7528\u836f\u54c1\r\n\r\n\tint getWeapon();\r\n\tvoid setWeapon(int w);\r\n\tint getClothes();\r\n\tvoid setClothes(int c);\r\n\r\n\tvoid showEquip();//\u5c55\u793a\u5f53\u524d\u88c5\u5907\r\n\tvoid wearEquip(int id);//\u7a7f\u4e0a\u88c5\u5907\r\n\tvoid removeEquip(int id);//\u8131\u4e0b\u88c5\u5907\r\n\r\n\tint getTaskId();\r\n\tbool getTaskIsEnd();\r\n\tvoid setTask(Task newTask);\r\n\tvoid setTaskIsEnd();\r\n\tTask getTask();\r\n\tstring getTaskName();\r\n\tstring getTaskDesc();\r\n\tGoods getTaskGoods();\r\n\tvoid setTaskGoods(Goods newTaskGoods);\r\n\r\nprivate:\r\n\tstring name;\r\n\tint type;\r\n\tint health_max;\r\n\tint health;\r\n\tint magic_max;\r\n\tint magic;\r\n\tint attack;\r\n\tint exp;\r\n\t//\u6bcf\u4e2a\u7b49\u7ea7\u5bf9\u5e94\u7684\u6700\u9ad8\u7ecf\u9a8c\u503c\uff0c\u7ecf\u9a8c\u503c\u5927\u4e8e\u7b49\u4e8e\u5c31\u5347\u7ea7\r\n\tconst int levelExp_Max[29] = { 6,12,18,24,30,36,42,48,54,60,69,78,87,96,105,114,123,132,141,150,162,174,186,198,210,225,240,270,300 };\r\n\tint exp_Max;\t\t//\u7ebf\u6027\u7ecf\u9a8c\u503c\uff0c\u6682\u5b9a\u4e3a\u6700\u9ad8300\r\n\tint level;\r\n\tint defend;\t\t\t//\u9632\u5fa1\r\n\tint money;\r\n\tBag bag;\t\t\t//\u80cc\u5305\r\n\t//int bag[20];\r\n\tint mapId;\t\t\t//\u8bb0\u5f55\u73a9\u5bb6\u5f53\u524d\u6240\u5728\u5730\r\n\tSkill skill;\t\t//\u4ed6\u6240\u62e5\u6709\u7684\u6280\u80fd\r\n\tint skillLevel;\t\t//\u5347\u7ea7\u5e26\u6765\u7684\u6280\u80fd\u5347\u7ea7\u70b9\u6570\r\n\tint story = 0;//\u5267\u60c5\u8282\u70b9\r\n\tint weapon = -1;//\u5f53\u524d\u6b66\u5668id  \u9ed8\u8ba4-1\u4e3a\u65e0\r\n\tint clothes = -1; //\u5f53\u524d\u9632\u5177id\r\n\tTask task;\r\n\t\t\t\t  //\u7269\u54c1\u5b9e\u4f8b\u5316\r\n\tGoods goods[24] = { 0, 1, 2, 3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23 };\r\n\r\n"]]}
{"hexsha": "521dbcf903f1f23bf6febc12ef4e2886ad09be35", "ext": "c", "lang": "C", "content": "dogecoin_bool dogecoin_p2p_deser_addr(unsigned int protocol_version, dogecoin_p2p_address* addr, struct const_buffer* buf)\n{\n    if (protocol_version >= DOGECOIN_ADDR_TIME_VERSION) {\n        if (!deser_u32(&addr->time, buf))\n            return false;\n    } else\n        addr->time = 0;\n\n    if (!deser_u64(&addr->services, buf))\n        return false;\n    if (!deser_bytes(&addr->ip, buf, 16))\n        return false;\n    if (!deser_u16(&addr->port, buf))\n        return false;\n    return true;\n}", "item_id": 1, "repo": "dogecoinfoundation/libdogecoin", "file": "src/protocol.c", "last_update_at": "2022-03-28T21:37:09+00:00", "question_id": "521dbcf903f1f23bf6febc12ef4e2886ad09be35_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["dogecoin_bool dogecoin_p2p_deser_addr(unsigned int protocol_version, dogecoin_p2p_address* addr, struct const_buffer* buf)\n{\n    if (protocol_version >= DOGECOIN_ADDR_TIME_VERSION) {\n        if (!deser_u32(&addr->time, buf))\n            return false;\n    } else\n        addr->time = 0;\n    if (!deser_u64(&addr->services, buf))\n        return false;\n    if (!deser_bytes(&addr->ip, buf, 16))\n        return false;\n    if (!deser_u16(&addr->port, buf))\n        return false;\n    return true;\n"]]}
{"hexsha": "5fcecf3f2502e5ba3ca431657f56d45e311fba4c", "ext": "c", "lang": "C", "content": "static void\nexp_generate_sneak_decoder(struct exp_list *elist) {\n  struct exp *exp;\n  int ofp_header = 0;\n\n  /* Header output. */\n  exp_generate_sneak_decoder_function(elist, fp_header);\n  fprintf(fp_header, \";\\n\");\n\n  /* ofp_header check. */\n#if 0\n  if (strcmp(elist->name, \"ofp_header\") != 0) {\n    TAILQ_FOREACH(exp, &elist->tailq, entry) {\n      if (exp->type == EXP_TYPE_STRUCT_DECLARATION &&\n          strcmp(exp->decl.type, \"ofp_header\") == 0) {\n        ofp_header = 1;\n      }\n    }\n  }\n#endif\n\n  /* Source output. */\n  exp_generate_sneak_decoder_function(elist, fp_source);\n  fprintf(fp_source, \"\\n\");\n  fprintf(fp_source, \"{\\n\");\n  fprintf(fp_source, \"  /* Size check. */\\n\");\n  if (ofp_header == 1) {\n    fprintf(fp_source,\n            \"  if (pbuf->plen < (sizeof(struct %s) - sizeof(struct ofp_header)))\\n\",\n            elist->name);\n  } else {\n    fprintf(fp_source, \"  if (pbuf->plen < sizeof(struct %s))\\n\", elist->name);\n  }\n  fprintf(fp_source, \"    return LAGOPUS_RESULT_OUT_OF_RANGE;\\n\");\n  fprintf(fp_source, \"\\n\");\n\n  fprintf(fp_source, \"  /* Decode packet. */\\n\");\n  TAILQ_FOREACH(exp, &elist->tailq, entry) {\n    enum decl_type type;\n\n    /* Look up declaration type. */\n    type = decl_type_lookup(exp->decl.type);\n\n    /* In case of simple declaration. */\n    if (exp->type == EXP_TYPE_DECLARATION) {\n      switch (type) {\n        case DECL_TYPE_CHAR:\n        case DECL_TYPE_UCHAR:\n          fprintf(fp_source, \"  DECODE_GETC\");\n          break;\n        case DECL_TYPE_WORD:\n          fprintf(fp_source, \"  DECODE_GETW\");\n          break;\n        case DECL_TYPE_LONG:\n          fprintf(fp_source, \"  DECODE_GETL\");\n          break;\n        case DECL_TYPE_LLONG:\n          fprintf(fp_source, \"  DECODE_GETLL\");\n          break;\n        case DECL_TYPE_UNKNOWN:\n          fprintf(stderr, \"Error: unknown type %s\\n\", exp->decl.type);\n          exit (1);\n          break;\n      }\n\n      /* Declaration name. */\n      fprintf(fp_source, \"(packet->%s);\\n\", exp->decl.name);\n    } else if (exp->type == EXP_TYPE_STRUCT_DECLARATION) {\n#if 1 /* Enable all header decode. */\n      if (strcmp(exp->decl.type, \"ofp_header\") == 0) {\n        fprintf(fp_source, \"  if (%s_decode(pbuf, &packet->%s) < 0) {\\n\",\n                exp->decl.type, exp->decl.name);\n        fprintf(fp_source, \"    return LAGOPUS_RESULT_OUT_OF_RANGE;\\n\");\n        fprintf(fp_source, \"  }\\n\");\n      }\n#endif\n    } else if (exp->type == EXP_TYPE_ARRAY_STRUCT_DECLARATION) {\n\n    } else {\n      switch (type) {\n        case DECL_TYPE_WORD:\n        case DECL_TYPE_LONG:\n        case DECL_TYPE_LLONG:\n          fprintf(fp_source, \"  for (int i = 0; i < %d; i++) {\\n\",\n                  exp->decl.array_size);\n          break;\n        default:\n          break;\n      }\n\n      switch (type) {\n        case DECL_TYPE_WORD:\n          fprintf(fp_source, \"    DECODE_GETW(packet->%s[i]);\\n\",\n                  exp->decl.name);\n          break;\n        case DECL_TYPE_LONG:\n          fprintf(fp_source, \"    DECODE_GETL(packet->%s[i]);\\n\",\n                  exp->decl.name);\n          break;\n        case DECL_TYPE_LLONG:\n          fprintf(fp_source, \"    DECODE_GETLL(packet->%s[i]);\\n\",\n                  exp->decl.name);\n          break;\n        default:\n          fprintf(fp_source, \"  DECODE_GET(packet->%s, %d);\\n\",\n                  exp->decl.name, exp->decl.array_size);\n          break;\n      }\n\n      switch (type) {\n        case DECL_TYPE_WORD:\n        case DECL_TYPE_LONG:\n        case DECL_TYPE_LLONG:\n          fprintf(fp_source, \"  }\\n\");\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  fprintf(fp_source, \"  DECODE_REWIND(sizeof(struct %s));\\n\", elist->name);\n  fprintf(fp_source, \"\\n\");\n  fprintf(fp_source, \"  return LAGOPUS_RESULT_OK;\\n\");\n  fprintf(fp_source, \"}\\n\");\n}", "item_id": 10, "repo": "iMasaruOki/lagopus", "file": "src/agent/generator.c", "last_update_at": "2022-03-14T03:29:46+00:00", "question_id": "5fcecf3f2502e5ba3ca431657f56d45e311fba4c_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nexp_generate_sneak_decoder(struct exp_list *elist) {\n  struct exp *exp;\n  int ofp_header = 0;\n  /* Header output. */\n  exp_generate_sneak_decoder_function(elist, fp_header);\n  fprintf(fp_header, \";\\n\");\n  /* ofp_header check. */\n#if 0\n  if (strcmp(elist->name, \"ofp_header\") != 0) {\n    TAILQ_FOREACH(exp, &elist->tailq, entry) {\n      if (exp->type == EXP_TYPE_STRUCT_DECLARATION &&\n          strcmp(exp->decl.type, \"ofp_header\") == 0) {\n        ofp_header = 1;\n      }\n    }\n  }\n#endif\n  /* Source output. */\n  exp_generate_sneak_decoder_function(elist, fp_source);\n  fprintf(fp_source, \"\\n\");\n  fprintf(fp_source, \"{\\n\");\n  fprintf(fp_source, \"  /* Size check. */\\n\");\n  if (ofp_header == 1) {\n    fprintf(fp_source,\n            \"  if (pbuf->plen < (sizeof(struct %s) - sizeof(struct ofp_header)))\\n\",\n            elist->name);\n  } else {\n    fprintf(fp_source, \"  if (pbuf->plen < sizeof(struct %s))\\n\", elist->name);\n  }\n  fprintf(fp_source, \"    return LAGOPUS_RESULT_OUT_OF_RANGE;\\n\");\n  fprintf(fp_source, \"\\n\");\n  fprintf(fp_source, \"  /* Decode packet. */\\n\");\n  TAILQ_FOREACH(exp, &elist->tailq, entry) {\n    enum decl_type type;\n    /* Look up declaration type. */\n    type = decl_type_lookup(exp->decl.type);\n    /* In case of simple declaration. */\n    if (exp->type == EXP_TYPE_DECLARATION) {\n      switch (type) {\n        case DECL_TYPE_CHAR:\n        case DECL_TYPE_UCHAR:\n          fprintf(fp_source, \"  DECODE_GETC\");\n          break;\n        case DECL_TYPE_WORD:\n          fprintf(fp_source, \"  DECODE_GETW\");\n          break;\n        case DECL_TYPE_LONG:\n          fprintf(fp_source, \"  DECODE_GETL\");\n          break;\n        case DECL_TYPE_LLONG:\n          fprintf(fp_source, \"  DECODE_GETLL\");\n          break;\n        case DECL_TYPE_UNKNOWN:\n          fprintf(stderr, \"Error: unknown type %s\\n\", exp->decl.type);\n          exit (1);\n          break;\n      }\n      /* Declaration name. */\n      fprintf(fp_source, \"(packet->%s);\\n\", exp->decl.name);\n    } else if (exp->type == EXP_TYPE_STRUCT_DECLARATION) {\n#if 1 /* Enable all header decode. */\n      if (strcmp(exp->decl.type, \"ofp_header\") == 0) {\n        fprintf(fp_source, \"  if (%s_decode(pbuf, &packet->%s) < 0) {\\n\",\n                exp->decl.type, exp->decl.name);\n        fprintf(fp_source, \"    return LAGOPUS_RESULT_OUT_OF_RANGE;\\n\");\n        fprintf(fp_source, \"  }\\n\");\n      }\n#endif\n    } else if (exp->type == EXP_TYPE_ARRAY_STRUCT_DECLARATION) {\n    } else {\n      switch (type) {\n        case DECL_TYPE_WORD:\n        case DECL_TYPE_LONG:\n        case DECL_TYPE_LLONG:\n          fprintf(fp_source, \"  for (int i = 0; i < %d; i++) {\\n\",\n                  exp->decl.array_size);\n          break;\n        default:\n          break;\n      }\n      switch (type) {\n        case DECL_TYPE_WORD:\n          fprintf(fp_source, \"    DECODE_GETW(packet->%s[i]);\\n\",\n                  exp->decl.name);\n          break;\n        case DECL_TYPE_LONG:\n          fprintf(fp_source, \"    DECODE_GETL(packet->%s[i]);\\n\",\n                  exp->decl.name);\n          break;\n        case DECL_TYPE_LLONG:\n          fprintf(fp_source, \"    DECODE_GETLL(packet->%s[i]);\\n\",\n                  exp->decl.name);\n          break;\n        default:\n          fprintf(fp_source, \"  DECODE_GET(packet->%s, %d);\\n\",\n                  exp->decl.name, exp->decl.array_size);\n          break;\n      }\n      switch (type) {\n        case DECL_TYPE_WORD:\n        case DECL_TYPE_LONG:\n        case DECL_TYPE_LLONG:\n          fprintf(fp_source, \"  }\\n\");\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  fprintf(fp_source, \"  DECODE_REWIND(sizeof(struct %s));\\n\", elist->name);\n  fprintf(fp_source, \"\\n\");\n  fprintf(fp_source, \"  return LAGOPUS_RESULT_OK;\\n\");\n  fprintf(fp_source, \"}\\n\");\n"]]}
{"hexsha": "9dea548dc72f70aba40e4fe3b33f7dae29e8572d", "ext": "c", "lang": "C", "content": "void gmx_omp_check_thread_affinity(FILE *fplog, const t_commrec *cr,\n                                   gmx_hw_opt_t *hw_opt)\n{\n    gmx_bool bKmpAffinitySet, bGompCpuAffinitySet;\n    char    *kmp_env, *gomp_env;\n\n    /* no need to worry if internal thread pinning is turned off */\n    if (hw_opt->thread_affinity == threadaffOFF)\n    {\n        return;\n    }\n\n#if defined(GMX_OPENMP)\n\n    /* We assume that the affinity setting is available on all platforms\n     * gcc supports. Even if this is not the case (e.g. Mac OS) the user\n     * will only get a warning.*/\n    bGompCpuAffinitySet = FALSE;\n    gomp_env            = NULL;\n#if defined(__GNUC__)\n    gomp_env            = getenv(\"GOMP_CPU_AFFINITY\");\n    bGompCpuAffinitySet = (gomp_env != NULL);\n#endif /* __GNUC__ */\n\n    bKmpAffinitySet = FALSE;\n#if defined(__INTEL_COMPILER)\n    kmp_env         = getenv(\"KMP_AFFINITY\");\n    bKmpAffinitySet = (kmp_env != NULL);\n\n    /* disable Intel OpenMP affinity if neither KMP_AFFINITY nor\n     * GOMP_CPU_AFFINITY is set (Intel uses the GNU env. var as well) */\n    if (!bKmpAffinitySet && !bGompCpuAffinitySet)\n    {\n        int retval;\n\n#ifdef _MSC_VER\n        /* Windows not POSIX */\n        retval = _putenv_s(\"KMP_AFFINITY\", \"disabled\");\n#else\n        /* POSIX */\n        retval = setenv(\"KMP_AFFINITY\", \"disabled\", 0);\n#endif  /* _MSC_VER */\n\n        if (debug)\n        {\n            fprintf(debug, \"Disabling Intel OpenMP affinity by setting the KMP_AFFINITY=disabled env. var.\\n\");\n        }\n\n        if (retval != 0)\n        {\n            gmx_warning(\"Disabling Intel OpenMp affinity setting failed!\");\n        }\n    }\n\n    /* turn off internal pinning KMP_AFFINITY != \"disabled\" */\n    if (bKmpAffinitySet && (gmx_strncasecmp(kmp_env, \"disabled\", 8) != 0))\n    {\n        /* TODO: with -pin auto we should only warn when using all cores */\n        md_print_warn(cr, fplog,\n                      \"NOTE: KMP_AFFINITY set, will turn off %s internal affinity\\n\"\n                      \"      setting as the two can conflict and cause performance degradation.\\n\"\n                      \"      To keep using the %s internal affinity setting, set the\\n\"\n                      \"      KMP_AFFINITY=disabled environment variable.\",\n                      ShortProgram(), ShortProgram());\n\n        hw_opt->thread_affinity = threadaffOFF;\n    }\n#endif /* __INTEL_COMPILER */\n\n#if defined(__INTEL_COMPILER) || defined(__GNUC__)\n    /* turn off internal pinning f GOMP_CPU_AFFINITY is set & non-empty */\n    if (bGompCpuAffinitySet && gomp_env != NULL && gomp_env != '\\0')\n    {\n        /* TODO: with -pin auto we should only warn when using all cores */\n        md_print_warn(cr, fplog,\n                      \"NOTE: GOMP_CPU_AFFINITY set, will turn off %s internal affinity\\n\"\n                      \"      setting as the two can conflict and cause performance degradation.\\n\"\n                      \"      To keep using the %s internal affinity setting, unset the\\n\"\n                      \"      GOMP_CPU_AFFINITY environment variable.\",\n                      ShortProgram(), ShortProgram());\n\n        hw_opt->thread_affinity = threadaffOFF;\n    }\n#endif /* __INTEL_COMPILER || __GNUC__ */\n\n#endif /* GMX_OPENMP */\n}", "item_id": 0, "repo": "farajilab/gifs_release", "file": "gromacs-4.6.5/src/gmxlib/gmx_omp.c", "last_update_at": "2022-03-22T16:49:22+00:00", "question_id": "9dea548dc72f70aba40e4fe3b33f7dae29e8572d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void gmx_omp_check_thread_affinity(FILE *fplog, const t_commrec *cr,\n                                   gmx_hw_opt_t *hw_opt)\n{\n    gmx_bool bKmpAffinitySet, bGompCpuAffinitySet;\n    char    *kmp_env, *gomp_env;\n    /* no need to worry if internal thread pinning is turned off */\n    if (hw_opt->thread_affinity == threadaffOFF)\n    {\n        return;\n    }\n#if defined(GMX_OPENMP)\n    /* We assume that the affinity setting is available on all platforms\n     * gcc supports. Even if this is not the case (e.g. Mac OS) the user\n     * will only get a warning.*/\n    bGompCpuAffinitySet = FALSE;\n    gomp_env            = NULL;\n#if defined(__GNUC__)\n    gomp_env            = getenv(\"GOMP_CPU_AFFINITY\");\n    bGompCpuAffinitySet = (gomp_env != NULL);\n#endif /* __GNUC__ */\n    bKmpAffinitySet = FALSE;\n#if defined(__INTEL_COMPILER)\n    kmp_env         = getenv(\"KMP_AFFINITY\");\n    bKmpAffinitySet = (kmp_env != NULL);\n    /* disable Intel OpenMP affinity if neither KMP_AFFINITY nor\n     * GOMP_CPU_AFFINITY is set (Intel uses the GNU env. var as well) */\n    if (!bKmpAffinitySet && !bGompCpuAffinitySet)\n    {\n        int retval;\n#ifdef _MSC_VER\n        /* Windows not POSIX */\n        retval = _putenv_s(\"KMP_AFFINITY\", \"disabled\");\n#else\n        /* POSIX */\n        retval = setenv(\"KMP_AFFINITY\", \"disabled\", 0);\n#endif  /* _MSC_VER */\n        if (debug)\n        {\n            fprintf(debug, \"Disabling Intel OpenMP affinity by setting the KMP_AFFINITY=disabled env. var.\\n\");\n        }\n        if (retval != 0)\n        {\n            gmx_warning(\"Disabling Intel OpenMp affinity setting failed!\");\n        }\n    }\n    /* turn off internal pinning KMP_AFFINITY != \"disabled\" */\n    if (bKmpAffinitySet && (gmx_strncasecmp(kmp_env, \"disabled\", 8) != 0))\n    {\n        /* TODO: with -pin auto we should only warn when using all cores */\n        md_print_warn(cr, fplog,\n                      \"NOTE: KMP_AFFINITY set, will turn off %s internal affinity\\n\"\n                      \"      setting as the two can conflict and cause performance degradation.\\n\"\n                      \"      To keep using the %s internal affinity setting, set the\\n\"\n                      \"      KMP_AFFINITY=disabled environment variable.\",\n                      ShortProgram(), ShortProgram());\n        hw_opt->thread_affinity = threadaffOFF;\n    }\n#endif /* __INTEL_COMPILER */\n#if defined(__INTEL_COMPILER) || defined(__GNUC__)\n    /* turn off internal pinning f GOMP_CPU_AFFINITY is set & non-empty */\n    if (bGompCpuAffinitySet && gomp_env != NULL && gomp_env != '\\0')\n    {\n        /* TODO: with -pin auto we should only warn when using all cores */\n        md_print_warn(cr, fplog,\n                      \"NOTE: GOMP_CPU_AFFINITY set, will turn off %s internal affinity\\n\"\n                      \"      setting as the two can conflict and cause performance degradation.\\n\"\n                      \"      To keep using the %s internal affinity setting, unset the\\n\"\n                      \"      GOMP_CPU_AFFINITY environment variable.\",\n                      ShortProgram(), ShortProgram());\n        hw_opt->thread_affinity = threadaffOFF;\n    }\n#endif /* __INTEL_COMPILER || __GNUC__ */\n#endif /* GMX_OPENMP */\n"]]}
{"hexsha": "9e04e3e4d4d52cb91650a121bb5d1f7e485bbd81", "ext": "c", "lang": "C", "content": "static void ucp_worker_init_guess_atomics(ucp_worker_h worker)\n{\n    uint64_t accumulated_flags = 0;\n    ucp_rsc_index_t iface_id;\n\n    for (iface_id = 0; iface_id < worker->num_ifaces; ++iface_id) {\n        accumulated_flags |= worker->ifaces[iface_id].attr.cap.flags;\n    }\n\n    if (accumulated_flags & UCT_IFACE_FLAG_ATOMIC_DEVICE) {\n        ucp_worker_init_device_atomics(worker);\n    } else {\n        ucp_worker_init_cpu_atomics(worker);\n    }\n}", "item_id": 28, "repo": "petro-rudenko/ucx", "file": "src/ucp/core/ucp_worker.c", "last_update_at": "2022-01-10T11:59:53+00:00", "question_id": "9e04e3e4d4d52cb91650a121bb5d1f7e485bbd81_28", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void ucp_worker_init_guess_atomics(ucp_worker_h worker)\n{\n    uint64_t accumulated_flags = 0;\n    ucp_rsc_index_t iface_id;\n    for (iface_id = 0; iface_id < worker->num_ifaces; ++iface_id) {\n        accumulated_flags |= worker->ifaces[iface_id].attr.cap.flags;\n    }\n    if (accumulated_flags & UCT_IFACE_FLAG_ATOMIC_DEVICE) {\n        ucp_worker_init_device_atomics(worker);\n    } else {\n        ucp_worker_init_cpu_atomics(worker);\n    }\n"]]}
{"hexsha": "f05e68d693b29d59f5ac61009f4031f50a391f02", "ext": "c", "lang": "C", "content": "string find_highest_level_class(object who)\n{\n    string *myClasses, highclass;\n    int lev = 0, x, clev;\n    if(!objectp(who)) return \"fail\";\n    myClasses = who->query_classes();\n    for(x = 0;x < sizeof(myClasses);x++)\n    {\n        clev = (int)who->query_class_level(myClasses[x]);\n        if(lev > clev) continue;\n        else\n        {\n            lev = clev;\n            highclass = myClasses[x];\n            continue;\n        }\n    }\n    if(!stringp(highclass)) return \"fail\";\n    return highclass;\n\n}", "item_id": 2, "repo": "Dbevan/SunderingShadows", "file": "d/deku/hhouse/ob/dirty_sash.c", "last_update_at": "2022-02-25T19:44:15+00:00", "question_id": "f05e68d693b29d59f5ac61009f4031f50a391f02_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["string find_highest_level_class(object who)\n{\n    string *myClasses, highclass;\n    int lev = 0, x, clev;\n    if(!objectp(who)) return \"fail\";\n    myClasses = who->query_classes();\n    for(x = 0;x < sizeof(myClasses);x++)\n    {\n        clev = (int)who->query_class_level(myClasses[x]);\n        if(lev > clev) continue;\n        else\n        {\n            lev = clev;\n            highclass = myClasses[x];\n            continue;\n        }\n    }\n    if(!stringp(highclass)) return \"fail\";\n    return highclass;\n"]]}
{"hexsha": "9e972d183f2be89cc321b15202f5c14a758601d0", "ext": "c", "lang": "C", "content": "void TtsIPv6AcceptThread(THREAD *thread, void *param)\r\n{\r\n\tTTS *tts = (TTS *)param;\r\n\t// Validate arguments\r\n\tif (tts == NULL || param == NULL)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tTtsAcceptProc(tts, tts->ListenSocketV6);\r\n}", "item_id": 19, "repo": "MtCedarNet/SoftEtherVPN", "file": "src/Cedar/Command.c", "last_update_at": "2022-03-31T13:08:09+00:00", "question_id": "9e972d183f2be89cc321b15202f5c14a758601d0_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void TtsIPv6AcceptThread(THREAD *thread, void *param)\r\n{\r\n\tTTS *tts = (TTS *)param;\r\n\t// Validate arguments\r\n\tif (tts == NULL || param == NULL)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tTtsAcceptProc(tts, tts->ListenSocketV6);\r\n"]]}
{"hexsha": "f0153c099b331ea049fed500630a4902bc96e43f", "ext": "c", "lang": "C", "content": "static int\nProcSecurityGenerateAuthorization(client)\n    ClientPtr client;\n{\n    REQUEST(xSecurityGenerateAuthorizationReq);\n    int len;\t\t\t/* request length in CARD32s*/\n    Bool removeAuth = FALSE;\t/* if bailout, call RemoveAuthorization? */\n    SecurityAuthorizationPtr pAuth = NULL;  /* auth we are creating */\n    int err;\t\t\t/* error to return from this function */\n    int status;\t\t\t/* return value from os functions */\n    XID authId;\t\t\t/* authorization ID assigned by os layer */\n    xSecurityGenerateAuthorizationReply rep; /* reply struct */\n    unsigned int trustLevel;    /* trust level of new auth */\n    XID group;\t\t\t/* group of new auth */\n    CARD32 timeout;\t\t/* timeout of new auth */\n    CARD32 *values;\t\t/* list of supplied attributes */\n    char *protoname;\t\t/* auth proto name sent in request */\n    char *protodata;\t\t/* auth proto data sent in request */\n    unsigned int authdata_len;  /* # bytes of generated auth data */\n    char *pAuthdata;\t\t/* generated auth data */\n    Mask eventMask;\t\t/* what events on this auth does client want */\n\n    /* paranoia: this \"can't happen\" because this extension is hidden\n     * from untrusted clients, but just in case...\n     */\n    if (client->trustLevel != XSecurityClientTrusted)\n\treturn BadRequest;\n\n    /* check request length */\n\n    REQUEST_AT_LEAST_SIZE(xSecurityGenerateAuthorizationReq);\n    len = SIZEOF(xSecurityGenerateAuthorizationReq) >> 2;\n    len += (stuff->nbytesAuthProto + (unsigned)3) >> 2;\n    len += (stuff->nbytesAuthData  + (unsigned)3) >> 2;\n    values = ((CARD32 *)stuff) + len;\n    len += Ones(stuff->valueMask);\n    if (client->req_len != len)\n\treturn BadLength;\n\n    /* check valuemask */\n    if (stuff->valueMask & ~XSecurityAllAuthorizationAttributes)\n    {\n\tclient->errorValue = stuff->valueMask;\n\treturn BadValue;\n    }\n\n    /* check timeout */\n    timeout = 60;\n    if (stuff->valueMask & XSecurityTimeout)\n    {\n\ttimeout = *values++;\n    }\n\n    /* check trustLevel */\n    trustLevel = XSecurityClientUntrusted;\n    if (stuff->valueMask & XSecurityTrustLevel)\n    {\n\ttrustLevel = *values++;\n\tif (trustLevel != XSecurityClientTrusted &&\n\t    trustLevel != XSecurityClientUntrusted)\n\t{\n\t    client->errorValue = trustLevel;\n\t    return BadValue;\n\t}\n    }\n\n    /* check group */\n    group = None;\n    if (stuff->valueMask & XSecurityGroup)\n    {\n\tgroup = *values++;\n\tif (SecurityValidateGroupCallback)\n\t{\n\t    SecurityValidateGroupInfoRec vgi;\n\t    vgi.group = group;\n\t    vgi.valid = FALSE;\n\t    CallCallbacks(&SecurityValidateGroupCallback, (pointer)&vgi);\n\n\t    /* if nobody said they recognized it, it's an error */\n\n\t    if (!vgi.valid)\n\t    {\n\t\tclient->errorValue = group;\n\t\treturn BadValue;\n\t    }\n\t}\n    }\n\n    /* check event mask */\n    eventMask = 0;\n    if (stuff->valueMask & XSecurityEventMask)\n    {\n\teventMask = *values++;\n\tif (eventMask & ~XSecurityAllEventMasks)\n\t{\n\t    client->errorValue = eventMask;\n\t    return BadValue;\n\t}\n    }\n\n    protoname = (char *)&stuff[1];\n    protodata = protoname + ((stuff->nbytesAuthProto + (unsigned)3) >> 2);\n\n    /* call os layer to generate the authorization */\n\n    authId = GenerateAuthorization(stuff->nbytesAuthProto, protoname,\n\t\t\t\t   stuff->nbytesAuthData,  protodata,\n\t\t\t\t   &authdata_len, &pAuthdata);\n    if ((XID) ~0L == authId)\n    {\n\terr = SecurityErrorBase + XSecurityBadAuthorizationProtocol;\n\tgoto bailout;\n    }\n\n    /* now that we've added the auth, remember to remove it if we have to\n     * abort the request for some reason (like allocation failure)\n     */\n    removeAuth = TRUE;\n\n    /* associate additional information with this auth ID */\n\n    pAuth = (SecurityAuthorizationPtr)xalloc(sizeof(SecurityAuthorizationRec));\n    if (!pAuth)\n    {\n\terr = BadAlloc;\n\tgoto bailout;\n    }\n\n    /* fill in the auth fields */\n\n    pAuth->id = authId;\n    pAuth->timeout = timeout;\n    pAuth->group = group;\n    pAuth->trustLevel = trustLevel;\n    pAuth->refcnt = 0;\t/* the auth was just created; nobody's using it yet */\n    pAuth->secondsRemaining = 0;\n    pAuth->timer = NULL;\n    pAuth->eventClients = NULL;\n\n    /* handle event selection */\n    if (eventMask)\n    {\n\terr = SecurityEventSelectForAuthorization(pAuth, client, eventMask);\n\tif (err != Success)\n\t    goto bailout;\n    }\n\n    if (!AddResource(authId, SecurityAuthorizationResType, pAuth))\n    {\n\terr = BadAlloc;\n\tgoto bailout;\n    }\n\n    /* start the timer ticking */\n\n    if (pAuth->timeout != 0)\n\tSecurityStartAuthorizationTimer(pAuth);\n\n    /* tell client the auth id and data */\n\n    rep.type = X_Reply;\n    rep.length = (authdata_len + 3) >> 2;\n    rep.sequenceNumber = client->sequence;\n    rep.authId = authId;\n    rep.dataLength = authdata_len;\n\n    if (client->swapped)\n    {\n\tregister char n;\n    \tswapl(&rep.length, n);\n    \tswaps(&rep.sequenceNumber, n);\n    \tswapl(&rep.authId, n);\n    \tswaps(&rep.dataLength, n);\n    }\n\n    WriteToClient(client, SIZEOF(xSecurityGenerateAuthorizationReply),\n\t\t  (char *)&rep);\n    WriteToClient(client, authdata_len, pAuthdata);\n\n    SecurityAudit(\"client %d generated authorization %d trust %d timeout %d group %d events %d\\n\",\n\t\t  client->index, pAuth->id, pAuth->trustLevel, pAuth->timeout,\n\t\t  pAuth->group, eventMask);\n\n    /* the request succeeded; don't call RemoveAuthorization or free pAuth */\n\n    removeAuth = FALSE;\n    pAuth = NULL;\n    err = client->noClientException;\n\nbailout:\n    if (removeAuth)\n\tRemoveAuthorization(stuff->nbytesAuthProto, protoname,\n\t\t\t    authdata_len, pAuthdata);\n    if (pAuth) xfree(pAuth);\n    return err;\n\n}", "item_id": 7, "repo": "tharindusathis/sourcecodes-of-CodeReadingTheOpenSourcePerspective", "file": "XFree86-3.3/xc/programs/Xserver/Xext/security.c", "last_update_at": "2022-03-11T04:30:49+00:00", "question_id": "f0153c099b331ea049fed500630a4902bc96e43f_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nProcSecurityGenerateAuthorization(client)\n    ClientPtr client;\n{\n    REQUEST(xSecurityGenerateAuthorizationReq);\n    int len;\t\t\t/* request length in CARD32s*/\n    Bool removeAuth = FALSE;\t/* if bailout, call RemoveAuthorization? */\n    SecurityAuthorizationPtr pAuth = NULL;  /* auth we are creating */\n    int err;\t\t\t/* error to return from this function */\n    int status;\t\t\t/* return value from os functions */\n    XID authId;\t\t\t/* authorization ID assigned by os layer */\n    xSecurityGenerateAuthorizationReply rep; /* reply struct */\n    unsigned int trustLevel;    /* trust level of new auth */\n    XID group;\t\t\t/* group of new auth */\n    CARD32 timeout;\t\t/* timeout of new auth */\n    CARD32 *values;\t\t/* list of supplied attributes */\n    char *protoname;\t\t/* auth proto name sent in request */\n    char *protodata;\t\t/* auth proto data sent in request */\n    unsigned int authdata_len;  /* # bytes of generated auth data */\n    char *pAuthdata;\t\t/* generated auth data */\n    Mask eventMask;\t\t/* what events on this auth does client want */\n    /* paranoia: this \"can't happen\" because this extension is hidden\n     * from untrusted clients, but just in case...\n     */\n    if (client->trustLevel != XSecurityClientTrusted)\n\treturn BadRequest;\n    /* check request length */\n    REQUEST_AT_LEAST_SIZE(xSecurityGenerateAuthorizationReq);\n    len = SIZEOF(xSecurityGenerateAuthorizationReq) >> 2;\n    len += (stuff->nbytesAuthProto + (unsigned)3) >> 2;\n    len += (stuff->nbytesAuthData  + (unsigned)3) >> 2;\n    values = ((CARD32 *)stuff) + len;\n    len += Ones(stuff->valueMask);\n    if (client->req_len != len)\n\treturn BadLength;\n    /* check valuemask */\n    if (stuff->valueMask & ~XSecurityAllAuthorizationAttributes)\n    {\n\tclient->errorValue = stuff->valueMask;\n\treturn BadValue;\n    }\n    /* check timeout */\n    timeout = 60;\n    if (stuff->valueMask & XSecurityTimeout)\n    {\n\ttimeout = *values++;\n    }\n    /* check trustLevel */\n    trustLevel = XSecurityClientUntrusted;\n    if (stuff->valueMask & XSecurityTrustLevel)\n    {\n\ttrustLevel = *values++;\n\tif (trustLevel != XSecurityClientTrusted &&\n\t    trustLevel != XSecurityClientUntrusted)\n\t{\n\t    client->errorValue = trustLevel;\n\t    return BadValue;\n\t}\n    }\n    /* check group */\n    group = None;\n    if (stuff->valueMask & XSecurityGroup)\n    {\n\tgroup = *values++;\n\tif (SecurityValidateGroupCallback)\n\t{\n\t    SecurityValidateGroupInfoRec vgi;\n\t    vgi.group = group;\n\t    vgi.valid = FALSE;\n\t    CallCallbacks(&SecurityValidateGroupCallback, (pointer)&vgi);\n\t    /* if nobody said they recognized it, it's an error */\n\t    if (!vgi.valid)\n\t    {\n\t\tclient->errorValue = group;\n\t\treturn BadValue;\n\t    }\n\t}\n    }\n    /* check event mask */\n    eventMask = 0;\n    if (stuff->valueMask & XSecurityEventMask)\n    {\n\teventMask = *values++;\n\tif (eventMask & ~XSecurityAllEventMasks)\n\t{\n\t    client->errorValue = eventMask;\n\t    return BadValue;\n\t}\n    }\n    protoname = (char *)&stuff[1];\n    protodata = protoname + ((stuff->nbytesAuthProto + (unsigned)3) >> 2);\n    /* call os layer to generate the authorization */\n    authId = GenerateAuthorization(stuff->nbytesAuthProto, protoname,\n\t\t\t\t   stuff->nbytesAuthData,  protodata,\n\t\t\t\t   &authdata_len, &pAuthdata);\n    if ((XID) ~0L == authId)\n    {\n\terr = SecurityErrorBase + XSecurityBadAuthorizationProtocol;\n\tgoto bailout;\n    }\n    /* now that we've added the auth, remember to remove it if we have to\n     * abort the request for some reason (like allocation failure)\n     */\n    removeAuth = TRUE;\n    /* associate additional information with this auth ID */\n    pAuth = (SecurityAuthorizationPtr)xalloc(sizeof(SecurityAuthorizationRec));\n    if (!pAuth)\n    {\n\terr = BadAlloc;\n\tgoto bailout;\n    }\n    /* fill in the auth fields */\n    pAuth->id = authId;\n    pAuth->timeout = timeout;\n    pAuth->group = group;\n    pAuth->trustLevel = trustLevel;\n    pAuth->refcnt = 0;\t/* the auth was just created; nobody's using it yet */\n    pAuth->secondsRemaining = 0;\n    pAuth->timer = NULL;\n    pAuth->eventClients = NULL;\n    /* handle event selection */\n    if (eventMask)\n    {\n\terr = SecurityEventSelectForAuthorization(pAuth, client, eventMask);\n\tif (err != Success)\n\t    goto bailout;\n    }\n    if (!AddResource(authId, SecurityAuthorizationResType, pAuth))\n    {\n\terr = BadAlloc;\n\tgoto bailout;\n    }\n    /* start the timer ticking */\n    if (pAuth->timeout != 0)\n\tSecurityStartAuthorizationTimer(pAuth);\n    /* tell client the auth id and data */\n    rep.type = X_Reply;\n    rep.length = (authdata_len + 3) >> 2;\n    rep.sequenceNumber = client->sequence;\n    rep.authId = authId;\n    rep.dataLength = authdata_len;\n    if (client->swapped)\n    {\n\tregister char n;\n    \tswapl(&rep.length, n);\n    \tswaps(&rep.sequenceNumber, n);\n    \tswapl(&rep.authId, n);\n    \tswaps(&rep.dataLength, n);\n    }\n    WriteToClient(client, SIZEOF(xSecurityGenerateAuthorizationReply),\n\t\t  (char *)&rep);\n    WriteToClient(client, authdata_len, pAuthdata);\n    SecurityAudit(\"client %d generated authorization %d trust %d timeout %d group %d events %d\\n\",\n\t\t  client->index, pAuth->id, pAuth->trustLevel, pAuth->timeout,\n\t\t  pAuth->group, eventMask);\n    /* the request succeeded; don't call RemoveAuthorization or free pAuth */\n    removeAuth = FALSE;\n    pAuth = NULL;\n    err = client->noClientException;\nbailout:\n    if (removeAuth)\n\tRemoveAuthorization(stuff->nbytesAuthProto, protoname,\n\t\t\t    authdata_len, pAuthdata);\n    if (pAuth) xfree(pAuth);\n    return err;\n"]]}
{"hexsha": "6cdfc653c29733e70d0663aff50997e53e695fb4", "ext": "c", "lang": "C", "content": "int\nipsec_updatereplay(u_int32_t seq, struct secasvar *sav)\n{\n\tchar buf[128];\n\tstruct secreplay *replay;\n\tu_int32_t diff;\n\tint fr;\n\tu_int32_t wsizeb;\t/* Constant: bits of window size. */\n\tint frlast;\t\t/* Constant: last frame. */\n\n\tIPSEC_ASSERT(sav != NULL, (\"Null SA\"));\n\tIPSEC_ASSERT(sav->replay != NULL, (\"Null replay state\"));\n\n\treplay = sav->replay;\n\n\tif (replay->wsize == 0)\n\t\tgoto ok;\t/* No need to check replay. */\n\n\t/* Constant. */\n\tfrlast = replay->wsize - 1;\n\twsizeb = replay->wsize << 3;\n\n\t/* Sequence number of 0 is invalid. */\n\tif (seq == 0)\n\t\treturn (1);\n\n\t/* First time. */\n\tif (replay->count == 0) {\n\t\treplay->lastseq = seq;\n\t\tbzero(replay->bitmap, replay->wsize);\n\t\t(replay->bitmap)[frlast] = 1;\n\t\tgoto ok;\n\t}\n\n\tif (seq > replay->lastseq) {\n\t\t/* seq is larger than lastseq. */\n\t\tdiff = seq - replay->lastseq;\n\n\t\t/* New larger sequence number. */\n\t\tif (diff < wsizeb) {\n\t\t\t/* In window. */\n\t\t\t/* Set bit for this packet. */\n\t\t\tvshiftl(replay->bitmap, diff, replay->wsize);\n\t\t\t(replay->bitmap)[frlast] |= 1;\n\t\t} else {\n\t\t\t/* This packet has a \"way larger\". */\n\t\t\tbzero(replay->bitmap, replay->wsize);\n\t\t\t(replay->bitmap)[frlast] = 1;\n\t\t}\n\t\treplay->lastseq = seq;\n\n\t\t/* Larger is good. */\n\t} else {\n\t\t/* seq is equal or less than lastseq. */\n\t\tdiff = replay->lastseq - seq;\n\n\t\t/* Over range to check, i.e. too old or wrapped. */\n\t\tif (diff >= wsizeb)\n\t\t\treturn (1);\n\n\t\tfr = frlast - diff / 8;\n\n\t\t/* This packet already seen? */\n\t\tif ((replay->bitmap)[fr] & (1 << (diff % 8)))\n\t\t\treturn (1);\n\n\t\t/* Mark as seen. */\n\t\t(replay->bitmap)[fr] |= (1 << (diff % 8));\n\n\t\t/* Out of order but good. */\n\t}\n\nok:\n\tif (replay->count == ~0) {\n\n\t\t/* Set overflow flag. */\n\t\treplay->overflow++;\n\n\t\t/* Don't increment, no more packets accepted. */\n\t\tif ((sav->flags & SADB_X_EXT_CYCSEQ) == 0)\n\t\t\treturn (1);\n\n\t\tipseclog((LOG_WARNING, \"%s: replay counter made %d cycle. %s\\n\",\n\t\t    __func__, replay->overflow,\n\t\t    ipsec_logsastr(sav, buf, sizeof(buf))));\n\t}\n\n\treplay->count++;\n\n\treturn (0);\n}", "item_id": 28, "repo": "TigerBSD/FreeBSD-Custom-ThinkPad", "file": "FreeBSD/sys/netipsec/ipsec.c", "last_update_at": "2022-03-16T05:58:05+00:00", "question_id": "6cdfc653c29733e70d0663aff50997e53e695fb4_28", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nipsec_updatereplay(u_int32_t seq, struct secasvar *sav)\n{\n\tchar buf[128];\n\tstruct secreplay *replay;\n\tu_int32_t diff;\n\tint fr;\n\tu_int32_t wsizeb;\t/* Constant: bits of window size. */\n\tint frlast;\t\t/* Constant: last frame. */\n\tIPSEC_ASSERT(sav != NULL, (\"Null SA\"));\n\tIPSEC_ASSERT(sav->replay != NULL, (\"Null replay state\"));\n\treplay = sav->replay;\n\tif (replay->wsize == 0)\n\t\tgoto ok;\t/* No need to check replay. */\n\t/* Constant. */\n\tfrlast = replay->wsize - 1;\n\twsizeb = replay->wsize << 3;\n\t/* Sequence number of 0 is invalid. */\n\tif (seq == 0)\n\t\treturn (1);\n\t/* First time. */\n\tif (replay->count == 0) {\n\t\treplay->lastseq = seq;\n\t\tbzero(replay->bitmap, replay->wsize);\n\t\t(replay->bitmap)[frlast] = 1;\n\t\tgoto ok;\n\t}\n\tif (seq > replay->lastseq) {\n\t\t/* seq is larger than lastseq. */\n\t\tdiff = seq - replay->lastseq;\n\t\t/* New larger sequence number. */\n\t\tif (diff < wsizeb) {\n\t\t\t/* In window. */\n\t\t\t/* Set bit for this packet. */\n\t\t\tvshiftl(replay->bitmap, diff, replay->wsize);\n\t\t\t(replay->bitmap)[frlast] |= 1;\n\t\t} else {\n\t\t\t/* This packet has a \"way larger\". */\n\t\t\tbzero(replay->bitmap, replay->wsize);\n\t\t\t(replay->bitmap)[frlast] = 1;\n\t\t}\n\t\treplay->lastseq = seq;\n\t\t/* Larger is good. */\n\t} else {\n\t\t/* seq is equal or less than lastseq. */\n\t\tdiff = replay->lastseq - seq;\n\t\t/* Over range to check, i.e. too old or wrapped. */\n\t\tif (diff >= wsizeb)\n\t\t\treturn (1);\n\t\tfr = frlast - diff / 8;\n\t\t/* This packet already seen? */\n\t\tif ((replay->bitmap)[fr] & (1 << (diff % 8)))\n\t\t\treturn (1);\n\t\t/* Mark as seen. */\n\t\t(replay->bitmap)[fr] |= (1 << (diff % 8));\n\t\t/* Out of order but good. */\n\t}\nok:\n\tif (replay->count == ~0) {\n\t\t/* Set overflow flag. */\n\t\treplay->overflow++;\n\t\t/* Don't increment, no more packets accepted. */\n\t\tif ((sav->flags & SADB_X_EXT_CYCSEQ) == 0)\n\t\t\treturn (1);\n\t\tipseclog((LOG_WARNING, \"%s: replay counter made %d cycle. %s\\n\",\n\t\t    __func__, replay->overflow,\n\t\t    ipsec_logsastr(sav, buf, sizeof(buf))));\n\t}\n\treplay->count++;\n\treturn (0);\n"]]}
{"hexsha": "1764ef509e93df97c64712092fbbc19609044400", "ext": "c", "lang": "C", "content": "double * rosen2dHess(double * x, void * args)\n{\n    assert(args == NULL);\n    \n    double * hess = calloc_double(2 * 2);\n    hess[0] = 2.0 + 100.0 * 2.0 * ( -2.0 * (x[1] - pow(x[0],2.0)) ) * ( -2.0 * x[0] * (-2.0 * x[0]));\n    hess[1] = 100.0 * 2.0 * x[1]; //d / dy ( df / dx)\n    hess[2] = 100.0 * 2.0 * (-2.0 * x[0]); // d / dx (df / dy)\n    hess[3] = 100.0 * 2.0;\n    return hess;\n}", "item_id": 8, "repo": "goroda/Compressed-Continuous-Computation", "file": "c3_cex/test/lib_optimization_test/opt_test.c", "last_update_at": "2022-03-12T21:08:03+00:00", "question_id": "1764ef509e93df97c64712092fbbc19609044400_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["double * rosen2dHess(double * x, void * args)\n{\n    assert(args == NULL);\n    double * hess = calloc_double(2 * 2);\n    hess[0] = 2.0 + 100.0 * 2.0 * ( -2.0 * (x[1] - pow(x[0],2.0)) ) * ( -2.0 * x[0] * (-2.0 * x[0]));\n    hess[1] = 100.0 * 2.0 * x[1]; //d / dy ( df / dx)\n    hess[2] = 100.0 * 2.0 * (-2.0 * x[0]); // d / dx (df / dy)\n    hess[3] = 100.0 * 2.0;\n    return hess;\n"]]}
{"hexsha": "9aee4e53711dab506f09e675eb89f14863b4dc21", "ext": "h", "lang": "C", "content": "namespace RE\n{\n\tclass TESForm;\n\n\tstruct BGSWorldLocation\n\t{\n\t\t// members\n\t\tNiPoint3 pos;               // 00\n\t\tTESForm* cellOrWorldSpace;  // 0C\n\t};\n\tstatic_assert(sizeof(BGSWorldLocation) == 0x18);\n}", "item_id": 0, "repo": "tossaponk/CommonLibSSE", "file": "include/RE/B/BGSWorldLocation.h", "last_update_at": "2022-02-21T21:31:27+00:00", "question_id": "9aee4e53711dab506f09e675eb89f14863b4dc21_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace RE\n{\n\tclass TESForm;\n\tstruct BGSWorldLocation\n\t{\n\t\t// members\n\t\tNiPoint3 pos;               // 00\n\t\tTESForm* cellOrWorldSpace;  // 0C\n\t};\n\tstatic_assert(sizeof(BGSWorldLocation) == 0x18);\n"]]}
{"hexsha": "82bd00af5cc3841ba6cd44ef51024b5792ba09b5", "ext": "c", "lang": "C", "content": "static int __init lart_flash_init (void)\n{\n   int result;\n   memset (&mtd,0,sizeof (mtd));\n   printk (\"MTD driver for LART. Written by Abraham vd Merwe <abraham@2d3d.co.za>\\n\");\n   printk (\"%s: Probing for 28F160x3 flash on LART...\\n\",module_name);\n   if (!flash_probe ())\n\t {\n\t\tprintk (KERN_WARNING \"%s: Found no LART compatible flash device\\n\",module_name);\n\t\treturn (-ENXIO);\n\t }\n   printk (\"%s: This looks like a LART board to me.\\n\",module_name);\n   mtd.name = module_name;\n   mtd.type = MTD_NORFLASH;\n   mtd.writesize = 1;\n   mtd.writebufsize = 4;\n   mtd.flags = MTD_CAP_NORFLASH;\n   mtd.size = FLASH_BLOCKSIZE_PARAM * FLASH_NUMBLOCKS_16m_PARAM + FLASH_BLOCKSIZE_MAIN * FLASH_NUMBLOCKS_16m_MAIN;\n   mtd.erasesize = FLASH_BLOCKSIZE_MAIN;\n   mtd.numeraseregions = ARRAY_SIZE(erase_regions);\n   mtd.eraseregions = erase_regions;\n   mtd._erase = flash_erase;\n   mtd._read = flash_read;\n   mtd._write = flash_write;\n   mtd.owner = THIS_MODULE;\n\n#ifdef LART_DEBUG\n   printk (KERN_DEBUG\n\t\t   \"mtd.name = %s\\n\"\n\t\t   \"mtd.size = 0x%.8x (%uM)\\n\"\n\t\t   \"mtd.erasesize = 0x%.8x (%uK)\\n\"\n\t\t   \"mtd.numeraseregions = %d\\n\",\n\t\t   mtd.name,\n\t\t   mtd.size,mtd.size / (1024*1024),\n\t\t   mtd.erasesize,mtd.erasesize / 1024,\n\t\t   mtd.numeraseregions);\n\n   if (mtd.numeraseregions)\n\t for (result = 0; result < mtd.numeraseregions; result++)\n\t   printk (KERN_DEBUG\n\t\t\t   \"\\n\\n\"\n\t\t\t   \"mtd.eraseregions[%d].offset = 0x%.8x\\n\"\n\t\t\t   \"mtd.eraseregions[%d].erasesize = 0x%.8x (%uK)\\n\"\n\t\t\t   \"mtd.eraseregions[%d].numblocks = %d\\n\",\n\t\t\t   result,mtd.eraseregions[result].offset,\n\t\t\t   result,mtd.eraseregions[result].erasesize,mtd.eraseregions[result].erasesize / 1024,\n\t\t\t   result,mtd.eraseregions[result].numblocks);\n\n   printk (\"\\npartitions = %d\\n\", ARRAY_SIZE(lart_partitions));\n\n   for (result = 0; result < ARRAY_SIZE(lart_partitions); result++)\n\t printk (KERN_DEBUG\n\t\t\t \"\\n\\n\"\n\t\t\t \"lart_partitions[%d].name = %s\\n\"\n\t\t\t \"lart_partitions[%d].offset = 0x%.8x\\n\"\n\t\t\t \"lart_partitions[%d].size = 0x%.8x (%uK)\\n\",\n\t\t\t result,lart_partitions[result].name,\n\t\t\t result,lart_partitions[result].offset,\n\t\t\t result,lart_partitions[result].size,lart_partitions[result].size / 1024);\n#endif\n\n   result = mtd_device_register(&mtd, lart_partitions,\n                                ARRAY_SIZE(lart_partitions));\n\n   return (result);\n}", "item_id": 9, "repo": "bradchesney79/illacceptanything", "file": "linux/drivers/mtd/devices/lart.c", "last_update_at": "2022-01-16T07:19:47+00:00", "question_id": "82bd00af5cc3841ba6cd44ef51024b5792ba09b5_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int __init lart_flash_init (void)\n{\n   int result;\n   memset (&mtd,0,sizeof (mtd));\n   printk (\"MTD driver for LART. Written by Abraham vd Merwe <abraham@2d3d.co.za>\\n\");\n   printk (\"%s: Probing for 28F160x3 flash on LART...\\n\",module_name);\n   if (!flash_probe ())\n\t {\n\t\tprintk (KERN_WARNING \"%s: Found no LART compatible flash device\\n\",module_name);\n\t\treturn (-ENXIO);\n\t }\n   printk (\"%s: This looks like a LART board to me.\\n\",module_name);\n   mtd.name = module_name;\n   mtd.type = MTD_NORFLASH;\n   mtd.writesize = 1;\n   mtd.writebufsize = 4;\n   mtd.flags = MTD_CAP_NORFLASH;\n   mtd.size = FLASH_BLOCKSIZE_PARAM * FLASH_NUMBLOCKS_16m_PARAM + FLASH_BLOCKSIZE_MAIN * FLASH_NUMBLOCKS_16m_MAIN;\n   mtd.erasesize = FLASH_BLOCKSIZE_MAIN;\n   mtd.numeraseregions = ARRAY_SIZE(erase_regions);\n   mtd.eraseregions = erase_regions;\n   mtd._erase = flash_erase;\n   mtd._read = flash_read;\n   mtd._write = flash_write;\n   mtd.owner = THIS_MODULE;\n#ifdef LART_DEBUG\n   printk (KERN_DEBUG\n\t\t   \"mtd.name = %s\\n\"\n\t\t   \"mtd.size = 0x%.8x (%uM)\\n\"\n\t\t   \"mtd.erasesize = 0x%.8x (%uK)\\n\"\n\t\t   \"mtd.numeraseregions = %d\\n\",\n\t\t   mtd.name,\n\t\t   mtd.size,mtd.size / (1024*1024),\n\t\t   mtd.erasesize,mtd.erasesize / 1024,\n\t\t   mtd.numeraseregions);\n   if (mtd.numeraseregions)\n\t for (result = 0; result < mtd.numeraseregions; result++)\n\t   printk (KERN_DEBUG\n\t\t\t   \"\\n\\n\"\n\t\t\t   \"mtd.eraseregions[%d].offset = 0x%.8x\\n\"\n\t\t\t   \"mtd.eraseregions[%d].erasesize = 0x%.8x (%uK)\\n\"\n\t\t\t   \"mtd.eraseregions[%d].numblocks = %d\\n\",\n\t\t\t   result,mtd.eraseregions[result].offset,\n\t\t\t   result,mtd.eraseregions[result].erasesize,mtd.eraseregions[result].erasesize / 1024,\n\t\t\t   result,mtd.eraseregions[result].numblocks);\n   printk (\"\\npartitions = %d\\n\", ARRAY_SIZE(lart_partitions));\n   for (result = 0; result < ARRAY_SIZE(lart_partitions); result++)\n\t printk (KERN_DEBUG\n\t\t\t \"\\n\\n\"\n\t\t\t \"lart_partitions[%d].name = %s\\n\"\n\t\t\t \"lart_partitions[%d].offset = 0x%.8x\\n\"\n\t\t\t \"lart_partitions[%d].size = 0x%.8x (%uK)\\n\",\n\t\t\t result,lart_partitions[result].name,\n\t\t\t result,lart_partitions[result].offset,\n\t\t\t result,lart_partitions[result].size,lart_partitions[result].size / 1024);\n#endif\n   result = mtd_device_register(&mtd, lart_partitions,\n                                ARRAY_SIZE(lart_partitions));\n   return (result);\n"]]}
{"hexsha": "7cc5793872a3905c6c2fc71677c3f716c45eab99", "ext": "c", "lang": "C", "content": "static int usbdk_get_device_descriptor(struct libusb_device *dev, unsigned char *buffer, int *host_endian)\n{\n\tstruct usbdk_device_priv *priv = _usbdk_device_priv(dev);\n\n\tmemcpy(buffer, &priv->info.DeviceDescriptor, DEVICE_DESC_LENGTH);\n\t*host_endian = 0;\n\n\treturn LIBUSB_SUCCESS;\n}", "item_id": 9, "repo": "u5surf/go-livepeer", "file": "vendor/github.com/ethereum/go-ethereum/vendor/github.com/karalabe/hid/libusb/libusb/os/windows_usbdk.c", "last_update_at": "2022-02-06T12:21:26+00:00", "question_id": "7cc5793872a3905c6c2fc71677c3f716c45eab99_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int usbdk_get_device_descriptor(struct libusb_device *dev, unsigned char *buffer, int *host_endian)\n{\n\tstruct usbdk_device_priv *priv = _usbdk_device_priv(dev);\n\tmemcpy(buffer, &priv->info.DeviceDescriptor, DEVICE_DESC_LENGTH);\n\t*host_endian = 0;\n\treturn LIBUSB_SUCCESS;\n"]]}
{"hexsha": "50984a3707680c1746868bcc4693c920145f81c7", "ext": "c", "lang": "C", "content": "JNICALL Java_com_virgilsecurity_crypto_phe_PheJNI_uokmsWrapRotation_1new__ (JNIEnv *jenv, jobject jobj) {\n    jlong c_ctx = 0;\n    *(vsce_uokms_wrap_rotation_t **)&c_ctx = vsce_uokms_wrap_rotation_new();\n    return c_ctx;\n}", "item_id": 56, "repo": "odidev/virgil-crypto-c", "file": "wrappers/java/phe/jni/PheJNI.c", "last_update_at": "2022-01-16T20:00:04+00:00", "question_id": "50984a3707680c1746868bcc4693c920145f81c7_56", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["JNICALL Java_com_virgilsecurity_crypto_phe_PheJNI_uokmsWrapRotation_1new__ (JNIEnv *jenv, jobject jobj) {\n    jlong c_ctx = 0;\n    *(vsce_uokms_wrap_rotation_t **)&c_ctx = vsce_uokms_wrap_rotation_new();\n    return c_ctx;\n"]]}
{"hexsha": "d36e38df4afd0b4ec0d9c497a13f9e0fa8ca11c0", "ext": "c", "lang": "C", "content": "void\nlock_print_info_all_transactions(\n/*=============================*/\n\tFILE*\tfile)\t/* in: file where to print */\n{\n\tlock_t*\tlock;\n\tulint\tspace;\n\tulint\tpage_no;\n\tibool\tload_page_first = TRUE;\n\tulint\tnth_trx\t\t= 0;\n\tulint\tnth_lock\t= 0;\n\tulint\ti;\n\tmtr_t\tmtr;\n\ttrx_t*\ttrx;\n\n\tfprintf(file, \"LIST OF TRANSACTIONS FOR EACH SESSION:\\n\");\n\n\t/* First print info on non-active transactions */\n\n\ttrx = UT_LIST_GET_FIRST(trx_sys->mysql_trx_list);\n\n\twhile (trx) {\n\t\tif (trx->conc_state == TRX_NOT_STARTED) {\n\t\t\tfputs(\"---\", file);\n\t\t\ttrx_print(file, trx, 600);\n\t\t}\n\n\t\ttrx = UT_LIST_GET_NEXT(mysql_trx_list, trx);\n\t}\n\nloop:\n\ttrx = UT_LIST_GET_FIRST(trx_sys->trx_list);\n\n\ti = 0;\n\n\t/* Since we temporarily release the kernel mutex when\n\treading a database page in below, variable trx may be\n\tobsolete now and we must loop through the trx list to\n\tget probably the same trx, or some other trx. */\n\n\twhile (trx && (i < nth_trx)) {\n\t\ttrx = UT_LIST_GET_NEXT(trx_list, trx);\n\t\ti++;\n\t}\n\n\tif (trx == NULL) {\n\t\tlock_mutex_exit_kernel();\n\n\t\tut_ad(lock_validate());\n\n\t\treturn;\n\t}\n\n\tif (nth_lock == 0) {\n\t\tfputs(\"---\", file);\n\t\ttrx_print(file, trx, 600);\n\n\t\tif (trx->read_view) {\n\t\t\tfprintf(file,\n\t\t\t\t\"Trx read view will not see trx with\"\n\t\t\t\t\" id >= %lu %lu, sees < %lu %lu\\n\",\n\t\t\t\t(ulong) ut_dulint_get_high(\n\t\t\t\t\ttrx->read_view->low_limit_id),\n\t\t\t\t(ulong) ut_dulint_get_low(\n\t\t\t\t\ttrx->read_view->low_limit_id),\n\t\t\t\t(ulong) ut_dulint_get_high(\n\t\t\t\t\ttrx->read_view->up_limit_id),\n\t\t\t\t(ulong) ut_dulint_get_low(\n\t\t\t\t\ttrx->read_view->up_limit_id));\n\t\t}\n\n\t\tif (trx->que_state == TRX_QUE_LOCK_WAIT) {\n\t\t\tfprintf(file,\n\t\t\t\t\"------- TRX HAS BEEN WAITING %lu SEC\"\n\t\t\t\t\" FOR THIS LOCK TO BE GRANTED:\\n\",\n\t\t\t\t(ulong) difftime(time(NULL),\n\t\t\t\t\t\t trx->wait_started));\n\n\t\t\tif (lock_get_type(trx->wait_lock) == LOCK_REC) {\n\t\t\t\tlock_rec_print(file, trx->wait_lock);\n\t\t\t} else {\n\t\t\t\tlock_table_print(file, trx->wait_lock);\n\t\t\t}\n\n\t\t\tfputs(\"------------------\\n\", file);\n\t\t}\n\t}\n\n\tif (!srv_print_innodb_lock_monitor) {\n\t\tnth_trx++;\n\t\tgoto loop;\n\t}\n\n\ti = 0;\n\n\t/* Look at the note about the trx loop above why we loop here:\n\tlock may be an obsolete pointer now. */\n\n\tlock = UT_LIST_GET_FIRST(trx->trx_locks);\n\n\twhile (lock && (i < nth_lock)) {\n\t\tlock = UT_LIST_GET_NEXT(trx_locks, lock);\n\t\ti++;\n\t}\n\n\tif (lock == NULL) {\n\t\tnth_trx++;\n\t\tnth_lock = 0;\n\n\t\tgoto loop;\n\t}\n\n\tif (lock_get_type(lock) == LOCK_REC) {\n\t\tspace = lock->un_member.rec_lock.space;\n\t\tpage_no = lock->un_member.rec_lock.page_no;\n\n\t\tif (load_page_first) {\n\t\t\tlock_mutex_exit_kernel();\n\n\t\t\tmtr_start(&mtr);\n\n\t\t\tbuf_page_get_with_no_latch(space, page_no, &mtr);\n\n\t\t\tmtr_commit(&mtr);\n\n\t\t\tload_page_first = FALSE;\n\n\t\t\tlock_mutex_enter_kernel();\n\n\t\t\tgoto loop;\n\t\t}\n\n\t\tlock_rec_print(file, lock);\n\t} else {\n\t\tut_ad(lock_get_type(lock) & LOCK_TABLE);\n\n\t\tlock_table_print(file, lock);\n\t}\n\n\tload_page_first = TRUE;\n\n\tnth_lock++;\n\n\tif (nth_lock >= 10) {\n\t\tfputs(\"10 LOCKS PRINTED FOR THIS TRX:\"\n\t\t      \" SUPPRESSING FURTHER PRINTS\\n\",\n\t\t      file);\n\n\t\tnth_trx++;\n\t\tnth_lock = 0;\n\n\t\tgoto loop;\n\t}\n\n\tgoto loop;\n}", "item_id": 87, "repo": "afeng11/tomato-arm", "file": "release/src-rt-6.x.4708/router/mysql/storage/innobase/lock/lock0lock.c", "last_update_at": "2022-01-20T18:21:05+00:00", "question_id": "d36e38df4afd0b4ec0d9c497a13f9e0fa8ca11c0_87", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nlock_print_info_all_transactions(\n/*=============================*/\n\tFILE*\tfile)\t/* in: file where to print */\n{\n\tlock_t*\tlock;\n\tulint\tspace;\n\tulint\tpage_no;\n\tibool\tload_page_first = TRUE;\n\tulint\tnth_trx\t\t= 0;\n\tulint\tnth_lock\t= 0;\n\tulint\ti;\n\tmtr_t\tmtr;\n\ttrx_t*\ttrx;\n\tfprintf(file, \"LIST OF TRANSACTIONS FOR EACH SESSION:\\n\");\n\t/* First print info on non-active transactions */\n\ttrx = UT_LIST_GET_FIRST(trx_sys->mysql_trx_list);\n\twhile (trx) {\n\t\tif (trx->conc_state == TRX_NOT_STARTED) {\n\t\t\tfputs(\"---\", file);\n\t\t\ttrx_print(file, trx, 600);\n\t\t}\n\t\ttrx = UT_LIST_GET_NEXT(mysql_trx_list, trx);\n\t}\nloop:\n\ttrx = UT_LIST_GET_FIRST(trx_sys->trx_list);\n\ti = 0;\n\t/* Since we temporarily release the kernel mutex when\n\treading a database page in below, variable trx may be\n\tobsolete now and we must loop through the trx list to\n\tget probably the same trx, or some other trx. */\n\twhile (trx && (i < nth_trx)) {\n\t\ttrx = UT_LIST_GET_NEXT(trx_list, trx);\n\t\ti++;\n\t}\n\tif (trx == NULL) {\n\t\tlock_mutex_exit_kernel();\n\t\tut_ad(lock_validate());\n\t\treturn;\n\t}\n\tif (nth_lock == 0) {\n\t\tfputs(\"---\", file);\n\t\ttrx_print(file, trx, 600);\n\t\tif (trx->read_view) {\n\t\t\tfprintf(file,\n\t\t\t\t\"Trx read view will not see trx with\"\n\t\t\t\t\" id >= %lu %lu, sees < %lu %lu\\n\",\n\t\t\t\t(ulong) ut_dulint_get_high(\n\t\t\t\t\ttrx->read_view->low_limit_id),\n\t\t\t\t(ulong) ut_dulint_get_low(\n\t\t\t\t\ttrx->read_view->low_limit_id),\n\t\t\t\t(ulong) ut_dulint_get_high(\n\t\t\t\t\ttrx->read_view->up_limit_id),\n\t\t\t\t(ulong) ut_dulint_get_low(\n\t\t\t\t\ttrx->read_view->up_limit_id));\n\t\t}\n\t\tif (trx->que_state == TRX_QUE_LOCK_WAIT) {\n\t\t\tfprintf(file,\n\t\t\t\t\"------- TRX HAS BEEN WAITING %lu SEC\"\n\t\t\t\t\" FOR THIS LOCK TO BE GRANTED:\\n\",\n\t\t\t\t(ulong) difftime(time(NULL),\n\t\t\t\t\t\t trx->wait_started));\n\t\t\tif (lock_get_type(trx->wait_lock) == LOCK_REC) {\n\t\t\t\tlock_rec_print(file, trx->wait_lock);\n\t\t\t} else {\n\t\t\t\tlock_table_print(file, trx->wait_lock);\n\t\t\t}\n\t\t\tfputs(\"------------------\\n\", file);\n\t\t}\n\t}\n\tif (!srv_print_innodb_lock_monitor) {\n\t\tnth_trx++;\n\t\tgoto loop;\n\t}\n\ti = 0;\n\t/* Look at the note about the trx loop above why we loop here:\n\tlock may be an obsolete pointer now. */\n\tlock = UT_LIST_GET_FIRST(trx->trx_locks);\n\twhile (lock && (i < nth_lock)) {\n\t\tlock = UT_LIST_GET_NEXT(trx_locks, lock);\n\t\ti++;\n\t}\n\tif (lock == NULL) {\n\t\tnth_trx++;\n\t\tnth_lock = 0;\n\t\tgoto loop;\n\t}\n\tif (lock_get_type(lock) == LOCK_REC) {\n\t\tspace = lock->un_member.rec_lock.space;\n\t\tpage_no = lock->un_member.rec_lock.page_no;\n\t\tif (load_page_first) {\n\t\t\tlock_mutex_exit_kernel();\n\t\t\tmtr_start(&mtr);\n\t\t\tbuf_page_get_with_no_latch(space, page_no, &mtr);\n\t\t\tmtr_commit(&mtr);\n\t\t\tload_page_first = FALSE;\n\t\t\tlock_mutex_enter_kernel();\n\t\t\tgoto loop;\n\t\t}\n\t\tlock_rec_print(file, lock);\n\t} else {\n\t\tut_ad(lock_get_type(lock) & LOCK_TABLE);\n\t\tlock_table_print(file, lock);\n\t}\n\tload_page_first = TRUE;\n\tnth_lock++;\n\tif (nth_lock >= 10) {\n\t\tfputs(\"10 LOCKS PRINTED FOR THIS TRX:\"\n\t\t      \" SUPPRESSING FURTHER PRINTS\\n\",\n\t\t      file);\n\t\tnth_trx++;\n\t\tnth_lock = 0;\n\t\tgoto loop;\n\t}\n\tgoto loop;\n"]]}
{"hexsha": "0395e1bc12b6e28bb8931b2107eb5ca0b13881fe", "ext": "c", "lang": "C", "content": "int\nunsetenv(const char* name)\n{\n  int r;\n  char* p = malloc(strlen(name) + 2);\n  if (!p) return -1;\n  strcpy(p, name);\n  strcat(p, \"=\");\n  r = _putenv(p);\n  free(p);\n  return r;\n}", "item_id": 0, "repo": "Leo-Neat/h2o", "file": "deps/mruby-env/src/env.c", "last_update_at": "2022-03-31T08:32:33+00:00", "question_id": "0395e1bc12b6e28bb8931b2107eb5ca0b13881fe_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nunsetenv(const char* name)\n{\n  int r;\n  char* p = malloc(strlen(name) + 2);\n  if (!p) return -1;\n  strcpy(p, name);\n  strcat(p, \"=\");\n  r = _putenv(p);\n  free(p);\n  return r;\n"]]}
{"hexsha": "133cb3aa9245c163e388267e8cd2484fe5f42277", "ext": "c", "lang": "C", "content": "LLUV_IMPL_SAFE(lluv_fs_event_create){\n  lluv_loop_t   *loop   = lluv_opt_loop_ex(L, 1, LLUV_FLAG_OPEN);\n  lluv_handle_t *handle = lluv_handle_create(L, UV_FS_EVENT, safe_flag | INHERITE_FLAGS(loop));\n  int err = uv_fs_event_init(loop->handle, LLUV_H(handle, uv_fs_event_t));\n  if(err < 0){\n    lluv_handle_cleanup(L, handle, -1);\n    return lluv_fail(L, safe_flag | loop->flags, LLUV_ERR_UV, (uv_errno_t)err, NULL);\n  }\n  return 1;\n}", "item_id": 0, "repo": "nirenr/AndroLua-", "file": "app/src/main/jni/lluv/lluv/lluv_fs_event.c", "last_update_at": "2022-03-30T13:22:47+00:00", "question_id": "133cb3aa9245c163e388267e8cd2484fe5f42277_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["LLUV_IMPL_SAFE(lluv_fs_event_create){\n  lluv_loop_t   *loop   = lluv_opt_loop_ex(L, 1, LLUV_FLAG_OPEN);\n  lluv_handle_t *handle = lluv_handle_create(L, UV_FS_EVENT, safe_flag | INHERITE_FLAGS(loop));\n  int err = uv_fs_event_init(loop->handle, LLUV_H(handle, uv_fs_event_t));\n  if(err < 0){\n    lluv_handle_cleanup(L, handle, -1);\n    return lluv_fail(L, safe_flag | loop->flags, LLUV_ERR_UV, (uv_errno_t)err, NULL);\n  }\n  return 1;\n"]]}
{"hexsha": "611ea8bbce83f1c0c4eb27dcbb9c1bb06ea253d1", "ext": "c", "lang": "C", "content": "int* quicksort(int arr[] ,int len, int low, int high)\n{\n    int j;\n    if (low < high)\n    {\n        j = partition(arr,len);\n        quicksort(arr, len,low , j);\n        quicksort(arr ,len , j + 1 , high);\n    }\n    return arr;\n}", "item_id": 1, "repo": "BirendraRokaha/Learn2020", "file": "C-CPlus/C/array/arrayTest.c", "last_update_at": "2022-03-02T09:51:03+00:00", "question_id": "611ea8bbce83f1c0c4eb27dcbb9c1bb06ea253d1_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int* quicksort(int arr[] ,int len, int low, int high)\n{\n    int j;\n    if (low < high)\n    {\n        j = partition(arr,len);\n        quicksort(arr, len,low , j);\n        quicksort(arr ,len , j + 1 , high);\n    }\n    return arr;\n"]]}
{"hexsha": "cfc6cb9e42715caf453e6d578171494a783ad3c9", "ext": "c", "lang": "C", "content": "static int SCPreallocMessage(SCMessageQueue *mq, uint32_t length, SCMsgHdr **hdr_ptr, uint8_t **msg_ptr, void **msg_handle)\n{\n    int rval;\n\n    pthread_mutex_lock(&mq->mutex);\n    rval = RBMQ_ReserveMsg(mq->queue, length, (void **) hdr_ptr, msg_ptr, msg_handle);\n    pthread_mutex_unlock(&mq->mutex);\n\n    return rval;\n}", "item_id": 4, "repo": "nabilabonasser/tutorials", "file": "tutorials/exercises/dcpids/snort-2.9.15/src/side-channel/sidechannel.c", "last_update_at": "2022-03-20T02:12:55+00:00", "question_id": "cfc6cb9e42715caf453e6d578171494a783ad3c9_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int SCPreallocMessage(SCMessageQueue *mq, uint32_t length, SCMsgHdr **hdr_ptr, uint8_t **msg_ptr, void **msg_handle)\n{\n    int rval;\n    pthread_mutex_lock(&mq->mutex);\n    rval = RBMQ_ReserveMsg(mq->queue, length, (void **) hdr_ptr, msg_ptr, msg_handle);\n    pthread_mutex_unlock(&mq->mutex);\n    return rval;\n"]]}
{"hexsha": "1e54ca985a3589d6ccbca5ca9dc98f1394152203", "ext": "c", "lang": "C", "content": "void *ui_get_system_icon ( int n )\n{\n    if (n <= 0){ return NULL; }\n\n    // See: window.h\n    switch (n){\n\n    case 1: return (void *) shared_buffer_app_icon;       break;\n    case 2: return (void *) shared_buffer_file_icon;      break;\n    case 3: return (void *) shared_buffer_folder_icon;    break;\n    case 4: return (void *) shared_buffer_terminal_icon;  break;\n    case 5: return (void *) shared_buffer_cursor_icon;    break;\n    // ...\n    };\n\n    return NULL;\n}", "item_id": 11, "repo": "gramado/field", "file": "base/new/user/kgwm.c", "last_update_at": "2022-03-24T11:24:42+00:00", "question_id": "1e54ca985a3589d6ccbca5ca9dc98f1394152203_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void *ui_get_system_icon ( int n )\n{\n    if (n <= 0){ return NULL; }\n    // See: window.h\n    switch (n){\n    case 1: return (void *) shared_buffer_app_icon;       break;\n    case 2: return (void *) shared_buffer_file_icon;      break;\n    case 3: return (void *) shared_buffer_folder_icon;    break;\n    case 4: return (void *) shared_buffer_terminal_icon;  break;\n    case 5: return (void *) shared_buffer_cursor_icon;    break;\n    // ...\n    };\n    return NULL;\n"]]}
{"hexsha": "8f7fdc830ac7ae79486fcf4856c1a0e8324f4f68", "ext": "c", "lang": "C", "content": "void setup(void) {\n   add_area(AREA);\n   add_area(FAIRYLAND_AREA);\n   set_light(1);\n   set_short(\"On a path in Darkwood\");\n   set_long(\"You are on a twisty path in the legendary Darkwood. \" +\n            \"You feel lucky to still be alive.\");\n\n   add_exit(\"north\", FAIRYLAND_ROOMS + \"/darkwood3.c\");\n   add_exit(\"south\", FAIRYLAND_ROOMS + \"/darkwood4.c\");\n   add_exit(\"east\", FAIRYLAND_ROOMS + \"/dw_path3.c\");\n   add_exit(\"west\", FAIRYLAND_ROOMS + \"/dw_path5.c\");\n\n   add_item(\"path\", \"The path is becoming more and more faint. Best hope you do not lose it.\");\n   add_item(\"darkwood\", \"The forest gets more evil now, and light is frequently blocked by the trees.\");\n}", "item_id": 0, "repo": "DEFCON-MUD/defcon-28-mud-source", "file": "gurba/lib/domains/angmar/rooms/fairyland/dw_path4.c", "last_update_at": "2022-03-11T20:50:59+00:00", "question_id": "8f7fdc830ac7ae79486fcf4856c1a0e8324f4f68_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void setup(void) {\n   add_area(AREA);\n   add_area(FAIRYLAND_AREA);\n   set_light(1);\n   set_short(\"On a path in Darkwood\");\n   set_long(\"You are on a twisty path in the legendary Darkwood. \" +\n            \"You feel lucky to still be alive.\");\n   add_exit(\"north\", FAIRYLAND_ROOMS + \"/darkwood3.c\");\n   add_exit(\"south\", FAIRYLAND_ROOMS + \"/darkwood4.c\");\n   add_exit(\"east\", FAIRYLAND_ROOMS + \"/dw_path3.c\");\n   add_exit(\"west\", FAIRYLAND_ROOMS + \"/dw_path5.c\");\n   add_item(\"path\", \"The path is becoming more and more faint. Best hope you do not lose it.\");\n   add_item(\"darkwood\", \"The forest gets more evil now, and light is frequently blocked by the trees.\");\n"]]}
{"hexsha": "25d50bf3432ac48e1dbe6b74b075846523227d3e", "ext": "c", "lang": "C", "content": "int Fraig_NodeVecPushUniqueOrderByLevel( Fraig_NodeVec_t * p, Fraig_Node_t * pNode )\n{\n    int i;\n    for ( i = 0; i < p->nSize; i++ )\n        if ( p->pArray[i] == pNode )\n            return 1;\n    Fraig_NodeVecPushOrderByLevel( p, pNode );\n    return 0;\n}", "item_id": 7, "repo": "HackerFoo/vtr-verilog-to-routing", "file": "abc/src/proof/fraig/fraigVec.c", "last_update_at": "2022-03-30T05:24:53+00:00", "question_id": "25d50bf3432ac48e1dbe6b74b075846523227d3e_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int Fraig_NodeVecPushUniqueOrderByLevel( Fraig_NodeVec_t * p, Fraig_Node_t * pNode )\n{\n    int i;\n    for ( i = 0; i < p->nSize; i++ )\n        if ( p->pArray[i] == pNode )\n            return 1;\n    Fraig_NodeVecPushOrderByLevel( p, pNode );\n    return 0;\n"]]}
{"hexsha": "2c142e3bf5c05c4e55643c27556f9201c807ae37", "ext": "c", "lang": "C", "content": "EffEntry* effNameToPtr(const char* name) {\n\tEffEntry* entry;\n\tint i;\n\n\tfor (i = 0; i < wp->numEntries; i++) {\n\t\tentry = &wp->entries[i];\n\t\tif (entry->flags && !strcmp(name, entry->name)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i < wp->numEntries) { //found a match\n\t\treturn entry;\n\t}\n\telse {\n\t\treturn NULL;\n\t}\n}", "item_id": 7, "repo": "NWPlayer123/PaperMario2", "file": "source/drv/effdrv.c", "last_update_at": "2022-02-05T18:08:36+00:00", "question_id": "2c142e3bf5c05c4e55643c27556f9201c807ae37_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["EffEntry* effNameToPtr(const char* name) {\n\tEffEntry* entry;\n\tint i;\n\tfor (i = 0; i < wp->numEntries; i++) {\n\t\tentry = &wp->entries[i];\n\t\tif (entry->flags && !strcmp(name, entry->name)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i < wp->numEntries) { //found a match\n\t\treturn entry;\n\t}\n\telse {\n\t\treturn NULL;\n\t}\n"]]}
{"hexsha": "107bc159e2e5d78baf6e082366fab5782f294df5", "ext": "h", "lang": "C", "content": "inline bool CaselessStringLessThanIgnoreSlashes( const char * const &lhs, const char * const &rhs )\t\n{ \n\tconst char *pa = lhs;\n\tconst char *pb = rhs;\n\twhile ( *pa && *pb )\n\t{\n\t\tchar a = *pa;\n\t\tchar b = *pb;\n\t\t\n\t\t// Check for dir slashes.\n\t\tif ( a == '/' || a == '\\\\' )\n\t\t{\n\t\t\tif ( b != '/' && b != '\\\\' )\n\t\t\t\treturn ('/' < b);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ( a >= 'a' && a <= 'z' )\n\t\t\t\ta = 'A' + (a - 'a');\n\t\t\t\n\t\t\tif ( b >= 'a' && b <= 'z' )\n\t\t\t\tb = 'A' + (b - 'a');\n\t\t\t\t\n\t\t\tif ( a > b )\n\t\t\t\treturn false;\n\t\t\telse if ( a < b )\n\t\t\t\treturn true;\n\t\t}\n\t\t++pa;\n\t\t++pb;\n\t}\n\t\n\t// Filenames also must be the same length.\n\tif ( *pa != *pb )\n\t{\n\t\t// If pa shorter than pb then it's \"less\"\n\t\treturn ( !*pa );\n\t}\n\n\treturn false;\n}", "item_id": 0, "repo": "newcommerdontblame/ionlib", "file": "src/sdk/hl2_csgo/public/tier1/utlrbtree.h", "last_update_at": "2022-03-03T13:10:02+00:00", "question_id": "107bc159e2e5d78baf6e082366fab5782f294df5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["inline bool CaselessStringLessThanIgnoreSlashes( const char * const &lhs, const char * const &rhs )\t\n{ \n\tconst char *pa = lhs;\n\tconst char *pb = rhs;\n\twhile ( *pa && *pb )\n\t{\n\t\tchar a = *pa;\n\t\tchar b = *pb;\n\t\t\n\t\t// Check for dir slashes.\n\t\tif ( a == '/' || a == '\\\\' )\n\t\t{\n\t\t\tif ( b != '/' && b != '\\\\' )\n\t\t\t\treturn ('/' < b);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ( a >= 'a' && a <= 'z' )\n\t\t\t\ta = 'A' + (a - 'a');\n\t\t\t\n\t\t\tif ( b >= 'a' && b <= 'z' )\n\t\t\t\tb = 'A' + (b - 'a');\n\t\t\t\t\n\t\t\tif ( a > b )\n\t\t\t\treturn false;\n\t\t\telse if ( a < b )\n\t\t\t\treturn true;\n\t\t}\n\t\t++pa;\n\t\t++pb;\n\t}\n\t\n\t// Filenames also must be the same length.\n\tif ( *pa != *pb )\n\t{\n\t\t// If pa shorter than pb then it's \"less\"\n\t\treturn ( !*pa );\n\t}\n\treturn false;\n"]]}
{"hexsha": "648a37aad7b3d5980e7a1291debeb8b4b9a4005e", "ext": "c", "lang": "C", "content": "unsigned short int  dev_timer_clr_int( void )\n{\n  TIM2->SR &= ~TIM_SR_UIF; /* clear update interrupt */\n\n  return  0;\n}", "item_id": 2, "repo": "ZhenshengLee/mros2-asp3-f767zi", "file": "test/comm_tests/tcp/tcp7/sample1.c", "last_update_at": "2022-03-17T09:23:04+00:00", "question_id": "648a37aad7b3d5980e7a1291debeb8b4b9a4005e_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsigned short int  dev_timer_clr_int( void )\n{\n  TIM2->SR &= ~TIM_SR_UIF; /* clear update interrupt */\n  return  0;\n"]]}
{"hexsha": "288e1e0afdae3d99c95df37a36059f596509f395", "ext": "h", "lang": "C", "content": "static inline SchedInfo*\nadamant_IVE_read(AdamantRuntime *runtime, guint reg, guint distance)\n{\n  /* The basic idea here is to follow the dependence chain for reg\n     back runtime->config->opti.unroll_factor many links.  That node\n     will act as our input dependence rather than the tail of the\n     dependence chain (since all intervening nodes could be folded). */\n  AdamantIVENode *node;\n  guint i;\n\n  if(reg > runtime->opti->induction_vars->len)\n    adamant_IVE_reset(runtime, reg, 0, 0, 0);\n\n  g_assert(reg < runtime->opti->induction_vars->len);\n\n  node = g_array_index(runtime->opti->induction_vars, AdamantIVENode*, reg);\n  if(node == NULL) {\n    adamant_IVE_reset(runtime, reg, 0, 0, 0);\n    node = g_array_index(runtime->opti->induction_vars, AdamantIVENode*, reg);\n    g_assert(node != NULL);\n  }\n\n  for(i = 1; node->parent != NULL && i < distance; i++, node = node->parent);\n  return &node->sched_info;\n}", "item_id": 9, "repo": "gcracker/parameter-toolkit", "file": "adamant/adamant_optimize.h", "last_update_at": "2022-03-30T06:58:55+00:00", "question_id": "288e1e0afdae3d99c95df37a36059f596509f395_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline SchedInfo*\nadamant_IVE_read(AdamantRuntime *runtime, guint reg, guint distance)\n{\n  /* The basic idea here is to follow the dependence chain for reg\n     back runtime->config->opti.unroll_factor many links.  That node\n     will act as our input dependence rather than the tail of the\n     dependence chain (since all intervening nodes could be folded). */\n  AdamantIVENode *node;\n  guint i;\n  if(reg > runtime->opti->induction_vars->len)\n    adamant_IVE_reset(runtime, reg, 0, 0, 0);\n  g_assert(reg < runtime->opti->induction_vars->len);\n  node = g_array_index(runtime->opti->induction_vars, AdamantIVENode*, reg);\n  if(node == NULL) {\n    adamant_IVE_reset(runtime, reg, 0, 0, 0);\n    node = g_array_index(runtime->opti->induction_vars, AdamantIVENode*, reg);\n    g_assert(node != NULL);\n  }\n  for(i = 1; node->parent != NULL && i < distance; i++, node = node->parent);\n  return &node->sched_info;\n"]]}
{"hexsha": "a246d4d64b8b0c2f58c06b5fbe0b67c50314c015", "ext": "c", "lang": "C", "content": "static int mt9v022_s_mbus_config(struct v4l2_subdev *sd,\n\t\t\t\t const struct v4l2_mbus_config *cfg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\n\tstruct mt9v022 *mt9v022 = to_mt9v022(client);\n\tunsigned long flags = soc_camera_apply_board_flags(ssdd, cfg);\n\tunsigned int bps = soc_mbus_get_fmtdesc(mt9v022->fmt->code)->bits_per_sample;\n\tint ret;\n\tu16 pixclk = 0;\n\n\tif (ssdd->set_bus_param) {\n\t\tret = ssdd->set_bus_param(ssdd, 1 << (bps - 1));\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (bps != 10) {\n\t\t/*\n\t\t * Without board specific bus width settings we only support the\n\t\t * sensors native bus width\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\n\t\tpixclk |= 0x10;\n\n\tif (!(flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH))\n\t\tpixclk |= 0x1;\n\n\tif (!(flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH))\n\t\tpixclk |= 0x2;\n\n\tret = reg_write(client, mt9v022->reg->pixclk_fv_lv, pixclk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(flags & V4L2_MBUS_MASTER))\n\t\tmt9v022->chip_control &= ~0x8;\n\n\tret = reg_write(client, MT9V022_CHIP_CONTROL, mt9v022->chip_control);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(&client->dev, \"Calculated pixclk 0x%x, chip control 0x%x\\n\",\n\t\tpixclk, mt9v022->chip_control);\n\n\treturn 0;\n}", "item_id": 20, "repo": "bradchesney79/illacceptanything", "file": "linux/drivers/media/i2c/soc_camera/mt9v022.c", "last_update_at": "2022-02-21T07:09:11+00:00", "question_id": "a246d4d64b8b0c2f58c06b5fbe0b67c50314c015_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int mt9v022_s_mbus_config(struct v4l2_subdev *sd,\n\t\t\t\t const struct v4l2_mbus_config *cfg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\n\tstruct mt9v022 *mt9v022 = to_mt9v022(client);\n\tunsigned long flags = soc_camera_apply_board_flags(ssdd, cfg);\n\tunsigned int bps = soc_mbus_get_fmtdesc(mt9v022->fmt->code)->bits_per_sample;\n\tint ret;\n\tu16 pixclk = 0;\n\tif (ssdd->set_bus_param) {\n\t\tret = ssdd->set_bus_param(ssdd, 1 << (bps - 1));\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (bps != 10) {\n\t\t/*\n\t\t * Without board specific bus width settings we only support the\n\t\t * sensors native bus width\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\tif (flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\n\t\tpixclk |= 0x10;\n\tif (!(flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH))\n\t\tpixclk |= 0x1;\n\tif (!(flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH))\n\t\tpixclk |= 0x2;\n\tret = reg_write(client, mt9v022->reg->pixclk_fv_lv, pixclk);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!(flags & V4L2_MBUS_MASTER))\n\t\tmt9v022->chip_control &= ~0x8;\n\tret = reg_write(client, MT9V022_CHIP_CONTROL, mt9v022->chip_control);\n\tif (ret < 0)\n\t\treturn ret;\n\tdev_dbg(&client->dev, \"Calculated pixclk 0x%x, chip control 0x%x\\n\",\n\t\tpixclk, mt9v022->chip_control);\n\treturn 0;\n"]]}
{"hexsha": "12efbf5c1165cfa12162c496a35b49392e0dfb2a", "ext": "c", "lang": "C", "content": "double mc_update(double delta_theta_m_star, double delta_theta_m, double Ts)\n{\n    // Run through motion controller block diagram\n    double delta_theta_m_error = delta_theta_m_star - delta_theta_m;\n    delta_theta_m_error_acc += delta_theta_m_error;\n    delta_theta_m_error_acc_acc += delta_theta_m_error_acc;\n\n    // Calculate commanded torque\n    double term1 = (Ba / Ts * delta_theta_m_error);\n    double term2 = (Ksa * delta_theta_m_error_acc);\n    double term3 = (Kisa * Ts * delta_theta_m_error_acc_acc);\n    double Tem_SFB_star = term1 + term2 + term3;\n\n    return Tem_SFB_star;\n}", "item_id": 0, "repo": "Severson-Group/AMDC-Firmware", "file": "sdk/bare/user/usr/beta_labs/mc.c", "last_update_at": "2022-03-09T18:38:49+00:00", "question_id": "12efbf5c1165cfa12162c496a35b49392e0dfb2a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["double mc_update(double delta_theta_m_star, double delta_theta_m, double Ts)\n{\n    // Run through motion controller block diagram\n    double delta_theta_m_error = delta_theta_m_star - delta_theta_m;\n    delta_theta_m_error_acc += delta_theta_m_error;\n    delta_theta_m_error_acc_acc += delta_theta_m_error_acc;\n    // Calculate commanded torque\n    double term1 = (Ba / Ts * delta_theta_m_error);\n    double term2 = (Ksa * delta_theta_m_error_acc);\n    double term3 = (Kisa * Ts * delta_theta_m_error_acc_acc);\n    double Tem_SFB_star = term1 + term2 + term3;\n    return Tem_SFB_star;\n"]]}
