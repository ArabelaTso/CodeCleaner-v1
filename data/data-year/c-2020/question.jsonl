{"hexsha": "04faca3221deae50eff4f90baadba00709ed95aa", "ext": "c", "lang": "C", "content": "static void get_passphrase(char *passphrase, int len)\n{\n\tchar *p;\n\tstruct termios current_settings;\n\n\tassert(len > 0);\n\tdisable_echo(&current_settings);\n\tp = fgets(passphrase, len, stdin);\n\ttcsetattr(0, TCSANOW, &current_settings);\n\tprintf(\"\\n\");\n\tif (!p) {\n\t\tprintf(\"Aborting.\\n\");\n\t\texit(1);\n\t}\n\tp = strrchr(passphrase, '\\n');\n\tif (!p)\n\t\tp = passphrase + len - 1;\n\t*p = '\\0';\n}", "item_id": 11, "repo": "afeng11/tomato-arm", "file": "release/src-rt-6.x.4708/router/e2fsprogs/misc/e4crypt.c", "last_update_at": "2020-05-24T07:23:26+00:00", "question_id": "04faca3221deae50eff4f90baadba00709ed95aa_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void get_passphrase(char *passphrase, int len)\n{\n\tchar *p;\n\tstruct termios current_settings;\n\tassert(len > 0);\n\tdisable_echo(&current_settings);\n\tp = fgets(passphrase, len, stdin);\n\ttcsetattr(0, TCSANOW, &current_settings);\n\tprintf(\"\\n\");\n\tif (!p) {\n\t\tprintf(\"Aborting.\\n\");\n\t\texit(1);\n\t}\n\tp = strrchr(passphrase, '\\n');\n\tif (!p)\n\t\tp = passphrase + len - 1;\n\t*p = '\\0';\n"]]}
{"hexsha": "c18adaba347eff15cd60d9dbdf6a823c47827fd4", "ext": "c", "lang": "C", "content": "static int\nhme_get_oldvpd_props(dev_info_t *dip, int vpd_base)\n{\n\tstruct hme *hmep;\n\tint vpd_start, vpd_len, kw_start, kw_len, kw_ptr;\n\tchar kw_namestr[3];\n\tchar kw_fieldstr[256];\n\tint i;\n\n\thmep = ddi_get_driver_private(dip);\n\n\tvpd_start = vpd_base;\n\n\tif ((GET_ROM8(&hmep->hme_romp[vpd_start]) & 0xff) != 0x90) {\n\t\treturn (1); /* error */\n\t} else {\n\t\tvpd_len = 9;\n\t}\n\n\t/* Get local-mac-address */\n\tkw_start = vpd_start + 3; /* Location of 1st keyword */\n\tkw_ptr = kw_start;\n\twhile ((kw_ptr - kw_start) < vpd_len) { /* Get all keywords */\n\t\tkw_namestr[0] = GET_ROM8(&hmep->hme_romp[kw_ptr]);\n\t\tkw_namestr[1] = GET_ROM8(&hmep->hme_romp[kw_ptr+1]);\n\t\tkw_namestr[2] = '\\0';\n\t\tkw_len = (int)(GET_ROM8(&hmep->hme_romp[kw_ptr+2]) & 0xff);\n\t\tfor (i = 0, kw_ptr += 3; i < kw_len; i++)\n\t\t\tkw_fieldstr[i] = GET_ROM8(&hmep->hme_romp[kw_ptr+i]);\n\t\tkw_fieldstr[i] = '\\0';\n\t\tif (hme_create_prop_from_kw(dip, kw_namestr, kw_fieldstr)) {\n\t\t\treturn (DDI_FAILURE);\n\t\t}\n\t\tkw_ptr += kw_len;\n\t} /* next keyword */\n\n\tif (ddi_prop_create(DDI_DEV_T_NONE, dip, DDI_PROP_CANSLEEP, \"model\",\n\t    \"SUNW,cheerio\", strlen(\"SUNW,cheerio\")+1) != DDI_SUCCESS) {\n\t\treturn (DDI_FAILURE);\n\t}\n\treturn (0);\n}", "item_id": 11, "repo": "AsahiOS/gate", "file": "usr/src/uts/common/io/hme/hme.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "c18adaba347eff15cd60d9dbdf6a823c47827fd4_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nhme_get_oldvpd_props(dev_info_t *dip, int vpd_base)\n{\n\tstruct hme *hmep;\n\tint vpd_start, vpd_len, kw_start, kw_len, kw_ptr;\n\tchar kw_namestr[3];\n\tchar kw_fieldstr[256];\n\tint i;\n\thmep = ddi_get_driver_private(dip);\n\tvpd_start = vpd_base;\n\tif ((GET_ROM8(&hmep->hme_romp[vpd_start]) & 0xff) != 0x90) {\n\t\treturn (1); /* error */\n\t} else {\n\t\tvpd_len = 9;\n\t}\n\t/* Get local-mac-address */\n\tkw_start = vpd_start + 3; /* Location of 1st keyword */\n\tkw_ptr = kw_start;\n\twhile ((kw_ptr - kw_start) < vpd_len) { /* Get all keywords */\n\t\tkw_namestr[0] = GET_ROM8(&hmep->hme_romp[kw_ptr]);\n\t\tkw_namestr[1] = GET_ROM8(&hmep->hme_romp[kw_ptr+1]);\n\t\tkw_namestr[2] = '\\0';\n\t\tkw_len = (int)(GET_ROM8(&hmep->hme_romp[kw_ptr+2]) & 0xff);\n\t\tfor (i = 0, kw_ptr += 3; i < kw_len; i++)\n\t\t\tkw_fieldstr[i] = GET_ROM8(&hmep->hme_romp[kw_ptr+i]);\n\t\tkw_fieldstr[i] = '\\0';\n\t\tif (hme_create_prop_from_kw(dip, kw_namestr, kw_fieldstr)) {\n\t\t\treturn (DDI_FAILURE);\n\t\t}\n\t\tkw_ptr += kw_len;\n\t} /* next keyword */\n\tif (ddi_prop_create(DDI_DEV_T_NONE, dip, DDI_PROP_CANSLEEP, \"model\",\n\t    \"SUNW,cheerio\", strlen(\"SUNW,cheerio\")+1) != DDI_SUCCESS) {\n\t\treturn (DDI_FAILURE);\n\t}\n\treturn (0);\n"]]}
{"hexsha": "d410b604d44f4612a87d05e26ed7352ca65fbd52", "ext": "c", "lang": "C", "content": "void DeleteCountdownDigits( void )\n{\n    DeleteDigit( &Min1Digit[ 0 ] );\n    DeleteDigit( &Min0Digit[ 0 ] );\n    DeleteSeperatorDigit( &Bit0Digit[ 0 ] );\n    DeleteDigit( &Sec1Digit[ 0 ] );\n    DeleteDigit( &Sec0Digit[ 0 ] );\n    DeleteSeperatorDigit( &Bit1Digit[ 0 ] );\n    DeleteDigit( &Hun1Digit[ 0 ] );\n    DeleteDigit( &Hun0Digit[ 0 ] );\n}", "item_id": 14, "repo": "ForsakenW/forsaken", "file": "ProjectX/screenpolys.c", "last_update_at": "2020-08-09T19:53:26+00:00", "question_id": "d410b604d44f4612a87d05e26ed7352ca65fbd52_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void DeleteCountdownDigits( void )\n{\n    DeleteDigit( &Min1Digit[ 0 ] );\n    DeleteDigit( &Min0Digit[ 0 ] );\n    DeleteSeperatorDigit( &Bit0Digit[ 0 ] );\n    DeleteDigit( &Sec1Digit[ 0 ] );\n    DeleteDigit( &Sec0Digit[ 0 ] );\n    DeleteSeperatorDigit( &Bit1Digit[ 0 ] );\n    DeleteDigit( &Hun1Digit[ 0 ] );\n    DeleteDigit( &Hun0Digit[ 0 ] );\n"]]}
{"hexsha": "ed6731e844c44a158035858eafa2c3674aaa22c1", "ext": "c", "lang": "C", "content": "int ngram_version(unsigned long *version) {\n\tassert(version);\n\tunsigned long options = 0;\n\toptions |= DEBUGGING << 0;\n\t*version = (options << 24) | NGRAM_VERSION;\n\treturn NGRAM_VERSION == 0 ? -1 : 0;\n}", "item_id": 0, "repo": "howerj/ngram", "file": "ngram.c", "last_update_at": "2020-08-28T16:39:34+00:00", "question_id": "ed6731e844c44a158035858eafa2c3674aaa22c1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int ngram_version(unsigned long *version) {\n\tassert(version);\n\tunsigned long options = 0;\n\toptions |= DEBUGGING << 0;\n\t*version = (options << 24) | NGRAM_VERSION;\n\treturn NGRAM_VERSION == 0 ? -1 : 0;\n"]]}
{"hexsha": "d7887cef2c685941b35246436d6ef3aa6893e8ee", "ext": "c", "lang": "C", "content": "int main(int argc, char **argv) {\r\n\tint c, whitespace_flag = 0;\r\n\tsize_t blocklen_min = 4, start = 0, end = -1;\r\n\twhile((c = getopt(argc, argv, \"wi:s:e:a:\")) != -1) switch(c) {\r\n\t\tcase 'w': whitespace_flag = 1; break;\r\n\t\tcase 'i': blocklen_min = atoi(optarg); break;\r\n\t\tcase 's': start = atoi(optarg); break;\r\n\t\tcase 'e': end = atoi(optarg); break;\r\n\t\tcase 'a': atime = atoi(optarg); break;\r\n\t\tdefault: return usage(argv[0]);\r\n\t}\r\n\tif(!argv[optind]) return usage(argv[0]);\r\n\tFILE *f = argv[optind][0] == '-' && !argv[optind][1] ? stdin : fopen(argv[optind], \"r\");\r\n\tif(!f) {\r\n\t\tperror(\"fopen\");\r\n\t\treturn 1;\r\n\t}\r\n\tstdout_is_tty = isatty(fileno(stdout));\r\n\tstruct sortitem { int dupes; int lineno; };\r\n\ttglist(unsigned) hashlist;\r\n\ttglist(char*) strlist;\r\n\ttypedef tglist(struct sortitem) sortitem_list; /* we need a named type to prevent pointer type mismatch warnings */\r\n\thbmap(int, sortitem_list*, 1024) dupes;\r\n\ttglist_init(&hashlist);\r\n\ttglist_init(&strlist);\r\n\thbmap_init(&dupes, intcmp, inthash);\r\n\tchar buf[1024];\r\n\tsize_t i = 0;\r\n\twhile(fgets(buf, sizeof buf, f)) {\r\n\t\t++i;\r\n\t\tif(i - 1 < start) continue;\r\n\t\tif(end != (size_t) -1 && i >= end) break;\r\n\t\tchar *p = buf, *q = strrchr(p, '\\n');\r\n\t\tif(q) *q = 0;\r\n\t\tif(whitespace_flag) while(isspace(*p)) p++;\r\n\t\tunsigned hash = string_hash(p);\r\n\t\ttglist_add(&hashlist, hash);\r\n\t\ttglist_add(&strlist, strdup(p));\r\n\t\tassert(tglist_getsize(&strlist) == i - start);\r\n\t\tassert(tglist_getsize(&strlist) == tglist_getsize(&hashlist));\r\n\t\tassert(!strcmp(p, tglist_get(&strlist, i-start-1)));\r\n\t}\r\n\tsize_t linecount = tglist_getsize(&hashlist);\r\n\tsize_t bl;\r\n\tnl = linecount;\r\n\r\n\tif(atime) {\r\n\t\tsignal(SIGALRM, sigh);\r\n\t\talarm(atime);\r\n\t}\r\n\r\n\t//for(bl = blocklen_max; bl >= blocklen_min; bl--) {\r\n\tfor(bl = blocklen_min; bl < blocklen_min+1; bl++) {\r\n\t\tfor(i = 0; i < linecount; ) {\r\n\t\t\thbmap_iter hi;\r\n\t\t\tint dupe_count = 0, longest_dupe = 0;\r\n\t\t\tsize_t j, h, last_dupe = 0;\r\n\t\t\tfor(j = i + bl; j + bl < linecount; ) {\r\n#define HL(X) tglist_get(&hashlist, X)\r\n#define SL(X) tglist_get(&strlist, X)\r\n\t\t\t\tfor(h = 0; h < bl; ++h) {\r\n\t\t\t\t\tif(!line_equal(HL(i+h), SL(i+h), HL(j+h), SL(j+h)))\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif(h == bl) {\r\n\t\t\t\t\t/* look if the dupe is actually longer */\r\n\t\t\t\t\twhile(j+h < linecount && i+h < j && line_equal(HL(i+h), SL(i+h), HL(j+h), SL(j+h)))\r\n\t\t\t\t\t\th++;\r\n\t\t\t\t\tsortitem_list* dlist = 0;\r\n\t\t\t\t\thi = hbmap_find(&dupes, i);\r\n\r\n\t\t\t\t\tif(hi == (hbmap_iter) -1)\r\n\t\t\t\t\t\tdlist = tglist_new();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tdlist = hbmap_getval(&dupes, hi);\r\n\r\n\t\t\t\t\tstruct sortitem tmp = {.dupes = h, .lineno = j};\r\n\t\t\t\t\ttglist_insert_sorted(dlist, tmp, sortitem_cmp);\r\n\r\n\t\t\t\t\tif(hi == (hbmap_iter) -1)\r\n\t\t\t\t\t\thbmap_insert(&dupes, i, dlist);\r\n\r\n\t\t\t\t\tlast_dupe = j;\r\n\t\t\t\t\tif(h > longest_dupe) longest_dupe = h;\r\n\t\t\t\t\t++dupe_count;\r\n\r\n\t\t\t\t}\r\n\t\t\t\tj+= h ? h : 1;\r\n\t\t\t}\r\n\t\t\ti += dupe_count ? longest_dupe : 1;\r\n\t\t\tcl = i;\r\n\t\t}\r\n\t}\r\n\thbmap_iter hi;\r\n\tsortitem_list si_list;\r\n\ttglist_init(&si_list);\r\n\thbmap_foreach(&dupes, hi) {\r\n\t\tint longest = 0;\r\n\t\tsortitem_list*dlist = hbmap_getval(&dupes, hi);\r\n\t\ttglist_foreach(dlist, i) {\r\n\t\t\tstruct sortitem *si = &tglist_get(dlist, i);\r\n\t\t\tif(si->dupes > longest) longest = si->dupes;\r\n\t\t}\r\n\t\tassert(longest == tglist_get(dlist, 0).dupes);\r\n\t\tstruct sortitem si = {.dupes = longest, .lineno = hbmap_getkey(&dupes, hi)};\r\n\t\ttglist_insert_sorted(&si_list, si, sortitem_cmp);\r\n\t}\r\n\tfor(i = 0; i < tglist_getsize(&si_list); i++) {\r\n\t\tstruct sortitem *si = &tglist_get(&si_list, i);\r\n\t\thi = hbmap_find(&dupes, si->lineno);\r\n\t\tsortitem_list *dlist = hbmap_getval(&dupes, hi);\r\n\t\tint j, cnt = 0;\r\n\t\ttglist_foreach(dlist, j) {\r\n\t\t\tif(tglist_get(dlist, j).dupes < si->dupes) break;\r\n\t\t\t++cnt;\r\n\t\t}\r\n\t\tif(neednl && stdout_is_tty) {\r\n\t\t\tdprintf(2, \"\\n\");\r\n\t\t\tneednl = 0;\r\n\t\t}\r\n\t\tprintf(\"[DUP] %d lines at %d: %d dupes (\", si->dupes, (int) start + si->lineno, cnt);\r\n\t\tfor(j = 0; j < cnt; ++j)\r\n\t\t\tprintf(\"%d%s\", (int) start + tglist_get(dlist, j).lineno, j == cnt -1 ? \")\\n\" : \", \");\r\n\t\tfor(j = 0; j < si->dupes; j++)\r\n\t\t\tprintf(\"%s\\n\", tglist_get(&strlist, si->lineno+j));\r\n\t}\r\n\tif(f != stdin) fclose(f);\r\n\tif(neednl) dprintf(2, \"\\n\");\r\n\treturn 0;\r\n}", "item_id": 4, "repo": "M1ndo/C_Debugger_Lib", "file": "lib/examples/codedup.c", "last_update_at": "2020-04-06T04:26:51+00:00", "question_id": "d7887cef2c685941b35246436d6ef3aa6893e8ee_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char **argv) {\r\n\tint c, whitespace_flag = 0;\r\n\tsize_t blocklen_min = 4, start = 0, end = -1;\r\n\twhile((c = getopt(argc, argv, \"wi:s:e:a:\")) != -1) switch(c) {\r\n\t\tcase 'w': whitespace_flag = 1; break;\r\n\t\tcase 'i': blocklen_min = atoi(optarg); break;\r\n\t\tcase 's': start = atoi(optarg); break;\r\n\t\tcase 'e': end = atoi(optarg); break;\r\n\t\tcase 'a': atime = atoi(optarg); break;\r\n\t\tdefault: return usage(argv[0]);\r\n\t}\r\n\tif(!argv[optind]) return usage(argv[0]);\r\n\tFILE *f = argv[optind][0] == '-' && !argv[optind][1] ? stdin : fopen(argv[optind], \"r\");\r\n\tif(!f) {\r\n\t\tperror(\"fopen\");\r\n\t\treturn 1;\r\n\t}\r\n\tstdout_is_tty = isatty(fileno(stdout));\r\n\tstruct sortitem { int dupes; int lineno; };\r\n\ttglist(unsigned) hashlist;\r\n\ttglist(char*) strlist;\r\n\ttypedef tglist(struct sortitem) sortitem_list; /* we need a named type to prevent pointer type mismatch warnings */\r\n\thbmap(int, sortitem_list*, 1024) dupes;\r\n\ttglist_init(&hashlist);\r\n\ttglist_init(&strlist);\r\n\thbmap_init(&dupes, intcmp, inthash);\r\n\tchar buf[1024];\r\n\tsize_t i = 0;\r\n\twhile(fgets(buf, sizeof buf, f)) {\r\n\t\t++i;\r\n\t\tif(i - 1 < start) continue;\r\n\t\tif(end != (size_t) -1 && i >= end) break;\r\n\t\tchar *p = buf, *q = strrchr(p, '\\n');\r\n\t\tif(q) *q = 0;\r\n\t\tif(whitespace_flag) while(isspace(*p)) p++;\r\n\t\tunsigned hash = string_hash(p);\r\n\t\ttglist_add(&hashlist, hash);\r\n\t\ttglist_add(&strlist, strdup(p));\r\n\t\tassert(tglist_getsize(&strlist) == i - start);\r\n\t\tassert(tglist_getsize(&strlist) == tglist_getsize(&hashlist));\r\n\t\tassert(!strcmp(p, tglist_get(&strlist, i-start-1)));\r\n\t}\r\n\tsize_t linecount = tglist_getsize(&hashlist);\r\n\tsize_t bl;\r\n\tnl = linecount;\r\n\r\n\tif(atime) {\r\n\t\tsignal(SIGALRM, sigh);\r\n\t\talarm(atime);\r\n\t}\r\n\r\n\t//for(bl = blocklen_max; bl >= blocklen_min; bl--) {\r\n\tfor(bl = blocklen_min; bl < blocklen_min+1; bl++) {\r\n\t\tfor(i = 0; i < linecount; ) {\r\n\t\t\thbmap_iter hi;\r\n\t\t\tint dupe_count = 0, longest_dupe = 0;\r\n\t\t\tsize_t j, h, last_dupe = 0;\r\n\t\t\tfor(j = i + bl; j + bl < linecount; ) {\r\n#define HL(X) tglist_get(&hashlist, X)\r\n#define SL(X) tglist_get(&strlist, X)\r\n\t\t\t\tfor(h = 0; h < bl; ++h) {\r\n\t\t\t\t\tif(!line_equal(HL(i+h), SL(i+h), HL(j+h), SL(j+h)))\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif(h == bl) {\r\n\t\t\t\t\t/* look if the dupe is actually longer */\r\n\t\t\t\t\twhile(j+h < linecount && i+h < j && line_equal(HL(i+h), SL(i+h), HL(j+h), SL(j+h)))\r\n\t\t\t\t\t\th++;\r\n\t\t\t\t\tsortitem_list* dlist = 0;\r\n\t\t\t\t\thi = hbmap_find(&dupes, i);\r\n\r\n\t\t\t\t\tif(hi == (hbmap_iter) -1)\r\n\t\t\t\t\t\tdlist = tglist_new();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tdlist = hbmap_getval(&dupes, hi);\r\n\r\n\t\t\t\t\tstruct sortitem tmp = {.dupes = h, .lineno = j};\r\n\t\t\t\t\ttglist_insert_sorted(dlist, tmp, sortitem_cmp);\r\n\r\n\t\t\t\t\tif(hi == (hbmap_iter) -1)\r\n\t\t\t\t\t\thbmap_insert(&dupes, i, dlist);\r\n\r\n\t\t\t\t\tlast_dupe = j;\r\n\t\t\t\t\tif(h > longest_dupe) longest_dupe = h;\r\n\t\t\t\t\t++dupe_count;\r\n\r\n\t\t\t\t}\r\n\t\t\t\tj+= h ? h : 1;\r\n\t\t\t}\r\n\t\t\ti += dupe_count ? longest_dupe : 1;\r\n\t\t\tcl = i;\r\n\t\t}\r\n\t}\r\n\thbmap_iter hi;\r\n\tsortitem_list si_list;\r\n\ttglist_init(&si_list);\r\n\thbmap_foreach(&dupes, hi) {\r\n\t\tint longest = 0;\r\n\t\tsortitem_list*dlist = hbmap_getval(&dupes, hi);\r\n\t\ttglist_foreach(dlist, i) {\r\n\t\t\tstruct sortitem *si = &tglist_get(dlist, i);\r\n\t\t\tif(si->dupes > longest) longest = si->dupes;\r\n\t\t}\r\n\t\tassert(longest == tglist_get(dlist, 0).dupes);\r\n\t\tstruct sortitem si = {.dupes = longest, .lineno = hbmap_getkey(&dupes, hi)};\r\n\t\ttglist_insert_sorted(&si_list, si, sortitem_cmp);\r\n\t}\r\n\tfor(i = 0; i < tglist_getsize(&si_list); i++) {\r\n\t\tstruct sortitem *si = &tglist_get(&si_list, i);\r\n\t\thi = hbmap_find(&dupes, si->lineno);\r\n\t\tsortitem_list *dlist = hbmap_getval(&dupes, hi);\r\n\t\tint j, cnt = 0;\r\n\t\ttglist_foreach(dlist, j) {\r\n\t\t\tif(tglist_get(dlist, j).dupes < si->dupes) break;\r\n\t\t\t++cnt;\r\n\t\t}\r\n\t\tif(neednl && stdout_is_tty) {\r\n\t\t\tdprintf(2, \"\\n\");\r\n\t\t\tneednl = 0;\r\n\t\t}\r\n\t\tprintf(\"[DUP] %d lines at %d: %d dupes (\", si->dupes, (int) start + si->lineno, cnt);\r\n\t\tfor(j = 0; j < cnt; ++j)\r\n\t\t\tprintf(\"%d%s\", (int) start + tglist_get(dlist, j).lineno, j == cnt -1 ? \")\\n\" : \", \");\r\n\t\tfor(j = 0; j < si->dupes; j++)\r\n\t\t\tprintf(\"%s\\n\", tglist_get(&strlist, si->lineno+j));\r\n\t}\r\n\tif(f != stdin) fclose(f);\r\n\tif(neednl) dprintf(2, \"\\n\");\r\n\treturn 0;\r\n"]]}
{"hexsha": "b9e0a264652214a4043b49fcfba34f5fa8fa151d", "ext": "c", "lang": "C", "content": "int main() {\n    float alturas = 0, altmaior = 0, altmenor;\n\n    printf(\"informe sua altura em metros: \\n\");\n    scanf(\"%f\", &alturas);\n    altmaior = alturas;\n    altmenor = alturas;\n\n    for(int i = 0; i < 14; i++) {\n        printf(\"informe sua altura em metros: \\n\");\n        scanf(\"%f\", &alturas);\n \n        if (alturas > altmaior) {\n            altmaior = alturas;\n        } else if (alturas < altmenor) {\n            altmenor = alturas;\n        }\n\n    }\n\n    printf(\"\\nmaior altura: %.2f\", altmaior);\n    printf(\"\\nmenor altura: %.2f\", altmenor);\n\n    return 0;\n}", "item_id": 0, "repo": "danielxsr/atividade_C_30112020", "file": "item_2/questoes/questao_09.c", "last_update_at": "2020-11-30T21:36:24+00:00", "question_id": "b9e0a264652214a4043b49fcfba34f5fa8fa151d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main() {\n    float alturas = 0, altmaior = 0, altmenor;\n    printf(\"informe sua altura em metros: \\n\");\n    scanf(\"%f\", &alturas);\n    altmaior = alturas;\n    altmenor = alturas;\n    for(int i = 0; i < 14; i++) {\n        printf(\"informe sua altura em metros: \\n\");\n        scanf(\"%f\", &alturas);\n        if (alturas > altmaior) {\n            altmaior = alturas;\n        } else if (alturas < altmenor) {\n            altmenor = alturas;\n        }\n    }\n    printf(\"\\nmaior altura: %.2f\", altmaior);\n    printf(\"\\nmenor altura: %.2f\", altmenor);\n    return 0;\n"]]}
{"hexsha": "9a86d84be1c9dbf9ce396b6cbead3ec86654727c", "ext": "c", "lang": "C", "content": "static bool enter_wizard_mode(void)\n{\n    /* Ask first time - unless resurrecting a dead character */\n    if (!(p_ptr->noscore & 0x0008) && !p_ptr->is_dead)\n    {\n        /* Explanation */\n        msg_print(\"You can only enter wizard mode from within debug mode.\");\n\n        return (FALSE);\n    }\n\n    /* Mark savefile */\n    p_ptr->noscore |= 0x0002;\n\n    /* Success */\n    return (TRUE);\n}", "item_id": 12, "repo": "MT-Arnoldussen/sil-q", "file": "src/dungeon.c", "last_update_at": "2020-11-07T12:43:58+00:00", "question_id": "9a86d84be1c9dbf9ce396b6cbead3ec86654727c_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static bool enter_wizard_mode(void)\n{\n    /* Ask first time - unless resurrecting a dead character */\n    if (!(p_ptr->noscore & 0x0008) && !p_ptr->is_dead)\n    {\n        /* Explanation */\n        msg_print(\"You can only enter wizard mode from within debug mode.\");\n        return (FALSE);\n    }\n    /* Mark savefile */\n    p_ptr->noscore |= 0x0002;\n    /* Success */\n    return (TRUE);\n"]]}
{"hexsha": "34c13a14e3fccfcddb037c0a96cc0b03cbdb9ca4", "ext": "c", "lang": "C", "content": "void smIPT_nS3(SmInitialPseudoTest* const me)\n{\n  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;\n  CMOCK_smIPT_nS3_CALL_INSTANCE* cmock_call_instance;\n  UNITY_SET_DETAIL(CMockString_smIPT_nS3);\n  cmock_call_instance = (CMOCK_smIPT_nS3_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.smIPT_nS3_CallInstance);\n  Mock.smIPT_nS3_CallInstance = CMock_Guts_MemNext(Mock.smIPT_nS3_CallInstance);\n  if (Mock.smIPT_nS3_IgnoreBool)\n  {\n    UNITY_CLR_DETAILS();\n    return;\n  }\n  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);\n  cmock_line = cmock_call_instance->LineNumber;\n  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)\n    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);\n  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)\n    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);\n  if (!cmock_call_instance->IgnoreArg_me)\n  {\n    UNITY_SET_DETAILS(CMockString_smIPT_nS3,CMockString_me);\n    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_me, me, cmock_line, CMockStringMismatch);\n  }\n  if (Mock.smIPT_nS3_CallbackFunctionPointer != NULL)\n  {\n    Mock.smIPT_nS3_CallbackFunctionPointer(me, Mock.smIPT_nS3_CallbackCalls++);\n  }\n  UNITY_CLR_DETAILS();\n}", "item_id": 43, "repo": "sporaio/spora-firmware", "file": "third-party/rkh/source/sm/test/stub/mocks/Mock_smInitialPseudoTestAct.c", "last_update_at": "2020-08-13T13:28:28+00:00", "question_id": "34c13a14e3fccfcddb037c0a96cc0b03cbdb9ca4_43", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void smIPT_nS3(SmInitialPseudoTest* const me)\n{\n  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;\n  CMOCK_smIPT_nS3_CALL_INSTANCE* cmock_call_instance;\n  UNITY_SET_DETAIL(CMockString_smIPT_nS3);\n  cmock_call_instance = (CMOCK_smIPT_nS3_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.smIPT_nS3_CallInstance);\n  Mock.smIPT_nS3_CallInstance = CMock_Guts_MemNext(Mock.smIPT_nS3_CallInstance);\n  if (Mock.smIPT_nS3_IgnoreBool)\n  {\n    UNITY_CLR_DETAILS();\n    return;\n  }\n  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);\n  cmock_line = cmock_call_instance->LineNumber;\n  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)\n    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);\n  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)\n    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);\n  if (!cmock_call_instance->IgnoreArg_me)\n  {\n    UNITY_SET_DETAILS(CMockString_smIPT_nS3,CMockString_me);\n    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_me, me, cmock_line, CMockStringMismatch);\n  }\n  if (Mock.smIPT_nS3_CallbackFunctionPointer != NULL)\n  {\n    Mock.smIPT_nS3_CallbackFunctionPointer(me, Mock.smIPT_nS3_CallbackCalls++);\n  }\n  UNITY_CLR_DETAILS();\n"]]}
{"hexsha": "30480f7d6b71d9ce9c0c7cca3186590550a7bfea", "ext": "c", "lang": "C", "content": "static void atmel_get_mib(struct atmel_private *priv, u8 type, u8 index,\n\t\t\t  u8 *data, int data_len)\n{\n\tstruct get_set_mib m;\n\tm.type = type;\n\tm.size = data_len;\n\tm.index = index;\n\n\tif (data_len > MIB_MAX_DATA_BYTES)\n\t\tprintk(KERN_ALERT \"%s: MIB buffer too small.\\n\", priv->dev->name);\n\n\tatmel_send_command_wait(priv, CMD_Get_MIB_Vars, &m, MIB_HEADER_SIZE + data_len);\n\tatmel_copy_to_host(priv->dev, data,\n\t\t\t   atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET + MIB_HEADER_SIZE), data_len);\n}", "item_id": 75, "repo": "afeng11/tomato-arm", "file": "release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/net/wireless/atmel.c", "last_update_at": "2020-05-24T07:23:26+00:00", "question_id": "30480f7d6b71d9ce9c0c7cca3186590550a7bfea_75", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void atmel_get_mib(struct atmel_private *priv, u8 type, u8 index,\n\t\t\t  u8 *data, int data_len)\n{\n\tstruct get_set_mib m;\n\tm.type = type;\n\tm.size = data_len;\n\tm.index = index;\n\tif (data_len > MIB_MAX_DATA_BYTES)\n\t\tprintk(KERN_ALERT \"%s: MIB buffer too small.\\n\", priv->dev->name);\n\tatmel_send_command_wait(priv, CMD_Get_MIB_Vars, &m, MIB_HEADER_SIZE + data_len);\n\tatmel_copy_to_host(priv->dev, data,\n\t\t\t   atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET + MIB_HEADER_SIZE), data_len);\n"]]}
{"hexsha": "eb55c2933692a1c28ed44679a2e7842474f0a34c", "ext": "c", "lang": "C", "content": "void cgetsizes_(MPI_Fint * ptrSize, MPI_Fint * intSize, MPI_Fint * aintSize)\n{\n    *ptrSize = (MPI_Fint) sizeof(void *);\n    *intSize = (MPI_Fint) sizeof(MPI_Fint);\n    *aintSize = (MPI_Fint) sizeof(MPI_Aint);\n}", "item_id": 1, "repo": "ucd-plse/mpi-error-prop", "file": "mpich-3.3/test/mpi/f90/attr/attrlangc.c", "last_update_at": "2020-07-17T04:14:25+00:00", "question_id": "eb55c2933692a1c28ed44679a2e7842474f0a34c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void cgetsizes_(MPI_Fint * ptrSize, MPI_Fint * intSize, MPI_Fint * aintSize)\n{\n    *ptrSize = (MPI_Fint) sizeof(void *);\n    *intSize = (MPI_Fint) sizeof(MPI_Fint);\n    *aintSize = (MPI_Fint) sizeof(MPI_Aint);\n"]]}
{"hexsha": "139ee5b227db92fe081f4338bd04a690fb7c8b81", "ext": "c", "lang": "C", "content": "int _net_release_client_context(net_client_cont_t *client) {\n  memset(&client->server_addr, 0, sizeof(client->server_addr));\n\n  /* TODO(valery): Implement safe free function */\n  free(client);\n\n  return NET_OK;\n}", "item_id": 0, "repo": "ivaleryz/rpc-in-c", "file": "src/network/src/network/_release_client_context.c", "last_update_at": "2020-12-29T08:30:23+00:00", "question_id": "139ee5b227db92fe081f4338bd04a690fb7c8b81_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int _net_release_client_context(net_client_cont_t *client) {\n  memset(&client->server_addr, 0, sizeof(client->server_addr));\n  /* TODO(valery): Implement safe free function */\n  free(client);\n  return NET_OK;\n"]]}
{"hexsha": "b9ca93b7c8eb05ec4998809e45317f426e69eb4b", "ext": "h", "lang": "C", "content": "cbuffer InternalPerMaterialCB : register(b12)\n{\n    MaterialData gMaterial;\n    MaterialData gTemporalMaterial;\n    float gTemporalLODThreshold;\n    bool gEnableTemporalNormalMaps;\n    bool gDebugTemporalMaterial;\n}", "item_id": 4, "repo": "tfoleyNV/Falcor-old", "file": "Framework/Source/Data/ShaderCommon.h", "last_update_at": "2020-03-24T18:16:27+00:00", "question_id": "b9ca93b7c8eb05ec4998809e45317f426e69eb4b_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["cbuffer InternalPerMaterialCB : register(b12)\n{\n    MaterialData gMaterial;\n    MaterialData gTemporalMaterial;\n    float gTemporalLODThreshold;\n    bool gEnableTemporalNormalMaps;\n    bool gDebugTemporalMaterial;\n"]]}
{"hexsha": "313e4b53faf172ec451a88fe90249707ccad0de2", "ext": "c", "lang": "C", "content": "i32_t kernel_color_print(char *str, u8_t color){\n\t/*\n\t *\u4e00\u56de\u30af\u30ea\u30a2\n\t */\n\tboxfill8(binfo->vram, binfo->scrnx, BLACK,\n\t\t   length << 3, input_y + (indent << 4), (length << 3)+(strlen(str) << 3), (input_y + (indent << 4)+16));\n\n\t/*\n\t *\u5b9f\u969b\u306b\u8868\u793a\u3059\u308b\n\t */\n\tputfonts8_asc(binfo->vram, binfo->scrnx, length << 3, input_y + (indent << 4), color, str);\n\n\tlength += strlen(str);\n\n\treturn 1;\n}", "item_id": 2, "repo": "Anne1231/yurios", "file": "lib/yuri/display.c", "last_update_at": "2020-10-20T10:44:29+00:00", "question_id": "313e4b53faf172ec451a88fe90249707ccad0de2_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["i32_t kernel_color_print(char *str, u8_t color){\n\t/*\n\t *\u4e00\u56de\u30af\u30ea\u30a2\n\t */\n\tboxfill8(binfo->vram, binfo->scrnx, BLACK,\n\t\t   length << 3, input_y + (indent << 4), (length << 3)+(strlen(str) << 3), (input_y + (indent << 4)+16));\n\t/*\n\t *\u5b9f\u969b\u306b\u8868\u793a\u3059\u308b\n\t */\n\tputfonts8_asc(binfo->vram, binfo->scrnx, length << 3, input_y + (indent << 4), color, str);\n\tlength += strlen(str);\n\treturn 1;\n"]]}
{"hexsha": "3c39e2b8b54758a414f470b4eda4ba423ce4dea6", "ext": "c", "lang": "C", "content": "static int\nadd_uuid(char *keyname, TSS_UUID *uu)\n{\n\tFILE *fp = NULL;\n\tchar fname[MAXPATHLEN];\n\tchar idstr[BUFSIZ];\n\tuuid_t uuid;\n\tchar *p = get_tpm_keystore_path();\n\n\tif (p == NULL)\n\t\treturn (-1);\n\n\ttss_uuid_convert_from(uu, uuid);\n\n\tif (uuid_is_null(uuid))\n\t\treturn (-1);\n\n\tuuid_unparse(uuid, idstr);\n\n\t(void) snprintf(fname, sizeof (fname),\n\t    \"%s/%s\", p, TPMTOK_UUID_INDEX_FILENAME);\n\n\tfp = fopen(fname, \"a\");\n\tif (fp == NULL)\n\t\treturn (-1);\n\n\t(void) fprintf(fp, \"%s %s\\n\", keyname, idstr);\n\t(void) fclose(fp);\n\n\treturn (0);\n}", "item_id": 8, "repo": "AsahiOS/gate", "file": "usr/src/lib/pkcs11/pkcs11_tpm/common/tpm_specific.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "3c39e2b8b54758a414f470b4eda4ba423ce4dea6_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nadd_uuid(char *keyname, TSS_UUID *uu)\n{\n\tFILE *fp = NULL;\n\tchar fname[MAXPATHLEN];\n\tchar idstr[BUFSIZ];\n\tuuid_t uuid;\n\tchar *p = get_tpm_keystore_path();\n\tif (p == NULL)\n\t\treturn (-1);\n\ttss_uuid_convert_from(uu, uuid);\n\tif (uuid_is_null(uuid))\n\t\treturn (-1);\n\tuuid_unparse(uuid, idstr);\n\t(void) snprintf(fname, sizeof (fname),\n\t    \"%s/%s\", p, TPMTOK_UUID_INDEX_FILENAME);\n\tfp = fopen(fname, \"a\");\n\tif (fp == NULL)\n\t\treturn (-1);\n\t(void) fprintf(fp, \"%s %s\\n\", keyname, idstr);\n\t(void) fclose(fp);\n\treturn (0);\n"]]}
{"hexsha": "07d4fb9c283439fa2b0ee9d68d806c373e2ae06c", "ext": "c", "lang": "C", "content": "static  void  NetUDP_TxPktValidate (NET_BUF_HDR       *p_buf_hdr,\n                                    NET_UDP_PORT_NBR   src_port,\n                                    NET_UDP_PORT_NBR   dest_port,\n                                    NET_UDP_FLAGS      flags_udp,\n                                    NET_ERR           *p_err)\n{\n    CPU_INT16U     ix;\n    CPU_INT16U     len;\n    NET_UDP_FLAGS  flag_mask;\n\n\n                                                                /* -------------- VALIDATE NET BUF TYPE --------------- */\n    switch (p_buf_hdr->Type) {\n        case NET_BUF_TYPE_TX_LARGE:\n        case NET_BUF_TYPE_TX_SMALL:\n             break;\n\n\n        case NET_BUF_TYPE_NONE:\n        case NET_BUF_TYPE_BUF:\n        case NET_BUF_TYPE_RX_LARGE:\n        default:\n             NET_CTR_ERR_INC(Net_ErrCtrs.Buf.InvTypeCtr);\n            *p_err = NET_BUF_ERR_INVALID_TYPE;\n             return;\n    }\n\n\n                                                                /* ----------------- VALIDATE PROTOCOL ---------------- */\n    switch (p_buf_hdr->ProtocolHdrType) {\n        case NET_PROTOCOL_TYPE_APP:\n        case NET_PROTOCOL_TYPE_SOCK:\n        case NET_PROTOCOL_TYPE_UDP_V4:\n        case NET_PROTOCOL_TYPE_UDP_V6:\n             ix  = (CPU_INT16U)p_buf_hdr->DataIx;\n             len = (CPU_INT16U)p_buf_hdr->DataLen;\n             break;\n\n\n        case NET_PROTOCOL_TYPE_NONE:\n        default:\n             NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxInvalidProtocolCtr);\n            *p_err = NET_ERR_INVALID_PROTOCOL;\n             return;\n    }\n\n    if (ix == NET_BUF_IX_NONE) {\n        NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxInvalidBufIxCtr);\n       *p_err = NET_BUF_ERR_INVALID_IX;\n        return;\n    }\n\n    if (ix <  NET_UDP_HDR_SIZE) {\n        NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxInvalidBufIxCtr);\n       *p_err = NET_BUF_ERR_INVALID_IX;\n        return;\n    }\n\n\n\n                                                                /* -------------- VALIDATE TOT DATA LEN --------------- */\n    if (len != p_buf_hdr->TotLen) {\n        NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxHdrDataLenCtr);\n       *p_err = NET_UDP_ERR_INVALID_LEN_DATA;\n        return;\n    }\n\n\n\n                                                                /* ---------------- VALIDATE UDP PORTS ---------------- */\n    if (src_port  == NET_UDP_PORT_NBR_RESERVED) {\n        NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxHdrPortSrcCtr);\n       *p_err = NET_UDP_ERR_INVALID_PORT_NBR;\n        return;\n    }\n\n    if (dest_port == NET_UDP_PORT_NBR_RESERVED) {\n        NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxHdrPortDestCtr);\n       *p_err = NET_UDP_ERR_INVALID_PORT_NBR;\n        return;\n    }\n\n\n\n                                                                /* ---------------- VALIDATE UDP FLAGS ---------------- */\n    flag_mask = NET_UDP_FLAG_NONE           |\n                NET_UDP_FLAG_TX_CHK_SUM_DIS |\n                NET_UDP_FLAG_TX_BLOCK;                          /* See Note #2b1.                                       */\n                                                                /* If any invalid flags req'd, rtn err (see Note #2a).  */\n    if ((flags_udp & (NET_UDP_FLAGS)~flag_mask) != NET_UDP_FLAG_NONE) {\n        NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxHdrFlagsCtr);\n       *p_err = NET_UDP_ERR_INVALID_FLAG;\n        return;\n    }\n\n\n   *p_err = NET_UDP_ERR_NONE;\n}", "item_id": 11, "repo": "jcdubois/uC-TCP-IP", "file": "Source/net_udp.c", "last_update_at": "2020-12-08T14:37:08+00:00", "question_id": "07d4fb9c283439fa2b0ee9d68d806c373e2ae06c_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static  void  NetUDP_TxPktValidate (NET_BUF_HDR       *p_buf_hdr,\n                                    NET_UDP_PORT_NBR   src_port,\n                                    NET_UDP_PORT_NBR   dest_port,\n                                    NET_UDP_FLAGS      flags_udp,\n                                    NET_ERR           *p_err)\n{\n    CPU_INT16U     ix;\n    CPU_INT16U     len;\n    NET_UDP_FLAGS  flag_mask;\n                                                                /* -------------- VALIDATE NET BUF TYPE --------------- */\n    switch (p_buf_hdr->Type) {\n        case NET_BUF_TYPE_TX_LARGE:\n        case NET_BUF_TYPE_TX_SMALL:\n             break;\n        case NET_BUF_TYPE_NONE:\n        case NET_BUF_TYPE_BUF:\n        case NET_BUF_TYPE_RX_LARGE:\n        default:\n             NET_CTR_ERR_INC(Net_ErrCtrs.Buf.InvTypeCtr);\n            *p_err = NET_BUF_ERR_INVALID_TYPE;\n             return;\n    }\n                                                                /* ----------------- VALIDATE PROTOCOL ---------------- */\n    switch (p_buf_hdr->ProtocolHdrType) {\n        case NET_PROTOCOL_TYPE_APP:\n        case NET_PROTOCOL_TYPE_SOCK:\n        case NET_PROTOCOL_TYPE_UDP_V4:\n        case NET_PROTOCOL_TYPE_UDP_V6:\n             ix  = (CPU_INT16U)p_buf_hdr->DataIx;\n             len = (CPU_INT16U)p_buf_hdr->DataLen;\n             break;\n        case NET_PROTOCOL_TYPE_NONE:\n        default:\n             NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxInvalidProtocolCtr);\n            *p_err = NET_ERR_INVALID_PROTOCOL;\n             return;\n    }\n    if (ix == NET_BUF_IX_NONE) {\n        NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxInvalidBufIxCtr);\n       *p_err = NET_BUF_ERR_INVALID_IX;\n        return;\n    }\n    if (ix <  NET_UDP_HDR_SIZE) {\n        NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxInvalidBufIxCtr);\n       *p_err = NET_BUF_ERR_INVALID_IX;\n        return;\n    }\n                                                                /* -------------- VALIDATE TOT DATA LEN --------------- */\n    if (len != p_buf_hdr->TotLen) {\n        NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxHdrDataLenCtr);\n       *p_err = NET_UDP_ERR_INVALID_LEN_DATA;\n        return;\n    }\n                                                                /* ---------------- VALIDATE UDP PORTS ---------------- */\n    if (src_port  == NET_UDP_PORT_NBR_RESERVED) {\n        NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxHdrPortSrcCtr);\n       *p_err = NET_UDP_ERR_INVALID_PORT_NBR;\n        return;\n    }\n    if (dest_port == NET_UDP_PORT_NBR_RESERVED) {\n        NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxHdrPortDestCtr);\n       *p_err = NET_UDP_ERR_INVALID_PORT_NBR;\n        return;\n    }\n                                                                /* ---------------- VALIDATE UDP FLAGS ---------------- */\n    flag_mask = NET_UDP_FLAG_NONE           |\n                NET_UDP_FLAG_TX_CHK_SUM_DIS |\n                NET_UDP_FLAG_TX_BLOCK;                          /* See Note #2b1.                                       */\n                                                                /* If any invalid flags req'd, rtn err (see Note #2a).  */\n    if ((flags_udp & (NET_UDP_FLAGS)~flag_mask) != NET_UDP_FLAG_NONE) {\n        NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxHdrFlagsCtr);\n       *p_err = NET_UDP_ERR_INVALID_FLAG;\n        return;\n    }\n   *p_err = NET_UDP_ERR_NONE;\n"]]}
{"hexsha": "686625adca35c81992e99d82250575eecf84231d", "ext": "c", "lang": "C", "content": "unsigned int call_pkm_modify_code(unsigned long arg)\n{\n        unsigned long *func;\n        static unsigned long oldfunc;\n\n        func = (unsigned long*)tts_debug_func_mod;\n        if(!func)\n                return TTS_TC_RET_FAILURE;\n        if(arg)\n        {\n                oldfunc = *func;\n                *func = 'r';\n        }\n        else\n        {\n                *func =  oldfunc;\n        }\n        return TTS_TC_RET_SUCCESS;\n}", "item_id": 1, "repo": "CaelestisZ/IrisCore", "file": "drivers/misc/ktest/kt_pkm.c", "last_update_at": "2020-06-28T00:49:21+00:00", "question_id": "686625adca35c81992e99d82250575eecf84231d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsigned int call_pkm_modify_code(unsigned long arg)\n{\n        unsigned long *func;\n        static unsigned long oldfunc;\n        func = (unsigned long*)tts_debug_func_mod;\n        if(!func)\n                return TTS_TC_RET_FAILURE;\n        if(arg)\n        {\n                oldfunc = *func;\n                *func = 'r';\n        }\n        else\n        {\n                *func =  oldfunc;\n        }\n        return TTS_TC_RET_SUCCESS;\n"]]}
{"hexsha": "0691037f99f3a0b0b113d3b94a5460915fe60990", "ext": "c", "lang": "C", "content": "int aes_128_eax_encrypt(const u8 *key, const u8 *nonce, size_t nonce_len,\n\t\t\tconst u8 *hdr, size_t hdr_len,\n\t\t\tu8 *data, size_t data_len, u8 *tag)\n{\n\tu8 *buf;\n\tsize_t buf_len;\n\tu8 nonce_mac[BLOCK_SIZE], hdr_mac[BLOCK_SIZE], data_mac[BLOCK_SIZE];\n\tint i;\n\n\tif (nonce_len > data_len)\n\t\tbuf_len = nonce_len;\n\telse\n\t\tbuf_len = data_len;\n\tif (hdr_len > buf_len)\n\t\tbuf_len = hdr_len;\n\tbuf_len += 16;\n\n\tbuf = os_malloc(buf_len);\n\tif (buf == NULL)\n\t\treturn -1;\n\n\tos_memset(buf, 0, 15);\n\n\tbuf[15] = 0;\n\tos_memcpy(buf + 16, nonce, nonce_len);\n\tomac1_aes_128(key, buf, 16 + nonce_len, nonce_mac);\n\n\tbuf[15] = 1;\n\tos_memcpy(buf + 16, hdr, hdr_len);\n\tomac1_aes_128(key, buf, 16 + hdr_len, hdr_mac);\n\n\taes_128_ctr_encrypt(key, nonce_mac, data, data_len);\n\tbuf[15] = 2;\n\tos_memcpy(buf + 16, data, data_len);\n\tomac1_aes_128(key, buf, 16 + data_len, data_mac);\n\n\tos_free(buf);\n\n\tfor (i = 0; i < BLOCK_SIZE; i++)\n\t\ttag[i] = nonce_mac[i] ^ data_mac[i] ^ hdr_mac[i];\n\n\treturn 0;\n}", "item_id": 6, "repo": "OpenIKEv2/libopenikev2_impl", "file": "libeapclient/crypto/aes_wrap.c", "last_update_at": "2020-06-16T04:50:40+00:00", "question_id": "0691037f99f3a0b0b113d3b94a5460915fe60990_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int aes_128_eax_encrypt(const u8 *key, const u8 *nonce, size_t nonce_len,\n\t\t\tconst u8 *hdr, size_t hdr_len,\n\t\t\tu8 *data, size_t data_len, u8 *tag)\n{\n\tu8 *buf;\n\tsize_t buf_len;\n\tu8 nonce_mac[BLOCK_SIZE], hdr_mac[BLOCK_SIZE], data_mac[BLOCK_SIZE];\n\tint i;\n\tif (nonce_len > data_len)\n\t\tbuf_len = nonce_len;\n\telse\n\t\tbuf_len = data_len;\n\tif (hdr_len > buf_len)\n\t\tbuf_len = hdr_len;\n\tbuf_len += 16;\n\tbuf = os_malloc(buf_len);\n\tif (buf == NULL)\n\t\treturn -1;\n\tos_memset(buf, 0, 15);\n\tbuf[15] = 0;\n\tos_memcpy(buf + 16, nonce, nonce_len);\n\tomac1_aes_128(key, buf, 16 + nonce_len, nonce_mac);\n\tbuf[15] = 1;\n\tos_memcpy(buf + 16, hdr, hdr_len);\n\tomac1_aes_128(key, buf, 16 + hdr_len, hdr_mac);\n\taes_128_ctr_encrypt(key, nonce_mac, data, data_len);\n\tbuf[15] = 2;\n\tos_memcpy(buf + 16, data, data_len);\n\tomac1_aes_128(key, buf, 16 + data_len, data_mac);\n\tos_free(buf);\n\tfor (i = 0; i < BLOCK_SIZE; i++)\n\t\ttag[i] = nonce_mac[i] ^ data_mac[i] ^ hdr_mac[i];\n\treturn 0;\n"]]}
{"hexsha": "44c97561e598773860860a9c850bfd8c071e08aa", "ext": "c", "lang": "C", "content": "void func_219()\n{\n\tGlobal_21058 = Global_21057;\n\tGlobal_21052 = Global_21053;\n\tGlobal_21099 = { Global_21087 };\n\tGlobal_21105 = { Global_21093 };\n\tGlobal_21060 = Global_21059;\n\tGlobal_21129 = { Global_21111 };\n\tGlobal_21135 = { Global_21117 };\n\tGlobal_21141 = { Global_21123 };\n\tGlobal_21147 = { Global_21153 };\n\tGlobal_6866 = Global_6867;\n\tGlobal_6868 = Global_6869;\n\tGlobal_21016 = Global_21017;\n\tGlobal_21018 = Global_21019;\n\tGlobal_21020 = { Global_21036 };\n\tGlobal_21009 = Global_21010;\n\tGlobal_22021 = 0;\n\tGlobal_21054 = 0;\n\tGlobal_21055 = 0;\n\tunk_0xD2459066EA58CE43(&Global_7552, 16);\n}", "item_id": 139, "repo": "Seanghost117/GTA-V-Decompiled-Scripts", "file": "decompiled_scripts/nigel3.c", "last_update_at": "2020-12-16T17:13:14+00:00", "question_id": "44c97561e598773860860a9c850bfd8c071e08aa_139", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void func_219()\n{\n\tGlobal_21058 = Global_21057;\n\tGlobal_21052 = Global_21053;\n\tGlobal_21099 = { Global_21087 };\n\tGlobal_21105 = { Global_21093 };\n\tGlobal_21060 = Global_21059;\n\tGlobal_21129 = { Global_21111 };\n\tGlobal_21135 = { Global_21117 };\n\tGlobal_21141 = { Global_21123 };\n\tGlobal_21147 = { Global_21153 };\n\tGlobal_6866 = Global_6867;\n\tGlobal_6868 = Global_6869;\n\tGlobal_21016 = Global_21017;\n\tGlobal_21018 = Global_21019;\n\tGlobal_21020 = { Global_21036 };\n\tGlobal_21009 = Global_21010;\n\tGlobal_22021 = 0;\n\tGlobal_21054 = 0;\n\tGlobal_21055 = 0;\n\tunk_0xD2459066EA58CE43(&Global_7552, 16);\n"]]}
{"hexsha": "239ad18e913a08e3f4fd80633f4e02102294ebc9", "ext": "c", "lang": "C", "content": "static ERL_NIF_TERM\nnifile_dir_alloc(ErlNifEnv* env, DIR* dp)\n{\n    nifile_dir_t* res;\n    ERL_NIF_TERM ret;\n\n    res = enif_alloc_resource(DIR_RES, sizeof(nifile_dir_t));\n    if(res == NULL) {\n        return enif_make_badarg(env);\n    }\n\n    ret = enif_make_resource(env, res);\n    enif_release_resource(res);\n\n    res->dp = dp;\n    res->closed = 0;\n\n    return enif_make_tuple2(env, ATOM_OK, ret);\n}", "item_id": 1, "repo": "martinsumner/nifile", "file": "c_src/nifile.c", "last_update_at": "2020-12-21T00:17:17+00:00", "question_id": "239ad18e913a08e3f4fd80633f4e02102294ebc9_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static ERL_NIF_TERM\nnifile_dir_alloc(ErlNifEnv* env, DIR* dp)\n{\n    nifile_dir_t* res;\n    ERL_NIF_TERM ret;\n    res = enif_alloc_resource(DIR_RES, sizeof(nifile_dir_t));\n    if(res == NULL) {\n        return enif_make_badarg(env);\n    }\n    ret = enif_make_resource(env, res);\n    enif_release_resource(res);\n    res->dp = dp;\n    res->closed = 0;\n    return enif_make_tuple2(env, ATOM_OK, ret);\n"]]}
{"hexsha": "6f702bb5f19442f13217e61b8e8bb28422903f98", "ext": "c", "lang": "C", "content": "void reply_remove_tcb(tcb_t *tcb)\n{\n    assert(thread_state_get_tsType(tcb->tcbState) == ThreadState_BlockedOnReply);\n    reply_t *reply = REPLY_PTR(thread_state_get_replyObject(tcb->tcbState));\n    word_t next_ptr = call_stack_get_callStackPtr(reply->replyNext);\n    word_t prev_ptr = call_stack_get_callStackPtr(reply->replyPrev);\n\n    if (next_ptr) {\n        if (call_stack_get_isHead(reply->replyNext)) {\n            SC_PTR(next_ptr)->scReply = NULL;\n        } else {\n            REPLY_PTR(next_ptr)->replyPrev = call_stack_new(0, false);\n        }\n    }\n\n    if (prev_ptr) {\n        REPLY_PTR(prev_ptr)->replyNext = call_stack_new(0, false);\n    }\n\n    reply->replyPrev = call_stack_new(0, false);\n    reply->replyNext = call_stack_new(0, false);\n    reply_unlink(reply);\n}", "item_id": 3, "repo": "Nexusoft/LLL-OS", "file": "kernel/src/object/reply.c", "last_update_at": "2020-10-16T20:05:17+00:00", "question_id": "6f702bb5f19442f13217e61b8e8bb28422903f98_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void reply_remove_tcb(tcb_t *tcb)\n{\n    assert(thread_state_get_tsType(tcb->tcbState) == ThreadState_BlockedOnReply);\n    reply_t *reply = REPLY_PTR(thread_state_get_replyObject(tcb->tcbState));\n    word_t next_ptr = call_stack_get_callStackPtr(reply->replyNext);\n    word_t prev_ptr = call_stack_get_callStackPtr(reply->replyPrev);\n    if (next_ptr) {\n        if (call_stack_get_isHead(reply->replyNext)) {\n            SC_PTR(next_ptr)->scReply = NULL;\n        } else {\n            REPLY_PTR(next_ptr)->replyPrev = call_stack_new(0, false);\n        }\n    }\n    if (prev_ptr) {\n        REPLY_PTR(prev_ptr)->replyNext = call_stack_new(0, false);\n    }\n    reply->replyPrev = call_stack_new(0, false);\n    reply->replyNext = call_stack_new(0, false);\n    reply_unlink(reply);\n"]]}
{"hexsha": "71b650cb0062a6fad39c57d82a8a89ef5e3e5a5c", "ext": "c", "lang": "C", "content": "void vetor_apaga(vetor* vec)\n{\n\tint i;\n\n\tif(vec == NULL)\n        return;\n\n\t/* liberta memoria de cada string */\n\tfor (i = 0; i < vec->tamanho; i++)\n\t{\n\t\tfree(vec->elementos[i].str);\n\t}\n\n\t/* liberta memoria dos apontares para as strings */\n\tfree(vec->elementos);\n\n\t/* liberta memoria da estrutura vetor */\n\tfree(vec);\n}", "item_id": 1, "repo": "ivzvvv/FEUP", "file": "Ano1/Prog2/trabalho01/vetor.c", "last_update_at": "2020-03-29T12:15:35+00:00", "question_id": "71b650cb0062a6fad39c57d82a8a89ef5e3e5a5c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void vetor_apaga(vetor* vec)\n{\n\tint i;\n\tif(vec == NULL)\n        return;\n\t/* liberta memoria de cada string */\n\tfor (i = 0; i < vec->tamanho; i++)\n\t{\n\t\tfree(vec->elementos[i].str);\n\t}\n\t/* liberta memoria dos apontares para as strings */\n\tfree(vec->elementos);\n\t/* liberta memoria da estrutura vetor */\n\tfree(vec);\n"]]}
{"hexsha": "bd6bd06fc15f7dde697aae351a85d1b6f29bb388", "ext": "c", "lang": "C", "content": "static void set_do_address(asn1_ctx_t* actx, gboolean do_address)\n{\n    p1_address_ctx_t* ctx;\n\n    if (actx->subtree.tree_ctx == NULL) {\n        actx->subtree.tree_ctx = wmem_new0(wmem_packet_scope(), p1_address_ctx_t);\n    }\n\n    ctx = (p1_address_ctx_t*)actx->subtree.tree_ctx;\n    ctx->do_address = do_address;\n}", "item_id": 0, "repo": "joshis1/C_Programming", "file": "resources/Wireshark/WiresharkDissectorFoo/epan/dissectors/asn1/p1/packet-p1-template.c", "last_update_at": "2020-12-31T11:42:02+00:00", "question_id": "bd6bd06fc15f7dde697aae351a85d1b6f29bb388_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void set_do_address(asn1_ctx_t* actx, gboolean do_address)\n{\n    p1_address_ctx_t* ctx;\n    if (actx->subtree.tree_ctx == NULL) {\n        actx->subtree.tree_ctx = wmem_new0(wmem_packet_scope(), p1_address_ctx_t);\n    }\n    ctx = (p1_address_ctx_t*)actx->subtree.tree_ctx;\n    ctx->do_address = do_address;\n"]]}
{"hexsha": "74a7249955b4a4a18371fe01b7f6c42f33f16646", "ext": "c", "lang": "C", "content": "int func_365(int iParam0, var uParam1, bool bParam2, int iParam3, bool bParam4, bool bParam5)\n{\n\tint iVar0;\n\tint iVar1;\n\tvar uVar2;\n\t\n\tif (bParam2)\n\t{\n\t\tif (!bParam4)\n\t\t{\n\t\t}\n\t\tGlobal_2097152[func_191() /*10931*/].f_6175.f_1274 = unk_0x5A002C4821A13338();\n\t}\n\tif (!bParam4)\n\t{\n\t}\n\tiVar1 = func_383(1411, iParam0);\n\tfunc_17(iVar1, uParam1->f_137, iParam3, 1);\n\tif (!bParam4)\n\t{\n\t}\n\tiVar1 = func_383(1412, iParam0);\n\tfunc_17(iVar1, uParam1->f_138, iParam3, 1);\n\tif (!bParam4)\n\t{\n\t}\n\tif (func_382(iParam0))\n\t{\n\t}\n\telse\n\t{\n\t\tiVar1 = func_383(1413, iParam0);\n\t\tfunc_17(iVar1, *uParam1, iParam3, 1);\n\t\tiVar0 = 0;\n\t\twhile (iVar0 < 49)\n\t\t{\n\t\t\tif (iVar0 < 25)\n\t\t\t{\n\t\t\t\tiVar1 = (func_383(1414, iParam0) + iVar0);\n\t\t\t\tfunc_17(iVar1, uParam1->f_9[iVar0], iParam3, 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tiVar1 = (func_381(iParam0) + (iVar0 - 25));\n\t\t\t\tfunc_17(iVar1, uParam1->f_9[iVar0], iParam3, 1);\n\t\t\t}\n\t\t\tiVar0++;\n\t\t}\n\t\tiVar0 = 0;\n\t\tiVar0 = 0;\n\t\twhile (iVar0 < 2)\n\t\t{\n\t\t\tiVar1 = (func_383(1439, iParam0) + iVar0);\n\t\t\tfunc_17(iVar1, uParam1->f_59[iVar0], iParam3, 1);\n\t\t\tiVar0++;\n\t\t}\n\t}\n\tiVar1 = func_383(1441, iParam0);\n\tfunc_17(iVar1, uParam1->f_62, iParam3, 1);\n\tiVar1 = func_383(1442, iParam0);\n\tfunc_17(iVar1, uParam1->f_63, iParam3, 1);\n\tiVar1 = func_383(1443, iParam0);\n\tfunc_17(iVar1, uParam1->f_64, iParam3, 1);\n\tif (func_382(iParam0))\n\t{\n\t\tif (!bParam4)\n\t\t{\n\t\t}\n\t}\n\telse\n\t{\n\t\tiVar1 = func_383(1444, iParam0);\n\t\tfunc_17(iVar1, uParam1->f_65, iParam3, 1);\n\t}\n\tiVar1 = func_383(1445, iParam0);\n\tfunc_17(iVar1, uParam1->f_67, iParam3, 1);\n\tif (func_382(iParam0))\n\t{\n\t\tif (!bParam4)\n\t\t{\n\t\t}\n\t}\n\telse\n\t{\n\t\tiVar1 = func_383(1446, iParam0);\n\t\tfunc_17(iVar1, uParam1->f_68, iParam3, 1);\n\t}\n\tiVar1 = func_383(1447, iParam0);\n\tfunc_17(iVar1, uParam1->f_69, iParam3, 1);\n\tiVar1 = func_383(1448, iParam0);\n\tfunc_17(iVar1, uParam1->f_70, -1, 1);\n\tiVar1 = func_383(1449, iParam0);\n\tfunc_17(iVar1, uParam1->f_71, iParam3, 1);\n\tiVar1 = func_383(1450, iParam0);\n\tfunc_17(iVar1, uParam1->f_72, iParam3, 1);\n\tiVar1 = func_383(1451, iParam0);\n\tfunc_17(iVar1, uParam1->f_73, iParam3, 1);\n\tiVar1 = func_383(1452, iParam0);\n\tfunc_17(iVar1, uParam1->f_5, iParam3, 1);\n\tiVar1 = func_383(1453, iParam0);\n\tfunc_17(iVar1, uParam1->f_6, iParam3, 1);\n\tiVar1 = func_383(1454, iParam0);\n\tfunc_17(iVar1, uParam1->f_7, iParam3, 1);\n\tiVar1 = func_383(1455, iParam0);\n\tfunc_17(iVar1, uParam1->f_8, iParam3, 1);\n\tif (func_382(iParam0))\n\t{\n\t\tif (!bParam4)\n\t\t{\n\t\t}\n\t}\n\telse\n\t{\n\t\tiVar1 = func_383(3880, iParam0);\n\t\tfunc_17(iVar1, uParam1->f_74, iParam3, 1);\n\t\tiVar1 = func_383(3881, iParam0);\n\t\tfunc_17(iVar1, uParam1->f_75, iParam3, 1);\n\t\tiVar1 = func_383(3882, iParam0);\n\t\tfunc_17(iVar1, uParam1->f_76, iParam3, 1);\n\t\tiVar1 = func_380(iParam0);\n\t\tfunc_17(iVar1, uParam1->f_97, iParam3, 1);\n\t\tiVar1 = func_379(iParam0);\n\t\tfunc_17(iVar1, uParam1->f_99, iParam3, 1);\n\t\tiVar1 = func_368(iParam0);\n\t\tfunc_17(iVar1, uParam1->f_98, iParam3, 1);\n\t}\n\tuVar2 = Global_2097152[func_191() /*10931*/].f_6175.f_1274;\n\tif (bParam5)\n\t{\n\t\tuVar2 = unk_0x5A002C4821A13338();\n\t}\n\tfunc_131(1628, uVar2, iParam3, 1, 0);\n\tif (!bParam4)\n\t{\n\t}\n\tfunc_131(func_367(1, iParam0), uParam1->f_102, iParam3, 1, 0);\n\tif (!bParam4)\n\t{\n\t}\n\tfunc_131(func_367(2, iParam0), uParam1->f_103, iParam3, 1, 0);\n\tif (!bParam4)\n\t{\n\t}\n\tfunc_131(func_367(3, iParam0), uParam1->f_104, iParam3, 1, 0);\n\tif (!bParam4)\n\t{\n\t}\n\tfunc_131(func_367(4, iParam0), uParam1->f_66, iParam3, 1, 0);\n\tfunc_131(func_367(5, iParam0), uParam1->f_77, iParam3, 1, 0);\n\tif (!bParam4)\n\t{\n\t}\n\tfunc_131(func_367(7, iParam0), uParam1->f_139, iParam3, 1, 0);\n\tif (!func_382(iParam0))\n\t{\n\t\tif (!unk_0x7BCC91F3C1CF24E8(&(uParam1->f_1)))\n\t\t{\n\t\t\tfunc_366(func_367(6, iParam0), &(uParam1->f_1), iParam3);\n\t\t\tif (!bParam4)\n\t\t\t{\n\t\t\t}\n\t\t}\n\t\telse if (!bParam4)\n\t\t{\n\t\t}\n\t}\n\tif (!bParam4)\n\t{\n\t}\n\treturn 1;\n}", "item_id": 200, "repo": "Seanghost117/GTA-V-Decompiled-Scripts", "file": "decompiled_scripts/social_controller.c", "last_update_at": "2020-12-16T17:13:14+00:00", "question_id": "74a7249955b4a4a18371fe01b7f6c42f33f16646_200", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int func_365(int iParam0, var uParam1, bool bParam2, int iParam3, bool bParam4, bool bParam5)\n{\n\tint iVar0;\n\tint iVar1;\n\tvar uVar2;\n\t\n\tif (bParam2)\n\t{\n\t\tif (!bParam4)\n\t\t{\n\t\t}\n\t\tGlobal_2097152[func_191() /*10931*/].f_6175.f_1274 = unk_0x5A002C4821A13338();\n\t}\n\tif (!bParam4)\n\t{\n\t}\n\tiVar1 = func_383(1411, iParam0);\n\tfunc_17(iVar1, uParam1->f_137, iParam3, 1);\n\tif (!bParam4)\n\t{\n\t}\n\tiVar1 = func_383(1412, iParam0);\n\tfunc_17(iVar1, uParam1->f_138, iParam3, 1);\n\tif (!bParam4)\n\t{\n\t}\n\tif (func_382(iParam0))\n\t{\n\t}\n\telse\n\t{\n\t\tiVar1 = func_383(1413, iParam0);\n\t\tfunc_17(iVar1, *uParam1, iParam3, 1);\n\t\tiVar0 = 0;\n\t\twhile (iVar0 < 49)\n\t\t{\n\t\t\tif (iVar0 < 25)\n\t\t\t{\n\t\t\t\tiVar1 = (func_383(1414, iParam0) + iVar0);\n\t\t\t\tfunc_17(iVar1, uParam1->f_9[iVar0], iParam3, 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tiVar1 = (func_381(iParam0) + (iVar0 - 25));\n\t\t\t\tfunc_17(iVar1, uParam1->f_9[iVar0], iParam3, 1);\n\t\t\t}\n\t\t\tiVar0++;\n\t\t}\n\t\tiVar0 = 0;\n\t\tiVar0 = 0;\n\t\twhile (iVar0 < 2)\n\t\t{\n\t\t\tiVar1 = (func_383(1439, iParam0) + iVar0);\n\t\t\tfunc_17(iVar1, uParam1->f_59[iVar0], iParam3, 1);\n\t\t\tiVar0++;\n\t\t}\n\t}\n\tiVar1 = func_383(1441, iParam0);\n\tfunc_17(iVar1, uParam1->f_62, iParam3, 1);\n\tiVar1 = func_383(1442, iParam0);\n\tfunc_17(iVar1, uParam1->f_63, iParam3, 1);\n\tiVar1 = func_383(1443, iParam0);\n\tfunc_17(iVar1, uParam1->f_64, iParam3, 1);\n\tif (func_382(iParam0))\n\t{\n\t\tif (!bParam4)\n\t\t{\n\t\t}\n\t}\n\telse\n\t{\n\t\tiVar1 = func_383(1444, iParam0);\n\t\tfunc_17(iVar1, uParam1->f_65, iParam3, 1);\n\t}\n\tiVar1 = func_383(1445, iParam0);\n\tfunc_17(iVar1, uParam1->f_67, iParam3, 1);\n\tif (func_382(iParam0))\n\t{\n\t\tif (!bParam4)\n\t\t{\n\t\t}\n\t}\n\telse\n\t{\n\t\tiVar1 = func_383(1446, iParam0);\n\t\tfunc_17(iVar1, uParam1->f_68, iParam3, 1);\n\t}\n\tiVar1 = func_383(1447, iParam0);\n\tfunc_17(iVar1, uParam1->f_69, iParam3, 1);\n\tiVar1 = func_383(1448, iParam0);\n\tfunc_17(iVar1, uParam1->f_70, -1, 1);\n\tiVar1 = func_383(1449, iParam0);\n\tfunc_17(iVar1, uParam1->f_71, iParam3, 1);\n\tiVar1 = func_383(1450, iParam0);\n\tfunc_17(iVar1, uParam1->f_72, iParam3, 1);\n\tiVar1 = func_383(1451, iParam0);\n\tfunc_17(iVar1, uParam1->f_73, iParam3, 1);\n\tiVar1 = func_383(1452, iParam0);\n\tfunc_17(iVar1, uParam1->f_5, iParam3, 1);\n\tiVar1 = func_383(1453, iParam0);\n\tfunc_17(iVar1, uParam1->f_6, iParam3, 1);\n\tiVar1 = func_383(1454, iParam0);\n\tfunc_17(iVar1, uParam1->f_7, iParam3, 1);\n\tiVar1 = func_383(1455, iParam0);\n\tfunc_17(iVar1, uParam1->f_8, iParam3, 1);\n\tif (func_382(iParam0))\n\t{\n\t\tif (!bParam4)\n\t\t{\n\t\t}\n\t}\n\telse\n\t{\n\t\tiVar1 = func_383(3880, iParam0);\n\t\tfunc_17(iVar1, uParam1->f_74, iParam3, 1);\n\t\tiVar1 = func_383(3881, iParam0);\n\t\tfunc_17(iVar1, uParam1->f_75, iParam3, 1);\n\t\tiVar1 = func_383(3882, iParam0);\n\t\tfunc_17(iVar1, uParam1->f_76, iParam3, 1);\n\t\tiVar1 = func_380(iParam0);\n\t\tfunc_17(iVar1, uParam1->f_97, iParam3, 1);\n\t\tiVar1 = func_379(iParam0);\n\t\tfunc_17(iVar1, uParam1->f_99, iParam3, 1);\n\t\tiVar1 = func_368(iParam0);\n\t\tfunc_17(iVar1, uParam1->f_98, iParam3, 1);\n\t}\n\tuVar2 = Global_2097152[func_191() /*10931*/].f_6175.f_1274;\n\tif (bParam5)\n\t{\n\t\tuVar2 = unk_0x5A002C4821A13338();\n\t}\n\tfunc_131(1628, uVar2, iParam3, 1, 0);\n\tif (!bParam4)\n\t{\n\t}\n\tfunc_131(func_367(1, iParam0), uParam1->f_102, iParam3, 1, 0);\n\tif (!bParam4)\n\t{\n\t}\n\tfunc_131(func_367(2, iParam0), uParam1->f_103, iParam3, 1, 0);\n\tif (!bParam4)\n\t{\n\t}\n\tfunc_131(func_367(3, iParam0), uParam1->f_104, iParam3, 1, 0);\n\tif (!bParam4)\n\t{\n\t}\n\tfunc_131(func_367(4, iParam0), uParam1->f_66, iParam3, 1, 0);\n\tfunc_131(func_367(5, iParam0), uParam1->f_77, iParam3, 1, 0);\n\tif (!bParam4)\n\t{\n\t}\n\tfunc_131(func_367(7, iParam0), uParam1->f_139, iParam3, 1, 0);\n\tif (!func_382(iParam0))\n\t{\n\t\tif (!unk_0x7BCC91F3C1CF24E8(&(uParam1->f_1)))\n\t\t{\n\t\t\tfunc_366(func_367(6, iParam0), &(uParam1->f_1), iParam3);\n\t\t\tif (!bParam4)\n\t\t\t{\n\t\t\t}\n\t\t}\n\t\telse if (!bParam4)\n\t\t{\n\t\t}\n\t}\n\tif (!bParam4)\n\t{\n\t}\n\treturn 1;\n"]]}
{"hexsha": "cfc3d9f99406532a575bacff98edcc8060d2f49b", "ext": "c", "lang": "C", "content": "static int\nikev2_delete_tunnel_interface (vnet_main_t * vnm, ikev2_sa_t * sa,\n\t\t\t       ikev2_child_sa_t * child)\n{\n  ikev2_del_ipsec_tunnel_args_t a;\n\n  clib_memset (&a, 0, sizeof (a));\n\n  if (sa->is_initiator)\n    {\n      ip_address_to_46 (&sa->iaddr, &a.local_ip);\n      ip_address_to_46 (&sa->raddr, &a.remote_ip);\n    }\n  else\n    {\n      ip_address_to_46 (&sa->raddr, &a.local_ip);\n      ip_address_to_46 (&sa->iaddr, &a.remote_ip);\n    }\n\n  a.remote_sa_id = child->remote_sa_id;\n  a.local_sa_id = child->local_sa_id;\n  a.sw_if_index = (sa->is_tun_itf_set ? sa->tun_itf : ~0);\n\n  vl_api_rpc_call_main_thread (ikev2_del_tunnel_from_main, (u8 *) & a,\n\t\t\t       sizeof (a));\n  return 0;\n}", "item_id": 39, "repo": "atsgen/vpp", "file": "src/plugins/ikev2/ikev2.c", "last_update_at": "2020-03-19T05:02:29+00:00", "question_id": "cfc3d9f99406532a575bacff98edcc8060d2f49b_39", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nikev2_delete_tunnel_interface (vnet_main_t * vnm, ikev2_sa_t * sa,\n\t\t\t       ikev2_child_sa_t * child)\n{\n  ikev2_del_ipsec_tunnel_args_t a;\n  clib_memset (&a, 0, sizeof (a));\n  if (sa->is_initiator)\n    {\n      ip_address_to_46 (&sa->iaddr, &a.local_ip);\n      ip_address_to_46 (&sa->raddr, &a.remote_ip);\n    }\n  else\n    {\n      ip_address_to_46 (&sa->raddr, &a.local_ip);\n      ip_address_to_46 (&sa->iaddr, &a.remote_ip);\n    }\n  a.remote_sa_id = child->remote_sa_id;\n  a.local_sa_id = child->local_sa_id;\n  a.sw_if_index = (sa->is_tun_itf_set ? sa->tun_itf : ~0);\n  vl_api_rpc_call_main_thread (ikev2_del_tunnel_from_main, (u8 *) & a,\n\t\t\t       sizeof (a));\n  return 0;\n"]]}
{"hexsha": "0ca8bbc17e13f351cfdafa7072b5542063af3e12", "ext": "c", "lang": "C", "content": "static struct inode *\nnfs3_proc_create(struct inode *dir, struct qstr *name, struct iattr *sattr,\n\t\t int flags)\n{\n\tstruct nfs_fh\t\tfhandle;\n\tstruct nfs_fattr\tfattr;\n\tstruct nfs_fattr\tdir_attr;\n\tstruct nfs3_createargs\targ = {\n\t\t.fh\t\t= NFS_FH(dir),\n\t\t.name\t\t= name->name,\n\t\t.len\t\t= name->len,\n\t\t.sattr\t\t= sattr,\n\t};\n\tstruct nfs3_diropres\tres = {\n\t\t.dir_attr\t= &dir_attr,\n\t\t.fh\t\t= &fhandle,\n\t\t.fattr\t\t= &fattr\n\t};\n\tint\t\t\tstatus;\n\n\tdprintk(\"NFS call  create %s\\n\", name->name);\n\targ.createmode = NFS3_CREATE_UNCHECKED;\n\tif (flags & O_EXCL) {\n\t\targ.createmode  = NFS3_CREATE_EXCLUSIVE;\n\t\targ.verifier[0] = jiffies;\n\t\targ.verifier[1] = current->pid;\n\t}\n\nagain:\n\tdir_attr.valid = 0;\n\tfattr.valid = 0;\n\tstatus = rpc_call(NFS_CLIENT(dir), NFS3PROC_CREATE, &arg, &res, 0);\n\tnfs_refresh_inode(dir, &dir_attr);\n\n\t/* If the server doesn't support the exclusive creation semantics,\n\t * try again with simple 'guarded' mode. */\n\tif (status == NFSERR_NOTSUPP) {\n\t\tswitch (arg.createmode) {\n\t\t\tcase NFS3_CREATE_EXCLUSIVE:\n\t\t\t\targ.createmode = NFS3_CREATE_GUARDED;\n\t\t\t\tbreak;\n\n\t\t\tcase NFS3_CREATE_GUARDED:\n\t\t\t\targ.createmode = NFS3_CREATE_UNCHECKED;\n\t\t\t\tbreak;\n\n\t\t\tcase NFS3_CREATE_UNCHECKED:\n\t\t\t\tgoto exit;\n\t\t}\n\t\tgoto again;\n\t}\n\nexit:\n\tdprintk(\"NFS reply create: %d\\n\", status);\n\n\tif (status != 0)\n\t\tgoto out;\n\tif (fhandle.size == 0 || !(fattr.valid & NFS_ATTR_FATTR)) {\n\t\tstatus = nfs3_proc_lookup(dir, name, &fhandle, &fattr);\n\t\tif (status != 0)\n\t\t\tgoto out;\n\t}\n\n\t/* When we created the file with exclusive semantics, make\n\t * sure we set the attributes afterwards. */\n\tif (arg.createmode == NFS3_CREATE_EXCLUSIVE) {\n\t\tstruct nfs3_sattrargs\targ = {\n\t\t\t.fh\t\t= &fhandle,\n\t\t\t.sattr\t\t= sattr,\n\t\t};\n\t\tdprintk(\"NFS call  setattr (post-create)\\n\");\n\n\t\t/* Note: we could use a guarded setattr here, but I'm\n\t\t * not sure this buys us anything (and I'd have\n\t\t * to revamp the NFSv3 XDR code) */\n\t\tfattr.valid = 0;\n\t\tstatus = rpc_call(NFS_CLIENT(dir), NFS3PROC_SETATTR,\n\t\t\t\t\t\t&arg, &fattr, 0);\n\t\tdprintk(\"NFS reply setattr (post-create): %d\\n\", status);\n\t}\n\tif (status == 0) {\n\t\tstruct inode *inode;\n\t\tinode = nfs_fhget(dir->i_sb, &fhandle, &fattr);\n\t\tif (inode)\n\t\t\treturn inode;\n\t\tstatus = -ENOMEM;\n\t}\nout:\n\treturn ERR_PTR(status);\n}", "item_id": 12, "repo": "dnhua/Linux_study", "file": "linux-2.6.0/fs/nfs/nfs3proc.c", "last_update_at": "2020-11-10T12:47:02+00:00", "question_id": "0ca8bbc17e13f351cfdafa7072b5542063af3e12_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct inode *\nnfs3_proc_create(struct inode *dir, struct qstr *name, struct iattr *sattr,\n\t\t int flags)\n{\n\tstruct nfs_fh\t\tfhandle;\n\tstruct nfs_fattr\tfattr;\n\tstruct nfs_fattr\tdir_attr;\n\tstruct nfs3_createargs\targ = {\n\t\t.fh\t\t= NFS_FH(dir),\n\t\t.name\t\t= name->name,\n\t\t.len\t\t= name->len,\n\t\t.sattr\t\t= sattr,\n\t};\n\tstruct nfs3_diropres\tres = {\n\t\t.dir_attr\t= &dir_attr,\n\t\t.fh\t\t= &fhandle,\n\t\t.fattr\t\t= &fattr\n\t};\n\tint\t\t\tstatus;\n\tdprintk(\"NFS call  create %s\\n\", name->name);\n\targ.createmode = NFS3_CREATE_UNCHECKED;\n\tif (flags & O_EXCL) {\n\t\targ.createmode  = NFS3_CREATE_EXCLUSIVE;\n\t\targ.verifier[0] = jiffies;\n\t\targ.verifier[1] = current->pid;\n\t}\nagain:\n\tdir_attr.valid = 0;\n\tfattr.valid = 0;\n\tstatus = rpc_call(NFS_CLIENT(dir), NFS3PROC_CREATE, &arg, &res, 0);\n\tnfs_refresh_inode(dir, &dir_attr);\n\t/* If the server doesn't support the exclusive creation semantics,\n\t * try again with simple 'guarded' mode. */\n\tif (status == NFSERR_NOTSUPP) {\n\t\tswitch (arg.createmode) {\n\t\t\tcase NFS3_CREATE_EXCLUSIVE:\n\t\t\t\targ.createmode = NFS3_CREATE_GUARDED;\n\t\t\t\tbreak;\n\t\t\tcase NFS3_CREATE_GUARDED:\n\t\t\t\targ.createmode = NFS3_CREATE_UNCHECKED;\n\t\t\t\tbreak;\n\t\t\tcase NFS3_CREATE_UNCHECKED:\n\t\t\t\tgoto exit;\n\t\t}\n\t\tgoto again;\n\t}\nexit:\n\tdprintk(\"NFS reply create: %d\\n\", status);\n\tif (status != 0)\n\t\tgoto out;\n\tif (fhandle.size == 0 || !(fattr.valid & NFS_ATTR_FATTR)) {\n\t\tstatus = nfs3_proc_lookup(dir, name, &fhandle, &fattr);\n\t\tif (status != 0)\n\t\t\tgoto out;\n\t}\n\t/* When we created the file with exclusive semantics, make\n\t * sure we set the attributes afterwards. */\n\tif (arg.createmode == NFS3_CREATE_EXCLUSIVE) {\n\t\tstruct nfs3_sattrargs\targ = {\n\t\t\t.fh\t\t= &fhandle,\n\t\t\t.sattr\t\t= sattr,\n\t\t};\n\t\tdprintk(\"NFS call  setattr (post-create)\\n\");\n\t\t/* Note: we could use a guarded setattr here, but I'm\n\t\t * not sure this buys us anything (and I'd have\n\t\t * to revamp the NFSv3 XDR code) */\n\t\tfattr.valid = 0;\n\t\tstatus = rpc_call(NFS_CLIENT(dir), NFS3PROC_SETATTR,\n\t\t\t\t\t\t&arg, &fattr, 0);\n\t\tdprintk(\"NFS reply setattr (post-create): %d\\n\", status);\n\t}\n\tif (status == 0) {\n\t\tstruct inode *inode;\n\t\tinode = nfs_fhget(dir->i_sb, &fhandle, &fattr);\n\t\tif (inode)\n\t\t\treturn inode;\n\t\tstatus = -ENOMEM;\n\t}\nout:\n\treturn ERR_PTR(status);\n"]]}
{"hexsha": "0e1efd2dce71fa3a9ab70f9ba3c998af4f7dd1bb", "ext": "c", "lang": "C", "content": "static int\nclnt_compose_rpcmsg(CLIENT *h, rpcproc_t procnum,\n    rdma_buf_t *rpcmsg, XDR *xdrs,\n    xdrproc_t xdr_args, caddr_t argsp)\n{\n\tcku_private_t *p = htop(h);\n\n\tif (h->cl_auth->ah_cred.oa_flavor != RPCSEC_GSS) {\n\t\t/*\n\t\t * Copy in the preserialized RPC header\n\t\t * information.\n\t\t */\n\t\tbcopy(p->cku_rpchdr, rpcmsg->addr, CKU_HDRSIZE);\n\n\t\t/*\n\t\t * transaction id is the 1st thing in the output\n\t\t * buffer.\n\t\t */\n\t\t/* LINTED pointer alignment */\n\t\t(*(uint32_t *)(rpcmsg->addr)) = p->cku_xid;\n\n\t\t/* Skip the preserialized stuff. */\n\t\tXDR_SETPOS(xdrs, CKU_HDRSIZE);\n\n\t\t/* Serialize dynamic stuff into the output buffer. */\n\t\tif ((!XDR_PUTINT32(xdrs, (int32_t *)&procnum)) ||\n\t\t    (!AUTH_MARSHALL(h->cl_auth, xdrs, p->cku_cred)) ||\n\t\t    (!(*xdr_args)(xdrs, argsp))) {\n\t\t\tDTRACE_PROBE(krpc__e__clntrdma__rpcmsg__dynargs);\n\t\t\treturn (CLNT_RDMA_FAIL);\n\t\t}\n\t\tp->cku_outsz = XDR_GETPOS(xdrs);\n\t} else {\n\t\tuint32_t *uproc = (uint32_t *)&p->cku_rpchdr[CKU_HDRSIZE];\n\t\tIXDR_PUT_U_INT32(uproc, procnum);\n\t\t(*(uint32_t *)(&p->cku_rpchdr[0])) = p->cku_xid;\n\t\tXDR_SETPOS(xdrs, 0);\n\n\t\t/* Serialize the procedure number and the arguments. */\n\t\tif (!AUTH_WRAP(h->cl_auth, (caddr_t)p->cku_rpchdr,\n\t\t    CKU_HDRSIZE+4, xdrs, xdr_args, argsp)) {\n\t\t\tif (rpcmsg->addr != xdrs->x_base) {\n\t\t\t\trpcmsg->addr = xdrs->x_base;\n\t\t\t\trpcmsg->len = xdr_getbufsize(xdrs);\n\t\t\t}\n\t\t\tDTRACE_PROBE(krpc__e__clntrdma__rpcmsg__procnum);\n\t\t\treturn (CLNT_RDMA_FAIL);\n\t\t}\n\t\t/*\n\t\t * If we had to allocate a new buffer while encoding\n\t\t * then update the addr and len.\n\t\t */\n\t\tif (rpcmsg->addr != xdrs->x_base) {\n\t\t\trpcmsg->addr = xdrs->x_base;\n\t\t\trpcmsg->len = xdr_getbufsize(xdrs);\n\t\t}\n\n\t\tp->cku_outsz = XDR_GETPOS(xdrs);\n\t\tDTRACE_PROBE1(krpc__i__compose__size__sec, int, p->cku_outsz)\n\t}\n\n\treturn (CLNT_RDMA_SUCCESS);\n}", "item_id": 4, "repo": "AsahiOS/gate", "file": "usr/src/uts/common/rpc/clnt_rdma.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "0e1efd2dce71fa3a9ab70f9ba3c998af4f7dd1bb_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nclnt_compose_rpcmsg(CLIENT *h, rpcproc_t procnum,\n    rdma_buf_t *rpcmsg, XDR *xdrs,\n    xdrproc_t xdr_args, caddr_t argsp)\n{\n\tcku_private_t *p = htop(h);\n\tif (h->cl_auth->ah_cred.oa_flavor != RPCSEC_GSS) {\n\t\t/*\n\t\t * Copy in the preserialized RPC header\n\t\t * information.\n\t\t */\n\t\tbcopy(p->cku_rpchdr, rpcmsg->addr, CKU_HDRSIZE);\n\t\t/*\n\t\t * transaction id is the 1st thing in the output\n\t\t * buffer.\n\t\t */\n\t\t/* LINTED pointer alignment */\n\t\t(*(uint32_t *)(rpcmsg->addr)) = p->cku_xid;\n\t\t/* Skip the preserialized stuff. */\n\t\tXDR_SETPOS(xdrs, CKU_HDRSIZE);\n\t\t/* Serialize dynamic stuff into the output buffer. */\n\t\tif ((!XDR_PUTINT32(xdrs, (int32_t *)&procnum)) ||\n\t\t    (!AUTH_MARSHALL(h->cl_auth, xdrs, p->cku_cred)) ||\n\t\t    (!(*xdr_args)(xdrs, argsp))) {\n\t\t\tDTRACE_PROBE(krpc__e__clntrdma__rpcmsg__dynargs);\n\t\t\treturn (CLNT_RDMA_FAIL);\n\t\t}\n\t\tp->cku_outsz = XDR_GETPOS(xdrs);\n\t} else {\n\t\tuint32_t *uproc = (uint32_t *)&p->cku_rpchdr[CKU_HDRSIZE];\n\t\tIXDR_PUT_U_INT32(uproc, procnum);\n\t\t(*(uint32_t *)(&p->cku_rpchdr[0])) = p->cku_xid;\n\t\tXDR_SETPOS(xdrs, 0);\n\t\t/* Serialize the procedure number and the arguments. */\n\t\tif (!AUTH_WRAP(h->cl_auth, (caddr_t)p->cku_rpchdr,\n\t\t    CKU_HDRSIZE+4, xdrs, xdr_args, argsp)) {\n\t\t\tif (rpcmsg->addr != xdrs->x_base) {\n\t\t\t\trpcmsg->addr = xdrs->x_base;\n\t\t\t\trpcmsg->len = xdr_getbufsize(xdrs);\n\t\t\t}\n\t\t\tDTRACE_PROBE(krpc__e__clntrdma__rpcmsg__procnum);\n\t\t\treturn (CLNT_RDMA_FAIL);\n\t\t}\n\t\t/*\n\t\t * If we had to allocate a new buffer while encoding\n\t\t * then update the addr and len.\n\t\t */\n\t\tif (rpcmsg->addr != xdrs->x_base) {\n\t\t\trpcmsg->addr = xdrs->x_base;\n\t\t\trpcmsg->len = xdr_getbufsize(xdrs);\n\t\t}\n\t\tp->cku_outsz = XDR_GETPOS(xdrs);\n\t\tDTRACE_PROBE1(krpc__i__compose__size__sec, int, p->cku_outsz)\n\t}\n\treturn (CLNT_RDMA_SUCCESS);\n"]]}
{"hexsha": "f60ba63f7fda7db5e3a2a94ec2a87e7438c1dbe2", "ext": "h", "lang": "C", "content": "inline SxComplex8 SxVector3<Complex8>::minval () const\n{\n   SX_EXIT; // complex numbers do not have minval\n   return SxComplex8 ();\n}", "item_id": 2, "repo": "ashtonmv/sphinx_vdw", "file": "sxaccelerate/src/math/SxVector3.h", "last_update_at": "2020-02-29T03:26:32+00:00", "question_id": "f60ba63f7fda7db5e3a2a94ec2a87e7438c1dbe2_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["inline SxComplex8 SxVector3<Complex8>::minval () const\n{\n   SX_EXIT; // complex numbers do not have minval\n   return SxComplex8 ();\n"]]}
{"hexsha": "82c8dbbc226b8607fd2d468b80230bde45c85467", "ext": "h", "lang": "C", "content": "class Serial\n{\n    private:\n        USART_TypeDef* m_usart;\n        Pin m_rxPin;\n        Pin m_txPin;\n        DmaChannel* m_dmaTxChannel;\n        uint32_t m_bauds;\n\n    public:\n        Serial(USART_TypeDef* usart, Bank* bank, uint8_t rx, uint8_t tx, gpioPinSetting settings, uint32_t bauds) : m_usart(usart), m_rxPin(bank, rx, settings), m_txPin(bank, tx, settings), m_bauds(bauds) { }\n\n        void serialSetup();\n        void enableDmaTx(DMA_TypeDef* periph, DMA_Channel_TypeDef* channel);\n        void print(const char* str, size_t len);\n        void startDmaTx(char* address, size_t length);\n        void clearDmaRegisters();\n}", "item_id": 0, "repo": "effectspcbs/platformio-stm32", "file": "test/src/serial.h", "last_update_at": "2020-11-06T21:19:46+00:00", "question_id": "82c8dbbc226b8607fd2d468b80230bde45c85467_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Serial\n{\n    private:\n        USART_TypeDef* m_usart;\n        Pin m_rxPin;\n        Pin m_txPin;\n        DmaChannel* m_dmaTxChannel;\n        uint32_t m_bauds;\n    public:\n        Serial(USART_TypeDef* usart, Bank* bank, uint8_t rx, uint8_t tx, gpioPinSetting settings, uint32_t bauds) : m_usart(usart), m_rxPin(bank, rx, settings), m_txPin(bank, tx, settings), m_bauds(bauds) { }\n        void serialSetup();\n        void enableDmaTx(DMA_TypeDef* periph, DMA_Channel_TypeDef* channel);\n        void print(const char* str, size_t len);\n        void startDmaTx(char* address, size_t length);\n        void clearDmaRegisters();\n"]]}
{"hexsha": "2cd2fee8976fb9835e8b4ea5a9b0abe540c66ba7", "ext": "c", "lang": "C", "content": "static void pm_io_space_update(PIIX4PMState *s)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n\n    s->io_base = le32_to_cpu(*(uint32_t *)(d->config + 0x40));\n    s->io_base &= 0xffc0;\n\n    memory_region_transaction_begin();\n    memory_region_set_enabled(&s->io, d->config[0x80] & 1);\n    memory_region_set_address(&s->io, s->io_base);\n    memory_region_transaction_commit();\n}", "item_id": 1, "repo": "trusted-ws/qira", "file": "tracers/qemu/qemu/hw/acpi/piix4.c", "last_update_at": "2020-12-02T16:32:17+00:00", "question_id": "2cd2fee8976fb9835e8b4ea5a9b0abe540c66ba7_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void pm_io_space_update(PIIX4PMState *s)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n    s->io_base = le32_to_cpu(*(uint32_t *)(d->config + 0x40));\n    s->io_base &= 0xffc0;\n    memory_region_transaction_begin();\n    memory_region_set_enabled(&s->io, d->config[0x80] & 1);\n    memory_region_set_address(&s->io, s->io_base);\n    memory_region_transaction_commit();\n"]]}
{"hexsha": "758d5111d4535b0cc34463ebad46877214b39809", "ext": "c", "lang": "C", "content": "static unsigned\nhwloc__look_synthetic(struct hwloc_topology *topology,\n\t\t      struct hwloc_synthetic_backend_data_s *data,\n\t\t      int level, unsigned first_cpu,\n\t\t      hwloc_bitmap_t parent_cpuset)\n{\n  hwloc_obj_t obj;\n  unsigned i;\n  struct hwloc_synthetic_level_data_s *curlevel = &data->level[level];\n  hwloc_obj_type_t type = curlevel->type;\n\n  /* pre-hooks */\n  switch (type) {\n    case HWLOC_OBJ_GROUP:\n      break;\n    case HWLOC_OBJ_SYSTEM:\n    case HWLOC_OBJ_BRIDGE:\n    case HWLOC_OBJ_PCI_DEVICE:\n    case HWLOC_OBJ_OS_DEVICE:\n      /* Shouldn't happen.  */\n      abort();\n      break;\n    case HWLOC_OBJ_MACHINE:\n      break;\n    case HWLOC_OBJ_NODE:\n      break;\n    case HWLOC_OBJ_SOCKET:\n      break;\n    case HWLOC_OBJ_CACHE:\n      break;\n    case HWLOC_OBJ_CORE:\n      break;\n    case HWLOC_OBJ_PU:\n      break;\n    case HWLOC_OBJ_MISC:\n    case HWLOC_OBJ_TYPE_MAX:\n      /* Should never happen */\n      assert(0);\n      break;\n  }\n\n  obj = hwloc_alloc_setup_object(type, curlevel->next_os_index++);\n  obj->cpuset = hwloc_bitmap_alloc();\n\n  if (!curlevel->arity) {\n    hwloc_bitmap_set(obj->cpuset, first_cpu++);\n  } else {\n    for (i = 0; i < curlevel->arity; i++)\n      first_cpu = hwloc__look_synthetic(topology, data, level + 1, first_cpu, obj->cpuset);\n  }\n\n  if (type == HWLOC_OBJ_NODE) {\n    obj->nodeset = hwloc_bitmap_alloc();\n    hwloc_bitmap_set(obj->nodeset, obj->os_index);\n  }\n\n  hwloc_bitmap_or(parent_cpuset, parent_cpuset, obj->cpuset);\n\n  /* post-hooks */\n  switch (type) {\n    case HWLOC_OBJ_GROUP:\n      obj->attr->group.depth = curlevel->depth;\n      break;\n    case HWLOC_OBJ_SYSTEM:\n    case HWLOC_OBJ_BRIDGE:\n    case HWLOC_OBJ_PCI_DEVICE:\n    case HWLOC_OBJ_OS_DEVICE:\n      abort();\n      break;\n    case HWLOC_OBJ_MACHINE:\n      break;\n    case HWLOC_OBJ_NODE:\n      /* 1GB in memory nodes, 256k 4k-pages.  */\n      obj->memory.local_memory = 1024*1024*1024;\n      obj->memory.page_types_len = 1;\n      obj->memory.page_types = malloc(sizeof(*obj->memory.page_types));\n      memset(obj->memory.page_types, 0, sizeof(*obj->memory.page_types));\n      obj->memory.page_types[0].size = 4096;\n      obj->memory.page_types[0].count = 256*1024;\n      break;\n    case HWLOC_OBJ_SOCKET:\n      break;\n    case HWLOC_OBJ_CACHE:\n      obj->attr->cache.depth = curlevel->depth;\n      obj->attr->cache.linesize = 64;\n      obj->attr->cache.type = curlevel->cachetype;\n      if (obj->attr->cache.depth == 1) {\n\t/* 32Kb in L1d */\n\tobj->attr->cache.size = 32*1024;\n      } else {\n\t/* *4 at each level, starting from 1MB for L2, unified */\n\tobj->attr->cache.size = 256*1024 << (2*obj->attr->cache.depth);\n      }\n      break;\n    case HWLOC_OBJ_CORE:\n      break;\n    case HWLOC_OBJ_PU:\n      break;\n    case HWLOC_OBJ_MISC:\n    case HWLOC_OBJ_TYPE_MAX:\n      /* Should never happen */\n      assert(0);\n      break;\n  }\n\n  hwloc_insert_object_by_cpuset(topology, obj);\n\n  return first_cpu;\n}", "item_id": 1, "repo": "afriedle-intel/ompi-release", "file": "opal/mca/hwloc/hwloc191/hwloc/src/topology-synthetic.c", "last_update_at": "2020-12-13T02:51:19+00:00", "question_id": "758d5111d4535b0cc34463ebad46877214b39809_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static unsigned\nhwloc__look_synthetic(struct hwloc_topology *topology,\n\t\t      struct hwloc_synthetic_backend_data_s *data,\n\t\t      int level, unsigned first_cpu,\n\t\t      hwloc_bitmap_t parent_cpuset)\n{\n  hwloc_obj_t obj;\n  unsigned i;\n  struct hwloc_synthetic_level_data_s *curlevel = &data->level[level];\n  hwloc_obj_type_t type = curlevel->type;\n  /* pre-hooks */\n  switch (type) {\n    case HWLOC_OBJ_GROUP:\n      break;\n    case HWLOC_OBJ_SYSTEM:\n    case HWLOC_OBJ_BRIDGE:\n    case HWLOC_OBJ_PCI_DEVICE:\n    case HWLOC_OBJ_OS_DEVICE:\n      /* Shouldn't happen.  */\n      abort();\n      break;\n    case HWLOC_OBJ_MACHINE:\n      break;\n    case HWLOC_OBJ_NODE:\n      break;\n    case HWLOC_OBJ_SOCKET:\n      break;\n    case HWLOC_OBJ_CACHE:\n      break;\n    case HWLOC_OBJ_CORE:\n      break;\n    case HWLOC_OBJ_PU:\n      break;\n    case HWLOC_OBJ_MISC:\n    case HWLOC_OBJ_TYPE_MAX:\n      /* Should never happen */\n      assert(0);\n      break;\n  }\n  obj = hwloc_alloc_setup_object(type, curlevel->next_os_index++);\n  obj->cpuset = hwloc_bitmap_alloc();\n  if (!curlevel->arity) {\n    hwloc_bitmap_set(obj->cpuset, first_cpu++);\n  } else {\n    for (i = 0; i < curlevel->arity; i++)\n      first_cpu = hwloc__look_synthetic(topology, data, level + 1, first_cpu, obj->cpuset);\n  }\n  if (type == HWLOC_OBJ_NODE) {\n    obj->nodeset = hwloc_bitmap_alloc();\n    hwloc_bitmap_set(obj->nodeset, obj->os_index);\n  }\n  hwloc_bitmap_or(parent_cpuset, parent_cpuset, obj->cpuset);\n  /* post-hooks */\n  switch (type) {\n    case HWLOC_OBJ_GROUP:\n      obj->attr->group.depth = curlevel->depth;\n      break;\n    case HWLOC_OBJ_SYSTEM:\n    case HWLOC_OBJ_BRIDGE:\n    case HWLOC_OBJ_PCI_DEVICE:\n    case HWLOC_OBJ_OS_DEVICE:\n      abort();\n      break;\n    case HWLOC_OBJ_MACHINE:\n      break;\n    case HWLOC_OBJ_NODE:\n      /* 1GB in memory nodes, 256k 4k-pages.  */\n      obj->memory.local_memory = 1024*1024*1024;\n      obj->memory.page_types_len = 1;\n      obj->memory.page_types = malloc(sizeof(*obj->memory.page_types));\n      memset(obj->memory.page_types, 0, sizeof(*obj->memory.page_types));\n      obj->memory.page_types[0].size = 4096;\n      obj->memory.page_types[0].count = 256*1024;\n      break;\n    case HWLOC_OBJ_SOCKET:\n      break;\n    case HWLOC_OBJ_CACHE:\n      obj->attr->cache.depth = curlevel->depth;\n      obj->attr->cache.linesize = 64;\n      obj->attr->cache.type = curlevel->cachetype;\n      if (obj->attr->cache.depth == 1) {\n\t/* 32Kb in L1d */\n\tobj->attr->cache.size = 32*1024;\n      } else {\n\t/* *4 at each level, starting from 1MB for L2, unified */\n\tobj->attr->cache.size = 256*1024 << (2*obj->attr->cache.depth);\n      }\n      break;\n    case HWLOC_OBJ_CORE:\n      break;\n    case HWLOC_OBJ_PU:\n      break;\n    case HWLOC_OBJ_MISC:\n    case HWLOC_OBJ_TYPE_MAX:\n      /* Should never happen */\n      assert(0);\n      break;\n  }\n  hwloc_insert_object_by_cpuset(topology, obj);\n  return first_cpu;\n"]]}
{"hexsha": "a7d23e95b9fb766067571c4bfbddd0a6d429ca85", "ext": "c", "lang": "C", "content": "comcryptReturn deComcryptData(\n\tcomcryptObj \t\t\tcobj,\n\tunsigned char \t\t\t*cipherText,\n\tunsigned \t\t\t\tcipherTextLen,\n\tunsigned char \t\t\t*plainText,\n\tunsigned\t \t\t\t*plainTextLen,\t// IN/OUT\n\tcomcryptEos \t\t\tendOfStream) \t// CCE_END_OF_STREAM, etc.\n\n{\n\tcomcryptPriv\t*cpriv = (comcryptPriv *)cobj;\n    unsigned char \t*outorigin = plainText;\n\tunsigned\t\tptextLen = *plainTextLen;\n\tunsigned\t\tthisPtext;\t\t\t\t// per block\n\tunsigned\t\tblockSize;\n\tdcbReturn\t\tdrtn;\n\tunsigned \t\tctextUsed;\n\n\t/*\n\t * Snag version from ciphertext, or as much as we can get\n\t */\n\twhile((cpriv->versionBytes < VERSION_BYTES) && cipherTextLen) {\n\t\tcpriv->version <<= 8;\n\t\tcpriv->version |= *cipherText;\n\t\tcpriv->versionBytes++;\n\t\tcipherText++;\n\t\tcipherTextLen--;\n\t}\n\n\t/*\n\t * Then skip over the remainder of the header (currently spares)\n\t */\n\tif((cpriv->spareBytes < SPARE_BYTES) && cipherTextLen) {\n\t\tunsigned toSkip = SPARE_BYTES - cpriv->spareBytes;\n\n\t\tif(toSkip > cipherTextLen) {\n\t\t\ttoSkip = cipherTextLen;\n\t\t}\n\t\tcpriv->spareBytes += toSkip;\n\t\tcipherText += toSkip;\n\t\tcipherTextLen -= toSkip;\n\t}\n\n\tif(cipherTextLen == 0) {\n\t\t*plainTextLen = 0;\n\t\treturn CCR_SUCCESS;\n\t}\n\n    if(cpriv->version != VERSION_3_Dec_97) {\n    \tddprintf((\"Incompatible version.\\n\"));\n\t\treturn CCR_BAD_CIPHERTEXT;\n    }\n\n\twhile(cipherTextLen != 0) {\n\n\t\t/*\n\t\t * Main loop. First deal with possible existing partial block.\n\t\t */\n\t\tif(cpriv->cbuf.codeBufLength != 0) {\n\t\t\tunsigned toCopy =\n\t\t\t\tcpriv->cbuf.codeBufSize - cpriv->cbuf.codeBufLength;\n\t\t\tunsigned origBufSize = cpriv->cbuf.codeBufLength;\n\n\t\t\tif(toCopy > cipherTextLen) {\n\t\t\t\ttoCopy = cipherTextLen;\n\t\t\t}\n\t\t\tmemmove(cpriv->cbuf.codeBuf + cpriv->cbuf.codeBufLength,\n\t\t\t\tcipherText, toCopy);\n\t\t\tcpriv->cbuf.codeBufLength += toCopy;\n\n\t\t\tthisPtext = ptextLen;\n\t\t\tdrtn = deComcryptBlock(cpriv,\n\t\t\t\t&cpriv->cbuf,\n\t\t\t\tcpriv->cbuf.codeBuf,\n\t\t\t\tcpriv->cbuf.codeBufLength,\n\t\t\t\tplainText,\n\t\t\t\t&thisPtext,\n\t\t\t\tendOfStream,\n\t\t\t\t&blockSize);\n\t\t\tswitch(drtn) {\n\t\t\t\tcase DCB_SHORT:\n\t\t\t\t\t/*\n\t\t\t\t\t * Incomplete block in codeBuf\n\t\t\t\t\t */\n\t\t\t\t\tif(endOfStream == CCE_END_OF_STREAM) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Caller thinks this is the end, but we need more\n\t\t\t\t\t\t */\n\t\t\t\t\t\tddprintf((\"deComcryptData(): CCE_END_OF_STREAM, \"\n\t\t\t\t\t\t\t\"not end of block\\n\"));\n\t\t\t\t\t\treturn CCR_BAD_CIPHERTEXT;\n\t\t\t\t\t}\n\t\t\t\t\tcipherTextLen -= toCopy;\n\t\t\t\t\tif(cipherTextLen != 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * i.e., codeBuf overflow - could be s/w error? Do\n\t\t\t\t\t\t * we need a bigger buffer?\n\t\t\t\t\t\t */\n\t\t\t\t\t\tddprintf((\"deComcryptData: full codeBuf, incomplete \"\n\t\t\t\t\t\t\t\"block\\n\"));\n\t\t\t\t\t\treturn CCR_BAD_CIPHERTEXT;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * OK, stash it and try again\n\t\t\t\t\t\t */\n\t\t\t\t\t\tscprintf((\"====incomplete codeBuf, codeBufLength %d, \"\n\t\t\t\t\t\t\t\"cipherTextLen %d\\n\",\n\t\t\t\t\t\t\tcpriv->cbuf.codeBufLength, toCopy));\n\t\t\t\t\t\tbreak;\t\t// out of main loop (after this switch)\n\t\t\t\t\t}\n\n\t\t\t\tcase DCB_OUTBUFFER_TOO_SMALL:\n\t\t\t\t\tddprintf((\"codeBuf decomcrypt error short buf\\n\"));\n\t\t\t\t\treturn CCR_OUTBUFFER_TOO_SMALL;\n\t\t\t\t\t\n\t\t\t\tcase DCB_PARSE_ERROR:\n\t\t\t\tdefault:\n\t\t\t\t\tddprintf((\"codeBuf decomcrypt error (%d)\\n\", drtn));\n\t\t\t\t\treturn CCR_BAD_CIPHERTEXT;\n\n\t\t\t\tcase DCB_SUCCESS:\n\t\t\t\t\t/*\n\t\t\t\t\t * ctextUsed is how much of caller's ciphertext we used\n\t\t\t\t\t * in this buffered block\n\t\t\t\t\t */\n\t\t\t\t\tctextUsed = blockSize - origBufSize;\n\t\t\t\t\tscprintf((\"====decrypted block in codeBuf, blockSize %d, \"\n\t\t\t\t\t\t\"ctextUsed %d, thisPtext %d\\n\",\n\t\t\t\t\t\tblockSize, ctextUsed, thisPtext));\n\t\t\t\t\tcipherText    += ctextUsed;\n\t\t\t\t\tcipherTextLen -= ctextUsed;\n\t\t\t\t\tplainText     += thisPtext;\n\t\t\t\t\tptextLen      -= thisPtext;\n\t\t\t\t\tcpriv->cbuf.codeBufLength = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We might have used up all of caller's cipherText processing\n\t\t\t * codeBuf...\n\t\t\t */\n\t\t\tif(cipherTextLen == 0) {\n\t\t\t\tbreak;\t\t\t\t// out of main loop\n\t\t\t}\n\n\t\t}\t/* buffered ciphertext in codeBuf */\n\n\t\t/*\n\t\t * Snarf ciphertext, one block at a time.\n\t\t */\n\n\t\tthisPtext = ptextLen;\n\t\tdrtn = deComcryptBlock(cpriv,\n\t\t\t&cpriv->cbuf,\n\t\t\tcipherText,\n\t\t\tcipherTextLen,\n\t\t\tplainText,\n\t\t\t&thisPtext,\n\t\t\tendOfStream,\n\t\t\t&blockSize);\n\t\tswitch(drtn) {\n\t\t\tcase DCB_SHORT:\n\t\t\t\t/*\n\t\t\t\t * Incomplete block\n\t\t\t\t */\n\t\t\t\tif(endOfStream == CCE_END_OF_STREAM) {\n\t\t\t\t\tddprintf((\"deComcryptData(): CCE_END_OF_STREAM, not end of \"\n\t\t\t\t\t\t\"block (2)\\n\"));\n\t\t\t\t\treturn CCR_BAD_CIPHERTEXT;\n\t\t\t\t}\n\t\t\t\tif(cipherTextLen >\n\t\t\t\t       (cpriv->cbuf.codeBufSize - cpriv->cbuf.codeBufLength)) {\n\t\t\t\t\tddprintf((\"deComcryptData(): codeBuf overflow!\\n\"));\n\t\t\t\t\treturn CCR_BAD_CIPHERTEXT;\n\t\t\t\t}\n\t\t\t\tmemmove(cpriv->cbuf.codeBuf + cpriv->cbuf.codeBufLength,\n\t\t\t\t\tcipherText, cipherTextLen);\n\t\t\t\tcpriv->cbuf.codeBufLength += cipherTextLen;\n\t\t\t\tcipherTextLen = 0;\n\t\t\t\tscprintf((\"====Incomplete block, cipherTextLen %d \"\n\t\t\t\t\t\"codeBufLength %d\\n\", cipherTextLen,\n\t\t\t\t\tcpriv->cbuf.codeBufLength));\n\t\t\t\tbreak;\t\t// actually out of main loop\n\n\t\t    case DCB_PARSE_ERROR:\n\t\t\tcase DCB_OUTBUFFER_TOO_SMALL:\n\t\t\tdefault:\n\t\t\t\treturn CCR_BAD_CIPHERTEXT;\n\n\t\t\tcase DCB_SUCCESS:\n\t\t\t\tif(ptextLen < thisPtext) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Software error\n\t\t\t\t\t */\n\t\t\t\t\tddprintf((\"deComcryptData: undetected ptext \"\n\t\t\t\t\t\t\"overflow (2)\\n\"));\n\t\t\t\t\treturn CCR_BAD_CIPHERTEXT;\n\t\t\t\t}\n\t\t\t\tplainText     += thisPtext;\n\t\t\t\tptextLen      -= thisPtext;\n\t\t\t\tcipherText    += blockSize;\n\t\t\t\tcipherTextLen -= blockSize;\n\t\t\t\tscprintf((\"====decrypted one block, blockSize %d \"\n\t\t\t\t\t\"thisPtext %d\\n\", blockSize, thisPtext));\n\t\t\t\tbreak;\n\t\t}\n\t}\t/* main loop */\n\n\t*plainTextLen = (unsigned)(plainText - outorigin);\n\treturn CCR_SUCCESS;\n}", "item_id": 8, "repo": "GaloisInc/hacrypto", "file": "src/C/Security-57031.40.6/Security/libsecurity_comcryption/lib/comcryption.c", "last_update_at": "2020-11-10T06:45:28+00:00", "question_id": "a7d23e95b9fb766067571c4bfbddd0a6d429ca85_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["comcryptReturn deComcryptData(\n\tcomcryptObj \t\t\tcobj,\n\tunsigned char \t\t\t*cipherText,\n\tunsigned \t\t\t\tcipherTextLen,\n\tunsigned char \t\t\t*plainText,\n\tunsigned\t \t\t\t*plainTextLen,\t// IN/OUT\n\tcomcryptEos \t\t\tendOfStream) \t// CCE_END_OF_STREAM, etc.\n{\n\tcomcryptPriv\t*cpriv = (comcryptPriv *)cobj;\n    unsigned char \t*outorigin = plainText;\n\tunsigned\t\tptextLen = *plainTextLen;\n\tunsigned\t\tthisPtext;\t\t\t\t// per block\n\tunsigned\t\tblockSize;\n\tdcbReturn\t\tdrtn;\n\tunsigned \t\tctextUsed;\n\t/*\n\t * Snag version from ciphertext, or as much as we can get\n\t */\n\twhile((cpriv->versionBytes < VERSION_BYTES) && cipherTextLen) {\n\t\tcpriv->version <<= 8;\n\t\tcpriv->version |= *cipherText;\n\t\tcpriv->versionBytes++;\n\t\tcipherText++;\n\t\tcipherTextLen--;\n\t}\n\t/*\n\t * Then skip over the remainder of the header (currently spares)\n\t */\n\tif((cpriv->spareBytes < SPARE_BYTES) && cipherTextLen) {\n\t\tunsigned toSkip = SPARE_BYTES - cpriv->spareBytes;\n\t\tif(toSkip > cipherTextLen) {\n\t\t\ttoSkip = cipherTextLen;\n\t\t}\n\t\tcpriv->spareBytes += toSkip;\n\t\tcipherText += toSkip;\n\t\tcipherTextLen -= toSkip;\n\t}\n\tif(cipherTextLen == 0) {\n\t\t*plainTextLen = 0;\n\t\treturn CCR_SUCCESS;\n\t}\n    if(cpriv->version != VERSION_3_Dec_97) {\n    \tddprintf((\"Incompatible version.\\n\"));\n\t\treturn CCR_BAD_CIPHERTEXT;\n    }\n\twhile(cipherTextLen != 0) {\n\t\t/*\n\t\t * Main loop. First deal with possible existing partial block.\n\t\t */\n\t\tif(cpriv->cbuf.codeBufLength != 0) {\n\t\t\tunsigned toCopy =\n\t\t\t\tcpriv->cbuf.codeBufSize - cpriv->cbuf.codeBufLength;\n\t\t\tunsigned origBufSize = cpriv->cbuf.codeBufLength;\n\t\t\tif(toCopy > cipherTextLen) {\n\t\t\t\ttoCopy = cipherTextLen;\n\t\t\t}\n\t\t\tmemmove(cpriv->cbuf.codeBuf + cpriv->cbuf.codeBufLength,\n\t\t\t\tcipherText, toCopy);\n\t\t\tcpriv->cbuf.codeBufLength += toCopy;\n\t\t\tthisPtext = ptextLen;\n\t\t\tdrtn = deComcryptBlock(cpriv,\n\t\t\t\t&cpriv->cbuf,\n\t\t\t\tcpriv->cbuf.codeBuf,\n\t\t\t\tcpriv->cbuf.codeBufLength,\n\t\t\t\tplainText,\n\t\t\t\t&thisPtext,\n\t\t\t\tendOfStream,\n\t\t\t\t&blockSize);\n\t\t\tswitch(drtn) {\n\t\t\t\tcase DCB_SHORT:\n\t\t\t\t\t/*\n\t\t\t\t\t * Incomplete block in codeBuf\n\t\t\t\t\t */\n\t\t\t\t\tif(endOfStream == CCE_END_OF_STREAM) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Caller thinks this is the end, but we need more\n\t\t\t\t\t\t */\n\t\t\t\t\t\tddprintf((\"deComcryptData(): CCE_END_OF_STREAM, \"\n\t\t\t\t\t\t\t\"not end of block\\n\"));\n\t\t\t\t\t\treturn CCR_BAD_CIPHERTEXT;\n\t\t\t\t\t}\n\t\t\t\t\tcipherTextLen -= toCopy;\n\t\t\t\t\tif(cipherTextLen != 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * i.e., codeBuf overflow - could be s/w error? Do\n\t\t\t\t\t\t * we need a bigger buffer?\n\t\t\t\t\t\t */\n\t\t\t\t\t\tddprintf((\"deComcryptData: full codeBuf, incomplete \"\n\t\t\t\t\t\t\t\"block\\n\"));\n\t\t\t\t\t\treturn CCR_BAD_CIPHERTEXT;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * OK, stash it and try again\n\t\t\t\t\t\t */\n\t\t\t\t\t\tscprintf((\"====incomplete codeBuf, codeBufLength %d, \"\n\t\t\t\t\t\t\t\"cipherTextLen %d\\n\",\n\t\t\t\t\t\t\tcpriv->cbuf.codeBufLength, toCopy));\n\t\t\t\t\t\tbreak;\t\t// out of main loop (after this switch)\n\t\t\t\t\t}\n\t\t\t\tcase DCB_OUTBUFFER_TOO_SMALL:\n\t\t\t\t\tddprintf((\"codeBuf decomcrypt error short buf\\n\"));\n\t\t\t\t\treturn CCR_OUTBUFFER_TOO_SMALL;\n\t\t\t\t\t\n\t\t\t\tcase DCB_PARSE_ERROR:\n\t\t\t\tdefault:\n\t\t\t\t\tddprintf((\"codeBuf decomcrypt error (%d)\\n\", drtn));\n\t\t\t\t\treturn CCR_BAD_CIPHERTEXT;\n\t\t\t\tcase DCB_SUCCESS:\n\t\t\t\t\t/*\n\t\t\t\t\t * ctextUsed is how much of caller's ciphertext we used\n\t\t\t\t\t * in this buffered block\n\t\t\t\t\t */\n\t\t\t\t\tctextUsed = blockSize - origBufSize;\n\t\t\t\t\tscprintf((\"====decrypted block in codeBuf, blockSize %d, \"\n\t\t\t\t\t\t\"ctextUsed %d, thisPtext %d\\n\",\n\t\t\t\t\t\tblockSize, ctextUsed, thisPtext));\n\t\t\t\t\tcipherText    += ctextUsed;\n\t\t\t\t\tcipherTextLen -= ctextUsed;\n\t\t\t\t\tplainText     += thisPtext;\n\t\t\t\t\tptextLen      -= thisPtext;\n\t\t\t\t\tcpriv->cbuf.codeBufLength = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We might have used up all of caller's cipherText processing\n\t\t\t * codeBuf...\n\t\t\t */\n\t\t\tif(cipherTextLen == 0) {\n\t\t\t\tbreak;\t\t\t\t// out of main loop\n\t\t\t}\n\t\t}\t/* buffered ciphertext in codeBuf */\n\t\t/*\n\t\t * Snarf ciphertext, one block at a time.\n\t\t */\n\t\tthisPtext = ptextLen;\n\t\tdrtn = deComcryptBlock(cpriv,\n\t\t\t&cpriv->cbuf,\n\t\t\tcipherText,\n\t\t\tcipherTextLen,\n\t\t\tplainText,\n\t\t\t&thisPtext,\n\t\t\tendOfStream,\n\t\t\t&blockSize);\n\t\tswitch(drtn) {\n\t\t\tcase DCB_SHORT:\n\t\t\t\t/*\n\t\t\t\t * Incomplete block\n\t\t\t\t */\n\t\t\t\tif(endOfStream == CCE_END_OF_STREAM) {\n\t\t\t\t\tddprintf((\"deComcryptData(): CCE_END_OF_STREAM, not end of \"\n\t\t\t\t\t\t\"block (2)\\n\"));\n\t\t\t\t\treturn CCR_BAD_CIPHERTEXT;\n\t\t\t\t}\n\t\t\t\tif(cipherTextLen >\n\t\t\t\t       (cpriv->cbuf.codeBufSize - cpriv->cbuf.codeBufLength)) {\n\t\t\t\t\tddprintf((\"deComcryptData(): codeBuf overflow!\\n\"));\n\t\t\t\t\treturn CCR_BAD_CIPHERTEXT;\n\t\t\t\t}\n\t\t\t\tmemmove(cpriv->cbuf.codeBuf + cpriv->cbuf.codeBufLength,\n\t\t\t\t\tcipherText, cipherTextLen);\n\t\t\t\tcpriv->cbuf.codeBufLength += cipherTextLen;\n\t\t\t\tcipherTextLen = 0;\n\t\t\t\tscprintf((\"====Incomplete block, cipherTextLen %d \"\n\t\t\t\t\t\"codeBufLength %d\\n\", cipherTextLen,\n\t\t\t\t\tcpriv->cbuf.codeBufLength));\n\t\t\t\tbreak;\t\t// actually out of main loop\n\t\t    case DCB_PARSE_ERROR:\n\t\t\tcase DCB_OUTBUFFER_TOO_SMALL:\n\t\t\tdefault:\n\t\t\t\treturn CCR_BAD_CIPHERTEXT;\n\t\t\tcase DCB_SUCCESS:\n\t\t\t\tif(ptextLen < thisPtext) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Software error\n\t\t\t\t\t */\n\t\t\t\t\tddprintf((\"deComcryptData: undetected ptext \"\n\t\t\t\t\t\t\"overflow (2)\\n\"));\n\t\t\t\t\treturn CCR_BAD_CIPHERTEXT;\n\t\t\t\t}\n\t\t\t\tplainText     += thisPtext;\n\t\t\t\tptextLen      -= thisPtext;\n\t\t\t\tcipherText    += blockSize;\n\t\t\t\tcipherTextLen -= blockSize;\n\t\t\t\tscprintf((\"====decrypted one block, blockSize %d \"\n\t\t\t\t\t\"thisPtext %d\\n\", blockSize, thisPtext));\n\t\t\t\tbreak;\n\t\t}\n\t}\t/* main loop */\n\t*plainTextLen = (unsigned)(plainText - outorigin);\n\treturn CCR_SUCCESS;\n"]]}
{"hexsha": "6d971bad31f6eeb8ae105a649d8e8b947080a663", "ext": "h", "lang": "C", "content": "class opaque_sampler\n{\npublic:\n    opaque_sampler(int width, int sampled_width, unsigned int sample_size, bool filter, const pixel_format& format);\n    virtual ~opaque_sampler();\n\n    virtual bool sample(const unsigned char* pixels, int offset, unsigned char* out);\n    void finish(unsigned char* out);\n\nprotected:\n    unsigned int* m_red;\n    unsigned int* m_green;\n    unsigned int* m_blue;\n    unsigned int m_sample_size;\n    unsigned int m_shift_count_2;\n    unsigned int m_shift_count;\n    int m_width;\n    int m_sampled_width;\n    int m_remainder;\n    int m_rows;\n    bool m_filter;\n    pixel_composer m_composer;\n\n    virtual int get_bytes_per_pixel();\n    virtual void emit_square(unsigned char* out);\n    virtual void emit(unsigned char* out);\n\n    static unsigned int get_shift_count(unsigned int n);\n}", "item_id": 0, "repo": "raulhaag/RapidDecoder", "file": "builtin-decoder-common/sampler.h", "last_update_at": "2020-04-26T02:20:54+00:00", "question_id": "6d971bad31f6eeb8ae105a649d8e8b947080a663_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class opaque_sampler\n{\npublic:\n    opaque_sampler(int width, int sampled_width, unsigned int sample_size, bool filter, const pixel_format& format);\n    virtual ~opaque_sampler();\n    virtual bool sample(const unsigned char* pixels, int offset, unsigned char* out);\n    void finish(unsigned char* out);\nprotected:\n    unsigned int* m_red;\n    unsigned int* m_green;\n    unsigned int* m_blue;\n    unsigned int m_sample_size;\n    unsigned int m_shift_count_2;\n    unsigned int m_shift_count;\n    int m_width;\n    int m_sampled_width;\n    int m_remainder;\n    int m_rows;\n    bool m_filter;\n    pixel_composer m_composer;\n    virtual int get_bytes_per_pixel();\n    virtual void emit_square(unsigned char* out);\n    virtual void emit(unsigned char* out);\n    static unsigned int get_shift_count(unsigned int n);\n"]]}
{"hexsha": "d4e01ea9f3b5c359b0ee8f9990fa34248011dc48", "ext": "h", "lang": "C", "content": "static inline HI_VOID isp_dpc_line_thresh_2_u32_write(S_ISPBE_REGS_TYPE *pstBeReg, HI_U32 uIspDpcLineThr2G, HI_U32 uIspDpcLineThr2Rb)\n{\n    U_ISP_DPC_LINE_THRESH_2 o_isp_dpc_line_thresh_2;\n    o_isp_dpc_line_thresh_2.bits.isp_dpc_line_thr2_g = uIspDpcLineThr2G;\n    o_isp_dpc_line_thresh_2.bits.isp_dpc_line_thr2_rb = uIspDpcLineThr2Rb;\n    pstBeReg->ISP_DPC_LINE_THRESH_2.u32 = o_isp_dpc_line_thresh_2.u32;\n}", "item_id": 216, "repo": "werringwu/TeamX4", "file": "mpp/component/isp/user/firmware/arch/hi3516ev200/include/isp_config_u32.h", "last_update_at": "2020-09-24T10:26:09+00:00", "question_id": "d4e01ea9f3b5c359b0ee8f9990fa34248011dc48_216", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline HI_VOID isp_dpc_line_thresh_2_u32_write(S_ISPBE_REGS_TYPE *pstBeReg, HI_U32 uIspDpcLineThr2G, HI_U32 uIspDpcLineThr2Rb)\n{\n    U_ISP_DPC_LINE_THRESH_2 o_isp_dpc_line_thresh_2;\n    o_isp_dpc_line_thresh_2.bits.isp_dpc_line_thr2_g = uIspDpcLineThr2G;\n    o_isp_dpc_line_thresh_2.bits.isp_dpc_line_thr2_rb = uIspDpcLineThr2Rb;\n    pstBeReg->ISP_DPC_LINE_THRESH_2.u32 = o_isp_dpc_line_thresh_2.u32;\n"]]}
{"hexsha": "5af82e808c4bf7ee73cf5fd248f405ee969a7b67", "ext": "c", "lang": "C", "content": "void ulver_hub_wait(ulver_env *env, ulver_coro *coro) {\n\tulver_thread *ut = ulver_current_thread(env);\n\t// add the current coro as a a waiting one\n\tut->current_coro->waiting_for = coro;\n\tulver_coro_switch(env, ut->hub);\n}", "item_id": 8, "repo": "unbit/ulver", "file": "src/hub.c", "last_update_at": "2020-10-12T10:52:03+00:00", "question_id": "5af82e808c4bf7ee73cf5fd248f405ee969a7b67_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void ulver_hub_wait(ulver_env *env, ulver_coro *coro) {\n\tulver_thread *ut = ulver_current_thread(env);\n\t// add the current coro as a a waiting one\n\tut->current_coro->waiting_for = coro;\n\tulver_coro_switch(env, ut->hub);\n"]]}
{"hexsha": "d180416590501365fda07cc955d1e4e94b497501", "ext": "c", "lang": "C", "content": "static void thread_bsp_init(void)\r\n{\r\n    uint32_t error_code = bsp_init(BSP_INIT_LEDS | BSP_INIT_BUTTONS, bsp_event_handler);\r\n    APP_ERROR_CHECK(error_code);\r\n\r\n    error_code = bsp_thread_init(thread_ot_instance_get());\r\n    APP_ERROR_CHECK(error_code);\r\n}", "item_id": 12, "repo": "zbennis/hetida4office", "file": "edge/co2sensor/firmware/nRF5_SDK_for_Thread_and_Zigbee_v4.1.0_32ce5f8/examples/thread/cloud/google_iot_coap/main.c", "last_update_at": "2020-11-14T19:19:31+00:00", "question_id": "d180416590501365fda07cc955d1e4e94b497501_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void thread_bsp_init(void)\r\n{\r\n    uint32_t error_code = bsp_init(BSP_INIT_LEDS | BSP_INIT_BUTTONS, bsp_event_handler);\r\n    APP_ERROR_CHECK(error_code);\r\n\r\n    error_code = bsp_thread_init(thread_ot_instance_get());\r\n    APP_ERROR_CHECK(error_code);\r\n"]]}
{"hexsha": "ce40be96d3ac9462427bd0e9d83dc301b3922933", "ext": "c", "lang": "C", "content": "int\n__db_slice_remove(dbenv, txn, name, subdb, flags)\n\tDB_ENV *dbenv;\n\tDB_TXN *txn;\n\tconst char *name;\n\tconst char *subdb;\n\tu_int32_t flags;\n{\n\tDB_ENV *slice;\n\tDB_TXN *sl_txn;\n\tENV *env;\n\tint i, ret, t_ret;\n\tu_int32_t metaflags;\n\n\t/* Slices do not handle sub-databases. */\n\tif (subdb != NULL)\n\t\treturn (0);\n\n\tenv = dbenv->env;\n\t/* This function is a nop if the db is not sliced. */\n\tif ((ret = __db_get_metaflags(env, name, &metaflags)) != 0)\n\t\treturn (ret);\n\tif (!FLD_ISSET(metaflags, DBMETA_SLICED))\n\t\treturn (0);\n\t/* Return an error if removing a sliced db from a non-sliced env. */\n\tif (!SLICES_ON(env))\n\t\treturn (__env_not_sliced(env));\n\n\tfor (i = -1; (slice = __slice_iterate(dbenv, &i)) != NULL; ) {\n\t\tif ((t_ret =\n\t\t    __txn_slice_begin(txn, &sl_txn, (db_slice_t)i)) != 0 ||\n\t\t    (t_ret = __env_dbremove_pp(slice,\n\t\t    sl_txn, name, subdb, flags)) != 0) {\n\t\t\t/*\n\t\t\t * Until cross slice DDL operations are atomic, any\n\t\t\t * missing files do not return an error code.\n\t\t\t */\n\t\t\tif (t_ret == ENOENT)\n\t\t\t\tcontinue;\n\t\t\t__db_err(env, t_ret, \"dbremove #%d %s\", i, name);\n\t\t\t/*\n\t\t\t * Suppress missing files in slice directories;\n\t\t\t * cross-slice DDL isn't atomic.\n\t\t\t */\n\t\t\tif (ret == 0)\n\t\t\t\tret = USR_ERR(env, DB_SLICE_CORRUPT);\n\t\t}\n\t}\n\treturn (ret);\n}", "item_id": 30, "repo": "secondwatchCH/JinCoin", "file": "db-6.2.32.NC/src/db/db_slice.c", "last_update_at": "2020-11-04T06:58:34+00:00", "question_id": "ce40be96d3ac9462427bd0e9d83dc301b3922933_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\n__db_slice_remove(dbenv, txn, name, subdb, flags)\n\tDB_ENV *dbenv;\n\tDB_TXN *txn;\n\tconst char *name;\n\tconst char *subdb;\n\tu_int32_t flags;\n{\n\tDB_ENV *slice;\n\tDB_TXN *sl_txn;\n\tENV *env;\n\tint i, ret, t_ret;\n\tu_int32_t metaflags;\n\t/* Slices do not handle sub-databases. */\n\tif (subdb != NULL)\n\t\treturn (0);\n\tenv = dbenv->env;\n\t/* This function is a nop if the db is not sliced. */\n\tif ((ret = __db_get_metaflags(env, name, &metaflags)) != 0)\n\t\treturn (ret);\n\tif (!FLD_ISSET(metaflags, DBMETA_SLICED))\n\t\treturn (0);\n\t/* Return an error if removing a sliced db from a non-sliced env. */\n\tif (!SLICES_ON(env))\n\t\treturn (__env_not_sliced(env));\n\tfor (i = -1; (slice = __slice_iterate(dbenv, &i)) != NULL; ) {\n\t\tif ((t_ret =\n\t\t    __txn_slice_begin(txn, &sl_txn, (db_slice_t)i)) != 0 ||\n\t\t    (t_ret = __env_dbremove_pp(slice,\n\t\t    sl_txn, name, subdb, flags)) != 0) {\n\t\t\t/*\n\t\t\t * Until cross slice DDL operations are atomic, any\n\t\t\t * missing files do not return an error code.\n\t\t\t */\n\t\t\tif (t_ret == ENOENT)\n\t\t\t\tcontinue;\n\t\t\t__db_err(env, t_ret, \"dbremove #%d %s\", i, name);\n\t\t\t/*\n\t\t\t * Suppress missing files in slice directories;\n\t\t\t * cross-slice DDL isn't atomic.\n\t\t\t */\n\t\t\tif (ret == 0)\n\t\t\t\tret = USR_ERR(env, DB_SLICE_CORRUPT);\n\t\t}\n\t}\n\treturn (ret);\n"]]}
{"hexsha": "9e773ff14a12ede8cf195c57430978627878503b", "ext": "c", "lang": "C", "content": "esp_dispatcher_handle_t esp_dispatcher_create(esp_dispatcher_config_t *cfg)\n{\n    AUDIO_NULL_CHECK(TAG, cfg, return NULL);\n    esp_dispatcher_handle_t impl = audio_calloc(1, sizeof(esp_dispatcher_t));\n    AUDIO_MEM_CHECK(TAG, impl, return NULL);\n    impl->result_que = xQueueCreate(1, sizeof(action_result_t));\n    AUDIO_MEM_CHECK(TAG, impl->result_que, goto _failed;);\n    impl->exe_que = xQueueCreate(ESP_DISPATCHER_EVENT_SIZE, sizeof(esp_dispatcher_info_t));\n    AUDIO_MEM_CHECK(TAG, impl->exe_que, goto _failed;);\n    impl->mutex = mutex_create();\n    AUDIO_MEM_CHECK(TAG, impl->mutex, goto _failed;);\n    STAILQ_INIT(&impl->exe_list);\n    ESP_LOGE(TAG, \"exe first list: %p\", STAILQ_FIRST(&impl->exe_list));\n\n    if (pdPASS != xTaskCreatePinnedToCore(dispatcher_event_task,\n                                          \"esp_dispatcher\",\n                                          cfg->task_stack,\n                                          impl,\n                                          cfg->task_prio,\n                                          &impl->task_handle,\n                                          cfg->task_core)) {\n        ESP_LOGE(TAG, \"Create task failed on %s\", __func__);\n        goto _failed;\n    }\n    return impl;\n_failed:\n    if (impl->result_que) {\n        vQueueDelete(impl->result_que);\n        impl->result_que = NULL;\n    }\n    if (impl->exe_que) {\n        vQueueDelete(impl->exe_que);\n        impl->exe_que = NULL;\n    }\n    if (impl->mutex) {\n        mutex_destroy(impl->mutex);\n        impl->mutex = NULL;\n    }\n    audio_free(impl);\n    impl = NULL;\n    return impl;\n}", "item_id": 5, "repo": "mbilloo/esp-idf", "file": "components/esp_dispatcher/esp_dispatcher.c", "last_update_at": "2020-05-12T23:30:41+00:00", "question_id": "9e773ff14a12ede8cf195c57430978627878503b_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["esp_dispatcher_handle_t esp_dispatcher_create(esp_dispatcher_config_t *cfg)\n{\n    AUDIO_NULL_CHECK(TAG, cfg, return NULL);\n    esp_dispatcher_handle_t impl = audio_calloc(1, sizeof(esp_dispatcher_t));\n    AUDIO_MEM_CHECK(TAG, impl, return NULL);\n    impl->result_que = xQueueCreate(1, sizeof(action_result_t));\n    AUDIO_MEM_CHECK(TAG, impl->result_que, goto _failed;);\n    impl->exe_que = xQueueCreate(ESP_DISPATCHER_EVENT_SIZE, sizeof(esp_dispatcher_info_t));\n    AUDIO_MEM_CHECK(TAG, impl->exe_que, goto _failed;);\n    impl->mutex = mutex_create();\n    AUDIO_MEM_CHECK(TAG, impl->mutex, goto _failed;);\n    STAILQ_INIT(&impl->exe_list);\n    ESP_LOGE(TAG, \"exe first list: %p\", STAILQ_FIRST(&impl->exe_list));\n    if (pdPASS != xTaskCreatePinnedToCore(dispatcher_event_task,\n                                          \"esp_dispatcher\",\n                                          cfg->task_stack,\n                                          impl,\n                                          cfg->task_prio,\n                                          &impl->task_handle,\n                                          cfg->task_core)) {\n        ESP_LOGE(TAG, \"Create task failed on %s\", __func__);\n        goto _failed;\n    }\n    return impl;\n_failed:\n    if (impl->result_que) {\n        vQueueDelete(impl->result_que);\n        impl->result_que = NULL;\n    }\n    if (impl->exe_que) {\n        vQueueDelete(impl->exe_que);\n        impl->exe_que = NULL;\n    }\n    if (impl->mutex) {\n        mutex_destroy(impl->mutex);\n        impl->mutex = NULL;\n    }\n    audio_free(impl);\n    impl = NULL;\n    return impl;\n"]]}
{"hexsha": "76562a7da975b1d201e3dd3cd8daf02cea150537", "ext": "c", "lang": "C", "content": "void  CPU_BitBandSet (CPU_ADDR    addr,\n                      CPU_INT08U  bit_nbr)\n{\n    CPU_ADDR  bit_word_off;\n    CPU_ADDR  bit_word_addr;\n\n\n    if ((addr >= CPU_BIT_BAND_SRAM_REG_LO) &&\n        (addr <= CPU_BIT_BAND_SRAM_REG_HI)) {\n        bit_word_off  = ((addr - CPU_BIT_BAND_SRAM_REG_LO  ) * 32) + (bit_nbr * 4);\n        bit_word_addr = CPU_BIT_BAND_SRAM_BASE   + bit_word_off;\n\n      *(volatile CPU_INT32U *)(bit_word_addr) = 1;\n\n    } else if ((addr >= CPU_BIT_BAND_PERIPH_REG_LO) &&\n               (addr <= CPU_BIT_BAND_PERIPH_REG_HI)) {\n        bit_word_off  = ((addr - CPU_BIT_BAND_PERIPH_REG_LO) * 32) + (bit_nbr * 4);\n        bit_word_addr = CPU_BIT_BAND_PERIPH_BASE + bit_word_off;\n\n      *(volatile CPU_INT32U *)(bit_word_addr) = 1;\n    }\n}", "item_id": 1, "repo": "umbraHare/STM32PRO", "file": "Drivers/uC-OS3/uC-CPU/ARM-Cortex-M/ARMv6-M/cpu_c.c", "last_update_at": "2020-11-29T01:26:06+00:00", "question_id": "76562a7da975b1d201e3dd3cd8daf02cea150537_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void  CPU_BitBandSet (CPU_ADDR    addr,\n                      CPU_INT08U  bit_nbr)\n{\n    CPU_ADDR  bit_word_off;\n    CPU_ADDR  bit_word_addr;\n    if ((addr >= CPU_BIT_BAND_SRAM_REG_LO) &&\n        (addr <= CPU_BIT_BAND_SRAM_REG_HI)) {\n        bit_word_off  = ((addr - CPU_BIT_BAND_SRAM_REG_LO  ) * 32) + (bit_nbr * 4);\n        bit_word_addr = CPU_BIT_BAND_SRAM_BASE   + bit_word_off;\n      *(volatile CPU_INT32U *)(bit_word_addr) = 1;\n    } else if ((addr >= CPU_BIT_BAND_PERIPH_REG_LO) &&\n               (addr <= CPU_BIT_BAND_PERIPH_REG_HI)) {\n        bit_word_off  = ((addr - CPU_BIT_BAND_PERIPH_REG_LO) * 32) + (bit_nbr * 4);\n        bit_word_addr = CPU_BIT_BAND_PERIPH_BASE + bit_word_off;\n      *(volatile CPU_INT32U *)(bit_word_addr) = 1;\n    }\n"]]}
{"hexsha": "7050b26ad17e4b2ae03081afc00b84ca1f5bc9df", "ext": "c", "lang": "C", "content": "static bool api_epm_Insert(pipes_struct *p)\n{\n\tconst struct ndr_interface_call *call;\n\tstruct ndr_pull *pull;\n\tstruct ndr_push *push;\n\tenum ndr_err_code ndr_err;\n\tDATA_BLOB blob;\n\tstruct epm_Insert *r;\n\n\tcall = &ndr_table_epmapper.calls[NDR_EPM_INSERT];\n\n\tr = talloc(talloc_tos(), struct epm_Insert);\n\tif (r == NULL) {\n\t\treturn false;\n\t}\n\n\tif (!prs_data_blob(&p->in_data.data, &blob, r)) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\n\tpull = ndr_pull_init_blob(&blob, r, NULL);\n\tif (pull == NULL) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\n\tpull->flags |= LIBNDR_FLAG_REF_ALLOC;\n\tndr_err = call->ndr_pull(pull, NDR_IN, r);\n\tif (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\n\tif (DEBUGLEVEL >= 10) {\n\t\tNDR_PRINT_IN_DEBUG(epm_Insert, r);\n\t}\n\n\tr->out.result = _epm_Insert(p, r);\n\n\tif (p->rng_fault_state) {\n\t\ttalloc_free(r);\n\t\t/* Return true here, srv_pipe_hnd.c will take care */\n\t\treturn true;\n\t}\n\n\tif (DEBUGLEVEL >= 10) {\n\t\tNDR_PRINT_OUT_DEBUG(epm_Insert, r);\n\t}\n\n\tpush = ndr_push_init_ctx(r, NULL);\n\tif (push == NULL) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\n\tndr_err = call->ndr_push(push, NDR_OUT, r);\n\tif (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\n\tblob = ndr_push_blob(push);\n\tif (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\n\ttalloc_free(r);\n\n\treturn true;\n}", "item_id": 0, "repo": "afeng11/tomato-arm", "file": "release/src-rt-6.x.4708/router/samba-3.5.8/librpc/gen_ndr/srv_epmapper.c", "last_update_at": "2020-05-24T07:23:26+00:00", "question_id": "7050b26ad17e4b2ae03081afc00b84ca1f5bc9df_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static bool api_epm_Insert(pipes_struct *p)\n{\n\tconst struct ndr_interface_call *call;\n\tstruct ndr_pull *pull;\n\tstruct ndr_push *push;\n\tenum ndr_err_code ndr_err;\n\tDATA_BLOB blob;\n\tstruct epm_Insert *r;\n\tcall = &ndr_table_epmapper.calls[NDR_EPM_INSERT];\n\tr = talloc(talloc_tos(), struct epm_Insert);\n\tif (r == NULL) {\n\t\treturn false;\n\t}\n\tif (!prs_data_blob(&p->in_data.data, &blob, r)) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\tpull = ndr_pull_init_blob(&blob, r, NULL);\n\tif (pull == NULL) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\tpull->flags |= LIBNDR_FLAG_REF_ALLOC;\n\tndr_err = call->ndr_pull(pull, NDR_IN, r);\n\tif (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\tif (DEBUGLEVEL >= 10) {\n\t\tNDR_PRINT_IN_DEBUG(epm_Insert, r);\n\t}\n\tr->out.result = _epm_Insert(p, r);\n\tif (p->rng_fault_state) {\n\t\ttalloc_free(r);\n\t\t/* Return true here, srv_pipe_hnd.c will take care */\n\t\treturn true;\n\t}\n\tif (DEBUGLEVEL >= 10) {\n\t\tNDR_PRINT_OUT_DEBUG(epm_Insert, r);\n\t}\n\tpush = ndr_push_init_ctx(r, NULL);\n\tif (push == NULL) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\tndr_err = call->ndr_push(push, NDR_OUT, r);\n\tif (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\tblob = ndr_push_blob(push);\n\tif (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\ttalloc_free(r);\n\treturn true;\n"]]}
{"hexsha": "d18844dfed35e8806c7ae0fc0edb034dcb56d5e0", "ext": "c", "lang": "C", "content": "static inline result_t markElementAsNotACKed_TinyDWFQ(TinyDWFQPtr queue, TOS_MsgPtr msg)\n{\n  int8_t ind;\n#line 700\n  int8_t prevIndex;\n  int8_t nextHead;\n\n#line 702\n  ind = queue->head[PENDING_TINYDWFQ];\n  prevIndex = ind;\n\n  while (ind != -1) \n    {\n      if (queue->element[ind].obj == msg) \n        {\n\n          nextHead = queue->element[ind].next;\n\n\n          queue->element[ind].status = NOT_ACKED_TINYDWFQ;\n          queue->element[ind].next = -1;\n          queue->numOfElements_pending--;\n\n\n          if (queue->head[NOT_ACKED_TINYDWFQ] == -1) \n            {\n\n              queue->head[NOT_ACKED_TINYDWFQ] = queue->tail[NOT_ACKED_TINYDWFQ] = ind;\n            }\n          else \n            {\n\n              queue->element[queue->tail[NOT_ACKED_TINYDWFQ]].next = ind;\n              queue->tail[NOT_ACKED_TINYDWFQ] = ind;\n            }\n          queue->numOfElements_notAcked++;\n\n\n          if (ind == queue->head[PENDING_TINYDWFQ]) \n            {\n\n              if (nextHead == -1) \n                {\n                  queue->head[PENDING_TINYDWFQ] = queue->tail[PENDING_TINYDWFQ] = -1;\n                }\n              else \n                {\n                  queue->head[PENDING_TINYDWFQ] = nextHead;\n                }\n            }\n          else {\n#line 744\n            if (ind == queue->tail[PENDING_TINYDWFQ]) \n              {\n\n                queue->tail[PENDING_TINYDWFQ] = prevIndex;\n                queue->element[prevIndex].next = -1;\n              }\n            else \n              {\n\n                queue->element[prevIndex].next = nextHead;\n              }\n            }\n#line 755\n          return SUCCESS;\n        }\n      else \n        {\n          prevIndex = ind;\n          ind = queue->element[ind].next;\n        }\n    }\n  return FAIL;\n}", "item_id": 290, "repo": "tinyos-io/tinyos-3.x-contrib", "file": "wsu/tools/XMonitor/oasis/apps/OasisApp/build/imote2/app.c", "last_update_at": "2020-02-28T20:35:09+00:00", "question_id": "d18844dfed35e8806c7ae0fc0edb034dcb56d5e0_290", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline result_t markElementAsNotACKed_TinyDWFQ(TinyDWFQPtr queue, TOS_MsgPtr msg)\n{\n  int8_t ind;\n#line 700\n  int8_t prevIndex;\n  int8_t nextHead;\n#line 702\n  ind = queue->head[PENDING_TINYDWFQ];\n  prevIndex = ind;\n  while (ind != -1) \n    {\n      if (queue->element[ind].obj == msg) \n        {\n          nextHead = queue->element[ind].next;\n          queue->element[ind].status = NOT_ACKED_TINYDWFQ;\n          queue->element[ind].next = -1;\n          queue->numOfElements_pending--;\n          if (queue->head[NOT_ACKED_TINYDWFQ] == -1) \n            {\n              queue->head[NOT_ACKED_TINYDWFQ] = queue->tail[NOT_ACKED_TINYDWFQ] = ind;\n            }\n          else \n            {\n              queue->element[queue->tail[NOT_ACKED_TINYDWFQ]].next = ind;\n              queue->tail[NOT_ACKED_TINYDWFQ] = ind;\n            }\n          queue->numOfElements_notAcked++;\n          if (ind == queue->head[PENDING_TINYDWFQ]) \n            {\n              if (nextHead == -1) \n                {\n                  queue->head[PENDING_TINYDWFQ] = queue->tail[PENDING_TINYDWFQ] = -1;\n                }\n              else \n                {\n                  queue->head[PENDING_TINYDWFQ] = nextHead;\n                }\n            }\n          else {\n#line 744\n            if (ind == queue->tail[PENDING_TINYDWFQ]) \n              {\n                queue->tail[PENDING_TINYDWFQ] = prevIndex;\n                queue->element[prevIndex].next = -1;\n              }\n            else \n              {\n                queue->element[prevIndex].next = nextHead;\n              }\n            }\n#line 755\n          return SUCCESS;\n        }\n      else \n        {\n          prevIndex = ind;\n          ind = queue->element[ind].next;\n        }\n    }\n  return FAIL;\n"]]}
{"hexsha": "f45c8ec2ff22307c3b69a00f19604a60eb2a73a3", "ext": "h", "lang": "C", "content": "ZEPHIR_INIT_FUNCS(zim_event_event_method_entry) {\n\tPHP_ME(Zim_Event_Event, fire, arginfo_zim_event_event_fire, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)\n\tPHP_ME(Zim_Event_Event, listen, arginfo_zim_event_event_listen, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)\n\tPHP_ME(Zim_Event_Event, on, arginfo_zim_event_event_on, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)\n\tPHP_FE_END\n};", "item_id": 0, "repo": "henter/zim-ext", "file": "ext/zim/event/event.zep.h", "last_update_at": "2020-01-19T09:56:33+00:00", "question_id": "f45c8ec2ff22307c3b69a00f19604a60eb2a73a3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ZEPHIR_INIT_FUNCS(zim_event_event_method_entry) {\n\tPHP_ME(Zim_Event_Event, fire, arginfo_zim_event_event_fire, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)\n\tPHP_ME(Zim_Event_Event, listen, arginfo_zim_event_event_listen, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)\n\tPHP_ME(Zim_Event_Event, on, arginfo_zim_event_event_on, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)\n\tPHP_FE_END\n"]]}
{"hexsha": "7751b83ec61c2d3c2ca184bc0ccc392af21db12d", "ext": "c", "lang": "C", "content": "int lcd_print_char(char ch, FILE *f) {\n    // wait for control\n    // note: we want to wrap the whole printf in the lcd_lock as well, so\n    // the text isn't interleaved... however we acquire here to yield while\n    // waiting\n    acquire(&lcd_lock);\n\n    if (lcdClearFlag) {\n        lcd_clear();\n        lcdClearFlag = 0;\n    }\n    if (lcdPos==0x20)\n        lcdPos = 0;\n    if (ch=='\\n')\n        lcdClearFlag = 1;\n    else {\n        if (lcdPos == 0x10)\n            lcdPosActual = 0xFF;\n        if (lcdContents[lcdPos] != ch) {\n            lcdContents[lcdPos] = ch;\n            if (lcdPosActual != lcdPos)\n                lcd_set_pos(lcdPos);\n            lcd_write(LCD_DATA, ch);\n            lcdPosActual++;\n        }\n        lcdPos++;\n    }\n\n    // give up control\n    release(&lcd_lock);\n    return ch;\n}", "item_id": 8, "repo": "viccro/andthebitches", "file": "src/drivers/lcd.c", "last_update_at": "2020-03-04T02:16:16+00:00", "question_id": "7751b83ec61c2d3c2ca184bc0ccc392af21db12d_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int lcd_print_char(char ch, FILE *f) {\n    // wait for control\n    // note: we want to wrap the whole printf in the lcd_lock as well, so\n    // the text isn't interleaved... however we acquire here to yield while\n    // waiting\n    acquire(&lcd_lock);\n    if (lcdClearFlag) {\n        lcd_clear();\n        lcdClearFlag = 0;\n    }\n    if (lcdPos==0x20)\n        lcdPos = 0;\n    if (ch=='\\n')\n        lcdClearFlag = 1;\n    else {\n        if (lcdPos == 0x10)\n            lcdPosActual = 0xFF;\n        if (lcdContents[lcdPos] != ch) {\n            lcdContents[lcdPos] = ch;\n            if (lcdPosActual != lcdPos)\n                lcd_set_pos(lcdPos);\n            lcd_write(LCD_DATA, ch);\n            lcdPosActual++;\n        }\n        lcdPos++;\n    }\n    // give up control\n    release(&lcd_lock);\n    return ch;\n"]]}
{"hexsha": "803bb58fe6266250b26f2b835bd1d643a7bb3d58", "ext": "c", "lang": "C", "content": "static CONST gattServiceCBs_t *gattServApp_FindServiceCBs( uint16 handle )\n{\n  serviceCBsList_t *pLoop = serviceCBsList;\n\n  while ( pLoop != NULL )\n  {\n    if ( pLoop->serviceInfo.handle == handle )\n    {\n      return ( pLoop->serviceInfo.pCBs );\n    }\n\n    // Try next service\n    pLoop = pLoop->next;\n  }\n\n  return ( (gattServiceCBs_t *)NULL );\n}", "item_id": 8, "repo": "sentervip/phy62xBleSDk2.0.1", "file": "PHY62XX_SDK_2.0.1/example/ble_peripheral/iBeacon/Source/gattservapp.c", "last_update_at": "2020-12-14T19:47:20+00:00", "question_id": "803bb58fe6266250b26f2b835bd1d643a7bb3d58_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static CONST gattServiceCBs_t *gattServApp_FindServiceCBs( uint16 handle )\n{\n  serviceCBsList_t *pLoop = serviceCBsList;\n  while ( pLoop != NULL )\n  {\n    if ( pLoop->serviceInfo.handle == handle )\n    {\n      return ( pLoop->serviceInfo.pCBs );\n    }\n    // Try next service\n    pLoop = pLoop->next;\n  }\n  return ( (gattServiceCBs_t *)NULL );\n"]]}
{"hexsha": "b35b57d86535d462fcab365db72e15bc95cd3108", "ext": "c", "lang": "C", "content": "static int\nfind_best_ufunc_inner_loop(PyUFuncObject *self,\n                        PyArrayObject **op,\n                        NPY_CASTING input_casting,\n                        NPY_CASTING output_casting,\n                        npy_intp buffersize,\n                        int any_object,\n                        PyArray_Descr **out_dtype,\n                        PyUFuncGenericFunction *out_innerloop,\n                        void **out_innerloopdata,\n                        int *out_trivial_loop_ok)\n{\n    npy_intp i, j, nin = self->nin, niter = nin + self->nout;\n    int types[NPY_MAXARGS];\n    char *ufunc_name;\n    int no_castable_output, all_inputs_scalar;\n\n    /* For making a better error message on coercion error */\n    char err_dst_typecode = '-', err_src_typecode = '-';\n\n    ufunc_name = self->name ? self->name : \"(unknown)\";\n\n    /* Check whether all the inputs are scalar */\n    all_inputs_scalar = 1;\n    for(i = 0; i < nin; ++i) {\n        if (PyArray_NDIM(op[i]) > 0) {\n            all_inputs_scalar = 0;\n        }\n    }\n\n    /* If the ufunc has userloops, search for them. */\n    if (self->userloops) {\n        switch (find_ufunc_matching_userloop(self, op,\n                                input_casting, output_casting,\n                                buffersize, any_object, all_inputs_scalar,\n                                out_dtype, out_innerloop, out_innerloopdata,\n                                out_trivial_loop_ok,\n                                &no_castable_output, &err_src_typecode,\n                                &err_dst_typecode)) {\n            /* Error */\n            case -1:\n                return -1;\n            /* A loop was found */\n            case 1:\n                return 0;\n        }\n    }\n\n    /*\n     * Determine the UFunc loop.  This could in general be *much* faster,\n     * and a better way to implement it might be for the ufunc to\n     * provide a function which gives back the result type and inner\n     * loop function.\n     *\n     * A default fast mechanism could be provided for functions which\n     * follow the most typical pattern, when all functions have signatures\n     * \"xx...x -> x\" for some built-in data type x, as follows.\n     *  - Use PyArray_ResultType to get the output type\n     *  - Look up the inner loop in a table based on the output type_num\n     *\n     * The method for finding the loop in the previous code did not\n     * appear consistent (as noted by some asymmetry in the generated\n     * coercion tables for np.add).\n     */\n    no_castable_output = 0;\n    for (i = 0; i < self->ntypes; ++i) {\n        char *orig_types = self->types + i*self->nargs;\n\n        /* Copy the types into an int array for matching */\n        for (j = 0; j < niter; ++j) {\n            types[j] = orig_types[j];\n        }\n\n        NPY_UF_DBG_PRINT1(\"Trying function loop %d\\n\", (int)i);\n        switch (ufunc_loop_matches(self, op,\n                    input_casting, output_casting,\n                    any_object, all_inputs_scalar,\n                    types,\n                    &no_castable_output, &err_src_typecode,\n                    &err_dst_typecode)) {\n            /* Error */\n            case -1:\n                return -1;\n            /* Found a match */\n            case 1:\n                set_ufunc_loop_data_types(self, op, out_dtype, types,\n                                    buffersize, out_trivial_loop_ok);\n\n                /* Save the inner loop and its data */\n                *out_innerloop = self->functions[i];\n                *out_innerloopdata = self->data[i];\n\n                NPY_UF_DBG_PRINT(\"Returning inner loop successfully\\n\");\n\n                return 0;\n        }\n\n    }\n\n    /* If no function was found, throw an error */\n    NPY_UF_DBG_PRINT(\"No loop was found\\n\");\n    if (no_castable_output) {\n        PyErr_Format(PyExc_TypeError,\n                \"ufunc '%s' output (typecode '%c') could not be coerced to \"\n                \"provided output parameter (typecode '%c') according \"\n                \"to the casting rule '%s'\",\n                ufunc_name, err_src_typecode, err_dst_typecode,\n                _casting_to_string(output_casting));\n    }\n    else {\n        /*\n         * TODO: We should try again if the casting rule is same_kind\n         *       or unsafe, and look for a function more liberally.\n         */\n        PyErr_Format(PyExc_TypeError,\n                \"ufunc '%s' not supported for the input types, and the \"\n                \"inputs could not be safely coerced to any supported \"\n                \"types according to the casting rule '%s'\",\n                ufunc_name,\n                _casting_to_string(input_casting));\n    }\n\n    return -1;\n}", "item_id": 15, "repo": "caoxof/numpy", "file": "numpy/core/src/umath/ufunc_object.c", "last_update_at": "2020-11-12T08:04:17+00:00", "question_id": "b35b57d86535d462fcab365db72e15bc95cd3108_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nfind_best_ufunc_inner_loop(PyUFuncObject *self,\n                        PyArrayObject **op,\n                        NPY_CASTING input_casting,\n                        NPY_CASTING output_casting,\n                        npy_intp buffersize,\n                        int any_object,\n                        PyArray_Descr **out_dtype,\n                        PyUFuncGenericFunction *out_innerloop,\n                        void **out_innerloopdata,\n                        int *out_trivial_loop_ok)\n{\n    npy_intp i, j, nin = self->nin, niter = nin + self->nout;\n    int types[NPY_MAXARGS];\n    char *ufunc_name;\n    int no_castable_output, all_inputs_scalar;\n    /* For making a better error message on coercion error */\n    char err_dst_typecode = '-', err_src_typecode = '-';\n    ufunc_name = self->name ? self->name : \"(unknown)\";\n    /* Check whether all the inputs are scalar */\n    all_inputs_scalar = 1;\n    for(i = 0; i < nin; ++i) {\n        if (PyArray_NDIM(op[i]) > 0) {\n            all_inputs_scalar = 0;\n        }\n    }\n    /* If the ufunc has userloops, search for them. */\n    if (self->userloops) {\n        switch (find_ufunc_matching_userloop(self, op,\n                                input_casting, output_casting,\n                                buffersize, any_object, all_inputs_scalar,\n                                out_dtype, out_innerloop, out_innerloopdata,\n                                out_trivial_loop_ok,\n                                &no_castable_output, &err_src_typecode,\n                                &err_dst_typecode)) {\n            /* Error */\n            case -1:\n                return -1;\n            /* A loop was found */\n            case 1:\n                return 0;\n        }\n    }\n    /*\n     * Determine the UFunc loop.  This could in general be *much* faster,\n     * and a better way to implement it might be for the ufunc to\n     * provide a function which gives back the result type and inner\n     * loop function.\n     *\n     * A default fast mechanism could be provided for functions which\n     * follow the most typical pattern, when all functions have signatures\n     * \"xx...x -> x\" for some built-in data type x, as follows.\n     *  - Use PyArray_ResultType to get the output type\n     *  - Look up the inner loop in a table based on the output type_num\n     *\n     * The method for finding the loop in the previous code did not\n     * appear consistent (as noted by some asymmetry in the generated\n     * coercion tables for np.add).\n     */\n    no_castable_output = 0;\n    for (i = 0; i < self->ntypes; ++i) {\n        char *orig_types = self->types + i*self->nargs;\n        /* Copy the types into an int array for matching */\n        for (j = 0; j < niter; ++j) {\n            types[j] = orig_types[j];\n        }\n        NPY_UF_DBG_PRINT1(\"Trying function loop %d\\n\", (int)i);\n        switch (ufunc_loop_matches(self, op,\n                    input_casting, output_casting,\n                    any_object, all_inputs_scalar,\n                    types,\n                    &no_castable_output, &err_src_typecode,\n                    &err_dst_typecode)) {\n            /* Error */\n            case -1:\n                return -1;\n            /* Found a match */\n            case 1:\n                set_ufunc_loop_data_types(self, op, out_dtype, types,\n                                    buffersize, out_trivial_loop_ok);\n                /* Save the inner loop and its data */\n                *out_innerloop = self->functions[i];\n                *out_innerloopdata = self->data[i];\n                NPY_UF_DBG_PRINT(\"Returning inner loop successfully\\n\");\n                return 0;\n        }\n    }\n    /* If no function was found, throw an error */\n    NPY_UF_DBG_PRINT(\"No loop was found\\n\");\n    if (no_castable_output) {\n        PyErr_Format(PyExc_TypeError,\n                \"ufunc '%s' output (typecode '%c') could not be coerced to \"\n                \"provided output parameter (typecode '%c') according \"\n                \"to the casting rule '%s'\",\n                ufunc_name, err_src_typecode, err_dst_typecode,\n                _casting_to_string(output_casting));\n    }\n    else {\n        /*\n         * TODO: We should try again if the casting rule is same_kind\n         *       or unsafe, and look for a function more liberally.\n         */\n        PyErr_Format(PyExc_TypeError,\n                \"ufunc '%s' not supported for the input types, and the \"\n                \"inputs could not be safely coerced to any supported \"\n                \"types according to the casting rule '%s'\",\n                ufunc_name,\n                _casting_to_string(input_casting));\n    }\n    return -1;\n"]]}
{"hexsha": "1b384311726897bff5ba3e1014a53a536eccc210", "ext": "c", "lang": "C", "content": "static int virtscsi_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *sc)\n{\n\tstruct virtio_scsi *vscsi = shost_priv(sh);\n\tstruct virtio_scsi_cmd *cmd;\n\tint ret;\n\n\tdev_dbg(&sc->device->sdev_gendev,\n\t\t\"cmd %p CDB: %#02x\\n\", sc, sc->cmnd[0]);\n\n\tret = SCSI_MLQUEUE_HOST_BUSY;\n\tcmd = mempool_alloc(virtscsi_cmd_pool, GFP_ATOMIC);\n\tif (!cmd)\n\t\tgoto out;\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->sc = sc;\n\tcmd->req.cmd = (struct virtio_scsi_cmd_req){\n\t\t.lun[0] = 1,\n\t\t.lun[1] = sc->device->id,\n\t\t.lun[2] = (sc->device->lun >> 8) | 0x40,\n\t\t.lun[3] = sc->device->lun & 0xff,\n\t\t.tag = (unsigned long)sc,\n\t\t.task_attr = VIRTIO_SCSI_S_SIMPLE,\n\t\t.prio = 0,\n\t\t.crn = 0,\n\t};\n\n\tBUG_ON(sc->cmd_len > VIRTIO_SCSI_CDB_SIZE);\n\tmemcpy(cmd->req.cmd.cdb, sc->cmnd, sc->cmd_len);\n\n\tif (virtscsi_kick_cmd(vscsi, vscsi->req_vq, cmd,\n\t\t\t      sizeof cmd->req.cmd, sizeof cmd->resp.cmd,\n\t\t\t      GFP_ATOMIC) >= 0)\n\t\tret = 0;\n\nout:\n\treturn ret;\n}", "item_id": 6, "repo": "Uswer/LineageOS-14.1_jag3gds", "file": "kernel/lge/msm8226/drivers/scsi/virtio_scsi.c", "last_update_at": "2020-06-01T10:53:47+00:00", "question_id": "1b384311726897bff5ba3e1014a53a536eccc210_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int virtscsi_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *sc)\n{\n\tstruct virtio_scsi *vscsi = shost_priv(sh);\n\tstruct virtio_scsi_cmd *cmd;\n\tint ret;\n\tdev_dbg(&sc->device->sdev_gendev,\n\t\t\"cmd %p CDB: %#02x\\n\", sc, sc->cmnd[0]);\n\tret = SCSI_MLQUEUE_HOST_BUSY;\n\tcmd = mempool_alloc(virtscsi_cmd_pool, GFP_ATOMIC);\n\tif (!cmd)\n\t\tgoto out;\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->sc = sc;\n\tcmd->req.cmd = (struct virtio_scsi_cmd_req){\n\t\t.lun[0] = 1,\n\t\t.lun[1] = sc->device->id,\n\t\t.lun[2] = (sc->device->lun >> 8) | 0x40,\n\t\t.lun[3] = sc->device->lun & 0xff,\n\t\t.tag = (unsigned long)sc,\n\t\t.task_attr = VIRTIO_SCSI_S_SIMPLE,\n\t\t.prio = 0,\n\t\t.crn = 0,\n\t};\n\tBUG_ON(sc->cmd_len > VIRTIO_SCSI_CDB_SIZE);\n\tmemcpy(cmd->req.cmd.cdb, sc->cmnd, sc->cmd_len);\n\tif (virtscsi_kick_cmd(vscsi, vscsi->req_vq, cmd,\n\t\t\t      sizeof cmd->req.cmd, sizeof cmd->resp.cmd,\n\t\t\t      GFP_ATOMIC) >= 0)\n\t\tret = 0;\nout:\n\treturn ret;\n"]]}
{"hexsha": "2a3c548f4a80635eaf6c36d347a7502e36c89bc3", "ext": "c", "lang": "C", "content": "TI_STATUS report_GetReportSeverityTable(TI_HANDLE hReport, TI_UINT8 *pSeverities)\n{\n    TI_UINT8 index;\n\n\tif( (NULL == hReport) || (NULL == pSeverities))\n\t{\n\n\t\treturn TI_NOK;\n\t}\n\n\n    os_memoryCopy (((TReport *)hReport)->hOs, \n                   (void *)pSeverities, \n                   (void *)(((TReport *)hReport)->aSeverityTable), \n                   sizeof(((TReport *)hReport)->aSeverityTable));\n\n    for (index = 0; index < sizeof(((TReport *)hReport)->aSeverityTable); index++)\n    {\n        pSeverities[index] += '0';\n    }\n\n    return TI_OK;\n}", "item_id": 7, "repo": "wilebeast/FireFox-OS", "file": "B2G/hardware/ti/wlan/wl1271/utils/report.c", "last_update_at": "2020-04-24T20:31:29+00:00", "question_id": "2a3c548f4a80635eaf6c36d347a7502e36c89bc3_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TI_STATUS report_GetReportSeverityTable(TI_HANDLE hReport, TI_UINT8 *pSeverities)\n{\n    TI_UINT8 index;\n\tif( (NULL == hReport) || (NULL == pSeverities))\n\t{\n\t\treturn TI_NOK;\n\t}\n    os_memoryCopy (((TReport *)hReport)->hOs, \n                   (void *)pSeverities, \n                   (void *)(((TReport *)hReport)->aSeverityTable), \n                   sizeof(((TReport *)hReport)->aSeverityTable));\n    for (index = 0; index < sizeof(((TReport *)hReport)->aSeverityTable); index++)\n    {\n        pSeverities[index] += '0';\n    }\n    return TI_OK;\n"]]}
{"hexsha": "a856370464d6371d871f55debd45b217cd3e791f", "ext": "c", "lang": "C", "content": "gulong dbhandler_get_num_calls(void)\n{\n    int rc;\n    rc = sqlite3_step(dbhandler_stmts[DBHANDLER_STMT_GET_NUM_CALLS]);\n    if (rc != SQLITE_DONE && rc != SQLITE_ROW) {\n        log_log(\"dbhandler_get_num_calls: rc = %d\\n\", rc);\n        sqlite3_reset(dbhandler_stmts[DBHANDLER_STMT_GET_NUM_CALLS]);\n        return 0;\n    }\n\n    gulong count = (gulong)sqlite3_column_int(dbhandler_stmts[DBHANDLER_STMT_GET_NUM_CALLS], 0);\n    sqlite3_reset(dbhandler_stmts[DBHANDLER_STMT_GET_NUM_CALLS]);\n\n    log_log(\"dbhandler_get_num_calls: count: %lu\\n\", count);\n    return count;\n}", "item_id": 3, "repo": "lahol/fritz2ci", "file": "dbhandler.c", "last_update_at": "2020-07-29T10:20:30+00:00", "question_id": "a856370464d6371d871f55debd45b217cd3e791f_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["gulong dbhandler_get_num_calls(void)\n{\n    int rc;\n    rc = sqlite3_step(dbhandler_stmts[DBHANDLER_STMT_GET_NUM_CALLS]);\n    if (rc != SQLITE_DONE && rc != SQLITE_ROW) {\n        log_log(\"dbhandler_get_num_calls: rc = %d\\n\", rc);\n        sqlite3_reset(dbhandler_stmts[DBHANDLER_STMT_GET_NUM_CALLS]);\n        return 0;\n    }\n    gulong count = (gulong)sqlite3_column_int(dbhandler_stmts[DBHANDLER_STMT_GET_NUM_CALLS], 0);\n    sqlite3_reset(dbhandler_stmts[DBHANDLER_STMT_GET_NUM_CALLS]);\n    log_log(\"dbhandler_get_num_calls: count: %lu\\n\", count);\n    return count;\n"]]}
{"hexsha": "1ff1444f6140da6f1965e64f2120a5fb7158f730", "ext": "c", "lang": "C", "content": "int ssp_write_alt(unsigned int spi_bus, unsigned int spi_csn,\n                  unsigned int addr1, unsigned int addr1bytenum,\n                  unsigned int addr2, unsigned int addr2bytenum,\n                  unsigned int data, unsigned int databytenum)\n{\n    struct spi_master   *master = hi_master[spi_bus];\n    struct spi_device   *spi = hi_spi[spi_bus][spi_csn];\n    struct spi_transfer *t;\n    struct spi_message  *m;\n    unsigned char       *buf;\n    int                 status = 0;\n    unsigned long       flags;\n    int                 buf_idx = 0;\n    int idx = g_spi_msg.msg_idx;\n\n    g_spi_msg.msg_idx++;\n    if (g_spi_msg.msg_idx > SPI_MSG_NUM - 1) {\n        g_spi_msg.msg_idx = 0;\n    }\n\n    buf = g_spi_msg.spi_msg_array[idx].buf;\n    t   = &g_spi_msg.spi_msg_array[idx].t;\n    m   = &g_spi_msg.spi_msg_array[idx].m;\n\n    /* check spi_message is or no finish */\n    spin_lock_irqsave(&master->queue_lock, flags);\n    if (m->state != NULL) {\n        spin_unlock_irqrestore(&master->queue_lock, flags);\n        dev_err(&spi->dev, \"%s, %s, %d line: spi_message no finish!\\n\", __FILE__, __func__, __LINE__);\n        return -EFAULT;\n    }\n    spin_unlock_irqrestore(&master->queue_lock, flags);\n\n    spi->mode = SPI_MODE_3 | SPI_LSB_FIRST;\n\n    memset(buf, 0, sizeof(g_spi_msg.spi_msg_array[idx].buf));\n\n    buf[buf_idx++] = addr1;\n\n    if (addr2bytenum == 2) {\n        buf[buf_idx++] = addr2 >> 8;\n    }\n    buf[buf_idx++] = addr2;\n\n    if (databytenum == 2) {\n        buf[buf_idx++] = data >> 8;\n    }\n    buf[buf_idx++] = data;\n    t->tx_buf    = buf;\n    t->rx_buf    = buf;\n    t->len       = buf_idx;\n    t->cs_change = 1;\n    t->speed_hz  = 2000000;\n    t->bits_per_word = 8;\n\n    spi_message_init(m);\n    spi_message_add_tail(t, m);\n    m->state = m;\n    status = spi_async(spi, m);\n    if (status) {\n        dev_err(&spi->dev, \"%s: spi_async() error!\\n\", __func__);\n        status = -EFAULT;\n    }\n\n    return status;\n}", "item_id": 1, "repo": "werringwu/TeamX4", "file": "mpp/component/isp/ext_drv/hi3516ev200/sensor_spi/sensor_spi.c", "last_update_at": "2020-09-24T10:26:09+00:00", "question_id": "1ff1444f6140da6f1965e64f2120a5fb7158f730_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int ssp_write_alt(unsigned int spi_bus, unsigned int spi_csn,\n                  unsigned int addr1, unsigned int addr1bytenum,\n                  unsigned int addr2, unsigned int addr2bytenum,\n                  unsigned int data, unsigned int databytenum)\n{\n    struct spi_master   *master = hi_master[spi_bus];\n    struct spi_device   *spi = hi_spi[spi_bus][spi_csn];\n    struct spi_transfer *t;\n    struct spi_message  *m;\n    unsigned char       *buf;\n    int                 status = 0;\n    unsigned long       flags;\n    int                 buf_idx = 0;\n    int idx = g_spi_msg.msg_idx;\n    g_spi_msg.msg_idx++;\n    if (g_spi_msg.msg_idx > SPI_MSG_NUM - 1) {\n        g_spi_msg.msg_idx = 0;\n    }\n    buf = g_spi_msg.spi_msg_array[idx].buf;\n    t   = &g_spi_msg.spi_msg_array[idx].t;\n    m   = &g_spi_msg.spi_msg_array[idx].m;\n    /* check spi_message is or no finish */\n    spin_lock_irqsave(&master->queue_lock, flags);\n    if (m->state != NULL) {\n        spin_unlock_irqrestore(&master->queue_lock, flags);\n        dev_err(&spi->dev, \"%s, %s, %d line: spi_message no finish!\\n\", __FILE__, __func__, __LINE__);\n        return -EFAULT;\n    }\n    spin_unlock_irqrestore(&master->queue_lock, flags);\n    spi->mode = SPI_MODE_3 | SPI_LSB_FIRST;\n    memset(buf, 0, sizeof(g_spi_msg.spi_msg_array[idx].buf));\n    buf[buf_idx++] = addr1;\n    if (addr2bytenum == 2) {\n        buf[buf_idx++] = addr2 >> 8;\n    }\n    buf[buf_idx++] = addr2;\n    if (databytenum == 2) {\n        buf[buf_idx++] = data >> 8;\n    }\n    buf[buf_idx++] = data;\n    t->tx_buf    = buf;\n    t->rx_buf    = buf;\n    t->len       = buf_idx;\n    t->cs_change = 1;\n    t->speed_hz  = 2000000;\n    t->bits_per_word = 8;\n    spi_message_init(m);\n    spi_message_add_tail(t, m);\n    m->state = m;\n    status = spi_async(spi, m);\n    if (status) {\n        dev_err(&spi->dev, \"%s: spi_async() error!\\n\", __func__);\n        status = -EFAULT;\n    }\n    return status;\n"]]}
{"hexsha": "1a486e8f11ed27d88ebf574331e4638dcd586187", "ext": "c", "lang": "C", "content": "GH_INLINE U32  GH_VO_MIXER_get_OSD_START(void)\n{\n    GH_VO_MIXER_OSD_START_REAL_S real;\n    GH_VO_MIXER_OSD_START_S dummy;\n     dummy.all =  0;\n     real.all = (*(volatile U32 *)REG_VO_MIXER_OSD_START_REAL);\n\n    dummy.bitc.vertical = real.bitc.vertical;\n    dummy.bitc.horizontal = real.bitc.horizontal;\n    return dummy.all;\n}", "item_id": 25, "repo": "Davidfind/rt-thread", "file": "bsp/gkipc/libraries/drv/710X/gh/src/gh_vo_mixer.c", "last_update_at": "2020-12-19T04:35:43+00:00", "question_id": "1a486e8f11ed27d88ebf574331e4638dcd586187_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["GH_INLINE U32  GH_VO_MIXER_get_OSD_START(void)\n{\n    GH_VO_MIXER_OSD_START_REAL_S real;\n    GH_VO_MIXER_OSD_START_S dummy;\n     dummy.all =  0;\n     real.all = (*(volatile U32 *)REG_VO_MIXER_OSD_START_REAL);\n    dummy.bitc.vertical = real.bitc.vertical;\n    dummy.bitc.horizontal = real.bitc.horizontal;\n    return dummy.all;\n"]]}
{"hexsha": "dc3398105fa77730a8dbc123f8186620788c4fd9", "ext": "c", "lang": "C", "content": "ssize_t flextcp_connection_tx_alloc2(struct flextcp_connection *conn, size_t len,\n    void **buf_1, size_t *len_1, void **buf_2)\n{\n  uint32_t avail, head;\n\n  /* if outgoing connection has already been closed, abort */\n  if ((conn->flags & CONN_FLAG_TXEOS) == CONN_FLAG_TXEOS)\n    return -1;\n\n  /* truncate if necessary */\n  avail = conn_tx_allocbytes(conn);\n  if (avail < len) {\n    len = avail;\n  }\n\n  /* calculate alloc head */\n  head = conn->txb_head + conn->txb_allocated;\n  if (head >= conn->txb_len) {\n    head -= conn->txb_len;\n  }\n\n  *buf_1 = conn->txb_base + head;\n\n  /* short alloc if we wrap around */\n  if (head + len > conn->txb_len) {\n    *len_1 = conn->txb_len - head;\n    *buf_2 = conn->txb_base;\n  } else {\n    *len_1 = len;\n    *buf_2 = NULL;\n  }\n\n  /* bump head alloc counter */\n  conn->txb_allocated += len;\n  return len;\n}", "item_id": 6, "repo": "y95847frank/rdma-tas", "file": "lib/tas/conn.c", "last_update_at": "2020-02-23T08:27:31+00:00", "question_id": "dc3398105fa77730a8dbc123f8186620788c4fd9_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ssize_t flextcp_connection_tx_alloc2(struct flextcp_connection *conn, size_t len,\n    void **buf_1, size_t *len_1, void **buf_2)\n{\n  uint32_t avail, head;\n  /* if outgoing connection has already been closed, abort */\n  if ((conn->flags & CONN_FLAG_TXEOS) == CONN_FLAG_TXEOS)\n    return -1;\n  /* truncate if necessary */\n  avail = conn_tx_allocbytes(conn);\n  if (avail < len) {\n    len = avail;\n  }\n  /* calculate alloc head */\n  head = conn->txb_head + conn->txb_allocated;\n  if (head >= conn->txb_len) {\n    head -= conn->txb_len;\n  }\n  *buf_1 = conn->txb_base + head;\n  /* short alloc if we wrap around */\n  if (head + len > conn->txb_len) {\n    *len_1 = conn->txb_len - head;\n    *buf_2 = conn->txb_base;\n  } else {\n    *len_1 = len;\n    *buf_2 = NULL;\n  }\n  /* bump head alloc counter */\n  conn->txb_allocated += len;\n  return len;\n"]]}
{"hexsha": "0b6b9e9a49462f32af57621e2af7632665f51db1", "ext": "c", "lang": "C", "content": "int main()\n{\n\tprintf(\"%s\\n\", \"Please, enter base and power -- a and b\");\n\tlong long base = 0;\n\tint power = 0;\n\tscanf(\"%lld %i\", &base, &power);\n\tif (power < 0)\n\t{\n\t\tprintf(\"Power should be positive\");\n\t\treturn 0;\n\t}\n\tif (base == 0 && power == 0)\n\t{\n\t\tprintf(\"0 power 0 is undefined\");\n\t\treturn 0;\n\t}\n\n\tprintf(\"Linear running time:\\n\");\n\tif (testLinear() == 0)\n\t{\n\t\tprintf(\"  Tests failed\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"  Tests succeed\\n  a power b = %lld\\n\", exponentiation(base, power));\n\t}\n\n\tprintf(\"\\nO(log b) running time:\\n\");\n\tif (testLogarifmic() == 0)\n\t{\n\t\tprintf(\"  Tests failed\\n\");\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tprintf(\"  Tests succeed\\n  a power b = %lld\\n\", exponentiationLogn(base, power));\n\t}\n\n\treturn 0;\n}", "item_id": 2, "repo": "ElenaBakova/Homeworks", "file": "Semester1/homework2/Exponentiation/Source.c", "last_update_at": "2020-11-28T20:05:15+00:00", "question_id": "0b6b9e9a49462f32af57621e2af7632665f51db1_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main()\n{\n\tprintf(\"%s\\n\", \"Please, enter base and power -- a and b\");\n\tlong long base = 0;\n\tint power = 0;\n\tscanf(\"%lld %i\", &base, &power);\n\tif (power < 0)\n\t{\n\t\tprintf(\"Power should be positive\");\n\t\treturn 0;\n\t}\n\tif (base == 0 && power == 0)\n\t{\n\t\tprintf(\"0 power 0 is undefined\");\n\t\treturn 0;\n\t}\n\tprintf(\"Linear running time:\\n\");\n\tif (testLinear() == 0)\n\t{\n\t\tprintf(\"  Tests failed\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"  Tests succeed\\n  a power b = %lld\\n\", exponentiation(base, power));\n\t}\n\tprintf(\"\\nO(log b) running time:\\n\");\n\tif (testLogarifmic() == 0)\n\t{\n\t\tprintf(\"  Tests failed\\n\");\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tprintf(\"  Tests succeed\\n  a power b = %lld\\n\", exponentiationLogn(base, power));\n\t}\n\treturn 0;\n"]]}
{"hexsha": "25a9a2a4d717279f5802c7e15a70c48192810d46", "ext": "c", "lang": "C", "content": "static real_T c10_get_BOREDOM_THRESHOLD\r\n  (SFc10_ARP_02_RPSsmile_GloveAtomicRachelImitateSmileInstanceStruct\r\n   *chartInstance, uint32_T c10_b)\r\n{\r\n  ssReadFromDataStoreElement(chartInstance->S, 0, NULL, c10_b);\r\n  if (chartInstance->c10_BOREDOM_THRESHOLD_address == 0) {\r\n    sf_mex_error_message(\"Invalid access to Data Store Memory data \\'BOREDOM_THRESHOLD\\' (#519) in the initialization routine of the chart.\\n\");\r\n  }\r\n\r\n  return *chartInstance->c10_BOREDOM_THRESHOLD_address;\r\n}", "item_id": 90, "repo": "maryamsab/realact", "file": "slprj/_sfprj/ARP_02_RPSsmile_GloveAtomicRachelImitateSmile/_self/sfun/src/c10_ARP_02_RPSsmile_GloveAtomicRachelImitateSmile.c", "last_update_at": "2020-12-02T21:41:36+00:00", "question_id": "25a9a2a4d717279f5802c7e15a70c48192810d46_90", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static real_T c10_get_BOREDOM_THRESHOLD\r\n  (SFc10_ARP_02_RPSsmile_GloveAtomicRachelImitateSmileInstanceStruct\r\n   *chartInstance, uint32_T c10_b)\r\n{\r\n  ssReadFromDataStoreElement(chartInstance->S, 0, NULL, c10_b);\r\n  if (chartInstance->c10_BOREDOM_THRESHOLD_address == 0) {\r\n    sf_mex_error_message(\"Invalid access to Data Store Memory data \\'BOREDOM_THRESHOLD\\' (#519) in the initialization routine of the chart.\\n\");\r\n  }\r\n\r\n  return *chartInstance->c10_BOREDOM_THRESHOLD_address;\r\n"]]}
{"hexsha": "2c417fc23c9d02e8f87fc74f4a56acbc0759c65d", "ext": "c", "lang": "C", "content": "static void _HandlePID(int x, int y, int Pressed) {\n  static int IsInHandlePID = 0;\n  unsigned   ReleaseCapture;\n\n  ReleaseCapture = 1;\n  if (IsInHandlePID++ == 0) {\n    _CalcBoardDimensions();\n    x -= _BoardX0;\n    y -= _BoardY0;\n    if ((x >= 0) && (y >= 0)) {\n      x /= _CellSize;\n      y /= _CellSize;\n      if ((x < 8) && (y < 8)) {\n        if (_IsValidMove(&_Board, x, y)) {\n          if (Pressed == 0) {\n            _ReleaseCapture();\n            _MakeMove(&_Board, x, y);\n            _NextPlayer();\n          } else {\n            _SetCapture();\n          }\n          ReleaseCapture = 0;\n        }   \n      }\n    }\n    if (ReleaseCapture) {\n      _ReleaseCapture();\n    }\n  }\n  IsInHandlePID--;\n}", "item_id": 24, "repo": "washingtonxr/Open_emWinDemo", "file": "SeggerEval_WIN32_MSVC_MinGW_GUI_V550/Sample/Tutorial/APP_Reversi.c", "last_update_at": "2020-04-29T18:22:32+00:00", "question_id": "2c417fc23c9d02e8f87fc74f4a56acbc0759c65d_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void _HandlePID(int x, int y, int Pressed) {\n  static int IsInHandlePID = 0;\n  unsigned   ReleaseCapture;\n  ReleaseCapture = 1;\n  if (IsInHandlePID++ == 0) {\n    _CalcBoardDimensions();\n    x -= _BoardX0;\n    y -= _BoardY0;\n    if ((x >= 0) && (y >= 0)) {\n      x /= _CellSize;\n      y /= _CellSize;\n      if ((x < 8) && (y < 8)) {\n        if (_IsValidMove(&_Board, x, y)) {\n          if (Pressed == 0) {\n            _ReleaseCapture();\n            _MakeMove(&_Board, x, y);\n            _NextPlayer();\n          } else {\n            _SetCapture();\n          }\n          ReleaseCapture = 0;\n        }   \n      }\n    }\n    if (ReleaseCapture) {\n      _ReleaseCapture();\n    }\n  }\n  IsInHandlePID--;\n"]]}
{"hexsha": "460bbe92403eda219d18134267efdbc3386dea91", "ext": "c", "lang": "C", "content": "void display_line( uint8_t line, const char *label, double num, const char *unit, uint8_t ser_line, bool ok ) {\n    char msg[21];\n    snprintf(msg, sizeof(msg), \" %-4s%6d.%02d %-2s \", label, (int)num, (int)(num * 100) % 100, unit);\n    if( ser_line == 1 ) printf(\"%s\", msg);\n    LCD_ShowString(8, line * 16, (uint8_t *)msg, ok ? BLACK : RED);\n}", "item_id": 4, "repo": "joba-1/Longan-Nano-Bme280-Spi", "file": "src/main.c", "last_update_at": "2020-11-14T05:01:23+00:00", "question_id": "460bbe92403eda219d18134267efdbc3386dea91_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void display_line( uint8_t line, const char *label, double num, const char *unit, uint8_t ser_line, bool ok ) {\n    char msg[21];\n    snprintf(msg, sizeof(msg), \" %-4s%6d.%02d %-2s \", label, (int)num, (int)(num * 100) % 100, unit);\n    if( ser_line == 1 ) printf(\"%s\", msg);\n    LCD_ShowString(8, line * 16, (uint8_t *)msg, ok ? BLACK : RED);\n"]]}
{"hexsha": "56353b08ef28c654869b54f8c505099b1fef3bd7", "ext": "c", "lang": "C", "content": "INT32 IGD_get_SpecificPortMapping_entry(INOUT struct action_event *event)\n{\n    struct device_and_service_index *pIndex = NULL;\n    CHAR internalPort[MAX_NUM_TO_STR_LEN], leaseTime[MAX_NUM_TO_STR_LEN];\n    IGD_PortMapping_Entry portmapEntry;\n    PORT_MAP_INDEX portmapIndex;\n    struct in_addr addr;\n    INT32 ret;\n\n    PAL_XML2S_TABLE tableSpecPorMap[] = {\n        {PM_SET[REMOTE_HOST],    PAL_XML2S_STRING, XML2S_MSIZE(PORT_MAP_INDEX, remoteHost),  NULL, MASK_OF_INDEX_REMOTE_HOST},\n        {PM_SET[EXTERNAL_PORT], PAL_XML2S_UINT16,  XML2S_MSIZE(PORT_MAP_INDEX, externalPort), NULL, MASK_OF_INDEX_EXTERNAL_PORT},\n        {PM_SET[PROTOCOL],         PAL_XML2S_STRING,  XML2S_MSIZE(PORT_MAP_INDEX, pmProtocol),  NULL, MASK_OF_INDEX_PROTOCOL},\n        XML2S_TABLE_END\n    };\n    pal_string_pair response[PORTMAP_ENTRY_FIELD_NUM - PORTMAP_INDEX_FIELD_NUM] = {\n        { PM_SET[INTERNAL_PORT] ,                     NULL },\n        { PM_SET[INTERNAL_CLIENT] ,                  NULL },\n        { PM_SET[ENABLED] ,                               NULL },\n        { PM_SET[PORTMAPPING_DESCRIPTION] , NULL },\n        { PM_SET[LEASE_DURATION] ,                  NULL }\n    };\n    \n    PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_DEBUG, \"ENTER %s...\", __func__);\n\n    if (!event || !(event->request)) \n    {\n        PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_WARNING, \"Input parameter error\");\n\n        ret = IGD_GENERAL_ERROR;\n        return ret;\n    }\n\n    pIndex = (struct device_and_service_index *)(event->service->private);\n    if (NULL == pIndex) {\n        PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_FAILURE, \"pIndex is NULL\");\n\n        ret = PAL_UPNP_SOAP_E_ACTION_FAILED;\n        event->request->error_code = ret;\n        strncpy(event->request->error_str, PAL_upnp_get_error_message(PAL_UPNP_SOAP_E_ACTION_FAILED), PAL_UPNP_LINE_SIZE);\n\n        return ret;\n    }\n    \n    bzero(&portmapIndex, sizeof(portmapIndex));\n    ret = PAL_xml2s_process(event->request->action_request, tableSpecPorMap, &portmapIndex);\n\n    if (ret < 0){\n        PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_FAILURE, \"PAL_xml2s_process error\");\n\n        ret = PAL_UPNP_SOAP_E_INVALID_ARGS;\n        event->request->error_code = ret;\n        strncpy(event->request->error_str, PAL_upnp_get_error_message(PAL_UPNP_SOAP_E_INVALID_ARGS), PAL_UPNP_LINE_SIZE);\n    } else if ((portmapIndex.remoteHost != NULL)\n                &&(0 == inet_pton(AF_INET, portmapIndex.remoteHost, &addr))){ \n        PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_DEBUG, \"remoteHost format error: x.x.x.x\");\n\n        ret = PAL_UPNP_SOAP_E_INVALID_ARGS;\n        event->request->error_code = ret;\n        strncpy(event->request->error_str, PAL_upnp_get_error_message(PAL_UPNP_SOAP_E_INVALID_ARGS), PAL_UPNP_LINE_SIZE);\n    } else {\n        bzero(&portmapEntry, sizeof(portmapEntry));\n        if(portmapIndex.remoteHost != NULL)\n        {\n            strncpy(portmapEntry.remoteHost, portmapIndex.remoteHost, IPV4_ADDR_LEN);\n        }\n        portmapEntry.externalPort = portmapIndex.externalPort;\n        if(portmapIndex.pmProtocol != NULL)\n        {\n            strncpy(portmapEntry.protocol, portmapIndex.pmProtocol, PORT_MAP_PROTOCOL_LEN);\n        }\n\n        ret = IGD_pii_get_portmapping_entry_specific(pIndex->wan_device_index,\n                                 pIndex->wan_connection_device_index,\n                                 pIndex->wan_connection_service_index,\n                                 (strcmp(WAN_IP_CONNECTION_SERVICE_TYPE,event->service->type) == 0) ? SERVICETYPE_IP : SERVICETYPE_PPP,\n                                 &portmapEntry);\n        if(ret == 0)\n        {\n            event->request->error_code = PAL_UPNP_E_SUCCESS;\n\n            snprintf(internalPort, MAX_NUM_TO_STR_LEN, \"%d\", portmapEntry.internalPort);\n            response[INTERNAL_PORT - PORTMAP_INDEX_FIELD_NUM].value = internalPort;\n\n            response[INTERNAL_CLIENT - PORTMAP_INDEX_FIELD_NUM].value = strdup(portmapEntry.internalClient);\n\n            if(portmapEntry.enabled == BOOL_TRUE)\n            {\n                response[ENABLED - PORTMAP_INDEX_FIELD_NUM].value = \"1\";\n            } else {\n                response[ENABLED - PORTMAP_INDEX_FIELD_NUM].value = \"0\";\n            }\n            \n            response[PORTMAPPING_DESCRIPTION - PORTMAP_INDEX_FIELD_NUM].value = strdup(portmapEntry.description);\n\n            snprintf(leaseTime, MAX_NUM_TO_STR_LEN, \"%d\", portmapEntry.leaseTime);\n            response[LEASE_DURATION - PORTMAP_INDEX_FIELD_NUM].value = leaseTime;\n            \n            ret = PAL_upnp_make_action(&(event->request->action_result), event->request->action_name, event->service->type, \n                                            PORTMAP_ENTRY_FIELD_NUM - PORTMAP_INDEX_FIELD_NUM, response, PAL_UPNP_ACTION_RESPONSE);\n            if(ret != PAL_UPNP_E_SUCCESS)\n            {\n                PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_FAILURE, \"PAL_upnp_make_action error\");\n\n                event->request->error_code = ret;\n                event->request->action_result = NULL;\n            }\n            \n            if(response[INTERNAL_CLIENT - PORTMAP_INDEX_FIELD_NUM].value)\n            {\n                free(response[INTERNAL_CLIENT - PORTMAP_INDEX_FIELD_NUM].value);\n            }\n            if(response[PORTMAPPING_DESCRIPTION - PORTMAP_INDEX_FIELD_NUM].value)\n            {\n                free(response[PORTMAPPING_DESCRIPTION - PORTMAP_INDEX_FIELD_NUM].value);\n            }\n            \n        } else {\n            PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_FAILURE, \"IGD_pii_get_portmapping_entry_specific error\");\n\n            ret = NO_SUCH_ENTRY_IN_ARRAY;\n            event->request->error_code = ret;\n            strncpy(event->request->error_str, NO_SUCH_ENTRY_IN_ARRAY_STR, sizeof(NO_SUCH_ENTRY_IN_ARRAY_STR)+1);\n        }\n        \n        PAL_xml2s_free(&portmapIndex, tableSpecPorMap);\n    }\n\n    PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_DEBUG, \"EXIT %s...\", __func__);\n\n    return ret;\n}", "item_id": 2, "repo": "cablelabs/Utopia", "file": "source/igd/src/igd_action_port_mapping.c", "last_update_at": "2020-12-10T07:34:30+00:00", "question_id": "56353b08ef28c654869b54f8c505099b1fef3bd7_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["INT32 IGD_get_SpecificPortMapping_entry(INOUT struct action_event *event)\n{\n    struct device_and_service_index *pIndex = NULL;\n    CHAR internalPort[MAX_NUM_TO_STR_LEN], leaseTime[MAX_NUM_TO_STR_LEN];\n    IGD_PortMapping_Entry portmapEntry;\n    PORT_MAP_INDEX portmapIndex;\n    struct in_addr addr;\n    INT32 ret;\n    PAL_XML2S_TABLE tableSpecPorMap[] = {\n        {PM_SET[REMOTE_HOST],    PAL_XML2S_STRING, XML2S_MSIZE(PORT_MAP_INDEX, remoteHost),  NULL, MASK_OF_INDEX_REMOTE_HOST},\n        {PM_SET[EXTERNAL_PORT], PAL_XML2S_UINT16,  XML2S_MSIZE(PORT_MAP_INDEX, externalPort), NULL, MASK_OF_INDEX_EXTERNAL_PORT},\n        {PM_SET[PROTOCOL],         PAL_XML2S_STRING,  XML2S_MSIZE(PORT_MAP_INDEX, pmProtocol),  NULL, MASK_OF_INDEX_PROTOCOL},\n        XML2S_TABLE_END\n    };\n    pal_string_pair response[PORTMAP_ENTRY_FIELD_NUM - PORTMAP_INDEX_FIELD_NUM] = {\n        { PM_SET[INTERNAL_PORT] ,                     NULL },\n        { PM_SET[INTERNAL_CLIENT] ,                  NULL },\n        { PM_SET[ENABLED] ,                               NULL },\n        { PM_SET[PORTMAPPING_DESCRIPTION] , NULL },\n        { PM_SET[LEASE_DURATION] ,                  NULL }\n    };\n    PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_DEBUG, \"ENTER %s...\", __func__);\n    if (!event || !(event->request)) \n    {\n        PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_WARNING, \"Input parameter error\");\n        ret = IGD_GENERAL_ERROR;\n        return ret;\n    }\n    pIndex = (struct device_and_service_index *)(event->service->private);\n    if (NULL == pIndex) {\n        PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_FAILURE, \"pIndex is NULL\");\n        ret = PAL_UPNP_SOAP_E_ACTION_FAILED;\n        event->request->error_code = ret;\n        strncpy(event->request->error_str, PAL_upnp_get_error_message(PAL_UPNP_SOAP_E_ACTION_FAILED), PAL_UPNP_LINE_SIZE);\n        return ret;\n    }\n    bzero(&portmapIndex, sizeof(portmapIndex));\n    ret = PAL_xml2s_process(event->request->action_request, tableSpecPorMap, &portmapIndex);\n    if (ret < 0){\n        PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_FAILURE, \"PAL_xml2s_process error\");\n        ret = PAL_UPNP_SOAP_E_INVALID_ARGS;\n        event->request->error_code = ret;\n        strncpy(event->request->error_str, PAL_upnp_get_error_message(PAL_UPNP_SOAP_E_INVALID_ARGS), PAL_UPNP_LINE_SIZE);\n    } else if ((portmapIndex.remoteHost != NULL)\n                &&(0 == inet_pton(AF_INET, portmapIndex.remoteHost, &addr))){ \n        PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_DEBUG, \"remoteHost format error: x.x.x.x\");\n        ret = PAL_UPNP_SOAP_E_INVALID_ARGS;\n        event->request->error_code = ret;\n        strncpy(event->request->error_str, PAL_upnp_get_error_message(PAL_UPNP_SOAP_E_INVALID_ARGS), PAL_UPNP_LINE_SIZE);\n    } else {\n        bzero(&portmapEntry, sizeof(portmapEntry));\n        if(portmapIndex.remoteHost != NULL)\n        {\n            strncpy(portmapEntry.remoteHost, portmapIndex.remoteHost, IPV4_ADDR_LEN);\n        }\n        portmapEntry.externalPort = portmapIndex.externalPort;\n        if(portmapIndex.pmProtocol != NULL)\n        {\n            strncpy(portmapEntry.protocol, portmapIndex.pmProtocol, PORT_MAP_PROTOCOL_LEN);\n        }\n        ret = IGD_pii_get_portmapping_entry_specific(pIndex->wan_device_index,\n                                 pIndex->wan_connection_device_index,\n                                 pIndex->wan_connection_service_index,\n                                 (strcmp(WAN_IP_CONNECTION_SERVICE_TYPE,event->service->type) == 0) ? SERVICETYPE_IP : SERVICETYPE_PPP,\n                                 &portmapEntry);\n        if(ret == 0)\n        {\n            event->request->error_code = PAL_UPNP_E_SUCCESS;\n            snprintf(internalPort, MAX_NUM_TO_STR_LEN, \"%d\", portmapEntry.internalPort);\n            response[INTERNAL_PORT - PORTMAP_INDEX_FIELD_NUM].value = internalPort;\n            response[INTERNAL_CLIENT - PORTMAP_INDEX_FIELD_NUM].value = strdup(portmapEntry.internalClient);\n            if(portmapEntry.enabled == BOOL_TRUE)\n            {\n                response[ENABLED - PORTMAP_INDEX_FIELD_NUM].value = \"1\";\n            } else {\n                response[ENABLED - PORTMAP_INDEX_FIELD_NUM].value = \"0\";\n            }\n            response[PORTMAPPING_DESCRIPTION - PORTMAP_INDEX_FIELD_NUM].value = strdup(portmapEntry.description);\n            snprintf(leaseTime, MAX_NUM_TO_STR_LEN, \"%d\", portmapEntry.leaseTime);\n            response[LEASE_DURATION - PORTMAP_INDEX_FIELD_NUM].value = leaseTime;\n            ret = PAL_upnp_make_action(&(event->request->action_result), event->request->action_name, event->service->type, \n                                            PORTMAP_ENTRY_FIELD_NUM - PORTMAP_INDEX_FIELD_NUM, response, PAL_UPNP_ACTION_RESPONSE);\n            if(ret != PAL_UPNP_E_SUCCESS)\n            {\n                PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_FAILURE, \"PAL_upnp_make_action error\");\n                event->request->error_code = ret;\n                event->request->action_result = NULL;\n            }\n            if(response[INTERNAL_CLIENT - PORTMAP_INDEX_FIELD_NUM].value)\n            {\n                free(response[INTERNAL_CLIENT - PORTMAP_INDEX_FIELD_NUM].value);\n            }\n            if(response[PORTMAPPING_DESCRIPTION - PORTMAP_INDEX_FIELD_NUM].value)\n            {\n                free(response[PORTMAPPING_DESCRIPTION - PORTMAP_INDEX_FIELD_NUM].value);\n            }\n        } else {\n            PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_FAILURE, \"IGD_pii_get_portmapping_entry_specific error\");\n            ret = NO_SUCH_ENTRY_IN_ARRAY;\n            event->request->error_code = ret;\n            strncpy(event->request->error_str, NO_SUCH_ENTRY_IN_ARRAY_STR, sizeof(NO_SUCH_ENTRY_IN_ARRAY_STR)+1);\n        }\n        PAL_xml2s_free(&portmapIndex, tableSpecPorMap);\n    }\n    PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_DEBUG, \"EXIT %s...\", __func__);\n    return ret;\n"]]}
{"hexsha": "da05cec1904a0fdc75ac90ff014b6544ee4eb41f", "ext": "c", "lang": "C", "content": "void light_ctl_work_handler(struct k_work *work)\n{\n    struct bt_mesh_light_ctl_srv *srv =\n        CONTAINER_OF(work, struct bt_mesh_light_ctl_srv, transition.timer.work);\n    struct bt_mesh_msg_ctx *ctx = NULL;\n    bt_mesh_light_server_state_change_t change = {0};\n\n    if (srv == NULL || srv->state == NULL ||\n            srv->transition.timer.work._reserved == NULL) {\n        BT_ERR(\"%s, Invalid parameter\", __func__);\n        return;\n    }\n\n    bt_mesh_light_server_lock();\n\n    ctx = (struct bt_mesh_msg_ctx *)srv->transition.timer.work._reserved;\n\n    if (srv->transition.just_started) {\n        srv->transition.just_started = false;\n        if (srv->transition.counter == 0U) {\n            change.ctl_set.lightness = srv->state->lightness;\n            change.ctl_set.temperature = srv->state->temperature;\n            change.ctl_set.delta_uv = srv->state->delta_uv;\n            bt_mesh_lighting_server_cb_evt_to_btc(\n                BTC_BLE_MESH_EVT_LIGHTING_SERVER_STATE_CHANGE, srv->model, ctx, (const u8_t *)&change, sizeof(change));\n            bt_mesh_atomic_clear_bit(srv->transition.flag, BLE_MESH_TRANS_TIMER_START);\n        } else {\n            transition_timer_start(&srv->transition);\n        }\n\n        bt_mesh_light_server_unlock();\n        return;\n    }\n\n    if (srv->transition.counter != 0U) {\n        srv->transition.counter--;\n        srv->state->lightness -= srv->tt_delta_lightness;\n        srv->state->temperature -= srv->tt_delta_temperature;\n        srv->state->delta_uv -= srv->tt_delta_delta_uv;\n    }\n\n    if (srv->transition.counter == 0U) {\n        transition_timer_stop(&srv->transition);\n        srv->state->lightness = srv->state->target_lightness;\n        srv->state->temperature = srv->state->target_temperature;\n        srv->state->delta_uv = srv->state->target_delta_uv;\n    }\n\n    change.ctl_set.lightness = srv->state->lightness;\n    change.ctl_set.temperature = srv->state->temperature;\n    change.ctl_set.delta_uv = srv->state->delta_uv;\n    bt_mesh_lighting_server_cb_evt_to_btc(\n        BTC_BLE_MESH_EVT_LIGHTING_SERVER_STATE_CHANGE, srv->model, ctx, (const u8_t *)&change, sizeof(change));\n\n    light_ctl_publish(srv->model, BLE_MESH_MODEL_OP_LIGHT_CTL_STATUS);\n\n    bt_mesh_light_server_unlock();\n    return;\n}", "item_id": 13, "repo": "cdsnyder/esp-idf", "file": "components/bt/esp_ble_mesh/mesh_models/server/state_transition.c", "last_update_at": "2020-02-27T06:15:44+00:00", "question_id": "da05cec1904a0fdc75ac90ff014b6544ee4eb41f_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void light_ctl_work_handler(struct k_work *work)\n{\n    struct bt_mesh_light_ctl_srv *srv =\n        CONTAINER_OF(work, struct bt_mesh_light_ctl_srv, transition.timer.work);\n    struct bt_mesh_msg_ctx *ctx = NULL;\n    bt_mesh_light_server_state_change_t change = {0};\n    if (srv == NULL || srv->state == NULL ||\n            srv->transition.timer.work._reserved == NULL) {\n        BT_ERR(\"%s, Invalid parameter\", __func__);\n        return;\n    }\n    bt_mesh_light_server_lock();\n    ctx = (struct bt_mesh_msg_ctx *)srv->transition.timer.work._reserved;\n    if (srv->transition.just_started) {\n        srv->transition.just_started = false;\n        if (srv->transition.counter == 0U) {\n            change.ctl_set.lightness = srv->state->lightness;\n            change.ctl_set.temperature = srv->state->temperature;\n            change.ctl_set.delta_uv = srv->state->delta_uv;\n            bt_mesh_lighting_server_cb_evt_to_btc(\n                BTC_BLE_MESH_EVT_LIGHTING_SERVER_STATE_CHANGE, srv->model, ctx, (const u8_t *)&change, sizeof(change));\n            bt_mesh_atomic_clear_bit(srv->transition.flag, BLE_MESH_TRANS_TIMER_START);\n        } else {\n            transition_timer_start(&srv->transition);\n        }\n        bt_mesh_light_server_unlock();\n        return;\n    }\n    if (srv->transition.counter != 0U) {\n        srv->transition.counter--;\n        srv->state->lightness -= srv->tt_delta_lightness;\n        srv->state->temperature -= srv->tt_delta_temperature;\n        srv->state->delta_uv -= srv->tt_delta_delta_uv;\n    }\n    if (srv->transition.counter == 0U) {\n        transition_timer_stop(&srv->transition);\n        srv->state->lightness = srv->state->target_lightness;\n        srv->state->temperature = srv->state->target_temperature;\n        srv->state->delta_uv = srv->state->target_delta_uv;\n    }\n    change.ctl_set.lightness = srv->state->lightness;\n    change.ctl_set.temperature = srv->state->temperature;\n    change.ctl_set.delta_uv = srv->state->delta_uv;\n    bt_mesh_lighting_server_cb_evt_to_btc(\n        BTC_BLE_MESH_EVT_LIGHTING_SERVER_STATE_CHANGE, srv->model, ctx, (const u8_t *)&change, sizeof(change));\n    light_ctl_publish(srv->model, BLE_MESH_MODEL_OP_LIGHT_CTL_STATUS);\n    bt_mesh_light_server_unlock();\n    return;\n"]]}
{"hexsha": "96a63e497adeb1256fd034555b09a9cdb6c2b967", "ext": "c", "lang": "C", "content": "int arm_arch_state(struct target *target)\n{\n\tstruct arm *arm = target_to_arm(target);\n\n\tif (arm->common_magic != ARM_COMMON_MAGIC) {\n\t\tLOG_ERROR(\"BUG: called for a non-ARM target\");\n\t\treturn ERROR_FAIL;\n\t}\n\n\t/* avoid filling log waiting for fileio reply */\n\tif (target->semihosting && target->semihosting->hit_fileio)\n\t\treturn ERROR_OK;\n\n\tLOG_USER(\"target halted in %s state due to %s, current mode: %s\\n\"\n\t\t\"cpsr: 0x%8.8\" PRIx32 \" pc: 0x%8.8\" PRIx32 \"%s%s\",\n\t\tarm_state_strings[arm->core_state],\n\t\tdebug_reason_name(target),\n\t\tarm_mode_name(arm->core_mode),\n\t\tbuf_get_u32(arm->cpsr->value, 0, 32),\n\t\tbuf_get_u32(arm->pc->value, 0, 32),\n\t\t(target->semihosting && target->semihosting->is_active) ? \", semihosting\" : \"\",\n\t\t(target->semihosting && target->semihosting->is_fileio) ? \" fileio\" : \"\");\n\n\treturn ERROR_OK;\n}", "item_id": 6, "repo": "ucsc-vama/rocket-chip-misc", "file": "riscv-tools/riscv-openocd/src/target/armv4_5.c", "last_update_at": "2020-06-05T02:34:13+00:00", "question_id": "96a63e497adeb1256fd034555b09a9cdb6c2b967_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int arm_arch_state(struct target *target)\n{\n\tstruct arm *arm = target_to_arm(target);\n\tif (arm->common_magic != ARM_COMMON_MAGIC) {\n\t\tLOG_ERROR(\"BUG: called for a non-ARM target\");\n\t\treturn ERROR_FAIL;\n\t}\n\t/* avoid filling log waiting for fileio reply */\n\tif (target->semihosting && target->semihosting->hit_fileio)\n\t\treturn ERROR_OK;\n\tLOG_USER(\"target halted in %s state due to %s, current mode: %s\\n\"\n\t\t\"cpsr: 0x%8.8\" PRIx32 \" pc: 0x%8.8\" PRIx32 \"%s%s\",\n\t\tarm_state_strings[arm->core_state],\n\t\tdebug_reason_name(target),\n\t\tarm_mode_name(arm->core_mode),\n\t\tbuf_get_u32(arm->cpsr->value, 0, 32),\n\t\tbuf_get_u32(arm->pc->value, 0, 32),\n\t\t(target->semihosting && target->semihosting->is_active) ? \", semihosting\" : \"\",\n\t\t(target->semihosting && target->semihosting->is_fileio) ? \" fileio\" : \"\");\n\treturn ERROR_OK;\n"]]}
{"hexsha": "89e3fb19dc4699becd4c89ca3db96b765fba5cc2", "ext": "c", "lang": "C", "content": "telospacket *read_telos_packet(int fd)\n\n{\n  int length;\n  telospacket *packet;\n  int i;\n  \n  const unsigned char *rawpkt;\n\n  //make sure I'm the only one reading the serial port\n  //pthread_mutex_lock(&sfreadmutex);\n\n  rawpkt = read_sf_packet(fd, &length);\n\tdbg(TSRC,\"read_sf_packet returned (rawpkt=%X, length=%i).\\n\",(int)rawpkt, length);\n\tif (rawpkt == NULL)\n\t{\n\t\tdbg(TSRC,\"rawpkt is NULL\\n\");\n\t\treturn NULL;\n\t}\n       \tprintf(\"Got data...\\n\");\n  for (i=0; i < length; i++)\n    printf(\"%X \", rawpkt[i]);\n  printf(\"\\nGet done.\\n\");\n  //pthread_mutex_unlock(&sfreadmutex);\n\n  if (length < 10)\n    {\n    \tdbg(TSRC,\"too short.\\n\");\n      free((void*)rawpkt);\n      return NULL;\n    }\n\n  packet = malloc(sizeof(telospacket));\n  \n  //get header information\n  packet->length = rawpkt[0];\n  packet->dsn = rawpkt[3];\n  packet->type = rawpkt[8];\n  packet->group = rawpkt[9];\n  packet->addr = rawpkt[6] | (rawpkt[7] << 8);\n  packet->data = malloc(packet->length);\n  if (!packet->data)\n  {\n  \tprintf(\"Out of memory!\\n\");\n  \tfree(packet);\n  }\n  printf(\"addr=%X\\n\",packet->addr);\n  memcpy(packet->data, rawpkt+10, packet->length);\n  free((void*)rawpkt);\n  \n  return packet;\n}", "item_id": 3, "repo": "tinyos-io/tinyos-3.x-contrib", "file": "eon/eon/src/client/sfaccess/telossource.c", "last_update_at": "2020-02-28T20:35:09+00:00", "question_id": "89e3fb19dc4699becd4c89ca3db96b765fba5cc2_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["telospacket *read_telos_packet(int fd)\n{\n  int length;\n  telospacket *packet;\n  int i;\n  const unsigned char *rawpkt;\n  //make sure I'm the only one reading the serial port\n  //pthread_mutex_lock(&sfreadmutex);\n  rawpkt = read_sf_packet(fd, &length);\n\tdbg(TSRC,\"read_sf_packet returned (rawpkt=%X, length=%i).\\n\",(int)rawpkt, length);\n\tif (rawpkt == NULL)\n\t{\n\t\tdbg(TSRC,\"rawpkt is NULL\\n\");\n\t\treturn NULL;\n\t}\n       \tprintf(\"Got data...\\n\");\n  for (i=0; i < length; i++)\n    printf(\"%X \", rawpkt[i]);\n  printf(\"\\nGet done.\\n\");\n  //pthread_mutex_unlock(&sfreadmutex);\n  if (length < 10)\n    {\n    \tdbg(TSRC,\"too short.\\n\");\n      free((void*)rawpkt);\n      return NULL;\n    }\n  packet = malloc(sizeof(telospacket));\n  //get header information\n  packet->length = rawpkt[0];\n  packet->dsn = rawpkt[3];\n  packet->type = rawpkt[8];\n  packet->group = rawpkt[9];\n  packet->addr = rawpkt[6] | (rawpkt[7] << 8);\n  packet->data = malloc(packet->length);\n  if (!packet->data)\n  {\n  \tprintf(\"Out of memory!\\n\");\n  \tfree(packet);\n  }\n  printf(\"addr=%X\\n\",packet->addr);\n  memcpy(packet->data, rawpkt+10, packet->length);\n  free((void*)rawpkt);\n  return packet;\n"]]}
{"hexsha": "23836bfcc5b5fd26390fa1ba240355a1cd416b90", "ext": "h", "lang": "C", "content": "class il2cpp_binding_internal : public il2cpp_binding {\npublic:\n\til2cpp_binding_internal(const il2cpp_context &ctx);\n\t~il2cpp_binding_internal();\n\n\tvoid setupHooks();\n\n\tconst il2cpp_context &mCtx;\n\tstd::vector<HookCall> mHooks;\n\tstd::unordered_map<std::string, size_t> mHooksByMethodName;\n\tstd::unordered_map<uint64_t, size_t> mHooksByInvocation;\n\n\tuint64_t mFnId;\n\tstd::vector<void *> mBuffers;\n\tvoid *mCurrentPtr;\n}", "item_id": 0, "repo": "Mettra/AudicaModLoader", "file": "AudicaModDoorstop/src/il2cpp_binding_internal.h", "last_update_at": "2020-04-14T01:07:45+00:00", "question_id": "23836bfcc5b5fd26390fa1ba240355a1cd416b90_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class il2cpp_binding_internal : public il2cpp_binding {\npublic:\n\til2cpp_binding_internal(const il2cpp_context &ctx);\n\t~il2cpp_binding_internal();\n\tvoid setupHooks();\n\tconst il2cpp_context &mCtx;\n\tstd::vector<HookCall> mHooks;\n\tstd::unordered_map<std::string, size_t> mHooksByMethodName;\n\tstd::unordered_map<uint64_t, size_t> mHooksByInvocation;\n\tuint64_t mFnId;\n\tstd::vector<void *> mBuffers;\n\tvoid *mCurrentPtr;\n"]]}
{"hexsha": "1d71bfe7f5b4a1b7dce1b0e2e989c53e5ea799cd", "ext": "c", "lang": "C", "content": "void mMult(Mat4 *m1, Mat4 m2) {\n\tint c, r, k;\n\tMat4 m3;\n\tfor(r = 0; r < 4; r ++) {\n\t\tfor(c = 0; c < 4; c ++) {\n\t\t\tfloat sum = 0;\n\t\t\tfor(k = 0; k < 4; k ++) {\n\t\t\t\tsum += m1->at[r][k] * m2.at[k][c];\n\t\t\t}\n\t\t\tm3.at[r][c] = sum;\n\t\t}\n\t}\n\tfor(c = 0; c < 16; c ++) m1->values[c] = m3.values[c];\n}", "item_id": 0, "repo": "DarioAle/graphics-programming-openGL", "file": "S13_Perpectiva/Transforms/Mat4.c", "last_update_at": "2020-03-10T01:37:09+00:00", "question_id": "1d71bfe7f5b4a1b7dce1b0e2e989c53e5ea799cd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void mMult(Mat4 *m1, Mat4 m2) {\n\tint c, r, k;\n\tMat4 m3;\n\tfor(r = 0; r < 4; r ++) {\n\t\tfor(c = 0; c < 4; c ++) {\n\t\t\tfloat sum = 0;\n\t\t\tfor(k = 0; k < 4; k ++) {\n\t\t\t\tsum += m1->at[r][k] * m2.at[k][c];\n\t\t\t}\n\t\t\tm3.at[r][c] = sum;\n\t\t}\n\t}\n\tfor(c = 0; c < 16; c ++) m1->values[c] = m3.values[c];\n"]]}
{"hexsha": "ac2a4f2af01c11d48c58f157698c38a36a9dc324", "ext": "c", "lang": "C", "content": "void midi_send_aftertouch(u8 index, u8 value){\n\tu8 midi_note = layout_get_midi_note(index);\n\thal_send_midi(USBMIDI, (POLYAFTERTOUCH + (current_midi_channel - 1)) | 0, midi_note, value);\n\thal_send_midi(DINMIDI, (POLYAFTERTOUCH + (current_midi_channel - 1)) | 0, midi_note, value);\n}", "item_id": 2, "repo": "Sk4rT4l/launchpad-pro-chords-and-scales", "file": "src/utils/midi.c", "last_update_at": "2020-05-13T11:31:04+00:00", "question_id": "ac2a4f2af01c11d48c58f157698c38a36a9dc324_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void midi_send_aftertouch(u8 index, u8 value){\n\tu8 midi_note = layout_get_midi_note(index);\n\thal_send_midi(USBMIDI, (POLYAFTERTOUCH + (current_midi_channel - 1)) | 0, midi_note, value);\n\thal_send_midi(DINMIDI, (POLYAFTERTOUCH + (current_midi_channel - 1)) | 0, midi_note, value);\n"]]}
{"hexsha": "846a9997156ea49969e721be538ae2c1b501cc70", "ext": "c", "lang": "C", "content": "int main(int argc, char* argv[])\r\n{\r\n  GMainLoop* gst_main_loop;\r\n  GThread* main_loop_thread;\r\n  struct event_base* base = NULL;\r\n  struct evhttp* httpSvr = NULL;\r\n  int res = 0;\r\n\r\n#ifdef _WIN32\r\n  {\r\n    /* If running on Windows need to initialise sockets. */\r\n    WORD wVersionRequested;\r\n    WSADATA wsaData;\r\n    wVersionRequested = MAKEWORD(2, 2);\r\n    WSAStartup(wVersionRequested, &wsaData);\r\n  }\r\n#endif\r\n\r\n  /* Initialise GStreamer. */\r\n  gst_init (&argc, &argv);\r\n\r\n  gst_main_loop = g_main_loop_new(NULL, FALSE);\r\n  main_loop_thread = g_thread_new(\"main_loop\", (GThreadFunc)g_main_loop_run, gst_main_loop);\r\n  if (main_loop_thread == NULL) {\r\n    fprintf(stderr, \"Couldn't create a main loop thread.\\n\");\r\n    return -1;\r\n  }\r\n\r\n  /* Initialise libevent HTTP server. */\r\n  base = event_base_new();\r\n  if (!base) {\r\n    fprintf(stderr, \"Couldn't create an event_base: exiting.\\n\");\r\n    return -1;\r\n  }\r\n\r\n  httpSvr = evhttp_new(base);\r\n  if (!httpSvr) {\r\n    fprintf(stderr, \"couldn't create evhttp. Exiting.\\n\");\r\n    return -1;\r\n  }\r\n\r\n  res = evhttp_bind_socket(httpSvr, HTTP_SERVER_ADDRESS, HTTP_SERVER_PORT);\r\n  if (res != 0) {\r\n    fprintf(stderr, \"Failed to start HTTP server on %s:%d.\\n\", HTTP_SERVER_ADDRESS, HTTP_SERVER_PORT);\r\n    return res;\r\n  }\r\n\r\n  evhttp_set_allowed_methods(httpSvr,\r\n    EVHTTP_REQ_GET |\r\n    EVHTTP_REQ_POST |\r\n    EVHTTP_REQ_OPTIONS);\r\n\r\n  printf(\"Waiting for SDP offer on http://%s:%d%s...\\n\", HTTP_SERVER_ADDRESS, HTTP_SERVER_PORT, HTTP_OFFER_URL);\r\n\r\n  res = evhttp_set_cb(httpSvr, HTTP_OFFER_URL, on_http_request_cb, NULL);\r\n\r\n  event_base_dispatch(base);\r\n\r\n  g_main_loop_unref (gst_main_loop);\r\n\r\n  evhttp_free(httpSvr);\r\n\r\n#ifdef _WIN32\r\n  WSACleanup();\r\n#endif\r\n\r\n  return 0;\r\n}", "item_id": 0, "repo": "sipsorcery/prototypes", "file": "gstreamer-webrtc-echo/gstreamer-webrtc-echo.c", "last_update_at": "2020-07-26T17:01:49+00:00", "question_id": "846a9997156ea49969e721be538ae2c1b501cc70_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char* argv[])\r\n{\r\n  GMainLoop* gst_main_loop;\r\n  GThread* main_loop_thread;\r\n  struct event_base* base = NULL;\r\n  struct evhttp* httpSvr = NULL;\r\n  int res = 0;\r\n\r\n#ifdef _WIN32\r\n  {\r\n    /* If running on Windows need to initialise sockets. */\r\n    WORD wVersionRequested;\r\n    WSADATA wsaData;\r\n    wVersionRequested = MAKEWORD(2, 2);\r\n    WSAStartup(wVersionRequested, &wsaData);\r\n  }\r\n#endif\r\n\r\n  /* Initialise GStreamer. */\r\n  gst_init (&argc, &argv);\r\n\r\n  gst_main_loop = g_main_loop_new(NULL, FALSE);\r\n  main_loop_thread = g_thread_new(\"main_loop\", (GThreadFunc)g_main_loop_run, gst_main_loop);\r\n  if (main_loop_thread == NULL) {\r\n    fprintf(stderr, \"Couldn't create a main loop thread.\\n\");\r\n    return -1;\r\n  }\r\n\r\n  /* Initialise libevent HTTP server. */\r\n  base = event_base_new();\r\n  if (!base) {\r\n    fprintf(stderr, \"Couldn't create an event_base: exiting.\\n\");\r\n    return -1;\r\n  }\r\n\r\n  httpSvr = evhttp_new(base);\r\n  if (!httpSvr) {\r\n    fprintf(stderr, \"couldn't create evhttp. Exiting.\\n\");\r\n    return -1;\r\n  }\r\n\r\n  res = evhttp_bind_socket(httpSvr, HTTP_SERVER_ADDRESS, HTTP_SERVER_PORT);\r\n  if (res != 0) {\r\n    fprintf(stderr, \"Failed to start HTTP server on %s:%d.\\n\", HTTP_SERVER_ADDRESS, HTTP_SERVER_PORT);\r\n    return res;\r\n  }\r\n\r\n  evhttp_set_allowed_methods(httpSvr,\r\n    EVHTTP_REQ_GET |\r\n    EVHTTP_REQ_POST |\r\n    EVHTTP_REQ_OPTIONS);\r\n\r\n  printf(\"Waiting for SDP offer on http://%s:%d%s...\\n\", HTTP_SERVER_ADDRESS, HTTP_SERVER_PORT, HTTP_OFFER_URL);\r\n\r\n  res = evhttp_set_cb(httpSvr, HTTP_OFFER_URL, on_http_request_cb, NULL);\r\n\r\n  event_base_dispatch(base);\r\n\r\n  g_main_loop_unref (gst_main_loop);\r\n\r\n  evhttp_free(httpSvr);\r\n\r\n#ifdef _WIN32\r\n  WSACleanup();\r\n#endif\r\n\r\n  return 0;\r\n"]]}
{"hexsha": "f578896bece271678209febd3701e4c76f33b7fd", "ext": "c", "lang": "C", "content": "int\nposix_spawnattr_getflags(\n\tconst posix_spawnattr_t *attr,\n\tshort *flags)\n{\n\tspawn_attr_t *sap = attr->__spawn_attrp;\n\n\tif (sap == NULL)\n\t\treturn (EINVAL);\n\n\t*flags = sap->sa_psflags;\n\treturn (0);\n}", "item_id": 16, "repo": "AsahiOS/gate", "file": "usr/src/lib/libc/port/threads/spawn.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "f578896bece271678209febd3701e4c76f33b7fd_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nposix_spawnattr_getflags(\n\tconst posix_spawnattr_t *attr,\n\tshort *flags)\n{\n\tspawn_attr_t *sap = attr->__spawn_attrp;\n\tif (sap == NULL)\n\t\treturn (EINVAL);\n\t*flags = sap->sa_psflags;\n\treturn (0);\n"]]}
{"hexsha": "ec9f8cf3d018e645732e3f302665c09b0e3c6bee", "ext": "c", "lang": "C", "content": "int func_203(int iParam0)\n{\n\tint iVar0;\n\t\n\tif (iParam0 == -1)\n\t{\n\t\tiParam0 = func_186();\n\t}\n\tif (iParam0 == -1)\n\t{\n\t\treturn 0;\n\t}\n\tiVar0 = func_205(&(Global_110945[iParam0 /*10*/].f_9), 1, 4, 0, 0);\n\tif (!iVar0 == 1)\n\t{\n\t\treturn 0;\n\t}\n\tfunc_204(iParam0);\n\treturn 1;\n}", "item_id": 110, "repo": "Seanghost117/GTA-V-Decompiled-Scripts", "file": "decompiled_scripts/launcher_rampage.c", "last_update_at": "2020-12-16T17:13:14+00:00", "question_id": "ec9f8cf3d018e645732e3f302665c09b0e3c6bee_110", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int func_203(int iParam0)\n{\n\tint iVar0;\n\t\n\tif (iParam0 == -1)\n\t{\n\t\tiParam0 = func_186();\n\t}\n\tif (iParam0 == -1)\n\t{\n\t\treturn 0;\n\t}\n\tiVar0 = func_205(&(Global_110945[iParam0 /*10*/].f_9), 1, 4, 0, 0);\n\tif (!iVar0 == 1)\n\t{\n\t\treturn 0;\n\t}\n\tfunc_204(iParam0);\n\treturn 1;\n"]]}
{"hexsha": "d052ec556de1c6318f14a8426762d62c653c74a8", "ext": "h", "lang": "C", "content": "namespace edk {\n\nstruct FormatInfo {\n  PixelFmt edk_fmt;\n  cncodecPixelFormat cncodec_fmt;\n  unsigned int plane_num;\n  std::string fmt_str;\n  bool supported;\n\n  static const FormatInfo* GetFormatInfo(PixelFmt fmt);\n  unsigned int GetPlaneSize(unsigned int pitch, unsigned int height, unsigned int plane) const;\n};\n\ncncodecType CodecTypeCast(CodecType type);\ncncodecColorSpace ColorStdCast(ColorStd color_std);\n\n}", "item_id": 0, "repo": "AmazingCreator-lmx/CNStream", "file": "easydk/src/easycodec/format_info.h", "last_update_at": "2020-07-20T10:46:40+00:00", "question_id": "d052ec556de1c6318f14a8426762d62c653c74a8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace edk {\nstruct FormatInfo {\n  PixelFmt edk_fmt;\n  cncodecPixelFormat cncodec_fmt;\n  unsigned int plane_num;\n  std::string fmt_str;\n  bool supported;\n  static const FormatInfo* GetFormatInfo(PixelFmt fmt);\n  unsigned int GetPlaneSize(unsigned int pitch, unsigned int height, unsigned int plane) const;\n};\ncncodecType CodecTypeCast(CodecType type);\ncncodecColorSpace ColorStdCast(ColorStd color_std);\n"]]}
{"hexsha": "94cf9dce0ea01623b6073c99f547d80e37133037", "ext": "c", "lang": "C", "content": "void ssao_destroy(struct ssao* s)\n{\n    free(s->kernel);\n    glDeleteTextures(1, &s->gl.noise_tex);\n    glDeleteTextures(1, &s->gl.ao_ctex);\n    glDeleteTextures(1, &s->gl.blur_ctex);\n    glDeleteFramebuffers(1, &s->gl.ao_fbo);\n    glDeleteFramebuffers(1, &s->gl.blur_fbo);\n}", "item_id": 4, "repo": "ElArtista/EnergyCore", "file": "src/ssao.c", "last_update_at": "2020-02-22T00:28:09+00:00", "question_id": "94cf9dce0ea01623b6073c99f547d80e37133037_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void ssao_destroy(struct ssao* s)\n{\n    free(s->kernel);\n    glDeleteTextures(1, &s->gl.noise_tex);\n    glDeleteTextures(1, &s->gl.ao_ctex);\n    glDeleteTextures(1, &s->gl.blur_ctex);\n    glDeleteFramebuffers(1, &s->gl.ao_fbo);\n    glDeleteFramebuffers(1, &s->gl.blur_fbo);\n"]]}
{"hexsha": "ea86865f6e3ef71aaa2a43dbecdab961c99806c3", "ext": "c", "lang": "C", "content": "void W25QXX_Write(uint32_t Addr, uint8_t* pData, uint32_t BytesToWrite)\n{\n\tuint8_t Offset = Addr % PAGE_SIZE;\n\n\tif (Offset != 0)\n\t{\n\t\tuint8_t PageRemainBytes = PAGE_SIZE - Offset;\n\n\t\tif (BytesToWrite <= PageRemainBytes)\n\t\t{\n\t\t\tW25QXX_PageWrite(Addr, pData, BytesToWrite);\n\t\t\treturn;\n\t\t}\n\n\t\tW25QXX_PageWrite(Addr, pData, PageRemainBytes);\n\t\tAddr += PageRemainBytes;\n\t\tpData += PageRemainBytes;\n\t\tBytesToWrite -= PageRemainBytes;\n\t}\n\n\tuint8_t PageCount = BytesToWrite / PAGE_SIZE;\n\tuint8_t SingleCount = BytesToWrite % PAGE_SIZE;\n\n\twhile (PageCount--)\n\t{\n\t\tW25QXX_PageWrite(Addr, pData, PAGE_SIZE);\n\t\tAddr += PAGE_SIZE;\n\t\tpData += PAGE_SIZE;\n\t}\n\tW25QXX_PageWrite(Addr, pData, SingleCount);\n\n}", "item_id": 1, "repo": "SICETA-UESTC/STM32F4-VisualGDBTemplate", "file": "Src/w25qxx.c", "last_update_at": "2020-01-20T04:06:39+00:00", "question_id": "ea86865f6e3ef71aaa2a43dbecdab961c99806c3_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void W25QXX_Write(uint32_t Addr, uint8_t* pData, uint32_t BytesToWrite)\n{\n\tuint8_t Offset = Addr % PAGE_SIZE;\n\tif (Offset != 0)\n\t{\n\t\tuint8_t PageRemainBytes = PAGE_SIZE - Offset;\n\t\tif (BytesToWrite <= PageRemainBytes)\n\t\t{\n\t\t\tW25QXX_PageWrite(Addr, pData, BytesToWrite);\n\t\t\treturn;\n\t\t}\n\t\tW25QXX_PageWrite(Addr, pData, PageRemainBytes);\n\t\tAddr += PageRemainBytes;\n\t\tpData += PageRemainBytes;\n\t\tBytesToWrite -= PageRemainBytes;\n\t}\n\tuint8_t PageCount = BytesToWrite / PAGE_SIZE;\n\tuint8_t SingleCount = BytesToWrite % PAGE_SIZE;\n\twhile (PageCount--)\n\t{\n\t\tW25QXX_PageWrite(Addr, pData, PAGE_SIZE);\n\t\tAddr += PAGE_SIZE;\n\t\tpData += PAGE_SIZE;\n\t}\n\tW25QXX_PageWrite(Addr, pData, SingleCount);\n"]]}
{"hexsha": "83edeb93a81a76f71face01a04777e84e0f293f2", "ext": "c", "lang": "C", "content": "__STATIC_INLINE void pulseDirectionalPriority(void)\n{\n  COEX_Req_t combinedReqState = coexCfg.combinedRequestState; // Local non-volatile flavor avoids warnings\n  bool highPriority = ((combinedReqState & COEX_REQ_HIPRI) != 0U);\n  bool setRequest = ((combinedReqState & COEX_REQ_ON) != 0U);\n\n  // DP priority possible\n  // Not in Direction PRIORITY bypass?\n  if ((COEX_HAL_GetDpPulseWidth() != 0)\n      // coexUpdateReqIsr() triggered by REQUEST changing, not PWM changing?\n      && (setRequest != getGpioOut(reqHandle, false))\n      // PRIORITY changing requiring a new priority pulse?\n      && (highPriority && !getGpioOut(priHandle, false))) {\n    COEX_ClearRequestAndPriority(); // then deaasert all PTA signals\n  }\n}", "item_id": 23, "repo": "lenloe1/v2.7", "file": "platform/radio/rail_lib/plugin/coexistence/common/coexistence.c", "last_update_at": "2020-08-25T02:36:22+00:00", "question_id": "83edeb93a81a76f71face01a04777e84e0f293f2_23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["__STATIC_INLINE void pulseDirectionalPriority(void)\n{\n  COEX_Req_t combinedReqState = coexCfg.combinedRequestState; // Local non-volatile flavor avoids warnings\n  bool highPriority = ((combinedReqState & COEX_REQ_HIPRI) != 0U);\n  bool setRequest = ((combinedReqState & COEX_REQ_ON) != 0U);\n  // DP priority possible\n  // Not in Direction PRIORITY bypass?\n  if ((COEX_HAL_GetDpPulseWidth() != 0)\n      // coexUpdateReqIsr() triggered by REQUEST changing, not PWM changing?\n      && (setRequest != getGpioOut(reqHandle, false))\n      // PRIORITY changing requiring a new priority pulse?\n      && (highPriority && !getGpioOut(priHandle, false))) {\n    COEX_ClearRequestAndPriority(); // then deaasert all PTA signals\n  }\n"]]}
{"hexsha": "eacf553d68478d3e8b35d7593967e89071755c3e", "ext": "c", "lang": "C", "content": "int main()\n{\n    int arr[3][4] = {{1, 2, 3, 4}, {2, 4, 6, 8}, {1, 3, 5, 7}};\n\n    int *brr[3];\n\n    int **crr;\n\n    printf(\"Printing 2D Array From Stack\\n\");\n\n    for(int i = 0; i < 3; i++)\n    {\n        for(int j = 0; j < 4; j++)\n        {\n            printf(\"%d \", arr[i][j]);\n        }\n\n        printf(\"\\n\");\n    }\n\n    printf(\"\\n\");\n\n    brr[0] = (int *) malloc(4 * sizeof(int));\n\n    brr[1] = (int *) malloc(4 * sizeof(int));\n\n    brr[2] = (int *) malloc(4 * sizeof(int));\n\n    printf(\"Printing 2D Array From Heap Using Single Pointer\\n\");\n\n    int brrCounter = 0;\n\n    for(int i = 0; i < 3; i++)\n    {\n        for(int j = 0; j < 4; j++)\n        {\n            brr[i][j] = ++brrCounter;\n\n            printf(\"%d \", brr[i][j]);\n        }\n\n        printf(\"\\n\");\n    }\n\n    printf(\"\\n\");\n\n    crr = (int **) malloc(3 * sizeof(int *));\n\n    crr[0] = (int *) malloc(4 * sizeof(int));\n\n    crr[1] = (int *) malloc(4 * sizeof(int));\n\n    crr[2] = (int *) malloc(4 * sizeof(int));\n\n    printf(\"Printing 2D Array From Heap Using Double Pointer\\n\");\n\n    int crrCounter = 0;\n\n    for(int i = 0; i < 3; i++)\n    {\n        for(int j = 0; j < 4; j++)\n        {\n            crr[i][j] = ++crrCounter;\n\n            printf(\"%d \", crr[i][j]);\n        }\n\n        printf(\"\\n\");\n    }\n\n    return 0;\n}", "item_id": 0, "repo": "Anim-101/CourseHub", "file": "Abdul Bari/Mastering Algorithm/Array Declaration/2D Array.c", "last_update_at": "2020-04-01T10:27:05+00:00", "question_id": "eacf553d68478d3e8b35d7593967e89071755c3e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main()\n{\n    int arr[3][4] = {{1, 2, 3, 4}, {2, 4, 6, 8}, {1, 3, 5, 7}};\n    int *brr[3];\n    int **crr;\n    printf(\"Printing 2D Array From Stack\\n\");\n    for(int i = 0; i < 3; i++)\n    {\n        for(int j = 0; j < 4; j++)\n        {\n            printf(\"%d \", arr[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    brr[0] = (int *) malloc(4 * sizeof(int));\n    brr[1] = (int *) malloc(4 * sizeof(int));\n    brr[2] = (int *) malloc(4 * sizeof(int));\n    printf(\"Printing 2D Array From Heap Using Single Pointer\\n\");\n    int brrCounter = 0;\n    for(int i = 0; i < 3; i++)\n    {\n        for(int j = 0; j < 4; j++)\n        {\n            brr[i][j] = ++brrCounter;\n            printf(\"%d \", brr[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    crr = (int **) malloc(3 * sizeof(int *));\n    crr[0] = (int *) malloc(4 * sizeof(int));\n    crr[1] = (int *) malloc(4 * sizeof(int));\n    crr[2] = (int *) malloc(4 * sizeof(int));\n    printf(\"Printing 2D Array From Heap Using Double Pointer\\n\");\n    int crrCounter = 0;\n    for(int i = 0; i < 3; i++)\n    {\n        for(int j = 0; j < 4; j++)\n        {\n            crr[i][j] = ++crrCounter;\n            printf(\"%d \", crr[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n"]]}
{"hexsha": "d18844dfed35e8806c7ae0fc0edb034dcb56d5e0", "ext": "c", "lang": "C", "content": "inline static  result_t CascadesRouterM$SubControl$init(void){\n#line 63\n  unsigned char result;\n#line 63\n\n#line 63\n  result = CascadesEngineM$StdControl$init();\n#line 63\n  result = rcombine(result, NeighborMgmtM$StdControl$init());\n#line 63\n\n#line 63\n  return result;\n#line 63\n}", "item_id": 17, "repo": "tinyos-io/tinyos-3.x-contrib", "file": "wsu/tools/XMonitor/oasis/apps/OasisApp/build/imote2/app.c", "last_update_at": "2020-02-28T20:35:09+00:00", "question_id": "d18844dfed35e8806c7ae0fc0edb034dcb56d5e0_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["inline static  result_t CascadesRouterM$SubControl$init(void){\n#line 63\n  unsigned char result;\n#line 63\n#line 63\n  result = CascadesEngineM$StdControl$init();\n#line 63\n  result = rcombine(result, NeighborMgmtM$StdControl$init());\n#line 63\n#line 63\n  return result;\n#line 63\n"]]}
{"hexsha": "673a71fdced3f532dac77ae1566689e059650efd", "ext": "c", "lang": "C", "content": "API_RESULT cli_modelc_light_xyl_default_set(UINT32 argc, UCHAR * argv[])\n{\n    API_RESULT retval;\n    int  choice;\n    MS_LIGHT_XYL_DEFAULT_SET_STRUCT  param;\n\n    CONSOLE_OUT\n    (\">> Send Light Xyl Default Set\\n\");\n\n    if (3 == argc)\n    {\n        choice = CLI_strtoi(argv[0], CLI_strlen(argv[0]), 16);\n        param.lightness = (UINT16)choice;\n        CONSOLE_OUT(\"Lightness (16-bit in HEX): 0x%04X\\n\", param.lightness);\n\n        choice = CLI_strtoi(argv[1], CLI_strlen(argv[1]), 16);\n        param.xyl_x = (UINT16)choice;\n        CONSOLE_OUT(\"xyL x (16-bit in HEX): 0x%04X\\n\", param.xyl_x);\n\n        choice = CLI_strtoi(argv[2], CLI_strlen(argv[2]), 16);\n        param.xyl_y = (UINT16)choice;\n        CONSOLE_OUT(\"xyL y (16-bit in HEX): 0x%04X\\n\", param.xyl_y);\n    }\n\n    retval = MS_light_xyl_default_set(&param);\n\n    CONSOLE_OUT\n    (\"retval = 0x%04X\\n\", retval);\n\n    return retval;\n}", "item_id": 3, "repo": "sentervip/phy62xBleSDk2.0.1", "file": "PHY62XX_SDK_2.0.1/components/ethermind/mesh/export/cli/model/client/cli_light_xyl_client.c", "last_update_at": "2020-12-14T19:47:20+00:00", "question_id": "673a71fdced3f532dac77ae1566689e059650efd_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["API_RESULT cli_modelc_light_xyl_default_set(UINT32 argc, UCHAR * argv[])\n{\n    API_RESULT retval;\n    int  choice;\n    MS_LIGHT_XYL_DEFAULT_SET_STRUCT  param;\n    CONSOLE_OUT\n    (\">> Send Light Xyl Default Set\\n\");\n    if (3 == argc)\n    {\n        choice = CLI_strtoi(argv[0], CLI_strlen(argv[0]), 16);\n        param.lightness = (UINT16)choice;\n        CONSOLE_OUT(\"Lightness (16-bit in HEX): 0x%04X\\n\", param.lightness);\n        choice = CLI_strtoi(argv[1], CLI_strlen(argv[1]), 16);\n        param.xyl_x = (UINT16)choice;\n        CONSOLE_OUT(\"xyL x (16-bit in HEX): 0x%04X\\n\", param.xyl_x);\n        choice = CLI_strtoi(argv[2], CLI_strlen(argv[2]), 16);\n        param.xyl_y = (UINT16)choice;\n        CONSOLE_OUT(\"xyL y (16-bit in HEX): 0x%04X\\n\", param.xyl_y);\n    }\n    retval = MS_light_xyl_default_set(&param);\n    CONSOLE_OUT\n    (\"retval = 0x%04X\\n\", retval);\n    return retval;\n"]]}
{"hexsha": "16bc57965f6d32e92fcb8cff212392fe30d48ae2", "ext": "c", "lang": "C", "content": "const char* get_issuer_alias(CERT_PROPS_HANDLE handle)\n{\n    const char* result;\n    if (handle == NULL)\n    {\n        LogError(\"Invalid parameter encounterered\");\n        result = NULL;\n    }\n    else\n    {\n        result = handle->issuer_alias;\n    }\n    return result;\n}", "item_id": 19, "repo": "kkdawkins/iotedge", "file": "edgelet/hsm-sys/azure-iot-hsm-c/src/hsm_certificate_props.c", "last_update_at": "2020-02-12T05:23:09+00:00", "question_id": "16bc57965f6d32e92fcb8cff212392fe30d48ae2_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const char* get_issuer_alias(CERT_PROPS_HANDLE handle)\n{\n    const char* result;\n    if (handle == NULL)\n    {\n        LogError(\"Invalid parameter encounterered\");\n        result = NULL;\n    }\n    else\n    {\n        result = handle->issuer_alias;\n    }\n    return result;\n"]]}
{"hexsha": "fe3921dfd614577bc599079480c73d03e74a86b0", "ext": "c", "lang": "C", "content": "void sck_smallwrite(char* data, unsigned int len){\n    sck->mode = 1;\n    sck->outlen = len;\n    memcpy(sck->buffer, data, len);\n    sck->cmd1 = 4;\n    while(sck->cmd1 == 4);\n}", "item_id": 4, "repo": "aerospark/rpcprojects", "file": "cide.c", "last_update_at": "2020-08-01T21:03:41+00:00", "question_id": "fe3921dfd614577bc599079480c73d03e74a86b0_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void sck_smallwrite(char* data, unsigned int len){\n    sck->mode = 1;\n    sck->outlen = len;\n    memcpy(sck->buffer, data, len);\n    sck->cmd1 = 4;\n    while(sck->cmd1 == 4);\n"]]}
{"hexsha": "8329f30483c494b9a9c846bfc92fdce9e6a6eacb", "ext": "h", "lang": "C", "content": "class FileSystem {\npublic:\n    static class IFileWrite * OpenWriteFile(const char * fileName, bool append, class IInstanceLog * log);\n    static class IFileRead * OpenReadFile(const char * fileName, class IInstanceLog * log);\n    static class IDirectory * OpenDirectory(const char * directoryPath, class IInstanceLog * log);\n    static class IElfBinary * OpenElfBinary(const char * bin, class IInstanceLog * log);\n    static bool ReadWholeFile(const char * filename, char * readBuffer, size_t size, class IInstanceLog * log);\n    static bool WriteWholeFile(const char * filename, const char * writeBuffer, size_t size, class IInstanceLog * log);\n    static bool ScanFile(class IInstanceLog * log, const char * filename, const char * format, ...);\n    static bool FileExists(const char * filename, class IInstanceLog * log);\n    static time_t GetLastWriteTime(const char * filename, class IInstanceLog * log);\n    static off_t GetFileSize(const char * filename, class IInstanceLog * log);\n    static off_t GetFileBlockSize(const char * filename, class IInstanceLog * log);\n    static bool Rename(const char * oldName, const char * newName, class IInstanceLog * log);\n    static bool RemoveFile(const char * filename, class IInstanceLog * log);\n    static bool CreateDirectory(const char * absolutePath, int mode, class IInstanceLog * log);\n    static bool RemoveDirectory(const char * directoryPath, class IInstanceLog * log);\n    static bool ChangeOwner(const char * path, const char * newOwner, const char * newGroup, class IInstanceLog * log);\n    static bool ChangeMode(const char * path, int mode, class IInstanceLog * log);\n    static ulong64 GetFileSystemTotalSize(const char * path, class IInstanceLog * log);\n    static ulong64 GetFileSystemUsedSpace(const char * path, class IInstanceLog * log);\n    static bool CheckSystemUser(const char * user, const char * group, class IInstanceLog * log);\n    static char * GetFileSystemUser(const char * filepath, class IInstanceLog * log);\n}", "item_id": 0, "repo": "innovaphone/13r1-sdk", "file": "common/interface/file.h", "last_update_at": "2020-01-17T13:33:14+00:00", "question_id": "8329f30483c494b9a9c846bfc92fdce9e6a6eacb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class FileSystem {\npublic:\n    static class IFileWrite * OpenWriteFile(const char * fileName, bool append, class IInstanceLog * log);\n    static class IFileRead * OpenReadFile(const char * fileName, class IInstanceLog * log);\n    static class IDirectory * OpenDirectory(const char * directoryPath, class IInstanceLog * log);\n    static class IElfBinary * OpenElfBinary(const char * bin, class IInstanceLog * log);\n    static bool ReadWholeFile(const char * filename, char * readBuffer, size_t size, class IInstanceLog * log);\n    static bool WriteWholeFile(const char * filename, const char * writeBuffer, size_t size, class IInstanceLog * log);\n    static bool ScanFile(class IInstanceLog * log, const char * filename, const char * format, ...);\n    static bool FileExists(const char * filename, class IInstanceLog * log);\n    static time_t GetLastWriteTime(const char * filename, class IInstanceLog * log);\n    static off_t GetFileSize(const char * filename, class IInstanceLog * log);\n    static off_t GetFileBlockSize(const char * filename, class IInstanceLog * log);\n    static bool Rename(const char * oldName, const char * newName, class IInstanceLog * log);\n    static bool RemoveFile(const char * filename, class IInstanceLog * log);\n    static bool CreateDirectory(const char * absolutePath, int mode, class IInstanceLog * log);\n    static bool RemoveDirectory(const char * directoryPath, class IInstanceLog * log);\n    static bool ChangeOwner(const char * path, const char * newOwner, const char * newGroup, class IInstanceLog * log);\n    static bool ChangeMode(const char * path, int mode, class IInstanceLog * log);\n    static ulong64 GetFileSystemTotalSize(const char * path, class IInstanceLog * log);\n    static ulong64 GetFileSystemUsedSpace(const char * path, class IInstanceLog * log);\n    static bool CheckSystemUser(const char * user, const char * group, class IInstanceLog * log);\n    static char * GetFileSystemUser(const char * filepath, class IInstanceLog * log);\n"]]}
{"hexsha": "c80166036ca4a5f4835df09a291bfb814ca3395b", "ext": "c", "lang": "C", "content": "bool Input_is_firing(Input* input) {\n  bool res;\n  if (input->fire && input->count >= 10) {\n    input->count = 0;\n    res = true;\n  } else {\n    input->count++;\n    res = false;\n  }\n\n  return res;\n}", "item_id": 0, "repo": "turboMaCk/asteroids", "file": "src/input.c", "last_update_at": "2020-04-05T14:05:07+00:00", "question_id": "c80166036ca4a5f4835df09a291bfb814ca3395b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool Input_is_firing(Input* input) {\n  bool res;\n  if (input->fire && input->count >= 10) {\n    input->count = 0;\n    res = true;\n  } else {\n    input->count++;\n    res = false;\n  }\n  return res;\n"]]}
{"hexsha": "6847d16db44004f0f8a5d1d2650bfe12079da031", "ext": "c", "lang": "C", "content": "int altmdm_pm_deregistercb(uint32_t type)\n{\n  altmdm_pm_cbfunc_t *lcallback = NULL;\n\n  if (!g_is_initdone)\n    {\n      return -EPERM;\n    }\n\n  if (type == MODEM_PM_CB_TYPE_ERROR)\n    {\n      lcallback = &g_pm_errcallback;\n    }\n  else\n    {\n      lcallback = &g_pm_callback;\n    }\n  if (*lcallback == NULL)\n    {\n      return -EPERM;\n    }\n\n  *lcallback = NULL;\n\n  return 0;\n}", "item_id": 35, "repo": "ErikkEnglund/incubator-nuttx", "file": "drivers/modem/altair/altmdm_pm.c", "last_update_at": "2020-09-28T14:14:44+00:00", "question_id": "6847d16db44004f0f8a5d1d2650bfe12079da031_35", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int altmdm_pm_deregistercb(uint32_t type)\n{\n  altmdm_pm_cbfunc_t *lcallback = NULL;\n  if (!g_is_initdone)\n    {\n      return -EPERM;\n    }\n  if (type == MODEM_PM_CB_TYPE_ERROR)\n    {\n      lcallback = &g_pm_errcallback;\n    }\n  else\n    {\n      lcallback = &g_pm_callback;\n    }\n  if (*lcallback == NULL)\n    {\n      return -EPERM;\n    }\n  *lcallback = NULL;\n  return 0;\n"]]}
{"hexsha": "de0c78883542bbe2959cf4d6d60b47acbac3c287", "ext": "c", "lang": "C", "content": "static void *\nhammer(\n  void *targs\n    )\n{\n  int status = 0;\n  task_info_t *tinfo = (task_info_t *)targs;\n  float *X = NULL; // for re-sort timing comparison\n  uint8_t *g = NULL; // for re-sort timing comparison\n\n  uint64_t *Y    = NULL;\n  uint64_t *tmpY = NULL;\n  uint64_t *isp_tmpY = NULL;\n\n  uint32_t *yval = NULL;\n  uint8_t  *goal = NULL;\n  uint32_t *from = NULL;\n  \n  uint32_t *pre_yval = NULL;\n  uint8_t  *pre_goal = NULL;\n  uint32_t *pre_from = NULL;\n  \n  uint32_t *post_yval = NULL;\n  uint8_t  *post_goal = NULL;\n  uint32_t *post_from = NULL;\n  \n  uint32_t *to   = NULL;\n  uint32_t *isp_to   = NULL;\n\n  uint32_t *to_split = NULL;\n\n  uint32_t n = tinfo->n;\n  uint32_t lb = 0; \n  uint32_t ub = n;\n\n  //-----------------------------------------\n  Y    = malloc(n * sizeof(uint64_t));\n  tmpY = malloc(n * sizeof(uint64_t));\n  isp_tmpY = malloc(n * sizeof(uint64_t));\n\n  yval = malloc(n * sizeof(uint32_t));\n  from = malloc(n * sizeof(uint32_t));\n  goal = malloc(n * sizeof(uint8_t));\n\n  pre_yval = malloc(n * sizeof(uint32_t));\n  pre_from = malloc(n * sizeof(uint32_t));\n  pre_goal = malloc(n * sizeof(uint8_t));\n\n  post_yval = malloc(n * sizeof(uint32_t));\n  post_from = malloc(n * sizeof(uint32_t));\n  post_goal = malloc(n * sizeof(uint8_t));\n\n  to   = malloc(n * sizeof(uint32_t));\n  isp_to   = malloc(n * sizeof(uint32_t));\n\n  to_split   = malloc(n * sizeof(uint32_t));\n  // Initialization\n  for ( uint32_t i = 0; i < n; i++ ) { yval[i] = i+1; }\n  for ( uint32_t i = 0; i < n; i++ ) { from[i] = (n-1) - i; }\n  for ( uint32_t i = 0; i < n; i++ ) { goal[i] = i % 2 ; } \n  for ( uint32_t i = 0; i < n; i++ ) { \n    Y[i] = x_mk_comp_val(from[i], goal[i], yval[i]); \n  }\n  for ( uint32_t i = 0; i < n; i++ ) { tmpY[i] = 0; }\n  // We decree that half the points go left, and other half go right\n  uint32_t lidx = 0;\n  uint32_t ridx = n / 2;\n  uint32_t split_yidx = n / 2;\n  uint32_t p1 = 0, p2 = n - 1;\n  for ( uint32_t i = 0; i < n; ) { \n    to_split[i++] = p1++;\n    to_split[i++] = p2--;\n  }\n  //-----------------------------------------\n  if ( tinfo->what_work_to_do == REORDER ) { \n    tinfo->t_start = get_time_usec();\n    reorder(Y, tmpY, to, to_split, lb, ub, split_yidx, &lidx, &ridx);\n    tinfo->t_stop = get_time_usec();\n  }\n  //--- run ISP version\n  lidx = 0;\n  ridx = n / 2;\n  if ( tinfo->what_work_to_do == REORDER_ISP ) { \n    tinfo->t_start = get_time_usec();\n    reorder_isp(Y, isp_tmpY, isp_to, to_split, lb, ub, split_yidx, \n        &lidx, &ridx, &status);\n    cBYE(status);\n    tinfo->t_stop = get_time_usec();\n  }\nBYE:\n  // Free stuff so that we have space for re-sort test \n  free(Y);\n  free(tmpY);\n  free(isp_tmpY);\n\n  free(yval);\n  free(goal);\n  free(from);\n  \n  free(pre_yval);\n  free(pre_goal);\n  free(pre_from);\n  \n  free(post_yval);\n  free(post_goal);\n  free(post_from);\n  \n  free(to);\n  free(isp_to);\n\n  free(to_split);\n  //-------------------------------\n  return NULL;\n}", "item_id": 1, "repo": "subramon/qlu", "file": "DT/stand_alone_ispc/stand_alone.c", "last_update_at": "2020-09-26T23:47:22+00:00", "question_id": "de0c78883542bbe2959cf4d6d60b47acbac3c287_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void *\nhammer(\n  void *targs\n    )\n{\n  int status = 0;\n  task_info_t *tinfo = (task_info_t *)targs;\n  float *X = NULL; // for re-sort timing comparison\n  uint8_t *g = NULL; // for re-sort timing comparison\n  uint64_t *Y    = NULL;\n  uint64_t *tmpY = NULL;\n  uint64_t *isp_tmpY = NULL;\n  uint32_t *yval = NULL;\n  uint8_t  *goal = NULL;\n  uint32_t *from = NULL;\n  uint32_t *pre_yval = NULL;\n  uint8_t  *pre_goal = NULL;\n  uint32_t *pre_from = NULL;\n  uint32_t *post_yval = NULL;\n  uint8_t  *post_goal = NULL;\n  uint32_t *post_from = NULL;\n  uint32_t *to   = NULL;\n  uint32_t *isp_to   = NULL;\n  uint32_t *to_split = NULL;\n  uint32_t n = tinfo->n;\n  uint32_t lb = 0; \n  uint32_t ub = n;\n  //-----------------------------------------\n  Y    = malloc(n * sizeof(uint64_t));\n  tmpY = malloc(n * sizeof(uint64_t));\n  isp_tmpY = malloc(n * sizeof(uint64_t));\n  yval = malloc(n * sizeof(uint32_t));\n  from = malloc(n * sizeof(uint32_t));\n  goal = malloc(n * sizeof(uint8_t));\n  pre_yval = malloc(n * sizeof(uint32_t));\n  pre_from = malloc(n * sizeof(uint32_t));\n  pre_goal = malloc(n * sizeof(uint8_t));\n  post_yval = malloc(n * sizeof(uint32_t));\n  post_from = malloc(n * sizeof(uint32_t));\n  post_goal = malloc(n * sizeof(uint8_t));\n  to   = malloc(n * sizeof(uint32_t));\n  isp_to   = malloc(n * sizeof(uint32_t));\n  to_split   = malloc(n * sizeof(uint32_t));\n  // Initialization\n  for ( uint32_t i = 0; i < n; i++ ) { yval[i] = i+1; }\n  for ( uint32_t i = 0; i < n; i++ ) { from[i] = (n-1) - i; }\n  for ( uint32_t i = 0; i < n; i++ ) { goal[i] = i % 2 ; } \n  for ( uint32_t i = 0; i < n; i++ ) { \n    Y[i] = x_mk_comp_val(from[i], goal[i], yval[i]); \n  }\n  for ( uint32_t i = 0; i < n; i++ ) { tmpY[i] = 0; }\n  // We decree that half the points go left, and other half go right\n  uint32_t lidx = 0;\n  uint32_t ridx = n / 2;\n  uint32_t split_yidx = n / 2;\n  uint32_t p1 = 0, p2 = n - 1;\n  for ( uint32_t i = 0; i < n; ) { \n    to_split[i++] = p1++;\n    to_split[i++] = p2--;\n  }\n  //-----------------------------------------\n  if ( tinfo->what_work_to_do == REORDER ) { \n    tinfo->t_start = get_time_usec();\n    reorder(Y, tmpY, to, to_split, lb, ub, split_yidx, &lidx, &ridx);\n    tinfo->t_stop = get_time_usec();\n  }\n  //--- run ISP version\n  lidx = 0;\n  ridx = n / 2;\n  if ( tinfo->what_work_to_do == REORDER_ISP ) { \n    tinfo->t_start = get_time_usec();\n    reorder_isp(Y, isp_tmpY, isp_to, to_split, lb, ub, split_yidx, \n        &lidx, &ridx, &status);\n    cBYE(status);\n    tinfo->t_stop = get_time_usec();\n  }\nBYE:\n  // Free stuff so that we have space for re-sort test \n  free(Y);\n  free(tmpY);\n  free(isp_tmpY);\n  free(yval);\n  free(goal);\n  free(from);\n  free(pre_yval);\n  free(pre_goal);\n  free(pre_from);\n  free(post_yval);\n  free(post_goal);\n  free(post_from);\n  free(to);\n  free(isp_to);\n  free(to_split);\n  //-------------------------------\n  return NULL;\n"]]}
{"hexsha": "a62d76091e7fa70e179a59014447065a19d6a777", "ext": "c", "lang": "C", "content": "const PNL_ATTR\nNlAttrFind__(const PNL_ATTR attrs, UINT32 size, UINT16 type)\n{\n    PNL_ATTR iter = NULL;\n    PNL_ATTR ret = NULL;\n    UINT32 left;\n\n    NL_ATTR_FOR_EACH (iter, left, attrs, size) {\n        if (NlAttrType(iter) == type) {\n            ret = iter;\n            goto done;\n        }\n    }\n\ndone:\n    return ret;\n}", "item_id": 20, "repo": "wenxueliu/ovs_note", "file": "datapath-windows/ovsext/Netlink/Netlink.c", "last_update_at": "2020-08-19T03:19:24+00:00", "question_id": "a62d76091e7fa70e179a59014447065a19d6a777_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const PNL_ATTR\nNlAttrFind__(const PNL_ATTR attrs, UINT32 size, UINT16 type)\n{\n    PNL_ATTR iter = NULL;\n    PNL_ATTR ret = NULL;\n    UINT32 left;\n    NL_ATTR_FOR_EACH (iter, left, attrs, size) {\n        if (NlAttrType(iter) == type) {\n            ret = iter;\n            goto done;\n        }\n    }\ndone:\n    return ret;\n"]]}
{"hexsha": "270f0b67955f229728b2670123d284dd9d45697b", "ext": "h", "lang": "C", "content": "namespace Sys {\n\tint currentColor = c_white;\n\tint circleSmoothness = 75;\n\tvoid* defaultFont = GLUT_BITMAP_TIMES_ROMAN_24;\n}", "item_id": 0, "repo": "sohomsahaun/Onto-the-Bones", "file": "Onto the Bones/otb_graphics.h", "last_update_at": "2020-09-15T12:17:17+00:00", "question_id": "270f0b67955f229728b2670123d284dd9d45697b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace Sys {\n\tint currentColor = c_white;\n\tint circleSmoothness = 75;\n\tvoid* defaultFont = GLUT_BITMAP_TIMES_ROMAN_24;\n"]]}
{"hexsha": "433eb0fe363f91ce5c0b50c03786b3d58af62d2b", "ext": "c", "lang": "C", "content": "static int nvgcolor_b_index_xl(lua_State *L)\n{\n    NVGcolor *self = R_CPPCAST(NVGcolor *, XL_checkutype(L, 1, \"NVGcolor\"));\n    float RETVAL;\n    RETVAL = self->b;\n    XL_pushfloat(L, RETVAL);\n    return 1;\n}", "item_id": 17, "repo": "askmeaboutlo0m/rouse", "file": "rouse-lua/lib/rouse/lua/nvg.c", "last_update_at": "2020-01-04T11:42:22+00:00", "question_id": "433eb0fe363f91ce5c0b50c03786b3d58af62d2b_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int nvgcolor_b_index_xl(lua_State *L)\n{\n    NVGcolor *self = R_CPPCAST(NVGcolor *, XL_checkutype(L, 1, \"NVGcolor\"));\n    float RETVAL;\n    RETVAL = self->b;\n    XL_pushfloat(L, RETVAL);\n    return 1;\n"]]}
{"hexsha": "0488a512034bd6654ad3b0615fe4dc1619905a64", "ext": "c", "lang": "C", "content": "TypeStateEntry *CreateMINMAXState(SmurfManager *SM, DdNode *pMINMAXBDD) {\n  MINMAXStateEntry *pMINMAXState = NULL;\n  \n  if((SM->uTempList1.nLength >= functionTypeLimits[FN_TYPE_MINMAX]) && isMINMAX(SM->dd, pMINMAXBDD, &SM->uTempList1)) {\n    Cudd_Ref(pMINMAXBDD);\n    \n    //Build MINMAX state\n    uintmax_t nNumBDDVars = SM->uTempList1.nLength;\n    uintmax_t nNumElts = SM->uTempList1.pList[nNumBDDVars-1]+1;\n    assert(nNumElts > 0);\n\n    uint8_t ret = check_SmurfStatesTableSize(SM, (uintmax_t)sizeof(MINMAXStateEntry) + (sizeof(uint8_t) * nNumElts));\n    if(ret != NO_ERROR) {assert(0); return NULL;}\n    \n    pMINMAXState = (MINMAXStateEntry *)SM->pSmurfStatesTableTail;\n    chomp_SmurfStatesTable(SM, (uintmax_t)sizeof(MINMAXStateEntry) + (sizeof(uint8_t) * nNumElts));\n    sbsat_stats[STAT_MINMAX_STATES_BUILT]+=1;\n    sbsat_stats[STAT_STATES_BUILT]+=1;\n    \n    pMINMAXState->type             = FN_MINMAX;\n    pMINMAXState->visited          = 0;\n    pMINMAXState->nNumVariables    = nNumElts;\n    pMINMAXState->nNumBDDVariables = nNumBDDVars;\n    pMINMAXState->nMin             = getMIN(SM->dd, pMINMAXBDD, nNumBDDVars);\n    pMINMAXState->nMax             = getMAX(SM->dd, pMINMAXBDD);\n    pMINMAXState->bExists          = (uint8_t *)(pMINMAXState+1);\n    pMINMAXState->pMINMAXBDD       = pMINMAXBDD;\n    \n    assert(pMINMAXState->nMin <= pMINMAXState->nMax);\n\n    uintmax_t nBDDVar = 0;\n    for(uintmax_t nVbleIndex = 0; nVbleIndex < nNumElts; nVbleIndex++) {\n      if(nVbleIndex == SM->uTempList1.pList[nBDDVar]) {\n\t//Variable is in the BDD\n\tpMINMAXState->bExists[nVbleIndex] = 1;\n\tnBDDVar++;\n      } else {\n\t//Variable is not in the BDD\n\tpMINMAXState->bExists[nVbleIndex] = 0;\n      }\n    }\n    assert(nBDDVar == nNumBDDVars);\n  }\n  \n  //Leaf node, just return\n  return (TypeStateEntry *)pMINMAXState;\n}", "item_id": 0, "repo": "weaversa/sbsat", "file": "src/solvers/smurf/fn_minmax/bdd2specfn_minmax.c", "last_update_at": "2020-05-24T13:45:15+00:00", "question_id": "0488a512034bd6654ad3b0615fe4dc1619905a64_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TypeStateEntry *CreateMINMAXState(SmurfManager *SM, DdNode *pMINMAXBDD) {\n  MINMAXStateEntry *pMINMAXState = NULL;\n  if((SM->uTempList1.nLength >= functionTypeLimits[FN_TYPE_MINMAX]) && isMINMAX(SM->dd, pMINMAXBDD, &SM->uTempList1)) {\n    Cudd_Ref(pMINMAXBDD);\n    //Build MINMAX state\n    uintmax_t nNumBDDVars = SM->uTempList1.nLength;\n    uintmax_t nNumElts = SM->uTempList1.pList[nNumBDDVars-1]+1;\n    assert(nNumElts > 0);\n    uint8_t ret = check_SmurfStatesTableSize(SM, (uintmax_t)sizeof(MINMAXStateEntry) + (sizeof(uint8_t) * nNumElts));\n    if(ret != NO_ERROR) {assert(0); return NULL;}\n    pMINMAXState = (MINMAXStateEntry *)SM->pSmurfStatesTableTail;\n    chomp_SmurfStatesTable(SM, (uintmax_t)sizeof(MINMAXStateEntry) + (sizeof(uint8_t) * nNumElts));\n    sbsat_stats[STAT_MINMAX_STATES_BUILT]+=1;\n    sbsat_stats[STAT_STATES_BUILT]+=1;\n    pMINMAXState->type             = FN_MINMAX;\n    pMINMAXState->visited          = 0;\n    pMINMAXState->nNumVariables    = nNumElts;\n    pMINMAXState->nNumBDDVariables = nNumBDDVars;\n    pMINMAXState->nMin             = getMIN(SM->dd, pMINMAXBDD, nNumBDDVars);\n    pMINMAXState->nMax             = getMAX(SM->dd, pMINMAXBDD);\n    pMINMAXState->bExists          = (uint8_t *)(pMINMAXState+1);\n    pMINMAXState->pMINMAXBDD       = pMINMAXBDD;\n    assert(pMINMAXState->nMin <= pMINMAXState->nMax);\n    uintmax_t nBDDVar = 0;\n    for(uintmax_t nVbleIndex = 0; nVbleIndex < nNumElts; nVbleIndex++) {\n      if(nVbleIndex == SM->uTempList1.pList[nBDDVar]) {\n\t//Variable is in the BDD\n\tpMINMAXState->bExists[nVbleIndex] = 1;\n\tnBDDVar++;\n      } else {\n\t//Variable is not in the BDD\n\tpMINMAXState->bExists[nVbleIndex] = 0;\n      }\n    }\n    assert(nBDDVar == nNumBDDVars);\n  }\n  //Leaf node, just return\n  return (TypeStateEntry *)pMINMAXState;\n"]]}
{"hexsha": "9a9ec2f35448226043552e85455249304b8617ce", "ext": "c", "lang": "C", "content": "Snake *snakesInit()\n{\n    Snake *ret;\n    if (!(ret = (Snake *)malloc(sizeof(Snake)))) {\n        return NULL;\n    }\n    ret->head    = NULL;\n    ret->newhead = NULL;\n    ret->next    = NULL;\n    return ret;\n}", "item_id": 0, "repo": "Randoragon/ncsnake", "file": "game.c", "last_update_at": "2020-08-12T14:36:17+00:00", "question_id": "9a9ec2f35448226043552e85455249304b8617ce_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Snake *snakesInit()\n{\n    Snake *ret;\n    if (!(ret = (Snake *)malloc(sizeof(Snake)))) {\n        return NULL;\n    }\n    ret->head    = NULL;\n    ret->newhead = NULL;\n    ret->next    = NULL;\n    return ret;\n"]]}
{"hexsha": "838aa96404ee8ca4b013669ee0f18675ad610edb", "ext": "c", "lang": "C", "content": "static int Draw_Mesh_shader_material(Mesh_t *mesh,const int texindex, struct Projector_s **projectors,const int numProjectors,  struct SkinObject_s *skinobj)\n{\n  // error check\n  vidCheckError();\n  LUX_DEBUGASSERT(mesh);\n\n  _dset_default(mesh);\n  _dset_shadermat_override_prep(texindex);\n  _dset_shader_prep(mesh);\n  _dset_lock(mesh);\n  _dset_initmesh(mesh);\n\n  _dset_multipass_start\n    _dset_mat_pass_start();\n    _dset_fog_start();\n    Draw_Mesh_simple(mesh);\n\n    _dset_mat_pass_end();\n    _dset_fog_end();\n  _dset_multipass_end;\n\n  _dset_unlock();\n  _dset_shader_end();\n  _dset_resetmesh(mesh);\n\n  vidCheckError();\n  return l_DrawData.numPasses;\n}", "item_id": 22, "repo": "pixeljetstream/luxinia1", "file": "engine/source/render/gl_drawmesh.c", "last_update_at": "2020-12-07T03:21:50+00:00", "question_id": "838aa96404ee8ca4b013669ee0f18675ad610edb_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int Draw_Mesh_shader_material(Mesh_t *mesh,const int texindex, struct Projector_s **projectors,const int numProjectors,  struct SkinObject_s *skinobj)\n{\n  // error check\n  vidCheckError();\n  LUX_DEBUGASSERT(mesh);\n  _dset_default(mesh);\n  _dset_shadermat_override_prep(texindex);\n  _dset_shader_prep(mesh);\n  _dset_lock(mesh);\n  _dset_initmesh(mesh);\n  _dset_multipass_start\n    _dset_mat_pass_start();\n    _dset_fog_start();\n    Draw_Mesh_simple(mesh);\n    _dset_mat_pass_end();\n    _dset_fog_end();\n  _dset_multipass_end;\n  _dset_unlock();\n  _dset_shader_end();\n  _dset_resetmesh(mesh);\n  vidCheckError();\n  return l_DrawData.numPasses;\n"]]}
{"hexsha": "d275bb1820f321ce82600cecbc807ceee3495fcc", "ext": "h", "lang": "C", "content": "static inline unsigned __hip_ds_swizzle_N(unsigned int src) {\n    union { int i; unsigned u; float f; } tmp; tmp.u = src;\n#if defined(__HCC__)\n    tmp.i = __llvm_amdgcn_ds_swizzle(tmp.i, pattern);\n#else\n    tmp.i = __builtin_amdgcn_ds_swizzle(tmp.i, pattern);\n#endif\n    return tmp.u;\n}", "item_id": 13, "repo": "icarus-sparry/HIP", "file": "include/hip/hcc_detail/device_functions.h", "last_update_at": "2020-03-27T06:37:35+00:00", "question_id": "d275bb1820f321ce82600cecbc807ceee3495fcc_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline unsigned __hip_ds_swizzle_N(unsigned int src) {\n    union { int i; unsigned u; float f; } tmp; tmp.u = src;\n#if defined(__HCC__)\n    tmp.i = __llvm_amdgcn_ds_swizzle(tmp.i, pattern);\n#else\n    tmp.i = __builtin_amdgcn_ds_swizzle(tmp.i, pattern);\n#endif\n    return tmp.u;\n"]]}
{"hexsha": "de6c79bda84aab2efa6518cb3eda5e0ec9799f16", "ext": "c", "lang": "C", "content": "void\nbus_space_render_tag(bus_space_tag_t t, char* buf, size_t len)\n{\n\tif (t == NULL) {\n\t\tstrlcat(buf, \"<NULL>\", len);\n\t\treturn;\n\t}\n\tbuf[0] = '\\0';\n\tif (t->parent)\n\t\tbus_space_render_tag(t->parent, buf, len);\n\n\tstrlcat(buf, \"/\", len);\n\tstrlcat(buf, t->name, len);\n}", "item_id": 39, "repo": "sizeofvoid/ifconfigd", "file": "usr/src/sys/arch/sparc64/sparc64/machdep.c", "last_update_at": "2020-08-28T01:27:00+00:00", "question_id": "de6c79bda84aab2efa6518cb3eda5e0ec9799f16_39", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nbus_space_render_tag(bus_space_tag_t t, char* buf, size_t len)\n{\n\tif (t == NULL) {\n\t\tstrlcat(buf, \"<NULL>\", len);\n\t\treturn;\n\t}\n\tbuf[0] = '\\0';\n\tif (t->parent)\n\t\tbus_space_render_tag(t->parent, buf, len);\n\tstrlcat(buf, \"/\", len);\n\tstrlcat(buf, t->name, len);\n"]]}
{"hexsha": "0dbada8eca2501902288ba2d93834ef3c7b6980e", "ext": "c", "lang": "C", "content": "static void file_no_access_to_file(void)\n{\n\tint fd;\n\t/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/\n\n\n\tmkdir(WORKDIR\"/embedlog-no-write\", 0755);\n\tfd = open(WORKDIR\"/embedlog-no-write/log\", O_CREAT, 0444);\n\tclose(fd);\n\n\tif (getuid() == 0)\n\t{\n\t\tmt_fok(el_option(EL_FPATH, WORKDIR\"/embedlog-no-write/log\"));\n\t\tmt_fok(el_puts(s5));\n\t\tmt_fok(file_check(WORKDIR\"/embedlog-no-write/log\", s5));\n\t}\n\telse\n\t{\n\t\tmt_ferr(el_option(EL_FPATH, WORKDIR\"/embedlog-no-write/log\"), EACCES);\n\t\tmt_ferr(el_puts(\"whatever\"), EACCES);\n\t}\n\tunlink(WORKDIR\"/embedlog-no-write/log\");\n\trmdir(WORKDIR\"/embedlog-no-write\");\n}", "item_id": 55, "repo": "mlyszczek/embedlog", "file": "tst/test-el-file.c", "last_update_at": "2020-01-23T15:10:16+00:00", "question_id": "0dbada8eca2501902288ba2d93834ef3c7b6980e_55", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void file_no_access_to_file(void)\n{\n\tint fd;\n\t/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/\n\tmkdir(WORKDIR\"/embedlog-no-write\", 0755);\n\tfd = open(WORKDIR\"/embedlog-no-write/log\", O_CREAT, 0444);\n\tclose(fd);\n\tif (getuid() == 0)\n\t{\n\t\tmt_fok(el_option(EL_FPATH, WORKDIR\"/embedlog-no-write/log\"));\n\t\tmt_fok(el_puts(s5));\n\t\tmt_fok(file_check(WORKDIR\"/embedlog-no-write/log\", s5));\n\t}\n\telse\n\t{\n\t\tmt_ferr(el_option(EL_FPATH, WORKDIR\"/embedlog-no-write/log\"), EACCES);\n\t\tmt_ferr(el_puts(\"whatever\"), EACCES);\n\t}\n\tunlink(WORKDIR\"/embedlog-no-write/log\");\n\trmdir(WORKDIR\"/embedlog-no-write\");\n"]]}
{"hexsha": "aff1bb744bec7f30b36df8e9f2c1114893321408", "ext": "c", "lang": "C", "content": "int func_45(int iParam0)\n{\n\tint iVar0;\n\t\n\tif (!unk_0x3D70CCF2C9B362CD(Local_85.f_3[iParam0 /*5*/].f_1))\n\t{\n\t\treturn 0;\n\t}\n\tiVar0 = unk_0x3C6C6327BA564AEE(Local_85.f_3[iParam0 /*5*/].f_1);\n\tif (unk_0xA59F96B50B97E63C(iVar0, 0))\n\t{\n\t\treturn 0;\n\t}\n\tif (!unk_0xAA5B806352173DEA(iVar0))\n\t{\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "item_id": 23, "repo": "Seanghost117/GTA-V-Decompiled-Scripts", "file": "decompiled_scripts/am_armybase.c", "last_update_at": "2020-12-16T17:13:14+00:00", "question_id": "aff1bb744bec7f30b36df8e9f2c1114893321408_23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int func_45(int iParam0)\n{\n\tint iVar0;\n\t\n\tif (!unk_0x3D70CCF2C9B362CD(Local_85.f_3[iParam0 /*5*/].f_1))\n\t{\n\t\treturn 0;\n\t}\n\tiVar0 = unk_0x3C6C6327BA564AEE(Local_85.f_3[iParam0 /*5*/].f_1);\n\tif (unk_0xA59F96B50B97E63C(iVar0, 0))\n\t{\n\t\treturn 0;\n\t}\n\tif (!unk_0xAA5B806352173DEA(iVar0))\n\t{\n\t\treturn 0;\n\t}\n\treturn 1;\n"]]}
{"hexsha": "eeb9ff89363502562ee900b382830e7a4f5bb3b3", "ext": "c", "lang": "C", "content": "static ssize_t afs_file_write(struct file *file, const char *buf, size_t size, loff_t *off)\n{\n\tafs_vnode_t *vnode;\n\n\tvnode = AFS_FS_I(file->f_dentry->d_inode);\n\tif (vnode->flags & AFS_VNODE_DELETED)\n\t\treturn -ESTALE;\n\n\treturn -EIO;\n}", "item_id": 0, "repo": "dnhua/Linux_study", "file": "linux-2.6.0/fs/afs/file.c", "last_update_at": "2020-11-10T12:47:02+00:00", "question_id": "eeb9ff89363502562ee900b382830e7a4f5bb3b3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static ssize_t afs_file_write(struct file *file, const char *buf, size_t size, loff_t *off)\n{\n\tafs_vnode_t *vnode;\n\tvnode = AFS_FS_I(file->f_dentry->d_inode);\n\tif (vnode->flags & AFS_VNODE_DELETED)\n\t\treturn -ESTALE;\n\treturn -EIO;\n"]]}
{"hexsha": "21edb0b3a842755d49ee060da137a469580d7757", "ext": "c", "lang": "C", "content": "int calInitSerial(char *dev) {\n\n  /* Open up the serial port */\n  int fd = open(dev, O_NONBLOCK);\n\n  if (fd <= 0) {\n    perror(\"open serial\");\n    return(-1);\n  }\n\n  tcgetattr(fd, &ios_saved);\n  ios_current = ios_saved;\n\n  cfmakeraw(&ios_current);\n\n  /* Set the baud rate */\n\n  cfsetispeed(&ios_current, B2400);  \n  cfsetospeed(&ios_current, B2400);\n  \n  /* Set the data bits and remove the parity */\n  ios_current.c_cflag &= ~(CSIZE | PARENB);\n  ios_current.c_cflag |= CS8;\n\n  ios_current.c_cc[VMIN] = 3;\n  ios_current.c_cc[VTIME] = 1;\n\n  tcsetattr(fd, TCSANOW, &ios_current);\n  tcflush(fd, TCIOFLUSH);\n  \n  return(fd);\n}", "item_id": 0, "repo": "symfund/microwindows", "file": "src/drivers/deprecated/dynacal.c", "last_update_at": "2020-12-19T13:47:11+00:00", "question_id": "21edb0b3a842755d49ee060da137a469580d7757_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int calInitSerial(char *dev) {\n  /* Open up the serial port */\n  int fd = open(dev, O_NONBLOCK);\n  if (fd <= 0) {\n    perror(\"open serial\");\n    return(-1);\n  }\n  tcgetattr(fd, &ios_saved);\n  ios_current = ios_saved;\n  cfmakeraw(&ios_current);\n  /* Set the baud rate */\n  cfsetispeed(&ios_current, B2400);  \n  cfsetospeed(&ios_current, B2400);\n  /* Set the data bits and remove the parity */\n  ios_current.c_cflag &= ~(CSIZE | PARENB);\n  ios_current.c_cflag |= CS8;\n  ios_current.c_cc[VMIN] = 3;\n  ios_current.c_cc[VTIME] = 1;\n  tcsetattr(fd, TCSANOW, &ios_current);\n  tcflush(fd, TCIOFLUSH);\n  return(fd);\n"]]}
{"hexsha": "a5f67cec5bd6d3a03b125c19138c9fae9824ea25", "ext": "c", "lang": "C", "content": "int func_3(int iParam0, int iParam1, int iParam2, int iParam3, int iParam4, int iParam5, int iParam6, int iParam7, int iParam8, int iParam9, int iParam10, int iParam11)\n{\n\tstruct<15> Var0;\n\tint iVar1;\n\t\n\tif (func_7(0))\n\t{\n\t\treturn 0;\n\t}\n\tif (iParam5 < 0)\n\t{\n\t\treturn 0;\n\t}\n\tif (iParam6 < 0)\n\t{\n\t\treturn 0;\n\t}\n\tif (iParam8 == 76)\n\t{\n\t\treturn 0;\n\t}\n\tif (iParam9 == 235)\n\t{\n\t\treturn 0;\n\t}\n\tif (iParam3 < 3)\n\t{\n\t\tif (unk_0xCE990E643CD9D0E5(iParam2, iParam3))\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (iParam4 < 3)\n\t{\n\t\tif (iParam4 != iParam3)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (iParam2 < 1 || iParam2 > 7)\n\t{\n\t\treturn 0;\n\t}\n\tif (Global_111858.f_7684.f_136 < 9)\n\t{\n\t\tVar0 = iParam0;\n\t\tif (Global_111858.f_7684.f_911 == Var0)\n\t\t{\n\t\t\tGlobal_111858.f_7684.f_911 = -1;\n\t\t}\n\t\tVar0.f_3 = func_6(iParam1);\n\t\tVar0.f_1 = iParam11;\n\t\tVar0.f_2 = iParam2;\n\t\tVar0.f_4 = (unk_0x578C4EF320340AF7() + iParam5);\n\t\tVar0.f_5 = iParam6;\n\t\tVar0.f_6 = iParam3;\n\t\tVar0.f_14 = iParam4;\n\t\tVar0.f_10 = iParam7;\n\t\tVar0.f_11 = -1;\n\t\tVar0.f_7 = iParam8;\n\t\tVar0.f_8 = iParam9;\n\t\tVar0.f_9 = iParam10;\n\t\tunk_0xD2459066EA58CE43(&(Var0.f_1), 1);\n\t\tunk_0xD2459066EA58CE43(&(Var0.f_1), 0);\n\t\tif (iParam7 != -1)\n\t\t{\n\t\t\tunk_0xBE20AB8238688965(&(Var0.f_1), 11);\n\t\t}\n\t\telse if (iParam1 == 0)\n\t\t{\n\t\t\tunk_0xBE20AB8238688965(&(Var0.f_1), 10);\n\t\t}\n\t\tGlobal_111858.f_7684[Global_111858.f_7684.f_136 /*15*/] = { Var0 };\n\t\tGlobal_111858.f_7684.f_136++;\n\t\tiVar1 = 0;\n\t\twhile (iVar1 < 3)\n\t\t{\n\t\t\tif (unk_0xCE990E643CD9D0E5(iParam2, iVar1))\n\t\t\t{\n\t\t\t\tfunc_4(iVar1);\n\t\t\t}\n\t\t\tiVar1++;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "item_id": 1, "repo": "Seanghost117/GTA-V-Decompiled-Scripts", "file": "decompiled_scripts/ambient_diving.c", "last_update_at": "2020-12-16T17:13:14+00:00", "question_id": "a5f67cec5bd6d3a03b125c19138c9fae9824ea25_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int func_3(int iParam0, int iParam1, int iParam2, int iParam3, int iParam4, int iParam5, int iParam6, int iParam7, int iParam8, int iParam9, int iParam10, int iParam11)\n{\n\tstruct<15> Var0;\n\tint iVar1;\n\t\n\tif (func_7(0))\n\t{\n\t\treturn 0;\n\t}\n\tif (iParam5 < 0)\n\t{\n\t\treturn 0;\n\t}\n\tif (iParam6 < 0)\n\t{\n\t\treturn 0;\n\t}\n\tif (iParam8 == 76)\n\t{\n\t\treturn 0;\n\t}\n\tif (iParam9 == 235)\n\t{\n\t\treturn 0;\n\t}\n\tif (iParam3 < 3)\n\t{\n\t\tif (unk_0xCE990E643CD9D0E5(iParam2, iParam3))\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (iParam4 < 3)\n\t{\n\t\tif (iParam4 != iParam3)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (iParam2 < 1 || iParam2 > 7)\n\t{\n\t\treturn 0;\n\t}\n\tif (Global_111858.f_7684.f_136 < 9)\n\t{\n\t\tVar0 = iParam0;\n\t\tif (Global_111858.f_7684.f_911 == Var0)\n\t\t{\n\t\t\tGlobal_111858.f_7684.f_911 = -1;\n\t\t}\n\t\tVar0.f_3 = func_6(iParam1);\n\t\tVar0.f_1 = iParam11;\n\t\tVar0.f_2 = iParam2;\n\t\tVar0.f_4 = (unk_0x578C4EF320340AF7() + iParam5);\n\t\tVar0.f_5 = iParam6;\n\t\tVar0.f_6 = iParam3;\n\t\tVar0.f_14 = iParam4;\n\t\tVar0.f_10 = iParam7;\n\t\tVar0.f_11 = -1;\n\t\tVar0.f_7 = iParam8;\n\t\tVar0.f_8 = iParam9;\n\t\tVar0.f_9 = iParam10;\n\t\tunk_0xD2459066EA58CE43(&(Var0.f_1), 1);\n\t\tunk_0xD2459066EA58CE43(&(Var0.f_1), 0);\n\t\tif (iParam7 != -1)\n\t\t{\n\t\t\tunk_0xBE20AB8238688965(&(Var0.f_1), 11);\n\t\t}\n\t\telse if (iParam1 == 0)\n\t\t{\n\t\t\tunk_0xBE20AB8238688965(&(Var0.f_1), 10);\n\t\t}\n\t\tGlobal_111858.f_7684[Global_111858.f_7684.f_136 /*15*/] = { Var0 };\n\t\tGlobal_111858.f_7684.f_136++;\n\t\tiVar1 = 0;\n\t\twhile (iVar1 < 3)\n\t\t{\n\t\t\tif (unk_0xCE990E643CD9D0E5(iParam2, iVar1))\n\t\t\t{\n\t\t\t\tfunc_4(iVar1);\n\t\t\t}\n\t\t\tiVar1++;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n"]]}
{"hexsha": "2a58ad6e602cf646275d11ac2a455c1f48131e9e", "ext": "c", "lang": "C", "content": "int osdp_compute_mac(struct osdp_pd *p, int is_cmd, const uint8_t *data, int len)\n{\n\tint pad_len;\n\tuint8_t buf[OSDP_PACKET_BUF_SIZE] = { 0 };\n\tuint8_t iv[16];\n\n\tmemcpy(buf, data, len);\n\tpad_len = (len % 16 == 0) ? len : get_pad_len(len);\n\tif (len % 16 != 0)\n\t\tbuf[len] = 0x80; /* end marker */\n\n\t/**\n\t * MAC for data blocks B[1] .. B[N] (post padding) is computed as:\n\t * IV1 = R_MAC (or) C_MAC  -- depending on is_cmd\n\t * IV2 = B[N-1] after -- AES-CBC ( IV1, B[1] to B[N-1], SMAC-1 )\n\t * MAC = AES-ECB ( IV2, B[N], SMAC-2 )\n\t */\n\n\tmemcpy(iv, is_cmd ? p->sc.r_mac : p->sc.c_mac, 16);\n\tif (pad_len > 16) {\n\t\t/* N-1 blocks -- encrypted with SMAC-1 */\n\t\tosdp_encrypt(p->sc.s_mac1, iv, buf, pad_len - 16);\n\t\t/* N-1 th block is the IV the N th block */\n\t\tmemcpy(iv, buf + pad_len - 32, 16);\n\t}\n\t/* N-th Block encrypted with SMAC-2 == MAC */\n\tosdp_encrypt(p->sc.s_mac2, iv, buf + pad_len - 16, 16);\n\tmemcpy(is_cmd ? p->sc.c_mac : p->sc.r_mac, buf + pad_len - 16, 16);\n\n#if 0\n    LOG_D(TAG \"MAC Diagnostics is_cmd: %d\", is_cmd);\n    osdp_dump(\"S-MAC1\", p->sc.s_mac1, 16);\n    osdp_dump(\"S-MAC2\", p->sc.s_mac2, 16);\n    osdp_dump(\"IV\", iv, 16);\n    osdp_dump(\"R-MAC\", p->sc.r_mac, 16);\n    osdp_dump(\"C-MAC\", p->sc.c_mac, 16);\n#endif\n\n\treturn 0;\n}", "item_id": 10, "repo": "silchas/libosdp", "file": "src/osdp_sc.c", "last_update_at": "2020-09-23T18:19:19+00:00", "question_id": "2a58ad6e602cf646275d11ac2a455c1f48131e9e_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int osdp_compute_mac(struct osdp_pd *p, int is_cmd, const uint8_t *data, int len)\n{\n\tint pad_len;\n\tuint8_t buf[OSDP_PACKET_BUF_SIZE] = { 0 };\n\tuint8_t iv[16];\n\tmemcpy(buf, data, len);\n\tpad_len = (len % 16 == 0) ? len : get_pad_len(len);\n\tif (len % 16 != 0)\n\t\tbuf[len] = 0x80; /* end marker */\n\t/**\n\t * MAC for data blocks B[1] .. B[N] (post padding) is computed as:\n\t * IV1 = R_MAC (or) C_MAC  -- depending on is_cmd\n\t * IV2 = B[N-1] after -- AES-CBC ( IV1, B[1] to B[N-1], SMAC-1 )\n\t * MAC = AES-ECB ( IV2, B[N], SMAC-2 )\n\t */\n\tmemcpy(iv, is_cmd ? p->sc.r_mac : p->sc.c_mac, 16);\n\tif (pad_len > 16) {\n\t\t/* N-1 blocks -- encrypted with SMAC-1 */\n\t\tosdp_encrypt(p->sc.s_mac1, iv, buf, pad_len - 16);\n\t\t/* N-1 th block is the IV the N th block */\n\t\tmemcpy(iv, buf + pad_len - 32, 16);\n\t}\n\t/* N-th Block encrypted with SMAC-2 == MAC */\n\tosdp_encrypt(p->sc.s_mac2, iv, buf + pad_len - 16, 16);\n\tmemcpy(is_cmd ? p->sc.c_mac : p->sc.r_mac, buf + pad_len - 16, 16);\n#if 0\n    LOG_D(TAG \"MAC Diagnostics is_cmd: %d\", is_cmd);\n    osdp_dump(\"S-MAC1\", p->sc.s_mac1, 16);\n    osdp_dump(\"S-MAC2\", p->sc.s_mac2, 16);\n    osdp_dump(\"IV\", iv, 16);\n    osdp_dump(\"R-MAC\", p->sc.r_mac, 16);\n    osdp_dump(\"C-MAC\", p->sc.c_mac, 16);\n#endif\n\treturn 0;\n"]]}
{"hexsha": "18c7861b99ce2a814defa8f9e1dbe008e35e4438", "ext": "c", "lang": "C", "content": "U32  GH_HDMI_get_AUNIT_NCTS_CTRL(void)\n{\n    U32 value = (*(volatile U32 *)REG_HDMI_AUNIT_NCTS_CTRL);\n\n    #if GH_HDMI_ENABLE_DEBUG_PRINT\n    GH_HDMI_DEBUG_PRINT_FUNCTION( \"value = RDREG(0x%08x); \\\\\\\\ [GH_HDMI_get_AUNIT_NCTS_CTRL] --> 0x%08x\\n\",\n                        REG_HDMI_AUNIT_NCTS_CTRL,value);\n    #endif\n    return value;\n}", "item_id": 76, "repo": "Davidfind/rt-thread", "file": "bsp/gkipc/libraries/drv/710XS/gh/src/gh_hdmi.c", "last_update_at": "2020-12-19T04:35:43+00:00", "question_id": "18c7861b99ce2a814defa8f9e1dbe008e35e4438_76", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["U32  GH_HDMI_get_AUNIT_NCTS_CTRL(void)\n{\n    U32 value = (*(volatile U32 *)REG_HDMI_AUNIT_NCTS_CTRL);\n    #if GH_HDMI_ENABLE_DEBUG_PRINT\n    GH_HDMI_DEBUG_PRINT_FUNCTION( \"value = RDREG(0x%08x); \\\\\\\\ [GH_HDMI_get_AUNIT_NCTS_CTRL] --> 0x%08x\\n\",\n                        REG_HDMI_AUNIT_NCTS_CTRL,value);\n    #endif\n    return value;\n"]]}
{"hexsha": "410fd374357d756e78842e630ac6ec03b0caecf7", "ext": "c", "lang": "C", "content": "int serial_complete(int handle,uint32_t timeout)\n{\n    int size;\n    utils_timer_t timer;\n    serial_t *s;\n\n    s =(serial_t *)handle;\t \n\n    if (s->init == false){\n        log_error(\"serial handle:%d not open.\\r\\n\",handle);\n        return -1;\n    } \n    utils_timer_init(&timer,timeout,false);\n\n    do {\n        size = circle_buffer_used_size(&s->send);\n        if (size != 0) {\n            osDelay(1);\n        }\n    } while (utils_timer_value(&timer) > 0 && size != 0);\n\n    return size;\n}", "item_id": 6, "repo": "wkxboot/beer_machine_mqtt", "file": "beer_machine_mqtt/Src/serial/serial.c", "last_update_at": "2020-11-06T02:48:16+00:00", "question_id": "410fd374357d756e78842e630ac6ec03b0caecf7_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int serial_complete(int handle,uint32_t timeout)\n{\n    int size;\n    utils_timer_t timer;\n    serial_t *s;\n    s =(serial_t *)handle;\t \n    if (s->init == false){\n        log_error(\"serial handle:%d not open.\\r\\n\",handle);\n        return -1;\n    } \n    utils_timer_init(&timer,timeout,false);\n    do {\n        size = circle_buffer_used_size(&s->send);\n        if (size != 0) {\n            osDelay(1);\n        }\n    } while (utils_timer_value(&timer) > 0 && size != 0);\n    return size;\n"]]}
{"hexsha": "977f383e2aec238e4fce3e4e80bde38a6e5f2645", "ext": "c", "lang": "C", "content": "void test_gcm_encrypt_decrypt(void){\n  unsigned char* key        = NULL;\n  unsigned char* plaintext  = NULL;\n  unsigned char* ciphertext = NULL;\n  unsigned char* decrypt    = NULL;\n\n  int key_len = 16;\n  size_t plaintext_len = 16;\n  size_t ciphertext_len = 0;\n  size_t decrypt_len = 0;\n  \n  key = calloc(key_len, 1);\n  plaintext = calloc(plaintext_len, 1);\n  \n  CU_ASSERT(aes_gcm_encrypt(key, key_len, plaintext, plaintext_len, &ciphertext, &ciphertext_len, false) == 0);\n  CU_ASSERT(ciphertext_len = plaintext_len + GCM_IV_LEN + GCM_TAG_LEN);\n  CU_ASSERT(aes_gcm_decrypt(key, key_len, ciphertext, ciphertext_len, &decrypt, &decrypt_len, false) == 0);\n  CU_ASSERT(decrypt_len == plaintext_len);\n  CU_ASSERT(memcmp(plaintext, decrypt, plaintext_len) == 0);\n\n\n  free(decrypt);\n  free(key);\n  free(plaintext);\n  free(ciphertext);\n  return;\n}", "item_id": 1, "repo": "cnxtech/kmyth", "file": "tpm1.2/test/aes_gcm_test_suite.c", "last_update_at": "2020-05-09T02:34:06+00:00", "question_id": "977f383e2aec238e4fce3e4e80bde38a6e5f2645_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void test_gcm_encrypt_decrypt(void){\n  unsigned char* key        = NULL;\n  unsigned char* plaintext  = NULL;\n  unsigned char* ciphertext = NULL;\n  unsigned char* decrypt    = NULL;\n  int key_len = 16;\n  size_t plaintext_len = 16;\n  size_t ciphertext_len = 0;\n  size_t decrypt_len = 0;\n  key = calloc(key_len, 1);\n  plaintext = calloc(plaintext_len, 1);\n  CU_ASSERT(aes_gcm_encrypt(key, key_len, plaintext, plaintext_len, &ciphertext, &ciphertext_len, false) == 0);\n  CU_ASSERT(ciphertext_len = plaintext_len + GCM_IV_LEN + GCM_TAG_LEN);\n  CU_ASSERT(aes_gcm_decrypt(key, key_len, ciphertext, ciphertext_len, &decrypt, &decrypt_len, false) == 0);\n  CU_ASSERT(decrypt_len == plaintext_len);\n  CU_ASSERT(memcmp(plaintext, decrypt, plaintext_len) == 0);\n  free(decrypt);\n  free(key);\n  free(plaintext);\n  free(ciphertext);\n  return;\n"]]}
{"hexsha": "c0c5b0ec81499b0675815ba39ec70c55e6b8d865", "ext": "c", "lang": "C", "content": "void _mcu_button_handle_input_event(mc_node *button_node, mci_input_event *input_event)\n{\n  // printf(\"_mcu_button_handle_input_event\\n\");\n  mcu_button *button = (mcu_button *)button_node->data;\n\n  if (!button->enabled)\n    return;\n\n  if (input_event->type == INPUT_EVENT_MOUSE_PRESS) {\n    // printf(\"_mcu_button_handle_input_event-1\\n\");\n    if (button->left_click && (mc_mouse_button_code)input_event->button_code == MOUSE_BUTTON_LEFT) {\n      // printf(\"_mcu_button_handle_input_event-2\\n\");\n      // Fire left-click\n      // TODO fptr casting\n      // TODO int this delegate for error handling\n      void (*left_click)(mci_input_event *, mcu_button *) =\n          (void (*)(mci_input_event *, mcu_button *))button->left_click;\n      // TODO -- MCcall(below) - have to make handle input event int\n      left_click(input_event, button);\n    }\n  }\n\n  input_event->handled = true;\n}", "item_id": 2, "repo": "ShimmyShaman/midge", "file": "src/modules/ui_elements/button.c", "last_update_at": "2020-08-08T06:22:11+00:00", "question_id": "c0c5b0ec81499b0675815ba39ec70c55e6b8d865_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void _mcu_button_handle_input_event(mc_node *button_node, mci_input_event *input_event)\n{\n  // printf(\"_mcu_button_handle_input_event\\n\");\n  mcu_button *button = (mcu_button *)button_node->data;\n  if (!button->enabled)\n    return;\n  if (input_event->type == INPUT_EVENT_MOUSE_PRESS) {\n    // printf(\"_mcu_button_handle_input_event-1\\n\");\n    if (button->left_click && (mc_mouse_button_code)input_event->button_code == MOUSE_BUTTON_LEFT) {\n      // printf(\"_mcu_button_handle_input_event-2\\n\");\n      // Fire left-click\n      // TODO fptr casting\n      // TODO int this delegate for error handling\n      void (*left_click)(mci_input_event *, mcu_button *) =\n          (void (*)(mci_input_event *, mcu_button *))button->left_click;\n      // TODO -- MCcall(below) - have to make handle input event int\n      left_click(input_event, button);\n    }\n  }\n  input_event->handled = true;\n"]]}
{"hexsha": "1be6b2888eb92b1bca047129249042ae95e96982", "ext": "h", "lang": "C", "content": "class RotateGizmo: public GraphicsSurface\n{\n\tpublic: enum\n\t{\n\t\tDEGREES,\n\t\tRADIANS\n\t};\n\tpublic: enum\n\t{\n\t\tNO_SELECT,\n\t\tX_AXIS,\n\t\tY_AXIS,\n\t\tZ_AXIS\n\t};\n\tprivate: GraphicsSurface* sphere;\n\tprivate: int32 segments;\n\tprivate: float step;\n\n\tprivate: Quaternion qX;\n\tprivate: Quaternion qY;\n\tprivate: Quaternion qZ;\n\n\tprivate: Vector3 xAxis;\n\tprivate: Vector3 yAxis;\n\tprivate: Vector3 zAxis;\n\t\n    private: float scale;\n    private: bool startRotation;\n\n    private: RGBA zColor, yColor, xColor, selectColor;\n    private: int32 selected;\n\n    private: Vector3 intersectedPoint;\n    private: Vector3 point1, point2;\n\tprivate: MagicList<GraphicsSurface> selectedList;\n\t\n\tprivate: MagicPointer<GraphicsSurface> targetObject;\n\tprivate: TexturingSurface* gizmo;\n    private: Texture2D* texture;\n\tprivate: Vector3 previousCursorPosition;\n\tprivate: Vector3 startCursorPosition;\n\n\tprivate: TexturingSurface* clenchedHandCursor;\n\tprivate: TexturingSurface* unclenchedHandCursor;\n\tprivate: TexturingSurface* arrowCursor;\n\tpublic: RotateGizmo(void);\n\tpublic: virtual ~RotateGizmo(void);\n\tpublic: void SetHome(void);\n\tpublic: GraphicsSurface* GetTargetObject(void)const;\n\tpublic: void Reset(void);\n\tpublic: TexturingSurface* GetGizmoSprite(void)const;\n\tpublic: void Init(TexturingSurface* _arrowCursor, TexturingSurface* _unclenchedHandCursor, TexturingSurface* _clenchedHandCursor);\n\tpublic: void SetSelectedList(MagicList<GraphicsSurface>& _list);\n\tpublic: MagicList<GraphicsSurface>& GetSelectedList(void);\n\tpublic: void ClearSelectedList(void);\n\tpublic: virtual void Draw(void);\n\tpublic: virtual void SetPosition(Vector3 _position);\n\tpublic: Mouse::Event* MouseEventFilter(Mouse::Event* _event);\n\tpublic: void CheckSelect(void);\n}", "item_id": 0, "repo": "gregory-vovchok/YEngine", "file": "Editor/DesignToolBar/RotateGizmo/RotateGizmo.h", "last_update_at": "2020-12-04T08:57:03+00:00", "question_id": "1be6b2888eb92b1bca047129249042ae95e96982_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class RotateGizmo: public GraphicsSurface\n{\n\tpublic: enum\n\t{\n\t\tDEGREES,\n\t\tRADIANS\n\t};\n\tpublic: enum\n\t{\n\t\tNO_SELECT,\n\t\tX_AXIS,\n\t\tY_AXIS,\n\t\tZ_AXIS\n\t};\n\tprivate: GraphicsSurface* sphere;\n\tprivate: int32 segments;\n\tprivate: float step;\n\tprivate: Quaternion qX;\n\tprivate: Quaternion qY;\n\tprivate: Quaternion qZ;\n\tprivate: Vector3 xAxis;\n\tprivate: Vector3 yAxis;\n\tprivate: Vector3 zAxis;\n\t\n    private: float scale;\n    private: bool startRotation;\n    private: RGBA zColor, yColor, xColor, selectColor;\n    private: int32 selected;\n    private: Vector3 intersectedPoint;\n    private: Vector3 point1, point2;\n\tprivate: MagicList<GraphicsSurface> selectedList;\n\t\n\tprivate: MagicPointer<GraphicsSurface> targetObject;\n\tprivate: TexturingSurface* gizmo;\n    private: Texture2D* texture;\n\tprivate: Vector3 previousCursorPosition;\n\tprivate: Vector3 startCursorPosition;\n\tprivate: TexturingSurface* clenchedHandCursor;\n\tprivate: TexturingSurface* unclenchedHandCursor;\n\tprivate: TexturingSurface* arrowCursor;\n\tpublic: RotateGizmo(void);\n\tpublic: virtual ~RotateGizmo(void);\n\tpublic: void SetHome(void);\n\tpublic: GraphicsSurface* GetTargetObject(void)const;\n\tpublic: void Reset(void);\n\tpublic: TexturingSurface* GetGizmoSprite(void)const;\n\tpublic: void Init(TexturingSurface* _arrowCursor, TexturingSurface* _unclenchedHandCursor, TexturingSurface* _clenchedHandCursor);\n\tpublic: void SetSelectedList(MagicList<GraphicsSurface>& _list);\n\tpublic: MagicList<GraphicsSurface>& GetSelectedList(void);\n\tpublic: void ClearSelectedList(void);\n\tpublic: virtual void Draw(void);\n\tpublic: virtual void SetPosition(Vector3 _position);\n\tpublic: Mouse::Event* MouseEventFilter(Mouse::Event* _event);\n\tpublic: void CheckSelect(void);\n"]]}
{"hexsha": "3d655fdf421f753a23ce769a9b3047113cd0bcf9", "ext": "c", "lang": "C", "content": "static void naos_mqtt_status_handler(esp_mqtt_status_t status) {\n  // acquire mutex\n  NAOS_LOCK(naos_mqtt_mutex);\n\n  // set status\n  naos_mqtt_status.connected = status == ESP_MQTT_STATUS_CONNECTED;\n\n  // release mutex\n  NAOS_UNLOCK(naos_mqtt_mutex);\n}", "item_id": 1, "repo": "shiftr-io/naos", "file": "com/src/mqtt.c", "last_update_at": "2020-02-18T22:04:43+00:00", "question_id": "3d655fdf421f753a23ce769a9b3047113cd0bcf9_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void naos_mqtt_status_handler(esp_mqtt_status_t status) {\n  // acquire mutex\n  NAOS_LOCK(naos_mqtt_mutex);\n  // set status\n  naos_mqtt_status.connected = status == ESP_MQTT_STATUS_CONNECTED;\n  // release mutex\n  NAOS_UNLOCK(naos_mqtt_mutex);\n"]]}
{"hexsha": "f803941e2dc304be0ba564d90b587fc4b63f0eea", "ext": "c", "lang": "C", "content": "int save_uncompressed(uint8_t port, uint8_t unit){\n\tvmu_pkg_t pkg;\n\tuint8 *pkg_out, *data;\n\tint pkg_size;\n\tFILE *fp;\n\tchar savename[32];\n\tmaple_device_t *vmu;\n\tint rv = 0, blocks_freed = 0;\n\tfile_t f;\n\n\t//Invalid controller/port\n\tif(port < 0 || port > 3 || unit < 1 || unit > 2){\n\t\treturn -2;\n\t}\n\n\t// Make sure there's a VMU in port a1.\n\t\t//Change this later to check all slots or the requested slots\n\tif(!(vmu = maple_enum_dev(port, unit))){\n\t\treturn -100;\n\t}\n\n\tif(!vmu->valid || !(vmu->info.functions & MAPLE_FUNC_MEMCARD)){\n\t\treturn -100;\n\t}\n\n\t//Only 20 chara allowed at max (21 if you include '\\0')\n\tsprintf(savename, \"/vmu/%c%d/\", port + 97, unit);\t//port gets converted to a, b, c or d. unit is unit\n\tstrcat(savename, \"UNCOMPRESS.s\");\n\n\tint filesize = sizeof(SaveFile_t);\n\tdata = (uint8_t *) malloc(filesize);\n\tif(data == NULL){\n\t\tfree(data);\n\t\treturn -1;\n\t}\n\tmemcpy(data, &save, sizeof(SaveFile_t));\t//Last param is number of bytes, not bits\n\n\tsprintf(pkg.desc_long, \"Uncompressed save file!\");\n\tstrcpy(pkg.desc_short, \"Uncompressed\");\n\tstrcpy(pkg.app_id, \"Proto_uncomp_save\");\n\tpkg.icon_cnt = 1;\n\tpkg.icon_anim_speed = 0;\n\tmemcpy(pkg.icon_pal, palette, 32);\n\tpkg.icon_data = icon;\n\tpkg.eyecatch_type = VMUPKG_EC_NONE;\n\tpkg.data_len = sizeof(SaveFile_t);\t//Double check this, but I think its right\n\tpkg.data = data;\n\n\tvmu_pkg_build(&pkg, &pkg_out, &pkg_size);\n\n\t// See if a file exists with that name, since we'll overwrite it.\n\tf = fs_open(savename, O_RDONLY);\n\tif(f != FILEHND_INVALID){\n\t\tblocks_freed = fs_total(f) >> 9;\n\t\tfs_close(f);\n\t}\n\n\t// Make sure there's enough free space on the VMU.\n\tif(vmufs_free_blocks(vmu) + blocks_freed < (pkg_size >> 9)){\n\t\tfree(pkg_out);\n\t\tfree(data);\n\t\treturn pkg_size >> 9;\n\t}\n\n\tif(!(fp = fopen(savename, \"wb\"))){\n\t\tfree(pkg_out);\n\t\tfree(data);\n\t\treturn -1;\n\t}\n\n\tif(fwrite(pkg_out, 1, pkg_size, fp) != (size_t)pkg_size){\n\t\trv = -1;\n\t}\n\n\tfclose(fp);\n\n\tfree(pkg_out);\n\tfree(data);\n\n\treturn rv;\n}", "item_id": 0, "repo": "Protofall/Homebrew-Tests", "file": "KallistiOSTests/VmuSavefile/savefile.c", "last_update_at": "2020-03-11T03:16:48+00:00", "question_id": "f803941e2dc304be0ba564d90b587fc4b63f0eea_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int save_uncompressed(uint8_t port, uint8_t unit){\n\tvmu_pkg_t pkg;\n\tuint8 *pkg_out, *data;\n\tint pkg_size;\n\tFILE *fp;\n\tchar savename[32];\n\tmaple_device_t *vmu;\n\tint rv = 0, blocks_freed = 0;\n\tfile_t f;\n\t//Invalid controller/port\n\tif(port < 0 || port > 3 || unit < 1 || unit > 2){\n\t\treturn -2;\n\t}\n\t// Make sure there's a VMU in port a1.\n\t\t//Change this later to check all slots or the requested slots\n\tif(!(vmu = maple_enum_dev(port, unit))){\n\t\treturn -100;\n\t}\n\tif(!vmu->valid || !(vmu->info.functions & MAPLE_FUNC_MEMCARD)){\n\t\treturn -100;\n\t}\n\t//Only 20 chara allowed at max (21 if you include '\\0')\n\tsprintf(savename, \"/vmu/%c%d/\", port + 97, unit);\t//port gets converted to a, b, c or d. unit is unit\n\tstrcat(savename, \"UNCOMPRESS.s\");\n\tint filesize = sizeof(SaveFile_t);\n\tdata = (uint8_t *) malloc(filesize);\n\tif(data == NULL){\n\t\tfree(data);\n\t\treturn -1;\n\t}\n\tmemcpy(data, &save, sizeof(SaveFile_t));\t//Last param is number of bytes, not bits\n\tsprintf(pkg.desc_long, \"Uncompressed save file!\");\n\tstrcpy(pkg.desc_short, \"Uncompressed\");\n\tstrcpy(pkg.app_id, \"Proto_uncomp_save\");\n\tpkg.icon_cnt = 1;\n\tpkg.icon_anim_speed = 0;\n\tmemcpy(pkg.icon_pal, palette, 32);\n\tpkg.icon_data = icon;\n\tpkg.eyecatch_type = VMUPKG_EC_NONE;\n\tpkg.data_len = sizeof(SaveFile_t);\t//Double check this, but I think its right\n\tpkg.data = data;\n\tvmu_pkg_build(&pkg, &pkg_out, &pkg_size);\n\t// See if a file exists with that name, since we'll overwrite it.\n\tf = fs_open(savename, O_RDONLY);\n\tif(f != FILEHND_INVALID){\n\t\tblocks_freed = fs_total(f) >> 9;\n\t\tfs_close(f);\n\t}\n\t// Make sure there's enough free space on the VMU.\n\tif(vmufs_free_blocks(vmu) + blocks_freed < (pkg_size >> 9)){\n\t\tfree(pkg_out);\n\t\tfree(data);\n\t\treturn pkg_size >> 9;\n\t}\n\tif(!(fp = fopen(savename, \"wb\"))){\n\t\tfree(pkg_out);\n\t\tfree(data);\n\t\treturn -1;\n\t}\n\tif(fwrite(pkg_out, 1, pkg_size, fp) != (size_t)pkg_size){\n\t\trv = -1;\n\t}\n\tfclose(fp);\n\tfree(pkg_out);\n\tfree(data);\n\treturn rv;\n"]]}
{"hexsha": "36530c136fba8eeb361dbda7b8055f5439b39b0e", "ext": "c", "lang": "C", "content": "primFun(primEnRange) {                  /* derived range for enum type     */\n    eval(primArg(1));                   /* :: (a,a) -> [a]                 */\n    updapRoot(ap(nameEnFrTo,primArg(3)),primArg(2));\n}", "item_id": 9, "repo": "omasanori/hugs98", "file": "src/builtin.c", "last_update_at": "2020-11-18T03:16:38+00:00", "question_id": "36530c136fba8eeb361dbda7b8055f5439b39b0e_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["primFun(primEnRange) {                  /* derived range for enum type     */\n    eval(primArg(1));                   /* :: (a,a) -> [a]                 */\n    updapRoot(ap(nameEnFrTo,primArg(3)),primArg(2));\n"]]}
{"hexsha": "8a55e0f4498482267fbd2cd6f81922a5877c6ec7", "ext": "c", "lang": "C", "content": "int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    REDISMODULE_NOT_USED(argv);\n    REDISMODULE_NOT_USED(argc);\n\n    if (RedisModule_Init(ctx,\"testkeyspace\",1,REDISMODULE_APIVER_1) == REDISMODULE_ERR){\n        return REDISMODULE_ERR;\n    }\n\n    loaded_event_log = RedisModule_CreateDict(ctx);\n    module_event_log = RedisModule_CreateDict(ctx);\n\n    int keySpaceAll = RedisModule_GetKeyspaceNotificationFlagsAll();\n\n    if (!(keySpaceAll & REDISMODULE_NOTIFY_LOADED)) {\n        // REDISMODULE_NOTIFY_LOADED event are not supported we can not start\n        return REDISMODULE_ERR;\n    }\n\n    if(RedisModule_SubscribeToKeyspaceEvents(ctx, REDISMODULE_NOTIFY_LOADED, KeySpace_NotificationLoaded) != REDISMODULE_OK){\n        return REDISMODULE_ERR;\n    }\n\n    if(RedisModule_SubscribeToKeyspaceEvents(ctx, REDISMODULE_NOTIFY_GENERIC, KeySpace_NotificationGeneric) != REDISMODULE_OK){\n        return REDISMODULE_ERR;\n    }\n\n    if(RedisModule_SubscribeToKeyspaceEvents(ctx, REDISMODULE_NOTIFY_MODULE, KeySpace_NotificationModule) != REDISMODULE_OK){\n        return REDISMODULE_ERR;\n    }\n\n    if (RedisModule_CreateCommand(ctx,\"keyspace.notify\", cmdNotify,\"\",0,0,0) == REDISMODULE_ERR){\n        return REDISMODULE_ERR;\n    }\n\n    if (RedisModule_CreateCommand(ctx,\"keyspace.is_module_key_notified\", cmdIsModuleKeyNotified,\"\",0,0,0) == REDISMODULE_ERR){\n        return REDISMODULE_ERR;\n    }\n\n    if (RedisModule_CreateCommand(ctx,\"keyspace.is_key_loaded\", cmdIsKeyLoaded,\"\",0,0,0) == REDISMODULE_ERR){\n        return REDISMODULE_ERR;\n    }\n\n    if (RedisModule_CreateCommand(ctx,\"keyspace.del_key_copy\", cmdDelKeyCopy,\"\",0,0,0) == REDISMODULE_ERR){\n        return REDISMODULE_ERR;\n    }\n    \n    if (RedisModule_CreateCommand(ctx,\"keyspace.incr_case1\", cmdIncrCase1,\"\",0,0,0) == REDISMODULE_ERR){\n        return REDISMODULE_ERR;\n    }\n    \n    if (RedisModule_CreateCommand(ctx,\"keyspace.incr_case2\", cmdIncrCase2,\"\",0,0,0) == REDISMODULE_ERR){\n        return REDISMODULE_ERR;\n    }\n    \n    if (RedisModule_CreateCommand(ctx,\"keyspace.incr_case3\", cmdIncrCase3,\"\",0,0,0) == REDISMODULE_ERR){\n        return REDISMODULE_ERR;\n    }\n\n    return REDISMODULE_OK;\n}", "item_id": 10, "repo": "artynet/redis", "file": "tests/modules/keyspace_events.c", "last_update_at": "2020-06-20T11:53:13+00:00", "question_id": "8a55e0f4498482267fbd2cd6f81922a5877c6ec7_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    REDISMODULE_NOT_USED(argv);\n    REDISMODULE_NOT_USED(argc);\n    if (RedisModule_Init(ctx,\"testkeyspace\",1,REDISMODULE_APIVER_1) == REDISMODULE_ERR){\n        return REDISMODULE_ERR;\n    }\n    loaded_event_log = RedisModule_CreateDict(ctx);\n    module_event_log = RedisModule_CreateDict(ctx);\n    int keySpaceAll = RedisModule_GetKeyspaceNotificationFlagsAll();\n    if (!(keySpaceAll & REDISMODULE_NOTIFY_LOADED)) {\n        // REDISMODULE_NOTIFY_LOADED event are not supported we can not start\n        return REDISMODULE_ERR;\n    }\n    if(RedisModule_SubscribeToKeyspaceEvents(ctx, REDISMODULE_NOTIFY_LOADED, KeySpace_NotificationLoaded) != REDISMODULE_OK){\n        return REDISMODULE_ERR;\n    }\n    if(RedisModule_SubscribeToKeyspaceEvents(ctx, REDISMODULE_NOTIFY_GENERIC, KeySpace_NotificationGeneric) != REDISMODULE_OK){\n        return REDISMODULE_ERR;\n    }\n    if(RedisModule_SubscribeToKeyspaceEvents(ctx, REDISMODULE_NOTIFY_MODULE, KeySpace_NotificationModule) != REDISMODULE_OK){\n        return REDISMODULE_ERR;\n    }\n    if (RedisModule_CreateCommand(ctx,\"keyspace.notify\", cmdNotify,\"\",0,0,0) == REDISMODULE_ERR){\n        return REDISMODULE_ERR;\n    }\n    if (RedisModule_CreateCommand(ctx,\"keyspace.is_module_key_notified\", cmdIsModuleKeyNotified,\"\",0,0,0) == REDISMODULE_ERR){\n        return REDISMODULE_ERR;\n    }\n    if (RedisModule_CreateCommand(ctx,\"keyspace.is_key_loaded\", cmdIsKeyLoaded,\"\",0,0,0) == REDISMODULE_ERR){\n        return REDISMODULE_ERR;\n    }\n    if (RedisModule_CreateCommand(ctx,\"keyspace.del_key_copy\", cmdDelKeyCopy,\"\",0,0,0) == REDISMODULE_ERR){\n        return REDISMODULE_ERR;\n    }\n    if (RedisModule_CreateCommand(ctx,\"keyspace.incr_case1\", cmdIncrCase1,\"\",0,0,0) == REDISMODULE_ERR){\n        return REDISMODULE_ERR;\n    }\n    if (RedisModule_CreateCommand(ctx,\"keyspace.incr_case2\", cmdIncrCase2,\"\",0,0,0) == REDISMODULE_ERR){\n        return REDISMODULE_ERR;\n    }\n    if (RedisModule_CreateCommand(ctx,\"keyspace.incr_case3\", cmdIncrCase3,\"\",0,0,0) == REDISMODULE_ERR){\n        return REDISMODULE_ERR;\n    }\n    return REDISMODULE_OK;\n"]]}
{"hexsha": "343bc427b588bcc183b60d0def641cac76d52848", "ext": "c", "lang": "C", "content": "int main() \n   {     \n   \t//Variables\n      int numGames = 36;\n      int date[numGames][1];\n      int AUscore[numGames][9];\n      int oppScore[numGames][9];\n      char oppName[NAMELEN], oppConf[4];\n      int i, j, k, score1, score2;\n      int secWin=0, secLoss=0, numWin=0, numLoss=0;\n      char result;\n      char year[4], college[10], sport[10];\n      \n   \n      /*-----------------------------------------------------------\n                        Open File\n      -----------------------------------------------------------*/\n   \n      FILE *dataFile;\n      dataFile = fopen(FILENAME, \"r\");//opens data file for reading\n   \n      if(dataFile == NULL)printf(\"error opening file \\n\");//makes sure data file exists\n      else{\n         fscanf(dataFile, \"%s %s %s\", year, college, sport);\n         printf(\"\t\t%s %s %s \\n\", year, college, sport);//prints the header\n         printHeaders();   \t//calls printHeader funcion\n      \t\n         for(i=0;i<numGames;i++){//start for loops\n         \t//scans data file------------------------------------------------\n            fscanf(dataFile, \"%d %d %s %s\", &date[i][0], &date[i][1],\n               \t\toppConf, oppName);\n            fscanf(dataFile, \"%d %d %d %d %d %d %d %d %d %d\",\n               \t\t&oppScore[i][0],&oppScore[i][1],&oppScore[i][2],&oppScore[i][3],\n               \t\t&oppScore[i][4],&oppScore[i][5],&oppScore[i][6],&oppScore[i][7],\n               \t\t&oppScore[i][8],&oppScore[i][9]);\n            fscanf(dataFile, \"%d %d %d %d %d %d %d %d %d %d\",\n               \t\t&AUscore[i][0],&AUscore[i][1],&AUscore[i][2],&AUscore[i][3],\n               \t\t&AUscore[i][4],&AUscore[i][5],&AUscore[i][6],&AUscore[i][7],\n               \t\t&AUscore[i][8],&AUscore[i][9]);\n         \t//----------------------------------------------------------------\n            score1 = 0;\n            score2 = 0;\n            for(j=0;j<10;j++){//calculates auburn and opponent scores and determines win/loss\n               score1 += oppScore[i][j];\n               score2 += AUscore[i][j];\n            }\n            if(score2<score1){\n               result='L';\n               numLoss+=1;\n            }\n            else if(score2>score1){\n               result='W';\n               numWin+=1;\n            }\n            else result='T';\n         \t\n         \n            printf(\"%02d/%02d\t%19s\t\t%02d-%02d \t%c \\n\", date[i][0], date[i][1],\n               \t\toppName, score1, score2, result);//prints data\n         }\n         printf(\"Auburn Season Record: %02d-%02d \\n\", numWin, numLoss);      \n      }\n      return 0;\n   }", "item_id": 0, "repo": "Skyfox64/auburn-csse", "file": "COMP 1200 - C-Programming/COMP 1200/Assignment 8/assign08.c", "last_update_at": "2020-12-10T00:50:08+00:00", "question_id": "343bc427b588bcc183b60d0def641cac76d52848_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main() \n   {     \n   \t//Variables\n      int numGames = 36;\n      int date[numGames][1];\n      int AUscore[numGames][9];\n      int oppScore[numGames][9];\n      char oppName[NAMELEN], oppConf[4];\n      int i, j, k, score1, score2;\n      int secWin=0, secLoss=0, numWin=0, numLoss=0;\n      char result;\n      char year[4], college[10], sport[10];\n      /*-----------------------------------------------------------\n                        Open File\n      -----------------------------------------------------------*/\n      FILE *dataFile;\n      dataFile = fopen(FILENAME, \"r\");//opens data file for reading\n      if(dataFile == NULL)printf(\"error opening file \\n\");//makes sure data file exists\n      else{\n         fscanf(dataFile, \"%s %s %s\", year, college, sport);\n         printf(\"\t\t%s %s %s \\n\", year, college, sport);//prints the header\n         printHeaders();   \t//calls printHeader funcion\n      \t\n         for(i=0;i<numGames;i++){//start for loops\n         \t//scans data file------------------------------------------------\n            fscanf(dataFile, \"%d %d %s %s\", &date[i][0], &date[i][1],\n               \t\toppConf, oppName);\n            fscanf(dataFile, \"%d %d %d %d %d %d %d %d %d %d\",\n               \t\t&oppScore[i][0],&oppScore[i][1],&oppScore[i][2],&oppScore[i][3],\n               \t\t&oppScore[i][4],&oppScore[i][5],&oppScore[i][6],&oppScore[i][7],\n               \t\t&oppScore[i][8],&oppScore[i][9]);\n            fscanf(dataFile, \"%d %d %d %d %d %d %d %d %d %d\",\n               \t\t&AUscore[i][0],&AUscore[i][1],&AUscore[i][2],&AUscore[i][3],\n               \t\t&AUscore[i][4],&AUscore[i][5],&AUscore[i][6],&AUscore[i][7],\n               \t\t&AUscore[i][8],&AUscore[i][9]);\n         \t//----------------------------------------------------------------\n            score1 = 0;\n            score2 = 0;\n            for(j=0;j<10;j++){//calculates auburn and opponent scores and determines win/loss\n               score1 += oppScore[i][j];\n               score2 += AUscore[i][j];\n            }\n            if(score2<score1){\n               result='L';\n               numLoss+=1;\n            }\n            else if(score2>score1){\n               result='W';\n               numWin+=1;\n            }\n            else result='T';\n         \t\n            printf(\"%02d/%02d\t%19s\t\t%02d-%02d \t%c \\n\", date[i][0], date[i][1],\n               \t\toppName, score1, score2, result);//prints data\n         }\n         printf(\"Auburn Season Record: %02d-%02d \\n\", numWin, numLoss);      \n      }\n      return 0;\n"]]}
{"hexsha": "1ff9e892e20084d18321c9a9831ecb335b9a5a07", "ext": "c", "lang": "C", "content": "static void VS_CC\nwrite_planar(img_hnd_t *ih, int n, VSFrameRef **dst, VSCore *core,\n             const VSAPI *vsapi)\n{\n    uint8_t *srcp = ih->image_buff;\n\n    for (int i = 0, num = ih->src[n].format->numPlanes; i < num; i++) {\n        int row_size = vsapi->getFrameWidth(dst[0], i) *\n                       ih->src[n].format->bytesPerSample;\n        row_size = (row_size + ih->row_adjust) & (~ih->row_adjust);\n        int height = vsapi->getFrameHeight(dst[0], i);\n        bit_blt(dst[0], i, vsapi, srcp, row_size, height);\n        srcp += row_size * height;\n    }\n    \n    if (ih->enable_alpha) {\n        set_dummy_alpha(ih, n, dst[1], core, vsapi);\n    }\n}", "item_id": 1, "repo": "darcyg/vapoursynth-plugins", "file": "plugins/imagereader/src/writeframe.c", "last_update_at": "2020-04-06T16:52:59+00:00", "question_id": "1ff9e892e20084d18321c9a9831ecb335b9a5a07_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void VS_CC\nwrite_planar(img_hnd_t *ih, int n, VSFrameRef **dst, VSCore *core,\n             const VSAPI *vsapi)\n{\n    uint8_t *srcp = ih->image_buff;\n    for (int i = 0, num = ih->src[n].format->numPlanes; i < num; i++) {\n        int row_size = vsapi->getFrameWidth(dst[0], i) *\n                       ih->src[n].format->bytesPerSample;\n        row_size = (row_size + ih->row_adjust) & (~ih->row_adjust);\n        int height = vsapi->getFrameHeight(dst[0], i);\n        bit_blt(dst[0], i, vsapi, srcp, row_size, height);\n        srcp += row_size * height;\n    }\n    if (ih->enable_alpha) {\n        set_dummy_alpha(ih, n, dst[1], core, vsapi);\n    }\n"]]}
{"hexsha": "b0b8496c96a437392f5a5a67531cd611e7eb6c7a", "ext": "c", "lang": "C", "content": "void say(unsigned level, const char *format, ...)\n{\n\tva_list ap;\n\n\tif (level > verbose)\n\t\treturn;\n\n\tva_start(ap, format);\n\n\tif (log_f) {\n\t\tfprintf(log_f, \"%u: \", getpid());\n\t\tvfprintf(log_f, format, ap);\n\t\tfprintf(log_f, \"\\n\");\n\t} else {\n\t\tfprintf(stderr, \"%u: \", getpid());\n\t\tvfprintf(stderr, format, ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\n\tva_end(ap);\n}", "item_id": 1, "repo": "rtokarev/OPENRELEASE", "file": "libopenrelease/log.c", "last_update_at": "2020-04-02T02:40:00+00:00", "question_id": "b0b8496c96a437392f5a5a67531cd611e7eb6c7a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void say(unsigned level, const char *format, ...)\n{\n\tva_list ap;\n\tif (level > verbose)\n\t\treturn;\n\tva_start(ap, format);\n\tif (log_f) {\n\t\tfprintf(log_f, \"%u: \", getpid());\n\t\tvfprintf(log_f, format, ap);\n\t\tfprintf(log_f, \"\\n\");\n\t} else {\n\t\tfprintf(stderr, \"%u: \", getpid());\n\t\tvfprintf(stderr, format, ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tva_end(ap);\n"]]}
{"hexsha": "49b7f22cf75146dba461a045461584f30a48ea88", "ext": "c", "lang": "C", "content": "int\ndtrace_handle_drop(dtrace_hdl_t *dtp, dtrace_handle_drop_f *hdlr, void *arg)\n{\n\tif (dtp->dt_drophdlr != NULL)\n\t\treturn (dt_set_errno(dtp, EALREADY));\n\n\tdtp->dt_drophdlr = hdlr;\n\tdtp->dt_droparg = arg;\n\n\treturn (0);\n}", "item_id": 1, "repo": "AsahiOS/gate", "file": "usr/src/lib/libdtrace/common/dt_handle.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "49b7f22cf75146dba461a045461584f30a48ea88_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\ndtrace_handle_drop(dtrace_hdl_t *dtp, dtrace_handle_drop_f *hdlr, void *arg)\n{\n\tif (dtp->dt_drophdlr != NULL)\n\t\treturn (dt_set_errno(dtp, EALREADY));\n\tdtp->dt_drophdlr = hdlr;\n\tdtp->dt_droparg = arg;\n\treturn (0);\n"]]}
{"hexsha": "9633a2b7ffc2c3c138560354970f78e8d120f975", "ext": "c", "lang": "C", "content": "void mx_set_profile_img(GtkButton *button, gpointer data) {\n    t_s_glade *gui = (t_s_glade *)data;\n    char *group_img = mx_open_file_chooser(GTK_WINDOW(gui->w_profile));\n    char *login = (char *)gtk_entry_get_text(GTK_ENTRY(gui->e_l_login));\n    mx_rep_img(gui->i_avatar, group_img, 225, 225);\n\n    GList *head = gtk_container_get_children(GTK_CONTAINER(gui->l_chats));\n    GList *node = head;\n\n    while (node) {\n        GtkWidget *grid = gtk_bin_get_child(GTK_BIN(node->data));\n        GtkWidget *label = gtk_grid_get_child_at(GTK_GRID(grid), 1, 0);\n        GtkWidget *img = gtk_grid_get_child_at(GTK_GRID(grid), 0, 0);\n        if (!mx_strcmp(login, gtk_label_get_text(GTK_LABEL(label))))\n            mx_rep_img(img, group_img, 48, 48);\n\n        node = g_list_next(node);\n    }\n    g_list_free(head);\n    (void)button;\n}", "item_id": 0, "repo": "PraydE007/uChat", "file": "client/src/mx_set_profile_img.c", "last_update_at": "2020-07-16T14:26:37+00:00", "question_id": "9633a2b7ffc2c3c138560354970f78e8d120f975_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void mx_set_profile_img(GtkButton *button, gpointer data) {\n    t_s_glade *gui = (t_s_glade *)data;\n    char *group_img = mx_open_file_chooser(GTK_WINDOW(gui->w_profile));\n    char *login = (char *)gtk_entry_get_text(GTK_ENTRY(gui->e_l_login));\n    mx_rep_img(gui->i_avatar, group_img, 225, 225);\n    GList *head = gtk_container_get_children(GTK_CONTAINER(gui->l_chats));\n    GList *node = head;\n    while (node) {\n        GtkWidget *grid = gtk_bin_get_child(GTK_BIN(node->data));\n        GtkWidget *label = gtk_grid_get_child_at(GTK_GRID(grid), 1, 0);\n        GtkWidget *img = gtk_grid_get_child_at(GTK_GRID(grid), 0, 0);\n        if (!mx_strcmp(login, gtk_label_get_text(GTK_LABEL(label))))\n            mx_rep_img(img, group_img, 48, 48);\n        node = g_list_next(node);\n    }\n    g_list_free(head);\n    (void)button;\n"]]}
{"hexsha": "cf22026f08b6e47c9fb5fb70e26a4bf4f7d71cb3", "ext": "h", "lang": "C", "content": "GH_INLINE U8   GH_DEBUG_AUC_get_USBP_CTRL_compdistune(void)\n{\n    GH_DEBUG_AUC_USBP_CTRL_S tmp_value;\n    U32 value = (*(volatile U32 *)REG_DEBUG_AUC_USBP_CTRL);\n\n    tmp_value.all = value;\n    #if GH_DEBUG_AUC_ENABLE_DEBUG_PRINT\n    GH_DEBUG_AUC_DEBUG_PRINT_FUNCTION( \"value = RDREG(0x%08x); \\\\\\\\ [GH_DEBUG_AUC_get_USBP_CTRL_compdistune] --> 0x%08x\\n\",\n                        REG_DEBUG_AUC_USBP_CTRL,value);\n    #endif\n    return tmp_value.bitc.compdistune;\n}", "item_id": 165, "repo": "Davidfind/rt-thread", "file": "bsp/gkipc/libraries/drv/710XS/gh/inc/gh_debug_auc.h", "last_update_at": "2020-12-19T04:35:43+00:00", "question_id": "cf22026f08b6e47c9fb5fb70e26a4bf4f7d71cb3_165", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["GH_INLINE U8   GH_DEBUG_AUC_get_USBP_CTRL_compdistune(void)\n{\n    GH_DEBUG_AUC_USBP_CTRL_S tmp_value;\n    U32 value = (*(volatile U32 *)REG_DEBUG_AUC_USBP_CTRL);\n    tmp_value.all = value;\n    #if GH_DEBUG_AUC_ENABLE_DEBUG_PRINT\n    GH_DEBUG_AUC_DEBUG_PRINT_FUNCTION( \"value = RDREG(0x%08x); \\\\\\\\ [GH_DEBUG_AUC_get_USBP_CTRL_compdistune] --> 0x%08x\\n\",\n                        REG_DEBUG_AUC_USBP_CTRL,value);\n    #endif\n    return tmp_value.bitc.compdistune;\n"]]}
{"hexsha": "ca714eb9f2a1f790dd217a04e086da3c52b6a805", "ext": "c", "lang": "C", "content": "static int\nmkworkdir(void)\n{\n\tchar b[32];\n\tchar *d;\n\n\tcleanup();\n\n\t(void) strlcpy(b, \"/tmp/symbols_testXXXXXX\", sizeof (b));\n\tif ((d = mkdtemp(b)) == NULL) {\n\t\tperror(\"mkdtemp\");\n\t\treturn (-1);\n\t}\n\tdname = mystrdup(d);\n\tmyasprintf(&cfile, \"%s/compile_test.c\", d);\n\tmyasprintf(&ofile, \"%s/compile_test.o\", d);\n\tmyasprintf(&lfile, \"%s/compile_test.log\", d);\n\tmyasprintf(&efile, \"%s/compile_test.exe\", d);\n\treturn (0);\n}", "item_id": 20, "repo": "AsahiOS/gate", "file": "usr/src/test/libc-tests/tests/symbols/symbols_test.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "ca714eb9f2a1f790dd217a04e086da3c52b6a805_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nmkworkdir(void)\n{\n\tchar b[32];\n\tchar *d;\n\tcleanup();\n\t(void) strlcpy(b, \"/tmp/symbols_testXXXXXX\", sizeof (b));\n\tif ((d = mkdtemp(b)) == NULL) {\n\t\tperror(\"mkdtemp\");\n\t\treturn (-1);\n\t}\n\tdname = mystrdup(d);\n\tmyasprintf(&cfile, \"%s/compile_test.c\", d);\n\tmyasprintf(&ofile, \"%s/compile_test.o\", d);\n\tmyasprintf(&lfile, \"%s/compile_test.log\", d);\n\tmyasprintf(&efile, \"%s/compile_test.exe\", d);\n\treturn (0);\n"]]}
{"hexsha": "b35ab611bef5b96b7341c43ef17b0cddd14c5fab", "ext": "c", "lang": "C", "content": "bStatus_t GAPObserverRole_StartDiscovery( uint8 mode, uint8 activeScan, uint8 whiteList )\n{\n  gapDevDiscReq_t params;\n\n  params.taskID = gapObserverRoleTaskId;\n  params.mode = mode;\n  params.activeScan = activeScan;\n  params.whiteList = whiteList;\n\n  return GAP_DeviceDiscoveryRequest( &params );\n}", "item_id": 2, "repo": "sentervip/phy62xBleSDk2.0.1", "file": "PHY62XX_SDK_2.0.1/components/profiles/Roles/observer.c", "last_update_at": "2020-12-14T19:47:20+00:00", "question_id": "b35ab611bef5b96b7341c43ef17b0cddd14c5fab_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bStatus_t GAPObserverRole_StartDiscovery( uint8 mode, uint8 activeScan, uint8 whiteList )\n{\n  gapDevDiscReq_t params;\n  params.taskID = gapObserverRoleTaskId;\n  params.mode = mode;\n  params.activeScan = activeScan;\n  params.whiteList = whiteList;\n  return GAP_DeviceDiscoveryRequest( &params );\n"]]}
{"hexsha": "83c55a2c40f95b48e2134253691cb77cb6debfd3", "ext": "h", "lang": "C", "content": "class AlignmentController\n{\n  private:\n    // Comms\n    ros::NodeHandle nh;\n    ros::Subscriber alignment_cmd_sub, object_sub, depth_sub, task_info_sub;\n    ros::Publisher x_pub, y_pub, depth_pub, status_pub;\n    ros::Timer timer;\n\n    // IIR Filter variables for error_dot\n    double PID_IIR_LPF_bandwidth, dt_iir, alpha, imu_filter_rate;\n\n    double max_zero_detect_duration;\n\n    control_toolbox::Pid x_pid, y_pid, z_pid;\n    double cmd_heave;\n    std_msgs::Float64 cmd_force_x, cmd_force_y;\n    riptide_msgs::DepthCommand depth_cmd;\n\n    riptide_msgs::ControlStatusLinear status_msg;\n    double current_depth;\n    double MAX_X_ERROR, MAX_Y_ERROR, MAX_Z_ERROR, MAX_BBOX_SURGE_ERROR, MAX_BBOX_DEPTH_ERROR;\n    \n    int alignment_plane, bbox_control, obj_bbox_dim, target_bbox_dim;\n\n    geometry_msgs::Vector3 error, error_dot, last_error_dot, last_error;\n    geometry_msgs::Vector3 obj_pos, target_pos;\n    double dt;\n\n    ros::Time sample_start;\n    ros::Duration sample_duration;\n\n    // Reset and active variables\n    //bool pid_alignment_reset, pid_alignment_active;\n    //bool pid_surge_reset, pid_sway_reset, pid_heave_reset;\n    bool pid_surge_active, pid_sway_active, pid_heave_active, pid_alignment_active;\n\n    void InitMsgs();\n    void UpdateError();\n    double Constrain(double current, double max);\n    double SmoothErrorIIR(double input, double prev);\n    void ResetSurge();\n    void ResetSway();\n    void ResetHeave();\n\n  public:\n    AlignmentController();\n    template <typename T>\n    void LoadParam(string param, T &var);\n    void ObjectCB(const riptide_msgs::Object::ConstPtr &obj_msg);\n    void DisableControllerTimer(const ros::TimerEvent& event);\n    void CommandCB(const riptide_msgs::AlignmentCommand::ConstPtr &cmd);\n    void DepthCB(const riptide_msgs::Depth::ConstPtr &depth_msg);\n    void TaskInfoCB(const riptide_msgs::TaskInfo::ConstPtr& task_msg);\n    //void ResetCB(const riptide_msgs::ResetControls::ConstPtr &reset_msg);\n }", "item_id": 0, "repo": "clabough2/riptide_software", "file": "riptide_controllers/include/riptide_controllers/alignment_controller.h", "last_update_at": "2020-07-17T23:57:58+00:00", "question_id": "83c55a2c40f95b48e2134253691cb77cb6debfd3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class AlignmentController\n{\n  private:\n    // Comms\n    ros::NodeHandle nh;\n    ros::Subscriber alignment_cmd_sub, object_sub, depth_sub, task_info_sub;\n    ros::Publisher x_pub, y_pub, depth_pub, status_pub;\n    ros::Timer timer;\n    // IIR Filter variables for error_dot\n    double PID_IIR_LPF_bandwidth, dt_iir, alpha, imu_filter_rate;\n    double max_zero_detect_duration;\n    control_toolbox::Pid x_pid, y_pid, z_pid;\n    double cmd_heave;\n    std_msgs::Float64 cmd_force_x, cmd_force_y;\n    riptide_msgs::DepthCommand depth_cmd;\n    riptide_msgs::ControlStatusLinear status_msg;\n    double current_depth;\n    double MAX_X_ERROR, MAX_Y_ERROR, MAX_Z_ERROR, MAX_BBOX_SURGE_ERROR, MAX_BBOX_DEPTH_ERROR;\n    int alignment_plane, bbox_control, obj_bbox_dim, target_bbox_dim;\n    geometry_msgs::Vector3 error, error_dot, last_error_dot, last_error;\n    geometry_msgs::Vector3 obj_pos, target_pos;\n    double dt;\n    ros::Time sample_start;\n    ros::Duration sample_duration;\n    // Reset and active variables\n    //bool pid_alignment_reset, pid_alignment_active;\n    //bool pid_surge_reset, pid_sway_reset, pid_heave_reset;\n    bool pid_surge_active, pid_sway_active, pid_heave_active, pid_alignment_active;\n    void InitMsgs();\n    void UpdateError();\n    double Constrain(double current, double max);\n    double SmoothErrorIIR(double input, double prev);\n    void ResetSurge();\n    void ResetSway();\n    void ResetHeave();\n  public:\n    AlignmentController();\n    template <typename T>\n    void LoadParam(string param, T &var);\n    void ObjectCB(const riptide_msgs::Object::ConstPtr &obj_msg);\n    void DisableControllerTimer(const ros::TimerEvent& event);\n    void CommandCB(const riptide_msgs::AlignmentCommand::ConstPtr &cmd);\n    void DepthCB(const riptide_msgs::Depth::ConstPtr &depth_msg);\n    void TaskInfoCB(const riptide_msgs::TaskInfo::ConstPtr& task_msg);\n    //void ResetCB(const riptide_msgs::ResetControls::ConstPtr &reset_msg);\n"]]}
{"hexsha": "70f4a8c8db38e473a6d492cf0a27e4333166ecd4", "ext": "c", "lang": "C", "content": "void GH_UART1_set_FCR_TX_Empty_Trigger(U8 data)\n{\n    m_uart1_fcr.bitc.tx_empty_trigger = data;\n    *(volatile U32 *)REG_UART1_FCR = m_uart1_fcr.all;\n    #if GH_UART1_ENABLE_DEBUG_PRINT\n    GH_UART1_DEBUG_PRINT_FUNCTION( \"WRREG(0x%08x,0x%08x); \\\\\\\\ [GH_UART1_set_FCR_TX_Empty_Trigger] <-- 0x%08x\\n\",\n                        REG_UART1_FCR,m_uart1_fcr.all,m_uart1_fcr.all);\n    #endif\n}", "item_id": 27, "repo": "Davidfind/rt-thread", "file": "bsp/gkipc/libraries/drv/710XS/gh/src/gh_uart1.c", "last_update_at": "2020-12-19T04:35:43+00:00", "question_id": "70f4a8c8db38e473a6d492cf0a27e4333166ecd4_27", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void GH_UART1_set_FCR_TX_Empty_Trigger(U8 data)\n{\n    m_uart1_fcr.bitc.tx_empty_trigger = data;\n    *(volatile U32 *)REG_UART1_FCR = m_uart1_fcr.all;\n    #if GH_UART1_ENABLE_DEBUG_PRINT\n    GH_UART1_DEBUG_PRINT_FUNCTION( \"WRREG(0x%08x,0x%08x); \\\\\\\\ [GH_UART1_set_FCR_TX_Empty_Trigger] <-- 0x%08x\\n\",\n                        REG_UART1_FCR,m_uart1_fcr.all,m_uart1_fcr.all);\n    #endif\n"]]}
{"hexsha": "8853d120c4eb86a20d7ff2c7513f815b12ccd8f3", "ext": "c", "lang": "C", "content": "int\nset_current_field(FORM *f, FIELD *c)\n{\n\tif (!f || !c || c->form != f)\n\t\treturn (E_BAD_ARGUMENT);\n\n\tif (!Opt(c, O_ACTIVE) || !Opt(c, O_VISIBLE))\n\t\treturn (E_REQUEST_DENIED);\n\n\tif (!Status(f, POSTED)) {\n\t\tC(f) = c;\n\t\tP(f) = c->page;\n\t\treturn (E_OK);\n\t}\n\tif (Status(f, DRIVER))\n\t\treturn (E_BAD_STATE);\n\n\tif (c != C(f)) {\n\t\tif (_validate(f)) {\n\t\t\tint v;\n\n\t\t\tterm_field(f);\n\n\t\t\tif (c -> page != P(f)) {\t/* page change */\n\t\t\t\tterm_form(f);\n\t\t\t\tv = _set_form_page(f, c->page, c);\n\t\t\t\tinit_form(f);\n\t\t\t} else\n\t\t\t\tv = _set_current_field(f, c);\n\n\t\t\tinit_field(f);\n\t\t\t(void) _update_current(f);\n\t\t\treturn (v);\n\t\t} else\n\t\t\treturn (E_INVALID_FIELD);\n\t}\n\treturn (E_OK);\n}", "item_id": 3, "repo": "AsahiOS/gate", "file": "usr/src/lib/libeti/form/common/post.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "8853d120c4eb86a20d7ff2c7513f815b12ccd8f3_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nset_current_field(FORM *f, FIELD *c)\n{\n\tif (!f || !c || c->form != f)\n\t\treturn (E_BAD_ARGUMENT);\n\tif (!Opt(c, O_ACTIVE) || !Opt(c, O_VISIBLE))\n\t\treturn (E_REQUEST_DENIED);\n\tif (!Status(f, POSTED)) {\n\t\tC(f) = c;\n\t\tP(f) = c->page;\n\t\treturn (E_OK);\n\t}\n\tif (Status(f, DRIVER))\n\t\treturn (E_BAD_STATE);\n\tif (c != C(f)) {\n\t\tif (_validate(f)) {\n\t\t\tint v;\n\t\t\tterm_field(f);\n\t\t\tif (c -> page != P(f)) {\t/* page change */\n\t\t\t\tterm_form(f);\n\t\t\t\tv = _set_form_page(f, c->page, c);\n\t\t\t\tinit_form(f);\n\t\t\t} else\n\t\t\t\tv = _set_current_field(f, c);\n\t\t\tinit_field(f);\n\t\t\t(void) _update_current(f);\n\t\t\treturn (v);\n\t\t} else\n\t\t\treturn (E_INVALID_FIELD);\n\t}\n\treturn (E_OK);\n"]]}
{"hexsha": "cff5d039c2bae3d82b84d5a70f90bfa77c126e38", "ext": "h", "lang": "C", "content": "void set_agnostic_pmods(const int& itv)\r\n\t{\r\n\t\t/* these pattern mods operate on all columns, only need basic meta\r\n\t\t * interval data, and do not need any more advanced pattern\r\n\t\t * sequencing. Just set only one hand's values and we'll copy them\r\n\t\t * over (or figure out how not to need to) later */\r\n\r\n\t\tPatternMods::set_agnostic(_s._pmod, _s(_mitvi), itv, _calc);\r\n\t\tPatternMods::set_agnostic(_js._pmod, _js(_mitvi), itv, _calc);\r\n\t\tPatternMods::set_agnostic(_hs._pmod, _hs(_mitvi), itv, _calc);\r\n\t\tPatternMods::set_agnostic(_cj._pmod, _cj(_mitvi), itv, _calc);\r\n\t\tPatternMods::set_agnostic(_cjd._pmod, _cjd(_mitvi), itv, _calc);\r\n\t\tPatternMods::set_agnostic(_hsd._pmod, _hsd(_mitvi), itv, _calc);\r\n\t\tPatternMods::set_agnostic(_fj._pmod, _fj(), itv, _calc);\r\n\t\tPatternMods::set_agnostic(_tt._pmod, _tt(), itv, _calc);\r\n\t\tPatternMods::set_agnostic(_tt2._pmod, _tt2(), itv, _calc);\r\n\t}", "item_id": 4, "repo": "graemephi/seeminacalc", "file": "etterna/Etterna/MinaCalc/Ulbu.h", "last_update_at": "2020-10-27T18:51:08+00:00", "question_id": "cff5d039c2bae3d82b84d5a70f90bfa77c126e38_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void set_agnostic_pmods(const int& itv)\r\n\t{\r\n\t\t/* these pattern mods operate on all columns, only need basic meta\r\n\t\t * interval data, and do not need any more advanced pattern\r\n\t\t * sequencing. Just set only one hand's values and we'll copy them\r\n\t\t * over (or figure out how not to need to) later */\r\n\r\n\t\tPatternMods::set_agnostic(_s._pmod, _s(_mitvi), itv, _calc);\r\n\t\tPatternMods::set_agnostic(_js._pmod, _js(_mitvi), itv, _calc);\r\n\t\tPatternMods::set_agnostic(_hs._pmod, _hs(_mitvi), itv, _calc);\r\n\t\tPatternMods::set_agnostic(_cj._pmod, _cj(_mitvi), itv, _calc);\r\n\t\tPatternMods::set_agnostic(_cjd._pmod, _cjd(_mitvi), itv, _calc);\r\n\t\tPatternMods::set_agnostic(_hsd._pmod, _hsd(_mitvi), itv, _calc);\r\n\t\tPatternMods::set_agnostic(_fj._pmod, _fj(), itv, _calc);\r\n\t\tPatternMods::set_agnostic(_tt._pmod, _tt(), itv, _calc);\r\n\t\tPatternMods::set_agnostic(_tt2._pmod, _tt2(), itv, _calc);\r\n"]]}
{"hexsha": "472fb8f44988ea74a4be6b12bbb4191b7ce2d28e", "ext": "c", "lang": "C", "content": "static int tolua_MathLuaAPI_Plane_new02(lua_State* tolua_S)\n{\n tolua_Error tolua_err;\n if (\n !tolua_isusertable(tolua_S,1,\"Plane\",0,&tolua_err) ||\n (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,\"const Vector3\",0,&tolua_err)) ||\n (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,\"const Vector3\",0,&tolua_err)) ||\n (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,\"const Vector3\",0,&tolua_err)) ||\n !tolua_isnoobj(tolua_S,5,&tolua_err)\n )\n goto tolua_lerror;\n else\n {\n  const Vector3* v0 = ((const Vector3*)  tolua_tousertype(tolua_S,2,0));\n  const Vector3* v1 = ((const Vector3*)  tolua_tousertype(tolua_S,3,0));\n  const Vector3* v2 = ((const Vector3*)  tolua_tousertype(tolua_S,4,0));\n {\n  Plane* tolua_ret = (Plane*)  Mtolua_new((Plane)(*v0,*v1,*v2));\n  tolua_pushusertype(tolua_S,(void*)tolua_ret,\"Plane\");\n }\n }\n return 1;\ntolua_lerror:\n return tolua_MathLuaAPI_Plane_new01(tolua_S);\n}", "item_id": 344, "repo": "devxkh/FrankE", "file": "src/src/XEScripts/LUA/LuaMathAPI.c", "last_update_at": "2020-11-27T16:54:42+00:00", "question_id": "472fb8f44988ea74a4be6b12bbb4191b7ce2d28e_344", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int tolua_MathLuaAPI_Plane_new02(lua_State* tolua_S)\n{\n tolua_Error tolua_err;\n if (\n !tolua_isusertable(tolua_S,1,\"Plane\",0,&tolua_err) ||\n (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,\"const Vector3\",0,&tolua_err)) ||\n (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,\"const Vector3\",0,&tolua_err)) ||\n (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,\"const Vector3\",0,&tolua_err)) ||\n !tolua_isnoobj(tolua_S,5,&tolua_err)\n )\n goto tolua_lerror;\n else\n {\n  const Vector3* v0 = ((const Vector3*)  tolua_tousertype(tolua_S,2,0));\n  const Vector3* v1 = ((const Vector3*)  tolua_tousertype(tolua_S,3,0));\n  const Vector3* v2 = ((const Vector3*)  tolua_tousertype(tolua_S,4,0));\n {\n  Plane* tolua_ret = (Plane*)  Mtolua_new((Plane)(*v0,*v1,*v2));\n  tolua_pushusertype(tolua_S,(void*)tolua_ret,\"Plane\");\n }\n }\n return 1;\ntolua_lerror:\n return tolua_MathLuaAPI_Plane_new01(tolua_S);\n"]]}
{"hexsha": "c81d8902091655434b9d2fba6e783cdf02485b77", "ext": "c", "lang": "C", "content": "static napi_value nsql_statement_close(napi_env env, napi_callback_info ctx) {\n  struct nsql_statement *self;\n  napi_value nself;\n  napi_status r;\n  int sqlr;\n\n  r = napi_get_cb_info(env, ctx, NULL, NULL, &nself, NULL);\n\n  if (r != napi_ok) {\n    nsql_report_error(env, r);\n\n    goto end;\n  }\n\n  r = napi_unwrap(env, nself, (void **)&self);\n\n  if (r != napi_ok) {\n    nsql_report_error(env, r);\n\n    goto end;\n  }\n\n  assert(self != NULL);\n\n  sqlr = sqlite3_finalize(self->stmt);\n\n  if (sqlr != SQLITE_OK) {\n    r = nsql_throw_sqlite_error(env, sqlr, NULL);\n  }\n\n  self->db = NULL;\n  self->stmt = NULL;\n\n  nsql_dprintf(\"%s\\n\", __func__);\n\nend:\n  return nsql_return(env, r, NULL);\n}", "item_id": 4, "repo": "decafcode/nsql", "file": "native/nsql/statement.c", "last_update_at": "2020-05-17T17:49:51+00:00", "question_id": "c81d8902091655434b9d2fba6e783cdf02485b77_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static napi_value nsql_statement_close(napi_env env, napi_callback_info ctx) {\n  struct nsql_statement *self;\n  napi_value nself;\n  napi_status r;\n  int sqlr;\n  r = napi_get_cb_info(env, ctx, NULL, NULL, &nself, NULL);\n  if (r != napi_ok) {\n    nsql_report_error(env, r);\n    goto end;\n  }\n  r = napi_unwrap(env, nself, (void **)&self);\n  if (r != napi_ok) {\n    nsql_report_error(env, r);\n    goto end;\n  }\n  assert(self != NULL);\n  sqlr = sqlite3_finalize(self->stmt);\n  if (sqlr != SQLITE_OK) {\n    r = nsql_throw_sqlite_error(env, sqlr, NULL);\n  }\n  self->db = NULL;\n  self->stmt = NULL;\n  nsql_dprintf(\"%s\\n\", __func__);\nend:\n  return nsql_return(env, r, NULL);\n"]]}
{"hexsha": "0dbe29d7d88b67c5bbda8491daeec53f74477528", "ext": "c", "lang": "C", "content": "void e() { i(); j(); test++; }", "item_id": 0, "repo": "ngzhian/emscripten", "file": "tests/emterpreter_advise_synclist.c", "last_update_at": "2020-07-26T05:50:02+00:00", "question_id": "0dbe29d7d88b67c5bbda8491daeec53f74477528_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void e() { i(); j(); test++; }\n"]]}
{"hexsha": "ca9e4756d9da32a93377996158d234ba218cb1c3", "ext": "h", "lang": "C", "content": "interface MPSGraphExecutionDescriptor : NSObject {\n\n\tBOOL _waitUntilCompleted;\n\t/*^block*/id _scheduledHandler;\n\t/*^block*/id _completionHandler;\n\tMPSGraphExecutable* _executable;\n\n}", "item_id": 0, "repo": "zhangkn/iOS14Header", "file": "System/Library/Frameworks/MetalPerformanceShadersGraph.framework/MPSGraphExecutionDescriptor.h", "last_update_at": "2020-11-04T15:43:01+00:00", "question_id": "ca9e4756d9da32a93377996158d234ba218cb1c3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface MPSGraphExecutionDescriptor : NSObject {\n\tBOOL _waitUntilCompleted;\n\t/*^block*/id _scheduledHandler;\n\t/*^block*/id _completionHandler;\n\tMPSGraphExecutable* _executable;\n"]]}
{"hexsha": "c0691f2959983dfc610c0cdf55e0c1da6f60c4e7", "ext": "c", "lang": "C", "content": "void linkedListRemove(struct LinkedListNode* node) {\n    node->next->prev = node->prev;\n    node->prev->next = node->next;\n    free(node);\n}", "item_id": 2, "repo": "youshihou/leetcode-algorithm", "file": "algorithm/algorithm/high-frequency/T146-lru-cache.c", "last_update_at": "2020-08-27T02:36:18+00:00", "question_id": "c0691f2959983dfc610c0cdf55e0c1da6f60c4e7_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void linkedListRemove(struct LinkedListNode* node) {\n    node->next->prev = node->prev;\n    node->prev->next = node->next;\n    free(node);\n"]]}
{"hexsha": "0a0f477797deecbc0e28c5869961486a9818ad0f", "ext": "c", "lang": "C", "content": "static INT64 calculate_op(YMF271Chip *chip, int slotnum, INT64 inp)\n{\n\tYMF271Slot *slot = &chip->slots[slotnum];\n\tINT64 env, slot_output, slot_input = 0;\n\n\tupdate_envelope(slot);\n\tupdate_lfo(chip, slot);\n\tenv = calculate_slot_volume(chip, slot);\n\n\tif (inp == OP_INPUT_FEEDBACK)\n\t{\n\t\t// from own feedback\n\t\tslot_input = (slot->feedback_modulation0 + slot->feedback_modulation1) / 2;\n\t\tslot->feedback_modulation0 = slot->feedback_modulation1;\n\t}\n\telse if (inp != OP_INPUT_NONE)\n\t{\n\t\t// from previous slot output\n\t\tslot_input = ((inp << (SIN_BITS-2)) * modulation_level[slot->feedback]);\n\t}\n\n\tslot_output = chip->lut_waves[slot->waveform][((slot->stepptr + slot_input) >> 16) & SIN_MASK];\n\tslot_output = (slot_output * env) >> 16;\n\tslot->stepptr += slot->step;\n\n\treturn slot_output;\n}", "item_id": 8, "repo": "emoon/HippoPlayer", "file": "src/plugins/playback/vgm/VGMPlay/chips/ymf271.c", "last_update_at": "2020-08-24T23:45:56+00:00", "question_id": "0a0f477797deecbc0e28c5869961486a9818ad0f_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static INT64 calculate_op(YMF271Chip *chip, int slotnum, INT64 inp)\n{\n\tYMF271Slot *slot = &chip->slots[slotnum];\n\tINT64 env, slot_output, slot_input = 0;\n\tupdate_envelope(slot);\n\tupdate_lfo(chip, slot);\n\tenv = calculate_slot_volume(chip, slot);\n\tif (inp == OP_INPUT_FEEDBACK)\n\t{\n\t\t// from own feedback\n\t\tslot_input = (slot->feedback_modulation0 + slot->feedback_modulation1) / 2;\n\t\tslot->feedback_modulation0 = slot->feedback_modulation1;\n\t}\n\telse if (inp != OP_INPUT_NONE)\n\t{\n\t\t// from previous slot output\n\t\tslot_input = ((inp << (SIN_BITS-2)) * modulation_level[slot->feedback]);\n\t}\n\tslot_output = chip->lut_waves[slot->waveform][((slot->stepptr + slot_input) >> 16) & SIN_MASK];\n\tslot_output = (slot_output * env) >> 16;\n\tslot->stepptr += slot->step;\n\treturn slot_output;\n"]]}
{"hexsha": "87e7aae510c986e652e839c0bff7c2b8a12bb3b0", "ext": "c", "lang": "C", "content": "char *get_tail(const char *code, char *rcode) {\n  char *quot;\n  unsigned code_len;\n\n  code_len = strlen(code);\n\n  memset(rcode, 0, 2);\n  if ((quot = strchr(code, '\\''))) {\n    rcode[0] = *(quot - 1);\n  } else {\n    rcode[0] = code[code_len - 1];\n  }\n\n  return rcode;\n}", "item_id": 5, "repo": "cycoe/type-coach", "file": "coach.c", "last_update_at": "2020-03-08T15:11:30+00:00", "question_id": "87e7aae510c986e652e839c0bff7c2b8a12bb3b0_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char *get_tail(const char *code, char *rcode) {\n  char *quot;\n  unsigned code_len;\n  code_len = strlen(code);\n  memset(rcode, 0, 2);\n  if ((quot = strchr(code, '\\''))) {\n    rcode[0] = *(quot - 1);\n  } else {\n    rcode[0] = code[code_len - 1];\n  }\n  return rcode;\n"]]}
{"hexsha": "9f6320a228cb740f3f352ccd1590f12489da5b11", "ext": "c", "lang": "C", "content": "void glshim_glTexEnvi(GLenum target, GLenum pname, GLint param) {\n    LOAD_GLES(glTexEnvi);\n#ifndef direct_glTexEnvi\n    PUSH_IF_COMPILING(glTexEnvi)\n#endif\n    gles_glTexEnvi(target, pname, param);\n}", "item_id": 129, "repo": "gameblabla/glshim-gcw", "file": "src/gl/wrap/gles.c", "last_update_at": "2020-05-20T19:50:14+00:00", "question_id": "9f6320a228cb740f3f352ccd1590f12489da5b11_129", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void glshim_glTexEnvi(GLenum target, GLenum pname, GLint param) {\n    LOAD_GLES(glTexEnvi);\n#ifndef direct_glTexEnvi\n    PUSH_IF_COMPILING(glTexEnvi)\n#endif\n    gles_glTexEnvi(target, pname, param);\n"]]}
{"hexsha": "5a276702dbc498ba5bf11da339a456e1942d54ad", "ext": "c", "lang": "C", "content": "static const char *contact_id_message(const char *id_who, const char *id_whom, int i) { //\u043d\u0430\u0445\u043e\u0434\u0438\u0442 \u0430\u0439\u0434\u0438 whom\n    int rc = 0;\n    char zSql[]=\"SELECT * FROM messages\";\n    int count = 0;\n    int krugi = -1;\n\n    do {\n            sqlite3_prepare(db, zSql, -1, &stmt, 0);\n            while(SQLITE_ROW == sqlite3_step(stmt)) {\n\n\n                //printf(\"%s\\n\", sqlite3_column_text(stmt,0));\n\n                if ((strcmp((const char*)sqlite3_column_text(stmt,1), id_who) == 0 ) && (strcmp((const char*)sqlite3_column_text(stmt,2), id_whom) == 0 ))\n                    krugi++;\n\n                if ((strcmp((const char*)sqlite3_column_text(stmt,1), id_whom) == 0 ) && (strcmp((const char*)sqlite3_column_text(stmt,2), id_who) == 0 ))\n                    krugi++;\n\n                    if(krugi == i) {\n                        const char *res = mx_strnew(255);\n                        res = (const char*)sqlite3_column_text(stmt,1);\n                        rc = sqlite3_finalize(stmt);\n                        return res;\n                    }\n            }\n                rc = sqlite3_finalize(stmt);\n                }\n    while(rc == SQLITE_SCHEMA); {}\n    return \"-1\";\n}", "item_id": 2, "repo": "vrudkovsky/uchat", "file": "server/src/dal/mx_get_who.c", "last_update_at": "2020-12-03T16:07:08+00:00", "question_id": "5a276702dbc498ba5bf11da339a456e1942d54ad_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static const char *contact_id_message(const char *id_who, const char *id_whom, int i) { //\u043d\u0430\u0445\u043e\u0434\u0438\u0442 \u0430\u0439\u0434\u0438 whom\n    int rc = 0;\n    char zSql[]=\"SELECT * FROM messages\";\n    int count = 0;\n    int krugi = -1;\n    do {\n            sqlite3_prepare(db, zSql, -1, &stmt, 0);\n            while(SQLITE_ROW == sqlite3_step(stmt)) {\n                //printf(\"%s\\n\", sqlite3_column_text(stmt,0));\n                if ((strcmp((const char*)sqlite3_column_text(stmt,1), id_who) == 0 ) && (strcmp((const char*)sqlite3_column_text(stmt,2), id_whom) == 0 ))\n                    krugi++;\n                if ((strcmp((const char*)sqlite3_column_text(stmt,1), id_whom) == 0 ) && (strcmp((const char*)sqlite3_column_text(stmt,2), id_who) == 0 ))\n                    krugi++;\n                    if(krugi == i) {\n                        const char *res = mx_strnew(255);\n                        res = (const char*)sqlite3_column_text(stmt,1);\n                        rc = sqlite3_finalize(stmt);\n                        return res;\n                    }\n            }\n                rc = sqlite3_finalize(stmt);\n                }\n    while(rc == SQLITE_SCHEMA); {}\n    return \"-1\";\n"]]}
{"hexsha": "1daad5eb4bc8b24d2cf0187f3b1aa1d653cb9e92", "ext": "c", "lang": "C", "content": "void  USBD_MSC_OS_CommSignalPend (CPU_INT08U   class_nbr,\n                                  CPU_INT32U   timeout,\n                                  USBD_ERR    *p_err)\n{\n    OS_EVENT  *p_comm_sem;\n    INT8U      os_err;\n    INT32U     timeout_ticks;\n\n\n    p_comm_sem    = USBD_MSC_OS_TaskSemTbl[class_nbr];\n    timeout_ticks = ((((INT32U)timeout * OS_TICKS_PER_SEC) + 1000u - 1u) / 1000u);\n\n    OSSemPend(p_comm_sem, timeout_ticks, &os_err);\n\n    switch (os_err) {\n        case OS_ERR_NONE:\n            *p_err = USBD_ERR_NONE;\n             break;\n\n        case OS_ERR_TIMEOUT:\n            *p_err = USBD_ERR_OS_TIMEOUT;\n             break;\n\n        case OS_ERR_PEND_ABORT:\n            *p_err = USBD_ERR_OS_ABORT;\n             break;\n\n        case OS_ERR_EVENT_TYPE:\n        case OS_ERR_PEND_ISR:\n        case OS_ERR_PEVENT_NULL:\n        case OS_ERR_PEND_LOCKED:\n        default:\n            *p_err = USBD_ERR_OS_FAIL;\n             break;\n    }\n}", "item_id": 3, "repo": "fiskbil/uC-USBD", "file": "Class/MSC/OS/uCOS-II/usbd_msc_os.c", "last_update_at": "2020-10-30T05:48:50+00:00", "question_id": "1daad5eb4bc8b24d2cf0187f3b1aa1d653cb9e92_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void  USBD_MSC_OS_CommSignalPend (CPU_INT08U   class_nbr,\n                                  CPU_INT32U   timeout,\n                                  USBD_ERR    *p_err)\n{\n    OS_EVENT  *p_comm_sem;\n    INT8U      os_err;\n    INT32U     timeout_ticks;\n    p_comm_sem    = USBD_MSC_OS_TaskSemTbl[class_nbr];\n    timeout_ticks = ((((INT32U)timeout * OS_TICKS_PER_SEC) + 1000u - 1u) / 1000u);\n    OSSemPend(p_comm_sem, timeout_ticks, &os_err);\n    switch (os_err) {\n        case OS_ERR_NONE:\n            *p_err = USBD_ERR_NONE;\n             break;\n        case OS_ERR_TIMEOUT:\n            *p_err = USBD_ERR_OS_TIMEOUT;\n             break;\n        case OS_ERR_PEND_ABORT:\n            *p_err = USBD_ERR_OS_ABORT;\n             break;\n        case OS_ERR_EVENT_TYPE:\n        case OS_ERR_PEND_ISR:\n        case OS_ERR_PEVENT_NULL:\n        case OS_ERR_PEND_LOCKED:\n        default:\n            *p_err = USBD_ERR_OS_FAIL;\n             break;\n    }\n"]]}
{"hexsha": "41edb30e6795a34c57af305da49e106a2fc93cc6", "ext": "c", "lang": "C", "content": "krb5_error_code\nkrb5_ldap_get_password_policy (context, name, policy, cnt)\n    krb5_context                context;\n    char                        *name;\n    osa_policy_ent_t            *policy;\n    int                         *cnt;\n{\n    krb5_error_code             st = 0;\n    char                        *policy_dn = NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (name == NULL) {\n\tst = EINVAL;\n\tgoto cleanup;\n    }\n\n    st = krb5_ldap_name_to_policydn(context, name, &policy_dn);\n    if (st != 0)\n\tgoto cleanup;\n\n    st = krb5_ldap_get_password_policy_from_dn(context, name, policy_dn, policy, cnt);\n\ncleanup:\n    if (policy_dn != NULL)\n\tfree (policy_dn);\n    return st;\n}", "item_id": 4, "repo": "AsahiOS/gate", "file": "usr/src/lib/krb5/plugins/kdb/ldap/libkdb_ldap/ldap_pwd_policy.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "41edb30e6795a34c57af305da49e106a2fc93cc6_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["krb5_error_code\nkrb5_ldap_get_password_policy (context, name, policy, cnt)\n    krb5_context                context;\n    char                        *name;\n    osa_policy_ent_t            *policy;\n    int                         *cnt;\n{\n    krb5_error_code             st = 0;\n    char                        *policy_dn = NULL;\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n    /* validate the input parameters */\n    if (name == NULL) {\n\tst = EINVAL;\n\tgoto cleanup;\n    }\n    st = krb5_ldap_name_to_policydn(context, name, &policy_dn);\n    if (st != 0)\n\tgoto cleanup;\n    st = krb5_ldap_get_password_policy_from_dn(context, name, policy_dn, policy, cnt);\ncleanup:\n    if (policy_dn != NULL)\n\tfree (policy_dn);\n    return st;\n"]]}
{"hexsha": "ba1422b5691df2ffc6e3e08a01ac0ef02590806c", "ext": "h", "lang": "C", "content": "class Font\n{\nprivate:\n\tunique_ptr<SpriteFont> sprite;\npublic:\n\tstatic Font * Default;\n\n\tFont(unique_ptr<SpriteFont> sprite);\n\tvoid Draw(SpriteBatch * spriteBatch, wstring text, int fontSize, Vector2 position, XMVECTORF32 color);\n\tVector2 Measure(wstring text);\n\tvoid Reset();\n}", "item_id": 0, "repo": "itsmistad/Dodge", "file": "Dodge/Dodge.Engine/Font.h", "last_update_at": "2020-01-24T16:19:07+00:00", "question_id": "ba1422b5691df2ffc6e3e08a01ac0ef02590806c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Font\n{\nprivate:\n\tunique_ptr<SpriteFont> sprite;\npublic:\n\tstatic Font * Default;\n\tFont(unique_ptr<SpriteFont> sprite);\n\tvoid Draw(SpriteBatch * spriteBatch, wstring text, int fontSize, Vector2 position, XMVECTORF32 color);\n\tVector2 Measure(wstring text);\n\tvoid Reset();\n"]]}
{"hexsha": "6cac1996d9610dcbf05bad3532573643a1f2559b", "ext": "c", "lang": "C", "content": "void tm1637_clear(void)\n{\n  uint8_t i;\n\n  tm1637_selectpos(0);\n  for(i=0;i<6;i++) { tm1637_write(0x00); }\n  tm1637_stop();\n\n  tm1637_setbright(hellig);\n\n}", "item_id": 5, "repo": "jjflash65/stm32f030", "file": "src/tm1637.c", "last_update_at": "2020-01-11T20:24:12+00:00", "question_id": "6cac1996d9610dcbf05bad3532573643a1f2559b_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void tm1637_clear(void)\n{\n  uint8_t i;\n  tm1637_selectpos(0);\n  for(i=0;i<6;i++) { tm1637_write(0x00); }\n  tm1637_stop();\n  tm1637_setbright(hellig);\n"]]}
{"hexsha": "53f99301fb6b3c1782bd568d7798c8cdf94db142", "ext": "c", "lang": "C", "content": "ssize_t vsnprintfrr(char *out, size_t outsz, const char *fmt, va_list ap)\n{\n\tstruct fbuf fbb = { .buf = out, .pos = out, .len = outsz - 1, };\n\tstruct fbuf *fb = (out && outsz) ? &fbb : NULL;\n\tssize_t ret;\n\n\tret = vbprintfrr(fb, fmt, ap);\n\tif (fb)\n\t\tfb->pos[0] = '\\0';\n\treturn ret;\n}", "item_id": 1, "repo": "slankdev/netlinkd", "file": "libvui/src/vui/lib/printf/glue.c", "last_update_at": "2020-03-25T01:28:54+00:00", "question_id": "53f99301fb6b3c1782bd568d7798c8cdf94db142_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ssize_t vsnprintfrr(char *out, size_t outsz, const char *fmt, va_list ap)\n{\n\tstruct fbuf fbb = { .buf = out, .pos = out, .len = outsz - 1, };\n\tstruct fbuf *fb = (out && outsz) ? &fbb : NULL;\n\tssize_t ret;\n\tret = vbprintfrr(fb, fmt, ap);\n\tif (fb)\n\t\tfb->pos[0] = '\\0';\n\treturn ret;\n"]]}
{"hexsha": "723cc96c22a5511876188623b3319166030d8749", "ext": "c", "lang": "C", "content": "int\nprom_getprop(pnode_t nodeid, caddr_t name, caddr_t value)\n{\n\tint len, rv;\n\tcell_t ci[8];\n\n\t/*\n\t * This function assumes the buffer is large enough to\n\t * hold the result, so in 1275 mode, we pass in the length\n\t * of the property as the length of the buffer, since we\n\t * have no way of knowing the size of the buffer. Pre-1275\n\t * OpenBoot(tm) PROMs did not have a bounded getprop.\n\t *\n\t * Note that we ignore the \"length\" result of the service.\n\t */\n\n\tif ((len = prom_getproplen(nodeid, name)) <= 0)\n\t\treturn (len);\n\n\tci[0] = p1275_ptr2cell(\"getprop\");\t/* Service name */\n\tci[1] = (cell_t)4;\t\t\t/* #argument cells */\n\tci[2] = (cell_t)0;\t\t\t/* #result cells */\n\tci[3] = p1275_phandle2cell((phandle_t)nodeid);\t/* Arg1: package */\n\tci[4] = p1275_ptr2cell(name);\t\t/* Arg2: property name */\n\tci[5] = p1275_ptr2cell(value);\t\t/* Arg3: buffer address */\n\tci[6] = len;\t\t\t\t/* Arg4: buf len (assumed) */\n\n\tpromif_preprom();\n\trv = p1275_cif_handler(&ci);\n\tpromif_postprom();\n\n\tif (rv != 0)\n\t\treturn (-1);\n\treturn (len);\t\t\t\t/* Return known length */\n}", "item_id": 7, "repo": "AsahiOS/gate", "file": "usr/src/psm/promif/ieee1275/common/prom_prop.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "723cc96c22a5511876188623b3319166030d8749_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nprom_getprop(pnode_t nodeid, caddr_t name, caddr_t value)\n{\n\tint len, rv;\n\tcell_t ci[8];\n\t/*\n\t * This function assumes the buffer is large enough to\n\t * hold the result, so in 1275 mode, we pass in the length\n\t * of the property as the length of the buffer, since we\n\t * have no way of knowing the size of the buffer. Pre-1275\n\t * OpenBoot(tm) PROMs did not have a bounded getprop.\n\t *\n\t * Note that we ignore the \"length\" result of the service.\n\t */\n\tif ((len = prom_getproplen(nodeid, name)) <= 0)\n\t\treturn (len);\n\tci[0] = p1275_ptr2cell(\"getprop\");\t/* Service name */\n\tci[1] = (cell_t)4;\t\t\t/* #argument cells */\n\tci[2] = (cell_t)0;\t\t\t/* #result cells */\n\tci[3] = p1275_phandle2cell((phandle_t)nodeid);\t/* Arg1: package */\n\tci[4] = p1275_ptr2cell(name);\t\t/* Arg2: property name */\n\tci[5] = p1275_ptr2cell(value);\t\t/* Arg3: buffer address */\n\tci[6] = len;\t\t\t\t/* Arg4: buf len (assumed) */\n\tpromif_preprom();\n\trv = p1275_cif_handler(&ci);\n\tpromif_postprom();\n\tif (rv != 0)\n\t\treturn (-1);\n\treturn (len);\t\t\t\t/* Return known length */\n"]]}
{"hexsha": "ba8ff10153bcc656d6e1b1b6da7e9fd4f37720e4", "ext": "c", "lang": "C", "content": "static int intel_i830_remove_entries(struct agp_memory *mem,off_t pg_start,\n\t\t\t\tint type)\n{\n\tint i;\n\n\tglobal_cache_flush();\n\n\tif (pg_start < intel_i830_private.gtt_entries) {\n\t\tprintk (KERN_INFO PFX \"Trying to disable local/stolen memory\\n\");\n\t\treturn (-EINVAL);\n\t}\n\n\tfor (i = pg_start; i < (mem->page_count + pg_start); i++)\n\t\tOUTREG32(intel_i830_private.registers,I810_PTE_BASE + (i * 4),agp_bridge->scratch_page);\n\n\tglobal_cache_flush();\n\n\tagp_bridge->driver->tlb_flush(mem);\n\n\treturn (0);\n}", "item_id": 12, "repo": "dnhua/Linux_study", "file": "linux-2.6.0/drivers/char/agp/intel-agp.c", "last_update_at": "2020-11-10T12:47:02+00:00", "question_id": "ba8ff10153bcc656d6e1b1b6da7e9fd4f37720e4_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int intel_i830_remove_entries(struct agp_memory *mem,off_t pg_start,\n\t\t\t\tint type)\n{\n\tint i;\n\tglobal_cache_flush();\n\tif (pg_start < intel_i830_private.gtt_entries) {\n\t\tprintk (KERN_INFO PFX \"Trying to disable local/stolen memory\\n\");\n\t\treturn (-EINVAL);\n\t}\n\tfor (i = pg_start; i < (mem->page_count + pg_start); i++)\n\t\tOUTREG32(intel_i830_private.registers,I810_PTE_BASE + (i * 4),agp_bridge->scratch_page);\n\tglobal_cache_flush();\n\tagp_bridge->driver->tlb_flush(mem);\n\treturn (0);\n"]]}
{"hexsha": "1afa236a1eea7b8a1e4ddb8fb79703eb1ce05c24", "ext": "c", "lang": "C", "content": "void\nibcm_process_lap_msg(ibcm_hca_info_t *hcap, uint8_t *input_madp,\n    ibcm_mad_addr_t *cm_mad_addr)\n{\n\tibcm_status_t\t\tstate_lookup_status;\n\tibcm_lap_msg_t\t\t*lap_msg = (ibcm_lap_msg_t *)\n\t    (&input_madp[IBCM_MAD_HDR_SIZE]);\n\tibcm_apr_msg_t\t\t*apr_msg;\n\tibcm_state_data_t\t*statep = NULL;\n\n\tIBTF_DPRINTF_L4(cmlog, \"ibcm_process_lap_msg:\");\n\n\trw_enter(&hcap->hca_state_rwlock, RW_READER);\n\n\tstate_lookup_status = ibcm_lookup_msg(IBCM_INCOMING_LAP,\n\t    b2h32(lap_msg->lap_remote_comm_id), 0, 0, hcap, &statep);\n\n\trw_exit(&hcap->hca_state_rwlock);\n\n\tIBTF_DPRINTF_L4(cmlog, \"ibcm_process_lap_msg: lookup status %x\"\n\t    \" com id %x\", state_lookup_status,\n\t    b2h32(lap_msg->lap_remote_comm_id));\n\n\tif (state_lookup_status != IBCM_LOOKUP_EXISTS) {\n\t\t/* Post a REJ message ? - but spec doesn't state so */\n\t\treturn;\n\t}\n\n\t/* There is an existing state structure entry with active comid */\n\n\tibcm_insert_trace(statep, IBCM_TRACE_INCOMING_LAP);\n\n\tmutex_enter(&statep->state_mutex);\n\n\tif ((statep->state == IBCM_STATE_ESTABLISHED) &&\n\t    (statep->ap_state == IBCM_AP_STATE_IDLE) &&\n\t    (statep->mode == IBCM_PASSIVE_MODE)) {\n\t\tif ((statep->lapr_msg) &&\n\t\t    (IBCM_OUT_HDRP(statep->lapr_msg)->TransactionID ==\n\t\t    ((ib_mad_hdr_t *)(input_madp))->TransactionID))\n\t\t\tibcm_post_stored_apr_mad(statep, input_madp);\n\t\telse {\n\t\t\tibcm_status_t\tclnt_response;\n\n\t\t\tstatep->ap_state = IBCM_AP_STATE_LAP_RCVD;\n\t\t\tstatep->clnt_proceed = IBCM_BLOCK;\n\t\t\tmutex_exit(&statep->state_mutex);\n\n\t\t\tif (statep->lapr_msg == NULL) {\n\t\t\t\tif (ibcm_alloc_out_msg(\n\t\t\t\t    statep->stored_reply_addr.ibmf_hdl,\n\t\t\t\t    &statep->lapr_msg, MAD_METHOD_SEND) !=\n\t\t\t\t    IBT_SUCCESS) {\n\n\t\t\t\t\tmutex_enter(&statep->state_mutex);\n\t\t\t\t\tstatep->clnt_proceed = IBCM_FAIL;\n\t\t\t\t\tcv_broadcast(&statep->block_client_cv);\n\t\t\t\t\tIBCM_REF_CNT_DECR(statep);\n\t\t\t\t\tmutex_exit(&statep->state_mutex);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tapr_msg = (ibcm_apr_msg_t *)\n\t\t\t    IBCM_OUT_MSGP(statep->lapr_msg);\n\t\t\tIBCM_OUT_HDRP(statep->lapr_msg)->TransactionID =\n\t\t\t    ((ib_mad_hdr_t *)(input_madp))->TransactionID;\n\t\t\tclnt_response =\n\t\t\t    ibcm_cep_state_lap(statep, lap_msg, apr_msg);\n\t\t\tIBTF_DPRINTF_L4(cmlog, \"ibcm_process_lap_msg:\"\n\t\t\t    \" statep 0x%p  apr status %d\", statep,\n\t\t\t    apr_msg->apr_ap_status);\n\n\t\t\tif (clnt_response == IBCM_DEFER) {\n\t\t\t\tIBTF_DPRINTF_L4(cmlog, \"ibcm_process_lap_msg: \"\n\t\t\t\t    \"client returned DEFER response\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* fail any blocked cm proceed api calls - client bug */\n\t\t\tmutex_enter(&statep->state_mutex);\n\t\t\tstatep->clnt_proceed = IBCM_FAIL;\n\t\t\tcv_broadcast(&statep->block_client_cv);\n\t\t\tmutex_exit(&statep->state_mutex);\n\n\t\t\tibcm_post_apr_mad(statep);\n\t\t\treturn;\n\t\t}\n\t}\t/* drop the LAP MAD in any other state */\n\n\tIBCM_REF_CNT_DECR(statep); /* decrement the ref count */\n\tmutex_exit(&statep->state_mutex);\n}", "item_id": 87, "repo": "AsahiOS/gate", "file": "usr/src/uts/common/io/ib/mgt/ibcm/ibcm_sm.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "1afa236a1eea7b8a1e4ddb8fb79703eb1ce05c24_87", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nibcm_process_lap_msg(ibcm_hca_info_t *hcap, uint8_t *input_madp,\n    ibcm_mad_addr_t *cm_mad_addr)\n{\n\tibcm_status_t\t\tstate_lookup_status;\n\tibcm_lap_msg_t\t\t*lap_msg = (ibcm_lap_msg_t *)\n\t    (&input_madp[IBCM_MAD_HDR_SIZE]);\n\tibcm_apr_msg_t\t\t*apr_msg;\n\tibcm_state_data_t\t*statep = NULL;\n\tIBTF_DPRINTF_L4(cmlog, \"ibcm_process_lap_msg:\");\n\trw_enter(&hcap->hca_state_rwlock, RW_READER);\n\tstate_lookup_status = ibcm_lookup_msg(IBCM_INCOMING_LAP,\n\t    b2h32(lap_msg->lap_remote_comm_id), 0, 0, hcap, &statep);\n\trw_exit(&hcap->hca_state_rwlock);\n\tIBTF_DPRINTF_L4(cmlog, \"ibcm_process_lap_msg: lookup status %x\"\n\t    \" com id %x\", state_lookup_status,\n\t    b2h32(lap_msg->lap_remote_comm_id));\n\tif (state_lookup_status != IBCM_LOOKUP_EXISTS) {\n\t\t/* Post a REJ message ? - but spec doesn't state so */\n\t\treturn;\n\t}\n\t/* There is an existing state structure entry with active comid */\n\tibcm_insert_trace(statep, IBCM_TRACE_INCOMING_LAP);\n\tmutex_enter(&statep->state_mutex);\n\tif ((statep->state == IBCM_STATE_ESTABLISHED) &&\n\t    (statep->ap_state == IBCM_AP_STATE_IDLE) &&\n\t    (statep->mode == IBCM_PASSIVE_MODE)) {\n\t\tif ((statep->lapr_msg) &&\n\t\t    (IBCM_OUT_HDRP(statep->lapr_msg)->TransactionID ==\n\t\t    ((ib_mad_hdr_t *)(input_madp))->TransactionID))\n\t\t\tibcm_post_stored_apr_mad(statep, input_madp);\n\t\telse {\n\t\t\tibcm_status_t\tclnt_response;\n\t\t\tstatep->ap_state = IBCM_AP_STATE_LAP_RCVD;\n\t\t\tstatep->clnt_proceed = IBCM_BLOCK;\n\t\t\tmutex_exit(&statep->state_mutex);\n\t\t\tif (statep->lapr_msg == NULL) {\n\t\t\t\tif (ibcm_alloc_out_msg(\n\t\t\t\t    statep->stored_reply_addr.ibmf_hdl,\n\t\t\t\t    &statep->lapr_msg, MAD_METHOD_SEND) !=\n\t\t\t\t    IBT_SUCCESS) {\n\t\t\t\t\tmutex_enter(&statep->state_mutex);\n\t\t\t\t\tstatep->clnt_proceed = IBCM_FAIL;\n\t\t\t\t\tcv_broadcast(&statep->block_client_cv);\n\t\t\t\t\tIBCM_REF_CNT_DECR(statep);\n\t\t\t\t\tmutex_exit(&statep->state_mutex);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tapr_msg = (ibcm_apr_msg_t *)\n\t\t\t    IBCM_OUT_MSGP(statep->lapr_msg);\n\t\t\tIBCM_OUT_HDRP(statep->lapr_msg)->TransactionID =\n\t\t\t    ((ib_mad_hdr_t *)(input_madp))->TransactionID;\n\t\t\tclnt_response =\n\t\t\t    ibcm_cep_state_lap(statep, lap_msg, apr_msg);\n\t\t\tIBTF_DPRINTF_L4(cmlog, \"ibcm_process_lap_msg:\"\n\t\t\t    \" statep 0x%p  apr status %d\", statep,\n\t\t\t    apr_msg->apr_ap_status);\n\t\t\tif (clnt_response == IBCM_DEFER) {\n\t\t\t\tIBTF_DPRINTF_L4(cmlog, \"ibcm_process_lap_msg: \"\n\t\t\t\t    \"client returned DEFER response\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* fail any blocked cm proceed api calls - client bug */\n\t\t\tmutex_enter(&statep->state_mutex);\n\t\t\tstatep->clnt_proceed = IBCM_FAIL;\n\t\t\tcv_broadcast(&statep->block_client_cv);\n\t\t\tmutex_exit(&statep->state_mutex);\n\t\t\tibcm_post_apr_mad(statep);\n\t\t\treturn;\n\t\t}\n\t}\t/* drop the LAP MAD in any other state */\n\tIBCM_REF_CNT_DECR(statep); /* decrement the ref count */\n\tmutex_exit(&statep->state_mutex);\n"]]}
{"hexsha": "e67d7935622bb4f056d840f586958924ebf9c56c", "ext": "c", "lang": "C", "content": "static enum ndr_err_code ndr_push_svcctl_EnumServicesStatusW(struct ndr_push *ndr, int flags, const struct svcctl_EnumServicesStatusW *r)\n{\n\tif (flags & NDR_IN) {\n\t\tif (r->in.handle == NULL) {\n\t\t\treturn ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, \"NULL [ref] pointer\");\n\t\t}\n\t\tNDR_CHECK(ndr_push_policy_handle(ndr, NDR_SCALARS, r->in.handle));\n\t\tNDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->in.type));\n\t\tNDR_CHECK(ndr_push_svcctl_ServiceState(ndr, NDR_SCALARS, r->in.state));\n\t\tNDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->in.offered));\n\t\tNDR_CHECK(ndr_push_unique_ptr(ndr, r->in.resume_handle));\n\t\tif (r->in.resume_handle) {\n\t\t\tNDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, *r->in.resume_handle));\n\t\t}\n\t}\n\tif (flags & NDR_OUT) {\n\t\tif (r->out.service == NULL) {\n\t\t\treturn ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, \"NULL [ref] pointer\");\n\t\t}\n\t\tNDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, r->in.offered));\n\t\tNDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->out.service, r->in.offered));\n\t\tif (r->out.needed == NULL) {\n\t\t\treturn ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, \"NULL [ref] pointer\");\n\t\t}\n\t\tNDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, *r->out.needed));\n\t\tif (r->out.services_returned == NULL) {\n\t\t\treturn ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, \"NULL [ref] pointer\");\n\t\t}\n\t\tNDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, *r->out.services_returned));\n\t\tNDR_CHECK(ndr_push_unique_ptr(ndr, r->out.resume_handle));\n\t\tif (r->out.resume_handle) {\n\t\t\tNDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, *r->out.resume_handle));\n\t\t}\n\t\tNDR_CHECK(ndr_push_WERROR(ndr, NDR_SCALARS, r->out.result));\n\t}\n\treturn NDR_ERR_SUCCESS;\n}", "item_id": 96, "repo": "afeng11/tomato-arm", "file": "release/src-rt-6.x.4708/router/samba-3.5.8/librpc/gen_ndr/ndr_svcctl.c", "last_update_at": "2020-05-24T07:23:26+00:00", "question_id": "e67d7935622bb4f056d840f586958924ebf9c56c_96", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static enum ndr_err_code ndr_push_svcctl_EnumServicesStatusW(struct ndr_push *ndr, int flags, const struct svcctl_EnumServicesStatusW *r)\n{\n\tif (flags & NDR_IN) {\n\t\tif (r->in.handle == NULL) {\n\t\t\treturn ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, \"NULL [ref] pointer\");\n\t\t}\n\t\tNDR_CHECK(ndr_push_policy_handle(ndr, NDR_SCALARS, r->in.handle));\n\t\tNDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->in.type));\n\t\tNDR_CHECK(ndr_push_svcctl_ServiceState(ndr, NDR_SCALARS, r->in.state));\n\t\tNDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->in.offered));\n\t\tNDR_CHECK(ndr_push_unique_ptr(ndr, r->in.resume_handle));\n\t\tif (r->in.resume_handle) {\n\t\t\tNDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, *r->in.resume_handle));\n\t\t}\n\t}\n\tif (flags & NDR_OUT) {\n\t\tif (r->out.service == NULL) {\n\t\t\treturn ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, \"NULL [ref] pointer\");\n\t\t}\n\t\tNDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, r->in.offered));\n\t\tNDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->out.service, r->in.offered));\n\t\tif (r->out.needed == NULL) {\n\t\t\treturn ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, \"NULL [ref] pointer\");\n\t\t}\n\t\tNDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, *r->out.needed));\n\t\tif (r->out.services_returned == NULL) {\n\t\t\treturn ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, \"NULL [ref] pointer\");\n\t\t}\n\t\tNDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, *r->out.services_returned));\n\t\tNDR_CHECK(ndr_push_unique_ptr(ndr, r->out.resume_handle));\n\t\tif (r->out.resume_handle) {\n\t\t\tNDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, *r->out.resume_handle));\n\t\t}\n\t\tNDR_CHECK(ndr_push_WERROR(ndr, NDR_SCALARS, r->out.result));\n\t}\n\treturn NDR_ERR_SUCCESS;\n"]]}
{"hexsha": "606e798607482e516846828c471b96eba840b47a", "ext": "c", "lang": "C", "content": "int\n_gnutls_server_select_cert(gnutls_session_t session,\n\t\t\t   gnutls_pk_algorithm_t * pk_algos,\n\t\t\t   size_t pk_algos_size)\n{\n\tunsigned i, j;\n\tint idx, ret;\n\tgnutls_certificate_credentials_t cred;\n\tchar server_name[MAX_CN];\n\n\tcred = (gnutls_certificate_credentials_t)\n\t    _gnutls_get_cred(session, GNUTLS_CRD_CERTIFICATE, NULL);\n\tif (cred == NULL) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_INSUFFICIENT_CREDENTIALS;\n\t}\n\n\t/* If the callback which retrieves certificate has been set,\n\t * use it and leave.\n\t */\n\tif (cred->server_get_cert_callback || cred->get_cert_callback\n\t    || cred->get_cert_callback2) {\n\t\tret = call_get_cert_callback(session, NULL, 0, NULL, 0);\n\t\tif (ret < 0)\n\t\t\treturn gnutls_assert_val(ret);\n\t\treturn ret;\n\t}\n\n\t/* Otherwise... */\n\n\tget_server_name(session, (unsigned char *) server_name,\n\t\t\tsizeof(server_name));\n\n\tidx = -1;\t\t/* default is use no certificate */\n\n\t/* find certificates that match the requested server_name\n\t */\n\n\tif (server_name[0] != 0) {\n\t\tfor (i = 0; i < cred->ncerts; i++) {\n\t\t\tif (cred->certs[i].names != NULL\n\t\t\t    && _gnutls_str_array_match(cred->certs[i].\n\t\t\t\t\t\t       names,\n\t\t\t\t\t\t       server_name) != 0) {\n\t\t\t\t/* if requested algorithms are also compatible select it */\n\t\t\t\tgnutls_pk_algorithm pk =\n\t\t\t\t    gnutls_pubkey_get_pk_algorithm(cred->\n\t\t\t\t\t\t\t\t   certs\n\t\t\t\t\t\t\t\t   [i].\n\t\t\t\t\t\t\t\t   cert_list\n\t\t\t\t\t\t\t\t   [0].\n\t\t\t\t\t\t\t\t   pubkey,\n\t\t\t\t\t\t\t\t   NULL);\n\n\t\t\t\t_gnutls_handshake_log\n\t\t\t\t    (\"HSK[%p]: Requested server name: '%s', ctype: %s (%d)\",\n\t\t\t\t     session, server_name,\n\t\t\t\t     gnutls_certificate_type_get_name\n\t\t\t\t     (session->security_parameters.\n\t\t\t\t      cert_type),\n\t\t\t\t     session->security_parameters.\n\t\t\t\t     cert_type);\n\n\t\t\t\tif (session->security_parameters.\n\t\t\t\t    cert_type ==\n\t\t\t\t    cred->certs[i].cert_list[0].type) {\n\t\t\t\t\tfor (j = 0; j < pk_algos_size; j++)\n\t\t\t\t\t\tif (pk_algos[j] == pk) {\n\t\t\t\t\t\t\tidx = i;\n\t\t\t\t\t\t\tgoto finished;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (j = 0; j < pk_algos_size; j++) {\n\t\t_gnutls_handshake_log\n\t\t    (\"HSK[%p]: Requested PK algorithm: %s (%d) -- ctype: %s (%d)\\n\",\n\t\t     session, gnutls_pk_get_name(pk_algos[j]), pk_algos[j],\n\t\t     gnutls_certificate_type_get_name(session->\n\t\t\t\t\t\t      security_parameters.cert_type),\n\t\t     session->security_parameters.cert_type);\n\n\t\tfor (i = 0; i < cred->ncerts; i++) {\n\t\t\tgnutls_pk_algorithm pk =\n\t\t\t    gnutls_pubkey_get_pk_algorithm(cred->certs[i].\n\t\t\t\t\t\t\t   cert_list[0].\n\t\t\t\t\t\t\t   pubkey,\n\t\t\t\t\t\t\t   NULL);\n\t\t\t/* find one compatible certificate\n\t\t\t */\n\t\t\t_gnutls_handshake_log\n\t\t\t    (\"HSK[%p]: certificate[%d] PK algorithm: %s (%d) - ctype: %s (%d)\\n\",\n\t\t\t     session, i, gnutls_pk_get_name(pk), pk,\n\t\t\t     gnutls_certificate_type_get_name(cred->\n\t\t\t\t\t\t\t      certs[i].\n\t\t\t\t\t\t\t      cert_list[0].\n\t\t\t\t\t\t\t      type),\n\t\t\t     cred->certs[i].cert_list[0].type);\n\n\t\t\tif (pk_algos[j] == pk) {\n\t\t\t\t/* if cert type matches\n\t\t\t\t */\n\t  /* *INDENT-OFF* */\n\t  if (session->security_parameters.cert_type == cred->certs[i].cert_list[0].type)\n\t    {\n\t      idx = i;\n\t      goto finished;\n\t    }\n\t  /* *INDENT-ON* */\n\t\t\t}\n\t\t}\n\t}\n\n\t/* store the certificate pointer for future use, in the handshake.\n\t * (This will allow not calling this callback again.)\n\t */\n      finished:\n\tif (idx >= 0) {\n\t\t_gnutls_selected_certs_set(session,\n\t\t\t\t\t   &cred->certs[idx].cert_list[0],\n\t\t\t\t\t   cred->certs[idx].\n\t\t\t\t\t   cert_list_length,\n\t\t\t\t\t   cred->pkey[idx], 0);\n\t} else {\n\t\tgnutls_assert();\n\t\t/* Certificate does not support REQUESTED_ALGO.  */\n\t\treturn GNUTLS_E_INSUFFICIENT_CREDENTIALS;\n\t}\n\n\treturn 0;\n}", "item_id": 27, "repo": "GaloisInc/hacrypto", "file": "src/C/gnutls/gnutls-3.2.12/lib/auth/cert.c", "last_update_at": "2020-11-10T06:45:28+00:00", "question_id": "606e798607482e516846828c471b96eba840b47a_27", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\n_gnutls_server_select_cert(gnutls_session_t session,\n\t\t\t   gnutls_pk_algorithm_t * pk_algos,\n\t\t\t   size_t pk_algos_size)\n{\n\tunsigned i, j;\n\tint idx, ret;\n\tgnutls_certificate_credentials_t cred;\n\tchar server_name[MAX_CN];\n\tcred = (gnutls_certificate_credentials_t)\n\t    _gnutls_get_cred(session, GNUTLS_CRD_CERTIFICATE, NULL);\n\tif (cred == NULL) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_INSUFFICIENT_CREDENTIALS;\n\t}\n\t/* If the callback which retrieves certificate has been set,\n\t * use it and leave.\n\t */\n\tif (cred->server_get_cert_callback || cred->get_cert_callback\n\t    || cred->get_cert_callback2) {\n\t\tret = call_get_cert_callback(session, NULL, 0, NULL, 0);\n\t\tif (ret < 0)\n\t\t\treturn gnutls_assert_val(ret);\n\t\treturn ret;\n\t}\n\t/* Otherwise... */\n\tget_server_name(session, (unsigned char *) server_name,\n\t\t\tsizeof(server_name));\n\tidx = -1;\t\t/* default is use no certificate */\n\t/* find certificates that match the requested server_name\n\t */\n\tif (server_name[0] != 0) {\n\t\tfor (i = 0; i < cred->ncerts; i++) {\n\t\t\tif (cred->certs[i].names != NULL\n\t\t\t    && _gnutls_str_array_match(cred->certs[i].\n\t\t\t\t\t\t       names,\n\t\t\t\t\t\t       server_name) != 0) {\n\t\t\t\t/* if requested algorithms are also compatible select it */\n\t\t\t\tgnutls_pk_algorithm pk =\n\t\t\t\t    gnutls_pubkey_get_pk_algorithm(cred->\n\t\t\t\t\t\t\t\t   certs\n\t\t\t\t\t\t\t\t   [i].\n\t\t\t\t\t\t\t\t   cert_list\n\t\t\t\t\t\t\t\t   [0].\n\t\t\t\t\t\t\t\t   pubkey,\n\t\t\t\t\t\t\t\t   NULL);\n\t\t\t\t_gnutls_handshake_log\n\t\t\t\t    (\"HSK[%p]: Requested server name: '%s', ctype: %s (%d)\",\n\t\t\t\t     session, server_name,\n\t\t\t\t     gnutls_certificate_type_get_name\n\t\t\t\t     (session->security_parameters.\n\t\t\t\t      cert_type),\n\t\t\t\t     session->security_parameters.\n\t\t\t\t     cert_type);\n\t\t\t\tif (session->security_parameters.\n\t\t\t\t    cert_type ==\n\t\t\t\t    cred->certs[i].cert_list[0].type) {\n\t\t\t\t\tfor (j = 0; j < pk_algos_size; j++)\n\t\t\t\t\t\tif (pk_algos[j] == pk) {\n\t\t\t\t\t\t\tidx = i;\n\t\t\t\t\t\t\tgoto finished;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (j = 0; j < pk_algos_size; j++) {\n\t\t_gnutls_handshake_log\n\t\t    (\"HSK[%p]: Requested PK algorithm: %s (%d) -- ctype: %s (%d)\\n\",\n\t\t     session, gnutls_pk_get_name(pk_algos[j]), pk_algos[j],\n\t\t     gnutls_certificate_type_get_name(session->\n\t\t\t\t\t\t      security_parameters.cert_type),\n\t\t     session->security_parameters.cert_type);\n\t\tfor (i = 0; i < cred->ncerts; i++) {\n\t\t\tgnutls_pk_algorithm pk =\n\t\t\t    gnutls_pubkey_get_pk_algorithm(cred->certs[i].\n\t\t\t\t\t\t\t   cert_list[0].\n\t\t\t\t\t\t\t   pubkey,\n\t\t\t\t\t\t\t   NULL);\n\t\t\t/* find one compatible certificate\n\t\t\t */\n\t\t\t_gnutls_handshake_log\n\t\t\t    (\"HSK[%p]: certificate[%d] PK algorithm: %s (%d) - ctype: %s (%d)\\n\",\n\t\t\t     session, i, gnutls_pk_get_name(pk), pk,\n\t\t\t     gnutls_certificate_type_get_name(cred->\n\t\t\t\t\t\t\t      certs[i].\n\t\t\t\t\t\t\t      cert_list[0].\n\t\t\t\t\t\t\t      type),\n\t\t\t     cred->certs[i].cert_list[0].type);\n\t\t\tif (pk_algos[j] == pk) {\n\t\t\t\t/* if cert type matches\n\t\t\t\t */\n\t  /* *INDENT-OFF* */\n\t  if (session->security_parameters.cert_type == cred->certs[i].cert_list[0].type)\n\t    {\n\t      idx = i;\n\t      goto finished;\n\t    }\n\t  /* *INDENT-ON* */\n\t\t\t}\n\t\t}\n\t}\n\t/* store the certificate pointer for future use, in the handshake.\n\t * (This will allow not calling this callback again.)\n\t */\n      finished:\n\tif (idx >= 0) {\n\t\t_gnutls_selected_certs_set(session,\n\t\t\t\t\t   &cred->certs[idx].cert_list[0],\n\t\t\t\t\t   cred->certs[idx].\n\t\t\t\t\t   cert_list_length,\n\t\t\t\t\t   cred->pkey[idx], 0);\n\t} else {\n\t\tgnutls_assert();\n\t\t/* Certificate does not support REQUESTED_ALGO.  */\n\t\treturn GNUTLS_E_INSUFFICIENT_CREDENTIALS;\n\t}\n\treturn 0;\n"]]}
{"hexsha": "34c13a14e3fccfcddb037c0a96cc0b03cbdb9ca4", "ext": "c", "lang": "C", "content": "rbool_t smIPT_isC3(const RKH_SM_T* sma, RKH_EVT_T* pe)\n{\n  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;\n  CMOCK_smIPT_isC3_CALL_INSTANCE* cmock_call_instance;\n  UNITY_SET_DETAIL(CMockString_smIPT_isC3);\n  cmock_call_instance = (CMOCK_smIPT_isC3_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.smIPT_isC3_CallInstance);\n  Mock.smIPT_isC3_CallInstance = CMock_Guts_MemNext(Mock.smIPT_isC3_CallInstance);\n  if (Mock.smIPT_isC3_IgnoreBool)\n  {\n    UNITY_CLR_DETAILS();\n    if (cmock_call_instance == NULL)\n      return Mock.smIPT_isC3_FinalReturn;\n    memcpy(&Mock.smIPT_isC3_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(rbool_t));\n    return cmock_call_instance->ReturnVal;\n  }\n  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);\n  cmock_line = cmock_call_instance->LineNumber;\n  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)\n    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);\n  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)\n    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);\n  if (!cmock_call_instance->IgnoreArg_sma)\n  {\n    UNITY_SET_DETAILS(CMockString_smIPT_isC3,CMockString_sma);\n    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_sma, sma, cmock_line, CMockStringMismatch);\n  }\n  if (!cmock_call_instance->IgnoreArg_pe)\n  {\n    UNITY_SET_DETAILS(CMockString_smIPT_isC3,CMockString_pe);\n    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pe, pe, cmock_line, CMockStringMismatch);\n  }\n  if (Mock.smIPT_isC3_CallbackFunctionPointer != NULL)\n  {\n    cmock_call_instance->ReturnVal = Mock.smIPT_isC3_CallbackFunctionPointer(sma, pe, Mock.smIPT_isC3_CallbackCalls++);\n  }\n  UNITY_CLR_DETAILS();\n  return cmock_call_instance->ReturnVal;\n}", "item_id": 238, "repo": "sporaio/spora-firmware", "file": "third-party/rkh/source/sm/test/stub/mocks/Mock_smInitialPseudoTestAct.c", "last_update_at": "2020-08-13T13:28:28+00:00", "question_id": "34c13a14e3fccfcddb037c0a96cc0b03cbdb9ca4_238", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["rbool_t smIPT_isC3(const RKH_SM_T* sma, RKH_EVT_T* pe)\n{\n  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;\n  CMOCK_smIPT_isC3_CALL_INSTANCE* cmock_call_instance;\n  UNITY_SET_DETAIL(CMockString_smIPT_isC3);\n  cmock_call_instance = (CMOCK_smIPT_isC3_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.smIPT_isC3_CallInstance);\n  Mock.smIPT_isC3_CallInstance = CMock_Guts_MemNext(Mock.smIPT_isC3_CallInstance);\n  if (Mock.smIPT_isC3_IgnoreBool)\n  {\n    UNITY_CLR_DETAILS();\n    if (cmock_call_instance == NULL)\n      return Mock.smIPT_isC3_FinalReturn;\n    memcpy(&Mock.smIPT_isC3_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(rbool_t));\n    return cmock_call_instance->ReturnVal;\n  }\n  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);\n  cmock_line = cmock_call_instance->LineNumber;\n  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)\n    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);\n  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)\n    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);\n  if (!cmock_call_instance->IgnoreArg_sma)\n  {\n    UNITY_SET_DETAILS(CMockString_smIPT_isC3,CMockString_sma);\n    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_sma, sma, cmock_line, CMockStringMismatch);\n  }\n  if (!cmock_call_instance->IgnoreArg_pe)\n  {\n    UNITY_SET_DETAILS(CMockString_smIPT_isC3,CMockString_pe);\n    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pe, pe, cmock_line, CMockStringMismatch);\n  }\n  if (Mock.smIPT_isC3_CallbackFunctionPointer != NULL)\n  {\n    cmock_call_instance->ReturnVal = Mock.smIPT_isC3_CallbackFunctionPointer(sma, pe, Mock.smIPT_isC3_CallbackCalls++);\n  }\n  UNITY_CLR_DETAILS();\n  return cmock_call_instance->ReturnVal;\n"]]}
{"hexsha": "d6107820335031b869e333596a4c0c62f6c4a7d0", "ext": "c", "lang": "C", "content": "void *DumbTest(void *vp)\n{\n   cpuset_t mycpuset;\n   CPU_ZERO(&mycpuset);         /* no manpage, so guess works like linux */\n   CPU_SET(bindID, &mycpuset);\n   assert(!cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_TID, -1,\n                              sizeof(mycpuset), &mycpuset));\n   pthread_exit(vp);\n}", "item_id": 0, "repo": "kevleyski/math-atlas", "file": "CONFIG/src/backend/probe_aff_CPUSET.c", "last_update_at": "2020-12-17T06:12:32+00:00", "question_id": "d6107820335031b869e333596a4c0c62f6c4a7d0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void *DumbTest(void *vp)\n{\n   cpuset_t mycpuset;\n   CPU_ZERO(&mycpuset);         /* no manpage, so guess works like linux */\n   CPU_SET(bindID, &mycpuset);\n   assert(!cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_TID, -1,\n                              sizeof(mycpuset), &mycpuset));\n   pthread_exit(vp);\n"]]}
{"hexsha": "0d902b985e1acb35b80e407ea269674d2f3a39ba", "ext": "c", "lang": "C", "content": "NPY_NO_EXPORT int\nPyUCS2Buffer_AsUCS4(Py_UNICODE *ucs2, npy_ucs4 *ucs4, int ucs2len, int ucs4len)\n{\n    int i;\n    npy_ucs4 chr;\n    Py_UNICODE ch;\n    int numchars=0;\n\n    for (i = 0; (i < ucs2len) && (numchars < ucs4len); i++) {\n        ch = *ucs2++;\n        if (ch >= 0xd800 && ch <= 0xdfff) {\n            /* surrogate pair */\n            chr = ((npy_ucs4)(ch-0xd800)) << 10;\n            chr += *ucs2++ + 0x2400;  /* -0xdc00 + 0x10000 */\n            i++;\n        }\n        else {\n            chr = (npy_ucs4) ch;\n        }\n        *ucs4++ = chr;\n        numchars++;\n    }\n    return numchars;\n}", "item_id": 1, "repo": "IntelLabs/numpy", "file": "numpy/core/src/common/ucsnarrow.c", "last_update_at": "2020-09-27T04:37:44+00:00", "question_id": "0d902b985e1acb35b80e407ea269674d2f3a39ba_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["NPY_NO_EXPORT int\nPyUCS2Buffer_AsUCS4(Py_UNICODE *ucs2, npy_ucs4 *ucs4, int ucs2len, int ucs4len)\n{\n    int i;\n    npy_ucs4 chr;\n    Py_UNICODE ch;\n    int numchars=0;\n    for (i = 0; (i < ucs2len) && (numchars < ucs4len); i++) {\n        ch = *ucs2++;\n        if (ch >= 0xd800 && ch <= 0xdfff) {\n            /* surrogate pair */\n            chr = ((npy_ucs4)(ch-0xd800)) << 10;\n            chr += *ucs2++ + 0x2400;  /* -0xdc00 + 0x10000 */\n            i++;\n        }\n        else {\n            chr = (npy_ucs4) ch;\n        }\n        *ucs4++ = chr;\n        numchars++;\n    }\n    return numchars;\n"]]}
{"hexsha": "d938df5dc082df131cc884b27858250c65d25c91", "ext": "h", "lang": "C", "content": "class VtkImageFlipWrap : public VtkImageResliceWrap\n{\n\tpublic:\n\t\tusing Nan::ObjectWrap::Wrap;\n\t\tstatic void Init(v8::Local<v8::Object> exports);\n\t\tstatic void InitPtpl();\n\t\tstatic void ConstructorGetter(\n\t\t\tv8::Local<v8::String> property,\n\t\t\tconst Nan::PropertyCallbackInfo<v8::Value>& info);\n\n\t\tVtkImageFlipWrap(vtkSmartPointer<vtkImageFlip>);\n\t\tVtkImageFlipWrap();\n\t\t~VtkImageFlipWrap( );\n\t\tstatic Nan::Persistent<v8::FunctionTemplate> ptpl;\n\n\tprivate:\n\t\tstatic void New(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\n\t\tstatic void FlipAboutOriginOff(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void FlipAboutOriginOn(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void GetFilteredAxes(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void GetFilteredAxis(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void GetFlipAboutOrigin(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void GetPreserveImageExtent(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void PreserveImageExtentOff(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void PreserveImageExtentOn(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void SetFilteredAxes(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void SetFilteredAxis(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void SetFlipAboutOrigin(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void SetPreserveImageExtent(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\n#ifdef VTK_NODE_PLUS_VTKIMAGEFLIPWRAP_CLASSDEF\n\t\tVTK_NODE_PLUS_VTKIMAGEFLIPWRAP_CLASSDEF\n#endif\n}", "item_id": 0, "repo": "axkibe/node-vtk", "file": "wrappers/8.1.1/vtkImageFlipWrap.h", "last_update_at": "2020-09-16T15:07:51+00:00", "question_id": "d938df5dc082df131cc884b27858250c65d25c91_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class VtkImageFlipWrap : public VtkImageResliceWrap\n{\n\tpublic:\n\t\tusing Nan::ObjectWrap::Wrap;\n\t\tstatic void Init(v8::Local<v8::Object> exports);\n\t\tstatic void InitPtpl();\n\t\tstatic void ConstructorGetter(\n\t\t\tv8::Local<v8::String> property,\n\t\t\tconst Nan::PropertyCallbackInfo<v8::Value>& info);\n\t\tVtkImageFlipWrap(vtkSmartPointer<vtkImageFlip>);\n\t\tVtkImageFlipWrap();\n\t\t~VtkImageFlipWrap( );\n\t\tstatic Nan::Persistent<v8::FunctionTemplate> ptpl;\n\tprivate:\n\t\tstatic void New(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void FlipAboutOriginOff(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void FlipAboutOriginOn(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void GetFilteredAxes(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void GetFilteredAxis(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void GetFlipAboutOrigin(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void GetPreserveImageExtent(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void PreserveImageExtentOff(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void PreserveImageExtentOn(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void SetFilteredAxes(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void SetFilteredAxis(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void SetFlipAboutOrigin(const Nan::FunctionCallbackInfo<v8::Value>& info);\n\t\tstatic void SetPreserveImageExtent(const Nan::FunctionCallbackInfo<v8::Value>& info);\n#ifdef VTK_NODE_PLUS_VTKIMAGEFLIPWRAP_CLASSDEF\n\t\tVTK_NODE_PLUS_VTKIMAGEFLIPWRAP_CLASSDEF\n#endif\n"]]}
{"hexsha": "553d6803860fb5fdbcbc0abe87443fdf8d99feaa", "ext": "c", "lang": "C", "content": "gboolean dvb_reader_get_current_pmt_packets(DVBReader *reader, guint8 **buffer, gsize *length)\n{\n    FLOG(\"\\n\");\n    g_return_val_if_fail(reader != NULL, FALSE);\n\n    if (reader->pmt_packet_count == 0)\n        return FALSE;\n\n    if (buffer) {\n        *buffer = g_malloc(reader->pmt_packet_count * TS_SIZE);\n        memcpy(*buffer, reader->pmt_data, reader->pmt_packet_count * TS_SIZE);\n    }\n    if (length)\n        *length = (gsize)(reader->pmt_packet_count * TS_SIZE);\n\n    return TRUE;\n}", "item_id": 48, "repo": "lahol/libdvbrecorder", "file": "dvbreader.c", "last_update_at": "2020-07-29T10:20:37+00:00", "question_id": "553d6803860fb5fdbcbc0abe87443fdf8d99feaa_48", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["gboolean dvb_reader_get_current_pmt_packets(DVBReader *reader, guint8 **buffer, gsize *length)\n{\n    FLOG(\"\\n\");\n    g_return_val_if_fail(reader != NULL, FALSE);\n    if (reader->pmt_packet_count == 0)\n        return FALSE;\n    if (buffer) {\n        *buffer = g_malloc(reader->pmt_packet_count * TS_SIZE);\n        memcpy(*buffer, reader->pmt_data, reader->pmt_packet_count * TS_SIZE);\n    }\n    if (length)\n        *length = (gsize)(reader->pmt_packet_count * TS_SIZE);\n    return TRUE;\n"]]}
{"hexsha": "2aa84529daa413c2344df0004d8d515385a80494", "ext": "c", "lang": "C", "content": "int func_162(int iParam0)\n{\n\tint iVar0;\n\t\n\tiVar0 = (iParam0 - Local_388[0 /*8*/]);\n\tif (iVar0 >= 0 && iVar0 < Local_388)\n\t{\n\t\tif (Local_388[iVar0 /*8*/] == iParam0)\n\t\t{\n\t\t\tif (!Local_388[iVar0 /*8*/].f_2)\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse if (Local_388[iVar0 /*8*/] != 0)\n\t\t{\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "item_id": 84, "repo": "Seanghost117/GTA-V-Decompiled-Scripts", "file": "decompiled_scripts/chinese2.c", "last_update_at": "2020-12-16T17:13:14+00:00", "question_id": "2aa84529daa413c2344df0004d8d515385a80494_84", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int func_162(int iParam0)\n{\n\tint iVar0;\n\t\n\tiVar0 = (iParam0 - Local_388[0 /*8*/]);\n\tif (iVar0 >= 0 && iVar0 < Local_388)\n\t{\n\t\tif (Local_388[iVar0 /*8*/] == iParam0)\n\t\t{\n\t\t\tif (!Local_388[iVar0 /*8*/].f_2)\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse if (Local_388[iVar0 /*8*/] != 0)\n\t\t{\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn 1;\n\t}\n\treturn 0;\n"]]}
{"hexsha": "7403d537586849fbd6e35d78027d21e9e791944c", "ext": "c", "lang": "C", "content": "static int r_viewport_height_index_xl(lua_State *L)\n{\n    R_Viewport *self = R_CPPCAST(R_Viewport *, XL_checkutype(L, 1, \"R_Viewport\"));\n    int RETVAL;\n    RETVAL = self->h;\n    XL_pushint(L, RETVAL);\n    return 1;\n}", "item_id": 11, "repo": "askmeaboutlo0m/rouse", "file": "rouse-lua/lib/rouse/lua/viewport.c", "last_update_at": "2020-01-04T11:42:22+00:00", "question_id": "7403d537586849fbd6e35d78027d21e9e791944c_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int r_viewport_height_index_xl(lua_State *L)\n{\n    R_Viewport *self = R_CPPCAST(R_Viewport *, XL_checkutype(L, 1, \"R_Viewport\"));\n    int RETVAL;\n    RETVAL = self->h;\n    XL_pushint(L, RETVAL);\n    return 1;\n"]]}
{"hexsha": "d5b4bbe878551602dda1d80746b70529175cb6ca", "ext": "c", "lang": "C", "content": "int kf7_get_subrec(\n   struct fcb *f, \n   level0_pntr *p,      // IN - the original pointer from get_ptr\n   int offset,                 // IN - offset of data to get within the rec \n   int bytes_to_read,          // IN - how many bytes of the rec to get\n   unsigned char *rec,         // IN-OUT - where to put the bytes from the rec\n   int *bytes_actually_read,   // OUT - how many bytes were actually transferred\n   int max_lc)                 // IN - max bytes to transfer\n{size_t size; FILE *file;\n\n  if ( check_fcb(f) ) {\n    *bytes_actually_read = bytes_to_read;\n    if ( *bytes_actually_read>max_lc ) {\n      f->error_code = longrec_err; *bytes_actually_read = max_lc;\n    }\n    if ( p->lc<=f->data_in_index_lc ) {\n      if ( (unsigned)offset+bytes_to_read>=f->data_in_index_lc ) {\n        f->error_code = longrec_err; *bytes_actually_read = f->data_in_index_lc - offset - 1;\n      }\n      memcpy(rec,(unsigned char *)(&p->data_rec)+offset,(size_t) *bytes_actually_read);\n    }\n    else {\n      file = file_index(f,p->segment);\n      if ( f->error_code!=no_err ) return(f->error_code);\n      if ( fseeko(file,(FILE_OFFSET)p->sc+offset,0)!=0 ) {\n        f->error_code = seek_err; return(f->error_code);\n      }\n      size = fread(rec,(size_t) 1,(size_t) *bytes_actually_read,file);\n      if ( size!=(size_t)*bytes_actually_read ) f->error_code = read_err;\n    }\n  }\n  return(f->error_code);\n}", "item_id": 153, "repo": "whuang022nccu/IndriLab", "file": "contrib/lemur/src/keyfilecode.c", "last_update_at": "2020-11-23T06:50:19+00:00", "question_id": "d5b4bbe878551602dda1d80746b70529175cb6ca_153", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int kf7_get_subrec(\n   struct fcb *f, \n   level0_pntr *p,      // IN - the original pointer from get_ptr\n   int offset,                 // IN - offset of data to get within the rec \n   int bytes_to_read,          // IN - how many bytes of the rec to get\n   unsigned char *rec,         // IN-OUT - where to put the bytes from the rec\n   int *bytes_actually_read,   // OUT - how many bytes were actually transferred\n   int max_lc)                 // IN - max bytes to transfer\n{size_t size; FILE *file;\n  if ( check_fcb(f) ) {\n    *bytes_actually_read = bytes_to_read;\n    if ( *bytes_actually_read>max_lc ) {\n      f->error_code = longrec_err; *bytes_actually_read = max_lc;\n    }\n    if ( p->lc<=f->data_in_index_lc ) {\n      if ( (unsigned)offset+bytes_to_read>=f->data_in_index_lc ) {\n        f->error_code = longrec_err; *bytes_actually_read = f->data_in_index_lc - offset - 1;\n      }\n      memcpy(rec,(unsigned char *)(&p->data_rec)+offset,(size_t) *bytes_actually_read);\n    }\n    else {\n      file = file_index(f,p->segment);\n      if ( f->error_code!=no_err ) return(f->error_code);\n      if ( fseeko(file,(FILE_OFFSET)p->sc+offset,0)!=0 ) {\n        f->error_code = seek_err; return(f->error_code);\n      }\n      size = fread(rec,(size_t) 1,(size_t) *bytes_actually_read,file);\n      if ( size!=(size_t)*bytes_actually_read ) f->error_code = read_err;\n    }\n  }\n  return(f->error_code);\n"]]}
{"hexsha": "a9b0bed4243ebff3273db5c2abe804fd10fb9344", "ext": "c", "lang": "C", "content": "TkTextIndex *\nTkTextMakeCharIndex(\n    TkTextBTree tree,\t\t/* Tree that lineIndex and charIndex refer\n\t\t\t\t * to. */\n    TkText *textPtr,\n    int lineIndex,\t\t/* Index of desired line (0 means first line\n\t\t\t\t * of text). */\n    int charIndex,\t\t/* Index of desired character. */\n    TkTextIndex *indexPtr)\t/* Structure to fill in. */\n{\n    register TkTextSegment *segPtr;\n    char *p, *start, *end;\n    int index, offset;\n    Tcl_UniChar ch;\n\n    indexPtr->tree = tree;\n    if (lineIndex < 0) {\n\tlineIndex = 0;\n\tcharIndex = 0;\n    }\n    if (charIndex < 0) {\n\tcharIndex = 0;\n    }\n    indexPtr->linePtr = TkBTreeFindLine(tree, textPtr, lineIndex);\n    if (indexPtr->linePtr == NULL) {\n\tindexPtr->linePtr = TkBTreeFindLine(tree, textPtr,\n\t\tTkBTreeNumLines(tree, textPtr));\n\tcharIndex = 0;\n    }\n\n    /*\n     * Verify that the index is within the range of the line. If not, just use\n     * the index of the last character in the line.\n     */\n\n    index = 0;\n    for (segPtr = indexPtr->linePtr->segPtr; ; segPtr = segPtr->nextPtr) {\n\tif (segPtr == NULL) {\n\t    /*\n\t     * Use the index of the last character in the line. Since the last\n\t     * character on the line is guaranteed to be a '\\n', we can back\n\t     * up a constant sizeof(char) bytes.\n\t     */\n\n\t    indexPtr->byteIndex = index - sizeof(char);\n\t    break;\n\t}\n\tif (segPtr->typePtr == &tkTextCharType) {\n\t    /*\n\t     * Turn character offset into a byte offset.\n\t     */\n\n\t    start = segPtr->body.chars;\n\t    end = start + segPtr->size;\n\t    for (p = start; p < end; p += offset) {\n\t\tif (charIndex == 0) {\n\t\t    indexPtr->byteIndex = index;\n\t\t    return indexPtr;\n\t\t}\n\t\tcharIndex--;\n\t\toffset = Tcl_UtfToUniChar(p, &ch);\n\t\tindex += offset;\n\t    }\n\t} else {\n\t    if (charIndex < segPtr->size) {\n\t\tindexPtr->byteIndex = index;\n\t\tbreak;\n\t    }\n\t    charIndex -= segPtr->size;\n\t    index += segPtr->size;\n\t}\n    }\n    return indexPtr;\n}", "item_id": 8, "repo": "nitishk017/ns2project", "file": "ns-allinone-2.35/tk8.5.10/generic/tkTextIndex.c", "last_update_at": "2020-05-29T13:04:42+00:00", "question_id": "a9b0bed4243ebff3273db5c2abe804fd10fb9344_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TkTextIndex *\nTkTextMakeCharIndex(\n    TkTextBTree tree,\t\t/* Tree that lineIndex and charIndex refer\n\t\t\t\t * to. */\n    TkText *textPtr,\n    int lineIndex,\t\t/* Index of desired line (0 means first line\n\t\t\t\t * of text). */\n    int charIndex,\t\t/* Index of desired character. */\n    TkTextIndex *indexPtr)\t/* Structure to fill in. */\n{\n    register TkTextSegment *segPtr;\n    char *p, *start, *end;\n    int index, offset;\n    Tcl_UniChar ch;\n    indexPtr->tree = tree;\n    if (lineIndex < 0) {\n\tlineIndex = 0;\n\tcharIndex = 0;\n    }\n    if (charIndex < 0) {\n\tcharIndex = 0;\n    }\n    indexPtr->linePtr = TkBTreeFindLine(tree, textPtr, lineIndex);\n    if (indexPtr->linePtr == NULL) {\n\tindexPtr->linePtr = TkBTreeFindLine(tree, textPtr,\n\t\tTkBTreeNumLines(tree, textPtr));\n\tcharIndex = 0;\n    }\n    /*\n     * Verify that the index is within the range of the line. If not, just use\n     * the index of the last character in the line.\n     */\n    index = 0;\n    for (segPtr = indexPtr->linePtr->segPtr; ; segPtr = segPtr->nextPtr) {\n\tif (segPtr == NULL) {\n\t    /*\n\t     * Use the index of the last character in the line. Since the last\n\t     * character on the line is guaranteed to be a '\\n', we can back\n\t     * up a constant sizeof(char) bytes.\n\t     */\n\t    indexPtr->byteIndex = index - sizeof(char);\n\t    break;\n\t}\n\tif (segPtr->typePtr == &tkTextCharType) {\n\t    /*\n\t     * Turn character offset into a byte offset.\n\t     */\n\t    start = segPtr->body.chars;\n\t    end = start + segPtr->size;\n\t    for (p = start; p < end; p += offset) {\n\t\tif (charIndex == 0) {\n\t\t    indexPtr->byteIndex = index;\n\t\t    return indexPtr;\n\t\t}\n\t\tcharIndex--;\n\t\toffset = Tcl_UtfToUniChar(p, &ch);\n\t\tindex += offset;\n\t    }\n\t} else {\n\t    if (charIndex < segPtr->size) {\n\t\tindexPtr->byteIndex = index;\n\t\tbreak;\n\t    }\n\t    charIndex -= segPtr->size;\n\t    index += segPtr->size;\n\t}\n    }\n    return indexPtr;\n"]]}
{"hexsha": "ecc7955975e4d983d2a95680e3c3f2608dc5a855", "ext": "c", "lang": "C", "content": "int\ngsfSeek(int handle, int option)\n{\n    /* JSB 04/05/00 replaced \">=\" with \">\" */\n    if ((handle < 1) || (handle > GSF_MAX_OPEN_FILES))\n    {\n        gsfError = GSF_BAD_FILE_HANDLE;\n        return (-1);\n    }\n\n    switch (option)\n    {\n        case GSF_REWIND:\n            /* If the last operation was a write then we need to fflush */\n            if (gsfFileTable[handle - 1].read_write_flag == LAST_OP_WRITE)\n            {\n                if (fflush (gsfFileTable[handle - 1].fp))\n                {\n                    gsfError = GSF_FLUSH_ERROR;\n                    return(-1);\n                }\n            }\n            gsfFileTable[handle - 1].read_write_flag = LAST_OP_FLUSH;\n\n            if (fseek(gsfFileTable[handle - 1].fp, 0, SEEK_SET))\n            {\n                gsfError = GSF_FILE_SEEK_ERROR;\n                return (-1);\n            }\n            break;\n\n        case GSF_END_OF_FILE:\n            /* If the last operation was a write then we need to fflush */\n            if (gsfFileTable[handle - 1].read_write_flag == LAST_OP_WRITE)\n            {\n                if (fflush (gsfFileTable[handle - 1].fp))\n                {\n                    gsfError = GSF_FLUSH_ERROR;\n                    return(-1);\n                }\n            }\n            gsfFileTable[handle - 1].read_write_flag = LAST_OP_FLUSH;\n\n            if (fseek(gsfFileTable[handle - 1].fp, 0, SEEK_END))\n            {\n                gsfError = GSF_FILE_SEEK_ERROR;\n                return (-1);\n            }\n            break;\n\n        case GSF_PREVIOUS_RECORD:\n            if (fseek(gsfFileTable[handle - 1].fp, gsfFileTable[handle - 1].previous_record, SEEK_SET))\n            {\n                gsfError = GSF_FILE_SEEK_ERROR;\n                return (-1);\n            }\n            break;\n\n        default:\n            gsfError = GSF_BAD_SEEK_OPTION;\n            return (-1);\n    }\n\n    return (0);\n}", "item_id": 3, "repo": "ausseabed/pygsf", "file": "gsf_v0304/gsf.c", "last_update_at": "2020-03-12T08:23:14+00:00", "question_id": "ecc7955975e4d983d2a95680e3c3f2608dc5a855_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\ngsfSeek(int handle, int option)\n{\n    /* JSB 04/05/00 replaced \">=\" with \">\" */\n    if ((handle < 1) || (handle > GSF_MAX_OPEN_FILES))\n    {\n        gsfError = GSF_BAD_FILE_HANDLE;\n        return (-1);\n    }\n    switch (option)\n    {\n        case GSF_REWIND:\n            /* If the last operation was a write then we need to fflush */\n            if (gsfFileTable[handle - 1].read_write_flag == LAST_OP_WRITE)\n            {\n                if (fflush (gsfFileTable[handle - 1].fp))\n                {\n                    gsfError = GSF_FLUSH_ERROR;\n                    return(-1);\n                }\n            }\n            gsfFileTable[handle - 1].read_write_flag = LAST_OP_FLUSH;\n            if (fseek(gsfFileTable[handle - 1].fp, 0, SEEK_SET))\n            {\n                gsfError = GSF_FILE_SEEK_ERROR;\n                return (-1);\n            }\n            break;\n        case GSF_END_OF_FILE:\n            /* If the last operation was a write then we need to fflush */\n            if (gsfFileTable[handle - 1].read_write_flag == LAST_OP_WRITE)\n            {\n                if (fflush (gsfFileTable[handle - 1].fp))\n                {\n                    gsfError = GSF_FLUSH_ERROR;\n                    return(-1);\n                }\n            }\n            gsfFileTable[handle - 1].read_write_flag = LAST_OP_FLUSH;\n            if (fseek(gsfFileTable[handle - 1].fp, 0, SEEK_END))\n            {\n                gsfError = GSF_FILE_SEEK_ERROR;\n                return (-1);\n            }\n            break;\n        case GSF_PREVIOUS_RECORD:\n            if (fseek(gsfFileTable[handle - 1].fp, gsfFileTable[handle - 1].previous_record, SEEK_SET))\n            {\n                gsfError = GSF_FILE_SEEK_ERROR;\n                return (-1);\n            }\n            break;\n        default:\n            gsfError = GSF_BAD_SEEK_OPTION;\n            return (-1);\n    }\n    return (0);\n"]]}
{"hexsha": "436edbc9e8797ccd98315375d7ed9d4ce3602f83", "ext": "c", "lang": "C", "content": "int handle_packet_anonymous(net_connection_t *net_connection, uint32_t packet_id, void *message_object)\n{\n  assert(net_connection != NULL);\n  assert(message_object != NULL);\n  switch (packet_id)\n  {\n    case PKT_TYPE_CONNECT_REQ:\n      {\n        connection_req_t *message = (connection_req_t*)message_object;\n        net_connection->host_port = message->host_port;\n        net_connection->anonymous = 0;\n\n        struct mg_connection *connection = net_connection->connection;\n        assert(connection != NULL);\n\n        uint32_t remote_ip = ntohl(*(uint32_t*)&connection->sa.sin.sin_addr);\n        uint64_t peer_id = concatenate(remote_ip, message->host_port);\n        if (has_peer(peer_id))\n        {\n          LOG_DEBUG(\"Cannot add an already existant peer with id: %u!\", peer_id);\n          return 1;\n        }\n\n        if (g_protocol_force_version_check)\n        {\n          if (memcmp(message->version_number, APPLICATION_VERSION, strlen(APPLICATION_VERSION)) != 0)\n          {\n            LOG_DEBUG(\"Failed to verify version number: [%s] expected: [%s], for peer with id: [%\" PRIu64 \"]!\\n\", message->version_number, APPLICATION_VERSION, peer_id);\n            return 1;\n          }\n\n          if (memcmp(message->version_name, APPLICATION_RELEASE_NAME, strlen(APPLICATION_RELEASE_NAME)) != 0)\n          {\n            LOG_DEBUG(\"Failed to verify version name: [%s] expected: [%s], for peer with id: [%\" PRIu64 \"]!\\n\", message->version_name, APPLICATION_RELEASE_NAME, peer_id);\n            return 1;\n          }\n        }\n\n        // check to see if the peer is connected to the right network,\n        // that's appropriate to what mode they are running in...\n        if (message->use_testnet != parameters_get_use_testnet())\n        {\n          return 1;\n        }\n\n        peer_t *peer = init_peer(peer_id, net_connection);\n        assert(add_peer(peer) == 0);\n\n        if (handle_packet_sendto(net_connection, PKT_TYPE_CONNECT_RESP))\n        {\n          free_peer(peer);\n          return 1;\n        }\n\n        return 0;\n      }\n      break;\n    case PKT_TYPE_CONNECT_RESP:\n      {\n        connection_resp_t *message = (connection_resp_t*)message_object;\n        net_connection->anonymous = 0;\n        return 0;\n      }\n      break;\n    default:\n      assert(close_net_connection(net_connection) == 0);\n      return 1;\n  }\n\n  return 1;\n}", "item_id": 20, "repo": "vulkancurrency/vulkan", "file": "src/core/protocol.c", "last_update_at": "2020-08-16T23:16:47+00:00", "question_id": "436edbc9e8797ccd98315375d7ed9d4ce3602f83_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int handle_packet_anonymous(net_connection_t *net_connection, uint32_t packet_id, void *message_object)\n{\n  assert(net_connection != NULL);\n  assert(message_object != NULL);\n  switch (packet_id)\n  {\n    case PKT_TYPE_CONNECT_REQ:\n      {\n        connection_req_t *message = (connection_req_t*)message_object;\n        net_connection->host_port = message->host_port;\n        net_connection->anonymous = 0;\n        struct mg_connection *connection = net_connection->connection;\n        assert(connection != NULL);\n        uint32_t remote_ip = ntohl(*(uint32_t*)&connection->sa.sin.sin_addr);\n        uint64_t peer_id = concatenate(remote_ip, message->host_port);\n        if (has_peer(peer_id))\n        {\n          LOG_DEBUG(\"Cannot add an already existant peer with id: %u!\", peer_id);\n          return 1;\n        }\n        if (g_protocol_force_version_check)\n        {\n          if (memcmp(message->version_number, APPLICATION_VERSION, strlen(APPLICATION_VERSION)) != 0)\n          {\n            LOG_DEBUG(\"Failed to verify version number: [%s] expected: [%s], for peer with id: [%\" PRIu64 \"]!\\n\", message->version_number, APPLICATION_VERSION, peer_id);\n            return 1;\n          }\n          if (memcmp(message->version_name, APPLICATION_RELEASE_NAME, strlen(APPLICATION_RELEASE_NAME)) != 0)\n          {\n            LOG_DEBUG(\"Failed to verify version name: [%s] expected: [%s], for peer with id: [%\" PRIu64 \"]!\\n\", message->version_name, APPLICATION_RELEASE_NAME, peer_id);\n            return 1;\n          }\n        }\n        // check to see if the peer is connected to the right network,\n        // that's appropriate to what mode they are running in...\n        if (message->use_testnet != parameters_get_use_testnet())\n        {\n          return 1;\n        }\n        peer_t *peer = init_peer(peer_id, net_connection);\n        assert(add_peer(peer) == 0);\n        if (handle_packet_sendto(net_connection, PKT_TYPE_CONNECT_RESP))\n        {\n          free_peer(peer);\n          return 1;\n        }\n        return 0;\n      }\n      break;\n    case PKT_TYPE_CONNECT_RESP:\n      {\n        connection_resp_t *message = (connection_resp_t*)message_object;\n        net_connection->anonymous = 0;\n        return 0;\n      }\n      break;\n    default:\n      assert(close_net_connection(net_connection) == 0);\n      return 1;\n  }\n  return 1;\n"]]}
{"hexsha": "0b4626439480805abbcb48521bc28c3f3f83af84", "ext": "c", "lang": "C", "content": "void GH_USB_set_RXCSRH_W_PERI_ISO(U8 data)\n{\n    m_usb_rxcsrh_w_peri.bitc.iso = data;\n    *(volatile U8 *)REG_USB_RXCSRH_W_PERI = m_usb_rxcsrh_w_peri.all;\n    #if GH_USB_ENABLE_DEBUG_PRINT\n    GH_USB_DEBUG_PRINT_FUNCTION( \"WRREG(0x%08x,0x%08x); \\\\\\\\ [GH_USB_set_RXCSRH_W_PERI_ISO] <-- 0x%08x\\n\",\n                        REG_USB_RXCSRH_W_PERI,m_usb_rxcsrh_w_peri.all,m_usb_rxcsrh_w_peri.all);\n    #endif\n}", "item_id": 446, "repo": "Davidfind/rt-thread", "file": "bsp/gkipc/libraries/drv/710XS/gh/src/gh_usb.c", "last_update_at": "2020-12-19T04:35:43+00:00", "question_id": "0b4626439480805abbcb48521bc28c3f3f83af84_446", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void GH_USB_set_RXCSRH_W_PERI_ISO(U8 data)\n{\n    m_usb_rxcsrh_w_peri.bitc.iso = data;\n    *(volatile U8 *)REG_USB_RXCSRH_W_PERI = m_usb_rxcsrh_w_peri.all;\n    #if GH_USB_ENABLE_DEBUG_PRINT\n    GH_USB_DEBUG_PRINT_FUNCTION( \"WRREG(0x%08x,0x%08x); \\\\\\\\ [GH_USB_set_RXCSRH_W_PERI_ISO] <-- 0x%08x\\n\",\n                        REG_USB_RXCSRH_W_PERI,m_usb_rxcsrh_w_peri.all,m_usb_rxcsrh_w_peri.all);\n    #endif\n"]]}
{"hexsha": "246a509f4e6895bc783916efd27d913363f9ccf3", "ext": "c", "lang": "C", "content": "int\nafs_tp_create(struct afs_thread_pool ** pool_out,\n\t      struct afs_work_queue * queue)\n{\n    int ret = 0;\n    struct afs_thread_pool * pool;\n\n    ret = _afs_tp_alloc(pool_out);\n    if (ret) {\n\tgoto error;\n    }\n    pool = *pool_out;\n\n    opr_mutex_init(&pool->lock);\n    opr_cv_init(&pool->shutdown_cv);\n    queue_Init(&pool->thread_list);\n    pool->work_queue = queue;\n    pool->entry = &_afs_tp_worker_default;\n    pool->rock = NULL;\n    pool->nthreads = 0;\n    pool->max_threads = 4;\n    pool->state = AFS_TP_STATE_INIT;\n\n error:\n    return ret;\n}", "item_id": 7, "repo": "jakllsch/openafs", "file": "src/util/thread_pool.c", "last_update_at": "2020-02-24T22:07:16+00:00", "question_id": "246a509f4e6895bc783916efd27d913363f9ccf3_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nafs_tp_create(struct afs_thread_pool ** pool_out,\n\t      struct afs_work_queue * queue)\n{\n    int ret = 0;\n    struct afs_thread_pool * pool;\n    ret = _afs_tp_alloc(pool_out);\n    if (ret) {\n\tgoto error;\n    }\n    pool = *pool_out;\n    opr_mutex_init(&pool->lock);\n    opr_cv_init(&pool->shutdown_cv);\n    queue_Init(&pool->thread_list);\n    pool->work_queue = queue;\n    pool->entry = &_afs_tp_worker_default;\n    pool->rock = NULL;\n    pool->nthreads = 0;\n    pool->max_threads = 4;\n    pool->state = AFS_TP_STATE_INIT;\n error:\n    return ret;\n"]]}
{"hexsha": "4f60c2b6ba88c78f3c6cb4c96573c75d87f70b3f", "ext": "c", "lang": "C", "content": "static int Integrity_POST(kmod_info_t* pkmod, void* d, int verbose)\n{\n\tint result = -1; // Set to zero for sucesses until it all works\n\tsize_t sha256DigestBufferLength = 32;\n\n\tif (NULL == d)\n\t{\n\t\tif (verbose)\n\t\t{\n\t\t\tkprintf(\"The AppleTEXTHash_t pointer was NOT passed to the Integrity_POST function\\n\");\n\t\t}\n\t\treturn result;\n\t}\n\n\tAppleTEXTHash_t* pHashData = (AppleTEXTHash_t*)d;\n\t\n\tif (pHashData->ath_version != 1 || pHashData->ath_length != (int)sha256DigestBufferLength)\n\t{\n\t\tif (verbose)\n\t\t{\n\t\t\tkprintf(\"The AppleTEXTHash_t pointer passed to Integrity_POST function, is invalid\\n\");\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tif (NULL == pHashData->ath_hash)\n\t{\n\t\tif (verbose)\n\t\t{\n\t\t\tkprintf(\"The AppleTEXTHash_t pointer passed to Integrity_POST function,has a null HASH pointer\\n\");\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tunsigned long plist_hash_output_buffer_size = (sha256DigestBufferLength * 2) + 1;\n\tunsigned char plist_hash_output_buffer[plist_hash_output_buffer_size];\n\tchar* pPlistHexBuf = (char*)bytesToHexString(pHashData->ath_hash, pHashData->ath_length, plist_hash_output_buffer, plist_hash_output_buffer_size);\n\t\n\tif (verbose)\n\t{\n\t\tkprintf(\"Plist hmac value is    %s\\n\", pPlistHexBuf);\n\t}\n\t\n\t// Now calcuate the HMAC\n    struct mach_header* pmach_header = (struct mach_header*)pkmod->address;\n    \n\tstruct load_command* pLoadCommand = NULL;\n\n\tuint32_t num_load_commands = 0;\n\tif (pmach_header->magic == MH_MAGIC_64)\n\t{\n\t\tstruct mach_header_64* pmach64_header = (struct mach_header_64*)pmach_header;\n\t\tnum_load_commands = pmach64_header->ncmds;\t\t\n\t\tpLoadCommand = (struct load_command*)(((unsigned char*)pmach_header) + sizeof(struct mach_header_64));\n\t}\n\telse if (pmach_header->magic == MH_MAGIC)\n\t{\n\t\tnum_load_commands = pmach_header->ncmds;\n\t\tpLoadCommand = (struct load_command*)(((unsigned char*)pmach_header) + sizeof(struct mach_header));\n\t}\n\n\tif (NULL == pLoadCommand)\n\t{\n\t\tif (verbose)\n\t\t{\n\t\t\tkprintf(\"pLoadCommand is NULL!\\n\");\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tconst struct ccdigest_info* di = ccsha256_di();\n    unsigned char hmac_key = 0;\n    cchmac_ctx_decl(di->state_size, di->block_size, ctx);\n    cchmac_init(di, ctx, 1, &hmac_key);\n\tint hashCreated = 0;\n    unsigned long iCnt;\n    unsigned long jCnt;\n\t\n\tstruct segment_command* pSniffPtr = (struct segment_command*)pLoadCommand;\n    \n\t\n\t// Loop through the Segments to find the __TEXT, __text segment\n\tfor (iCnt = 0; iCnt < num_load_commands; iCnt++)\n    {\n        // The struct segment_command and the struct segment_command_64  have the same\n        // first three fields so sniff the name by casting to a struct segment_command \n\n        if (strncmp(\"__TEXT\", pSniffPtr->segname, strlen(\"__TEXT\")))\n        {\n            // These are not the droids we are looking for\n\t\t\t// MOve the SniffPtr to the next segment;\n            if (LC_SEGMENT_64 == pSniffPtr->cmd)\n            {\n                struct segment_command_64* pSegmentPtr = (struct segment_command_64*)pSniffPtr;\n                pSniffPtr = (struct segment_command*)(((unsigned char *)pSegmentPtr) + pSegmentPtr->cmdsize);\n            }\n            else if (LC_SEGMENT == pSniffPtr->cmd)\n            {\n                pSniffPtr = (struct segment_command*)(((unsigned char *)pSniffPtr) + pSniffPtr->cmdsize);\n            }\n\t\t\t\n\t\t\t// Go back to the top of the loop and look again\n            continue; \n        }\n        \n\t\t// Bingo! We found the __TEXT segment!\n\t\t// Deal with a 64 bit segment\n        if (LC_SEGMENT_64 == pLoadCommand->cmd)\n        {\n            struct segment_command_64* pSegmentPtr = NULL;\n\n            // This is a 64 bit load segment command\n            pSegmentPtr = (struct segment_command_64*)pSniffPtr;\n            unsigned int numSections = (unsigned int)pSegmentPtr->nsects;\n            struct section_64* pSectionPtr = (struct section_64*)(((unsigned char*)pSegmentPtr) + sizeof(struct segment_command_64));\n            int texttextsectionprocessed = 0;\n\n            // Need to find the __text __TEXT section\n            for (jCnt = 0; jCnt < numSections; jCnt++)\n            {\n                if ( !strcmp(pSectionPtr->sectname, \"__text\") && !strcmp(pSectionPtr->segname, \"__TEXT\"))\n                {\n                    // Found it\n                    unsigned char* pSectionData = (unsigned char*)(((unsigned char*)pmach_header) + pSectionPtr->offset);\n\n                    cchmac_update(di, ctx, (unsigned long)pSectionPtr->size, pSectionData);\t\n\t\t\t\t\thashCreated = 1;\n\n                    texttextsectionprocessed = 1;\n                    break;\n                }\n                else\n                {\n                    // Move to the next section record\n                    pSectionPtr++;\n                }\n            }\n            if (texttextsectionprocessed)\n            {\n                // The text text section was found and processed\n                break;\n            }\n        }\n\t\telse if (LC_SEGMENT == pLoadCommand->cmd) // Deal with a 32 bit segment\n\t\t{\n\t\t\tstruct segment_command* pSegmentPtr = NULL;\n\n            // This is a 32 bit load segment command\n            pSegmentPtr = (struct segment_command*)pLoadCommand;\n            unsigned int numSections = (unsigned int)pSegmentPtr->nsects;\n            struct section* pSectionPtr = (struct section*)(((unsigned char*)pSegmentPtr) + sizeof(struct segment_command));\n\t\t\tint texttextsectionprocessed = 0;\n\n            // Need to find the __text __TEXT section\n            for (jCnt = 0; jCnt < numSections; jCnt++)\n\t\t\t{\n\t\t\t\tif ( !strcmp(pSectionPtr->sectname, \"__text\") && !strcmp(pSectionPtr->segname, \"__TEXT\"))\n\t\t\t\t{\n\t\t\t\t\t// Found it\n\t\t\t\t\tunsigned char* pSectionData = (unsigned char*)(((unsigned char*)pmach_header) + pSectionPtr->offset);\n\n\t\t\t\t\tcchmac_update(di, ctx, (unsigned long)pSectionPtr->size, pSectionData);\t\n\t\t\t\t\thashCreated = 1;\n\n\t\t\t\t\ttexttextsectionprocessed = 1;\n                    break;\n\t\t\t\t}\n\t\t\t\telse\n                {\n                    // Move to the next section record\n                    pSectionPtr++;\n                }\n\t\t\t}\n\t\t\tif (texttextsectionprocessed)\n\t\t\t{\n\t\t\t\t// The text text section was found and processed\n\t\t\t\t// Time to bail on the loop\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n    }\n\t\n\tunsigned long hash_output_buffer_size = (sha256DigestBufferLength * 2) + 1;\n\tunsigned char hash_output_buffer[hash_output_buffer_size];\n\tunsigned char hmac_buffer[sha256DigestBufferLength];\n    memset(hmac_buffer, 0, sha256DigestBufferLength);\n\t\t\n\t// Check to see if the hash was created \n\tif (hashCreated) \n\t{\n\t\t// finalize the HMAC\n        \n\t\tcchmac_final(di, ctx, hmac_buffer);\n\t    char* pHexBuf = (char*)bytesToHexString(hmac_buffer, sha256DigestBufferLength, hash_output_buffer, hash_output_buffer_size);\n\t\tif (verbose)\n\t\t{\n\t    \tkprintf(\"Computed hmac value is %s\\n\", pHexBuf);\n\t\t}\n        \n\t}  \n\telse\n\t{\n\t\tif (verbose)\n\t\t{\n\t\t\tkprintf(\"Integrity_POST: WARNING! could not create the hash!\\n\");\n\t\t}\n\t\treturn -1;\n\t}\n\t\n#ifdef FORCE_FAIL\n    // futz with the generated hmac\n\thash_output_buffer[0] = 0;\t// This will always work because it is the charter representation of the \n\t\t\t\t\t\t\t\t// hash that is being checked.\n#endif \n\tresult = memcmp(hash_output_buffer, plist_hash_output_buffer, hash_output_buffer_size);\n\t\n\treturn result;\n}", "item_id": 1, "repo": "GaloisInc/hacrypto", "file": "src/C/corecrypto/corecrypto_kext/kext_fipspost.c", "last_update_at": "2020-11-10T06:45:28+00:00", "question_id": "4f60c2b6ba88c78f3c6cb4c96573c75d87f70b3f_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int Integrity_POST(kmod_info_t* pkmod, void* d, int verbose)\n{\n\tint result = -1; // Set to zero for sucesses until it all works\n\tsize_t sha256DigestBufferLength = 32;\n\tif (NULL == d)\n\t{\n\t\tif (verbose)\n\t\t{\n\t\t\tkprintf(\"The AppleTEXTHash_t pointer was NOT passed to the Integrity_POST function\\n\");\n\t\t}\n\t\treturn result;\n\t}\n\tAppleTEXTHash_t* pHashData = (AppleTEXTHash_t*)d;\n\t\n\tif (pHashData->ath_version != 1 || pHashData->ath_length != (int)sha256DigestBufferLength)\n\t{\n\t\tif (verbose)\n\t\t{\n\t\t\tkprintf(\"The AppleTEXTHash_t pointer passed to Integrity_POST function, is invalid\\n\");\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tif (NULL == pHashData->ath_hash)\n\t{\n\t\tif (verbose)\n\t\t{\n\t\t\tkprintf(\"The AppleTEXTHash_t pointer passed to Integrity_POST function,has a null HASH pointer\\n\");\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tunsigned long plist_hash_output_buffer_size = (sha256DigestBufferLength * 2) + 1;\n\tunsigned char plist_hash_output_buffer[plist_hash_output_buffer_size];\n\tchar* pPlistHexBuf = (char*)bytesToHexString(pHashData->ath_hash, pHashData->ath_length, plist_hash_output_buffer, plist_hash_output_buffer_size);\n\t\n\tif (verbose)\n\t{\n\t\tkprintf(\"Plist hmac value is    %s\\n\", pPlistHexBuf);\n\t}\n\t\n\t// Now calcuate the HMAC\n    struct mach_header* pmach_header = (struct mach_header*)pkmod->address;\n\tstruct load_command* pLoadCommand = NULL;\n\tuint32_t num_load_commands = 0;\n\tif (pmach_header->magic == MH_MAGIC_64)\n\t{\n\t\tstruct mach_header_64* pmach64_header = (struct mach_header_64*)pmach_header;\n\t\tnum_load_commands = pmach64_header->ncmds;\t\t\n\t\tpLoadCommand = (struct load_command*)(((unsigned char*)pmach_header) + sizeof(struct mach_header_64));\n\t}\n\telse if (pmach_header->magic == MH_MAGIC)\n\t{\n\t\tnum_load_commands = pmach_header->ncmds;\n\t\tpLoadCommand = (struct load_command*)(((unsigned char*)pmach_header) + sizeof(struct mach_header));\n\t}\n\tif (NULL == pLoadCommand)\n\t{\n\t\tif (verbose)\n\t\t{\n\t\t\tkprintf(\"pLoadCommand is NULL!\\n\");\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tconst struct ccdigest_info* di = ccsha256_di();\n    unsigned char hmac_key = 0;\n    cchmac_ctx_decl(di->state_size, di->block_size, ctx);\n    cchmac_init(di, ctx, 1, &hmac_key);\n\tint hashCreated = 0;\n    unsigned long iCnt;\n    unsigned long jCnt;\n\t\n\tstruct segment_command* pSniffPtr = (struct segment_command*)pLoadCommand;\n\t\n\t// Loop through the Segments to find the __TEXT, __text segment\n\tfor (iCnt = 0; iCnt < num_load_commands; iCnt++)\n    {\n        // The struct segment_command and the struct segment_command_64  have the same\n        // first three fields so sniff the name by casting to a struct segment_command \n        if (strncmp(\"__TEXT\", pSniffPtr->segname, strlen(\"__TEXT\")))\n        {\n            // These are not the droids we are looking for\n\t\t\t// MOve the SniffPtr to the next segment;\n            if (LC_SEGMENT_64 == pSniffPtr->cmd)\n            {\n                struct segment_command_64* pSegmentPtr = (struct segment_command_64*)pSniffPtr;\n                pSniffPtr = (struct segment_command*)(((unsigned char *)pSegmentPtr) + pSegmentPtr->cmdsize);\n            }\n            else if (LC_SEGMENT == pSniffPtr->cmd)\n            {\n                pSniffPtr = (struct segment_command*)(((unsigned char *)pSniffPtr) + pSniffPtr->cmdsize);\n            }\n\t\t\t\n\t\t\t// Go back to the top of the loop and look again\n            continue; \n        }\n\t\t// Bingo! We found the __TEXT segment!\n\t\t// Deal with a 64 bit segment\n        if (LC_SEGMENT_64 == pLoadCommand->cmd)\n        {\n            struct segment_command_64* pSegmentPtr = NULL;\n            // This is a 64 bit load segment command\n            pSegmentPtr = (struct segment_command_64*)pSniffPtr;\n            unsigned int numSections = (unsigned int)pSegmentPtr->nsects;\n            struct section_64* pSectionPtr = (struct section_64*)(((unsigned char*)pSegmentPtr) + sizeof(struct segment_command_64));\n            int texttextsectionprocessed = 0;\n            // Need to find the __text __TEXT section\n            for (jCnt = 0; jCnt < numSections; jCnt++)\n            {\n                if ( !strcmp(pSectionPtr->sectname, \"__text\") && !strcmp(pSectionPtr->segname, \"__TEXT\"))\n                {\n                    // Found it\n                    unsigned char* pSectionData = (unsigned char*)(((unsigned char*)pmach_header) + pSectionPtr->offset);\n                    cchmac_update(di, ctx, (unsigned long)pSectionPtr->size, pSectionData);\t\n\t\t\t\t\thashCreated = 1;\n                    texttextsectionprocessed = 1;\n                    break;\n                }\n                else\n                {\n                    // Move to the next section record\n                    pSectionPtr++;\n                }\n            }\n            if (texttextsectionprocessed)\n            {\n                // The text text section was found and processed\n                break;\n            }\n        }\n\t\telse if (LC_SEGMENT == pLoadCommand->cmd) // Deal with a 32 bit segment\n\t\t{\n\t\t\tstruct segment_command* pSegmentPtr = NULL;\n            // This is a 32 bit load segment command\n            pSegmentPtr = (struct segment_command*)pLoadCommand;\n            unsigned int numSections = (unsigned int)pSegmentPtr->nsects;\n            struct section* pSectionPtr = (struct section*)(((unsigned char*)pSegmentPtr) + sizeof(struct segment_command));\n\t\t\tint texttextsectionprocessed = 0;\n            // Need to find the __text __TEXT section\n            for (jCnt = 0; jCnt < numSections; jCnt++)\n\t\t\t{\n\t\t\t\tif ( !strcmp(pSectionPtr->sectname, \"__text\") && !strcmp(pSectionPtr->segname, \"__TEXT\"))\n\t\t\t\t{\n\t\t\t\t\t// Found it\n\t\t\t\t\tunsigned char* pSectionData = (unsigned char*)(((unsigned char*)pmach_header) + pSectionPtr->offset);\n\t\t\t\t\tcchmac_update(di, ctx, (unsigned long)pSectionPtr->size, pSectionData);\t\n\t\t\t\t\thashCreated = 1;\n\t\t\t\t\ttexttextsectionprocessed = 1;\n                    break;\n\t\t\t\t}\n\t\t\t\telse\n                {\n                    // Move to the next section record\n                    pSectionPtr++;\n                }\n\t\t\t}\n\t\t\tif (texttextsectionprocessed)\n\t\t\t{\n\t\t\t\t// The text text section was found and processed\n\t\t\t\t// Time to bail on the loop\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n    }\n\t\n\tunsigned long hash_output_buffer_size = (sha256DigestBufferLength * 2) + 1;\n\tunsigned char hash_output_buffer[hash_output_buffer_size];\n\tunsigned char hmac_buffer[sha256DigestBufferLength];\n    memset(hmac_buffer, 0, sha256DigestBufferLength);\n\t\t\n\t// Check to see if the hash was created \n\tif (hashCreated) \n\t{\n\t\t// finalize the HMAC\n\t\tcchmac_final(di, ctx, hmac_buffer);\n\t    char* pHexBuf = (char*)bytesToHexString(hmac_buffer, sha256DigestBufferLength, hash_output_buffer, hash_output_buffer_size);\n\t\tif (verbose)\n\t\t{\n\t    \tkprintf(\"Computed hmac value is %s\\n\", pHexBuf);\n\t\t}\n\t}  \n\telse\n\t{\n\t\tif (verbose)\n\t\t{\n\t\t\tkprintf(\"Integrity_POST: WARNING! could not create the hash!\\n\");\n\t\t}\n\t\treturn -1;\n\t}\n\t\n#ifdef FORCE_FAIL\n    // futz with the generated hmac\n\thash_output_buffer[0] = 0;\t// This will always work because it is the charter representation of the \n\t\t\t\t\t\t\t\t// hash that is being checked.\n#endif \n\tresult = memcmp(hash_output_buffer, plist_hash_output_buffer, hash_output_buffer_size);\n\t\n\treturn result;\n"]]}
{"hexsha": "c2d628e9a4094db995344334367caffa54f08065", "ext": "c", "lang": "C", "content": "void\ncpu_init(struct cpu_info *ci)\n{\n\t/* configure the CPU if needed */\n\tif (ci->cpu_setup != NULL)\n\t\t(*ci->cpu_setup)(ci);\n\n\t/*\n\t * We do this here after identifycpu() because errata may affect\n\t * what we do.\n\t */\n\tpatinit(ci);\n \n\t/*\n\t * Enable ring 0 write protection (486 or above, but 386\n\t * no longer supported).\n\t */\n\tlcr0(rcr0() | CR0_WP);\n\n\tif (cpu_feature & CPUID_PGE)\n\t\tlcr4(rcr4() | CR4_PGE);\t/* enable global TLB caching */\n\n#ifdef MULTIPROCESSOR\n\tci->ci_flags |= CPUF_RUNNING;\n\ttlbflushg();\n#endif\n\n\t/*\n\t * If we have FXSAVE/FXRESTOR, use them.\n\t */\n\tif (cpu_feature & CPUID_FXSR) {\n\t\tlcr4(rcr4() | CR4_OSFXSR);\n\n\t\t/*\n\t\t * If we have SSE/SSE2, enable XMM exceptions.\n\t\t */\n\t\tif (cpu_feature & (CPUID_SSE|CPUID_SSE2))\n\t\t\tlcr4(rcr4() | CR4_OSXMMEXCPT);\n\t}\n}", "item_id": 2, "repo": "sizeofvoid/ifconfigd", "file": "usr/src/sys/arch/i386/i386/cpu.c", "last_update_at": "2020-08-28T01:27:00+00:00", "question_id": "c2d628e9a4094db995344334367caffa54f08065_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\ncpu_init(struct cpu_info *ci)\n{\n\t/* configure the CPU if needed */\n\tif (ci->cpu_setup != NULL)\n\t\t(*ci->cpu_setup)(ci);\n\t/*\n\t * We do this here after identifycpu() because errata may affect\n\t * what we do.\n\t */\n\tpatinit(ci);\n\t/*\n\t * Enable ring 0 write protection (486 or above, but 386\n\t * no longer supported).\n\t */\n\tlcr0(rcr0() | CR0_WP);\n\tif (cpu_feature & CPUID_PGE)\n\t\tlcr4(rcr4() | CR4_PGE);\t/* enable global TLB caching */\n#ifdef MULTIPROCESSOR\n\tci->ci_flags |= CPUF_RUNNING;\n\ttlbflushg();\n#endif\n\t/*\n\t * If we have FXSAVE/FXRESTOR, use them.\n\t */\n\tif (cpu_feature & CPUID_FXSR) {\n\t\tlcr4(rcr4() | CR4_OSFXSR);\n\t\t/*\n\t\t * If we have SSE/SSE2, enable XMM exceptions.\n\t\t */\n\t\tif (cpu_feature & (CPUID_SSE|CPUID_SSE2))\n\t\t\tlcr4(rcr4() | CR4_OSXMMEXCPT);\n\t}\n"]]}
{"hexsha": "9ed20a286e3b1f61ff31c766fd661db123ed0677", "ext": "c", "lang": "C", "content": "void keyboard_destroy_notify(struct wl_listener *listener, void *data) {\n\tstruct sample_keyboard *keyboard = wl_container_of(listener, keyboard, destroy);\n\twl_list_remove(&keyboard->destroy.link);\n\twl_list_remove(&keyboard->key.link);\n\tfree(keyboard);\n}", "item_id": 8, "repo": "SimulaVR/wlroots", "file": "examples/touch.c", "last_update_at": "2020-04-18T05:56:10+00:00", "question_id": "9ed20a286e3b1f61ff31c766fd661db123ed0677_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void keyboard_destroy_notify(struct wl_listener *listener, void *data) {\n\tstruct sample_keyboard *keyboard = wl_container_of(listener, keyboard, destroy);\n\twl_list_remove(&keyboard->destroy.link);\n\twl_list_remove(&keyboard->key.link);\n\tfree(keyboard);\n"]]}
{"hexsha": "0880d4e5f91c81d53d175ed8a7f74577d11d9936", "ext": "c", "lang": "C", "content": "static void end_frame(AVFilterLink *link)\n{\n    CropContext *crop = link->dst->priv;\n\n    crop->var_values[VAR_N] += 1.0;\n    avfilter_unref_buffer(link->cur_buf);\n    avfilter_end_frame(link->dst->outputs[0]);\n}", "item_id": 8, "repo": "fillest/rtmp_load", "file": "src/libav/libavfilter/vf_crop.c", "last_update_at": "2020-09-26T00:58:57+00:00", "question_id": "0880d4e5f91c81d53d175ed8a7f74577d11d9936_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void end_frame(AVFilterLink *link)\n{\n    CropContext *crop = link->dst->priv;\n    crop->var_values[VAR_N] += 1.0;\n    avfilter_unref_buffer(link->cur_buf);\n    avfilter_end_frame(link->dst->outputs[0]);\n"]]}
{"hexsha": "be9da64e3158f3f5a7082eccfa76ea74cd058f6b", "ext": "c", "lang": "C", "content": "int pop_front(Dequeue* self) {\n\tif (empty(self)) {\n\t\treturn -1;\n\t}\n\n\tint result = *(self->base);\n\n\tfor (int i = 0; i < self->self_size - 1; ++i) {\n\t\t*(self->base + i) = *(self->base + i + 1);\n\t}\n\n\treserve(self, self->self_size - 1);\n\n\treturn result;\n}", "item_id": 6, "repo": "ed-asriyan/University", "file": "Programming/Labs/9/dequeue.c", "last_update_at": "2020-12-15T12:36:06+00:00", "question_id": "be9da64e3158f3f5a7082eccfa76ea74cd058f6b_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int pop_front(Dequeue* self) {\n\tif (empty(self)) {\n\t\treturn -1;\n\t}\n\tint result = *(self->base);\n\tfor (int i = 0; i < self->self_size - 1; ++i) {\n\t\t*(self->base + i) = *(self->base + i + 1);\n\t}\n\treserve(self, self->self_size - 1);\n\treturn result;\n"]]}
{"hexsha": "b7b6b3c26b1c6961c31259308732347697676b71", "ext": "c", "lang": "C", "content": "ssize_t\nsend (int fd, const void *buf, size_t n, int flags)\n{\n  ssize_t size;\n  const char *func_str;\n  u32 sid = ldp_sid_from_fd (fd);\n\n  if ((errno = -ldp_init ()))\n    return -1;\n\n  if (sid != INVALID_SESSION_ID)\n    {\n\n      func_str = \"vppcom_session_sendto\";\n\n      if (LDP_DEBUG > 2)\n\tclib_warning (\"LDP<%d>: fd %d (0x%x): calling %s(): sid %u (0x%x), \"\n\t\t      \"buf %p, n %u, flags 0x%x\",\n\t\t      getpid (), fd, fd, func_str, sid, sid, buf, n, flags);\n\n      size = vppcom_session_sendto (sid, (void *) buf, n, flags, NULL);\n      if (size < VPPCOM_OK)\n\t{\n\t  errno = -size;\n\t  size = -1;\n\t}\n    }\n  else\n    {\n      func_str = \"libc_send\";\n\n      if (LDP_DEBUG > 2)\n\tclib_warning (\"LDP<%d>: fd %d (0x%x): calling %s(): \"\n\t\t      \"buf %p, n %u, flags 0x%x\",\n\t\t      getpid (), fd, fd, func_str, buf, n, flags);\n\n      size = libc_send (fd, buf, n, flags);\n    }\n\n  if (LDP_DEBUG > 2)\n    {\n      if (size < 0)\n\t{\n\t  int errno_val = errno;\n\t  perror (func_str);\n\t  clib_warning (\"LDP<%d>: ERROR: fd %d (0x%x): %s() failed! \"\n\t\t\t\"rv %d, errno = %d\", getpid (), fd, fd,\n\t\t\tfunc_str, size, errno_val);\n\t  errno = errno_val;\n\t}\n      else\n\tclib_warning (\"LDP<%d>: fd %d (0x%x): returning %d (0x%x)\",\n\t\t      getpid (), fd, fd, size, size);\n    }\n  return size;\n}", "item_id": 17, "repo": "ydy1234/vpp", "file": "src/vcl/ldp.c", "last_update_at": "2020-05-21T16:26:02+00:00", "question_id": "b7b6b3c26b1c6961c31259308732347697676b71_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ssize_t\nsend (int fd, const void *buf, size_t n, int flags)\n{\n  ssize_t size;\n  const char *func_str;\n  u32 sid = ldp_sid_from_fd (fd);\n  if ((errno = -ldp_init ()))\n    return -1;\n  if (sid != INVALID_SESSION_ID)\n    {\n      func_str = \"vppcom_session_sendto\";\n      if (LDP_DEBUG > 2)\n\tclib_warning (\"LDP<%d>: fd %d (0x%x): calling %s(): sid %u (0x%x), \"\n\t\t      \"buf %p, n %u, flags 0x%x\",\n\t\t      getpid (), fd, fd, func_str, sid, sid, buf, n, flags);\n      size = vppcom_session_sendto (sid, (void *) buf, n, flags, NULL);\n      if (size < VPPCOM_OK)\n\t{\n\t  errno = -size;\n\t  size = -1;\n\t}\n    }\n  else\n    {\n      func_str = \"libc_send\";\n      if (LDP_DEBUG > 2)\n\tclib_warning (\"LDP<%d>: fd %d (0x%x): calling %s(): \"\n\t\t      \"buf %p, n %u, flags 0x%x\",\n\t\t      getpid (), fd, fd, func_str, buf, n, flags);\n      size = libc_send (fd, buf, n, flags);\n    }\n  if (LDP_DEBUG > 2)\n    {\n      if (size < 0)\n\t{\n\t  int errno_val = errno;\n\t  perror (func_str);\n\t  clib_warning (\"LDP<%d>: ERROR: fd %d (0x%x): %s() failed! \"\n\t\t\t\"rv %d, errno = %d\", getpid (), fd, fd,\n\t\t\tfunc_str, size, errno_val);\n\t  errno = errno_val;\n\t}\n      else\n\tclib_warning (\"LDP<%d>: fd %d (0x%x): returning %d (0x%x)\",\n\t\t      getpid (), fd, fd, size, size);\n    }\n  return size;\n"]]}
{"hexsha": "d6ba104358a3ba67e3699c641433a8b609a07502", "ext": "c", "lang": "C", "content": "void show_ospf_neighbors (uii_connection_t *uii) {\n  ospf_interface_t *ospf_interface;\n  ospf_neighbor_t *neighbor;\n\n\n  uii_add_bulk_output (uii, \"%-15s %-8s %-15s   %s\\r\\n\", \n\t\t       \"Neighbor ID\", \"State\", \"Address\", \"Interface\");\n  \n  LL_Iterate (OSPF.ll_ospf_interfaces, ospf_interface) {\n    \n    LL_Iterate (ospf_interface->ll_neighbors, neighbor) {\n      uii_add_bulk_output (uii, \"%-15s %-8s %-15s   %s\\r\\n\", \n\t\t\t   long_inet_ntoa (neighbor->neighbor_id), \n\t\t\t   ospf_states[neighbor->state],\n\t\t\t   prefix_toa (neighbor->prefix),\n\t\t\t   ospf_interface->interface->name);\n    }\n  }\n  uii_send_bulk_data (uii); \n}", "item_id": 5, "repo": "leleobhz/mrt", "file": "src/programs/sospf/neighbor.c", "last_update_at": "2020-12-27T22:47:09+00:00", "question_id": "d6ba104358a3ba67e3699c641433a8b609a07502_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void show_ospf_neighbors (uii_connection_t *uii) {\n  ospf_interface_t *ospf_interface;\n  ospf_neighbor_t *neighbor;\n  uii_add_bulk_output (uii, \"%-15s %-8s %-15s   %s\\r\\n\", \n\t\t       \"Neighbor ID\", \"State\", \"Address\", \"Interface\");\n  LL_Iterate (OSPF.ll_ospf_interfaces, ospf_interface) {\n    LL_Iterate (ospf_interface->ll_neighbors, neighbor) {\n      uii_add_bulk_output (uii, \"%-15s %-8s %-15s   %s\\r\\n\", \n\t\t\t   long_inet_ntoa (neighbor->neighbor_id), \n\t\t\t   ospf_states[neighbor->state],\n\t\t\t   prefix_toa (neighbor->prefix),\n\t\t\t   ospf_interface->interface->name);\n    }\n  }\n  uii_send_bulk_data (uii); \n"]]}
{"hexsha": "3e52235862a4390096b4cd7dac925bd99235a160", "ext": "c", "lang": "C", "content": "void* VG_(HT_Next)(VgHashTable *table)\n{\n   Int i;\n   vg_assert(table);\n   /* See long comment on HT_Next prototype in pub_tool_hashtable.h.\n      In short if this fails, it means the caller tried to modify the\n      table whilst iterating over it, which is a bug. */\n   vg_assert(table->iterOK);\n\n   if (table->iterNode && table->iterNode->next) {\n      table->iterNode = table->iterNode->next;\n      return table->iterNode;\n   }\n\n   for (i = table->iterChain; i < table->n_chains; i++) {\n      if (table->chains[i]) {\n         table->iterNode  = table->chains[i];\n         table->iterChain = i + 1;  // Next chain to be traversed\n         return table->iterNode;\n      }\n   }\n   return NULL;\n}", "item_id": 10, "repo": "wangcy6/weekly_read", "file": "code_reading/leixing518-valgrind-master/valgrind/coregrind/m_hashtable.c", "last_update_at": "2020-10-18T12:59:31+00:00", "question_id": "3e52235862a4390096b4cd7dac925bd99235a160_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void* VG_(HT_Next)(VgHashTable *table)\n{\n   Int i;\n   vg_assert(table);\n   /* See long comment on HT_Next prototype in pub_tool_hashtable.h.\n      In short if this fails, it means the caller tried to modify the\n      table whilst iterating over it, which is a bug. */\n   vg_assert(table->iterOK);\n   if (table->iterNode && table->iterNode->next) {\n      table->iterNode = table->iterNode->next;\n      return table->iterNode;\n   }\n   for (i = table->iterChain; i < table->n_chains; i++) {\n      if (table->chains[i]) {\n         table->iterNode  = table->chains[i];\n         table->iterChain = i + 1;  // Next chain to be traversed\n         return table->iterNode;\n      }\n   }\n   return NULL;\n"]]}
{"hexsha": "a70b20a77f88e8054c469268472b75a76335cf80", "ext": "h", "lang": "C", "content": "interface TLTimelineSessionOperation : NSOperation {\n\n\tid<TLTimelineDataSourceProvider> _provider;\n\tNSArray* _operations;\n\tdouble _providerTimeout;\n\tdouble _operationTimeout;\n\t/*^block*/id _sessionCompletionBlock;\n\tNSOperationQueue* _operationQueue;\n\tNSError* _sessionError;\n\n}", "item_id": 0, "repo": "zhangkn/iOS14Header", "file": "System/Library/PrivateFrameworks/Timeline.framework/TLTimelineSessionOperation.h", "last_update_at": "2020-11-04T15:43:01+00:00", "question_id": "a70b20a77f88e8054c469268472b75a76335cf80_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface TLTimelineSessionOperation : NSOperation {\n\tid<TLTimelineDataSourceProvider> _provider;\n\tNSArray* _operations;\n\tdouble _providerTimeout;\n\tdouble _operationTimeout;\n\t/*^block*/id _sessionCompletionBlock;\n\tNSOperationQueue* _operationQueue;\n\tNSError* _sessionError;\n"]]}
{"hexsha": "9e228f134a62c67a32f9bdfc05ded3999b8cd7e9", "ext": "c", "lang": "C", "content": "void rtgui_timer_destory(rtgui_timer_t *timer)\n{\n    RT_ASSERT(timer != RT_NULL);\n\n    /* stop timer firstly */\n    rtgui_timer_stop(timer);\n\n    /* detach rt-thread timer */\n    rt_timer_detach(&(timer->timer));\n\n    rtgui_free(timer);\n}", "item_id": 3, "repo": "ghsecuritylab/Hackthon_weatherStation_RTT", "file": "components/rtgui/common/rtgui_system.c", "last_update_at": "2020-09-28T11:32:41+00:00", "question_id": "9e228f134a62c67a32f9bdfc05ded3999b8cd7e9_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void rtgui_timer_destory(rtgui_timer_t *timer)\n{\n    RT_ASSERT(timer != RT_NULL);\n    /* stop timer firstly */\n    rtgui_timer_stop(timer);\n    /* detach rt-thread timer */\n    rt_timer_detach(&(timer->timer));\n    rtgui_free(timer);\n"]]}
{"hexsha": "02be4bbfa4a3e3d1ea5e4f4bea0b02314529a934", "ext": "c", "lang": "C", "content": "int bn_quotient_remainder_quot_wanted(x,y,z,zmax)\n     Bignum *x, *y, *z, *zmax;\n{\n  BOOL sx = BignumPos(x);\n  BOOL sy = BignumPos(y);\n  int value;\n  \n  if (!sx) bn_negate(x);\n  if (!sy) bn_negate(y);\n  value = bn_div_mod_quot_wanted(x,y,z,zmax);\n  if (!sx) bn_negate(x);\n  if (!sy) bn_negate(y);\n  if (!value) {\n    if (sx^sy)\n      bn_negate(z);\n    bn_canonize(z);\n  }\n  return value;\n}", "item_id": 19, "repo": "leuschel/ecce", "file": "www/CiaoDE/ciao/engine/bignum.c", "last_update_at": "2020-08-10T18:17:26+00:00", "question_id": "02be4bbfa4a3e3d1ea5e4f4bea0b02314529a934_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int bn_quotient_remainder_quot_wanted(x,y,z,zmax)\n     Bignum *x, *y, *z, *zmax;\n{\n  BOOL sx = BignumPos(x);\n  BOOL sy = BignumPos(y);\n  int value;\n  if (!sx) bn_negate(x);\n  if (!sy) bn_negate(y);\n  value = bn_div_mod_quot_wanted(x,y,z,zmax);\n  if (!sx) bn_negate(x);\n  if (!sy) bn_negate(y);\n  if (!value) {\n    if (sx^sy)\n      bn_negate(z);\n    bn_canonize(z);\n  }\n  return value;\n"]]}
{"hexsha": "b13f6dccf8fb6cd663ccee7b0f3e7a0ec85ec1d0", "ext": "c", "lang": "C", "content": "static HRESULT WINAPI ITypeLib2_fnQueryInterface(ITypeLib2 *iface, REFIID riid, void **ppv)\n{\n    ITypeLibImpl *This = impl_from_ITypeLib2(iface);\n\n    TRACE(\"(%p)->(IID: %s)\\n\",This,debugstr_guid(riid));\n\n    if(IsEqualIID(riid, &IID_IUnknown) ||\n       IsEqualIID(riid,&IID_ITypeLib)||\n       IsEqualIID(riid,&IID_ITypeLib2))\n    {\n        *ppv = &This->ITypeLib2_iface;\n    }\n    else if(IsEqualIID(riid, &IID_ICreateTypeLib) ||\n             IsEqualIID(riid, &IID_ICreateTypeLib2))\n    {\n        *ppv = &This->ICreateTypeLib2_iface;\n    }\n    else\n    {\n        *ppv = NULL;\n        TRACE(\"-- Interface: E_NOINTERFACE\\n\");\n        return E_NOINTERFACE;\n    }\n\n    IUnknown_AddRef((IUnknown*)*ppv);\n    return S_OK;\n}", "item_id": 86, "repo": "Sur3/wine", "file": "dlls/oleaut32/typelib.c", "last_update_at": "2020-03-02T14:44:56+00:00", "question_id": "b13f6dccf8fb6cd663ccee7b0f3e7a0ec85ec1d0_86", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static HRESULT WINAPI ITypeLib2_fnQueryInterface(ITypeLib2 *iface, REFIID riid, void **ppv)\n{\n    ITypeLibImpl *This = impl_from_ITypeLib2(iface);\n    TRACE(\"(%p)->(IID: %s)\\n\",This,debugstr_guid(riid));\n    if(IsEqualIID(riid, &IID_IUnknown) ||\n       IsEqualIID(riid,&IID_ITypeLib)||\n       IsEqualIID(riid,&IID_ITypeLib2))\n    {\n        *ppv = &This->ITypeLib2_iface;\n    }\n    else if(IsEqualIID(riid, &IID_ICreateTypeLib) ||\n             IsEqualIID(riid, &IID_ICreateTypeLib2))\n    {\n        *ppv = &This->ICreateTypeLib2_iface;\n    }\n    else\n    {\n        *ppv = NULL;\n        TRACE(\"-- Interface: E_NOINTERFACE\\n\");\n        return E_NOINTERFACE;\n    }\n    IUnknown_AddRef((IUnknown*)*ppv);\n    return S_OK;\n"]]}
{"hexsha": "ae34556f143f414fb8417601975f8ab9c80edff6", "ext": "c", "lang": "C", "content": "void\npcache_grow_map(pollcache_t *pcp, int fd)\n{\n\tint  \tnewsize;\n\tulong_t\t*newmap;\n\n\t/*\n\t * grow to nearest multiple of POLLMAPCHUNK, assuming POLLMAPCHUNK is\n\t * power of 2.\n\t */\n\tnewsize = (fd + POLLMAPCHUNK) & ~(POLLMAPCHUNK - 1);\n\tnewmap = kmem_zalloc((newsize / BT_NBIPUL) * sizeof (ulong_t),\n\t    KM_SLEEP);\n\t/*\n\t * don't want pollwakeup to set a bit while growing the bitmap.\n\t */\n\tASSERT(mutex_owned(&pcp->pc_lock) == 0);\n\tmutex_enter(&pcp->pc_lock);\n\tbcopy(pcp->pc_bitmap, newmap,\n\t    (pcp->pc_mapsize / BT_NBIPUL) * sizeof (ulong_t));\n\tkmem_free(pcp->pc_bitmap,\n\t    (pcp->pc_mapsize /BT_NBIPUL) * sizeof (ulong_t));\n\tpcp->pc_bitmap = newmap;\n\tpcp->pc_mapsize = newsize;\n\tmutex_exit(&pcp->pc_lock);\n}", "item_id": 14, "repo": "AsahiOS/gate", "file": "usr/src/uts/common/syscall/poll.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "ae34556f143f414fb8417601975f8ab9c80edff6_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\npcache_grow_map(pollcache_t *pcp, int fd)\n{\n\tint  \tnewsize;\n\tulong_t\t*newmap;\n\t/*\n\t * grow to nearest multiple of POLLMAPCHUNK, assuming POLLMAPCHUNK is\n\t * power of 2.\n\t */\n\tnewsize = (fd + POLLMAPCHUNK) & ~(POLLMAPCHUNK - 1);\n\tnewmap = kmem_zalloc((newsize / BT_NBIPUL) * sizeof (ulong_t),\n\t    KM_SLEEP);\n\t/*\n\t * don't want pollwakeup to set a bit while growing the bitmap.\n\t */\n\tASSERT(mutex_owned(&pcp->pc_lock) == 0);\n\tmutex_enter(&pcp->pc_lock);\n\tbcopy(pcp->pc_bitmap, newmap,\n\t    (pcp->pc_mapsize / BT_NBIPUL) * sizeof (ulong_t));\n\tkmem_free(pcp->pc_bitmap,\n\t    (pcp->pc_mapsize /BT_NBIPUL) * sizeof (ulong_t));\n\tpcp->pc_bitmap = newmap;\n\tpcp->pc_mapsize = newsize;\n\tmutex_exit(&pcp->pc_lock);\n"]]}
{"hexsha": "a9ab594c317af7799b1b7b18e4431352638fd2df", "ext": "c", "lang": "C", "content": "int alarm_range(gauge_t *g) {\n  aldl_define_t *def = &aldl->def[g->data_a];\n  aldl_data_t *data = &rec->data[g->data_a];\n  switch(def->type) {\n    case ALDL_FLOAT:\n      if( ( def->alarm_low_enable == 1 && data->f < def->alarm_low.f ) ||\n      ( def->alarm_high_enable == 1 && data->f > def->alarm_high.f) ) return 1;\n      return 0;\n      break;\n    case ALDL_INT:\n      if( ( def->alarm_low_enable == 1 && data->i < def->alarm_low.i ) ||\n      ( def->alarm_high_enable == 1 && data->i > def->alarm_high.i) ) return 1;\n      return 0;\n    default:\n      return 0;\n  }\n}", "item_id": 7, "repo": "paulgiuliano/aldl-pi", "file": "consoleif.c", "last_update_at": "2020-08-03T00:23:11+00:00", "question_id": "a9ab594c317af7799b1b7b18e4431352638fd2df_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int alarm_range(gauge_t *g) {\n  aldl_define_t *def = &aldl->def[g->data_a];\n  aldl_data_t *data = &rec->data[g->data_a];\n  switch(def->type) {\n    case ALDL_FLOAT:\n      if( ( def->alarm_low_enable == 1 && data->f < def->alarm_low.f ) ||\n      ( def->alarm_high_enable == 1 && data->f > def->alarm_high.f) ) return 1;\n      return 0;\n      break;\n    case ALDL_INT:\n      if( ( def->alarm_low_enable == 1 && data->i < def->alarm_low.i ) ||\n      ( def->alarm_high_enable == 1 && data->i > def->alarm_high.i) ) return 1;\n      return 0;\n    default:\n      return 0;\n  }\n"]]}
{"hexsha": "8632eb3a321ccd453d4e1114713f4edf2ae3a5ee", "ext": "c", "lang": "C", "content": "static void\nSV_RunCmd (usercmd_t *ucmd, qboolean inside)\n{\n\tedict_t    *ent;\n\tint         i, n;\n\tint         oldmsec;\n\n\tif (!inside && sv_timekick->ivalue) {\n\t\tdouble\ttime_since;\n\t\tint\t\ttime_allowed;\n\n\t\tif (host_client->msec_last_check == -1)\n\t\t\tgoto SV_RunCmd__clear;\n\n\t\thost_client->msecs += ucmd->msec;\n\t\ttime_since = svs.realtime - host_client->msec_last_check;\n\t\tif (time_since >= sv_timekick_interval->ivalue) {\n\t\t\ttime_allowed = time_since * (1000 + sv_timekick_allowed->ivalue);\n\t\t\tif (host_client->msecs > time_allowed) {\n\t\t\t\thost_client->msec_over++;\n\t\t\t\tSV_BroadcastPrintf(PRINT_HIGH, \"Temporal anomaly:\\n\"\n\t\t\t\t\t\t\"%f in %f for %s (%d/%d)\\n\", host_client->msecs,\n\t\t\t\t\t\ttime_since, host_client->name, host_client->msec_over,\n\t\t\t\t\t\tsv_timekick->ivalue);\n\t\t\t\tif (host_client->msec_over >= sv_timekick->ivalue) {\n\t\t\t\t\tSV_BroadcastPrintf(PRINT_HIGH,\n\t\t\t\t\t\t\t\"Kicked %s for time sync errors. (%d times)\\n\",\n\t\t\t\t\t\t\thost_client->name, host_client->msec_over);\n\t\t\t\t\tSV_DropClient (host_client);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nSV_RunCmd__clear:\n\t\thost_client->msecs = 0;\n\t\thost_client->msec_last_check = svs.realtime;\n\t}\n\t\t\n\tcmd = *ucmd;\n\n\t// chop up very long commands\n\tif (cmd.msec > 50) {\n\t\toldmsec = ucmd->msec;\n\t\tcmd.msec = oldmsec / 2;\n\t\tSV_RunCmd (&cmd, true);\n\t\tcmd.msec = oldmsec / 2;\n\t\tcmd.impulse = 0;\n\t\tSV_RunCmd (&cmd, true);\n\t\treturn;\n\t}\n\n\tif (!sv_player->v.fixangle)\n\t\tVectorCopy (ucmd->angles, sv_player->v.v_angle);\n\n\tsv_player->v.button0 = ucmd->buttons & 1;\n\tsv_player->v.button2 = (ucmd->buttons & 2) >> 1;\n\tsv_player->v.button1 = (ucmd->buttons & 4) >> 2;\n\tif (ucmd->impulse)\n\t\tsv_player->v.impulse = ucmd->impulse;\n\n//\n// angles\n// show 1/3 the pitch angle and all the roll angle  \n\tif (sv_player->v.health > 0) {\n\t\tif (!sv_player->v.fixangle) {\n\t\t\tsv_player->v.angles[PITCH] = -sv_player->v.v_angle[PITCH] / 3;\n\t\t\tsv_player->v.angles[YAW] = sv_player->v.v_angle[YAW];\n\t\t}\n\t\tsv_player->v.angles[ROLL] =\n\t\t\tV_CalcRoll (sv_player->v.angles, sv_player->v.velocity) * 4;\n\t}\n\n\thost.frametime = ucmd->msec * 0.001;\n\tif (host.frametime > 0.1)\n\t\thost.frametime = 0.1;\n\n\tif (!host_client->spectator) {\n\t\tpr_global_struct->frametime = host.frametime;\n\n\t\tpr_global_struct->time = sv.time;\n\t\tpr_global_struct->self = EDICT_TO_PROG (sv_player);\n\t\tPR_ExecuteProgram (pr_global_struct->PlayerPreThink);\n\n\t\tSV_RunThink (sv_player);\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t\tpmove.origin[i] =\n\t\t\tsv_player->v.origin[i] + (sv_player->v.mins[i] - player_mins[i]);\n\tVectorCopy (sv_player->v.velocity, pmove.velocity);\n\tVectorCopy (sv_player->v.v_angle, pmove.angles);\n\n\tpmove.spectator = host_client->spectator;\n\tpmove.waterjumptime = sv_player->v.teleport_time;\n\tpmove.numphysent = 1;\n\tpmove.physents[0].model = sv.worldmodel;\n\tpmove.physents[0].id = -1;\n\tpmove.cmd = *ucmd;\n\tpmove.dead = sv_player->v.health <= 0;\n\tpmove.oldbuttons = host_client->oldbuttons;\n\tpmove.player_id = -1;\n\n\tmovevars.entgravity = host_client->entgravity;\n\tmovevars.maxspeed = host_client->maxspeed;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tpmove_mins[i] = pmove.origin[i] - 256;\n\t\tpmove_maxs[i] = pmove.origin[i] + 256;\n\t}\n\tAddLinksToPmove (sv_areanodes);\n\tPlayerMove ();\n\n\thost_client->oldbuttons = pmove.oldbuttons;\n\tsv_player->v.teleport_time = pmove.waterjumptime;\n\tsv_player->v.waterlevel = pmove.waterlevel;\n\tsv_player->v.watertype = pmove.watertype;\n\tif (pmove.groundent) {\n\t\tsv_player->v.flags = (int) sv_player->v.flags | FL_ONGROUND;\n\t\tsv_player->v.groundentity =\n\t\t\tEDICT_TO_PROG (EDICT_NUM (pmove.groundent->info));\n\t} else\n\t\tsv_player->v.flags = (int) sv_player->v.flags & ~FL_ONGROUND;\n\tfor (i = 0; i < 3; i++)\n\t\tsv_player->v.origin[i] =\n\t\t\tpmove.origin[i] - (sv_player->v.mins[i] - player_mins[i]);\n\n\tVectorCopy (pmove.velocity, sv_player->v.velocity);\n\n\tVectorCopy (pmove.angles, sv_player->v.v_angle);\n\n\tif (!host_client->spectator) {\n\t\t// link into place and touch triggers\n\t\tSV_LinkEdict (sv_player, true);\n\n\t\t// touch other objects\n\t\tfor (i = 0; i < pmove.numtouch; i++) {\n\t\t\tn = pmove.touch[i]->info;\n\t\t\tent = EDICT_NUM (n);\n\t\t\tif (!ent->v.touch || (playertouch[n / 8] & (1 << (n % 8))))\n\t\t\t\tcontinue;\n\t\t\tpr_global_struct->self = EDICT_TO_PROG (ent);\n\t\t\tpr_global_struct->other = EDICT_TO_PROG (sv_player);\n\t\t\tPR_ExecuteProgram (ent->v.touch);\n\t\t\tplayertouch[n / 8] |= 1 << (n % 8);\n\t\t}\n\t}\n}", "item_id": 23, "repo": "luaman/twilight", "file": "src/qw/sv_user.c", "last_update_at": "2020-03-02T08:38:23+00:00", "question_id": "8632eb3a321ccd453d4e1114713f4edf2ae3a5ee_23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nSV_RunCmd (usercmd_t *ucmd, qboolean inside)\n{\n\tedict_t    *ent;\n\tint         i, n;\n\tint         oldmsec;\n\tif (!inside && sv_timekick->ivalue) {\n\t\tdouble\ttime_since;\n\t\tint\t\ttime_allowed;\n\t\tif (host_client->msec_last_check == -1)\n\t\t\tgoto SV_RunCmd__clear;\n\t\thost_client->msecs += ucmd->msec;\n\t\ttime_since = svs.realtime - host_client->msec_last_check;\n\t\tif (time_since >= sv_timekick_interval->ivalue) {\n\t\t\ttime_allowed = time_since * (1000 + sv_timekick_allowed->ivalue);\n\t\t\tif (host_client->msecs > time_allowed) {\n\t\t\t\thost_client->msec_over++;\n\t\t\t\tSV_BroadcastPrintf(PRINT_HIGH, \"Temporal anomaly:\\n\"\n\t\t\t\t\t\t\"%f in %f for %s (%d/%d)\\n\", host_client->msecs,\n\t\t\t\t\t\ttime_since, host_client->name, host_client->msec_over,\n\t\t\t\t\t\tsv_timekick->ivalue);\n\t\t\t\tif (host_client->msec_over >= sv_timekick->ivalue) {\n\t\t\t\t\tSV_BroadcastPrintf(PRINT_HIGH,\n\t\t\t\t\t\t\t\"Kicked %s for time sync errors. (%d times)\\n\",\n\t\t\t\t\t\t\thost_client->name, host_client->msec_over);\n\t\t\t\t\tSV_DropClient (host_client);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nSV_RunCmd__clear:\n\t\thost_client->msecs = 0;\n\t\thost_client->msec_last_check = svs.realtime;\n\t}\n\t\t\n\tcmd = *ucmd;\n\t// chop up very long commands\n\tif (cmd.msec > 50) {\n\t\toldmsec = ucmd->msec;\n\t\tcmd.msec = oldmsec / 2;\n\t\tSV_RunCmd (&cmd, true);\n\t\tcmd.msec = oldmsec / 2;\n\t\tcmd.impulse = 0;\n\t\tSV_RunCmd (&cmd, true);\n\t\treturn;\n\t}\n\tif (!sv_player->v.fixangle)\n\t\tVectorCopy (ucmd->angles, sv_player->v.v_angle);\n\tsv_player->v.button0 = ucmd->buttons & 1;\n\tsv_player->v.button2 = (ucmd->buttons & 2) >> 1;\n\tsv_player->v.button1 = (ucmd->buttons & 4) >> 2;\n\tif (ucmd->impulse)\n\t\tsv_player->v.impulse = ucmd->impulse;\n//\n// angles\n// show 1/3 the pitch angle and all the roll angle  \n\tif (sv_player->v.health > 0) {\n\t\tif (!sv_player->v.fixangle) {\n\t\t\tsv_player->v.angles[PITCH] = -sv_player->v.v_angle[PITCH] / 3;\n\t\t\tsv_player->v.angles[YAW] = sv_player->v.v_angle[YAW];\n\t\t}\n\t\tsv_player->v.angles[ROLL] =\n\t\t\tV_CalcRoll (sv_player->v.angles, sv_player->v.velocity) * 4;\n\t}\n\thost.frametime = ucmd->msec * 0.001;\n\tif (host.frametime > 0.1)\n\t\thost.frametime = 0.1;\n\tif (!host_client->spectator) {\n\t\tpr_global_struct->frametime = host.frametime;\n\t\tpr_global_struct->time = sv.time;\n\t\tpr_global_struct->self = EDICT_TO_PROG (sv_player);\n\t\tPR_ExecuteProgram (pr_global_struct->PlayerPreThink);\n\t\tSV_RunThink (sv_player);\n\t}\n\tfor (i = 0; i < 3; i++)\n\t\tpmove.origin[i] =\n\t\t\tsv_player->v.origin[i] + (sv_player->v.mins[i] - player_mins[i]);\n\tVectorCopy (sv_player->v.velocity, pmove.velocity);\n\tVectorCopy (sv_player->v.v_angle, pmove.angles);\n\tpmove.spectator = host_client->spectator;\n\tpmove.waterjumptime = sv_player->v.teleport_time;\n\tpmove.numphysent = 1;\n\tpmove.physents[0].model = sv.worldmodel;\n\tpmove.physents[0].id = -1;\n\tpmove.cmd = *ucmd;\n\tpmove.dead = sv_player->v.health <= 0;\n\tpmove.oldbuttons = host_client->oldbuttons;\n\tpmove.player_id = -1;\n\tmovevars.entgravity = host_client->entgravity;\n\tmovevars.maxspeed = host_client->maxspeed;\n\tfor (i = 0; i < 3; i++) {\n\t\tpmove_mins[i] = pmove.origin[i] - 256;\n\t\tpmove_maxs[i] = pmove.origin[i] + 256;\n\t}\n\tAddLinksToPmove (sv_areanodes);\n\tPlayerMove ();\n\thost_client->oldbuttons = pmove.oldbuttons;\n\tsv_player->v.teleport_time = pmove.waterjumptime;\n\tsv_player->v.waterlevel = pmove.waterlevel;\n\tsv_player->v.watertype = pmove.watertype;\n\tif (pmove.groundent) {\n\t\tsv_player->v.flags = (int) sv_player->v.flags | FL_ONGROUND;\n\t\tsv_player->v.groundentity =\n\t\t\tEDICT_TO_PROG (EDICT_NUM (pmove.groundent->info));\n\t} else\n\t\tsv_player->v.flags = (int) sv_player->v.flags & ~FL_ONGROUND;\n\tfor (i = 0; i < 3; i++)\n\t\tsv_player->v.origin[i] =\n\t\t\tpmove.origin[i] - (sv_player->v.mins[i] - player_mins[i]);\n\tVectorCopy (pmove.velocity, sv_player->v.velocity);\n\tVectorCopy (pmove.angles, sv_player->v.v_angle);\n\tif (!host_client->spectator) {\n\t\t// link into place and touch triggers\n\t\tSV_LinkEdict (sv_player, true);\n\t\t// touch other objects\n\t\tfor (i = 0; i < pmove.numtouch; i++) {\n\t\t\tn = pmove.touch[i]->info;\n\t\t\tent = EDICT_NUM (n);\n\t\t\tif (!ent->v.touch || (playertouch[n / 8] & (1 << (n % 8))))\n\t\t\t\tcontinue;\n\t\t\tpr_global_struct->self = EDICT_TO_PROG (ent);\n\t\t\tpr_global_struct->other = EDICT_TO_PROG (sv_player);\n\t\t\tPR_ExecuteProgram (ent->v.touch);\n\t\t\tplayertouch[n / 8] |= 1 << (n % 8);\n\t\t}\n\t}\n"]]}
{"hexsha": "772201157cd6171a47992a5c8576424713b950b7", "ext": "c", "lang": "C", "content": "struct blk *\nremovr(struct blk *p, int n)\n{\n\tint nn, neg;\n\tstruct blk *q, *s, *r;\n\tfsfile(p);\n\tneg = sbackc(p);\n\tif (neg < 0)\n\t\tchsign(p);\n\trewind(p);\n\tnn = (n + 1) / 2;\n\tq = salloc(nn);\n\twhile (n > 1) {\n\t\tsputc(q, sgetc(p));\n\t\tn -= 2;\n\t}\n\tr = salloc(2);\n\twhile (sfeof(p) == 0)\n\t\tsputc(r, sgetc(p));\n\trelease(p);\n\tif (n == 1) {\n\t\ts = dcdiv(r, tenptr);\n\t\trelease(r);\n\t\trewind(rem);\n\t\tif (sfeof(rem) == 0)\n\t\t\tsputc(q, sgetc(rem));\n\t\trelease(rem);\n\t\tif (neg < 0) {\n\t\t\tchsign(s);\n\t\t\tchsign(q);\n\t\t\tirem = q;\n\t\t\treturn (s);\n\t\t}\n\t\tirem = q;\n\t\treturn (s);\n\t}\n\tif (neg < 0) {\n\t\tchsign(r);\n\t\tchsign(q);\n\t\tirem = q;\n\t\treturn (r);\n\t}\n\tirem = q;\n\treturn (r);\n}", "item_id": 5, "repo": "AsahiOS/gate", "file": "usr/src/cmd/dc/dc.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "772201157cd6171a47992a5c8576424713b950b7_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct blk *\nremovr(struct blk *p, int n)\n{\n\tint nn, neg;\n\tstruct blk *q, *s, *r;\n\tfsfile(p);\n\tneg = sbackc(p);\n\tif (neg < 0)\n\t\tchsign(p);\n\trewind(p);\n\tnn = (n + 1) / 2;\n\tq = salloc(nn);\n\twhile (n > 1) {\n\t\tsputc(q, sgetc(p));\n\t\tn -= 2;\n\t}\n\tr = salloc(2);\n\twhile (sfeof(p) == 0)\n\t\tsputc(r, sgetc(p));\n\trelease(p);\n\tif (n == 1) {\n\t\ts = dcdiv(r, tenptr);\n\t\trelease(r);\n\t\trewind(rem);\n\t\tif (sfeof(rem) == 0)\n\t\t\tsputc(q, sgetc(rem));\n\t\trelease(rem);\n\t\tif (neg < 0) {\n\t\t\tchsign(s);\n\t\t\tchsign(q);\n\t\t\tirem = q;\n\t\t\treturn (s);\n\t\t}\n\t\tirem = q;\n\t\treturn (s);\n\t}\n\tif (neg < 0) {\n\t\tchsign(r);\n\t\tchsign(q);\n\t\tirem = q;\n\t\treturn (r);\n\t}\n\tirem = q;\n\treturn (r);\n"]]}
{"hexsha": "8d33e546fd74f67ede4aef6ff2dcb3a78a01fe26", "ext": "c", "lang": "C", "content": "static errcode_t free_gdp_blocks(ext2_filsys fs,\n\t\t\t\t ext2fs_block_bitmap reserve_blocks,\n\t\t\t\t ext2_filsys old_fs,\n\t\t\t\t dgrp_t group)\n{\n\tblk64_t\tblk;\n\tint\tj;\n\tdgrp_t\ti;\n\text2fs_block_bitmap bg_map = NULL;\n\terrcode_t retval = 0;\n\tdgrp_t count = old_fs->group_desc_count - fs->group_desc_count;\n\n\t/* If bigalloc, don't free metadata living in the same cluster */\n\tif (EXT2FS_CLUSTER_RATIO(fs) > 1) {\n\t\tretval = ext2fs_allocate_block_bitmap(fs, \"bgdata\", &bg_map);\n\t\tif (retval)\n\t\t\tgoto out;\n\n\t\tretval = mark_table_blocks(fs, bg_map);\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\n\tfor (i = group; i < group + count; i++) {\n\t\tblk = ext2fs_block_bitmap_loc(old_fs, i);\n\t\tif (blk &&\n\t\t    (blk < ext2fs_blocks_count(fs->super)) &&\n\t\t    !(bg_map && ext2fs_test_block_bitmap2(bg_map, blk))) {\n\t\t\text2fs_block_alloc_stats2(fs, blk, -1);\n\t\t\text2fs_mark_block_bitmap2(reserve_blocks, blk);\n\t\t}\n\n\t\tblk = ext2fs_inode_bitmap_loc(old_fs, i);\n\t\tif (blk &&\n\t\t    (blk < ext2fs_blocks_count(fs->super)) &&\n\t\t    !(bg_map && ext2fs_test_block_bitmap2(bg_map, blk))) {\n\t\t\text2fs_block_alloc_stats2(fs, blk, -1);\n\t\t\text2fs_mark_block_bitmap2(reserve_blocks, blk);\n\t\t}\n\n\t\tblk = ext2fs_inode_table_loc(old_fs, i);\n\t\tfor (j = 0;\n\t\t     j < fs->inode_blocks_per_group; j++, blk++) {\n\t\t\tif (blk >= ext2fs_blocks_count(fs->super) ||\n\t\t\t    (bg_map && ext2fs_test_block_bitmap2(bg_map, blk)))\n\t\t\t\tcontinue;\n\t\t\text2fs_block_alloc_stats2(fs, blk, -1);\n\t\t\text2fs_mark_block_bitmap2(reserve_blocks, blk);\n\t\t}\n\t}\n\nout:\n\tif (bg_map)\n\t\text2fs_free_block_bitmap(bg_map);\n\treturn retval;\n}", "item_id": 6, "repo": "afeng11/tomato-arm", "file": "release/src-rt-6.x.4708/router/e2fsprogs/resize/resize2fs.c", "last_update_at": "2020-05-24T07:23:26+00:00", "question_id": "8d33e546fd74f67ede4aef6ff2dcb3a78a01fe26_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static errcode_t free_gdp_blocks(ext2_filsys fs,\n\t\t\t\t ext2fs_block_bitmap reserve_blocks,\n\t\t\t\t ext2_filsys old_fs,\n\t\t\t\t dgrp_t group)\n{\n\tblk64_t\tblk;\n\tint\tj;\n\tdgrp_t\ti;\n\text2fs_block_bitmap bg_map = NULL;\n\terrcode_t retval = 0;\n\tdgrp_t count = old_fs->group_desc_count - fs->group_desc_count;\n\t/* If bigalloc, don't free metadata living in the same cluster */\n\tif (EXT2FS_CLUSTER_RATIO(fs) > 1) {\n\t\tretval = ext2fs_allocate_block_bitmap(fs, \"bgdata\", &bg_map);\n\t\tif (retval)\n\t\t\tgoto out;\n\t\tretval = mark_table_blocks(fs, bg_map);\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\tfor (i = group; i < group + count; i++) {\n\t\tblk = ext2fs_block_bitmap_loc(old_fs, i);\n\t\tif (blk &&\n\t\t    (blk < ext2fs_blocks_count(fs->super)) &&\n\t\t    !(bg_map && ext2fs_test_block_bitmap2(bg_map, blk))) {\n\t\t\text2fs_block_alloc_stats2(fs, blk, -1);\n\t\t\text2fs_mark_block_bitmap2(reserve_blocks, blk);\n\t\t}\n\t\tblk = ext2fs_inode_bitmap_loc(old_fs, i);\n\t\tif (blk &&\n\t\t    (blk < ext2fs_blocks_count(fs->super)) &&\n\t\t    !(bg_map && ext2fs_test_block_bitmap2(bg_map, blk))) {\n\t\t\text2fs_block_alloc_stats2(fs, blk, -1);\n\t\t\text2fs_mark_block_bitmap2(reserve_blocks, blk);\n\t\t}\n\t\tblk = ext2fs_inode_table_loc(old_fs, i);\n\t\tfor (j = 0;\n\t\t     j < fs->inode_blocks_per_group; j++, blk++) {\n\t\t\tif (blk >= ext2fs_blocks_count(fs->super) ||\n\t\t\t    (bg_map && ext2fs_test_block_bitmap2(bg_map, blk)))\n\t\t\t\tcontinue;\n\t\t\text2fs_block_alloc_stats2(fs, blk, -1);\n\t\t\text2fs_mark_block_bitmap2(reserve_blocks, blk);\n\t\t}\n\t}\nout:\n\tif (bg_map)\n\t\text2fs_free_block_bitmap(bg_map);\n\treturn retval;\n"]]}
{"hexsha": "c674f940b145340f9658d2e66412181c50e47bd5", "ext": "c", "lang": "C", "content": "struct tevent_req *rpccli_spoolss_GetPrinterData_send(TALLOC_CTX *mem_ctx,\n\t\t\t\t\t\t      struct tevent_context *ev,\n\t\t\t\t\t\t      struct rpc_pipe_client *cli,\n\t\t\t\t\t\t      struct policy_handle *_handle /* [in] [ref] */,\n\t\t\t\t\t\t      const char *_value_name /* [in] [charset(UTF16)] */,\n\t\t\t\t\t\t      enum winreg_Type *_type /* [out] [ref] */,\n\t\t\t\t\t\t      uint8_t *_data /* [out] [ref,size_is(offered)] */,\n\t\t\t\t\t\t      uint32_t _offered /* [in]  */,\n\t\t\t\t\t\t      uint32_t *_needed /* [out] [ref] */)\n{\n\tstruct tevent_req *req;\n\tstruct rpccli_spoolss_GetPrinterData_state *state;\n\tstruct tevent_req *subreq;\n\n\treq = tevent_req_create(mem_ctx, &state,\n\t\t\t\tstruct rpccli_spoolss_GetPrinterData_state);\n\tif (req == NULL) {\n\t\treturn NULL;\n\t}\n\tstate->out_mem_ctx = NULL;\n\tstate->dispatch_recv = cli->dispatch_recv;\n\n\t/* In parameters */\n\tstate->orig.in.handle = _handle;\n\tstate->orig.in.value_name = _value_name;\n\tstate->orig.in.offered = _offered;\n\n\t/* Out parameters */\n\tstate->orig.out.type = _type;\n\tstate->orig.out.data = _data;\n\tstate->orig.out.needed = _needed;\n\n\t/* Result */\n\tZERO_STRUCT(state->orig.out.result);\n\n\tstate->out_mem_ctx = talloc_named_const(state, 0,\n\t\t\t     \"rpccli_spoolss_GetPrinterData_out_memory\");\n\tif (tevent_req_nomem(state->out_mem_ctx, req)) {\n\t\treturn tevent_req_post(req, ev);\n\t}\n\n\t/* make a temporary copy, that we pass to the dispatch function */\n\tstate->tmp = state->orig;\n\n\tsubreq = cli->dispatch_send(state, ev, cli,\n\t\t\t\t    &ndr_table_spoolss,\n\t\t\t\t    NDR_SPOOLSS_GETPRINTERDATA,\n\t\t\t\t    &state->tmp);\n\tif (tevent_req_nomem(subreq, req)) {\n\t\treturn tevent_req_post(req, ev);\n\t}\n\ttevent_req_set_callback(subreq, rpccli_spoolss_GetPrinterData_done, req);\n\treturn req;\n}", "item_id": 104, "repo": "afeng11/tomato-arm", "file": "release/src-rt-6.x.4708/router/samba-3.5.8/librpc/gen_ndr/cli_spoolss.c", "last_update_at": "2020-05-24T07:23:26+00:00", "question_id": "c674f940b145340f9658d2e66412181c50e47bd5_104", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct tevent_req *rpccli_spoolss_GetPrinterData_send(TALLOC_CTX *mem_ctx,\n\t\t\t\t\t\t      struct tevent_context *ev,\n\t\t\t\t\t\t      struct rpc_pipe_client *cli,\n\t\t\t\t\t\t      struct policy_handle *_handle /* [in] [ref] */,\n\t\t\t\t\t\t      const char *_value_name /* [in] [charset(UTF16)] */,\n\t\t\t\t\t\t      enum winreg_Type *_type /* [out] [ref] */,\n\t\t\t\t\t\t      uint8_t *_data /* [out] [ref,size_is(offered)] */,\n\t\t\t\t\t\t      uint32_t _offered /* [in]  */,\n\t\t\t\t\t\t      uint32_t *_needed /* [out] [ref] */)\n{\n\tstruct tevent_req *req;\n\tstruct rpccli_spoolss_GetPrinterData_state *state;\n\tstruct tevent_req *subreq;\n\treq = tevent_req_create(mem_ctx, &state,\n\t\t\t\tstruct rpccli_spoolss_GetPrinterData_state);\n\tif (req == NULL) {\n\t\treturn NULL;\n\t}\n\tstate->out_mem_ctx = NULL;\n\tstate->dispatch_recv = cli->dispatch_recv;\n\t/* In parameters */\n\tstate->orig.in.handle = _handle;\n\tstate->orig.in.value_name = _value_name;\n\tstate->orig.in.offered = _offered;\n\t/* Out parameters */\n\tstate->orig.out.type = _type;\n\tstate->orig.out.data = _data;\n\tstate->orig.out.needed = _needed;\n\t/* Result */\n\tZERO_STRUCT(state->orig.out.result);\n\tstate->out_mem_ctx = talloc_named_const(state, 0,\n\t\t\t     \"rpccli_spoolss_GetPrinterData_out_memory\");\n\tif (tevent_req_nomem(state->out_mem_ctx, req)) {\n\t\treturn tevent_req_post(req, ev);\n\t}\n\t/* make a temporary copy, that we pass to the dispatch function */\n\tstate->tmp = state->orig;\n\tsubreq = cli->dispatch_send(state, ev, cli,\n\t\t\t\t    &ndr_table_spoolss,\n\t\t\t\t    NDR_SPOOLSS_GETPRINTERDATA,\n\t\t\t\t    &state->tmp);\n\tif (tevent_req_nomem(subreq, req)) {\n\t\treturn tevent_req_post(req, ev);\n\t}\n\ttevent_req_set_callback(subreq, rpccli_spoolss_GetPrinterData_done, req);\n\treturn req;\n"]]}
{"hexsha": "ad38a7d41636e419e85e754edfae632003db1ef4", "ext": "c", "lang": "C", "content": "int main() {\n    char sz[] = \"This is a nice day\";\n\n    FILE* f = fopen(\"ex1.txt\", \"w+\");\n    if (f == NULL) {\n        perror(\"failed to open\");\n        return 1;\n    }\n\n    ftruncate(fileno(f), sizeof(sz) - 1);\n\n    size_t pagesize = sysconf(_SC_PAGE_SIZE);\n\n    void* maddr = mmap(NULL, pagesize, PROT_WRITE | PROT_READ, MAP_SHARED, fileno(f), 0);\n    if (!maddr) {\n        perror(\"failed to mmap\");\n        return 1;\n    }\n\n    memcpy(maddr, sz, sizeof(sz) - 1);\n\n    munmap(maddr, pagesize);\n    fclose(f);\n\n    return 0;\n}", "item_id": 0, "repo": "Semior001/uni_operational_systems", "file": "week11/ex1.c", "last_update_at": "2020-12-21T21:57:12+00:00", "question_id": "ad38a7d41636e419e85e754edfae632003db1ef4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main() {\n    char sz[] = \"This is a nice day\";\n    FILE* f = fopen(\"ex1.txt\", \"w+\");\n    if (f == NULL) {\n        perror(\"failed to open\");\n        return 1;\n    }\n    ftruncate(fileno(f), sizeof(sz) - 1);\n    size_t pagesize = sysconf(_SC_PAGE_SIZE);\n    void* maddr = mmap(NULL, pagesize, PROT_WRITE | PROT_READ, MAP_SHARED, fileno(f), 0);\n    if (!maddr) {\n        perror(\"failed to mmap\");\n        return 1;\n    }\n    memcpy(maddr, sz, sizeof(sz) - 1);\n    munmap(maddr, pagesize);\n    fclose(f);\n    return 0;\n"]]}
{"hexsha": "9e9e48b7c876ca573c178dd4fdbdde09cfe16e77", "ext": "c", "lang": "C", "content": "void machine_hw_spi_init_internal(\r\n    machine_hw_spi_obj_t    *self,\r\n    int8_t                  host,\r\n    int32_t                 baudrate,\r\n    int8_t                  polarity,\r\n    int8_t                  phase,\r\n    int8_t                  firstbit,\r\n    int8_t                  sck,\r\n    int8_t                  mosi,\r\n    int8_t                  miso,\r\n    int8_t                  cs,\r\n    int8_t                  duplex,\r\n\tuint8_t\t\t\t\t\tqueue_size,\r\n\tuint8_t\t\t\t\t\tnew) {\r\n\r\n\r\n    esp_err_t ret;\r\n\r\n    self->state = MACHINE_HW_SPI_STATE_DEINIT;\r\n\r\n\tif ((baudrate <= 0) || (baudrate > 80000000)) {\r\n        mp_raise_ValueError(\"SPI baudrate must be >0 & <=80000000\");\r\n\t}\r\n\r\n\t// Host initialization\r\n\tif ((host != HSPI_HOST) && (host != VSPI_HOST)) {\r\n\t\tmp_raise_ValueError(\"SPI host must be either HSPI(1) or VSPI(2)\");\r\n\t}\r\n\tif ((SPIbus_configs[VSPI_HOST] == NULL) && (host == VSPI_HOST)) {\r\n\t\tmp_raise_ValueError(\"SPI host must be HSPI(1), VSPI(2) used by SPIRAM\");\r\n\t}\r\n\r\n    int used_spi = spi_host_used_by_sdspi();\r\n    if ((used_spi != 0) && (used_spi == host)) {\r\n        // change spi host\r\n        if (host == VSPI_HOST) {\r\n    \t\tmp_raise_ValueError(\"SPI host must be HSPI(1), VSPI(2) used by SDCard driver\");\r\n        }\r\n        else {\r\n    \t\tmp_raise_ValueError(\"SPI host must be VSPI(2), HSPI(1) used by SDCard driver\");\r\n        }\r\n    }\r\n\r\n    self->spi.spihost = host;\r\n    self->spi.buscfg = SPIbus_configs[self->spi.spihost];\r\n\r\n    // Init pins\r\n    if (cs >= 0) {\r\n\t\tgpio_pad_select_gpio(cs);\r\n\t\tgpio_set_direction(cs, GPIO_MODE_OUTPUT);\r\n\t\tgpio_set_level(cs, 1);\r\n    }\r\n    gpio_pad_select_gpio(miso);\r\n    gpio_pad_select_gpio(mosi);\r\n    gpio_pad_select_gpio(sck);\r\n    gpio_set_direction(miso, GPIO_MODE_INPUT);\r\n    gpio_set_pull_mode(miso, GPIO_PULLUP_ONLY);\r\n    gpio_set_direction(mosi, GPIO_MODE_OUTPUT);\r\n    gpio_set_direction(sck, GPIO_MODE_OUTPUT);\r\n\r\n    // Set configuration\r\n    self->polarity = polarity & 1;\r\n    self->phase = phase & 1;\r\n    self->firstbit = firstbit & 1;\r\n    self->duplex = duplex & 1;\r\n\r\n    self->spi.dma_channel = 1;\r\n    self->spi.curr_clock = baudrate;\r\n    self->spi.handle = NULL;\r\n    self->spi.dc = -1;\r\n    self->spi.selected = 0;\r\n    self->spi.cs = cs;\r\n\r\n    self->spi.buscfg->miso_io_num = miso;\r\n    self->spi.buscfg->mosi_io_num = mosi;\r\n    self->spi.buscfg->sclk_io_num = sck;\r\n    self->spi.buscfg->quadwp_io_num = -1;\r\n    self->spi.buscfg->quadhd_io_num = -1;\r\n    //self->spi.buscfg->max_transfer_sz = 6*1024;\r\n\r\n    self->spi.devcfg.clock_speed_hz = self->spi.curr_clock;\r\n    self->spi.devcfg.duty_cycle_pos = 128;\r\n    self->spi.devcfg.mode = self->phase | (self->polarity << 1);\r\n    self->spi.devcfg.spics_io_num = -1;\r\n    self->spi.devcfg.queue_size = queue_size;\r\n    self->spi.devcfg.flags = ((self->firstbit == MICROPY_PY_MACHINE_SPI_LSB) ? SPI_DEVICE_TXBIT_LSBFIRST | SPI_DEVICE_RXBIT_LSBFIRST : 0);\r\n    if (!self->duplex) self->spi.devcfg.flags |= SPI_DEVICE_HALFDUPLEX;\r\n    self->spi.devcfg.pre_cb = NULL;\r\n\r\n\t// ==== Initialize the SPI bus and attach the device ====\r\n\tret = add_extspi_device(&self->spi);\r\n\tif (ret == ESP_OK) {\r\n\t\tret = spi_device_select(&self->spi, 1);\r\n\t\tif (ret != ESP_OK) {\r\n\t        machine_hw_spi_deinit_internal(self);\r\n            mp_raise_msg(&mp_type_OSError, \"Error selecting device\");\r\n\t\t}\r\n\t\tret = spi_device_deselect(&self->spi);\r\n\t\tif (ret != ESP_OK) {\r\n\t        machine_hw_spi_deinit_internal(self);\r\n            mp_raise_msg(&mp_type_OSError, \"Error deselecting device\");\r\n\t\t}\r\n\t    self->state = MACHINE_HW_SPI_STATE_INIT;\r\n\t    return;\r\n\t}\r\n\r\n\tswitch (ret) {\r\n        case ESP_ERR_INVALID_ARG:\r\n            mp_raise_msg(&mp_type_OSError, \"invalid configuration\");\r\n            return;\r\n        case ESP_ERR_INVALID_STATE:\r\n            mp_raise_msg(&mp_type_OSError, \"invalid state\");\r\n            return;\r\n        case ESP_ERR_NO_MEM:\r\n            mp_raise_msg(&mp_type_OSError, \"out of memory\");\r\n            return;\r\n        case ESP_ERR_NOT_FOUND:\r\n            mp_raise_msg(&mp_type_OSError, \"no free slots\");\r\n            return;\r\n        default:\r\n        {\r\n        \tchar err[40];\r\n        \tsprintf(err, \"error initializing spi (%d)\", ret);\r\n\t\t\tmp_raise_msg(&mp_type_OSError, err);\r\n\t\t\treturn;\r\n        }\r\n    }\r\n}", "item_id": 0, "repo": "lewisxhe/MicroPython_ESP32_psRAM_LoBo", "file": "MicroPython_BUILD/components/micropython/esp32/machine_hw_spi.c", "last_update_at": "2020-08-16T04:39:47+00:00", "question_id": "9e9e48b7c876ca573c178dd4fdbdde09cfe16e77_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void machine_hw_spi_init_internal(\r\n    machine_hw_spi_obj_t    *self,\r\n    int8_t                  host,\r\n    int32_t                 baudrate,\r\n    int8_t                  polarity,\r\n    int8_t                  phase,\r\n    int8_t                  firstbit,\r\n    int8_t                  sck,\r\n    int8_t                  mosi,\r\n    int8_t                  miso,\r\n    int8_t                  cs,\r\n    int8_t                  duplex,\r\n\tuint8_t\t\t\t\t\tqueue_size,\r\n\tuint8_t\t\t\t\t\tnew) {\r\n\r\n\r\n    esp_err_t ret;\r\n\r\n    self->state = MACHINE_HW_SPI_STATE_DEINIT;\r\n\r\n\tif ((baudrate <= 0) || (baudrate > 80000000)) {\r\n        mp_raise_ValueError(\"SPI baudrate must be >0 & <=80000000\");\r\n\t}\r\n\r\n\t// Host initialization\r\n\tif ((host != HSPI_HOST) && (host != VSPI_HOST)) {\r\n\t\tmp_raise_ValueError(\"SPI host must be either HSPI(1) or VSPI(2)\");\r\n\t}\r\n\tif ((SPIbus_configs[VSPI_HOST] == NULL) && (host == VSPI_HOST)) {\r\n\t\tmp_raise_ValueError(\"SPI host must be HSPI(1), VSPI(2) used by SPIRAM\");\r\n\t}\r\n\r\n    int used_spi = spi_host_used_by_sdspi();\r\n    if ((used_spi != 0) && (used_spi == host)) {\r\n        // change spi host\r\n        if (host == VSPI_HOST) {\r\n    \t\tmp_raise_ValueError(\"SPI host must be HSPI(1), VSPI(2) used by SDCard driver\");\r\n        }\r\n        else {\r\n    \t\tmp_raise_ValueError(\"SPI host must be VSPI(2), HSPI(1) used by SDCard driver\");\r\n        }\r\n    }\r\n\r\n    self->spi.spihost = host;\r\n    self->spi.buscfg = SPIbus_configs[self->spi.spihost];\r\n\r\n    // Init pins\r\n    if (cs >= 0) {\r\n\t\tgpio_pad_select_gpio(cs);\r\n\t\tgpio_set_direction(cs, GPIO_MODE_OUTPUT);\r\n\t\tgpio_set_level(cs, 1);\r\n    }\r\n    gpio_pad_select_gpio(miso);\r\n    gpio_pad_select_gpio(mosi);\r\n    gpio_pad_select_gpio(sck);\r\n    gpio_set_direction(miso, GPIO_MODE_INPUT);\r\n    gpio_set_pull_mode(miso, GPIO_PULLUP_ONLY);\r\n    gpio_set_direction(mosi, GPIO_MODE_OUTPUT);\r\n    gpio_set_direction(sck, GPIO_MODE_OUTPUT);\r\n\r\n    // Set configuration\r\n    self->polarity = polarity & 1;\r\n    self->phase = phase & 1;\r\n    self->firstbit = firstbit & 1;\r\n    self->duplex = duplex & 1;\r\n\r\n    self->spi.dma_channel = 1;\r\n    self->spi.curr_clock = baudrate;\r\n    self->spi.handle = NULL;\r\n    self->spi.dc = -1;\r\n    self->spi.selected = 0;\r\n    self->spi.cs = cs;\r\n\r\n    self->spi.buscfg->miso_io_num = miso;\r\n    self->spi.buscfg->mosi_io_num = mosi;\r\n    self->spi.buscfg->sclk_io_num = sck;\r\n    self->spi.buscfg->quadwp_io_num = -1;\r\n    self->spi.buscfg->quadhd_io_num = -1;\r\n    //self->spi.buscfg->max_transfer_sz = 6*1024;\r\n\r\n    self->spi.devcfg.clock_speed_hz = self->spi.curr_clock;\r\n    self->spi.devcfg.duty_cycle_pos = 128;\r\n    self->spi.devcfg.mode = self->phase | (self->polarity << 1);\r\n    self->spi.devcfg.spics_io_num = -1;\r\n    self->spi.devcfg.queue_size = queue_size;\r\n    self->spi.devcfg.flags = ((self->firstbit == MICROPY_PY_MACHINE_SPI_LSB) ? SPI_DEVICE_TXBIT_LSBFIRST | SPI_DEVICE_RXBIT_LSBFIRST : 0);\r\n    if (!self->duplex) self->spi.devcfg.flags |= SPI_DEVICE_HALFDUPLEX;\r\n    self->spi.devcfg.pre_cb = NULL;\r\n\r\n\t// ==== Initialize the SPI bus and attach the device ====\r\n\tret = add_extspi_device(&self->spi);\r\n\tif (ret == ESP_OK) {\r\n\t\tret = spi_device_select(&self->spi, 1);\r\n\t\tif (ret != ESP_OK) {\r\n\t        machine_hw_spi_deinit_internal(self);\r\n            mp_raise_msg(&mp_type_OSError, \"Error selecting device\");\r\n\t\t}\r\n\t\tret = spi_device_deselect(&self->spi);\r\n\t\tif (ret != ESP_OK) {\r\n\t        machine_hw_spi_deinit_internal(self);\r\n            mp_raise_msg(&mp_type_OSError, \"Error deselecting device\");\r\n\t\t}\r\n\t    self->state = MACHINE_HW_SPI_STATE_INIT;\r\n\t    return;\r\n\t}\r\n\r\n\tswitch (ret) {\r\n        case ESP_ERR_INVALID_ARG:\r\n            mp_raise_msg(&mp_type_OSError, \"invalid configuration\");\r\n            return;\r\n        case ESP_ERR_INVALID_STATE:\r\n            mp_raise_msg(&mp_type_OSError, \"invalid state\");\r\n            return;\r\n        case ESP_ERR_NO_MEM:\r\n            mp_raise_msg(&mp_type_OSError, \"out of memory\");\r\n            return;\r\n        case ESP_ERR_NOT_FOUND:\r\n            mp_raise_msg(&mp_type_OSError, \"no free slots\");\r\n            return;\r\n        default:\r\n        {\r\n        \tchar err[40];\r\n        \tsprintf(err, \"error initializing spi (%d)\", ret);\r\n\t\t\tmp_raise_msg(&mp_type_OSError, err);\r\n\t\t\treturn;\r\n        }\r\n    }\r\n"]]}
{"hexsha": "df32173c13834578c11e55c786e2bafa580afec2", "ext": "c", "lang": "C", "content": "int32_t\nget_fid(uint32_t inode, uint8_t *buf, uint64_t off)\n{\n\tstruct file_id *fid;\n\n\t/* LINTED */\n\tfid = (struct file_id *)buf;\n\tif ((read_file(inode, buf, sizeof (struct file_id), off)) != 0) {\n\t\treturn (1);\n\t}\n\n\tif (ud_verify_tag(udh, &fid->fid_tag, UD_FILE_ID_DESC, 0, 0, 1) != 0) {\n\t\t(void) fprintf(stdout,\n\t\t\tgettext(\"file_id tag does not verify off %llx\\n\"),\n\t\t\toff);\n\t\treturn (1);\n\t}\n\n\tif ((read_file(inode, buf, FID_LEN(fid), off)) != 0) {\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}", "item_id": 12, "repo": "AsahiOS/gate", "file": "usr/src/cmd/fs.d/udfs/fsdb/fsdb.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "df32173c13834578c11e55c786e2bafa580afec2_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int32_t\nget_fid(uint32_t inode, uint8_t *buf, uint64_t off)\n{\n\tstruct file_id *fid;\n\t/* LINTED */\n\tfid = (struct file_id *)buf;\n\tif ((read_file(inode, buf, sizeof (struct file_id), off)) != 0) {\n\t\treturn (1);\n\t}\n\tif (ud_verify_tag(udh, &fid->fid_tag, UD_FILE_ID_DESC, 0, 0, 1) != 0) {\n\t\t(void) fprintf(stdout,\n\t\t\tgettext(\"file_id tag does not verify off %llx\\n\"),\n\t\t\toff);\n\t\treturn (1);\n\t}\n\tif ((read_file(inode, buf, FID_LEN(fid), off)) != 0) {\n\t\treturn (1);\n\t}\n\treturn (0);\n"]]}
{"hexsha": "a1902895944147d9aa9f47a9a2ded59919142e1e", "ext": "c", "lang": "C", "content": "int cpu_poll_metrics(monikor_t *mon, struct timeval *clock) {\n  float values[NB_CPU_METRICS];\n  int n;\n\n  n = cpu_fetch_metrics(values, NB_CPU_METRICS);\n  for (int i = 0; i < n; i++) {\n    monikor_metric_push(mon, monikor_metric_float(\n      metric_names[i], clock, values[i], MONIKOR_METRIC_TIMEDELTA\n    ));\n  }\n  if (!cpu_fetch_loadavg(mon, clock))\n    n++;\n  return n;\n}", "item_id": 3, "repo": "quanta-computing/monikor", "file": "lib/modules/cpu/poll.c", "last_update_at": "2020-11-25T19:17:48+00:00", "question_id": "a1902895944147d9aa9f47a9a2ded59919142e1e_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int cpu_poll_metrics(monikor_t *mon, struct timeval *clock) {\n  float values[NB_CPU_METRICS];\n  int n;\n  n = cpu_fetch_metrics(values, NB_CPU_METRICS);\n  for (int i = 0; i < n; i++) {\n    monikor_metric_push(mon, monikor_metric_float(\n      metric_names[i], clock, values[i], MONIKOR_METRIC_TIMEDELTA\n    ));\n  }\n  if (!cpu_fetch_loadavg(mon, clock))\n    n++;\n  return n;\n"]]}
{"hexsha": "78be8eadb2ff6f612a9ff5762519c0d8ec2aa1e4", "ext": "c", "lang": "C", "content": "static void cleanUp(LV2UI_Handle handle)\n{\n    NovachordUi* ui = (NovachordUi*) handle;\n    freeResources(&ui->resources);\n    sendUiDisable(ui);\n    gtk_widget_destroy(ui->drawingArea);\n    free(ui);\n}", "item_id": 16, "repo": "Jools64/Hammond-Novachord-LV2-Plugin", "file": "novachord_ui.c", "last_update_at": "2020-04-06T15:23:07+00:00", "question_id": "78be8eadb2ff6f612a9ff5762519c0d8ec2aa1e4_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void cleanUp(LV2UI_Handle handle)\n{\n    NovachordUi* ui = (NovachordUi*) handle;\n    freeResources(&ui->resources);\n    sendUiDisable(ui);\n    gtk_widget_destroy(ui->drawingArea);\n    free(ui);\n"]]}
{"hexsha": "5fe5ea81fc8f6133d33ecd5340974464e314b90a", "ext": "c", "lang": "C", "content": "int\nstrwaitmark(vnode_t *vp)\n{\n\tstruct stdata *stp = vp->v_stream;\n\tqueue_t *rq = _RD(stp->sd_wrq);\n\tint mark;\n\n\tmutex_enter(&stp->sd_lock);\n\twhile (rq->q_first == NULL &&\n\t    !(stp->sd_flag & (STRATMARK|STRNOTATMARK|STREOF))) {\n\t\tstp->sd_flag |= RSLEEP;\n\n\t\t/* Wait for 100 milliseconds for any state change. */\n\t\tif (str_cv_wait(&rq->q_wait, &stp->sd_lock, 100, 1) == -1) {\n\t\t\tmutex_exit(&stp->sd_lock);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\tif (stp->sd_flag & STRATMARK)\n\t\tmark = 1;\n\telse if (rq->q_first != NULL && (rq->q_first->b_flag & MSGMARK))\n\t\tmark = 1;\n\telse\n\t\tmark = 0;\n\n\tmutex_exit(&stp->sd_lock);\n\treturn (mark);\n}", "item_id": 118, "repo": "AsahiOS/gate", "file": "usr/src/uts/common/os/strsubr.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "5fe5ea81fc8f6133d33ecd5340974464e314b90a_118", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nstrwaitmark(vnode_t *vp)\n{\n\tstruct stdata *stp = vp->v_stream;\n\tqueue_t *rq = _RD(stp->sd_wrq);\n\tint mark;\n\tmutex_enter(&stp->sd_lock);\n\twhile (rq->q_first == NULL &&\n\t    !(stp->sd_flag & (STRATMARK|STRNOTATMARK|STREOF))) {\n\t\tstp->sd_flag |= RSLEEP;\n\t\t/* Wait for 100 milliseconds for any state change. */\n\t\tif (str_cv_wait(&rq->q_wait, &stp->sd_lock, 100, 1) == -1) {\n\t\t\tmutex_exit(&stp->sd_lock);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\tif (stp->sd_flag & STRATMARK)\n\t\tmark = 1;\n\telse if (rq->q_first != NULL && (rq->q_first->b_flag & MSGMARK))\n\t\tmark = 1;\n\telse\n\t\tmark = 0;\n\tmutex_exit(&stp->sd_lock);\n\treturn (mark);\n"]]}
{"hexsha": "6622a24ae44729d3d95b6032eec5f63f6f2460db", "ext": "c", "lang": "C", "content": "int main(int argc, char *argv[])\n{\n    int i, j, k;\n    static double a[SIZE][SIZE], b[SIZE][SIZE];\n    double t1, t2, t, ts, tst;\n    double temp;\n    int myrank, mysize, errs = 0;\n    MPI_Status status;\n    MPI_Aint sizeofreal;\n\n    MPI_Datatype col, xpose;\n\n    MTest_Init(&argc, &argv);\n    MPI_Comm_rank(MPI_COMM_WORLD, &myrank);\n    MPI_Comm_size(MPI_COMM_WORLD, &mysize);\n    if (mysize != 2) {\n        fprintf(stderr, \"This test must be run with 2 processes\\n\");\n        MPI_Abort(MPI_COMM_WORLD, 1);\n    }\n\n    MPI_Type_extent(MPI_DOUBLE, &sizeofreal);\n\n    MPI_Type_vector(SIZE, 1, SIZE, MPI_DOUBLE, &col);\n    MPI_Type_hvector(SIZE, 1, sizeofreal, col, &xpose);\n    MPI_Type_commit(&xpose);\n\n    /* Preset the arrays so that they're in memory */\n    for (i = 0; i < SIZE; i++)\n        for (j = 0; j < SIZE; j++) {\n            a[i][j] = 0;\n            b[i][j] = 0;\n        }\n    a[SIZE - 1][0] = 1;\n\n    /* Time the transpose example */\n    MPI_Barrier(MPI_COMM_WORLD);\n    t1 = MPI_Wtime();\n    for (i = 0; i < ITER; i++) {\n        if (myrank == 0)\n            MPI_Send(&a[0][0], SIZE * SIZE, MPI_DOUBLE, 1, 0, MPI_COMM_WORLD);\n        else\n            MPI_Recv(&b[0][0], 1, xpose, 0, 0, MPI_COMM_WORLD, &status);\n    }\n    t2 = MPI_Wtime();\n    t = (t2 - t1) / ITER;\n\n    /* Time sending the same amount of data, but without the transpose */\n    MPI_Barrier(MPI_COMM_WORLD);\n    t1 = MPI_Wtime();\n    for (i = 0; i < ITER; i++) {\n        if (myrank == 0) {\n            MPI_Send(&a[0][0], sizeof(a), MPI_BYTE, 1, 0, MPI_COMM_WORLD);\n        } else {\n            MPI_Recv(&b[0][0], sizeof(b), MPI_BYTE, 0, 0, MPI_COMM_WORLD, &status);\n        }\n    }\n    t2 = MPI_Wtime();\n    ts = (t2 - t1) / ITER;\n\n    /* Time sending the same amount of data, with the transpose done\n     * as a separate step */\n    MPI_Barrier(MPI_COMM_WORLD);\n    t1 = MPI_Wtime();\n    for (k = 0; k < ITER; k++) {\n        if (myrank == 0) {\n            MPI_Send(&a[0][0], sizeof(a), MPI_BYTE, 1, 0, MPI_COMM_WORLD);\n        } else {\n            MPI_Recv(&b[0][0], sizeof(b), MPI_BYTE, 0, 0, MPI_COMM_WORLD, &status);\n            for (i = 0; i < SIZE; i++)\n                for (j = i; j < SIZE; j++) {\n                    temp = b[j][i];\n                    b[j][i] = b[i][j];\n                    b[i][j] = temp;\n                }\n        }\n    }\n    t2 = MPI_Wtime();\n    tst = (t2 - t1) / ITER;\n\n    /* Print out the results */\n    if (myrank == 1) {\n        /* if t and tst are too different, then there is a performance\n         * problem in the handling of the datatypes */\n\n        if (t > 2 * tst) {\n            errs++;\n            fprintf(stderr,\n                    \"Transpose time with datatypes is more than twice time without datatypes\\n\");\n            fprintf(stderr, \"%f\\t%f\\t%f\\n\", t, ts, tst);\n        }\n    }\n\n    MPI_Type_free(&col);\n    MPI_Type_free(&xpose);\n\n    MTest_Finalize(errs);\n    return MTestReturnValue(errs);\n}", "item_id": 0, "repo": "ucd-plse/mpi-error-prop", "file": "mpich-3.3/test/mpi/perf/transp_datatype.c", "last_update_at": "2020-07-17T04:14:25+00:00", "question_id": "6622a24ae44729d3d95b6032eec5f63f6f2460db_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char *argv[])\n{\n    int i, j, k;\n    static double a[SIZE][SIZE], b[SIZE][SIZE];\n    double t1, t2, t, ts, tst;\n    double temp;\n    int myrank, mysize, errs = 0;\n    MPI_Status status;\n    MPI_Aint sizeofreal;\n    MPI_Datatype col, xpose;\n    MTest_Init(&argc, &argv);\n    MPI_Comm_rank(MPI_COMM_WORLD, &myrank);\n    MPI_Comm_size(MPI_COMM_WORLD, &mysize);\n    if (mysize != 2) {\n        fprintf(stderr, \"This test must be run with 2 processes\\n\");\n        MPI_Abort(MPI_COMM_WORLD, 1);\n    }\n    MPI_Type_extent(MPI_DOUBLE, &sizeofreal);\n    MPI_Type_vector(SIZE, 1, SIZE, MPI_DOUBLE, &col);\n    MPI_Type_hvector(SIZE, 1, sizeofreal, col, &xpose);\n    MPI_Type_commit(&xpose);\n    /* Preset the arrays so that they're in memory */\n    for (i = 0; i < SIZE; i++)\n        for (j = 0; j < SIZE; j++) {\n            a[i][j] = 0;\n            b[i][j] = 0;\n        }\n    a[SIZE - 1][0] = 1;\n    /* Time the transpose example */\n    MPI_Barrier(MPI_COMM_WORLD);\n    t1 = MPI_Wtime();\n    for (i = 0; i < ITER; i++) {\n        if (myrank == 0)\n            MPI_Send(&a[0][0], SIZE * SIZE, MPI_DOUBLE, 1, 0, MPI_COMM_WORLD);\n        else\n            MPI_Recv(&b[0][0], 1, xpose, 0, 0, MPI_COMM_WORLD, &status);\n    }\n    t2 = MPI_Wtime();\n    t = (t2 - t1) / ITER;\n    /* Time sending the same amount of data, but without the transpose */\n    MPI_Barrier(MPI_COMM_WORLD);\n    t1 = MPI_Wtime();\n    for (i = 0; i < ITER; i++) {\n        if (myrank == 0) {\n            MPI_Send(&a[0][0], sizeof(a), MPI_BYTE, 1, 0, MPI_COMM_WORLD);\n        } else {\n            MPI_Recv(&b[0][0], sizeof(b), MPI_BYTE, 0, 0, MPI_COMM_WORLD, &status);\n        }\n    }\n    t2 = MPI_Wtime();\n    ts = (t2 - t1) / ITER;\n    /* Time sending the same amount of data, with the transpose done\n     * as a separate step */\n    MPI_Barrier(MPI_COMM_WORLD);\n    t1 = MPI_Wtime();\n    for (k = 0; k < ITER; k++) {\n        if (myrank == 0) {\n            MPI_Send(&a[0][0], sizeof(a), MPI_BYTE, 1, 0, MPI_COMM_WORLD);\n        } else {\n            MPI_Recv(&b[0][0], sizeof(b), MPI_BYTE, 0, 0, MPI_COMM_WORLD, &status);\n            for (i = 0; i < SIZE; i++)\n                for (j = i; j < SIZE; j++) {\n                    temp = b[j][i];\n                    b[j][i] = b[i][j];\n                    b[i][j] = temp;\n                }\n        }\n    }\n    t2 = MPI_Wtime();\n    tst = (t2 - t1) / ITER;\n    /* Print out the results */\n    if (myrank == 1) {\n        /* if t and tst are too different, then there is a performance\n         * problem in the handling of the datatypes */\n        if (t > 2 * tst) {\n            errs++;\n            fprintf(stderr,\n                    \"Transpose time with datatypes is more than twice time without datatypes\\n\");\n            fprintf(stderr, \"%f\\t%f\\t%f\\n\", t, ts, tst);\n        }\n    }\n    MPI_Type_free(&col);\n    MPI_Type_free(&xpose);\n    MTest_Finalize(errs);\n    return MTestReturnValue(errs);\n"]]}
{"hexsha": "54551954d929c6c244701120d5a73ccb730787f0", "ext": "c", "lang": "C", "content": "static void *listener(void *arg)\n{\n\tstruct listener *me = (struct listener *)arg;\n\tint numOutBufs = 0;\n\tint nErr = 0;\n\tadsp_listener_invoke_ctx ctx = 0;\n\tstruct invoke_bufs *bufs = 0;\n\tboolean bNeedMore;\n\tint result = -1;\n\tadsp_listener_remote_handle handle;\n\tuint32 sc, ii, inBufsAllocated = 0;\n\tconst char *eheap = getenv(\"ADSP_LISTENER_HEAP_ID\");\n\tint heapid = eheap == 0 ? -1 : atoi(eheap);\n\tconst char *eflags = getenv(\"ADSP_LISTENER_HEAP_FLAGS\");\n\tuint32 flags = eflags == 0 ? 0 : atoi(eflags);\n\teventfd_t event = 0xff;\n\n\tVERIFY_EPRINTF(\"listener using ion heap: %d\\n\", heapid);\n\n\tVERIFY(0 != (bufs = rpcmem_realloc(heapid, flags, 0, 0, sizeof(*bufs))));\n\tmemset(bufs, 0, sizeof(*bufs));\n\n\tdo\n\t{\ninvoke:\n\t\tbNeedMore = FALSE;\n\t\tsc = 0xffffffff;\n\t\tif (result != 0)\n\t\t{\n\t\t\tnumOutBufs = 0;\n\t\t}\n\t\tnErr = __QAIC_HEADER(adsp_listener_next_invoke)(\n\t\t           ctx, result, bufs->outbufs, numOutBufs, &ctx,\n\t\t           &handle, &sc, bufs->inbufs, inBufsAllocated,\n\t\t           bufs->inbufLenReqs, MAX_BUFS, bufs->outbufLenReqs, MAX_BUFS);\n\t\tif (nErr)\n\t\t{\n\t\t\tVERIFY_EPRINTF(\"listener protocol failure %d\\n\", nErr);\n\t\t\tVERIFY(0 == (nErr = __QAIC_HEADER(adsp_listener_next_invoke)(\n\t\t\t                        ctx, nErr, 0, 0, &ctx,\n\t\t\t                        &handle, &sc, bufs->inbufs, inBufsAllocated,\n\t\t\t                        bufs->inbufLenReqs, MAX_BUFS, bufs->outbufLenReqs, MAX_BUFS)));\n\t\t}\n\n\t\tif (MAX_BUFS < REMOTE_SCALARS_INBUFS(sc) || MAX_BUFS < REMOTE_SCALARS_OUTBUFS(sc))\n\t\t{\n\t\t\tresult = - 8;\n\t\t\tgoto invoke;\n\t\t}\n\t\tfor (ii = 0; ii < REMOTE_SCALARS_INBUFS(sc); ++ii)\n\t\t{\n\t\t\tif (bufs->inbufs[ii].dataLen < bufs->inbufLenReqs[ii])\n\t\t\t{\n\t\t\t\tif (0 != bufs->inbufLenReqs[ii])\n\t\t\t\t{\n\t\t\t\t\tbufs->inbufs[ii].data = rpcmem_realloc(heapid, flags, bufs->inbufs[ii].data,  bufs->inbufs[ii].dataLen, bufs->inbufLenReqs[ii]);\n\t\t\t\t\tif (0 == bufs->inbufs[ii].data)\n\t\t\t\t\t{\n\t\t\t\t\t\tbufs->inbufs[ii].dataLen = 0;\n\t\t\t\t\t\tresult = -8;\n\t\t\t\t\t\tgoto invoke;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbufs->inbufs[ii].dataLen = bufs->inbufLenReqs[ii];\n\t\t\t\tinBufsAllocated = STD_MAX(inBufsAllocated, ii + 1);\n\t\t\t\tbNeedMore = TRUE;\n\t\t\t}\n\t\t\tbufs->args[ii].buf.pv = bufs->inbufs[ii].data;\n\t\t\tbufs->args[ii].buf.nLen = bufs->inbufLenReqs[ii];\n\t\t}\n\t\tfor (ii = 0; ii < REMOTE_SCALARS_OUTBUFS(sc); ++ii)\n\t\t{\n\t\t\tif (bufs->outbufs[ii].dataLen < bufs->outbufLenReqs[ii])\n\t\t\t{\n\t\t\t\tif (0 !=  bufs->outbufLenReqs[ii])\n\t\t\t\t{\n\t\t\t\t\tbufs->outbufs[ii].data = rpcmem_realloc(heapid, flags, bufs->outbufs[ii].data, bufs->outbufs[ii].dataLen, bufs->outbufLenReqs[ii]);\n\t\t\t\t\tif (0 == bufs->outbufs[ii].data)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = -8;\n\t\t\t\t\t\tgoto invoke;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbufs->outbufs[ii].dataLen = bufs->outbufLenReqs[ii];\n\t\t\t}\n\t\t\tbufs->args[ii + REMOTE_SCALARS_INBUFS(sc)].buf.pv = bufs->outbufs[ii].data;\n\t\t\tbufs->args[ii + REMOTE_SCALARS_INBUFS(sc)].buf.nLen = bufs->outbufLenReqs[ii];\n\t\t}\n\t\tnumOutBufs = REMOTE_SCALARS_OUTBUFS(sc);\n\t\tif (bNeedMore)\n\t\t{\n\t\t\tassert(inBufsAllocated >= REMOTE_SCALARS_INBUFS(sc));\n\t\t\tif (0 != (result = __QAIC_HEADER(adsp_listener_invoke_get_in_bufs)(ctx, bufs->inbufs,\n\t\t\t                   REMOTE_SCALARS_INBUFS(sc))))\n\t\t\t{\n\t\t\t\tVERIFY_EPRINTF(\"adsp_listener_invoke_get_in_bufs failed  %d\\n\", result);\n\t\t\t\tgoto invoke;\n\t\t\t}\n\t\t}\n\n\t\tresult = mod_table_handle_invoke(&me->mt, handle, sc, bufs->args);\n\t}\n\twhile (1);\nbail:\n\tfor (ii = 0; ii < MAX_BUFS && bufs; ++ii)\n\t{\n\t\tRPC_FREEIF(heapid, bufs->outbufs[ii].data);\n\t\tRPC_FREEIF(heapid, bufs->inbufs[ii].data);\n\t}\n\tRPC_FREEIF(heapid, bufs);\n\tif (nErr)\n\t{\n\t\tVERIFY_EPRINTF(\"listener thread exiting with code %d\\n\", nErr);\n\t\tif (0 != adsp_current_process_exit())\n\t\t{\n\t\t\tVERIFY_EPRINTF(\"listener thread failed to cleanly shutdown.  This is ok durring process exit.\\n\");\n\t\t}\n\t}\n\teventfd_write(me->eventfd, event);\n\treturn (void *)(uintptr_t)nErr;\n}", "item_id": 1, "repo": "Najon/libadsprpc", "file": "src/lib/listener.c", "last_update_at": "2020-11-12T00:07:47+00:00", "question_id": "54551954d929c6c244701120d5a73ccb730787f0_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void *listener(void *arg)\n{\n\tstruct listener *me = (struct listener *)arg;\n\tint numOutBufs = 0;\n\tint nErr = 0;\n\tadsp_listener_invoke_ctx ctx = 0;\n\tstruct invoke_bufs *bufs = 0;\n\tboolean bNeedMore;\n\tint result = -1;\n\tadsp_listener_remote_handle handle;\n\tuint32 sc, ii, inBufsAllocated = 0;\n\tconst char *eheap = getenv(\"ADSP_LISTENER_HEAP_ID\");\n\tint heapid = eheap == 0 ? -1 : atoi(eheap);\n\tconst char *eflags = getenv(\"ADSP_LISTENER_HEAP_FLAGS\");\n\tuint32 flags = eflags == 0 ? 0 : atoi(eflags);\n\teventfd_t event = 0xff;\n\tVERIFY_EPRINTF(\"listener using ion heap: %d\\n\", heapid);\n\tVERIFY(0 != (bufs = rpcmem_realloc(heapid, flags, 0, 0, sizeof(*bufs))));\n\tmemset(bufs, 0, sizeof(*bufs));\n\tdo\n\t{\ninvoke:\n\t\tbNeedMore = FALSE;\n\t\tsc = 0xffffffff;\n\t\tif (result != 0)\n\t\t{\n\t\t\tnumOutBufs = 0;\n\t\t}\n\t\tnErr = __QAIC_HEADER(adsp_listener_next_invoke)(\n\t\t           ctx, result, bufs->outbufs, numOutBufs, &ctx,\n\t\t           &handle, &sc, bufs->inbufs, inBufsAllocated,\n\t\t           bufs->inbufLenReqs, MAX_BUFS, bufs->outbufLenReqs, MAX_BUFS);\n\t\tif (nErr)\n\t\t{\n\t\t\tVERIFY_EPRINTF(\"listener protocol failure %d\\n\", nErr);\n\t\t\tVERIFY(0 == (nErr = __QAIC_HEADER(adsp_listener_next_invoke)(\n\t\t\t                        ctx, nErr, 0, 0, &ctx,\n\t\t\t                        &handle, &sc, bufs->inbufs, inBufsAllocated,\n\t\t\t                        bufs->inbufLenReqs, MAX_BUFS, bufs->outbufLenReqs, MAX_BUFS)));\n\t\t}\n\t\tif (MAX_BUFS < REMOTE_SCALARS_INBUFS(sc) || MAX_BUFS < REMOTE_SCALARS_OUTBUFS(sc))\n\t\t{\n\t\t\tresult = - 8;\n\t\t\tgoto invoke;\n\t\t}\n\t\tfor (ii = 0; ii < REMOTE_SCALARS_INBUFS(sc); ++ii)\n\t\t{\n\t\t\tif (bufs->inbufs[ii].dataLen < bufs->inbufLenReqs[ii])\n\t\t\t{\n\t\t\t\tif (0 != bufs->inbufLenReqs[ii])\n\t\t\t\t{\n\t\t\t\t\tbufs->inbufs[ii].data = rpcmem_realloc(heapid, flags, bufs->inbufs[ii].data,  bufs->inbufs[ii].dataLen, bufs->inbufLenReqs[ii]);\n\t\t\t\t\tif (0 == bufs->inbufs[ii].data)\n\t\t\t\t\t{\n\t\t\t\t\t\tbufs->inbufs[ii].dataLen = 0;\n\t\t\t\t\t\tresult = -8;\n\t\t\t\t\t\tgoto invoke;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbufs->inbufs[ii].dataLen = bufs->inbufLenReqs[ii];\n\t\t\t\tinBufsAllocated = STD_MAX(inBufsAllocated, ii + 1);\n\t\t\t\tbNeedMore = TRUE;\n\t\t\t}\n\t\t\tbufs->args[ii].buf.pv = bufs->inbufs[ii].data;\n\t\t\tbufs->args[ii].buf.nLen = bufs->inbufLenReqs[ii];\n\t\t}\n\t\tfor (ii = 0; ii < REMOTE_SCALARS_OUTBUFS(sc); ++ii)\n\t\t{\n\t\t\tif (bufs->outbufs[ii].dataLen < bufs->outbufLenReqs[ii])\n\t\t\t{\n\t\t\t\tif (0 !=  bufs->outbufLenReqs[ii])\n\t\t\t\t{\n\t\t\t\t\tbufs->outbufs[ii].data = rpcmem_realloc(heapid, flags, bufs->outbufs[ii].data, bufs->outbufs[ii].dataLen, bufs->outbufLenReqs[ii]);\n\t\t\t\t\tif (0 == bufs->outbufs[ii].data)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = -8;\n\t\t\t\t\t\tgoto invoke;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbufs->outbufs[ii].dataLen = bufs->outbufLenReqs[ii];\n\t\t\t}\n\t\t\tbufs->args[ii + REMOTE_SCALARS_INBUFS(sc)].buf.pv = bufs->outbufs[ii].data;\n\t\t\tbufs->args[ii + REMOTE_SCALARS_INBUFS(sc)].buf.nLen = bufs->outbufLenReqs[ii];\n\t\t}\n\t\tnumOutBufs = REMOTE_SCALARS_OUTBUFS(sc);\n\t\tif (bNeedMore)\n\t\t{\n\t\t\tassert(inBufsAllocated >= REMOTE_SCALARS_INBUFS(sc));\n\t\t\tif (0 != (result = __QAIC_HEADER(adsp_listener_invoke_get_in_bufs)(ctx, bufs->inbufs,\n\t\t\t                   REMOTE_SCALARS_INBUFS(sc))))\n\t\t\t{\n\t\t\t\tVERIFY_EPRINTF(\"adsp_listener_invoke_get_in_bufs failed  %d\\n\", result);\n\t\t\t\tgoto invoke;\n\t\t\t}\n\t\t}\n\t\tresult = mod_table_handle_invoke(&me->mt, handle, sc, bufs->args);\n\t}\n\twhile (1);\nbail:\n\tfor (ii = 0; ii < MAX_BUFS && bufs; ++ii)\n\t{\n\t\tRPC_FREEIF(heapid, bufs->outbufs[ii].data);\n\t\tRPC_FREEIF(heapid, bufs->inbufs[ii].data);\n\t}\n\tRPC_FREEIF(heapid, bufs);\n\tif (nErr)\n\t{\n\t\tVERIFY_EPRINTF(\"listener thread exiting with code %d\\n\", nErr);\n\t\tif (0 != adsp_current_process_exit())\n\t\t{\n\t\t\tVERIFY_EPRINTF(\"listener thread failed to cleanly shutdown.  This is ok durring process exit.\\n\");\n\t\t}\n\t}\n\teventfd_write(me->eventfd, event);\n\treturn (void *)(uintptr_t)nErr;\n"]]}
{"hexsha": "17caec855283f21680b49a0dac914639d23f0b63", "ext": "c", "lang": "C", "content": "int getport(char *str)\n{\n  char *bad;\n  int port;\n  if(!*str) return -1;\n  if(str[0] == '-')\n  {\n    if(str[1] != 0) return -1;\n    return 0;\n  }\n  port = (int)strtol(str,&bad,10);\n  if(*bad) return -1;\n  return port;\n}", "item_id": 0, "repo": "imont/telehash-c", "file": "util/port.c", "last_update_at": "2020-06-02T02:15:06+00:00", "question_id": "17caec855283f21680b49a0dac914639d23f0b63_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int getport(char *str)\n{\n  char *bad;\n  int port;\n  if(!*str) return -1;\n  if(str[0] == '-')\n  {\n    if(str[1] != 0) return -1;\n    return 0;\n  }\n  port = (int)strtol(str,&bad,10);\n  if(*bad) return -1;\n  return port;\n"]]}
{"hexsha": "aaf0de2dc4f840dc4c8c310c02b14d1cbc3c8bfc", "ext": "c", "lang": "C", "content": "static char\t\t*do_if_ok(t_byte len, int n)\n{\n\tchar\tsign;\n\tchar\t*res;\n\n\twhile (n / power_ten(len) / 10 != 0)\n\t\tlen++;\n\tsign = n < 0 ? -1 : 1;\n\tlen = len + (sign == -1 ? 1 : 0) + 1;\n\tres = (char*)malloc(sizeof(char) * (len + 1));\n\tif (res == 0)\n\t\treturn (0);\n\tres[len] = '\\0';\n\twhile (n != 0)\n\t{\n\t\tres[len - 1] = n % 10 * (sign == -1 ? -1 : 1) + '0';\n\t\tn = n / 10;\n\t\tlen--;\n\t}\n\tres[0] = sign == -1 ? '-' : res[0];\n\treturn (res);\n}", "item_id": 0, "repo": "Aenstein/libft", "file": "src/atoi_itoa/ft_itoa.c", "last_update_at": "2020-08-11T14:21:07+00:00", "question_id": "aaf0de2dc4f840dc4c8c310c02b14d1cbc3c8bfc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static char\t\t*do_if_ok(t_byte len, int n)\n{\n\tchar\tsign;\n\tchar\t*res;\n\twhile (n / power_ten(len) / 10 != 0)\n\t\tlen++;\n\tsign = n < 0 ? -1 : 1;\n\tlen = len + (sign == -1 ? 1 : 0) + 1;\n\tres = (char*)malloc(sizeof(char) * (len + 1));\n\tif (res == 0)\n\t\treturn (0);\n\tres[len] = '\\0';\n\twhile (n != 0)\n\t{\n\t\tres[len - 1] = n % 10 * (sign == -1 ? -1 : 1) + '0';\n\t\tn = n / 10;\n\t\tlen--;\n\t}\n\tres[0] = sign == -1 ? '-' : res[0];\n\treturn (res);\n"]]}
{"hexsha": "ca3b010c95c61a0a5d68e14dba7c22c32bfacead", "ext": "c", "lang": "C", "content": "int sde_rotator_session_validate(struct sde_rot_mgr *mgr,\n\tstruct sde_rot_file_private *private,\n\tstruct sde_rotation_config *config)\n{\n\tint ret;\n\n\tif (!mgr || !private || !config) {\n\t\tSDEROT_ERR(\"null parameters\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tSDEROT_DBG(\n\t\t\"validate session id=%u in{%u,%u}f:%x out{%u,%u}f:%x fps:%d\\n\",\n\t\tconfig->session_id, config->input.width, config->input.height,\n\t\tconfig->input.format, config->output.width,\n\t\tconfig->output.height, config->output.format,\n\t\tconfig->frame_rate);\n\n\tret = sde_rotator_verify_config_all(mgr, config);\n\tif (ret) {\n\t\tSDEROT_WARN(\"rotator verify format failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (config->output.sbuf && mgr->sbuf_ctx != private && mgr->sbuf_ctx) {\n\t\tSDEROT_WARN(\"too many sbuf sessions\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}", "item_id": 94, "repo": "wqk317/mi8_kernel_source", "file": "dipper/drivers/media/platform/msm/sde/rotator/sde_rotator_core.c", "last_update_at": "2020-03-28T11:26:15+00:00", "question_id": "ca3b010c95c61a0a5d68e14dba7c22c32bfacead_94", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int sde_rotator_session_validate(struct sde_rot_mgr *mgr,\n\tstruct sde_rot_file_private *private,\n\tstruct sde_rotation_config *config)\n{\n\tint ret;\n\tif (!mgr || !private || !config) {\n\t\tSDEROT_ERR(\"null parameters\\n\");\n\t\treturn -EINVAL;\n\t}\n\tSDEROT_DBG(\n\t\t\"validate session id=%u in{%u,%u}f:%x out{%u,%u}f:%x fps:%d\\n\",\n\t\tconfig->session_id, config->input.width, config->input.height,\n\t\tconfig->input.format, config->output.width,\n\t\tconfig->output.height, config->output.format,\n\t\tconfig->frame_rate);\n\tret = sde_rotator_verify_config_all(mgr, config);\n\tif (ret) {\n\t\tSDEROT_WARN(\"rotator verify format failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (config->output.sbuf && mgr->sbuf_ctx != private && mgr->sbuf_ctx) {\n\t\tSDEROT_WARN(\"too many sbuf sessions\\n\");\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n"]]}
{"hexsha": "2efed89f567820318e35204fa1f44ec3e47dd7aa", "ext": "c", "lang": "C", "content": "int main (int argc, char * argv[]) {\n  // crete folders to write results\n  system(\"mkdir -p vtu\");\n  system(\"mkdir -p plic\");\n  system(\"mkdir -p dump\");\n  maxruntime (&argc, argv);\n  if (argc > 1)\n    LEVEL = atoi (argv[1]);\n  if (argc > 2)\n    Bo = atof(argv[2]);\n  if (argc > 3)\n    Ga = atof(argv[3]);\n  size (WIDTH);\n  origin (0, 0);\n  init_grid (128);\n  rho1 = 1.0;\n  rho2 = 1.0/RHOR;\n  mu1 = 1.0/Ga;\n  mu2 = 1.0/(MUR*Ga);\n  f.sigma = 1.0/Bo;\n  TOLERANCE = 1e-4;\n  run();\n}", "item_id": 0, "repo": "AndreWeiner/hybrid_approach_species", "file": "basilisk_solver/bubble_axis_symmetric.c", "last_update_at": "2020-09-23T18:02:16+00:00", "question_id": "2efed89f567820318e35204fa1f44ec3e47dd7aa_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main (int argc, char * argv[]) {\n  // crete folders to write results\n  system(\"mkdir -p vtu\");\n  system(\"mkdir -p plic\");\n  system(\"mkdir -p dump\");\n  maxruntime (&argc, argv);\n  if (argc > 1)\n    LEVEL = atoi (argv[1]);\n  if (argc > 2)\n    Bo = atof(argv[2]);\n  if (argc > 3)\n    Ga = atof(argv[3]);\n  size (WIDTH);\n  origin (0, 0);\n  init_grid (128);\n  rho1 = 1.0;\n  rho2 = 1.0/RHOR;\n  mu1 = 1.0/Ga;\n  mu2 = 1.0/(MUR*Ga);\n  f.sigma = 1.0/Bo;\n  TOLERANCE = 1e-4;\n  run();\n"]]}
{"hexsha": "837d3cb4a8053195e0a2c840183a1938eac444e4", "ext": "c", "lang": "C", "content": "static char *get_timestamp(char *buf, int len, time_t cur_time)\n{\n    struct tm tm_time;\n\n    localtime_r(&cur_time, &tm_time);\n\n    snprintf(buf, len, \"%d-%d-%d %d:%d:%d\",\n             1900 + tm_time.tm_year, 1 + tm_time.tm_mon,\n             tm_time.tm_mday, tm_time.tm_hour,\n             tm_time.tm_min, tm_time.tm_sec);\n    return buf;\n}", "item_id": 0, "repo": "allentree/LoRaGW-SDK", "file": "libraries/libalilog/log.c", "last_update_at": "2020-07-09T06:42:54+00:00", "question_id": "837d3cb4a8053195e0a2c840183a1938eac444e4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static char *get_timestamp(char *buf, int len, time_t cur_time)\n{\n    struct tm tm_time;\n    localtime_r(&cur_time, &tm_time);\n    snprintf(buf, len, \"%d-%d-%d %d:%d:%d\",\n             1900 + tm_time.tm_year, 1 + tm_time.tm_mon,\n             tm_time.tm_mday, tm_time.tm_hour,\n             tm_time.tm_min, tm_time.tm_sec);\n    return buf;\n"]]}
{"hexsha": "9a6f8b09de7717c3143d16d83c2a66fa4f94ff69", "ext": "c", "lang": "C", "content": "void SomaInsere(celula *lst){\n\tcelula *p, *soma;\n\t\n\tsoma = malloc(sizeof(celula));\n\t\n\tp = lst->seg;\t\n\t\n\toma->conteudo = (p->conteudo)+(p->seg->conteudo);\n\tsoma->seg = NULL;\t\n\t\n\twhile (p->seg != NULL) p = p->seg;\n\t\n\tp->seg = soma;\t\n}", "item_id": 2, "repo": "andersonsilvade/python_C", "file": "Dev-Cpp/Estrutura de Dados/Lista 2/exe2.c", "last_update_at": "2020-11-04T08:36:28+00:00", "question_id": "9a6f8b09de7717c3143d16d83c2a66fa4f94ff69_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void SomaInsere(celula *lst){\n\tcelula *p, *soma;\n\t\n\tsoma = malloc(sizeof(celula));\n\t\n\tp = lst->seg;\t\n\t\n\toma->conteudo = (p->conteudo)+(p->seg->conteudo);\n\tsoma->seg = NULL;\t\n\t\n\twhile (p->seg != NULL) p = p->seg;\n\t\n\tp->seg = soma;\t\n"]]}
{"hexsha": "9b397418e51039d234ab999c52e3425c9d1b888a", "ext": "c", "lang": "C", "content": "static int row_get_ioprio_class_to_serve(struct row_data *rd, int force)\n{\n\tint i;\n\tint ret = IOPRIO_CLASS_NONE;\n\n\tif (!rd->nr_reqs[READ] && !rd->nr_reqs[WRITE]) {\n\t\trow_log(rd->dispatch_queue, \"No more requests in scheduler\");\n\t\tgoto check_idling;\n\t}\n\n\t/* First, go over the high priority queues */\n\tfor (i = 0; i < ROWQ_REG_PRIO_IDX; i++) {\n\t\tif (!list_empty(&rd->row_queues[i].fifo)) {\n\t\t\tif (hrtimer_active(&rd->rd_idle_data.hr_timer)) {\n\t\t\t\tif (hrtimer_try_to_cancel(\n\t\t\t\t\t&rd->rd_idle_data.hr_timer) >= 0) {\n\t\t\t\t\trow_log(rd->dispatch_queue,\n\t\t\t\t\t\"Canceling delayed work on %d. RT pending\",\n\t\t\t\t\t     rd->rd_idle_data.idling_queue_idx);\n\t\t\t\t\trd->rd_idle_data.idling_queue_idx =\n\t\t\t\t\t\tROWQ_MAX_PRIO;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (row_regular_req_pending(rd) &&\n\t\t\t    (rd->reg_prio_starvation.starvation_counter >=\n\t\t\t     rd->reg_prio_starvation.starvation_limit))\n\t\t\t\tret = IOPRIO_CLASS_BE;\n\t\t\telse if (row_low_req_pending(rd) &&\n\t\t\t    (rd->low_prio_starvation.starvation_counter >=\n\t\t\t     rd->low_prio_starvation.starvation_limit))\n\t\t\t\tret = IOPRIO_CLASS_IDLE;\n\t\t\telse\n\t\t\t\tret = IOPRIO_CLASS_RT;\n\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/*\n\t * At the moment idling is implemented only for READ queues.\n\t * If enabled on WRITE, this needs updating\n\t */\n\tif (hrtimer_active(&rd->rd_idle_data.hr_timer)) {\n\t\trow_log(rd->dispatch_queue, \"Delayed work pending. Exiting\");\n\t\tgoto done;\n\t}\ncheck_idling:\n\t/* Check for (high priority) idling and enable if needed */\n\tfor (i = 0; i < ROWQ_REG_PRIO_IDX && !force; i++) {\n\t\tif (rd->row_queues[i].idle_data.begin_idling &&\n\t\t    row_queues_def[i].idling_enabled)\n\t\t\tgoto initiate_idling;\n\t}\n\n\t/* Regular priority queues */\n\tfor (i = ROWQ_REG_PRIO_IDX; i < ROWQ_LOW_PRIO_IDX; i++) {\n\t\tif (list_empty(&rd->row_queues[i].fifo)) {\n\t\t\t/* We can idle only if this is not a forced dispatch */\n\t\t\tif (rd->row_queues[i].idle_data.begin_idling &&\n\t\t\t    !force && row_queues_def[i].idling_enabled)\n\t\t\t\tgoto initiate_idling;\n\t\t} else {\n\t\t\tif (row_low_req_pending(rd) &&\n\t\t\t    (rd->low_prio_starvation.starvation_counter >=\n\t\t\t     rd->low_prio_starvation.starvation_limit))\n\t\t\t\tret = IOPRIO_CLASS_IDLE;\n\t\t\telse\n\t\t\t\tret = IOPRIO_CLASS_BE;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (rd->nr_reqs[READ] || rd->nr_reqs[WRITE])\n\t\tret = IOPRIO_CLASS_IDLE;\n\tgoto done;\n\ninitiate_idling:\n\thrtimer_start(&rd->rd_idle_data.hr_timer,\n\t\tktime_set(0, rd->rd_idle_data.idle_time_ms * NSEC_PER_MSEC),\n\t\tHRTIMER_MODE_REL);\n\n\trd->rd_idle_data.idling_queue_idx = i;\n\trow_log_rowq(rd, i, \"Scheduled delayed work on %d. exiting\", i);\n\ndone:\n\treturn ret;\n}", "item_id": 11, "repo": "Uswer/LineageOS-14.1_jag3gds", "file": "kernel/lge/msm8226/block/row-iosched.c", "last_update_at": "2020-06-01T10:53:47+00:00", "question_id": "9b397418e51039d234ab999c52e3425c9d1b888a_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int row_get_ioprio_class_to_serve(struct row_data *rd, int force)\n{\n\tint i;\n\tint ret = IOPRIO_CLASS_NONE;\n\tif (!rd->nr_reqs[READ] && !rd->nr_reqs[WRITE]) {\n\t\trow_log(rd->dispatch_queue, \"No more requests in scheduler\");\n\t\tgoto check_idling;\n\t}\n\t/* First, go over the high priority queues */\n\tfor (i = 0; i < ROWQ_REG_PRIO_IDX; i++) {\n\t\tif (!list_empty(&rd->row_queues[i].fifo)) {\n\t\t\tif (hrtimer_active(&rd->rd_idle_data.hr_timer)) {\n\t\t\t\tif (hrtimer_try_to_cancel(\n\t\t\t\t\t&rd->rd_idle_data.hr_timer) >= 0) {\n\t\t\t\t\trow_log(rd->dispatch_queue,\n\t\t\t\t\t\"Canceling delayed work on %d. RT pending\",\n\t\t\t\t\t     rd->rd_idle_data.idling_queue_idx);\n\t\t\t\t\trd->rd_idle_data.idling_queue_idx =\n\t\t\t\t\t\tROWQ_MAX_PRIO;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (row_regular_req_pending(rd) &&\n\t\t\t    (rd->reg_prio_starvation.starvation_counter >=\n\t\t\t     rd->reg_prio_starvation.starvation_limit))\n\t\t\t\tret = IOPRIO_CLASS_BE;\n\t\t\telse if (row_low_req_pending(rd) &&\n\t\t\t    (rd->low_prio_starvation.starvation_counter >=\n\t\t\t     rd->low_prio_starvation.starvation_limit))\n\t\t\t\tret = IOPRIO_CLASS_IDLE;\n\t\t\telse\n\t\t\t\tret = IOPRIO_CLASS_RT;\n\t\t\tgoto done;\n\t\t}\n\t}\n\t/*\n\t * At the moment idling is implemented only for READ queues.\n\t * If enabled on WRITE, this needs updating\n\t */\n\tif (hrtimer_active(&rd->rd_idle_data.hr_timer)) {\n\t\trow_log(rd->dispatch_queue, \"Delayed work pending. Exiting\");\n\t\tgoto done;\n\t}\ncheck_idling:\n\t/* Check for (high priority) idling and enable if needed */\n\tfor (i = 0; i < ROWQ_REG_PRIO_IDX && !force; i++) {\n\t\tif (rd->row_queues[i].idle_data.begin_idling &&\n\t\t    row_queues_def[i].idling_enabled)\n\t\t\tgoto initiate_idling;\n\t}\n\t/* Regular priority queues */\n\tfor (i = ROWQ_REG_PRIO_IDX; i < ROWQ_LOW_PRIO_IDX; i++) {\n\t\tif (list_empty(&rd->row_queues[i].fifo)) {\n\t\t\t/* We can idle only if this is not a forced dispatch */\n\t\t\tif (rd->row_queues[i].idle_data.begin_idling &&\n\t\t\t    !force && row_queues_def[i].idling_enabled)\n\t\t\t\tgoto initiate_idling;\n\t\t} else {\n\t\t\tif (row_low_req_pending(rd) &&\n\t\t\t    (rd->low_prio_starvation.starvation_counter >=\n\t\t\t     rd->low_prio_starvation.starvation_limit))\n\t\t\t\tret = IOPRIO_CLASS_IDLE;\n\t\t\telse\n\t\t\t\tret = IOPRIO_CLASS_BE;\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (rd->nr_reqs[READ] || rd->nr_reqs[WRITE])\n\t\tret = IOPRIO_CLASS_IDLE;\n\tgoto done;\ninitiate_idling:\n\thrtimer_start(&rd->rd_idle_data.hr_timer,\n\t\tktime_set(0, rd->rd_idle_data.idle_time_ms * NSEC_PER_MSEC),\n\t\tHRTIMER_MODE_REL);\n\trd->rd_idle_data.idling_queue_idx = i;\n\trow_log_rowq(rd, i, \"Scheduled delayed work on %d. exiting\", i);\ndone:\n\treturn ret;\n"]]}
{"hexsha": "6370deedc023aaf563b991fac53e4e66246f69c6", "ext": "h", "lang": "C", "content": "inline bool ScannerContext::Stream::ReadBoolean(bool* b, Status* status) {\n  uint8_t* val;\n  RETURN_IF_FALSE(ReadBytes(1, &val, status));\n  *b = (*val != 0);\n  return true;\n}", "item_id": 5, "repo": "ImpalaToGo/ImpalaToGo", "file": "be/src/exec/scanner-context.inline.h", "last_update_at": "2020-11-21T16:33:19+00:00", "question_id": "6370deedc023aaf563b991fac53e4e66246f69c6_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["inline bool ScannerContext::Stream::ReadBoolean(bool* b, Status* status) {\n  uint8_t* val;\n  RETURN_IF_FALSE(ReadBytes(1, &val, status));\n  *b = (*val != 0);\n  return true;\n"]]}
{"hexsha": "ca0bef59efc0d8550110692cfc5866b8368bf34e", "ext": "c", "lang": "C", "content": "int\nrt2560_tx_data(struct rt2560_softc *sc, struct mbuf *m0,\n    struct ieee80211_node *ni)\n{\n\tstruct ieee80211com *ic = &sc->sc_ic;\n\tstruct rt2560_tx_ring *txq = &sc->txq;\n\tstruct rt2560_tx_desc *desc;\n\tstruct rt2560_tx_data *data;\n\tstruct ieee80211_frame *wh;\n\tstruct ieee80211_key *k;\n\tstruct mbuf *m1;\n\tuint16_t dur;\n\tuint32_t flags = 0;\n\tint pktlen, rate, needcts = 0, needrts = 0, error;\n\n\twh = mtod(m0, struct ieee80211_frame *);\n\n\tif (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {\n\t\tk = ieee80211_get_txkey(ic, wh, ni);\n\n\t\tif ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)\n\t\t\treturn ENOBUFS;\n\n\t\t/* packet header may have moved, reset our local pointer */\n\t\twh = mtod(m0, struct ieee80211_frame *);\n\t}\n\n\t/* compute actual packet length (including CRC and crypto overhead) */\n\tpktlen = m0->m_pkthdr.len + IEEE80211_CRC_LEN;\n\n\t/* pickup a rate */\n\tif (IEEE80211_IS_MULTICAST(wh->i_addr1) ||\n\t    ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==\n\t     IEEE80211_FC0_TYPE_MGT)) {\n\t\t/* mgmt/multicast frames are sent at the lowest avail. rate */\n\t\trate = ni->ni_rates.rs_rates[0];\n\t} else if (ic->ic_fixed_rate != -1) {\n\t\trate = ic->ic_sup_rates[ic->ic_curmode].\n\t\t    rs_rates[ic->ic_fixed_rate];\n\t} else\n\t\trate = ni->ni_rates.rs_rates[ni->ni_txrate];\n\tif (rate == 0)\n\t\trate = 2;\t/* XXX should not happen */\n\trate &= IEEE80211_RATE_VAL;\n\n\t/*\n\t * Packet Bursting: backoff after ppb=8 frames to give other STAs a\n\t * chance to contend for the wireless medium.\n\t */\n\tif (ic->ic_opmode == IEEE80211_M_STA && (ni->ni_txseq & 7))\n\t\tflags |= RT2560_TX_IFS_SIFS;\n\n\t/* check if RTS/CTS or CTS-to-self protection must be used */\n\tif (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {\n\t\t/* multicast frames are not sent at OFDM rates in 802.11b/g */\n\t\tif (pktlen > ic->ic_rtsthreshold) {\n\t\t\tneedrts = 1;\t/* RTS/CTS based on frame length */\n\t\t} else if ((ic->ic_flags & IEEE80211_F_USEPROT) &&\n\t\t    RAL_RATE_IS_OFDM(rate)) {\n\t\t\tif (ic->ic_protmode == IEEE80211_PROT_CTSONLY)\n\t\t\t\tneedcts = 1;\t/* CTS-to-self */\n\t\t\telse if (ic->ic_protmode == IEEE80211_PROT_RTSCTS)\n\t\t\t\tneedrts = 1;\t/* RTS/CTS */\n\t\t}\n\t}\n\tif (needrts || needcts) {\n\t\tstruct mbuf *mprot;\n\t\tint protrate, ackrate;\n\n\t\tprotrate = 2;\t/* XXX */\n\t\tackrate  = rt2560_ack_rate(ic, rate);\n\n\t\tdur = rt2560_txtime(pktlen, rate, ic->ic_flags) +\n\t\t      rt2560_txtime(RAL_ACK_SIZE, ackrate, ic->ic_flags) +\n\t\t      2 * RAL_SIFS;\n\t\tif (needrts) {\n\t\t\tdur += rt2560_txtime(RAL_CTS_SIZE, rt2560_ack_rate(ic,\n\t\t\t    protrate), ic->ic_flags) + RAL_SIFS;\n\t\t\tmprot = ieee80211_get_rts(ic, wh, dur);\n\t\t} else {\n\t\t\tmprot = ieee80211_get_cts_to_self(ic, dur);\n\t\t}\n\t\tif (mprot == NULL) {\n\t\t\tprintf(\"%s: could not allocate protection frame\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tm_freem(m0);\n\t\t\treturn ENOBUFS;\n\t\t}\n\n\t\tdesc = &txq->desc[txq->cur_encrypt];\n\t\tdata = &txq->data[txq->cur_encrypt];\n\n\t\terror = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, mprot,\n\t\t    BUS_DMA_NOWAIT);\n\t\tif (error != 0) {\n\t\t\tprintf(\"%s: can't map mbuf (error %d)\\n\",\n\t\t\t    sc->sc_dev.dv_xname, error);\n\t\t\tm_freem(mprot);\n\t\t\tm_freem(m0);\n\t\t\treturn error;\n\t\t}\n\n\t\tdata->m = mprot;\n\t\t/* avoid multiple free() of the same node for each fragment */\n\t\tdata->ni = ieee80211_ref_node(ni);\n\n\t\t/* XXX may want to pass the protection frame to BPF */\n\n\t\trt2560_setup_tx_desc(sc, desc,\n\t\t    (needrts ? RT2560_TX_NEED_ACK : 0) | RT2560_TX_MORE_FRAG,\n\t\t    mprot->m_pkthdr.len, protrate, 1,\n\t\t    data->map->dm_segs->ds_addr);\n\n\t\tbus_dmamap_sync(sc->sc_dmat, data->map, 0,\n\t\t    data->map->dm_mapsize, BUS_DMASYNC_PREWRITE);\n\t\tbus_dmamap_sync(sc->sc_dmat, txq->map,\n\t\t    txq->cur_encrypt * RT2560_TX_DESC_SIZE,\n\t\t    RT2560_TX_DESC_SIZE, BUS_DMASYNC_PREWRITE);\n\n\t\ttxq->queued++;\n\t\tif (++txq->cur_encrypt >= txq->count)\n\t\t\ttxq->cur_encrypt = 0;\n\n\t\tflags |= RT2560_TX_LONG_RETRY | RT2560_TX_IFS_SIFS;\n\t}\n\n\tdata = &txq->data[txq->cur_encrypt];\n\tdesc = &txq->desc[txq->cur_encrypt];\n\n\terror = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,\n\t    BUS_DMA_NOWAIT);\n\tif (error != 0 && error != EFBIG) {\n\t\tprintf(\"%s: can't map mbuf (error %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, error);\n\t\tm_freem(m0);\n\t\treturn error;\n\t}\n\tif (error != 0) {\n\t\t/* too many fragments, linearize */\n\t\tMGETHDR(m1, M_DONTWAIT, MT_DATA);\n\t\tif (m1 == NULL) {\n\t\t\tm_freem(m0);\n\t\t\treturn ENOBUFS;\n\t\t}\n\t\tif (m0->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m1, M_DONTWAIT);\n\t\t\tif (!(m1->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tm_freem(m1);\n\t\t\t\treturn ENOBUFS;\n\t\t\t}\n\t\t}\n\t\tm_copydata(m0, 0, m0->m_pkthdr.len, mtod(m1, caddr_t));\n\t\tm1->m_pkthdr.len = m1->m_len = m0->m_pkthdr.len;\n\t\tm_freem(m0);\n\t\tm0 = m1;\n\n\t\terror = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,\n\t\t    BUS_DMA_NOWAIT);\n\t\tif (error != 0) {\n\t\t\tprintf(\"%s: can't map mbuf (error %d)\\n\",\n\t\t\t    sc->sc_dev.dv_xname, error);\n\t\t\tm_freem(m0);\n\t\t\treturn error;\n\t\t}\n\n\t\t/* packet header have moved, reset our local pointer */\n\t\twh = mtod(m0, struct ieee80211_frame *);\n\t}\n\n#if NBPFILTER > 0\n\tif (sc->sc_drvbpf != NULL) {\n\t\tstruct mbuf mb;\n\t\tstruct rt2560_tx_radiotap_header *tap = &sc->sc_txtap;\n\n\t\ttap->wt_flags = 0;\n\t\ttap->wt_rate = rate;\n\t\ttap->wt_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);\n\t\ttap->wt_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);\n\t\ttap->wt_antenna = sc->tx_ant;\n\n\t\tmb.m_data = (caddr_t)tap;\n\t\tmb.m_len = sc->sc_txtap_len;\n\t\tmb.m_next = m0;\n\t\tmb.m_nextpkt = NULL;\n\t\tmb.m_type = 0;\n\t\tmb.m_flags = 0;\n\t\tbpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);\n\t}\n#endif\n\n\tdata->m = m0;\n\tdata->ni = ni;\n\n\tif (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {\n\t\tflags |= RT2560_TX_NEED_ACK;\n\n\t\tdur = rt2560_txtime(RAL_ACK_SIZE, rt2560_ack_rate(ic, rate),\n\t\t    ic->ic_flags) + RAL_SIFS;\n\t\t*(uint16_t *)wh->i_dur = htole16(dur);\n\t}\n\n\trt2560_setup_tx_desc(sc, desc, flags, m0->m_pkthdr.len, rate, 1,\n\t    data->map->dm_segs->ds_addr);\n\n\tbus_dmamap_sync(sc->sc_dmat, data->map, 0, data->map->dm_mapsize,\n\t    BUS_DMASYNC_PREWRITE);\n\tbus_dmamap_sync(sc->sc_dmat, txq->map,\n\t    txq->cur_encrypt * RT2560_TX_DESC_SIZE, RT2560_TX_DESC_SIZE,\n\t    BUS_DMASYNC_PREWRITE);\n\n\tDPRINTFN(10, (\"sending frame len=%u idx=%u rate=%u\\n\",\n\t    m0->m_pkthdr.len, txq->cur_encrypt, rate));\n\n\t/* kick encrypt */\n\ttxq->queued++;\n\tif (++txq->cur_encrypt >= txq->count)\n\t\ttxq->cur_encrypt = 0;\n\tRAL_WRITE(sc, RT2560_SECCSR1, RT2560_KICK_ENCRYPT);\n\n\treturn 0;\n}", "item_id": 29, "repo": "sizeofvoid/ifconfigd", "file": "usr/src/sys/dev/ic/rt2560.c", "last_update_at": "2020-08-28T01:27:00+00:00", "question_id": "ca0bef59efc0d8550110692cfc5866b8368bf34e_29", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nrt2560_tx_data(struct rt2560_softc *sc, struct mbuf *m0,\n    struct ieee80211_node *ni)\n{\n\tstruct ieee80211com *ic = &sc->sc_ic;\n\tstruct rt2560_tx_ring *txq = &sc->txq;\n\tstruct rt2560_tx_desc *desc;\n\tstruct rt2560_tx_data *data;\n\tstruct ieee80211_frame *wh;\n\tstruct ieee80211_key *k;\n\tstruct mbuf *m1;\n\tuint16_t dur;\n\tuint32_t flags = 0;\n\tint pktlen, rate, needcts = 0, needrts = 0, error;\n\twh = mtod(m0, struct ieee80211_frame *);\n\tif (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {\n\t\tk = ieee80211_get_txkey(ic, wh, ni);\n\t\tif ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)\n\t\t\treturn ENOBUFS;\n\t\t/* packet header may have moved, reset our local pointer */\n\t\twh = mtod(m0, struct ieee80211_frame *);\n\t}\n\t/* compute actual packet length (including CRC and crypto overhead) */\n\tpktlen = m0->m_pkthdr.len + IEEE80211_CRC_LEN;\n\t/* pickup a rate */\n\tif (IEEE80211_IS_MULTICAST(wh->i_addr1) ||\n\t    ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==\n\t     IEEE80211_FC0_TYPE_MGT)) {\n\t\t/* mgmt/multicast frames are sent at the lowest avail. rate */\n\t\trate = ni->ni_rates.rs_rates[0];\n\t} else if (ic->ic_fixed_rate != -1) {\n\t\trate = ic->ic_sup_rates[ic->ic_curmode].\n\t\t    rs_rates[ic->ic_fixed_rate];\n\t} else\n\t\trate = ni->ni_rates.rs_rates[ni->ni_txrate];\n\tif (rate == 0)\n\t\trate = 2;\t/* XXX should not happen */\n\trate &= IEEE80211_RATE_VAL;\n\t/*\n\t * Packet Bursting: backoff after ppb=8 frames to give other STAs a\n\t * chance to contend for the wireless medium.\n\t */\n\tif (ic->ic_opmode == IEEE80211_M_STA && (ni->ni_txseq & 7))\n\t\tflags |= RT2560_TX_IFS_SIFS;\n\t/* check if RTS/CTS or CTS-to-self protection must be used */\n\tif (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {\n\t\t/* multicast frames are not sent at OFDM rates in 802.11b/g */\n\t\tif (pktlen > ic->ic_rtsthreshold) {\n\t\t\tneedrts = 1;\t/* RTS/CTS based on frame length */\n\t\t} else if ((ic->ic_flags & IEEE80211_F_USEPROT) &&\n\t\t    RAL_RATE_IS_OFDM(rate)) {\n\t\t\tif (ic->ic_protmode == IEEE80211_PROT_CTSONLY)\n\t\t\t\tneedcts = 1;\t/* CTS-to-self */\n\t\t\telse if (ic->ic_protmode == IEEE80211_PROT_RTSCTS)\n\t\t\t\tneedrts = 1;\t/* RTS/CTS */\n\t\t}\n\t}\n\tif (needrts || needcts) {\n\t\tstruct mbuf *mprot;\n\t\tint protrate, ackrate;\n\t\tprotrate = 2;\t/* XXX */\n\t\tackrate  = rt2560_ack_rate(ic, rate);\n\t\tdur = rt2560_txtime(pktlen, rate, ic->ic_flags) +\n\t\t      rt2560_txtime(RAL_ACK_SIZE, ackrate, ic->ic_flags) +\n\t\t      2 * RAL_SIFS;\n\t\tif (needrts) {\n\t\t\tdur += rt2560_txtime(RAL_CTS_SIZE, rt2560_ack_rate(ic,\n\t\t\t    protrate), ic->ic_flags) + RAL_SIFS;\n\t\t\tmprot = ieee80211_get_rts(ic, wh, dur);\n\t\t} else {\n\t\t\tmprot = ieee80211_get_cts_to_self(ic, dur);\n\t\t}\n\t\tif (mprot == NULL) {\n\t\t\tprintf(\"%s: could not allocate protection frame\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tm_freem(m0);\n\t\t\treturn ENOBUFS;\n\t\t}\n\t\tdesc = &txq->desc[txq->cur_encrypt];\n\t\tdata = &txq->data[txq->cur_encrypt];\n\t\terror = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, mprot,\n\t\t    BUS_DMA_NOWAIT);\n\t\tif (error != 0) {\n\t\t\tprintf(\"%s: can't map mbuf (error %d)\\n\",\n\t\t\t    sc->sc_dev.dv_xname, error);\n\t\t\tm_freem(mprot);\n\t\t\tm_freem(m0);\n\t\t\treturn error;\n\t\t}\n\t\tdata->m = mprot;\n\t\t/* avoid multiple free() of the same node for each fragment */\n\t\tdata->ni = ieee80211_ref_node(ni);\n\t\t/* XXX may want to pass the protection frame to BPF */\n\t\trt2560_setup_tx_desc(sc, desc,\n\t\t    (needrts ? RT2560_TX_NEED_ACK : 0) | RT2560_TX_MORE_FRAG,\n\t\t    mprot->m_pkthdr.len, protrate, 1,\n\t\t    data->map->dm_segs->ds_addr);\n\t\tbus_dmamap_sync(sc->sc_dmat, data->map, 0,\n\t\t    data->map->dm_mapsize, BUS_DMASYNC_PREWRITE);\n\t\tbus_dmamap_sync(sc->sc_dmat, txq->map,\n\t\t    txq->cur_encrypt * RT2560_TX_DESC_SIZE,\n\t\t    RT2560_TX_DESC_SIZE, BUS_DMASYNC_PREWRITE);\n\t\ttxq->queued++;\n\t\tif (++txq->cur_encrypt >= txq->count)\n\t\t\ttxq->cur_encrypt = 0;\n\t\tflags |= RT2560_TX_LONG_RETRY | RT2560_TX_IFS_SIFS;\n\t}\n\tdata = &txq->data[txq->cur_encrypt];\n\tdesc = &txq->desc[txq->cur_encrypt];\n\terror = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,\n\t    BUS_DMA_NOWAIT);\n\tif (error != 0 && error != EFBIG) {\n\t\tprintf(\"%s: can't map mbuf (error %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, error);\n\t\tm_freem(m0);\n\t\treturn error;\n\t}\n\tif (error != 0) {\n\t\t/* too many fragments, linearize */\n\t\tMGETHDR(m1, M_DONTWAIT, MT_DATA);\n\t\tif (m1 == NULL) {\n\t\t\tm_freem(m0);\n\t\t\treturn ENOBUFS;\n\t\t}\n\t\tif (m0->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m1, M_DONTWAIT);\n\t\t\tif (!(m1->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tm_freem(m1);\n\t\t\t\treturn ENOBUFS;\n\t\t\t}\n\t\t}\n\t\tm_copydata(m0, 0, m0->m_pkthdr.len, mtod(m1, caddr_t));\n\t\tm1->m_pkthdr.len = m1->m_len = m0->m_pkthdr.len;\n\t\tm_freem(m0);\n\t\tm0 = m1;\n\t\terror = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,\n\t\t    BUS_DMA_NOWAIT);\n\t\tif (error != 0) {\n\t\t\tprintf(\"%s: can't map mbuf (error %d)\\n\",\n\t\t\t    sc->sc_dev.dv_xname, error);\n\t\t\tm_freem(m0);\n\t\t\treturn error;\n\t\t}\n\t\t/* packet header have moved, reset our local pointer */\n\t\twh = mtod(m0, struct ieee80211_frame *);\n\t}\n#if NBPFILTER > 0\n\tif (sc->sc_drvbpf != NULL) {\n\t\tstruct mbuf mb;\n\t\tstruct rt2560_tx_radiotap_header *tap = &sc->sc_txtap;\n\t\ttap->wt_flags = 0;\n\t\ttap->wt_rate = rate;\n\t\ttap->wt_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);\n\t\ttap->wt_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);\n\t\ttap->wt_antenna = sc->tx_ant;\n\t\tmb.m_data = (caddr_t)tap;\n\t\tmb.m_len = sc->sc_txtap_len;\n\t\tmb.m_next = m0;\n\t\tmb.m_nextpkt = NULL;\n\t\tmb.m_type = 0;\n\t\tmb.m_flags = 0;\n\t\tbpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);\n\t}\n#endif\n\tdata->m = m0;\n\tdata->ni = ni;\n\tif (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {\n\t\tflags |= RT2560_TX_NEED_ACK;\n\t\tdur = rt2560_txtime(RAL_ACK_SIZE, rt2560_ack_rate(ic, rate),\n\t\t    ic->ic_flags) + RAL_SIFS;\n\t\t*(uint16_t *)wh->i_dur = htole16(dur);\n\t}\n\trt2560_setup_tx_desc(sc, desc, flags, m0->m_pkthdr.len, rate, 1,\n\t    data->map->dm_segs->ds_addr);\n\tbus_dmamap_sync(sc->sc_dmat, data->map, 0, data->map->dm_mapsize,\n\t    BUS_DMASYNC_PREWRITE);\n\tbus_dmamap_sync(sc->sc_dmat, txq->map,\n\t    txq->cur_encrypt * RT2560_TX_DESC_SIZE, RT2560_TX_DESC_SIZE,\n\t    BUS_DMASYNC_PREWRITE);\n\tDPRINTFN(10, (\"sending frame len=%u idx=%u rate=%u\\n\",\n\t    m0->m_pkthdr.len, txq->cur_encrypt, rate));\n\t/* kick encrypt */\n\ttxq->queued++;\n\tif (++txq->cur_encrypt >= txq->count)\n\t\ttxq->cur_encrypt = 0;\n\tRAL_WRITE(sc, RT2560_SECCSR1, RT2560_KICK_ENCRYPT);\n\treturn 0;\n"]]}
{"hexsha": "15ab61fd350fb903bfa34ef84f18b70d56ef131c", "ext": "c", "lang": "C", "content": "static int _cffi_const_SQLITE_FUNCTION(unsigned long long *o)\n{\n  int n = (SQLITE_FUNCTION) <= 0;\n  *o = (unsigned long long)((SQLITE_FUNCTION) | 0);  /* check that SQLITE_FUNCTION is an integer */\n  return n;\n}", "item_id": 111, "repo": "akercheval/espy", "file": "lib_pypy/_sqlite3_cffi.c", "last_update_at": "2020-03-15T14:12:32+00:00", "question_id": "15ab61fd350fb903bfa34ef84f18b70d56ef131c_111", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int _cffi_const_SQLITE_FUNCTION(unsigned long long *o)\n{\n  int n = (SQLITE_FUNCTION) <= 0;\n  *o = (unsigned long long)((SQLITE_FUNCTION) | 0);  /* check that SQLITE_FUNCTION is an integer */\n  return n;\n"]]}
{"hexsha": "3f69319c82b474f40d5bc0574695e1994597035e", "ext": "c", "lang": "C", "content": "void program_unistr_mat(program_t *program, const char *name, mat4x4 m) {\n    program_use(program);\n    GLint loc = glGetUniformLocation(program->id, name);\n    UNI_KILL(loc, name);\n    glUniformMatrix4fv(loc, 1, GL_FALSE, m[0]);\n}", "item_id": 8, "repo": "thomaslienbacher/TEngine", "file": "src/program.c", "last_update_at": "2020-05-24T03:03:04+00:00", "question_id": "3f69319c82b474f40d5bc0574695e1994597035e_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void program_unistr_mat(program_t *program, const char *name, mat4x4 m) {\n    program_use(program);\n    GLint loc = glGetUniformLocation(program->id, name);\n    UNI_KILL(loc, name);\n    glUniformMatrix4fv(loc, 1, GL_FALSE, m[0]);\n"]]}
{"hexsha": "a0af2da5782a1d7ad7a0247973864e7515dc145b", "ext": "c", "lang": "C", "content": "static int\nipmp_readgroupinfo_lists(ipmp_state_t *statep, ipmp_groupinfo_t *grinfop,\n    const struct timeval *endtp)\n{\n\tint retval;\n\tipmp_iflist_t *iflistp;\n\tipmp_addrlist_t *adlistp;\n\n\tretval = ipmp_readinfo(statep, IPMP_IFLIST, (void **)&iflistp, endtp);\n\tif (retval != IPMP_SUCCESS)\n\t\treturn (retval);\n\n\tretval = ipmp_readinfo(statep, IPMP_ADDRLIST, (void **)&adlistp, endtp);\n\tif (retval != IPMP_SUCCESS) {\n\t\tipmp_freeiflist(iflistp);\n\t\treturn (retval);\n\t}\n\n\tgrinfop->gr_iflistp = iflistp;\n\tgrinfop->gr_adlistp = adlistp;\n\treturn (IPMP_SUCCESS);\n}", "item_id": 2, "repo": "AsahiOS/gate", "file": "usr/src/lib/libipmp/common/ipmp_query.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "a0af2da5782a1d7ad7a0247973864e7515dc145b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nipmp_readgroupinfo_lists(ipmp_state_t *statep, ipmp_groupinfo_t *grinfop,\n    const struct timeval *endtp)\n{\n\tint retval;\n\tipmp_iflist_t *iflistp;\n\tipmp_addrlist_t *adlistp;\n\tretval = ipmp_readinfo(statep, IPMP_IFLIST, (void **)&iflistp, endtp);\n\tif (retval != IPMP_SUCCESS)\n\t\treturn (retval);\n\tretval = ipmp_readinfo(statep, IPMP_ADDRLIST, (void **)&adlistp, endtp);\n\tif (retval != IPMP_SUCCESS) {\n\t\tipmp_freeiflist(iflistp);\n\t\treturn (retval);\n\t}\n\tgrinfop->gr_iflistp = iflistp;\n\tgrinfop->gr_adlistp = adlistp;\n\treturn (IPMP_SUCCESS);\n"]]}
{"hexsha": "efc3a9a0a6ec20999862748f064948346cd9b2cd", "ext": "c", "lang": "C", "content": "END_TEST\n\nSTART_TEST(test_bst_remove){\n    bst_t *t;\n    bst_initialize(&t,int_constructor,int_destructor,int_comparator);\n    int i;\n    for(i=0;i<N;i++){\n        bst_insert(t,&v[i]);\n    }\n    for(i=0;i<N;i++){\n        ck_assert(bst_find(t,&v[i]));\n        bst_remove(t,&v[i]);\n    }\n    ck_assert(t->root==NULL);\n    bst_delete(&t);\n}", "item_id": 3, "repo": "VergilSkye/EDA-IFB-CC", "file": "Testes/teste_bst.c", "last_update_at": "2020-11-17T01:43:41+00:00", "question_id": "efc3a9a0a6ec20999862748f064948346cd9b2cd_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["END_TEST\nSTART_TEST(test_bst_remove){\n    bst_t *t;\n    bst_initialize(&t,int_constructor,int_destructor,int_comparator);\n    int i;\n    for(i=0;i<N;i++){\n        bst_insert(t,&v[i]);\n    }\n    for(i=0;i<N;i++){\n        ck_assert(bst_find(t,&v[i]));\n        bst_remove(t,&v[i]);\n    }\n    ck_assert(t->root==NULL);\n    bst_delete(&t);\n"]]}
{"hexsha": "e8d58d7f389ea158f8c4605cefab8555c81e4f58", "ext": "h", "lang": "C", "content": "class Signature {\n public:\n  char* encryption_alg_;\n  int size_serialized_;\n  byte* serialized_statement_;\n  int size_signature_;\n  byte* signature_;\n  char* signer_name_;\n\n  Signature();\n  ~Signature();\n\n  bool Serialize(crypto_signature& sig);\n  bool Deserialize(crypto_signature& sig);\n  void PrintSignature();\n}", "item_id": 5, "repo": "jlmucb/crypto", "file": "v1/include/keys.h", "last_update_at": "2020-10-08T20:04:01+00:00", "question_id": "e8d58d7f389ea158f8c4605cefab8555c81e4f58_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Signature {\n public:\n  char* encryption_alg_;\n  int size_serialized_;\n  byte* serialized_statement_;\n  int size_signature_;\n  byte* signature_;\n  char* signer_name_;\n  Signature();\n  ~Signature();\n  bool Serialize(crypto_signature& sig);\n  bool Deserialize(crypto_signature& sig);\n  void PrintSignature();\n"]]}
{"hexsha": "92673de26eb836af89af7e4a526b41def3cfd284", "ext": "c", "lang": "C", "content": "static void\nste_map_io(STE10_100 * ste)\n{\n\tuint32_t base = ste->bar0;\n\tMapProc *mapproc = PCI_RegisterIOH;\n\t/* IO-Space enabled ? */\n\tif (!(ste->command & 1)) {\n\t\tfprintf(stderr, \"STE: iospace not enabled %d\\n\", __LINE__);\n\t}\n\tbase = base & ~0x7f;\n\tste_map(ste, mapproc, base);\n}", "item_id": 46, "repo": "zihui89w/leigun", "file": "modules/softgun/ste10_100.c", "last_update_at": "2020-05-13T04:33:25+00:00", "question_id": "92673de26eb836af89af7e4a526b41def3cfd284_46", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nste_map_io(STE10_100 * ste)\n{\n\tuint32_t base = ste->bar0;\n\tMapProc *mapproc = PCI_RegisterIOH;\n\t/* IO-Space enabled ? */\n\tif (!(ste->command & 1)) {\n\t\tfprintf(stderr, \"STE: iospace not enabled %d\\n\", __LINE__);\n\t}\n\tbase = base & ~0x7f;\n\tste_map(ste, mapproc, base);\n"]]}
{"hexsha": "8dcb978e0e2274b9b184740e87e3522987396b64", "ext": "c", "lang": "C", "content": "int\nhc_sock_reset(hc_sock_t * s)\n{\n    s->roff = s->woff = 0;\n    s->remaining = 0;\n     return 0;\n}", "item_id": 16, "repo": "muscariello/hicn-test", "file": "ctrl/libhicnctrl/src/api.c", "last_update_at": "2020-12-29T06:10:08+00:00", "question_id": "8dcb978e0e2274b9b184740e87e3522987396b64_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nhc_sock_reset(hc_sock_t * s)\n{\n    s->roff = s->woff = 0;\n    s->remaining = 0;\n     return 0;\n"]]}
{"hexsha": "af180933a506439d17acb94dd473146fe3bf1291", "ext": "c", "lang": "C", "content": "int main(int argc, const char * const argv[])\n{\n  (void)argc;\n  (void)argv;\n\n  /* Initialize the application.\n     You do not need to do this more than one time. */\n  SteadyState_3D_SOR_Solver_CoreC_initialize();\n\n  /* Invoke the entry-point functions.\n     You can call entry-point functions multiple times. */\n  main_SteadyState_3D_SOR_Solver_CoreC();\n\n  /* Terminate the application.\n     You do not need to do this more than one time. */\n  SteadyState_3D_SOR_Solver_CoreC_terminate();\n  return 0;\n}", "item_id": 4, "repo": "simonvanvliet/IndividualBasedModelMutualisticConsortia", "file": "codegen/lib/SteadyState_3D_SOR_Solver_CoreC/examples/main.c", "last_update_at": "2020-02-17T01:14:46+00:00", "question_id": "af180933a506439d17acb94dd473146fe3bf1291_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, const char * const argv[])\n{\n  (void)argc;\n  (void)argv;\n  /* Initialize the application.\n     You do not need to do this more than one time. */\n  SteadyState_3D_SOR_Solver_CoreC_initialize();\n  /* Invoke the entry-point functions.\n     You can call entry-point functions multiple times. */\n  main_SteadyState_3D_SOR_Solver_CoreC();\n  /* Terminate the application.\n     You do not need to do this more than one time. */\n  SteadyState_3D_SOR_Solver_CoreC_terminate();\n  return 0;\n"]]}
{"hexsha": "ae183afad22e01dc270c365b1bd15a34251edf45", "ext": "c", "lang": "C", "content": "static void test_pack_MCI_SOUND_PARMSW(void)\n{\n    /* MCI_SOUND_PARMSW (pack 1) */\n    TEST_TYPE_SIZE   (MCI_SOUND_PARMSW, 16)\n    TEST_TYPE_ALIGN  (MCI_SOUND_PARMSW, 1)\n    TEST_FIELD_SIZE  (MCI_SOUND_PARMSW, dwCallback, 8)\n    TEST_FIELD_ALIGN (MCI_SOUND_PARMSW, dwCallback, 1)\n    TEST_FIELD_OFFSET(MCI_SOUND_PARMSW, dwCallback, 0)\n    TEST_FIELD_SIZE  (MCI_SOUND_PARMSW, lpstrSoundName, 8)\n    TEST_FIELD_ALIGN (MCI_SOUND_PARMSW, lpstrSoundName, 1)\n    TEST_FIELD_OFFSET(MCI_SOUND_PARMSW, lpstrSoundName, 8)\n}", "item_id": 67, "repo": "pchome/wine-1", "file": "dlls/winmm/tests/generated.c", "last_update_at": "2020-06-10T07:25:06+00:00", "question_id": "ae183afad22e01dc270c365b1bd15a34251edf45_67", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void test_pack_MCI_SOUND_PARMSW(void)\n{\n    /* MCI_SOUND_PARMSW (pack 1) */\n    TEST_TYPE_SIZE   (MCI_SOUND_PARMSW, 16)\n    TEST_TYPE_ALIGN  (MCI_SOUND_PARMSW, 1)\n    TEST_FIELD_SIZE  (MCI_SOUND_PARMSW, dwCallback, 8)\n    TEST_FIELD_ALIGN (MCI_SOUND_PARMSW, dwCallback, 1)\n    TEST_FIELD_OFFSET(MCI_SOUND_PARMSW, dwCallback, 0)\n    TEST_FIELD_SIZE  (MCI_SOUND_PARMSW, lpstrSoundName, 8)\n    TEST_FIELD_ALIGN (MCI_SOUND_PARMSW, lpstrSoundName, 1)\n    TEST_FIELD_OFFSET(MCI_SOUND_PARMSW, lpstrSoundName, 8)\n"]]}
{"hexsha": "5dfd0f3b2942556e9f29eedfb3cfee75037da1f9", "ext": "c", "lang": "C", "content": "BOOL\nCpuInfoDisplayGroups(\n    __in PCPUINFO_CONTEXT CpuInfoContext\n    )\n{\n    PYORI_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Entry;\n    DWORD CurrentOffset = 0;\n    WORD GroupIndex;\n\n    Entry = CpuInfoContext->ProcInfo;\n\n    while (Entry != NULL) {\n\n        if (Entry->Relationship == YoriProcessorRelationGroup) {\n            for (GroupIndex = 0; GroupIndex < Entry->u.Group.MaximumGroupCount; GroupIndex++) {\n                YoriLibOutput(YORI_LIB_OUTPUT_STDOUT, _T(\"Group %i\\n\"), GroupIndex);\n                CpuInfoDisplayProcessorMask(GroupIndex, Entry->u.Group.GroupInfo[GroupIndex].ActiveProcessorMask);\n\n            }\n            YoriLibOutput(YORI_LIB_OUTPUT_STDOUT, _T(\"\\n\"));\n        }\n\n        CurrentOffset += Entry->SizeInBytes;\n        if (CurrentOffset >= CpuInfoContext->BytesInBuffer) {\n            break;\n        }\n        Entry = YoriLibAddToPointer(CpuInfoContext->ProcInfo, CurrentOffset);\n    }\n\n    return TRUE;\n}", "item_id": 6, "repo": "jstarks/yori", "file": "cpuinfo/cpuinfo.c", "last_update_at": "2020-06-16T22:07:50+00:00", "question_id": "5dfd0f3b2942556e9f29eedfb3cfee75037da1f9_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["BOOL\nCpuInfoDisplayGroups(\n    __in PCPUINFO_CONTEXT CpuInfoContext\n    )\n{\n    PYORI_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Entry;\n    DWORD CurrentOffset = 0;\n    WORD GroupIndex;\n    Entry = CpuInfoContext->ProcInfo;\n    while (Entry != NULL) {\n        if (Entry->Relationship == YoriProcessorRelationGroup) {\n            for (GroupIndex = 0; GroupIndex < Entry->u.Group.MaximumGroupCount; GroupIndex++) {\n                YoriLibOutput(YORI_LIB_OUTPUT_STDOUT, _T(\"Group %i\\n\"), GroupIndex);\n                CpuInfoDisplayProcessorMask(GroupIndex, Entry->u.Group.GroupInfo[GroupIndex].ActiveProcessorMask);\n            }\n            YoriLibOutput(YORI_LIB_OUTPUT_STDOUT, _T(\"\\n\"));\n        }\n        CurrentOffset += Entry->SizeInBytes;\n        if (CurrentOffset >= CpuInfoContext->BytesInBuffer) {\n            break;\n        }\n        Entry = YoriLibAddToPointer(CpuInfoContext->ProcInfo, CurrentOffset);\n    }\n    return TRUE;\n"]]}
{"hexsha": "9e67f816f2b8e29c647d60577b1716b4bb9948e0", "ext": "c", "lang": "C", "content": "void updateTimers() {\n    static clock_t lastUser = 0;\n    clock_t curr;\n    curr        = clock();\n    userElapsed = curr - lastUser;\n    lastUser    = curr;\n}", "item_id": 1, "repo": "alekar/hugs", "file": "src/timer.c", "last_update_at": "2020-11-22T21:53:41+00:00", "question_id": "9e67f816f2b8e29c647d60577b1716b4bb9948e0_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void updateTimers() {\n    static clock_t lastUser = 0;\n    clock_t curr;\n    curr        = clock();\n    userElapsed = curr - lastUser;\n    lastUser    = curr;\n"]]}
{"hexsha": "4e0226aa37ae496e3bd8fa8850b38037fe2a3804", "ext": "c", "lang": "C", "content": "ssize_t echo_mini_isp_debug_rx_fps_info(const char *cmd_buf)\n{\n\tsize_t errcode = ERR_SUCCESS;\n\tint ret;\n\tu8 param[2];\n\tchar cmd_name[20];\n\n\tmisp_info(\"%s S\", __func__);\n\tret = sscanf(cmd_buf, \"%19s %hhu %hhu\", cmd_name, &param[0], &param[1]);\n\tif (ret != 3) {\n\t\terrcode = -EINVAL;\n\t\treturn errcode;\n\t}\n\n\tif (param[0] == 0) {\n\t\tmisp_info(\"rx_fps_info initial!\");\n\t\terrcode = mini_isp_debug_mipi_rx_fps_start(param[1]);\n\t} else if (param[0] == 1) {\n\t\tmisp_info(\"rx_fps_info exit!\");\n\t\tmini_isp_debug_mipi_rx_fps_stop();\n\t}\n\n\tmisp_info(\"%s E\", __func__);\n\treturn errcode;\n}", "item_id": 57, "repo": "wqk317/mi8_kernel_source", "file": "mi8/drivers/media/platform/altek/miniisp_isp.c", "last_update_at": "2020-03-28T11:26:15+00:00", "question_id": "4e0226aa37ae496e3bd8fa8850b38037fe2a3804_57", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ssize_t echo_mini_isp_debug_rx_fps_info(const char *cmd_buf)\n{\n\tsize_t errcode = ERR_SUCCESS;\n\tint ret;\n\tu8 param[2];\n\tchar cmd_name[20];\n\tmisp_info(\"%s S\", __func__);\n\tret = sscanf(cmd_buf, \"%19s %hhu %hhu\", cmd_name, &param[0], &param[1]);\n\tif (ret != 3) {\n\t\terrcode = -EINVAL;\n\t\treturn errcode;\n\t}\n\tif (param[0] == 0) {\n\t\tmisp_info(\"rx_fps_info initial!\");\n\t\terrcode = mini_isp_debug_mipi_rx_fps_start(param[1]);\n\t} else if (param[0] == 1) {\n\t\tmisp_info(\"rx_fps_info exit!\");\n\t\tmini_isp_debug_mipi_rx_fps_stop();\n\t}\n\tmisp_info(\"%s E\", __func__);\n\treturn errcode;\n"]]}
{"hexsha": "70cee756a0b2747d8f02d52c4c8ceca0bdb4ad10", "ext": "c", "lang": "C", "content": "void CWE369_Divide_by_Zero__int_fscanf_divide_68_bad()\r\n{\r\n    int data;\r\n    /* Initialize data */\r\n    data = -1;\r\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\r\n    fscanf(stdin, \"%d\", &data);\r\n    CWE369_Divide_by_Zero__int_fscanf_divide_68_badData = data;\r\n    CWE369_Divide_by_Zero__int_fscanf_divide_68b_badSink();\r\n}", "item_id": 0, "repo": "kppw99/enVAS", "file": "dataset/source/SARD/SARD-3/95194/CWE369_Divide_by_Zero__int_fscanf_divide_68a.c", "last_update_at": "2020-03-17T00:28:31+00:00", "question_id": "70cee756a0b2747d8f02d52c4c8ceca0bdb4ad10_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void CWE369_Divide_by_Zero__int_fscanf_divide_68_bad()\r\n{\r\n    int data;\r\n    /* Initialize data */\r\n    data = -1;\r\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\r\n    fscanf(stdin, \"%d\", &data);\r\n    CWE369_Divide_by_Zero__int_fscanf_divide_68_badData = data;\r\n    CWE369_Divide_by_Zero__int_fscanf_divide_68b_badSink();\r\n"]]}
{"hexsha": "ed90302e9880aa43f62fb398a613a7a2232f4792", "ext": "h", "lang": "C", "content": "static inline VmathMatrix4 vmathM4MakeOrthographic_V(\n    float left, float right, float bottom, float top, float zNear, float zFar)\n{\n    VmathMatrix4 result;\n    vmathM4MakeOrthographic(&result, left, right, bottom, top, zNear, zFar);\n    return result;\n}", "item_id": 363, "repo": "prideout/parg", "file": "include/vmath.h", "last_update_at": "2020-10-07T16:30:26+00:00", "question_id": "ed90302e9880aa43f62fb398a613a7a2232f4792_363", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline VmathMatrix4 vmathM4MakeOrthographic_V(\n    float left, float right, float bottom, float top, float zNear, float zFar)\n{\n    VmathMatrix4 result;\n    vmathM4MakeOrthographic(&result, left, right, bottom, top, zNear, zFar);\n    return result;\n"]]}
{"hexsha": "049fa6835b75b16387f74e2d16cd26cd5eac5a82", "ext": "c", "lang": "C", "content": "static void analyze_pdu(mate_config* mc, mate_pdu* pdu) {\n\t/* TODO:\n\treturn a g_boolean to tell we've destroyed the pdu when the pdu is unnassigned\n\tdestroy the unassigned pdu\n\t*/\n\tmate_cfg_gop* cfg = NULL;\n\tmate_gop* gop = NULL;\n\tgchar* gop_key;\n\tgchar* orig_gop_key = NULL;\n\tAVPL* candidate_start = NULL;\n\tAVPL* candidate_stop = NULL;\n\tAVPL* is_start = NULL;\n\tAVPL* is_stop = NULL;\n\tAVPL* gopkey_match = NULL;\n\tLoAL* gog_keys = NULL;\n\tAVPL* curr_gogkey = NULL;\n\tvoid* cookie = NULL;\n\tAVPL* gogkey_match = NULL;\n\tgchar* gogkey_str = NULL;\n\n\tdbg_print (dbg_gop,1,dbg_facility,\"analyze_pdu: %s\",pdu->cfg->name);\n\n\tif (! (cfg = (mate_cfg_gop *)g_hash_table_lookup(mc->gops_by_pduname,pdu->cfg->name)) )\n\t\treturn;\n\n\tif ((gopkey_match = new_avpl_pairs_match(\"gop_key_match\", pdu->avpl, cfg->key, TRUE, TRUE))) {\n\t\tgop_key = avpl_to_str(gopkey_match);\n\n\t\tg_hash_table_lookup_extended(cfg->gop_index,(gconstpointer)gop_key,(gpointer *)&orig_gop_key,(gpointer *)&gop);\n\n\t\tif ( gop ) {\n\t\t\tg_free(gop_key);\n\n\t\t\t/* is the gop dead ? */\n\t\t\tif ( ! gop->released &&\n\t\t\t\t ( ( gop->cfg->lifetime > 0.0 && gop->time_to_die >= rd->now) ||\n\t\t\t\t   ( gop->cfg->idle_timeout > 0.0 && gop->time_to_timeout >= rd->now) ) ) {\n\t\t\t\tdbg_print (dbg_gop,4,dbg_facility,\"analyze_pdu: expiring released gop\");\n\t\t\t\tgop->released = TRUE;\n\n\t\t\t\tif (gop->gog && gop->cfg->start) gop->gog->num_of_released_gops++;\n\t\t\t}\n\n\t\t\t/* TODO: is the gop expired? */\n\n\t\t\tgop_key = orig_gop_key;\n\n\t\t\tdbg_print (dbg_gop,2,dbg_facility,\"analyze_pdu: got gop: %s\",gop_key);\n\n\t\t\tif (( candidate_start = cfg->start )) {\n\n\t\t\t\tdbg_print (dbg_gop,2,dbg_facility,\"analyze_pdu: got candidate start\");\n\n\t\t\t\tif (( is_start = new_avpl_pairs_match(\"\", pdu->avpl, candidate_start, TRUE, FALSE) )) {\n\t\t\t\t\tdelete_avpl(is_start,FALSE);\n\t\t\t\t\tif ( gop->released ) {\n\t\t\t\t\t\tdbg_print (dbg_gop,3,dbg_facility,\"analyze_pdu: start on released gop, let's create a new gop\");\n\n\t\t\t\t\t\tg_hash_table_remove(cfg->gop_index,gop_key);\n\t\t\t\t\t\tgop->gop_key = NULL;\n\t\t\t\t\t\tgop = new_gop(cfg,pdu,gop_key);\n\t\t\t\t\t\tg_hash_table_insert(cfg->gop_index,gop_key,gop);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdbg_print (dbg_gop,1,dbg_facility,\"analyze_pdu: duplicate start on gop\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpdu->gop = gop;\n\n\t\t\tif (gop->last_pdu) gop->last_pdu->next = pdu;\n\t\t\tgop->last_pdu = pdu;\n\t\t\tpdu->next = NULL;\n\t\t\tpdu->time_in_gop = rd->now - gop->start_time;\n\n\t\t\tif (gop->released) pdu->after_release = TRUE;\n\n\t\t} else {\n\n\t\t\tdbg_print (dbg_gop,1,dbg_facility,\"analyze_pdu: no gop already\");\n\n\t\t\tif ( ! cfg->start ) {\n\t\t\t\t/* there is no GopStart, we'll check for matching GogKeys\n\t\t\t\tif we have one we'll create the Gop */\n\n\t\t\t\tapply_extras(pdu->avpl,gopkey_match,cfg->extra);\n\n\t\t\t\tgog_keys = (LoAL *)g_hash_table_lookup(mc->gogs_by_gopname,cfg->name);\n\n\t\t\t\tif (gog_keys) {\n\n\t\t\t\t\twhile (( curr_gogkey = get_next_avpl(gog_keys,&cookie) )) {\n\t\t\t\t\t\tif (( gogkey_match = new_avpl_pairs_match(cfg->name, gopkey_match, curr_gogkey, TRUE, FALSE) )) {\n\t\t\t\t\t\t\tgogkey_str = avpl_to_str(gogkey_match);\n\n\t\t\t\t\t\t\tif (g_hash_table_lookup(cfg->gog_index,gogkey_str)) {\n\t\t\t\t\t\t\t\tgop = new_gop(cfg,pdu,gop_key);\n\t\t\t\t\t\t\t\tg_hash_table_insert(cfg->gop_index,gop_key,gop);\n\t\t\t\t\t\t\t\tdelete_avpl(gogkey_match,FALSE);\n\t\t\t\t\t\t\t\tg_free(gogkey_str);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdelete_avpl(gogkey_match,FALSE);\n\t\t\t\t\t\t\t\tg_free(gogkey_str);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! gop ) {\n\t\t\t\t\t\tg_free(gop_key);\n\t\t\t\t\t\tdelete_avpl(gopkey_match,TRUE);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tg_free(gop_key);\n\t\t\t\t\tdelete_avpl(gopkey_match,TRUE);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tcandidate_start = cfg->start;\n\n\t\t\t\tif (( is_start = new_avpl_pairs_match(\"\", pdu->avpl, candidate_start, TRUE, FALSE) )) {\n\t\t\t\t\tdelete_avpl(is_start,FALSE);\n\t\t\t\t\tgop = new_gop(cfg,pdu,gop_key);\n\t\t\t\t} else {\n\t\t\t\t\tg_free(gop_key);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tpdu->gop = gop;\n\t\t\t}\n\t\t}\n\n\t\tif (gop->last_pdu) gop->last_pdu->next = pdu;\n\t\tgop->last_pdu = pdu;\n\t\tpdu->next = NULL;\n\n\t\tpdu->time_in_gop = rd->now - gop->start_time;\n\n\t\tgop->num_of_pdus++;\n\t\tgop->time_to_timeout = cfg->idle_timeout > 0.0 ? cfg->idle_timeout + rd->now : (float) -1.0 ;\n\n\t\tdbg_print (dbg_gop,4,dbg_facility,\"analyze_pdu: merge with key\");\n\n\t\tmerge_avpl(gop->avpl,gopkey_match,TRUE);\n\t\tdelete_avpl(gopkey_match,TRUE);\n\n\t\tdbg_print (dbg_gop,4,dbg_facility,\"analyze_pdu: apply extras\");\n\n\t\tapply_extras(pdu->avpl,gop->avpl,gop->cfg->extra);\n\n\t\tgop->last_time = pdu->rel_time;\n\n\t\tif ( ! gop->released) {\n\t\t\tcandidate_stop = cfg->stop;\n\n\t\t\tif (candidate_stop) {\n\t\t\t\tis_stop = new_avpl_pairs_match(\"\", pdu->avpl, candidate_stop, TRUE, FALSE);\n\t\t\t} else {\n\t\t\t\tis_stop = new_avpl(\"\");\n\t\t\t}\n\n\t\t\tif(is_stop) {\n\t\t\t\tdbg_print (dbg_gop,1,dbg_facility,\"analyze_pdu: is a `stop\");\n\t\t\t\tdelete_avpl(is_stop,FALSE);\n\n\t\t\t\tif (! gop->released) {\n\t\t\t\t\tgop->released = TRUE;\n\t\t\t\t\tgop->release_time = pdu->rel_time;\n\t\t\t\t\tif (gop->gog && gop->cfg->start) gop->gog->num_of_released_gops++;\n\t\t\t\t}\n\n\t\t\t\tpdu->is_stop = TRUE;\n\n\t\t\t}\n\t\t}\n\n\t\tif (gop->last_n != gop->avpl->len) apply_transforms(gop->cfg->transforms,gop->avpl);\n\n\t\tgop->last_n = gop->avpl->len;\n\n\t\tif (gop->gog) {\n\t\t\treanalyze_gop(mc, gop);\n\t\t} else {\n\t\t\tanalyze_gop(mc, gop);\n\t\t}\n\n\t} else {\n\t\tdbg_print (dbg_gop,4,dbg_facility,\"analyze_pdu: no match for this pdu\");\n\n\t\tpdu->gop = NULL;\n\t}\n}", "item_id": 12, "repo": "joshis1/C_Programming", "file": "resources/Wireshark/WiresharkDissectorFoo/plugins/epan/mate/mate_runtime.c", "last_update_at": "2020-12-31T11:42:02+00:00", "question_id": "049fa6835b75b16387f74e2d16cd26cd5eac5a82_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void analyze_pdu(mate_config* mc, mate_pdu* pdu) {\n\t/* TODO:\n\treturn a g_boolean to tell we've destroyed the pdu when the pdu is unnassigned\n\tdestroy the unassigned pdu\n\t*/\n\tmate_cfg_gop* cfg = NULL;\n\tmate_gop* gop = NULL;\n\tgchar* gop_key;\n\tgchar* orig_gop_key = NULL;\n\tAVPL* candidate_start = NULL;\n\tAVPL* candidate_stop = NULL;\n\tAVPL* is_start = NULL;\n\tAVPL* is_stop = NULL;\n\tAVPL* gopkey_match = NULL;\n\tLoAL* gog_keys = NULL;\n\tAVPL* curr_gogkey = NULL;\n\tvoid* cookie = NULL;\n\tAVPL* gogkey_match = NULL;\n\tgchar* gogkey_str = NULL;\n\tdbg_print (dbg_gop,1,dbg_facility,\"analyze_pdu: %s\",pdu->cfg->name);\n\tif (! (cfg = (mate_cfg_gop *)g_hash_table_lookup(mc->gops_by_pduname,pdu->cfg->name)) )\n\t\treturn;\n\tif ((gopkey_match = new_avpl_pairs_match(\"gop_key_match\", pdu->avpl, cfg->key, TRUE, TRUE))) {\n\t\tgop_key = avpl_to_str(gopkey_match);\n\t\tg_hash_table_lookup_extended(cfg->gop_index,(gconstpointer)gop_key,(gpointer *)&orig_gop_key,(gpointer *)&gop);\n\t\tif ( gop ) {\n\t\t\tg_free(gop_key);\n\t\t\t/* is the gop dead ? */\n\t\t\tif ( ! gop->released &&\n\t\t\t\t ( ( gop->cfg->lifetime > 0.0 && gop->time_to_die >= rd->now) ||\n\t\t\t\t   ( gop->cfg->idle_timeout > 0.0 && gop->time_to_timeout >= rd->now) ) ) {\n\t\t\t\tdbg_print (dbg_gop,4,dbg_facility,\"analyze_pdu: expiring released gop\");\n\t\t\t\tgop->released = TRUE;\n\t\t\t\tif (gop->gog && gop->cfg->start) gop->gog->num_of_released_gops++;\n\t\t\t}\n\t\t\t/* TODO: is the gop expired? */\n\t\t\tgop_key = orig_gop_key;\n\t\t\tdbg_print (dbg_gop,2,dbg_facility,\"analyze_pdu: got gop: %s\",gop_key);\n\t\t\tif (( candidate_start = cfg->start )) {\n\t\t\t\tdbg_print (dbg_gop,2,dbg_facility,\"analyze_pdu: got candidate start\");\n\t\t\t\tif (( is_start = new_avpl_pairs_match(\"\", pdu->avpl, candidate_start, TRUE, FALSE) )) {\n\t\t\t\t\tdelete_avpl(is_start,FALSE);\n\t\t\t\t\tif ( gop->released ) {\n\t\t\t\t\t\tdbg_print (dbg_gop,3,dbg_facility,\"analyze_pdu: start on released gop, let's create a new gop\");\n\t\t\t\t\t\tg_hash_table_remove(cfg->gop_index,gop_key);\n\t\t\t\t\t\tgop->gop_key = NULL;\n\t\t\t\t\t\tgop = new_gop(cfg,pdu,gop_key);\n\t\t\t\t\t\tg_hash_table_insert(cfg->gop_index,gop_key,gop);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdbg_print (dbg_gop,1,dbg_facility,\"analyze_pdu: duplicate start on gop\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpdu->gop = gop;\n\t\t\tif (gop->last_pdu) gop->last_pdu->next = pdu;\n\t\t\tgop->last_pdu = pdu;\n\t\t\tpdu->next = NULL;\n\t\t\tpdu->time_in_gop = rd->now - gop->start_time;\n\t\t\tif (gop->released) pdu->after_release = TRUE;\n\t\t} else {\n\t\t\tdbg_print (dbg_gop,1,dbg_facility,\"analyze_pdu: no gop already\");\n\t\t\tif ( ! cfg->start ) {\n\t\t\t\t/* there is no GopStart, we'll check for matching GogKeys\n\t\t\t\tif we have one we'll create the Gop */\n\t\t\t\tapply_extras(pdu->avpl,gopkey_match,cfg->extra);\n\t\t\t\tgog_keys = (LoAL *)g_hash_table_lookup(mc->gogs_by_gopname,cfg->name);\n\t\t\t\tif (gog_keys) {\n\t\t\t\t\twhile (( curr_gogkey = get_next_avpl(gog_keys,&cookie) )) {\n\t\t\t\t\t\tif (( gogkey_match = new_avpl_pairs_match(cfg->name, gopkey_match, curr_gogkey, TRUE, FALSE) )) {\n\t\t\t\t\t\t\tgogkey_str = avpl_to_str(gogkey_match);\n\t\t\t\t\t\t\tif (g_hash_table_lookup(cfg->gog_index,gogkey_str)) {\n\t\t\t\t\t\t\t\tgop = new_gop(cfg,pdu,gop_key);\n\t\t\t\t\t\t\t\tg_hash_table_insert(cfg->gop_index,gop_key,gop);\n\t\t\t\t\t\t\t\tdelete_avpl(gogkey_match,FALSE);\n\t\t\t\t\t\t\t\tg_free(gogkey_str);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdelete_avpl(gogkey_match,FALSE);\n\t\t\t\t\t\t\t\tg_free(gogkey_str);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( ! gop ) {\n\t\t\t\t\t\tg_free(gop_key);\n\t\t\t\t\t\tdelete_avpl(gopkey_match,TRUE);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tg_free(gop_key);\n\t\t\t\t\tdelete_avpl(gopkey_match,TRUE);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcandidate_start = cfg->start;\n\t\t\t\tif (( is_start = new_avpl_pairs_match(\"\", pdu->avpl, candidate_start, TRUE, FALSE) )) {\n\t\t\t\t\tdelete_avpl(is_start,FALSE);\n\t\t\t\t\tgop = new_gop(cfg,pdu,gop_key);\n\t\t\t\t} else {\n\t\t\t\t\tg_free(gop_key);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpdu->gop = gop;\n\t\t\t}\n\t\t}\n\t\tif (gop->last_pdu) gop->last_pdu->next = pdu;\n\t\tgop->last_pdu = pdu;\n\t\tpdu->next = NULL;\n\t\tpdu->time_in_gop = rd->now - gop->start_time;\n\t\tgop->num_of_pdus++;\n\t\tgop->time_to_timeout = cfg->idle_timeout > 0.0 ? cfg->idle_timeout + rd->now : (float) -1.0 ;\n\t\tdbg_print (dbg_gop,4,dbg_facility,\"analyze_pdu: merge with key\");\n\t\tmerge_avpl(gop->avpl,gopkey_match,TRUE);\n\t\tdelete_avpl(gopkey_match,TRUE);\n\t\tdbg_print (dbg_gop,4,dbg_facility,\"analyze_pdu: apply extras\");\n\t\tapply_extras(pdu->avpl,gop->avpl,gop->cfg->extra);\n\t\tgop->last_time = pdu->rel_time;\n\t\tif ( ! gop->released) {\n\t\t\tcandidate_stop = cfg->stop;\n\t\t\tif (candidate_stop) {\n\t\t\t\tis_stop = new_avpl_pairs_match(\"\", pdu->avpl, candidate_stop, TRUE, FALSE);\n\t\t\t} else {\n\t\t\t\tis_stop = new_avpl(\"\");\n\t\t\t}\n\t\t\tif(is_stop) {\n\t\t\t\tdbg_print (dbg_gop,1,dbg_facility,\"analyze_pdu: is a `stop\");\n\t\t\t\tdelete_avpl(is_stop,FALSE);\n\t\t\t\tif (! gop->released) {\n\t\t\t\t\tgop->released = TRUE;\n\t\t\t\t\tgop->release_time = pdu->rel_time;\n\t\t\t\t\tif (gop->gog && gop->cfg->start) gop->gog->num_of_released_gops++;\n\t\t\t\t}\n\t\t\t\tpdu->is_stop = TRUE;\n\t\t\t}\n\t\t}\n\t\tif (gop->last_n != gop->avpl->len) apply_transforms(gop->cfg->transforms,gop->avpl);\n\t\tgop->last_n = gop->avpl->len;\n\t\tif (gop->gog) {\n\t\t\treanalyze_gop(mc, gop);\n\t\t} else {\n\t\t\tanalyze_gop(mc, gop);\n\t\t}\n\t} else {\n\t\tdbg_print (dbg_gop,4,dbg_facility,\"analyze_pdu: no match for this pdu\");\n\t\tpdu->gop = NULL;\n\t}\n"]]}
{"hexsha": "efefdffdc23aea4d05ed9b5258b7f2287063ff1d", "ext": "c", "lang": "C", "content": "int ndpi_flowv6_flow_hash(u_int8_t l4_proto, struct ndpi_in6_addr *src_ip, struct ndpi_in6_addr *dst_ip,\n                          u_int16_t src_port, u_int16_t dst_port,\n                          u_int8_t icmp_type, u_int8_t icmp_code,\n                          u_char *hash_buf, u_int8_t hash_buf_len)\n{\n    u_int8_t comm_buf[40] = { 0 };\n    u_int16_t off = 0;\n    u_int16_t seed = 0;\n    struct ndpi_in6_addr *ip_a_ptr, *ip_b_ptr;\n    u_int16_t port_a, port_b;\n    int icmp_one_way = 0;\n\n    switch(l4_proto) {\n    case IPPROTO_ICMPV6:\n        src_port = icmp_type;\n        dst_port = ndpi_community_id_icmp_type_to_code_v6(icmp_type, icmp_code, &icmp_one_way);\n        break;\n    case IPPROTO_SCTP:\n    case IPPROTO_UDP:\n    case IPPROTO_TCP:\n        /* src/dst port ok */\n        break;\n    default:\n        src_port = dst_port = 0;\n        break;\n    }\n\n    /* Convert tuple to NBO */\n    src_port = htons(src_port);\n    dst_port = htons(dst_port);\n\n    if(icmp_one_way || ndpi_community_id_peer_v6_is_less_than(src_ip, dst_ip, src_port, dst_port)) {\n        ip_a_ptr = src_ip, ip_b_ptr = dst_ip;\n        port_a = src_port, port_b = dst_port;\n    } else {\n        ip_a_ptr = dst_ip, ip_b_ptr = src_ip;\n        port_a = dst_port, port_b = src_port;\n    }\n\n    /* Seed */\n    off = ndpi_community_id_buf_copy(&comm_buf[off], &seed, sizeof(seed));\n\n    /* Source and destination IPs */\n    off += ndpi_community_id_buf_copy(&comm_buf[off], ip_a_ptr, sizeof(struct ndpi_in6_addr));\n    off += ndpi_community_id_buf_copy(&comm_buf[off], ip_b_ptr, sizeof(struct ndpi_in6_addr));\n\n    return ndpi_community_id_finalize_and_compute_hash(comm_buf, off,l4_proto, port_a, port_b, (char*)hash_buf, hash_buf_len);\n}", "item_id": 3, "repo": "coolriolee/libndpi", "file": "lib/ndpi_community_id.c", "last_update_at": "2020-05-13T08:06:19+00:00", "question_id": "efefdffdc23aea4d05ed9b5258b7f2287063ff1d_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int ndpi_flowv6_flow_hash(u_int8_t l4_proto, struct ndpi_in6_addr *src_ip, struct ndpi_in6_addr *dst_ip,\n                          u_int16_t src_port, u_int16_t dst_port,\n                          u_int8_t icmp_type, u_int8_t icmp_code,\n                          u_char *hash_buf, u_int8_t hash_buf_len)\n{\n    u_int8_t comm_buf[40] = { 0 };\n    u_int16_t off = 0;\n    u_int16_t seed = 0;\n    struct ndpi_in6_addr *ip_a_ptr, *ip_b_ptr;\n    u_int16_t port_a, port_b;\n    int icmp_one_way = 0;\n    switch(l4_proto) {\n    case IPPROTO_ICMPV6:\n        src_port = icmp_type;\n        dst_port = ndpi_community_id_icmp_type_to_code_v6(icmp_type, icmp_code, &icmp_one_way);\n        break;\n    case IPPROTO_SCTP:\n    case IPPROTO_UDP:\n    case IPPROTO_TCP:\n        /* src/dst port ok */\n        break;\n    default:\n        src_port = dst_port = 0;\n        break;\n    }\n    /* Convert tuple to NBO */\n    src_port = htons(src_port);\n    dst_port = htons(dst_port);\n    if(icmp_one_way || ndpi_community_id_peer_v6_is_less_than(src_ip, dst_ip, src_port, dst_port)) {\n        ip_a_ptr = src_ip, ip_b_ptr = dst_ip;\n        port_a = src_port, port_b = dst_port;\n    } else {\n        ip_a_ptr = dst_ip, ip_b_ptr = src_ip;\n        port_a = dst_port, port_b = src_port;\n    }\n    /* Seed */\n    off = ndpi_community_id_buf_copy(&comm_buf[off], &seed, sizeof(seed));\n    /* Source and destination IPs */\n    off += ndpi_community_id_buf_copy(&comm_buf[off], ip_a_ptr, sizeof(struct ndpi_in6_addr));\n    off += ndpi_community_id_buf_copy(&comm_buf[off], ip_b_ptr, sizeof(struct ndpi_in6_addr));\n    return ndpi_community_id_finalize_and_compute_hash(comm_buf, off,l4_proto, port_a, port_b, (char*)hash_buf, hash_buf_len);\n"]]}
{"hexsha": "2dc0924bb129a6c94913a4ff18116565386017b9", "ext": "c", "lang": "C", "content": "struct GenericList *reverseGenericList(struct GenericList *curr) {\n    if (!curr)\n        return NULL;\n\n    struct GenericList *prev = NULL, *next = NULL;\n    while (curr != NULL) {\n        next = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = next;\n    }\n\n    return prev;\n}", "item_id": 0, "repo": "aloknigam247/cygnus", "file": "src/base/genericlist.c", "last_update_at": "2020-08-05T15:03:58+00:00", "question_id": "2dc0924bb129a6c94913a4ff18116565386017b9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct GenericList *reverseGenericList(struct GenericList *curr) {\n    if (!curr)\n        return NULL;\n    struct GenericList *prev = NULL, *next = NULL;\n    while (curr != NULL) {\n        next = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = next;\n    }\n    return prev;\n"]]}
{"hexsha": "5ea979eb6ba3d15d39c72d2e1641ef3e5cc26c8f", "ext": "c", "lang": "C", "content": "static void\n  vl_api_tap_inject_enable_disable_t_handler\n  (vl_api_tap_inject_enable_disable_t * mp)\n{\n  printf(\"[tap-inject API] %s\\n\", __func__);\n  vl_api_tap_inject_enable_disable_reply_t * rmp;\n  cplane_netdev_main_t * mmp = cplane_netdev_get_main();\n\n  int rv = 0;\n  clib_error_t * err = tap_inject_enable_disable_all_interfaces (mp->is_enable ? 1 : 0);\n  if (err) {\n    tap_inject_enable_disable_all_interfaces (0);\n    rv = -1;\n  }\n\n  REPLY_MACRO (VL_API_TAP_INJECT_ENABLE_DISABLE_REPLY);\n}", "item_id": 12, "repo": "slankdev/netlinkd", "file": "cplane_netdev/cplane_netdev.c", "last_update_at": "2020-03-25T01:28:54+00:00", "question_id": "5ea979eb6ba3d15d39c72d2e1641ef3e5cc26c8f_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\n  vl_api_tap_inject_enable_disable_t_handler\n  (vl_api_tap_inject_enable_disable_t * mp)\n{\n  printf(\"[tap-inject API] %s\\n\", __func__);\n  vl_api_tap_inject_enable_disable_reply_t * rmp;\n  cplane_netdev_main_t * mmp = cplane_netdev_get_main();\n  int rv = 0;\n  clib_error_t * err = tap_inject_enable_disable_all_interfaces (mp->is_enable ? 1 : 0);\n  if (err) {\n    tap_inject_enable_disable_all_interfaces (0);\n    rv = -1;\n  }\n  REPLY_MACRO (VL_API_TAP_INJECT_ENABLE_DISABLE_REPLY);\n"]]}
{"hexsha": "aa27ed54898b470e130bf006df03d402ef7e0076", "ext": "c", "lang": "C", "content": "void init_devices(DWORD devnum)\n{\n\tdevices = (device *)malloc(devnum * sizeof(device));\n\t\n\tif(devices == NULL) {\n\t\tprintf(\"cannot allocate memory for devices...\\n\");\n\t\texit(1);\n\t}\n\t\n\tcurrent_devices = 0;\n}", "item_id": 0, "repo": "gbarletta/venusvm", "file": "src/devices.c", "last_update_at": "2020-09-04T01:08:08+00:00", "question_id": "aa27ed54898b470e130bf006df03d402ef7e0076_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void init_devices(DWORD devnum)\n{\n\tdevices = (device *)malloc(devnum * sizeof(device));\n\t\n\tif(devices == NULL) {\n\t\tprintf(\"cannot allocate memory for devices...\\n\");\n\t\texit(1);\n\t}\n\t\n\tcurrent_devices = 0;\n"]]}
{"hexsha": "e1fa1c3e409967b56975ae65d4b39d032bd80380", "ext": "c", "lang": "C", "content": "bool is_valid_name(const char *name) {\n    int len = 0;\n    while (*name) {\n        char ch = *name;\n        if (++len < 32 && ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch == '_'))) {\n            name++;\n            continue;\n        }\n        return false;\n    }\n    return len > 0 && name[0] != '_';\n}", "item_id": 0, "repo": "lqs/crabdb", "file": "server/src/utils.c", "last_update_at": "2020-07-30T06:14:56+00:00", "question_id": "e1fa1c3e409967b56975ae65d4b39d032bd80380_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool is_valid_name(const char *name) {\n    int len = 0;\n    while (*name) {\n        char ch = *name;\n        if (++len < 32 && ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch == '_'))) {\n            name++;\n            continue;\n        }\n        return false;\n    }\n    return len > 0 && name[0] != '_';\n"]]}
{"hexsha": "26868d8ed1fe25af757fa7a8d009b7e4a914b726", "ext": "c", "lang": "C", "content": "void\nccsip_process_call_info_header (sipMessage_t *request_p, ccsipCCB_t *ccb)\n{\n    char       *call_info_hdrs[MAX_CALL_INFO_HEADERS];\n    uint16_t    num_call_info_headers;\n    int         i = 0;\n\n    if (!ccb) {\n        return;\n    }\n\n    if (ccb->in_call_info) {\n        ccsip_free_call_info_header(ccb->in_call_info);\n        ccb->in_call_info = NULL;\n    }\n\n    if (!request_p) {\n        return;\n    }\n\n    memset(call_info_hdrs, 0, MAX_CALL_INFO_HEADERS * sizeof(char *));\n\n    num_call_info_headers = sippmh_get_num_particular_headers(request_p,\n                                                              SIP_HEADER_CALL_INFO,\n                                                              SIP_HEADER_CALL_INFO,\n                                                              call_info_hdrs,\n                                                              MAX_CALL_INFO_HEADERS);\n    \n    if (num_call_info_headers > 0) {\n        ccb->in_call_info = (cc_call_info_t *)\n            cpr_calloc(1, sizeof(cc_call_info_t));\n        if (ccb->in_call_info) {\n\n            ccb->in_call_info->data.call_info_feat_data.feature_flag = 0;\n\n            // Parse each Call-Info header\n            for (i = 0; i < MAX_CALL_INFO_HEADERS; i++) {\n                if (call_info_hdrs[i]) {                    \n                    ccsip_decode_call_info_hdr(call_info_hdrs[i], ccb->in_call_info);\n                }\n            }\n            \n        } else {\n            ccb->in_call_info = NULL;\n        }\n    }\n    \n}", "item_id": 4, "repo": "wilebeast/FireFox-OS", "file": "B2G/gecko/media/webrtc/signaling/src/sipcc/core/sipstack/ccsip_callinfo.c", "last_update_at": "2020-04-24T20:31:29+00:00", "question_id": "26868d8ed1fe25af757fa7a8d009b7e4a914b726_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nccsip_process_call_info_header (sipMessage_t *request_p, ccsipCCB_t *ccb)\n{\n    char       *call_info_hdrs[MAX_CALL_INFO_HEADERS];\n    uint16_t    num_call_info_headers;\n    int         i = 0;\n    if (!ccb) {\n        return;\n    }\n    if (ccb->in_call_info) {\n        ccsip_free_call_info_header(ccb->in_call_info);\n        ccb->in_call_info = NULL;\n    }\n    if (!request_p) {\n        return;\n    }\n    memset(call_info_hdrs, 0, MAX_CALL_INFO_HEADERS * sizeof(char *));\n    num_call_info_headers = sippmh_get_num_particular_headers(request_p,\n                                                              SIP_HEADER_CALL_INFO,\n                                                              SIP_HEADER_CALL_INFO,\n                                                              call_info_hdrs,\n                                                              MAX_CALL_INFO_HEADERS);\n    if (num_call_info_headers > 0) {\n        ccb->in_call_info = (cc_call_info_t *)\n            cpr_calloc(1, sizeof(cc_call_info_t));\n        if (ccb->in_call_info) {\n            ccb->in_call_info->data.call_info_feat_data.feature_flag = 0;\n            // Parse each Call-Info header\n            for (i = 0; i < MAX_CALL_INFO_HEADERS; i++) {\n                if (call_info_hdrs[i]) {                    \n                    ccsip_decode_call_info_hdr(call_info_hdrs[i], ccb->in_call_info);\n                }\n            }\n        } else {\n            ccb->in_call_info = NULL;\n        }\n    }\n"]]}
{"hexsha": "add02c52453fa9c1158910b1557ff752c3f3e452", "ext": "h", "lang": "C", "content": "inline static int\nnext_utf8(const char *str, int len, uint32_t *cp)\n{\n        unsigned char b0 = (str++)[0];\n        int nbytes;\n\n        if (!len)\n                return -1;\n\n        if (!b0)\n                return -1;\n        else if (b0 < 0x80) { // ASCII\n                *cp = b0; return 1;\n        }\n        else if (b0 < 0xc0) // C1 or continuation\n                return -1;\n        else if (b0 < 0xe0) {\n                nbytes = 2; *cp = b0 & 0x1f;\n        }\n        else if (b0 < 0xf0) {\n                nbytes = 3; *cp = b0 & 0x0f;\n        }\n        else if (b0 < 0xf8) {\n                nbytes = 4; *cp = b0 & 0x07;\n        }\n        else\n                return -1;\n\n        if (len < nbytes)\n                return -1;\n\n        for (int i = 1; i < nbytes; i++) {\n                b0 = (str++)[0];\n                if (!b0)\n                        return -1;\n\n                *cp <<= 6;\n                *cp |= b0 & 0x3f;\n        }\n\n        return nbytes;\n}", "item_id": 0, "repo": "marchelzo/eria", "file": "include/utf8.h", "last_update_at": "2020-05-07T10:35:15+00:00", "question_id": "add02c52453fa9c1158910b1557ff752c3f3e452_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["inline static int\nnext_utf8(const char *str, int len, uint32_t *cp)\n{\n        unsigned char b0 = (str++)[0];\n        int nbytes;\n        if (!len)\n                return -1;\n        if (!b0)\n                return -1;\n        else if (b0 < 0x80) { // ASCII\n                *cp = b0; return 1;\n        }\n        else if (b0 < 0xc0) // C1 or continuation\n                return -1;\n        else if (b0 < 0xe0) {\n                nbytes = 2; *cp = b0 & 0x1f;\n        }\n        else if (b0 < 0xf0) {\n                nbytes = 3; *cp = b0 & 0x0f;\n        }\n        else if (b0 < 0xf8) {\n                nbytes = 4; *cp = b0 & 0x07;\n        }\n        else\n                return -1;\n        if (len < nbytes)\n                return -1;\n        for (int i = 1; i < nbytes; i++) {\n                b0 = (str++)[0];\n                if (!b0)\n                        return -1;\n                *cp <<= 6;\n                *cp |= b0 & 0x3f;\n        }\n        return nbytes;\n"]]}
{"hexsha": "1b76a6a0fab632e5453f879499d0bc1a0ce242fc", "ext": "c", "lang": "C", "content": "static void\nfree_box_tree(BoxNode *n)\n{\n   PixelList *p,*pp;\n   if (n->l) free_box_tree(n->l);\n   if (n->r) free_box_tree(n->r);\n   for (p=n->head[0];p;p=pp) {\n      pp=p->next[0];\n      free(p);\n   }\n   free(n);\n}", "item_id": 14, "repo": "dguo/headlines", "file": "other/Imaging-1.1.7/libImaging/Quant.c", "last_update_at": "2020-08-20T05:42:51+00:00", "question_id": "1b76a6a0fab632e5453f879499d0bc1a0ce242fc_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nfree_box_tree(BoxNode *n)\n{\n   PixelList *p,*pp;\n   if (n->l) free_box_tree(n->l);\n   if (n->r) free_box_tree(n->r);\n   for (p=n->head[0];p;p=pp) {\n      pp=p->next[0];\n      free(p);\n   }\n   free(n);\n"]]}
{"hexsha": "50294e07e60ca3fdc609ae6eaae73866d884b854", "ext": "c", "lang": "C", "content": "int split_indel_map(cigar32_t **res_cigar, int *res_len, int *res_m,\n                    uint8_t *read_seq, int read_len, uint8_t *ref_seq, int ref_len, \n                    int ref_offset,\n                    lamsa_aln_para *AP,\n                    uint32_t **hash_num, uint64_t ***hash_node)\n{\n    int hash_len = AP->hash_len, key_len = AP->hash_key_len, hash_size = AP->hash_size;\n\n\tint32_t *hash_pos = (int32_t*)malloc(ref_len * sizeof(int32_t)); int **hash_node_num;\n\tinit_hash(ref_seq, ref_len, hash_len, hash_num, hash_node, &hash_node_num, &hash_pos, key_len, hash_size);\n\n\tint res;\n\tres = hash_split_map(res_cigar, res_len, res_m, ref_seq, ref_len, ref_offset, read_seq, read_len, AP, *hash_num, *hash_node, hash_node_num, hash_pos, 1, 1);\n\n\tfree(hash_pos);\n\tint i; for (i = 0; i < hash_size; ++i) free(hash_node_num[i]);\n\tfree(hash_node_num);\n\treturn res;\n}", "item_id": 16, "repo": "gaoyan07/LSAT", "file": "src/split_mapping.c", "last_update_at": "2020-04-17T05:42:47+00:00", "question_id": "50294e07e60ca3fdc609ae6eaae73866d884b854_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int split_indel_map(cigar32_t **res_cigar, int *res_len, int *res_m,\n                    uint8_t *read_seq, int read_len, uint8_t *ref_seq, int ref_len, \n                    int ref_offset,\n                    lamsa_aln_para *AP,\n                    uint32_t **hash_num, uint64_t ***hash_node)\n{\n    int hash_len = AP->hash_len, key_len = AP->hash_key_len, hash_size = AP->hash_size;\n\tint32_t *hash_pos = (int32_t*)malloc(ref_len * sizeof(int32_t)); int **hash_node_num;\n\tinit_hash(ref_seq, ref_len, hash_len, hash_num, hash_node, &hash_node_num, &hash_pos, key_len, hash_size);\n\tint res;\n\tres = hash_split_map(res_cigar, res_len, res_m, ref_seq, ref_len, ref_offset, read_seq, read_len, AP, *hash_num, *hash_node, hash_node_num, hash_pos, 1, 1);\n\tfree(hash_pos);\n\tint i; for (i = 0; i < hash_size; ++i) free(hash_node_num[i]);\n\tfree(hash_node_num);\n\treturn res;\n"]]}
{"hexsha": "f4dd81e4dc7e5773cc51877a9dd7294d9d792af8", "ext": "c", "lang": "C", "content": "Int32 TarsOutputStream_writeVectorCharBuffer(TarsOutputStream * os, const char* buff, uint32_t len, uint8_t tag)\r\n{\r\n\tInt32 ret;\r\n\tDataHead *hh;\r\n\r\n\t//DataHead_setType(os->_h, eSimpleList);\r\n\t// DataHead_setTag(os->_h, tag);\r\n\r\n\t//ret = DataHead_writeTo(os->_h, os);\r\n\tret = DataHead_setAndWriteTo(os->_h, eSimpleList, tag, os);\r\n\tif (TARS_SUCCESS != ret)\treturn ret;\r\n\r\n\thh = DataHead_new();\r\n\tif (!hh) return TARS_MALLOC_ERROR;\r\n\r\n\t//DataHead_setType(hh, eChar);\r\n\t//DataHead_setTag(hh, 0);\r\n\r\n\t//ret = DataHead_writeTo(hh, os);\r\n\tret = DataHead_setAndWriteTo(hh, eChar, 0, os);\r\n\tDataHead_del(&hh);\r\n\r\n\tif (TARS_SUCCESS != ret)\treturn ret;\r\n\r\n\tret = TarsOutputStream_writeInt32(os, len, 0);\r\n\tif (TARS_SUCCESS != ret)\treturn ret;\r\n\r\n\treturn TarsOutputStream_writeBuf(os, buff, len);\r\n}", "item_id": 68, "repo": "yangg37/Tars", "file": "php/tarsclient/ext/tars_c.c", "last_update_at": "2020-01-28T15:48:30+00:00", "question_id": "f4dd81e4dc7e5773cc51877a9dd7294d9d792af8_68", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Int32 TarsOutputStream_writeVectorCharBuffer(TarsOutputStream * os, const char* buff, uint32_t len, uint8_t tag)\r\n{\r\n\tInt32 ret;\r\n\tDataHead *hh;\r\n\r\n\t//DataHead_setType(os->_h, eSimpleList);\r\n\t// DataHead_setTag(os->_h, tag);\r\n\r\n\t//ret = DataHead_writeTo(os->_h, os);\r\n\tret = DataHead_setAndWriteTo(os->_h, eSimpleList, tag, os);\r\n\tif (TARS_SUCCESS != ret)\treturn ret;\r\n\r\n\thh = DataHead_new();\r\n\tif (!hh) return TARS_MALLOC_ERROR;\r\n\r\n\t//DataHead_setType(hh, eChar);\r\n\t//DataHead_setTag(hh, 0);\r\n\r\n\t//ret = DataHead_writeTo(hh, os);\r\n\tret = DataHead_setAndWriteTo(hh, eChar, 0, os);\r\n\tDataHead_del(&hh);\r\n\r\n\tif (TARS_SUCCESS != ret)\treturn ret;\r\n\r\n\tret = TarsOutputStream_writeInt32(os, len, 0);\r\n\tif (TARS_SUCCESS != ret)\treturn ret;\r\n\r\n\treturn TarsOutputStream_writeBuf(os, buff, len);\r\n"]]}
{"hexsha": "5c420184fc59a9c3f0664bd58fd5bfdc641d8563", "ext": "c", "lang": "C", "content": "void SLL()\r\n{\r\n int ch=0;\r\n first=NULL;\r\n last=NULL;\r\n clrscr();\r\n while(ch!=9)\r\n{\r\n printf(\"enter your choice 1) insertion at beginning 2) insertion in middle 3) insertion at end 4) deletion at beginning 5) deletion in middle 6)deletion at end 7) display 8)search 9) exit\\n\");\r\n scanf(\"%d\",&ch);\r\n if(ch==1)\r\n {\r\n  insert_beg();\r\n  count++;\r\n }\r\n else if(ch==2)\r\n {\r\n   insert_mid();\r\n   count++;\r\n }\r\n else if(ch==3)\r\n {\r\n  insert_end();\r\n  count++;\r\n }\r\n else if(ch==4)\r\n {\r\n  del_beg();\r\n  count--;\r\n }\r\n else if(ch==5)\r\n {\r\n  del_mid();\r\n  count--;\r\n }\r\n else if(ch==6)\r\n {\r\n  del_end();\r\n  count--;\r\n }\r\n else if(ch==7)\r\n {\r\n  display();\r\n }\r\n else if(ch==9)\r\n {\r\n  printf(\"exit\\n\");\r\n }\r\n else if(ch==8)\r\n {\r\n   search();\r\n }\r\n else\r\n {\r\n  printf(\"error\\n\");\r\n  }\r\n  }\r\n  getch();\r\n  }", "item_id": 5, "repo": "codetronaut/combined_c_proj", "file": "libraries/src/libraries/Will_Add/LINK.c", "last_update_at": "2020-06-17T20:48:26+00:00", "question_id": "5c420184fc59a9c3f0664bd58fd5bfdc641d8563_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void SLL()\r\n{\r\n int ch=0;\r\n first=NULL;\r\n last=NULL;\r\n clrscr();\r\n while(ch!=9)\r\n{\r\n printf(\"enter your choice 1) insertion at beginning 2) insertion in middle 3) insertion at end 4) deletion at beginning 5) deletion in middle 6)deletion at end 7) display 8)search 9) exit\\n\");\r\n scanf(\"%d\",&ch);\r\n if(ch==1)\r\n {\r\n  insert_beg();\r\n  count++;\r\n }\r\n else if(ch==2)\r\n {\r\n   insert_mid();\r\n   count++;\r\n }\r\n else if(ch==3)\r\n {\r\n  insert_end();\r\n  count++;\r\n }\r\n else if(ch==4)\r\n {\r\n  del_beg();\r\n  count--;\r\n }\r\n else if(ch==5)\r\n {\r\n  del_mid();\r\n  count--;\r\n }\r\n else if(ch==6)\r\n {\r\n  del_end();\r\n  count--;\r\n }\r\n else if(ch==7)\r\n {\r\n  display();\r\n }\r\n else if(ch==9)\r\n {\r\n  printf(\"exit\\n\");\r\n }\r\n else if(ch==8)\r\n {\r\n   search();\r\n }\r\n else\r\n {\r\n  printf(\"error\\n\");\r\n  }\r\n  }\r\n  getch();\r\n"]]}
{"hexsha": "c8677bd81988b79068dd778f289b0cc50f8402cf", "ext": "h", "lang": "C", "content": "static inline int\nfetch16 (unw_addr_space_t as, unw_accessors_t *a,\n\t unw_word_t *addr, int16_t *valp, void *arg)\n{\n  unw_word_t val, aligned_addr = *addr & -WSIZE, off = *addr - aligned_addr;\n  int ret;\n\n  assert ((off & 0x1) == 0);\n\n  *addr += 2;\n\n  ret = (*a->access_mem) (as, aligned_addr, &val, 0, arg);\n\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n  val >>= 8*off;\n#else\n  val >>= 8*(WSIZE - 2 - off);\n#endif\n  *valp = val & 0xffff;\n  return ret;\n}", "item_id": 5, "repo": "wilebeast/FireFox-OS", "file": "B2G/gecko/tools/profiler/libunwind/src/include/remote.h", "last_update_at": "2020-04-24T20:31:29+00:00", "question_id": "c8677bd81988b79068dd778f289b0cc50f8402cf_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline int\nfetch16 (unw_addr_space_t as, unw_accessors_t *a,\n\t unw_word_t *addr, int16_t *valp, void *arg)\n{\n  unw_word_t val, aligned_addr = *addr & -WSIZE, off = *addr - aligned_addr;\n  int ret;\n  assert ((off & 0x1) == 0);\n  *addr += 2;\n  ret = (*a->access_mem) (as, aligned_addr, &val, 0, arg);\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n  val >>= 8*off;\n#else\n  val >>= 8*(WSIZE - 2 - off);\n#endif\n  *valp = val & 0xffff;\n  return ret;\n"]]}
{"hexsha": "a2797098d444f0923f2788224f1978bf14994167", "ext": "c", "lang": "C", "content": "static struct rb_mjit_unit *\nget_from_list(struct rb_mjit_unit_list *list)\n{\n    struct rb_mjit_unit *unit = NULL, *next, *best = NULL;\n\n    /* Find iseq with max total_calls */\n    list_for_each_safe(&list->head, unit, next, unode) {\n        if (unit->iseq == NULL) { /* ISeq is GCed. */\n            remove_from_list(unit, list);\n            free_unit(unit);\n            continue;\n        }\n\n        if (best == NULL || best->iseq->body->total_calls < unit->iseq->body->total_calls) {\n            best = unit;\n        }\n    }\n    if (best) {\n        remove_from_list(best, list);\n    }\n    return best;\n}", "item_id": 3, "repo": "kke/ruby-packer", "file": "ruby/mjit_worker.c", "last_update_at": "2020-06-29T21:27:54+00:00", "question_id": "a2797098d444f0923f2788224f1978bf14994167_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct rb_mjit_unit *\nget_from_list(struct rb_mjit_unit_list *list)\n{\n    struct rb_mjit_unit *unit = NULL, *next, *best = NULL;\n    /* Find iseq with max total_calls */\n    list_for_each_safe(&list->head, unit, next, unode) {\n        if (unit->iseq == NULL) { /* ISeq is GCed. */\n            remove_from_list(unit, list);\n            free_unit(unit);\n            continue;\n        }\n        if (best == NULL || best->iseq->body->total_calls < unit->iseq->body->total_calls) {\n            best = unit;\n        }\n    }\n    if (best) {\n        remove_from_list(best, list);\n    }\n    return best;\n"]]}
{"hexsha": "534e9bc98fce94c2c863f6522da0354eecf878a9", "ext": "c", "lang": "C", "content": "const char *sdl_ui_menu_toggle_helper(int activated, const char *resource_name)\n{\n    int value, r;\n\n    if (activated) {\n        r = resources_toggle(resource_name, &value);\n        if (r < 0) {\n            r = resources_get_int(resource_name, &value);\n        }\n    } else {\n        r = resources_get_int(resource_name, &value);\n    }\n\n    if (r < 0) {\n        return sdl_menu_text_unknown;\n    } else {\n        return value ? sdl_menu_text_tick : NULL;\n    }\n}", "item_id": 4, "repo": "paulscottrobson/cxp-computer", "file": "core/vice-3.3/src/arch/sdl/menu_common.c", "last_update_at": "2020-02-03T16:46:40+00:00", "question_id": "534e9bc98fce94c2c863f6522da0354eecf878a9_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const char *sdl_ui_menu_toggle_helper(int activated, const char *resource_name)\n{\n    int value, r;\n    if (activated) {\n        r = resources_toggle(resource_name, &value);\n        if (r < 0) {\n            r = resources_get_int(resource_name, &value);\n        }\n    } else {\n        r = resources_get_int(resource_name, &value);\n    }\n    if (r < 0) {\n        return sdl_menu_text_unknown;\n    } else {\n        return value ? sdl_menu_text_tick : NULL;\n    }\n"]]}
{"hexsha": "eb6fb4e121a8272cbc5bac085ccee6699d6687ae", "ext": "c", "lang": "C", "content": "static void Compute_Bridge_Path(Path *path1, Path *path2, Alignment *align, int comp,\n                                int aovl, int bovl, Work_Data *work, Trace_Buffer *tbuf)\n{ Path   *apath;\n  int     ain, aout;\n  int     bin, bout, boff;\n  int     i, j, p;\n  uint16 *trk;\n\n  apath = align->path;\n\n  if (bovl > aovl)\n    { bin  = path2->bbpos;\n      bout = path1->bepos;\n      ain  = MapToTPBelow(path1,&bin,0,tbuf);\n      aout = MapToTPAbove(path2,&bout,0,tbuf);\n    }\n  else\n    { ain  = path2->abpos;\n      aout = path1->aepos;\n      bin  = MapToTPBelow(path1,&ain,1,tbuf);\n      bout = MapToTPAbove(path2,&aout,1,tbuf);\n    }\n\n#ifdef TEST_BRIDGE\n  printf(\"\\n  Tangle [%5d..%5d] vs [%5d..%5d]  %4d\\n\",\n      path1->abpos,path1->aepos,path2->abpos,path2->aepos,abs(aovl-bovl));\n  printf(\"         [%5d..%5d] vs [%5d..%5d]  %4d vs %4d\\n\",\n      path1->bbpos,path1->bepos,path2->bbpos,path2->bepos,aovl,bovl);\n  printf(\"      (%d,%d) to (%d,%d)\\n\",ain,bin,aout,bout);\n  fflush(stdout);\n#endif\n\n  apath->abpos = ain - 2*MR_tspace;\n  apath->aepos = aout + 2*MR_tspace;\n  apath->bbpos = MapToTPBelow(path1,&(apath->abpos),1,tbuf);\n  apath->bepos = MapToTPAbove(path2,&(apath->aepos),1,tbuf);\n\n  if (comp)\n    { boff = MR_tspace - apath->aepos % MR_tspace;\n\n      p = align->alen - apath->abpos;\n      apath->abpos = align->alen - apath->aepos;\n      apath->aepos = p;\n      p = align->blen - apath->bbpos;\n      apath->bbpos = align->blen - apath->bepos;\n      apath->bepos = p;\n\n      boff = boff - apath->abpos % MR_tspace;\n      align->aseq  -= boff;\n      apath->abpos += boff;\n      apath->aepos += boff;\n      align->alen  += boff;\n    }\n\n#ifdef TEST_BRIDGE\n  printf(\"\\n      (%d,%d) to (%d,%d)\\n\",apath->abpos,apath->bbpos,apath->aepos,apath->bepos);\n  fflush(stdout);\n\n  Compute_Alignment(align,work,DIFF_ALIGN,0);\n  Print_Reference(stdout,align,work,8,100,10,0,6);\n  fflush(stdout);\n#endif\n\n  Compute_Alignment(align,work,DIFF_TRACE,MR_tspace);\n\n  trk = (uint16 *) apath->trace;\n  if (comp)\n    { j = apath->tlen-2;\n      i = 0;\n      while (i < j)\n        { p = trk[i];\n          trk[i] = trk[j];\n          trk[j] = p;\n          p = trk[i+1];\n          trk[i+1] = trk[j+1];\n          trk[j+1] = p;\n          i += 2;\n          j -= 2;\n        }\n\n      align->aseq  += boff;\n      apath->abpos -= boff;\n      apath->aepos -= boff;\n      align->alen  -= boff;\n\n      p = align->alen - apath->abpos;\n      apath->abpos = align->alen - apath->aepos;\n      apath->aepos = p;\n      p = align->blen - apath->bbpos;\n      apath->bbpos = align->blen - apath->bepos;\n      apath->bepos = p;\n    }\n\n#ifdef TEST_BRIDGE\n  { int err;\n\n    bin  = apath->bbpos;\n    bout = apath->bepos;\n    err  = apath->diffs;\n\n    p = 2*(ain / MR_tspace - apath->abpos / MR_tspace);\n    for (i = 0; i < p; i += 2)\n      { bin += trk[i+1];\n        err -= trk[i];\n      }\n\n    p = 2*(apath->aepos / MR_tspace - aout / MR_tspace);\n    for (i = align->path->tlen, p = i-p; i > p; i -= 2)\n      { bout -= trk[i-1];\n        err  -= trk[i-2];\n      }\n\n    printf(\"      (%d,%d) to (%d,%d)\\n\",ain,bin,aout,bout);\n    printf(\"  Box %d vs %d -> %d %d%%\\n\",aout-ain,bout-bin,err,\n                                         (200*err)/((aout-ain)+(bout-bin)));\n    fflush(stdout);\n  }\n#endif\n\n  if (tbuf->top + apath->tlen >= tbuf->max)\n    { tbuf->max = 1.2*(tbuf->top+apath->tlen) + TRACE_CHUNK;\n      tbuf->trace = (uint16 *) Realloc(tbuf->trace,sizeof(uint16)*tbuf->max,\"Allocating paths\");\n      if (tbuf->trace == NULL)\n        Clean_Exit(1);\n    }\n  trk = tbuf->trace + tbuf->top;\n  memcpy(trk,apath->trace,apath->tlen*sizeof(uint16));\n  apath->trace = (void *) (tbuf->top);\n  tbuf->top += apath->tlen;\n}", "item_id": 12, "repo": "PacificBiosciences/DALIGNER", "file": "filter.c", "last_update_at": "2020-04-24T08:24:51+00:00", "question_id": "eb6fb4e121a8272cbc5bac085ccee6699d6687ae_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void Compute_Bridge_Path(Path *path1, Path *path2, Alignment *align, int comp,\n                                int aovl, int bovl, Work_Data *work, Trace_Buffer *tbuf)\n{ Path   *apath;\n  int     ain, aout;\n  int     bin, bout, boff;\n  int     i, j, p;\n  uint16 *trk;\n  apath = align->path;\n  if (bovl > aovl)\n    { bin  = path2->bbpos;\n      bout = path1->bepos;\n      ain  = MapToTPBelow(path1,&bin,0,tbuf);\n      aout = MapToTPAbove(path2,&bout,0,tbuf);\n    }\n  else\n    { ain  = path2->abpos;\n      aout = path1->aepos;\n      bin  = MapToTPBelow(path1,&ain,1,tbuf);\n      bout = MapToTPAbove(path2,&aout,1,tbuf);\n    }\n#ifdef TEST_BRIDGE\n  printf(\"\\n  Tangle [%5d..%5d] vs [%5d..%5d]  %4d\\n\",\n      path1->abpos,path1->aepos,path2->abpos,path2->aepos,abs(aovl-bovl));\n  printf(\"         [%5d..%5d] vs [%5d..%5d]  %4d vs %4d\\n\",\n      path1->bbpos,path1->bepos,path2->bbpos,path2->bepos,aovl,bovl);\n  printf(\"      (%d,%d) to (%d,%d)\\n\",ain,bin,aout,bout);\n  fflush(stdout);\n#endif\n  apath->abpos = ain - 2*MR_tspace;\n  apath->aepos = aout + 2*MR_tspace;\n  apath->bbpos = MapToTPBelow(path1,&(apath->abpos),1,tbuf);\n  apath->bepos = MapToTPAbove(path2,&(apath->aepos),1,tbuf);\n  if (comp)\n    { boff = MR_tspace - apath->aepos % MR_tspace;\n      p = align->alen - apath->abpos;\n      apath->abpos = align->alen - apath->aepos;\n      apath->aepos = p;\n      p = align->blen - apath->bbpos;\n      apath->bbpos = align->blen - apath->bepos;\n      apath->bepos = p;\n      boff = boff - apath->abpos % MR_tspace;\n      align->aseq  -= boff;\n      apath->abpos += boff;\n      apath->aepos += boff;\n      align->alen  += boff;\n    }\n#ifdef TEST_BRIDGE\n  printf(\"\\n      (%d,%d) to (%d,%d)\\n\",apath->abpos,apath->bbpos,apath->aepos,apath->bepos);\n  fflush(stdout);\n  Compute_Alignment(align,work,DIFF_ALIGN,0);\n  Print_Reference(stdout,align,work,8,100,10,0,6);\n  fflush(stdout);\n#endif\n  Compute_Alignment(align,work,DIFF_TRACE,MR_tspace);\n  trk = (uint16 *) apath->trace;\n  if (comp)\n    { j = apath->tlen-2;\n      i = 0;\n      while (i < j)\n        { p = trk[i];\n          trk[i] = trk[j];\n          trk[j] = p;\n          p = trk[i+1];\n          trk[i+1] = trk[j+1];\n          trk[j+1] = p;\n          i += 2;\n          j -= 2;\n        }\n      align->aseq  += boff;\n      apath->abpos -= boff;\n      apath->aepos -= boff;\n      align->alen  -= boff;\n      p = align->alen - apath->abpos;\n      apath->abpos = align->alen - apath->aepos;\n      apath->aepos = p;\n      p = align->blen - apath->bbpos;\n      apath->bbpos = align->blen - apath->bepos;\n      apath->bepos = p;\n    }\n#ifdef TEST_BRIDGE\n  { int err;\n    bin  = apath->bbpos;\n    bout = apath->bepos;\n    err  = apath->diffs;\n    p = 2*(ain / MR_tspace - apath->abpos / MR_tspace);\n    for (i = 0; i < p; i += 2)\n      { bin += trk[i+1];\n        err -= trk[i];\n      }\n    p = 2*(apath->aepos / MR_tspace - aout / MR_tspace);\n    for (i = align->path->tlen, p = i-p; i > p; i -= 2)\n      { bout -= trk[i-1];\n        err  -= trk[i-2];\n      }\n    printf(\"      (%d,%d) to (%d,%d)\\n\",ain,bin,aout,bout);\n    printf(\"  Box %d vs %d -> %d %d%%\\n\",aout-ain,bout-bin,err,\n                                         (200*err)/((aout-ain)+(bout-bin)));\n    fflush(stdout);\n  }\n#endif\n  if (tbuf->top + apath->tlen >= tbuf->max)\n    { tbuf->max = 1.2*(tbuf->top+apath->tlen) + TRACE_CHUNK;\n      tbuf->trace = (uint16 *) Realloc(tbuf->trace,sizeof(uint16)*tbuf->max,\"Allocating paths\");\n      if (tbuf->trace == NULL)\n        Clean_Exit(1);\n    }\n  trk = tbuf->trace + tbuf->top;\n  memcpy(trk,apath->trace,apath->tlen*sizeof(uint16));\n  apath->trace = (void *) (tbuf->top);\n  tbuf->top += apath->tlen;\n"]]}
{"hexsha": "859b313cc12dfef3c76e74bf45abca23ec8cdf29", "ext": "c", "lang": "C", "content": "static void CALLBACK vertexCallback(GLvoid *vertex)\n{\n    GLdouble *ptr;\n    ptr = (GLdouble *) vertex;\n    glVertex3dv((GLdouble *) ptr);\n\n}", "item_id": 1, "repo": "andraantariksa/cit205-nfa-to-dfa", "file": "external/graphviz/cmd/smyrna/polytess.c", "last_update_at": "2020-02-21T01:52:17+00:00", "question_id": "859b313cc12dfef3c76e74bf45abca23ec8cdf29_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void CALLBACK vertexCallback(GLvoid *vertex)\n{\n    GLdouble *ptr;\n    ptr = (GLdouble *) vertex;\n    glVertex3dv((GLdouble *) ptr);\n"]]}
{"hexsha": "8de761e9ead6f595f0feaa03296d29b47fda5a0b", "ext": "c", "lang": "C", "content": "flea_err_e THR_flea_mpi_t__add_in_place_ignore_sign(\n  flea_mpi_t*       p_in_out,\n  const flea_mpi_t* p_b\n)\n{\n  flea_uword_t carry = 0;\n  flea_mpi_ulen_t i;\n\n  FLEA_THR_BEG_FUNC();\n  if(p_in_out->m_nb_alloc_words < p_b->m_nb_used_words)\n  {\n    FLEA_THROW(\"error: addition result mpi too small to hold result value\", FLEA_ERR_BUFF_TOO_SMALL);\n  }\n  // prepare result for expansion\n  memset(\n    &p_in_out->m_words[p_in_out->m_nb_used_words],\n    0,\n    sizeof(p_in_out->m_words[0]) * (p_in_out->m_nb_alloc_words - p_in_out->m_nb_used_words)\n  );\n  // from here on we can process the words of b\n  for(i = 0; i < p_b->m_nb_used_words; i++)\n  {\n    flea_dbl_uword_t carry_res;\n    carry_res = ((flea_dbl_uword_t) p_in_out->m_words[i]) + p_b->m_words[i] + carry;\n\n    p_in_out->m_words[i] = ((flea_uword_t) carry_res);\n\n    carry = carry_res >> (sizeof(flea_uword_t) * 8);\n  }\n  // handle remaining borrow (because a is not smaller than b, there must be\n  // another word in a if there is a borrow pending after processing the highest word of b)\n  while(carry) // maximally two iterations\n  {\n    flea_uword_t orig_word = 0;\n    flea_dbl_uword_t carry_res;\n    if(i >= p_in_out->m_nb_used_words)\n    {\n      if(i >= p_in_out->m_nb_alloc_words)\n      {\n        FLEA_THROW(\"addition result too large\", FLEA_ERR_BUFF_TOO_SMALL);\n      }\n    }\n    else\n    {\n      orig_word = p_in_out->m_words[i];\n    }\n    carry_res = ((flea_dbl_uword_t) orig_word) + carry;\n    p_in_out->m_words[i] = ((flea_uword_t) carry_res);\n\n    carry = carry_res >> (sizeof(flea_uword_t) * 8);\n    i++;\n  }\n  flea_mpi_t__set_used_words(p_in_out);\n  FLEA_THR_FIN_SEC();\n}", "item_id": 14, "repo": "falko-strenzke/fleaTLS", "file": "src/common/math/mpi.c", "last_update_at": "2020-08-06T10:25:03+00:00", "question_id": "8de761e9ead6f595f0feaa03296d29b47fda5a0b_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["flea_err_e THR_flea_mpi_t__add_in_place_ignore_sign(\n  flea_mpi_t*       p_in_out,\n  const flea_mpi_t* p_b\n)\n{\n  flea_uword_t carry = 0;\n  flea_mpi_ulen_t i;\n  FLEA_THR_BEG_FUNC();\n  if(p_in_out->m_nb_alloc_words < p_b->m_nb_used_words)\n  {\n    FLEA_THROW(\"error: addition result mpi too small to hold result value\", FLEA_ERR_BUFF_TOO_SMALL);\n  }\n  // prepare result for expansion\n  memset(\n    &p_in_out->m_words[p_in_out->m_nb_used_words],\n    0,\n    sizeof(p_in_out->m_words[0]) * (p_in_out->m_nb_alloc_words - p_in_out->m_nb_used_words)\n  );\n  // from here on we can process the words of b\n  for(i = 0; i < p_b->m_nb_used_words; i++)\n  {\n    flea_dbl_uword_t carry_res;\n    carry_res = ((flea_dbl_uword_t) p_in_out->m_words[i]) + p_b->m_words[i] + carry;\n    p_in_out->m_words[i] = ((flea_uword_t) carry_res);\n    carry = carry_res >> (sizeof(flea_uword_t) * 8);\n  }\n  // handle remaining borrow (because a is not smaller than b, there must be\n  // another word in a if there is a borrow pending after processing the highest word of b)\n  while(carry) // maximally two iterations\n  {\n    flea_uword_t orig_word = 0;\n    flea_dbl_uword_t carry_res;\n    if(i >= p_in_out->m_nb_used_words)\n    {\n      if(i >= p_in_out->m_nb_alloc_words)\n      {\n        FLEA_THROW(\"addition result too large\", FLEA_ERR_BUFF_TOO_SMALL);\n      }\n    }\n    else\n    {\n      orig_word = p_in_out->m_words[i];\n    }\n    carry_res = ((flea_dbl_uword_t) orig_word) + carry;\n    p_in_out->m_words[i] = ((flea_uword_t) carry_res);\n    carry = carry_res >> (sizeof(flea_uword_t) * 8);\n    i++;\n  }\n  flea_mpi_t__set_used_words(p_in_out);\n  FLEA_THR_FIN_SEC();\n"]]}
{"hexsha": "2e2d6c34c08ca648b6bc7347e61fddbc34bb3497", "ext": "h", "lang": "C", "content": "static inline h5_err_t\nhdf5_get_mdc_property (\n        hid_t fapl_id,\n        H5AC_cache_config_t *config\n        ) {\n\tHDF5_WRAPPER_ENTER (h5_err_t,\n\t\t\t    \"fapl_id=%lld, config=%p\",\n\t\t\t    (long long int)fapl_id, config);\n\tif (H5Pget_mdc_config (fapl_id, config) < 0)\n\t\tH5_RETURN_ERROR (\n\t\t\tH5_ERR_HDF5,\n\t\t\t\"%s\",\n\t\t\t\"Cannot get metadata cache configuration in\"\n\t\t\t\" the file access property list.\");\n\tH5_RETURN (H5_SUCCESS);\n}", "item_id": 48, "repo": "greole/H5hut", "file": "src/h5core/private/h5_hdf5.h", "last_update_at": "2020-01-12T14:01:55+00:00", "question_id": "2e2d6c34c08ca648b6bc7347e61fddbc34bb3497_48", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline h5_err_t\nhdf5_get_mdc_property (\n        hid_t fapl_id,\n        H5AC_cache_config_t *config\n        ) {\n\tHDF5_WRAPPER_ENTER (h5_err_t,\n\t\t\t    \"fapl_id=%lld, config=%p\",\n\t\t\t    (long long int)fapl_id, config);\n\tif (H5Pget_mdc_config (fapl_id, config) < 0)\n\t\tH5_RETURN_ERROR (\n\t\t\tH5_ERR_HDF5,\n\t\t\t\"%s\",\n\t\t\t\"Cannot get metadata cache configuration in\"\n\t\t\t\" the file access property list.\");\n\tH5_RETURN (H5_SUCCESS);\n"]]}
{"hexsha": "d63fb502ae1c98a24619f5720717602367a2559e", "ext": "c", "lang": "C", "content": "__attribute__((noinline, section(\".printf_lite\")))\n#endif\nstatic void output_utf8_string_as_utf8(const char* s, PrintfParams* printfParams)\n{\n\tif ( !s ) return;\n//#if PRINTF_LITE_STRING_WIDTH_SPECIFIER_SUPPORT == 1\n//  size_t len = lengt\n//#endif\n\tif ( printfParams->precision_specifier >= 0 ) {\n    while ( *s && printfParams->precision_specifier-- ) print_utf8_char(*s++, printfParams);\n  }\n\telse\n  {\n    while ( *s ) print_utf8_char(*s++, printfParams);\n  }\n}", "item_id": 3, "repo": "jungeshidai/CloverBootloader", "file": "Library/MemLogLibDefault/printf_lite.c", "last_update_at": "2020-11-07T13:13:12+00:00", "question_id": "d63fb502ae1c98a24619f5720717602367a2559e_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["__attribute__((noinline, section(\".printf_lite\")))\n#endif\nstatic void output_utf8_string_as_utf8(const char* s, PrintfParams* printfParams)\n{\n\tif ( !s ) return;\n//#if PRINTF_LITE_STRING_WIDTH_SPECIFIER_SUPPORT == 1\n//  size_t len = lengt\n//#endif\n\tif ( printfParams->precision_specifier >= 0 ) {\n    while ( *s && printfParams->precision_specifier-- ) print_utf8_char(*s++, printfParams);\n  }\n\telse\n  {\n    while ( *s ) print_utf8_char(*s++, printfParams);\n  }\n"]]}
{"hexsha": "666f437624b2d3c9cf6e20be2d5f3dfe3ec1aa44", "ext": "c", "lang": "C", "content": "int\nkr4_change(struct ktable *kt, struct kroute_full *kl)\n{\n\tstruct kroute_node\t*kr;\n\tint\t\t\t action = RTM_ADD;\n\tu_int16_t\t\t labelid;\n\n\tif ((kr = kroute_find(kt, kl->prefix.v4.s_addr, kl->prefixlen,\n\t    RTP_BGP)) != NULL)\n\t\taction = RTM_CHANGE;\n\n\t/* nexthop within 127/8 -> ignore silently */\n\tif ((kl->nexthop.v4.s_addr & htonl(IN_CLASSA_NET)) ==\n\t    htonl(INADDR_LOOPBACK & IN_CLASSA_NET))\n\t\treturn (0);\n\n\tlabelid = rtlabel_name2id(kl->label);\n\n\t/* for blackhole and reject routes nexthop needs to be 127.0.0.1 */\n\tif (kl->flags & (F_BLACKHOLE|F_REJECT))\n\t\tkl->nexthop.v4.s_addr = htonl(INADDR_LOOPBACK);\n\n\tif (action == RTM_ADD) {\n\t\tif ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {\n\t\t\tlog_warn(\"kr_change\");\n\t\t\treturn (-1);\n\t\t}\n\t\tkr->r.prefix.s_addr = kl->prefix.v4.s_addr;\n\t\tkr->r.prefixlen = kl->prefixlen;\n\t\tkr->r.nexthop.s_addr = kl->nexthop.v4.s_addr;\n\t\tkr->r.flags = kl->flags | F_BGPD_INSERTED;\n\t\tkr->r.priority = RTP_BGP;\n\t\tkr->r.labelid = labelid;\n\n\t\tif (kroute_insert(kt, kr) == -1)\n\t\t\tfree(kr);\n\t} else {\n\t\tkr->r.nexthop.s_addr = kl->nexthop.v4.s_addr;\n\t\trtlabel_unref(kr->r.labelid);\n\t\tkr->r.labelid = labelid;\n\t\tif (kl->flags & F_BLACKHOLE)\n\t\t\tkr->r.flags |= F_BLACKHOLE;\n\t\telse\n\t\t\tkr->r.flags &= ~F_BLACKHOLE;\n\t\tif (kl->flags & F_REJECT)\n\t\t\tkr->r.flags |= F_REJECT;\n\t\telse\n\t\t\tkr->r.flags &= ~F_REJECT;\n\t}\n\n\tif (send_rtmsg(kr_state.fd, action, kt, &kr->r) == -1)\n\t\treturn (-1);\n\n\treturn (0);\n}", "item_id": 9, "repo": "sizeofvoid/ifconfigd", "file": "usr/src/usr.sbin/bgpd/kroute.c", "last_update_at": "2020-08-28T01:27:00+00:00", "question_id": "666f437624b2d3c9cf6e20be2d5f3dfe3ec1aa44_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nkr4_change(struct ktable *kt, struct kroute_full *kl)\n{\n\tstruct kroute_node\t*kr;\n\tint\t\t\t action = RTM_ADD;\n\tu_int16_t\t\t labelid;\n\tif ((kr = kroute_find(kt, kl->prefix.v4.s_addr, kl->prefixlen,\n\t    RTP_BGP)) != NULL)\n\t\taction = RTM_CHANGE;\n\t/* nexthop within 127/8 -> ignore silently */\n\tif ((kl->nexthop.v4.s_addr & htonl(IN_CLASSA_NET)) ==\n\t    htonl(INADDR_LOOPBACK & IN_CLASSA_NET))\n\t\treturn (0);\n\tlabelid = rtlabel_name2id(kl->label);\n\t/* for blackhole and reject routes nexthop needs to be 127.0.0.1 */\n\tif (kl->flags & (F_BLACKHOLE|F_REJECT))\n\t\tkl->nexthop.v4.s_addr = htonl(INADDR_LOOPBACK);\n\tif (action == RTM_ADD) {\n\t\tif ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {\n\t\t\tlog_warn(\"kr_change\");\n\t\t\treturn (-1);\n\t\t}\n\t\tkr->r.prefix.s_addr = kl->prefix.v4.s_addr;\n\t\tkr->r.prefixlen = kl->prefixlen;\n\t\tkr->r.nexthop.s_addr = kl->nexthop.v4.s_addr;\n\t\tkr->r.flags = kl->flags | F_BGPD_INSERTED;\n\t\tkr->r.priority = RTP_BGP;\n\t\tkr->r.labelid = labelid;\n\t\tif (kroute_insert(kt, kr) == -1)\n\t\t\tfree(kr);\n\t} else {\n\t\tkr->r.nexthop.s_addr = kl->nexthop.v4.s_addr;\n\t\trtlabel_unref(kr->r.labelid);\n\t\tkr->r.labelid = labelid;\n\t\tif (kl->flags & F_BLACKHOLE)\n\t\t\tkr->r.flags |= F_BLACKHOLE;\n\t\telse\n\t\t\tkr->r.flags &= ~F_BLACKHOLE;\n\t\tif (kl->flags & F_REJECT)\n\t\t\tkr->r.flags |= F_REJECT;\n\t\telse\n\t\t\tkr->r.flags &= ~F_REJECT;\n\t}\n\tif (send_rtmsg(kr_state.fd, action, kt, &kr->r) == -1)\n\t\treturn (-1);\n\treturn (0);\n"]]}
{"hexsha": "2c2a9d429c607e1077f8414ff8a27391fdfabc8c", "ext": "c", "lang": "C", "content": "cell\npfopen(char *name, int len, int mode, cell *up)\n{\n    char cstrbuf[512];\n    char *s;\n    s = expand_name(altocstr(name, len, cstrbuf, 512));\n\n    if (!strncmp(\"popen:\", s, 6))\n        return (cell)popen(s+6, popen_modes[mode&3]);\n\n    return( (cell)fopen(s, open_modes[mode&3]) );\n}", "item_id": 6, "repo": "lowfatcomputing/cforth", "file": "src/cforth/io.c", "last_update_at": "2020-12-07T03:45:49+00:00", "question_id": "2c2a9d429c607e1077f8414ff8a27391fdfabc8c_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["cell\npfopen(char *name, int len, int mode, cell *up)\n{\n    char cstrbuf[512];\n    char *s;\n    s = expand_name(altocstr(name, len, cstrbuf, 512));\n    if (!strncmp(\"popen:\", s, 6))\n        return (cell)popen(s+6, popen_modes[mode&3]);\n    return( (cell)fopen(s, open_modes[mode&3]) );\n"]]}
{"hexsha": "fca777dfe95182d7d0778254b346b2a2fbe253ae", "ext": "c", "lang": "C", "content": "errval_t vfs_dir_read_next(void *st, vfs_handle_t handle, char **retname, struct fs_fileinfo *info) {\n    \n    errval_t err;\n    \n    // VFS mount state with root directories and mount linked list\n    struct vfs_mount *mt = st;\n    \n    // VFS handle to store the FS specific handle and the type\n    struct vfs_handle *h = handle;\n    \n    switch (h->type) {\n        case RAMFS:\n            err = ramfs_dir_read_next(mt->ram_mount, h->handle, retname, info);\n            break;\n        case FATFS:\n            err = fs_rpc_readdir(mt->fat_mount, h->handle, retname, info);\n            break;\n        case MBTFS:\n            err = mbtfs_dir_read_next(mt->mbt_mount, h->handle, retname, info);\n            break;\n        default:\n            err = SYS_ERR_OK;\n            debug_printf(\"vfs read dir unsuccessful\\n\");\n            break;\n    }\n    \n    return err;\n    \n}", "item_id": 12, "repo": "winbergs/DoritOS", "file": "lib/fs/vfs.c", "last_update_at": "2020-03-13T00:47:56+00:00", "question_id": "fca777dfe95182d7d0778254b346b2a2fbe253ae_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["errval_t vfs_dir_read_next(void *st, vfs_handle_t handle, char **retname, struct fs_fileinfo *info) {\n    errval_t err;\n    // VFS mount state with root directories and mount linked list\n    struct vfs_mount *mt = st;\n    // VFS handle to store the FS specific handle and the type\n    struct vfs_handle *h = handle;\n    switch (h->type) {\n        case RAMFS:\n            err = ramfs_dir_read_next(mt->ram_mount, h->handle, retname, info);\n            break;\n        case FATFS:\n            err = fs_rpc_readdir(mt->fat_mount, h->handle, retname, info);\n            break;\n        case MBTFS:\n            err = mbtfs_dir_read_next(mt->mbt_mount, h->handle, retname, info);\n            break;\n        default:\n            err = SYS_ERR_OK;\n            debug_printf(\"vfs read dir unsuccessful\\n\");\n            break;\n    }\n    return err;\n"]]}
{"hexsha": "7058bd0b35192cb210685de9ec3f10c1758108f8", "ext": "h", "lang": "C", "content": "static double solve2(int N, vector<int> A) {\n        int K = int(A.size());\n        if (N > K)\n            return 0.0;\n\n        sort(A.begin(), A.end(), greater<int>());\n        if (N == K)\n            return A.back();\n\n        long long left = accumulate(A.begin() + N, A.end(), 0ll);\n        A.resize(N);\n\n        int cnt = 1;\n        while (A.size() > 1) {\n            long long gap = 1ll * (A[A.size() - 2] - A.back()) * cnt;\n            if (left <= gap)\n                break;\n\n            left -= gap;\n            A.pop_back();\n            cnt++;\n        }\n\n        return A.back() + (1.0 * left / cnt);\n    }", "item_id": 0, "repo": "bluedawnstar/algorithm_library", "file": "library/binarySearch/problems/coverTime.h", "last_update_at": "2020-11-13T00:29:26+00:00", "question_id": "7058bd0b35192cb210685de9ec3f10c1758108f8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static double solve2(int N, vector<int> A) {\n        int K = int(A.size());\n        if (N > K)\n            return 0.0;\n        sort(A.begin(), A.end(), greater<int>());\n        if (N == K)\n            return A.back();\n        long long left = accumulate(A.begin() + N, A.end(), 0ll);\n        A.resize(N);\n        int cnt = 1;\n        while (A.size() > 1) {\n            long long gap = 1ll * (A[A.size() - 2] - A.back()) * cnt;\n            if (left <= gap)\n                break;\n            left -= gap;\n            A.pop_back();\n            cnt++;\n        }\n        return A.back() + (1.0 * left / cnt);\n"]]}
{"hexsha": "860554cbed4d6a3757abdcf5301e10822dfb2da8", "ext": "h", "lang": "C", "content": "class MPv4\n  :\n  public MPv3\n{\n  public:\n  ///\n  /// Constructor\n  ///\n  MPv4(\n      const int,  ///< grid dimensions\n      const int,  ///< Coordinate System flag\n      const int,  ///< Total number of variables in state vector\n      const int,  ///< Number of tracer variables in state vector.\n      const std::string *, ///< List of what the tracer variables mean.\n      struct which_physics *, ///< extra physics stuff.\n      struct rad_sources *,    ///< radiation sources.\n      const double  ///< EOS Gamma\n      );\n\n  ///\n  /// Destructor\n  ///\n  ~MPv4();\n\n  ///\n  /// This takes a copy of the primitive vector and advances it in\n  /// time over the step requested, and at the end copies the updated\n  /// vector into the destination vector.  For fully local\n  /// microphysics but WITH radiative transfer, where the column\n  /// densities for diffuse and direct radiation are included as\n  /// parameters.  The input list of column densities is ordered by\n  /// the number of sources in each category in the vector of\n  /// integers.\n  ///\n  /// Integers refer to:\n  /// - Number of diffuse ionising sources (at infinity), \n  /// - Number of diffuse UV sources (at infinity),\n  /// - Number of ionising point sources,\n  /// - Number of UV point sources.\n  ///\n  /// Returned data is the time-averaged column density\n  /// <<\\delta\\rho\\times\\delta x>>\n  ///\n  virtual int TimeUpdateMP_RTnew(\n          const pion_flt *, ///< Primitive Vector to be updated.\n          const int,      ///< Number of UV heating sources.\n          const std::vector<struct rt_source_data> &,\n          ///< list of UV-heating column densities and source properties.\n          const int,      ///< number of ionising radiation sources.\n          const std::vector<struct rt_source_data> &,\n          ///< list of ionising src column densities and source properties.\n          pion_flt *,       ///< Destination Vector for updated values\n                         ///< (can be same as first Vector.\n          const double,   ///< Time Step to advance by.\n          const double,   ///< EOS gamma.\n          const int, ///< Switch for what type of integration to use.\n                    ///< (0=adaptive RK5, 1=adaptive Euler,2=onestep o4-RK)\n          double *    ///< any returned data (final temperature?).\n          );\n\n  ///\n  /// This returns the minimum timescale of the times flagged in the\n  /// arguments.  (photoionisation time is not implemented).\n  ///\n  double timescales(\n          const pion_flt *, ///< Current cell.\n          const double,   ///< EOS gamma.\n          const bool, ///< set to 'true' if including cooling time.\n          const bool, ///< set to 'true' if including recombination time.\n          const bool  ///< set to 'true' if including photo-ionsation time.\n          );\n\n  ///\n  /// This returns the minimum timescale of all microphysical \n  /// processes, including reaction times for each species and the\n  /// total heating/cooling time for the gas.  It requires the\n  /// radiation field as an input, so it has substantially greater\n  /// capability than the other timescales function.\n  ///\n  double timescales_RT(\n          const pion_flt *, ///< Current cell.\n          const int,      ///< Number of UV heating sources.\n          const std::vector<struct rt_source_data> &,\n          ///< list of UV-heating column densities and source properties.\n          const int,      ///< number of ionising radiation sources.\n          const std::vector<struct rt_source_data> &,\n          ///< list of ionising src column densities and source properties.\n          const double   ///< EOS gamma.\n          );\n\n  protected:\n  ///\n  /// convert state vector from grid cell into local microphysics\n  /// vector.\n  ///\n  virtual int convert_prim2local(\n          const pion_flt *, ///< primitive vector from grid cell (length nv_prim)\n          double *        ///< local vector [x,E](n+1).\n          );\n\n  ///\n  /// Convert int(exp(-dtau)dt) into time-averaged value of\n  /// rho*(1-x)*ds\n  ///\n  double get_timeaveraged_rhodx(\n            const double, ///< this is int(exp(-dtau)dt)\n            const double  ///< this is dt\n            );\n          \n  ///\n  /// Set the size of local vectors, and index them with integers.\n  ///\n  virtual void setup_local_vectors();\n\n  int lv_dtau; ///< index of dtau variable in local vector.\n\n  //---------------------------------------------------------------------------\n  //-------------- FUNCTIONS DERIVED FROM BASE CLASS FOLLOW -------------------\n  //---------------------------------------------------------------------------\n  public:\n  ///\n  /// calculate dy/dt for the vector of y-values.\n  ///\n  virtual int ydot(\n          double,         ///< current time (probably not needed for rate equations)\n          const N_Vector, ///< current Y-value\n          N_Vector,       ///< vector for Y-dot values\n          const double *  ///< extra user-data vector, P, for evaluating ydot(y,t,p)\n          );\n\n  ///\n  /// Get the number of extra parameters and the number of equations.\n  ///\n  virtual void get_problem_size(int *, ///< number of equations\n                        int *  ///< number of parameters in user_data vector.\n                        );\n  protected:\n  ///\n  /// set the relative and absolute error tolerances\n  ///\n  virtual void get_error_tolerances(\n          double *, ///< relative error tolerance (single value)\n          double []  ///< absolute error tolerance (array)\n          );\n\n  //---------------------------------------------------------------------------\n  //-------------- END OF FUNCTIONS DERIVED FROM BASE CLASS -------------------\n  //---------------------------------------------------------------------------\n}", "item_id": 0, "repo": "jfbucas/PION", "file": "source/microphysics/MPv4.h", "last_update_at": "2020-12-05T13:30:03+00:00", "question_id": "860554cbed4d6a3757abdcf5301e10822dfb2da8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class MPv4\n  :\n  public MPv3\n{\n  public:\n  ///\n  /// Constructor\n  ///\n  MPv4(\n      const int,  ///< grid dimensions\n      const int,  ///< Coordinate System flag\n      const int,  ///< Total number of variables in state vector\n      const int,  ///< Number of tracer variables in state vector.\n      const std::string *, ///< List of what the tracer variables mean.\n      struct which_physics *, ///< extra physics stuff.\n      struct rad_sources *,    ///< radiation sources.\n      const double  ///< EOS Gamma\n      );\n  ///\n  /// Destructor\n  ///\n  ~MPv4();\n  ///\n  /// This takes a copy of the primitive vector and advances it in\n  /// time over the step requested, and at the end copies the updated\n  /// vector into the destination vector.  For fully local\n  /// microphysics but WITH radiative transfer, where the column\n  /// densities for diffuse and direct radiation are included as\n  /// parameters.  The input list of column densities is ordered by\n  /// the number of sources in each category in the vector of\n  /// integers.\n  ///\n  /// Integers refer to:\n  /// - Number of diffuse ionising sources (at infinity), \n  /// - Number of diffuse UV sources (at infinity),\n  /// - Number of ionising point sources,\n  /// - Number of UV point sources.\n  ///\n  /// Returned data is the time-averaged column density\n  /// <<\\delta\\rho\\times\\delta x>>\n  ///\n  virtual int TimeUpdateMP_RTnew(\n          const pion_flt *, ///< Primitive Vector to be updated.\n          const int,      ///< Number of UV heating sources.\n          const std::vector<struct rt_source_data> &,\n          ///< list of UV-heating column densities and source properties.\n          const int,      ///< number of ionising radiation sources.\n          const std::vector<struct rt_source_data> &,\n          ///< list of ionising src column densities and source properties.\n          pion_flt *,       ///< Destination Vector for updated values\n                         ///< (can be same as first Vector.\n          const double,   ///< Time Step to advance by.\n          const double,   ///< EOS gamma.\n          const int, ///< Switch for what type of integration to use.\n                    ///< (0=adaptive RK5, 1=adaptive Euler,2=onestep o4-RK)\n          double *    ///< any returned data (final temperature?).\n          );\n  ///\n  /// This returns the minimum timescale of the times flagged in the\n  /// arguments.  (photoionisation time is not implemented).\n  ///\n  double timescales(\n          const pion_flt *, ///< Current cell.\n          const double,   ///< EOS gamma.\n          const bool, ///< set to 'true' if including cooling time.\n          const bool, ///< set to 'true' if including recombination time.\n          const bool  ///< set to 'true' if including photo-ionsation time.\n          );\n  ///\n  /// This returns the minimum timescale of all microphysical \n  /// processes, including reaction times for each species and the\n  /// total heating/cooling time for the gas.  It requires the\n  /// radiation field as an input, so it has substantially greater\n  /// capability than the other timescales function.\n  ///\n  double timescales_RT(\n          const pion_flt *, ///< Current cell.\n          const int,      ///< Number of UV heating sources.\n          const std::vector<struct rt_source_data> &,\n          ///< list of UV-heating column densities and source properties.\n          const int,      ///< number of ionising radiation sources.\n          const std::vector<struct rt_source_data> &,\n          ///< list of ionising src column densities and source properties.\n          const double   ///< EOS gamma.\n          );\n  protected:\n  ///\n  /// convert state vector from grid cell into local microphysics\n  /// vector.\n  ///\n  virtual int convert_prim2local(\n          const pion_flt *, ///< primitive vector from grid cell (length nv_prim)\n          double *        ///< local vector [x,E](n+1).\n          );\n  ///\n  /// Convert int(exp(-dtau)dt) into time-averaged value of\n  /// rho*(1-x)*ds\n  ///\n  double get_timeaveraged_rhodx(\n            const double, ///< this is int(exp(-dtau)dt)\n            const double  ///< this is dt\n            );\n  ///\n  /// Set the size of local vectors, and index them with integers.\n  ///\n  virtual void setup_local_vectors();\n  int lv_dtau; ///< index of dtau variable in local vector.\n  //---------------------------------------------------------------------------\n  //-------------- FUNCTIONS DERIVED FROM BASE CLASS FOLLOW -------------------\n  //---------------------------------------------------------------------------\n  public:\n  ///\n  /// calculate dy/dt for the vector of y-values.\n  ///\n  virtual int ydot(\n          double,         ///< current time (probably not needed for rate equations)\n          const N_Vector, ///< current Y-value\n          N_Vector,       ///< vector for Y-dot values\n          const double *  ///< extra user-data vector, P, for evaluating ydot(y,t,p)\n          );\n  ///\n  /// Get the number of extra parameters and the number of equations.\n  ///\n  virtual void get_problem_size(int *, ///< number of equations\n                        int *  ///< number of parameters in user_data vector.\n                        );\n  protected:\n  ///\n  /// set the relative and absolute error tolerances\n  ///\n  virtual void get_error_tolerances(\n          double *, ///< relative error tolerance (single value)\n          double []  ///< absolute error tolerance (array)\n          );\n  //---------------------------------------------------------------------------\n  //-------------- END OF FUNCTIONS DERIVED FROM BASE CLASS -------------------\n  //---------------------------------------------------------------------------\n"]]}
{"hexsha": "5850b41508fd68eac17ec0a66dab6627912fa136", "ext": "c", "lang": "C", "content": "deBool qpXmlWriter_startDocument (qpXmlWriter* writer)\n{\n\tDE_ASSERT(writer && !writer->xmlIsWriting);\n\twriter->xmlIsWriting\t\t\t= DE_TRUE;\n\twriter->xmlElementDepth\t\t\t= 0;\n\twriter->xmlPrevIsStartElement\t= DE_FALSE;\n\tfprintf(writer->outputFile, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n\treturn DE_TRUE;\n}", "item_id": 2, "repo": "omegaphora/external_deqp", "file": "framework/qphelper/qpXmlWriter.c", "last_update_at": "2020-07-13T13:02:45+00:00", "question_id": "5850b41508fd68eac17ec0a66dab6627912fa136_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["deBool qpXmlWriter_startDocument (qpXmlWriter* writer)\n{\n\tDE_ASSERT(writer && !writer->xmlIsWriting);\n\twriter->xmlIsWriting\t\t\t= DE_TRUE;\n\twriter->xmlElementDepth\t\t\t= 0;\n\twriter->xmlPrevIsStartElement\t= DE_FALSE;\n\tfprintf(writer->outputFile, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n\treturn DE_TRUE;\n"]]}
{"hexsha": "a68b16a35cf02eb4ee240a3ead00bca09e5bc778", "ext": "c", "lang": "C", "content": "bool fdi_serial_wire_debug_read_data(\n    fdi_serial_wire_t *serial_wire,\n    uint32_t address,\n    uint8_t *data,\n    uint32_t length,\n    fdi_serial_wire_debug_error_t *error\n) {\n    uint32_t offset = 0;\n    while (length > 0) {\n        uint32_t sublength = (tar_increment_bits + 1) - (address & tar_increment_bits);\n        if (length < sublength) {\n            sublength = length;\n        }\n        \n        if (!fdi_serial_wire_debug_read_memory_transfer(serial_wire, address, data, sublength, error)) {\n            return false;\n        }\n        \n        address += sublength;\n        data += sublength;\n        length -= sublength;\n        offset += sublength;\n    }\n    return true;\n}", "item_id": 19, "repo": "denisbohm/firefly-ice-firmware", "file": "instruments/src/fdi_serial_wire_debug.c", "last_update_at": "2020-11-24T22:17:22+00:00", "question_id": "a68b16a35cf02eb4ee240a3ead00bca09e5bc778_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool fdi_serial_wire_debug_read_data(\n    fdi_serial_wire_t *serial_wire,\n    uint32_t address,\n    uint8_t *data,\n    uint32_t length,\n    fdi_serial_wire_debug_error_t *error\n) {\n    uint32_t offset = 0;\n    while (length > 0) {\n        uint32_t sublength = (tar_increment_bits + 1) - (address & tar_increment_bits);\n        if (length < sublength) {\n            sublength = length;\n        }\n        if (!fdi_serial_wire_debug_read_memory_transfer(serial_wire, address, data, sublength, error)) {\n            return false;\n        }\n        address += sublength;\n        data += sublength;\n        length -= sublength;\n        offset += sublength;\n    }\n    return true;\n"]]}
{"hexsha": "03d9791b678332d11c108dadafa46306fde45b1f", "ext": "c", "lang": "C", "content": "int proc_comm(pid_t pid, char **name)\n{\n\tint r;\n\tchar *p;\n\n\tassert(pid >= 1);\n\tassert(name);\n\n\tif (asprintf(&p, \"/proc/%u/comm\", pid) < 0)\n\t\treturn -ENOMEM;\n\n\tr = read_one_line_file(p, name);\n\tfree(p);\n\n\tif (r < 0)\n\t\treturn r;\n\n\treturn 0;\n}", "item_id": 4, "repo": "alip/sydbox-1", "file": "src/proc.c", "last_update_at": "2020-02-06T22:46:19+00:00", "question_id": "03d9791b678332d11c108dadafa46306fde45b1f_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int proc_comm(pid_t pid, char **name)\n{\n\tint r;\n\tchar *p;\n\tassert(pid >= 1);\n\tassert(name);\n\tif (asprintf(&p, \"/proc/%u/comm\", pid) < 0)\n\t\treturn -ENOMEM;\n\tr = read_one_line_file(p, name);\n\tfree(p);\n\tif (r < 0)\n\t\treturn r;\n\treturn 0;\n"]]}
{"hexsha": "3e9531dd0000363a9c5796243a30a1ed9a5f3bef", "ext": "c", "lang": "C", "content": "static ssize_t adis16240_write_16bit(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf,\n\t\tsize_t len)\n{\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tint ret;\n\tlong val;\n\n\tret = strict_strtol(buf, 10, &val);\n\tif (ret)\n\t\tgoto error_ret;\n\tret = adis16240_spi_write_reg_16(dev, this_attr->address, val);\n\nerror_ret:\n\treturn ret ? ret : len;\n}", "item_id": 7, "repo": "afeng11/tomato-arm", "file": "release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/staging/iio/accel/adis16240_core.c", "last_update_at": "2020-05-24T07:23:26+00:00", "question_id": "3e9531dd0000363a9c5796243a30a1ed9a5f3bef_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static ssize_t adis16240_write_16bit(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf,\n\t\tsize_t len)\n{\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tint ret;\n\tlong val;\n\tret = strict_strtol(buf, 10, &val);\n\tif (ret)\n\t\tgoto error_ret;\n\tret = adis16240_spi_write_reg_16(dev, this_attr->address, val);\nerror_ret:\n\treturn ret ? ret : len;\n"]]}
{"hexsha": "645132a892107512a1ff76b5ecae273b937b4f66", "ext": "c", "lang": "C", "content": "static char **handle_switch_O(char *arg, char **next)\n{\n\tint level = 1;\n\tif (arg[1] >= '0' && arg[1] <= '9')\n\t\tlevel = arg[1] - '0';\n\toptimize = level;\n\toptimize_size = arg[1] == 's';\n\treturn next;\n}", "item_id": 21, "repo": "sparsecli/sparse", "file": "lib.c", "last_update_at": "2020-07-14T07:05:19+00:00", "question_id": "645132a892107512a1ff76b5ecae273b937b4f66_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static char **handle_switch_O(char *arg, char **next)\n{\n\tint level = 1;\n\tif (arg[1] >= '0' && arg[1] <= '9')\n\t\tlevel = arg[1] - '0';\n\toptimize = level;\n\toptimize_size = arg[1] == 's';\n\treturn next;\n"]]}
{"hexsha": "7f497e2a2ff47035706db774f54a963cff35afae", "ext": "c", "lang": "C", "content": "static void containsAPI(WrenVM* vm)\n{\n  insert(vm);\n  \n  wrenEnsureSlots(vm, 1);\n  wrenSetSlotString(vm, 1, \"England\");\n\n  bool result = wrenGetMapContainsKey(vm, 0, 1);\n  wrenSetSlotBool(vm, 0, result);\n}", "item_id": 4, "repo": "CohenArthur/wren", "file": "test/api/maps.c", "last_update_at": "2020-12-22T11:19:31+00:00", "question_id": "7f497e2a2ff47035706db774f54a963cff35afae_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void containsAPI(WrenVM* vm)\n{\n  insert(vm);\n  wrenEnsureSlots(vm, 1);\n  wrenSetSlotString(vm, 1, \"England\");\n  bool result = wrenGetMapContainsKey(vm, 0, 1);\n  wrenSetSlotBool(vm, 0, result);\n"]]}
{"hexsha": "2c8fdfef0d7590d0dd22db3c662f3c7fc9b833a6", "ext": "c", "lang": "C", "content": "errval_t lmp_endpoint_create_in_slot(size_t buflen, struct capref dest,\n                                     struct lmp_endpoint **retep)\n{\n    struct lmp_endpoint *ep = NULL;\n    errval_t err;\n\n    // We increase buflen by 1 here to accomodate for in-kernel sentinel word\n    buflen++;\n\n    err = lmp_endpoint_alloc(buflen, &ep);\n    if (err_is_fail(err)) {\n        return err;\n    }\n\n    assert(ep != NULL);\n    if (retep != NULL) {\n        *retep = ep;\n    }\n\n    uintptr_t epoffset = (uintptr_t)&ep->k - (uintptr_t)curdispatcher();\n\n    // mint new badged cap from our existing reply endpoint\n    return cap_mint(dest, cap_selfep, epoffset, buflen);\n}", "item_id": 3, "repo": "modeswitch/barrelfish", "file": "lib/barrelfish/lmp_endpoints.c", "last_update_at": "2020-09-02T15:41:44+00:00", "question_id": "2c8fdfef0d7590d0dd22db3c662f3c7fc9b833a6_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["errval_t lmp_endpoint_create_in_slot(size_t buflen, struct capref dest,\n                                     struct lmp_endpoint **retep)\n{\n    struct lmp_endpoint *ep = NULL;\n    errval_t err;\n    // We increase buflen by 1 here to accomodate for in-kernel sentinel word\n    buflen++;\n    err = lmp_endpoint_alloc(buflen, &ep);\n    if (err_is_fail(err)) {\n        return err;\n    }\n    assert(ep != NULL);\n    if (retep != NULL) {\n        *retep = ep;\n    }\n    uintptr_t epoffset = (uintptr_t)&ep->k - (uintptr_t)curdispatcher();\n    // mint new badged cap from our existing reply endpoint\n    return cap_mint(dest, cap_selfep, epoffset, buflen);\n"]]}
{"hexsha": "9ea90cfb78f627708f2583e9f3c960bcac597732", "ext": "c", "lang": "C", "content": "char *_str(){\n\tchar *p = calloc(1, 30);\n\tstrcpy(p, \"test update\");\n\treturn p;\n}", "item_id": 0, "repo": "FramebotCommunity/framebot", "file": "test/test_update.c", "last_update_at": "2020-04-03T17:06:09+00:00", "question_id": "9ea90cfb78f627708f2583e9f3c960bcac597732_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char *_str(){\n\tchar *p = calloc(1, 30);\n\tstrcpy(p, \"test update\");\n\treturn p;\n"]]}
{"hexsha": "39f96c03cf090362567dd9fe0be705a363ffcda9", "ext": "c", "lang": "C", "content": "mrb_value\npg_new_result(mrb_state *mrb, PGresult *result, mrb_value mrb_pgconn)\n{\n  mrb_value val;\n  mrb_value type_map;\n\n  val = mrb_obj_value(Data_Wrap_Struct(mrb, mrb_cPGresult(mrb), &mrb_pgresult_type, result));\n  mrb_iv_set(mrb, val, mrb_intern_lit(mrb, \"@connection\"), mrb_pgconn);\n\n  type_map = mrb_iv_get(mrb, mrb_pgconn, mrb_intern_lit(mrb, \"@type_map_for_results\"));\n  \n  if(!mrb_nil_p(type_map)) {\n    mrb_iv_set(mrb, val, mrb_intern_lit(mrb, \"type_map\"), type_map);\n  }\n\n  return val;\n}", "item_id": 2, "repo": "test-bench/mruby-ruby-compat", "file": "mrbgems/pg/src/mrb_pg.c", "last_update_at": "2020-08-11T20:52:50+00:00", "question_id": "39f96c03cf090362567dd9fe0be705a363ffcda9_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["mrb_value\npg_new_result(mrb_state *mrb, PGresult *result, mrb_value mrb_pgconn)\n{\n  mrb_value val;\n  mrb_value type_map;\n  val = mrb_obj_value(Data_Wrap_Struct(mrb, mrb_cPGresult(mrb), &mrb_pgresult_type, result));\n  mrb_iv_set(mrb, val, mrb_intern_lit(mrb, \"@connection\"), mrb_pgconn);\n  type_map = mrb_iv_get(mrb, mrb_pgconn, mrb_intern_lit(mrb, \"@type_map_for_results\"));\n  if(!mrb_nil_p(type_map)) {\n    mrb_iv_set(mrb, val, mrb_intern_lit(mrb, \"type_map\"), type_map);\n  }\n  return val;\n"]]}
{"hexsha": "6f9314e685984e3426506069d34fd880694698b6", "ext": "c", "lang": "C", "content": "u8\r\nPHY_GetTxPowerIndex_8188E(\r\n\tIN\tPADAPTER\t\tpAdapter,\r\n\tIN\tu8\t\t\t\tRFPath,\r\n\tIN\tu8\t\t\t\tRate,\t\r\n\tIN\tCHANNEL_WIDTH\tBandWidth,\t\r\n\tIN\tu8\t\t\t\tChannel\r\n\t)\r\n{\r\n\tPHAL_DATA_TYPE pHalData = GET_HAL_DATA(pAdapter);\r\n\tu8 base_index = 0;\r\n\ts8 by_rate_diff = 0, txPower = 0, limit = 0, track_diff = 0, extra_bias = 0;\r\n\tu8 txNum = phy_GetCurrentTxNum_8188E(pAdapter, Rate);\r\n\tBOOLEAN bIn24G = _FALSE;\r\n\r\n\tbase_index = PHY_GetTxPowerIndexBase(pAdapter,RFPath, Rate, BandWidth, Channel, &bIn24G);\r\n\r\n\tby_rate_diff = PHY_GetTxPowerByRate(pAdapter, BAND_ON_2_4G, RFPath, txNum, Rate);\r\n\tlimit = PHY_GetTxPowerLimit(pAdapter, pAdapter->registrypriv.RegPwrTblSel, (u8)(!bIn24G), pHalData->CurrentChannelBW, RFPath, Rate, pHalData->CurrentChannel);\r\n\tby_rate_diff = by_rate_diff > limit ? limit : by_rate_diff;\r\n\r\n\ttrack_diff = PHY_GetTxPowerTrackingOffset(pAdapter, RFPath, Rate);\r\n\r\n\textra_bias = tx_power_extra_bias(RFPath, Rate, BandWidth, Channel);\r\n\r\n\ttxPower = base_index + by_rate_diff + track_diff + extra_bias;\r\n\r\n\tif(txPower > MAX_POWER_INDEX)\r\n\t\ttxPower = MAX_POWER_INDEX;\r\n\r\n\tif (0)\r\n\tDBG_871X(\"RF-%c ch%d TxPwrIdx = %d(0x%X) [%2u %2d %2d %2d]\\n\"\r\n\t\t, ((RFPath==0)?'A':'B'), Channel, txPower, txPower, base_index, by_rate_diff, track_diff, extra_bias);\r\n\r\n\treturn (u8)txPower;\t\r\n}", "item_id": 24, "repo": "xregist/v3s-linux-sdk", "file": "linux-3.4/drivers/net/wireless/rtl8189_smart/hal/rtl8188e/rtl8188e_phycfg.c", "last_update_at": "2020-01-31T10:27:07+00:00", "question_id": "6f9314e685984e3426506069d34fd880694698b6_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["u8\r\nPHY_GetTxPowerIndex_8188E(\r\n\tIN\tPADAPTER\t\tpAdapter,\r\n\tIN\tu8\t\t\t\tRFPath,\r\n\tIN\tu8\t\t\t\tRate,\t\r\n\tIN\tCHANNEL_WIDTH\tBandWidth,\t\r\n\tIN\tu8\t\t\t\tChannel\r\n\t)\r\n{\r\n\tPHAL_DATA_TYPE pHalData = GET_HAL_DATA(pAdapter);\r\n\tu8 base_index = 0;\r\n\ts8 by_rate_diff = 0, txPower = 0, limit = 0, track_diff = 0, extra_bias = 0;\r\n\tu8 txNum = phy_GetCurrentTxNum_8188E(pAdapter, Rate);\r\n\tBOOLEAN bIn24G = _FALSE;\r\n\r\n\tbase_index = PHY_GetTxPowerIndexBase(pAdapter,RFPath, Rate, BandWidth, Channel, &bIn24G);\r\n\r\n\tby_rate_diff = PHY_GetTxPowerByRate(pAdapter, BAND_ON_2_4G, RFPath, txNum, Rate);\r\n\tlimit = PHY_GetTxPowerLimit(pAdapter, pAdapter->registrypriv.RegPwrTblSel, (u8)(!bIn24G), pHalData->CurrentChannelBW, RFPath, Rate, pHalData->CurrentChannel);\r\n\tby_rate_diff = by_rate_diff > limit ? limit : by_rate_diff;\r\n\r\n\ttrack_diff = PHY_GetTxPowerTrackingOffset(pAdapter, RFPath, Rate);\r\n\r\n\textra_bias = tx_power_extra_bias(RFPath, Rate, BandWidth, Channel);\r\n\r\n\ttxPower = base_index + by_rate_diff + track_diff + extra_bias;\r\n\r\n\tif(txPower > MAX_POWER_INDEX)\r\n\t\ttxPower = MAX_POWER_INDEX;\r\n\r\n\tif (0)\r\n\tDBG_871X(\"RF-%c ch%d TxPwrIdx = %d(0x%X) [%2u %2d %2d %2d]\\n\"\r\n\t\t, ((RFPath==0)?'A':'B'), Channel, txPower, txPower, base_index, by_rate_diff, track_diff, extra_bias);\r\n\r\n\treturn (u8)txPower;\t\r\n"]]}
{"hexsha": "8e4218da0830de8205519bf8b62fb7e8728f62ee", "ext": "h", "lang": "C", "content": "class HUMBLE_EXPORT_API Mutex\n{\n  friend class MutexPrivate;\n  MutexPrivate *d;\n\npublic:\n  Mutex();\n  ~Mutex();\n  void lock();\n  void unlock();\n}", "item_id": 0, "repo": "thomaskrause/annis4", "file": "ext/humblelogging-3.0.1/include/humblelogging/util/mutex.h", "last_update_at": "2020-01-20T14:50:38+00:00", "question_id": "8e4218da0830de8205519bf8b62fb7e8728f62ee_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class HUMBLE_EXPORT_API Mutex\n{\n  friend class MutexPrivate;\n  MutexPrivate *d;\npublic:\n  Mutex();\n  ~Mutex();\n  void lock();\n  void unlock();\n"]]}
{"hexsha": "a057c60f1b5e5a9be5ac58bc4942fcc36b693dd6", "ext": "c", "lang": "C", "content": "void\nrstp_set_bridge_address(struct rstp *rstp, rstp_identifier bridge_address)\n    OVS_EXCLUDED(rstp_mutex)\n{\n    ovs_mutex_lock(&rstp_mutex);\n    rstp_set_bridge_address__(rstp, bridge_address);\n    ovs_mutex_unlock(&rstp_mutex);\n}", "item_id": 5, "repo": "wenxueliu/ovs_note", "file": "lib/rstp.c", "last_update_at": "2020-08-19T03:19:24+00:00", "question_id": "a057c60f1b5e5a9be5ac58bc4942fcc36b693dd6_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nrstp_set_bridge_address(struct rstp *rstp, rstp_identifier bridge_address)\n    OVS_EXCLUDED(rstp_mutex)\n{\n    ovs_mutex_lock(&rstp_mutex);\n    rstp_set_bridge_address__(rstp, bridge_address);\n    ovs_mutex_unlock(&rstp_mutex);\n"]]}
{"hexsha": "72925533a1a57536b5810870d4c1b15df2e06401", "ext": "c", "lang": "C", "content": "static const char *server_hostname_port(cmd_parms *cmd, void *dummy, const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);\n    const char *portstr;\n    int port;\n\n    if (err != NULL) {\n        return err;\n    }\n\n    portstr = ap_strchr_c(arg, ':');\n    if (portstr) {\n        cmd->server->server_hostname = apr_pstrndup(cmd->pool, arg,\n                                                    portstr - arg);\n        portstr++;\n        port = atoi(portstr);\n        if (port <= 0 || port >= 65536) { /* 65536 == 1<<16 */\n            return apr_pstrcat(cmd->temp_pool, \"The port number \\\"\", arg,\n                          \"\\\" is outside the appropriate range \"\n                          \"(i.e., 1..65535).\", NULL);\n        }\n    }\n    else {\n        cmd->server->server_hostname = apr_pstrdup(cmd->pool, arg);\n        port = 0;\n    }\n\n    cmd->server->port = port;\n    return NULL;\n}", "item_id": 46, "repo": "ydnzol/apache", "file": "server/core.c", "last_update_at": "2020-11-06T11:02:17+00:00", "question_id": "72925533a1a57536b5810870d4c1b15df2e06401_46", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static const char *server_hostname_port(cmd_parms *cmd, void *dummy, const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);\n    const char *portstr;\n    int port;\n    if (err != NULL) {\n        return err;\n    }\n    portstr = ap_strchr_c(arg, ':');\n    if (portstr) {\n        cmd->server->server_hostname = apr_pstrndup(cmd->pool, arg,\n                                                    portstr - arg);\n        portstr++;\n        port = atoi(portstr);\n        if (port <= 0 || port >= 65536) { /* 65536 == 1<<16 */\n            return apr_pstrcat(cmd->temp_pool, \"The port number \\\"\", arg,\n                          \"\\\" is outside the appropriate range \"\n                          \"(i.e., 1..65535).\", NULL);\n        }\n    }\n    else {\n        cmd->server->server_hostname = apr_pstrdup(cmd->pool, arg);\n        port = 0;\n    }\n    cmd->server->port = port;\n    return NULL;\n"]]}
{"hexsha": "e771159fbef6dbfb7a5b3f4ce599cbcc89d98a09", "ext": "c", "lang": "C", "content": "static void\ndissect_zcl_gp_proxy_sink_table_request(proto_tree *tree, tvbuff_t *tvb, guint *offset)\n{\n    /* get Options field */\n    guint8 options = tvb_get_guint8(tvb, *offset);\n    guint8 app_id, req_type;\n    static const int * n_options[] = {\n        &hf_zbee_zcl_proxy_sink_tbl_req_fld_app_id,\n        &hf_zbee_zcl_proxy_sink_tbl_req_fld_req_type,\n        NULL\n    };\n\n    proto_tree_add_bitmask(tree, tvb, *offset, hf_zbee_zcl_proxy_sink_tbl_req_options,\n                           ett_zbee_zcl_proxy_sink_tbl_req_options, n_options, ENC_NA);\n    *offset += 1;\n    app_id = options & ZBEE_ZCL_GP_PROXY_SINK_TBL_REQ_CMD_APP_ID;\n    req_type = (options & ZBEE_ZCL_GP_PROXY_SINK_TBL_REQ_CMD_REQ_TYPE) >>\n        ZBEE_ZCL_GP_PROXY_SINK_TBL_REQ_CMD_REQ_TYPE_SHIFT;\n    if (req_type == ZBEE_ZCL_GP_PROXY_SINK_TABLE_REQ_CMD_REQUSET_BY_GPD_ID) {\n        /* Include GPD ID and/or Endpoint */\n        if (app_id == ZBEE_ZCL_GP_APP_ID_DEFAULT) {\n            /* App_id = 000: GPD SRC ID only */\n            proto_tree_add_item(tree, hf_zbee_gp_src_id, tvb, *offset, 4, ENC_LITTLE_ENDIAN);\n            *offset += 4;\n        }\n        else if (app_id == ZBEE_ZCL_GP_APP_ID_ZGP) {\n            /* App_id = 010: MAC address + Endoint */\n            proto_tree_add_item(tree, hf_zbee_gp_ieee, tvb, *offset, 8, ENC_LITTLE_ENDIAN);\n            *offset += 8;\n            proto_tree_add_item(tree, hf_zbee_gp_endpoint, tvb, *offset, 1, ENC_NA);\n            *offset += 1;\n        }\n    }\n    else if (req_type == ZBEE_ZCL_GP_PROXY_SINK_TABLE_REQ_CMD_REQUSET_BY_INDEX) {\n        /* Include index only */\n        proto_tree_add_item(tree, hf_zbee_zcl_proxy_sink_tbl_req_index, tvb, *offset, 1, ENC_NA);\n        *offset += 1;\n    }\n}", "item_id": 146, "repo": "joshis1/C_Programming", "file": "resources/Wireshark/WiresharkDissectorFoo/epan/dissectors/packet-zbee-zcl-general.c", "last_update_at": "2020-12-31T11:42:02+00:00", "question_id": "e771159fbef6dbfb7a5b3f4ce599cbcc89d98a09_146", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\ndissect_zcl_gp_proxy_sink_table_request(proto_tree *tree, tvbuff_t *tvb, guint *offset)\n{\n    /* get Options field */\n    guint8 options = tvb_get_guint8(tvb, *offset);\n    guint8 app_id, req_type;\n    static const int * n_options[] = {\n        &hf_zbee_zcl_proxy_sink_tbl_req_fld_app_id,\n        &hf_zbee_zcl_proxy_sink_tbl_req_fld_req_type,\n        NULL\n    };\n    proto_tree_add_bitmask(tree, tvb, *offset, hf_zbee_zcl_proxy_sink_tbl_req_options,\n                           ett_zbee_zcl_proxy_sink_tbl_req_options, n_options, ENC_NA);\n    *offset += 1;\n    app_id = options & ZBEE_ZCL_GP_PROXY_SINK_TBL_REQ_CMD_APP_ID;\n    req_type = (options & ZBEE_ZCL_GP_PROXY_SINK_TBL_REQ_CMD_REQ_TYPE) >>\n        ZBEE_ZCL_GP_PROXY_SINK_TBL_REQ_CMD_REQ_TYPE_SHIFT;\n    if (req_type == ZBEE_ZCL_GP_PROXY_SINK_TABLE_REQ_CMD_REQUSET_BY_GPD_ID) {\n        /* Include GPD ID and/or Endpoint */\n        if (app_id == ZBEE_ZCL_GP_APP_ID_DEFAULT) {\n            /* App_id = 000: GPD SRC ID only */\n            proto_tree_add_item(tree, hf_zbee_gp_src_id, tvb, *offset, 4, ENC_LITTLE_ENDIAN);\n            *offset += 4;\n        }\n        else if (app_id == ZBEE_ZCL_GP_APP_ID_ZGP) {\n            /* App_id = 010: MAC address + Endoint */\n            proto_tree_add_item(tree, hf_zbee_gp_ieee, tvb, *offset, 8, ENC_LITTLE_ENDIAN);\n            *offset += 8;\n            proto_tree_add_item(tree, hf_zbee_gp_endpoint, tvb, *offset, 1, ENC_NA);\n            *offset += 1;\n        }\n    }\n    else if (req_type == ZBEE_ZCL_GP_PROXY_SINK_TABLE_REQ_CMD_REQUSET_BY_INDEX) {\n        /* Include index only */\n        proto_tree_add_item(tree, hf_zbee_zcl_proxy_sink_tbl_req_index, tvb, *offset, 1, ENC_NA);\n        *offset += 1;\n    }\n"]]}
{"hexsha": "bd4c0e28cc54a0d726aef7db2bf7bba1e4101444", "ext": "h", "lang": "C", "content": "class NumberParserTest : public IntlTest {\n  public:\n    void testBasic();\n    void testLocaleFi();\n    void testSeriesMatcher();\n    void testCombinedCurrencyMatcher();\n    void testAffixPatternMatcher();\n    void testGroupingDisabled();\n    void testCaseFolding();\n    void test20360_BidiOverflow();\n    void testInfiniteRecursion();\n\n    void runIndexedTest(int32_t index, UBool exec, const char *&name, char *par = 0);\n}", "item_id": 5, "repo": "quyse/inanity", "file": "deps/icu/repo/source/test/intltest/numbertest.h", "last_update_at": "2020-11-15T11:07:56+00:00", "question_id": "bd4c0e28cc54a0d726aef7db2bf7bba1e4101444_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class NumberParserTest : public IntlTest {\n  public:\n    void testBasic();\n    void testLocaleFi();\n    void testSeriesMatcher();\n    void testCombinedCurrencyMatcher();\n    void testAffixPatternMatcher();\n    void testGroupingDisabled();\n    void testCaseFolding();\n    void test20360_BidiOverflow();\n    void testInfiniteRecursion();\n    void runIndexedTest(int32_t index, UBool exec, const char *&name, char *par = 0);\n"]]}
{"hexsha": "b4b2014f5d3d6acab384365c8f29d4b18614062b", "ext": "c", "lang": "C", "content": "static void MP4_FreeBox_avcC( MP4_Box_t *p_box )\n{\n    MP4_Box_data_avcC_t *p_avcC = p_box->data.p_avcC;\n    int i;\n\n    if( p_avcC->i_avcC > 0 ) FREENULL( p_avcC->p_avcC );\n\n    if( p_avcC->sps )\n    {\n        for( i = 0; i < p_avcC->i_sps; i++ )\n            FREENULL( p_avcC->sps[i] );\n    }\n    if( p_avcC->pps )\n    {\n        for( i = 0; i < p_avcC->i_pps; i++ )\n            FREENULL( p_avcC->pps[i] );\n    }\n    if( p_avcC->i_sps > 0 ) FREENULL( p_avcC->sps );\n    if( p_avcC->i_sps > 0 ) FREENULL( p_avcC->i_sps_length );\n    if( p_avcC->i_pps > 0 ) FREENULL( p_avcC->pps );\n    if( p_avcC->i_pps > 0 ) FREENULL( p_avcC->i_pps_length );\n}", "item_id": 32, "repo": "dhs347/gear-lib", "file": "src/mp4parser_inner.c", "last_update_at": "2020-05-15T05:44:00+00:00", "question_id": "b4b2014f5d3d6acab384365c8f29d4b18614062b_32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void MP4_FreeBox_avcC( MP4_Box_t *p_box )\n{\n    MP4_Box_data_avcC_t *p_avcC = p_box->data.p_avcC;\n    int i;\n    if( p_avcC->i_avcC > 0 ) FREENULL( p_avcC->p_avcC );\n    if( p_avcC->sps )\n    {\n        for( i = 0; i < p_avcC->i_sps; i++ )\n            FREENULL( p_avcC->sps[i] );\n    }\n    if( p_avcC->pps )\n    {\n        for( i = 0; i < p_avcC->i_pps; i++ )\n            FREENULL( p_avcC->pps[i] );\n    }\n    if( p_avcC->i_sps > 0 ) FREENULL( p_avcC->sps );\n    if( p_avcC->i_sps > 0 ) FREENULL( p_avcC->i_sps_length );\n    if( p_avcC->i_pps > 0 ) FREENULL( p_avcC->pps );\n    if( p_avcC->i_pps > 0 ) FREENULL( p_avcC->i_pps_length );\n"]]}
{"hexsha": "c1969597dd911de7c2382f1af190a983a881bc94", "ext": "c", "lang": "C", "content": "TSS2_RC Tss2_Sys_CreateLoaded_Prepare(\n    TSS2_SYS_CONTEXT *sysContext,\n    TPMI_RH_HIERARCHY parentHandle,\n    const TPM2B_SENSITIVE_CREATE *inSensitive,\n    const TPM2B_TEMPLATE *inPublic)\n{\n    _TSS2_SYS_CONTEXT_BLOB *ctx = syscontext_cast(sysContext);\n    TSS2_RC rval;\n\n    if (!ctx)\n        return TSS2_SYS_RC_BAD_REFERENCE;\n\n    if (!inPublic)\n        return TSS2_SYS_RC_BAD_REFERENCE;\n\n    rval = CommonPreparePrologue(ctx, TPM2_CC_CreateLoaded);\n    if (rval)\n        return rval;\n\n    rval = Tss2_MU_UINT32_Marshal(parentHandle, ctx->cmdBuffer,\n                          ctx->maxCmdSize,\n                          &ctx->nextData);\n    if (rval)\n        return rval;\n\n    if (!inSensitive) {\n        ctx->decryptNull = 1;\n\n        rval = Tss2_MU_UINT16_Marshal(0, ctx->cmdBuffer,\n                                      ctx->maxCmdSize,\n                                      &ctx->nextData);\n    } else {\n        rval = Tss2_MU_TPM2B_SENSITIVE_CREATE_Marshal(inSensitive,\n                                                      ctx->cmdBuffer,\n                                                      ctx->maxCmdSize,\n                                                      &ctx->nextData);\n    }\n\n    if (rval)\n        return rval;\n\n    rval = Tss2_MU_TPM2B_TEMPLATE_Marshal(inPublic, ctx->cmdBuffer,\n                                          ctx->maxCmdSize,\n                                          &ctx->nextData);\n    if (rval)\n        return rval;\n\n    ctx->decryptAllowed = 1;\n    ctx->encryptAllowed = 1;\n    ctx->authAllowed = 1;\n\n    rval = CommonPrepareEpilogue(ctx);\n    return rval;\n}", "item_id": 0, "repo": "jhachenbergerSIT/tpm2-tss", "file": "src/tss2-sys/api/Tss2_Sys_CreateLoaded.c", "last_update_at": "2020-12-23T06:51:09+00:00", "question_id": "c1969597dd911de7c2382f1af190a983a881bc94_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TSS2_RC Tss2_Sys_CreateLoaded_Prepare(\n    TSS2_SYS_CONTEXT *sysContext,\n    TPMI_RH_HIERARCHY parentHandle,\n    const TPM2B_SENSITIVE_CREATE *inSensitive,\n    const TPM2B_TEMPLATE *inPublic)\n{\n    _TSS2_SYS_CONTEXT_BLOB *ctx = syscontext_cast(sysContext);\n    TSS2_RC rval;\n    if (!ctx)\n        return TSS2_SYS_RC_BAD_REFERENCE;\n    if (!inPublic)\n        return TSS2_SYS_RC_BAD_REFERENCE;\n    rval = CommonPreparePrologue(ctx, TPM2_CC_CreateLoaded);\n    if (rval)\n        return rval;\n    rval = Tss2_MU_UINT32_Marshal(parentHandle, ctx->cmdBuffer,\n                          ctx->maxCmdSize,\n                          &ctx->nextData);\n    if (rval)\n        return rval;\n    if (!inSensitive) {\n        ctx->decryptNull = 1;\n        rval = Tss2_MU_UINT16_Marshal(0, ctx->cmdBuffer,\n                                      ctx->maxCmdSize,\n                                      &ctx->nextData);\n    } else {\n        rval = Tss2_MU_TPM2B_SENSITIVE_CREATE_Marshal(inSensitive,\n                                                      ctx->cmdBuffer,\n                                                      ctx->maxCmdSize,\n                                                      &ctx->nextData);\n    }\n    if (rval)\n        return rval;\n    rval = Tss2_MU_TPM2B_TEMPLATE_Marshal(inPublic, ctx->cmdBuffer,\n                                          ctx->maxCmdSize,\n                                          &ctx->nextData);\n    if (rval)\n        return rval;\n    ctx->decryptAllowed = 1;\n    ctx->encryptAllowed = 1;\n    ctx->authAllowed = 1;\n    rval = CommonPrepareEpilogue(ctx);\n    return rval;\n"]]}
{"hexsha": "187a6c648eb470a31fb911bfa98305b4a5a78dd7", "ext": "c", "lang": "C", "content": "static struct S0  func_52(struct S0  p_53, struct S1 * p_54, struct S1 * p_55, struct S1 * p_56, struct S1  p_57)\n{ /* block id: 101 */\n    uint8_t l_227 = 3UL;\n    int32_t *l_228 = &g_214;\n    const struct S3 l_229 = {-12834,3,624,-6,8,31570,34,35,4,446};\n    struct S1 l_234 = {0x7CBEL,65531UL};\n    int8_t *l_255 = &g_253;\n    int32_t l_280 = 0xE149A9F4L;\n    int32_t l_281 = 3L;\n    int32_t l_318 = (-2L);\n    int32_t l_320 = 0xFA7069FDL;\n    int32_t l_322[1][1];\n    int32_t l_383[6] = {1L,1L,1L,1L,1L,1L};\n    struct S5 *l_427 = &g_69;\n    int16_t **l_492 = (void*)0;\n    uint16_t l_548 = 1UL;\n    int8_t l_581 = 0x33L;\n    int16_t ***l_597 = &l_492;\n    uint32_t l_646 = 0UL;\n    int i, j;\n    for (i = 0; i < 1; i++)\n    {\n        for (j = 0; j < 1; j++)\n            l_322[i][j] = 0L;\n    }\n    if ((((*l_228) = l_227) <= ((l_229 , (&p_57 != (void*)0)) == p_53.f2)))\n    { /* block id: 103 */\n        for (g_94 = 8; (g_94 > 31); g_94 = safe_add_func_uint16_t_u_u(g_94, 2))\n        { /* block id: 106 */\n            if (p_57.f1)\n                break;\n        }\n    }\n    else\n    { /* block id: 109 */\n        int16_t *l_247 = &g_109;\n        int16_t * const l_249 = (void*)0;\n        int32_t l_250 = (-1L);\n        int32_t l_272 = 0L;\n        int32_t l_275 = 0L;\n        int32_t l_329 = 0x121242E4L;\n        struct S0 l_363 = {175,9,31,37};\n        int32_t l_374 = 0x9A027F3BL;\n        uint32_t l_391 = 0xCD74C835L;\n        uint32_t ***l_400 = &g_345;\n        uint32_t *l_409 = (void*)0;\n        int32_t *l_410 = &l_280;\n        const uint16_t l_411 = 0x43A9L;\n        int32_t *l_412 = &l_250;\n        struct S5 l_415[5][8] = {{{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L}},{{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L}},{{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L}},{{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L}},{{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L}}};\n        uint32_t l_544 = 4294967293UL;\n        uint32_t l_582 = 0xA0A9C2C1L;\n        int32_t l_621[4] = {0xC353EE67L,0xC353EE67L,0xC353EE67L,0xC353EE67L};\n        int16_t ***l_630 = &l_492;\n        struct S3 l_639 = {-32711,-2,123,13,10,14313,101,-44,-66,6352};\n        struct S1 *l_645 = &l_234;\n        int i, j;\n        for (l_227 = (-14); (l_227 <= 46); l_227++)\n        { /* block id: 112 */\n            struct S0 *l_236 = &g_153;\n            struct S0 **l_235 = &l_236;\n            struct S0 **l_237 = (void*)0;\n            struct S0 *l_239[4][5] = {{&g_153,(void*)0,&g_153,&g_153,&g_153},{(void*)0,&g_153,(void*)0,&g_153,&g_153},{&g_153,(void*)0,&g_153,&g_153,&g_153},{(void*)0,&g_153,(void*)0,&g_153,&g_153}};\n            struct S0 **l_238 = &l_239[2][1];\n            int32_t l_244 = 3L;\n            int16_t **l_248 = &l_247;\n            int32_t l_305 = 0xFBD691C8L;\n            int32_t l_323 = (-5L);\n            int32_t l_326[3][3][10] = {{{0x1F4B9C93L,8L,8L,0x1F4B9C93L,0x349389C5L,5L,0x73619E2BL,(-1L),(-1L),1L},{0xFDE84D4DL,(-1L),(-1L),0x73619E2BL,8L,0x7A2AB3D7L,8L,0x73619E2BL,(-1L),(-1L)},{(-1L),1L,(-1L),0x1F4B9C93L,0x71D502BBL,0xDEF5D37AL,5L,(-1L),0x349389C5L,0x349389C5L}},{{1L,1L,0xDEF5D37AL,0x7A2AB3D7L,0x7A2AB3D7L,0xDEF5D37AL,1L,1L,0x1F4B9C93L,5L},{(-1L),(-1L),0x73619E2BL,1L,0L,0x7A2AB3D7L,(-1L),5L,(-1L),0x7A2AB3D7L},{0xFDE84D4DL,0L,0x73619E2BL,0L,0xFDE84D4DL,5L,0x1F4B9C93L,1L,1L,0xDEF5D37AL}},{{0x1F4B9C93L,0x71D502BBL,0xDEF5D37AL,5L,(-1L),0x349389C5L,0x349389C5L,(-1L),5L,0xDEF5D37AL},{5L,5L,(-1L),0xDEF5D37AL,0xFDE84D4DL,(-1L),(-1L),0x73619E2BL,8L,0x7A2AB3D7L},{0x73619E2BL,(-1L),(-1L),1L,0L,1L,(-1L),(-1L),0x73619E2BL,5L}}};\n            int32_t *l_373 = &l_329;\n            int32_t *l_378 = &l_323;\n            int32_t *l_379 = &l_275;\n            int32_t *l_380 = &l_280;\n            int32_t *l_381[8] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};\n            int32_t l_382 = 0x5FE0C3B8L;\n            uint16_t l_384 = 1UL;\n            uint8_t l_388[10][1][2] = {{{0x82L,0xB0L}},{{0xB0L,0x5FL}},{{0xB0L,0x5FL}},{{0xB0L,0xB0L}},{{0x82L,0x82L}},{{0x82L,0xB0L}},{{0xB0L,0x5FL}},{{0xB0L,0x5FL}},{{0xB0L,0xB0L}},{{0x82L,0x82L}}};\n            int i, j, k;\n            if ((((p_53.f0 == (func_17(l_234, (((*l_238) = ((*l_235) = &p_53)) != &p_53)) , g_113.f8)) < (safe_rshift_func_uint16_t_u_s((((((safe_add_func_uint8_t_u_u(l_244, ((safe_mul_func_int8_t_s_s((250UL != (+((((*l_248) = l_247) != l_249) ^ p_53.f2))), (*l_228))) || p_53.f2))) , (*l_228)) , 0xC7L) || l_250) | p_53.f3), g_113.f3))) == l_250))\n            { /* block id: 116 */\n                int32_t l_251 = 0xAE49ED9AL;\n                int8_t *l_254 = &g_253;\n                for (g_69.f0 = 0; (g_69.f0 <= 8); g_69.f0 += 1)\n                { /* block id: 119 */\n                    uint16_t *l_262 = (void*)0;\n                    uint16_t *l_263 = &l_234.f0;\n                    int16_t *l_273[5];\n                    int i;\n                    for (i = 0; i < 5; i++)\n                        l_273[i] = &g_274;\n                    if (l_251)\n                        break;\n                    (*l_228) |= ((0x2AL | (g_252 == (l_255 = l_254))) , (p_53 , (safe_add_func_uint16_t_u_u((safe_div_func_int16_t_s_s((l_275 ^= (p_53 , ((safe_div_func_int32_t_s_s((((*l_263) = 0x18A4L) | ((((g_109 = (l_272 &= (safe_mul_func_uint16_t_u_u(((safe_sub_func_uint8_t_u_u(((-1L) || (!((safe_mul_func_uint8_t_u_u((safe_mod_func_int16_t_s_s((-7L), (5UL && 251UL))), l_250)) ^ l_244))), 7UL)) || l_251), 0L)))) != 0UL) , (void*)0) != &l_229)), p_57.f1)) > (*g_252)))), p_57.f1)), 0x5575L))));\n                    if (l_251)\n                        break;\n                    p_53.f0 = ((safe_rshift_func_int8_t_s_s((*g_252), p_53.f2)) , (0UL || (*l_228)));\n                }\n            }\n            else\n            { /* block id: 130 */\n                int32_t *l_278 = &l_250;\n                int32_t *l_279[8][4] = {{&l_244,(void*)0,(void*)0,(void*)0},{(void*)0,&l_272,&l_275,&l_244},{(void*)0,&l_250,&l_250,(void*)0},{(void*)0,(void*)0,&l_275,&g_214},{(void*)0,(void*)0,(void*)0,&l_244},{&l_244,&l_250,&l_244,&l_244},{(void*)0,(void*)0,(void*)0,&g_214},{&l_275,(void*)0,(void*)0,(void*)0}};\n                uint8_t l_282 = 253UL;\n                uint16_t *l_289[6] = {&g_43[6][6][2].f0,&g_43[6][6][2].f0,&g_43[6][6][2].f0,&g_43[6][6][2].f0,&g_43[6][6][2].f0,&g_43[6][6][2].f0};\n                struct S0 *l_300[7] = {&g_153,&g_153,&g_153,&g_153,&g_153,&g_153,&g_153};\n                uint8_t *l_303 = &g_94;\n                uint32_t l_304 = 0x5DECD937L;\n                int32_t l_328 = 0L;\n                uint32_t **l_333 = (void*)0;\n                struct S5 l_358 = {65526UL,65535UL,{-17020,-3,129,6,9,5641,116,6,16,3716},0x87A08BDBL};\n                int i, j;\n                ++l_282;\n                if ((((((safe_mul_func_int16_t_s_s((l_244 = (safe_add_func_int8_t_s_s(((((--g_69.f0) || l_244) & (g_43[6][6][2].f1 = p_53.f2)) ^ ((**l_248) |= (g_274 = p_57.f1))), (*g_252)))), (safe_div_func_int8_t_s_s((safe_rshift_func_uint8_t_u_u(g_182.f9, 0)), ((*l_303) = ((p_53.f1 && ((safe_lshift_func_uint8_t_u_s((safe_sub_func_uint32_t_u_u((l_300[0] == (*l_235)), ((*l_228) = ((safe_sub_func_int8_t_s_s(0x3CL, 1L)) | p_57.f1)))), 5)) <= l_250)) | g_113.f0)))))) | g_69.f3) || p_53.f0) , l_304) != l_305))\n                { /* block id: 139 */\n                    struct S4 *l_308 = &g_138;\n                    int32_t l_315 = 1L;\n                    int32_t l_316 = 0xC4D5F313L;\n                    int32_t l_317 = 0x579CAB94L;\n                    int32_t l_325 = 0L;\n                    int32_t l_327[4][3][8] = {{{0x030C2675L,3L,0xE8FD32BEL,0xFF4CD6DDL,(-1L),1L,1L,1L},{3L,(-10L),0x51BD3FEEL,1L,(-10L),0x8A8F9135L,0x3ADFECCFL,0xDE5CFD58L},{0x51BD3FEEL,(-1L),0x57BA0327L,1L,0xFDD9E36FL,3L,0x3D1CCB86L,1L}},{{0x3D1CCB86L,0x3ADFECCFL,0x57BA0327L,0xFF4CD6DDL,0xFF4CD6DDL,0x57BA0327L,0x3ADFECCFL,0x3D1CCB86L},{0xFDD9E36FL,0x5D09D952L,0x51BD3FEEL,0xDE5CFD58L,(-1L),(-1L),0xE8FD32BEL,0x57BA0327L},{0L,1L,(-1L),0x8A8F9135L,0xDE5CFD58L,(-1L),0xDE5CFD58L,0x8A8F9135L}},{{0x3ADFECCFL,0x5D09D952L,0x3ADFECCFL,0x51BD3FEEL,(-1L),0x57BA0327L,1L,0xFDD9E36FL},{0x8A8F9135L,0x3ADFECCFL,0xDE5CFD58L,0xE8FD32BEL,0L,3L,(-1L),(-1L)},{0x8A8F9135L,(-1L),0x3D1CCB86L,0x3D1CCB86L,(-1L),0x8A8F9135L,0x5D09D952L,(-10L)}},{{0x3ADFECCFL,1L,3L,0x5D09D952L,0xDE5CFD58L,0x030C2675L,0xFDD9E36FL,0xFF4CD6DDL},{0L,(-10L),0x030C2675L,0x5D09D952L,(-1L),0x5D09D952L,0x030C2675L,(-10L)},{0xFDD9E36FL,(-1L),0xE8FD32BEL,0x3D1CCB86L,0xFF4CD6DDL,0x51BD3FEEL,0L,(-1L)}}};\n                    int i, j, k;\n                    for (p_57.f0 = (-21); (p_57.f0 < 48); ++p_57.f0)\n                    { /* block id: 142 */\n                        struct S4 **l_309 = &l_308;\n                        (*l_309) = l_308;\n                        return g_153;\n                    }\n                    if (l_305)\n                        break;\n                    for (l_305 = (-25); (l_305 < 11); l_305 = safe_add_func_int16_t_s_s(l_305, 1))\n                    { /* block id: 149 */\n                        int8_t l_312 = 0xE5L;\n                        int32_t l_313 = 1L;\n                        int32_t l_314 = 0xB566A646L;\n                        int32_t l_319 = 1L;\n                        int32_t l_321 = 3L;\n                        int32_t l_324[4];\n                        uint16_t l_330 = 0xFA7FL;\n                        int i;\n                        for (i = 0; i < 4; i++)\n                            l_324[i] = 0x82E92E31L;\n                        l_330--;\n                    }\n                    for (l_244 = 0; (l_244 <= 3); l_244 += 1)\n                    { /* block id: 154 */\n                        uint32_t ***l_334 = &l_333;\n                        int32_t l_347 = 0xF0677D09L;\n                        struct S2 **l_350 = &g_348;\n                        int i, j;\n                        (*l_334) = l_333;\n                        p_53.f0 = (247UL & (safe_lshift_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u((safe_lshift_func_int16_t_s_s((safe_add_func_uint16_t_u_u((p_57.f1 = ((&l_239[l_244][(l_244 + 1)] == &l_239[l_244][l_244]) < (~(((((*l_228) && p_57.f0) ^ (safe_lshift_func_int16_t_s_s((+(*l_278)), (((((((((((l_315 > ((g_345 == (void*)0) , g_113.f6)) < g_69.f2.f3) >= p_53.f0) , l_326[1][0][2]) || 1UL) != (*g_252)) && (*g_252)) >= p_57.f0) >= 65532UL) , 0x41F066B9L) || p_57.f1)))) ^ l_347) < l_305)))), p_53.f2)), p_53.f3)), g_138.f0.f2)), 15)));\n                        (*l_350) = g_348;\n                    }\n                }\n                else\n                { /* block id: 160 */\n                    struct S3 **l_351 = &g_112;\n                    struct S3 *l_354 = &g_138.f0;\n                    struct S3 **l_353[1];\n                    int i;\n                    for (i = 0; i < 1; i++)\n                        l_353[i] = &l_354;\n                    g_356 = (g_355 = (g_352 = ((*l_351) = (void*)0)));\n                    if (l_329)\n                        continue;\n                }\n                (*l_228) = (l_358 , ((*l_278) = p_53.f0));\n                (*l_228) ^= (g_69.f1 <= (p_57.f1 || (*g_252)));\n            }\n            for (l_318 = 0; (l_318 <= (-8)); --l_318)\n            { /* block id: 173 */\n                uint16_t l_367[3];\n                int32_t *l_372 = &g_214;\n                int i;\n                for (i = 0; i < 3; i++)\n                    l_367[i] = 65527UL;\n                for (l_234.f1 = (-8); (l_234.f1 >= 26); ++l_234.f1)\n                { /* block id: 176 */\n                    (*l_228) = (l_275 > (*g_252));\n                    return l_363;\n                }\n                l_244 = (*l_228);\n                for (l_234.f1 = 3; (l_234.f1 <= 8); l_234.f1 += 1)\n                { /* block id: 183 */\n                    uint16_t l_375 = 0x71EFL;\n                    for (l_244 = 0; (l_244 <= 8); l_244 += 1)\n                    { /* block id: 186 */\n                        return g_153;\n                    }\n                    for (g_84 = 8; (g_84 >= 0); g_84 -= 1)\n                    { /* block id: 191 */\n                        int32_t *l_364 = &l_329;\n                        int32_t *l_365 = (void*)0;\n                        int32_t *l_366[1];\n                        int32_t **l_370 = &l_366[0];\n                        int32_t **l_371 = (void*)0;\n                        int i;\n                        for (i = 0; i < 1; i++)\n                            l_366[i] = (void*)0;\n                        l_367[1]++;\n                        g_151[4] = (l_373 = (l_372 = ((*l_370) = &g_214)));\n                        --l_375;\n                    }\n                }\n            }\n            l_384++;\n            for (g_94 = 2; (g_94 <= 7); g_94 += 1)\n            { /* block id: 204 */\n                int16_t l_387[1][8];\n                int i, j;\n                for (i = 0; i < 1; i++)\n                {\n                    for (j = 0; j < 8; j++)\n                        l_387[i][j] = 1L;\n                }\n                l_388[6][0][1]--;\n                (*l_380) = l_387[0][0];\n            }\n        }\n        if (((*l_412) = ((((p_53.f3 = ((*l_228) = (p_53.f1 = l_391))) || ((*l_410) ^= (safe_rshift_func_int16_t_s_u((((p_53.f3 <= (((safe_sub_func_uint8_t_u_u((safe_mul_func_int16_t_s_s((-2L), (safe_lshift_func_uint16_t_u_u((l_374 != 65530UL), 13)))), ((*l_255) = ((((*l_400) = &g_346[3][1][3]) != (g_401 = &g_346[0][2][2])) <= (l_272 ^= (safe_sub_func_uint8_t_u_u((((safe_sub_func_uint32_t_u_u((((safe_unary_minus_func_uint16_t_u(((safe_lshift_func_int16_t_s_u(((((*l_228) && ((*g_252) | 2UL)) , p_53.f1) != g_69.f0), 9)) > (-5L)))) >= p_53.f0) > (*l_228)), (*l_228))) >= (*l_228)) , (*l_228)), 1UL))))))) | 65528UL) | p_57.f1)) <= 1L) < g_182.f0), l_275)))) > l_411) , p_53.f3)))\n        { /* block id: 218 */\n            uint8_t l_443[8] = {0x1DL,0x1DL,0x1DL,0x1DL,0x1DL,0x1DL,0x1DL,0x1DL};\n            uint32_t *l_451 = &g_131;\n            int32_t l_504[3][5] = {{(-1L),(-1L),1L,1L,(-1L)},{(-1L),(-1L),1L,1L,(-1L)},{(-1L),(-1L),1L,1L,(-1L)}};\n            struct S4 *l_574 = &g_518[1];\n            int16_t ***l_595 = &l_492;\n            int16_t l_620 = (-6L);\n            uint8_t l_622 = 0x8BL;\n            uint32_t *l_636 = &g_494[2];\n            uint16_t l_644 = 0x655EL;\n            int i, j;\n            if ((((safe_mul_func_uint8_t_u_u(p_53.f2, ((l_415[1][6] , ((*l_228) = (((safe_mod_func_uint8_t_u_u((safe_unary_minus_func_int8_t_s(p_53.f2)), 0xEFL)) >= ((safe_sub_func_uint8_t_u_u((safe_div_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s((safe_add_func_uint32_t_u_u((7UL < (((*g_75) = l_427) == (void*)0)), ((safe_div_func_uint8_t_u_u(((safe_div_func_uint32_t_u_u((((safe_lshift_func_uint8_t_u_u((safe_mod_func_int32_t_s_s(p_53.f2, (g_113.f5 && 255UL))), g_94)) >= 0x48L) , 0x0A836DACL), p_53.f1)) | g_349.f0), (*l_228))) , 4L))), g_111.f4)), p_53.f1)), (*g_252))) || p_53.f1)) , 0xA8E3F1E3L))) ^ 0x4A00F90DL))) ^ 0x7BL) < 0x4F381AB7L))\n            { /* block id: 221 */\n                struct S1 l_450 = {0x958CL,0UL};\n                int8_t l_468[8][4][2] = {{{0x38L,1L},{0x38L,0x38L},{1L,0x38L},{0x38L,1L}},{{0x38L,0x38L},{1L,0x38L},{0x38L,1L},{0x38L,0x38L}},{{1L,0x38L},{0x38L,1L},{0x38L,0x38L},{1L,0x38L}},{{0x38L,1L},{0x38L,0x38L},{1L,0x38L},{0x38L,1L}},{{0x38L,0x38L},{1L,0x38L},{0x38L,1L},{0x38L,0x38L}},{{1L,0x38L},{0x38L,1L},{0x38L,0x38L},{1L,0x38L}},{{0x38L,1L},{0x38L,0x38L},{1L,0x38L},{0x38L,1L}},{{0x38L,0x38L},{1L,0x38L},{0x38L,1L},{0x38L,0x38L}}};\n                int32_t l_476 = (-1L);\n                int16_t ***l_493 = &l_492;\n                int32_t l_503 = (-3L);\n                struct S4 *l_520 = &g_521[4][0][0];\n                const struct S3 l_529 = {2366,0,1008,2,10,12108,126,-23,-15,1054};\n                int32_t *l_575 = &l_476;\n                int32_t *l_576 = &l_503;\n                int32_t *l_577 = &l_374;\n                int32_t *l_578 = &l_281;\n                int32_t *l_579 = &l_476;\n                int32_t *l_580[7];\n                int i, j, k;\n                for (i = 0; i < 7; i++)\n                    l_580[i] = &l_250;\n                if ((safe_unary_minus_func_int8_t_s((safe_div_func_int16_t_s_s((((safe_rshift_func_uint16_t_u_s((safe_div_func_int8_t_s_s(p_53.f3, l_443[6])), ((((*l_247) = ((*g_42) , (p_53.f3 && (*l_412)))) >= (safe_div_func_uint8_t_u_u(9UL, 1UL))) <= p_57.f0))) > (safe_sub_func_int32_t_s_s((safe_add_func_uint8_t_u_u((((l_451 = (func_17(l_450, l_450.f0) , (*g_345))) != (**l_400)) == (*l_410)), (*l_228))), (*l_228)))) < l_443[6]), g_357.f9)))))\n                { /* block id: 224 */\n                    int8_t l_457[7];\n                    int i;\n                    for (i = 0; i < 7; i++)\n                        l_457[i] = 0xE6L;\n                    for (g_349.f5 = 15; (g_349.f5 == (-25)); --g_349.f5)\n                    { /* block id: 227 */\n                        uint16_t l_460[9] = {0x13E5L,1UL,0x13E5L,0x13E5L,1UL,0x13E5L,0x13E5L,1UL,0x13E5L};\n                        uint16_t *l_463 = &l_450.f1;\n                        int i;\n                        (*l_412) |= ((p_53.f3 & ((*l_247) = 0xA57DL)) & (*l_228));\n                        if (p_53.f0)\n                            break;\n                        p_53.f0 = ((!((safe_unary_minus_func_uint32_t_u(((safe_mod_func_int32_t_s_s(((*l_410) = (-2L)), ((*l_228) &= p_53.f3))) ^ l_457[0]))) || (((g_153.f0 >= (+(safe_div_func_uint32_t_u_u(p_53.f2, (((l_460[8] , (safe_lshift_func_uint16_t_u_u(p_53.f2, 15))) ^ (((*l_463) = g_111.f6) , (((0x2BB8L < p_53.f2) ^ p_53.f0) > 4294967295UL))) , p_53.f0))))) && l_457[0]) <= 0x1EL))) == p_53.f3);\n                        (*g_42) = (*p_54);\n                    }\n                }\n                else\n                { /* block id: 237 */\n                    uint8_t l_477 = 0x96L;\n                    for (l_450.f0 = 0; (l_450.f0 != 42); l_450.f0 = safe_add_func_int16_t_s_s(l_450.f0, 2))\n                    { /* block id: 240 */\n                        int32_t l_466[6] = {0x1655F412L,0x1655F412L,0x1655F412L,0x1655F412L,0x1655F412L,0x1655F412L};\n                        int32_t *l_467 = (void*)0;\n                        int32_t *l_469 = (void*)0;\n                        int32_t *l_470 = &l_466[5];\n                        int32_t *l_471 = &l_322[0][0];\n                        int32_t *l_472 = &l_320;\n                        int32_t *l_473 = &l_272;\n                        int32_t *l_474 = &l_374;\n                        int32_t *l_475[8][1] = {{&l_320},{&l_281},{&l_281},{&l_322[0][0]},{&l_320},{&l_320},{&l_322[0][0]},{&l_320}};\n                        int i, j;\n                        l_477--;\n                        return g_153;\n                    }\n                }\n                if (((*l_228) |= (((g_494[2] = (!((safe_rshift_func_int16_t_s_s(((*l_247) = ((void*)0 == &g_23)), 6)) == (safe_add_func_int32_t_s_s(((safe_rshift_func_int16_t_s_u((((p_53.f1 = (*l_412)) > (*l_410)) && (safe_add_func_uint8_t_u_u(((safe_rshift_func_int8_t_s_u((safe_rshift_func_int16_t_s_u((g_274 = (&g_76 != (((*g_252) , (((*l_493) = l_492) != (void*)0)) , &g_76))), p_53.f1)), g_111.f7)) | l_450.f0), p_57.f0))), g_111.f5)) , 1L), p_53.f0))))) > l_468[7][3][0]) || 1L)))\n                { /* block id: 251 */\n                    struct S3 *l_497[9][10][2] = {{{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113}},{{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111}},{{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113}},{{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0}},{{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182}},{{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182}},{{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0}},{{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113}},{{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111}}};\n                    int32_t l_505 = 0x3BBE76C4L;\n                    uint8_t l_506 = 6UL;\n                    int i, j, k;\n                    (*l_410) |= ((*l_412) = p_53.f0);\n                    for (l_374 = (-26); (l_374 == 16); l_374 = safe_add_func_int16_t_s_s(l_374, 4))\n                    { /* block id: 256 */\n                        struct S3 **l_498 = &l_497[8][7][0];\n                        (*l_498) = l_497[8][9][0];\n                    }\n                    for (p_57.f0 = 0; (p_57.f0 != 45); p_57.f0 = safe_add_func_uint8_t_u_u(p_57.f0, 7))\n                    { /* block id: 261 */\n                        int32_t **l_501 = &l_412;\n                        int32_t *l_502[1];\n                        int i;\n                        for (i = 0; i < 1; i++)\n                            l_502[i] = &l_281;\n                        (*l_501) = &l_281;\n                        l_506++;\n                    }\n                }\n                else\n                { /* block id: 265 */\n                    struct S4 *l_516 = &g_138;\n                    struct S4 **l_515 = &l_516;\n                    struct S4 **l_519 = (void*)0;\n                    uint16_t *l_523 = (void*)0;\n                    uint16_t *l_524 = &l_450.f0;\n                    int32_t l_547 = 2L;\n                    struct S5 *l_566 = (void*)0;\n                    p_53.f0 = (((safe_div_func_int32_t_s_s((safe_mul_func_uint16_t_u_u(((*l_524) = (+(l_504[1][2] || (g_138 , (((*l_410) = (safe_add_func_int8_t_s_s((*g_252), ((l_520 = (g_517 = ((*l_515) = &g_138))) == ((*g_348) , &g_521[4][0][0]))))) >= (safe_unary_minus_func_int16_t_s((g_113.f9 < ((g_69.f2.f4 ^ (~p_57.f0)) <= p_53.f3))))))))), 0x3F82L)), 1L)) || 8L) != p_53.f1);\n                    for (g_85 = 0; (g_85 <= 2); g_85 += 1)\n                    { /* block id: 274 */\n                        uint32_t *l_532 = &g_494[3];\n                        int32_t l_535 = (-6L);\n                        uint16_t *l_545 = &g_43[6][6][2].f1;\n                        uint16_t l_546 = 65532UL;\n                        struct S2 **l_551 = &g_348;\n                        int32_t *l_567 = &l_503;\n                        (*l_412) = ((safe_lshift_func_uint8_t_u_s((safe_mod_func_uint32_t_u_u(((g_153 , ((l_529 , (((*l_545) = (safe_sub_func_int8_t_s_s(((((+(--(*l_532))) , ((*g_517) , (l_535 | ((g_182.f8 , (((((safe_add_func_uint8_t_u_u((safe_div_func_int32_t_s_s((safe_sub_func_int32_t_s_s(l_504[0][1], p_53.f3)), (safe_lshift_func_uint8_t_u_u((((*l_524) = p_57.f0) <= (*l_228)), 1)))), 0x9CL)) > 0x6DCC9F64L) || l_544) >= (*g_252)) > 4UL)) >= 4294967295UL)))) <= g_138.f0.f6) < 5UL), 0xB6L))) == l_546)) | 0xC305L)) , l_529.f8), l_547)), (*g_252))) || l_548);\n                        (*l_412) &= (safe_add_func_int32_t_s_s(p_53.f3, (0xFA528CD4L <= ((((*p_56) = (*g_42)) , &l_228) == (void*)0))));\n                        (*l_551) = &g_349;\n                        (*l_567) ^= ((*l_228) > (safe_lshift_func_uint16_t_u_s(((safe_add_func_int32_t_s_s(p_57.f1, (((((g_153 , ((((*l_410) &= p_53.f3) ^ 4294967295UL) > (safe_mul_func_int16_t_s_s(p_57.f1, 5UL)))) <= ((safe_mul_func_uint16_t_u_u((safe_mul_func_uint8_t_u_u((safe_add_func_int16_t_s_s((((((255UL != (~(4294967294UL == 0UL))) , (void*)0) == l_566) , g_69.f3) ^ l_504[2][3]), g_274)), 0x5DL)), g_111.f6)) == l_535)) & 8UL) && p_53.f2) | (*l_412)))) || p_53.f0), 3)));\n                    }\n                    (*l_412) = (((g_274 |= 0L) == g_349.f1) && (safe_lshift_func_int8_t_s_s(0L, (safe_rshift_func_int16_t_s_s((safe_add_func_uint16_t_u_u(((void*)0 != l_574), (l_234 , l_529.f8))), 12)))));\n                }\n                l_582++;\n            }\n            else\n            { /* block id: 289 */\n                uint32_t l_606[6];\n                int32_t l_609 = 0x40AE2A13L;\n                int32_t *l_610 = &l_504[1][3];\n                int32_t *l_611 = &l_318;\n                int32_t *l_612 = &g_84;\n                int32_t *l_613 = &l_609;\n                int32_t *l_614 = (void*)0;\n                int32_t *l_615 = &l_504[1][2];\n                int32_t l_616 = 0x99467C25L;\n                int32_t *l_617 = &l_322[0][0];\n                int32_t *l_618[5];\n                int16_t l_619 = 8L;\n                int i;\n                for (i = 0; i < 6; i++)\n                    l_606[i] = 0x997170ADL;\n                for (i = 0; i < 5; i++)\n                    l_618[i] = &l_616;\n                for (g_131 = (-27); (g_131 == 22); g_131++)\n                { /* block id: 292 */\n                    for (l_318 = 2; (l_318 >= 0); l_318 -= 1)\n                    { /* block id: 295 */\n                        (*l_410) = ((*l_228) = p_57.f1);\n                    }\n                }\n                for (p_57.f0 = 3; (p_57.f0 <= 8); p_57.f0 += 1)\n                { /* block id: 302 */\n                    int32_t *l_600 = (void*)0;\n                    int32_t *l_602 = &l_504[2][0];\n                    int32_t *l_603 = &l_320;\n                    int32_t *l_604 = &l_281;\n                    int32_t *l_605[9][2] = {{(void*)0,&l_329},{(void*)0,(void*)0},{&l_329,&l_329},{&l_329,&l_280},{&l_329,&l_329},{&l_280,&l_329},{&l_329,&l_280},{&l_329,&l_329},{&l_280,&l_329}};\n                    int i, j;\n                    for (l_250 = 0; (l_250 <= 8); l_250 += 1)\n                    { /* block id: 305 */\n                        struct S3 l_594[7] = {{-9867,4,834,0,10,12828,54,32,17,4899},{-9867,4,834,0,10,12828,54,32,17,4899},{-9867,4,834,0,10,12828,54,32,17,4899},{-9867,4,834,0,10,12828,54,32,17,4899},{-9867,4,834,0,10,12828,54,32,17,4899},{-9867,4,834,0,10,12828,54,32,17,4899},{-9867,4,834,0,10,12828,54,32,17,4899}};\n                        int16_t ****l_596[10] = {&l_595,&l_595,&l_595,&l_595,&l_595,&l_595,&l_595,&l_595,&l_595,&l_595};\n                        uint16_t *l_598 = &l_415[1][6].f0;\n                        int i;\n                        (*l_410) |= ((safe_add_func_int8_t_s_s((safe_mod_func_uint16_t_u_u((((safe_unary_minus_func_int8_t_s((((&g_356 == &g_112) & (safe_mod_func_uint8_t_u_u((249UL >= (l_594[6] , (p_53.f1 != ((*l_598) = ((l_597 = l_595) == (void*)0))))), (*g_252)))) <= ((void*)0 == l_451)))) != g_599) != p_57.f0), 2UL)), (-1L))) != (*l_228));\n                    }\n                    l_606[2]--;\n                }\n                l_622++;\n            }\n            for (l_582 = 0; (l_582 > 11); l_582 = safe_add_func_int16_t_s_s(l_582, 7))\n            { /* block id: 316 */\n                struct S3 **l_627 = &g_356;\n                (*l_627) = &g_113;\n            }\n            (*l_410) |= (safe_sub_func_uint32_t_u_u(p_53.f1, (l_630 != ((g_599 = (safe_add_func_int32_t_s_s((*l_228), (safe_div_func_int16_t_s_s((safe_unary_minus_func_uint32_t_u(((*l_636) |= 1UL))), (safe_add_func_int8_t_s_s((*g_252), (g_153 , 0x7DL)))))))) , l_595))));\n            g_151[2] = &l_374;\n        }\n        else\n        { /* block id: 323 */\n            if (l_646)\n            { /* block id: 324 */\n                return p_53;\n            }\n            else\n            { /* block id: 326 */\n                struct S0 l_647[3][6][8] = {{{{-136,13,28,56},{145,13,26,9},{25,0,13,51},{-81,8,14,33},{-140,15,5,35},{-129,10,27,47},{124,4,0,104},{121,11,4,41}},{{30,12,15,71},{-136,13,28,56},{-55,14,13,73},{-148,11,29,18},{25,0,13,51},{-61,5,20,10},{66,11,28,12},{174,14,3,98}},{{110,4,20,75},{-150,13,15,70},{-141,10,31,71},{47,14,31,82},{-116,6,24,66},{95,3,18,52},{-81,14,25,100},{29,12,13,108}},{{-61,5,20,10},{-114,12,30,14},{-23,5,25,53},{172,13,28,120},{29,2,12,91},{174,14,3,98},{174,14,3,98},{29,2,12,91}},{{-23,5,25,53},{56,4,31,53},{56,4,31,53},{-23,5,25,53},{59,9,19,14},{30,12,15,71},{-61,5,20,10},{-118,2,9,105}},{{124,4,0,104},{47,14,31,82},{154,4,1,112},{-129,10,27,47},{-150,13,15,70},{-140,15,5,35},{172,13,28,120},{74,8,2,48}}},{{{-0,14,5,119},{47,14,31,82},{145,13,26,9},{-150,12,27,48},{174,14,3,98},{30,12,15,71},{-134,5,10,54},{154,4,1,112}},{{-97,7,20,120},{56,4,31,53},{-81,14,25,100},{-19,5,8,89},{-134,10,28,16},{174,14,3,98},{-112,11,31,77},{-149,15,5,23}},{{-140,15,5,35},{-114,12,30,14},{-116,6,24,66},{101,10,31,13},{95,1,23,52},{95,3,18,52},{-129,10,27,47},{172,13,28,120}},{{59,6,30,38},{-150,13,15,70},{59,9,19,14},{124,4,0,104},{152,6,21,93},{-61,5,20,10},{-141,10,31,71},{56,4,31,53}},{{-148,11,29,18},{-136,13,28,56},{-39,7,30,57},{-150,13,15,70},{29,12,13,108},{-129,10,27,47},{-114,12,30,14},{-141,10,31,71}},{{42,8,21,80},{145,13,26,9},{-81,8,14,33},{130,13,14,91},{-81,8,14,33},{145,13,26,9},{42,8,21,80},{-86,15,8,7}}},{{{25,0,13,51},{128,3,7,9},{59,6,30,38},{95,1,23,52},{154,4,1,112},{74,8,2,48},{45,11,4,116},{-116,6,24,66}},{{59,9,19,14},{101,10,31,13},{-118,2,9,105},{-136,13,28,56},{154,4,1,112},{-112,11,31,77},{110,4,20,75},{130,13,14,91}},{{25,0,13,51},{9,13,20,103},{-134,10,28,16},{-116,6,24,66},{-81,8,14,33},{161,6,7,45},{83,12,31,120},{-134,5,10,54}},{{42,8,21,80},{110,4,20,75},{-129,10,27,47},{34,6,31,81},{29,12,13,108},{95,1,23,52},{-46,5,11,42},{145,13,26,9}},{{-148,11,29,18},{-39,7,30,57},{30,12,15,71},{29,2,12,91},{152,6,21,93},{101,10,31,13},{154,4,1,112},{-19,5,8,89}},{{59,6,30,38},{-118,2,9,105},{42,8,21,80},{66,11,28,12},{95,1,23,52},{-136,13,28,56},{-140,15,5,35},{161,6,7,45}}}};\n                int i, j, k;\n                return l_647[1][1][5];\n            }\n        }\n        for (l_329 = 0; (l_329 != (-25)); l_329--)\n        { /* block id: 332 */\n            struct S1 **l_650[10] = {&l_645,&l_645,&l_645,&l_645,&l_645,&l_645,&l_645,&l_645,&l_645,&l_645};\n            int i;\n            p_56 = &g_43[1][0][0];\n        }\n        return l_363;\n    }\n    for (g_69.f3 = 6; (g_69.f3 <= (-1)); --g_69.f3)\n    { /* block id: 339 */\n        const int32_t *l_653 = &l_322[0][0];\n        const int32_t **l_654 = &l_653;\n        (*l_654) = ((*l_427) , l_653);\n    }\n    return g_153;\n}", "item_id": 6, "repo": "caokun8008/ckeos", "file": "externals/binaryen/test/emscripten/tests/fuzz/16.c", "last_update_at": "2020-10-20T03:03:06+00:00", "question_id": "187a6c648eb470a31fb911bfa98305b4a5a78dd7_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct S0  func_52(struct S0  p_53, struct S1 * p_54, struct S1 * p_55, struct S1 * p_56, struct S1  p_57)\n{ /* block id: 101 */\n    uint8_t l_227 = 3UL;\n    int32_t *l_228 = &g_214;\n    const struct S3 l_229 = {-12834,3,624,-6,8,31570,34,35,4,446};\n    struct S1 l_234 = {0x7CBEL,65531UL};\n    int8_t *l_255 = &g_253;\n    int32_t l_280 = 0xE149A9F4L;\n    int32_t l_281 = 3L;\n    int32_t l_318 = (-2L);\n    int32_t l_320 = 0xFA7069FDL;\n    int32_t l_322[1][1];\n    int32_t l_383[6] = {1L,1L,1L,1L,1L,1L};\n    struct S5 *l_427 = &g_69;\n    int16_t **l_492 = (void*)0;\n    uint16_t l_548 = 1UL;\n    int8_t l_581 = 0x33L;\n    int16_t ***l_597 = &l_492;\n    uint32_t l_646 = 0UL;\n    int i, j;\n    for (i = 0; i < 1; i++)\n    {\n        for (j = 0; j < 1; j++)\n            l_322[i][j] = 0L;\n    }\n    if ((((*l_228) = l_227) <= ((l_229 , (&p_57 != (void*)0)) == p_53.f2)))\n    { /* block id: 103 */\n        for (g_94 = 8; (g_94 > 31); g_94 = safe_add_func_uint16_t_u_u(g_94, 2))\n        { /* block id: 106 */\n            if (p_57.f1)\n                break;\n        }\n    }\n    else\n    { /* block id: 109 */\n        int16_t *l_247 = &g_109;\n        int16_t * const l_249 = (void*)0;\n        int32_t l_250 = (-1L);\n        int32_t l_272 = 0L;\n        int32_t l_275 = 0L;\n        int32_t l_329 = 0x121242E4L;\n        struct S0 l_363 = {175,9,31,37};\n        int32_t l_374 = 0x9A027F3BL;\n        uint32_t l_391 = 0xCD74C835L;\n        uint32_t ***l_400 = &g_345;\n        uint32_t *l_409 = (void*)0;\n        int32_t *l_410 = &l_280;\n        const uint16_t l_411 = 0x43A9L;\n        int32_t *l_412 = &l_250;\n        struct S5 l_415[5][8] = {{{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L}},{{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L}},{{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L}},{{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L}},{{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L}}};\n        uint32_t l_544 = 4294967293UL;\n        uint32_t l_582 = 0xA0A9C2C1L;\n        int32_t l_621[4] = {0xC353EE67L,0xC353EE67L,0xC353EE67L,0xC353EE67L};\n        int16_t ***l_630 = &l_492;\n        struct S3 l_639 = {-32711,-2,123,13,10,14313,101,-44,-66,6352};\n        struct S1 *l_645 = &l_234;\n        int i, j;\n        for (l_227 = (-14); (l_227 <= 46); l_227++)\n        { /* block id: 112 */\n            struct S0 *l_236 = &g_153;\n            struct S0 **l_235 = &l_236;\n            struct S0 **l_237 = (void*)0;\n            struct S0 *l_239[4][5] = {{&g_153,(void*)0,&g_153,&g_153,&g_153},{(void*)0,&g_153,(void*)0,&g_153,&g_153},{&g_153,(void*)0,&g_153,&g_153,&g_153},{(void*)0,&g_153,(void*)0,&g_153,&g_153}};\n            struct S0 **l_238 = &l_239[2][1];\n            int32_t l_244 = 3L;\n            int16_t **l_248 = &l_247;\n            int32_t l_305 = 0xFBD691C8L;\n            int32_t l_323 = (-5L);\n            int32_t l_326[3][3][10] = {{{0x1F4B9C93L,8L,8L,0x1F4B9C93L,0x349389C5L,5L,0x73619E2BL,(-1L),(-1L),1L},{0xFDE84D4DL,(-1L),(-1L),0x73619E2BL,8L,0x7A2AB3D7L,8L,0x73619E2BL,(-1L),(-1L)},{(-1L),1L,(-1L),0x1F4B9C93L,0x71D502BBL,0xDEF5D37AL,5L,(-1L),0x349389C5L,0x349389C5L}},{{1L,1L,0xDEF5D37AL,0x7A2AB3D7L,0x7A2AB3D7L,0xDEF5D37AL,1L,1L,0x1F4B9C93L,5L},{(-1L),(-1L),0x73619E2BL,1L,0L,0x7A2AB3D7L,(-1L),5L,(-1L),0x7A2AB3D7L},{0xFDE84D4DL,0L,0x73619E2BL,0L,0xFDE84D4DL,5L,0x1F4B9C93L,1L,1L,0xDEF5D37AL}},{{0x1F4B9C93L,0x71D502BBL,0xDEF5D37AL,5L,(-1L),0x349389C5L,0x349389C5L,(-1L),5L,0xDEF5D37AL},{5L,5L,(-1L),0xDEF5D37AL,0xFDE84D4DL,(-1L),(-1L),0x73619E2BL,8L,0x7A2AB3D7L},{0x73619E2BL,(-1L),(-1L),1L,0L,1L,(-1L),(-1L),0x73619E2BL,5L}}};\n            int32_t *l_373 = &l_329;\n            int32_t *l_378 = &l_323;\n            int32_t *l_379 = &l_275;\n            int32_t *l_380 = &l_280;\n            int32_t *l_381[8] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};\n            int32_t l_382 = 0x5FE0C3B8L;\n            uint16_t l_384 = 1UL;\n            uint8_t l_388[10][1][2] = {{{0x82L,0xB0L}},{{0xB0L,0x5FL}},{{0xB0L,0x5FL}},{{0xB0L,0xB0L}},{{0x82L,0x82L}},{{0x82L,0xB0L}},{{0xB0L,0x5FL}},{{0xB0L,0x5FL}},{{0xB0L,0xB0L}},{{0x82L,0x82L}}};\n            int i, j, k;\n            if ((((p_53.f0 == (func_17(l_234, (((*l_238) = ((*l_235) = &p_53)) != &p_53)) , g_113.f8)) < (safe_rshift_func_uint16_t_u_s((((((safe_add_func_uint8_t_u_u(l_244, ((safe_mul_func_int8_t_s_s((250UL != (+((((*l_248) = l_247) != l_249) ^ p_53.f2))), (*l_228))) || p_53.f2))) , (*l_228)) , 0xC7L) || l_250) | p_53.f3), g_113.f3))) == l_250))\n            { /* block id: 116 */\n                int32_t l_251 = 0xAE49ED9AL;\n                int8_t *l_254 = &g_253;\n                for (g_69.f0 = 0; (g_69.f0 <= 8); g_69.f0 += 1)\n                { /* block id: 119 */\n                    uint16_t *l_262 = (void*)0;\n                    uint16_t *l_263 = &l_234.f0;\n                    int16_t *l_273[5];\n                    int i;\n                    for (i = 0; i < 5; i++)\n                        l_273[i] = &g_274;\n                    if (l_251)\n                        break;\n                    (*l_228) |= ((0x2AL | (g_252 == (l_255 = l_254))) , (p_53 , (safe_add_func_uint16_t_u_u((safe_div_func_int16_t_s_s((l_275 ^= (p_53 , ((safe_div_func_int32_t_s_s((((*l_263) = 0x18A4L) | ((((g_109 = (l_272 &= (safe_mul_func_uint16_t_u_u(((safe_sub_func_uint8_t_u_u(((-1L) || (!((safe_mul_func_uint8_t_u_u((safe_mod_func_int16_t_s_s((-7L), (5UL && 251UL))), l_250)) ^ l_244))), 7UL)) || l_251), 0L)))) != 0UL) , (void*)0) != &l_229)), p_57.f1)) > (*g_252)))), p_57.f1)), 0x5575L))));\n                    if (l_251)\n                        break;\n                    p_53.f0 = ((safe_rshift_func_int8_t_s_s((*g_252), p_53.f2)) , (0UL || (*l_228)));\n                }\n            }\n            else\n            { /* block id: 130 */\n                int32_t *l_278 = &l_250;\n                int32_t *l_279[8][4] = {{&l_244,(void*)0,(void*)0,(void*)0},{(void*)0,&l_272,&l_275,&l_244},{(void*)0,&l_250,&l_250,(void*)0},{(void*)0,(void*)0,&l_275,&g_214},{(void*)0,(void*)0,(void*)0,&l_244},{&l_244,&l_250,&l_244,&l_244},{(void*)0,(void*)0,(void*)0,&g_214},{&l_275,(void*)0,(void*)0,(void*)0}};\n                uint8_t l_282 = 253UL;\n                uint16_t *l_289[6] = {&g_43[6][6][2].f0,&g_43[6][6][2].f0,&g_43[6][6][2].f0,&g_43[6][6][2].f0,&g_43[6][6][2].f0,&g_43[6][6][2].f0};\n                struct S0 *l_300[7] = {&g_153,&g_153,&g_153,&g_153,&g_153,&g_153,&g_153};\n                uint8_t *l_303 = &g_94;\n                uint32_t l_304 = 0x5DECD937L;\n                int32_t l_328 = 0L;\n                uint32_t **l_333 = (void*)0;\n                struct S5 l_358 = {65526UL,65535UL,{-17020,-3,129,6,9,5641,116,6,16,3716},0x87A08BDBL};\n                int i, j;\n                ++l_282;\n                if ((((((safe_mul_func_int16_t_s_s((l_244 = (safe_add_func_int8_t_s_s(((((--g_69.f0) || l_244) & (g_43[6][6][2].f1 = p_53.f2)) ^ ((**l_248) |= (g_274 = p_57.f1))), (*g_252)))), (safe_div_func_int8_t_s_s((safe_rshift_func_uint8_t_u_u(g_182.f9, 0)), ((*l_303) = ((p_53.f1 && ((safe_lshift_func_uint8_t_u_s((safe_sub_func_uint32_t_u_u((l_300[0] == (*l_235)), ((*l_228) = ((safe_sub_func_int8_t_s_s(0x3CL, 1L)) | p_57.f1)))), 5)) <= l_250)) | g_113.f0)))))) | g_69.f3) || p_53.f0) , l_304) != l_305))\n                { /* block id: 139 */\n                    struct S4 *l_308 = &g_138;\n                    int32_t l_315 = 1L;\n                    int32_t l_316 = 0xC4D5F313L;\n                    int32_t l_317 = 0x579CAB94L;\n                    int32_t l_325 = 0L;\n                    int32_t l_327[4][3][8] = {{{0x030C2675L,3L,0xE8FD32BEL,0xFF4CD6DDL,(-1L),1L,1L,1L},{3L,(-10L),0x51BD3FEEL,1L,(-10L),0x8A8F9135L,0x3ADFECCFL,0xDE5CFD58L},{0x51BD3FEEL,(-1L),0x57BA0327L,1L,0xFDD9E36FL,3L,0x3D1CCB86L,1L}},{{0x3D1CCB86L,0x3ADFECCFL,0x57BA0327L,0xFF4CD6DDL,0xFF4CD6DDL,0x57BA0327L,0x3ADFECCFL,0x3D1CCB86L},{0xFDD9E36FL,0x5D09D952L,0x51BD3FEEL,0xDE5CFD58L,(-1L),(-1L),0xE8FD32BEL,0x57BA0327L},{0L,1L,(-1L),0x8A8F9135L,0xDE5CFD58L,(-1L),0xDE5CFD58L,0x8A8F9135L}},{{0x3ADFECCFL,0x5D09D952L,0x3ADFECCFL,0x51BD3FEEL,(-1L),0x57BA0327L,1L,0xFDD9E36FL},{0x8A8F9135L,0x3ADFECCFL,0xDE5CFD58L,0xE8FD32BEL,0L,3L,(-1L),(-1L)},{0x8A8F9135L,(-1L),0x3D1CCB86L,0x3D1CCB86L,(-1L),0x8A8F9135L,0x5D09D952L,(-10L)}},{{0x3ADFECCFL,1L,3L,0x5D09D952L,0xDE5CFD58L,0x030C2675L,0xFDD9E36FL,0xFF4CD6DDL},{0L,(-10L),0x030C2675L,0x5D09D952L,(-1L),0x5D09D952L,0x030C2675L,(-10L)},{0xFDD9E36FL,(-1L),0xE8FD32BEL,0x3D1CCB86L,0xFF4CD6DDL,0x51BD3FEEL,0L,(-1L)}}};\n                    int i, j, k;\n                    for (p_57.f0 = (-21); (p_57.f0 < 48); ++p_57.f0)\n                    { /* block id: 142 */\n                        struct S4 **l_309 = &l_308;\n                        (*l_309) = l_308;\n                        return g_153;\n                    }\n                    if (l_305)\n                        break;\n                    for (l_305 = (-25); (l_305 < 11); l_305 = safe_add_func_int16_t_s_s(l_305, 1))\n                    { /* block id: 149 */\n                        int8_t l_312 = 0xE5L;\n                        int32_t l_313 = 1L;\n                        int32_t l_314 = 0xB566A646L;\n                        int32_t l_319 = 1L;\n                        int32_t l_321 = 3L;\n                        int32_t l_324[4];\n                        uint16_t l_330 = 0xFA7FL;\n                        int i;\n                        for (i = 0; i < 4; i++)\n                            l_324[i] = 0x82E92E31L;\n                        l_330--;\n                    }\n                    for (l_244 = 0; (l_244 <= 3); l_244 += 1)\n                    { /* block id: 154 */\n                        uint32_t ***l_334 = &l_333;\n                        int32_t l_347 = 0xF0677D09L;\n                        struct S2 **l_350 = &g_348;\n                        int i, j;\n                        (*l_334) = l_333;\n                        p_53.f0 = (247UL & (safe_lshift_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u((safe_lshift_func_int16_t_s_s((safe_add_func_uint16_t_u_u((p_57.f1 = ((&l_239[l_244][(l_244 + 1)] == &l_239[l_244][l_244]) < (~(((((*l_228) && p_57.f0) ^ (safe_lshift_func_int16_t_s_s((+(*l_278)), (((((((((((l_315 > ((g_345 == (void*)0) , g_113.f6)) < g_69.f2.f3) >= p_53.f0) , l_326[1][0][2]) || 1UL) != (*g_252)) && (*g_252)) >= p_57.f0) >= 65532UL) , 0x41F066B9L) || p_57.f1)))) ^ l_347) < l_305)))), p_53.f2)), p_53.f3)), g_138.f0.f2)), 15)));\n                        (*l_350) = g_348;\n                    }\n                }\n                else\n                { /* block id: 160 */\n                    struct S3 **l_351 = &g_112;\n                    struct S3 *l_354 = &g_138.f0;\n                    struct S3 **l_353[1];\n                    int i;\n                    for (i = 0; i < 1; i++)\n                        l_353[i] = &l_354;\n                    g_356 = (g_355 = (g_352 = ((*l_351) = (void*)0)));\n                    if (l_329)\n                        continue;\n                }\n                (*l_228) = (l_358 , ((*l_278) = p_53.f0));\n                (*l_228) ^= (g_69.f1 <= (p_57.f1 || (*g_252)));\n            }\n            for (l_318 = 0; (l_318 <= (-8)); --l_318)\n            { /* block id: 173 */\n                uint16_t l_367[3];\n                int32_t *l_372 = &g_214;\n                int i;\n                for (i = 0; i < 3; i++)\n                    l_367[i] = 65527UL;\n                for (l_234.f1 = (-8); (l_234.f1 >= 26); ++l_234.f1)\n                { /* block id: 176 */\n                    (*l_228) = (l_275 > (*g_252));\n                    return l_363;\n                }\n                l_244 = (*l_228);\n                for (l_234.f1 = 3; (l_234.f1 <= 8); l_234.f1 += 1)\n                { /* block id: 183 */\n                    uint16_t l_375 = 0x71EFL;\n                    for (l_244 = 0; (l_244 <= 8); l_244 += 1)\n                    { /* block id: 186 */\n                        return g_153;\n                    }\n                    for (g_84 = 8; (g_84 >= 0); g_84 -= 1)\n                    { /* block id: 191 */\n                        int32_t *l_364 = &l_329;\n                        int32_t *l_365 = (void*)0;\n                        int32_t *l_366[1];\n                        int32_t **l_370 = &l_366[0];\n                        int32_t **l_371 = (void*)0;\n                        int i;\n                        for (i = 0; i < 1; i++)\n                            l_366[i] = (void*)0;\n                        l_367[1]++;\n                        g_151[4] = (l_373 = (l_372 = ((*l_370) = &g_214)));\n                        --l_375;\n                    }\n                }\n            }\n            l_384++;\n            for (g_94 = 2; (g_94 <= 7); g_94 += 1)\n            { /* block id: 204 */\n                int16_t l_387[1][8];\n                int i, j;\n                for (i = 0; i < 1; i++)\n                {\n                    for (j = 0; j < 8; j++)\n                        l_387[i][j] = 1L;\n                }\n                l_388[6][0][1]--;\n                (*l_380) = l_387[0][0];\n            }\n        }\n        if (((*l_412) = ((((p_53.f3 = ((*l_228) = (p_53.f1 = l_391))) || ((*l_410) ^= (safe_rshift_func_int16_t_s_u((((p_53.f3 <= (((safe_sub_func_uint8_t_u_u((safe_mul_func_int16_t_s_s((-2L), (safe_lshift_func_uint16_t_u_u((l_374 != 65530UL), 13)))), ((*l_255) = ((((*l_400) = &g_346[3][1][3]) != (g_401 = &g_346[0][2][2])) <= (l_272 ^= (safe_sub_func_uint8_t_u_u((((safe_sub_func_uint32_t_u_u((((safe_unary_minus_func_uint16_t_u(((safe_lshift_func_int16_t_s_u(((((*l_228) && ((*g_252) | 2UL)) , p_53.f1) != g_69.f0), 9)) > (-5L)))) >= p_53.f0) > (*l_228)), (*l_228))) >= (*l_228)) , (*l_228)), 1UL))))))) | 65528UL) | p_57.f1)) <= 1L) < g_182.f0), l_275)))) > l_411) , p_53.f3)))\n        { /* block id: 218 */\n            uint8_t l_443[8] = {0x1DL,0x1DL,0x1DL,0x1DL,0x1DL,0x1DL,0x1DL,0x1DL};\n            uint32_t *l_451 = &g_131;\n            int32_t l_504[3][5] = {{(-1L),(-1L),1L,1L,(-1L)},{(-1L),(-1L),1L,1L,(-1L)},{(-1L),(-1L),1L,1L,(-1L)}};\n            struct S4 *l_574 = &g_518[1];\n            int16_t ***l_595 = &l_492;\n            int16_t l_620 = (-6L);\n            uint8_t l_622 = 0x8BL;\n            uint32_t *l_636 = &g_494[2];\n            uint16_t l_644 = 0x655EL;\n            int i, j;\n            if ((((safe_mul_func_uint8_t_u_u(p_53.f2, ((l_415[1][6] , ((*l_228) = (((safe_mod_func_uint8_t_u_u((safe_unary_minus_func_int8_t_s(p_53.f2)), 0xEFL)) >= ((safe_sub_func_uint8_t_u_u((safe_div_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s((safe_add_func_uint32_t_u_u((7UL < (((*g_75) = l_427) == (void*)0)), ((safe_div_func_uint8_t_u_u(((safe_div_func_uint32_t_u_u((((safe_lshift_func_uint8_t_u_u((safe_mod_func_int32_t_s_s(p_53.f2, (g_113.f5 && 255UL))), g_94)) >= 0x48L) , 0x0A836DACL), p_53.f1)) | g_349.f0), (*l_228))) , 4L))), g_111.f4)), p_53.f1)), (*g_252))) || p_53.f1)) , 0xA8E3F1E3L))) ^ 0x4A00F90DL))) ^ 0x7BL) < 0x4F381AB7L))\n            { /* block id: 221 */\n                struct S1 l_450 = {0x958CL,0UL};\n                int8_t l_468[8][4][2] = {{{0x38L,1L},{0x38L,0x38L},{1L,0x38L},{0x38L,1L}},{{0x38L,0x38L},{1L,0x38L},{0x38L,1L},{0x38L,0x38L}},{{1L,0x38L},{0x38L,1L},{0x38L,0x38L},{1L,0x38L}},{{0x38L,1L},{0x38L,0x38L},{1L,0x38L},{0x38L,1L}},{{0x38L,0x38L},{1L,0x38L},{0x38L,1L},{0x38L,0x38L}},{{1L,0x38L},{0x38L,1L},{0x38L,0x38L},{1L,0x38L}},{{0x38L,1L},{0x38L,0x38L},{1L,0x38L},{0x38L,1L}},{{0x38L,0x38L},{1L,0x38L},{0x38L,1L},{0x38L,0x38L}}};\n                int32_t l_476 = (-1L);\n                int16_t ***l_493 = &l_492;\n                int32_t l_503 = (-3L);\n                struct S4 *l_520 = &g_521[4][0][0];\n                const struct S3 l_529 = {2366,0,1008,2,10,12108,126,-23,-15,1054};\n                int32_t *l_575 = &l_476;\n                int32_t *l_576 = &l_503;\n                int32_t *l_577 = &l_374;\n                int32_t *l_578 = &l_281;\n                int32_t *l_579 = &l_476;\n                int32_t *l_580[7];\n                int i, j, k;\n                for (i = 0; i < 7; i++)\n                    l_580[i] = &l_250;\n                if ((safe_unary_minus_func_int8_t_s((safe_div_func_int16_t_s_s((((safe_rshift_func_uint16_t_u_s((safe_div_func_int8_t_s_s(p_53.f3, l_443[6])), ((((*l_247) = ((*g_42) , (p_53.f3 && (*l_412)))) >= (safe_div_func_uint8_t_u_u(9UL, 1UL))) <= p_57.f0))) > (safe_sub_func_int32_t_s_s((safe_add_func_uint8_t_u_u((((l_451 = (func_17(l_450, l_450.f0) , (*g_345))) != (**l_400)) == (*l_410)), (*l_228))), (*l_228)))) < l_443[6]), g_357.f9)))))\n                { /* block id: 224 */\n                    int8_t l_457[7];\n                    int i;\n                    for (i = 0; i < 7; i++)\n                        l_457[i] = 0xE6L;\n                    for (g_349.f5 = 15; (g_349.f5 == (-25)); --g_349.f5)\n                    { /* block id: 227 */\n                        uint16_t l_460[9] = {0x13E5L,1UL,0x13E5L,0x13E5L,1UL,0x13E5L,0x13E5L,1UL,0x13E5L};\n                        uint16_t *l_463 = &l_450.f1;\n                        int i;\n                        (*l_412) |= ((p_53.f3 & ((*l_247) = 0xA57DL)) & (*l_228));\n                        if (p_53.f0)\n                            break;\n                        p_53.f0 = ((!((safe_unary_minus_func_uint32_t_u(((safe_mod_func_int32_t_s_s(((*l_410) = (-2L)), ((*l_228) &= p_53.f3))) ^ l_457[0]))) || (((g_153.f0 >= (+(safe_div_func_uint32_t_u_u(p_53.f2, (((l_460[8] , (safe_lshift_func_uint16_t_u_u(p_53.f2, 15))) ^ (((*l_463) = g_111.f6) , (((0x2BB8L < p_53.f2) ^ p_53.f0) > 4294967295UL))) , p_53.f0))))) && l_457[0]) <= 0x1EL))) == p_53.f3);\n                        (*g_42) = (*p_54);\n                    }\n                }\n                else\n                { /* block id: 237 */\n                    uint8_t l_477 = 0x96L;\n                    for (l_450.f0 = 0; (l_450.f0 != 42); l_450.f0 = safe_add_func_int16_t_s_s(l_450.f0, 2))\n                    { /* block id: 240 */\n                        int32_t l_466[6] = {0x1655F412L,0x1655F412L,0x1655F412L,0x1655F412L,0x1655F412L,0x1655F412L};\n                        int32_t *l_467 = (void*)0;\n                        int32_t *l_469 = (void*)0;\n                        int32_t *l_470 = &l_466[5];\n                        int32_t *l_471 = &l_322[0][0];\n                        int32_t *l_472 = &l_320;\n                        int32_t *l_473 = &l_272;\n                        int32_t *l_474 = &l_374;\n                        int32_t *l_475[8][1] = {{&l_320},{&l_281},{&l_281},{&l_322[0][0]},{&l_320},{&l_320},{&l_322[0][0]},{&l_320}};\n                        int i, j;\n                        l_477--;\n                        return g_153;\n                    }\n                }\n                if (((*l_228) |= (((g_494[2] = (!((safe_rshift_func_int16_t_s_s(((*l_247) = ((void*)0 == &g_23)), 6)) == (safe_add_func_int32_t_s_s(((safe_rshift_func_int16_t_s_u((((p_53.f1 = (*l_412)) > (*l_410)) && (safe_add_func_uint8_t_u_u(((safe_rshift_func_int8_t_s_u((safe_rshift_func_int16_t_s_u((g_274 = (&g_76 != (((*g_252) , (((*l_493) = l_492) != (void*)0)) , &g_76))), p_53.f1)), g_111.f7)) | l_450.f0), p_57.f0))), g_111.f5)) , 1L), p_53.f0))))) > l_468[7][3][0]) || 1L)))\n                { /* block id: 251 */\n                    struct S3 *l_497[9][10][2] = {{{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113}},{{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111}},{{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113}},{{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0}},{{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182}},{{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182}},{{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0}},{{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113}},{{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111}}};\n                    int32_t l_505 = 0x3BBE76C4L;\n                    uint8_t l_506 = 6UL;\n                    int i, j, k;\n                    (*l_410) |= ((*l_412) = p_53.f0);\n                    for (l_374 = (-26); (l_374 == 16); l_374 = safe_add_func_int16_t_s_s(l_374, 4))\n                    { /* block id: 256 */\n                        struct S3 **l_498 = &l_497[8][7][0];\n                        (*l_498) = l_497[8][9][0];\n                    }\n                    for (p_57.f0 = 0; (p_57.f0 != 45); p_57.f0 = safe_add_func_uint8_t_u_u(p_57.f0, 7))\n                    { /* block id: 261 */\n                        int32_t **l_501 = &l_412;\n                        int32_t *l_502[1];\n                        int i;\n                        for (i = 0; i < 1; i++)\n                            l_502[i] = &l_281;\n                        (*l_501) = &l_281;\n                        l_506++;\n                    }\n                }\n                else\n                { /* block id: 265 */\n                    struct S4 *l_516 = &g_138;\n                    struct S4 **l_515 = &l_516;\n                    struct S4 **l_519 = (void*)0;\n                    uint16_t *l_523 = (void*)0;\n                    uint16_t *l_524 = &l_450.f0;\n                    int32_t l_547 = 2L;\n                    struct S5 *l_566 = (void*)0;\n                    p_53.f0 = (((safe_div_func_int32_t_s_s((safe_mul_func_uint16_t_u_u(((*l_524) = (+(l_504[1][2] || (g_138 , (((*l_410) = (safe_add_func_int8_t_s_s((*g_252), ((l_520 = (g_517 = ((*l_515) = &g_138))) == ((*g_348) , &g_521[4][0][0]))))) >= (safe_unary_minus_func_int16_t_s((g_113.f9 < ((g_69.f2.f4 ^ (~p_57.f0)) <= p_53.f3))))))))), 0x3F82L)), 1L)) || 8L) != p_53.f1);\n                    for (g_85 = 0; (g_85 <= 2); g_85 += 1)\n                    { /* block id: 274 */\n                        uint32_t *l_532 = &g_494[3];\n                        int32_t l_535 = (-6L);\n                        uint16_t *l_545 = &g_43[6][6][2].f1;\n                        uint16_t l_546 = 65532UL;\n                        struct S2 **l_551 = &g_348;\n                        int32_t *l_567 = &l_503;\n                        (*l_412) = ((safe_lshift_func_uint8_t_u_s((safe_mod_func_uint32_t_u_u(((g_153 , ((l_529 , (((*l_545) = (safe_sub_func_int8_t_s_s(((((+(--(*l_532))) , ((*g_517) , (l_535 | ((g_182.f8 , (((((safe_add_func_uint8_t_u_u((safe_div_func_int32_t_s_s((safe_sub_func_int32_t_s_s(l_504[0][1], p_53.f3)), (safe_lshift_func_uint8_t_u_u((((*l_524) = p_57.f0) <= (*l_228)), 1)))), 0x9CL)) > 0x6DCC9F64L) || l_544) >= (*g_252)) > 4UL)) >= 4294967295UL)))) <= g_138.f0.f6) < 5UL), 0xB6L))) == l_546)) | 0xC305L)) , l_529.f8), l_547)), (*g_252))) || l_548);\n                        (*l_412) &= (safe_add_func_int32_t_s_s(p_53.f3, (0xFA528CD4L <= ((((*p_56) = (*g_42)) , &l_228) == (void*)0))));\n                        (*l_551) = &g_349;\n                        (*l_567) ^= ((*l_228) > (safe_lshift_func_uint16_t_u_s(((safe_add_func_int32_t_s_s(p_57.f1, (((((g_153 , ((((*l_410) &= p_53.f3) ^ 4294967295UL) > (safe_mul_func_int16_t_s_s(p_57.f1, 5UL)))) <= ((safe_mul_func_uint16_t_u_u((safe_mul_func_uint8_t_u_u((safe_add_func_int16_t_s_s((((((255UL != (~(4294967294UL == 0UL))) , (void*)0) == l_566) , g_69.f3) ^ l_504[2][3]), g_274)), 0x5DL)), g_111.f6)) == l_535)) & 8UL) && p_53.f2) | (*l_412)))) || p_53.f0), 3)));\n                    }\n                    (*l_412) = (((g_274 |= 0L) == g_349.f1) && (safe_lshift_func_int8_t_s_s(0L, (safe_rshift_func_int16_t_s_s((safe_add_func_uint16_t_u_u(((void*)0 != l_574), (l_234 , l_529.f8))), 12)))));\n                }\n                l_582++;\n            }\n            else\n            { /* block id: 289 */\n                uint32_t l_606[6];\n                int32_t l_609 = 0x40AE2A13L;\n                int32_t *l_610 = &l_504[1][3];\n                int32_t *l_611 = &l_318;\n                int32_t *l_612 = &g_84;\n                int32_t *l_613 = &l_609;\n                int32_t *l_614 = (void*)0;\n                int32_t *l_615 = &l_504[1][2];\n                int32_t l_616 = 0x99467C25L;\n                int32_t *l_617 = &l_322[0][0];\n                int32_t *l_618[5];\n                int16_t l_619 = 8L;\n                int i;\n                for (i = 0; i < 6; i++)\n                    l_606[i] = 0x997170ADL;\n                for (i = 0; i < 5; i++)\n                    l_618[i] = &l_616;\n                for (g_131 = (-27); (g_131 == 22); g_131++)\n                { /* block id: 292 */\n                    for (l_318 = 2; (l_318 >= 0); l_318 -= 1)\n                    { /* block id: 295 */\n                        (*l_410) = ((*l_228) = p_57.f1);\n                    }\n                }\n                for (p_57.f0 = 3; (p_57.f0 <= 8); p_57.f0 += 1)\n                { /* block id: 302 */\n                    int32_t *l_600 = (void*)0;\n                    int32_t *l_602 = &l_504[2][0];\n                    int32_t *l_603 = &l_320;\n                    int32_t *l_604 = &l_281;\n                    int32_t *l_605[9][2] = {{(void*)0,&l_329},{(void*)0,(void*)0},{&l_329,&l_329},{&l_329,&l_280},{&l_329,&l_329},{&l_280,&l_329},{&l_329,&l_280},{&l_329,&l_329},{&l_280,&l_329}};\n                    int i, j;\n                    for (l_250 = 0; (l_250 <= 8); l_250 += 1)\n                    { /* block id: 305 */\n                        struct S3 l_594[7] = {{-9867,4,834,0,10,12828,54,32,17,4899},{-9867,4,834,0,10,12828,54,32,17,4899},{-9867,4,834,0,10,12828,54,32,17,4899},{-9867,4,834,0,10,12828,54,32,17,4899},{-9867,4,834,0,10,12828,54,32,17,4899},{-9867,4,834,0,10,12828,54,32,17,4899},{-9867,4,834,0,10,12828,54,32,17,4899}};\n                        int16_t ****l_596[10] = {&l_595,&l_595,&l_595,&l_595,&l_595,&l_595,&l_595,&l_595,&l_595,&l_595};\n                        uint16_t *l_598 = &l_415[1][6].f0;\n                        int i;\n                        (*l_410) |= ((safe_add_func_int8_t_s_s((safe_mod_func_uint16_t_u_u((((safe_unary_minus_func_int8_t_s((((&g_356 == &g_112) & (safe_mod_func_uint8_t_u_u((249UL >= (l_594[6] , (p_53.f1 != ((*l_598) = ((l_597 = l_595) == (void*)0))))), (*g_252)))) <= ((void*)0 == l_451)))) != g_599) != p_57.f0), 2UL)), (-1L))) != (*l_228));\n                    }\n                    l_606[2]--;\n                }\n                l_622++;\n            }\n            for (l_582 = 0; (l_582 > 11); l_582 = safe_add_func_int16_t_s_s(l_582, 7))\n            { /* block id: 316 */\n                struct S3 **l_627 = &g_356;\n                (*l_627) = &g_113;\n            }\n            (*l_410) |= (safe_sub_func_uint32_t_u_u(p_53.f1, (l_630 != ((g_599 = (safe_add_func_int32_t_s_s((*l_228), (safe_div_func_int16_t_s_s((safe_unary_minus_func_uint32_t_u(((*l_636) |= 1UL))), (safe_add_func_int8_t_s_s((*g_252), (g_153 , 0x7DL)))))))) , l_595))));\n            g_151[2] = &l_374;\n        }\n        else\n        { /* block id: 323 */\n            if (l_646)\n            { /* block id: 324 */\n                return p_53;\n            }\n            else\n            { /* block id: 326 */\n                struct S0 l_647[3][6][8] = {{{{-136,13,28,56},{145,13,26,9},{25,0,13,51},{-81,8,14,33},{-140,15,5,35},{-129,10,27,47},{124,4,0,104},{121,11,4,41}},{{30,12,15,71},{-136,13,28,56},{-55,14,13,73},{-148,11,29,18},{25,0,13,51},{-61,5,20,10},{66,11,28,12},{174,14,3,98}},{{110,4,20,75},{-150,13,15,70},{-141,10,31,71},{47,14,31,82},{-116,6,24,66},{95,3,18,52},{-81,14,25,100},{29,12,13,108}},{{-61,5,20,10},{-114,12,30,14},{-23,5,25,53},{172,13,28,120},{29,2,12,91},{174,14,3,98},{174,14,3,98},{29,2,12,91}},{{-23,5,25,53},{56,4,31,53},{56,4,31,53},{-23,5,25,53},{59,9,19,14},{30,12,15,71},{-61,5,20,10},{-118,2,9,105}},{{124,4,0,104},{47,14,31,82},{154,4,1,112},{-129,10,27,47},{-150,13,15,70},{-140,15,5,35},{172,13,28,120},{74,8,2,48}}},{{{-0,14,5,119},{47,14,31,82},{145,13,26,9},{-150,12,27,48},{174,14,3,98},{30,12,15,71},{-134,5,10,54},{154,4,1,112}},{{-97,7,20,120},{56,4,31,53},{-81,14,25,100},{-19,5,8,89},{-134,10,28,16},{174,14,3,98},{-112,11,31,77},{-149,15,5,23}},{{-140,15,5,35},{-114,12,30,14},{-116,6,24,66},{101,10,31,13},{95,1,23,52},{95,3,18,52},{-129,10,27,47},{172,13,28,120}},{{59,6,30,38},{-150,13,15,70},{59,9,19,14},{124,4,0,104},{152,6,21,93},{-61,5,20,10},{-141,10,31,71},{56,4,31,53}},{{-148,11,29,18},{-136,13,28,56},{-39,7,30,57},{-150,13,15,70},{29,12,13,108},{-129,10,27,47},{-114,12,30,14},{-141,10,31,71}},{{42,8,21,80},{145,13,26,9},{-81,8,14,33},{130,13,14,91},{-81,8,14,33},{145,13,26,9},{42,8,21,80},{-86,15,8,7}}},{{{25,0,13,51},{128,3,7,9},{59,6,30,38},{95,1,23,52},{154,4,1,112},{74,8,2,48},{45,11,4,116},{-116,6,24,66}},{{59,9,19,14},{101,10,31,13},{-118,2,9,105},{-136,13,28,56},{154,4,1,112},{-112,11,31,77},{110,4,20,75},{130,13,14,91}},{{25,0,13,51},{9,13,20,103},{-134,10,28,16},{-116,6,24,66},{-81,8,14,33},{161,6,7,45},{83,12,31,120},{-134,5,10,54}},{{42,8,21,80},{110,4,20,75},{-129,10,27,47},{34,6,31,81},{29,12,13,108},{95,1,23,52},{-46,5,11,42},{145,13,26,9}},{{-148,11,29,18},{-39,7,30,57},{30,12,15,71},{29,2,12,91},{152,6,21,93},{101,10,31,13},{154,4,1,112},{-19,5,8,89}},{{59,6,30,38},{-118,2,9,105},{42,8,21,80},{66,11,28,12},{95,1,23,52},{-136,13,28,56},{-140,15,5,35},{161,6,7,45}}}};\n                int i, j, k;\n                return l_647[1][1][5];\n            }\n        }\n        for (l_329 = 0; (l_329 != (-25)); l_329--)\n        { /* block id: 332 */\n            struct S1 **l_650[10] = {&l_645,&l_645,&l_645,&l_645,&l_645,&l_645,&l_645,&l_645,&l_645,&l_645};\n            int i;\n            p_56 = &g_43[1][0][0];\n        }\n        return l_363;\n    }\n    for (g_69.f3 = 6; (g_69.f3 <= (-1)); --g_69.f3)\n    { /* block id: 339 */\n        const int32_t *l_653 = &l_322[0][0];\n        const int32_t **l_654 = &l_653;\n        (*l_654) = ((*l_427) , l_653);\n    }\n    return g_153;\n"]]}
{"hexsha": "7f5fff73d92c5d81135221c170cbf61a2bc05dba", "ext": "c", "lang": "C", "content": "bool transliteration_table_save(char *filename) {\n    if (trans_table == NULL || filename == NULL) {\n        return false;\n    }\n\n    FILE *f;\n\n    if ((f = fopen(filename, \"wb\")) != NULL) {\n        bool ret = transliteration_table_write(f);\n        fclose(f);\n        return ret;\n    } else {\n        return false;\n    }\n\n}", "item_id": 35, "repo": "Fillr/libpostal", "file": "src/transliterate.c", "last_update_at": "2020-02-26T09:49:30+00:00", "question_id": "7f5fff73d92c5d81135221c170cbf61a2bc05dba_35", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool transliteration_table_save(char *filename) {\n    if (trans_table == NULL || filename == NULL) {\n        return false;\n    }\n    FILE *f;\n    if ((f = fopen(filename, \"wb\")) != NULL) {\n        bool ret = transliteration_table_write(f);\n        fclose(f);\n        return ret;\n    } else {\n        return false;\n    }\n"]]}
{"hexsha": "82718bb33022a8c2ef28484e2f6d0dd2f522d593", "ext": "c", "lang": "C", "content": "bool ws_file_copy_step4(EV_P, void *cb_data, char *str_path) {\n\tSDEBUG(\"ws_file_copy_step4\");\n\tstruct sock_ev_client_request *client_request = cb_data;\n\tstruct sock_ev_client_file *client_file = (struct sock_ev_client_file *)(client_request->vod_request_data);\n\tbool bol_ret = true;\n\tchar *str_response = NULL;\n\tsize_t int_response_len = 0;\n\tSDEFINE_VAR_ALL(str_new_path, str_new_path_to, str_result_path);\n\tif (*(client_file->str_partial_path + strlen(client_file->str_partial_path) - 1) == '/') {\n\t\t*(client_file->str_partial_path + strlen(client_file->str_partial_path) - 1) = '\\0';\n\t}\n\tif (*(client_file->str_partial_path_to + strlen(client_file->str_partial_path_to) - 1) == '/') {\n\t\t*(client_file->str_partial_path_to + strlen(client_file->str_partial_path_to) - 1) = '\\0';\n\t}\n\tsize_t int_new_path_len = 0;\n\tsize_t int_new_path_to_len = 0;\n\tif (*str_path == '/') {\n\t\tSFINISH_SNCAT(\n\t\t\tstr_new_path, &int_new_path_len,\n\t\t\tclient_file->str_partial_path, strlen(client_file->str_partial_path),\n\t\t\tstr_path, strlen(str_path)\n\t\t);\n\t\tSFINISH_SNCAT(\n\t\t\tstr_new_path_to, &int_new_path_to_len,\n\t\t\tclient_file->str_partial_path_to, strlen(client_file->str_partial_path),\n\t\t\tstr_path, strlen(str_path)\n\t\t);\n\t} else {\n\t\tSFINISH_SNCAT(\n\t\t\tstr_new_path, &int_new_path_len,\n\t\t\tclient_file->str_partial_path, strlen(client_file->str_partial_path),\n\t\t\t\"/\", (size_t)1,\n\t\t\tstr_path, strlen(str_path)\n\t\t);\n\t\tSFINISH_SNCAT(\n\t\t\tstr_new_path_to, &int_new_path_to_len,\n\t\t\tclient_file->str_partial_path_to, strlen(client_file->str_partial_path),\n\t\t\t\"/\", (size_t)1,\n\t\t\tstr_path, strlen(str_path)\n\t\t);\n\t}\n\n\tstr_result_path = canonical(client_file->str_canonical_start, str_new_path, \"read_file\");\n\tif (str_result_path != NULL) {\n\t\tSFINISH_CHECK(\n\t\t\tcanonical_copy(client_file->str_canonical_start, str_new_path, client_file->str_canonical_start_to, str_new_path_to),\n\t\t\t\"canonical_copy failed\");\n\t\tSFREE(str_result_path);\n\t} else {\n\t\tstr_result_path = canonical(client_file->str_canonical_start_to, str_new_path_to, \"read_dir\");\n\t\tif (str_result_path == NULL) {\n\t\t\tstr_result_path = canonical(client_file->str_canonical_start_to, str_new_path_to, \"create_dir\");\n\t\t\tSFINISH_CHECK(str_result_path != NULL, \"canonical failed\");\n\t\t}\n\t}\nfinish:\n\tif (bol_error_state) {\n\t\tbol_error_state = false;\n\t\tclient_request->int_response_id = (ssize_t)DArray_end(client_request->arr_response) + 1;\n\t\tchar str_temp[101] = {0};\n\t\tsnprintf(str_temp, 100, \"%zd\", client_request->int_response_id);\n\t\tif (errno != 0) {\n\t\t\tSFREE(str_response);\n\t\t\tSFINISH_SNCAT(\n\t\t\t\tstr_response, &int_response_len,\n\t\t\t\t\"messageid = \", (size_t)12,\n\t\t\t\tclient_request->str_message_id, strlen(client_request->str_message_id),\n\t\t\t\t\"\\012responsenumber = \", (size_t)18,\n\t\t\t\tstr_temp, strlen(str_temp),\n\t\t\t\t\"\\012FATAL\\012\", (size_t)7,\n\t\t\t\t\"Failed to delete file \", (size_t)18,\n\t\t\t\tclient_file->str_path, strlen(client_file->str_path),\n\t\t\t\t\": \", (size_t)2,\n\t\t\t\tstrerror(errno), strlen(strerror(errno))\n\t\t\t);\n\t\t} else {\n\t\t\tchar *_str_response = str_response;\n\t\t\tSFINISH_SNCAT(\n\t\t\t\tstr_response, &int_response_len,\n\t\t\t\t\"messageid = \", (size_t)12,\n\t\t\t\tclient_request->str_message_id, strlen(client_request->str_message_id),\n\t\t\t\t\"\\012responsenumber = \", (size_t)18,\n\t\t\t\tstr_temp, strlen(str_temp),\n\t\t\t\t\"\\012\", (size_t)1,\n\t\t\t\t_str_response, strlen(_str_response)\n\t\t\t);\n\t\t\tSFREE(_str_response);\n\t\t}\n\n\t\tWS_sendFrame(EV_A, client_request->parent, true, 0x01, str_response, int_response_len);\n\t\tDArray_push(client_request->arr_response, str_response);\n\n\t\t// This is handled in step5\n\t\t// ws_file_free(client_file);\n\n\t\t// client_request_free(client_request);\n\t\t// client_request_free takes care of this\n\t\t// SFREE(client_file);\n\t\tbol_ret = false;\n\t}\n\tSFREE_ALL();\n\treturn bol_ret;\n}", "item_id": 11, "repo": "crosstocci/postage", "file": "envelope/ws_file.c", "last_update_at": "2020-05-27T01:33:46+00:00", "question_id": "82718bb33022a8c2ef28484e2f6d0dd2f522d593_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool ws_file_copy_step4(EV_P, void *cb_data, char *str_path) {\n\tSDEBUG(\"ws_file_copy_step4\");\n\tstruct sock_ev_client_request *client_request = cb_data;\n\tstruct sock_ev_client_file *client_file = (struct sock_ev_client_file *)(client_request->vod_request_data);\n\tbool bol_ret = true;\n\tchar *str_response = NULL;\n\tsize_t int_response_len = 0;\n\tSDEFINE_VAR_ALL(str_new_path, str_new_path_to, str_result_path);\n\tif (*(client_file->str_partial_path + strlen(client_file->str_partial_path) - 1) == '/') {\n\t\t*(client_file->str_partial_path + strlen(client_file->str_partial_path) - 1) = '\\0';\n\t}\n\tif (*(client_file->str_partial_path_to + strlen(client_file->str_partial_path_to) - 1) == '/') {\n\t\t*(client_file->str_partial_path_to + strlen(client_file->str_partial_path_to) - 1) = '\\0';\n\t}\n\tsize_t int_new_path_len = 0;\n\tsize_t int_new_path_to_len = 0;\n\tif (*str_path == '/') {\n\t\tSFINISH_SNCAT(\n\t\t\tstr_new_path, &int_new_path_len,\n\t\t\tclient_file->str_partial_path, strlen(client_file->str_partial_path),\n\t\t\tstr_path, strlen(str_path)\n\t\t);\n\t\tSFINISH_SNCAT(\n\t\t\tstr_new_path_to, &int_new_path_to_len,\n\t\t\tclient_file->str_partial_path_to, strlen(client_file->str_partial_path),\n\t\t\tstr_path, strlen(str_path)\n\t\t);\n\t} else {\n\t\tSFINISH_SNCAT(\n\t\t\tstr_new_path, &int_new_path_len,\n\t\t\tclient_file->str_partial_path, strlen(client_file->str_partial_path),\n\t\t\t\"/\", (size_t)1,\n\t\t\tstr_path, strlen(str_path)\n\t\t);\n\t\tSFINISH_SNCAT(\n\t\t\tstr_new_path_to, &int_new_path_to_len,\n\t\t\tclient_file->str_partial_path_to, strlen(client_file->str_partial_path),\n\t\t\t\"/\", (size_t)1,\n\t\t\tstr_path, strlen(str_path)\n\t\t);\n\t}\n\tstr_result_path = canonical(client_file->str_canonical_start, str_new_path, \"read_file\");\n\tif (str_result_path != NULL) {\n\t\tSFINISH_CHECK(\n\t\t\tcanonical_copy(client_file->str_canonical_start, str_new_path, client_file->str_canonical_start_to, str_new_path_to),\n\t\t\t\"canonical_copy failed\");\n\t\tSFREE(str_result_path);\n\t} else {\n\t\tstr_result_path = canonical(client_file->str_canonical_start_to, str_new_path_to, \"read_dir\");\n\t\tif (str_result_path == NULL) {\n\t\t\tstr_result_path = canonical(client_file->str_canonical_start_to, str_new_path_to, \"create_dir\");\n\t\t\tSFINISH_CHECK(str_result_path != NULL, \"canonical failed\");\n\t\t}\n\t}\nfinish:\n\tif (bol_error_state) {\n\t\tbol_error_state = false;\n\t\tclient_request->int_response_id = (ssize_t)DArray_end(client_request->arr_response) + 1;\n\t\tchar str_temp[101] = {0};\n\t\tsnprintf(str_temp, 100, \"%zd\", client_request->int_response_id);\n\t\tif (errno != 0) {\n\t\t\tSFREE(str_response);\n\t\t\tSFINISH_SNCAT(\n\t\t\t\tstr_response, &int_response_len,\n\t\t\t\t\"messageid = \", (size_t)12,\n\t\t\t\tclient_request->str_message_id, strlen(client_request->str_message_id),\n\t\t\t\t\"\\012responsenumber = \", (size_t)18,\n\t\t\t\tstr_temp, strlen(str_temp),\n\t\t\t\t\"\\012FATAL\\012\", (size_t)7,\n\t\t\t\t\"Failed to delete file \", (size_t)18,\n\t\t\t\tclient_file->str_path, strlen(client_file->str_path),\n\t\t\t\t\": \", (size_t)2,\n\t\t\t\tstrerror(errno), strlen(strerror(errno))\n\t\t\t);\n\t\t} else {\n\t\t\tchar *_str_response = str_response;\n\t\t\tSFINISH_SNCAT(\n\t\t\t\tstr_response, &int_response_len,\n\t\t\t\t\"messageid = \", (size_t)12,\n\t\t\t\tclient_request->str_message_id, strlen(client_request->str_message_id),\n\t\t\t\t\"\\012responsenumber = \", (size_t)18,\n\t\t\t\tstr_temp, strlen(str_temp),\n\t\t\t\t\"\\012\", (size_t)1,\n\t\t\t\t_str_response, strlen(_str_response)\n\t\t\t);\n\t\t\tSFREE(_str_response);\n\t\t}\n\t\tWS_sendFrame(EV_A, client_request->parent, true, 0x01, str_response, int_response_len);\n\t\tDArray_push(client_request->arr_response, str_response);\n\t\t// This is handled in step5\n\t\t// ws_file_free(client_file);\n\t\t// client_request_free(client_request);\n\t\t// client_request_free takes care of this\n\t\t// SFREE(client_file);\n\t\tbol_ret = false;\n\t}\n\tSFREE_ALL();\n\treturn bol_ret;\n"]]}
{"hexsha": "b4954c0f4caee8423cf00319c933de9c5c1cee7b", "ext": "c", "lang": "C", "content": "void gl_transform_vb( GLcontext *ctx, GLboolean firstPartToDo, GLboolean allDone )\n{\n  struct vertex_buffer *VB = ctx->VB;\n#ifdef MITS\n  struct sched_param sparam1, sparam2, mparams;\n#endif\n\n#ifdef PROFILE\n  GLdouble t0 = gl_time();\n#endif\n\n  ASSERT( VB->Count>0 );\n\n#ifdef PROFILE\n  ctx->VertexTime += gl_time() - t0;\n  ctx->VertexCount += VB->Count - VB->Start;\n#endif\n  \n  if ((ctx->Texture.Enabled || ctx->RenderMode==GL_FEEDBACK) &&\n      ctx->NewTextureMatrix)\n    gl_analyze_texture_matrix(ctx);\n\n  if (ctx->Driver.RasterSetup && VB->Start) {\n      (*ctx->Driver.RasterSetup)( ctx, 0, VB->Start );\n  }\n\n#ifdef MITS\n\n  if (VB->Count > 72) {\n\n    if( firsttime ) {\n\n      int policy;\n     \n\n      if( !getuid() ) {\n\tpolicy = SCHED_FIFO;\n      }\n      else {\n\tpolicy = SCHED_OTHER;\n      }\n\n\n      mparams.sched_priority = sched_get_priority_max(policy) - 1;\n      sched_setscheduler(0, policy, &mparams);\n\n      sparam1.sched_priority = sched_get_priority_max(policy);\n      sparam2.sched_priority = sched_get_priority_max(policy);\n\n\n      sem_init( &tDone1, 0, 0);\n      sem_init( &tDone2, 0, 0);\t    \n\n\n      /* Set up threads with OTHER policy and maximum priority */\n      pthread_attr_init( &attr1 );\n      pthread_attr_setscope( &attr1, PTHREAD_SCOPE_SYSTEM);\n      pthread_attr_setschedpolicy( &attr1, policy );\n      pthread_attr_setdetachstate( &attr1, PTHREAD_CREATE_DETACHED);\n      pthread_attr_setschedparam( &attr1, &sparam1 );\n\n      pthread_attr_init( &attr2 );\n      pthread_attr_setscope( &attr2, PTHREAD_SCOPE_SYSTEM);\n      pthread_attr_setschedpolicy( &attr2, policy );\n      pthread_attr_setdetachstate( &attr2, PTHREAD_CREATE_DETACHED);\n      pthread_attr_setschedparam( &attr2, &sparam2 );\n\n      set1.thread_sem = &tDone1;\n      set2.thread_sem = &tDone2;\n\n      pthread_create( &thread1, &attr1, gl_transform_vb_range_scheduler, &set1);\n      pthread_create( &thread2, &attr2, gl_transform_vb_range_scheduler, &set2); \n      firsttime = 0;\n\n    } /* end if */\n\n\n    set1.ctx = ctx;\n    set1.start = VB->Start;\n    set1.count = VB->Start + (VB->Count-VB->Start)/2;\n    set1.firstPartToDo = firstPartToDo;\n\n\n    set2.ctx = ctx;\n    set2.start = VB->Start + (VB->Count - VB->Start)/2;\n    set2.count = VB->Count;\n    set2.firstPartToDo = firstPartToDo;\n    \n    set1.tsync = set2.tsync = 0;\n\n\n    /* Wake the vertex buffer processing threads */\n    sem_post( &tDone1 );\n    sem_post( &tDone2 );\n    sched_yield();\n\n\n    /* Spin until both are done */\n    while( !set1.tsync && !set2.tsync);\n\n\n  }\n  else {\n\n\n    gl_transform_vb_range( ctx, VB->Start, VB->Count,\n\t\t\t &VB->ClipOrMask, &VB->ClipAndMask,\n\t\t\t firstPartToDo );\n\n  } /* end if */\n\n#else\n\n    gl_transform_vb_range( ctx, VB->Start, VB->Count,\n\t\t\t &VB->ClipOrMask, &VB->ClipAndMask,\n\t\t\t firstPartToDo );\n\n#endif\n\n  if (VB->ClipAndMask) {\n    gl_reset_vb( ctx, allDone );\n    return;\n  }\n\n\n#ifdef PROFILE\n  ctx->VertexTime += gl_time() - t0;\n  ctx->VertexCount += VB->Count - VB->Start;\n#endif\n\n  /*\n   * Now we're ready to rasterize the Vertex Buffer!!!\n   *\n   * If the device driver can't rasterize the vertex buffer then we'll\n   * do it ourselves.\n   */\n  if (!ctx->Driver.RenderVB || !(*ctx->Driver.RenderVB)(ctx,allDone)) {\n    gl_render_vb( ctx, allDone );\n  }\n}", "item_id": 4, "repo": "GunterMueller/ST_STX_Fork", "file": "build/stx/support/MESA/Mesa-3.0/src/vbxform.c", "last_update_at": "2020-01-23T20:46:08+00:00", "question_id": "b4954c0f4caee8423cf00319c933de9c5c1cee7b_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void gl_transform_vb( GLcontext *ctx, GLboolean firstPartToDo, GLboolean allDone )\n{\n  struct vertex_buffer *VB = ctx->VB;\n#ifdef MITS\n  struct sched_param sparam1, sparam2, mparams;\n#endif\n#ifdef PROFILE\n  GLdouble t0 = gl_time();\n#endif\n  ASSERT( VB->Count>0 );\n#ifdef PROFILE\n  ctx->VertexTime += gl_time() - t0;\n  ctx->VertexCount += VB->Count - VB->Start;\n#endif\n  if ((ctx->Texture.Enabled || ctx->RenderMode==GL_FEEDBACK) &&\n      ctx->NewTextureMatrix)\n    gl_analyze_texture_matrix(ctx);\n  if (ctx->Driver.RasterSetup && VB->Start) {\n      (*ctx->Driver.RasterSetup)( ctx, 0, VB->Start );\n  }\n#ifdef MITS\n  if (VB->Count > 72) {\n    if( firsttime ) {\n      int policy;\n      if( !getuid() ) {\n\tpolicy = SCHED_FIFO;\n      }\n      else {\n\tpolicy = SCHED_OTHER;\n      }\n      mparams.sched_priority = sched_get_priority_max(policy) - 1;\n      sched_setscheduler(0, policy, &mparams);\n      sparam1.sched_priority = sched_get_priority_max(policy);\n      sparam2.sched_priority = sched_get_priority_max(policy);\n      sem_init( &tDone1, 0, 0);\n      sem_init( &tDone2, 0, 0);\t    \n      /* Set up threads with OTHER policy and maximum priority */\n      pthread_attr_init( &attr1 );\n      pthread_attr_setscope( &attr1, PTHREAD_SCOPE_SYSTEM);\n      pthread_attr_setschedpolicy( &attr1, policy );\n      pthread_attr_setdetachstate( &attr1, PTHREAD_CREATE_DETACHED);\n      pthread_attr_setschedparam( &attr1, &sparam1 );\n      pthread_attr_init( &attr2 );\n      pthread_attr_setscope( &attr2, PTHREAD_SCOPE_SYSTEM);\n      pthread_attr_setschedpolicy( &attr2, policy );\n      pthread_attr_setdetachstate( &attr2, PTHREAD_CREATE_DETACHED);\n      pthread_attr_setschedparam( &attr2, &sparam2 );\n      set1.thread_sem = &tDone1;\n      set2.thread_sem = &tDone2;\n      pthread_create( &thread1, &attr1, gl_transform_vb_range_scheduler, &set1);\n      pthread_create( &thread2, &attr2, gl_transform_vb_range_scheduler, &set2); \n      firsttime = 0;\n    } /* end if */\n    set1.ctx = ctx;\n    set1.start = VB->Start;\n    set1.count = VB->Start + (VB->Count-VB->Start)/2;\n    set1.firstPartToDo = firstPartToDo;\n    set2.ctx = ctx;\n    set2.start = VB->Start + (VB->Count - VB->Start)/2;\n    set2.count = VB->Count;\n    set2.firstPartToDo = firstPartToDo;\n    set1.tsync = set2.tsync = 0;\n    /* Wake the vertex buffer processing threads */\n    sem_post( &tDone1 );\n    sem_post( &tDone2 );\n    sched_yield();\n    /* Spin until both are done */\n    while( !set1.tsync && !set2.tsync);\n  }\n  else {\n    gl_transform_vb_range( ctx, VB->Start, VB->Count,\n\t\t\t &VB->ClipOrMask, &VB->ClipAndMask,\n\t\t\t firstPartToDo );\n  } /* end if */\n#else\n    gl_transform_vb_range( ctx, VB->Start, VB->Count,\n\t\t\t &VB->ClipOrMask, &VB->ClipAndMask,\n\t\t\t firstPartToDo );\n#endif\n  if (VB->ClipAndMask) {\n    gl_reset_vb( ctx, allDone );\n    return;\n  }\n#ifdef PROFILE\n  ctx->VertexTime += gl_time() - t0;\n  ctx->VertexCount += VB->Count - VB->Start;\n#endif\n  /*\n   * Now we're ready to rasterize the Vertex Buffer!!!\n   *\n   * If the device driver can't rasterize the vertex buffer then we'll\n   * do it ourselves.\n   */\n  if (!ctx->Driver.RenderVB || !(*ctx->Driver.RenderVB)(ctx,allDone)) {\n    gl_render_vb( ctx, allDone );\n  }\n"]]}
{"hexsha": "d6c816db65cc0685dfa02a5dddf42c1d2954ed7d", "ext": "c", "lang": "C", "content": "static int pt_blk_proceed_to_exec_mode(struct pt_block_decoder *decoder,\n\t\t\t\t       struct pt_block *block,\n\t\t\t\t       const struct pt_event *ev)\n{\n\tint status;\n\n\tif (!decoder || !ev)\n\t\treturn -pte_internal;\n\n\t/* Apply the event immediately if we don't have an IP. */\n\tif (ev->ip_suppressed)\n\t\treturn 1;\n\n\tstatus = pt_blk_proceed_to_ip_with_trace(decoder, block,\n\t\t\t\t\t\t ev->variant.exec_mode.ip);\n\tif (status < 0)\n\t\treturn status;\n\n\t/* We may have reached the IP. */\n\treturn (decoder->ip == ev->variant.exec_mode.ip ? 1 : 0);\n}", "item_id": 31, "repo": "hase-project/processor-trace", "file": "libipt/src/pt_block_decoder.c", "last_update_at": "2020-03-03T08:15:49+00:00", "question_id": "d6c816db65cc0685dfa02a5dddf42c1d2954ed7d_31", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int pt_blk_proceed_to_exec_mode(struct pt_block_decoder *decoder,\n\t\t\t\t       struct pt_block *block,\n\t\t\t\t       const struct pt_event *ev)\n{\n\tint status;\n\tif (!decoder || !ev)\n\t\treturn -pte_internal;\n\t/* Apply the event immediately if we don't have an IP. */\n\tif (ev->ip_suppressed)\n\t\treturn 1;\n\tstatus = pt_blk_proceed_to_ip_with_trace(decoder, block,\n\t\t\t\t\t\t ev->variant.exec_mode.ip);\n\tif (status < 0)\n\t\treturn status;\n\t/* We may have reached the IP. */\n\treturn (decoder->ip == ev->variant.exec_mode.ip ? 1 : 0);\n"]]}
{"hexsha": "da14ea94c309af0d426d4281d083461816ca329b", "ext": "c", "lang": "C", "content": "static int\nsmb_set_proto_prop(sa_property_t prop)\n{\n\tint ret = SA_OK;\n\tchar *name;\n\tchar *value;\n\tint index = -1;\n\tstruct smb_proto_option_defs *opt;\n\n\tname = sa_get_property_attr(prop, \"type\");\n\tvalue = sa_get_property_attr(prop, \"value\");\n\tif (name != NULL && value != NULL) {\n\t\tindex = findprotoopt(name);\n\t\tif (index >= 0) {\n\t\t\t/* should test for valid value */\n\t\t\tret = smb_validate_proto_prop(index, name, value);\n\t\t\tif (ret == SA_OK) {\n\t\t\t\topt = &smb_proto_options[index];\n\n\t\t\t\t/* Save to SMF */\n\t\t\t\tif (smb_config_set(opt->smb_index,\n\t\t\t\t    value) != 0) {\n\t\t\t\t\tret = SA_BAD_VALUE;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Specialized refresh mechanisms can\n\t\t\t\t * be flagged in the proto_options and\n\t\t\t\t * processed here.\n\t\t\t\t */\n\t\t\t\tif (opt->refresh & SMB_REFRESH_REFRESH)\n\t\t\t\t\t(void) smf_refresh_instance(\n\t\t\t\t\t    SMBD_DEFAULT_INSTANCE_FMRI);\n\t\t\t\telse if (opt->refresh & SMB_REFRESH_RESTART)\n\t\t\t\t\t(void) smf_restart_instance(\n\t\t\t\t\t    SMBD_DEFAULT_INSTANCE_FMRI);\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tif (name != NULL)\n\t\tsa_free_attr_string(name);\n\tif (value != NULL)\n\t\tsa_free_attr_string(value);\n\n\treturn (ret);\n}", "item_id": 35, "repo": "AsahiOS/gate", "file": "usr/src/lib/libshare/smb/libshare_smb.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "da14ea94c309af0d426d4281d083461816ca329b_35", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nsmb_set_proto_prop(sa_property_t prop)\n{\n\tint ret = SA_OK;\n\tchar *name;\n\tchar *value;\n\tint index = -1;\n\tstruct smb_proto_option_defs *opt;\n\tname = sa_get_property_attr(prop, \"type\");\n\tvalue = sa_get_property_attr(prop, \"value\");\n\tif (name != NULL && value != NULL) {\n\t\tindex = findprotoopt(name);\n\t\tif (index >= 0) {\n\t\t\t/* should test for valid value */\n\t\t\tret = smb_validate_proto_prop(index, name, value);\n\t\t\tif (ret == SA_OK) {\n\t\t\t\topt = &smb_proto_options[index];\n\t\t\t\t/* Save to SMF */\n\t\t\t\tif (smb_config_set(opt->smb_index,\n\t\t\t\t    value) != 0) {\n\t\t\t\t\tret = SA_BAD_VALUE;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Specialized refresh mechanisms can\n\t\t\t\t * be flagged in the proto_options and\n\t\t\t\t * processed here.\n\t\t\t\t */\n\t\t\t\tif (opt->refresh & SMB_REFRESH_REFRESH)\n\t\t\t\t\t(void) smf_refresh_instance(\n\t\t\t\t\t    SMBD_DEFAULT_INSTANCE_FMRI);\n\t\t\t\telse if (opt->refresh & SMB_REFRESH_RESTART)\n\t\t\t\t\t(void) smf_restart_instance(\n\t\t\t\t\t    SMBD_DEFAULT_INSTANCE_FMRI);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tif (name != NULL)\n\t\tsa_free_attr_string(name);\n\tif (value != NULL)\n\t\tsa_free_attr_string(value);\n\treturn (ret);\n"]]}
{"hexsha": "5a2c83295014c04d8d2147568fa86efe1cfa94bd", "ext": "c", "lang": "C", "content": "int\nibtl_cm_is_multi_sm(ib_guid_t hca_guid)\n{\n\tibtl_hca_devinfo_t\t*hdevp;\t/* HCA Dev Info */\n\tuint_t\t\t\tmulti_sm;\n\n\tmutex_enter(&ibtl_clnt_list_mutex);\n\thdevp = ibtl_get_hcadevinfo(hca_guid);\n\tif (hdevp == NULL) {\n\t\tIBTF_DPRINTF_L2(ibtf_cm, \"ibtl_cm_is_multi_sm: NO HCA (%llX) \"\n\t\t    \"availble\", hca_guid);\n\t\tmutex_exit(&ibtl_clnt_list_mutex);\n\t\treturn (-1);\n\t}\n\tmulti_sm = hdevp->hd_multism;\n\tmutex_exit(&ibtl_clnt_list_mutex);\n\n\tIBTF_DPRINTF_L3(ibtf_cm, \"ibtl_cm_is_multi_sm(%llX): %d\", hca_guid,\n\t    multi_sm);\n\n\treturn (multi_sm);\n}", "item_id": 10, "repo": "AsahiOS/gate", "file": "usr/src/uts/common/io/ib/ibtl/ibtl_cm.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "5a2c83295014c04d8d2147568fa86efe1cfa94bd_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nibtl_cm_is_multi_sm(ib_guid_t hca_guid)\n{\n\tibtl_hca_devinfo_t\t*hdevp;\t/* HCA Dev Info */\n\tuint_t\t\t\tmulti_sm;\n\tmutex_enter(&ibtl_clnt_list_mutex);\n\thdevp = ibtl_get_hcadevinfo(hca_guid);\n\tif (hdevp == NULL) {\n\t\tIBTF_DPRINTF_L2(ibtf_cm, \"ibtl_cm_is_multi_sm: NO HCA (%llX) \"\n\t\t    \"availble\", hca_guid);\n\t\tmutex_exit(&ibtl_clnt_list_mutex);\n\t\treturn (-1);\n\t}\n\tmulti_sm = hdevp->hd_multism;\n\tmutex_exit(&ibtl_clnt_list_mutex);\n\tIBTF_DPRINTF_L3(ibtf_cm, \"ibtl_cm_is_multi_sm(%llX): %d\", hca_guid,\n\t    multi_sm);\n\treturn (multi_sm);\n"]]}
{"hexsha": "f227261283585d094b7418f31229359ac17e44ef", "ext": "c", "lang": "C", "content": "void main()\n{\n int a[10],min,max,n;\n printf(\"enter size of array\\n\");\n scanf(\"%d\",&n);\n printf(\"enter array elements\\n\");\n for(int i=0;i<n;i++)\n {\n  scanf(\"%d\",&a[i]);\n }\n minmax(a,n,&min,&max);\n  printf(\"min=%d and max=%d\\n\", min,max);\n}", "item_id": 0, "repo": "ashiljohnson/HacktoberFest-2021", "file": "C/joelss2001-MinandMaxUsingPointers.c", "last_update_at": "2020-10-28T11:39:18+00:00", "question_id": "f227261283585d094b7418f31229359ac17e44ef_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void main()\n{\n int a[10],min,max,n;\n printf(\"enter size of array\\n\");\n scanf(\"%d\",&n);\n printf(\"enter array elements\\n\");\n for(int i=0;i<n;i++)\n {\n  scanf(\"%d\",&a[i]);\n }\n minmax(a,n,&min,&max);\n  printf(\"min=%d and max=%d\\n\", min,max);\n"]]}
{"hexsha": "baa9662e27034b19bb56d464d05b6f7db6418121", "ext": "c", "lang": "C", "content": "st_s* bcore_btree_vd_s_status( bcore_btree_vd_s* o )\n{\n    uz_t blocks = 0;\n    uz_t nodes = 0;\n    uz_t deleted_nodes = 0;\n    if( o->chain_beg )\n    {\n        bcore_btree_node_vd_s* chain_beg = o->chain_beg;\n        while( chain_beg )\n        {\n            chain_beg = *( bcore_btree_node_vd_s** )( chain_beg + o->block_size );\n            blocks++;\n        }\n        nodes = blocks * o->block_size - ( o->chain_end - o->chain_ins );\n    }\n    if( o->del_chain )\n    {\n        bcore_btree_node_vd_s* del_chain = o->del_chain;\n        while( del_chain )\n        {\n            del_chain = del_chain->parent;\n            deleted_nodes++;\n        }\n    }\n\n    st_s* string = st_s_create();\n    uz_t used_nodes = nodes - deleted_nodes;\n    st_s_pushf( string, \"keys ........... %lu\\n\", bcore_btree_node_vd_s_keys( o->root ) );\n    st_s_pushf( string, \"nodes .......... %lu\\n\", used_nodes );\n    st_s_pushf( string, \"keys/nodes ..... %5.4f\\n\", used_nodes > 0 ? ( double )( bcore_btree_node_vd_s_keys( o->root ) ) / used_nodes : 0 );\n    st_s_pushf( string, \"depth .......... %lu\\n\", bcore_btree_node_vd_s_depth( o->root ) );\n    st_s_pushf( string, \"block size ..... %lu\\n\", o->block_size );\n    st_s_pushf( string, \"blocks ......... %lu\\n\", blocks );\n    st_s_pushf( string, \"deleted nodes .. %lu\\n\", deleted_nodes );\n    return string;\n}", "item_id": 64, "repo": "johsteffens/beth", "file": "lib/bcore/bcore_btree.c", "last_update_at": "2020-08-05T16:41:50+00:00", "question_id": "baa9662e27034b19bb56d464d05b6f7db6418121_64", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["st_s* bcore_btree_vd_s_status( bcore_btree_vd_s* o )\n{\n    uz_t blocks = 0;\n    uz_t nodes = 0;\n    uz_t deleted_nodes = 0;\n    if( o->chain_beg )\n    {\n        bcore_btree_node_vd_s* chain_beg = o->chain_beg;\n        while( chain_beg )\n        {\n            chain_beg = *( bcore_btree_node_vd_s** )( chain_beg + o->block_size );\n            blocks++;\n        }\n        nodes = blocks * o->block_size - ( o->chain_end - o->chain_ins );\n    }\n    if( o->del_chain )\n    {\n        bcore_btree_node_vd_s* del_chain = o->del_chain;\n        while( del_chain )\n        {\n            del_chain = del_chain->parent;\n            deleted_nodes++;\n        }\n    }\n    st_s* string = st_s_create();\n    uz_t used_nodes = nodes - deleted_nodes;\n    st_s_pushf( string, \"keys ........... %lu\\n\", bcore_btree_node_vd_s_keys( o->root ) );\n    st_s_pushf( string, \"nodes .......... %lu\\n\", used_nodes );\n    st_s_pushf( string, \"keys/nodes ..... %5.4f\\n\", used_nodes > 0 ? ( double )( bcore_btree_node_vd_s_keys( o->root ) ) / used_nodes : 0 );\n    st_s_pushf( string, \"depth .......... %lu\\n\", bcore_btree_node_vd_s_depth( o->root ) );\n    st_s_pushf( string, \"block size ..... %lu\\n\", o->block_size );\n    st_s_pushf( string, \"blocks ......... %lu\\n\", blocks );\n    st_s_pushf( string, \"deleted nodes .. %lu\\n\", deleted_nodes );\n    return string;\n"]]}
{"hexsha": "ae6341b5ebef30e9514e7133f5cd0893c138aa51", "ext": "c", "lang": "C", "content": "void lcdPrintfResize(int x, int y, uint16_t color,  float ratio, const char *fmt, ...)\n{\n  va_list arg;\n  va_start (arg, fmt);\n  int32_t len;\n  char print_buffer[256];\n  int Size_Char;\n  int i;\n  int x_Pre = x;\n  int y_Pre = y;\n  PHAN_FONT_OBJ FontBuf;\n  uint8_t font_width;\n  resize_image_t r_src, r_dst;\n  uint16_t pixel;\n\n  r_src.x = 0;\n  r_src.y = 0;\n  r_src.w = 0;\n  r_src.h = 16;\n  r_src.stride = LCD_WIDTH;\n  r_src.p_data = lcd_buffer;\n\n\n  x = 0;\n  y = 0;\n\n  len = vsnprintf(print_buffer, 255, fmt, arg);\n  va_end (arg);\n\n  for( i=0; i<len; i+=Size_Char )\n  {\n    PHan_FontLoad( &print_buffer[i], &FontBuf );\n\n\n    disHanFontBuffer(x, y, &FontBuf, 0xFF);\n\n    Size_Char = FontBuf.Size_Char;\n    if (Size_Char >= 2)\n    {\n      font_width = 16;\n      x += 2*8;\n    }\n    else\n    {\n      font_width = 8;\n      x += 1*8;\n    }\n\n    r_src.w += font_width;\n\n    if ((x+font_width) > HW_LCD_WIDTH)\n    {\n      x  = x_Pre;\n      y += 16;\n      r_src.h += 16;\n    }\n\n    if( FontBuf.Code_Type == PHAN_END_CODE ) break;\n  }\n\n  r_dst.x = 0;\n  r_dst.y = r_src.y + r_src.h;\n  r_dst.w = r_src.w * ratio;\n  r_dst.h = r_src.h * ratio;\n  r_dst.stride = LCD_WIDTH;\n  r_dst.p_data = lcd_buffer;\n\n  if (lcd_resize_mode == LCD_RESIZE_BILINEAR)\n  {\n    resizeImageFastGray(&r_src, &r_dst);\n  }\n  else\n  {\n    resizeImageNearest(&r_src, &r_dst);\n  }\n\n  for (int i_y=0; i_y<r_dst.h; i_y++)\n  {\n    for (int i_x=0; i_x<r_dst.w; i_x++)\n    {\n      pixel = lcd_buffer[(i_y+r_dst.y)*LCD_WIDTH + i_x];\n      if (pixel > 0)\n      {\n        lcdDrawPixelMix(x_Pre+i_x, y_Pre+i_y, color, pixel);\n      }\n    }\n  }\n}", "item_id": 20, "repo": "chcbaram/game_n_watch", "file": "stm32h7b0_fw/src/hw/driver/lcd.c", "last_update_at": "2020-12-07T07:40:17+00:00", "question_id": "ae6341b5ebef30e9514e7133f5cd0893c138aa51_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void lcdPrintfResize(int x, int y, uint16_t color,  float ratio, const char *fmt, ...)\n{\n  va_list arg;\n  va_start (arg, fmt);\n  int32_t len;\n  char print_buffer[256];\n  int Size_Char;\n  int i;\n  int x_Pre = x;\n  int y_Pre = y;\n  PHAN_FONT_OBJ FontBuf;\n  uint8_t font_width;\n  resize_image_t r_src, r_dst;\n  uint16_t pixel;\n  r_src.x = 0;\n  r_src.y = 0;\n  r_src.w = 0;\n  r_src.h = 16;\n  r_src.stride = LCD_WIDTH;\n  r_src.p_data = lcd_buffer;\n  x = 0;\n  y = 0;\n  len = vsnprintf(print_buffer, 255, fmt, arg);\n  va_end (arg);\n  for( i=0; i<len; i+=Size_Char )\n  {\n    PHan_FontLoad( &print_buffer[i], &FontBuf );\n    disHanFontBuffer(x, y, &FontBuf, 0xFF);\n    Size_Char = FontBuf.Size_Char;\n    if (Size_Char >= 2)\n    {\n      font_width = 16;\n      x += 2*8;\n    }\n    else\n    {\n      font_width = 8;\n      x += 1*8;\n    }\n    r_src.w += font_width;\n    if ((x+font_width) > HW_LCD_WIDTH)\n    {\n      x  = x_Pre;\n      y += 16;\n      r_src.h += 16;\n    }\n    if( FontBuf.Code_Type == PHAN_END_CODE ) break;\n  }\n  r_dst.x = 0;\n  r_dst.y = r_src.y + r_src.h;\n  r_dst.w = r_src.w * ratio;\n  r_dst.h = r_src.h * ratio;\n  r_dst.stride = LCD_WIDTH;\n  r_dst.p_data = lcd_buffer;\n  if (lcd_resize_mode == LCD_RESIZE_BILINEAR)\n  {\n    resizeImageFastGray(&r_src, &r_dst);\n  }\n  else\n  {\n    resizeImageNearest(&r_src, &r_dst);\n  }\n  for (int i_y=0; i_y<r_dst.h; i_y++)\n  {\n    for (int i_x=0; i_x<r_dst.w; i_x++)\n    {\n      pixel = lcd_buffer[(i_y+r_dst.y)*LCD_WIDTH + i_x];\n      if (pixel > 0)\n      {\n        lcdDrawPixelMix(x_Pre+i_x, y_Pre+i_y, color, pixel);\n      }\n    }\n  }\n"]]}
{"hexsha": "3daeadd187616412f608eec0b547f1c4e188c7c0", "ext": "c", "lang": "C", "content": "void render_text_rgba(\n    Attrib *attrib, int justify, float x, float y, float n, char *text,\n    const float *background, const float *text_color)\n{\n    float matrix[16];\n    set_matrix_2d(matrix, g->width, g->height);\n    glUseProgram(attrib->program);\n    glUniformMatrix4fv(attrib->matrix, 1, GL_FALSE, matrix);\n    glUniform1i(attrib->sampler, 3);\n    glUniform1i(attrib->extra1, 0);\n    glUniform4fv(attrib->extra5, 1, background);\n    glUniform4fv(attrib->extra6, 1, text_color);\n    int length = strlen(text);\n    x -= n * justify * (length - 1) / 2;\n    GLuint buffer = gen_text_buffer(x, y, n, text);\n    draw_text(attrib, buffer, length);\n    del_buffer(buffer);\n}", "item_id": 89, "repo": "pspiworld/piworld", "file": "src/main.c", "last_update_at": "2020-07-26T10:28:39+00:00", "question_id": "3daeadd187616412f608eec0b547f1c4e188c7c0_89", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void render_text_rgba(\n    Attrib *attrib, int justify, float x, float y, float n, char *text,\n    const float *background, const float *text_color)\n{\n    float matrix[16];\n    set_matrix_2d(matrix, g->width, g->height);\n    glUseProgram(attrib->program);\n    glUniformMatrix4fv(attrib->matrix, 1, GL_FALSE, matrix);\n    glUniform1i(attrib->sampler, 3);\n    glUniform1i(attrib->extra1, 0);\n    glUniform4fv(attrib->extra5, 1, background);\n    glUniform4fv(attrib->extra6, 1, text_color);\n    int length = strlen(text);\n    x -= n * justify * (length - 1) / 2;\n    GLuint buffer = gen_text_buffer(x, y, n, text);\n    draw_text(attrib, buffer, length);\n    del_buffer(buffer);\n"]]}
{"hexsha": "1b83500774415b77d7992633b11af900c7be6997", "ext": "c", "lang": "C", "content": "static tap_packet_status\nframe_seq_analysis_packet( void *ptr, packet_info *pinfo, epan_dissect_t *edt _U_, const void *dummy _U_)\n{\n\tseq_analysis_info_t *sainfo = (seq_analysis_info_t *) ptr;\n\tseq_analysis_item_t *sai = sequence_analysis_create_sai_with_addresses(pinfo, sainfo);\n\n\tif (!sai)\n\t\treturn TAP_PACKET_DONT_REDRAW;\n\n\tsai->frame_number = pinfo->num;\n\n\tsequence_analysis_use_color_filter(pinfo, sai);\n\n\tsai->port_src=pinfo->srcport;\n\tsai->port_dst=pinfo->destport;\n\n\tsequence_analysis_use_col_info_as_label_comment(pinfo, sai);\n\n\tsai->line_style = 1;\n\tsai->conv_num = 0;\n\tsai->display = TRUE;\n\n\tg_queue_push_tail(sainfo->items, sai);\n\n\treturn TAP_PACKET_REDRAW;\n}", "item_id": 0, "repo": "joshis1/C_Programming", "file": "resources/Wireshark/WiresharkDissectorFoo/epan/dissectors/packet-frame.c", "last_update_at": "2020-12-31T11:42:02+00:00", "question_id": "1b83500774415b77d7992633b11af900c7be6997_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static tap_packet_status\nframe_seq_analysis_packet( void *ptr, packet_info *pinfo, epan_dissect_t *edt _U_, const void *dummy _U_)\n{\n\tseq_analysis_info_t *sainfo = (seq_analysis_info_t *) ptr;\n\tseq_analysis_item_t *sai = sequence_analysis_create_sai_with_addresses(pinfo, sainfo);\n\tif (!sai)\n\t\treturn TAP_PACKET_DONT_REDRAW;\n\tsai->frame_number = pinfo->num;\n\tsequence_analysis_use_color_filter(pinfo, sai);\n\tsai->port_src=pinfo->srcport;\n\tsai->port_dst=pinfo->destport;\n\tsequence_analysis_use_col_info_as_label_comment(pinfo, sai);\n\tsai->line_style = 1;\n\tsai->conv_num = 0;\n\tsai->display = TRUE;\n\tg_queue_push_tail(sainfo->items, sai);\n\treturn TAP_PACKET_REDRAW;\n"]]}
{"hexsha": "02bf33dffefbfc4a2c1fa36563c60265fed0803a", "ext": "c", "lang": "C", "content": "void i2c_write(I2C_MODULE i2c_id, uint8_t address, uint8_t *data, int len)\n{\n    uint8_t i2cBuffer[len + 1];\n    int i;\n\n    i2cBuffer[0] = address | 0x00;\n    memcpy(&i2cBuffer[1], data, len);\n\n    if (!StartTransfer(i2c_id, FALSE))\n    {\n        return;\n    }\n    for (i = 0; i < len + 1; i++)\n    {\n        if (!TransmitOneByte(i2c_id, i2cBuffer[i]))\n        {\n            break;\n        }\n    }\n\n    StopTransfer(i2c_id);\n}", "item_id": 4, "repo": "MicrochipTech/aws-iot-winc1500-secure-wifi-board-included-source-files", "file": "mcu-firmware/saml21g18b_sensor_board_demo/src/cryptoauthlib/lib/hal/hal_pic32mx695f512h_i2c.c", "last_update_at": "2020-08-26T19:28:13+00:00", "question_id": "02bf33dffefbfc4a2c1fa36563c60265fed0803a_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void i2c_write(I2C_MODULE i2c_id, uint8_t address, uint8_t *data, int len)\n{\n    uint8_t i2cBuffer[len + 1];\n    int i;\n    i2cBuffer[0] = address | 0x00;\n    memcpy(&i2cBuffer[1], data, len);\n    if (!StartTransfer(i2c_id, FALSE))\n    {\n        return;\n    }\n    for (i = 0; i < len + 1; i++)\n    {\n        if (!TransmitOneByte(i2c_id, i2cBuffer[i]))\n        {\n            break;\n        }\n    }\n    StopTransfer(i2c_id);\n"]]}
{"hexsha": "a9e51600222c7bfebfcb289cbeeed390bc6dcc64", "ext": "c", "lang": "C", "content": "void SG_file_spec__add_patterns__array(\n\tSG_context*                pCtx,\n\tSG_file_spec*              pThis,\n\tSG_file_spec__pattern_type eType,\n\tconst char* const*         ppPatterns,\n\tSG_uint32                  uCount,\n\tSG_uint32                  uFlags\n\t)\n{\n\tSG_uint32 uIndex = 0u;\n\n\tSG_NULLARGCHECK(pThis);\n\tSG_ERR_CHECK(  _validate_pattern_type(pCtx, eType)  );\n\tSG_ARGCHECK(ppPatterns != NULL || uCount == 0u, ppPatterns);\n\n\tfor (uIndex = 0u; uIndex < uCount; ++uIndex)\n\t{\n\t\tSG_ARGCHECK(ppPatterns[uIndex] != NULL, ppPatterns);\n\t}\n\n\tfor (uIndex = 0u; uIndex < uCount; ++uIndex)\n\t{\n\t\tSG_file_spec__add_pattern__sz(pCtx, pThis, eType, ppPatterns[uIndex], uFlags);\n\t}\n\nfail:\n\treturn;\n}", "item_id": 14, "repo": "jeffhostetler/veracity", "file": "src/libraries/ut/sg_file_spec.c", "last_update_at": "2020-11-22T14:14:18+00:00", "question_id": "a9e51600222c7bfebfcb289cbeeed390bc6dcc64_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void SG_file_spec__add_patterns__array(\n\tSG_context*                pCtx,\n\tSG_file_spec*              pThis,\n\tSG_file_spec__pattern_type eType,\n\tconst char* const*         ppPatterns,\n\tSG_uint32                  uCount,\n\tSG_uint32                  uFlags\n\t)\n{\n\tSG_uint32 uIndex = 0u;\n\tSG_NULLARGCHECK(pThis);\n\tSG_ERR_CHECK(  _validate_pattern_type(pCtx, eType)  );\n\tSG_ARGCHECK(ppPatterns != NULL || uCount == 0u, ppPatterns);\n\tfor (uIndex = 0u; uIndex < uCount; ++uIndex)\n\t{\n\t\tSG_ARGCHECK(ppPatterns[uIndex] != NULL, ppPatterns);\n\t}\n\tfor (uIndex = 0u; uIndex < uCount; ++uIndex)\n\t{\n\t\tSG_file_spec__add_pattern__sz(pCtx, pThis, eType, ppPatterns[uIndex], uFlags);\n\t}\nfail:\n\treturn;\n"]]}
{"hexsha": "e7d2d626f920c604b9fc332ac5afc949a1b0fc12", "ext": "c", "lang": "C", "content": "BOOL xmlfsm_next_sibling(XmlNodeTraverser *data) {\n\tdata->node.data = data->buffer.data;\n\tif (xmlfsm_skip_node(&data->buffer, 0) == XMLPARSE_SUCCESS) {\n\t\tdata->node.end = data->buffer.data;\n\t\tdata->node_start = data->node.data;\n\t\txmlfsm_node_name(&data->node, &data->node_name);\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}", "item_id": 5, "repo": "dotdoom/mukite", "file": "xmcomp/src/xmlfsm.c", "last_update_at": "2020-06-06T13:35:56+00:00", "question_id": "e7d2d626f920c604b9fc332ac5afc949a1b0fc12_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["BOOL xmlfsm_next_sibling(XmlNodeTraverser *data) {\n\tdata->node.data = data->buffer.data;\n\tif (xmlfsm_skip_node(&data->buffer, 0) == XMLPARSE_SUCCESS) {\n\t\tdata->node.end = data->buffer.data;\n\t\tdata->node_start = data->node.data;\n\t\txmlfsm_node_name(&data->node, &data->node_name);\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n"]]}
{"hexsha": "6558ef2767245d284afe4f62fd73ebc226238328", "ext": "c", "lang": "C", "content": "void obs_ntr_connection_create(struct ntr_data *owner_data)\n{\n\tstruct ntr_connection_data *temp_connection_data = bzalloc(sizeof(struct ntr_connection_data));\n\n\tfor (int screen_index = 0; screen_index < SCREEN_COUNT; screen_index++)\n\t{\n\t\ttemp_connection_data->uncompressed_buffer[screen_index] = bzalloc(SCREEN_WIDTH[screen_index] * SCREEN_HEIGHT[screen_index] * 4);\n\n\t\tpthread_mutex_init_value(&temp_connection_data->buffer_mutex[screen_index]);\n\t\tpthread_mutex_init(&temp_connection_data->buffer_mutex[screen_index], NULL);\n\t}\n\n\tshared_connection_data = temp_connection_data;\n\n\tshared_connection_data->net_thread_exited = false;\n\tshared_connection_data->net_thread_started = true;\n\tpthread_create(&shared_connection_data->net_thread, NULL, obs_ntr_net_thread_run, shared_connection_data);\n}", "item_id": 2, "repo": "bluekirby0/obs-ntr", "file": "src/obs-ntr.c", "last_update_at": "2020-05-04T22:24:58+00:00", "question_id": "6558ef2767245d284afe4f62fd73ebc226238328_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void obs_ntr_connection_create(struct ntr_data *owner_data)\n{\n\tstruct ntr_connection_data *temp_connection_data = bzalloc(sizeof(struct ntr_connection_data));\n\tfor (int screen_index = 0; screen_index < SCREEN_COUNT; screen_index++)\n\t{\n\t\ttemp_connection_data->uncompressed_buffer[screen_index] = bzalloc(SCREEN_WIDTH[screen_index] * SCREEN_HEIGHT[screen_index] * 4);\n\t\tpthread_mutex_init_value(&temp_connection_data->buffer_mutex[screen_index]);\n\t\tpthread_mutex_init(&temp_connection_data->buffer_mutex[screen_index], NULL);\n\t}\n\tshared_connection_data = temp_connection_data;\n\tshared_connection_data->net_thread_exited = false;\n\tshared_connection_data->net_thread_started = true;\n\tpthread_create(&shared_connection_data->net_thread, NULL, obs_ntr_net_thread_run, shared_connection_data);\n"]]}
{"hexsha": "32901f0a423a48495156542c305b873a4ed53a48", "ext": "c", "lang": "C", "content": "void printText(int x, int y, int col, int backcol, int fill, char *format, ...)\n{\n\tint x1, y1, i;\n\tu32 data;\n\tu16 *line16 = NULL;\n\tu32 *line32 = NULL;\n\tu8 *font;\n\tu8 ch = 0;\n\tchar buf[128] = {\"\"};\n\tint pitch = vscreen->width*bpp/8;\n\tva_list arglist;\n\t\tva_start(arglist, format);\n\t\tvsprintf(buf, format, arglist);\n\t\tva_end(arglist);\n\n\tfor(i=0; i<sizeof(buf); i++)\n\t{\n\t\tch = buf[i];\n\t\t// mapping\n\t\tif (ch<0x20) ch = 0;\n\t\telse if (ch<0x80) { ch -= 0x20; }\n\t\telse if (ch<0xa0) {\tch = 0;\t}\n\t\telse ch -= 0x40;\n\t\tfont = (u8 *)&hankaku_font10[ch*10];\n\t\t// draw\n\t\tif (bpp == 16) line16 = (u16*)(vscreen->data + x*2 + y * pitch);\n\t\telse           line32 = (u32*)(vscreen->data + x*4 + y * pitch);\n\n\t\tfor (y1=0; y1<10; y1++)\n\t\t{\n\t\t\tdata = *font++;\n\t\t\tfor (x1=0; x1<5; x1++)\n\t\t\t{\n\t\t\t\tif (data & 1)\n\t\t\t\t{\n\t\t\t\t\tif (bpp == 16) *line16 = col;\n\t\t\t\t    else           *line32 = col;\n\t\t\t\t}\n\t\t\t\telse if (fill)\n\t\t\t\t{\n\t\t\t\t\tif (bpp == 16) *line16 = backcol;\n\t\t\t\t\telse           *line32 = backcol;\n\t\t\t\t}\n\n\t\t\t\tif (bpp == 16) line16++;\n\t\t\t\telse           line32++;\n\n\t\t\t\tdata = data >> 1;\n\t\t\t}\n\t\t\tif (bpp == 16) line16 += pitch/2-5;\n\t\t\telse           line32 += pitch/4-5;\n\t\t}\n\t\tx+=5;\n\t}\n}", "item_id": 2, "repo": "Darknior/OpenBORv3b3946", "file": "sdl/menu.c", "last_update_at": "2020-04-17T11:04:28+00:00", "question_id": "32901f0a423a48495156542c305b873a4ed53a48_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void printText(int x, int y, int col, int backcol, int fill, char *format, ...)\n{\n\tint x1, y1, i;\n\tu32 data;\n\tu16 *line16 = NULL;\n\tu32 *line32 = NULL;\n\tu8 *font;\n\tu8 ch = 0;\n\tchar buf[128] = {\"\"};\n\tint pitch = vscreen->width*bpp/8;\n\tva_list arglist;\n\t\tva_start(arglist, format);\n\t\tvsprintf(buf, format, arglist);\n\t\tva_end(arglist);\n\tfor(i=0; i<sizeof(buf); i++)\n\t{\n\t\tch = buf[i];\n\t\t// mapping\n\t\tif (ch<0x20) ch = 0;\n\t\telse if (ch<0x80) { ch -= 0x20; }\n\t\telse if (ch<0xa0) {\tch = 0;\t}\n\t\telse ch -= 0x40;\n\t\tfont = (u8 *)&hankaku_font10[ch*10];\n\t\t// draw\n\t\tif (bpp == 16) line16 = (u16*)(vscreen->data + x*2 + y * pitch);\n\t\telse           line32 = (u32*)(vscreen->data + x*4 + y * pitch);\n\t\tfor (y1=0; y1<10; y1++)\n\t\t{\n\t\t\tdata = *font++;\n\t\t\tfor (x1=0; x1<5; x1++)\n\t\t\t{\n\t\t\t\tif (data & 1)\n\t\t\t\t{\n\t\t\t\t\tif (bpp == 16) *line16 = col;\n\t\t\t\t    else           *line32 = col;\n\t\t\t\t}\n\t\t\t\telse if (fill)\n\t\t\t\t{\n\t\t\t\t\tif (bpp == 16) *line16 = backcol;\n\t\t\t\t\telse           *line32 = backcol;\n\t\t\t\t}\n\t\t\t\tif (bpp == 16) line16++;\n\t\t\t\telse           line32++;\n\t\t\t\tdata = data >> 1;\n\t\t\t}\n\t\t\tif (bpp == 16) line16 += pitch/2-5;\n\t\t\telse           line32 += pitch/4-5;\n\t\t}\n\t\tx+=5;\n\t}\n"]]}
{"hexsha": "aa4e3ccb3cc548b9c2b7d044f3a28200c755ee22", "ext": "c", "lang": "C", "content": "void gl_getfragdataindex( int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[] ) {\n\n\tif (NULL == glGetFragDataIndex) mogl_glunsupported(\"glGetFragDataIndex\");\n\tplhs[0]=mxCreateDoubleMatrix(1,1,mxREAL);\n\t*mxGetPr(plhs[0])=(double)glGetFragDataIndex((GLuint)mxGetScalar(prhs[0]),\n\t\t(const GLchar*)mxGetData(prhs[1]));\n\n}", "item_id": 43, "repo": "petzschnerlab/piercing-of-consciousness-as-a-threshold-crossing-operation", "file": "lib/ExtOnPath/Psychtoolbox_wo_svn/PsychOpenGL/MOGL/source/gl_auto.c", "last_update_at": "2020-03-17T13:16:12+00:00", "question_id": "aa4e3ccb3cc548b9c2b7d044f3a28200c755ee22_43", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void gl_getfragdataindex( int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[] ) {\n\tif (NULL == glGetFragDataIndex) mogl_glunsupported(\"glGetFragDataIndex\");\n\tplhs[0]=mxCreateDoubleMatrix(1,1,mxREAL);\n\t*mxGetPr(plhs[0])=(double)glGetFragDataIndex((GLuint)mxGetScalar(prhs[0]),\n\t\t(const GLchar*)mxGetData(prhs[1]));\n"]]}
{"hexsha": "717413d8c99f0881c185605a09283a66fceb927e", "ext": "c", "lang": "C", "content": "int bgcp_match (void *cx, const char *topic_name, const char *type_name)\n{\n\tSR_CX\t\t*cp = (SR_CX *) cx;\n\tSR_NOTIFY_DATA\t*anp;\n\tSR_NOTIFY\t*np;\n\n\tLIST_FOREACH (cp->notifications, anp) {\n\t\tnp = anp->notification;\n\t\tif (!nmatch (str_ptr (np->topic), topic_name, 0) &&\n\t\t    !nmatch (str_ptr (np->type), type_name, 0))\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}", "item_id": 47, "repo": "qeo/qeo-core", "file": "dds/src/trans/ip/ri_bgcp.c", "last_update_at": "2020-10-30T20:23:26+00:00", "question_id": "717413d8c99f0881c185605a09283a66fceb927e_47", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int bgcp_match (void *cx, const char *topic_name, const char *type_name)\n{\n\tSR_CX\t\t*cp = (SR_CX *) cx;\n\tSR_NOTIFY_DATA\t*anp;\n\tSR_NOTIFY\t*np;\n\tLIST_FOREACH (cp->notifications, anp) {\n\t\tnp = anp->notification;\n\t\tif (!nmatch (str_ptr (np->topic), topic_name, 0) &&\n\t\t    !nmatch (str_ptr (np->type), type_name, 0))\n\t\t\treturn (1);\n\t}\n\treturn (0);\n"]]}
{"hexsha": "0aedd3ee13dbdbfec9fb8a5477992c48dee8226d", "ext": "c", "lang": "C", "content": "ISR(TIMER2_OVF_vect)\n{\n  ADCSRA = ADCSRA |  _BV(ADSC);\n  BZR(value);\n  itoa(value, word, 10);\n \n}", "item_id": 1, "repo": "VojtaBednarsky/park_senzors", "file": "test_dir/main.c", "last_update_at": "2020-12-09T14:04:38+00:00", "question_id": "0aedd3ee13dbdbfec9fb8a5477992c48dee8226d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ISR(TIMER2_OVF_vect)\n{\n  ADCSRA = ADCSRA |  _BV(ADSC);\n  BZR(value);\n  itoa(value, word, 10);\n"]]}
{"hexsha": "433d7a0a80c344f4274a5302ccd7e0ba6b61b4dd", "ext": "c", "lang": "C", "content": "int bttv_i2c_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[], int num)\n{\n\tstruct bttv *btv = i2c_get_adapdata(i2c_adap);\n\tint retval = 0;\n\tint i;\n\n\tif (i2c_debug)\n\t\tprintk(\"bt-i2c:\");\n\tbtwrite(BT848_INT_I2CDONE|BT848_INT_RACK, BT848_INT_STAT);\n\tfor (i = 0 ; i < num; i++) {\n\t\tif (msgs[i].flags & I2C_M_RD) {\n\t\t\t/* read */\n\t\t\tretval = bttv_i2c_readbytes(btv, &msgs[i], i+1 == num);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto err;\n\t\t} else {\n\t\t\t/* write */\n\t\t\tretval = bttv_i2c_sendbytes(btv, &msgs[i], i+1 == num);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\treturn num;\n\n err:\n\treturn retval;\n}", "item_id": 13, "repo": "dnhua/Linux_study", "file": "linux-2.6.0/drivers/media/video/bttv-if.c", "last_update_at": "2020-11-10T12:47:02+00:00", "question_id": "433d7a0a80c344f4274a5302ccd7e0ba6b61b4dd_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int bttv_i2c_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[], int num)\n{\n\tstruct bttv *btv = i2c_get_adapdata(i2c_adap);\n\tint retval = 0;\n\tint i;\n\tif (i2c_debug)\n\t\tprintk(\"bt-i2c:\");\n\tbtwrite(BT848_INT_I2CDONE|BT848_INT_RACK, BT848_INT_STAT);\n\tfor (i = 0 ; i < num; i++) {\n\t\tif (msgs[i].flags & I2C_M_RD) {\n\t\t\t/* read */\n\t\t\tretval = bttv_i2c_readbytes(btv, &msgs[i], i+1 == num);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto err;\n\t\t} else {\n\t\t\t/* write */\n\t\t\tretval = bttv_i2c_sendbytes(btv, &msgs[i], i+1 == num);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\treturn num;\n err:\n\treturn retval;\n"]]}
{"hexsha": "999a69941b5a759a6074fbc8f7474eee4f955074", "ext": "c", "lang": "C", "content": "void push_next_indice(\n    Encoder_State *st,           /* i/o: encoder state structure */\n    unsigned short value,        /* i  : value of the quantized indice */\n    short nb_bits       /* i  : number of bits used to quantize the indice */\n)\n{\n\n    /* store the values in the list */\n    st->ind_list[st->next_ind].value   = value;\n    st->ind_list[st->next_ind].nb_bits = nb_bits;\n    st->next_ind++;\n\n    /* update the total number of bits already written */\n    st->nb_bits_tot += nb_bits;\n\n    return;\n}", "item_id": 3, "repo": "cesarmo759/android_kernel_samsung_msm8916", "file": "vendor/samsung/external/ims_voice_engine/codec/evs/float_c/lib_com/bitstream.c", "last_update_at": "2020-06-28T00:49:21+00:00", "question_id": "999a69941b5a759a6074fbc8f7474eee4f955074_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void push_next_indice(\n    Encoder_State *st,           /* i/o: encoder state structure */\n    unsigned short value,        /* i  : value of the quantized indice */\n    short nb_bits       /* i  : number of bits used to quantize the indice */\n)\n{\n    /* store the values in the list */\n    st->ind_list[st->next_ind].value   = value;\n    st->ind_list[st->next_ind].nb_bits = nb_bits;\n    st->next_ind++;\n    /* update the total number of bits already written */\n    st->nb_bits_tot += nb_bits;\n    return;\n"]]}
{"hexsha": "02700f9126e88f62b7a28b5f3f1d4479869dd80c", "ext": "c", "lang": "C", "content": "enum _ecore_status_t ecore_mcp_halt(struct ecore_hwfn *p_hwfn,\n\t\t\t\t    struct ecore_ptt *p_ptt)\n{\n\tu32 resp = 0, param = 0, cpu_state, cnt = 0;\n\tenum _ecore_status_t rc;\n\n\trc = ecore_mcp_cmd(p_hwfn, p_ptt, DRV_MSG_CODE_MCP_HALT, 0, &resp,\n\t\t\t   &param);\n\tif (rc != ECORE_SUCCESS) {\n\t\tDP_ERR(p_hwfn, \"MCP response failure, aborting\\n\");\n\t\treturn rc;\n\t}\n\n\tdo {\n\t\tOSAL_MSLEEP(ECORE_MCP_HALT_SLEEP_MS);\n\t\tcpu_state = ecore_rd(p_hwfn, p_ptt, MCP_REG_CPU_STATE);\n\t\tif (cpu_state & MCP_REG_CPU_STATE_SOFT_HALTED)\n\t\t\tbreak;\n\t} while (++cnt < ECORE_MCP_HALT_MAX_RETRIES);\n\n\tif (cnt == ECORE_MCP_HALT_MAX_RETRIES) {\n\t\tDP_NOTICE(p_hwfn, false,\n\t\t\t  \"Failed to halt the MCP [CPU_MODE = 0x%08x, CPU_STATE = 0x%08x]\\n\",\n\t\t\t  ecore_rd(p_hwfn, p_ptt, MCP_REG_CPU_MODE), cpu_state);\n\t\treturn ECORE_BUSY;\n\t}\n\n\treturn ECORE_SUCCESS;\n}", "item_id": 63, "repo": "AsahiOS/gate", "file": "usr/src/uts/common/io/qede/579xx/drivers/ecore/ecore_mcp.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "02700f9126e88f62b7a28b5f3f1d4479869dd80c_63", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["enum _ecore_status_t ecore_mcp_halt(struct ecore_hwfn *p_hwfn,\n\t\t\t\t    struct ecore_ptt *p_ptt)\n{\n\tu32 resp = 0, param = 0, cpu_state, cnt = 0;\n\tenum _ecore_status_t rc;\n\trc = ecore_mcp_cmd(p_hwfn, p_ptt, DRV_MSG_CODE_MCP_HALT, 0, &resp,\n\t\t\t   &param);\n\tif (rc != ECORE_SUCCESS) {\n\t\tDP_ERR(p_hwfn, \"MCP response failure, aborting\\n\");\n\t\treturn rc;\n\t}\n\tdo {\n\t\tOSAL_MSLEEP(ECORE_MCP_HALT_SLEEP_MS);\n\t\tcpu_state = ecore_rd(p_hwfn, p_ptt, MCP_REG_CPU_STATE);\n\t\tif (cpu_state & MCP_REG_CPU_STATE_SOFT_HALTED)\n\t\t\tbreak;\n\t} while (++cnt < ECORE_MCP_HALT_MAX_RETRIES);\n\tif (cnt == ECORE_MCP_HALT_MAX_RETRIES) {\n\t\tDP_NOTICE(p_hwfn, false,\n\t\t\t  \"Failed to halt the MCP [CPU_MODE = 0x%08x, CPU_STATE = 0x%08x]\\n\",\n\t\t\t  ecore_rd(p_hwfn, p_ptt, MCP_REG_CPU_MODE), cpu_state);\n\t\treturn ECORE_BUSY;\n\t}\n\treturn ECORE_SUCCESS;\n"]]}
{"hexsha": "f1cce97ba7bec7069dbdffee1e58f76c678402ed", "ext": "c", "lang": "C", "content": "static int\nsysmatch(p)\nchar *p;\n{\n\tchar *arg;\n\n\twhile (p && *p) {\n\t\tp = nextarg(p, &arg);\n\t    \tif (EQUALS(arg, Rmtname)) \n\t\t\treturn(SUCCESS);\n\t}\n\treturn FAIL;\n}", "item_id": 4, "repo": "AsahiOS/gate", "file": "usr/src/cmd/bnu/limits.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "f1cce97ba7bec7069dbdffee1e58f76c678402ed_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nsysmatch(p)\nchar *p;\n{\n\tchar *arg;\n\twhile (p && *p) {\n\t\tp = nextarg(p, &arg);\n\t    \tif (EQUALS(arg, Rmtname)) \n\t\t\treturn(SUCCESS);\n\t}\n\treturn FAIL;\n"]]}
{"hexsha": "9608218928255e3b098d7f7f0565f3c3fa4c236d", "ext": "c", "lang": "C", "content": "static int local_create_fifo(FAR const char *path)\n{\n\tint ret;\n\n\t/* Create the client-to-server FIFO if it does not already exist. */\n\n\tif (!local_fifo_exists(path)) {\n\t\tret = mkfifo(path, 0644);\n\t\tif (ret < 0) {\n\t\t\tint errcode = get_errno();\n\t\t\tDEBUGASSERT(errcode > 0);\n\n\t\t\tndbg(\"ERROR: Failed to create FIFO %s: %d\\n\", path, errcode);\n\t\t\treturn -errcode;\n\t\t}\n\t}\n\n\t/* The FIFO (or some character driver) exists at PATH or we successfully\n\t * created the FIFO at that location.\n\t */\n\n\treturn OK;\n}", "item_id": 1, "repo": "bmolodan/TizenRT", "file": "os/net/local/local_fifo.c", "last_update_at": "2020-08-25T08:36:29+00:00", "question_id": "9608218928255e3b098d7f7f0565f3c3fa4c236d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int local_create_fifo(FAR const char *path)\n{\n\tint ret;\n\t/* Create the client-to-server FIFO if it does not already exist. */\n\tif (!local_fifo_exists(path)) {\n\t\tret = mkfifo(path, 0644);\n\t\tif (ret < 0) {\n\t\t\tint errcode = get_errno();\n\t\t\tDEBUGASSERT(errcode > 0);\n\t\t\tndbg(\"ERROR: Failed to create FIFO %s: %d\\n\", path, errcode);\n\t\t\treturn -errcode;\n\t\t}\n\t}\n\t/* The FIFO (or some character driver) exists at PATH or we successfully\n\t * created the FIFO at that location.\n\t */\n\treturn OK;\n"]]}
{"hexsha": "5cf119a86d37cab0de968edd113b43caf0d6a264", "ext": "c", "lang": "C", "content": "static void surface_state_move(struct wlr_surface_state *state,\n\t\tstruct wlr_surface_state *next) {\n\tsurface_state_copy(state, next);\n\n\tif (next->committed & WLR_SURFACE_STATE_BUFFER) {\n\t\tsurface_state_set_buffer(state, next->buffer_resource);\n\t\tsurface_state_reset_buffer(next);\n\t\tnext->dx = next->dy = 0;\n\t}\n\tif (next->committed & WLR_SURFACE_STATE_SURFACE_DAMAGE) {\n\t\tpixman_region32_clear(&next->surface_damage);\n\t}\n\tif (next->committed & WLR_SURFACE_STATE_BUFFER_DAMAGE) {\n\t\tpixman_region32_clear(&next->buffer_damage);\n\t}\n\tif (next->committed & WLR_SURFACE_STATE_FRAME_CALLBACK_LIST) {\n\t\twl_list_insert_list(&state->frame_callback_list,\n\t\t\t&next->frame_callback_list);\n\t\twl_list_init(&next->frame_callback_list);\n\t}\n\n\tnext->committed = 0;\n}", "item_id": 8, "repo": "David96/wlroots", "file": "types/wlr_surface.c", "last_update_at": "2020-06-08T19:31:15+00:00", "question_id": "5cf119a86d37cab0de968edd113b43caf0d6a264_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void surface_state_move(struct wlr_surface_state *state,\n\t\tstruct wlr_surface_state *next) {\n\tsurface_state_copy(state, next);\n\tif (next->committed & WLR_SURFACE_STATE_BUFFER) {\n\t\tsurface_state_set_buffer(state, next->buffer_resource);\n\t\tsurface_state_reset_buffer(next);\n\t\tnext->dx = next->dy = 0;\n\t}\n\tif (next->committed & WLR_SURFACE_STATE_SURFACE_DAMAGE) {\n\t\tpixman_region32_clear(&next->surface_damage);\n\t}\n\tif (next->committed & WLR_SURFACE_STATE_BUFFER_DAMAGE) {\n\t\tpixman_region32_clear(&next->buffer_damage);\n\t}\n\tif (next->committed & WLR_SURFACE_STATE_FRAME_CALLBACK_LIST) {\n\t\twl_list_insert_list(&state->frame_callback_list,\n\t\t\t&next->frame_callback_list);\n\t\twl_list_init(&next->frame_callback_list);\n\t}\n\tnext->committed = 0;\n"]]}
{"hexsha": "1259874e0b2f36d122e8b0ff1faae4afc7472e91", "ext": "c", "lang": "C", "content": "void expr_cleanup(ExprsPtr exprs) {\n    struct Experiment *expr = exprs->exprs[0];\n    unsigned i = 0;\n    for (i = 0; i < expr->nport_modules; ++i) {\n        struct ExpPortModules *pm = expr->port_modules[i];\n        unsigned j = 0;\n        for (j = 0; j < pm->nconfigs; ++j) {\n            struct ExpModuleConfig *cfg = pm->configs[j];\n\n            if (cfg->module) module_delete_get(cfg->name)(cfg->module);\n        }\n    }\n}", "item_id": 7, "repo": "luwangli/Agg-Evict", "file": "pktreceiver/src/experiment.c", "last_update_at": "2020-09-06T06:32:21+00:00", "question_id": "1259874e0b2f36d122e8b0ff1faae4afc7472e91_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void expr_cleanup(ExprsPtr exprs) {\n    struct Experiment *expr = exprs->exprs[0];\n    unsigned i = 0;\n    for (i = 0; i < expr->nport_modules; ++i) {\n        struct ExpPortModules *pm = expr->port_modules[i];\n        unsigned j = 0;\n        for (j = 0; j < pm->nconfigs; ++j) {\n            struct ExpModuleConfig *cfg = pm->configs[j];\n            if (cfg->module) module_delete_get(cfg->name)(cfg->module);\n        }\n    }\n"]]}
{"hexsha": "835fd7175d4d02cac7f00248a8719677cfd853de", "ext": "c", "lang": "C", "content": "bool_t MidiInitializeCallbacks(midi_callbacks_t *callbacks) {\n  if (callbacks == NULL) return false;\n  memset(callbacks, 0, sizeof(midi_callbacks_t));\n  callbacks->next_event_id = 1;\n  callbacks->rx.next_rx_event_id = 1;\n  callbacks->rx.next_sys_ex_rx_event_id = 1;\n  callbacks->tx.next_tx_event_id = 1;\n  return true;\n}", "item_id": 0, "repo": "SuperOxigen/midi-ctrl", "file": "src/midi_callback.c", "last_update_at": "2020-02-29T22:10:16+00:00", "question_id": "835fd7175d4d02cac7f00248a8719677cfd853de_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool_t MidiInitializeCallbacks(midi_callbacks_t *callbacks) {\n  if (callbacks == NULL) return false;\n  memset(callbacks, 0, sizeof(midi_callbacks_t));\n  callbacks->next_event_id = 1;\n  callbacks->rx.next_rx_event_id = 1;\n  callbacks->rx.next_sys_ex_rx_event_id = 1;\n  callbacks->tx.next_tx_event_id = 1;\n  return true;\n"]]}
{"hexsha": "7ff099f728f281015b97759ac593b329cc5b64ec", "ext": "c", "lang": "C", "content": "static void call_process_timeout(void *user_ctx, const belle_sip_timeout_event_t *event) {\n\tSalOp* op=(SalOp*)user_ctx;\n\n\tif (op->state==SalOpStateTerminated) return;\n\n\tif (!op->dialog)  {\n\t\t/*call terminated very early*/\n\t\tsal_error_info_set(&op->error_info,SalReasonRequestTimeout,408,\"Request timeout\",NULL);\n\t\top->base.root->callbacks.call_failure(op);\n\t\top->state = SalOpStateTerminating;\n\t\tcall_set_released(op);\n\t} else {\n\t\t/*dialog will terminated shortly, nothing to do*/\n\t}\n}", "item_id": 9, "repo": "bcaswell-fcc/vtc_secure_linphone", "file": "coreapi/bellesip_sal/sal_op_call.c", "last_update_at": "2020-11-30T12:31:20+00:00", "question_id": "7ff099f728f281015b97759ac593b329cc5b64ec_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void call_process_timeout(void *user_ctx, const belle_sip_timeout_event_t *event) {\n\tSalOp* op=(SalOp*)user_ctx;\n\tif (op->state==SalOpStateTerminated) return;\n\tif (!op->dialog)  {\n\t\t/*call terminated very early*/\n\t\tsal_error_info_set(&op->error_info,SalReasonRequestTimeout,408,\"Request timeout\",NULL);\n\t\top->base.root->callbacks.call_failure(op);\n\t\top->state = SalOpStateTerminating;\n\t\tcall_set_released(op);\n\t} else {\n\t\t/*dialog will terminated shortly, nothing to do*/\n\t}\n"]]}
{"hexsha": "34c13a14e3fccfcddb037c0a96cc0b03cbdb9ca4", "ext": "c", "lang": "C", "content": "void smI5_nS0_CMockExpect(UNITY_LINE_TYPE cmock_line, SmInitialPseudoTest* const me)\n{\n  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_smI5_nS0_CALL_INSTANCE));\n  CMOCK_smI5_nS0_CALL_INSTANCE* cmock_call_instance = (CMOCK_smI5_nS0_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);\n  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);\n  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));\n  Mock.smI5_nS0_CallInstance = CMock_Guts_MemChain(Mock.smI5_nS0_CallInstance, cmock_guts_index);\n  Mock.smI5_nS0_IgnoreBool = (int)0;\n  cmock_call_instance->LineNumber = cmock_line;\n  cmock_call_instance->CallOrder = ++GlobalExpectCount;\n  CMockExpectParameters_smI5_nS0(cmock_call_instance, me);\n  UNITY_CLR_DETAILS();\n}", "item_id": 137, "repo": "sporaio/spora-firmware", "file": "third-party/rkh/source/sm/test/stub/mocks/Mock_smInitialPseudoTestAct.c", "last_update_at": "2020-08-13T13:28:28+00:00", "question_id": "34c13a14e3fccfcddb037c0a96cc0b03cbdb9ca4_137", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void smI5_nS0_CMockExpect(UNITY_LINE_TYPE cmock_line, SmInitialPseudoTest* const me)\n{\n  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_smI5_nS0_CALL_INSTANCE));\n  CMOCK_smI5_nS0_CALL_INSTANCE* cmock_call_instance = (CMOCK_smI5_nS0_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);\n  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);\n  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));\n  Mock.smI5_nS0_CallInstance = CMock_Guts_MemChain(Mock.smI5_nS0_CallInstance, cmock_guts_index);\n  Mock.smI5_nS0_IgnoreBool = (int)0;\n  cmock_call_instance->LineNumber = cmock_line;\n  cmock_call_instance->CallOrder = ++GlobalExpectCount;\n  CMockExpectParameters_smI5_nS0(cmock_call_instance, me);\n  UNITY_CLR_DETAILS();\n"]]}
{"hexsha": "4a7e4ea4dd35fd76a57727326ee4a1e5494699e7", "ext": "c", "lang": "C", "content": "void * sst_read_self_stat(sst_proc_stat * pstat)\n{\n\tconst int num_stats = 52;\n\tvoid * ret = NULL;\n\tFILE * fself = fopen(pself(\"stat\"), \"r\");\n\t\n\tif (fself)\n\t{\n\t\tint stats = fscanf(fself, fmt_str_stat, &(pstat->pid),\n\t\t\tpstat->comm, &(pstat->state), &(pstat->ppid), &(pstat->pgrp),\n\t\t\t&(pstat->session), &(pstat->tty_nr), &(pstat->tpgid),\n\t\t\t&(pstat->flags), &(pstat->minflt), &(pstat->cminflt),\n\t\t\t&(pstat->majflt), &(pstat->cmajflt), &(pstat->utime),\n\t\t\t&(pstat->stime), &(pstat->cutime), &(pstat->cstime),\n\t\t\t&(pstat->priority), &(pstat->nice), &(pstat->num_threads),\n\t\t\t&(pstat->itrealvalue), &(pstat->starttime), &(pstat->vsize),\n\t\t\t&(pstat->rss), &(pstat->rsslim), &(pstat->startcode),\n\t\t\t&(pstat->endcode), &(pstat->startstack), &(pstat->kstkesp),\n\t\t\t&(pstat->kstkeip), &(pstat->signal), &(pstat->blocked),\n\t\t\t&(pstat->sigignore), &(pstat->sigcatch), &(pstat->wchan),\n\t\t\t&(pstat->nswap), &(pstat->cnswap), &(pstat->exit_signal),\n\t\t\t&(pstat->processor), &(pstat->rt_priority), &(pstat->policy),\n\t\t\t&(pstat->delayacct_blkio_ticks), &(pstat->guest_time),\n\t\t\t&(pstat->cguest_time), &(pstat->start_data), &(pstat->end_data),\n\t\t\t&(pstat->start_brk), &(pstat->arg_start), &(pstat->arg_end),\n\t\t\t&(pstat->env_start), &(pstat->env_end), &(pstat->exit_code)\n\t\t);\n\t\t\n\t\tfclose(fself);\n\t\tif (num_stats == stats)\n\t\t\tret = pstat;\n\t}\n\t\n\treturn ret;\n}", "item_id": 0, "repo": "vladcc/self_stat", "file": "self-stat/self_stat.c", "last_update_at": "2020-09-20T22:12:53+00:00", "question_id": "4a7e4ea4dd35fd76a57727326ee4a1e5494699e7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void * sst_read_self_stat(sst_proc_stat * pstat)\n{\n\tconst int num_stats = 52;\n\tvoid * ret = NULL;\n\tFILE * fself = fopen(pself(\"stat\"), \"r\");\n\t\n\tif (fself)\n\t{\n\t\tint stats = fscanf(fself, fmt_str_stat, &(pstat->pid),\n\t\t\tpstat->comm, &(pstat->state), &(pstat->ppid), &(pstat->pgrp),\n\t\t\t&(pstat->session), &(pstat->tty_nr), &(pstat->tpgid),\n\t\t\t&(pstat->flags), &(pstat->minflt), &(pstat->cminflt),\n\t\t\t&(pstat->majflt), &(pstat->cmajflt), &(pstat->utime),\n\t\t\t&(pstat->stime), &(pstat->cutime), &(pstat->cstime),\n\t\t\t&(pstat->priority), &(pstat->nice), &(pstat->num_threads),\n\t\t\t&(pstat->itrealvalue), &(pstat->starttime), &(pstat->vsize),\n\t\t\t&(pstat->rss), &(pstat->rsslim), &(pstat->startcode),\n\t\t\t&(pstat->endcode), &(pstat->startstack), &(pstat->kstkesp),\n\t\t\t&(pstat->kstkeip), &(pstat->signal), &(pstat->blocked),\n\t\t\t&(pstat->sigignore), &(pstat->sigcatch), &(pstat->wchan),\n\t\t\t&(pstat->nswap), &(pstat->cnswap), &(pstat->exit_signal),\n\t\t\t&(pstat->processor), &(pstat->rt_priority), &(pstat->policy),\n\t\t\t&(pstat->delayacct_blkio_ticks), &(pstat->guest_time),\n\t\t\t&(pstat->cguest_time), &(pstat->start_data), &(pstat->end_data),\n\t\t\t&(pstat->start_brk), &(pstat->arg_start), &(pstat->arg_end),\n\t\t\t&(pstat->env_start), &(pstat->env_end), &(pstat->exit_code)\n\t\t);\n\t\t\n\t\tfclose(fself);\n\t\tif (num_stats == stats)\n\t\t\tret = pstat;\n\t}\n\t\n\treturn ret;\n"]]}
{"hexsha": "f76ef9aaab6fe7569bd725330a8fee48e52f9b3c", "ext": "h", "lang": "C", "content": "inline LcsHashTable::LcsHashTable()\n{\n    hashBlock = NULL;\n    hashTableSize = 0;\n    nextValueNode = 0;\n}", "item_id": 7, "repo": "alexavila150/luciddb", "file": "fennel/lcs/LcsHash.h", "last_update_at": "2020-05-13T14:18:33+00:00", "question_id": "f76ef9aaab6fe7569bd725330a8fee48e52f9b3c_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["inline LcsHashTable::LcsHashTable()\n{\n    hashBlock = NULL;\n    hashTableSize = 0;\n    nextValueNode = 0;\n"]]}
{"hexsha": "492f3e3af7a5a5c034bd94e8dde92e7215c49d4e", "ext": "c", "lang": "C", "content": "void qspExecLocByName(QSP_CHAR *name, QSP_BOOL isChangeDesc)\n{\n\tint locInd = qspLocIndex(name);\n\tif (locInd < 0)\n\t{\n\t\tqspSetError(QSP_ERR_LOCNOTFOUND);\n\t\treturn;\n\t}\n\tqspExecLocByIndex(locInd, isChangeDesc, QSP_FALSE);\n}", "item_id": 4, "repo": "Sonnix1/Qqsp", "file": "qsp/locations.c", "last_update_at": "2020-10-17T05:22:45+00:00", "question_id": "492f3e3af7a5a5c034bd94e8dde92e7215c49d4e_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void qspExecLocByName(QSP_CHAR *name, QSP_BOOL isChangeDesc)\n{\n\tint locInd = qspLocIndex(name);\n\tif (locInd < 0)\n\t{\n\t\tqspSetError(QSP_ERR_LOCNOTFOUND);\n\t\treturn;\n\t}\n\tqspExecLocByIndex(locInd, isChangeDesc, QSP_FALSE);\n"]]}
{"hexsha": "3c731aecc4f63f114738f93c1048785c129aec24", "ext": "c", "lang": "C", "content": "static GEN\nellisograph_dummy(GEN E, long n, GEN jt, GEN jtt, GEN s0, long flag)\n{\n  GEN c4 = ell_get_c4(E), c6 = ell_get_c6(E), c6c4 = gdiv(c6, c4);\n  GEN jtp = gmul(c6c4, gdivgs(gmul(jt, jtt), -n));\n  GEN iso = ellisog_by_jt(c4, c6, jt, jtp, gmul(s0, c6c4), n, flag);\n  GEN v = mkvec2(iso, cgetg(1, t_VEC));\n  return mkvec2(ellisograph_a4a6(E, flag), mkvec(v));\n}", "item_id": 30, "repo": "timecorridor/filecoin-bridge", "file": "bridge/class-master/depend/pari/src/basemath/ellisog.c", "last_update_at": "2020-10-22T10:16:07+00:00", "question_id": "3c731aecc4f63f114738f93c1048785c129aec24_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static GEN\nellisograph_dummy(GEN E, long n, GEN jt, GEN jtt, GEN s0, long flag)\n{\n  GEN c4 = ell_get_c4(E), c6 = ell_get_c6(E), c6c4 = gdiv(c6, c4);\n  GEN jtp = gmul(c6c4, gdivgs(gmul(jt, jtt), -n));\n  GEN iso = ellisog_by_jt(c4, c6, jt, jtp, gmul(s0, c6c4), n, flag);\n  GEN v = mkvec2(iso, cgetg(1, t_VEC));\n  return mkvec2(ellisograph_a4a6(E, flag), mkvec(v));\n"]]}
{"hexsha": "2d794af3064d9b04f63e394ed9a792ae47a44a2c", "ext": "c", "lang": "C", "content": "bool obj_equals(obj* left, obj* right)\n{\n    // handle case where either or both are null\n    if (left == NULL && right == NULL) return true; // both null means both equal\n    else if (left == NULL || right == NULL)\n        return false; // left or right only null means not equal\n\n    // if the objects are of different type, then not equal\n    if (left->type != right->type) { return false; }\n\n    switch (left->type)\n    {\n        // case UIntNTuple_t: return tuple_equals(left->data, right->data);\n        // case Dictionary_t: return dict_equals((dict*)left->data, (dict*)right->data);\n        case Set_t: return set_equals((set*)left->data, (set*)right->data);\n        case CharSet_t: return charset_equals(left->data, right->data);\n        case Slot_t: return slot_equals(left->data, right->data);\n        case MetaAST_t: return metaast_equals(left->data, right->data);\n        case Slice_t: return slice_equals(left->data, right->data);\n        case CRFClusterNode_t: return crf_cluster_node_equals(left->data, right->data);\n        case CRFLabelNode_t: return crf_label_node_equals(left->data, right->data);\n        case CRFActionHead_t: return crf_action_head_equals(left->data, right->data);\n        case BSRHead_t: return bsr_head_equals(left->data, right->data);\n        case Descriptor_t: return desc_equals(left->data, right->data);\n        // case FSet_t: return fset_equals(left->data, right->data);\n        default: return obj_compare(left, right) == 0;\n    }\n\n    // TODO->make this call equals directly for sets/dictionaries, as compare will be inefficient\n}", "item_id": 5, "repo": "david-andrew/dewy-compiler-compiler", "file": "src/compiler/object.c", "last_update_at": "2020-12-09T00:45:20+00:00", "question_id": "2d794af3064d9b04f63e394ed9a792ae47a44a2c_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool obj_equals(obj* left, obj* right)\n{\n    // handle case where either or both are null\n    if (left == NULL && right == NULL) return true; // both null means both equal\n    else if (left == NULL || right == NULL)\n        return false; // left or right only null means not equal\n    // if the objects are of different type, then not equal\n    if (left->type != right->type) { return false; }\n    switch (left->type)\n    {\n        // case UIntNTuple_t: return tuple_equals(left->data, right->data);\n        // case Dictionary_t: return dict_equals((dict*)left->data, (dict*)right->data);\n        case Set_t: return set_equals((set*)left->data, (set*)right->data);\n        case CharSet_t: return charset_equals(left->data, right->data);\n        case Slot_t: return slot_equals(left->data, right->data);\n        case MetaAST_t: return metaast_equals(left->data, right->data);\n        case Slice_t: return slice_equals(left->data, right->data);\n        case CRFClusterNode_t: return crf_cluster_node_equals(left->data, right->data);\n        case CRFLabelNode_t: return crf_label_node_equals(left->data, right->data);\n        case CRFActionHead_t: return crf_action_head_equals(left->data, right->data);\n        case BSRHead_t: return bsr_head_equals(left->data, right->data);\n        case Descriptor_t: return desc_equals(left->data, right->data);\n        // case FSet_t: return fset_equals(left->data, right->data);\n        default: return obj_compare(left, right) == 0;\n    }\n    // TODO->make this call equals directly for sets/dictionaries, as compare will be inefficient\n"]]}
{"hexsha": "0b67a18e6bef9a7a056cf7196e7026d3bad949c9", "ext": "c", "lang": "C", "content": "static ssize_t\nusdf_cq_readerr(struct fid_cq *fcq, struct fi_cq_err_entry *entry,\n\t        uint64_t flags)\n{\n\tstruct usdf_cq *cq;\n\tuint32_t api_version;\n\n\tUSDF_TRACE_SYS(CQ, \"\\n\");\n\n\tcq = container_of(fcq, struct usdf_cq, cq_fid);\n\tapi_version = cq->cq_domain->dom_fabric->fab_attr.fabric->api_version;\n\n\t// The return values are analogous to sockets cq_readerr\n\tif (cq->cq_comp.uc_status == 0) {\n\t\treturn -FI_EAGAIN;\n\t}\n\n\tentry->op_context = cq->cq_comp.uc_context;\n\tentry->flags = 0;\n\tswitch (cq->cq_comp.uc_status) {\n\tcase USD_COMPSTAT_SUCCESS:\n\t\tentry->prov_errno = FI_SUCCESS;\n\t\tbreak;\n\tcase USD_COMPSTAT_ERROR_CRC:\n\t\tentry->prov_errno = FI_ECRC;\n\t\tbreak;\n\tcase USD_COMPSTAT_ERROR_TRUNC:\n\t\tentry->prov_errno = FI_ETRUNC;\n\t\tbreak;\n\tcase USD_COMPSTAT_ERROR_TIMEOUT:\n\t\tentry->prov_errno = FI_ETIMEDOUT;\n\t\tbreak;\n\tcase USD_COMPSTAT_ERROR_INTERNAL:\n\tdefault:\n\t\tentry->prov_errno = FI_EOTHER;\n\t\tbreak;\n\t}\n\tentry->err = entry->prov_errno;\n\n\tcq->cq_comp.uc_status = 0;\n\n\t/* We don't have err_data to give back to the user. */\n\tif (FI_VERSION_GE(api_version, FI_VERSION(1, 5)))\n\t\tentry->err_data_size = 0;\n\n\treturn 1;\n}", "item_id": 0, "repo": "ucd-plse/mpi-error-prop", "file": "mpich-3.3/src/mpid/ch4/netmod/ofi/libfabric/prov/usnic/src/usdf_cq.c", "last_update_at": "2020-07-17T04:14:25+00:00", "question_id": "0b67a18e6bef9a7a056cf7196e7026d3bad949c9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static ssize_t\nusdf_cq_readerr(struct fid_cq *fcq, struct fi_cq_err_entry *entry,\n\t        uint64_t flags)\n{\n\tstruct usdf_cq *cq;\n\tuint32_t api_version;\n\tUSDF_TRACE_SYS(CQ, \"\\n\");\n\tcq = container_of(fcq, struct usdf_cq, cq_fid);\n\tapi_version = cq->cq_domain->dom_fabric->fab_attr.fabric->api_version;\n\t// The return values are analogous to sockets cq_readerr\n\tif (cq->cq_comp.uc_status == 0) {\n\t\treturn -FI_EAGAIN;\n\t}\n\tentry->op_context = cq->cq_comp.uc_context;\n\tentry->flags = 0;\n\tswitch (cq->cq_comp.uc_status) {\n\tcase USD_COMPSTAT_SUCCESS:\n\t\tentry->prov_errno = FI_SUCCESS;\n\t\tbreak;\n\tcase USD_COMPSTAT_ERROR_CRC:\n\t\tentry->prov_errno = FI_ECRC;\n\t\tbreak;\n\tcase USD_COMPSTAT_ERROR_TRUNC:\n\t\tentry->prov_errno = FI_ETRUNC;\n\t\tbreak;\n\tcase USD_COMPSTAT_ERROR_TIMEOUT:\n\t\tentry->prov_errno = FI_ETIMEDOUT;\n\t\tbreak;\n\tcase USD_COMPSTAT_ERROR_INTERNAL:\n\tdefault:\n\t\tentry->prov_errno = FI_EOTHER;\n\t\tbreak;\n\t}\n\tentry->err = entry->prov_errno;\n\tcq->cq_comp.uc_status = 0;\n\t/* We don't have err_data to give back to the user. */\n\tif (FI_VERSION_GE(api_version, FI_VERSION(1, 5)))\n\t\tentry->err_data_size = 0;\n\treturn 1;\n"]]}
{"hexsha": "35762ddd01ef86d2437846d5c8ca1a2414c3ab6f", "ext": "c", "lang": "C", "content": "SYX_FUNC_PRIMITIVE(Gtk_g_value_take_object)\n{\n  GValue *arg1 = (GValue *) 0 ;\n  gpointer arg2 = (gpointer) 0 ;\n  SyxOop result_oop;\n  \n  SWIG_FIRST_SELF(arg1, GValue *, es->message_receiver)\n  SWIG_FIRST_SELF(arg2, gpointer, es->message_arguments[0])\n  g_value_take_object(arg1,arg2);\n  SWIG_APPEND_VALUE (es->message_receiver);\n  SYX_PRIM_RETURN (result_oop);\n}", "item_id": 268, "repo": "BackupTheBerlios/syx", "file": "plugins/gtk/gtk_wrap.c", "last_update_at": "2020-09-21T11:28:13+00:00", "question_id": "35762ddd01ef86d2437846d5c8ca1a2414c3ab6f_268", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["SYX_FUNC_PRIMITIVE(Gtk_g_value_take_object)\n{\n  GValue *arg1 = (GValue *) 0 ;\n  gpointer arg2 = (gpointer) 0 ;\n  SyxOop result_oop;\n  SWIG_FIRST_SELF(arg1, GValue *, es->message_receiver)\n  SWIG_FIRST_SELF(arg2, gpointer, es->message_arguments[0])\n  g_value_take_object(arg1,arg2);\n  SWIG_APPEND_VALUE (es->message_receiver);\n  SYX_PRIM_RETURN (result_oop);\n"]]}
{"hexsha": "236125b624a1c7e091fece738ff2d18761d0668a", "ext": "c", "lang": "C", "content": "static int max326_setup(struct uart_dev_s *dev)\n{\n#ifndef CONFIG_SUPPRESS_UART_CONFIG\n  struct max326_dev_s *priv = (struct max326_dev_s *)dev->priv;\n\n  /* Configure the UART as an RS-232 UART */\n\n  max326_uart_configure(priv->uartbase, &priv->config);\n#endif\n\n  /* Make sure that all interrupts are disabled */\n\n  max326_int_disableall(priv, NULL);\n  return OK;\n}", "item_id": 4, "repo": "huahang/incubator-nuttx", "file": "arch/arm/src/max326xx/max32660/max32660_serial.c", "last_update_at": "2020-07-02T22:38:02+00:00", "question_id": "236125b624a1c7e091fece738ff2d18761d0668a_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int max326_setup(struct uart_dev_s *dev)\n{\n#ifndef CONFIG_SUPPRESS_UART_CONFIG\n  struct max326_dev_s *priv = (struct max326_dev_s *)dev->priv;\n  /* Configure the UART as an RS-232 UART */\n  max326_uart_configure(priv->uartbase, &priv->config);\n#endif\n  /* Make sure that all interrupts are disabled */\n  max326_int_disableall(priv, NULL);\n  return OK;\n"]]}
{"hexsha": "685c4514e7472e2887ba06ef14caa4562691234c", "ext": "c", "lang": "C", "content": "gceSTATUS\ngcoOS_QueryVideoMemory(\n    IN gcoOS Os,\n    OUT gctPHYS_ADDR * InternalAddress,\n    OUT gctSIZE_T * InternalSize,\n    OUT gctPHYS_ADDR * ExternalAddress,\n    OUT gctSIZE_T * ExternalSize,\n    OUT gctPHYS_ADDR * ContiguousAddress,\n    OUT gctSIZE_T * ContiguousSize\n    )\n{\n    gceSTATUS status;\n    gcsHAL_INTERFACE iface;\n\n    gcmHEADER();\n\n        /* Call kernel HAL to query video memory. */\n    iface.command = gcvHAL_QUERY_VIDEO_MEMORY;\n\n        /* Call kernel service. */\n    gcmONERROR(gcoOS_DeviceControl(gcvNULL,\n            IOCTL_GCHAL_INTERFACE,\n                                   &iface, gcmSIZEOF(iface),\n                                   &iface, gcmSIZEOF(iface)));\n\n        if (InternalAddress != gcvNULL)\n        {\n            /* Verify arguments. */\n            gcmVERIFY_ARGUMENT(InternalSize != gcvNULL);\n\n            /* Save internal memory size. */\n        *InternalAddress = gcmINT2PTR(iface.u.QueryVideoMemory.internalPhysical);\n        *InternalSize    = (gctSIZE_T) iface.u.QueryVideoMemory.internalSize;\n        }\n\n        if (ExternalAddress != gcvNULL)\n        {\n            /* Verify arguments. */\n            gcmVERIFY_ARGUMENT(ExternalSize != gcvNULL);\n\n            /* Save external memory size. */\n        *ExternalAddress = gcmINT2PTR(iface.u.QueryVideoMemory.externalPhysical);\n        *ExternalSize    = (gctSIZE_T) iface.u.QueryVideoMemory.externalSize;\n        }\n\n        if (ContiguousAddress != gcvNULL)\n        {\n            /* Verify arguments. */\n            gcmVERIFY_ARGUMENT(ContiguousSize != gcvNULL);\n\n            /* Save contiguous memory size. */\n        *ContiguousAddress = gcmINT2PTR(iface.u.QueryVideoMemory.contiguousPhysical);\n        *ContiguousSize    = (gctSIZE_T) iface.u.QueryVideoMemory.contiguousSize;\n        }\n\n    /* Success. */\n    gcmFOOTER_ARG(\"*InternalAddress=0x%08x *InternalSize=%lu \"\n                  \"*ExternalAddress=0x%08x *ExternalSize=%lu \"\n                  \"*ContiguousAddress=0x%08x *ContiguousSize=%lu\",\n                  gcmOPT_VALUE(InternalAddress), gcmOPT_VALUE(InternalSize),\n                  gcmOPT_VALUE(ExternalAddress), gcmOPT_VALUE(ExternalSize),\n                  gcmOPT_VALUE(ContiguousAddress),\n                  gcmOPT_VALUE(ContiguousSize));\n    return gcvSTATUS_OK;\n\nOnError:\n    /* Return the status. */\n    gcmFOOTER();\n    return status;\n}", "item_id": 11, "repo": "NightOfTwelve/android_device_huawei_hwp7", "file": "kernel/huawei/hwp7/drivers/misc/gpu_drv/hal/os/ce/user/gc_hal_user_os.c", "last_update_at": "2020-04-03T14:00:34+00:00", "question_id": "685c4514e7472e2887ba06ef14caa4562691234c_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["gceSTATUS\ngcoOS_QueryVideoMemory(\n    IN gcoOS Os,\n    OUT gctPHYS_ADDR * InternalAddress,\n    OUT gctSIZE_T * InternalSize,\n    OUT gctPHYS_ADDR * ExternalAddress,\n    OUT gctSIZE_T * ExternalSize,\n    OUT gctPHYS_ADDR * ContiguousAddress,\n    OUT gctSIZE_T * ContiguousSize\n    )\n{\n    gceSTATUS status;\n    gcsHAL_INTERFACE iface;\n    gcmHEADER();\n        /* Call kernel HAL to query video memory. */\n    iface.command = gcvHAL_QUERY_VIDEO_MEMORY;\n        /* Call kernel service. */\n    gcmONERROR(gcoOS_DeviceControl(gcvNULL,\n            IOCTL_GCHAL_INTERFACE,\n                                   &iface, gcmSIZEOF(iface),\n                                   &iface, gcmSIZEOF(iface)));\n        if (InternalAddress != gcvNULL)\n        {\n            /* Verify arguments. */\n            gcmVERIFY_ARGUMENT(InternalSize != gcvNULL);\n            /* Save internal memory size. */\n        *InternalAddress = gcmINT2PTR(iface.u.QueryVideoMemory.internalPhysical);\n        *InternalSize    = (gctSIZE_T) iface.u.QueryVideoMemory.internalSize;\n        }\n        if (ExternalAddress != gcvNULL)\n        {\n            /* Verify arguments. */\n            gcmVERIFY_ARGUMENT(ExternalSize != gcvNULL);\n            /* Save external memory size. */\n        *ExternalAddress = gcmINT2PTR(iface.u.QueryVideoMemory.externalPhysical);\n        *ExternalSize    = (gctSIZE_T) iface.u.QueryVideoMemory.externalSize;\n        }\n        if (ContiguousAddress != gcvNULL)\n        {\n            /* Verify arguments. */\n            gcmVERIFY_ARGUMENT(ContiguousSize != gcvNULL);\n            /* Save contiguous memory size. */\n        *ContiguousAddress = gcmINT2PTR(iface.u.QueryVideoMemory.contiguousPhysical);\n        *ContiguousSize    = (gctSIZE_T) iface.u.QueryVideoMemory.contiguousSize;\n        }\n    /* Success. */\n    gcmFOOTER_ARG(\"*InternalAddress=0x%08x *InternalSize=%lu \"\n                  \"*ExternalAddress=0x%08x *ExternalSize=%lu \"\n                  \"*ContiguousAddress=0x%08x *ContiguousSize=%lu\",\n                  gcmOPT_VALUE(InternalAddress), gcmOPT_VALUE(InternalSize),\n                  gcmOPT_VALUE(ExternalAddress), gcmOPT_VALUE(ExternalSize),\n                  gcmOPT_VALUE(ContiguousAddress),\n                  gcmOPT_VALUE(ContiguousSize));\n    return gcvSTATUS_OK;\nOnError:\n    /* Return the status. */\n    gcmFOOTER();\n    return status;\n"]]}
{"hexsha": "2013dc830e83b495362ba0c06aa44b17c37d556f", "ext": "c", "lang": "C", "content": "static int vrtimer_cb(timer_comp_t *tcomp, void *data) {\n    vrtimer_comp_t *vrt = (vrtimer_comp_t *) data;\n    vrtimer_t *pos;\n    vrtimer_t *tmp;\n\n    abstick_t curticks;\n    if (vrt->hrtimer->ops.get_value(vrt->hrtimer, &curticks) < 0) {\n        error_async(\"Failed to read hrtimer value\");\n        return -1;\n    }\n\n    irqctx_t ctx;\n    spinlock_acquire(&vrt->lock, &ctx);\n\n    list_for_each_entry_safe(pos, tmp, &vrt->timers, list) {\n        if (curticks >= pos->abs_ticks) {\n            insane_async(\"vrtimer id=0x%p abs_ticks=%lu expired\", pos, (uint32_t) pos->abs_ticks);\n\n            // Execute timer callback\n            if (pos->cb(vrt, pos->data) < 0) {\n                error_async(\"Error while executing vrtimer callback at 0x%p\", pos->cb);\n            }\n\n            list_del_init(&pos->list);\n            if (pos->periodic) {\n                pos->abs_ticks = curticks + pos->ticks;\n                add_vrtimer_sorted_locked(vrt, pos);\n            } else {\n                free(pos);\n            }\n        } else {\n            break;\n        }\n    }\n\n    update_expiration_locked(vrt);\n\n    spinlock_release(&vrt->lock, &ctx);\n\n    return 0;\n}", "item_id": 2, "repo": "lzungri/laritos", "file": "core/component/vrtimer.c", "last_update_at": "2020-06-12T08:32:47+00:00", "question_id": "2013dc830e83b495362ba0c06aa44b17c37d556f_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int vrtimer_cb(timer_comp_t *tcomp, void *data) {\n    vrtimer_comp_t *vrt = (vrtimer_comp_t *) data;\n    vrtimer_t *pos;\n    vrtimer_t *tmp;\n    abstick_t curticks;\n    if (vrt->hrtimer->ops.get_value(vrt->hrtimer, &curticks) < 0) {\n        error_async(\"Failed to read hrtimer value\");\n        return -1;\n    }\n    irqctx_t ctx;\n    spinlock_acquire(&vrt->lock, &ctx);\n    list_for_each_entry_safe(pos, tmp, &vrt->timers, list) {\n        if (curticks >= pos->abs_ticks) {\n            insane_async(\"vrtimer id=0x%p abs_ticks=%lu expired\", pos, (uint32_t) pos->abs_ticks);\n            // Execute timer callback\n            if (pos->cb(vrt, pos->data) < 0) {\n                error_async(\"Error while executing vrtimer callback at 0x%p\", pos->cb);\n            }\n            list_del_init(&pos->list);\n            if (pos->periodic) {\n                pos->abs_ticks = curticks + pos->ticks;\n                add_vrtimer_sorted_locked(vrt, pos);\n            } else {\n                free(pos);\n            }\n        } else {\n            break;\n        }\n    }\n    update_expiration_locked(vrt);\n    spinlock_release(&vrt->lock, &ctx);\n    return 0;\n"]]}
{"hexsha": "96007633ad39b2e266fbc66c34e9eaf40a72ed1e", "ext": "c", "lang": "C", "content": "int megasas_wait_for_outstanding_fusion(struct megasas_instance *instance,\n\t\t\t\t\tint iotimeout, int *convert)\n{\n\tint i, outstanding, retval = 0, hb_seconds_missed = 0;\n\tu32 fw_state;\n\n\tfor (i = 0; i < resetwaittime; i++) {\n\t\t/* Check if firmware is in fault state */\n\t\tfw_state = instance->instancet->read_fw_status_reg(\n\t\t\tinstance->reg_set) & MFI_STATE_MASK;\n\t\tif (fw_state == MFI_STATE_FAULT) {\n\t\t\tdev_warn(&instance->pdev->dev, \"Found FW in FAULT state,\"\n\t\t\t       \" will reset adapter scsi%d.\\n\",\n\t\t\t\tinstance->host->host_no);\n\t\t\tretval = 1;\n\t\t\tgoto out;\n\t\t}\n\t\t/* If SR-IOV VF mode & heartbeat timeout, don't wait */\n\t\tif (instance->requestorId && !iotimeout) {\n\t\t\tretval = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* If SR-IOV VF mode & I/O timeout, check for HB timeout */\n\t\tif (instance->requestorId && iotimeout) {\n\t\t\tif (instance->hb_host_mem->HB.fwCounter !=\n\t\t\t    instance->hb_host_mem->HB.driverCounter) {\n\t\t\t\tinstance->hb_host_mem->HB.driverCounter =\n\t\t\t\t\tinstance->hb_host_mem->HB.fwCounter;\n\t\t\t\thb_seconds_missed = 0;\n\t\t\t} else {\n\t\t\t\thb_seconds_missed++;\n\t\t\t\tif (hb_seconds_missed ==\n\t\t\t\t    (MEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF/HZ)) {\n\t\t\t\t\tdev_warn(&instance->pdev->dev, \"SR-IOV:\"\n\t\t\t\t\t       \" Heartbeat never completed \"\n\t\t\t\t\t       \" while polling during I/O \"\n\t\t\t\t\t       \" timeout handling for \"\n\t\t\t\t\t       \"scsi%d.\\n\",\n\t\t\t\t\t       instance->host->host_no);\n\t\t\t\t\t       *convert = 1;\n\t\t\t\t\t       retval = 1;\n\t\t\t\t\t       goto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\toutstanding = atomic_read(&instance->fw_outstanding);\n\t\tif (!outstanding)\n\t\t\tgoto out;\n\n\t\tif (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {\n\t\t\tdev_notice(&instance->pdev->dev, \"[%2d]waiting for %d \"\n\t\t\t       \"commands to complete for scsi%d\\n\", i,\n\t\t\t       outstanding, instance->host->host_no);\n\t\t\tmegasas_complete_cmd_dpc_fusion(\n\t\t\t\t(unsigned long)instance);\n\t\t}\n\t\tmsleep(1000);\n\t}\n\n\tif (atomic_read(&instance->fw_outstanding)) {\n\t\tdev_err(&instance->pdev->dev, \"pending commands remain after waiting, \"\n\t\t       \"will reset adapter scsi%d.\\n\",\n\t\t       instance->host->host_no);\n\t\t*convert = 1;\n\t\tretval = 1;\n\t}\nout:\n\treturn retval;\n}", "item_id": 33, "repo": "hashnfv/hashnfv-kvmfornfv", "file": "kernel/drivers/scsi/megaraid/megaraid_sas_fusion.c", "last_update_at": "2020-09-03T09:19:01+00:00", "question_id": "96007633ad39b2e266fbc66c34e9eaf40a72ed1e_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int megasas_wait_for_outstanding_fusion(struct megasas_instance *instance,\n\t\t\t\t\tint iotimeout, int *convert)\n{\n\tint i, outstanding, retval = 0, hb_seconds_missed = 0;\n\tu32 fw_state;\n\tfor (i = 0; i < resetwaittime; i++) {\n\t\t/* Check if firmware is in fault state */\n\t\tfw_state = instance->instancet->read_fw_status_reg(\n\t\t\tinstance->reg_set) & MFI_STATE_MASK;\n\t\tif (fw_state == MFI_STATE_FAULT) {\n\t\t\tdev_warn(&instance->pdev->dev, \"Found FW in FAULT state,\"\n\t\t\t       \" will reset adapter scsi%d.\\n\",\n\t\t\t\tinstance->host->host_no);\n\t\t\tretval = 1;\n\t\t\tgoto out;\n\t\t}\n\t\t/* If SR-IOV VF mode & heartbeat timeout, don't wait */\n\t\tif (instance->requestorId && !iotimeout) {\n\t\t\tretval = 1;\n\t\t\tgoto out;\n\t\t}\n\t\t/* If SR-IOV VF mode & I/O timeout, check for HB timeout */\n\t\tif (instance->requestorId && iotimeout) {\n\t\t\tif (instance->hb_host_mem->HB.fwCounter !=\n\t\t\t    instance->hb_host_mem->HB.driverCounter) {\n\t\t\t\tinstance->hb_host_mem->HB.driverCounter =\n\t\t\t\t\tinstance->hb_host_mem->HB.fwCounter;\n\t\t\t\thb_seconds_missed = 0;\n\t\t\t} else {\n\t\t\t\thb_seconds_missed++;\n\t\t\t\tif (hb_seconds_missed ==\n\t\t\t\t    (MEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF/HZ)) {\n\t\t\t\t\tdev_warn(&instance->pdev->dev, \"SR-IOV:\"\n\t\t\t\t\t       \" Heartbeat never completed \"\n\t\t\t\t\t       \" while polling during I/O \"\n\t\t\t\t\t       \" timeout handling for \"\n\t\t\t\t\t       \"scsi%d.\\n\",\n\t\t\t\t\t       instance->host->host_no);\n\t\t\t\t\t       *convert = 1;\n\t\t\t\t\t       retval = 1;\n\t\t\t\t\t       goto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toutstanding = atomic_read(&instance->fw_outstanding);\n\t\tif (!outstanding)\n\t\t\tgoto out;\n\t\tif (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {\n\t\t\tdev_notice(&instance->pdev->dev, \"[%2d]waiting for %d \"\n\t\t\t       \"commands to complete for scsi%d\\n\", i,\n\t\t\t       outstanding, instance->host->host_no);\n\t\t\tmegasas_complete_cmd_dpc_fusion(\n\t\t\t\t(unsigned long)instance);\n\t\t}\n\t\tmsleep(1000);\n\t}\n\tif (atomic_read(&instance->fw_outstanding)) {\n\t\tdev_err(&instance->pdev->dev, \"pending commands remain after waiting, \"\n\t\t       \"will reset adapter scsi%d.\\n\",\n\t\t       instance->host->host_no);\n\t\t*convert = 1;\n\t\tretval = 1;\n\t}\nout:\n\treturn retval;\n"]]}
{"hexsha": "02207e092773898d9877205d10919c290864086b", "ext": "c", "lang": "C", "content": "static ngx_int_t ngx_http_redirectionio_create_ctx_handler(ngx_http_request_t *r) {\n    ngx_http_redirectionio_ctx_t    *ctx;\n    ngx_http_redirectionio_conf_t   *conf;\n    ngx_pool_cleanup_t              *cln;\n\n    // Disallow in sub request\n    if (r != r->main) {\n        return NGX_DECLINED;\n    }\n\n    conf = ngx_http_get_module_loc_conf(r, ngx_http_redirectionio_module);\n\n    if (conf->enable == NGX_HTTP_REDIRECTIONIO_OFF) {\n        return NGX_DECLINED;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_redirectionio_module);\n\n    if (ctx == NULL) {\n        ctx = (ngx_http_redirectionio_ctx_t *) ngx_pcalloc(r->pool, sizeof(ngx_http_redirectionio_ctx_t));\n\n        if (ctx == NULL) {\n            return NGX_DECLINED;\n        }\n\n        ctx->resource = NULL;\n        ctx->matched_action_status = API_NOT_CALLED;\n        ctx->request = NULL;\n        ctx->action = NULL;\n        ctx->response_headers = NULL;\n        ctx->body_filter = NULL;\n        ctx->action_string = NULL;\n        ctx->action_string_len = 0;\n        ctx->action_string_readed = 0;\n        ctx->connection_error = 0;\n        ctx->wait_for_connection = 0;\n        ctx->last_buffer_sent = 0;\n        ctx->read_handler = ngx_http_redirectionio_read_dummy_handler;\n        ctx->project_key.len = 0;\n        ctx->scheme.len = 0;\n        ctx->host.len = 0;\n\n        if (ngx_http_complex_value(r, conf->project_key, &ctx->project_key) != NGX_OK) {\n            return NGX_DECLINED;\n        }\n\n        if (conf->scheme != NULL && ngx_http_complex_value(r, conf->scheme, &ctx->scheme) != NGX_OK) {\n            return NGX_DECLINED;\n        }\n\n        if (conf->host != NULL && ngx_http_complex_value(r, conf->host, &ctx->host) != NGX_OK) {\n            return NGX_DECLINED;\n        }\n\n        cln = ngx_pool_cleanup_add(r->pool, 0);\n\n        if (cln == NULL) {\n            return NGX_DECLINED;\n        }\n\n        cln->data = ctx;\n        cln->handler = ngx_http_redirectionio_context_cleanup;\n\n        ngx_http_set_ctx(r, ctx, ngx_http_redirectionio_module);\n\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"http redirectionio init context\");\n\n        redirectionio_log_init_with_callback(ngx_http_redirectionio_log_callback, r->connection->log);\n    }\n\n    return NGX_DECLINED;\n}", "item_id": 1, "repo": "redirectionio/libnginx-mod-redirectionio", "file": "src/ngx_http_redirectionio_module.c", "last_update_at": "2020-12-29T21:29:26+00:00", "question_id": "02207e092773898d9877205d10919c290864086b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static ngx_int_t ngx_http_redirectionio_create_ctx_handler(ngx_http_request_t *r) {\n    ngx_http_redirectionio_ctx_t    *ctx;\n    ngx_http_redirectionio_conf_t   *conf;\n    ngx_pool_cleanup_t              *cln;\n    // Disallow in sub request\n    if (r != r->main) {\n        return NGX_DECLINED;\n    }\n    conf = ngx_http_get_module_loc_conf(r, ngx_http_redirectionio_module);\n    if (conf->enable == NGX_HTTP_REDIRECTIONIO_OFF) {\n        return NGX_DECLINED;\n    }\n    ctx = ngx_http_get_module_ctx(r, ngx_http_redirectionio_module);\n    if (ctx == NULL) {\n        ctx = (ngx_http_redirectionio_ctx_t *) ngx_pcalloc(r->pool, sizeof(ngx_http_redirectionio_ctx_t));\n        if (ctx == NULL) {\n            return NGX_DECLINED;\n        }\n        ctx->resource = NULL;\n        ctx->matched_action_status = API_NOT_CALLED;\n        ctx->request = NULL;\n        ctx->action = NULL;\n        ctx->response_headers = NULL;\n        ctx->body_filter = NULL;\n        ctx->action_string = NULL;\n        ctx->action_string_len = 0;\n        ctx->action_string_readed = 0;\n        ctx->connection_error = 0;\n        ctx->wait_for_connection = 0;\n        ctx->last_buffer_sent = 0;\n        ctx->read_handler = ngx_http_redirectionio_read_dummy_handler;\n        ctx->project_key.len = 0;\n        ctx->scheme.len = 0;\n        ctx->host.len = 0;\n        if (ngx_http_complex_value(r, conf->project_key, &ctx->project_key) != NGX_OK) {\n            return NGX_DECLINED;\n        }\n        if (conf->scheme != NULL && ngx_http_complex_value(r, conf->scheme, &ctx->scheme) != NGX_OK) {\n            return NGX_DECLINED;\n        }\n        if (conf->host != NULL && ngx_http_complex_value(r, conf->host, &ctx->host) != NGX_OK) {\n            return NGX_DECLINED;\n        }\n        cln = ngx_pool_cleanup_add(r->pool, 0);\n        if (cln == NULL) {\n            return NGX_DECLINED;\n        }\n        cln->data = ctx;\n        cln->handler = ngx_http_redirectionio_context_cleanup;\n        ngx_http_set_ctx(r, ctx, ngx_http_redirectionio_module);\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"http redirectionio init context\");\n        redirectionio_log_init_with_callback(ngx_http_redirectionio_log_callback, r->connection->log);\n    }\n    return NGX_DECLINED;\n"]]}
{"hexsha": "307259e10a319785c9ef9274f80d2ddda83728e3", "ext": "c", "lang": "C", "content": "void uart0_send_uint32_hex(uint32_t number)\n{\n    char buf[9];\n    uint32_to_cstring(number, buf, 16, 8);\n    uart0_send_cstring(buf);\n}", "item_id": 4, "repo": "DD1984/nrf24l01-rc", "file": "lpc812-nrf24l01-receiver/firmware/uart0.c", "last_update_at": "2020-05-23T09:14:36+00:00", "question_id": "307259e10a319785c9ef9274f80d2ddda83728e3_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void uart0_send_uint32_hex(uint32_t number)\n{\n    char buf[9];\n    uint32_to_cstring(number, buf, 16, 8);\n    uart0_send_cstring(buf);\n"]]}
{"hexsha": "7066b83cc134de1593a07a85c535e734ada513c4", "ext": "c", "lang": "C", "content": "bagError bagGetNumSurfaceCorrectors  (bagHandle hnd_opt, u32 *num)\n{\n    hid_t          typenow;\n    hsize_t        adims[] = {0,0};\n    bagError       err;\n    int            inx;\n    \n    *num = 0;\n\n    if (hnd_opt == NULL)\n        return BAG_INVALID_BAG_HANDLE;\n\n    /*! Access the \"z\" member of the datatype */\n    inx = H5Tget_member_index (hnd_opt->opt_datatype_id[Surface_Correction], \"z\");\n    typenow = H5Tget_member_type (hnd_opt->opt_datatype_id[Surface_Correction], inx );\n\n    if (typenow < 0)\n        return BAG_HDF_TYPE_NOT_FOUND;\n\n    /*! Now dimension of the \"z\" array is obtained */\n    err = H5Tget_array_dims( typenow, adims, NULL );\n    if (err > 0)\n    {\n        *num  = (u32)adims[1];\n        return BAG_SUCCESS;\n    }\n    else\n    {\n        *num = 0;\n        return BAG_HDF_TYPE_NOT_FOUND;\n    }\n}", "item_id": 1, "repo": "Sammie-Jo/MergeBathy_Repos-MergeBathy_CPP", "file": "api/bag_surface_correct.c", "last_update_at": "2020-07-30T03:52:07+00:00", "question_id": "7066b83cc134de1593a07a85c535e734ada513c4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bagError bagGetNumSurfaceCorrectors  (bagHandle hnd_opt, u32 *num)\n{\n    hid_t          typenow;\n    hsize_t        adims[] = {0,0};\n    bagError       err;\n    int            inx;\n    *num = 0;\n    if (hnd_opt == NULL)\n        return BAG_INVALID_BAG_HANDLE;\n    /*! Access the \"z\" member of the datatype */\n    inx = H5Tget_member_index (hnd_opt->opt_datatype_id[Surface_Correction], \"z\");\n    typenow = H5Tget_member_type (hnd_opt->opt_datatype_id[Surface_Correction], inx );\n    if (typenow < 0)\n        return BAG_HDF_TYPE_NOT_FOUND;\n    /*! Now dimension of the \"z\" array is obtained */\n    err = H5Tget_array_dims( typenow, adims, NULL );\n    if (err > 0)\n    {\n        *num  = (u32)adims[1];\n        return BAG_SUCCESS;\n    }\n    else\n    {\n        *num = 0;\n        return BAG_HDF_TYPE_NOT_FOUND;\n    }\n"]]}
{"hexsha": "b20716700009f4c612b392955b4b7711defc3489", "ext": "c", "lang": "C", "content": "SWIGINTERN PyObject *_wrap_svn_repos_verify_fs2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {\n  PyObject *resultobj = 0;\n  svn_repos_t *arg1 = (svn_repos_t *) 0 ;\n  svn_revnum_t arg2 ;\n  svn_revnum_t arg3 ;\n  svn_repos_notify_func_t arg4 = (svn_repos_notify_func_t) 0 ;\n  void *arg5 = (void *) 0 ;\n  svn_cancel_func_t arg6 = (svn_cancel_func_t) 0 ;\n  void *arg7 = (void *) 0 ;\n  apr_pool_t *arg8 = (apr_pool_t *) 0 ;\n  apr_pool_t *_global_pool = NULL ;\n  PyObject *_global_py_pool = NULL ;\n  PyObject * obj0 = 0 ;\n  PyObject * obj1 = 0 ;\n  PyObject * obj2 = 0 ;\n  PyObject * obj3 = 0 ;\n  PyObject * obj4 = 0 ;\n  PyObject * obj5 = 0 ;\n  PyObject * obj6 = 0 ;\n  PyObject * obj7 = 0 ;\n  svn_error_t *result = 0 ;\n  \n  if (svn_swig_py_get_pool_arg(args, SWIGTYPE_p_apr_pool_t,\n      &_global_py_pool, &_global_pool))\n  SWIG_fail;\n  arg8 = _global_pool;\n  if (!PyArg_ParseTuple(args,(char *)\"OOOOOOO|O:svn_repos_verify_fs2\",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;\n  {\n    arg1 = (svn_repos_t *)svn_swig_MustGetPtr(obj0, SWIGTYPE_p_svn_repos_t, svn_argnum_obj0);\n    if (PyErr_Occurred()) {\n      SWIG_fail;\n    }\n  }\n  {\n    arg2 = (svn_revnum_t)SWIG_As_long (obj1);\n    if (SWIG_arg_fail(svn_argnum_obj1)) {\n      SWIG_fail;\n    }\n  }\n  {\n    arg3 = (svn_revnum_t)SWIG_As_long (obj2);\n    if (SWIG_arg_fail(svn_argnum_obj2)) {\n      SWIG_fail;\n    }\n  }\n  {\n    svn_repos_notify_func_t * tmp =\n    svn_swig_MustGetPtr(obj3, SWIGTYPE_p_p_f_p_void_p_q_const__struct_svn_repos_notify_t_p_apr_pool_t__void, svn_argnum_obj3);\n    if (tmp == NULL || PyErr_Occurred()) {\n      SWIG_fail;\n    }\n    arg4 = *tmp;\n  }\n  {\n    if (obj4 == Py_None) {\n      arg5 = NULL;\n    } else if (SWIG_ConvertPtr(obj4, (void **) &arg5, 0, 0) == -1) {\n      arg5 = (void *) obj4;\n      PyErr_Clear();\n    }\n  }\n  {\n    svn_cancel_func_t * tmp =\n    svn_swig_MustGetPtr(obj5, SWIGTYPE_p_p_f_p_void__p_svn_error_t, svn_argnum_obj5);\n    if (tmp == NULL || PyErr_Occurred()) {\n      SWIG_fail;\n    }\n    arg6 = *tmp;\n  }\n  {\n    if (obj6 == Py_None) {\n      arg7 = NULL;\n    } else if (SWIG_ConvertPtr(obj6, (void **) &arg7, 0, 0) == -1) {\n      arg7 = (void *) obj6;\n      PyErr_Clear();\n    }\n  }\n  if (obj7) {\n    /* Verify that the user supplied a valid pool */\n    if (obj7 != Py_None && obj7 != _global_py_pool) {\n      SWIG_Python_TypeError(SWIG_TypePrettyName(SWIGTYPE_p_apr_pool_t), obj7);\n      SWIG_arg_fail(svn_argnum_obj7);\n      SWIG_fail;\n    }\n  }\n  {\n    svn_swig_py_release_py_lock();\n    \n    result = (svn_error_t *)svn_repos_verify_fs2(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);\n    \n    svn_swig_py_acquire_py_lock();\n    \n  }\n  {\n    if (result != NULL) {\n      if (result->apr_err != SVN_ERR_SWIG_PY_EXCEPTION_SET)\n      svn_swig_py_svn_exception(result);\n      else\n      svn_error_clear(result);\n      SWIG_fail;\n    }\n    Py_INCREF(Py_None);\n    resultobj = Py_None;\n  }\n  {\n    Py_XDECREF(_global_py_pool);\n  }\n  return resultobj;\nfail:\n  {\n    Py_XDECREF(_global_py_pool);\n  }\n  return NULL;\n}", "item_id": 186, "repo": "tux-mind/platform_external_subversion", "file": "subversion/bindings/swig/python/svn_repos.c", "last_update_at": "2020-11-04T07:17:20+00:00", "question_id": "b20716700009f4c612b392955b4b7711defc3489_186", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["SWIGINTERN PyObject *_wrap_svn_repos_verify_fs2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {\n  PyObject *resultobj = 0;\n  svn_repos_t *arg1 = (svn_repos_t *) 0 ;\n  svn_revnum_t arg2 ;\n  svn_revnum_t arg3 ;\n  svn_repos_notify_func_t arg4 = (svn_repos_notify_func_t) 0 ;\n  void *arg5 = (void *) 0 ;\n  svn_cancel_func_t arg6 = (svn_cancel_func_t) 0 ;\n  void *arg7 = (void *) 0 ;\n  apr_pool_t *arg8 = (apr_pool_t *) 0 ;\n  apr_pool_t *_global_pool = NULL ;\n  PyObject *_global_py_pool = NULL ;\n  PyObject * obj0 = 0 ;\n  PyObject * obj1 = 0 ;\n  PyObject * obj2 = 0 ;\n  PyObject * obj3 = 0 ;\n  PyObject * obj4 = 0 ;\n  PyObject * obj5 = 0 ;\n  PyObject * obj6 = 0 ;\n  PyObject * obj7 = 0 ;\n  svn_error_t *result = 0 ;\n  if (svn_swig_py_get_pool_arg(args, SWIGTYPE_p_apr_pool_t,\n      &_global_py_pool, &_global_pool))\n  SWIG_fail;\n  arg8 = _global_pool;\n  if (!PyArg_ParseTuple(args,(char *)\"OOOOOOO|O:svn_repos_verify_fs2\",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;\n  {\n    arg1 = (svn_repos_t *)svn_swig_MustGetPtr(obj0, SWIGTYPE_p_svn_repos_t, svn_argnum_obj0);\n    if (PyErr_Occurred()) {\n      SWIG_fail;\n    }\n  }\n  {\n    arg2 = (svn_revnum_t)SWIG_As_long (obj1);\n    if (SWIG_arg_fail(svn_argnum_obj1)) {\n      SWIG_fail;\n    }\n  }\n  {\n    arg3 = (svn_revnum_t)SWIG_As_long (obj2);\n    if (SWIG_arg_fail(svn_argnum_obj2)) {\n      SWIG_fail;\n    }\n  }\n  {\n    svn_repos_notify_func_t * tmp =\n    svn_swig_MustGetPtr(obj3, SWIGTYPE_p_p_f_p_void_p_q_const__struct_svn_repos_notify_t_p_apr_pool_t__void, svn_argnum_obj3);\n    if (tmp == NULL || PyErr_Occurred()) {\n      SWIG_fail;\n    }\n    arg4 = *tmp;\n  }\n  {\n    if (obj4 == Py_None) {\n      arg5 = NULL;\n    } else if (SWIG_ConvertPtr(obj4, (void **) &arg5, 0, 0) == -1) {\n      arg5 = (void *) obj4;\n      PyErr_Clear();\n    }\n  }\n  {\n    svn_cancel_func_t * tmp =\n    svn_swig_MustGetPtr(obj5, SWIGTYPE_p_p_f_p_void__p_svn_error_t, svn_argnum_obj5);\n    if (tmp == NULL || PyErr_Occurred()) {\n      SWIG_fail;\n    }\n    arg6 = *tmp;\n  }\n  {\n    if (obj6 == Py_None) {\n      arg7 = NULL;\n    } else if (SWIG_ConvertPtr(obj6, (void **) &arg7, 0, 0) == -1) {\n      arg7 = (void *) obj6;\n      PyErr_Clear();\n    }\n  }\n  if (obj7) {\n    /* Verify that the user supplied a valid pool */\n    if (obj7 != Py_None && obj7 != _global_py_pool) {\n      SWIG_Python_TypeError(SWIG_TypePrettyName(SWIGTYPE_p_apr_pool_t), obj7);\n      SWIG_arg_fail(svn_argnum_obj7);\n      SWIG_fail;\n    }\n  }\n  {\n    svn_swig_py_release_py_lock();\n    result = (svn_error_t *)svn_repos_verify_fs2(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);\n    svn_swig_py_acquire_py_lock();\n  }\n  {\n    if (result != NULL) {\n      if (result->apr_err != SVN_ERR_SWIG_PY_EXCEPTION_SET)\n      svn_swig_py_svn_exception(result);\n      else\n      svn_error_clear(result);\n      SWIG_fail;\n    }\n    Py_INCREF(Py_None);\n    resultobj = Py_None;\n  }\n  {\n    Py_XDECREF(_global_py_pool);\n  }\n  return resultobj;\nfail:\n  {\n    Py_XDECREF(_global_py_pool);\n  }\n  return NULL;\n"]]}
{"hexsha": "d5c902c108d548676b53137409719298fd6956bc", "ext": "c", "lang": "C", "content": "static inline void printFrameStringBuffer(LOG_OUPUT_TYPE outputType)\r\n{\r\n\tchar** pBuffer = getPointerToPrintBuffer();\r\n\tconst char* printBuffer = getPrintBuffer();\r\n\tu64 bytesToWrite = (*pBuffer) - printBuffer;\r\n\tswitch (outputType)\r\n\t{\r\n\t\tcase (LOG_STDOUT):\r\n\t\t{\r\n\t\t\tu64 bytesWritten = fwrite(printBuffer, 1, bytesToWrite, stdout);\r\n\t\t\tassert(bytesWritten == bytesToWrite);\r\n\t\t} break;\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t}\r\n\r\n}", "item_id": 2, "repo": "davidgm94/glez", "file": "glez/src/frame.c", "last_update_at": "2020-04-11T02:00:53+00:00", "question_id": "d5c902c108d548676b53137409719298fd6956bc_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void printFrameStringBuffer(LOG_OUPUT_TYPE outputType)\r\n{\r\n\tchar** pBuffer = getPointerToPrintBuffer();\r\n\tconst char* printBuffer = getPrintBuffer();\r\n\tu64 bytesToWrite = (*pBuffer) - printBuffer;\r\n\tswitch (outputType)\r\n\t{\r\n\t\tcase (LOG_STDOUT):\r\n\t\t{\r\n\t\t\tu64 bytesWritten = fwrite(printBuffer, 1, bytesToWrite, stdout);\r\n\t\t\tassert(bytesWritten == bytesToWrite);\r\n\t\t} break;\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t}\r\n\r\n"]]}
{"hexsha": "9adc95cd0c96468f8f3a4b469a790afff6d28649", "ext": "c", "lang": "C", "content": "int fflush(FILE *fp)\n{\n\tint ret = 0;\n\tsize_t i = 0;\n\t/* fflush(NULL) flushes all fd */\n\tif (fp == NULL) {\n\t\tfor (fp = stdout; i < FOPEN_MAX; ++fp, ++i) {\n\t\t\tif (fp->buf != NULL) {\n\t\t\t\tret = __flushbuf(EOF, fp);\n\t\t\t}\n\t\t}\n\t}\n\telse if (fp->write == 1) {\n\t\tret = __flushbuf(EOF, fp);\n\t}\n\n\tfp->len = BUFSIZ;\n\tif (fp->unbuf == 1)\n\t\tfp->len = 1;\n\treturn ret;\n}", "item_id": 0, "repo": "vendu/hlibc-1", "file": "src/stdio/fflush.c", "last_update_at": "2020-01-19T08:52:03+00:00", "question_id": "9adc95cd0c96468f8f3a4b469a790afff6d28649_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int fflush(FILE *fp)\n{\n\tint ret = 0;\n\tsize_t i = 0;\n\t/* fflush(NULL) flushes all fd */\n\tif (fp == NULL) {\n\t\tfor (fp = stdout; i < FOPEN_MAX; ++fp, ++i) {\n\t\t\tif (fp->buf != NULL) {\n\t\t\t\tret = __flushbuf(EOF, fp);\n\t\t\t}\n\t\t}\n\t}\n\telse if (fp->write == 1) {\n\t\tret = __flushbuf(EOF, fp);\n\t}\n\tfp->len = BUFSIZ;\n\tif (fp->unbuf == 1)\n\t\tfp->len = 1;\n\treturn ret;\n"]]}
{"hexsha": "d0638d5ffe89f4615f46c4511532ee67da6635c9", "ext": "c", "lang": "C", "content": "void cb_dots_subkeys()\n{\n    int len;\n    int ret;\n    int type;\n    size_t off = 0;\n    char *out_buf;\n    size_t out_size;\n    char *json;\n    char *fmt;\n    char *fmt_out;\n    flb_sds_t str;\n    msgpack_unpacked result;\n    msgpack_object map;\n    struct flb_record_accessor *ra;\n\n    /* Sample JSON message */\n    json =\n        \"{\\\"key1\\\": \\\"something\\\", \\\"kubernetes\\\": {\\\"annotations\\\": \"\n        \"{\\\"fluentbit.io/tag\\\": \\\"thetag\\\"}}}\";\n\n    /* Convert to msgpack */\n    len = strlen(json);\n    ret = flb_pack_json(json, len, &out_buf, &out_size, &type);\n    TEST_CHECK(ret == 0);\n    if (ret == -1) {\n        exit(EXIT_FAILURE);\n    }\n\n    /* Formatter */\n    fmt = flb_sds_create(\"$kubernetes['annotations']['fluentbit.io/tag']\");\n    fmt_out = \"thetag\";\n\n    ra = flb_ra_create(fmt, FLB_FALSE);\n    TEST_CHECK(ra != NULL);\n    if (!ra) {\n        exit(EXIT_FAILURE);\n    }\n\n    /* Unpack msgpack object */\n    msgpack_unpacked_init(&result);\n    msgpack_unpack_next(&result, out_buf, out_size, &off);\n    map = result.data;\n\n    /* Do translation */\n    str = flb_ra_translate(ra, NULL, -1, map, NULL);\n    TEST_CHECK(str != NULL);\n    if (!str) {\n        exit(EXIT_FAILURE);\n    }\n\n    TEST_CHECK(flb_sds_len(str) == strlen(fmt_out));\n    TEST_CHECK(memcmp(str, fmt_out, strlen(fmt_out)) == 0);\n    printf(\"== input ==\\n%s\\n== output ==\\n%s\\n\", str, fmt_out);\n\n    flb_sds_destroy(str);\n    flb_sds_destroy(fmt);\n    flb_ra_destroy(ra);\n    flb_free(out_buf);\n    msgpack_unpacked_destroy(&result);\n}", "item_id": 5, "repo": "blkmajik/fluent-bit", "file": "tests/internal/record_accessor.c", "last_update_at": "2020-01-21T09:56:45+00:00", "question_id": "d0638d5ffe89f4615f46c4511532ee67da6635c9_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void cb_dots_subkeys()\n{\n    int len;\n    int ret;\n    int type;\n    size_t off = 0;\n    char *out_buf;\n    size_t out_size;\n    char *json;\n    char *fmt;\n    char *fmt_out;\n    flb_sds_t str;\n    msgpack_unpacked result;\n    msgpack_object map;\n    struct flb_record_accessor *ra;\n    /* Sample JSON message */\n    json =\n        \"{\\\"key1\\\": \\\"something\\\", \\\"kubernetes\\\": {\\\"annotations\\\": \"\n        \"{\\\"fluentbit.io/tag\\\": \\\"thetag\\\"}}}\";\n    /* Convert to msgpack */\n    len = strlen(json);\n    ret = flb_pack_json(json, len, &out_buf, &out_size, &type);\n    TEST_CHECK(ret == 0);\n    if (ret == -1) {\n        exit(EXIT_FAILURE);\n    }\n    /* Formatter */\n    fmt = flb_sds_create(\"$kubernetes['annotations']['fluentbit.io/tag']\");\n    fmt_out = \"thetag\";\n    ra = flb_ra_create(fmt, FLB_FALSE);\n    TEST_CHECK(ra != NULL);\n    if (!ra) {\n        exit(EXIT_FAILURE);\n    }\n    /* Unpack msgpack object */\n    msgpack_unpacked_init(&result);\n    msgpack_unpack_next(&result, out_buf, out_size, &off);\n    map = result.data;\n    /* Do translation */\n    str = flb_ra_translate(ra, NULL, -1, map, NULL);\n    TEST_CHECK(str != NULL);\n    if (!str) {\n        exit(EXIT_FAILURE);\n    }\n    TEST_CHECK(flb_sds_len(str) == strlen(fmt_out));\n    TEST_CHECK(memcmp(str, fmt_out, strlen(fmt_out)) == 0);\n    printf(\"== input ==\\n%s\\n== output ==\\n%s\\n\", str, fmt_out);\n    flb_sds_destroy(str);\n    flb_sds_destroy(fmt);\n    flb_ra_destroy(ra);\n    flb_free(out_buf);\n    msgpack_unpacked_destroy(&result);\n"]]}
{"hexsha": "a14187605f5e477549b11143d5da129c55aec9b0", "ext": "c", "lang": "C", "content": "static struct at_state_t *at_state_from_cid(struct cardstate *cs, int cid)\n{\n\tstruct at_state_t *at_state;\n\tint i;\n\tunsigned long flags;\n\n\tif (cid == 0)\n\t\treturn &cs->at_state;\n\n\tfor (i = 0; i < cs->channels; ++i)\n\t\tif (cid == cs->bcs[i].at_state.cid)\n\t\t\treturn &cs->bcs[i].at_state;\n\n\tspin_lock_irqsave(&cs->lock, flags);\n\n\tlist_for_each_entry(at_state, &cs->temp_at_states, list)\n\t\tif (cid == at_state->cid) {\n\t\t\tspin_unlock_irqrestore(&cs->lock, flags);\n\t\t\treturn at_state;\n\t\t}\n\n\tspin_unlock_irqrestore(&cs->lock, flags);\n\n\treturn NULL;\n}", "item_id": 7, "repo": "afeng11/tomato-arm", "file": "release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/isdn/gigaset/ev-layer.c", "last_update_at": "2020-05-24T07:23:26+00:00", "question_id": "a14187605f5e477549b11143d5da129c55aec9b0_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct at_state_t *at_state_from_cid(struct cardstate *cs, int cid)\n{\n\tstruct at_state_t *at_state;\n\tint i;\n\tunsigned long flags;\n\tif (cid == 0)\n\t\treturn &cs->at_state;\n\tfor (i = 0; i < cs->channels; ++i)\n\t\tif (cid == cs->bcs[i].at_state.cid)\n\t\t\treturn &cs->bcs[i].at_state;\n\tspin_lock_irqsave(&cs->lock, flags);\n\tlist_for_each_entry(at_state, &cs->temp_at_states, list)\n\t\tif (cid == at_state->cid) {\n\t\t\tspin_unlock_irqrestore(&cs->lock, flags);\n\t\t\treturn at_state;\n\t\t}\n\tspin_unlock_irqrestore(&cs->lock, flags);\n\treturn NULL;\n"]]}
{"hexsha": "ed46be8ca1e0c08b5f8d96b25424857487775ddb", "ext": "c", "lang": "C", "content": "static ngx_int_t\nngx_http_enhanced_memcached_process_request_set(ngx_http_request_t *r)\n{\n  ngx_http_enhanced_memcached_ctx_t  *ctx;\n\n  ctx = ngx_http_get_module_ctx(r, ngx_http_enhanced_memcached_module);\n\n  if (ctx->key_status != READY) {\n    return ngx_http_enhanced_memcached_process_key(r);\n  }\n\n  return ngx_http_enhanced_memcached_process_request_return_string(r, \"set\", (u_char *) \"STORED\", sizeof(\"STORED\") - 1, 409, \"NOT_STORED\", sizeof(\"NOT_STORED\") - 1);\n}", "item_id": 16, "repo": "steamboatid/nginx", "file": "debian/modules/http-enhanced-memcached/ngx_http_enhanced_memcached_module.c", "last_update_at": "2020-10-01T05:01:54+00:00", "question_id": "ed46be8ca1e0c08b5f8d96b25424857487775ddb_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static ngx_int_t\nngx_http_enhanced_memcached_process_request_set(ngx_http_request_t *r)\n{\n  ngx_http_enhanced_memcached_ctx_t  *ctx;\n  ctx = ngx_http_get_module_ctx(r, ngx_http_enhanced_memcached_module);\n  if (ctx->key_status != READY) {\n    return ngx_http_enhanced_memcached_process_key(r);\n  }\n  return ngx_http_enhanced_memcached_process_request_return_string(r, \"set\", (u_char *) \"STORED\", sizeof(\"STORED\") - 1, 409, \"NOT_STORED\", sizeof(\"NOT_STORED\") - 1);\n"]]}
{"hexsha": "65513d0308003398acbc48328e651b2a314e53e0", "ext": "c", "lang": "C", "content": "void UPnPInvoke_DigitalSecurityCameraStillImage_GetImagePresentationURL(struct UPnPService *service,void (*CallbackPtr)(struct UPnPService*,int,void*,char*), void* user, char* ReqEncoding, char* ReqCompression, char* ReqResolution)\r\n{\r\n\tint headerLength;\r\n\tchar *headerBuffer;\r\n\tchar *SoapBodyTemplate;\r\n\tchar* buffer;\r\n\tint bufferLength;\r\n\tchar* IP;\r\n\tunsigned short Port;\r\n\tchar* Path;\r\n\tstruct sockaddr_in addr;\r\n\tstruct InvokeStruct *invoke_data = (struct InvokeStruct*)MALLOC(sizeof(struct InvokeStruct));\r\n\t\r\n\tif(service==NULL)\r\n\t{\r\n\t\tFREE(invoke_data);\r\n\t\treturn;\r\n\t}\r\n\tbuffer = (char*)MALLOC((int)strlen(service->ServiceType)+(int)strlen(ReqEncoding)+(int)strlen(ReqCompression)+(int)strlen(ReqResolution)+369);\r\n\tSoapBodyTemplate = \"%sGetImagePresentationURL xmlns:u=\\\"%s\\\"><ReqEncoding>%s</ReqEncoding><ReqCompression>%s</ReqCompression><ReqResolution>%s</ReqResolution></u:GetImagePresentationURL%s\";\r\n\tbufferLength = sprintf(buffer,SoapBodyTemplate,UPNPCP_SOAP_BodyHead,service->ServiceType, ReqEncoding, ReqCompression, ReqResolution,UPNPCP_SOAP_BodyTail);\r\n\t\r\n\tUPnPAddRef(service->Parent);\r\n\tILibParseUri(service->ControlURL,&IP,&Port,&Path);\r\n\t\r\n\theaderBuffer = (char*)MALLOC(178 + (int)strlen(Path) + (int)strlen(IP) + (int)strlen(service->ServiceType));\r\n\theaderLength = sprintf(headerBuffer,UPNPCP_SOAP_Header,Path,IP,Port,service->ServiceType,\"GetImagePresentationURL\",bufferLength);\r\n\t\r\n\tmemset((char *)&addr, 0, sizeof(addr));\r\n\taddr.sin_family = AF_INET;\r\n\taddr.sin_addr.s_addr = inet_addr(IP);\r\n\taddr.sin_port = htons(Port);\r\n\t\r\n\tinvoke_data->CallbackPtr = CallbackPtr;\r\n\tinvoke_data->User = user;\r\n\tILibAddRequest_DirectEx(((struct UPnPCP*)service->Parent->CP)->HTTP, headerBuffer,headerLength,buffer,bufferLength,&addr, &UPnPInvoke_DigitalSecurityCameraStillImage_GetImagePresentationURL_Sink,service, invoke_data);\t\r\n\t\r\n\tFREE(IP);\r\n\tFREE(Path);\r\n}", "item_id": 100, "repo": "jwnichls/puc", "file": "edu/cmu/hcii/puc/devices/UPnP/AxisCamera/Native/UPnPControlPoint.c", "last_update_at": "2020-02-18T03:11:10+00:00", "question_id": "65513d0308003398acbc48328e651b2a314e53e0_100", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void UPnPInvoke_DigitalSecurityCameraStillImage_GetImagePresentationURL(struct UPnPService *service,void (*CallbackPtr)(struct UPnPService*,int,void*,char*), void* user, char* ReqEncoding, char* ReqCompression, char* ReqResolution)\r\n{\r\n\tint headerLength;\r\n\tchar *headerBuffer;\r\n\tchar *SoapBodyTemplate;\r\n\tchar* buffer;\r\n\tint bufferLength;\r\n\tchar* IP;\r\n\tunsigned short Port;\r\n\tchar* Path;\r\n\tstruct sockaddr_in addr;\r\n\tstruct InvokeStruct *invoke_data = (struct InvokeStruct*)MALLOC(sizeof(struct InvokeStruct));\r\n\t\r\n\tif(service==NULL)\r\n\t{\r\n\t\tFREE(invoke_data);\r\n\t\treturn;\r\n\t}\r\n\tbuffer = (char*)MALLOC((int)strlen(service->ServiceType)+(int)strlen(ReqEncoding)+(int)strlen(ReqCompression)+(int)strlen(ReqResolution)+369);\r\n\tSoapBodyTemplate = \"%sGetImagePresentationURL xmlns:u=\\\"%s\\\"><ReqEncoding>%s</ReqEncoding><ReqCompression>%s</ReqCompression><ReqResolution>%s</ReqResolution></u:GetImagePresentationURL%s\";\r\n\tbufferLength = sprintf(buffer,SoapBodyTemplate,UPNPCP_SOAP_BodyHead,service->ServiceType, ReqEncoding, ReqCompression, ReqResolution,UPNPCP_SOAP_BodyTail);\r\n\t\r\n\tUPnPAddRef(service->Parent);\r\n\tILibParseUri(service->ControlURL,&IP,&Port,&Path);\r\n\t\r\n\theaderBuffer = (char*)MALLOC(178 + (int)strlen(Path) + (int)strlen(IP) + (int)strlen(service->ServiceType));\r\n\theaderLength = sprintf(headerBuffer,UPNPCP_SOAP_Header,Path,IP,Port,service->ServiceType,\"GetImagePresentationURL\",bufferLength);\r\n\t\r\n\tmemset((char *)&addr, 0, sizeof(addr));\r\n\taddr.sin_family = AF_INET;\r\n\taddr.sin_addr.s_addr = inet_addr(IP);\r\n\taddr.sin_port = htons(Port);\r\n\t\r\n\tinvoke_data->CallbackPtr = CallbackPtr;\r\n\tinvoke_data->User = user;\r\n\tILibAddRequest_DirectEx(((struct UPnPCP*)service->Parent->CP)->HTTP, headerBuffer,headerLength,buffer,bufferLength,&addr, &UPnPInvoke_DigitalSecurityCameraStillImage_GetImagePresentationURL_Sink,service, invoke_data);\t\r\n\t\r\n\tFREE(IP);\r\n\tFREE(Path);\r\n"]]}
{"hexsha": "798496353e8c6aa824a4582355dfbbe36424d9aa", "ext": "c", "lang": "C", "content": "static ssize_t store_ideapad_cam(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tint ret, state;\n\n\tif (!count)\n\t\treturn 0;\n\tif (sscanf(buf, \"%i\", &state) != 1)\n\t\treturn -EINVAL;\n\tret = ideapad_dev_set_state(IDEAPAD_DEV_CAMERA, !!state);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}", "item_id": 4, "repo": "afeng11/tomato-arm", "file": "release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/platform/x86/ideapad_acpi.c", "last_update_at": "2020-05-24T07:23:26+00:00", "question_id": "798496353e8c6aa824a4582355dfbbe36424d9aa_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static ssize_t store_ideapad_cam(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tint ret, state;\n\tif (!count)\n\t\treturn 0;\n\tif (sscanf(buf, \"%i\", &state) != 1)\n\t\treturn -EINVAL;\n\tret = ideapad_dev_set_state(IDEAPAD_DEV_CAMERA, !!state);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n"]]}
{"hexsha": "36039b9fd05a764265a177ddc6da1df28ac69f54", "ext": "c", "lang": "C", "content": "static void compileTryExcept(Compiler* c, JStarStmt* s) {\n    bool hasExcept = !vecEmpty(&s->as.tryStmt.excs);\n    bool hasEnsure = s->as.tryStmt.ensure != NULL;\n    int numHandlers = (hasExcept ? 1 : 0) + (hasEnsure ? 1 : 0);\n\n    TryExcept tryBlock;\n    enterTryBlock(c, &tryBlock, numHandlers);\n\n    if(c->tryDepth > MAX_TRY_DEPTH) {\n        error(c, s->line, \"Exceeded max number of nested try blocks: %d.\", MAX_TRY_DEPTH);\n    }\n\n    size_t ensSetup = 0, excSetup = 0;\n\n    if(hasEnsure) {\n        ensSetup = emitBytecode(c, OP_SETUP_ENSURE, s->line);\n        emitShort(c, 0, 0);\n    }\n\n    if(hasExcept) {\n        excSetup = emitBytecode(c, OP_SETUP_EXCEPT, s->line);\n        emitShort(c, 0, 0);\n    }\n\n    compileStatement(c, s->as.tryStmt.block);\n\n    if(hasExcept) {\n        emitBytecode(c, OP_POP_HANDLER, s->line);\n    }\n\n    if(hasEnsure) {\n        emitBytecode(c, OP_POP_HANDLER, s->line);\n        // Reached end of try block during normal execution flow, set exception and unwind\n        // cause to null to signal the ensure handler that no exception was raised\n        emitBytecode(c, OP_NULL, s->line);\n        emitBytecode(c, OP_NULL, s->line);\n    }\n\n    enterScope(c);\n\n    JStarIdentifier exc = createIdentifier(\".exception\");\n    declareVar(c, &exc, 0);\n    defineVar(c, &exc, 0);\n\n    JStarIdentifier cause = createIdentifier(\".cause\");\n    declareVar(c, &cause, 0);\n    defineVar(c, &cause, 0);\n\n    if(hasExcept) {\n        size_t excJmp = emitBytecode(c, OP_JUMP, 0);\n        emitShort(c, 0, 0);\n\n        setJumpTo(c, excSetup, getCurrentAddr(c), s->line);\n        compileExcepts(c, &s->as.tryStmt.excs, 0);\n\n        if(hasEnsure) {\n            emitBytecode(c, OP_POP_HANDLER, 0);\n        } else {\n            emitBytecode(c, OP_END_HANDLER, 0);\n            exitScope(c);\n        }\n\n        setJumpTo(c, excJmp, getCurrentAddr(c), 0);\n    }\n\n    if(hasEnsure) {\n        setJumpTo(c, ensSetup, getCurrentAddr(c), s->line);\n        compileStatement(c, s->as.tryStmt.ensure);\n        emitBytecode(c, OP_END_HANDLER, 0);\n        exitScope(c);\n    }\n\n    exitTryBlock(c, numHandlers);\n}", "item_id": 38, "repo": "silas1037/jstar", "file": "src/compiler.c", "last_update_at": "2020-12-01T21:42:49+00:00", "question_id": "36039b9fd05a764265a177ddc6da1df28ac69f54_38", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void compileTryExcept(Compiler* c, JStarStmt* s) {\n    bool hasExcept = !vecEmpty(&s->as.tryStmt.excs);\n    bool hasEnsure = s->as.tryStmt.ensure != NULL;\n    int numHandlers = (hasExcept ? 1 : 0) + (hasEnsure ? 1 : 0);\n    TryExcept tryBlock;\n    enterTryBlock(c, &tryBlock, numHandlers);\n    if(c->tryDepth > MAX_TRY_DEPTH) {\n        error(c, s->line, \"Exceeded max number of nested try blocks: %d.\", MAX_TRY_DEPTH);\n    }\n    size_t ensSetup = 0, excSetup = 0;\n    if(hasEnsure) {\n        ensSetup = emitBytecode(c, OP_SETUP_ENSURE, s->line);\n        emitShort(c, 0, 0);\n    }\n    if(hasExcept) {\n        excSetup = emitBytecode(c, OP_SETUP_EXCEPT, s->line);\n        emitShort(c, 0, 0);\n    }\n    compileStatement(c, s->as.tryStmt.block);\n    if(hasExcept) {\n        emitBytecode(c, OP_POP_HANDLER, s->line);\n    }\n    if(hasEnsure) {\n        emitBytecode(c, OP_POP_HANDLER, s->line);\n        // Reached end of try block during normal execution flow, set exception and unwind\n        // cause to null to signal the ensure handler that no exception was raised\n        emitBytecode(c, OP_NULL, s->line);\n        emitBytecode(c, OP_NULL, s->line);\n    }\n    enterScope(c);\n    JStarIdentifier exc = createIdentifier(\".exception\");\n    declareVar(c, &exc, 0);\n    defineVar(c, &exc, 0);\n    JStarIdentifier cause = createIdentifier(\".cause\");\n    declareVar(c, &cause, 0);\n    defineVar(c, &cause, 0);\n    if(hasExcept) {\n        size_t excJmp = emitBytecode(c, OP_JUMP, 0);\n        emitShort(c, 0, 0);\n        setJumpTo(c, excSetup, getCurrentAddr(c), s->line);\n        compileExcepts(c, &s->as.tryStmt.excs, 0);\n        if(hasEnsure) {\n            emitBytecode(c, OP_POP_HANDLER, 0);\n        } else {\n            emitBytecode(c, OP_END_HANDLER, 0);\n            exitScope(c);\n        }\n        setJumpTo(c, excJmp, getCurrentAddr(c), 0);\n    }\n    if(hasEnsure) {\n        setJumpTo(c, ensSetup, getCurrentAddr(c), s->line);\n        compileStatement(c, s->as.tryStmt.ensure);\n        emitBytecode(c, OP_END_HANDLER, 0);\n        exitScope(c);\n    }\n    exitTryBlock(c, numHandlers);\n"]]}
{"hexsha": "643f4a2b85468613b9279ddf6eadb10c5fcd77c6", "ext": "c", "lang": "C", "content": "uint8_t* hex2bin(const char *hexstr, size_t *size)\n{\n  size_t hexstr_len = strlen(hexstr);\n  size_t bytes_len = hexstr_len / 2;\n\n  uint8_t* bytes = (uint8_t*)malloc(bytes_len);\n  int count = 0;\n  const char* pos = hexstr;\n\n  for (count = 0; count < bytes_len; count++)\n  {\n    sscanf(pos, \"%2hhx\", &bytes[count]);\n    pos += 2;\n  }\n\n  if (size != NULL)\n  {\n    *size = bytes_len;\n  }\n\n  return bytes;\n}", "item_id": 5, "repo": "vulkancurrency/vulkan", "file": "src/common/util.c", "last_update_at": "2020-08-16T23:16:47+00:00", "question_id": "643f4a2b85468613b9279ddf6eadb10c5fcd77c6_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint8_t* hex2bin(const char *hexstr, size_t *size)\n{\n  size_t hexstr_len = strlen(hexstr);\n  size_t bytes_len = hexstr_len / 2;\n  uint8_t* bytes = (uint8_t*)malloc(bytes_len);\n  int count = 0;\n  const char* pos = hexstr;\n  for (count = 0; count < bytes_len; count++)\n  {\n    sscanf(pos, \"%2hhx\", &bytes[count]);\n    pos += 2;\n  }\n  if (size != NULL)\n  {\n    *size = bytes_len;\n  }\n  return bytes;\n"]]}
{"hexsha": "6cdff29f95bf754c7c2c6891171e584b7cdfaea7", "ext": "c", "lang": "C", "content": "int git_attr_cache__push_file(\n\tgit_repository *repo,\n\tconst char *base,\n\tconst char *filename,\n\tgit_attr_file_source source,\n\tgit_attr_file_parser parse,\n\tvoid* parsedata,\n\tgit_vector *stack)\n{\n\tint error = 0;\n\tgit_buf path = GIT_BUF_INIT;\n\tconst char *workdir = git_repository_workdir(repo);\n\tconst char *relfile, *content = NULL;\n\tgit_attr_cache *cache = git_repository_attr_cache(repo);\n\tgit_attr_file *file = NULL;\n\tgit_blob *blob = NULL;\n\tgit_futils_filestamp stamp;\n\n\tassert(filename && stack);\n\n\t/* join base and path as needed */\n\tif (base != NULL && git_path_root(filename) < 0) {\n\t\tif (git_buf_joinpath(&path, base, filename) < 0)\n\t\t\treturn -1;\n\t\tfilename = path.ptr;\n\t}\n\n\trelfile = filename;\n\tif (workdir && git__prefixcmp(relfile, workdir) == 0)\n\t\trelfile += strlen(workdir);\n\n\t/* check cache */\n\tif (load_attr_from_cache(&file, cache, source, relfile) < 0)\n\t\treturn -1;\n\n\t/* if not in cache, load data, parse, and cache */\n\n\tif (source == GIT_ATTR_FILE_FROM_FILE) {\n\t\tgit_futils_filestamp_set(\n\t\t\t&stamp, file ? &file->cache_data.stamp : NULL);\n\n\t\terror = load_attr_file(&content, &stamp, filename);\n\t} else {\n\t\terror = load_attr_blob_from_index(&content, &blob,\n\t\t\trepo, file ? &file->cache_data.oid : NULL, relfile);\n\t}\n\n\tif (error) {\n\t\t/* not finding a file is not an error for this function */\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\tgoto finish;\n\t}\n\n\t/* if we got here, we have to parse and/or reparse the file */\n\tif (file)\n\t\tgit_attr_file__clear_rules(file);\n\telse {\n\t\terror = git_attr_file__new(&file, source, relfile, &cache->pool);\n\t\tif (error < 0)\n\t\t\tgoto finish;\n\t}\n\n\tif (parse && (error = parse(repo, parsedata, content, file)) < 0)\n\t\tgoto finish;\n\n\tgit_strmap_insert(cache->files, file->key, file, error); //-V595\n\tif (error > 0)\n\t\terror = 0;\n\n\t/* remember \"cache buster\" file signature */\n\tif (blob)\n\t\tgit_oid_cpy(&file->cache_data.oid, git_object_id((git_object *)blob));\n\telse\n\t\tgit_futils_filestamp_set(&file->cache_data.stamp, &stamp);\n\nfinish:\n\t/* push file onto vector if we found one*/\n\tif (!error && file != NULL)\n\t\terror = git_vector_insert(stack, file);\n\n\tif (error != 0)\n\t\tgit_attr_file__free(file);\n\n\tif (blob)\n\t\tgit_blob_free(blob);\n\telse\n\t\tgit__free((void *)content);\n\n\tgit_buf_free(&path);\n\n\treturn error;\n}", "item_id": 10, "repo": "allisrc/libgit2-allisrc", "file": "src/attr.c", "last_update_at": "2020-11-17T15:13:45+00:00", "question_id": "6cdff29f95bf754c7c2c6891171e584b7cdfaea7_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int git_attr_cache__push_file(\n\tgit_repository *repo,\n\tconst char *base,\n\tconst char *filename,\n\tgit_attr_file_source source,\n\tgit_attr_file_parser parse,\n\tvoid* parsedata,\n\tgit_vector *stack)\n{\n\tint error = 0;\n\tgit_buf path = GIT_BUF_INIT;\n\tconst char *workdir = git_repository_workdir(repo);\n\tconst char *relfile, *content = NULL;\n\tgit_attr_cache *cache = git_repository_attr_cache(repo);\n\tgit_attr_file *file = NULL;\n\tgit_blob *blob = NULL;\n\tgit_futils_filestamp stamp;\n\tassert(filename && stack);\n\t/* join base and path as needed */\n\tif (base != NULL && git_path_root(filename) < 0) {\n\t\tif (git_buf_joinpath(&path, base, filename) < 0)\n\t\t\treturn -1;\n\t\tfilename = path.ptr;\n\t}\n\trelfile = filename;\n\tif (workdir && git__prefixcmp(relfile, workdir) == 0)\n\t\trelfile += strlen(workdir);\n\t/* check cache */\n\tif (load_attr_from_cache(&file, cache, source, relfile) < 0)\n\t\treturn -1;\n\t/* if not in cache, load data, parse, and cache */\n\tif (source == GIT_ATTR_FILE_FROM_FILE) {\n\t\tgit_futils_filestamp_set(\n\t\t\t&stamp, file ? &file->cache_data.stamp : NULL);\n\t\terror = load_attr_file(&content, &stamp, filename);\n\t} else {\n\t\terror = load_attr_blob_from_index(&content, &blob,\n\t\t\trepo, file ? &file->cache_data.oid : NULL, relfile);\n\t}\n\tif (error) {\n\t\t/* not finding a file is not an error for this function */\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\tgoto finish;\n\t}\n\t/* if we got here, we have to parse and/or reparse the file */\n\tif (file)\n\t\tgit_attr_file__clear_rules(file);\n\telse {\n\t\terror = git_attr_file__new(&file, source, relfile, &cache->pool);\n\t\tif (error < 0)\n\t\t\tgoto finish;\n\t}\n\tif (parse && (error = parse(repo, parsedata, content, file)) < 0)\n\t\tgoto finish;\n\tgit_strmap_insert(cache->files, file->key, file, error); //-V595\n\tif (error > 0)\n\t\terror = 0;\n\t/* remember \"cache buster\" file signature */\n\tif (blob)\n\t\tgit_oid_cpy(&file->cache_data.oid, git_object_id((git_object *)blob));\n\telse\n\t\tgit_futils_filestamp_set(&file->cache_data.stamp, &stamp);\nfinish:\n\t/* push file onto vector if we found one*/\n\tif (!error && file != NULL)\n\t\terror = git_vector_insert(stack, file);\n\tif (error != 0)\n\t\tgit_attr_file__free(file);\n\tif (blob)\n\t\tgit_blob_free(blob);\n\telse\n\t\tgit__free((void *)content);\n\tgit_buf_free(&path);\n\treturn error;\n"]]}
{"hexsha": "e696364a8a2ecfff01742fe9c0bb993055ef21de", "ext": "h", "lang": "C", "content": "inline NanoString unary_dtype_infer(NanoString op, NanoString x) {\n    if (op.is_bool()) return ns_bool;\n    int dsize_ = x.dsize_();\n    if (op.is_float()) {\n        if (op.is_white() && !(amp_reg & amp_keep_white))\n            return (dsize_ == 3) ? ns_float64 : ns_float32;\n        return float_dtype(dsize_);\n    }\n    if (op.is_int()) return int_dtype(dsize_);\n    return x;\n}", "item_id": 5, "repo": "Jittor/Jittor", "file": "python/jittor/src/misc/nano_string.h", "last_update_at": "2020-01-12T15:43:54+00:00", "question_id": "e696364a8a2ecfff01742fe9c0bb993055ef21de_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["inline NanoString unary_dtype_infer(NanoString op, NanoString x) {\n    if (op.is_bool()) return ns_bool;\n    int dsize_ = x.dsize_();\n    if (op.is_float()) {\n        if (op.is_white() && !(amp_reg & amp_keep_white))\n            return (dsize_ == 3) ? ns_float64 : ns_float32;\n        return float_dtype(dsize_);\n    }\n    if (op.is_int()) return int_dtype(dsize_);\n    return x;\n"]]}
{"hexsha": "46d0a55ff309b8e6439399dedf2b614ed04ff924", "ext": "c", "lang": "C", "content": "static HippoReadInfo mp3_read_data(void* user_data, void* dest, uint32_t max_output_bytes,\n                                    uint32_t native_sample_rate) {\n    struct ReplayerData* data = (struct ReplayerData*)user_data;\n\n    uint16_t samples_to_read = hippo_min(max_output_bytes / 8, FRAME_SIZE);\n\n\tdrmp3_read_pcm_frames_f32(&data->song, samples_to_read, (float*)dest);\n\n    HippoReadInfo t = {\n    \tdata->song.sampleRate,\n        samples_to_read,\n        data->song.channels,\n        HippoOutputType_f32,\n    };\n\n    return t;\n}", "item_id": 5, "repo": "emoon/HippoPlayer", "file": "src/plugins/playback/mp3/mp3_plugin.c", "last_update_at": "2020-08-24T23:45:56+00:00", "question_id": "46d0a55ff309b8e6439399dedf2b614ed04ff924_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static HippoReadInfo mp3_read_data(void* user_data, void* dest, uint32_t max_output_bytes,\n                                    uint32_t native_sample_rate) {\n    struct ReplayerData* data = (struct ReplayerData*)user_data;\n    uint16_t samples_to_read = hippo_min(max_output_bytes / 8, FRAME_SIZE);\n\tdrmp3_read_pcm_frames_f32(&data->song, samples_to_read, (float*)dest);\n    HippoReadInfo t = {\n    \tdata->song.sampleRate,\n        samples_to_read,\n        data->song.channels,\n        HippoOutputType_f32,\n    };\n    return t;\n"]]}
{"hexsha": "fcdb7bc8e4eeabc2f3b0e336c064bfce634c6e30", "ext": "c", "lang": "C", "content": "static TCGv rotate32_x(TCGv reg, TCGv shift, int left)\n{\n    TCGv_i64 t0, shift64;\n    TCGv X, lo, hi, zero;\n\n    shift64 = tcg_temp_new_i64();\n    tcg_gen_extu_i32_i64(shift64, shift);\n\n    t0 = tcg_temp_new_i64();\n\n    X = tcg_temp_new();\n    lo = tcg_temp_new();\n    hi = tcg_temp_new();\n\n    if (left) {\n        /* create [reg:X:..] */\n\n        tcg_gen_shli_i32(lo, QREG_CC_X, 31);\n        tcg_gen_concat_i32_i64(t0, lo, reg);\n\n        /* rotate */\n\n        tcg_gen_rotl_i64(t0, t0, shift64);\n        tcg_temp_free_i64(shift64);\n\n        /* result is [reg:..:reg:X] */\n\n        tcg_gen_extr_i64_i32(lo, hi, t0);\n        tcg_gen_andi_i32(X, lo, 1);\n\n        tcg_gen_shri_i32(lo, lo, 1);\n    } else {\n        /* create [..:X:reg] */\n\n        tcg_gen_concat_i32_i64(t0, reg, QREG_CC_X);\n\n        tcg_gen_rotr_i64(t0, t0, shift64);\n        tcg_temp_free_i64(shift64);\n\n        /* result is value: [X:reg:..:reg] */\n\n        tcg_gen_extr_i64_i32(lo, hi, t0);\n\n        /* extract X */\n\n        tcg_gen_shri_i32(X, hi, 31);\n\n        /* extract result */\n\n        tcg_gen_shli_i32(hi, hi, 1);\n    }\n    tcg_temp_free_i64(t0);\n    tcg_gen_or_i32(lo, lo, hi);\n    tcg_temp_free(hi);\n\n    /* if shift == 0, register and X are not affected */\n\n    zero = tcg_const_i32(0);\n    tcg_gen_movcond_i32(TCG_COND_EQ, X, shift, zero, QREG_CC_X, X);\n    tcg_gen_movcond_i32(TCG_COND_EQ, reg, shift, zero, reg, lo);\n    tcg_temp_free(zero);\n    tcg_temp_free(lo);\n\n    return X;\n}", "item_id": 104, "repo": "MisaZhu/qemu_raspi", "file": "qemu-4.2.0/target/m68k/translate.c", "last_update_at": "2020-05-25T09:49:33+00:00", "question_id": "fcdb7bc8e4eeabc2f3b0e336c064bfce634c6e30_104", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static TCGv rotate32_x(TCGv reg, TCGv shift, int left)\n{\n    TCGv_i64 t0, shift64;\n    TCGv X, lo, hi, zero;\n    shift64 = tcg_temp_new_i64();\n    tcg_gen_extu_i32_i64(shift64, shift);\n    t0 = tcg_temp_new_i64();\n    X = tcg_temp_new();\n    lo = tcg_temp_new();\n    hi = tcg_temp_new();\n    if (left) {\n        /* create [reg:X:..] */\n        tcg_gen_shli_i32(lo, QREG_CC_X, 31);\n        tcg_gen_concat_i32_i64(t0, lo, reg);\n        /* rotate */\n        tcg_gen_rotl_i64(t0, t0, shift64);\n        tcg_temp_free_i64(shift64);\n        /* result is [reg:..:reg:X] */\n        tcg_gen_extr_i64_i32(lo, hi, t0);\n        tcg_gen_andi_i32(X, lo, 1);\n        tcg_gen_shri_i32(lo, lo, 1);\n    } else {\n        /* create [..:X:reg] */\n        tcg_gen_concat_i32_i64(t0, reg, QREG_CC_X);\n        tcg_gen_rotr_i64(t0, t0, shift64);\n        tcg_temp_free_i64(shift64);\n        /* result is value: [X:reg:..:reg] */\n        tcg_gen_extr_i64_i32(lo, hi, t0);\n        /* extract X */\n        tcg_gen_shri_i32(X, hi, 31);\n        /* extract result */\n        tcg_gen_shli_i32(hi, hi, 1);\n    }\n    tcg_temp_free_i64(t0);\n    tcg_gen_or_i32(lo, lo, hi);\n    tcg_temp_free(hi);\n    /* if shift == 0, register and X are not affected */\n    zero = tcg_const_i32(0);\n    tcg_gen_movcond_i32(TCG_COND_EQ, X, shift, zero, QREG_CC_X, X);\n    tcg_gen_movcond_i32(TCG_COND_EQ, reg, shift, zero, reg, lo);\n    tcg_temp_free(zero);\n    tcg_temp_free(lo);\n    return X;\n"]]}
{"hexsha": "aca3a427f1d7e0a0022f835887d1461defcee09f", "ext": "c", "lang": "C", "content": "struct value *\nlsscm_safe_lazy_string_to_value (SCM string, int arg_pos,\n\t\t\t\t const char *func_name, SCM *except_scmp)\n{\n  lazy_string_smob *ls_smob;\n  struct value *value = NULL;\n\n  gdb_assert (lsscm_is_lazy_string (string));\n\n  ls_smob = (lazy_string_smob *) SCM_SMOB_DATA (string);\n\n  if (ls_smob->address == 0)\n    {\n      *except_scmp\n\t= gdbscm_make_out_of_range_error (func_name, arg_pos, string,\n\t\t\t\t\t _(\"cannot create a value from NULL\"));\n      return NULL;\n    }\n\n  try\n    {\n      struct type *type = tyscm_scm_to_type (ls_smob->type);\n      struct type *realtype = check_typedef (type);\n\n      switch (realtype->code ())\n\t{\n\tcase TYPE_CODE_PTR:\n\t  /* If a length is specified we need to convert this to an array\n\t     of the specified size.  */\n\t  if (ls_smob->length != -1)\n\t    {\n\t      /* PR 20786: There's no way to specify an array of length zero.\n\t\t Record a length of [0,-1] which is how Ada does it.  Anything\n\t\t we do is broken, but this one possible solution.  */\n\t      type = lookup_array_range_type (TYPE_TARGET_TYPE (realtype),\n\t\t\t\t\t      0, ls_smob->length - 1);\n\t      value = value_at_lazy (type, ls_smob->address);\n\t    }\n\t  else\n\t    value = value_from_pointer (type, ls_smob->address);\n\t  break;\n\tdefault:\n\t  value = value_at_lazy (type, ls_smob->address);\n\t  break;\n\t}\n    }\n  catch (const gdb_exception &except)\n    {\n      *except_scmp = gdbscm_scm_from_gdb_exception (unpack (except));\n      return NULL;\n    }\n\n  return value;\n}", "item_id": 10, "repo": "greyblue9/binutils-gdb", "file": "gdb/guile/scm-lazy-string.c", "last_update_at": "2020-10-14T03:24:35+00:00", "question_id": "aca3a427f1d7e0a0022f835887d1461defcee09f_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct value *\nlsscm_safe_lazy_string_to_value (SCM string, int arg_pos,\n\t\t\t\t const char *func_name, SCM *except_scmp)\n{\n  lazy_string_smob *ls_smob;\n  struct value *value = NULL;\n  gdb_assert (lsscm_is_lazy_string (string));\n  ls_smob = (lazy_string_smob *) SCM_SMOB_DATA (string);\n  if (ls_smob->address == 0)\n    {\n      *except_scmp\n\t= gdbscm_make_out_of_range_error (func_name, arg_pos, string,\n\t\t\t\t\t _(\"cannot create a value from NULL\"));\n      return NULL;\n    }\n  try\n    {\n      struct type *type = tyscm_scm_to_type (ls_smob->type);\n      struct type *realtype = check_typedef (type);\n      switch (realtype->code ())\n\t{\n\tcase TYPE_CODE_PTR:\n\t  /* If a length is specified we need to convert this to an array\n\t     of the specified size.  */\n\t  if (ls_smob->length != -1)\n\t    {\n\t      /* PR 20786: There's no way to specify an array of length zero.\n\t\t Record a length of [0,-1] which is how Ada does it.  Anything\n\t\t we do is broken, but this one possible solution.  */\n\t      type = lookup_array_range_type (TYPE_TARGET_TYPE (realtype),\n\t\t\t\t\t      0, ls_smob->length - 1);\n\t      value = value_at_lazy (type, ls_smob->address);\n\t    }\n\t  else\n\t    value = value_from_pointer (type, ls_smob->address);\n\t  break;\n\tdefault:\n\t  value = value_at_lazy (type, ls_smob->address);\n\t  break;\n\t}\n    }\n  catch (const gdb_exception &except)\n    {\n      *except_scmp = gdbscm_scm_from_gdb_exception (unpack (except));\n      return NULL;\n    }\n  return value;\n"]]}
{"hexsha": "be2448e0d39e2cdd69c2faa702277499cd3e8bed", "ext": "c", "lang": "C", "content": "static char *get_address(uint8_t *publickey, char *address, size_t len)\n{\n    unsigned char redeem_script[35];\n    uint32_t md32[32];\n    unsigned char md20[20];\n    unsigned char program_hash[21];\n    unsigned char bin_idstring[25];\n    size_t expected_len;\n\n    assert(publickey);\n    assert(address);\n    assert(len > 0);\n\n    redeem_script[0] = 33;\n    memcpy(redeem_script + 1, publickey, 33);\n    redeem_script[34] = PADDING_STANDARD;\n    BRHash160(md20, redeem_script, sizeof(redeem_script));\n\n    program_hash[0] = PADDING_IDENTITY;\n    memcpy(program_hash + 1, md20, sizeof(md20));\n\n    BRSHA256_2(md32, program_hash, sizeof(program_hash));\n\n    memcpy(bin_idstring, program_hash, sizeof(program_hash));\n    memcpy(bin_idstring + sizeof(program_hash), md32, 4);\n\n    expected_len = BRBase58Encode(NULL, 0, bin_idstring, sizeof(bin_idstring));\n    if (len < expected_len)\n        return NULL;\n\n    BRBase58Encode(address, len, bin_idstring, sizeof(bin_idstring));\n    return address;\n}", "item_id": 18, "repo": "chenyukaola/Elastos.DID.Native.SDK", "file": "hdkey/HDkey.c", "last_update_at": "2020-04-30T05:14:08+00:00", "question_id": "be2448e0d39e2cdd69c2faa702277499cd3e8bed_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static char *get_address(uint8_t *publickey, char *address, size_t len)\n{\n    unsigned char redeem_script[35];\n    uint32_t md32[32];\n    unsigned char md20[20];\n    unsigned char program_hash[21];\n    unsigned char bin_idstring[25];\n    size_t expected_len;\n    assert(publickey);\n    assert(address);\n    assert(len > 0);\n    redeem_script[0] = 33;\n    memcpy(redeem_script + 1, publickey, 33);\n    redeem_script[34] = PADDING_STANDARD;\n    BRHash160(md20, redeem_script, sizeof(redeem_script));\n    program_hash[0] = PADDING_IDENTITY;\n    memcpy(program_hash + 1, md20, sizeof(md20));\n    BRSHA256_2(md32, program_hash, sizeof(program_hash));\n    memcpy(bin_idstring, program_hash, sizeof(program_hash));\n    memcpy(bin_idstring + sizeof(program_hash), md32, 4);\n    expected_len = BRBase58Encode(NULL, 0, bin_idstring, sizeof(bin_idstring));\n    if (len < expected_len)\n        return NULL;\n    BRBase58Encode(address, len, bin_idstring, sizeof(bin_idstring));\n    return address;\n"]]}
{"hexsha": "d4bf505ed16c3ea3d3e840ed8e9a052f8b2a6a6f", "ext": "h", "lang": "C", "content": "static __inline__ int\nAG_WidgetMapSurfaceNODUP(void *obj, AG_Surface *su)\n{\n\tAG_Widget *wid = (AG_Widget *)obj;\n\tint name;\n\n\tAG_ObjectLock(wid);\n\tif ((name = AG_WidgetMapSurface(wid, su)) != -1) {\n\t\twid->surfaceFlags[name] |= AG_WIDGET_SURFACE_NODUP;\n\t}\n\tAG_ObjectUnlock(wid);\n\treturn (name);\n}", "item_id": 6, "repo": "WallyZambotti/AGAR-SDL2", "file": "gui/widget.h", "last_update_at": "2020-05-22T10:25:42+00:00", "question_id": "d4bf505ed16c3ea3d3e840ed8e9a052f8b2a6a6f_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static __inline__ int\nAG_WidgetMapSurfaceNODUP(void *obj, AG_Surface *su)\n{\n\tAG_Widget *wid = (AG_Widget *)obj;\n\tint name;\n\tAG_ObjectLock(wid);\n\tif ((name = AG_WidgetMapSurface(wid, su)) != -1) {\n\t\twid->surfaceFlags[name] |= AG_WIDGET_SURFACE_NODUP;\n\t}\n\tAG_ObjectUnlock(wid);\n\treturn (name);\n"]]}
{"hexsha": "1453f9ba6130932cd273d6df7cff1a6ea4376609", "ext": "c", "lang": "C", "content": "uint16 USBUART_GetCount(void) \n    {\n        uint16 bytesCount = 0u;\n\n        if (USBUART_EP[USBUART_cdc_data_out_ep].apiEpState == USBUART_OUT_BUFFER_FULL)\n        {\n            bytesCount = USBUART_GetEPCount(USBUART_cdc_data_out_ep);\n        }\n\n        return(bytesCount);\n    }", "item_id": 5, "repo": "blahmoomoo/Masters-Project-PSoC-Labs", "file": "Source/Lab4.cydsn/Generated_Source/PSoC5/USBUART_cdc.c", "last_update_at": "2020-09-09T08:27:26+00:00", "question_id": "1453f9ba6130932cd273d6df7cff1a6ea4376609_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint16 USBUART_GetCount(void) \n    {\n        uint16 bytesCount = 0u;\n        if (USBUART_EP[USBUART_cdc_data_out_ep].apiEpState == USBUART_OUT_BUFFER_FULL)\n        {\n            bytesCount = USBUART_GetEPCount(USBUART_cdc_data_out_ep);\n        }\n        return(bytesCount);\n"]]}
{"hexsha": "ee72d55a9939b25def927ed0ead36a854248dff4", "ext": "c", "lang": "C", "content": "static inline void axp_read_adc(struct axp_charger *charger,\n  struct axp_adc_res *adc)\n{\n\tuint8_t tmp[8];\n\tadc->vac_res = 0;\n\tadc->iac_res = 0;\n\tadc->vusb_res = 0;\n\tadc->iusb_res = 0;\n\t\n\taxp_reads(charger->master,AXP22_VBATH_RES,6,tmp);\n\tadc->vbat_res = ((uint16_t) tmp[0] << 8 )| tmp[1];\n\tadc->ichar_res = ((uint16_t) tmp[2] << 8 )| tmp[3];\n\tadc->idischar_res = ((uint16_t) tmp[4] << 8 )| tmp[5];\n\taxp_reads(charger->master,AXP22_OCVBATH_RES,2,tmp);\n\tadc->ocvbat_res = ((uint16_t) tmp[0] << 8 )| tmp[1];\n\taxp_reads(charger->master,AXP22_VTS_RES,2,tmp);\n\tadc->ts_res = ((uint16_t) tmp[0] << 8 )| tmp[1];\n}", "item_id": 13, "repo": "xregist/v3s-linux-sdk", "file": "linux-3.4/drivers/power/axp_power/axp22-sply.c", "last_update_at": "2020-01-31T10:27:07+00:00", "question_id": "ee72d55a9939b25def927ed0ead36a854248dff4_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void axp_read_adc(struct axp_charger *charger,\n  struct axp_adc_res *adc)\n{\n\tuint8_t tmp[8];\n\tadc->vac_res = 0;\n\tadc->iac_res = 0;\n\tadc->vusb_res = 0;\n\tadc->iusb_res = 0;\n\t\n\taxp_reads(charger->master,AXP22_VBATH_RES,6,tmp);\n\tadc->vbat_res = ((uint16_t) tmp[0] << 8 )| tmp[1];\n\tadc->ichar_res = ((uint16_t) tmp[2] << 8 )| tmp[3];\n\tadc->idischar_res = ((uint16_t) tmp[4] << 8 )| tmp[5];\n\taxp_reads(charger->master,AXP22_OCVBATH_RES,2,tmp);\n\tadc->ocvbat_res = ((uint16_t) tmp[0] << 8 )| tmp[1];\n\taxp_reads(charger->master,AXP22_VTS_RES,2,tmp);\n\tadc->ts_res = ((uint16_t) tmp[0] << 8 )| tmp[1];\n"]]}
{"hexsha": "7bf34352bb5c6764bc70d119481a9983d62ee43a", "ext": "c", "lang": "C", "content": "static inline uint32_t adc_read_u32(analogin_t *obj)\n{\n    uint32_t value;\n#if ANALOGIN_MEDIAN_FILTER\n    uint32_t v1 = adc_read(obj);\n    uint32_t v2 = adc_read(obj);\n    uint32_t v3 = adc_read(obj);\n    order(&v1, &v2);\n    order(&v2, &v3);\n    order(&v1, &v2);\n    value = v2;\n#else\n    value = adc_read(obj);\n#endif\n    return value;\n}", "item_id": 2, "repo": "volty98/nxp-legacy-lpc-mbed6", "file": "TARGET_LPC82X/analogin_api.c", "last_update_at": "2020-07-15T16:17:30+00:00", "question_id": "7bf34352bb5c6764bc70d119481a9983d62ee43a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline uint32_t adc_read_u32(analogin_t *obj)\n{\n    uint32_t value;\n#if ANALOGIN_MEDIAN_FILTER\n    uint32_t v1 = adc_read(obj);\n    uint32_t v2 = adc_read(obj);\n    uint32_t v3 = adc_read(obj);\n    order(&v1, &v2);\n    order(&v2, &v3);\n    order(&v1, &v2);\n    value = v2;\n#else\n    value = adc_read(obj);\n#endif\n    return value;\n"]]}
{"hexsha": "19299e377e35a371d414fbd0db1727c9ee477621", "ext": "c", "lang": "C", "content": "const char * __thiscall IVRSystem_020_GetEventTypeNameFromEnum(void *_this, EVREventType eType)\n{\n    push_ptr_parameter(_this);\n    push_uint32_parameter(eType);\n    return 0;\n}", "item_id": 23, "repo": "vsod99/proton-ge-custom", "file": "vrclient_x64/tests/capi_thunks_autogen.c", "last_update_at": "2020-11-20T12:58:47+00:00", "question_id": "19299e377e35a371d414fbd0db1727c9ee477621_23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const char * __thiscall IVRSystem_020_GetEventTypeNameFromEnum(void *_this, EVREventType eType)\n{\n    push_ptr_parameter(_this);\n    push_uint32_parameter(eType);\n    return 0;\n"]]}
{"hexsha": "d06e5ec57792bc339dd38e05fcd492492bbd38db", "ext": "h", "lang": "C", "content": "namespace device {\n\nstruct CtapGetAssertionRequest;\nstruct CtapGetAssertionOptions;\nstruct CtapMakeCredentialRequest;\nstruct EnumerateRPsResponse;\nclass FidoDevice;\nclass FidoTask;\n\n// Adaptor class from a |FidoDevice| to the |FidoAuthenticator| interface.\n// Responsible for translating WebAuthn-level requests into serializations that\n// can be passed to the device for transport.\nclass COMPONENT_EXPORT(DEVICE_FIDO) FidoDeviceAuthenticator\n    : public FidoAuthenticator {\n public:\n  explicit FidoDeviceAuthenticator(std::unique_ptr<FidoDevice> device);\n  ~FidoDeviceAuthenticator() override;\n\n  // FidoAuthenticator:\n  void InitializeAuthenticator(base::OnceClosure callback) override;\n  void ExcludeAppIdCredentialsBeforeMakeCredential(\n      CtapMakeCredentialRequest request,\n      base::OnceCallback<void(CtapDeviceResponseCode, absl::optional<bool>)>)\n      override;\n  void MakeCredential(CtapMakeCredentialRequest request,\n                      MakeCredentialCallback callback) override;\n  void GetAssertion(CtapGetAssertionRequest request,\n                    CtapGetAssertionOptions options,\n                    GetAssertionCallback callback) override;\n  void GetNextAssertion(GetAssertionCallback callback) override;\n  void GetTouch(base::OnceClosure callback) override;\n  void GetPinRetries(GetRetriesCallback callback) override;\n  void GetPINToken(std::string pin,\n                   std::vector<pin::Permissions> permissions,\n                   absl::optional<std::string> rp_id,\n                   GetTokenCallback callback) override;\n  void GetUvRetries(GetRetriesCallback callback) override;\n  bool CanGetUvToken() override;\n  void GetUvToken(std::vector<pin::Permissions> permissions,\n                  absl::optional<std::string> rp_id,\n                  GetTokenCallback callback) override;\n  uint32_t CurrentMinPINLength() override;\n  uint32_t NewMinPINLength() override;\n  bool ForcePINChange() override;\n  void SetPIN(const std::string& pin, SetPINCallback callback) override;\n  void ChangePIN(const std::string& old_pin,\n                 const std::string& new_pin,\n                 SetPINCallback callback) override;\n  PINUVDisposition PINUVDispositionForMakeCredential(\n      const CtapMakeCredentialRequest& request,\n      const FidoRequestHandlerBase::Observer* observer) override;\n\n  // WillNeedPINToGetAssertion returns whether a PIN prompt will be needed to\n  // serve the given request on this authenticator.\n  PINUVDisposition PINUVDispositionForGetAssertion(\n      const CtapGetAssertionRequest& request,\n      const FidoRequestHandlerBase::Observer* observer) override;\n\n  void GetCredentialsMetadata(const pin::TokenResponse& pin_token,\n                              GetCredentialsMetadataCallback callback) override;\n  void EnumerateCredentials(const pin::TokenResponse& pin_token,\n                            EnumerateCredentialsCallback callback) override;\n  void DeleteCredential(const pin::TokenResponse& pin_token,\n                        const PublicKeyCredentialDescriptor& credential_id,\n                        DeleteCredentialCallback callback) override;\n\n  void GetModality(BioEnrollmentCallback callback) override;\n  void GetSensorInfo(BioEnrollmentCallback callback) override;\n  void BioEnrollFingerprint(const pin::TokenResponse&,\n                            absl::optional<std::vector<uint8_t>> template_id,\n                            BioEnrollmentCallback) override;\n  void BioEnrollCancel(BioEnrollmentCallback) override;\n  void BioEnrollEnumerate(const pin::TokenResponse&,\n                          BioEnrollmentCallback) override;\n  void BioEnrollRename(const pin::TokenResponse&,\n                       std::vector<uint8_t> template_id,\n                       std::string name,\n                       BioEnrollmentCallback) override;\n  void BioEnrollDelete(const pin::TokenResponse&,\n                       std::vector<uint8_t> template_id,\n                       BioEnrollmentCallback) override;\n  void WriteLargeBlob(\n      const std::vector<uint8_t>& large_blob,\n      const LargeBlobKey& large_blob_key,\n      absl::optional<pin::TokenResponse> pin_uv_auth_token,\n      base::OnceCallback<void(CtapDeviceResponseCode)> callback) override;\n  void ReadLargeBlob(const std::vector<LargeBlobKey>& large_blob_keys,\n                     absl::optional<pin::TokenResponse> pin_uv_auth_token,\n                     LargeBlobReadCallback callback) override;\n\n  absl::optional<base::span<const int32_t>> GetAlgorithms() override;\n  bool DiscoverableCredentialStorageFull() const override;\n\n  void Reset(ResetCallback callback) override;\n  void Cancel() override;\n  std::string GetId() const override;\n  std::string GetDisplayName() const override;\n  ProtocolVersion SupportedProtocol() const override;\n  bool SupportsHMACSecretExtension() const override;\n  bool SupportsEnterpriseAttestation() const override;\n  bool SupportsCredBlobOfSize(size_t num_bytes) const override;\n  const absl::optional<AuthenticatorSupportedOptions>& Options() const override;\n  absl::optional<FidoTransportProtocol> AuthenticatorTransport() const override;\n  bool IsInPairingMode() const override;\n  bool IsPaired() const override;\n  bool RequiresBlePairingPin() const override;\n#if defined(OS_WIN)\n  bool IsWinNativeApiAuthenticator() const override;\n#endif  // defined(OS_WIN)\n#if defined(OS_MAC)\n  bool IsTouchIdAuthenticator() const override;\n#endif  // defined(OS_MAC)\n#if BUILDFLAG(IS_CHROMEOS_ASH)\n  bool IsChromeOSAuthenticator() const override;\n#endif  // BUILDFLAG(IS_CHROMEOS_ASH)\n  base::WeakPtr<FidoAuthenticator> GetWeakPtr() override;\n\n  FidoDevice* device() { return device_.get(); }\n  void SetTaskForTesting(std::unique_ptr<FidoTask> task);\n\n protected:\n  void OnCtapMakeCredentialResponseReceived(\n      MakeCredentialCallback callback,\n      absl::optional<std::vector<uint8_t>> response_data);\n  void OnCtapGetAssertionResponseReceived(\n      GetAssertionCallback callback,\n      absl::optional<std::vector<uint8_t>> response_data);\n\n private:\n  using GetEphemeralKeyCallback =\n      base::OnceCallback<void(CtapDeviceResponseCode,\n                              absl::optional<pin::KeyAgreementResponse>)>;\n  void InitializeAuthenticatorDone(base::OnceClosure callback);\n  void GetEphemeralKey(GetEphemeralKeyCallback callback);\n  void DoGetAssertion(CtapGetAssertionRequest request,\n                      CtapGetAssertionOptions options,\n                      GetAssertionCallback callback);\n  void OnHaveEphemeralKeyForGetAssertion(\n      CtapGetAssertionRequest request,\n      CtapGetAssertionOptions options,\n      GetAssertionCallback callback,\n      CtapDeviceResponseCode status,\n      absl::optional<pin::KeyAgreementResponse> key);\n  void OnHaveEphemeralKeyForGetPINToken(\n      std::string pin,\n      std::vector<pin::Permissions> permissions,\n      absl::optional<std::string> rp_id,\n      GetTokenCallback callback,\n      CtapDeviceResponseCode status,\n      absl::optional<pin::KeyAgreementResponse> key);\n  void OnHaveEphemeralKeyForSetPIN(\n      std::string pin,\n      SetPINCallback callback,\n      CtapDeviceResponseCode status,\n      absl::optional<pin::KeyAgreementResponse> key);\n  void OnHaveEphemeralKeyForChangePIN(\n      std::string old_pin,\n      std::string new_pin,\n      SetPINCallback callback,\n      CtapDeviceResponseCode status,\n      absl::optional<pin::KeyAgreementResponse> key);\n  void OnHaveEphemeralKeyForUvToken(\n      absl::optional<std::string> rp_id,\n      std::vector<pin::Permissions> permissions,\n      GetTokenCallback callback,\n      CtapDeviceResponseCode status,\n      absl::optional<pin::KeyAgreementResponse> key);\n\n  void FetchLargeBlobArray(\n      absl::optional<pin::TokenResponse> pin_uv_auth_token,\n      LargeBlobArrayReader large_blob_array_reader,\n      base::OnceCallback<void(CtapDeviceResponseCode,\n                              absl::optional<LargeBlobArrayReader>)> callback);\n  void WriteLargeBlobArray(\n      absl::optional<pin::TokenResponse> pin_uv_auth_token,\n      LargeBlobArrayWriter large_blob_array_writer,\n      base::OnceCallback<void(CtapDeviceResponseCode)> callback);\n  void OnReadLargeBlobFragment(\n      const size_t bytes_requested,\n      LargeBlobArrayReader large_blob_array_reader,\n      absl::optional<pin::TokenResponse> pin_uv_auth_token,\n      base::OnceCallback<void(CtapDeviceResponseCode,\n                              absl::optional<LargeBlobArrayReader>)> callback,\n      CtapDeviceResponseCode status,\n      absl::optional<LargeBlobsResponse> response);\n  void OnWriteLargeBlobFragment(\n      LargeBlobArrayWriter large_blob_array_writer,\n      absl::optional<pin::TokenResponse> pin_uv_auth_token,\n      base::OnceCallback<void(CtapDeviceResponseCode)> callback,\n      CtapDeviceResponseCode status,\n      absl::optional<LargeBlobsResponse> response);\n  void OnHaveLargeBlobArrayForWrite(\n      const std::vector<uint8_t>& large_blob,\n      const LargeBlobKey& large_blob_key,\n      absl::optional<pin::TokenResponse> pin_uv_auth_token,\n      base::OnceCallback<void(CtapDeviceResponseCode)> callback,\n      CtapDeviceResponseCode status,\n      absl::optional<LargeBlobArrayReader> large_blob_array_reader);\n  void OnHaveLargeBlobArrayForRead(\n      const std::vector<LargeBlobKey>& large_blob_keys,\n      LargeBlobReadCallback callback,\n      CtapDeviceResponseCode status,\n      absl::optional<LargeBlobArrayReader> large_blob_array_reader);\n\n  template <typename... Args>\n  void TaskClearProxy(base::OnceCallback<void(Args...)> callback, Args... args);\n  template <typename... Args>\n  void OperationClearProxy(base::OnceCallback<void(Args...)> callback,\n                           Args... args);\n  template <typename Task, typename Response, typename... RequestArgs>\n  void RunTask(RequestArgs&&... request_args,\n               base::OnceCallback<void(CtapDeviceResponseCode,\n                                       absl::optional<Response>)> callback);\n  template <typename Request, typename Response>\n  void RunOperation(Request request,\n                    base::OnceCallback<void(CtapDeviceResponseCode,\n                                            absl::optional<Response>)> callback,\n                    base::OnceCallback<absl::optional<Response>(\n                        const absl::optional<cbor::Value>&)> parser,\n                    bool (*string_fixup_predicate)(\n                        const std::vector<const cbor::Value*>&) = nullptr);\n\n  struct EnumerateCredentialsState;\n  void OnEnumerateRPsDone(EnumerateCredentialsState state,\n                          CtapDeviceResponseCode status,\n                          absl::optional<EnumerateRPsResponse> response);\n  void OnEnumerateCredentialsDone(\n      EnumerateCredentialsState state,\n      CtapDeviceResponseCode status,\n      absl::optional<EnumerateCredentialsResponse> response);\n\n  size_t max_large_blob_fragment_length();\n\n  const std::unique_ptr<FidoDevice> device_;\n  absl::optional<AuthenticatorSupportedOptions> options_;\n  std::unique_ptr<FidoTask> task_;\n  std::unique_ptr<GenericDeviceOperation> operation_;\n\n  // The highest advertised PINUVAuthProtocol version that the authenticator\n  // supports. This is guaranteed to be non-null after authenticator\n  // initialization if |options_| indicates that PIN is supported.\n  absl::optional<PINUVAuthProtocol> chosen_pin_uv_auth_protocol_;\n\n  base::WeakPtrFactory<FidoDeviceAuthenticator> weak_factory_{this};\n\n  DISALLOW_COPY_AND_ASSIGN(FidoDeviceAuthenticator);\n};\n\n}", "item_id": 0, "repo": "DamieFC/chromium", "file": "device/fido/fido_device_authenticator.h", "last_update_at": "2020-10-18T02:33:40+00:00", "question_id": "d06e5ec57792bc339dd38e05fcd492492bbd38db_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace device {\nstruct CtapGetAssertionRequest;\nstruct CtapGetAssertionOptions;\nstruct CtapMakeCredentialRequest;\nstruct EnumerateRPsResponse;\nclass FidoDevice;\nclass FidoTask;\n// Adaptor class from a |FidoDevice| to the |FidoAuthenticator| interface.\n// Responsible for translating WebAuthn-level requests into serializations that\n// can be passed to the device for transport.\nclass COMPONENT_EXPORT(DEVICE_FIDO) FidoDeviceAuthenticator\n    : public FidoAuthenticator {\n public:\n  explicit FidoDeviceAuthenticator(std::unique_ptr<FidoDevice> device);\n  ~FidoDeviceAuthenticator() override;\n  // FidoAuthenticator:\n  void InitializeAuthenticator(base::OnceClosure callback) override;\n  void ExcludeAppIdCredentialsBeforeMakeCredential(\n      CtapMakeCredentialRequest request,\n      base::OnceCallback<void(CtapDeviceResponseCode, absl::optional<bool>)>)\n      override;\n  void MakeCredential(CtapMakeCredentialRequest request,\n                      MakeCredentialCallback callback) override;\n  void GetAssertion(CtapGetAssertionRequest request,\n                    CtapGetAssertionOptions options,\n                    GetAssertionCallback callback) override;\n  void GetNextAssertion(GetAssertionCallback callback) override;\n  void GetTouch(base::OnceClosure callback) override;\n  void GetPinRetries(GetRetriesCallback callback) override;\n  void GetPINToken(std::string pin,\n                   std::vector<pin::Permissions> permissions,\n                   absl::optional<std::string> rp_id,\n                   GetTokenCallback callback) override;\n  void GetUvRetries(GetRetriesCallback callback) override;\n  bool CanGetUvToken() override;\n  void GetUvToken(std::vector<pin::Permissions> permissions,\n                  absl::optional<std::string> rp_id,\n                  GetTokenCallback callback) override;\n  uint32_t CurrentMinPINLength() override;\n  uint32_t NewMinPINLength() override;\n  bool ForcePINChange() override;\n  void SetPIN(const std::string& pin, SetPINCallback callback) override;\n  void ChangePIN(const std::string& old_pin,\n                 const std::string& new_pin,\n                 SetPINCallback callback) override;\n  PINUVDisposition PINUVDispositionForMakeCredential(\n      const CtapMakeCredentialRequest& request,\n      const FidoRequestHandlerBase::Observer* observer) override;\n  // WillNeedPINToGetAssertion returns whether a PIN prompt will be needed to\n  // serve the given request on this authenticator.\n  PINUVDisposition PINUVDispositionForGetAssertion(\n      const CtapGetAssertionRequest& request,\n      const FidoRequestHandlerBase::Observer* observer) override;\n  void GetCredentialsMetadata(const pin::TokenResponse& pin_token,\n                              GetCredentialsMetadataCallback callback) override;\n  void EnumerateCredentials(const pin::TokenResponse& pin_token,\n                            EnumerateCredentialsCallback callback) override;\n  void DeleteCredential(const pin::TokenResponse& pin_token,\n                        const PublicKeyCredentialDescriptor& credential_id,\n                        DeleteCredentialCallback callback) override;\n  void GetModality(BioEnrollmentCallback callback) override;\n  void GetSensorInfo(BioEnrollmentCallback callback) override;\n  void BioEnrollFingerprint(const pin::TokenResponse&,\n                            absl::optional<std::vector<uint8_t>> template_id,\n                            BioEnrollmentCallback) override;\n  void BioEnrollCancel(BioEnrollmentCallback) override;\n  void BioEnrollEnumerate(const pin::TokenResponse&,\n                          BioEnrollmentCallback) override;\n  void BioEnrollRename(const pin::TokenResponse&,\n                       std::vector<uint8_t> template_id,\n                       std::string name,\n                       BioEnrollmentCallback) override;\n  void BioEnrollDelete(const pin::TokenResponse&,\n                       std::vector<uint8_t> template_id,\n                       BioEnrollmentCallback) override;\n  void WriteLargeBlob(\n      const std::vector<uint8_t>& large_blob,\n      const LargeBlobKey& large_blob_key,\n      absl::optional<pin::TokenResponse> pin_uv_auth_token,\n      base::OnceCallback<void(CtapDeviceResponseCode)> callback) override;\n  void ReadLargeBlob(const std::vector<LargeBlobKey>& large_blob_keys,\n                     absl::optional<pin::TokenResponse> pin_uv_auth_token,\n                     LargeBlobReadCallback callback) override;\n  absl::optional<base::span<const int32_t>> GetAlgorithms() override;\n  bool DiscoverableCredentialStorageFull() const override;\n  void Reset(ResetCallback callback) override;\n  void Cancel() override;\n  std::string GetId() const override;\n  std::string GetDisplayName() const override;\n  ProtocolVersion SupportedProtocol() const override;\n  bool SupportsHMACSecretExtension() const override;\n  bool SupportsEnterpriseAttestation() const override;\n  bool SupportsCredBlobOfSize(size_t num_bytes) const override;\n  const absl::optional<AuthenticatorSupportedOptions>& Options() const override;\n  absl::optional<FidoTransportProtocol> AuthenticatorTransport() const override;\n  bool IsInPairingMode() const override;\n  bool IsPaired() const override;\n  bool RequiresBlePairingPin() const override;\n#if defined(OS_WIN)\n  bool IsWinNativeApiAuthenticator() const override;\n#endif  // defined(OS_WIN)\n#if defined(OS_MAC)\n  bool IsTouchIdAuthenticator() const override;\n#endif  // defined(OS_MAC)\n#if BUILDFLAG(IS_CHROMEOS_ASH)\n  bool IsChromeOSAuthenticator() const override;\n#endif  // BUILDFLAG(IS_CHROMEOS_ASH)\n  base::WeakPtr<FidoAuthenticator> GetWeakPtr() override;\n  FidoDevice* device() { return device_.get(); }\n  void SetTaskForTesting(std::unique_ptr<FidoTask> task);\n protected:\n  void OnCtapMakeCredentialResponseReceived(\n      MakeCredentialCallback callback,\n      absl::optional<std::vector<uint8_t>> response_data);\n  void OnCtapGetAssertionResponseReceived(\n      GetAssertionCallback callback,\n      absl::optional<std::vector<uint8_t>> response_data);\n private:\n  using GetEphemeralKeyCallback =\n      base::OnceCallback<void(CtapDeviceResponseCode,\n                              absl::optional<pin::KeyAgreementResponse>)>;\n  void InitializeAuthenticatorDone(base::OnceClosure callback);\n  void GetEphemeralKey(GetEphemeralKeyCallback callback);\n  void DoGetAssertion(CtapGetAssertionRequest request,\n                      CtapGetAssertionOptions options,\n                      GetAssertionCallback callback);\n  void OnHaveEphemeralKeyForGetAssertion(\n      CtapGetAssertionRequest request,\n      CtapGetAssertionOptions options,\n      GetAssertionCallback callback,\n      CtapDeviceResponseCode status,\n      absl::optional<pin::KeyAgreementResponse> key);\n  void OnHaveEphemeralKeyForGetPINToken(\n      std::string pin,\n      std::vector<pin::Permissions> permissions,\n      absl::optional<std::string> rp_id,\n      GetTokenCallback callback,\n      CtapDeviceResponseCode status,\n      absl::optional<pin::KeyAgreementResponse> key);\n  void OnHaveEphemeralKeyForSetPIN(\n      std::string pin,\n      SetPINCallback callback,\n      CtapDeviceResponseCode status,\n      absl::optional<pin::KeyAgreementResponse> key);\n  void OnHaveEphemeralKeyForChangePIN(\n      std::string old_pin,\n      std::string new_pin,\n      SetPINCallback callback,\n      CtapDeviceResponseCode status,\n      absl::optional<pin::KeyAgreementResponse> key);\n  void OnHaveEphemeralKeyForUvToken(\n      absl::optional<std::string> rp_id,\n      std::vector<pin::Permissions> permissions,\n      GetTokenCallback callback,\n      CtapDeviceResponseCode status,\n      absl::optional<pin::KeyAgreementResponse> key);\n  void FetchLargeBlobArray(\n      absl::optional<pin::TokenResponse> pin_uv_auth_token,\n      LargeBlobArrayReader large_blob_array_reader,\n      base::OnceCallback<void(CtapDeviceResponseCode,\n                              absl::optional<LargeBlobArrayReader>)> callback);\n  void WriteLargeBlobArray(\n      absl::optional<pin::TokenResponse> pin_uv_auth_token,\n      LargeBlobArrayWriter large_blob_array_writer,\n      base::OnceCallback<void(CtapDeviceResponseCode)> callback);\n  void OnReadLargeBlobFragment(\n      const size_t bytes_requested,\n      LargeBlobArrayReader large_blob_array_reader,\n      absl::optional<pin::TokenResponse> pin_uv_auth_token,\n      base::OnceCallback<void(CtapDeviceResponseCode,\n                              absl::optional<LargeBlobArrayReader>)> callback,\n      CtapDeviceResponseCode status,\n      absl::optional<LargeBlobsResponse> response);\n  void OnWriteLargeBlobFragment(\n      LargeBlobArrayWriter large_blob_array_writer,\n      absl::optional<pin::TokenResponse> pin_uv_auth_token,\n      base::OnceCallback<void(CtapDeviceResponseCode)> callback,\n      CtapDeviceResponseCode status,\n      absl::optional<LargeBlobsResponse> response);\n  void OnHaveLargeBlobArrayForWrite(\n      const std::vector<uint8_t>& large_blob,\n      const LargeBlobKey& large_blob_key,\n      absl::optional<pin::TokenResponse> pin_uv_auth_token,\n      base::OnceCallback<void(CtapDeviceResponseCode)> callback,\n      CtapDeviceResponseCode status,\n      absl::optional<LargeBlobArrayReader> large_blob_array_reader);\n  void OnHaveLargeBlobArrayForRead(\n      const std::vector<LargeBlobKey>& large_blob_keys,\n      LargeBlobReadCallback callback,\n      CtapDeviceResponseCode status,\n      absl::optional<LargeBlobArrayReader> large_blob_array_reader);\n  template <typename... Args>\n  void TaskClearProxy(base::OnceCallback<void(Args...)> callback, Args... args);\n  template <typename... Args>\n  void OperationClearProxy(base::OnceCallback<void(Args...)> callback,\n                           Args... args);\n  template <typename Task, typename Response, typename... RequestArgs>\n  void RunTask(RequestArgs&&... request_args,\n               base::OnceCallback<void(CtapDeviceResponseCode,\n                                       absl::optional<Response>)> callback);\n  template <typename Request, typename Response>\n  void RunOperation(Request request,\n                    base::OnceCallback<void(CtapDeviceResponseCode,\n                                            absl::optional<Response>)> callback,\n                    base::OnceCallback<absl::optional<Response>(\n                        const absl::optional<cbor::Value>&)> parser,\n                    bool (*string_fixup_predicate)(\n                        const std::vector<const cbor::Value*>&) = nullptr);\n  struct EnumerateCredentialsState;\n  void OnEnumerateRPsDone(EnumerateCredentialsState state,\n                          CtapDeviceResponseCode status,\n                          absl::optional<EnumerateRPsResponse> response);\n  void OnEnumerateCredentialsDone(\n      EnumerateCredentialsState state,\n      CtapDeviceResponseCode status,\n      absl::optional<EnumerateCredentialsResponse> response);\n  size_t max_large_blob_fragment_length();\n  const std::unique_ptr<FidoDevice> device_;\n  absl::optional<AuthenticatorSupportedOptions> options_;\n  std::unique_ptr<FidoTask> task_;\n  std::unique_ptr<GenericDeviceOperation> operation_;\n  // The highest advertised PINUVAuthProtocol version that the authenticator\n  // supports. This is guaranteed to be non-null after authenticator\n  // initialization if |options_| indicates that PIN is supported.\n  absl::optional<PINUVAuthProtocol> chosen_pin_uv_auth_protocol_;\n  base::WeakPtrFactory<FidoDeviceAuthenticator> weak_factory_{this};\n  DISALLOW_COPY_AND_ASSIGN(FidoDeviceAuthenticator);\n};\n"]]}
{"hexsha": "b4ad7da439415ff02c885c05a4892f4e0a3817c2", "ext": "c", "lang": "C", "content": "void read_all(int* input_fds, int count) {\n    // \u0420\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0431\u044b\u0441\u0442\u0440\u043e, \u0442\u0430\u043a \u043a\u0430\u043a \u0447\u0438\u0442\u0430\u0435\u0442 \u0432\u0441\u0435 \u0447\u0442\u043e \u0435\u0441\u0442\u044c \u0432 \"\u0444\u0430\u0439\u043b\u0435\" \u043d\u0430 \u0434\u0430\u043d\u043d\u044b\u0439 \u043c\u043e\u043c\u0435\u043d\u0442 \u0432\u043d\u0435 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u0442\u043e\u0433\u043e \u043f\u0438\u0448\u0435\u0442 \u043b\u0438 \u0442\u0443\u0434\u0430 \u043a\u0442\u043e-\u043d\u0438\u0431\u0443\u0434\u044c \u0438\u043b\u0438 \u043d\u0435\u0442\n    // \u0423 \u044d\u0442\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430 \u0435\u0441\u0442\u044c \u0431\u043e\u043b\u044c\u0448\u0430\u044f \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u0430: \u0432\u043d\u0443\u0442\u0440\u0438 \u0432\u0435\u0447\u043d\u043e\u0433\u043e \u0446\u0438\u043a\u043b\u0430 \u043f\u043e\u0441\u0442\u043e\u044f\u043d\u043d\u043e \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0435 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0435.\n    // \u041f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f \u0442\u0440\u0430\u0442\u0438\u0442\u0441\u044f \u0432\u043f\u0443\u0441\u0442\u0443\u044e.\n    log_printf(\"Nonblock realisation start\\n\");\n    for (int i = 0; i < count; ++i) {\n        fcntl(input_fds[i], F_SETFL, fcntl(input_fds[i], F_GETFL) | O_NONBLOCK); // \u041f\u043e\u043c\u0435\u0442\u0438\u043b\u0438 \u0434\u0435\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0440\u044b \u043a\u0430\u043a \u043d\u0435\u0431\u043b\u043e\u043a\u0438\u0440\u0443\u044e\u0449\u0438\u0435\n    }\n    bool all_closed = false;\n    while (!all_closed) {\n        all_closed = true;\n        for (int i = 0; i < count; ++i) { // \u041f\u0440\u043e\u0445\u043e\u0434\u0438\u043c\u0441\u044f \u043f\u043e \u0432\u0441\u0435\u043c \u0444\u0430\u0439\u043b\u043e\u0432\u044b\u043c \u0434\u0435\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0440\u0430\u043c\n            if (input_fds[i] == -1) {\n                continue;\n            }\n            all_closed = false;\n            char buf[100];\n            int read_bytes = 0;\n            // \u041f\u044b\u0442\u0430\u0435\u043c\u0441\u044f \u0447\u0438\u0442\u0430\u0442\u044c \u043f\u043e\u043a\u0430 \u043b\u0438\u0431\u043e \u043d\u0435 \u043a\u043e\u043d\u0447\u0438\u0442\u0441\u044f \u0444\u0430\u0439\u043b, \u043b\u0438\u0431\u043e \u043d\u0435 \u043f\u043e\u0439\u043c\u0430\u0435\u043c \u043e\u0448\u0438\u0431\u043a\u0443\n            while ((read_bytes = read(input_fds[i], buf, sizeof(buf))) > 0) {\n                buf[read_bytes] = '\\0';\n                log_printf(\"Read from %d subprocess: %s\", i, buf);\n            }\n            if (read_bytes == 0) { // \u041b\u0438\u0431\u043e \u043f\u0440\u043e\u0447\u0438\u0442\u0430\u043b\u0438 \u0432\u0435\u0441\u044c \u0444\u0430\u0439\u043b\n                close(input_fds[i]);\n                input_fds[i] = -1;\n            } else {\n                conditional_handle_error(errno != EAGAIN, \"strange error\"); // \u041b\u0438\u0431\u043e \u043f\u043e\u0439\u043c\u0430\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 (+ \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0447\u0442\u043e \u043e\u0448\u0438\u0431\u043a\u0430 \u043e\u0436\u0438\u0434\u0430\u0435\u043c\u0430\u044f)\n            }\n        }\n    }\n    log_printf(\"Nonblock realisation finish\\n\");\n}", "item_id": 0, "repo": "yuri-pechatnov/caos_2019-2020", "file": "sem19-multiplexing/multiplexing_reader_nonblock.c", "last_update_at": "2020-07-21T17:18:06+00:00", "question_id": "b4ad7da439415ff02c885c05a4892f4e0a3817c2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void read_all(int* input_fds, int count) {\n    // \u0420\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0431\u044b\u0441\u0442\u0440\u043e, \u0442\u0430\u043a \u043a\u0430\u043a \u0447\u0438\u0442\u0430\u0435\u0442 \u0432\u0441\u0435 \u0447\u0442\u043e \u0435\u0441\u0442\u044c \u0432 \"\u0444\u0430\u0439\u043b\u0435\" \u043d\u0430 \u0434\u0430\u043d\u043d\u044b\u0439 \u043c\u043e\u043c\u0435\u043d\u0442 \u0432\u043d\u0435 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u0442\u043e\u0433\u043e \u043f\u0438\u0448\u0435\u0442 \u043b\u0438 \u0442\u0443\u0434\u0430 \u043a\u0442\u043e-\u043d\u0438\u0431\u0443\u0434\u044c \u0438\u043b\u0438 \u043d\u0435\u0442\n    // \u0423 \u044d\u0442\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430 \u0435\u0441\u0442\u044c \u0431\u043e\u043b\u044c\u0448\u0430\u044f \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u0430: \u0432\u043d\u0443\u0442\u0440\u0438 \u0432\u0435\u0447\u043d\u043e\u0433\u043e \u0446\u0438\u043a\u043b\u0430 \u043f\u043e\u0441\u0442\u043e\u044f\u043d\u043d\u043e \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0435 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0435.\n    // \u041f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f \u0442\u0440\u0430\u0442\u0438\u0442\u0441\u044f \u0432\u043f\u0443\u0441\u0442\u0443\u044e.\n    log_printf(\"Nonblock realisation start\\n\");\n    for (int i = 0; i < count; ++i) {\n        fcntl(input_fds[i], F_SETFL, fcntl(input_fds[i], F_GETFL) | O_NONBLOCK); // \u041f\u043e\u043c\u0435\u0442\u0438\u043b\u0438 \u0434\u0435\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0440\u044b \u043a\u0430\u043a \u043d\u0435\u0431\u043b\u043e\u043a\u0438\u0440\u0443\u044e\u0449\u0438\u0435\n    }\n    bool all_closed = false;\n    while (!all_closed) {\n        all_closed = true;\n        for (int i = 0; i < count; ++i) { // \u041f\u0440\u043e\u0445\u043e\u0434\u0438\u043c\u0441\u044f \u043f\u043e \u0432\u0441\u0435\u043c \u0444\u0430\u0439\u043b\u043e\u0432\u044b\u043c \u0434\u0435\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0440\u0430\u043c\n            if (input_fds[i] == -1) {\n                continue;\n            }\n            all_closed = false;\n            char buf[100];\n            int read_bytes = 0;\n            // \u041f\u044b\u0442\u0430\u0435\u043c\u0441\u044f \u0447\u0438\u0442\u0430\u0442\u044c \u043f\u043e\u043a\u0430 \u043b\u0438\u0431\u043e \u043d\u0435 \u043a\u043e\u043d\u0447\u0438\u0442\u0441\u044f \u0444\u0430\u0439\u043b, \u043b\u0438\u0431\u043e \u043d\u0435 \u043f\u043e\u0439\u043c\u0430\u0435\u043c \u043e\u0448\u0438\u0431\u043a\u0443\n            while ((read_bytes = read(input_fds[i], buf, sizeof(buf))) > 0) {\n                buf[read_bytes] = '\\0';\n                log_printf(\"Read from %d subprocess: %s\", i, buf);\n            }\n            if (read_bytes == 0) { // \u041b\u0438\u0431\u043e \u043f\u0440\u043e\u0447\u0438\u0442\u0430\u043b\u0438 \u0432\u0435\u0441\u044c \u0444\u0430\u0439\u043b\n                close(input_fds[i]);\n                input_fds[i] = -1;\n            } else {\n                conditional_handle_error(errno != EAGAIN, \"strange error\"); // \u041b\u0438\u0431\u043e \u043f\u043e\u0439\u043c\u0430\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443 (+ \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0447\u0442\u043e \u043e\u0448\u0438\u0431\u043a\u0430 \u043e\u0436\u0438\u0434\u0430\u0435\u043c\u0430\u044f)\n            }\n        }\n    }\n    log_printf(\"Nonblock realisation finish\\n\");\n"]]}
{"hexsha": "e9915549aeb073eb8ffe03325381ea200ced67f1", "ext": "c", "lang": "C", "content": "static mrb_value\nmrb_sdl2_input_mouse_set_cursor(mrb_state *mrb, mrb_value self)\n{\n  mrb_sdl2_input_mouse_cursor_data_t *data;\n  mrb_value cursor;\n  mrb_get_args(mrb, \"o\", &cursor);\n  data =\n    (mrb_sdl2_input_mouse_cursor_data_t*)mrb_data_get_ptr(mrb, cursor, &mrb_sdl2_input_mouse_cursor_data_type);\n  SDL_SetCursor(data->cursor);\n  data->is_associated = true;\n  return self;\n}", "item_id": 8, "repo": "kabies/mruby-sdl2", "file": "src/sdl2_mouse.c", "last_update_at": "2020-05-18T16:32:47+00:00", "question_id": "e9915549aeb073eb8ffe03325381ea200ced67f1_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static mrb_value\nmrb_sdl2_input_mouse_set_cursor(mrb_state *mrb, mrb_value self)\n{\n  mrb_sdl2_input_mouse_cursor_data_t *data;\n  mrb_value cursor;\n  mrb_get_args(mrb, \"o\", &cursor);\n  data =\n    (mrb_sdl2_input_mouse_cursor_data_t*)mrb_data_get_ptr(mrb, cursor, &mrb_sdl2_input_mouse_cursor_data_type);\n  SDL_SetCursor(data->cursor);\n  data->is_associated = true;\n  return self;\n"]]}
{"hexsha": "c04bf3627e694b5ac32712705e98beb67c612181", "ext": "c", "lang": "C", "content": "static Iter *\n_copyIter(Iter *from)\n{\n    Iter *newnode = makeNode(Iter);\n\n    Node_Copy(from, newnode, iterexpr);\n    newnode->itertype = from->itertype;\n    \n    return newnode;\n}", "item_id": 49, "repo": "xuefengedu/database", "file": "postgresql1commit/backend/nodes/copyfuncs.c", "last_update_at": "2020-03-31T15:03:51+00:00", "question_id": "c04bf3627e694b5ac32712705e98beb67c612181_49", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static Iter *\n_copyIter(Iter *from)\n{\n    Iter *newnode = makeNode(Iter);\n    Node_Copy(from, newnode, iterexpr);\n    newnode->itertype = from->itertype;\n    return newnode;\n"]]}
{"hexsha": "85226f2030c4ea5aa1cfa19ded9cdff16a3b75e0", "ext": "h", "lang": "C", "content": "interface SXComponentScrollPosition : SXScrollPosition {\n\n\tNSString* _componentIdentifier;\n\tdouble _relativePageOffset;\n\tdouble _canvasWidth;\n\n}", "item_id": 0, "repo": "zhangkn/iOS14Header", "file": "System/Library/PrivateFrameworks/Silex.framework/SXComponentScrollPosition.h", "last_update_at": "2020-11-04T15:43:01+00:00", "question_id": "85226f2030c4ea5aa1cfa19ded9cdff16a3b75e0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface SXComponentScrollPosition : SXScrollPosition {\n\tNSString* _componentIdentifier;\n\tdouble _relativePageOffset;\n\tdouble _canvasWidth;\n"]]}
{"hexsha": "00369752948b63109d26daceef125f2106a6a0a1", "ext": "c", "lang": "C", "content": "char *\nurl_decode(char *str, int max, const char *stopchars, int unsafe, int *is_utf8) {\n\tchar *ptr = str;\n\tint len = strlen(str);\n\tchar *end = str + (max >= 0 ? max : len);\n\tint trailing = 0;\n\tint minuch = 0, uch = 0;\n\n\tif (is_utf8)\n\t\t*is_utf8 = 1;\n\n\twhile (*ptr && ptr < end && (!stopchars || !strchr(stopchars, *ptr))) {\n\t\tif (*ptr == '%' && isxdigit(*(ptr + 1)) && isxdigit(*(ptr + 2))) {\n\t\t\tint a = *(unsigned char*)(ptr + 1);\n\t\t\tint b = *(unsigned char*)(ptr + 2);\n\n\t\t\tif (a <= '9')\n\t\t\t\ta -= '0';\n\t\t\telse if (a <= 'F')\n\t\t\t\ta -= 'A' - 10;\n\t\t\telse\n\t\t\t\ta -= 'a' - 10;\n\t\t\tif (b <= '9')\n\t\t\t\tb -= '0';\n\t\t\telse if (b <= 'F')\n\t\t\t\tb -= 'A' - 10;\n\t\t\telse\n\t\t\t\tb -= 'a' - 10;\n\t\t\t*ptr = a * 16 + b;\n\t\t\tif (!unsafe) {\n\t\t\t\tif (*ptr == '\\t')\n\t\t\t\t\t*ptr = ' ';\n\t\t\t\telse if (*(unsigned char*)ptr < ' ') /* Extra safety check. */\n\t\t\t\t\t*ptr = '?';\n\t\t\t}\n\t\t\tmemmove(ptr + 1, ptr + 3, str + len - (ptr + 3) + 1);\n\t\t\tend -= 2;\n\t\t\tlen -= 2;\n\t\t} else if (*ptr == '+') {\n\t\t\t*ptr = ' ';\n\t\t}\n\t\tif (is_utf8 && *is_utf8) {\n\t\t\tif ((*ptr & 0x80) == 0) {\n\t\t\t\tif (trailing > 0)\n\t\t\t\t\t*is_utf8 = 0;\n\t\t\t} else if ((*ptr & 0xC0) == 0x80) {\n\t\t\t\tuch = uch << 6 | (*ptr & 0x3F);\n\t\t\t\tif (--trailing < 0)\n\t\t\t\t\t*is_utf8 = 0;\n\t\t\t\telse if (trailing == 0 && uch < minuch)\n\t\t\t\t\t*is_utf8 = 0;\n\t\t\t} else if (trailing > 0) {\n\t\t\t\t*is_utf8 = 0;\n\t\t\t} else if ((*ptr & 0xE0) == 0xC0) {\n\t\t\t\ttrailing = 1;\n\t\t\t\tminuch = 0x80;\n\t\t\t\tuch = *ptr & 0x1F;\n\t\t\t} else if ((*ptr & 0xF0) == 0xE0) {\n\t\t\t\ttrailing = 2;\n\t\t\t\tminuch = 0x800;\n\t\t\t\tuch = *ptr & 0x1F;\n\t\t\t} else if ((*ptr & 0xF8) == 0xF0) {\n\t\t\t\ttrailing = 3;\n\t\t\t\tminuch = 0x10000;\n\t\t\t\tuch = *ptr & 0x1F;\n\t\t\t} else {\n\t\t\t\t*is_utf8 = 0;\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\tif (is_utf8 && trailing > 0)\n\t\t*is_utf8 = 0;\n\treturn ptr;\n}", "item_id": 1, "repo": "schibsted/sebase", "file": "util/lib/url.c", "last_update_at": "2020-09-07T23:36:40+00:00", "question_id": "00369752948b63109d26daceef125f2106a6a0a1_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char *\nurl_decode(char *str, int max, const char *stopchars, int unsafe, int *is_utf8) {\n\tchar *ptr = str;\n\tint len = strlen(str);\n\tchar *end = str + (max >= 0 ? max : len);\n\tint trailing = 0;\n\tint minuch = 0, uch = 0;\n\tif (is_utf8)\n\t\t*is_utf8 = 1;\n\twhile (*ptr && ptr < end && (!stopchars || !strchr(stopchars, *ptr))) {\n\t\tif (*ptr == '%' && isxdigit(*(ptr + 1)) && isxdigit(*(ptr + 2))) {\n\t\t\tint a = *(unsigned char*)(ptr + 1);\n\t\t\tint b = *(unsigned char*)(ptr + 2);\n\t\t\tif (a <= '9')\n\t\t\t\ta -= '0';\n\t\t\telse if (a <= 'F')\n\t\t\t\ta -= 'A' - 10;\n\t\t\telse\n\t\t\t\ta -= 'a' - 10;\n\t\t\tif (b <= '9')\n\t\t\t\tb -= '0';\n\t\t\telse if (b <= 'F')\n\t\t\t\tb -= 'A' - 10;\n\t\t\telse\n\t\t\t\tb -= 'a' - 10;\n\t\t\t*ptr = a * 16 + b;\n\t\t\tif (!unsafe) {\n\t\t\t\tif (*ptr == '\\t')\n\t\t\t\t\t*ptr = ' ';\n\t\t\t\telse if (*(unsigned char*)ptr < ' ') /* Extra safety check. */\n\t\t\t\t\t*ptr = '?';\n\t\t\t}\n\t\t\tmemmove(ptr + 1, ptr + 3, str + len - (ptr + 3) + 1);\n\t\t\tend -= 2;\n\t\t\tlen -= 2;\n\t\t} else if (*ptr == '+') {\n\t\t\t*ptr = ' ';\n\t\t}\n\t\tif (is_utf8 && *is_utf8) {\n\t\t\tif ((*ptr & 0x80) == 0) {\n\t\t\t\tif (trailing > 0)\n\t\t\t\t\t*is_utf8 = 0;\n\t\t\t} else if ((*ptr & 0xC0) == 0x80) {\n\t\t\t\tuch = uch << 6 | (*ptr & 0x3F);\n\t\t\t\tif (--trailing < 0)\n\t\t\t\t\t*is_utf8 = 0;\n\t\t\t\telse if (trailing == 0 && uch < minuch)\n\t\t\t\t\t*is_utf8 = 0;\n\t\t\t} else if (trailing > 0) {\n\t\t\t\t*is_utf8 = 0;\n\t\t\t} else if ((*ptr & 0xE0) == 0xC0) {\n\t\t\t\ttrailing = 1;\n\t\t\t\tminuch = 0x80;\n\t\t\t\tuch = *ptr & 0x1F;\n\t\t\t} else if ((*ptr & 0xF0) == 0xE0) {\n\t\t\t\ttrailing = 2;\n\t\t\t\tminuch = 0x800;\n\t\t\t\tuch = *ptr & 0x1F;\n\t\t\t} else if ((*ptr & 0xF8) == 0xF0) {\n\t\t\t\ttrailing = 3;\n\t\t\t\tminuch = 0x10000;\n\t\t\t\tuch = *ptr & 0x1F;\n\t\t\t} else {\n\t\t\t\t*is_utf8 = 0;\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\tif (is_utf8 && trailing > 0)\n\t\t*is_utf8 = 0;\n\treturn ptr;\n"]]}
{"hexsha": "bc28e1de3ac64b8634bbbfd471bd2bbf59e4a4c3", "ext": "c", "lang": "C", "content": "int camera_agent_set_auto_exposure(sensor_index_t sensor_index,u8 onoff)\n{\n\tu16 OpCode = ISPCMD_BASIC_SET_AUTOEXPOSURE;\n\tu32 cmd;\n\tu8 buf[3] = {0};\n\tint errorcode;\n\n\tprint_debug(\"Enter Function:%s=[%s]\", __func__, onoff?\"off\":\"on\");\n\tcmd = misp_construct_opcode(OpCode,SET_CMD,sizeof(buf));\n\tsensor_index = remap_sensor_index(sensor_index);\n\n\tbuf[0] = onoff;\n\tbuf[1] = onoff;\n\tbuf[2] = onoff;\n\n\terrorcode = misp_exec_cmd(cmd,buf);\n\tif (errorcode) {\n\t\tprint_error(\"%s fail, error code = %d\", __func__, errorcode);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "item_id": 34, "repo": "NightOfTwelve/android_device_huawei_hwp7", "file": "kernel/huawei/hwp7/drivers/huawei/drivers/camera/mini_isp/camera_agent.c", "last_update_at": "2020-04-03T14:00:34+00:00", "question_id": "bc28e1de3ac64b8634bbbfd471bd2bbf59e4a4c3_34", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int camera_agent_set_auto_exposure(sensor_index_t sensor_index,u8 onoff)\n{\n\tu16 OpCode = ISPCMD_BASIC_SET_AUTOEXPOSURE;\n\tu32 cmd;\n\tu8 buf[3] = {0};\n\tint errorcode;\n\tprint_debug(\"Enter Function:%s=[%s]\", __func__, onoff?\"off\":\"on\");\n\tcmd = misp_construct_opcode(OpCode,SET_CMD,sizeof(buf));\n\tsensor_index = remap_sensor_index(sensor_index);\n\tbuf[0] = onoff;\n\tbuf[1] = onoff;\n\tbuf[2] = onoff;\n\terrorcode = misp_exec_cmd(cmd,buf);\n\tif (errorcode) {\n\t\tprint_error(\"%s fail, error code = %d\", __func__, errorcode);\n\t\treturn -1;\n\t}\n\treturn 0;\n"]]}
{"hexsha": "4baa91bfad50003be92af1d4d21931c0431a0e67", "ext": "c", "lang": "C", "content": "inline static  void SimMainP$Scheduler$init(void){\n#line 46\n  SimSchedulerBasicP$Scheduler$init();\n#line 46\n}", "item_id": 7, "repo": "jryans/compass-dsr-tinyos", "file": "apps/tests/netarch/TestDsr2/build/micaz/app.c", "last_update_at": "2020-10-14T07:54:13+00:00", "question_id": "4baa91bfad50003be92af1d4d21931c0431a0e67_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["inline static  void SimMainP$Scheduler$init(void){\n#line 46\n  SimSchedulerBasicP$Scheduler$init();\n#line 46\n"]]}
{"hexsha": "cf5f4b9bc4c411a40ba0ed680a4b06a55f935d4c", "ext": "c", "lang": "C", "content": "const char *AVSC_CC avisynth_c_plugin_init( AVS_ScriptEnvironment* env )\n{\n    /* load the avs library */\n    if( ffms_load_avs_lib( env ) )\n        return \"Failure\";\n    ffms_avs_lib.avs_add_function( env, \"FFIndex\", \"[source]s[cachefile]s[indexmask]i[dumpmask]i[audiofile]s[errorhandling]i[overwrite]b[utf8]b\", create_FFIndex, 0 );\n    ffms_avs_lib.avs_add_function( env, \"FFVideoSource\", \"[source]s[track]i[cache]b[cachefile]s[fpsnum]i[fpsden]i[threads]i[timecodes]s[seekmode]i[rffmode]i[width]i[height]i[resizer]s[colorspace]s[utf8]b[varprefix]s\", create_FFVideoSource, 0 );\n    ffms_avs_lib.avs_add_function( env, \"FFAudioSource\", \"[source]s[track]i[cache]b[cachefile]s[adjustdelay]i[utf8]b[varprefix]s\", create_FFAudioSource, 0 );\n    ffms_avs_lib.avs_add_function( env, \"FFGetLogLevel\", \"\", create_FFGetLogLevel, 0 );\n    ffms_avs_lib.avs_add_function( env, \"FFSetLogLevel\", \"i\", create_FFSetLogLevel, 0 );\n    ffms_avs_lib.avs_add_function( env, \"FFGetVersion\", \"\", create_FFGetVersion, 0 );\n\n    /* tell avs to call our cleanup method when it closes */\n    ffms_avs_lib.avs_at_exit( env, ffms_free_avs_lib, 0 );\n    return \"FFmpegSource - The Second Coming V2.0 Final\";\n}", "item_id": 6, "repo": "qyot27/ffms2", "file": "src/avisynth_c/avisynth.c", "last_update_at": "2020-11-15T11:33:26+00:00", "question_id": "cf5f4b9bc4c411a40ba0ed680a4b06a55f935d4c_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const char *AVSC_CC avisynth_c_plugin_init( AVS_ScriptEnvironment* env )\n{\n    /* load the avs library */\n    if( ffms_load_avs_lib( env ) )\n        return \"Failure\";\n    ffms_avs_lib.avs_add_function( env, \"FFIndex\", \"[source]s[cachefile]s[indexmask]i[dumpmask]i[audiofile]s[errorhandling]i[overwrite]b[utf8]b\", create_FFIndex, 0 );\n    ffms_avs_lib.avs_add_function( env, \"FFVideoSource\", \"[source]s[track]i[cache]b[cachefile]s[fpsnum]i[fpsden]i[threads]i[timecodes]s[seekmode]i[rffmode]i[width]i[height]i[resizer]s[colorspace]s[utf8]b[varprefix]s\", create_FFVideoSource, 0 );\n    ffms_avs_lib.avs_add_function( env, \"FFAudioSource\", \"[source]s[track]i[cache]b[cachefile]s[adjustdelay]i[utf8]b[varprefix]s\", create_FFAudioSource, 0 );\n    ffms_avs_lib.avs_add_function( env, \"FFGetLogLevel\", \"\", create_FFGetLogLevel, 0 );\n    ffms_avs_lib.avs_add_function( env, \"FFSetLogLevel\", \"i\", create_FFSetLogLevel, 0 );\n    ffms_avs_lib.avs_add_function( env, \"FFGetVersion\", \"\", create_FFGetVersion, 0 );\n    /* tell avs to call our cleanup method when it closes */\n    ffms_avs_lib.avs_at_exit( env, ffms_free_avs_lib, 0 );\n    return \"FFmpegSource - The Second Coming V2.0 Final\";\n"]]}
{"hexsha": "f77092683f5350a554bd7cd3c21246e8fd7ce0fb", "ext": "c", "lang": "C", "content": "VS_EXTERNAL_API(void) VapourSynthPluginInit(VSConfigPlugin configFunc, VSRegisterFunction registerFunc, VSPlugin *plugin)\n{\n\tif (!zimg_check_api_version(ZIMG_API_VERSION))\n\t\treturn;\n\n\tconfigFunc(\"the.weather.channel\", \"z\", \"batman\", VAPOURSYNTH_API_VERSION, 1, plugin);\n\t\n\tregisterFunc(\"Colorspace\", \"clip:clip;\"\n\t                           \"matrix_in:int;\"\n\t                           \"transfer_in:int;\"\n\t                           \"primaries_in:int;\"\n\t                           \"matrix_out:int:opt;\"\n\t                           \"transfer_out:int:opt;\"\n\t                           \"primaries_out:int:opt\", vs_colorspace_create, 0, plugin);\n\tregisterFunc(\"Depth\", \"clip:clip;\"\n\t                      \"dither:data:opt;\"\n\t                      \"format:int:opt;\"\n\t                      \"sample:int:opt;\"\n\t                      \"depth:int:opt;\"\n\t                      \"fullrange_in:int:opt;\"\n\t                      \"fullrange_out:int:opt\", vs_depth_create, 0, plugin);\n\tregisterFunc(\"Resize\", \"clip:clip;\"\n\t                       \"width:int;\"\n\t                       \"height:int;\"\n\t                       \"filter:data:opt;\"\n\t                       \"filter_param_a:float:opt;\"\n\t                       \"filter_param_b:float:opt;\"\n\t                       \"shift_w:float:opt;\"\n\t                       \"shift_h:float:opt;\"\n\t                       \"subwidth:float:opt;\"\n\t                       \"subheight:float:opt;\"\n\t                       \"filter_uv:data:opt;\"\n\t                       \"filter_param_a_uv:float:opt;\"\n\t                       \"filter_param_b_uv:float:opt;\"\n\t                       \"subsample_w:int:opt;\"\n\t                       \"subsample_h:int:opt;\"\n\t                       \"chroma_loc_in:data:opt;\"\n\t                       \"chroma_loc_out:data:opt;\", vs_resize_create, 0, plugin);\n\n\tzimg_set_cpu(ZIMG_CPU_AUTO);\n}", "item_id": 10, "repo": "darcyg/vapoursynth-plugins", "file": "plugins/zimg/src/vszimg/vszimg.c", "last_update_at": "2020-04-06T16:52:59+00:00", "question_id": "f77092683f5350a554bd7cd3c21246e8fd7ce0fb_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["VS_EXTERNAL_API(void) VapourSynthPluginInit(VSConfigPlugin configFunc, VSRegisterFunction registerFunc, VSPlugin *plugin)\n{\n\tif (!zimg_check_api_version(ZIMG_API_VERSION))\n\t\treturn;\n\tconfigFunc(\"the.weather.channel\", \"z\", \"batman\", VAPOURSYNTH_API_VERSION, 1, plugin);\n\t\n\tregisterFunc(\"Colorspace\", \"clip:clip;\"\n\t                           \"matrix_in:int;\"\n\t                           \"transfer_in:int;\"\n\t                           \"primaries_in:int;\"\n\t                           \"matrix_out:int:opt;\"\n\t                           \"transfer_out:int:opt;\"\n\t                           \"primaries_out:int:opt\", vs_colorspace_create, 0, plugin);\n\tregisterFunc(\"Depth\", \"clip:clip;\"\n\t                      \"dither:data:opt;\"\n\t                      \"format:int:opt;\"\n\t                      \"sample:int:opt;\"\n\t                      \"depth:int:opt;\"\n\t                      \"fullrange_in:int:opt;\"\n\t                      \"fullrange_out:int:opt\", vs_depth_create, 0, plugin);\n\tregisterFunc(\"Resize\", \"clip:clip;\"\n\t                       \"width:int;\"\n\t                       \"height:int;\"\n\t                       \"filter:data:opt;\"\n\t                       \"filter_param_a:float:opt;\"\n\t                       \"filter_param_b:float:opt;\"\n\t                       \"shift_w:float:opt;\"\n\t                       \"shift_h:float:opt;\"\n\t                       \"subwidth:float:opt;\"\n\t                       \"subheight:float:opt;\"\n\t                       \"filter_uv:data:opt;\"\n\t                       \"filter_param_a_uv:float:opt;\"\n\t                       \"filter_param_b_uv:float:opt;\"\n\t                       \"subsample_w:int:opt;\"\n\t                       \"subsample_h:int:opt;\"\n\t                       \"chroma_loc_in:data:opt;\"\n\t                       \"chroma_loc_out:data:opt;\", vs_resize_create, 0, plugin);\n\tzimg_set_cpu(ZIMG_CPU_AUTO);\n"]]}
{"hexsha": "5724301122cb54e4eae26eaf08a8671f977aabb9", "ext": "c", "lang": "C", "content": "int fatorPrimo (int n) {\n  int i = 3, j = 0;\n  int maior = 0;\n  int fator = 0;\n  int aux = n;\n\n  while (j < n) {\n    if (aux % 2 == 0) {\n      aux -= aux / 2;\n      fator = 2;\n    } else if (aux % i == 0) {\n      aux -= aux / i;\n      fator = i;\n    } else {\n      i++;\n    }\n\n    if (fator > maior) { maior = fator; };\n    \n    j++;\n  }\n\n  return maior;\n}", "item_id": 0, "repo": "imsouza/c-backes", "file": "cap-09/exec12.c", "last_update_at": "2020-12-06T03:12:01+00:00", "question_id": "5724301122cb54e4eae26eaf08a8671f977aabb9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int fatorPrimo (int n) {\n  int i = 3, j = 0;\n  int maior = 0;\n  int fator = 0;\n  int aux = n;\n  while (j < n) {\n    if (aux % 2 == 0) {\n      aux -= aux / 2;\n      fator = 2;\n    } else if (aux % i == 0) {\n      aux -= aux / i;\n      fator = i;\n    } else {\n      i++;\n    }\n    if (fator > maior) { maior = fator; };\n    j++;\n  }\n  return maior;\n"]]}
{"hexsha": "e4c7d7200b5781b1ac1b6c7451720aea4dcd40a8", "ext": "c", "lang": "C", "content": "int stlink_flashloader_start(stlink_t *sl, flash_loader_t *fl) {\n  // disable DMA\n  set_dma_state(sl, fl, 0);\n\n  // wait for ongoing op to finish\n  wait_flash_busy(sl);\n  // Clear errors\n  clear_flash_error(sl);\n\n  if ((sl->flash_type == STM32_FLASH_TYPE_F2_F4) ||\n      (sl->flash_type == STM32_FLASH_TYPE_F7) ||\n      (sl->flash_type == STM32_FLASH_TYPE_L4_L4P)) {\n    ILOG(\"Starting Flash write for F2/F4/F7/L4\\n\");\n\n    // Flash loader initialisation\n    if (stlink_flash_loader_init(sl, fl) == -1) {\n      ELOG(\"stlink_flash_loader_init() == -1\\n\");\n      return (-1);\n    }\n\n    unlock_flash_if(sl); // first unlock the cr\n\n    int voltage;\n    if (sl->version.stlink_v == 1) {\n      WLOG(\"STLINK V1 cannot read voltage, use default voltage 3.2V\\n\");\n      voltage = 3200;\n    } else {\n      voltage = stlink_target_voltage(sl);\n    }\n\n    if (voltage == -1) {\n      ELOG(\"Failed to read Target voltage\\n\");\n      return (-1);\n    }\n\n    if (sl->flash_type == STM32_FLASH_TYPE_L4_L4P) {\n      // L4 does not have a byte-write mode\n      if (voltage < 1710) {\n        ELOG(\"Target voltage (%d mV) too low for flash writes!\\n\", voltage);\n        return (-1);\n      }\n    } else {\n      if (voltage > 2700) {\n        ILOG(\"enabling 32-bit flash writes\\n\");\n        write_flash_cr_psiz(sl, 2, BANK_1);\n      } else {\n        ILOG(\"Target voltage (%d mV) too low for 32-bit flash, \"\n             \"using 8-bit flash writes\\n\",\n             voltage);\n        write_flash_cr_psiz(sl, 0, BANK_1);\n      }\n    }\n\n    // set programming mode\n    set_flash_cr_pg(sl, BANK_1);\n  } else if (sl->flash_type == STM32_FLASH_TYPE_WB_WL ||\n             sl->flash_type == STM32_FLASH_TYPE_G0 ||\n             sl->flash_type == STM32_FLASH_TYPE_G4) {\n    ILOG(\"Starting Flash write for WB/G0/G4\\n\");\n\n    unlock_flash_if(sl);         // unlock flash if necessary\n    set_flash_cr_pg(sl, BANK_1); // set PG 'allow programming' bit\n  } else if (sl->flash_type == STM32_FLASH_TYPE_L0_L1) {\n    ILOG(\"Starting Flash write for L0\\n\");\n\n    uint32_t val;\n    uint32_t flash_regs_base = get_stm32l0_flash_base(sl);\n\n    // disable pecr protection\n    stlink_write_debug32(sl, flash_regs_base + FLASH_PEKEYR_OFF,\n                         FLASH_L0_PEKEY1);\n    stlink_write_debug32(sl, flash_regs_base + FLASH_PEKEYR_OFF,\n                         FLASH_L0_PEKEY2);\n\n    // check pecr.pelock is cleared\n    stlink_read_debug32(sl, flash_regs_base + FLASH_PECR_OFF, &val);\n    if (val & (1 << 0)) {\n      ELOG(\"pecr.pelock not clear\\n\");\n      return (-1);\n    }\n\n    // unlock program memory\n    stlink_write_debug32(sl, flash_regs_base + FLASH_PRGKEYR_OFF,\n                         FLASH_L0_PRGKEY1);\n    stlink_write_debug32(sl, flash_regs_base + FLASH_PRGKEYR_OFF,\n                         FLASH_L0_PRGKEY2);\n\n    // check pecr.prglock is cleared\n    stlink_read_debug32(sl, flash_regs_base + FLASH_PECR_OFF, &val);\n    if (val & (1 << 1)) {\n      ELOG(\"pecr.prglock not clear\\n\");\n      return (-1);\n    }\n\n    /* Flash loader initialisation */\n    if (stlink_flash_loader_init(sl, fl) == -1) {\n      // L0/L1 have fallback to soft write\n      WLOG(\"stlink_flash_loader_init() == -1\\n\");\n    }\n  } else if ((sl->flash_type == STM32_FLASH_TYPE_F0_F1_F3) ||\n             (sl->flash_type == STM32_FLASH_TYPE_F1_XL)) {\n    ILOG(\"Starting Flash write for VL/F0/F3/F1_XL\\n\");\n\n    // flash loader initialisation\n    if (stlink_flash_loader_init(sl, fl) == -1) {\n      ELOG(\"stlink_flash_loader_init() == -1\\n\");\n      return (-1);\n    }\n\n    // unlock flash\n    unlock_flash_if(sl);\n\n    // set programming mode\n    set_flash_cr_pg(sl, BANK_1);\n    if (sl->flash_type == STM32_FLASH_TYPE_F1_XL) {\n      set_flash_cr_pg(sl, BANK_2);\n    }\n  } else if (sl->flash_type == STM32_FLASH_TYPE_H7) {\n    ILOG(\"Starting Flash write for H7\\n\");\n\n    unlock_flash_if(sl);         // unlock the cr\n    set_flash_cr_pg(sl, BANK_1); // set programming mode\n    if (sl->chip_flags & CHIP_F_HAS_DUAL_BANK) {\n      set_flash_cr_pg(sl, BANK_2);\n    }\n    if (sl->chip_id != STM32_CHIPID_H7Ax) {\n      // set parallelism\n      write_flash_cr_psiz(sl, 3 /*64it*/, BANK_1);\n      if (sl->chip_flags & CHIP_F_HAS_DUAL_BANK) {\n        write_flash_cr_psiz(sl, 3 /*64bit*/, BANK_2);\n      }\n    }\n  } else {\n    ELOG(\"unknown coreid, not sure how to write: %x\\n\", sl->core_id);\n    return (-1);\n  }\n\n  return (0);\n}", "item_id": 3, "repo": "khoih-prog/stlink", "file": "src/flashloader.c", "last_update_at": "2020-04-07T15:04:54+00:00", "question_id": "e4c7d7200b5781b1ac1b6c7451720aea4dcd40a8_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int stlink_flashloader_start(stlink_t *sl, flash_loader_t *fl) {\n  // disable DMA\n  set_dma_state(sl, fl, 0);\n  // wait for ongoing op to finish\n  wait_flash_busy(sl);\n  // Clear errors\n  clear_flash_error(sl);\n  if ((sl->flash_type == STM32_FLASH_TYPE_F2_F4) ||\n      (sl->flash_type == STM32_FLASH_TYPE_F7) ||\n      (sl->flash_type == STM32_FLASH_TYPE_L4_L4P)) {\n    ILOG(\"Starting Flash write for F2/F4/F7/L4\\n\");\n    // Flash loader initialisation\n    if (stlink_flash_loader_init(sl, fl) == -1) {\n      ELOG(\"stlink_flash_loader_init() == -1\\n\");\n      return (-1);\n    }\n    unlock_flash_if(sl); // first unlock the cr\n    int voltage;\n    if (sl->version.stlink_v == 1) {\n      WLOG(\"STLINK V1 cannot read voltage, use default voltage 3.2V\\n\");\n      voltage = 3200;\n    } else {\n      voltage = stlink_target_voltage(sl);\n    }\n    if (voltage == -1) {\n      ELOG(\"Failed to read Target voltage\\n\");\n      return (-1);\n    }\n    if (sl->flash_type == STM32_FLASH_TYPE_L4_L4P) {\n      // L4 does not have a byte-write mode\n      if (voltage < 1710) {\n        ELOG(\"Target voltage (%d mV) too low for flash writes!\\n\", voltage);\n        return (-1);\n      }\n    } else {\n      if (voltage > 2700) {\n        ILOG(\"enabling 32-bit flash writes\\n\");\n        write_flash_cr_psiz(sl, 2, BANK_1);\n      } else {\n        ILOG(\"Target voltage (%d mV) too low for 32-bit flash, \"\n             \"using 8-bit flash writes\\n\",\n             voltage);\n        write_flash_cr_psiz(sl, 0, BANK_1);\n      }\n    }\n    // set programming mode\n    set_flash_cr_pg(sl, BANK_1);\n  } else if (sl->flash_type == STM32_FLASH_TYPE_WB_WL ||\n             sl->flash_type == STM32_FLASH_TYPE_G0 ||\n             sl->flash_type == STM32_FLASH_TYPE_G4) {\n    ILOG(\"Starting Flash write for WB/G0/G4\\n\");\n    unlock_flash_if(sl);         // unlock flash if necessary\n    set_flash_cr_pg(sl, BANK_1); // set PG 'allow programming' bit\n  } else if (sl->flash_type == STM32_FLASH_TYPE_L0_L1) {\n    ILOG(\"Starting Flash write for L0\\n\");\n    uint32_t val;\n    uint32_t flash_regs_base = get_stm32l0_flash_base(sl);\n    // disable pecr protection\n    stlink_write_debug32(sl, flash_regs_base + FLASH_PEKEYR_OFF,\n                         FLASH_L0_PEKEY1);\n    stlink_write_debug32(sl, flash_regs_base + FLASH_PEKEYR_OFF,\n                         FLASH_L0_PEKEY2);\n    // check pecr.pelock is cleared\n    stlink_read_debug32(sl, flash_regs_base + FLASH_PECR_OFF, &val);\n    if (val & (1 << 0)) {\n      ELOG(\"pecr.pelock not clear\\n\");\n      return (-1);\n    }\n    // unlock program memory\n    stlink_write_debug32(sl, flash_regs_base + FLASH_PRGKEYR_OFF,\n                         FLASH_L0_PRGKEY1);\n    stlink_write_debug32(sl, flash_regs_base + FLASH_PRGKEYR_OFF,\n                         FLASH_L0_PRGKEY2);\n    // check pecr.prglock is cleared\n    stlink_read_debug32(sl, flash_regs_base + FLASH_PECR_OFF, &val);\n    if (val & (1 << 1)) {\n      ELOG(\"pecr.prglock not clear\\n\");\n      return (-1);\n    }\n    /* Flash loader initialisation */\n    if (stlink_flash_loader_init(sl, fl) == -1) {\n      // L0/L1 have fallback to soft write\n      WLOG(\"stlink_flash_loader_init() == -1\\n\");\n    }\n  } else if ((sl->flash_type == STM32_FLASH_TYPE_F0_F1_F3) ||\n             (sl->flash_type == STM32_FLASH_TYPE_F1_XL)) {\n    ILOG(\"Starting Flash write for VL/F0/F3/F1_XL\\n\");\n    // flash loader initialisation\n    if (stlink_flash_loader_init(sl, fl) == -1) {\n      ELOG(\"stlink_flash_loader_init() == -1\\n\");\n      return (-1);\n    }\n    // unlock flash\n    unlock_flash_if(sl);\n    // set programming mode\n    set_flash_cr_pg(sl, BANK_1);\n    if (sl->flash_type == STM32_FLASH_TYPE_F1_XL) {\n      set_flash_cr_pg(sl, BANK_2);\n    }\n  } else if (sl->flash_type == STM32_FLASH_TYPE_H7) {\n    ILOG(\"Starting Flash write for H7\\n\");\n    unlock_flash_if(sl);         // unlock the cr\n    set_flash_cr_pg(sl, BANK_1); // set programming mode\n    if (sl->chip_flags & CHIP_F_HAS_DUAL_BANK) {\n      set_flash_cr_pg(sl, BANK_2);\n    }\n    if (sl->chip_id != STM32_CHIPID_H7Ax) {\n      // set parallelism\n      write_flash_cr_psiz(sl, 3 /*64it*/, BANK_1);\n      if (sl->chip_flags & CHIP_F_HAS_DUAL_BANK) {\n        write_flash_cr_psiz(sl, 3 /*64bit*/, BANK_2);\n      }\n    }\n  } else {\n    ELOG(\"unknown coreid, not sure how to write: %x\\n\", sl->core_id);\n    return (-1);\n  }\n  return (0);\n"]]}
{"hexsha": "ac4060e16e102410c0c11f982f759614dae2bad8", "ext": "c", "lang": "C", "content": "int main(void)\n{\n    int rows = 3;\n    int cols = 5;\n    double array[rows][cols];\n    input_array(rows, cols, array);\n    show_result(rows, cols, array);\n    return 0;\n}", "item_id": 0, "repo": "YIHONG-JIN/Solution-for-C-Primer-Plus-the-6th-", "file": "Chapter 10/practice/14.c", "last_update_at": "2020-11-24T14:24:39+00:00", "question_id": "ac4060e16e102410c0c11f982f759614dae2bad8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(void)\n{\n    int rows = 3;\n    int cols = 5;\n    double array[rows][cols];\n    input_array(rows, cols, array);\n    show_result(rows, cols, array);\n    return 0;\n"]]}
{"hexsha": "c0193a01d202c83bd69faaf43e9e146db5aa8a49", "ext": "c", "lang": "C", "content": "const char*\nrt_band_get_ext_path(rt_band band) {\n\n    assert(NULL != band);\n\n\n    if (!band->offline) {\n        RASTER_DEBUG(3, \"rt_band_get_ext_path: Band is not offline\");\n        return 0;\n    }\n    return band->data.offline.path;\n}", "item_id": 32, "repo": "vitessedata/gpdb.4.3.99.x", "file": "gpdb/contrib/postgis/raster/rt_core/rt_api.c", "last_update_at": "2020-07-08T12:59:12+00:00", "question_id": "c0193a01d202c83bd69faaf43e9e146db5aa8a49_32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const char*\nrt_band_get_ext_path(rt_band band) {\n    assert(NULL != band);\n    if (!band->offline) {\n        RASTER_DEBUG(3, \"rt_band_get_ext_path: Band is not offline\");\n        return 0;\n    }\n    return band->data.offline.path;\n"]]}
{"hexsha": "9e3e5f4468276476bd6c04456d96a1884a35d042", "ext": "c", "lang": "C", "content": "void initializeCrc()\n{\n    LL_CRC_SetInputDataReverseMode(CRC, LL_CRC_INDATA_REVERSE_NONE);\n    LL_CRC_SetOutputDataReverseMode(CRC, LL_CRC_OUTDATA_REVERSE_NONE);\n    LL_CRC_SetPolynomialCoef(CRC, LL_CRC_DEFAULT_CRC32_POLY);\n    LL_CRC_SetPolynomialSize(CRC, LL_CRC_POLYLENGTH_32B);\n    LL_CRC_SetInitialData(CRC, LL_CRC_DEFAULT_CRC_INITVALUE);\n\n    LL_CRC_SetPolynomialCoef(CRC, LINE_SENSOR_CRC_POLYNOMIAL);\n    LL_CRC_SetPolynomialSize(CRC, LL_CRC_POLYLENGTH_32B);\n}", "item_id": 4, "repo": "robot-corral/mazebot", "file": "software/line-sensor-wireless-interface/src/line_sensor_client.c", "last_update_at": "2020-03-17T04:13:31+00:00", "question_id": "9e3e5f4468276476bd6c04456d96a1884a35d042_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void initializeCrc()\n{\n    LL_CRC_SetInputDataReverseMode(CRC, LL_CRC_INDATA_REVERSE_NONE);\n    LL_CRC_SetOutputDataReverseMode(CRC, LL_CRC_OUTDATA_REVERSE_NONE);\n    LL_CRC_SetPolynomialCoef(CRC, LL_CRC_DEFAULT_CRC32_POLY);\n    LL_CRC_SetPolynomialSize(CRC, LL_CRC_POLYLENGTH_32B);\n    LL_CRC_SetInitialData(CRC, LL_CRC_DEFAULT_CRC_INITVALUE);\n    LL_CRC_SetPolynomialCoef(CRC, LINE_SENSOR_CRC_POLYNOMIAL);\n    LL_CRC_SetPolynomialSize(CRC, LL_CRC_POLYLENGTH_32B);\n"]]}
{"hexsha": "0c39d2babffaf5506c0e82b034edaf4d3d75908b", "ext": "c", "lang": "C", "content": "unsigned char crc8 (char *str, size_t len) {\n\tchar div = 0b10001100; // Rotated poly\n\tunsigned char crc = 0;\n\n\tsize_t i;\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char byte = str[i];\n\n\t\tint j;\n\t\tfor (j = 0; j < 8; j++) {\n\n\t\t\t// Shift CRC\n\t\t\tchar crc_carry = crc & 1;\n\t\t\tcrc >>= 1;\n\n\t\t\t// Shift Byte\n\t\t\tchar byte_carry = byte & 1;\n\t\t\tbyte >>= 1;\n\n\t\t\t// If crc_carry XOR byte_carry we make crc XOR div\n\t\t\tif (crc_carry ^ byte_carry)\n\t\t\t\tcrc ^= div;\n\t\t}\n\n\t}\n\n\treturn crc;\n}", "item_id": 5, "repo": "electronicayciencia/ds1820", "file": "ds1820_old/monitor/ds1820_monitor.c", "last_update_at": "2020-04-15T12:55:31+00:00", "question_id": "0c39d2babffaf5506c0e82b034edaf4d3d75908b_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsigned char crc8 (char *str, size_t len) {\n\tchar div = 0b10001100; // Rotated poly\n\tunsigned char crc = 0;\n\tsize_t i;\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char byte = str[i];\n\t\tint j;\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\t// Shift CRC\n\t\t\tchar crc_carry = crc & 1;\n\t\t\tcrc >>= 1;\n\t\t\t// Shift Byte\n\t\t\tchar byte_carry = byte & 1;\n\t\t\tbyte >>= 1;\n\t\t\t// If crc_carry XOR byte_carry we make crc XOR div\n\t\t\tif (crc_carry ^ byte_carry)\n\t\t\t\tcrc ^= div;\n\t\t}\n\t}\n\treturn crc;\n"]]}
{"hexsha": "e9cd65c84b2a5a0f3e939f57f074537106c3f23d", "ext": "c", "lang": "C", "content": "int KSI_PKISignature_serialize(const KSI_PKISignature *sig, unsigned char **raw, size_t *raw_len) {\n\tint res = KSI_UNKNOWN_ERROR;\n\tunsigned char *tmp = NULL;\n\n\tif (sig == NULL || raw == NULL || raw_len == NULL){\n\t\tres = KSI_INVALID_ARGUMENT;\n\t\tgoto cleanup;\n\t}\n\tKSI_ERR_clearErrors(sig->ctx);\n\n\n\ttmp = KSI_malloc(sig->pkcs7.cbData);\n\tif (tmp == NULL) {\n\t\tKSI_pushError(sig->ctx, res = KSI_OUT_OF_MEMORY, NULL);\n\t\tgoto cleanup;\n\t}\n\n\tmemcpy(tmp, sig->pkcs7.pbData, sig->pkcs7.cbData);\n\n\t*raw = tmp;\n\t*raw_len = (size_t)sig->pkcs7.cbData;\n\n\ttmp = NULL;\n\n\tres = KSI_OK;\n\ncleanup:\n\n\tKSI_free(tmp);\n\n\treturn res;\n}", "item_id": 3, "repo": "guardtime/libksi", "file": "src/ksi/pkitruststore_cryptoapi.c", "last_update_at": "2020-06-09T21:31:49+00:00", "question_id": "e9cd65c84b2a5a0f3e939f57f074537106c3f23d_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int KSI_PKISignature_serialize(const KSI_PKISignature *sig, unsigned char **raw, size_t *raw_len) {\n\tint res = KSI_UNKNOWN_ERROR;\n\tunsigned char *tmp = NULL;\n\tif (sig == NULL || raw == NULL || raw_len == NULL){\n\t\tres = KSI_INVALID_ARGUMENT;\n\t\tgoto cleanup;\n\t}\n\tKSI_ERR_clearErrors(sig->ctx);\n\ttmp = KSI_malloc(sig->pkcs7.cbData);\n\tif (tmp == NULL) {\n\t\tKSI_pushError(sig->ctx, res = KSI_OUT_OF_MEMORY, NULL);\n\t\tgoto cleanup;\n\t}\n\tmemcpy(tmp, sig->pkcs7.pbData, sig->pkcs7.cbData);\n\t*raw = tmp;\n\t*raw_len = (size_t)sig->pkcs7.cbData;\n\ttmp = NULL;\n\tres = KSI_OK;\ncleanup:\n\tKSI_free(tmp);\n\treturn res;\n"]]}
{"hexsha": "b115d1bfb1fd74fd8882385529f2f2ef2035cdba", "ext": "c", "lang": "C", "content": "ins* lookfor_inst ( mc88110* mc, unsigned int oc_deci )\n{\n    int left = 0;\n    int right = mc->n_insts - 3;\n    while( left <= right )\n    {\n        int medium = (left + right) / 2;\n        if ( (unsigned)mc->insts[medium].oc.deci < oc_deci )\n        {\n            left = medium + 1;\n        }\n        else if ( (unsigned)mc->insts[medium].oc.deci > oc_deci )\n        {\n            right = medium - 1;\n        }\n        else\n        {\n            return mc->insts + medium;\n        }\n    }\n    return mc->insts + (mc->n_insts - 2);\n}", "item_id": 38, "repo": "Kraftex/uni_upm", "file": "asignaturas segundo/Estructura de Computadores/own_emu.c", "last_update_at": "2020-07-11T16:24:21+00:00", "question_id": "b115d1bfb1fd74fd8882385529f2f2ef2035cdba_38", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ins* lookfor_inst ( mc88110* mc, unsigned int oc_deci )\n{\n    int left = 0;\n    int right = mc->n_insts - 3;\n    while( left <= right )\n    {\n        int medium = (left + right) / 2;\n        if ( (unsigned)mc->insts[medium].oc.deci < oc_deci )\n        {\n            left = medium + 1;\n        }\n        else if ( (unsigned)mc->insts[medium].oc.deci > oc_deci )\n        {\n            right = medium - 1;\n        }\n        else\n        {\n            return mc->insts + medium;\n        }\n    }\n    return mc->insts + (mc->n_insts - 2);\n"]]}
{"hexsha": "88163fe024c005148eeec1a180d0617fd9ccad74", "ext": "c", "lang": "C", "content": "void led_writeDisplay(_ADAFRUIT_LED* ptr){\n  i2c_start();\n  send_i2c_byte(ptr->i2c_addr);\n\tsend_i2c_byte(0x00); // Start at address 0\n\tuint8_t i;\n  for (i=0; i<8; i++) {\n    send_i2c_byte(ptr->displaybuffer[i] & 0xFF);\n    send_i2c_byte(ptr->displaybuffer[i] >> 8);\n  }\n  reset_i2c_bus();\n}", "item_id": 3, "repo": "aehoppe/BombSquad", "file": "lib/adafruit_led.c", "last_update_at": "2020-08-28T14:18:56+00:00", "question_id": "88163fe024c005148eeec1a180d0617fd9ccad74_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void led_writeDisplay(_ADAFRUIT_LED* ptr){\n  i2c_start();\n  send_i2c_byte(ptr->i2c_addr);\n\tsend_i2c_byte(0x00); // Start at address 0\n\tuint8_t i;\n  for (i=0; i<8; i++) {\n    send_i2c_byte(ptr->displaybuffer[i] & 0xFF);\n    send_i2c_byte(ptr->displaybuffer[i] >> 8);\n  }\n  reset_i2c_bus();\n"]]}
{"hexsha": "ca4fbedf8fded10a6f240d075f22a9162c273f3c", "ext": "c", "lang": "C", "content": "static int\nconnect_tcp_ip(const char *host, int display)\n{\n\tuint16_t port = libaxl_get_tcp_port(display);\n\tint fd;\n\n\tabort(); /* XXX */\n\n\tsetsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &(int){1}, sizeof(int));\n\tsetsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &(int){1}, sizeof(int));\n\n\treturn -1;\n}", "item_id": 0, "repo": "maandree/libaxl", "file": "libaxl_connect_without_handshake.c", "last_update_at": "2020-09-09T13:18:40+00:00", "question_id": "ca4fbedf8fded10a6f240d075f22a9162c273f3c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nconnect_tcp_ip(const char *host, int display)\n{\n\tuint16_t port = libaxl_get_tcp_port(display);\n\tint fd;\n\tabort(); /* XXX */\n\tsetsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &(int){1}, sizeof(int));\n\tsetsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &(int){1}, sizeof(int));\n\treturn -1;\n"]]}
{"hexsha": "cfb794766fead2823f0e5d3ba36259d97b9b952a", "ext": "c", "lang": "C", "content": "static int sdhci_pci_select_drive_strength(struct sdhci_host *host,\n\t\t\t\t\t   struct mmc_card *card,\n\t\t\t\t\t   unsigned int max_dtr, int host_drv,\n\t\t\t\t\t   int card_drv, int *drv_type)\n{\n\tstruct sdhci_pci_slot *slot = sdhci_priv(host);\n\n\tif (!slot->select_drive_strength)\n\t\treturn 0;\n\n\treturn slot->select_drive_strength(host, card, max_dtr, host_drv,\n\t\t\t\t\t   card_drv, drv_type);\n}", "item_id": 24, "repo": "rubedos/l4t_R32.5.1_viper", "file": "kernel/kernel-4.9/drivers/mmc/host/sdhci-pci-core.c", "last_update_at": "2020-03-28T11:26:15+00:00", "question_id": "cfb794766fead2823f0e5d3ba36259d97b9b952a_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int sdhci_pci_select_drive_strength(struct sdhci_host *host,\n\t\t\t\t\t   struct mmc_card *card,\n\t\t\t\t\t   unsigned int max_dtr, int host_drv,\n\t\t\t\t\t   int card_drv, int *drv_type)\n{\n\tstruct sdhci_pci_slot *slot = sdhci_priv(host);\n\tif (!slot->select_drive_strength)\n\t\treturn 0;\n\treturn slot->select_drive_strength(host, card, max_dtr, host_drv,\n\t\t\t\t\t   card_drv, drv_type);\n"]]}
{"hexsha": "9e0fb3202a8f8c3995951f5767348bf8dde56507", "ext": "c", "lang": "C", "content": "static double\nget_next_S(double t, int n, double *stateptr)\n{\n\tdouble\t\tS;\n\n\t/* The magic constant here is T from Vitter's paper */\n\tif (t <= (22.0 * n))\n\t{\n\t\t/* Process records using Algorithm X until t is large enough */\n\t\tdouble\t\tV,\n\t\t\t\t\tquot;\n\n\t\tV = random_fract();\t\t/* Generate V */\n\t\tS = 0;\n\t\tt += 1;\n\t\t/* Note: \"num\" in Vitter's code is always equal to t - n */\n\t\tquot = (t - (double) n) / t;\n\t\t/* Find min S satisfying (4.1) */\n\t\twhile (quot > V)\n\t\t{\n\t\t\tS += 1;\n\t\t\tt += 1;\n\t\t\tquot *= (t - (double) n) / t;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Now apply Algorithm Z */\n\t\tdouble\t\tW = *stateptr;\n\t\tdouble\t\tterm = t - (double) n + 1;\n\n\t\tfor (;;)\n\t\t{\n\t\t\tdouble\t\tnumer,\n\t\t\t\t\t\tnumer_lim,\n\t\t\t\t\t\tdenom;\n\t\t\tdouble\t\tU,\n\t\t\t\t\t\tX,\n\t\t\t\t\t\tlhs,\n\t\t\t\t\t\trhs,\n\t\t\t\t\t\ty,\n\t\t\t\t\t\ttmp;\n\n\t\t\t/* Generate U and X */\n\t\t\tU = random_fract();\n\t\t\tX = t * (W - 1.0);\n\t\t\tS = floor(X);\t\t/* S is tentatively set to floor(X) */\n\t\t\t/* Test if U <= h(S)/cg(X) in the manner of (6.3) */\n\t\t\ttmp = (t + 1) / term;\n\t\t\tlhs = exp(log(((U * tmp * tmp) * (term + S)) / (t + X)) / n);\n\t\t\trhs = (((t + X) / (term + S)) * term) / t;\n\t\t\tif (lhs <= rhs)\n\t\t\t{\n\t\t\t\tW = rhs / lhs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Test if U <= f(S)/cg(X) */\n\t\t\ty = (((U * (t + 1)) / term) * (t + S + 1)) / (t + X);\n\t\t\tif ((double) n < S)\n\t\t\t{\n\t\t\t\tdenom = t;\n\t\t\t\tnumer_lim = term + S;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdenom = t - (double) n + S;\n\t\t\t\tnumer_lim = t + 1;\n\t\t\t}\n\t\t\tfor (numer = t + S; numer >= numer_lim; numer -= 1)\n\t\t\t{\n\t\t\t\ty *= numer / denom;\n\t\t\t\tdenom -= 1;\n\t\t\t}\n\t\t\tW = exp(-log(random_fract()) / n);\t/* Generate W in advance */\n\t\t\tif (exp(log(y) / n) <= (t + X) / t)\n\t\t\t\tbreak;\n\t\t}\n\t\t*stateptr = W;\n\t}\n\treturn S;\n}", "item_id": 6, "repo": "chrishajas/gpdb", "file": "src/backend/commands/analyze.c", "last_update_at": "2020-01-23T04:09:39+00:00", "question_id": "9e0fb3202a8f8c3995951f5767348bf8dde56507_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static double\nget_next_S(double t, int n, double *stateptr)\n{\n\tdouble\t\tS;\n\t/* The magic constant here is T from Vitter's paper */\n\tif (t <= (22.0 * n))\n\t{\n\t\t/* Process records using Algorithm X until t is large enough */\n\t\tdouble\t\tV,\n\t\t\t\t\tquot;\n\t\tV = random_fract();\t\t/* Generate V */\n\t\tS = 0;\n\t\tt += 1;\n\t\t/* Note: \"num\" in Vitter's code is always equal to t - n */\n\t\tquot = (t - (double) n) / t;\n\t\t/* Find min S satisfying (4.1) */\n\t\twhile (quot > V)\n\t\t{\n\t\t\tS += 1;\n\t\t\tt += 1;\n\t\t\tquot *= (t - (double) n) / t;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Now apply Algorithm Z */\n\t\tdouble\t\tW = *stateptr;\n\t\tdouble\t\tterm = t - (double) n + 1;\n\t\tfor (;;)\n\t\t{\n\t\t\tdouble\t\tnumer,\n\t\t\t\t\t\tnumer_lim,\n\t\t\t\t\t\tdenom;\n\t\t\tdouble\t\tU,\n\t\t\t\t\t\tX,\n\t\t\t\t\t\tlhs,\n\t\t\t\t\t\trhs,\n\t\t\t\t\t\ty,\n\t\t\t\t\t\ttmp;\n\t\t\t/* Generate U and X */\n\t\t\tU = random_fract();\n\t\t\tX = t * (W - 1.0);\n\t\t\tS = floor(X);\t\t/* S is tentatively set to floor(X) */\n\t\t\t/* Test if U <= h(S)/cg(X) in the manner of (6.3) */\n\t\t\ttmp = (t + 1) / term;\n\t\t\tlhs = exp(log(((U * tmp * tmp) * (term + S)) / (t + X)) / n);\n\t\t\trhs = (((t + X) / (term + S)) * term) / t;\n\t\t\tif (lhs <= rhs)\n\t\t\t{\n\t\t\t\tW = rhs / lhs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Test if U <= f(S)/cg(X) */\n\t\t\ty = (((U * (t + 1)) / term) * (t + S + 1)) / (t + X);\n\t\t\tif ((double) n < S)\n\t\t\t{\n\t\t\t\tdenom = t;\n\t\t\t\tnumer_lim = term + S;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdenom = t - (double) n + S;\n\t\t\t\tnumer_lim = t + 1;\n\t\t\t}\n\t\t\tfor (numer = t + S; numer >= numer_lim; numer -= 1)\n\t\t\t{\n\t\t\t\ty *= numer / denom;\n\t\t\t\tdenom -= 1;\n\t\t\t}\n\t\t\tW = exp(-log(random_fract()) / n);\t/* Generate W in advance */\n\t\t\tif (exp(log(y) / n) <= (t + X) / t)\n\t\t\t\tbreak;\n\t\t}\n\t\t*stateptr = W;\n\t}\n\treturn S;\n"]]}
{"hexsha": "8af5f540b7b889c6c73cfadf0ae662cca9dbe72a", "ext": "c", "lang": "C", "content": "void\ndobootopts(int argc, char **argv)\n{\n\tstatic char filenamebuf[1 + 32];\n\tchar *SystemPartition = NULL;\n\tchar *cp;\n\tint i;\n\n\tfor (i = 1; i < argc; i++) {\n\t\tcp = argv[i];\n\t\tif (cp == NULL)\n\t\t\tcontinue;\n\t\tif (strncmp(cp, \"OSLoadOptions=\", 14) == 0) {\n\t\t\tif (strcmp(&cp[14], \"auto\") == 0)\n\t\t\t\tbootauto = AUTO_YES;\n\t\t\telse if (strcmp(&cp[14], \"single\") == 0)\n\t\t\t\tbootauto = AUTO_NO;\n\t\t\telse if (strcmp(&cp[14], \"mini\") == 0)\n\t\t\t\tbootauto = AUTO_MINI;\n\t\t\telse if (strcmp(&cp[14], \"debug\") == 0)\n\t\t\t\tbootauto = AUTO_DEBUG;\n\t\t} else if (strncmp(cp, \"OSLoadPartition=\", 16) == 0)\n\t\t\tOSLoadPartition = &cp[16];\n\t\telse if (strncmp(cp, \"OSLoadFilename=\", 15) == 0)\n\t\t\tOSLoadFilename = &cp[15];\n\t\telse if (strncmp(cp, \"SystemPartition=\", 16) == 0)\n\t\t\tSystemPartition = &cp[16];\n\t}\n\n\t/* If \"OSLoadOptions=\" is missing, see if any arg was given. */\n\tif (bootauto == AUTO_NONE && *argv[1] == '/')\n\t\tOSLoadFilename = argv[1];\n\n\tif (bootauto == AUTO_MINI) {\n\t\tstatic char loadpart[64];\n\t\tchar *p;\n\n\t\tstrlcpy(loadpart, argv[0], sizeof loadpart);\n\t\tif ((p = strstr(loadpart, \"partition(8)\")) != NULL) {\n\t\t\tp += strlen(\"partition(\");\n\t\t} else if (strncmp(loadpart, \"dksc(\", 5) == 0) {\n\t\t\tp = strstr(loadpart, \",8)\");\n\t\t\tif (p != NULL)\n\t\t\t\tp++;\n\t\t} else\n\t\t\tp = NULL;\n\n\t\tif (p != NULL) {\n\t\t\tp[0] = '0';\n\t\t\tp[2] = '\\0';\n\t\t\tsnprintf(filenamebuf, sizeof filenamebuf,\n\t\t\t    \"/bsd.rd.IP%d\", IP);\n\t\t\tOSLoadPartition = loadpart;\n\t\t\tOSLoadFilename = filenamebuf;\n\t\t}\n\t}\n}", "item_id": 1, "repo": "sizeofvoid/ifconfigd", "file": "usr/src/sys/arch/sgi/stand/boot/boot.c", "last_update_at": "2020-08-28T01:27:00+00:00", "question_id": "8af5f540b7b889c6c73cfadf0ae662cca9dbe72a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\ndobootopts(int argc, char **argv)\n{\n\tstatic char filenamebuf[1 + 32];\n\tchar *SystemPartition = NULL;\n\tchar *cp;\n\tint i;\n\tfor (i = 1; i < argc; i++) {\n\t\tcp = argv[i];\n\t\tif (cp == NULL)\n\t\t\tcontinue;\n\t\tif (strncmp(cp, \"OSLoadOptions=\", 14) == 0) {\n\t\t\tif (strcmp(&cp[14], \"auto\") == 0)\n\t\t\t\tbootauto = AUTO_YES;\n\t\t\telse if (strcmp(&cp[14], \"single\") == 0)\n\t\t\t\tbootauto = AUTO_NO;\n\t\t\telse if (strcmp(&cp[14], \"mini\") == 0)\n\t\t\t\tbootauto = AUTO_MINI;\n\t\t\telse if (strcmp(&cp[14], \"debug\") == 0)\n\t\t\t\tbootauto = AUTO_DEBUG;\n\t\t} else if (strncmp(cp, \"OSLoadPartition=\", 16) == 0)\n\t\t\tOSLoadPartition = &cp[16];\n\t\telse if (strncmp(cp, \"OSLoadFilename=\", 15) == 0)\n\t\t\tOSLoadFilename = &cp[15];\n\t\telse if (strncmp(cp, \"SystemPartition=\", 16) == 0)\n\t\t\tSystemPartition = &cp[16];\n\t}\n\t/* If \"OSLoadOptions=\" is missing, see if any arg was given. */\n\tif (bootauto == AUTO_NONE && *argv[1] == '/')\n\t\tOSLoadFilename = argv[1];\n\tif (bootauto == AUTO_MINI) {\n\t\tstatic char loadpart[64];\n\t\tchar *p;\n\t\tstrlcpy(loadpart, argv[0], sizeof loadpart);\n\t\tif ((p = strstr(loadpart, \"partition(8)\")) != NULL) {\n\t\t\tp += strlen(\"partition(\");\n\t\t} else if (strncmp(loadpart, \"dksc(\", 5) == 0) {\n\t\t\tp = strstr(loadpart, \",8)\");\n\t\t\tif (p != NULL)\n\t\t\t\tp++;\n\t\t} else\n\t\t\tp = NULL;\n\t\tif (p != NULL) {\n\t\t\tp[0] = '0';\n\t\t\tp[2] = '\\0';\n\t\t\tsnprintf(filenamebuf, sizeof filenamebuf,\n\t\t\t    \"/bsd.rd.IP%d\", IP);\n\t\t\tOSLoadPartition = loadpart;\n\t\t\tOSLoadFilename = filenamebuf;\n\t\t}\n\t}\n"]]}
{"hexsha": "64122e3416f02540821ac7f7f582d714ee34a660", "ext": "c", "lang": "C", "content": "int\nsmb_ctx_readrc(struct smb_ctx *ctx)\n{\n\tchar pwbuf[NSS_BUFLEN_PASSWD];\n\tstruct passwd pw;\n\tchar *sname = NULL;\n\tint sname_max;\n\tint err = 0;\n\n\t/*\n\t * If the user name is not specified some other way,\n\t * use the current user name.  Also save the homedir.\n\t * NB: ct_home=NULL is allowed, and we don't want to\n\t * bail out with an error for a missing ct_home.\n\t */\n\tif (getpwuid_r(getuid(), &pw, pwbuf, sizeof (pwbuf)) != NULL) {\n\t\tif (ctx->ct_user[0] == 0)\n\t\t\t(void) smb_ctx_setuser(ctx, pw.pw_name, B_FALSE);\n\t\tif (ctx->ct_home == NULL)\n\t\t\tctx->ct_home = strdup(pw.pw_dir);\n\t}\n\n\tif ((err = smb_open_rcfile(ctx->ct_home)) != 0) {\n\t\tDPRINT(\"smb_open_rcfile, err=%d\", err);\n\t\t/* ignore any error here */\n\t\treturn (0);\n\t}\n\n\tsname_max = 3 * SMBIOC_MAX_NAME + 4;\n\tsname = malloc(sname_max);\n\tif (sname == NULL) {\n\t\terr = ENOMEM;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * default parameters (level=0)\n\t */\n\tsmb_ctx_readrcsection(ctx, \"default\", 0);\n\tnb_ctx_readrcsection(smb_rc, ctx->ct_nb, \"default\", 0);\n\n\t/*\n\t * If we don't have a server name, we can't read any of the\n\t * [server...] sections.\n\t */\n\tif (ctx->ct_fullserver == NULL)\n\t\tgoto done;\n\t/*\n\t * SERVER parameters.\n\t */\n\tsmb_ctx_readrcsection(ctx, ctx->ct_fullserver, 1);\n\n\t/*\n\t * If we don't have a user name, we can't read any of the\n\t * [server:user...] sections.\n\t */\n\tif (ctx->ct_user[0] == 0)\n\t\tgoto done;\n\t/*\n\t * SERVER:USER parameters\n\t */\n\tsnprintf(sname, sname_max, \"%s:%s\",\n\t    ctx->ct_fullserver,\n\t    ctx->ct_user);\n\tsmb_ctx_readrcsection(ctx, sname, 2);\n\n\n\t/*\n\t * If we don't have a share name, we can't read any of the\n\t * [server:user:share] sections.\n\t */\n\tif (ctx->ct_origshare == NULL)\n\t\tgoto done;\n\t/*\n\t * SERVER:USER:SHARE parameters\n\t */\n\tsnprintf(sname, sname_max, \"%s:%s:%s\",\n\t    ctx->ct_fullserver,\n\t    ctx->ct_user,\n\t    ctx->ct_origshare);\n\tsmb_ctx_readrcsection(ctx, sname, 3);\n\ndone:\n\tif (sname)\n\t\tfree(sname);\n\tsmb_close_rcfile();\n\tif (smb_debug)\n\t\tdump_ctx(\"after smb_ctx_readrc\", ctx);\n\tif (err)\n\t\tDPRINT(\"err=%d\\n\", err);\n\n\treturn (err);\n}", "item_id": 33, "repo": "AsahiOS/gate", "file": "usr/src/lib/libsmbfs/smb/ctx.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "64122e3416f02540821ac7f7f582d714ee34a660_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nsmb_ctx_readrc(struct smb_ctx *ctx)\n{\n\tchar pwbuf[NSS_BUFLEN_PASSWD];\n\tstruct passwd pw;\n\tchar *sname = NULL;\n\tint sname_max;\n\tint err = 0;\n\t/*\n\t * If the user name is not specified some other way,\n\t * use the current user name.  Also save the homedir.\n\t * NB: ct_home=NULL is allowed, and we don't want to\n\t * bail out with an error for a missing ct_home.\n\t */\n\tif (getpwuid_r(getuid(), &pw, pwbuf, sizeof (pwbuf)) != NULL) {\n\t\tif (ctx->ct_user[0] == 0)\n\t\t\t(void) smb_ctx_setuser(ctx, pw.pw_name, B_FALSE);\n\t\tif (ctx->ct_home == NULL)\n\t\t\tctx->ct_home = strdup(pw.pw_dir);\n\t}\n\tif ((err = smb_open_rcfile(ctx->ct_home)) != 0) {\n\t\tDPRINT(\"smb_open_rcfile, err=%d\", err);\n\t\t/* ignore any error here */\n\t\treturn (0);\n\t}\n\tsname_max = 3 * SMBIOC_MAX_NAME + 4;\n\tsname = malloc(sname_max);\n\tif (sname == NULL) {\n\t\terr = ENOMEM;\n\t\tgoto done;\n\t}\n\t/*\n\t * default parameters (level=0)\n\t */\n\tsmb_ctx_readrcsection(ctx, \"default\", 0);\n\tnb_ctx_readrcsection(smb_rc, ctx->ct_nb, \"default\", 0);\n\t/*\n\t * If we don't have a server name, we can't read any of the\n\t * [server...] sections.\n\t */\n\tif (ctx->ct_fullserver == NULL)\n\t\tgoto done;\n\t/*\n\t * SERVER parameters.\n\t */\n\tsmb_ctx_readrcsection(ctx, ctx->ct_fullserver, 1);\n\t/*\n\t * If we don't have a user name, we can't read any of the\n\t * [server:user...] sections.\n\t */\n\tif (ctx->ct_user[0] == 0)\n\t\tgoto done;\n\t/*\n\t * SERVER:USER parameters\n\t */\n\tsnprintf(sname, sname_max, \"%s:%s\",\n\t    ctx->ct_fullserver,\n\t    ctx->ct_user);\n\tsmb_ctx_readrcsection(ctx, sname, 2);\n\t/*\n\t * If we don't have a share name, we can't read any of the\n\t * [server:user:share] sections.\n\t */\n\tif (ctx->ct_origshare == NULL)\n\t\tgoto done;\n\t/*\n\t * SERVER:USER:SHARE parameters\n\t */\n\tsnprintf(sname, sname_max, \"%s:%s:%s\",\n\t    ctx->ct_fullserver,\n\t    ctx->ct_user,\n\t    ctx->ct_origshare);\n\tsmb_ctx_readrcsection(ctx, sname, 3);\ndone:\n\tif (sname)\n\t\tfree(sname);\n\tsmb_close_rcfile();\n\tif (smb_debug)\n\t\tdump_ctx(\"after smb_ctx_readrc\", ctx);\n\tif (err)\n\t\tDPRINT(\"err=%d\\n\", err);\n\treturn (err);\n"]]}
{"hexsha": "bcefe12c85aa5cab1fb3f3a2222dd4f570b15a6d", "ext": "c", "lang": "C", "content": "JNICALL\nJava_hdf_hdf5lib_H5_H5DreadVL\n    (JNIEnv *env, jclass clss, jlong dataset_id, jlong mem_type_id, jlong mem_space_id,\n          jlong file_space_id, jlong xfer_plist_id, jobjectArray buf)\n{\n    H5T_class_t type_class;\n    htri_t      isStr = 0;\n    htri_t      isVlenStr = 0;\n    htri_t      isComplex = 0;\n    htri_t      isComplex2 = 0;\n    hid_t       nested_tid = H5I_INVALID_HID;\n    herr_t      status = FAIL;\n\n    UNUSED(clss);\n\n    if (NULL == buf)\n        H5_NULL_ARGUMENT_ERROR(ENVONLY, \"H5DreadVL: read buffer is NULL\");\n\n    if ((isStr = H5Tdetect_class((hid_t)mem_type_id, H5T_STRING)) < 0)\n        H5_LIBRARY_ERROR(ENVONLY);\n\n    if ((type_class = H5Tget_class((hid_t)mem_type_id)) < 0)\n        H5_LIBRARY_ERROR(ENVONLY);\n\n    if (type_class == H5T_COMPOUND) {\n        unsigned i;\n        int      num_members;\n\n        if ((num_members = H5Tget_nmembers(mem_type_id)) < 0)\n            H5_LIBRARY_ERROR(ENVONLY);\n\n        for (i = 0; i < (unsigned) num_members; i++) {\n            if ((nested_tid = H5Tget_member_type((hid_t)mem_type_id, i)) < 0)\n                H5_LIBRARY_ERROR(ENVONLY);\n\n            if ((isComplex = H5Tdetect_class((hid_t)nested_tid, H5T_COMPOUND)) < 0)\n                H5_LIBRARY_ERROR(ENVONLY);\n\n            if ((isComplex2 = H5Tdetect_class((hid_t)nested_tid, H5T_VLEN)) < 0)\n                H5_LIBRARY_ERROR(ENVONLY);\n\n            isComplex = isComplex || isComplex2;\n\n            if (H5Tclose(nested_tid) < 0)\n                H5_LIBRARY_ERROR(ENVONLY);\n            nested_tid = H5I_INVALID_HID;\n        }\n    }\n    else if (type_class == H5T_VLEN) {\n        isVlenStr = 1; /* Strings created by H5Tvlen_create(H5T_C_S1) */\n    }\n\n    if (!isStr || isComplex || isVlenStr) {\n        if ((status = H5DreadVL_asstr(env, (hid_t)dataset_id, (hid_t)mem_type_id,\n                (hid_t)mem_space_id, (hid_t)file_space_id, (hid_t)xfer_plist_id, buf)) < 0)\n            CHECK_JNI_EXCEPTION(ENVONLY, JNI_FALSE);\n    }\n    else if (isStr) {\n        if ((status = H5DreadVL_str(env, (hid_t)dataset_id, (hid_t)mem_type_id,\n                (hid_t)mem_space_id, (hid_t)file_space_id, (hid_t)xfer_plist_id, buf)) < 0)\n            CHECK_JNI_EXCEPTION(ENVONLY, JNI_FALSE);\n    }\n\ndone:\n    if (nested_tid >= 0)\n        H5Tclose(nested_tid);\n\n    return (jint)status;\n}", "item_id": 22, "repo": "khou2020/hdf5", "file": "java/src/jni/h5dImp.c", "last_update_at": "2020-10-28T03:31:35+00:00", "question_id": "bcefe12c85aa5cab1fb3f3a2222dd4f570b15a6d_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["JNICALL\nJava_hdf_hdf5lib_H5_H5DreadVL\n    (JNIEnv *env, jclass clss, jlong dataset_id, jlong mem_type_id, jlong mem_space_id,\n          jlong file_space_id, jlong xfer_plist_id, jobjectArray buf)\n{\n    H5T_class_t type_class;\n    htri_t      isStr = 0;\n    htri_t      isVlenStr = 0;\n    htri_t      isComplex = 0;\n    htri_t      isComplex2 = 0;\n    hid_t       nested_tid = H5I_INVALID_HID;\n    herr_t      status = FAIL;\n    UNUSED(clss);\n    if (NULL == buf)\n        H5_NULL_ARGUMENT_ERROR(ENVONLY, \"H5DreadVL: read buffer is NULL\");\n    if ((isStr = H5Tdetect_class((hid_t)mem_type_id, H5T_STRING)) < 0)\n        H5_LIBRARY_ERROR(ENVONLY);\n    if ((type_class = H5Tget_class((hid_t)mem_type_id)) < 0)\n        H5_LIBRARY_ERROR(ENVONLY);\n    if (type_class == H5T_COMPOUND) {\n        unsigned i;\n        int      num_members;\n        if ((num_members = H5Tget_nmembers(mem_type_id)) < 0)\n            H5_LIBRARY_ERROR(ENVONLY);\n        for (i = 0; i < (unsigned) num_members; i++) {\n            if ((nested_tid = H5Tget_member_type((hid_t)mem_type_id, i)) < 0)\n                H5_LIBRARY_ERROR(ENVONLY);\n            if ((isComplex = H5Tdetect_class((hid_t)nested_tid, H5T_COMPOUND)) < 0)\n                H5_LIBRARY_ERROR(ENVONLY);\n            if ((isComplex2 = H5Tdetect_class((hid_t)nested_tid, H5T_VLEN)) < 0)\n                H5_LIBRARY_ERROR(ENVONLY);\n            isComplex = isComplex || isComplex2;\n            if (H5Tclose(nested_tid) < 0)\n                H5_LIBRARY_ERROR(ENVONLY);\n            nested_tid = H5I_INVALID_HID;\n        }\n    }\n    else if (type_class == H5T_VLEN) {\n        isVlenStr = 1; /* Strings created by H5Tvlen_create(H5T_C_S1) */\n    }\n    if (!isStr || isComplex || isVlenStr) {\n        if ((status = H5DreadVL_asstr(env, (hid_t)dataset_id, (hid_t)mem_type_id,\n                (hid_t)mem_space_id, (hid_t)file_space_id, (hid_t)xfer_plist_id, buf)) < 0)\n            CHECK_JNI_EXCEPTION(ENVONLY, JNI_FALSE);\n    }\n    else if (isStr) {\n        if ((status = H5DreadVL_str(env, (hid_t)dataset_id, (hid_t)mem_type_id,\n                (hid_t)mem_space_id, (hid_t)file_space_id, (hid_t)xfer_plist_id, buf)) < 0)\n            CHECK_JNI_EXCEPTION(ENVONLY, JNI_FALSE);\n    }\ndone:\n    if (nested_tid >= 0)\n        H5Tclose(nested_tid);\n    return (jint)status;\n"]]}
{"hexsha": "bb1455ac0191268374ae88fad1fbc9a872bbc5df", "ext": "c", "lang": "C", "content": "int ipl2_main(int argc, char *argv[])\n{\n  int ret;\n\n  UNUSED(ret); /* Not used in all configurations */\n\n  _info(\"start: %s\\n\", CONFIG_CURRENT_REVISION);\n  _info(\"imgsig: %u\\n\", IMG_SIGNATURE);\n\n#ifdef CONFIG_CHARGER\n  /* NOTE:\n   * chg_disable() must be done before CMIC_FWAKE L->H.\n   * Please refer to PDFW15IS-2494 for more information\n   */\n\n  chg_disable();\n#endif\n\n  lc823450_mtd_initialize(0);\n\n#ifdef CONFIG_ADC\n  ret = check_forceusbboot();\n#endif\n\n#ifdef CONFIG_USBMSC\n  if (ret)\n    {\n      msc_enable(0);\n    }\n\n  ret = check_diskformat();\n\n  if (ret)\n    {\n      msc_enable(1);\n    }\n\n  memset(copybuf, 0, sizeof(copybuf));\n  get_config(1, copybuf);\n\n  /* for \"reboot usb\" */\n\n  if (!strncmp(\"usb\", copybuf, 3))\n    {\n      /* remove boot flag for next boot */\n\n      memset(copybuf, 0, sizeof(copybuf));\n      set_config(1, copybuf);\n      msc_enable(1);\n    }\n#endif\n\n#ifdef CONFIG_LASTKMSG\n  check_lastkmsg();\n#endif /* CONFIG_LASTKMSG */\n\n  if (!strncmp(\"recovery\", copybuf, 8))\n    {\n      /* check recovery kernel update */\n\n      mount(CONFIG_MTD_CP_DEVPATH, \"/mnt/sd0\", \"evfat\", 0, NULL);\n      nxsig_usleep(10000);\n\n      /* recovery kernel install from UPG.img */\n\n      install_recovery(\"/mnt/sd0/UPG.IMG\");\n      load_kernel(\"recovery\", CONFIG_MTD_RECOVERY_DEVPATH);\n\n    }\n  else\n    {\n      load_kernel(\"nuttx\", CONFIG_MTD_KERNEL_DEVPATH);\n    }\n\n  /* not reached */\n\n  return -1;\n}", "item_id": 12, "repo": "ErikkEnglund/incubator-nuttx", "file": "arch/arm/src/lc823450/lc823450_ipl2.c", "last_update_at": "2020-09-28T14:14:44+00:00", "question_id": "bb1455ac0191268374ae88fad1fbc9a872bbc5df_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int ipl2_main(int argc, char *argv[])\n{\n  int ret;\n  UNUSED(ret); /* Not used in all configurations */\n  _info(\"start: %s\\n\", CONFIG_CURRENT_REVISION);\n  _info(\"imgsig: %u\\n\", IMG_SIGNATURE);\n#ifdef CONFIG_CHARGER\n  /* NOTE:\n   * chg_disable() must be done before CMIC_FWAKE L->H.\n   * Please refer to PDFW15IS-2494 for more information\n   */\n  chg_disable();\n#endif\n  lc823450_mtd_initialize(0);\n#ifdef CONFIG_ADC\n  ret = check_forceusbboot();\n#endif\n#ifdef CONFIG_USBMSC\n  if (ret)\n    {\n      msc_enable(0);\n    }\n  ret = check_diskformat();\n  if (ret)\n    {\n      msc_enable(1);\n    }\n  memset(copybuf, 0, sizeof(copybuf));\n  get_config(1, copybuf);\n  /* for \"reboot usb\" */\n  if (!strncmp(\"usb\", copybuf, 3))\n    {\n      /* remove boot flag for next boot */\n      memset(copybuf, 0, sizeof(copybuf));\n      set_config(1, copybuf);\n      msc_enable(1);\n    }\n#endif\n#ifdef CONFIG_LASTKMSG\n  check_lastkmsg();\n#endif /* CONFIG_LASTKMSG */\n  if (!strncmp(\"recovery\", copybuf, 8))\n    {\n      /* check recovery kernel update */\n      mount(CONFIG_MTD_CP_DEVPATH, \"/mnt/sd0\", \"evfat\", 0, NULL);\n      nxsig_usleep(10000);\n      /* recovery kernel install from UPG.img */\n      install_recovery(\"/mnt/sd0/UPG.IMG\");\n      load_kernel(\"recovery\", CONFIG_MTD_RECOVERY_DEVPATH);\n    }\n  else\n    {\n      load_kernel(\"nuttx\", CONFIG_MTD_KERNEL_DEVPATH);\n    }\n  /* not reached */\n  return -1;\n"]]}
{"hexsha": "bd729b1f769b73a339bb3c5f92094e4ffb487a51", "ext": "c", "lang": "C", "content": "void\nclient_send_environ(void)\n{\n\tstruct msg_environ_data\tdata;\n\tchar\t\t      **var;\n\n\tfor (var = environ; *var != NULL; var++) {\n\t\tif (strlcpy(data.var, *var, sizeof data.var) >= sizeof data.var)\n\t\t\tcontinue;\n\t\tclient_write_server(MSG_ENVIRON, &data, sizeof data);\n\t}\n}", "item_id": 3, "repo": "sizeofvoid/ifconfigd", "file": "usr/src/usr.bin/tmux/client.c", "last_update_at": "2020-08-28T01:27:00+00:00", "question_id": "bd729b1f769b73a339bb3c5f92094e4ffb487a51_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nclient_send_environ(void)\n{\n\tstruct msg_environ_data\tdata;\n\tchar\t\t      **var;\n\tfor (var = environ; *var != NULL; var++) {\n\t\tif (strlcpy(data.var, *var, sizeof data.var) >= sizeof data.var)\n\t\t\tcontinue;\n\t\tclient_write_server(MSG_ENVIRON, &data, sizeof data);\n\t}\n"]]}
{"hexsha": "329623028032166a25cf378bfd8440be7cba61e4", "ext": "c", "lang": "C", "content": "static void HAL_ResetPinMakeOutput(void)\n{\n\tstruct port_config pin_conf;\n\tport_get_config_defaults(&pin_conf);\n\tpin_conf.direction = PORT_PIN_DIR_OUTPUT;\n\tport_pin_set_config(SX_RF_RESET_PIN,&pin_conf);\n}", "item_id": 8, "repo": "azerimaker/RAK4260-LoRaNode-demo", "file": "APPS_ENDDEVICE_DEMO1/src/ASF/thirdparty/wireless/lorawan/hal/src/radio_driver_hal.c", "last_update_at": "2020-07-23T06:52:44+00:00", "question_id": "329623028032166a25cf378bfd8440be7cba61e4_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void HAL_ResetPinMakeOutput(void)\n{\n\tstruct port_config pin_conf;\n\tport_get_config_defaults(&pin_conf);\n\tpin_conf.direction = PORT_PIN_DIR_OUTPUT;\n\tport_pin_set_config(SX_RF_RESET_PIN,&pin_conf);\n"]]}
{"hexsha": "04ce6bf890e68854ff25af435d8af9c8742827ff", "ext": "c", "lang": "C", "content": "GuestMemoryBlockList *qmp_guest_get_memory_blocks(Error **errp)\n{\n    GuestMemoryBlockList *head, **link;\n    Error *local_err = NULL;\n    struct dirent *de;\n    DIR *dp;\n\n    head = NULL;\n    link = &head;\n\n    dp = opendir(\"/sys/devices/system/memory/\");\n    if (!dp) {\n        /* it's ok if this happens to be a system that doesn't expose\n         * memory blocks via sysfs, but otherwise we should report\n         * an error\n         */\n        if (errno != ENOENT) {\n            error_setg_errno(errp, errno, \"Can't open directory\"\n                             \"\\\"/sys/devices/system/memory/\\\"\\n\");\n        }\n        return NULL;\n    }\n\n    /* Note: the phys_index of memory block may be discontinuous,\n     * this is because a memblk is the unit of the Sparse Memory design, which\n     * allows discontinuous memory ranges (ex. NUMA), so here we should\n     * traverse the memory block directory.\n     */\n    while ((de = readdir(dp)) != NULL) {\n        GuestMemoryBlock *mem_blk;\n        GuestMemoryBlockList *entry;\n\n        if ((strncmp(de->d_name, \"memory\", 6) != 0) ||\n            !(de->d_type & DT_DIR)) {\n            continue;\n        }\n\n        mem_blk = g_malloc0(sizeof *mem_blk);\n        /* The d_name is \"memoryXXX\",  phys_index is block id, same as XXX */\n        mem_blk->phys_index = strtoul(&de->d_name[6], NULL, 10);\n        mem_blk->has_can_offline = true; /* lolspeak ftw */\n        transfer_memory_block(mem_blk, true, NULL, &local_err);\n\n        entry = g_malloc0(sizeof *entry);\n        entry->value = mem_blk;\n\n        *link = entry;\n        link = &entry->next;\n    }\n\n    closedir(dp);\n    if (local_err == NULL) {\n        /* there's no guest with zero memory blocks */\n        if (head == NULL) {\n            error_setg(errp, \"guest reported zero memory blocks!\");\n        }\n        return head;\n    }\n\n    qapi_free_GuestMemoryBlockList(head);\n    error_propagate(errp, local_err);\n    return NULL;\n}", "item_id": 44, "repo": "pAplakidis/qira", "file": "tracers/qemu/qemu-2.5.1/qga/commands-posix.c", "last_update_at": "2020-12-02T16:32:17+00:00", "question_id": "04ce6bf890e68854ff25af435d8af9c8742827ff_44", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["GuestMemoryBlockList *qmp_guest_get_memory_blocks(Error **errp)\n{\n    GuestMemoryBlockList *head, **link;\n    Error *local_err = NULL;\n    struct dirent *de;\n    DIR *dp;\n    head = NULL;\n    link = &head;\n    dp = opendir(\"/sys/devices/system/memory/\");\n    if (!dp) {\n        /* it's ok if this happens to be a system that doesn't expose\n         * memory blocks via sysfs, but otherwise we should report\n         * an error\n         */\n        if (errno != ENOENT) {\n            error_setg_errno(errp, errno, \"Can't open directory\"\n                             \"\\\"/sys/devices/system/memory/\\\"\\n\");\n        }\n        return NULL;\n    }\n    /* Note: the phys_index of memory block may be discontinuous,\n     * this is because a memblk is the unit of the Sparse Memory design, which\n     * allows discontinuous memory ranges (ex. NUMA), so here we should\n     * traverse the memory block directory.\n     */\n    while ((de = readdir(dp)) != NULL) {\n        GuestMemoryBlock *mem_blk;\n        GuestMemoryBlockList *entry;\n        if ((strncmp(de->d_name, \"memory\", 6) != 0) ||\n            !(de->d_type & DT_DIR)) {\n            continue;\n        }\n        mem_blk = g_malloc0(sizeof *mem_blk);\n        /* The d_name is \"memoryXXX\",  phys_index is block id, same as XXX */\n        mem_blk->phys_index = strtoul(&de->d_name[6], NULL, 10);\n        mem_blk->has_can_offline = true; /* lolspeak ftw */\n        transfer_memory_block(mem_blk, true, NULL, &local_err);\n        entry = g_malloc0(sizeof *entry);\n        entry->value = mem_blk;\n        *link = entry;\n        link = &entry->next;\n    }\n    closedir(dp);\n    if (local_err == NULL) {\n        /* there's no guest with zero memory blocks */\n        if (head == NULL) {\n            error_setg(errp, \"guest reported zero memory blocks!\");\n        }\n        return head;\n    }\n    qapi_free_GuestMemoryBlockList(head);\n    error_propagate(errp, local_err);\n    return NULL;\n"]]}
{"hexsha": "d51cbb2beba3e1167f5be994f5891f433adb4b3e", "ext": "c", "lang": "C", "content": "void ReleaseAllRestartPoints( void )\n{\n    RESTART *   Object;\n    RESTART *   NextUsedObject;\n\n    if( !ENABLE_RESTART ) return;\n\n    Object = FirstRestartUsed;\n\n    while( Object != NULL )\n    {\n        NextUsedObject = Object->NextUsed;\n        KillUsedRestartPoint( Object );\n        Object = NextUsedObject;\n    }\n}", "item_id": 3, "repo": "ForsakenW/forsaken", "file": "ProjectX/restart.c", "last_update_at": "2020-08-09T19:53:26+00:00", "question_id": "d51cbb2beba3e1167f5be994f5891f433adb4b3e_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void ReleaseAllRestartPoints( void )\n{\n    RESTART *   Object;\n    RESTART *   NextUsedObject;\n    if( !ENABLE_RESTART ) return;\n    Object = FirstRestartUsed;\n    while( Object != NULL )\n    {\n        NextUsedObject = Object->NextUsed;\n        KillUsedRestartPoint( Object );\n        Object = NextUsedObject;\n    }\n"]]}
{"hexsha": "55017723786741a9a1ad1507250dc56d6e0d81ae", "ext": "c", "lang": "C", "content": "void\nset_nacm_write_dflt(test_nacm_cfg_t *nacm_config, const char *action)\n{\n    struct lyd_node *node = NULL;\n\n    node = lyd_new_path(nacm_config->root, nacm_config->ly_ctx, \"/ietf-netconf-acm:nacm/write-default\",\n            (void *)action, 0, LYD_PATH_OPT_UPDATE);\n    assert_non_null(node);\n\n    if (NULL == nacm_config->root) {\n        nacm_config->root = node;\n    }\n}", "item_id": 4, "repo": "TonyMcKnight22/sysrepo", "file": "tests/helpers/nacm_module_helper.c", "last_update_at": "2020-03-21T01:28:40+00:00", "question_id": "55017723786741a9a1ad1507250dc56d6e0d81ae_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nset_nacm_write_dflt(test_nacm_cfg_t *nacm_config, const char *action)\n{\n    struct lyd_node *node = NULL;\n    node = lyd_new_path(nacm_config->root, nacm_config->ly_ctx, \"/ietf-netconf-acm:nacm/write-default\",\n            (void *)action, 0, LYD_PATH_OPT_UPDATE);\n    assert_non_null(node);\n    if (NULL == nacm_config->root) {\n        nacm_config->root = node;\n    }\n"]]}
{"hexsha": "349717e826ff54c6ca00b37383ef9728c57acef9", "ext": "c", "lang": "C", "content": "static void SearchBySubject(libraryDB lib, strings subject)\n{\n\tint i, j;\n\tint mathchFlag = 0;\n\tstrings tmp;\n\n\tsubject = ConvertToLowerCase(subject);\n\tfor (i = 0; i < lib->nbook + 1; i++) {\n\t\tfor (j = 0; lib->book[i]->subjectheading[j] != NULL; j++) {\n\t\t\ttmp = lib->book[i]->subjectheading[j];\n\t\t\ttmp = ConvertToLowerCase(tmp);\n\t\t\tif (StringsEqual(tmp, subject)) {\n\t\t\t\tmathchFlag = 1;\n\t\t\t\tprintf(\"Books:\\n\");\n\t\t\t\tprintf(\"Title: %s\\n\", lib->book[i]->title);\n\t\t\t\tprintf(\"First Author: %s\\n\", lib->book[i]->authors[0]);\n\t\t\t\tprintf(\"ISBN: %s\\n\", lib->book[i]->ISBN);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tif (mathchFlag == 0) {\n\t\tprintf(\"Sorry, No match items.\\n\");\n\t}\n}", "item_id": 4, "repo": "Ruesigoren/Solution", "file": "Chapter 16/16.2-LibraryDB.c", "last_update_at": "2020-05-18T02:16:55+00:00", "question_id": "349717e826ff54c6ca00b37383ef9728c57acef9_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void SearchBySubject(libraryDB lib, strings subject)\n{\n\tint i, j;\n\tint mathchFlag = 0;\n\tstrings tmp;\n\tsubject = ConvertToLowerCase(subject);\n\tfor (i = 0; i < lib->nbook + 1; i++) {\n\t\tfor (j = 0; lib->book[i]->subjectheading[j] != NULL; j++) {\n\t\t\ttmp = lib->book[i]->subjectheading[j];\n\t\t\ttmp = ConvertToLowerCase(tmp);\n\t\t\tif (StringsEqual(tmp, subject)) {\n\t\t\t\tmathchFlag = 1;\n\t\t\t\tprintf(\"Books:\\n\");\n\t\t\t\tprintf(\"Title: %s\\n\", lib->book[i]->title);\n\t\t\t\tprintf(\"First Author: %s\\n\", lib->book[i]->authors[0]);\n\t\t\t\tprintf(\"ISBN: %s\\n\", lib->book[i]->ISBN);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tif (mathchFlag == 0) {\n\t\tprintf(\"Sorry, No match items.\\n\");\n\t}\n"]]}
{"hexsha": "0309fd79ec3c0b5bbfbd2a599824a0d119a48388", "ext": "c", "lang": "C", "content": "int\nm88k_dmx_print(u_int t, u_int d, u_int a, u_int no)\n{\n\tstatic const u_int addr_mod[16] = {\n\t\t0, 3, 2, 2, 1, 0, 0, 0,\n\t\t0, 0, 0, 0, 0, 0, 0, 0\n\t};\n\tstatic const char *mode[16]  = {\n\t\t\"?\", \".b\", \".b\", \".h\", \".b\", \"?\", \"?\", \"?\",\n\t\t\".b\", \"?\", \"?\" , \"?\" , \".h\" , \"?\", \"?\", \"\"\n\t};\n\tstatic const u_int mask[16] = {\n\t\t0, 0xff, 0xff00, 0xffff,\n\t\t0xff0000, 0, 0, 0,\n\t\t0xff000000, 0, 0, 0,\n\t\t0xffff0000, 0, 0, 0xffffffff\n\t};\n\tstatic const u_int shift[16] = {\n\t\t0,  0, 8, 0, 16, 0, 0, 0,\n\t\t24, 0, 0, 0, 16, 0, 0, 0\n\t};\n\tint reg = DMT_DREGBITS(t);\n\n\tif (ISSET(t, DMT_LOCKBAR)) {\n\t\tdb_printf(\"xmem%s%s r%d(0x%x) <-> mem(0x%x),\",\n\t\t    DMT_ENBITS(t) == 0x0f ? \"\" : \".bu\",\n\t\t    ISSET(t, DMT_DAS) ? \"\" : \".usr\", reg,\n\t\t    ((t >> 2 & 0xf) == 0xf) ? d : (d & 0xff), a);\n\t\treturn 1;\n\t} else if (DMT_ENBITS(t) == 0xf) {\n\t\t/* full or double word */\n\t\tif (ISSET(t, DMT_WRITE)) {\n\t\t\tif (ISSET(t, DMT_DOUB1) && no == 2)\n\t\t\t\tdb_printf(\"st.d%s -> mem(0x%x) (** restart sxip **)\",\n\t\t\t\t    ISSET(t, DMT_DAS) ? \"\" : \".usr\", a);\n\t\t\telse\n\t\t\t\tdb_printf(\"st%s (0x%x) -> mem(0x%x)\",\n\t\t\t\t    ISSET(t, DMT_DAS) ? \"\" : \".usr\", d, a);\n\t\t} else {\n\t\t\t/* load */\n\t\t\tif (ISSET(t, DMT_DOUB1) && no == 2)\n\t\t\t\tdb_printf(\"ld.d%s r%d <- mem(0x%x), r%d <- mem(0x%x)\",\n\t\t\t\t    ISSET(t, DMT_DAS) ? \"\" : \".usr\", reg, a, reg+1, a+4);\n\t\t\telse\n\t\t\t\tdb_printf(\"ld%s r%d <- mem(0x%x)\",\n\t\t\t\t    ISSET(t, DMT_DAS) ? \"\" : \".usr\", reg, a);\n\t\t}\n\t} else {\n\t\t/* fractional word - check if load or store */\n\t\ta += addr_mod[DMT_ENBITS(t)];\n\t\tif (ISSET(t, DMT_WRITE))\n\t\t\tdb_printf(\"st%s%s (0x%x) -> mem(0x%x)\",\n\t\t\t    mode[DMT_ENBITS(t)],\n\t\t\t    ISSET(t, DMT_DAS) ? \"\" : \".usr\",\n\t\t\t    (d & mask[DMT_ENBITS(t)]) >> shift[DMT_ENBITS(t)],\n\t\t\t    a);\n\t\telse\n\t\t\tdb_printf(\"ld%s%s%s r%d <- mem(0x%x)\",\n\t\t\t    mode[DMT_ENBITS(t)],\n\t\t\t    ISSET(t, DMT_SIGNED) ? \"\" : \"u\",\n\t\t\t    ISSET(t, DMT_DAS) ? \"\" : \".usr\", reg, a);\n\t}\n\treturn (0);\n}", "item_id": 0, "repo": "sizeofvoid/ifconfigd", "file": "usr/src/sys/arch/m88k/m88k/db_interface.c", "last_update_at": "2020-08-28T01:27:00+00:00", "question_id": "0309fd79ec3c0b5bbfbd2a599824a0d119a48388_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nm88k_dmx_print(u_int t, u_int d, u_int a, u_int no)\n{\n\tstatic const u_int addr_mod[16] = {\n\t\t0, 3, 2, 2, 1, 0, 0, 0,\n\t\t0, 0, 0, 0, 0, 0, 0, 0\n\t};\n\tstatic const char *mode[16]  = {\n\t\t\"?\", \".b\", \".b\", \".h\", \".b\", \"?\", \"?\", \"?\",\n\t\t\".b\", \"?\", \"?\" , \"?\" , \".h\" , \"?\", \"?\", \"\"\n\t};\n\tstatic const u_int mask[16] = {\n\t\t0, 0xff, 0xff00, 0xffff,\n\t\t0xff0000, 0, 0, 0,\n\t\t0xff000000, 0, 0, 0,\n\t\t0xffff0000, 0, 0, 0xffffffff\n\t};\n\tstatic const u_int shift[16] = {\n\t\t0,  0, 8, 0, 16, 0, 0, 0,\n\t\t24, 0, 0, 0, 16, 0, 0, 0\n\t};\n\tint reg = DMT_DREGBITS(t);\n\tif (ISSET(t, DMT_LOCKBAR)) {\n\t\tdb_printf(\"xmem%s%s r%d(0x%x) <-> mem(0x%x),\",\n\t\t    DMT_ENBITS(t) == 0x0f ? \"\" : \".bu\",\n\t\t    ISSET(t, DMT_DAS) ? \"\" : \".usr\", reg,\n\t\t    ((t >> 2 & 0xf) == 0xf) ? d : (d & 0xff), a);\n\t\treturn 1;\n\t} else if (DMT_ENBITS(t) == 0xf) {\n\t\t/* full or double word */\n\t\tif (ISSET(t, DMT_WRITE)) {\n\t\t\tif (ISSET(t, DMT_DOUB1) && no == 2)\n\t\t\t\tdb_printf(\"st.d%s -> mem(0x%x) (** restart sxip **)\",\n\t\t\t\t    ISSET(t, DMT_DAS) ? \"\" : \".usr\", a);\n\t\t\telse\n\t\t\t\tdb_printf(\"st%s (0x%x) -> mem(0x%x)\",\n\t\t\t\t    ISSET(t, DMT_DAS) ? \"\" : \".usr\", d, a);\n\t\t} else {\n\t\t\t/* load */\n\t\t\tif (ISSET(t, DMT_DOUB1) && no == 2)\n\t\t\t\tdb_printf(\"ld.d%s r%d <- mem(0x%x), r%d <- mem(0x%x)\",\n\t\t\t\t    ISSET(t, DMT_DAS) ? \"\" : \".usr\", reg, a, reg+1, a+4);\n\t\t\telse\n\t\t\t\tdb_printf(\"ld%s r%d <- mem(0x%x)\",\n\t\t\t\t    ISSET(t, DMT_DAS) ? \"\" : \".usr\", reg, a);\n\t\t}\n\t} else {\n\t\t/* fractional word - check if load or store */\n\t\ta += addr_mod[DMT_ENBITS(t)];\n\t\tif (ISSET(t, DMT_WRITE))\n\t\t\tdb_printf(\"st%s%s (0x%x) -> mem(0x%x)\",\n\t\t\t    mode[DMT_ENBITS(t)],\n\t\t\t    ISSET(t, DMT_DAS) ? \"\" : \".usr\",\n\t\t\t    (d & mask[DMT_ENBITS(t)]) >> shift[DMT_ENBITS(t)],\n\t\t\t    a);\n\t\telse\n\t\t\tdb_printf(\"ld%s%s%s r%d <- mem(0x%x)\",\n\t\t\t    mode[DMT_ENBITS(t)],\n\t\t\t    ISSET(t, DMT_SIGNED) ? \"\" : \"u\",\n\t\t\t    ISSET(t, DMT_DAS) ? \"\" : \".usr\", reg, a);\n\t}\n\treturn (0);\n"]]}
{"hexsha": "f01ca4334d91ec12f1dee3990b3b7e2fa93bb0fc", "ext": "c", "lang": "C", "content": "static void abov_tk_dual_detection_mode(struct abov_tk_info *info, int mode)\n{\n\tu8 cmd;\n\tint ret;\n\n\tif (info->fw_ver < ABOV_DUAL_DETECTION_CMD_FW_VER) {\n\t\tinfo->dual_mode = false;\n\t\treturn;\n\t}\n\n\tdev_info(&info->client->dev,\n\t\t\t\"%s: %s\\n\", __func__, mode ? \"on\" : \"off\");\n\n\tif (mode)\n\t\tcmd = CMD_DUAL_DETECT;\n\telse\n\t\tcmd = CMD_SINGLE_DETECT;\n\n\tret = abov_tk_i2c_write(info->client, ABOV_DUAL_DETECT, &cmd, 1);\n\tif (ret < 0)\n\t\tdev_err(&info->client->dev,\n\t\t\t\"%s %d : fail %d\\n\", __func__, __LINE__, ret);\n\n\tinfo->dual_mode = !!mode;\n}", "item_id": 28, "repo": "CaelestisZ/IrisCore", "file": "drivers/input/keyboard/abov_touchkey_a7.c", "last_update_at": "2020-06-28T00:49:21+00:00", "question_id": "f01ca4334d91ec12f1dee3990b3b7e2fa93bb0fc_28", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void abov_tk_dual_detection_mode(struct abov_tk_info *info, int mode)\n{\n\tu8 cmd;\n\tint ret;\n\tif (info->fw_ver < ABOV_DUAL_DETECTION_CMD_FW_VER) {\n\t\tinfo->dual_mode = false;\n\t\treturn;\n\t}\n\tdev_info(&info->client->dev,\n\t\t\t\"%s: %s\\n\", __func__, mode ? \"on\" : \"off\");\n\tif (mode)\n\t\tcmd = CMD_DUAL_DETECT;\n\telse\n\t\tcmd = CMD_SINGLE_DETECT;\n\tret = abov_tk_i2c_write(info->client, ABOV_DUAL_DETECT, &cmd, 1);\n\tif (ret < 0)\n\t\tdev_err(&info->client->dev,\n\t\t\t\"%s %d : fail %d\\n\", __func__, __LINE__, ret);\n\tinfo->dual_mode = !!mode;\n"]]}
{"hexsha": "95eb22e0722facfcbd64dd95905a715a76876465", "ext": "c", "lang": "C", "content": "void reg_msg_init(struct public_params *pub, struct register_msg *msg)\n{\n   element_init_G1(msg->M, pub->p);\n   element_init_G1(msg->R, pub->p);\n   element_init_Zr(msg->rg, pub->p);\n   element_init_Zr(msg->rZ, pub->p);\n}", "item_id": 3, "repo": "ut-osa/anon-pass", "file": "src/libanonpass/anon-pass.c", "last_update_at": "2020-05-01T20:04:02+00:00", "question_id": "95eb22e0722facfcbd64dd95905a715a76876465_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void reg_msg_init(struct public_params *pub, struct register_msg *msg)\n{\n   element_init_G1(msg->M, pub->p);\n   element_init_G1(msg->R, pub->p);\n   element_init_Zr(msg->rg, pub->p);\n   element_init_Zr(msg->rZ, pub->p);\n"]]}
{"hexsha": "fdb726a5a42aa226e6970736626f9c8bf36ae884", "ext": "c", "lang": "C", "content": "static int smb1351_determine_initial_state(struct smb1351_charger *chip)\n{\n\tint rc;\n\tu8 reg = 0;\n\n\t/*\n\t * It is okay to read the interrupt status here since\n\t * interrupts aren't requested. Reading interrupt status\n\t * clears the interrupt so be careful to read interrupt\n\t * status only in interrupt handling code\n\t */\n\n\trc = smb1351_read_reg(chip, IRQ_B_REG, &reg);\n\tif (rc) {\n\t\tpr_err(\"Couldn't read IRQ_B rc = %d\\n\", rc);\n\t\tgoto fail_init_status;\n\t}\n\n\tchip->battery_missing = (reg & IRQ_BATT_MISSING_BIT) ? true : false;\n\n\trc = smb1351_read_reg(chip, IRQ_C_REG, &reg);\n\tif (rc) {\n\t\tpr_err(\"Couldn't read IRQ_C rc = %d\\n\", rc);\n\t\tgoto fail_init_status;\n\t}\n\tchip->batt_full = (reg & IRQ_TERM_BIT) ? true : false;\n\n\trc = smb1351_read_reg(chip, IRQ_A_REG, &reg);\n\tif (rc) {\n\t\tpr_err(\"Couldn't read irq A rc = %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (reg & IRQ_HOT_HARD_BIT)\n\t\tchip->batt_hot = true;\n\tif (reg & IRQ_COLD_HARD_BIT)\n\t\tchip->batt_cold = true;\n\tif (reg & IRQ_HOT_SOFT_BIT)\n\t\tchip->batt_warm = true;\n\tif (reg & IRQ_COLD_SOFT_BIT)\n\t\tchip->batt_cool = true;\n\n\trc = smb1351_read_reg(chip, IRQ_E_REG, &reg);\n\tif (rc) {\n\t\tpr_err(\"Couldn't read IRQ_E rc = %d\\n\", rc);\n\t\tgoto fail_init_status;\n\t}\n\n\tif (reg & IRQ_USBIN_UV_BIT) {\n\t\tsmb1351_usbin_uv_handler(chip, 1);\n\t} else {\n\t\tsmb1351_stay_awake(&chip->smb1351_ws, RERUN_APSD);\n\t\tschedule_delayed_work(&chip->rerun_apsd_work,\n\t\t\t\tmsecs_to_jiffies(RERUN_APSD_DELAY_MS));\n\t}\n\n\trc = smb1351_read_reg(chip, IRQ_G_REG, &reg);\n\tif (rc) {\n\t\tpr_err(\"Couldn't read IRQ_G rc = %d\\n\", rc);\n\t\tgoto fail_init_status;\n\t}\n\n\tif (reg & IRQ_SOURCE_DET_BIT)\n\t\tsmb1351_apsd_complete_handler(chip, 1);\n\n\treturn 0;\n\nfail_init_status:\n\tpr_err(\"Couldn't determine initial status\\n\");\n\treturn rc;\n}", "item_id": 84, "repo": "CaelestisZ/IrisCore", "file": "drivers/power/smb1351-charger.c", "last_update_at": "2020-06-28T00:49:21+00:00", "question_id": "fdb726a5a42aa226e6970736626f9c8bf36ae884_84", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int smb1351_determine_initial_state(struct smb1351_charger *chip)\n{\n\tint rc;\n\tu8 reg = 0;\n\t/*\n\t * It is okay to read the interrupt status here since\n\t * interrupts aren't requested. Reading interrupt status\n\t * clears the interrupt so be careful to read interrupt\n\t * status only in interrupt handling code\n\t */\n\trc = smb1351_read_reg(chip, IRQ_B_REG, &reg);\n\tif (rc) {\n\t\tpr_err(\"Couldn't read IRQ_B rc = %d\\n\", rc);\n\t\tgoto fail_init_status;\n\t}\n\tchip->battery_missing = (reg & IRQ_BATT_MISSING_BIT) ? true : false;\n\trc = smb1351_read_reg(chip, IRQ_C_REG, &reg);\n\tif (rc) {\n\t\tpr_err(\"Couldn't read IRQ_C rc = %d\\n\", rc);\n\t\tgoto fail_init_status;\n\t}\n\tchip->batt_full = (reg & IRQ_TERM_BIT) ? true : false;\n\trc = smb1351_read_reg(chip, IRQ_A_REG, &reg);\n\tif (rc) {\n\t\tpr_err(\"Couldn't read irq A rc = %d\\n\", rc);\n\t\treturn rc;\n\t}\n\tif (reg & IRQ_HOT_HARD_BIT)\n\t\tchip->batt_hot = true;\n\tif (reg & IRQ_COLD_HARD_BIT)\n\t\tchip->batt_cold = true;\n\tif (reg & IRQ_HOT_SOFT_BIT)\n\t\tchip->batt_warm = true;\n\tif (reg & IRQ_COLD_SOFT_BIT)\n\t\tchip->batt_cool = true;\n\trc = smb1351_read_reg(chip, IRQ_E_REG, &reg);\n\tif (rc) {\n\t\tpr_err(\"Couldn't read IRQ_E rc = %d\\n\", rc);\n\t\tgoto fail_init_status;\n\t}\n\tif (reg & IRQ_USBIN_UV_BIT) {\n\t\tsmb1351_usbin_uv_handler(chip, 1);\n\t} else {\n\t\tsmb1351_stay_awake(&chip->smb1351_ws, RERUN_APSD);\n\t\tschedule_delayed_work(&chip->rerun_apsd_work,\n\t\t\t\tmsecs_to_jiffies(RERUN_APSD_DELAY_MS));\n\t}\n\trc = smb1351_read_reg(chip, IRQ_G_REG, &reg);\n\tif (rc) {\n\t\tpr_err(\"Couldn't read IRQ_G rc = %d\\n\", rc);\n\t\tgoto fail_init_status;\n\t}\n\tif (reg & IRQ_SOURCE_DET_BIT)\n\t\tsmb1351_apsd_complete_handler(chip, 1);\n\treturn 0;\nfail_init_status:\n\tpr_err(\"Couldn't determine initial status\\n\");\n\treturn rc;\n"]]}
{"hexsha": "62c00d81b6da971b239ae5d4ad6d9ecbe85340a7", "ext": "c", "lang": "C", "content": "JNICALL\nJava_com_pingan_apicrypt_ApiCrypt_encrypt(JNIEnv *env, jclass type, jstring enc_) {\n    const char *enc = (*env)->GetStringUTFChars(env, enc_, 0);\n\n    if (enc == NULL || strlen(enc) <= 0) {\n        return NULL;\n    }\n\n    unsigned char *pBuffer = NULL;\n\n    //\u7b80\u5355\u5f02\u6216\u52a0\u5bc6\n    //simpleEnc(enc, returnValue);\n\n    //DES\u52a0\u5bc6\n    des_encipher((const unsigned char *) enc, &pBuffer);\n\n    //AES\u52a0\u5bc6\n//    aes128_cbc_encrypt(enc, NULL, &pBuffer);\n\n    (*env)->ReleaseStringUTFChars(env, enc_, enc);\n\n    jstring ret = (*env)->NewStringUTF(env, (char *)pBuffer);\n\n    free(pBuffer);\n    return ret;\n}", "item_id": 2, "repo": "leonsimple/ApiCrypt", "file": "app/src/main/jni/api_crypt.c", "last_update_at": "2020-10-05T22:26:12+00:00", "question_id": "62c00d81b6da971b239ae5d4ad6d9ecbe85340a7_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["JNICALL\nJava_com_pingan_apicrypt_ApiCrypt_encrypt(JNIEnv *env, jclass type, jstring enc_) {\n    const char *enc = (*env)->GetStringUTFChars(env, enc_, 0);\n    if (enc == NULL || strlen(enc) <= 0) {\n        return NULL;\n    }\n    unsigned char *pBuffer = NULL;\n    //\u7b80\u5355\u5f02\u6216\u52a0\u5bc6\n    //simpleEnc(enc, returnValue);\n    //DES\u52a0\u5bc6\n    des_encipher((const unsigned char *) enc, &pBuffer);\n    //AES\u52a0\u5bc6\n//    aes128_cbc_encrypt(enc, NULL, &pBuffer);\n    (*env)->ReleaseStringUTFChars(env, enc_, enc);\n    jstring ret = (*env)->NewStringUTF(env, (char *)pBuffer);\n    free(pBuffer);\n    return ret;\n"]]}
{"hexsha": "5ff962d8102a9885a12d17cfeab042bcd9261277", "ext": "c", "lang": "C", "content": "static int\nptls_compare_separator_line (const char *line, const char *begin_or_end,\n\t\t\t     const char *label)\n{\n  int ret = strncmp (line, \"-----\", 5);\n  size_t text_index = 5;\n\n  if (ret == 0)\n    {\n      size_t begin_or_end_length = strlen (begin_or_end);\n      ret = strncmp (line + text_index, begin_or_end, begin_or_end_length);\n      text_index += begin_or_end_length;\n    }\n\n  if (ret == 0)\n    {\n      ret = line[text_index] - ' ';\n      text_index++;\n    }\n\n  if (ret == 0)\n    {\n      size_t label_length = strlen (label);\n      ret = strncmp (line + text_index, label, label_length);\n      text_index += label_length;\n    }\n\n  if (ret == 0)\n    {\n      ret = strncmp (line + text_index, \"-----\", 5);\n    }\n\n  return ret;\n}", "item_id": 10, "repo": "lfntac/vppmirror", "file": "src/plugins/quic/quic.c", "last_update_at": "2020-09-23T08:56:24+00:00", "question_id": "5ff962d8102a9885a12d17cfeab042bcd9261277_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nptls_compare_separator_line (const char *line, const char *begin_or_end,\n\t\t\t     const char *label)\n{\n  int ret = strncmp (line, \"-----\", 5);\n  size_t text_index = 5;\n  if (ret == 0)\n    {\n      size_t begin_or_end_length = strlen (begin_or_end);\n      ret = strncmp (line + text_index, begin_or_end, begin_or_end_length);\n      text_index += begin_or_end_length;\n    }\n  if (ret == 0)\n    {\n      ret = line[text_index] - ' ';\n      text_index++;\n    }\n  if (ret == 0)\n    {\n      size_t label_length = strlen (label);\n      ret = strncmp (line + text_index, label, label_length);\n      text_index += label_length;\n    }\n  if (ret == 0)\n    {\n      ret = strncmp (line + text_index, \"-----\", 5);\n    }\n  return ret;\n"]]}
{"hexsha": "280de5037ca96adac96b488cc9abfc6238ce6428", "ext": "h", "lang": "C", "content": "CC_INLINE void cccfb_one_shot(const struct ccmode_cfb *mode,\n                              size_t key_len, const void *key, const void *iv,\n                              size_t nbytes, const void *in, void *out)\n{\n\tcccfb_ctx_decl(mode->size, ctx);\n\tmode->init(mode, ctx, key_len, key, iv);\n\tmode->cfb(ctx, nbytes, in, out);\n\tcccfb_ctx_clear(mode->size, ctx);\n}", "item_id": 2, "repo": "GaloisInc/hacrypto", "file": "src/C/corecrypto/ccmode/corecrypto/ccmode.h", "last_update_at": "2020-11-10T06:45:28+00:00", "question_id": "280de5037ca96adac96b488cc9abfc6238ce6428_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["CC_INLINE void cccfb_one_shot(const struct ccmode_cfb *mode,\n                              size_t key_len, const void *key, const void *iv,\n                              size_t nbytes, const void *in, void *out)\n{\n\tcccfb_ctx_decl(mode->size, ctx);\n\tmode->init(mode, ctx, key_len, key, iv);\n\tmode->cfb(ctx, nbytes, in, out);\n\tcccfb_ctx_clear(mode->size, ctx);\n"]]}
{"hexsha": "2cf794aac94e0405a850f99d2521e0f233d4cde6", "ext": "c", "lang": "C", "content": "METHODDEF(void)\r\nfinish_pass_master (j_compress_ptr cinfo)\r\n{\r\n  my_master_ptr master = (my_master_ptr) cinfo->master;\r\n\r\n  /* The entropy coder always needs an end-of-pass call,\r\n   * either to analyze statistics or to flush its output buffer.\r\n   */\r\n  (*cinfo->entropy->finish_pass) (cinfo);\r\n\r\n  /* Update state for next pass */\r\n  switch (master->pass_type) {\r\n  case main_pass:\r\n    /* next pass is either output of scan 0 (after optimization)\r\n     * or output of scan 1 (if no optimization).\r\n     */\r\n    master->pass_type = output_pass;\r\n    if (! cinfo->optimize_coding)\r\n      master->scan_number++;\r\n    break;\r\n  case huff_opt_pass:\r\n    /* next pass is always output of current scan */\r\n    master->pass_type = output_pass;\r\n    break;\r\n  case output_pass:\r\n    /* next pass is either optimization or output of next scan */\r\n    if (cinfo->optimize_coding)\r\n      master->pass_type = huff_opt_pass;\r\n    master->scan_number++;\r\n    break;\r\n  }\r\n\r\n  master->pass_number++;\r\n}", "item_id": 8, "repo": "nalinimsingh/ITK_4D", "file": "Modules/ThirdParty/JPEG/src/itkjpeg/jcmaster.c", "last_update_at": "2020-02-01T02:07:00+00:00", "question_id": "2cf794aac94e0405a850f99d2521e0f233d4cde6_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["METHODDEF(void)\r\nfinish_pass_master (j_compress_ptr cinfo)\r\n{\r\n  my_master_ptr master = (my_master_ptr) cinfo->master;\r\n\r\n  /* The entropy coder always needs an end-of-pass call,\r\n   * either to analyze statistics or to flush its output buffer.\r\n   */\r\n  (*cinfo->entropy->finish_pass) (cinfo);\r\n\r\n  /* Update state for next pass */\r\n  switch (master->pass_type) {\r\n  case main_pass:\r\n    /* next pass is either output of scan 0 (after optimization)\r\n     * or output of scan 1 (if no optimization).\r\n     */\r\n    master->pass_type = output_pass;\r\n    if (! cinfo->optimize_coding)\r\n      master->scan_number++;\r\n    break;\r\n  case huff_opt_pass:\r\n    /* next pass is always output of current scan */\r\n    master->pass_type = output_pass;\r\n    break;\r\n  case output_pass:\r\n    /* next pass is either optimization or output of next scan */\r\n    if (cinfo->optimize_coding)\r\n      master->pass_type = huff_opt_pass;\r\n    master->scan_number++;\r\n    break;\r\n  }\r\n\r\n  master->pass_number++;\r\n"]]}
{"hexsha": "baa35db61c142aea924b784e3dc1fdcd090aaa66", "ext": "c", "lang": "C", "content": "static int set_joy_b_x_axis_name(const char *val,void *param)\n{\n    util_string_set(&joy_b.axis[HID_X_AXIS].name, val);\n    if (joy_done_init) {\n        setup_axis_mapping(&joy_b);\n    }\n    return 0;\n}", "item_id": 9, "repo": "paulscottrobson/cxp-computer", "file": "core/vice-3.3/src/arch/gtk3/joy-osx.c", "last_update_at": "2020-02-03T16:46:40+00:00", "question_id": "baa35db61c142aea924b784e3dc1fdcd090aaa66_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int set_joy_b_x_axis_name(const char *val,void *param)\n{\n    util_string_set(&joy_b.axis[HID_X_AXIS].name, val);\n    if (joy_done_init) {\n        setup_axis_mapping(&joy_b);\n    }\n    return 0;\n"]]}
{"hexsha": "664ab3d9944e9680c85ec4185224d31e1d2f8447", "ext": "c", "lang": "C", "content": "void\nthread_rele(kthread_t *t)\n{\n\tkproject_t *kpj;\n\n\tthread_lock(t);\n\n\tASSERT(t == curthread || t->t_state == TS_FREE || t->t_procp == &p0);\n\tkpj = ttoproj(t);\n\tt->t_proj = proj0p;\n\n\tthread_unlock(t);\n\n\tif (kpj != proj0p) {\n\t\tproject_rele(kpj);\n\t\t(void) project_hold(proj0p);\n\t}\n}", "item_id": 3, "repo": "AsahiOS/gate", "file": "usr/src/uts/common/disp/thread.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "664ab3d9944e9680c85ec4185224d31e1d2f8447_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nthread_rele(kthread_t *t)\n{\n\tkproject_t *kpj;\n\tthread_lock(t);\n\tASSERT(t == curthread || t->t_state == TS_FREE || t->t_procp == &p0);\n\tkpj = ttoproj(t);\n\tt->t_proj = proj0p;\n\tthread_unlock(t);\n\tif (kpj != proj0p) {\n\t\tproject_rele(kpj);\n\t\t(void) project_hold(proj0p);\n\t}\n"]]}
{"hexsha": "3bff718f60c51ae860968f165cb183a7af3b5967", "ext": "c", "lang": "C", "content": "void sparse_exponential(int n, int nnz, int *ia, int *ja, double *a, double t, double *initialArray, double *res){ \n\tint i;\n\tint m = n-1; \n\tdouble w[n];\n\tint ideg = 6;\n\tdouble tol = 1;\n\tint iflag = 0;\n\tint lwsp = n*(m+1)+n+pow((m+2.),2)+4*pow((m+2.),2)+ideg+1;\n\tdouble  wsp[lwsp];\n\tint liwsp = m+2;\n\tint iwsp[liwsp];\n\tdouble t1 = t;\n\tdouble anorm = 0;\n\tint itrace = 0;\n\n\tfor(i=0;i<=n*n;i++)res[i]=0.0;\t\n\twrapalldmexpv_(&n,&m,&t1,initialArray,w,&tol,&anorm,wsp,&lwsp,iwsp,&liwsp,\n\t\t\t&itrace,&iflag,ia,ja,a,&nnz,res);\n\n}", "item_id": 0, "repo": "dortegadelv/IMaDNA", "file": "sparseExp.c", "last_update_at": "2020-04-17T17:22:14+00:00", "question_id": "3bff718f60c51ae860968f165cb183a7af3b5967_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void sparse_exponential(int n, int nnz, int *ia, int *ja, double *a, double t, double *initialArray, double *res){ \n\tint i;\n\tint m = n-1; \n\tdouble w[n];\n\tint ideg = 6;\n\tdouble tol = 1;\n\tint iflag = 0;\n\tint lwsp = n*(m+1)+n+pow((m+2.),2)+4*pow((m+2.),2)+ideg+1;\n\tdouble  wsp[lwsp];\n\tint liwsp = m+2;\n\tint iwsp[liwsp];\n\tdouble t1 = t;\n\tdouble anorm = 0;\n\tint itrace = 0;\n\tfor(i=0;i<=n*n;i++)res[i]=0.0;\t\n\twrapalldmexpv_(&n,&m,&t1,initialArray,w,&tol,&anorm,wsp,&lwsp,iwsp,&liwsp,\n\t\t\t&itrace,&iflag,ia,ja,a,&nnz,res);\n"]]}
{"hexsha": "1e775eb48e85e5a69dc89ff4a0bf97e1e6a73601", "ext": "c", "lang": "C", "content": "ofc_sema_typeval_t* ofc_sema_typeval_multiply(\n\tconst ofc_sema_typeval_t* a,\n\tconst ofc_sema_typeval_t* b)\n{\n\tif (!a || !a->type\n\t\t|| !b || !b->type\n\t\t|| !ofc_sema_type_compatible(\n\t\t\ta->type, b->type))\n\t\treturn NULL;\n\n\tofc_sema_typeval_t tv;\n\ttv.type = a->type;\n\n\ttv.src = OFC_SPARSE_REF_EMPTY;\n\tofc_sparse_ref_bridge(\n\t\ta->src, b->src, &tv.src);\n\n\tswitch (a->type->type)\n\t{\n\t\tcase OFC_SEMA_TYPE_REAL:\n\t\t\ttv.real = a->real * b->real;\n\t\t\tbreak;\n\t\tcase OFC_SEMA_TYPE_COMPLEX:\n\t\t\ttv.complex.real = (a->complex.real * b->complex.real)\n\t\t\t\t- (a->complex.imaginary * b->complex.imaginary);\n\t\t\ttv.complex.imaginary = (a->complex.real * b->complex.imaginary)\n\t\t\t\t+ (b->complex.real * a->complex.imaginary);\n\t\t\tbreak;\n\t\tcase OFC_SEMA_TYPE_INTEGER:\n\t\tcase OFC_SEMA_TYPE_BYTE:\n\t\t\ttv.integer = a->integer * b->integer;\n\t\t\tif ((b->integer != 0)\n\t\t\t\t&& ((tv.integer / b->integer) != a->integer))\n\t\t\t\treturn NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn NULL;\n\t}\n\n\treturn ofc_sema_typeval__alloc(tv);\n}", "item_id": 30, "repo": "mbdevpl/open-fortran-compiler", "file": "src/sema/typeval.c", "last_update_at": "2020-06-03T02:05:18+00:00", "question_id": "1e775eb48e85e5a69dc89ff4a0bf97e1e6a73601_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ofc_sema_typeval_t* ofc_sema_typeval_multiply(\n\tconst ofc_sema_typeval_t* a,\n\tconst ofc_sema_typeval_t* b)\n{\n\tif (!a || !a->type\n\t\t|| !b || !b->type\n\t\t|| !ofc_sema_type_compatible(\n\t\t\ta->type, b->type))\n\t\treturn NULL;\n\tofc_sema_typeval_t tv;\n\ttv.type = a->type;\n\ttv.src = OFC_SPARSE_REF_EMPTY;\n\tofc_sparse_ref_bridge(\n\t\ta->src, b->src, &tv.src);\n\tswitch (a->type->type)\n\t{\n\t\tcase OFC_SEMA_TYPE_REAL:\n\t\t\ttv.real = a->real * b->real;\n\t\t\tbreak;\n\t\tcase OFC_SEMA_TYPE_COMPLEX:\n\t\t\ttv.complex.real = (a->complex.real * b->complex.real)\n\t\t\t\t- (a->complex.imaginary * b->complex.imaginary);\n\t\t\ttv.complex.imaginary = (a->complex.real * b->complex.imaginary)\n\t\t\t\t+ (b->complex.real * a->complex.imaginary);\n\t\t\tbreak;\n\t\tcase OFC_SEMA_TYPE_INTEGER:\n\t\tcase OFC_SEMA_TYPE_BYTE:\n\t\t\ttv.integer = a->integer * b->integer;\n\t\t\tif ((b->integer != 0)\n\t\t\t\t&& ((tv.integer / b->integer) != a->integer))\n\t\t\t\treturn NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn NULL;\n\t}\n\treturn ofc_sema_typeval__alloc(tv);\n"]]}
{"hexsha": "bf86dc3a808b0e0c868cc5db791a953433cd3d94", "ext": "c", "lang": "C", "content": "void editor_del_row(int at)\n{\n    if(at < 0 || at >= E.numrows) return;\n    editor_free_row(&E.row[at]);\n    memmove(&E.row[at], &E.row[at + 1], sizeof(erow) * (E.numrows - at - 1));\n    for(int j = at; j < E.numrows - 1; j++) E.row[j].idx--;\n    E.numrows--;\n    E.dirty++;\n}", "item_id": 17, "repo": "Gun9niR/Kilo", "file": "kilo.c", "last_update_at": "2020-07-29T13:02:04+00:00", "question_id": "bf86dc3a808b0e0c868cc5db791a953433cd3d94_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void editor_del_row(int at)\n{\n    if(at < 0 || at >= E.numrows) return;\n    editor_free_row(&E.row[at]);\n    memmove(&E.row[at], &E.row[at + 1], sizeof(erow) * (E.numrows - at - 1));\n    for(int j = at; j < E.numrows - 1; j++) E.row[j].idx--;\n    E.numrows--;\n    E.dirty++;\n"]]}
{"hexsha": "2f43f279e2ad3c80cfcdfdff19ff1dd48bc7c956", "ext": "c", "lang": "C", "content": "static int cmp_pt(const void* a, const void* b)\n{\n    const Point* pa = (const Point*)a;\n    const Point* pb = (const Point*)b;\n    int d = pa->y - pb->y;\n    return d ? d : (int)(pa->x - pb->x);\n}", "item_id": 1, "repo": "KhronosGroup/OpenVX-cts", "file": "test_conformance/test_minmaxloc.c", "last_update_at": "2020-05-16T18:26:35+00:00", "question_id": "2f43f279e2ad3c80cfcdfdff19ff1dd48bc7c956_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int cmp_pt(const void* a, const void* b)\n{\n    const Point* pa = (const Point*)a;\n    const Point* pb = (const Point*)b;\n    int d = pa->y - pb->y;\n    return d ? d : (int)(pa->x - pb->x);\n"]]}
{"hexsha": "6722eeed6406260589589bfff536811d23577508", "ext": "h", "lang": "C", "content": "class ProgramActions : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit ProgramActions(QObject* parent = nullptr);\n    ~ProgramActions();\n    bool authorization(QMap<QString, QLineEdit*>* lineEdits);\n    bool registration(QMap<QString, QLineEdit*>* lineEdits);\n    void clearFields(QMap<QString, QLineEdit*>* lineEdits);\n    void checkAnswers(QMap<QString, QLineEdit*>* lineEdits, QMap<QString, QLabel*>* labels);\n    void clearTaskList(QMap<QString, QLabel*>* labels);\n    void setTasks(QMap<QString, QLabel*>* labels);\n    void setResult(QMap<QString, QLabel*>* results, QMap<QString, QLabel*>* labels);\n    void clearAnswers();\n\nprivate:\n    bool validator(QMap<QString, QLineEdit*>* lineEdits);\n    QString getTasks();\n    QMap<QString, QString> getFields(QMap<QString, QLineEdit*>* lineEdits);\n    void setAnswer(QString task, int answer);\n\n    ProgramModel* myDatabase;\n    QMap<QString, int> answers;\n    QMap<QString, bool> myResult;\n}", "item_id": 0, "repo": "Nikolai-Barabanov/my_QT_projects", "file": "Arithmetic/programactions.h", "last_update_at": "2020-07-23T18:06:17+00:00", "question_id": "6722eeed6406260589589bfff536811d23577508_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class ProgramActions : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit ProgramActions(QObject* parent = nullptr);\n    ~ProgramActions();\n    bool authorization(QMap<QString, QLineEdit*>* lineEdits);\n    bool registration(QMap<QString, QLineEdit*>* lineEdits);\n    void clearFields(QMap<QString, QLineEdit*>* lineEdits);\n    void checkAnswers(QMap<QString, QLineEdit*>* lineEdits, QMap<QString, QLabel*>* labels);\n    void clearTaskList(QMap<QString, QLabel*>* labels);\n    void setTasks(QMap<QString, QLabel*>* labels);\n    void setResult(QMap<QString, QLabel*>* results, QMap<QString, QLabel*>* labels);\n    void clearAnswers();\nprivate:\n    bool validator(QMap<QString, QLineEdit*>* lineEdits);\n    QString getTasks();\n    QMap<QString, QString> getFields(QMap<QString, QLineEdit*>* lineEdits);\n    void setAnswer(QString task, int answer);\n    ProgramModel* myDatabase;\n    QMap<QString, int> answers;\n    QMap<QString, bool> myResult;\n"]]}
{"hexsha": "a97f5987d227a45f513330e865b644e31b80f769", "ext": "c", "lang": "C", "content": "int PMI2_Finalize(void)\n{\n    int pmi2_errno = PMI2_SUCCESS;\n    int rc;\n    const char *errmsg;\n    PMI2_Command cmd = { 0 };\n\n    if (PMI2_initialized > SINGLETON_INIT_BUT_NO_PM) {\n        pmi2_errno = PMIi_WriteSimpleCommandStr(PMI2_fd, &cmd, FINALIZE_CMD, NULL);\n        if (pmi2_errno)\n            PMI2U_ERR_POP(pmi2_errno);\n        pmi2_errno = PMIi_ReadCommandExp(PMI2_fd, &cmd, FINALIZERESP_CMD, &rc, &errmsg);\n        if (pmi2_errno)\n            PMI2U_ERR_POP(pmi2_errno);\n        PMI2U_ERR_CHKANDJUMP1(rc, pmi2_errno, PMI2_ERR_OTHER, \"**pmi2_finalize\",\n                              \"**pmi2_finalize %s\", errmsg ? errmsg : \"unknown\");\n        PMI2U_Free(cmd.command);\n        freepairs(cmd.pairs, cmd.nPairs);\n\n        shutdown(PMI2_fd, SHUT_RDWR);\n        close(PMI2_fd);\n    }\n\n  fn_exit:\n    return pmi2_errno;\n  fn_fail:\n\n    goto fn_exit;\n}", "item_id": 7, "repo": "ucd-plse/mpi-error-prop", "file": "mpich-3.3/src/pmi/pmi2/simple/simple2pmi.c", "last_update_at": "2020-07-17T04:14:25+00:00", "question_id": "a97f5987d227a45f513330e865b644e31b80f769_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int PMI2_Finalize(void)\n{\n    int pmi2_errno = PMI2_SUCCESS;\n    int rc;\n    const char *errmsg;\n    PMI2_Command cmd = { 0 };\n    if (PMI2_initialized > SINGLETON_INIT_BUT_NO_PM) {\n        pmi2_errno = PMIi_WriteSimpleCommandStr(PMI2_fd, &cmd, FINALIZE_CMD, NULL);\n        if (pmi2_errno)\n            PMI2U_ERR_POP(pmi2_errno);\n        pmi2_errno = PMIi_ReadCommandExp(PMI2_fd, &cmd, FINALIZERESP_CMD, &rc, &errmsg);\n        if (pmi2_errno)\n            PMI2U_ERR_POP(pmi2_errno);\n        PMI2U_ERR_CHKANDJUMP1(rc, pmi2_errno, PMI2_ERR_OTHER, \"**pmi2_finalize\",\n                              \"**pmi2_finalize %s\", errmsg ? errmsg : \"unknown\");\n        PMI2U_Free(cmd.command);\n        freepairs(cmd.pairs, cmd.nPairs);\n        shutdown(PMI2_fd, SHUT_RDWR);\n        close(PMI2_fd);\n    }\n  fn_exit:\n    return pmi2_errno;\n  fn_fail:\n    goto fn_exit;\n"]]}
{"hexsha": "7bc9bc3ead6ecad9c4a3a03446bd70e330208f69", "ext": "c", "lang": "C", "content": "void SetTrayY(TrayType *tp, const char *str)\n{\n   Assert(tp);\n   Assert(str);\n   tp->requestedY = atoi(str);\n}", "item_id": 28, "repo": "xinligg/jwm", "file": "src/tray.c", "last_update_at": "2020-11-26T07:26:55+00:00", "question_id": "7bc9bc3ead6ecad9c4a3a03446bd70e330208f69_28", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void SetTrayY(TrayType *tp, const char *str)\n{\n   Assert(tp);\n   Assert(str);\n   tp->requestedY = atoi(str);\n"]]}
{"hexsha": "306be2ff0d815abd3a0fa87c00f3887dac0327d3", "ext": "c", "lang": "C", "content": "int main(int argc, char *argv[]) {\n\tFILE *fp;\n\tint a, b[600];\n\tunsigned i, n;\n\tchar c;\n\n\tif (argc != 2) {\n\t\tprintf(\"Usage: %s [FILE]\\n\", argv[0]);\n\t\treturn 1;\n\t}\n\tfp = fopen(*++argv, \"r\");\n\tdo {\n\t\tc = getc(fp);\n\t} while (c != ',' && c != EOF);\n\twhile (fscanf(fp, \"%d\", &a) != EOF) {\n\t\tb[0] = a;\n\t\tn = 1;\n\t\twhile (getc(fp) == ';' && getc(fp) == ' ') {\n\t\t\tdo {\n\t\t\t\tc = getc(fp);\n\t\t\t} while (c != ',' && c != EOF);\n\t\t\tif (fscanf(fp, \"%d\", &b[n++]) == EOF)\n\t\t\t\tgoto fail_eof;\n\t\t}\n\t\tqsort(&b, n, sizeof(int), cmpint);\n\t\tfor (i = n - 1; i > 0; i--) {\n\t\t\tb[i] -= b[i - 1];\n\t\t}\n\t\tprintf(\"%d\", b[0]);\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tprintf(\",%d\", b[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tdo {\n\t\t\tc = getc(fp);\n\t\t} while (c != ',' && c != EOF);\n\t}\n\treturn 0;\nfail_eof:\n\tprintf(\"unexpected end of input\\n\");\n\treturn EXIT_FAILURE;\n}", "item_id": 0, "repo": "IlkhamGaysin/ce-challenges", "file": "easy/road_trip.c", "last_update_at": "2020-08-03T11:44:54+00:00", "question_id": "306be2ff0d815abd3a0fa87c00f3887dac0327d3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char *argv[]) {\n\tFILE *fp;\n\tint a, b[600];\n\tunsigned i, n;\n\tchar c;\n\tif (argc != 2) {\n\t\tprintf(\"Usage: %s [FILE]\\n\", argv[0]);\n\t\treturn 1;\n\t}\n\tfp = fopen(*++argv, \"r\");\n\tdo {\n\t\tc = getc(fp);\n\t} while (c != ',' && c != EOF);\n\twhile (fscanf(fp, \"%d\", &a) != EOF) {\n\t\tb[0] = a;\n\t\tn = 1;\n\t\twhile (getc(fp) == ';' && getc(fp) == ' ') {\n\t\t\tdo {\n\t\t\t\tc = getc(fp);\n\t\t\t} while (c != ',' && c != EOF);\n\t\t\tif (fscanf(fp, \"%d\", &b[n++]) == EOF)\n\t\t\t\tgoto fail_eof;\n\t\t}\n\t\tqsort(&b, n, sizeof(int), cmpint);\n\t\tfor (i = n - 1; i > 0; i--) {\n\t\t\tb[i] -= b[i - 1];\n\t\t}\n\t\tprintf(\"%d\", b[0]);\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tprintf(\",%d\", b[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tdo {\n\t\t\tc = getc(fp);\n\t\t} while (c != ',' && c != EOF);\n\t}\n\treturn 0;\nfail_eof:\n\tprintf(\"unexpected end of input\\n\");\n\treturn EXIT_FAILURE;\n"]]}
{"hexsha": "4a7e249f84404ba049c38add27a511ae501f8ec2", "ext": "c", "lang": "C", "content": "static usbdifStatus_t\nUsbdVendorDataIn(usbdifClassDef_t *prc, uint8_t epnum)\n{\n  usbdVendorHandle_t        *pVendor;\n\n  pVendor = (usbdVendorHandle_t*) prc->pClassData;\n\n  if(pVendor != USBDIF_NULL) {\n    pVendor->TxState = 0;\n    return USBDIF_STATUS_SUCCESS;\n  } else {\n    return USBDIF_STATUS_UNKNOWN;\n  }\n}", "item_id": 3, "repo": "zhtlab/McuDevelop", "file": "Middlewares/Usbdif/src/usbdvendor.c", "last_update_at": "2020-12-14T09:29:53+00:00", "question_id": "4a7e249f84404ba049c38add27a511ae501f8ec2_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static usbdifStatus_t\nUsbdVendorDataIn(usbdifClassDef_t *prc, uint8_t epnum)\n{\n  usbdVendorHandle_t        *pVendor;\n  pVendor = (usbdVendorHandle_t*) prc->pClassData;\n  if(pVendor != USBDIF_NULL) {\n    pVendor->TxState = 0;\n    return USBDIF_STATUS_SUCCESS;\n  } else {\n    return USBDIF_STATUS_UNKNOWN;\n  }\n"]]}
{"hexsha": "d2a36491f9ae91204426ba39fdcec2b107c6ebe7", "ext": "c", "lang": "C", "content": "s32 act_grabbed(struct MarioState *m) {\n    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK2) {\n        s32 thrown = (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK6) == 0;\n\n        m->faceAngle[1] = m->usedObj->oMoveAngleYaw;\n        vec3f_copy(m->pos, m->marioObj->header.gfx.pos);\n#ifdef VERSION_SH\n        queue_rumble_data(5, 60);\n#endif\n\n        return set_mario_action(m, (m->forwardVel >= 0.0f) ? ACT_THROWN_FORWARD : ACT_THROWN_BACKWARD,\n                                thrown);\n    }\n\n    set_mario_animation(m, MARIO_ANIM_BEING_GRABBED);\n    return FALSE;\n}", "item_id": 21, "repo": "Daviz00/sm64", "file": "src/game/mario_actions_automatic.c", "last_update_at": "2020-12-23T13:53:10+00:00", "question_id": "d2a36491f9ae91204426ba39fdcec2b107c6ebe7_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["s32 act_grabbed(struct MarioState *m) {\n    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK2) {\n        s32 thrown = (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK6) == 0;\n        m->faceAngle[1] = m->usedObj->oMoveAngleYaw;\n        vec3f_copy(m->pos, m->marioObj->header.gfx.pos);\n#ifdef VERSION_SH\n        queue_rumble_data(5, 60);\n#endif\n        return set_mario_action(m, (m->forwardVel >= 0.0f) ? ACT_THROWN_FORWARD : ACT_THROWN_BACKWARD,\n                                thrown);\n    }\n    set_mario_animation(m, MARIO_ANIM_BEING_GRABBED);\n    return FALSE;\n"]]}
{"hexsha": "8838d512c14a7c5ec33e226bb650fc7a31dddc41", "ext": "h", "lang": "C", "content": "class InfoSQL {\n   public:\n      /**\n       * Constructs new SQL connection.\n       */\n      InfoSQL();\n\n\n      /**\n       * Destructor, dissconnects from SQL.\n       */\n      ~InfoSQL();\n\n   bool setupDatabaseConnection();\n   bool checkDatabaseConnection(int maxNbrTries = 1);\n\n      /**\n       *   @name Get- and delete- functions for trafficdisturbances.\n       */\n      //@{\n        /**\n         *  Adds a number of trafficdisturbances from a vector to the\n         *  database.\n         *  @param distVect  The vector with disturbances.\n         *  @param firstPacket True if it's the first disturbances that\n         *                     is sent with this situationID.\n         *  @return True if the adding was okey, otherwise false.\n         */\n      bool addDisturbance(DisturbanceElement* distElem);\n\n      /**\n       *  Removes the disturbances with a situationID\n       *  and elementID.\n\n       *  @param disturbanceID      The disturbance ID.\n       *  @param situationReference The situationReference string.\n       *  @param supplier           A string identifying a supplier.\n       *  @param removeAll          Whether all disturbances from the\n       *                            supplier should be removed.\n       *  @param toBeKept           A list of situationReference strings\n       *                            specifying which disturbances\n       *                            should not be removed if removeAll\n       *                            is set.\n       *  @return True if the delete was OK, otherwise false.\n       */\n   bool deleteDisturbances(DisturbanceElement::DisturbanceID disturbanceID,\n                              const MC2String& situationReference,\n                              const MC2String& supplier,\n                              bool removeAll,\n                              vector<MC2String>& toBeKept);\n\n      /**\n       *  Updates the disturbances with a situationID and a elementID.\n       *  @param type  The new disturbance type.\n       *  @param severity The new severity.\n       *  @param startTime The new disturbance start time.\n       *  @param endTime The new disturbance end time.\n       *  @param creationTime The time of the update, the new\n       *                      creation time.\n       *  @param comment The new disturbance comment.\n       *  @param situationID The situationID of the updated disturbance.\n       *  @param elementID The elementID of the updated disturbance.\n       *  @return True if the updating was okey, otherwise false.\n       */\n      bool updateDisturbance(uint32 disturbanceID,\n                             TrafficDataTypes::disturbanceType type,\n                             TrafficDataTypes::severity severity,\n                             uint32 startTime,\n                             uint32 endTime,\n                             uint32 costFactor,\n                             MC2String text);\n\n      /*\n       *  Returns all disturbances within a given bounding box from\n       *  the database.\n       *  @param bbox  The MC2BoundingBox.\n       *  @param distVect A reference to a vector, where the function\n       *                  inserts all the disturbances.\n       *  @return True if the loading was okey, otherwise false.\n       */\n      bool getDisturbancesWithinBBox(const MC2BoundingBox& bbox,\n                                     vector<DisturbanceElement*> &distVect);\n\n   /**\n       *  Returns all disturbances within a given bounding box from\n       *  the database.\n       *  @param bbox  The MC2BoundingBox.\n       *  @param distVect A reference to a vector, where the function\n       *                  inserts all the disturbances.\n       *  @return True if the loading was okey, otherwise false.\n       */\n      bool getDisturbancesWithinRadius(int32 latitude,\n                                       int32 longitude,\n                                       uint32 distance,\n                                       vector<DisturbanceElement*> &distVect);\n\n      /**\n       *  Returns all disturbances from a specified supplier.\n       *  @param distVect Output parameter. The found disturbances are\n       *                  push_back:ed into the vector.\n       *  @param supplier The string identifying the supplier.\n       */\n      void getDisturbancesForSupplier( vector<DisturbanceElement*> &distVect,\n                                       const MC2String& supplier );\n      /**\n       *  Returns all disturbances from a specified supplier, except\n       *  certain specified disturbances.\n       *  @param distVect Output parameter. The found disturbances are\n       *                  push_back:ed into the vector.\n       *  @param supplier The string identifying the supplier.\n       *  @param toBeKept A list of situationReference strings identifying\n       *                  situations that should not be inserted into\n       *                  <code>distVect</code>.\n       */\n      void getDisturbancesForSupplier( vector<DisturbanceElement*> &distVect,\n                                       const MC2String& supplier,\n                                       const vector<MC2String>& toBeKept );\n\n\n      /**\n       * Removes disturbances with end time less than time.\n       * @return true if operation successfull, false otherwise.\n       */\n      bool deleteOldDisturbances();\n\n\n      /**\n       *   Get the disturbance with the given ID.\n       *   @return The found disturbance or NULL if not found.\n       */\n      DisturbanceElement* getDisturbance(uint32 disturbanceID);\n\n      /**\n       *   Get the disturbance with the given situationReference\n       *   @return The found disturbance or NULL if not found.\n       */\n      DisturbanceElement* getDisturbance(const MC2String& situationReference);\n\nprivate:\n      /**\n       *   Get the disturbance with the given situationReference and\n       *   disturbanceID. If disturbanceID is equal to MAX_UINT32 it\n       *   is not considered.  If situationReference is equal to the\n       *   empty string it is not considered.\n       *   @return The found disturbance or NULL if not found.\n       */\n   DisturbanceElement* getDisturbance(DisturbanceElement::DisturbanceID disturbanceID,\n                                      const MC2String& situationReference);\npublic:\n\n      /**\n       *  Returns the coordinates of one or two TMC points in the database.\n       *  @param firstLocationCode The primary TMC point.\n       *  @param secondLocationCode The secondary TMC-point.\n       *  @param extent The extent.\n       *  @param direction The direction.\n       *  @param country The country\n       *  @param latitude The vector with lats.\n       *  @param longitude The vector with longs.\n       *  @return True if the point(s) were successfully found.\n       */\n      bool getTMCCoords(MC2String firstLocation,\n                        MC2String secondLocation,\n                        int32 extent,\n                        TrafficDataTypes::direction direction,\n                        vector< pair<int32, int32> > &firstCoords,\n                        vector< pair<int32, int32> > &secondCoords);\n\n   private:\n   /**\n    * Extract the first DisturbanceElement from a SQL answer.\n    * @param sqlQuery A SQL query already containing the answer.\n    *                 When the function returns it will have advanced\n    *                 to the first line that does not belong with the\n    *                 disturbance.\n    * @param disturbances Output parameter for the extracted disturbances.\n    */\n   void extractDisturbances(SQLQuery& sqlQuery,\n                           map<uint32,DisturbanceElement*>& disturbances);\n\n      /**\n       *   Do a SQL query. Copied from UserModule/UserProcessor\n       *   @param sqlQuery Pointer to the SQLQuery to use\n       *   @param query The query string\n       *   @param whereTag Set this to a constant string which\n       *                   identifies the callee\n       *   @return True if successful, false otherwise\n       */\n      //@{\n      bool doQuery(SQLQuery* sqlQuery,\n                   const std::ostringstream& stream,\n                   const char* whereTag);\n\n      bool doQuery(SQLQuery* sqlQuery, const MC2String& str,\n                   const char* whereTag);\n\n      bool doQuery(SQLQuery* sqlQuery, const char* query,\n                   const char* whereTag);\n      //@}\n\n      /**\n       *   Adds a table to the internal table vectors. Copied from\n       *   UserModule/UserProcessor\n       *   @param name The name of the table\n       *   @param createQuery The SQL query that creates the query\n       *   @param extraQuery Any additional query to run after creation of\n       *                     table (such as index creation)\n       */\n      void addTable(const MC2String& name, const MC2String& createQuery,\n                    const MC2String& extraQuery = \"\");\n\n      /**\n       *   Initializes the table vectors. Copied from UserModule/UserProcessor\n       *   @return The number of tables, 0 if something went wrong\n       */\n      size_t initTables();\n\n      /**\n       *   Checks database for required tables. Tries to create tables.\n       *   @return true if successfull\n       */\n      bool initialCheckDatabase();\n\n      /**\n       * Returns an unused id in a table.\n       * @param tableName The name of the table\n       * @param colName   The name of the id column\n       * @return Returns an unused id. 0 if error.\n       */\n      uint32 getNewUniqueID(const char* tableName, const char* colName);\n\n      /**\n       *   The database connection\n       */\n      CharEncSQLConn* m_sqlConnection;\n\n   /**\n    * Struct that encapsulates the data stored by calls to addTable.\n    */\n   struct TableData {\n      /**\n       * Constructor.\n       * @param name The name of the table.\n       * @param createQuery The query used to create the table if it\n       *                    doesn't exist.\n       * @param extraQuery Extra query run after a successful create\n       *                   query.\n       */\n      TableData(const MC2String& name,\n                const MC2String& createQuery,\n                const MC2String& extraQuery) :\n         name(name), createQuery(createQuery), extraQuery(extraQuery)\n      {}\n      /** The table name. */\n      MC2String name;\n      /** The query to create the table. */\n      MC2String createQuery;\n      /** Any extra query. */\n      MC2String extraQuery;\n   };\n   /** Typedef of container to store TableData structs in. */\n   typedef std::vector<TableData> tableCont_t;\n   /** Data about the needed tables. */\n   tableCont_t m_tableData;\n}", "item_id": 0, "repo": "wayfinder/Wayfinder-Server", "file": "Server/Modules/InfoModule/include/InfoSQL.h", "last_update_at": "2020-05-30T19:53:26+00:00", "question_id": "8838d512c14a7c5ec33e226bb650fc7a31dddc41_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class InfoSQL {\n   public:\n      /**\n       * Constructs new SQL connection.\n       */\n      InfoSQL();\n      /**\n       * Destructor, dissconnects from SQL.\n       */\n      ~InfoSQL();\n   bool setupDatabaseConnection();\n   bool checkDatabaseConnection(int maxNbrTries = 1);\n      /**\n       *   @name Get- and delete- functions for trafficdisturbances.\n       */\n      //@{\n        /**\n         *  Adds a number of trafficdisturbances from a vector to the\n         *  database.\n         *  @param distVect  The vector with disturbances.\n         *  @param firstPacket True if it's the first disturbances that\n         *                     is sent with this situationID.\n         *  @return True if the adding was okey, otherwise false.\n         */\n      bool addDisturbance(DisturbanceElement* distElem);\n      /**\n       *  Removes the disturbances with a situationID\n       *  and elementID.\n       *  @param disturbanceID      The disturbance ID.\n       *  @param situationReference The situationReference string.\n       *  @param supplier           A string identifying a supplier.\n       *  @param removeAll          Whether all disturbances from the\n       *                            supplier should be removed.\n       *  @param toBeKept           A list of situationReference strings\n       *                            specifying which disturbances\n       *                            should not be removed if removeAll\n       *                            is set.\n       *  @return True if the delete was OK, otherwise false.\n       */\n   bool deleteDisturbances(DisturbanceElement::DisturbanceID disturbanceID,\n                              const MC2String& situationReference,\n                              const MC2String& supplier,\n                              bool removeAll,\n                              vector<MC2String>& toBeKept);\n      /**\n       *  Updates the disturbances with a situationID and a elementID.\n       *  @param type  The new disturbance type.\n       *  @param severity The new severity.\n       *  @param startTime The new disturbance start time.\n       *  @param endTime The new disturbance end time.\n       *  @param creationTime The time of the update, the new\n       *                      creation time.\n       *  @param comment The new disturbance comment.\n       *  @param situationID The situationID of the updated disturbance.\n       *  @param elementID The elementID of the updated disturbance.\n       *  @return True if the updating was okey, otherwise false.\n       */\n      bool updateDisturbance(uint32 disturbanceID,\n                             TrafficDataTypes::disturbanceType type,\n                             TrafficDataTypes::severity severity,\n                             uint32 startTime,\n                             uint32 endTime,\n                             uint32 costFactor,\n                             MC2String text);\n      /*\n       *  Returns all disturbances within a given bounding box from\n       *  the database.\n       *  @param bbox  The MC2BoundingBox.\n       *  @param distVect A reference to a vector, where the function\n       *                  inserts all the disturbances.\n       *  @return True if the loading was okey, otherwise false.\n       */\n      bool getDisturbancesWithinBBox(const MC2BoundingBox& bbox,\n                                     vector<DisturbanceElement*> &distVect);\n   /**\n       *  Returns all disturbances within a given bounding box from\n       *  the database.\n       *  @param bbox  The MC2BoundingBox.\n       *  @param distVect A reference to a vector, where the function\n       *                  inserts all the disturbances.\n       *  @return True if the loading was okey, otherwise false.\n       */\n      bool getDisturbancesWithinRadius(int32 latitude,\n                                       int32 longitude,\n                                       uint32 distance,\n                                       vector<DisturbanceElement*> &distVect);\n      /**\n       *  Returns all disturbances from a specified supplier.\n       *  @param distVect Output parameter. The found disturbances are\n       *                  push_back:ed into the vector.\n       *  @param supplier The string identifying the supplier.\n       */\n      void getDisturbancesForSupplier( vector<DisturbanceElement*> &distVect,\n                                       const MC2String& supplier );\n      /**\n       *  Returns all disturbances from a specified supplier, except\n       *  certain specified disturbances.\n       *  @param distVect Output parameter. The found disturbances are\n       *                  push_back:ed into the vector.\n       *  @param supplier The string identifying the supplier.\n       *  @param toBeKept A list of situationReference strings identifying\n       *                  situations that should not be inserted into\n       *                  <code>distVect</code>.\n       */\n      void getDisturbancesForSupplier( vector<DisturbanceElement*> &distVect,\n                                       const MC2String& supplier,\n                                       const vector<MC2String>& toBeKept );\n      /**\n       * Removes disturbances with end time less than time.\n       * @return true if operation successfull, false otherwise.\n       */\n      bool deleteOldDisturbances();\n      /**\n       *   Get the disturbance with the given ID.\n       *   @return The found disturbance or NULL if not found.\n       */\n      DisturbanceElement* getDisturbance(uint32 disturbanceID);\n      /**\n       *   Get the disturbance with the given situationReference\n       *   @return The found disturbance or NULL if not found.\n       */\n      DisturbanceElement* getDisturbance(const MC2String& situationReference);\nprivate:\n      /**\n       *   Get the disturbance with the given situationReference and\n       *   disturbanceID. If disturbanceID is equal to MAX_UINT32 it\n       *   is not considered.  If situationReference is equal to the\n       *   empty string it is not considered.\n       *   @return The found disturbance or NULL if not found.\n       */\n   DisturbanceElement* getDisturbance(DisturbanceElement::DisturbanceID disturbanceID,\n                                      const MC2String& situationReference);\npublic:\n      /**\n       *  Returns the coordinates of one or two TMC points in the database.\n       *  @param firstLocationCode The primary TMC point.\n       *  @param secondLocationCode The secondary TMC-point.\n       *  @param extent The extent.\n       *  @param direction The direction.\n       *  @param country The country\n       *  @param latitude The vector with lats.\n       *  @param longitude The vector with longs.\n       *  @return True if the point(s) were successfully found.\n       */\n      bool getTMCCoords(MC2String firstLocation,\n                        MC2String secondLocation,\n                        int32 extent,\n                        TrafficDataTypes::direction direction,\n                        vector< pair<int32, int32> > &firstCoords,\n                        vector< pair<int32, int32> > &secondCoords);\n   private:\n   /**\n    * Extract the first DisturbanceElement from a SQL answer.\n    * @param sqlQuery A SQL query already containing the answer.\n    *                 When the function returns it will have advanced\n    *                 to the first line that does not belong with the\n    *                 disturbance.\n    * @param disturbances Output parameter for the extracted disturbances.\n    */\n   void extractDisturbances(SQLQuery& sqlQuery,\n                           map<uint32,DisturbanceElement*>& disturbances);\n      /**\n       *   Do a SQL query. Copied from UserModule/UserProcessor\n       *   @param sqlQuery Pointer to the SQLQuery to use\n       *   @param query The query string\n       *   @param whereTag Set this to a constant string which\n       *                   identifies the callee\n       *   @return True if successful, false otherwise\n       */\n      //@{\n      bool doQuery(SQLQuery* sqlQuery,\n                   const std::ostringstream& stream,\n                   const char* whereTag);\n      bool doQuery(SQLQuery* sqlQuery, const MC2String& str,\n                   const char* whereTag);\n      bool doQuery(SQLQuery* sqlQuery, const char* query,\n                   const char* whereTag);\n      //@}\n      /**\n       *   Adds a table to the internal table vectors. Copied from\n       *   UserModule/UserProcessor\n       *   @param name The name of the table\n       *   @param createQuery The SQL query that creates the query\n       *   @param extraQuery Any additional query to run after creation of\n       *                     table (such as index creation)\n       */\n      void addTable(const MC2String& name, const MC2String& createQuery,\n                    const MC2String& extraQuery = \"\");\n      /**\n       *   Initializes the table vectors. Copied from UserModule/UserProcessor\n       *   @return The number of tables, 0 if something went wrong\n       */\n      size_t initTables();\n      /**\n       *   Checks database for required tables. Tries to create tables.\n       *   @return true if successfull\n       */\n      bool initialCheckDatabase();\n      /**\n       * Returns an unused id in a table.\n       * @param tableName The name of the table\n       * @param colName   The name of the id column\n       * @return Returns an unused id. 0 if error.\n       */\n      uint32 getNewUniqueID(const char* tableName, const char* colName);\n      /**\n       *   The database connection\n       */\n      CharEncSQLConn* m_sqlConnection;\n   /**\n    * Struct that encapsulates the data stored by calls to addTable.\n    */\n   struct TableData {\n      /**\n       * Constructor.\n       * @param name The name of the table.\n       * @param createQuery The query used to create the table if it\n       *                    doesn't exist.\n       * @param extraQuery Extra query run after a successful create\n       *                   query.\n       */\n      TableData(const MC2String& name,\n                const MC2String& createQuery,\n                const MC2String& extraQuery) :\n         name(name), createQuery(createQuery), extraQuery(extraQuery)\n      {}\n      /** The table name. */\n      MC2String name;\n      /** The query to create the table. */\n      MC2String createQuery;\n      /** Any extra query. */\n      MC2String extraQuery;\n   };\n   /** Typedef of container to store TableData structs in. */\n   typedef std::vector<TableData> tableCont_t;\n   /** Data about the needed tables. */\n   tableCont_t m_tableData;\n"]]}
{"hexsha": "aaa16267ae708db7b48234ffed3233b49850824c", "ext": "c", "lang": "C", "content": "static int32_t\nimport_int32(struct import_stream *is) {\n\tif (is->size < 4) {\n\t\tluaL_error(is->alloc->L, \"Invalid import stream (%d)\",is->current_id);\n\t}\n\tuint8_t b[4];\n\tb[0] = (uint8_t)*(is->stream);\n\tb[1] = (uint8_t)*(is->stream+1);\n\tb[2] = (uint8_t)*(is->stream+2);\n\tb[3] = (uint8_t)*(is->stream+3);\n\tis->stream += 4;\n\tis->size -= 4;\n\n\treturn (int32_t)(b[0] | (uint32_t)b[1]<<8 | (uint32_t)b[2]<<16 | (uint32_t)b[3]<<24);\n}", "item_id": 3, "repo": "hanxi/ejoy2d", "file": "lib/spritepack.c", "last_update_at": "2020-03-03T10:40:32+00:00", "question_id": "aaa16267ae708db7b48234ffed3233b49850824c_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int32_t\nimport_int32(struct import_stream *is) {\n\tif (is->size < 4) {\n\t\tluaL_error(is->alloc->L, \"Invalid import stream (%d)\",is->current_id);\n\t}\n\tuint8_t b[4];\n\tb[0] = (uint8_t)*(is->stream);\n\tb[1] = (uint8_t)*(is->stream+1);\n\tb[2] = (uint8_t)*(is->stream+2);\n\tb[3] = (uint8_t)*(is->stream+3);\n\tis->stream += 4;\n\tis->size -= 4;\n\treturn (int32_t)(b[0] | (uint32_t)b[1]<<8 | (uint32_t)b[2]<<16 | (uint32_t)b[3]<<24);\n"]]}
{"hexsha": "353832cbf0c59e54fd3655367b48d677dcc31d25", "ext": "c", "lang": "C", "content": "int do_valid_stuff()\r\n{\r\n   printf(\"The serial number is valid!\\n\");\r\n   // do serial-restricted, valid stuff here.\r\n   exit( 0 );\r\n}", "item_id": 2, "repo": "yusefkarim/introduction-to-exploit-development", "file": "1_introduction_to_stack_overflows/src/serial.c", "last_update_at": "2020-12-22T19:49:23+00:00", "question_id": "353832cbf0c59e54fd3655367b48d677dcc31d25_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int do_valid_stuff()\r\n{\r\n   printf(\"The serial number is valid!\\n\");\r\n   // do serial-restricted, valid stuff here.\r\n   exit( 0 );\r\n"]]}
{"hexsha": "96d8d2c833d9db6e7bb048dc46bc8b2c31642c25", "ext": "h", "lang": "C", "content": "static inline int cpq_get_attention_status (struct controller *ctrl, struct slot *slot)\n{\n\tu8 hp_slot;\n\n\tif (slot == NULL)\n\t\treturn 1;\n\n\thp_slot = slot->device - ctrl->slot_device_offset;\n\n\treturn read_amber_LED (ctrl, hp_slot);\n}", "item_id": 17, "repo": "dnhua/Linux_study", "file": "linux-2.6.0/drivers/pci/hotplug/cpqphp.h", "last_update_at": "2020-11-10T12:47:02+00:00", "question_id": "96d8d2c833d9db6e7bb048dc46bc8b2c31642c25_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline int cpq_get_attention_status (struct controller *ctrl, struct slot *slot)\n{\n\tu8 hp_slot;\n\tif (slot == NULL)\n\t\treturn 1;\n\thp_slot = slot->device - ctrl->slot_device_offset;\n\treturn read_amber_LED (ctrl, hp_slot);\n"]]}
{"hexsha": "962df4ff500ca40ef6efeeca4166c9dcad999718", "ext": "c", "lang": "C", "content": "int\nfop_vnevent(vnode_t *vp, vnevent_t vnevent, vnode_t *dvp, char *fnm,\n    caller_context_t *ct)\n{\n\tint\terr;\n\n\terr = (*(vp)->v_op->vop_vnevent)(vp, vnevent, dvp, fnm, ct);\n\tVOPSTATS_UPDATE(vp, vnevent);\n\treturn (err);\n}", "item_id": 97, "repo": "AsahiOS/gate", "file": "usr/src/uts/common/fs/vnode.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "962df4ff500ca40ef6efeeca4166c9dcad999718_97", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nfop_vnevent(vnode_t *vp, vnevent_t vnevent, vnode_t *dvp, char *fnm,\n    caller_context_t *ct)\n{\n\tint\terr;\n\terr = (*(vp)->v_op->vop_vnevent)(vp, vnevent, dvp, fnm, ct);\n\tVOPSTATS_UPDATE(vp, vnevent);\n\treturn (err);\n"]]}
{"hexsha": "9060ba0a7fa88a0a4dbb338ca3e46c7b404d3550", "ext": "c", "lang": "C", "content": "static void a_1434(int a_F1){ /* listfillblock+>a */\nint a_L2;int a_L3;int a_L4;int a_P[2];\nif(!a_1431()){ goto a_G3;}\na_1423(a_F1);return;\na_G3:a_L4=0;a_L3=0;\na_1012(2106125219);\na_G5:if(a_1417(1454739076)){ goto a_G5;}\nif(!a_1430(a_P)){ goto a_G9;}a_L2=a_P[0];\na_1015(a_L2);\na_G8:__incr(a_L4); goto a_G5;\na_G9:if(!a_1262(a_P)){ goto a_G13;}a_L2=a_P[0];\na_1272(a_L2);\na_1017(a_L2); goto a_G8;\na_G13:if(!__equal(a_L4,0)){ goto a_G16;}\na_P[0]=2093833888;a_P[1]=a_F1;a_1108(2,a_P+0);\na_1269();return;\na_G16:if(!a_1417(1454739064)){ goto a_G21;}\nif(!__equal(a_L3,0)){ goto a_G20;}\na_L3=1;\na_1012(2106125250); goto a_G5;\na_G20:a_P[0]=2093833841;a_P[1]=a_F1;a_1108(2,a_P+0); goto a_G5;\na_G21:a_1264(1454739070);\na_1012(2106125139);return;\n}", "item_id": 270, "repo": "lcsirmaz/aleph", "file": "c/comp.c", "last_update_at": "2020-04-01T23:43:15+00:00", "question_id": "9060ba0a7fa88a0a4dbb338ca3e46c7b404d3550_270", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void a_1434(int a_F1){ /* listfillblock+>a */\nint a_L2;int a_L3;int a_L4;int a_P[2];\nif(!a_1431()){ goto a_G3;}\na_1423(a_F1);return;\na_G3:a_L4=0;a_L3=0;\na_1012(2106125219);\na_G5:if(a_1417(1454739076)){ goto a_G5;}\nif(!a_1430(a_P)){ goto a_G9;}a_L2=a_P[0];\na_1015(a_L2);\na_G8:__incr(a_L4); goto a_G5;\na_G9:if(!a_1262(a_P)){ goto a_G13;}a_L2=a_P[0];\na_1272(a_L2);\na_1017(a_L2); goto a_G8;\na_G13:if(!__equal(a_L4,0)){ goto a_G16;}\na_P[0]=2093833888;a_P[1]=a_F1;a_1108(2,a_P+0);\na_1269();return;\na_G16:if(!a_1417(1454739064)){ goto a_G21;}\nif(!__equal(a_L3,0)){ goto a_G20;}\na_L3=1;\na_1012(2106125250); goto a_G5;\na_G20:a_P[0]=2093833841;a_P[1]=a_F1;a_1108(2,a_P+0); goto a_G5;\na_G21:a_1264(1454739070);\na_1012(2106125139);return;\n"]]}
{"hexsha": "93eca487086214dd83c0ca0a98aa47b421a9470e", "ext": "c", "lang": "C", "content": "void\ninit_desctbls(void)\n{\n\tuint_t vec;\n\tuser_desc_t *gdt;\n\n\t/*\n\t * Setup and install our GDT.\n\t */\n\tgdt = init_gdt();\n\n\t/*\n\t * Store static pa of gdt to speed up pa_to_ma() translations\n\t * on lwp context switches.\n\t */\n\tASSERT(IS_P2ALIGNED((uintptr_t)gdt, PAGESIZE));\n\tCPU->cpu_gdt = gdt;\n\tCPU->cpu_m.mcpu_gdtpa = pfn_to_pa(va_to_pfn(gdt));\n\n\t/*\n\t * Setup and install our IDT.\n\t */\n#if !defined(__lint)\n\tASSERT(NIDT * sizeof (*idt0) <= PAGESIZE);\n#endif\n\tidt0 = (gate_desc_t *)BOP_ALLOC(bootops, (caddr_t)IDT_VA,\n\t    PAGESIZE, PAGESIZE);\n\tbzero(idt0, PAGESIZE);\n\tinit_idt(idt0);\n\tfor (vec = 0; vec < NIDT; vec++)\n\t\txen_idt_write(&idt0[vec], vec);\n\n\tCPU->cpu_idt = idt0;\n\n\t/*\n\t * set default kernel stack\n\t */\n\txen_stack_switch(KDS_SEL,\n\t    (ulong_t)&dblfault_stack0[sizeof (dblfault_stack0)]);\n\n\txen_init_callbacks();\n\n\tinit_ldt();\n}", "item_id": 17, "repo": "AsahiOS/gate", "file": "usr/src/uts/intel/ia32/os/desctbls.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "93eca487086214dd83c0ca0a98aa47b421a9470e_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\ninit_desctbls(void)\n{\n\tuint_t vec;\n\tuser_desc_t *gdt;\n\t/*\n\t * Setup and install our GDT.\n\t */\n\tgdt = init_gdt();\n\t/*\n\t * Store static pa of gdt to speed up pa_to_ma() translations\n\t * on lwp context switches.\n\t */\n\tASSERT(IS_P2ALIGNED((uintptr_t)gdt, PAGESIZE));\n\tCPU->cpu_gdt = gdt;\n\tCPU->cpu_m.mcpu_gdtpa = pfn_to_pa(va_to_pfn(gdt));\n\t/*\n\t * Setup and install our IDT.\n\t */\n#if !defined(__lint)\n\tASSERT(NIDT * sizeof (*idt0) <= PAGESIZE);\n#endif\n\tidt0 = (gate_desc_t *)BOP_ALLOC(bootops, (caddr_t)IDT_VA,\n\t    PAGESIZE, PAGESIZE);\n\tbzero(idt0, PAGESIZE);\n\tinit_idt(idt0);\n\tfor (vec = 0; vec < NIDT; vec++)\n\t\txen_idt_write(&idt0[vec], vec);\n\tCPU->cpu_idt = idt0;\n\t/*\n\t * set default kernel stack\n\t */\n\txen_stack_switch(KDS_SEL,\n\t    (ulong_t)&dblfault_stack0[sizeof (dblfault_stack0)]);\n\txen_init_callbacks();\n\tinit_ldt();\n"]]}
{"hexsha": "590899c31767f2f5a9a6fa68732167a57010e38b", "ext": "c", "lang": "C", "content": "static VALUE\ngl_EvalCoord1dv(obj,arg1)\nVALUE obj,arg1;\n{\n\tGLdouble params[1] = {0.0};\n\tCheck_Type(arg1,T_ARRAY);\n\tary2cdbl(arg1,params,1);\n\tglEvalCoord1dv(params);\n\tCHECK_GLERROR_FROM(\"glEvalCoord1dv\");\n\treturn Qnil;\n}", "item_id": 51, "repo": "drbrain/opengl", "file": "ext/opengl/gl-1.0-1.1.c", "last_update_at": "2020-12-27T23:01:47+00:00", "question_id": "590899c31767f2f5a9a6fa68732167a57010e38b_51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static VALUE\ngl_EvalCoord1dv(obj,arg1)\nVALUE obj,arg1;\n{\n\tGLdouble params[1] = {0.0};\n\tCheck_Type(arg1,T_ARRAY);\n\tary2cdbl(arg1,params,1);\n\tglEvalCoord1dv(params);\n\tCHECK_GLERROR_FROM(\"glEvalCoord1dv\");\n\treturn Qnil;\n"]]}
{"hexsha": "de8e63173b8be0eb53741e5165506cb64d0ac1fa", "ext": "c", "lang": "C", "content": "static char *\nunq(const char *str)\n{\n\tconst char *s;\n\tchar *unq_str, *d;\n\tint escaped;\n\n\tunq_str = malloc(strlen(str) + 1);\n\tif (unq_str == NULL)\n\t\treturn NULL;\n\n\tescaped = 0;\n\td = unq_str;\n\tfor (s = str; *s != '\\0'; s++) {\n\t\tswitch (*s) {\n\t\tcase '\\\\':\n\t\t\tif (escaped)\n\t\t\t\t*d++ = *s;\n\t\t\tescaped = !escaped;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*d++ = *s;\n\t\t\tescaped = 0;\n\t\t}\n\t}\n\t*d = '\\0';\n\n\treturn unq_str;\n}", "item_id": 2, "repo": "calmsacibis995/minix", "file": "crypto/external/bsd/libsaslc/dist/src/mech_digestmd5.c", "last_update_at": "2020-11-10T06:45:28+00:00", "question_id": "de8e63173b8be0eb53741e5165506cb64d0ac1fa_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static char *\nunq(const char *str)\n{\n\tconst char *s;\n\tchar *unq_str, *d;\n\tint escaped;\n\tunq_str = malloc(strlen(str) + 1);\n\tif (unq_str == NULL)\n\t\treturn NULL;\n\tescaped = 0;\n\td = unq_str;\n\tfor (s = str; *s != '\\0'; s++) {\n\t\tswitch (*s) {\n\t\tcase '\\\\':\n\t\t\tif (escaped)\n\t\t\t\t*d++ = *s;\n\t\t\tescaped = !escaped;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*d++ = *s;\n\t\t\tescaped = 0;\n\t\t}\n\t}\n\t*d = '\\0';\n\treturn unq_str;\n"]]}
{"hexsha": "1314e52a7e38705cd25d76479500654f245ac0bc", "ext": "c", "lang": "C", "content": "void insert(node** h, int key)\n{\n\tnode* temp = malloc(sizeof(node));\n\ttemp->data = key;\n\tif(*h)\n\t{\n\t\ttemp->next = *h;\n\t\ttemp = *h;\n\t}\n\telse\n\t{\n\t\ttemp->next = NULL;\n\t\t*h = temp;\n\t}\n}", "item_id": 0, "repo": "Bharat123rox/DataStructures-Algorithms-Assignments", "file": "Week 9/9_4.c", "last_update_at": "2020-02-22T04:36:10+00:00", "question_id": "1314e52a7e38705cd25d76479500654f245ac0bc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void insert(node** h, int key)\n{\n\tnode* temp = malloc(sizeof(node));\n\ttemp->data = key;\n\tif(*h)\n\t{\n\t\ttemp->next = *h;\n\t\ttemp = *h;\n\t}\n\telse\n\t{\n\t\ttemp->next = NULL;\n\t\t*h = temp;\n\t}\n"]]}
{"hexsha": "0be6a9ece117b200e2c43850300c41fe1a236867", "ext": "c", "lang": "C", "content": "DPIX *\ndpixCopy(DPIX  *dpixd,   /* can be null */\n         DPIX  *dpixs)\n{\nl_int32     w, h, bytes;\nl_float64  *datas, *datad;\n\n    PROCNAME(\"dpixCopy\");\n\n    if (!dpixs)\n        return (DPIX *)ERROR_PTR(\"dpixs not defined\", procName, NULL);\n    if (dpixs == dpixd)\n        return dpixd;\n\n        /* Total bytes in image data */\n    dpixGetDimensions(dpixs, &w, &h);\n    bytes = 8 * w * h;\n\n        /* If we're making a new dpix ... */\n    if (!dpixd) {\n        if ((dpixd = dpixCreateTemplate(dpixs)) == NULL)\n            return (DPIX *)ERROR_PTR(\"dpixd not made\", procName, NULL);\n        datas = dpixGetData(dpixs);\n        datad = dpixGetData(dpixd);\n        memcpy((char *)datad, (char *)datas, bytes);\n        return dpixd;\n    }\n\n        /* Reallocate image data if sizes are different */\n    dpixResizeImageData(dpixd, dpixs);\n\n        /* Copy data */\n    dpixCopyResolution(dpixd, dpixs);\n    datas = dpixGetData(dpixs);\n    datad = dpixGetData(dpixd);\n    memcpy((char*)datad, (char*)datas, bytes);\n    return dpixd;\n}", "item_id": 20, "repo": "dreamsxin/ultimatepp", "file": "bazaar/PixRaster/lib/fpix1.c", "last_update_at": "2020-04-14T12:37:34+00:00", "question_id": "0be6a9ece117b200e2c43850300c41fe1a236867_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["DPIX *\ndpixCopy(DPIX  *dpixd,   /* can be null */\n         DPIX  *dpixs)\n{\nl_int32     w, h, bytes;\nl_float64  *datas, *datad;\n    PROCNAME(\"dpixCopy\");\n    if (!dpixs)\n        return (DPIX *)ERROR_PTR(\"dpixs not defined\", procName, NULL);\n    if (dpixs == dpixd)\n        return dpixd;\n        /* Total bytes in image data */\n    dpixGetDimensions(dpixs, &w, &h);\n    bytes = 8 * w * h;\n        /* If we're making a new dpix ... */\n    if (!dpixd) {\n        if ((dpixd = dpixCreateTemplate(dpixs)) == NULL)\n            return (DPIX *)ERROR_PTR(\"dpixd not made\", procName, NULL);\n        datas = dpixGetData(dpixs);\n        datad = dpixGetData(dpixd);\n        memcpy((char *)datad, (char *)datas, bytes);\n        return dpixd;\n    }\n        /* Reallocate image data if sizes are different */\n    dpixResizeImageData(dpixd, dpixs);\n        /* Copy data */\n    dpixCopyResolution(dpixd, dpixs);\n    datas = dpixGetData(dpixs);\n    datad = dpixGetData(dpixd);\n    memcpy((char*)datad, (char*)datas, bytes);\n    return dpixd;\n"]]}
{"hexsha": "3c172dd6a0c7a61bb18cdf670091b3cce16b27e9", "ext": "c", "lang": "C", "content": "void bdrv_detach_aio_context(BlockDriverState *bs)\n{\n    BdrvAioNotifier *baf;\n\n    if (!bs->drv) {\n        return;\n    }\n\n    QLIST_FOREACH(baf, &bs->aio_notifiers, list) {\n        baf->detach_aio_context(baf->opaque);\n    }\n\n    if (bs->throttle_state) {\n        throttle_timers_detach_aio_context(&bs->throttle_timers);\n    }\n    if (bs->drv->bdrv_detach_aio_context) {\n        bs->drv->bdrv_detach_aio_context(bs);\n    }\n    if (bs->file) {\n        bdrv_detach_aio_context(bs->file->bs);\n    }\n    if (bs->backing) {\n        bdrv_detach_aio_context(bs->backing->bs);\n    }\n\n    bs->aio_context = NULL;\n}", "item_id": 100, "repo": "trusted-ws/qira", "file": "tracers/qemu/qemu/block.c", "last_update_at": "2020-12-02T16:32:17+00:00", "question_id": "3c172dd6a0c7a61bb18cdf670091b3cce16b27e9_100", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void bdrv_detach_aio_context(BlockDriverState *bs)\n{\n    BdrvAioNotifier *baf;\n    if (!bs->drv) {\n        return;\n    }\n    QLIST_FOREACH(baf, &bs->aio_notifiers, list) {\n        baf->detach_aio_context(baf->opaque);\n    }\n    if (bs->throttle_state) {\n        throttle_timers_detach_aio_context(&bs->throttle_timers);\n    }\n    if (bs->drv->bdrv_detach_aio_context) {\n        bs->drv->bdrv_detach_aio_context(bs);\n    }\n    if (bs->file) {\n        bdrv_detach_aio_context(bs->file->bs);\n    }\n    if (bs->backing) {\n        bdrv_detach_aio_context(bs->backing->bs);\n    }\n    bs->aio_context = NULL;\n"]]}
{"hexsha": "7402a314f694052a5c54aae3ba803936daa06ec8", "ext": "c", "lang": "C", "content": "void boardInit(void) {\n\n#if USE_MSP430_USART0\n  P3SEL |= (1 << 4) | (1 << 5);\n#endif\n\n#if USE_MSP430_USART1\n  P3SEL |= (1 << 6) | (1 << 7);\n#endif\n\n  /*\n   * Timer 0 setup, uses SMCLK as source.\n   */\n  TACCR0 = SMCLK / 4 / CH_FREQUENCY - 1;/* Counter limit.               */\n  TACTL = TACLR;                        /* Clean start.                 */\n  TACTL = TASSEL_2 | ID_2 | MC_1;       /* Src=SMCLK, ID=4, cmp=TACCR0. */\n  TACCTL0 = CCIE;                       /* Interrupt on compare.        */\n}", "item_id": 1, "repo": "Tecnologic/STM32H743_ChibiOS", "file": "os/os/hal/boards/OLIMEX_MSP430_P1611/board.c", "last_update_at": "2020-08-29T03:33:55+00:00", "question_id": "7402a314f694052a5c54aae3ba803936daa06ec8_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void boardInit(void) {\n#if USE_MSP430_USART0\n  P3SEL |= (1 << 4) | (1 << 5);\n#endif\n#if USE_MSP430_USART1\n  P3SEL |= (1 << 6) | (1 << 7);\n#endif\n  /*\n   * Timer 0 setup, uses SMCLK as source.\n   */\n  TACCR0 = SMCLK / 4 / CH_FREQUENCY - 1;/* Counter limit.               */\n  TACTL = TACLR;                        /* Clean start.                 */\n  TACTL = TASSEL_2 | ID_2 | MC_1;       /* Src=SMCLK, ID=4, cmp=TACCR0. */\n  TACCTL0 = CCIE;                       /* Interrupt on compare.        */\n"]]}
{"hexsha": "2daaad6e91ef2a92c7711d68cfef8c2f6967e0b0", "ext": "c", "lang": "C", "content": "static int\ncopy_devinfo(const char *path, const char *connection, uint_t flags,\n    hp_node_t *rootp)\n{\n\thp_node_t\thp_root = NULL;\n\tdi_node_t\tdi_root;\n\tint\t\trv;\n\n\t/* Get libdevinfo snapshot */\n\tif ((di_root = di_init(path, DINFOSUBTREE | DINFOHP)) == DI_NODE_NIL)\n\t\treturn (errno);\n\n\t/* Do initial search pass, if required */\n\tif (strcmp(path, \"/\") == 0) {\n\t\tflags |= HPINFOSEARCH;\n\t\t(void) di_walk_node(di_root, DI_WALK_CLDFIRST, NULL, search_cb);\n\t}\n\n\t/*\n\t * If a connection is specified, just copy immediate hotplug info.\n\t * Else, copy the device tree normally.\n\t */\n\tif (connection != NULL)\n\t\trv = copy_hotplug(NULL, di_root, connection, flags, &hp_root);\n\telse\n\t\trv = copy_devices(NULL, di_root, flags, &hp_root);\n\n\t/* Destroy devinfo snapshot */\n\tdi_fini(di_root);\n\n\t*rootp = (rv == 0) ? hp_root : NULL;\n\treturn (rv);\n}", "item_id": 1, "repo": "AsahiOS/gate", "file": "usr/src/cmd/hotplugd/hotplugd_info.c", "last_update_at": "2020-12-30T00:04:16+00:00", "question_id": "2daaad6e91ef2a92c7711d68cfef8c2f6967e0b0_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\ncopy_devinfo(const char *path, const char *connection, uint_t flags,\n    hp_node_t *rootp)\n{\n\thp_node_t\thp_root = NULL;\n\tdi_node_t\tdi_root;\n\tint\t\trv;\n\t/* Get libdevinfo snapshot */\n\tif ((di_root = di_init(path, DINFOSUBTREE | DINFOHP)) == DI_NODE_NIL)\n\t\treturn (errno);\n\t/* Do initial search pass, if required */\n\tif (strcmp(path, \"/\") == 0) {\n\t\tflags |= HPINFOSEARCH;\n\t\t(void) di_walk_node(di_root, DI_WALK_CLDFIRST, NULL, search_cb);\n\t}\n\t/*\n\t * If a connection is specified, just copy immediate hotplug info.\n\t * Else, copy the device tree normally.\n\t */\n\tif (connection != NULL)\n\t\trv = copy_hotplug(NULL, di_root, connection, flags, &hp_root);\n\telse\n\t\trv = copy_devices(NULL, di_root, flags, &hp_root);\n\t/* Destroy devinfo snapshot */\n\tdi_fini(di_root);\n\t*rootp = (rv == 0) ? hp_root : NULL;\n\treturn (rv);\n"]]}
{"hexsha": "bd366ecb746b7221cae82928009f6943dcc88831", "ext": "h", "lang": "C", "content": "class d912pxy_thread_lock\n{\npublic:\n\td912pxy_thread_lock();\t\n\t~d912pxy_thread_lock();\n\t\n\tUINT32 TryHold();\n\tvoid Hold();\n\tvoid Release();\n\tvoid Init();\n\n\tLONG LockedAdd(LONG val);\n\tvoid LockedSet(LONG val);\n\n\tvoid WaitHold(LONG cond);\n\tvoid HoldWait(LONG cond);\n\n\tLONG SpinOnce(LONG cond);\n\n\tLONG Add(LONG val);\n\tvoid Wait(LONG cond);\n\tUINT WaitTimeout(LONG cond, DWORD ms);\t\n\n\tLONG GetValue();\n\tvoid SetValue(LONG val);\n\tvoid SetValueAsync(LONG val);\n\n\tvoid ResetLock();\n\t\nprivate:\t\n\tCRITICAL_SECTION cs;\n\tLONG spinLock;\n\n}", "item_id": 0, "repo": "febryjp/d912pxy", "file": "d912pxy/d912pxy_thread_lock.h", "last_update_at": "2020-07-19T14:56:07+00:00", "question_id": "bd366ecb746b7221cae82928009f6943dcc88831_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class d912pxy_thread_lock\n{\npublic:\n\td912pxy_thread_lock();\t\n\t~d912pxy_thread_lock();\n\t\n\tUINT32 TryHold();\n\tvoid Hold();\n\tvoid Release();\n\tvoid Init();\n\tLONG LockedAdd(LONG val);\n\tvoid LockedSet(LONG val);\n\tvoid WaitHold(LONG cond);\n\tvoid HoldWait(LONG cond);\n\tLONG SpinOnce(LONG cond);\n\tLONG Add(LONG val);\n\tvoid Wait(LONG cond);\n\tUINT WaitTimeout(LONG cond, DWORD ms);\t\n\tLONG GetValue();\n\tvoid SetValue(LONG val);\n\tvoid SetValueAsync(LONG val);\n\tvoid ResetLock();\n\t\nprivate:\t\n\tCRITICAL_SECTION cs;\n\tLONG spinLock;\n"]]}
{"hexsha": "7f497e2a2ff47035706db774f54a963cff35afae", "ext": "c", "lang": "C", "content": "static void insert(WrenVM* vm)\n{\n  wrenSetSlotNewMap(vm, 0);\n  \n  wrenEnsureSlots(vm, 3);\n\n  // Insert String\n  wrenSetSlotString(vm, 1, \"England\");\n  wrenSetSlotString(vm, 2, \"London\");\n  wrenSetMapValue(vm, 0, 1, 2);\n\n  // Insert Double\n  wrenSetSlotDouble(vm, 1, 1.0);\n  wrenSetSlotDouble(vm, 2, 42.0);\n  wrenSetMapValue(vm, 0, 1, 2);\n\n  // Insert Boolean\n  wrenSetSlotBool(vm, 1, false);\n  wrenSetSlotBool(vm, 2, true);\n  wrenSetMapValue(vm, 0, 1, 2);\n\n  // Insert Null\n  wrenSetSlotNull(vm, 1);\n  wrenSetSlotNull(vm, 2);\n  wrenSetMapValue(vm, 0, 1, 2);\n\n  // Insert List\n  wrenSetSlotString(vm, 1, \"Empty\");\n  wrenSetSlotNewList(vm, 2);\n  wrenSetMapValue(vm, 0, 1, 2);\n}", "item_id": 1, "repo": "CohenArthur/wren", "file": "test/api/maps.c", "last_update_at": "2020-12-22T11:19:31+00:00", "question_id": "7f497e2a2ff47035706db774f54a963cff35afae_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void insert(WrenVM* vm)\n{\n  wrenSetSlotNewMap(vm, 0);\n  wrenEnsureSlots(vm, 3);\n  // Insert String\n  wrenSetSlotString(vm, 1, \"England\");\n  wrenSetSlotString(vm, 2, \"London\");\n  wrenSetMapValue(vm, 0, 1, 2);\n  // Insert Double\n  wrenSetSlotDouble(vm, 1, 1.0);\n  wrenSetSlotDouble(vm, 2, 42.0);\n  wrenSetMapValue(vm, 0, 1, 2);\n  // Insert Boolean\n  wrenSetSlotBool(vm, 1, false);\n  wrenSetSlotBool(vm, 2, true);\n  wrenSetMapValue(vm, 0, 1, 2);\n  // Insert Null\n  wrenSetSlotNull(vm, 1);\n  wrenSetSlotNull(vm, 2);\n  wrenSetMapValue(vm, 0, 1, 2);\n  // Insert List\n  wrenSetSlotString(vm, 1, \"Empty\");\n  wrenSetSlotNewList(vm, 2);\n  wrenSetMapValue(vm, 0, 1, 2);\n"]]}
{"hexsha": "c820162cac14ed07a0a0937dbf1f5dcdd7851559", "ext": "c", "lang": "C", "content": "static int sigar_swap_fs_get(sigar_t *sigar, sigar_swap_t *swap) /* <= 10.3 */\n{\n    DIR *dirp;\n    struct dirent *ent;\n    char swapfile[SSTRLEN(VM_DIR) + SSTRLEN(\"/\") + SSTRLEN(SWAPFILE) + 12];\n    struct stat swapstat;\n    struct statfs vmfs;\n    sigar_uint64_t val, bsize;\n\n    swap->used = swap->total = swap->free = 0;\n\n    if (!(dirp = opendir(VM_DIR))) {\n         return errno;\n     }\n \n    /* looking for \"swapfile0\", \"swapfile1\", etc. */\n    while ((ent = readdir(dirp))) {\n        char *ptr = swapfile;\n\n        if ((ent->d_namlen < SSTRLEN(SWAPFILE)+1) || /* n/a, see comment above */\n            (ent->d_namlen > SSTRLEN(SWAPFILE)+11)) /* ensure no overflow */\n        {\n            continue;\n        }\n\n        if (!strnEQ(ent->d_name, SWAPFILE, SSTRLEN(SWAPFILE))) {\n            continue;\n        }\n        \n        /* sprintf(swapfile, \"%s/%s\", VM_DIR, ent->d_name) */\n\n        memcpy(ptr, VM_DIR, SSTRLEN(VM_DIR));\n        ptr += SSTRLEN(VM_DIR);\n\n        *ptr++ = '/';\n\n        memcpy(ptr, ent->d_name, ent->d_namlen+1);\n\n        if (stat(swapfile, &swapstat) < 0) {\n            continue;\n        }\n\n        swap->used += swapstat.st_size;\n    }\n\n    closedir(dirp);\n\n    if (statfs(VM_DIR, &vmfs) < 0) {\n        return errno;\n    }\n\n    bsize = vmfs.f_bsize / 512;\n    val = vmfs.f_bfree;\n    swap->total = SIGAR_FS_BLOCKS_TO_BYTES(val, bsize) + swap->used;\n\n    swap->free = swap->total - swap->used;\n\n    return SIGAR_OK;\n}", "item_id": 9, "repo": "cloudkick/ck-agent", "file": "extern/sigar/src/os/darwin/darwin_sigar.c", "last_update_at": "2020-04-23T01:03:59+00:00", "question_id": "c820162cac14ed07a0a0937dbf1f5dcdd7851559_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int sigar_swap_fs_get(sigar_t *sigar, sigar_swap_t *swap) /* <= 10.3 */\n{\n    DIR *dirp;\n    struct dirent *ent;\n    char swapfile[SSTRLEN(VM_DIR) + SSTRLEN(\"/\") + SSTRLEN(SWAPFILE) + 12];\n    struct stat swapstat;\n    struct statfs vmfs;\n    sigar_uint64_t val, bsize;\n    swap->used = swap->total = swap->free = 0;\n    if (!(dirp = opendir(VM_DIR))) {\n         return errno;\n     }\n    /* looking for \"swapfile0\", \"swapfile1\", etc. */\n    while ((ent = readdir(dirp))) {\n        char *ptr = swapfile;\n        if ((ent->d_namlen < SSTRLEN(SWAPFILE)+1) || /* n/a, see comment above */\n            (ent->d_namlen > SSTRLEN(SWAPFILE)+11)) /* ensure no overflow */\n        {\n            continue;\n        }\n        if (!strnEQ(ent->d_name, SWAPFILE, SSTRLEN(SWAPFILE))) {\n            continue;\n        }\n        /* sprintf(swapfile, \"%s/%s\", VM_DIR, ent->d_name) */\n        memcpy(ptr, VM_DIR, SSTRLEN(VM_DIR));\n        ptr += SSTRLEN(VM_DIR);\n        *ptr++ = '/';\n        memcpy(ptr, ent->d_name, ent->d_namlen+1);\n        if (stat(swapfile, &swapstat) < 0) {\n            continue;\n        }\n        swap->used += swapstat.st_size;\n    }\n    closedir(dirp);\n    if (statfs(VM_DIR, &vmfs) < 0) {\n        return errno;\n    }\n    bsize = vmfs.f_bsize / 512;\n    val = vmfs.f_bfree;\n    swap->total = SIGAR_FS_BLOCKS_TO_BYTES(val, bsize) + swap->used;\n    swap->free = swap->total - swap->used;\n    return SIGAR_OK;\n"]]}
{"hexsha": "81247c269ad3acb4c4abce2f4b3f283c500b92a3", "ext": "c", "lang": "C", "content": "double\tleaf_conductance_APAR_curve(\tdouble\tAPAR,\n\t\t\t\t\t\t\t\t\tdouble\tAPAR_coef) \t\n{\n\t/*--------------------------------------------------------------*/\n\t/*\tLocal function declaration\t\t\t\t\t\t\t\t\t*/\n\t/*--------------------------------------------------------------*/\n\t/*--------------------------------------------------------------*/\n\t/*\tLocal variable definition.\t\t\t\t\t\t\t\t\t*/\n\t/*--------------------------------------------------------------*/\n\tdouble\tm_APAR;\n\t/*--------------------------------------------------------------*/\n\t/*\tEstimate multiplier on stomatal_conductance_max to get\t*/\n\t/*\tmean stratum conductance reduction \t\t\t*/\n\t/*\tAPAR was the only factor.\t\t\t\t*/\n\t/*--------------------------------------------------------------*/\n\tm_APAR = ( APAR * APAR_coef ) / ( 1.0 + APAR * APAR_coef );\n\treturn(m_APAR);\n}", "item_id": 0, "repo": "laurencelin/RHESSysEastCoast", "file": "cn/leaf_conductance_APAR_curve.c", "last_update_at": "2020-09-09T22:00:53+00:00", "question_id": "81247c269ad3acb4c4abce2f4b3f283c500b92a3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["double\tleaf_conductance_APAR_curve(\tdouble\tAPAR,\n\t\t\t\t\t\t\t\t\tdouble\tAPAR_coef) \t\n{\n\t/*--------------------------------------------------------------*/\n\t/*\tLocal function declaration\t\t\t\t\t\t\t\t\t*/\n\t/*--------------------------------------------------------------*/\n\t/*--------------------------------------------------------------*/\n\t/*\tLocal variable definition.\t\t\t\t\t\t\t\t\t*/\n\t/*--------------------------------------------------------------*/\n\tdouble\tm_APAR;\n\t/*--------------------------------------------------------------*/\n\t/*\tEstimate multiplier on stomatal_conductance_max to get\t*/\n\t/*\tmean stratum conductance reduction \t\t\t*/\n\t/*\tAPAR was the only factor.\t\t\t\t*/\n\t/*--------------------------------------------------------------*/\n\tm_APAR = ( APAR * APAR_coef ) / ( 1.0 + APAR * APAR_coef );\n\treturn(m_APAR);\n"]]}
{"hexsha": "d5f41eb3047e9cee55c2b94892456057ccb9f8ac", "ext": "c", "lang": "C", "content": "static sst26vf016b_error_t sst26vf016b_wakeup(void) {\n\tLOG_DBG(\"wakeup\");\n\tu8_t buffer_tx[] = {sst26vf016b_op_RDPD};\n\tu8_t buffer_rx[1];\n\tstruct spi_buf tx_buf [] = {\n\t\t{\n\t\t.buf = buffer_tx,\n\t\t.len = sizeof(buffer_tx)/sizeof(u8_t)\n\t\t}\n\t};\n\tconst struct spi_buf_set tx = {\n\t\t.buffers = tx_buf,\n\t\t.count = sizeof(tx_buf)/sizeof(struct spi_buf)\n\t};\n\tconst struct spi_buf rx_buf []= {\n\t\t{\n\t\t.buf = NULL,\n\t\t.len = 4,\n\t\t},\n\t\t{\n\t\t.buf = buffer_rx,\n\t\t.len = sizeof(buffer_rx),\n\t\t}\n\t};\n\tconst struct spi_buf_set rx = {\n\t\t.buffers = rx_buf,\n\t\t.count = sizeof(rx_buf)/sizeof(struct spi_buf)\n\t};\n\n\tif (spi_transceive(sst26vf016b.spiDev, &sst26vf016b.spi_conf, &tx, &rx)) {\n\t\treturn sst26vf016b_error_SPI;\n\t}\n\n\tif (SST26VF016B_JEDEC_DeviceID != buffer_rx[0]) {\n\t\tLOG_ERR(\"wrong device id! current DeviceID=0x%X vs DeviceID=0x%X\",\n\t\t\t\tbuffer_rx[0],\n\t\t\t\tSST26VF016B_JEDEC_DeviceID\n\t\t\t);\n\t\treturn sst26vf016b_error_wakeup_wrongid;\n\t}\n\tk_sleep(K_MSEC(10)); // 10 msec till the device has left deep sleep\n\treturn sst26vf016b_error_none;\n}", "item_id": 8, "repo": "StefJar/zephyr_SST26VF016B_SPI_driver", "file": "sst26vf016b.c", "last_update_at": "2020-06-17T07:51:13+00:00", "question_id": "d5f41eb3047e9cee55c2b94892456057ccb9f8ac_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static sst26vf016b_error_t sst26vf016b_wakeup(void) {\n\tLOG_DBG(\"wakeup\");\n\tu8_t buffer_tx[] = {sst26vf016b_op_RDPD};\n\tu8_t buffer_rx[1];\n\tstruct spi_buf tx_buf [] = {\n\t\t{\n\t\t.buf = buffer_tx,\n\t\t.len = sizeof(buffer_tx)/sizeof(u8_t)\n\t\t}\n\t};\n\tconst struct spi_buf_set tx = {\n\t\t.buffers = tx_buf,\n\t\t.count = sizeof(tx_buf)/sizeof(struct spi_buf)\n\t};\n\tconst struct spi_buf rx_buf []= {\n\t\t{\n\t\t.buf = NULL,\n\t\t.len = 4,\n\t\t},\n\t\t{\n\t\t.buf = buffer_rx,\n\t\t.len = sizeof(buffer_rx),\n\t\t}\n\t};\n\tconst struct spi_buf_set rx = {\n\t\t.buffers = rx_buf,\n\t\t.count = sizeof(rx_buf)/sizeof(struct spi_buf)\n\t};\n\tif (spi_transceive(sst26vf016b.spiDev, &sst26vf016b.spi_conf, &tx, &rx)) {\n\t\treturn sst26vf016b_error_SPI;\n\t}\n\tif (SST26VF016B_JEDEC_DeviceID != buffer_rx[0]) {\n\t\tLOG_ERR(\"wrong device id! current DeviceID=0x%X vs DeviceID=0x%X\",\n\t\t\t\tbuffer_rx[0],\n\t\t\t\tSST26VF016B_JEDEC_DeviceID\n\t\t\t);\n\t\treturn sst26vf016b_error_wakeup_wrongid;\n\t}\n\tk_sleep(K_MSEC(10)); // 10 msec till the device has left deep sleep\n\treturn sst26vf016b_error_none;\n"]]}
{"hexsha": "64d1fd4f5e87a11389b6af0ce3aa7f36cc0292d0", "ext": "c", "lang": "C", "content": "static IRAtom* scalarShift ( MCEnv*  mce,\n                             IRType  ty,\n                             IROp    original_op,\n                             IRAtom* qaa, IRAtom* qbb, \n                             IRAtom* aa,  IRAtom* bb )\n{\n   tl_assert(isShadowAtom(mce,qaa));\n   tl_assert(isShadowAtom(mce,qbb));\n   tl_assert(isOriginalAtom(mce,aa));\n   tl_assert(isOriginalAtom(mce,bb));\n   tl_assert(sameKindedAtoms(qaa,aa));\n   tl_assert(sameKindedAtoms(qbb,bb));\n   return \n      assignNew(\n         'V', mce, ty,\n         mkUifU( mce, ty,\n                 assignNew('V', mce, ty, binop(original_op, qaa, bb)),\n                 mkPCastTo(mce, ty, qbb)\n         )\n   );\n}", "item_id": 49, "repo": "wangcy6/weekly_read", "file": "code_reading/leixing518-valgrind-master/valgrind/memcheck/mc_translate.c", "last_update_at": "2020-10-18T12:59:31+00:00", "question_id": "64d1fd4f5e87a11389b6af0ce3aa7f36cc0292d0_49", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static IRAtom* scalarShift ( MCEnv*  mce,\n                             IRType  ty,\n                             IROp    original_op,\n                             IRAtom* qaa, IRAtom* qbb, \n                             IRAtom* aa,  IRAtom* bb )\n{\n   tl_assert(isShadowAtom(mce,qaa));\n   tl_assert(isShadowAtom(mce,qbb));\n   tl_assert(isOriginalAtom(mce,aa));\n   tl_assert(isOriginalAtom(mce,bb));\n   tl_assert(sameKindedAtoms(qaa,aa));\n   tl_assert(sameKindedAtoms(qbb,bb));\n   return \n      assignNew(\n         'V', mce, ty,\n         mkUifU( mce, ty,\n                 assignNew('V', mce, ty, binop(original_op, qaa, bb)),\n                 mkPCastTo(mce, ty, qbb)\n         )\n   );\n"]]}
{"hexsha": "ca0cb2647eab8d12c149994b57d68d323f7f92c6", "ext": "c", "lang": "C", "content": "int\n_ReadChunkArray(int st[],\n\t\tint endp[],\n\t\tint bsize,\n\t\tint fp,\n\t\tchar *destfp,\n\t\tArrayType *array,\n\t\tint isDestLO,\n\t\tbool *isNull)\n{\n    int i,j,jj;\n    int n, temp, words_read;\n    int chunk_span[MAXDIM], chunk_off[MAXDIM]; \n    int chunk_st[MAXDIM], chunk_end[MAXDIM];\n    int block_seek;\n    \n    int  bptr, *C, csize, *dim, *lb;\n    int range_st[MAXDIM], range_end[MAXDIM], \n    range[MAXDIM], array_span[MAXDIM];\n    int PA[MAXDIM], PCHUNK[MAXDIM], PC[MAXDIM];\n    int  to_read;\n    int cdist[MAXDIM], adist[MAXDIM]; \n    int dist[MAXDIM], temp_seek;\n    \n    int srcOff;        /* Needed since LO don't understand SEEK_CUR*/\n    char *baseDestFp = (char *)destfp;\n    \n    CHUNK_INFO *A = (CHUNK_INFO *) ARR_DATA_PTR(array);\n    n = ARR_NDIM(array); \n    dim = ARR_DIMS(array);\n    lb = ARR_LBOUND(array); \n    C = A->C;\n    \n    csize = C[n-1];\n    PC[n-1] = 1;\n    temp = dim[n - 1]/C[n-1];\n    for (i = n-2; i >= 0; i--){\n        PC[i] = PC[i+1] * temp;\n        temp = dim[i] / C[i];\n        csize *= C[i];\n    }\n    \n    for (i = 0; i < n; st[i] -= lb[i], endp[i] -= lb[i], i++)\n\t;\n    mda_get_prod(n, C, PCHUNK);\n    mda_get_range(n, array_span, st, endp);\n    mda_get_prod(n, array_span, PA);\n    \n    array2chunk_coord(n, C, st, chunk_st);\n    array2chunk_coord(n, C, endp, chunk_end);\n    mda_get_range(n, chunk_span, chunk_st, chunk_end);\n    mda_get_offset_values(n, dist, PC, chunk_span);\n    \n    for (i = 0; i < n; i++) {\n        range_st[i] = st[i];\n        range_end[i] = min(chunk_st[i]*C[i]+C[i]-1, endp[i]);\n    }\n    \n    for (i = j = 0; i < n; i++)\n        j+= chunk_st[i]*PC[i];\n    temp_seek = srcOff = j * csize * bsize;\n    if (lo_lseek(fp, srcOff, SEEK_SET) < 0) RETURN_NULL;\n    \n    jj = n-1;\n    for (i = 0; i < n; chunk_off[i++] = 0)\n\t;\n    words_read = 0; temp_seek = 0;\n    do {\n        /* Write chunk (chunk_st) to output buffer */\n        mda_get_range(n, array_span,  range_st, range_end);\n        mda_get_offset_values(n, adist, PA, array_span);\n        mda_get_offset_values(n, cdist, PCHUNK, array_span);\n        for (i=0; i < n; range[i] = range_st[i]-st[i], i++);\n        bptr = tuple2linear(n, range, PA);\n        for (i = 0; i < n; range[i++] = 0);\n        j = n-1; bptr *= bsize;\n        if (isDestLO) { \n            if (lo_lseek(destfp, bptr, SEEK_SET) < 0)\n\t\tRETURN_NULL;\n        }\n        else \n            destfp = baseDestFp + bptr; \n        for(i = 0, block_seek = 0; i < n; i++)\n            block_seek += (range_st[i]-(chunk_st[i] + chunk_off[i])\n\t\t\t   *C[i])*PCHUNK[i];\n        if (dist[jj] + block_seek + temp_seek) {\n            temp = (dist[jj]*csize+block_seek+temp_seek)*bsize;\n            srcOff += temp;\n            if (lo_lseek(fp, srcOff, SEEK_SET) < 0)\n\t\tRETURN_NULL;\n        }\n        for (i = n-1, to_read = bsize; i >= 0; \n\t     to_read *= min(C[i], array_span[i]), i--)\n            if (cdist[i] || adist[i])\n\t\tbreak;\n        do {\n            if (cdist[j]) {\n                srcOff += (cdist[j]*bsize);\n                if (lo_lseek(fp, srcOff, SEEK_SET) < 0)\n\t\t    RETURN_NULL;\n            }\n            block_seek += cdist[j];\n            bptr += adist[j]*bsize;\n            if (isDestLO) { \n                if (lo_lseek(destfp, bptr, SEEK_SET) < 0)\n\t\t    RETURN_NULL;\n            }\n            else \n                destfp = baseDestFp + bptr;\n            temp = _LOtransfer ((char**)&destfp, to_read, 1, (char**)&fp, 1, isDestLO);\n            if (temp < to_read)\n\t\tRETURN_NULL;\n            srcOff += to_read;\n            words_read+=to_read;\n            bptr += to_read;\n            block_seek += (to_read/bsize);\n            /* \n             * compute next tuple in range[]\n             */\n            {\n                int x;\n                if (!(i+1)) \n                    j = -1;\n                else {\n                    range[i] = (range[i]+1)%array_span[i];\n                    for (x = i; x*(!range[x]); x--) \n                        range[x-1] = (range[x-1]+1)%array_span[x-1];\n                    if (x) \n                        j = x; \n                    else { \n                        if (range[0]) \n                            j = 0; \n                        else \n                            j = -1;\n                    }\n                }\n            }\n\t    /* \n\t     * end of compute next tuple -- \n\t     * j is set to -1 if tuple generation is over\n\t     */\n        } while (j != -1);    \n\t\n\tblock_seek = csize - block_seek;    \n        temp_seek = block_seek;\n        jj = next_tuple(n, chunk_off, chunk_span);\n        if (jj == -1)\n\t    break;\n        range_st[jj] = (chunk_st[jj]+chunk_off[jj])*C[jj];\n        range_end[jj] = min(range_st[jj] + C[jj]-1, endp[jj]);\n        \n        for (i = jj+1; i < n; i++) {\n\t    range_st[i] = st[i];\n\t    range_end[i] = min((chunk_st[i]+chunk_off[i])*C[i]+C[i]-1, endp[i]);\n        }\n    } while (jj != -1);\n    return(words_read);\n}", "item_id": 8, "repo": "xuefengedu/database", "file": "postgresql/backend/utils/adt/chunk.c", "last_update_at": "2020-03-31T15:03:51+00:00", "question_id": "ca0cb2647eab8d12c149994b57d68d323f7f92c6_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\n_ReadChunkArray(int st[],\n\t\tint endp[],\n\t\tint bsize,\n\t\tint fp,\n\t\tchar *destfp,\n\t\tArrayType *array,\n\t\tint isDestLO,\n\t\tbool *isNull)\n{\n    int i,j,jj;\n    int n, temp, words_read;\n    int chunk_span[MAXDIM], chunk_off[MAXDIM]; \n    int chunk_st[MAXDIM], chunk_end[MAXDIM];\n    int block_seek;\n    int  bptr, *C, csize, *dim, *lb;\n    int range_st[MAXDIM], range_end[MAXDIM], \n    range[MAXDIM], array_span[MAXDIM];\n    int PA[MAXDIM], PCHUNK[MAXDIM], PC[MAXDIM];\n    int  to_read;\n    int cdist[MAXDIM], adist[MAXDIM]; \n    int dist[MAXDIM], temp_seek;\n    int srcOff;        /* Needed since LO don't understand SEEK_CUR*/\n    char *baseDestFp = (char *)destfp;\n    CHUNK_INFO *A = (CHUNK_INFO *) ARR_DATA_PTR(array);\n    n = ARR_NDIM(array); \n    dim = ARR_DIMS(array);\n    lb = ARR_LBOUND(array); \n    C = A->C;\n    csize = C[n-1];\n    PC[n-1] = 1;\n    temp = dim[n - 1]/C[n-1];\n    for (i = n-2; i >= 0; i--){\n        PC[i] = PC[i+1] * temp;\n        temp = dim[i] / C[i];\n        csize *= C[i];\n    }\n    for (i = 0; i < n; st[i] -= lb[i], endp[i] -= lb[i], i++)\n\t;\n    mda_get_prod(n, C, PCHUNK);\n    mda_get_range(n, array_span, st, endp);\n    mda_get_prod(n, array_span, PA);\n    array2chunk_coord(n, C, st, chunk_st);\n    array2chunk_coord(n, C, endp, chunk_end);\n    mda_get_range(n, chunk_span, chunk_st, chunk_end);\n    mda_get_offset_values(n, dist, PC, chunk_span);\n    for (i = 0; i < n; i++) {\n        range_st[i] = st[i];\n        range_end[i] = min(chunk_st[i]*C[i]+C[i]-1, endp[i]);\n    }\n    for (i = j = 0; i < n; i++)\n        j+= chunk_st[i]*PC[i];\n    temp_seek = srcOff = j * csize * bsize;\n    if (lo_lseek(fp, srcOff, SEEK_SET) < 0) RETURN_NULL;\n    jj = n-1;\n    for (i = 0; i < n; chunk_off[i++] = 0)\n\t;\n    words_read = 0; temp_seek = 0;\n    do {\n        /* Write chunk (chunk_st) to output buffer */\n        mda_get_range(n, array_span,  range_st, range_end);\n        mda_get_offset_values(n, adist, PA, array_span);\n        mda_get_offset_values(n, cdist, PCHUNK, array_span);\n        for (i=0; i < n; range[i] = range_st[i]-st[i], i++);\n        bptr = tuple2linear(n, range, PA);\n        for (i = 0; i < n; range[i++] = 0);\n        j = n-1; bptr *= bsize;\n        if (isDestLO) { \n            if (lo_lseek(destfp, bptr, SEEK_SET) < 0)\n\t\tRETURN_NULL;\n        }\n        else \n            destfp = baseDestFp + bptr; \n        for(i = 0, block_seek = 0; i < n; i++)\n            block_seek += (range_st[i]-(chunk_st[i] + chunk_off[i])\n\t\t\t   *C[i])*PCHUNK[i];\n        if (dist[jj] + block_seek + temp_seek) {\n            temp = (dist[jj]*csize+block_seek+temp_seek)*bsize;\n            srcOff += temp;\n            if (lo_lseek(fp, srcOff, SEEK_SET) < 0)\n\t\tRETURN_NULL;\n        }\n        for (i = n-1, to_read = bsize; i >= 0; \n\t     to_read *= min(C[i], array_span[i]), i--)\n            if (cdist[i] || adist[i])\n\t\tbreak;\n        do {\n            if (cdist[j]) {\n                srcOff += (cdist[j]*bsize);\n                if (lo_lseek(fp, srcOff, SEEK_SET) < 0)\n\t\t    RETURN_NULL;\n            }\n            block_seek += cdist[j];\n            bptr += adist[j]*bsize;\n            if (isDestLO) { \n                if (lo_lseek(destfp, bptr, SEEK_SET) < 0)\n\t\t    RETURN_NULL;\n            }\n            else \n                destfp = baseDestFp + bptr;\n            temp = _LOtransfer ((char**)&destfp, to_read, 1, (char**)&fp, 1, isDestLO);\n            if (temp < to_read)\n\t\tRETURN_NULL;\n            srcOff += to_read;\n            words_read+=to_read;\n            bptr += to_read;\n            block_seek += (to_read/bsize);\n            /* \n             * compute next tuple in range[]\n             */\n            {\n                int x;\n                if (!(i+1)) \n                    j = -1;\n                else {\n                    range[i] = (range[i]+1)%array_span[i];\n                    for (x = i; x*(!range[x]); x--) \n                        range[x-1] = (range[x-1]+1)%array_span[x-1];\n                    if (x) \n                        j = x; \n                    else { \n                        if (range[0]) \n                            j = 0; \n                        else \n                            j = -1;\n                    }\n                }\n            }\n\t    /* \n\t     * end of compute next tuple -- \n\t     * j is set to -1 if tuple generation is over\n\t     */\n        } while (j != -1);    \n\t\n\tblock_seek = csize - block_seek;    \n        temp_seek = block_seek;\n        jj = next_tuple(n, chunk_off, chunk_span);\n        if (jj == -1)\n\t    break;\n        range_st[jj] = (chunk_st[jj]+chunk_off[jj])*C[jj];\n        range_end[jj] = min(range_st[jj] + C[jj]-1, endp[jj]);\n        for (i = jj+1; i < n; i++) {\n\t    range_st[i] = st[i];\n\t    range_end[i] = min((chunk_st[i]+chunk_off[i])*C[i]+C[i]-1, endp[i]);\n        }\n    } while (jj != -1);\n    return(words_read);\n"]]}
{"hexsha": "c895079831f0f0f7db91d740d9f42fea0831f39a", "ext": "c", "lang": "C", "content": "static inline int vote(voters_t *const restrict voters)\n{\n  const int k = voters->k;\n  double *const restrict tally = voters->dists;\n  int *const restrict votes = voters->labels;\n  int group;\n  \n  memset(tally, 0, k*sizeof(*tally));\n  SAFE_FOR_SIMD\n  for (int i=0; i<k; i++)\n    tally[votes[i]-1] += 1.0;\n  \n  group = 0;\n  \n  for (int i=1; i<k; i++)\n  {\n    if (tally[i] > tally[group])\n      group = i;\n  }\n  \n  return group+1;\n}", "item_id": 2, "repo": "wrathematics/knn", "file": "src/knn.c", "last_update_at": "2020-01-29T11:59:03+00:00", "question_id": "c895079831f0f0f7db91d740d9f42fea0831f39a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline int vote(voters_t *const restrict voters)\n{\n  const int k = voters->k;\n  double *const restrict tally = voters->dists;\n  int *const restrict votes = voters->labels;\n  int group;\n  memset(tally, 0, k*sizeof(*tally));\n  SAFE_FOR_SIMD\n  for (int i=0; i<k; i++)\n    tally[votes[i]-1] += 1.0;\n  group = 0;\n  for (int i=1; i<k; i++)\n  {\n    if (tally[i] > tally[group])\n      group = i;\n  }\n  return group+1;\n"]]}
{"hexsha": "f5bc73ac391a05eb2f91b68d898b111d3a423233", "ext": "c", "lang": "C", "content": "int main(const int argc, const char* const argv[])\n{\n    if (argc != 3)\n    {\n        fprintf(stderr, \"Usage:   %s <iface-name> <node-id>\\n\", argv[0]);\n        fprintf(stderr, \"Example: %s vcan0 42\\n\", argv[0]);\n        return 1;\n    }\n\n    // Initialize the node with a static node-ID as specified in the command-line arguments.\n    CanardInstance canard = canardInit(&canardAllocate, &canardFree);\n    canard.mtu_bytes      = CANARD_MTU_CAN_CLASSIC;  // Do not use CAN FD to enhance compatibility.\n    canard.node_id        = (CanardNodeID) atoi(argv[2]);\n\n    // Initialize a SocketCAN socket. Do not use CAN FD to enhance compatibility.\n    const SocketCANFD sock = socketcanOpen(argv[1], false);\n    if (sock < 0)\n    {\n        fprintf(stderr, \"Could not initialize the SocketCAN interface: errno %d %s\\n\", -sock, strerror(-sock));\n        return 1;\n    }\n\n    CanardRxSubscription heartbeat_subscription;\n    (void) canardRxSubscribe(&canard,   // Subscribe to messages uavcan.node.Heartbeat.\n                         CanardTransferKindMessage,\n                         HeartbeatSubjectID,  // The fixed Subject-ID of the Heartbeat message type (see DSDL definition).\n                         7,      // The maximum payload size (max DSDL object size) from the DSDL definition.\n                         CANARD_DEFAULT_TRANSFER_ID_TIMEOUT_USEC,\n                         &heartbeat_subscription);\n\n    // // Configure the library to listen for register access service requests.\n    // CanardRxSubscription srv_register_access;\n    // (void) canardRxSubscribe(&canard,\n    //                          CanardTransferKindRequest,\n    //                          RegisterAccessServiceID,\n    //                          1024U,  // Larger buffers are OK.\n    //                          CANARD_DEFAULT_TRANSFER_ID_TIMEOUT_USEC,\n    //                          &srv_register_access);\n\n    // The main loop: publish messages and process service requests.\n    const time_t boot_ts     = time(NULL);\n    time_t       next_1hz_at = boot_ts;\n    while (true)\n    {\n        if (next_1hz_at < time(NULL))\n        {\n            next_1hz_at++;\n            //* publishMeasurement(&canard);\n            publishHeartbeat(&canard, time(NULL) - boot_ts);\n        }\n\n        // Transmit pending frames.\n        const CanardFrame* txf = canardTxPeek(&canard);\n        while (txf != NULL)\n        {\n            (void) socketcanPush(sock, txf, 0);  // Error handling not implemented\n            canardTxPop(&canard);\n            free((void*) txf);\n            txf = canardTxPeek(&canard);\n        }\n\n        // Process received frames, if any.\n        CanardFrame rxf;\n        uint8_t     buffer[64];\n        while (socketcanPop(sock, &rxf, sizeof(buffer), buffer, 1000) > 0)  // Error handling not implemented\n        {\n            CanardTransfer transfer;\n            if (canardRxAccept(&canard, &rxf, 0, &transfer))\n            {\n                if ((transfer.transfer_kind == CanardTransferKindMessage) &&\n                    (transfer.port_id == HeartbeatSubjectID))\n                {\n                    //handleRegisterAccess(&canard, &transfer);\n                    handleHeartbeat();\n                }\n                free((void*) transfer.payload);\n            }\n        }\n    }\n}", "item_id": 1, "repo": "hugo-a-garcia/uavcan-c-stethosscope", "file": "src/main.c", "last_update_at": "2020-09-04T18:53:12+00:00", "question_id": "f5bc73ac391a05eb2f91b68d898b111d3a423233_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(const int argc, const char* const argv[])\n{\n    if (argc != 3)\n    {\n        fprintf(stderr, \"Usage:   %s <iface-name> <node-id>\\n\", argv[0]);\n        fprintf(stderr, \"Example: %s vcan0 42\\n\", argv[0]);\n        return 1;\n    }\n    // Initialize the node with a static node-ID as specified in the command-line arguments.\n    CanardInstance canard = canardInit(&canardAllocate, &canardFree);\n    canard.mtu_bytes      = CANARD_MTU_CAN_CLASSIC;  // Do not use CAN FD to enhance compatibility.\n    canard.node_id        = (CanardNodeID) atoi(argv[2]);\n    // Initialize a SocketCAN socket. Do not use CAN FD to enhance compatibility.\n    const SocketCANFD sock = socketcanOpen(argv[1], false);\n    if (sock < 0)\n    {\n        fprintf(stderr, \"Could not initialize the SocketCAN interface: errno %d %s\\n\", -sock, strerror(-sock));\n        return 1;\n    }\n    CanardRxSubscription heartbeat_subscription;\n    (void) canardRxSubscribe(&canard,   // Subscribe to messages uavcan.node.Heartbeat.\n                         CanardTransferKindMessage,\n                         HeartbeatSubjectID,  // The fixed Subject-ID of the Heartbeat message type (see DSDL definition).\n                         7,      // The maximum payload size (max DSDL object size) from the DSDL definition.\n                         CANARD_DEFAULT_TRANSFER_ID_TIMEOUT_USEC,\n                         &heartbeat_subscription);\n    // // Configure the library to listen for register access service requests.\n    // CanardRxSubscription srv_register_access;\n    // (void) canardRxSubscribe(&canard,\n    //                          CanardTransferKindRequest,\n    //                          RegisterAccessServiceID,\n    //                          1024U,  // Larger buffers are OK.\n    //                          CANARD_DEFAULT_TRANSFER_ID_TIMEOUT_USEC,\n    //                          &srv_register_access);\n    // The main loop: publish messages and process service requests.\n    const time_t boot_ts     = time(NULL);\n    time_t       next_1hz_at = boot_ts;\n    while (true)\n    {\n        if (next_1hz_at < time(NULL))\n        {\n            next_1hz_at++;\n            //* publishMeasurement(&canard);\n            publishHeartbeat(&canard, time(NULL) - boot_ts);\n        }\n        // Transmit pending frames.\n        const CanardFrame* txf = canardTxPeek(&canard);\n        while (txf != NULL)\n        {\n            (void) socketcanPush(sock, txf, 0);  // Error handling not implemented\n            canardTxPop(&canard);\n            free((void*) txf);\n            txf = canardTxPeek(&canard);\n        }\n        // Process received frames, if any.\n        CanardFrame rxf;\n        uint8_t     buffer[64];\n        while (socketcanPop(sock, &rxf, sizeof(buffer), buffer, 1000) > 0)  // Error handling not implemented\n        {\n            CanardTransfer transfer;\n            if (canardRxAccept(&canard, &rxf, 0, &transfer))\n            {\n                if ((transfer.transfer_kind == CanardTransferKindMessage) &&\n                    (transfer.port_id == HeartbeatSubjectID))\n                {\n                    //handleRegisterAccess(&canard, &transfer);\n                    handleHeartbeat();\n                }\n                free((void*) transfer.payload);\n            }\n        }\n    }\n"]]}
{"hexsha": "e366ef108c520ac5cd17a7a661b5483b297c6b10", "ext": "c", "lang": "C", "content": "int pthread_get_nproc(int * number)\n{\n    if(number == NULL)\n    {\n        return EFAULT;\n    }\n\n    /* get number of processors online */\n    if(((*number) = (int)sysconf(_SC_NPROC_ONLN)) == -1)\n    {\n        return ENOTSUP;\n    }\n\n    return 0;\n}", "item_id": 10, "repo": "anvayg/duet", "file": "experiments/chdfg/qsort.comb.c", "last_update_at": "2020-08-15T15:26:25+00:00", "question_id": "e366ef108c520ac5cd17a7a661b5483b297c6b10_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int pthread_get_nproc(int * number)\n{\n    if(number == NULL)\n    {\n        return EFAULT;\n    }\n    /* get number of processors online */\n    if(((*number) = (int)sysconf(_SC_NPROC_ONLN)) == -1)\n    {\n        return ENOTSUP;\n    }\n    return 0;\n"]]}
{"hexsha": "b2f805c40ddbf09f4f7419f63459b02e2d4289c5", "ext": "c", "lang": "C", "content": "JNICALL Java_com_gams_api_gevm_TerminateClear(JNIEnv *env, jobject obj)\n{\n   jfieldID fid;\n   u64_t pgev;\n   jclass cls = (*env)->GetObjectClass(env, obj);\n   fid = (*env)->GetFieldID(env, cls, \"gevPtr\", \"J\");\n   if (fid == NULL) return ;\n   pgev.i = (*env)->GetLongField(env, obj, fid);\n   gevTerminateClear((gevHandle_t)pgev.p);\n}", "item_id": 78, "repo": "danxiaogui/gams-java", "file": "Resource/gevmjni.c", "last_update_at": "2020-02-23T07:34:10+00:00", "question_id": "b2f805c40ddbf09f4f7419f63459b02e2d4289c5_78", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["JNICALL Java_com_gams_api_gevm_TerminateClear(JNIEnv *env, jobject obj)\n{\n   jfieldID fid;\n   u64_t pgev;\n   jclass cls = (*env)->GetObjectClass(env, obj);\n   fid = (*env)->GetFieldID(env, cls, \"gevPtr\", \"J\");\n   if (fid == NULL) return ;\n   pgev.i = (*env)->GetLongField(env, obj, fid);\n   gevTerminateClear((gevHandle_t)pgev.p);\n"]]}
{"hexsha": "5ef2f4e9c9d2995460918eab82a4377154b7dac8", "ext": "c", "lang": "C", "content": "h2o_t h2o_new_px(double p, double x)\n{\n\th2o_t ret;\n\tenum h2o_region region = h2o_region_px(p, x);\n\n\tswitch (region)\n\t{\n\t\tcase H2O_REGION_OUT_OF_RANGE:\n\t\t\tbreak;\n\t\tcase H2O_REGION4:\n\t\t\tret._arg1 = h2o_region4_T_p(p);\n\t\t\tret._arg2 = x;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(not_reached);\n\t}\n\tret.region = region;\n\n\treturn ret;\n}", "item_id": 2, "repo": "mgorny/libh2o", "file": "src/h2o.c", "last_update_at": "2020-09-28T04:53:12+00:00", "question_id": "5ef2f4e9c9d2995460918eab82a4377154b7dac8_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["h2o_t h2o_new_px(double p, double x)\n{\n\th2o_t ret;\n\tenum h2o_region region = h2o_region_px(p, x);\n\tswitch (region)\n\t{\n\t\tcase H2O_REGION_OUT_OF_RANGE:\n\t\t\tbreak;\n\t\tcase H2O_REGION4:\n\t\t\tret._arg1 = h2o_region4_T_p(p);\n\t\t\tret._arg2 = x;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(not_reached);\n\t}\n\tret.region = region;\n\treturn ret;\n"]]}
{"hexsha": "2ccbee50cb69171062e84c9a1b36baf7e31be2f8", "ext": "c", "lang": "C", "content": "int userdiff_config(const char *k, const char *v)\n{\n\tstruct userdiff_driver *drv;\n\tconst char *name, *type;\n\tint namelen;\n\n\tif (parse_config_key(k, \"diff\", &name, &namelen, &type) || !name)\n\t\treturn 0;\n\n\tdrv = userdiff_find_by_namelen(name, namelen);\n\tif (!drv) {\n\t\tALLOC_GROW(drivers, ndrivers+1, drivers_alloc);\n\t\tdrv = &drivers[ndrivers++];\n\t\tmemset(drv, 0, sizeof(*drv));\n\t\tdrv->name = xmemdupz(name, namelen);\n\t\tdrv->binary = -1;\n\t}\n\n\tif (!strcmp(type, \"funcname\"))\n\t\treturn parse_funcname(&drv->funcname, k, v, 0);\n\tif (!strcmp(type, \"xfuncname\"))\n\t\treturn parse_funcname(&drv->funcname, k, v, REG_EXTENDED);\n\tif (!strcmp(type, \"binary\"))\n\t\treturn parse_tristate(&drv->binary, k, v);\n\tif (!strcmp(type, \"command\"))\n\t\treturn git_config_string(&drv->external, k, v);\n\tif (!strcmp(type, \"textconv\"))\n\t\treturn git_config_string(&drv->textconv, k, v);\n\tif (!strcmp(type, \"cachetextconv\"))\n\t\treturn parse_bool(&drv->textconv_want_cache, k, v);\n\tif (!strcmp(type, \"wordregex\"))\n\t\treturn git_config_string(&drv->word_regex, k, v);\n\n\treturn 0;\n}", "item_id": 2, "repo": "riritn1111/heroku_app", "file": "git-2.4.0/userdiff.c", "last_update_at": "2020-07-09T03:46:16+00:00", "question_id": "2ccbee50cb69171062e84c9a1b36baf7e31be2f8_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int userdiff_config(const char *k, const char *v)\n{\n\tstruct userdiff_driver *drv;\n\tconst char *name, *type;\n\tint namelen;\n\tif (parse_config_key(k, \"diff\", &name, &namelen, &type) || !name)\n\t\treturn 0;\n\tdrv = userdiff_find_by_namelen(name, namelen);\n\tif (!drv) {\n\t\tALLOC_GROW(drivers, ndrivers+1, drivers_alloc);\n\t\tdrv = &drivers[ndrivers++];\n\t\tmemset(drv, 0, sizeof(*drv));\n\t\tdrv->name = xmemdupz(name, namelen);\n\t\tdrv->binary = -1;\n\t}\n\tif (!strcmp(type, \"funcname\"))\n\t\treturn parse_funcname(&drv->funcname, k, v, 0);\n\tif (!strcmp(type, \"xfuncname\"))\n\t\treturn parse_funcname(&drv->funcname, k, v, REG_EXTENDED);\n\tif (!strcmp(type, \"binary\"))\n\t\treturn parse_tristate(&drv->binary, k, v);\n\tif (!strcmp(type, \"command\"))\n\t\treturn git_config_string(&drv->external, k, v);\n\tif (!strcmp(type, \"textconv\"))\n\t\treturn git_config_string(&drv->textconv, k, v);\n\tif (!strcmp(type, \"cachetextconv\"))\n\t\treturn parse_bool(&drv->textconv_want_cache, k, v);\n\tif (!strcmp(type, \"wordregex\"))\n\t\treturn git_config_string(&drv->word_regex, k, v);\n\treturn 0;\n"]]}
{"hexsha": "d096a5a633bf3ef308e895ca5b269fb1fa97e6c5", "ext": "c", "lang": "C", "content": "static void\nreply_cb (GDBusConnection *connection,\n          GAsyncResult    *res,\n          gpointer         user_data)\n{\n  GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (user_data);\n  GVariant *value;\n  GError *error;\n\n  error = NULL;\n  value = g_dbus_connection_call_finish (connection,\n                                         res,\n                                         &error);\n  if (error != NULL)\n    {\n      g_simple_async_result_set_from_error (simple,\n                                            error);\n      g_error_free (error);\n    }\n  else\n    {\n      g_simple_async_result_set_op_res_gpointer (simple,\n                                                 value,\n                                                 (GDestroyNotify) g_variant_unref);\n    }\n\n  /* no need to complete in idle since the method GDBusConnection already does */\n  g_simple_async_result_complete (simple);\n  g_object_unref (simple);\n}", "item_id": 29, "repo": "cesarmo759/android_kernel_samsung_msm8916", "file": "vendor/samsung/external/glib-2.0/gio/gdbusproxy.c", "last_update_at": "2020-06-28T00:49:21+00:00", "question_id": "d096a5a633bf3ef308e895ca5b269fb1fa97e6c5_29", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nreply_cb (GDBusConnection *connection,\n          GAsyncResult    *res,\n          gpointer         user_data)\n{\n  GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (user_data);\n  GVariant *value;\n  GError *error;\n  error = NULL;\n  value = g_dbus_connection_call_finish (connection,\n                                         res,\n                                         &error);\n  if (error != NULL)\n    {\n      g_simple_async_result_set_from_error (simple,\n                                            error);\n      g_error_free (error);\n    }\n  else\n    {\n      g_simple_async_result_set_op_res_gpointer (simple,\n                                                 value,\n                                                 (GDestroyNotify) g_variant_unref);\n    }\n  /* no need to complete in idle since the method GDBusConnection already does */\n  g_simple_async_result_complete (simple);\n  g_object_unref (simple);\n"]]}
{"hexsha": "36f22233b58c1753a4c8371c2c97487cfa25ee99", "ext": "c", "lang": "C", "content": "void func_170()\n{\n\tint iVar0;\n\tvar uVar1;\n\tvar uVar2;\n\t\n\tif (unk_0xCE990E643CD9D0E5(iLocal_122, 9))\n\t{\n\t\tif (unk_0xCE990E643CD9D0E5(iLocal_122, 8))\n\t\t{\n\t\t\tif (func_68(unk_0x460153A63B9477BC(), 1) || func_70() >= func_69())\n\t\t\t{\n\t\t\t\tfunc_90();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfunc_151(2, 224, 1);\n\t\t\tif (unk_0x1BD7199394D7F19A(2, 224))\n\t\t\t{\n\t\t\t\tiVar0 = iLocal_128;\n\t\t\t\tfunc_90();\n\t\t\t\tif (iVar0 == 0 && !func_64(unk_0x460153A63B9477BC()))\n\t\t\t\t{\n\t\t\t\t\tfunc_326();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfunc_324();\n\t\t\t\t}\n\t\t\t\tif (!func_62(unk_0x460153A63B9477BC()))\n\t\t\t\t{\n\t\t\t\t\tfunc_216(0, iVar0);\n\t\t\t\t}\n\t\t\t\tif (func_62(unk_0x460153A63B9477BC()))\n\t\t\t\t{\n\t\t\t\t\tunk_0xBE20AB8238688965(&iLocal_122, 10);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (unk_0xCE990E643CD9D0E5(iLocal_122, 10))\n\t{\n\t\tif (func_182(unk_0x460153A63B9477BC(), -2, 0, 0, 0) != 1)\n\t\t{\n\t\t\tif (func_74(unk_0x460153A63B9477BC()))\n\t\t\t{\n\t\t\t\tuVar1 = func_172();\n\t\t\t\tfunc_171(\"GB_BECOMEB\", uVar1, func_182(unk_0x460153A63B9477BC(), -2, 0, 0, 0), -1, 1);\n\t\t\t}\n\t\t\telse if (func_62(unk_0x460153A63B9477BC()))\n\t\t\t{\n\t\t\t\tuVar2 = func_172();\n\t\t\t\tif (func_64(unk_0x460153A63B9477BC()))\n\t\t\t\t{\n\t\t\t\t\tfunc_171(\"GB_BECOMEC\", uVar2, func_182(unk_0x460153A63B9477BC(), -2, 0, 0, 0), -1, 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfunc_171(\"GB_BECOME\", uVar2, func_182(unk_0x460153A63B9477BC(), -2, 0, 0, 0), -1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tunk_0xD2459066EA58CE43(&iLocal_122, 10);\n\t\t}\n\t}\n}", "item_id": 65, "repo": "Seanghost117/GTA-V-Decompiled-Scripts", "file": "decompiled_scripts/apparcadebusinesshub.c", "last_update_at": "2020-12-16T17:13:14+00:00", "question_id": "36f22233b58c1753a4c8371c2c97487cfa25ee99_65", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void func_170()\n{\n\tint iVar0;\n\tvar uVar1;\n\tvar uVar2;\n\t\n\tif (unk_0xCE990E643CD9D0E5(iLocal_122, 9))\n\t{\n\t\tif (unk_0xCE990E643CD9D0E5(iLocal_122, 8))\n\t\t{\n\t\t\tif (func_68(unk_0x460153A63B9477BC(), 1) || func_70() >= func_69())\n\t\t\t{\n\t\t\t\tfunc_90();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfunc_151(2, 224, 1);\n\t\t\tif (unk_0x1BD7199394D7F19A(2, 224))\n\t\t\t{\n\t\t\t\tiVar0 = iLocal_128;\n\t\t\t\tfunc_90();\n\t\t\t\tif (iVar0 == 0 && !func_64(unk_0x460153A63B9477BC()))\n\t\t\t\t{\n\t\t\t\t\tfunc_326();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfunc_324();\n\t\t\t\t}\n\t\t\t\tif (!func_62(unk_0x460153A63B9477BC()))\n\t\t\t\t{\n\t\t\t\t\tfunc_216(0, iVar0);\n\t\t\t\t}\n\t\t\t\tif (func_62(unk_0x460153A63B9477BC()))\n\t\t\t\t{\n\t\t\t\t\tunk_0xBE20AB8238688965(&iLocal_122, 10);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (unk_0xCE990E643CD9D0E5(iLocal_122, 10))\n\t{\n\t\tif (func_182(unk_0x460153A63B9477BC(), -2, 0, 0, 0) != 1)\n\t\t{\n\t\t\tif (func_74(unk_0x460153A63B9477BC()))\n\t\t\t{\n\t\t\t\tuVar1 = func_172();\n\t\t\t\tfunc_171(\"GB_BECOMEB\", uVar1, func_182(unk_0x460153A63B9477BC(), -2, 0, 0, 0), -1, 1);\n\t\t\t}\n\t\t\telse if (func_62(unk_0x460153A63B9477BC()))\n\t\t\t{\n\t\t\t\tuVar2 = func_172();\n\t\t\t\tif (func_64(unk_0x460153A63B9477BC()))\n\t\t\t\t{\n\t\t\t\t\tfunc_171(\"GB_BECOMEC\", uVar2, func_182(unk_0x460153A63B9477BC(), -2, 0, 0, 0), -1, 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfunc_171(\"GB_BECOME\", uVar2, func_182(unk_0x460153A63B9477BC(), -2, 0, 0, 0), -1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tunk_0xD2459066EA58CE43(&iLocal_122, 10);\n\t\t}\n\t}\n"]]}
{"hexsha": "c8c1b2f368b137f3d044336d70d94f2b892a21a6", "ext": "c", "lang": "C", "content": "TEST_FUNCTION(srw_lock_create_succeeds)\r\n{\r\n    ///arrange\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(timer_create_new())\r\n        .SetReturn((TIMER_HANDLE)my_malloc(2));\r\n    STRICT_EXPECTED_CALL(mocked_InitializeSRWLock(IGNORED_ARG));\r\n\r\n    ///act\r\n    SRW_LOCK_HANDLE bsdlLock = srw_lock_create(true, \"test_lock\");\r\n\r\n    ///assert\r\n    ASSERT_IS_NOT_NULL(bsdlLock);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    ///clean\r\n    srw_lock_destroy(bsdlLock);\r\n}", "item_id": 5, "repo": "Azure/azure-c-pal", "file": "win32/tests/srw_lock_win32_ut/srw_lock_win32_ut.c", "last_update_at": "2020-05-20T13:39:31+00:00", "question_id": "c8c1b2f368b137f3d044336d70d94f2b892a21a6_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TEST_FUNCTION(srw_lock_create_succeeds)\r\n{\r\n    ///arrange\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(timer_create_new())\r\n        .SetReturn((TIMER_HANDLE)my_malloc(2));\r\n    STRICT_EXPECTED_CALL(mocked_InitializeSRWLock(IGNORED_ARG));\r\n\r\n    ///act\r\n    SRW_LOCK_HANDLE bsdlLock = srw_lock_create(true, \"test_lock\");\r\n\r\n    ///assert\r\n    ASSERT_IS_NOT_NULL(bsdlLock);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    ///clean\r\n    srw_lock_destroy(bsdlLock);\r\n"]]}
{"hexsha": "6fbff8c222b82d22c7ddfa7e8f992f33f8eb208f", "ext": "c", "lang": "C", "content": "static ngx_int_t\nngx_http_doorman_orig_uri_variable(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data)\n{\n    ngx_http_doorman_ctx_t  *ctx;\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_doorman_module);\n\n    if (ctx) {\n        v->len = ctx->orig_uri.len;\n        v->valid = 1;\n        v->no_cacheable = 0;\n        v->not_found = 0;\n        v->data = ctx->orig_uri.data;\n\n    } else {\n        v->not_found = 1;\n    }\n\n    return NGX_OK;\n}", "item_id": 19, "repo": "mikegagnon/nginx-overload-handler", "file": "nginx_doorman/ngx_http_doorman_module.c", "last_update_at": "2020-11-26T12:19:25+00:00", "question_id": "6fbff8c222b82d22c7ddfa7e8f992f33f8eb208f_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static ngx_int_t\nngx_http_doorman_orig_uri_variable(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data)\n{\n    ngx_http_doorman_ctx_t  *ctx;\n    ctx = ngx_http_get_module_ctx(r, ngx_http_doorman_module);\n    if (ctx) {\n        v->len = ctx->orig_uri.len;\n        v->valid = 1;\n        v->no_cacheable = 0;\n        v->not_found = 0;\n        v->data = ctx->orig_uri.data;\n    } else {\n        v->not_found = 1;\n    }\n    return NGX_OK;\n"]]}
{"hexsha": "d52a78d640c255f15294af993f8d568d2b840211", "ext": "c", "lang": "C", "content": "int oggflac_id(unsigned char *buf,int len)\n{\n  (void)buf;\n  (void)len;\n  return 0;\n}", "item_id": 11, "repo": "qingkouwei/mediaones", "file": "3rdparty/opus-tools-0.2/src/flac.c", "last_update_at": "2020-08-09T13:37:39+00:00", "question_id": "d52a78d640c255f15294af993f8d568d2b840211_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int oggflac_id(unsigned char *buf,int len)\n{\n  (void)buf;\n  (void)len;\n  return 0;\n"]]}
